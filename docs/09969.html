<html>
<head>
<title>Exploring Flutter’s Scrollable.ensureVisible</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Flutter的Scrollable.ensureVisible</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/exploring-flutters-scrollable-ensurevisible-f4d1ef8c51d3?source=collection_archive---------3-----------------------#2021-10-10">https://levelup.gitconnected.com/exploring-flutters-scrollable-ensurevisible-f4d1ef8c51d3?source=collection_archive---------3-----------------------#2021-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a0229ec4a1f29f32de627f5088114c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WbyCBAOR8XJJ4GyI"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4234" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您是否曾经不得不构建一个具有多个不同高度的小部件的滚动视图的应用程序，并且您想要添加一个链接，以便用户可以自动从一个小部件滚动到另一个小部件？一个这样的例子可以是文章或菜单的目录。</p><p id="3f4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将展示我们如何实现这一点，为了做到这一点，我将使用一个包含几个部分的屏幕，并在屏幕顶部显示一个目录，其中包含指向相应部分的链接。</p><p id="9dbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看如何！</p><blockquote class="le lf lg"><p id="9cd2" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><em class="it">本帖基于</em> <code class="fe ll lm ln lo b"><em class="it">Flutter 2.5.2</em></code> <em class="it">和</em> <code class="fe ll lm ln lo b"><em class="it">Dart SDK 2.14.3</em></code></p></blockquote><h1 id="360e" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">解决办法</h1><p id="7492" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">为此，我们将在带有<code class="fe ll lm ln lo b">Column</code>子部件的<code class="fe ll lm ln lo b">SingleChildScrollView</code>小部件中使用<code class="fe ll lm ln lo b"><a class="ae kf" href="https://api.flutter.dev/flutter/widgets/Scrollable/ensureVisible.html" rel="noopener ugc nofollow" target="_blank">Scrollable.ensureVisible</a></code>。</p><p id="6ad3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，我们将为每个部分创建一个<code class="fe ll lm ln lo b">GlobalKey()</code>。然后我们将使用这个键作为链接指向的小部件的键。最后，当我们点击目录中的链接时，我们将使用这个键，如下面的代码片段所示:</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="031f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，目标小部件将在400毫秒后可见。</p><p id="c31e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一节中，我将尝试给出一个更详细的实现演示！</p><h1 id="65aa" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">履行</h1><h2 id="b369" class="my lq it bd lr mz na dn lv nb nc dp lz kr nd ne md kv nf ng mh kz nh ni ml nj bi translated">准备工作</h2><p id="e9e3" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">首先，让我们创建一个表示该部分的数据结构。它将有一个键、一个标题和一个主体。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3211" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">标题将用于目录中，而键将用于滚动到目标部分。</p><p id="4ba9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们将使用这个类为我们的示例生成一些虚拟数据。我们可以使用一些lorem ipsum来表示一些长文本。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="1263" class="my lq it bd lr mz na dn lv nb nc dp lz kr nd ne md kv nf ng mh kz nh ni ml nj bi translated">小工具</h2><p id="1279" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">接下来，让我们为<code class="fe ll lm ln lo b">Section</code>创建一个小部件，在这里我们将显示每个部分的标题和主体。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="84bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，让我们为一个部分的链接创建一个小部件。我们将它命名为<code class="fe ll lm ln lo b">SectionLink</code>，我们将传递一个section和对<code class="fe ll lm ln lo b">InkWell</code>的<code class="fe ll lm ln lo b">onTap</code>事件的回调。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ed16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将添加一个<code class="fe ll lm ln lo b">TableOfContents</code>小部件，在这里我们基本上迭代各个部分，并且为每个部分创建一个<code class="fe ll lm ln lo b">SectionLink</code>。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="477f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，让我们创建<code class="fe ll lm ln lo b">ArticlePage</code>,在这里我们将把所有东西联系在一起。在这个小部件中，我们将创建一个包含<code class="fe ll lm ln lo b">TableOfContents</code>的<code class="fe ll lm ln lo b">SingleChildScrollView</code>和一个包含部分的<code class="fe ll lm ln lo b">Column</code>小部件。</p><p id="d136" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于<code class="fe ll lm ln lo b">TableOfContents</code>，我们将把部分和点击部分时的回调作为参数传递。这个回调包含滚动到目标小部件的逻辑。首先，我们通过确保<code class="fe ll lm ln lo b">currentContext</code>的值不为空来验证树中是否存在带有这个键的小部件。然后，我们将把这个上下文传递给<code class="fe ll lm ln lo b">Scrollable.ensureVisible</code>以滚动到目标小部件。</p><p id="7d66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于<code class="fe ll lm ln lo b">ListView</code>，我们迭代各个部分，对于每个部分，我们使用部分中的键作为小部件的键来创建一个新的<code class="fe ll lm ln lo b">SectionWidget</code>。</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e63f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您现在构建并运行该应用程序，当您点击内容列表中的链接时，您将看到以下视频行为。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/08b226c1061d8f2fcce1d23d4505abf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*TTSwt9JxOcg8rYsK.gif"/></div></figure><blockquote class="le lf lg"><p id="2dda" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><em class="it">你也可以使用</em><a class="ae kf" href="https://dartpad.dev/?id=33c44d2f905cf23d4e0f825b45d79d91&amp;null_safety=true" rel="noopener ugc nofollow" target="_blank"><em class="it">dartpad . dev</em></a><em class="it">来查找并运行本帖的代码。</em></p></blockquote><h1 id="952a" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">更多选项</h1><p id="8a86" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">现在我们已经看到了如何使用<code class="fe ll lm ln lo b">Scrollable.ensureVisible</code>，让我们探索更多的选项，我们可以使用这些选项来定制到目标小部件的过渡。</p><p id="364e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中两个是<code class="fe ll lm ln lo b">duration</code>和<code class="fe ll lm ln lo b">curve</code>，我们在前面的例子中已经见过。<code class="fe ll lm ln lo b">duration</code>可用于设置从链接到目标部件的动画所需的持续时间。</p><p id="3187" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe ll lm ln lo b">curve</code>参数，我们可以定义过渡将遵循的动画曲线。基本上，我们可以为<code class="fe ll lm ln lo b">curve</code>参数设置一个值，通过在特定的时间帧加速或减速来改变动画，而不是以恒定的速率进行过渡。可以取<code class="fe ll lm ln lo b">Curves.bounceInOut</code>、<code class="fe ll lm ln lo b">Curves.easeInOut</code>等值。例如，使用<code class="fe ll lm ln lo b">Curves.easeInOut</code>，动画将缓慢开始，然后加速，然后缓慢结束。</p><blockquote class="le lf lg"><p id="c7d9" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><em class="it">注意:不同选项的可视化可以在</em><a class="ae kf" href="https://api.flutter.dev/flutter/animation/Curves-class.html" rel="noopener ugc nofollow" target="_blank"><em class="it">API . flutter . dev</em></a><em class="it">中找到。</em></p></blockquote><p id="0d9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ll lm ln lo b">Scrollable.ensureVisible</code>的另一个参数是<code class="fe ll lm ln lo b">alignment</code>，可以用来设置目标widget的位置。如果该值为0.0，子对象将靠近视口的前沿，0.5靠近中心，1.0靠近后沿。</p><p id="2b91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，最后一个参数是<code class="fe ll lm ln lo b">alignmentPolicy</code>，可以在应用<code class="fe ll lm ln lo b">alignment</code>参数时用来决定策略。该参数属于<code class="fe ll lm ln lo b">ScrollPositionAlignmentPolicy</code>类型，是一个带有以下选项的枚举:<code class="fe ll lm ln lo b">explicit</code>、<code class="fe ll lm ln lo b">keepVisibleAtEnd</code>或<code class="fe ll lm ln lo b">keepVisibleAtStart</code>。</p><p id="bfc4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当它被设置为<code class="fe ll lm ln lo b">explicit</code>时，它将使用<code class="fe ll lm ln lo b">alignment</code>属性来决定目标对象的对齐位置。如果它被设置为<code class="fe ll lm ln lo b">keepVisibleAtEnd</code>，它将确保如果目标项目的下边缘低于滚动容器的下边缘，则目标项目的底部刚好可见。相反，<code class="fe ll lm ln lo b">keepVisibleAtStart</code>将确保如果目标对象的上边缘高于滚动容器的上边缘，则目标对象的顶部刚好可见。</p><h1 id="6688" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="e107" class="pw-post-body-paragraph kg kh it ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">这就是了！我希望这篇文章对你有用，它让你对如何使用<code class="fe ll lm ln lo b">Scrollable.ensureVisible</code>和它的所有选项在滚动视图上滚动到特定的小部件有了一些了解。</p><p id="2745" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你对这篇文章有任何问题或评论，请随时在<a class="ae kf" href="https://twitter.com/diamantidis_io" rel="noopener ugc nofollow" target="_blank">推特</a>上联系我！</p><p id="715a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下次见！</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="0190" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lh">原载于2021年10月10日</em><a class="ae kf" href="https://diamantidis.github.io/2021/10/10/exploring-flutter-scrollable-ensurevisible" rel="noopener ugc nofollow" target="_blank"><em class="lh">https://diamantidis . github . io</em></a><em class="lh">。</em></p></div></div>    
</body>
</html>