<html>
<head>
<title>How to Thread in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中线程化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-thread-in-python-9adf899d52ce?source=collection_archive---------9-----------------------#2020-06-09">https://levelup.gitconnected.com/how-to-thread-in-python-9adf899d52ce?source=collection_archive---------9-----------------------#2020-06-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/b6d24b424f22b40fe2fad6ce6693a2c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nyHEu13MoeyNwQK3Pc-9_g.jpeg"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">在<a class="ae jh" href="https://unsplash.com/s/photos/thread?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jh" href="https://unsplash.com/@amir_v_ali?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> amirali mirhashemian </a>拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="4d68" class="pw-subtitle-paragraph kh jj jk bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">不仅仅是如何线程化，还有一些关于线程化本身的核心概念</h2></div><p id="4745" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我希望这篇博文能让你好起来。这篇文章将让你快速了解Python，如何开始编写多线程应用程序，以及一些关于线程本身的核心概念。首先，我将梳理一下Python版本(2.7到3.x)之间的一些差异，然后是一些核心线程概念，最后是一些如何在Python中开始线程化的例子。</p><h1 id="ca7c" class="lv lw jk bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">Python和用例</h1><p id="ccbc" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">Python是一种奇妙的语言。它的用例范围从人工智能编程、数据分析、网站开发、网页抓取、数据操作，一直到简单的斐波那契脚本。用途真的是无止境的，我对Python了解得越多，就能找到越多的用例。</p><p id="e14b" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Python 2.7是finito。嗯，它仍然广泛用于社区和企业，但对2.7的支持于2020年1月1日结束，2020年4月20日发布最终关键版本2.7.18。今年是2.7的寿终正寝(EOL)年，所以向前看，所有开发人员都应该练习使用3.x版本。</p><p id="b98e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Python 3在其前身的基础上增加了一套令人兴奋的新特性。该清单包括:</p><ul class=""><li id="0f09" class="ms mt jk lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">Print语句与print()函数</li><li id="0751" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">整数除法</li><li id="6aee" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">Unicode支持</li><li id="add1" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">xrange()已更改为范围()</li><li id="b6ce" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">引发异常和异常处理</li><li id="29da" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">对于循环变量和全局变量泄漏</li><li id="c00e" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">raw_input()到input()</li><li id="2580" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">银行家四舍五入</li><li id="b448" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">更多！</li></ul><p id="c93f" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我见过的概述版本之间关键差异的最好的帖子是2014年写的一篇帖子。要了解更多信息，我会<a class="ae jh" href="https://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html" rel="noopener ugc nofollow" target="_blank">查看</a>，因为我不会在这篇文章中详细介绍所有内容。当然，还有官方文档(<a class="ae jh" href="https://docs.python.org/2.7/" rel="noopener ugc nofollow" target="_blank"> Python2.7 </a>，<a class="ae jh" href="https://docs.python.org/3.8/" rel="noopener ugc nofollow" target="_blank"> Python3.8 </a>)这是关于Python的信息宝库。我认为在进入StackOverflow之前，一定要检查API的正确用法。</p><h1 id="ef40" class="lv lw jk bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">概念</h1><p id="6c54" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">再一次，在我们深入例子之前，有一些关于线程的关键概念需要回顾。这些笔记是我自己读完杰森·格雷戈里的<a class="ae jh" href="https://www.gameenginebook.com/" rel="noopener ugc nofollow" target="_blank">游戏引擎架构</a>(第四版)第四章后的感想。这本书是一个很棒的资源，不仅涵盖了游戏概念，还把你从计算机的CPU带到了高级编程概念。</p><p id="329a" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl">内核</strong></p><p id="3209" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">内核处理系统中各种各样的任务。它是设备硬件和软件之间的沟通者。它还负责调度在哪个周期哪个内核上运行哪个进程。内核允许开发者创建一个线程，并访问机器上的内存。编程语言封装了内核调用，因此不会发生危险的事情(比如写入错误的内存空间)。编程语言越高，用于连接高级语言和低级调用的API就越多。</p><p id="c39f" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl">流程</strong></p><p id="65a0" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">进程是操作系统(OSs)管理包含在可执行文件中的程序的运行实例的方式。创建的每个进程还会创建一个主线程来启动。一个进程容纳了该进程中所有线程的共享存储，因此可以将该进程视为线程处理其数据的“环境”。</p><p id="4610" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl">抢占式多任务处理</strong></p><p id="aed5" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在早期的计算机时代，CPU只有一个内核，只有一个输入流。这允许一次运行一个进程。随着计算机的发展——更多的内核、超线程——它允许有多个指令流的能力，因此允许多个进程运行。抢占式多任务处理是操作系统在处理器上调度任务的方式。抢占式多任务处理允许调度程序查看进程列表，检查哪个进程处于可以运行的状态(或开始检查其指令列表)，并在下一个内核周期将该进程调度到一个内核上，而不是等待单个任务完成后再进入下一个任务。</p><p id="9801" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl">螺纹</strong></p><p id="39c2" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">线程封装了单个机器语言指令流的运行实例。一个进程中可以存在多个线程。如果你曾经在点击“计算/渲染”后程序冻结，可能是所有的处理都在同一个线程上进行，因此锁定了用户界面。<br/> <em class="ng">“不要做UI线程上的工作。”</em></p><p id="3054" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">一个线程具有:</p><ul class=""><li id="c902" class="ms mt jk lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">一个<em class="ng">线程ID </em> (TID)对于进程中的每个线程是唯一的，而对于系统中的每个线程不是唯一的</li><li id="708d" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><em class="ng">调用堆栈</em>作为线程将在内核上执行的指令</li><li id="1e5b" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">所有专用和通用<em class="ng">寄存器</em>的值(通常只有用户模式寄存器，除非程序升级运行)</li><li id="9d03" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">一块被称为<em class="ng">线程本地存储</em> (TSL)的通用内存</li><li id="4b49" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">对进程内所有线程可用的进程内存的访问</li></ul><p id="f36e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl">线程库</strong></p><p id="03f7" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">大多数线程库都有相同的基本线程函数:</p><ul class=""><li id="f84c" class="ms mt jk lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><em class="ng">创建</em>一个线程</li><li id="49cd" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><em class="ng">终止</em>一个线程</li><li id="3171" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><em class="ng">请求</em>一个线程<em class="ng">退出</em></li><li id="e0e1" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><em class="ng">睡眠</em>超时</li><li id="459a" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><em class="ng">把剩余的时间让给另一个线程</em></li><li id="9a38" class="ms mt jk lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">等待螺纹完成，然后<em class="ng">将</em>与主螺纹连接</li></ul><p id="5cc6" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">通常一个线程会一直运行到它终止，但是有时候一个线程会在继续之前等待一个事件的发生，并且占用CPU直到它结束。为了防止一个线程占用内核太长时间，并且不允许其他线程继续，开发人员的工具箱中有三种方法:轮询、阻塞和让步。</p><p id="6b18" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl">线程轮询</strong></p><p id="7900" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">将线程置于一个仅在条件返回true时退出的紧密循环中，因此不会继续指令流(或运行check_condition()的相同指令)。</p><p id="9c3d" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl">螺纹堵塞</strong></p><p id="de5c" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">阻塞使线程休眠，直到满足条件。这种方法将所有进程和线程的本地CPU内存(缓存)保存到存储器(RAM或HDD/SDD ),内核记住线程的ID和状态。当条件最终满足时，它将从内存中回调信息，并在内核调度它时开始处理。</p><p id="09b2" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb jl">螺纹屈服</strong></p><p id="c9aa" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让步是轮询和阻塞的混合。当线程的条件不满足时，线程将把它在CPU上的剩余时间让给(传递给)进程内的另一个线程(如果没有，则让给它自己，直到进程在CPU上超时)。</p><p id="fb1f" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">如果你想更详细地介绍这方面的内容，我提到的游戏引擎架构这本书是最好的。此外，在线查看更多这些概念。</p><h1 id="11a3" class="lv lw jk bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">穿线</h1><p id="9e2e" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">现在我们已经有了一些概念，让我们深入了解何时使用线程。正如在线程概念下提到的，“永远不要在UI线程上工作”是一个大问题。</p><p id="2551" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">示例:</p><p id="030d" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您正在使用的3D建模程序是单线程应用程序。图形用户界面，计算，一切都在一个线程上。您刚刚创建了一个具有1，000，000个顶点的对象，并希望使用最终材质渲染该对象。你点击render，你的程序就停止了，看不到结束的迹象(刚刚超过30分钟)。这是因为你的计算占用了线程在处理器上的所有时间，它不允许程序继续运行它的UI循环。</p><p id="88d9" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">一个解决方案是，生成第二个线程来进行计算和存储数据，这将允许主线程(您的GUI和程序所在的线程)继续运行，您仍然可以使用该程序。</p><p id="210f" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">Python有一个模块恰如其分地叫做<a class="ae jh" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank"> <em class="ng">线程</em> </a>。这就是我们将在示例中使用的内容。</p><h1 id="6563" class="lv lw jk bd lx ly lz ma mb mc md me mf kq mg kr mh kt mi ku mj kw mk kx ml mm bi translated">离散傅立叶变换</h1><p id="0d42" class="pw-post-body-paragraph kz la jk lb b lc mn kl le lf mo ko lh li mp lk ll lm mq lo lp lq mr ls lt lu in bi translated">来自<a class="ae jh" href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform" rel="noopener ugc nofollow" target="_blank">维基百科</a>的离散傅立叶变换(DFT)定义为:<br/> <em class="ng">在数学上，离散傅立叶变换(DFT)将一个函数的有限个等距样本序列转换为离散时间傅立叶变换(DTFT)的等长样本序列，离散时间傅立叶变换是一个频率的复值函数。</em></p><p id="b3f0" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">您不必完全理解这个函数，它只是一个占位符，用来展示线程的好处，也是我所学到的函数之一。</p><p id="9fff" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">完整代码托管于此:<a class="ae jh" href="https://github.com/srepollock/python_threading_example" rel="noopener ugc nofollow" target="_blank">sre pollock/python _ threading _ example</a></p><figure class="ni nj nk nl gu iw gi gj paragraph-image"><div class="gi gj nh"><img src="../Images/42be6df9f8b1ebb11c30748f4f67eea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/0*qZ5N58xkCCYiFOiQ"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">我们的进口</figcaption></figure><p id="97a5" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">首先，我们设置脚本的<a class="ae jh" href="https://en.wikipedia.org/wiki/Shebang_(Unix)" rel="noopener ugc nofollow" target="_blank"> shebang </a>和导入。我们需要的只是数学、随机、线程和时间模块。DFT函数的数学，帮助生成一些数字的random，线程(duh)，以及显示非线程和线程函数之间速度差异的time。</p><figure class="ni nj nk nl gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nm"><img src="../Images/bb14998a1dcd7992e8299da999416b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4xuGqB1lLwi9qSFN"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">理解函数不是必需的，但它对你来说是更多的知识</figcaption></figure><p id="23e4" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这里我们有DFT函数本身。</p><figure class="ni nj nk nl gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nm"><img src="../Images/bddbc666bd3a31865e379bd4a7afaf32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rtnl2h-4eJh_mE1z"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">DFT，DFT，DFT，DFT</figcaption></figure><p id="ff6e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这是DFT的线程版本。注意，在这个版本中，有一个开始和结束索引。这是因为每个线程都接触同一个数据源，并且会在竞争中覆盖自己，除非我们明确告诉它将数据写入何处。</p><figure class="ni nj nk nl gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nn"><img src="../Images/f9f9fb17bf5b331d160673f1f5b7e0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8JJSWAbWllDaDbMy"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">输入只需要DFT的实数集。图像是尚未计算的虚数</figcaption></figure><p id="892c" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这里我们为DFT函数生成一些假数据。数组仍然需要满才能正确索引，所以我们用128个0填充“outreal”和“outimage”</p><figure class="ni nj nk nl gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nm"><img src="../Images/68ad3d174c2710e035f9e4b6bf891570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yY_vdWkMRHbTtyYd"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">上半部分运行非线程DFT，下半部分运行线程DFT</figcaption></figure><p id="2990" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">最后，我们按顺序运行这些函数，以展示每个函数从输入计算输出的能力。在您的计算机上运行时，您的结果可能会有所不同，但总体外观如下所示:</p><figure class="ni nj nk nl gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj no"><img src="../Images/9b478d63c981785a4c4efe75284ca15d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xbRE3TUTHJuLg3xi"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">如您所见，线程化DFT比非线程化DFT花费的时间更少。去穿线！</figcaption></figure><p id="5662" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><em class="ng">运行在2015年中期的MacBook Pro 13英寸双核i5上</em></p><p id="1739" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">恭喜你，你现在已经做了一个线程化的Python脚本！</p><p id="9e74" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">我希望你能从这篇文章中获得一些启示。也许您对线程的了解比您想象的要多。也许您现在很好奇，渴望获得更多关于线程的信息。最重要的是，我希望你不要停止学习！</p><p id="d3a1" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">感谢你花时间阅读这篇文章，让我对自己有了更多的了解。期待前方的路。</p><p id="e800" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">祝你一切顺利——斯潘塞</p></div></div>    
</body>
</html>