<html>
<head>
<title>Using SQLite on Unity for Android and iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android和iOS的Unity上使用SQLite</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-sqlite-on-unity-for-android-and-ios-16c3da6ba1bf?source=collection_archive---------8-----------------------#2020-03-18">https://levelup.gitconnected.com/using-sqlite-on-unity-for-android-and-ios-16c3da6ba1bf?source=collection_archive---------8-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fbad2b3c0f2093257425dc58e54a8656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fy_7tadgMVA773rBHy8ZYw.jpeg"/></div></div></figure><p id="36e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在浏览<a class="ae kz" href="https://github.com/rudderlabs/rudder-server" rel="noopener ugc nofollow" target="_blank"> RudderStack </a> SDK路线图时，我们决定将Unity next纳入支持的平台列表。为什么是统一？我们发现，尽管在很大程度上依赖于数据，但托管的客户数据管理解决方案并没有为游戏行业提供足够的服务。这种对数据的依赖是多种因素造成的。游戏产生大量数据，尤其是来自移动设备的遥测数据，而游戏公司在产品货币化方面面临巨大困难。</p><h1 id="67fa" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">背景</h1><p id="0b4f" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><a class="ae kz" href="https://rudderstack.com/" rel="noopener ugc nofollow" target="_blank"> RudderStack </a>承诺捕获用户生成的事件。我们将这些事件路由到不同的目的地，比如云应用程序、数据仓库和云文件系统。</p><p id="3bd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了成功实施Unity SDK，我们有四个主要要求:</p><ol class=""><li id="ff98" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">SDK应该实现初始化和事件收集机制。</li><li id="8619" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">事件应该临时存储在持久存储上，以确保我们希望平台具有的交付语义。</li><li id="06be" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">事件应该被推送到方向舵服务器。这些事件将在不同的环境中运行。</li><li id="de91" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">最后，应该有一种机制来处理设备模式的SDK。设备模式SDK支持许多目的地，这些目的地是RudderStack服务器到服务器集成所不能支持的。设备模式支持的另一个目的是利用本机SDK的功能，特别是推送通知、属性等等。</li></ol><h1 id="1c1f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">挑战</h1><h1 id="0fac" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为Unity选择正确的C#版本</h1><p id="f8f9" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们遇到的第一个挑战是选择正确的C#版本。团结支持。Net 3.5，。Net 4.x，以及。净标准。但是，3.5版和4.x版之间有一些重大的变化和不兼容。许多流行的游戏都是在3.5版上构建的。迁移到4.x是一个如此痛苦的过程，以至于电影公司宁愿停留在旧版本上。</p><p id="5ab3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们开始用开发Unity SDKs。Net 4.x，发布后不久，我们就意识到很多游戏因为是在3.5版本开发，所以无法使用我们的SDK。最终，我们重写了大约80%的代码，回到了3.5版本。</p><h2 id="0c81" class="mr lb it bd lc ms mt dn lg mu mv dp lk km mw mx lo kq my mz ls ku na nb lw nc bi translated">从中吸取的教训</h2><p id="31c8" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在开始开发之前，请务必做好以下研究:</p><ol class=""><li id="ff2a" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">业界采用最多的软件版本是哪个？</li><li id="8b15" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">与我们的项目相关的SDK的采用情况如何？通过识别开发人员在使用什么和为什么使用来学习和区分优先级。</li></ol><p id="9b0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从产品和工程的角度来看，这些都是重要的考虑因素。</p><h1 id="d166" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">将Unity数据安全一致地传送到选定的目的地</h1><p id="6ddf" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在主要的挑战来了，这也是我们写这篇博客的原因。通过不可靠的网络捕获和传输数据是一项艰巨的任务。如果您不能安全、一致地将数据传送到选定的目的地，那么捕获数据是徒劳的。一种安全一致地交付数据的方法是使用某种缓存机制来存储事件。这种机制会存储事件，直到您收到数据已正确传送到目的地的确认。</p><p id="4e6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用<a class="ae kz" href="https://docs.unity3d.com/ScriptReference/PlayerPrefs.html" rel="noopener ugc nofollow" target="_blank"> PlayerPrefs </a>在Unity上存储事件。然而，我们有三个主要的限制:</p><ol class=""><li id="336a" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">我们应该能够存储任意大小的事件缓冲区。我们在Rudder中使用的默认缓冲区大小是10K事件。然而，对于这种情况，我们希望能够放大和缩小它。</li><li id="0aae" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">应该有在存储的事件上定义和实施模式的灵活性。PlayerPrefs是一个简单的键值存储，支持非常有限的一组数据类型，没有层次结构。</li><li id="6f7c" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">管理缓冲区不应该发生在主线程中。使用PlayerPrefs发生在主线程中，这在大多数情况下不是一个可行的选择。</li></ol><p id="8761" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了这个目的，我们决定使用SQLite，而不是PlayerPrefs。SQLite是一个轻量级、可嵌入、高度可靠的SQL数据库引擎，非常适合移动设备。然而，在Unity中嵌入SQLite并不简单。</p><h1 id="4ad6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">实施</h1><h1 id="91a7" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">入门指南</h1><p id="7ec3" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">。Net和Unity不支持SQLite开箱即用。我们还希望尽可能减少第三方库的使用，以保持SDK尽可能的轻量级。收集事件应该是极其轻量级的，不会引入bug和大量依赖。</p><p id="4bc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最初，我们试图构建独立的二进制文件来支持SQLite并与Unity SDK集成。这里的问题是，这种设计在生产中部署和维护起来很痛苦，因为它不是线程安全的。</p><h1 id="1165" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Android和iOS的Unity插件支持</h1><p id="ee3b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">因此，我们最终决定遵循一个流行的Unity模式，包括开发Unity提供的优秀的<a class="ae kz" href="https://docs.unity3d.com/Manual/Plugins.html" rel="noopener ugc nofollow" target="_blank">插件</a>。</p><p id="15a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Unity使用预处理器指令同时支持Android和iOS的代码。它控制将根据平台执行的代码行。我们利用这个Unity产品为Unity分别构建了Android SDK和iOS插件。</p><p id="2371" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们的for Unity插件有一个初始化<code class="fe nd ne nf ng b">RudderClient</code>的方法，看起来像下面的代码片段:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="8ed5" class="mr lb it ng b gy np nq l nr ns">+ (void) _initiateInstance: (NSString*) _anonymousId<br/>                  writeKey: (NSString*) _writeKey<br/>               endPointUrl: (NSString*) _endPointUrl<br/>            flushQueueSize: (int) _flushQueueSize<br/>          dbCountThreshold: (int) _dbCountThreshold<br/>              sleepTimeOut: (int) _sleepTimeout<br/>                configRefreshInterval: (int) _configRefreshInterval<br/>      trackLifecycleEvents: (BOOL) _trackLifecycleEvents<br/>         recordScreenViews: (BOOL) _recordScreenViews<br/>                  logLevel: (int) _logLevel;</span></pre><p id="5ee8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将从Unity桥获取所有必要的参数，并启动<code class="fe nd ne nf ng b">RudderClient</code>。我们对Android有如下类似的方法:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="6574" class="mr lb it ng b gy np nq l nr ns">public static void _initiateInstance(<br/>            Context _context,<br/>            String _anonymousId,<br/>            String _writeKey,<br/>            String _endPointUrl,<br/>            int _flushQueueSize,<br/>            int _dbCountThreshold,<br/>            int _sleepTimeout,<br/>            int _configRefreshInterval,<br/>            boolean _trackLifecycleEvents,<br/>            boolean _recordScreenViews,<br/>            int _logLevel<br/>    )</span></pre><p id="fd89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当我们想从C#代码中调用这些方法时，我们可以在运行时使用预处理器指令来控制这些方法的调用以及平台。C#中的代码如下所示:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="e464" class="mr lb it ng b gy np nq l nr ns">#if UNITY_IPHONE<br/>[DllImport("__Internal")]<br/>private static extern void _initiateInstance(<br/>    string _anonymousId,<br/>    string _writeKey,<br/>    string _endPointUrl,<br/>    int _flushQueueSize,<br/>    int _dbCountThreshold,<br/>    int _sleepTimeout,<br/>    int _configRefreshInterval,<br/>    bool _trackLifecycleEvents,<br/>    bool _recordScreenViews,<br/>    int _logLevel<br/>);<br/>#endif</span></pre><p id="dd0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这段代码定义了用于iPhone环境的方法。当我们需要调用一个方法时，我们可以检查当前运行时并使用下面的代码片段调用这个方法:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="a67f" class="mr lb it ng b gy np nq l nr ns">#if UNITY_IPHONE<br/>if (Application.platform == RuntimePlatform.IPhonePlayer)<br/>{<br/>    _initiateInstance(<br/>        RudderCache.GetAnonymousId(),<br/>        _writeKey,<br/>        _endPointUrl,<br/>        _flushQueueSize,<br/>        _dbCountThreshold,<br/>        _sleepTimeout,<br/>        _configRefreshInterval,<br/>        _trackLifecycleEvents,<br/>        _recordScreenViews,<br/>        _logLevel<br/>    );<br/>}<br/>#endif</span></pre><p id="02e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类似地，对于Android，我们必须在Unity代码中定义一个<code class="fe nd ne nf ng b">AndroidJavaClass</code>对象，这样我们就可以在代码中访问它的方法。为此，请使用以下代码:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="f621" class="mr lb it ng b gy np nq l nr ns">#if UNITY_ANDROID<br/>private static readonly string androidClientName = "com.rudderstack.android.sdk.wrapper.RudderClientWrapper";</span><span id="b67b" class="mr lb it ng b gy nt nq l nr ns">private static AndroidJavaClass androidClientClass;</span><span id="b6aa" class="mr lb it ng b gy nt nq l nr ns">AndroidJavaClass unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");<br/>AndroidJavaObject activity = unityPlayer.GetStatic&lt;AndroidJavaObject&gt;("currentActivity");<br/>AndroidJavaObject context = activity.Call&lt;AndroidJavaObject&gt;("getApplicationContext");<br/>androidClientClass = new AndroidJavaClass(androidClientName);<br/>#endif</span></pre><p id="bd00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，为了从我们的Android插件中调用<code class="fe nd ne nf ng b">initiateInstance</code>方法，我们将检查运行时并使用<code class="fe nd ne nf ng b">AndroidJavaClass</code>对象的<code class="fe nd ne nf ng b">callStatic</code>方法进行调用，如下所示:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="30bb" class="mr lb it ng b gy np nq l nr ns">#if UNITY_ANDROID<br/>if (Application.platform == RuntimePlatform.Android)<br/>{<br/>    androidClientClass.CallStatic(<br/>        "_initiateInstance",<br/>        context,<br/>        RudderCache.GetAnonymousId(),<br/>        _writeKey,<br/>        _endPointUrl,<br/>        _flushQueueSize,<br/>        _dbCountThreshold,<br/>        _sleepTimeout,<br/>        _configRefreshInterval,<br/>        _trackLifecycleEvents,<br/>        _recordScreenViews,<br/>        _logLevel<br/>    );<br/>}<br/>#endif</span></pre><h1 id="9100" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用Unity插件目录</h1><p id="e2c9" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">此外，Unity在其名为<code class="fe nd ne nf ng b">Plugins</code>的<code class="fe nd ne nf ng b">Assets</code>目录下支持一种特殊的目录。该目录包含应用程序所需的所有平台特定的库。只需创建两个文件夹，一个名为<code class="fe nd ne nf ng b">Android</code>，另一个名为<code class="fe nd ne nf ng b">iOS</code>，位于<code class="fe nd ne nf ng b">Plugins</code>文件夹中。Unity会自动将这些文件添加到相应平台的项目的最终产品/版本中。</p><p id="e062" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们利用这一机制，为Android和iOS构建了插件。我们按照上面提到的目录结构将这些插件添加到项目中。通过这种方式，Unity能够与Android的JAVA和iOS的Object-C进行互操作。由于这个原因，我们在可以交互的技术方面获得了很大的灵活性。在我们的例子中，我们可以在Unity中嵌入适用于Android和iOS的SQLite。</p><p id="0c9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">按照这种方法，我们最终拥有两个插件，每个平台一个，以及一个包装Unity应用程序，它与这些插件互操作，以公开我们需要的功能。</p><blockquote class="nu nv nw"><p id="2a71" class="kb kc nx kd b ke kf kg kh ki kj kk kl ny kn ko kp nz kr ks kt oa kv kw kx ky im bi translated"><em class="it">刚刚发生了什么:</em></p><p id="b287" class="kb kc nx kd b ke kf kg kh ki kj kk kl ny kn ko kp nz kr ks kt oa kv kw kx ky im bi translated"><em class="it">简而言之，包装器是用C#编写的，它满足了我们管理客户端事件缓存大小的第一个要求。插件负责我们在文章开头提到的其余需求。</em></p></blockquote><h1 id="a10d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">添加新目的地</h1><p id="41ee" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">最后，我们希望提供尽可能多的与Unity和移动开发相关的目的地。与Unity最相关的目的地是Adjust和Firebase。对于这两者，我们支持所谓的设备模式SDK。设备模式SDK允许将事件推送到目的地，而无需通过RadderStack服务器。</p><p id="bcb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们决定在Unity本身中构建<a class="ae kz" href="https://github.com/rudderlabs/rudder-sdk-unity/blob/master/SDK/Rudder/RudderIntegrationManager.cs" rel="noopener ugc nofollow" target="_blank">设备模式机制</a>，并使用平台的Unity SDKs。通过这种方式，您可以使用平台支持的本机代码，这提供了更大的可靠性和长期支持。</p><h1 id="5cab" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="f24c" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Unity是一个功能丰富、用途广泛的游戏开发平台。我们希望为游戏开发者提供移动和服务器端开发者通常可以访问的数据功能。尽管在Unity中支持嵌入式数据库并不简单，但该平台允许你通过插件系统以一种优雅的方式做到这一点。<br/>方向舵栈和所有的SDK都是开源的，可以在<a class="ae kz" href="https://github.com/rudderlabs" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。你也可以在这里找到这个Unity SDK <a class="ae kz" href="https://docs.rudderstack.com/sdk-integration-guide/getting-started-with-unity-sdk" rel="noopener ugc nofollow" target="_blank">的详细文档。我们希望听到您对如何改进我们的SDK的反馈。</a></p></div></div>    
</body>
</html>