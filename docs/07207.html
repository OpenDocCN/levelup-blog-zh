<html>
<head>
<title>Running Distributed Queries in Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在微服务中运行分布式查询</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/running-distributed-queries-in-micro-services-157b12b93154?source=collection_archive---------9-----------------------#2021-02-01">https://levelup.gitconnected.com/running-distributed-queries-in-micro-services-157b12b93154?source=collection_archive---------9-----------------------#2021-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1e1e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">CQRS和API组合方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/07d919577572d5bfd3ac0d8d998c8265.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKw8rX2Jx9rzNGd37goBfA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">丹尼斯·库默在<a class="ae kv" href="https://unsplash.com/s/photos/distributed-data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9efc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们有一个使用微服务架构的应用时，有几种数据策略可以使用。推荐的方法之一是让每个微服务拥有自己的数据存储。这意味着系统的整体状态将分布在多个数据存储中，只能从它们自己的微服务中访问。</p><p id="f0f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数复杂的查询将涉及多个数据库中的可用数据。每个消费者都可以访问所有这些微服务，并聚合所有数据来满足他们的查询。但是，由于以下几个原因，它并不理想:</p><ul class=""><li id="2673" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">消费者非常了解系统如何管理数据。</li><li id="f37f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">消费者需要访问存储与查询相关的数据的每个服务。</li><li id="362c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">改变架构可能需要改变许多消费者。</li></ul><p id="ad18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决这个问题有两种方法:CQRS和API结合。有趣的是，支持这两种解决方案的服务具有相同的API，因此您可以从一种解决方案切换到另一种解决方案，甚至可以混合使用而不会影响用户。这意味着一些查询将由CQRS服务，而其他查询将由API组成，并且所有查询将由相同的服务实现。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="9713" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">命令查询责任分离(CQRS)</h2><p id="6c8a" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">使用命令查询责任分离(CQRS)，来自各种微服务的数据将被聚集到一个新的只读数据存储区域，该区域旨在回答特定的查询。名字的意思是你把更新数据(命令)的责任和读取数据(查询)的责任分开(分开)。这些活动由不同的服务处理。这通常通过监控所有数据存储变化来实现，并且需要适当的变化通知系统。您也可以使用轮询，但这通常是不可取的。当存在经常使用的已知查询时，该解决方案将大放异彩。</p><p id="f6bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是CQRS在实践中的描述。CQRS服务(负责查询)从三个微服务(负责更新)接收更改通知，并将它们聚合到自己的数据存储中。当查询到来时，CQRS服务通过访问自己的聚合视图做出响应，而不需要访问微服务:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/b5fc8c9de9ab25963bf5744e33f4aaa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*bIlQAKMq9RDLhaWOg7vRhA.png"/></div></figure><p id="aa92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">优点如下:</p><ul class=""><li id="d31c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">查询不会干扰主数据存储的更新。</li><li id="a3bc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">聚合器服务公开了一个为特定查询定制的API。</li><li id="78d3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在不影响消费者的情况下，更容易在幕后改变数据管理方式。</li><li id="33d1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">快速响应时间。</li></ul><p id="b66e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缺点如下:</p><ul class=""><li id="b730" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">这增加了系统的复杂性。</li><li id="e35a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">它复制了数据。</li><li id="1c97" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">局部视图需要显式处理。</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="f0d9" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">API成分</h2><p id="9074" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">API组合方法更加轻量级。从表面上看，这似乎是一个CQRS解决方案。它公开了一个API，可以回答多个微服务中众所周知的查询。不同之处在于，它不保留自己的数据存储。每当有请求进来，它就访问每一个包含数据的微服务，组合结果，然后返回它们。</p><p id="fc92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当系统不支持数据更改的事件通知时，该解决方案将大放异彩，并可以接受主数据存储的运行查询负载。</p><p id="f9ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个实际的API组合示例，其中对API Composer服务的查询被转换为对后台三个微服务的查询:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/95883b704e9bc8dc2af3596e5e6d8017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*ypIG-64_MnzZHN1TXGWRnQ.png"/></div></figure><p id="391f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">优点是:</p><ul class=""><li id="bd84" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">轻量级解决方案。</li><li id="6458" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">聚合器服务公开了一个为特定查询定制的API。</li><li id="7e23" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">结果总是最新的。</li><li id="dfc9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">没有架构需求，比如事件通知。</li></ul><p id="3d0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缺点是:</p><ul class=""><li id="1dc0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">任何服务的失败都将导致查询失败。</li><li id="2eb5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">这需要关于重试和超时的策略决策。</li><li id="97e9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">大量的查询可能会影响主数据存储。</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h2 id="c9fc" class="mn mo iq bd mp mq mr dn ms mt mu dp mv lf mw mx my lj mz na nb ln nc nd ne nf bi translated">结论</h2><p id="43a7" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在本文中，我们简要介绍了在微服务架构上处理分布式查询的两种方法。API组合是一种更容易上手的解决方案。</p><p id="dbe5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，由于复杂程度要高得多，建议只有在适当的条件存在且具有明显的吸引力时，才应开始从API成分向CQRS的过渡。</p></div></div>    
</body>
</html>