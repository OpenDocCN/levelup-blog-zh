<html>
<head>
<title>Complex SwiftUI App Tutorial. Part 3. Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">复杂SwiftUI App教程。第三部分。行动</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/complex-swiftui-app-tutorial-part-3-actions-7a3c09dd4f89?source=collection_archive---------6-----------------------#2021-04-20">https://levelup.gitconnected.com/complex-swiftui-app-tutorial-part-3-actions-7a3c09dd4f89?source=collection_archive---------6-----------------------#2021-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="21fd" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">iOS应用程序开发</h2><div class=""/><div class=""><h2 id="ad2c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在本教程中，我们将向网格项目添加一个ContextMenu，并在SwiftUI应用程序中实现目标操作。我们将使用联合收割机，核心数据和MVVM模式。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f651557fb05621f64de1c7285c9b7323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*at4lurkjv-MDmvmK4BaPsQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者提供的截图</figcaption></figure></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><blockquote class="lo lp lq"><p id="e03b" class="lr ls lt lu b lv lw kd lx ly lz kg ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">在本教程中，我们使用最新版本的Xcode (12.4)和macOS Big Sur (11.2.2)进行编写。</p></blockquote></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="7767" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">在本教程中，我们将使用在<a class="ae mr" href="https://alexzarr.medium.com/complex-swiftui-app-tutorial-part-2-main-view-31464249b367" rel="noopener"> Complex SwiftUI app教程中开发的App。第二部分。主视图</a>教程，所以推荐通读一下。否则，如果您不想这样做，您可以简单地在这里下载starter项目<a class="ae mr" href="https://github.com/alexzarr/DailyGoals/tree/tutorial-part-02/main-view" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="4398" class="ms mt it bd mu mv mw dn mx my mz dp na mo nb nc nd mp ne nf ng mq nh ni nj iz bi translated">我们今天要做什么</h2><p id="6265" class="pw-post-body-paragraph lr ls it lu b lv nk kd lx ly nl kg ma mo nm md me mp nn mh mi mq no ml mm mn im bi translated">今天，我们将把我们的目标标记为今天完成，并开始存储我们一段时间以来的表现记录。此外，我们将添加编辑和删除目标。我们将使用<code class="fe np nq nr ns b">ContextMenu</code>进行操作，创建另一个<strong class="lu jd"> SwiftUI </strong>视图来编辑目标，并向我们的<code class="fe np nq nr ns b">DataManager</code>添加一个新方法来将<code class="fe np nq nr ns b">TLGoalRecords</code>存储在<strong class="lu jd">核心数据</strong>中。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="d560" class="ms mt it bd mu mv mw dn mx my mz dp na mo nb nc nd mp ne nf ng mq nh ni nj iz bi translated">入门指南</h2><p id="015c" class="pw-post-body-paragraph lr ls it lu b lv nk kd lx ly nl kg ma mo nm md me mp nn mh mi mq no ml mm mn im bi translated">首先，确保你已经准备好了入门应用。如果您已经完成了本教程前面的所有部分，那么您就万事俱备了。否则，下载<a class="ae mr" href="https://github.com/alexzarr/DailyGoals/tree/tutorial-part-02/main-view" rel="noopener ugc nofollow" target="_blank">启动项目</a>。</p><p id="2a10" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">此时，我们可以创建新的目标，并在主屏幕上看到我们所有的目标。我们有一个显示目标的<code class="fe np nq nr ns b">LazyVGrid</code>，现在，我们将添加一个点击目标的动作。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="2b67" class="ms mt it bd mu mv mw dn mx my mz dp na mo nb nc nd mp ne nf ng mq nh ni nj iz bi translated">我已经完成了今天行动的目标</h2><p id="22e6" class="pw-post-body-paragraph lr ls it lu b lv nk kd lx ly nl kg ma mo nm md me mp nn mh mi mq no ml mm mn im bi translated">要添加动作，我们需要先有一个负责逻辑的层。实际上，我们需要我们案例中的东西:主视图的视图模型和实现了新方法的<code class="fe np nq nr ns b">DataManager</code>。先说<code class="fe np nq nr ns b">DataManager</code>。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="379b" class="ms mt it bd mu mv mw dn mx my mz dp na mo nb nc nd mp ne nf ng mq nh ni nj iz bi translated">数据管理器</h2><p id="eb2a" class="pw-post-body-paragraph lr ls it lu b lv nk kd lx ly nl kg ma mo nm md me mp nn mh mi mq no ml mm mn im bi translated">我们将为与<code class="fe np nq nr ns b">TLGoalRecords</code>相关的动作创建一个新的协议<code class="fe np nq nr ns b">GoalRecordDataManager</code>。为了避免将来<code class="fe np nq nr ns b">DataManager</code>有一个巨大的文件，我们将为这个协议创建一个单独的文件。但首先，让我们重构其中的当前代码。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><blockquote class="lo lp lq"><p id="7da7" class="lr ls lt lu b lv lw kd lx ly lz kg ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">在一个完美的世界中，我们应该创建一个单独的分支，在那里实现计划的重构，合并它，然后继续当前的任务。但是现在，我们就在这里做。它不疼。</p></blockquote></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="f8ba" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">创建<code class="fe np nq nr ns b">DataManager+Goal.swift</code>文件。然后将实现这个协议的<code class="fe np nq nr ns b">GoalDataManagerProtocol</code>定义和<code class="fe np nq nr ns b">DataManager</code>扩展移到这个文件中。此外，我们将向该协议添加一个新方法<code class="fe np nq nr ns b">readGoal</code>。该文件将如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a323" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">如您所见，我们向协议添加了一个新方法，并在扩展中实现了它。在这个方法中，我们用给定的<code class="fe np nq nr ns b">id</code>或<code class="fe np nq nr ns b">nil</code>返回一个目标，如果没有这样的目标。</p><blockquote class="lo lp lq"><p id="754d" class="lr ls lt lu b lv lw kd lx ly lz kg ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">注意<code class="fe np nq nr ns b">id</code>参数是可选的。这是因为<code class="fe np nq nr ns b">TLGoal</code>有一个可选参数<code class="fe np nq nr ns b">id</code>。事实上，它永远不会是<code class="fe np nq nr ns b">nil</code>，所以为了方便起见，我们将其设置为可选参数。</p></blockquote><p id="9473" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">现在，我们的<code class="fe np nq nr ns b">DataManager.swift</code>看起来不错:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3af9" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">确保您为<code class="fe np nq nr ns b">persistenceController</code>移除了<code class="fe np nq nr ns b">private </code>。暴露它并不是最明智的事情，但是因为我们把我们的<code class="fe np nq nr ns b">DataManager</code>藏在协议后面，它不会有太大的改变。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="cb49" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">最后，创建<code class="fe np nq nr ns b">DataManager+GoalRecord.swift</code>文件。它将有一个包含三种方法(及其实现)协议:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="4b3d" class="nv nw it lu b lv lw ly lz mo nx mp ny mq nz mn oa ob oc od bi translated">我们用三种方法创建了一个新的协议，</li><li id="dbb2" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oa ob oc od bi translated">创建了一个扩展来实现完全相同的方法，但是为<code class="fe np nq nr ns b">date</code>添加了一个默认值，</li><li id="b4eb" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oa ob oc od bi translated">最后，实现了这个协议。</li></ul></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="4735" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated"><code class="fe np nq nr ns b">DataManager</code>的最后一步是将新协议添加到<code class="fe np nq nr ns b">typealias</code>中，我们已经为<code class="fe np nq nr ns b">DataManagerProtocol</code>准备了该协议:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cb3b" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">现在，当我们点击一个目标时，我们准备使用<code class="fe np nq nr ns b">DataManager</code>来创建一个新的记录。首先，我们将为<code class="fe np nq nr ns b">MyGoalsView</code>创建一个viewModel，因此它将负责与模型的交互。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="4afb" class="ms mt it bd mu mv mw dn mx my mz dp na mo nb nc nd mp ne nf ng mq nh ni nj iz bi translated">MyGoalsViewModel</h2><p id="6884" class="pw-post-body-paragraph lr ls it lu b lv nk kd lx ly nl kg ma mo nm md me mp nn mh mi mq no ml mm mn im bi translated">创建一个新的Swift文件<code class="fe np nq nr ns b">MyGoalsViewModel</code>。这个视图模型现在有两个方法:<code class="fe np nq nr ns b">markAsDone</code>和<code class="fe np nq nr ns b">unmarkAsDone</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="019d" class="nv nw it lu b lv lw ly lz mo nx mp ny mq nz mn oa ob oc od bi translated">我们创建了一个符合<code class="fe np nq nr ns b">ObservableObject</code>的新类，</li><li id="0d55" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oa ob oc od bi translated">注入了<code class="fe np nq nr ns b">DataManager</code>，所以我们可以测试这个视图模型，</li><li id="027a" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oa ob oc od bi translated">添加了一个新方法，基本上调用了新创建的<code class="fe np nq nr ns b">DataManager</code>的<code class="fe np nq nr ns b">createGoalRecord</code>方法，</li><li id="b2e2" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oa ob oc od bi translated">又加了一个叫<code class="fe np nq nr ns b">deleteGoalRecord</code>的。</li></ul><p id="c765" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">现在，我们几乎准备好实现我们视图中的操作了。但在此之前，让我们先给我们的<code class="fe np nq nr ns b">TLGoal</code>添加几个计算变量。转到<code class="fe np nq nr ns b">TLGoal.swift</code>，添加以下内容:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="5ac5" class="nv nw it lu b lv lw ly lz mo nx mp ny mq nz mn oa ob oc od bi translated">添加<code class="fe np nq nr ns b">lastRecord</code>，它只是从<code class="fe np nq nr ns b">records</code>集合中取出最后一个<code class="fe np nq nr ns b">TLGoalRecord</code>，</li><li id="f5be" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oa ob oc od bi translated">添加<code class="fe np nq nr ns b">isCompletedToday</code>,它简单地获取<code class="fe np nq nr ns b">lastRecord</code>,并检查其<code class="fe np nq nr ns b">date</code>是否是今天。</li></ul></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="4fba" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">现在，打开<code class="fe np nq nr ns b">MyGoalsItemView.swift</code>。今天的目标完成后，我们将更改背景:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ol class=""><li id="9857" class="nv nw it lu b lv lw ly lz mo nx mp ny mq nz mn oj ob oc od bi translated">我们检查<code class="fe np nq nr ns b">goalIsCompletedToday</code>是否将背景色设置为绿色，否则，我们使用默认的背景色，</li><li id="062c" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oj ob oc od bi translated">我们为预览创建另一个<code class="fe np nq nr ns b">TLGoal</code>变量，</li><li id="6cff" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oj ob oc od bi translated">我们将我们的预览移动到一个<code class="fe np nq nr ns b">Group</code>中，并将我们的<code class="fe np nq nr ns b">previewLayout</code>修改器应用到整个<code class="fe np nq nr ns b">Group</code>中，所以我们不需要为每个预览项目应用它，</li><li id="406c" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oj ob oc od bi translated">最后，我们在<code class="fe np nq nr ns b">Group</code>中添加另一个<code class="fe np nq nr ns b">MyGoalsItemView</code>。</li></ol></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="a5c7" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">现在，画布向我们展示了两个项目:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/8d77e3b1eca54956beca82cedbcedbd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RIpqbX-JfarRj9hVbKTQYA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者提供的截图</figcaption></figure><p id="bac3" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">看起来不错。但是让我们先创建一个自定义颜色。按下<code class="fe np nq nr ns b">Command</code> + <code class="fe np nq nr ns b">N</code>创建一个新文件。在<code class="fe np nq nr ns b">iOS</code>选项卡中，选择<code class="fe np nq nr ns b">Resources</code>部分的<code class="fe np nq nr ns b">Asset Catalog</code>。点击<code class="fe np nq nr ns b">Next</code>，称之为<code class="fe np nq nr ns b">Colors</code>，点击<code class="fe np nq nr ns b">Create</code>。</p><p id="4e02" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">现在，我们有一个专门针对颜色的资产目录。打开它，点击底部栏中的加号按钮，选择<code class="fe np nq nr ns b">Color Set</code>。称之为<code class="fe np nq nr ns b">completed</code>，为<code class="fe np nq nr ns b">Any Appearance</code>设置8位RGB值为59，199，255，为<code class="fe np nq nr ns b">Dark Appearance</code>设置75，135，215。或者你可以选择任何你喜欢的颜色。</p><p id="684d" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">还有，趁我们在这里，我们再加一个颜色，叫<code class="fe np nq nr ns b">background</code>。它的<code class="fe np nq nr ns b">Any Appearance</code>会是白色的<code class="fe np nq nr ns b">Dark Appearance</code>会是黑色的。我们需要它，因为我们使用的<code class="fe np nq nr ns b">Color(.systemBackground)</code>使用了macOS中没有的<code class="fe np nq nr ns b">UIColor.systemBackground</code>。</p><p id="ba5e" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">最后，创建一个新的Swift文件<code class="fe np nq nr ns b">Color+CustomColors.swift</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="51ef" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">现在，我们在一个扩展中拥有了来自资源的所有颜色。再次打开<code class="fe np nq nr ns b">MyGoalsItemView.swift</code>并改变背景颜色:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3d47" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">太好了。现在，如果你打开<code class="fe np nq nr ns b">MyGoalsView.swift</code>，你会看到它显示我们今天的目标是否完成:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/68366333ab0fee1655b23e3ba17e737b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hasV73jZAl9tENwITjMNVA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作者提供的截图</figcaption></figure><p id="c806" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">太好了。最后，是时候添加我们在视图模型中实现的动作了。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="4d6a" class="ms mt it bd mu mv mw dn mx my mz dp na mo nb nc nd mp ne nf ng mq nh ni nj iz bi translated">标记为完成</h2><p id="33dc" class="pw-post-body-paragraph lr ls it lu b lv nk kd lx ly nl kg ma mo nm md me mp nn mh mi mq no ml mm mn im bi translated">为了实现将今天的目标标记为已完成，我们将注入我们的视图模型，然后将<code class="fe np nq nr ns b">MyGoalsItemView</code>放入<code class="fe np nq nr ns b">Button</code>中，并在其动作中使用我们的新方法:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ol class=""><li id="5b32" class="nv nw it lu b lv lw ly lz mo nx mp ny mq nz mn oj ob oc od bi translated">我们在视图中添加了<code class="fe np nq nr ns b">MyGoalsViewModel</code>，</li><li id="95bd" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oj ob oc od bi translated">我们在<code class="fe np nq nr ns b">Grid</code>上添加了一个<code class="fe np nq nr ns b">Button</code>来调用tap上的<code class="fe np nq nr ns b">markAsDone</code>，</li><li id="518f" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oj ob oc od bi translated">我们在<code class="fe np nq nr ns b">PreviewProvider</code>中创建了<code class="fe np nq nr ns b">dataManager</code>，</li><li id="c059" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oj ob oc od bi translated">我们用具有这个<code class="fe np nq nr ns b">dataManager</code>的viewModel初始化视图。</li></ol></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="0499" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">现在，如果你构建并运行了这个应用程序(或者甚至你运行了实时预览)，你就可以将你的目标标记为已完成。如果您重新构建应用程序并再次运行，该状态将持续存在，因此您可以确保您的记录被正确存储，并且您可以开始收集关于您如何随着时间的推移处理目标的记录。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h1 id="f99f" class="om mt it bd mu on oo op mx oq or os na ki ot kj nd kl ou km ng ko ov kp nj ow bi translated">撤消操作</h1><p id="6e3d" class="pw-post-body-paragraph lr ls it lu b lv nk kd lx ly nl kg ma mo nm md me mp nn mh mi mq no ml mm mn im bi translated">但是如果你不小心碰到了一个目标呢？在这种情况下，您需要撤销此操作。为此，我们将实现一个<code class="fe np nq nr ns b">ContentMenu</code>，这样你可以长按任何目标并撤销你的动作。就这么办吧。将以下内容添加到您的视图中:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ol class=""><li id="1a6e" class="nv nw it lu b lv lw ly lz mo nx mp ny mq nz mn oj ob oc od bi translated">我们给我们的<code class="fe np nq nr ns b">Button</code>添加了一个新的修改器<code class="fe np nq nr ns b">.contextMenu</code>，</li><li id="97f7" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oj ob oc od bi translated">我们实现了一个方法来构建<code class="fe np nq nr ns b">ContextMenu</code>的项目。我们添加了一个包装器<code class="fe np nq nr ns b">@ViewBuilder</code>，显示我们正在构建一个<code class="fe np nq nr ns b">View</code>。我们检查了目标是否完成，并在这种情况下展示了我们的<code class="fe np nq nr ns b">undo</code>方法。最后，我们添加了接下来要实现的两个操作。</li></ol></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="e598" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">现在，如果你点击并按住你的任何一个目标，你会看到一个常规的<code class="fe np nq nr ns b">ContextMenu</code>，根据目标的状态有几个动作。目前只有<code class="fe np nq nr ns b">Not completed</code>能用。我们将在下一个教程中讨论它。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><h2 id="a255" class="ms mt it bd mu mv mw dn mx my mz dp na mo nb nc nd mp ne nf ng mq nh ni nj iz bi translated">下一步是什么</h2><p id="cc69" class="pw-post-body-paragraph lr ls it lu b lv nk kd lx ly nl kg ma mo nm md me mp nn mh mi mq no ml mm mn im bi translated">恭喜你。我们已经创建了一个点击目标的操作，并向我们的目标添加了一个<code class="fe np nq nr ns b">ContextMenu</code>，因此我们可以撤销将它们标记为已完成(此外，该菜单还会有其他操作，如“删除”和“编辑”)。我们正在逐步开发我们的应用程序，帮助人们获得新习惯，戒掉坏习惯。我们使用<strong class="lu jd"> SwiftUI </strong>和<strong class="lu jd">组合</strong>以及<strong class="lu jd"> MVVM </strong>模式。我们尽可能地隐藏在<strong class="lu jd">协议</strong>之后，以使我们的应用程序可测试。我们确保我们的应用在<strong class="lu jd">预览</strong>模式下工作，不会影响设备/模拟器上的数据。毕竟，我们使我们的代码干净且可测试，所以如果在某个时候，我们需要扩展应用程序，我们将能够毫不费力地完成。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="b655" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">该应用程序的完整代码可在<a class="ae mr" href="https://github.com/alexzarr/daily-goals-yt-tutorial/tree/part-3-mark-as-done-action" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="6c67" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated">敬请期待！下一个教程将很快推出。</p></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="8ab9" class="pw-post-body-paragraph lr ls it lu b lv lw kd lx ly lz kg ma mo mc md me mp mg mh mi mq mk ml mm mn im bi translated"><em class="lt">本教程是复杂SwiftUI应用教程的第二部分。要检查其他零件，请使用以下链接:</em></p><ol class=""><li id="0b1d" class="nv nw it lu b lv lw ly lz mo nx mp ny mq nz mn oj ob oc od bi translated"><a class="ae mr" href="https://medium.com/geekculture/complex-swiftui-app-tutorial-part-1-designing-model-17db0977712b" rel="noopener"> <em class="lt">复杂SwiftUI App教程。第一部分。设计模型</em> </a> <em class="lt">。</em></li><li id="cda8" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oj ob oc od bi translated"><a class="ae mr" href="https://alexzarr.medium.com/complex-swiftui-app-tutorial-part-2-main-view-31464249b367" rel="noopener"> <em class="lt">复杂SwiftUI App教程。第二部分。主视图</em> </a> <em class="lt">。</em></li><li id="bb1e" class="nv nw it lu b lv oe ly of mo og mp oh mq oi mn oj ob oc od bi translated"><em class="lt">复杂SwiftUI App教程。第三部分。行动。(本教程)</em></li></ol></div></div>    
</body>
</html>