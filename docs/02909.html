<html>
<head>
<title>Enhance Your HTTP-Request With Axios and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Axios和TypeScript增强您的HTTP请求</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/enhance-your-http-request-with-axios-and-typescript-f52a6c6c2c8e?source=collection_archive---------0-----------------------#2020-04-10">https://levelup.gitconnected.com/enhance-your-http-request-with-axios-and-typescript-f52a6c6c2c8e?source=collection_archive---------0-----------------------#2020-04-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">像专家一样使用OOP制作HTTP-request</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fd1ea600be8436bec09fa285419e7b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2Jm_mgF_Uxc5qpun"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">émile Perron</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="bdb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你好，世界！让我分享一些建议，告诉你如何让你的日常生活变得更有力量。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="492d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们介绍一些基础知识，这样我们就知道我们在同一页上。在JavaScript/TypeScript中，无论我们谈论的是客户端还是服务器端，我们都可以发出HTTP请求。</p><p id="038b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于客户端，你可以使用老派的<code class="fe lv lw lx ly b">XMLHttpRequest</code>(请不要这么做)，或者基于<code class="fe lv lw lx ly b">Promises</code>的现代<code class="fe lv lw lx ly b">fetch</code>。</p><p id="84da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于服务器端，Node.js模块<code class="fe lv lw lx ly b">https</code>总是为您提供。</p><p id="c32d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们大多数人都使用图书馆，其中最受欢迎的是<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank">axios</a></code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c85b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Axios实例</h1><p id="842e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">实现更清晰代码的第一步是一个<code class="fe lv lw lx ly b">axios</code>的实例。这有助于我们遵循DRY原则，因为我们使用了一个<code class="fe lv lw lx ly b">baseUrl</code>，在多个请求之间共享公共头，并附加了一个<code class="fe lv lw lx ly b">Authorization</code>头。</p><p id="bbab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让事情变得更好永远都不晚，或者至少试着去做。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8828" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">HTTP客户端</h1><p id="86d7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在最开始，我们需要一些基础<code class="fe lv lw lx ly b">http-client</code>，它将被扩展以创建所需的<code class="fe lv lw lx ly b">API</code>。</p><p id="ea70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将是一个抽象类(防止创建这个基类的实例)，它的构造函数将创建一个<code class="fe lv lw lx ly b">axios-instance</code>。在我们的例子中，我们从构造函数中获取基本URL。<code class="fe lv lw lx ly b">axios.create</code>的结果将被保存到该类的受保护变量中(仅对其继承者可见)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5dc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在99%的情况下，我必须从响应中析构<code class="fe lv lw lx ly b">data</code>。所以，让我们创建一个<code class="fe lv lw lx ly b">interceptor</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8bec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多新代码。我们来讨论一下上面是怎么回事。</p><p id="c62e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构造函数中，我们运行私有方法<code class="fe lv lw lx ly b">_initializeResponseInterceptor</code>，它将一个<code class="fe lv lw lx ly b">interceptor</code>添加到我们的响应中。</p><p id="c663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe lv lw lx ly b">interceptor</code>需要两次回调:<code class="fe lv lw lx ly b">_handleResponse</code>和<code class="fe lv lw lx ly b">_handleError</code>。</p><p id="c492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">_handleError</code>非常清楚——它只是接受一个错误并转发它。</p><p id="5fc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自响应的<code class="fe lv lw lx ly b">_handleResponse</code>析构<code class="fe lv lw lx ly b">data</code>。</p><p id="fc0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们使用TypeScript，所以我们必须帮助它理解正在发生的事情。这就是为什么我们在文件的顶部声明模块<code class="fe lv lw lx ly b">axios</code>。这样，当我们将响应作为纯粹的<code class="fe lv lw lx ly b">data</code>使用时，TypeScript不会抱怨。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d5fb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">真实世界的例子</h1><p id="137b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">是时候测试我们的解决方案了。我们有一些很棒的API，必须发出GET和POST请求。我们创建了一个<code class="fe lv lw lx ly b">HttpClient</code>的实例，并在<code class="fe lv lw lx ly b">super</code>中传递URL，描述我们的请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="19f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以创建一个受保护的<code class="fe lv lw lx ly b">MainApi</code>版本，在这里我们执行所有带有<code class="fe lv lw lx ly b">Authorization</code>头的敏感请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的代码中可以看出，我们添加了一个新方法<code class="fe lv lw lx ly b">_initializeRequestInterceptor</code>。使用这种方法，每个请求的头中都有<code class="fe lv lw lx ly b">Authorization</code>键。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c79b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">摘要</h1><p id="5640" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我希望你能找到新的有用的东西。当然，所有这些东西都可以用函数和纯<code class="fe lv lw lx ly b">axios.create</code>来代替，但从我的角度来看，它会帮助你编写更干净的代码，并用一个<code class="fe lv lw lx ly b">API</code>将所有工作集中在一个地方。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="d223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/use-case-of-singleton-with-axios-and-typescript-da564e76296">在这里</a>你可以找到当前文章的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/use-case-of-singleton-with-axios-and-typescript-da564e76296"> <strong class="lb iu">第二部分</strong> </a>。</p></div></div>    
</body>
</html>