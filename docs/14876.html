<html>
<head>
<title>Rust: Generics Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust:泛型解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rust-generics-explained-5e9bb75e0ef0?source=collection_archive---------6-----------------------#2022-12-30">https://levelup.gitconnected.com/rust-generics-explained-5e9bb75e0ef0?source=collection_archive---------6-----------------------#2022-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c915" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">探索Rust中的泛型:使用类型占位符编写灵活且可重用的代码</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/27f985263bba3747eabc6a34e4ea75cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0uJB2qBaaGR1biF82CBOgw.jpeg"/></div></div></figure><p id="2f71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">泛型是一种编写灵活且可重用的代码的方式，它允许您指定占位符类型，这些类型可以在以后使用代码时填充。这类似于模板在C++中的工作方式，或者类型参数在Java和其他语言中的工作方式。</p><p id="8f51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用泛型，您可以编写适用于任何类型的代码，而不是特定于特定类型的代码。这使得编写开发人员可以在各种情况下使用的代码变得更加容易，而不必为每个特定类型重写代码。</p><p id="c9a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，编写一个函数，它接受两个值并返回它们的和。如果没有泛型，您需要为想要支持的每种类型编写一个单独的函数，如下所示:</p><pre class="kp kq kr ks gt la lb lc bn ld le bi"><span id="28cb" class="lf lg it lb b be lh li l lj lk">fn add_i32(x: i32, y: i32) -&gt; i32 {<br/>    x + y<br/>}<br/><br/>fn add_f64(x: f64, y: f64) -&gt; f64 {<br/>    x + y<br/>}</span></pre><h2 id="d497" class="ll lg it bd lm ln lo dn lp lq lr dp ls kb lt lu lv kf lw lx ly kj lz ma mb mc bi translated">函数中的泛型</h2><p id="ce5d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">要在Rust中使用泛型，必须首先使用`<t>'语法在函数或结构定义中声明一个泛型类型参数。例如，下面是一个简单的函数，它采用泛型类型“t”并返回它:</t></p><pre class="kp kq kr ks gt la lb lc bn ld le bi"><span id="df4d" class="lf lg it lb b be lh li l lj lk">fn identity&lt;T&gt;(x: T) -&gt; T {<br/>    x<br/>}</span></pre><p id="1508" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，通过在调用该函数时指定类型参数，可以将该函数用于任何类型。例如:</p><pre class="kp kq kr ks gt la lb lc bn ld le bi"><span id="2b47" class="lf lg it lb b be lh li l lj lk">let x = identity(5); // x has type i32<br/>let y = identity("hello"); // y has type &amp;str</span></pre><p id="fc68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以通过用逗号分隔来指定多个泛型类型参数:</p><pre class="kp kq kr ks gt la lb lc bn ld le bi"><span id="73b6" class="lf lg it lb b be lh li l lj lk">fn pair&lt;T, U&gt;(x: T, y: U) -&gt; (T, U) {<br/>    (x, y)<br/>}<br/><br/>let x = pair(5, "hello"); // x has type (i32, &amp;str)</span></pre><h2 id="96bd" class="ll lg it bd lm ln lo dn lp lq lr dp ls kb lt lu lv kf lw lx ly kj lz ma mb mc bi translated">结构中的泛型</h2><p id="311c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">除了在函数定义中使用泛型，还可以在结构定义中使用泛型。例如，下面是一个使用泛型的简单链表实现:</p><pre class="kp kq kr ks gt la lb lc bn ld le bi"><span id="1df4" class="lf lg it lb b be lh li l lj lk">struct Node&lt;T&gt; {<br/>    value: T,<br/>    next: Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;,<br/>}</span></pre><p id="daeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本例中,“Node”结构有一个通用类型参数“t ”,它表示该节点持有的值的类型。这意味着您可以对任何类型使用“Node”结构，如下所示:</p><pre class="kp kq kr ks gt la lb lc bn ld le bi"><span id="1527" class="lf lg it lb b be lh li l lj lk">let node1 = Node { value: 5, next: None }; // node1 has type Node&lt;i32&gt;<br/>let node2 = Node { value: "hello", next: Some(Box::new(node1)) }; // node2 has type Node&lt;&amp;str&gt;</span></pre><h2 id="778f" class="ll lg it bd lm ln lo dn lp lq lr dp ls kb lt lu lv kf lw lx ly kj lz ma mb mc bi translated">性状的类属</h2><p id="5f65" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">您还可以在trait定义中使用泛型来指定开发人员可以实现trait的类型。例如，下面是一个简单的特征，它定义了一个比较两个值的方法:</p><pre class="kp kq kr ks gt la lb lc bn ld le bi"><span id="fa36" class="lf lg it lb b be lh li l lj lk">trait Comparable&lt;T&gt; {<br/>    fn cmp(&amp;self, other: &amp;T) -&gt; Ordering;<br/>}</span></pre><p id="a83a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一特征可应用于任何类型的“t ”,这些类型可以用“cmp”方法进行比较。例如，您可以为“i32”类型实现这个特征，如下所示:</p><pre class="kp kq kr ks gt la lb lc bn ld le bi"><span id="dd9b" class="lf lg it lb b be lh li l lj lk">impl Comparable&lt;i32&gt; for i32 {<br/>    fn cmp(&amp;self, other: &amp;i32) -&gt; Ordering {<br/>        self.cmp(other)<br/>    }<br/>}</span></pre><p id="0a03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，您可以将此特征用于“i32”类型，如下所示:</p><pre class="kp kq kr ks gt la lb lc bn ld le bi"><span id="7bcc" class="lf lg it lb b be lh li l lj lk">let x = 5;<br/>let y = 6;<br/><br/>if x.cmp(&amp;y) == Ordering::Less {<br/>    println!("x is less than y");<br/>}</span></pre><h2 id="352d" class="ll lg it bd lm ln lo dn lp lq lr dp ls kb lt lu lv kf lw lx ly kj lz ma mb mc bi translated">通用约束</h2><p id="1a2a" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">泛型还可以有约束，这些约束指定泛型类型为了与函数或结构一起使用而必须满足的要求。例如，您可能希望编写一个函数，它可以处理任何实现“Add”特征的类型，这允许您将同一类型的两个值相加。您可以使用“where”关键字来指定此约束:</p><pre class="kp kq kr ks gt la lb lc bn ld le bi"><span id="e061" class="lf lg it lb b be lh li l lj lk">fn add&lt;T&gt;(x: T, y: T) -&gt; T<br/>where T: Add&lt;Output=T&gt;<br/>{<br/>    x + y<br/>}</span></pre><p id="82f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该函数接受两个类型为“t”的值，并返回一个类型为“t”的值，并且它有一个约束条件，即“t”必须实现“Add”特征。这意味着您只能对实现“Add”的类型(如整数或浮点数)使用此函数。</p><p id="4808" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了使用“where”关键字之外，您还可以使用特征界限。特征界限是一种指定泛型类型必须实现特定特征的方式。例如:</p><pre class="kp kq kr ks gt la lb lc bn ld le bi"><span id="60fd" class="lf lg it lb b be lh li l lj lk">fn add&lt;T: Add&lt;Output=T&gt;&gt;(x: T, y: T) -&gt; T {<br/>    x + y<br/>}</span></pre><p id="e723" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是如何使用该函数的示例:</p><pre class="kp kq kr ks gt la lb lc bn ld le bi"><span id="208c" class="lf lg it lb b be lh li l lj lk">let x = 5;<br/>let y = 6;<br/><br/>let sum = add(x, y); // sum has type i32<br/><br/>println!("The sum is {}", sum);</span></pre><h2 id="510e" class="ll lg it bd lm ln lo dn lp lq lr dp ls kb lt lu lv kf lw lx ly kj lz ma mb mc bi translated">你想联系吗？</h2><p id="6350" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果你想联系我，请在LinkedIn上联系我。</p><p id="c598" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，可以随意查看<a class="ae mi" href="https://medium.com/@mr-pascal/my-book-recommendations-4b9f73bf961b" rel="noopener">我的书籍推荐</a>📚。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><div class="kp kq kr ks gt mq"><a href="https://mr-pascal.medium.com/my-book-recommendations-4b9f73bf961b" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">我的书籍推荐</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">在接下来的章节中，你可以找到我对所有日常生活话题的书籍推荐，它们对我帮助很大。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">mr-pascal.medium.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ky mq"/></div></div></a></div><div class="nf ng gp gr nh mq"><a href="https://mr-pascal.medium.com/membership" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">通过我的推荐链接加入Medium—Pascal Zwikirsch</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">mr-pascal.medium.com</p></div></div><div class="mz l"><div class="ni l nb nc nd mz ne ky mq"/></div></div></a></div></div></div>    
</body>
</html>