<html>
<head>
<title>How to write code that can solve logic without a loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写不用循环就能求解逻辑的代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-a-code-that-solves-logical-constraints-instead-of-testing-them-57d7575e8070?source=collection_archive---------7-----------------------#2020-04-26">https://levelup.gitconnected.com/how-to-write-a-code-that-solves-logical-constraints-instead-of-testing-them-57d7575e8070?source=collection_archive---------7-----------------------#2020-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2e58" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用整数线性规划求解复杂逻辑</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f7c3b636d2a95d187ad3555099ec22f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xNzOXA7pBrtKZNX-JW4Oqw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。</figcaption></figure><p id="b6bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">想象一下下面的场景。你有一套逻辑约束。这些约束只能通过输入变量的某种组合来满足。您需要编写返回有效输入的代码，即满足所有逻辑约束的代码。有两种方法可以进行。</p><h2 id="2f69" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">选项1:循环测试</strong></h2><p id="7d18" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">第一个想法是编写代码，根据逻辑测试每个可能的输入组合。从所有可能的输入组合列表开始，将它们传递给包含所有逻辑约束的循环，根据循环中的约束测试每个输入组合，对所有可能的组合重复该过程。最后，返回满足所有约束的组合。我们可以让这样的算法更快、更有效、更干净等等。，但这并没有反驳我们仍然在所有的可能性上运行一个循环来返回正确的输出的事实。</p><h2 id="845f" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">选项2:不测试，不循环</strong></h2><p id="5603" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这里没有任何循环。这意味着代码不需要“测试”任何东西就能得到答案的方法。不是对照逻辑约束逐一检查所有可能性，而是“解决”约束，以得出唯一可能的结果。这篇文章的目的是展示如何编写这样的代码。</p><h2 id="0eb0" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">无测试方法</h2><p id="373e" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">首先想到的是并行化。人们将并行检查逻辑约束，并得出正确的结果。问题是，即使我们将代码并行化，我们仍然会对照约束检查所有的可能性。这个循环仍然以这样或那样的形式存在。这不符合我们的目的。</p><p id="4d2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们能把逻辑约束写成线性方程会怎么样？这样做会将一堆if-else子句简化为一组线性方程。然后剩下的就是解那些线性方程组，找到正确的答案！那么有没有一种方法可以让我们同时解决所有的线性约束<em class="mp">和</em>从而得到正确的结果呢？是的有。<strong class="kx ir">同时解决一堆约束听起来很像线性规划</strong>(如果所说的约束本质上是线性的)。如果你关注了我的上一篇文章，或者曾经接触过线性编程，你就能猜到它的发展方向。正如我在上一篇文章中提到的</p><blockquote class="mr ms mt"><p id="7527" class="kv kw mp kx b ky kz jr la lb lc ju ld mu lf lg lh mv lj lk ll mw ln lo lp lq ij bi translated">线性程序为变量服从许多线性关系的问题找到最优解。</p></blockquote><p id="5142" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么，怎样才能写出线性关系形式的逻辑约束，即线性方程呢？答案是通过使用二元变量和一点创造力。让我们考虑AND逻辑门的例子。如果两个输入相同，则输出为真。在二进制形式中，我们可以把0写成假(或关)，把1写成真(或开)。因此，我可以用两个输入In1和In2来写这个门的等式，其中两个输入都可以是0或1，如下所示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">具有两个输入I1和I2的与门的线性方程。</figcaption></figure><p id="ca50" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我们已经了解了逻辑门如何转化为线性方程(以二进制变量表示)，我们就准备编写一段代码，实际上可以一次性解决一堆这样的约束条件！</p><h2 id="6851" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">挑战</h2><p id="064b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我最近在期刊<a class="ae mq" href="https://www.lasettimanaenigmistica.com/index.html?m=site" rel="noopener ugc nofollow" target="_blank">La Settimana enigstica</a>上遇到了一个难题，我想通过编写一个代码来解决这个难题，这个代码不会遍历所有的可能性，而是会得出正确的逻辑结果。我把这个问题解释如下。</p><p id="9895" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mp">一个人去集市上的旋转木马操作员那里。旋转木马操作员告诉他，谁能猜出当他打开所有5个开关时会发生什么，谁就可以终身免费乘坐。这5个开关执行以下操作:</em></p><ul class=""><li id="051a" class="mz na iq kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated"><em class="mp">开关1:黄色亮时红色亮</em></li><li id="3789" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><em class="mp">开关2:红色和绿色从不一起亮</em></li><li id="8ce1" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><em class="mp">开关3:蓝色和绿色只能一起开和关</em></li><li id="6e38" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><em class="mp">开关4:蓝色和紫色不能同时关闭</em></li><li id="cd2a" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><em class="mp">开关5:如果紫色亮起，蓝色和黄色必须亮起</em></li></ul><h2 id="5df5" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">方法:整数线性规划</h2><p id="7dca" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们将通过编写不真正“测试”任何东西的代码来解决这个问题。它只是求解方程(逻辑约束)并得出答案。</p><p id="cb70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，让我们定义彩色灯的变量</p><ul class=""><li id="c9d1" class="mz na iq kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated"><em class="mp"> Y </em>:黄色</li><li id="5408" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">R :红色</li><li id="7809" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><em class="mp"> G </em>:绿色</li><li id="6fb9" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><em class="mp"> B </em>:蓝色</li><li id="94bf" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">紫色</li></ul><p id="d427" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些灯(或变量)中的每一个都可以打开或关闭，我们进一步定义</p><ul class=""><li id="c4eb" class="mz na iq kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">值为1:开</li><li id="9be7" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">值为0:关闭</li></ul><p id="77fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过应用与与门相同的逻辑，我们将尝试理解每个开关背后的逻辑，并将其写成一个等式。这将要求我们首先写下开关允许(或不允许)什么，以及如何将这些组合表示为每个开关的线性方程。</p><p id="d3c5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">开关1:当<br/> </strong>为黄色时，开关1为红色。这允许[Y，R]有以下值:[1，1]，[0，1]，[0，0]。<br/>注意，第一种情况，黄色开，红色开。在第二种和第三种情况下，如果黄色关闭，红色可能会打开或关闭，因为如果黄色关闭，条件不会说明红色的状态。我可以把它写成方程式</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn my l"/></div></figure><p id="987a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">开关2:红色和绿色从不一起打开<br/> </strong>这允许[R，G]的以下值:[0，0]，[0，1]，[1，0]。<br/>这是因为两者可以一起关闭，但不能一起打开。以方程式的形式</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no my l"/></div></figure><p id="363d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">开关3:蓝色和绿色只能一起开和关<br/> </strong>可能的[B，G]组合有:[0，0]，[1，1]。作为一个等式</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no my l"/></div></figure><p id="cd6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">开关4:蓝色和紫色不能同时关<br/> </strong>可能的[B，P]组合有:[0，1]，[1，0]，[1，1]。条件并没有说他们在一起，因此最后一个选项。作为一个等式</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np my l"/></div></figure><p id="90a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">开关5:如果紫色打开，蓝色和黄色必须打开<br/> </strong>该条件最好被视为两个子约束的组合。<br/>如果紫色亮起，蓝色必须亮起，如果紫色亮起，黄色必须亮起。<br/>它看起来很像开关1，但我们需要应用两次逻辑，即<br/>紫色减去蓝色的最大值为0，紫色减去黄色的最大值为0。或者换句话说</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq my l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">一个特别棘手的逻辑约束。</figcaption></figure><p id="6d83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，变量的二进制性质允许我们以简单的数学形式重写逻辑约束。我们将上述4个不等式(开关1，2，4，5)和一个等式(开关3)以矩阵形式用文字表示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr my l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">问题的矩阵表述。</figcaption></figure><p id="32f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这现在开始看起来很像一个线性程序，除了所有变量只取0或1的值(灯可以开也可以关)。所有变量只能取整数值的线性规划(LP)称为整数线性规划或ILP。我们的是0–1 ILP的特例，因为为了模拟布尔逻辑，变量只允许有两个值(注意，ILP不同于混合整数线性规划或MILP，因为在MILP中，只有一些变量取整数值)。</p><p id="1bcc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">成本函数<br/> </strong>到目前为止我还没有涉及到成本函数。在线性程序中，成本函数旨在优化结果，即最小化或最大化我们正在求解的变量的线性组合。在这种特殊情况下，我们试图找到(唯一)可能的答案。那么，有什么需要优化的吗？我会说，在这种情况下，成本函数可能甚至是不必要的，因为<strong class="kx ir">我们只是在检查问题的可行性</strong>(唯一可能的答案)。因此，我将成本函数简单地定义为一个包含五个元素的矩阵，所有元素都等于0。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns my l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">成本函数矩阵。</figcaption></figure><p id="9bba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个问题现在简化为一个熟悉的LP结构</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt my l"/></div></figure><p id="4ff6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，第一个条件(最小化成本函数)纯粹是为了完整性而写的。</p><h2 id="77a1" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">用Python编写问题代码</h2><p id="1719" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我的Python设置如下</p><ul class=""><li id="2a45" class="mz na iq kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">Python 3.8.2</li><li id="f571" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">数字版本1.4.1</li><li id="d90a" class="mz na iq kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">Cvxopt 1.2.3</li></ul><p id="5878" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我之前的帖子讨论了如何使用<a class="ae mq" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linprog.html" rel="noopener ugc nofollow" target="_blank"> SciPy </a>中的优化库和<a class="ae mq" href="http://cvxopt.org" rel="noopener ugc nofollow" target="_blank"> CVXOPT </a>中的<a class="ae mq" href="https://www.gnu.org/software/glpk/" rel="noopener ugc nofollow" target="_blank"> GLPK </a>解算器在Python中实现LP。我们当前面临的问题是一个ILP，也就是说，我只允许我的变量使用整数值(0，1更具体)。Python中的SciPy实现不允许传递这样的约束。然而，这对于其他库来说当然是可能的。</p><p id="9274" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">带有GLPK求解器的CVXOPT库允许您指定哪些变量本质上是二进制的，即假设值为0或1。在我们的例子中，我们所有的5个变量本质上都是二进制的，因此二进制指数是0，1，2，3，4。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="6802" class="lr ls iq nv b gy nz oa l ob oc"># define the indices of the variables that are binary in nature<br/># in our case all 5 variables are binary</span><span id="1611" class="lr ls iq nv b gy od oa l ob oc">Binary_ind = range(5)</span><span id="883d" class="lr ls iq nv b gy od oa l ob oc"># …(rest of the code)…</span><span id="118c" class="lr ls iq nv b gy od oa l ob oc"># pass these indices to the glpk ilp solver as a set<br/># of indices under the parameter ‘B’, i.e. binary indices</span><span id="da17" class="lr ls iq nv b gy od oa l ob oc">status, solution = glpk.ilp(c, A_ineq, B_ineq, A_eq, B_eq, B=set(Binary_ind))</span></pre><p id="90e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了我们的矩阵公式和如何告诉求解器哪些变量是二进制的知识，我们现在可以编码这个问题，如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe my l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用CVXOPT和GLPK在Python中实现ILP代码。</figcaption></figure><p id="6e7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这返回</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="05d3" class="lr ls iq nv b gy nz oa l ob oc">solution found <br/>Yellow is OFF , Red is OFF , Green is ON , Blue is ON , Purple is OFF</span></pre><p id="3e09" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们找到了正确的答案！</p><p id="4879" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章(以及上一篇LP文章)的代码存放在我的<a class="ae mq" href="https://github.com/codiusmaximus/lights" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>上。</p><h2 id="94c7" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">观点</h2><p id="6027" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">一个简单的逻辑谜题促使人们探索用Python来回答它的不同方式。此外，这迫使我提出一个问题‘你能让代码模仿人类的思维过程吗？’。在我看来，在这种情况下，人类的思维过程是我们排除明显不可信的解决方案，并通过剩余的选项进行推理。ILP方法模拟了这一过程，它限制了解决方案的空间，只浏览了可能性的子集，最终得到了正确的解决方案。这与我们测试所有可能性的if-else条件的集合非常不同。因此，通过在这种情况下使用ILP，可以一次找到一组逻辑约束的似乎合理的结果，而无需实际遍历所有的可能性。</p></div></div>    
</body>
</html>