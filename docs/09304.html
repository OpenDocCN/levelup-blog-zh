<html>
<head>
<title>Typescript Tips and Tricks for JS Developers (Part2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS开发人员的Typescript提示和技巧(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-tips-and-tricks-for-js-developers-part2-d7d750769b5f?source=collection_archive---------11-----------------------#2021-07-25">https://levelup.gitconnected.com/typescript-tips-and-tricks-for-js-developers-part2-d7d750769b5f?source=collection_archive---------11-----------------------#2021-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/945947dde9d46861e9b33264373b1a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UajBGmr23t6H13E62dmYRA.png"/></div></div></figure><h1 id="0424" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍🚩：</h1><p id="fb6f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">你好，🇩🇪🇹🇳:</p><p id="7bf1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">今天我很高兴向大家介绍我的第二部分，关于打字技巧和窍门。我得到了关于<a class="ae mc" href="https://ahmedrebai.medium.com/typescript-tips-and-tricks-with-typescript-for-angular-developers-ea000f50550c" rel="noopener">第一部分</a>的积极反馈，该部分没有涵盖所有可用的技巧和Typescript提供的丰富皮肤，所以我决定添加第二部分来讨论:</p><ul class=""><li id="2fdd" class="md me it lb b lc lx lg ly lk mf lo mg ls mh lw mi mj mk ml bi translated">定制装饰</li><li id="adb5" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">更深层次的泛型(约束)</li></ul><p id="30a5" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">希望对bog ✍️亲爱的社区有帮助，阅读愉快:)</p><h1 id="01cd" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">#Tip1:自定义装饰🔧 🔨</h1><p id="d2d1" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们将从Typescript提供的一个非常有趣和有用的功能开始:“自定义装饰者”🛡🛡。</p><p id="8099" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi mr translated"><span class="l ms mt mu bm mv mw mx my mz di">D</span>T6】ecorators是一种添加注释的方式🚧和元编程语法添加到类及其属性或参数中，</p><p id="8129" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">例如，在Angular中，我们可以使用Decorators的用例列表如下:</p><ul class=""><li id="6b2c" class="md me it lb b lc lx lg ly lk mf lo mg ls mh lw mi mj mk ml bi translated">通过<code class="fe na nb nc nd b">ngOnchanges</code>跟踪组件属性变化。</li><li id="c32f" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">调用<code class="fe na nb nc nd b">unsubscribe</code>避免内存泄漏。</li><li id="739d" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">角度区域之外的复杂计算。</li><li id="9074" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">计算执行时间</li><li id="7b0e" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">处理和记录错误。</li><li id="bfbe" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">使用<em class="ne">存储API。</em></li><li id="6d06" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">页面参数</li></ul><p id="5083" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">等等…</p><p id="a525" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">问题</strong> ⛔️:</p><p id="9e5e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在开发项目中的一些特性时，您将处理日常操作、重复的任务和重复的代码🚩！这将随着项目的发展而产生不良影响！</p><p id="3f00" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">解决方案</strong> ✅:</p><p id="cd09" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">有了typescript，我们可以从定制装饰器特性中获益</p><p id="bb37" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我将展示一个如何实现<strong class="lb iu">自定义装饰器(安全)</strong>的例子</p><p id="5678" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">因此，我们将实现一个注释“Safe ”,添加该注释是为了避免在处理<strong class="lb iu">存储API </strong> ⛑时出现意外错误</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="453d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">代码解释✂️:</p><ul class=""><li id="796f" class="md me it lb b lc lx lg ly lk mf lo mg ls mh lw mi mj mk ml bi translated"><strong class="lb iu">safedirectorparams</strong>:定义可以传递给装饰者的参数类型</li><li id="f67b" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><strong class="lb iu">safedirectorloglevel</strong>:代表可用日志记录级别的枚举类型</li><li id="10ef" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><strong class="lb iu">导出函数安全&lt; T &gt; </strong>:定义我们装饰者的名字</li><li id="59a3" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><strong class="lb iu">const original method = descriptor . value</strong>:我们首先缓存原始的方法实现</li><li id="1219" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><strong class="lb iu">const log level = params . log level | | safedirectorloglevel。默认</strong>:获取当前日志级别</li><li id="5603" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><strong class="lb iu">descriptor . value = function(…args){:</strong>我们的<strong class="lb iu"> </strong>自定义逻辑(对于我们的情况，当捕获到错误时，我们将选择创建一个控制台消息或您的自定义错误处理程序，并返回我们的描述符(装饰符)</li><li id="8d65" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><strong class="lb iu">存储服务</strong>实现:</li></ul><p id="b425" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在我们将把装饰器添加到我们的<strong class="lb iu">存储服务</strong>中实现的方法中</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><ul class=""><li id="756e" class="md me it lb b lc lx lg ly lk mf lo mg ls mh lw mi mj mk ml bi translated"><strong class="lb iu">应用组件ts </strong>:</li></ul><p id="eee7" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在，我们将在app组件中注入我们的服务，并对localStorage中一个不存在的项目进行调用:“test”，然后检查两个场景(不带“@Safe”，带“@Safe”)</p><pre class="nf ng nh ni gt nl nd nm nn aw no bi"><span id="7df9" class="np kc it nd b gy nq nr l ns nt"><em class="ne">import</em> { <em class="ne">Component</em> } <em class="ne">from</em> '@angular/core';</span><span id="5c4b" class="np kc it nd b gy nu nr l ns nt"><em class="ne">import</em> { <em class="ne">StorageService</em> } <em class="ne">from</em> './services/storage.service';</span><span id="da5a" class="np kc it nd b gy nu nr l ns nt"><em class="ne">@Component</em>({</span><span id="a011" class="np kc it nd b gy nu nr l ns nt">selector: 'app-root',</span><span id="114f" class="np kc it nd b gy nu nr l ns nt">templateUrl: './app.component.html',</span><span id="9962" class="np kc it nd b gy nu nr l ns nt">styleUrls: ['./app.component.scss'],</span><span id="7239" class="np kc it nd b gy nu nr l ns nt">})</span><span id="a117" class="np kc it nd b gy nu nr l ns nt"><em class="ne">export</em> <em class="ne">class</em> AppComponent {</span><span id="ce86" class="np kc it nd b gy nu nr l ns nt"><em class="ne">title</em> <em class="ne">=</em> 'customDecoratorwith';</span><span id="5913" class="np kc it nd b gy nu nr l ns nt"><em class="ne">constructor</em>(<em class="ne">private</em> storageService<em class="ne">:</em> StorageService) {}</span><span id="ae3d" class="np kc it nd b gy nu nr l ns nt"><em class="ne">ngOnInit</em>() {</span><span id="cf9a" class="np kc it nd b gy nu nr l ns nt"><strong class="nd iu"><em class="ne">console</em>.<em class="ne">log</em>(<em class="ne">StorageService</em>.<em class="ne">getItem</em>('test'));</strong></span><span id="4483" class="np kc it nd b gy nu nr l ns nt">}</span><span id="8b7f" class="np kc it nd b gy nu nr l ns nt">}</span></pre><ul class=""><li id="7394" class="md me it lb b lc lx lg ly lk mf lo mg ls mh lw mi mj mk ml bi translated">没有<strong class="lb iu">装饰器的结果安全</strong> ✖️:</li></ul><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/c4c85a3d41eee9bda6f8099b81288fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W84z044PCr09ZADF_6GHMw.png"/></div></div></figure><ul class=""><li id="2c9c" class="md me it lb b lc lx lg ly lk mf lo mg ls mh lw mi mj mk ml bi translated">使用<strong class="lb iu">装饰器安全</strong> ✔️的结果:</li></ul><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/3f6caa83615d8f19a59f2362a5ab3a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a53PW8J04UOy-UjnZ8mVQw.png"/></div></div></figure><h1 id="f899" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">#Tip2:更深层次的泛型(约束)🔧 🔨：</h1><p id="773c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在我将试着解释一些在之前的博客中没有提到的关于类型脚本泛型的有趣的事情:"<strong class="lb iu">泛型约束</strong> " ⛏.</p><p id="5af6" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">所以正如我们所说的，TypeScript泛型帮助我们编写可重用的代码，但是有些事情我们应该考虑使用泛型🚩：</p><ol class=""><li id="d705" class="md me it lb b lc lx lg ly lk mf lo mg ls mh lw nx mj mk ml bi translated">这个函数或类是否需要处理多种数据类型<strong class="lb iu">❔</strong></li><li id="5ad9" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw nx mj mk ml bi translated">这个函数或类<strong class="lb iu">会在❔的多个地方使用吗</strong></li></ol><p id="9138" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">此外，我们可以通过使用“关键字扩展”对泛型类型参数应用约束，以进行更多的类型检查，并确保类型属性存在。</p><p id="b3f6" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">代码示例</strong>📙 ✍️:</p><p id="c42a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们正在实现一个通用函数<strong class="lb iu"> getLength(args: T) </strong>，它将返回作为<strong class="lb iu"> params </strong>传递的参数的<em class="ne">长度</em>！</p><p id="174e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">问题</strong> ⛔️:但是如果args没有长度属性！🚫 🚫</p><p id="d091" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">(将会抛出一个错误)</p><p id="7937" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">解决方案</strong> ✅:</p><p id="2801" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">定义接口<strong class="lb iu"> functtArgs </strong>用于类型检查，并通过添加</p><pre class="nf ng nh ni gt nl nd nm nn aw no bi"><span id="c110" class="np kc it nd b gy nq nr l ns nt">&lt;T extends functArgs&gt;</span></pre><p id="39e4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们告诉我们的编译器只接受具有长度属性的参数！</p><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="b8d9" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">参考文献</strong>📓 📕<strong class="ak"> : </strong></h1><ul class=""><li id="0bc7" class="md me it lb b lc ld lg lh lk ny lo nz ls oa lw mi mj mk ml bi translated"><a class="ae mc" href="https://blog.devgenius.io/custom-method-decorators-in-angular-a-http-cache-decorator-fb21d1e09932" rel="noopener ugc nofollow" target="_blank">https://blog . dev genius . io/custom-method-decorators-in-angular-a-http-cache-decorator-fb21d 1e 09932</a></li><li id="d592" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae mc" href="https://github.com/DmitriyKhirniy/typescript-decorators" rel="noopener ugc nofollow" target="_blank">https://github.com/DmitriyKhirniy/typescript-decorators</a></li><li id="90d0" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae mc" rel="noopener ugc nofollow" target="_blank" href="/building-custom-typescript-decorators-for-angular-4595816e7b87">https://level up . git connected . com/building-custom-typescript-decorators-for-angular-4595816 e7b 87</a></li><li id="bbe3" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae mc" href="https://www.typescripttutorial.net/typescript-tutorial/typescript-generics/" rel="noopener ugc nofollow" target="_blank">https://www . typescripttutorial . net/typescript-tutorial/typescript-generics/</a></li><li id="7746" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated"><a class="ae mc" href="https://blog.logrocket.com/getting-started-with-typescript-generics/" rel="noopener ugc nofollow" target="_blank">https://blog . log rocket . com/getting-started-with-typescript-generics/</a></li></ul><h1 id="e5f7" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论✍️:</h1><p id="0159" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">总之，在Typescript技巧的第2部分中，我只是试图涵盖和解释一些有趣的特性，如<strong class="lb iu">自定义装饰符</strong>和<strong class="lb iu">通用约束</strong>，这些特性在JS开发人员编写服务器端或客户端代码时会很有帮助。⛹ ⛏</p><p id="8e00" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">等待您的反馈:)</p><p id="a40f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">你可以跟着我:</p><p id="38bb" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><a class="ae mc" href="https://twitter.com/RebaiAhmed_" rel="noopener ugc nofollow" target="_blank">推特</a></p><p id="ff9c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><a class="ae mc" href="https://github.com/Rebaiahmed" rel="noopener ugc nofollow" target="_blank"> Github </a></p><p id="43ed" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">谢谢🙏</p></div></div>    
</body>
</html>