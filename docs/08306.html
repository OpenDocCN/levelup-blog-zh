<html>
<head>
<title>The Liskov Substitution Principle Made Simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">里斯科夫替代原理变得简单</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-liskov-substitution-principle-made-simple-5e69165e7ab5?source=collection_archive---------2-----------------------#2021-04-20">https://levelup.gitconnected.com/the-liskov-substitution-principle-made-simple-5e69165e7ab5?source=collection_archive---------2-----------------------#2021-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d533" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">或者什么时候扩展基类，什么时候组成对象。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb6b24e1556e81dc9ba486f61920e494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2X9Af2QGC0LaXt206Z0exg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">米海三都</figcaption></figure><p id="3ed5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最容易被忽视的固体原理的第一名是……利斯科夫替代。这里没有惊喜。</p><p id="6388" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不会用科学定义来烦你。简而言之，该原则声明所有对象类型都应该可以替换它们的子类型，而不会改变正确的行为。</p><p id="95e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理解原理的关键在于“正确的行为”。我们用一个例子来看看原理。</p><h1 id="687d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">自动驾驶系统问题</h1><p id="9784" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">作为AutoPilotCars AI初创公司软件工程团队的一部分，我们必须想出一个控制普通汽车(比如丰田凯美瑞)的解决方案。</p><p id="5189" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">经过深思熟虑，团队决定构建两个模块:</p><ul class=""><li id="2a81" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated">将汽车转换成“可驾驶”物体的模块。该模块支持四个简单的命令:前进或后退，左转或右转。</li><li id="a69f" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">自动驾驶模块计算路线，并在可驾驶模块显示的四个命令的帮助下驾驶汽车。</li></ul><p id="8e48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/e944c42a00666238c808c5920b160530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9nlNMTtxSaXmB9Sjv33eA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们必须建立两个模块:一个控制汽车，一个驾驶汽车。米海三都</figcaption></figure><p id="bee5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和一些基本的C#代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="2ba8" class="nj lw it bd lx nk nl dn mb nm nn dp mf lh no np mh ll nq nr mj lp ns nt ml nu bi translated">向卡车市场扩张</h2><p id="a01b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">由于我们的两个模块非常成功，该公司决定扩展到一个新的市场，卡车。我们观察到卡车和汽车支持相同类型的命令，所以我们想要重用自动驾驶模块并重新实现可驾驶模块。</p><p id="b56a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将把常见的抽象提取到一个单独的接口中，并让自动驾驶模块控制可驾驶的对象。以下是解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="fffe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于Car类，我们提取了“IDrivable”接口。现在，自动驾驶类依赖于IDrivable接口。到这里为止都很好。</p><p id="2ad2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事情进展得很顺利，所以我们公司想扩展到火车领域。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/fa8a9ff6726455176a134a338e1ea587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1ssa2070cIhtJ2Uhv39nQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">火车不能左转或右转。米海三都</figcaption></figure><p id="9c32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们第一次减速带。火车不能左转或右转，因为它们在轨道上。所以我们别无选择，只能忽略实现TurnLeft()和TurnRight()方法。这意味着抛出NotImplementedException或者什么都不做(因为在这种情况下，该方法返回void)。</p><h1 id="5f83" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">问题</strong></h1><p id="fd4e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">想象一下，自动驾驶模块背后有一个AI算法。经过无数个小时的训练，它终于掌握了四个方向。该模块不知道它是否控制一辆汽车、一辆卡车或一列火车，它只知道它将接收一个“可驱动的”对象。</p><p id="1dfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于汽车和卡车来说，它工作得完美无缺，但是对于火车呢？我们有两种可能的结果:</p><ul class=""><li id="4ed5" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated">如果TurnLeft()和TurnRight()方法抛出异常，它将在运行时意外地停止程序。没有用</li><li id="090f" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">如果这些方法什么都不做，算法可以学习要么忽略它们(这不好，因为在汽车和卡车上，我们不希望它们被忽略)，要么继续陷入无限循环，试图转弯。又不行了</li></ul><p id="d295" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们通过继承IDrivable接口打破了Liskov替换原则。我们的自动驾驶课程只有在我们得到一辆汽车或一辆卡车，而不是一辆火车时才起作用。</p><h2 id="9095" class="nj lw it bd lx nk nl dn mb nm nn dp mf lh no np mh ll nq nr mj lp ns nt ml nu bi translated">解决办法</h2><p id="f8e9" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们可以忽略继承Train类的IDrivable接口。这将使逻辑分离，因此所有代码看起来都没问题。但这样做也意味着我们必须为火车建造另一个自动驾驶模块。价格昂贵。</p><p id="0587" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以更新自动驾驶模块，并验证接收到的对象是否是火车。并相应地更新代码。但这是掉进兔子洞之前的第一步。如果导致另一个如果，等等，直到我们到达一个点，我们不知道wtf发生了。</p><p id="567e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也许有更好的方法。我们将在接口分离原则文章中讨论这一点。</p><h2 id="2cd0" class="nj lw it bd lx nk nl dn mb nm nn dp mf lh no np mh ll nq nr mj lp ns nt ml nu bi translated">中违反LSP的示例。NET框架</h2><p id="a536" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">有时候很难不违反原则。以微软为例。可以说，他们拥有一些世界上最好的开发人员在开发C#语言。但即使是他们也无法预见。NET框架将会发展。</p><p id="5863" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天，在。您可以调用Add()方法数组。它不会工作，它将抛出一个NotSupportException。但是为什么能做到呢？因为Array类实现了定义该方法的IList接口。</p><p id="e64d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此问题出现在。NET 2.0(当泛型被引入时)，由于微软不想打破向后兼容性，他们做出了这个妥协</p><h1 id="cb07" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">当心</h1><p id="23ef" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">避免基于类提取接口。在90%的情况下，提取的接口导致违反原则。当您寻找通用抽象时，请执行以下操作:</p><ul class=""><li id="b050" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated">应用ROT规则(三法则)。我们渴望在复制粘贴一次代码后，尽快提取代码。两个案例代表的信息太少，无法提取一个好的概括。至少等三次，甚至更多，如果你没有信心的话。</li><li id="3c39" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">并不是每一个<strong class="la iu">都是一个</strong>的关系就应该导致继承。例如，一个正方形是一个长方形，但是我们不想让一个继承另一个。矩形可以设置宽度和长度，但是这样的方法对于正方形来说是不好的。有时候最好把事情分开。</li><li id="ed1a" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">在编写接口或建立类层次结构之前，从客户的角度来看你的类API。</li></ul><p id="9c3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，有时你别无选择，只能打破LSP。它发生在我们最好的人身上。就像微软不想打破旧的合同，并保持或保持框架停止，你可能会面临唯一的出路是打破它的情况。尽你所能让你的客户知道并继续前进。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="9a24" class="lv lw it bd lx ly od ma mb mc oe me mf jz of ka mh kc og kd mj kf oh kg ml mm bi translated">外卖食品</h1><ul class=""><li id="164c" class="ms mt it la b lb mn le mo lh oi ll oj lp ok lt mx my mz na bi translated">通常，当我们试图移除特征时，LSP被违反。NotImplementedException(或类似的)是最大的违规标志。</li><li id="9461" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">避免从类中提取接口。寻找共同的抽象。应用ROT <em class="ol">(三原则- &gt;在提取抽象之前至少复制粘贴三次)</em></li><li id="2464" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">面对较大的界面，支持多个较小的界面；它不太可能违反原则(将在接口隔离原则中详细讨论)</li><li id="9206" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">违反原则几乎总是会导致难以发现的错误。</li></ul></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="170b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">扎实的原理制作简单的系列:</strong></p><ul class=""><li id="e4ba" class="ms mt it la b lb lc le lf lh mu ll mv lp mw lt mx my mz na bi translated"><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/the-single-responsibility-principle-made-simple-4e1597a44d7d">单一责任原则</a> (SRP)</li><li id="2b0b" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated"><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/the-open-closed-principle-made-simple-cc3d0ed70553">开闭原理</a> (OCP)</li><li id="0ac8" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated">利斯科夫替代原理(LSP)</li><li id="6827" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated"><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/interface-segregation-principle-made-simple-990da495441c">接口隔离原理</a> (ISP)</li><li id="f01d" class="ms mt it la b lb nb le nc lh nd ll ne lp nf lt mx my mz na bi translated"><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/the-dependency-inversion-principle-made-simple-70108b88dc76">依存倒置原则</a> (DIP)</li></ul></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="46b3" class="lv lw it bd lx ly od ma mb mc oe me mf jz of ka mh kc og kd mj kf oh kg ml mm bi translated">进一步阅读</h1><div class="om on gp gr oo op"><a href="https://blog.ndepend.com/solid-design-the-liskov-substitution-principle/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">固体设计:利斯科夫替代原理(LSP) - NDepend</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">利斯科夫替代原理是众所周知的固体首字母缩略词中的L。最初的原则定义是…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">blog.ndepend.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a href="https://stackify.com/solid-design-liskov-substitution-principle/" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">坚实的设计原则解释:利斯科夫替代原则与代码示例</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">所有5个坚实的设计原则被广泛使用，如果你不知道他们的名字，你会很快认识到他们…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">stackify.com</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a href="https://www.baeldung.com/java-liskov-substitution-principle" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">Java中的Liskov替换原则| Baeldung</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">Robert C. Martin在他2000年的论文《设计原则和设计…》中介绍了可靠的设计原则</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">www.baeldung.com</p></div></div><div class="oy l"><div class="pf l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>