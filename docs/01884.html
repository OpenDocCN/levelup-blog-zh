<html>
<head>
<title>Create a CI/CD Pipeline with Kubernetes and Jenkins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Kubernetes和Jenkins一起创建CI/CD渠道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-a-ci-cd-pipeline-with-kubernetes-and-jenkins-e16ae96bc51e?source=collection_archive---------10-----------------------#2020-02-04">https://levelup.gitconnected.com/create-a-ci-cd-pipeline-with-kubernetes-and-jenkins-e16ae96bc51e?source=collection_archive---------10-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b293" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">本文原载于</em><a class="ae kp" href="https://www.magalix.com/blog/create-a-ci/cd-pipeline-with-kubernetes-and-jenkins" rel="noopener ugc nofollow" target="_blank">https://www . magalix . com/blog/create-a-ci/CD-pipeline-with-kubernetes-and-Jenkins</a></p><p id="e426" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CI/CD是一个经常和其他术语一起出现的术语，比如DevOps、敏捷、Scrum和看板、自动化等等。有时，它被认为只是工作流程的一部分，而没有真正理解它是什么或者为什么要采用它。对于年轻的DevOps工程师来说，将CI/CD视为理所当然是很常见的，他们可能没有见过软件发布周期的“传统”方式，因此不能欣赏CI/CD。</p><p id="07f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CI/CD代表持续集成/持续交付和/或部署。不实施CI/CD的团队在创建新的软件产品时必须经过以下阶段:</p><ol class=""><li id="f196" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">产品经理(代表客户的利益)提供产品应该具备的必要特性和应该遵循的行为。文档必须尽可能全面和具体。</li><li id="fbec" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">开发人员和业务分析师通过编写代码、运行单元测试并将结果提交给版本控制系统(例如git)来开始应用程序的工作。</li><li id="d584" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">一旦开发阶段完成，项目就转移到QA阶段。针对产品运行了几个测试，比如用户验收测试、集成测试、性能测试等等。在此期间，在QA阶段完成之前，不应对代码库进行任何更改。如果有任何bug，它们会被传回给开发人员来修复，然后将产品交还给QA。</li><li id="2fab" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">QA完成后，运营团队将代码部署到生产环境中。</li></ol><p id="5fdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述工作流程有许多缺点:</p><ul class=""><li id="5624" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn le kw kx ky bi translated">首先，从产品经理提出要求到产品准备生产需要很长时间。</li><li id="a4cf" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">对于开发人员来说，解决一个月或更久以前编写的代码中的错误是很难的。记住，bug只有在开发阶段结束，QA阶段开始后才能被发现。</li><li id="e2de" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">当有一个<em class="ko">紧急</em>代码变更时，比如一个需要修补的严重错误，由于需要尽快部署，QA阶段往往会缩短。</li><li id="cf2d" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">由于不同团队之间很少协作，当出现bug时，人们开始相互指责。每个人都开始只关心项目中他/她自己的部分，而忽略了共同的目标。</li></ul><p id="fda4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CI/CD通过引入自动化解决了上述问题。代码中的每个更改一旦被推送到版本控制系统，就会得到测试，并进一步部署到登台/UAT环境中进行进一步的测试，然后再部署到生产环境中供用户使用。自动化确保整个过程快速、可靠、可重复，并且更不容易出错。</p><p id="9971" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于这个主题已经有了完整的书籍。如何、为什么以及何时在您的基础架构中实施它。然而，只要有可能，我们总是喜欢少理论，多实践。话虽如此，以下是提交代码更改后应执行的自动化步骤的简要描述:</p><ol class=""><li id="3ac3" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated"><strong class="js iu">持续集成(CI): </strong>第一步不包括QA。换句话说，它并不关注代码是否提供了客户所要求的特性。相反，它确保了代码的高质量。通过单元测试、集成测试，开发人员很快就会被告知代码质量中的任何问题。我们可以用代码覆盖率和静态分析来进一步增加测试，以获得更多的质量保证。</li><li id="061a" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated"><strong class="js iu">用户验收测试:</strong>这是CD流程的第一部分。在这个阶段，对代码执行自动化测试，以确保它满足客户的期望。例如，一个web应用程序可以正常工作而不抛出任何错误，但是客户希望访问者在导航到主页面之前看到一个提供报价的登录页面。当前代码将访问者直接带到主页面，这偏离了客户的需求。UAT测试指出了这类问题。在非CD环境中，这是人类QA测试人员的工作。</li><li id="5fb1" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated"><strong class="js iu">部署:</strong>这是CD流程的第二部分。它包括对将要托管应用程序的服务器/pod/容器进行更改，以便它们反映更新的版本。这应该以自动化的方式完成，最好是通过配置管理工具，如Ansible、Chef或Puppet。</li></ol><p id="16ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">管道是一个非常简单的概念的花哨术语；当您有许多脚本需要按照一定的顺序执行来实现一个共同的目标时，它们被统称为“管道”。例如，在Jenkins中，一个管道可能由一个或多个<em class="ko">阶段</em>组成，这些阶段必须全部完成，构建才能成功。使用阶段有助于可视化整个过程，了解每个阶段需要多长时间，并确定构建失败的确切位置。</p><p id="9eb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本实验室中，我们将构建一个持续交付(CD)管道。我们正在使用一个用Go编写的非常简单的应用程序。为了简单起见，我们将只对代码运行一种类型的测试。本实验的先决条件如下:</p><ul class=""><li id="a31f" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn le kw kx ky bi translated">正在运行的Jenkins实例。这可以是云实例、虚拟机、裸机或docker容器。它必须可以从互联网上公开访问，以便存储库可以通过web-hooks连接到Jenkins。</li><li id="9700" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">图像注册中心:你可以使用Docker Registry，一个基于云的产品，比如<a class="ae kp" href="https://aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank"> ECR </a>或者<a class="ae kp" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank"> GCR </a>，或者甚至是一个定制的注册中心。</li><li id="f4af" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">GitHub上的一个账号。虽然我们在这个例子中使用GitHub，但是这个过程只需稍加修改就可以与其他存储库(如Bitbucket)一起工作。</li></ul><p id="c4ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">管道可以描述如下:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/b3383a14dd6aae27cfbb27347bedccc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/0*AWR1qIR1roSl9w-g.png"/></div></figure><h1 id="8570" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">步骤01:应用程序文件</h1><p id="5af7" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">我们的示例应用程序将使用“Hello World”来响应任何GET请求。创建一个名为main.go的新文件，并添加以下几行:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="c75c" class="mv lo it mr b gy mw mx l my mz">package main</span><span id="d630" class="mv lo it mr b gy na mx l my mz">import (<br/>   "log"<br/>   "net/http"<br/>)</span><span id="8748" class="mv lo it mr b gy na mx l my mz">type Server struct{}</span><span id="d1eb" class="mv lo it mr b gy na mx l my mz">func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {<br/>   w.WriteHeader(http.StatusOK)<br/>   w.Header().Set("Content-Type", "application/json")<br/>   w.Write([]byte(`{"message": "hello world"}`))<br/>}</span><span id="f476" class="mv lo it mr b gy na mx l my mz">func main() {<br/>   s := &amp;Server{}<br/>   http.Handle("/", s)<br/>   log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span></pre><p id="40bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们正在构建一个CD管道，所以我们应该有一些测试。我们的代码非常简单，只需要一个测试用例；确保我们在点击根URL时收到正确的字符串。在同一个目录中创建一个名为main_test.go的新文件，并添加以下几行:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="4cf2" class="mv lo it mr b gy mw mx l my mz">package main</span><span id="bb20" class="mv lo it mr b gy na mx l my mz">import (<br/>   "log"<br/>   "net/http"<br/>)</span><span id="8dda" class="mv lo it mr b gy na mx l my mz">type Server struct{}</span><span id="fd78" class="mv lo it mr b gy na mx l my mz">func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {<br/>   w.WriteHeader(http.StatusOK)<br/>   w.Header().Set("Content-Type", "application/json")<br/>   w.Write([]byte(`{"message": "hello world"}`))<br/>}</span><span id="bae8" class="mv lo it mr b gy na mx l my mz">func main() {<br/>   s := &amp;Server{}<br/>   http.Handle("/", s)<br/>   log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span></pre><p id="6fee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还有一些其他文件可以帮助我们部署应用程序，它们的名称是:</p><p id="95f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">docker file</strong></p><p id="1028" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们打包应用程序的地方:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="f9a7" class="mv lo it mr b gy mw mx l my mz">FROM golang:alpine AS build-env<br/>RUN mkdir /go/src/app &amp;&amp; apk update &amp;&amp; apk add git<br/>ADD main.go /go/src/app/<br/>WORKDIR /go/src/app<br/>RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags '-extldflags "-static"' -o app .</span><span id="2242" class="mv lo it mr b gy na mx l my mz">FROM scratch<br/>WORKDIR /app<br/>COPY --from=build-env /go/src/app/app .<br/>ENTRYPOINT [ "./app" ]</span></pre><p id="a59f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Dockerfile是一个<a class="ae kp" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多级</a>文件，以保持图像尺寸尽可能小。它从基于golang:alpine的构建图像开始。生成的二进制文件用于第二个图像，这只是一个<a class="ae kp" href="https://hub.docker.com/_/scratch/" rel="noopener ugc nofollow" target="_blank">临时的</a>图像。临时映像不包含依赖项或库，只包含启动应用程序的二进制文件。</p><p id="a7ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">服务</strong></p><p id="6189" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们使用Kubernetes作为托管这个应用程序的平台，所以我们至少需要一个服务和一个部署。我们的service.yml文件如下所示:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="dff3" class="mv lo it mr b gy mw mx l my mz">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: hello-svc<br/>spec:<br/>  selector:<br/>    role: app<br/>  ports:<br/>    - protocol: TCP<br/>      port: 80<br/>      targetPort: 8080<br/>      nodePort: 32000<br/>  type: NodePort</span></pre><p id="82d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个定义没什么特别的。只是一个使用NodePort作为其类型的服务。它将监听任何群集节点的IP地址上的端口32000。传入的连接被中继到端口8080上的pod。对于内部通信，该服务侦听端口80。</p><p id="3e9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">部署</strong></p><p id="5b6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">应用程序本身一旦被docker化，就可以通过部署资源部署到Kubernetes。deployment.yml文件如下所示:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="1313" class="mv lo it mr b gy mw mx l my mz">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: hello-deployment<br/>  labels:<br/>    role: app<br/>spec:<br/>  replicas: 2<br/>  selector:<br/>    matchLabels:<br/>      role: app<br/>  template:<br/>    metadata:<br/>      labels:<br/>        role: app<br/>    spec:<br/>      containers:<br/>      - name: app<br/>        image: ""<br/>        resources:<br/>          requests:<br/>            cpu: 10m</span></pre><p id="24a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个部署定义最有趣的地方是图像部分。我们使用了一个变量，而不是硬编码图像名称和标签。稍后，我们将看到如何使用这个定义作为Ansible的模板，并通过命令行参数替换映像名称(以及部署的任何其他参数)。</p><p id="2ba7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">战术手册</strong></p><p id="55ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本实验中，我们使用Ansible作为部署工具。部署Kubernetes资源还有很多其他方式，包括<a class="ae kp" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank">掌舵图</a>，但我认为Ansible是一个更简单的选择。Ansible使用剧本来组织它的指令。我们的playbook.yml文件如下所示:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="9378" class="mv lo it mr b gy mw mx l my mz">- hosts: localhost<br/>  tasks:<br/>  - name: Deploy the service<br/>    k8s:<br/>      state: present<br/>      definition: ""<br/>      validate_certs: no<br/>      namespace: default<br/>  - name: Deploy the application<br/>    k8s:<br/>      state: present<br/>      validate_certs: no<br/>      namespace: default<br/>      definition: ""</span></pre><p id="e9e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Ansible已经包含了<a class="ae kp" href="https://docs.ansible.com/ansible/latest/modules/k8s_module.html" rel="noopener ugc nofollow" target="_blank"> k8s模块</a>，用于处理与Kubernetes API服务器的通信。因此，我们不需要安装<a class="ae kp" href="https://kubernetes.io/docs/reference/kubectl/overview/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>，但是我们需要一个有效的kubeconfig文件来连接到集群(稍后会详细介绍)。让我们快速讨论一下本行动手册的重要部分:</p><ul class=""><li id="4671" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn le kw kx ky bi translated">行动手册用于向集群部署服务和资源。</li><li id="8331" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">由于我们需要在执行时将数据动态地注入到定义文件中，所以我们需要将我们的定义文件用作模板，其中变量可以从外部提供。</li><li id="cfdd" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">为此，Ansible提供了lookup函数，您可以将有效的YAML文件作为模板传递。Ansible支持多种将变量注入模板的方式。在这个特定的实验中，我们使用命令行方法。</li></ul><h1 id="5f50" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">步骤2:安装Jenkins、Ansible和Docker</h1><p id="5d5b" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">让我们安装Ansible并使用它来自动部署一个Jenkins服务器和Docker运行时环境。我们还需要安装openshift Python模块，使Ansible能够与Kubernetes连接。</p><p id="1269" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Ansible的安装非常容易；只需安装Python并使用pip安装Ansible:</p><ol class=""><li id="8724" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">登录到Jenkins实例</li><li id="59fd" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">安装Python 3、Ansible和openshift模块:</li></ol><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="8ebc" class="mv lo it mr b gy mw mx l my mz">sudo apt update &amp;&amp; sudo apt install -y python3 &amp;&amp; sudo apt install -y python3-pip &amp;&amp; sudo pip3 install ansible &amp;&amp; sudo pip3 install openshift</span></pre><p id="86ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.默认情况下，pip将二进制文件安装在用户主文件夹的隐藏目录下。我们需要将这个目录添加到$PATH变量中，这样我们就可以轻松地调用命令:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="eaff" class="mv lo it mr b gy mw mx l my mz">echo "export PATH=$PATH:~/.local/bin" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc</span></pre><p id="e9ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.安装部署Jenkins实例所需的Ansible角色:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="41cc" class="mv lo it mr b gy mw mx l my mz">ansible-galaxy install geerlingguy.jenkins</span></pre><p id="01b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.安装Docker角色:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="1381" class="mv lo it mr b gy mw mx l my mz">ansible-galaxy install geerlingguy.docker</span></pre><p id="2eda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">6.创建行动手册。YAML文件并添加以下几行:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="1457" class="mv lo it mr b gy mw mx l my mz">- hosts: localhost<br/>  become: yes<br/>  vars:<br/>    jenkins_hostname: 35.238.224.64<br/>    docker_users:<br/>    - jenkins<br/>  roles:<br/>    - role: geerlingguy.jenkins<br/>    - role: geerlingguy.docker</span></pre><p id="d285" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">7.通过以下命令运行剧本:ansible-playbook playbook.yaml。注意，我们使用实例的公共IP地址作为Jenkins将使用的主机名。如果使用DNS，可能需要用实例的DNS名称替换它。另外，请注意，在运行行动手册之前，您必须在防火墙上启用端口8080(如果有)。</p><p id="1393" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">8.几分钟后，詹金斯应该安装完毕。您可以通过导航到机器的IP地址(或DNS名称)并指定端口8080来进行检查:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/a9020ad649e5c6ef5744255a19b4ef72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-L5X6MBJrOSk_1iX.png"/></div></div></figure><p id="461c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">9.单击登录链接，提供用户名“admin”和密码“admin”。请注意，这些是由我们使用的Ansible角色设置的默认凭据。在生产环境中使用Jenkins时，您可以(也应该)更改这些默认值。这可以通过设置角色变量来实现。可以参考<a class="ae kp" href="https://galaxy.ansible.com/geerlingguy/jenkins" rel="noopener ugc nofollow" target="_blank">角色官方页面</a>。</p><p id="7d39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">10.您需要做的最后一件事是安装以下将在我们的实验室中使用的插件:</p><ul class=""><li id="1055" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn le kw kx ky bi translated">饭桶</li><li id="de55" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">管道</li><li id="ad8a" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">CloudBees Docker构建和发布</li><li id="2232" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">开源代码库</li></ul><h1 id="7b87" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">步骤03:配置Jenkins用户以连接到集群</h1><p id="7217" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">如前所述，本实验假设您已经启动并运行了一个Kubernetes集群。为了使Jenkins能够连接到这个集群，我们需要添加必要的kubeconfig文件。在这个特定的实验中，我们使用的是托管在Google Cloud上的Kubernetes集群，因此我们使用gcloud命令。你的具体情况可能不同。但是在任何情况下，我们都必须将kubeconfig文件复制到Jenkins的用户目录中，如下所示:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="8786" class="mv lo it mr b gy mw mx l my mz">$ sudo cp ~/.kube/config ~jenkins/.kube/<br/>$ sudo chown -R jenkins: ~jenkins/.kube/</span></pre><p id="ed30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，您将在此使用的帐户必须拥有创建和管理部署和服务的必要权限。</p><h1 id="33ad" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">步骤04:创建Jenkins管道作业</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/220ce1fcca8c5b23fa3f521d9a1123d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ClAqLeCY4tT_UoUF.png"/></div></div></figure><p id="4c6f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建新的Jenkins作业并选择管道类型。作业设置应该如下所示:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/998e5daa5f87d6e5fb40e14893560150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j5i8O4zmfZP1kmNr.png"/></div></div></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/9fc91441fbbc99f7ba453e62ee0b0371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o82mjQoJ0fTA4I02.png"/></div></div></figure><p id="c174" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们更改的设置是:</p><ul class=""><li id="413e" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn le kw kx ky bi translated">我们使用Poll SCM作为构建触发器；设置该选项指示Jenkins定期检查Git存储库(每分钟* * * * *)一次。如果自上次轮询以来回购发生了更改，则触发该作业。</li><li id="be87" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">在管道本身中，我们指定了存储库URL和凭证。树枝是主人。</li><li id="a288" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">在本实验中，我们将作业的所有代码添加到Jenkinsfile中，该文件与代码存储在同一个存储库中。本文稍后将讨论Jenkinsfile。</li></ul><h1 id="ba39" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">步骤05:为GitHub和Docker Hub配置Jenkins凭证</h1><p id="8f92" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">转到<a class="ae kp" href="http://35.238.224.64:8080/credentials/store/system/domain/_/newCredentials" rel="noopener ugc nofollow" target="_blank">/credentials/store/system/domain/_/new credentials</a>并将凭证添加到两个目标。请确保为每个文件提供一个有意义的ID和描述，因为您稍后会引用它们:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/05c154c91fbc89e0b004c91cfbe2e4e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TMRCnIFctV4VkVUA.png"/></div></div></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/d4ac3774ae0249ed2e1c9890b1710808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iuDzf3Fuj4NHQG2i.png"/></div></div></figure><h1 id="d24d" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">步骤06:创建JenkinsFile</h1><p id="253f" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">Jenkinsfile指导Jenkins如何构建、测试、归档、发布和交付我们的应用程序。我们的Jenkinsfile如下所示:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="7e25" class="mv lo it mr b gy mw mx l my mz">pipeline {<br/>   agent any<br/>   environment {<br/>       registry = "magalixcorp/k8scicd"<br/>       GOCACHE = "/tmp"<br/>   }<br/>   stages {<br/>       stage('Build') {<br/>           agent {<br/>               docker {<br/>                   image 'golang'<br/>               }<br/>           }<br/>           steps {<br/>               // Create our project directory.<br/>               sh 'cd ${GOPATH}/src'<br/>               sh 'mkdir -p ${GOPATH}/src/hello-world'<br/>               // Copy all files in our Jenkins workspace to our project directory.               <br/>               sh 'cp -r ${WORKSPACE}/* ${GOPATH}/src/hello-world'<br/>               // Build the app.<br/>               sh 'go build'              <br/>           }    <br/>       }<br/>       stage('Test') {<br/>           agent {<br/>               docker {<br/>                   image 'golang'<br/>               }<br/>           }<br/>           steps {                <br/>               // Create our project directory.<br/>               sh 'cd ${GOPATH}/src'<br/>               sh 'mkdir -p ${GOPATH}/src/hello-world'<br/>               // Copy all files in our Jenkins workspace to our project directory.               <br/>               sh 'cp -r ${WORKSPACE}/* ${GOPATH}/src/hello-world'<br/>               // Remove cached test results.<br/>               sh 'go clean -cache'<br/>               // Run Unit Tests.<br/>               sh 'go test ./... -v -short'           <br/>           }<br/>       }<br/>       stage('Publish') {<br/>           environment {<br/>               registryCredential = 'dockerhub'<br/>           }<br/>           steps{<br/>               script {<br/>                   def appimage = docker.build registry + ":$BUILD_NUMBER"<br/>                   docker.withRegistry( '', registryCredential ) {<br/>                       appimage.push()<br/>                       appimage.push('latest')<br/>                   }<br/>               }<br/>           }<br/>       }<br/>       stage ('Deploy') {<br/>           steps {<br/>               script{<br/>                   def image_id = registry + ":$BUILD_NUMBER"<br/>                   sh "ansible-playbook  playbook.yml --extra-vars \"image_id=${image_id}\""<br/>               }<br/>           }<br/>       }<br/>   }<br/>}</span></pre><p id="5fce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个文件比看起来容易。基本上，管道包含四个阶段:</p><ol class=""><li id="6fb1" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">构建是我们构建Go二进制文件并确保在构建过程中没有任何错误的地方。</li><li id="76e2" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">在测试中，我们应用一个简单的UAT测试来确保应用程序按预期工作。</li><li id="dc85" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">发布，在这里构建Docker映像并将其推送到注册中心。之后任何环境都可以利用。</li><li id="a73d" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">部署，这是调用Ansible联系Kubernetes并应用定义文件的最后一步。</li></ol><p id="c7a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们讨论这个Jenkinsfile文件的重要部分:</p><ul class=""><li id="6b66" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn le kw kx ky bi translated">前两个阶段大体相似。他们都使用golang Docker映像来构建/测试应用程序。让stage在Docker容器中运行总是一个好的做法，该容器已经包含了所有必需的构建和测试工具。另一种选择是将这些工具安装在主服务器或其中一个从服务器上。当您需要针对不同的工具版本进行测试时，问题就开始出现了。例如，也许我们想使用Go 1.9构建和测试我们的代码，因为我们的应用程序还不能使用最新的Golang版本。在一个图像中包含所有内容使得改变版本甚至图像类型就像改变一个字符串一样简单。</li><li id="c5dd" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">发布阶段(从第42行开始)从指定一个环境变量开始，该变量将在后面的步骤中使用。变量指向我们在前面的步骤中添加到Jenkins的Docker Hub凭证的ID。</li><li id="6682" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">第48行:我们使用docker插件来构建图像。默认情况下，它使用注册表中的Dockerfile，并添加内部版本号作为图像标签。稍后，当您需要确定哪个Jenkins版本是当前运行的容器的源时，这将非常重要。</li><li id="8335" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">第49–51行:映像构建成功后，我们使用构建号将其推送到Docker Hub。此外，我们将“latest”标签添加到图像中(第二个标签),这样我们允许用户在不指定构建号的情况下获取图像，如果他们需要的话。</li><li id="ac13" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">第56–60行:部署阶段是我们将部署和服务定义文件应用到集群的阶段。我们使用前面讨论过的剧本来调用Ansible。注意，我们将image_id作为命令行变量传递。该值会自动替换部署文件中的映像名称。</li></ul><p id="b6c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文的最后一部分是我们实际测试工作的地方。我们将把我们的代码提交给GitHub，并确保我们的代码通过管道，直到它到达集群:</p><ol class=""><li id="777b" class="kq kr it js b jt ju jx jy kb ks kf kt kj ku kn kv kw kx ky bi translated">添加我们的文件:git add *</li><li id="f06f" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">提交我们的更改:git commit -m“初始提交”</li><li id="16c2" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">推送至GitHub: git push</li><li id="38ea" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">在Jenkins上，我们可以等待作业自动触发，也可以直接点击“立即构建”。</li><li id="a75f" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn kv kw kx ky bi translated">如果作业成功，我们可以使用以下命令检查部署的应用程序:</li></ol><p id="9fb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">获取节点IP地址:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="1080" class="mv lo it mr b gy mw mx l my mz">kubectl get nodes -o wide<br/>NAME                                          STATUS   ROLES    AGE   VERSION          INTERNAL-IP   EXTERNAL-IP     OS-IMAGE                             KERNEL-VERSION   CONTAINER-RUNTIME<br/>gke-security-lab-default-pool-46f98c95-qsdj   Ready       7d    v1.13.11-gke.9   10.128.0.59   35.193.211.74   Container-Optimized OS from Google   4.14.145+        docker://18.9.7</span></pre><p id="f3b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们向我们的应用程序发起一个HTTP请求:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="2d68" class="mv lo it mr b gy mw mx l my mz">$ curl 35.193.211.74:32000<br/>{"message": "hello world"}</span></pre><p id="ef5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，我们可以看到我们的应用程序工作正常。让我们在代码中故意犯一个错误，并确保管道不会将错误代码发送到目标环境:</p><p id="474e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将应该显示的消息更改为“Hello World！”请注意，我们将每个单词的第一个字母大写，并在末尾添加了一个感叹号。因为我们的客户可能不希望消息以这种方式显示，所以管道应该在测试阶段停止。</p><p id="6e30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们做出改变。main.go文件现在应该是这样的:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="df18" class="mv lo it mr b gy mw mx l my mz">package main</span><span id="b01b" class="mv lo it mr b gy na mx l my mz">import (<br/>   "log"<br/>   "net/http"<br/>)</span><span id="87ba" class="mv lo it mr b gy na mx l my mz">type Server struct{}</span><span id="1e6a" class="mv lo it mr b gy na mx l my mz">func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {<br/>   w.WriteHeader(http.StatusOK)<br/>   w.Header().Set("Content-Type", "application/json")<br/>   w.Write([]byte(`{"message": "Hello World!"}`))<br/>}</span><span id="c26c" class="mv lo it mr b gy na mx l my mz">func main() {<br/>   s := &amp;Server{}<br/>   http.Handle("/", s)<br/>   log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span></pre><p id="9f77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们提交并推送我们的代码:</p><pre class="lg lh li lj gt mq mr ms mt aw mu bi"><span id="9416" class="mv lo it mr b gy mw mx l my mz">$ git add main.go<br/>$ git commit -m "Changes the greeting message"                                                                                                       <br/>[master 24a310e] Changes the greeting message<br/> 1 file changed, 1 insertion(+), 1 deletion(-)<br/>$ git push<br/>Counting objects: 3, done.<br/>Delta compression using up to 4 threads.<br/>Compressing objects: 100% (3/3), done.<br/>Writing objects: 100% (3/3), 319 bytes | 319.00 KiB/s, done.<br/>Total 3 (delta 2), reused 0 (delta 0)<br/>remote: Resolving deltas: 100% (2/2), completed with 2 local objects.<br/>To <a class="ae kp" href="https://github.com/MagalixCorp/k8scicd.git" rel="noopener ugc nofollow" target="_blank">https://github.com/MagalixCorp/k8scicd.git</a><br/>   7954e03..24a310e  master -&gt; master</span></pre><p id="bb01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到Jenkins，我们可以看到最后一次构建失败了:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/bd09de9cf1224da76e5c163de61c36ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H8nGfcnNC9Kte6uI.png"/></div></div></figure><p id="2ead" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过单击失败的作业，我们可以看到失败的原因:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nb"><img src="../Images/2c84d5394242c43b39542f9046c9950e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d-97lKlxdr9cZL3r.png"/></div></div></figure><p id="29d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的错误代码永远不会到达目标环境。</p><h1 id="c536" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="819d" class="kq kr it js b jt ml jx mm kb ng kf nh kj ni kn le kw kx ky bi translated">CI/CD是任何遵循敏捷方法的现代环境中不可或缺的一部分。</li><li id="0897" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">通过管道，您可以确保代码从版本控制系统到目标环境(测试/试运行/生产等)的平稳过渡。)同时应用所有必要的测试和质量控制实践。</li><li id="cf85" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">在本文中，我们有一个实际的实验室，在那里我们构建了一个连续的交付管道来部署Golang应用程序。</li><li id="e1fe" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">通过Jenkins，我们能够从存储库中提取代码，使用相关的Docker映像进行构建和测试。</li><li id="7740" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">接下来，我们将我们的应用程序进行Docker化并推送到Docker Hub，因为它已经通过了我们的测试。</li><li id="9443" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">最后，我们使用Ansible将应用程序部署到运行Kubernetes的目标环境中。</li><li id="2420" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">使用Jenkins pipelines和Ansible可以非常容易和灵活地改变工作流，而几乎没有摩擦。例如，我们可以在测试阶段添加更多的测试，我们可以更改用于构建和测试代码的Go版本，我们可以使用更多的变量来更改部署和服务定义的其他方面。</li><li id="635d" class="kq kr it js b jt kz jx la kb lb kf lc kj ld kn le kw kx ky bi translated">这里最好的部分是我们使用Kubernetes部署，这确保我们在更改容器映像时应用程序不会停机。这是可能的，因为部署默认情况下使用滚动更新方法一次终止和重新创建一个容器。只有当新容器正常运行时，部署才会终止旧容器。</li></ul></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="a43d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">原载于2020年2月4日</em><a class="ae kp" href="https://www.magalix.com/blog/create-a-ci/cd-pipeline-with-kubernetes-and-jenkins" rel="noopener ugc nofollow" target="_blank"><em class="ko">【https://www.magalix.com】</em></a><em class="ko">。</em></p></div></div>    
</body>
</html>