<html>
<head>
<title>Learning C++: The STL and the Array Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL和数组类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-the-stl-and-the-array-class-f35a1dcb8663?source=collection_archive---------14-----------------------#2020-04-04">https://levelup.gitconnected.com/learning-c-the-stl-and-the-array-class-f35a1dcb8663?source=collection_archive---------14-----------------------#2020-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/26ba789de9bdd251c7bce5676098683b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zISVPqQ-1jpLPh8H"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@nicogiras?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Nico Giras </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="845a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">C++的内置(原始)数组有一些缺陷，这使得它很难在许多程序中使用。原始数组的一个主要问题是没有返回数组大小的函数。这意味着当你需要数组的大小来控制for循环时，你必须使用存储数组大小的变量或常量。原始数组的另一个问题是，你不能把数组传递给一个函数，你还必须传递它的大小。不能在函数中使用带有原始数组的range for循环，因为函数不能访问设置迭代器所需的信息。</p><p id="8770" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用原始数组的一个解决方案是使用属于标准模板库(STL)及其容器集的<code class="fe le lf lg lh b">array</code>类。在这篇文章中，我将介绍如何在你的C++程序中使用这个类。</p><h1 id="2a74" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">array类的功能</h1><p id="ea34" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">array</code>类是STL中的一个模板类。它被认为是STL容器类中的一个，所以它有许多与其他STL容器相同的特性，比如<code class="fe le lf lg lh b">vector</code>类。如果你需要一个固定的数字序列，那么应该选择<code class="fe le lf lg lh b">array</code>类而不是其他STL容器，因为像原始数组一样，<code class="fe le lf lg lh b">array</code>类提供随机访问，并且用于存储其元素的内存是在堆栈上分配的，因为不需要像<code class="fe le lf lg lh b">vector</code>类那样重新分配内存。</p><h1 id="83eb" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">创建数组类对象</h1><p id="e4a3" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">创建新的<code class="fe le lf lg lh b">array</code>对象有几种方法。一种方法是用数据类型和大小(元素数量)来声明对象，就像这样:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="dacb" class="mt lj it lh b gy mu mv l mw mx">array&lt;int, 10&gt; numbers;</span></pre><p id="f032" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">numbers</code>数组被分配来存储10个整数。该对象还自动初始化为<code class="fe le lf lg lh b">int</code>数据类型的默认值，因此数组中存储了10个零。</p><p id="037c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以使用初始化列表用数据初始化一个新的<code class="fe le lf lg lh b">array</code>对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6fa3" class="mt lj it lh b gy mu mv l mw mx">array&lt;int, 5&gt; numbers {1,2,3,4,5};</span></pre><p id="a42b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您声明了一个大小和一个初始值设定项列表，但没有提供该大小的数据，则其余元素将被设置为数据类型的默认值:</p><p id="0f7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">array&lt;int, 10&gt; numbers {1,2,3,4,5};</code></p><p id="30d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以通过赋值(复制构造函数)从另一个<code class="fe le lf lg lh b">array </code>对象创建一个新的<code class="fe le lf lg lh b">array</code>对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2c5c" class="mt lj it lh b gy mu mv l mw mx">array&lt;int, 10&gt; numbers {1,2,3,4,5};<br/>array&lt;int, 10&gt; nums = numbers;</span></pre><h1 id="5518" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">尺寸函数</h1><p id="b647" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在进入<code class="fe le lf lg lh b">array </code>类操作之前，我需要介绍一个许多数组操作都需要的重要函数——函数<code class="fe le lf lg lh b">size</code>。正如我在本文开头提到的，原始数组的一个问题是它们没有一个<code class="fe le lf lg lh b">size</code>函数或其他返回数组大小的函数。<code class="fe le lf lg lh b">array</code>类确实有一个<code class="fe le lf lg lh b">size</code>函数，它应该在你访问<code class="fe le lf lg lh b">array</code>类对象的任何时候使用。在接下来的部分中，我将演示如何使用这个函数。</p><h1 id="bd47" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">访问数组元素</h1><p id="451b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">访问数组元素最明显的方法是使用下标符号，如下例所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6c13" class="mt lj it lh b gy mu mv l mw mx">#include &lt;iostream&gt;<br/>#include &lt;array&gt;<br/>using namespace std;</span><span id="d61a" class="mt lj it lh b gy my mv l mw mx">int main()<br/>{<br/>  array&lt;int, 5&gt; numbers {1,2,3,4,5};<br/>  for (unsigned i = 0; i &lt; numbers.size(); i++) {<br/>    cout &lt;&lt; numbers[i] &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="2378" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以使用<code class="fe le lf lg lh b">at </code>功能代替<code class="fe le lf lg lh b">[]</code>运算符:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="56b2" class="mt lj it lh b gy mu mv l mw mx">for (unsigned i = 0; i &lt; numbers.size(); i++) {<br/>  cout &lt;&lt; numbers.at(i) &lt;&lt; " ";<br/>}</span></pre><p id="6e0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，你也可以使用一个范围<code class="fe le lf lg lh b">for</code>循环，完全避免<code class="fe le lf lg lh b">size</code>功能:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="feb5" class="mt lj it lh b gy mu mv l mw mx">for (int n : numbers) {<br/>  cout &lt;&lt; n &lt;&lt; " ";<br/>}</span></pre><p id="fea3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数组对象可用的两个特殊访问函数是<code class="fe le lf lg lh b">front</code>和<code class="fe le lf lg lh b">back</code>。这些函数分别返回数组的第一个元素和最后一个元素:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e5e7" class="mt lj it lh b gy mu mv l mw mx">array&lt;int, 5&gt; numbers {1,2,3,4,5};<br/>cout &lt;&lt; "The first element is: " &lt;&lt; numbers.front() &lt;&lt; endl;<br/>cout &lt;&lt; "The last element is: " &lt;&lt; numbers.back() &lt;&lt; endl;</span></pre><h1 id="0d66" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">数组对象使用迭代器</h1><p id="c0b7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">您可以使用迭代器来遍历数组对象。标准迭代器函数:<code class="fe le lf lg lh b">begin</code>、<code class="fe le lf lg lh b">end</code>、<code class="fe le lf lg lh b">rbegin</code>和<code class="fe le lf lg lh b">rend </code>可用。下面是一个程序中这些函数的工作示例，该程序从头到尾显示一个数组，然后以相反的顺序显示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="25b0" class="mt lj it lh b gy mu mv l mw mx">int main()<br/>{<br/>  array&lt;string, 4&gt; beatles =<br/>    {"John", "Paul", "George", "Ringo"};<br/>  cout &lt;&lt; "The Beatles in order of joining the group: "<br/>       &lt;&lt; endl &lt;&lt; endl;<br/>  for (auto iter = beatles.begin(); iter != beatles.end();<br/>       iter++) {<br/>    cout &lt;&lt; *iter &lt;&lt; endl;<br/>  }<br/>  cout &lt;&lt; endl &lt;&lt; "The Beatles in reverse order of joining: "<br/>       &lt;&lt; endl &lt;&lt; endl;<br/>  for (auto riter = beatles.rbegin(); riter != beatles.rend();<br/>       riter++) {<br/>    cout &lt;&lt; *riter &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="a3c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6c49" class="mt lj it lh b gy mu mv l mw mx">The Beatles in order of joining the group:</span><span id="15e9" class="mt lj it lh b gy my mv l mw mx">John<br/>Paul<br/>George<br/>Ringo</span><span id="2c7a" class="mt lj it lh b gy my mv l mw mx">The Beatles in reverse order of joining:</span><span id="1334" class="mt lj it lh b gy my mv l mw mx">Ringo<br/>George<br/>Paul<br/>John</span></pre><p id="2d27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">迭代器的另一个用途是在STL算法中。下面是一个对数字进行排序的程序:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0bd3" class="mt lj it lh b gy mu mv l mw mx">#include &lt;iostream&gt;</span><span id="2651" class="mt lj it lh b gy my mv l mw mx">#include &lt;array&gt;</span><span id="d993" class="mt lj it lh b gy my mv l mw mx">#include &lt;algorithm&gt;</span><span id="5170" class="mt lj it lh b gy my mv l mw mx">using namespace std;</span><span id="6d26" class="mt lj it lh b gy my mv l mw mx">int main()<br/>{<br/>  array&lt;int, 10&gt; numbers {6,1,10,5,9,2,8,3,7,4};<br/>  for (int n : numbers) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  sort(numbers.begin(), numbers.end());<br/>  for (int n : numbers) {<br/>    cout &lt;&lt; n &lt;&lt; " "; // 1 2 3 4 5 6 7 8 9 10<br/>  }<br/>  return 0;<br/>}</span></pre><h1 id="ec71" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">数组相对于原始C++数组的优势</h1><p id="164f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在本文的前面，我提到了使用<code class="fe le lf lg lh b">array</code>类优于原始数组的两个优点。这两个原因都围绕着这样一个概念，即<code class="fe le lf lg lh b">array</code>类具有<code class="fe le lf lg lh b">size</code>函数，可用于您希望在数组末尾停止的循环中。传递给函数的原始数组必须与它们的大小一起传递，因为不能在函数中的原始数组上使用range <code class="fe le lf lg lh b">for</code>循环，因为函数不能访问正确的信息来使用range <code class="fe le lf lg lh b">for</code>循环。</p><p id="de9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个不起作用的例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2c99" class="mt lj it lh b gy mu mv l mw mx">void computeAverage(int arr[]) {<br/>  for (int n : arr) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>}</span><span id="b64a" class="mt lj it lh b gy my mv l mw mx">int main()<br/>{<br/>  const int SIZE = 5;<br/>  int grades[SIZE] = {88, 71, 91, 85, 93};<br/>  printArray(grades);<br/>  return 0;<br/>}</span></pre><p id="51ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">错误如下:“begin未在此范围内声明。”编译器不能使用<code class="fe le lf lg lh b">begin</code>函数创建迭代器，因为数组是在<code class="fe le lf lg lh b">main</code>函数中创建的，在<code class="fe le lf lg lh b">computeAverage</code>函数的作用域之外。</p><p id="8b52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过，您可以在这个程序中成功地使用一个<code class="fe le lf lg lh b">array</code>对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9e3b" class="mt lj it lh b gy mu mv l mw mx">#include &lt;iostream&gt;<br/>#include &lt;array&gt;<br/>using namespace std;</span><span id="be38" class="mt lj it lh b gy my mv l mw mx">void printArray(auto arr) {<br/>  for (int n : arr) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>}</span><span id="370d" class="mt lj it lh b gy my mv l mw mx">int main()<br/>{<br/>  array&lt;int, 5&gt; grades = {88, 71, 91, 85, 93};<br/>  printArray(grades); // displays 88 71 91 85 93<br/>  return 0;<br/>}</span></pre><p id="079d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我使用了<code class="fe le lf lg lh b">auto</code>关键字来键入函数参数，以便编译器可以确定如何在运行时处理该参数。</p><h1 id="f5dc" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">最终建议</h1><p id="a9d5" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">STL <code class="fe le lf lg lh b">array</code>类提供了与原始数组相同的功能，并且提供了许多便利，这使得它在您需要一个可以随机访问的顺序容器时更加有用。当然，这并不否定对大多数应用程序在任何类型的数组上使用<code class="fe le lf lg lh b">vector</code>的更一般的建议，因为向量比数组(任何类型)具有更大的灵活性，除非您存储的是大型数据集，并且需要数组提供的随机访问效率。</p><p id="7d7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>