<html>
<head>
<title>How To Design An Auto-Complete Engine From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从头开始设计一个自动完成的引擎</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-design-an-auto-complete-engine-from-scratch-9ff2d0bad06a?source=collection_archive---------4-----------------------#2022-04-29">https://levelup.gitconnected.com/how-to-design-an-auto-complete-engine-from-scratch-9ff2d0bad06a?source=collection_archive---------4-----------------------#2022-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dd22" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">方公司的系统设计问题。</h2></div><p id="875a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你有兴趣了解搜索引擎的设计如何在亚马逊、Medium和维基百科等热门网站上工作吗？这篇博文从头开始讨论了自动完成搜索引擎的设计和实现。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/1159a72888342e2e5a506ab176fbd358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vKS-VJVgv6ykYMwzrpoWNQ.jpeg"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">来源:<a class="ae mb" href="https://www.pexels.com/photo/coffee-apple-iphone-smartphone-38547/" rel="noopener ugc nofollow" target="_blank">像素</a></figcaption></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="573f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">功能需求</h1><p id="e700" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">系统应能满足以下功能要求:</p><ol class=""><li id="83de" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated">从预定义的字符串集合中搜索字符串。</li><li id="f182" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">从索引的字符串集合中提供完成。我们需要的匹配类型只是前缀匹配。</li></ol><p id="0dc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了理解这个需求，让我们假设您有一组所有列出的城市。让我们假设您正在构建一个旅游应用程序，因此您需要返回最常去的城市。下面是一个列表:</p><ul class=""><li id="e24a" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld nn nf ng nh bi translated">英国伦敦。</li><li id="c4d3" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">法国巴黎。</li><li id="9f96" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">美国纽约市。</li><li id="33be" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">俄罗斯莫斯科。</li><li id="e6cc" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">阿拉伯联合酋长国迪拜。</li><li id="863a" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">日本东京。</li><li id="e0c4" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">新加坡。</li><li id="d3af" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">美国洛杉矶。</li><li id="6dea" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">西班牙巴塞罗那。</li><li id="75a5" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">西班牙马德里。</li></ul><p id="1d70" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们假设用户键入字母d。引擎应该给出以下建议:</p><ol class=""><li id="95ac" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated">迪拜，</li><li id="c15e" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">德里，</li><li id="16c5" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">大马士革</li><li id="bfdd" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi">…..</li></ol><p id="166f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注</strong>:这份榜单是按照人气排名的。</p><p id="1b59" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果用户在迪拜输入，引擎应该识别出这是迪拜的城市。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="48da" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">非功能性需求</h1><ol class=""><li id="d9d5" class="mz na it kk b kl mu ko mv kr no kv np kz nq ld ne nf ng nh bi translated"><strong class="kk iu">延迟</strong>:引擎应该在<em class="nr"> 10 ms </em>内返回结果。</li><li id="e777" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu">可伸缩性</strong>:引擎应该能够索引<em class="nr">100亿个字符串</em>。</li><li id="3c49" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu">吞吐量</strong>:引擎应该支持每小时1000个请求的<em class="nr"> QPS。</em></li><li id="7961" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu">可用性</strong>:发动机应经历零停机时间。</li><li id="9b01" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu">可定制性</strong>:引擎应该是可定制的。</li><li id="9370" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">内存+磁盘可用性:我们可以假设有无限多的内存和磁盘可用。</li></ol></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="ad42" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">每个工程师都应该知道的系统度量</h1><p id="0dfa" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">在我们开始解决问题之前，有必要了解最常见的系统指标。这些措施如下:</p><ol class=""><li id="5e04" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated">L1高速缓存参考:0.5 ns</li><li id="678e" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">访问主存储器的延迟:100 ns</li><li id="c904" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">访问固态硬盘的延迟:100 us</li><li id="17b6" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">访问硬盘的延迟:10毫秒</li><li id="662d" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">同一数据中心内的往返:500美元</li><li id="0f1b" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">1台web服务器的最大内存:256 GB</li></ol></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="6010" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据结构设计</h1><p id="19ac" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">让我们首先从搜索索引的数据结构设计开始。通常，人们可以使用以下两种不同的数据结构来搜索信息:</p><p id="1d47" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">倒排索引</strong>:倒排索引，也称为发布列表或倒排文件，是一种将内容(如文字或数字)映射到其在表格中的位置的索引存储方案。让我们举下面的例子。在下图中，我们可以看到一个单词列表，这些单词都是从各自的文档中派生出来的。每个单词(也称为术语)都有一个相关的ID和文档号。</p><p id="b47e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然倒排索引有利于搜索完整的术语，但它们不适用于前缀、后缀匹配等。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ns"><img src="../Images/3cf8a5116be2e5abf6d3392d986627a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qcuFlDAnV2YlU6Xw.png"/></div></div></figure><p id="ce4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">二叉查找树:</strong> <a class="ae mb" href="https://www.geeksforgeeks.org/binary-search-tree-data-structure/" rel="noopener ugc nofollow" target="_blank">一个二叉查找树是很好理解的数据结构</a>。它具有以下属性:</p><ol class=""><li id="6832" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated">每个节点有两个子节点。</li><li id="cc7c" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">节点的左子树只包含键小于该节点键的节点。</li><li id="3bf7" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">节点右边的子树只包含键比节点的键更重要的节点。</li><li id="ad95" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated">可以使用字符串的字典序比较来定义比较。<br/>在平衡良好的二叉查找树中的搜索复杂度将是<em class="nr"> M * log N </em>，其中M是最长字符串的长度，N是树中的键的数量。</li></ol><p id="45e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">Trie</strong>:<a class="ae mb" href="https://www.geeksforgeeks.org/trie-insert-and-search/" rel="noopener ugc nofollow" target="_blank">Trie是一种高效的信息检索数据结构</a>。尝试建立在与树相同的思想之上，但是为存储信息进行了优化，以便更快地检索。搜索复杂度可以降低到最佳限度(即密钥大小)。trie在时间复杂度上进行折衷(即，降低时间复杂度)，但是需要更大的空间量(增加空间复杂度)。</p><p id="fe9b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当比较数据结构时，树状数据结构比散列表更好地支持前缀和精确搜索语义。当我们使用trie树时，trie树在时间复杂度方面变得高效。</p><p id="8a50" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们将采用树状数据结构。</p><h1 id="c064" class="mc md it bd me mf nt mh mi mj nu ml mm jz nv ka mo kc nw kd mq kf nx kg ms mt bi translated">内存与磁盘结构</h1><p id="af8d" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">关于系统设计，下一个问题是我们是否应该将这个数据结构全部保存在内存中，还是保存在磁盘上，还是保存在内存中。</p><p id="4236" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过以下计算来更好地理解这一点:</p><p id="74d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">内存需求</strong></p><p id="d89b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设每个节点代表一个城市。一个城市会有一些与之相关联的元数据。它可能是城市的名称、同义词、国家、地理位置、人口、受欢迎程度等。假设我们有100个<em class="nr">字节</em>的数据。考虑到100亿个字符串，这将是1 TB的数据。我们可以有把握地假设，我们无法将它保存在一个现成的web服务器中。我们假设一个典型的现成web服务器有<em class="nr"> 256 GB </em>的内存容量。</p><p id="3952" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">数据布局</strong></p><ol class=""><li id="a20b" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated"><strong class="kk iu">所有数据都在磁盘上:</strong>在这个设计中，我们将假设所有数据都在磁盘上(为了便于论证)。让我们假设一个典型的访问模式看起来像至少两次不同的磁盘寻道。我假设我们正在检索十个结果。乐观地说，它们分布在两个独立的页面上。如果页面不在内存缓冲区中并且不连续，这通常需要20 ms。如果磁盘试图遵循非常随机的模式，尾部延迟将会很高。考虑到我们10 ms的查找延迟要求，这似乎是不可行的。</li><li id="f151" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu">混合存储中的数据</strong>:这种设计假设20%的数据保存在内存中，80%驻留在磁盘上。考虑到大多数热数据(即频繁访问的数据)可以缓存在内存中，这种技术可能更具成本效益。尾部延迟仍将涉及对磁盘的访问，这可能会导致10毫秒以上的访问延迟。</li></ol><p id="6a48" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">所有数据都在内存中</strong>:在这个设计中，我们假设所有数据都在内存中。访问成本很低，即每个存储器引用需要10–100 ns。因此，瓶颈从数据访问转移到了计算(&lt; 10ms)。假设我们有无限量的可用内存(我们将讨论如何实现这一点)，我们应该将所有数据保存在内存中。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="9b03" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据结构设计</h1><p id="e30f" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">现在让我们设计如下的核心数据结构:</p><pre class="lm ln lo lp gt ny nz oa ob aw oc bi"><span id="189c" class="od md it nz b gy oe of l og oh">struct NonLeafNode  {<br/>    vector&lt;Node *&gt; children;<br/>    String value;<br/>};</span><span id="7f1c" class="od md it nz b gy oi of l og oh">struct LeafNode  {<br/>    vector&lt;Node *&gt; children;<br/>    String value;<br/>    // Metadata<br/>    double popularity;<br/>    String country;<br/>    double population; <br/>    ..........<br/>};</span></pre><h1 id="32a2" class="mc md it bd me mf nt mh mi mj nu ml mm jz nv ka mo kc nw kd mq kf nx kg ms mt bi translated">系统结构</h1><h2 id="d243" class="od md it bd me oj ok dn mi ol om dp mm kr on oo mo kv op oq mq kz or os ms ot bi translated">可量测性</h2><p id="892d" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">接下来让我们讨论系统应该如何扩展。对于要扩展到1 TB内存的应用程序，我们需要支持可伸缩性。我们将采用水平缩放而非垂直缩放(<a class="ae mb" href="https://docs.google.com/document/d/1XZv-Dlz8Tzi_fxbI-tY7yRKVcmhlXqQ7haWIab7GIHg/edit#heading=h.20ydeno1hf73" rel="noopener ugc nofollow" target="_blank">点击</a>了解更多缩放信息)。</p><p id="fd95" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">垂直缩放:</strong></p><p id="291c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">优点</strong>:</p><ul class=""><li id="0190" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld nn nf ng nh bi translated">易于实施。</li></ul><p id="11fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">缺点</strong>:</p><ul class=""><li id="69b4" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld nn nf ng nh bi translated">规模上的限制。</li><li id="deae" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">随着尺寸的增加，硬件变得复杂和昂贵。</li></ul><p id="d1ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">水平缩放:</strong></p><p id="99c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">优点</strong>:</p><ul class=""><li id="2232" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld nn nf ng nh bi translated">提供无限的伸缩性(通过弹性)。</li><li id="be5e" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">提供更多容错能力(通过冗余)。</li><li id="6da2" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">更便宜(可以用现成的硬件实现)。</li><li id="5745" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">无需依赖复杂的专用硬件。</li></ul><p id="7de6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">缺点</strong>:</p><ul class=""><li id="ea81" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld nn nf ng nh bi translated">介绍实现的复杂性。</li></ul><p id="e81a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过水平扩展，我们将数据划分到多个服务器中。假设我们需要存储1 TB的数据，每台服务器有256 GB的内存。假设trie的开销是50%。我们需要将近2 TB的内存。这相当于8台网络服务器。</p><h2 id="3207" class="od md it bd me oj ok dn mi ol om dp mm kr on oo mo kv op oq mq kz or os ms ot bi translated">分片</h2><p id="c351" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">为了在八个节点之间划分数据，我们将使用分片(<a class="ae mb" href="https://docs.google.com/document/d/1XZv-Dlz8Tzi_fxbI-tY7yRKVcmhlXqQ7haWIab7GIHg/edit#heading=h.xrt06eedfkqb" rel="noopener ugc nofollow" target="_blank">在这里阅读更多关于分片的内容</a>)。有几种方法可以分割数据。我们将在下一节讨论每种方法的优缺点:</p><p id="4337" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">按字母顺序分割数据:</strong>我们可以使用的最基本的方案是按字母顺序分割数据。下图显示了数据在节点间的分布情况。这种方案的优点是实现简单。这种方案的缺点是会对特定节点造成过大的压力。保存带有A、R或S的数据的节点将有许多被索引的字符串。这是由于英语中数据分布的偏斜。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ou"><img src="../Images/a85e3bddf4d18f04ce851853be23d068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jn2uj2arSYf4rxvU.png"/></div></div></figure><p id="c739" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">随机分割数据</strong>:在这种方法中，我们对每个节点进行统一采样，并使用类似随机树的方法存储数据。主要思想是随机分布数据(使用预定义的哈希函数)并确保负载均匀分布。即使负载保持均匀分布，这种方法也有某些缺点。如果服务器出现故障，所有数据都需要重新分发，这可能会导致上游中断。</p><p id="d97f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">使用一致散列法对数据进行分片:</strong>一致散列法(<a class="ae mb" href="https://medium.com/system-design-blog/consistent-hashing-b9134c8a9062" rel="noopener">博客</a>，<a class="ae mb" href="https://dl.acm.org/doi/abs/10.1145/258533.258660" rel="noopener ugc nofollow" target="_blank">论文</a>)是一种使用随机树进行分布的技术，但在数据分布方面采用了稍微不同的方法。像其他哈希方案一样，一致哈希将一组项目分配给桶，以便每个桶接收大致相同数量的项目。但是，与标准哈希方案不同，桶中的小变化只会对桶的项目分配产生微小的变化。一致散列通过构建“<em class="nr">范围散列函数来实现这一点</em>一个范围散列函数确保<em class="nr">平滑分布</em>，一个<em class="nr">键的低分布</em>，以及一个<em class="nr">每个桶的低负载</em>。(<em class="nr">注:我们将在另一篇博客</em>中讨论一致散列背后的直觉)。</p><p id="87cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里提到的方案中，一致散列是最健壮和性能最好的方案，并且被普遍使用。</p><h2 id="0127" class="od md it bd me oj ok dn mi ol om dp mm kr on oo mo kv op oq mq kz or os ms ot bi translated">有效性</h2><p id="10fa" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">保留所有内存的一个问题是，如果服务器停机，一部分数据可能会在很长一段时间内不可用。这是因为从数据源(从磁盘)读取数据并在内存中构建索引是一个缓慢的过程。用户将不会访问当前不在内存中的数据部分。</p><p id="f612" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nr">在设计中引入冗余度</em></p><p id="492c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了确保高可用性，我们在系统中引入了冗余。每个碎片现在出现在两个不同的节点上，而不是一个节点上。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ov"><img src="../Images/2844ac8ca59d6111f8bf5d62cc7b0085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Cyg96S3xO8w8XkiF.png"/></div></div></figure><p id="90c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看上面的图像。我们可以看到，每个碎片(例如，A-D，X- Z)现在出现在两个节点上，而不是一个。</p><p id="30bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="nr">优点</em> </strong>:</p><ul class=""><li id="7bf7" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld nn nf ng nh bi translated">这种设计确保了即使其中一个碎片不可用，另一个碎片也可以满足请求。</li><li id="6b15" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">在一个节点压力很大的情况下，请求可以被重定向到同一个shard。</li></ul><p id="082e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="nr">弊</em> </strong>:</p><ul class=""><li id="456a" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld nn nf ng nh bi translated">这增加了系统的存储器需求。</li><li id="0a60" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld nn nf ng nh bi translated">这引入了额外的实现复杂性(分片路由、分片数据的同步等。).</li></ul><h1 id="fc72" class="mc md it bd me mf nt mh mi mj nu ml mm jz nv ka mo kc nw kd mq kf nx kg ms mt bi translated">高级图表和数据流</h1><p id="5cef" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">这里我们讨论搜索引擎的高级视图和数据流图。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ow"><img src="../Images/7d5fe660c8192ae1399490fd70e7ee21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*urZ99C4-mL_EnZ6D.png"/></div></div></figure><p id="a1e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该系统的主要组件如下:</p><ol class=""><li id="4f80" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated"><strong class="kk iu">客户端:</strong>客户端由Web应用、移动应用或访问后端服务的API端点组成。</li><li id="fdaa" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu">负载平衡器</strong>:负载平衡器用于将请求路由到web服务器，并平衡两个服务之间的负载。</li><li id="4711" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu"> Web服务器</strong>:Web服务器编码业务逻辑。在自动完成引擎中，web服务器将执行以下操作:</li></ol><p id="e3f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">—验证请求。</p><p id="3072" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">—检查缓存是否已经缓存了请求的结果。如果没有，点击索引器节点。</p><p id="96a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">—查找应该在其上路由请求的索引器节点。</p><p id="8c6c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">—向正确的节点集发送请求(使用一致的哈希方案)。</p><p id="232d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">—如果请求精确匹配，只需查找一个节点。</p><p id="f82f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">—如果请求前缀匹配，可以查找一个或两个节点。</p><p id="5bf9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">—聚合来自索引器节点的结果，通过向用户个性化这些结果来对它们进行排序，并将结果发送回客户端。</p><ol class=""><li id="d2c7" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated"><strong class="kk iu">缓存</strong>:缓存间歇存储来自索引器节点的中间结果。我们可能有内存缓存(比如<em class="nr"> Memcached </em>)或者支持持久化的磁盘缓存(<em class="nr"> Redis </em>)。</li><li id="bdf9" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu">索引器节点</strong>:索引器节点存储分布式trie数据结构。我们的设计有16个节点，可容纳1 TB的数据(冗余系数为2)。索引器节点使用分布式文件存储进行备份。如果一个索引器节点关闭，集群管理器(图中未显示)将重启该节点。然后，节点将在重新启动时重新索引分布式文件存储中的所有数据。</li><li id="5730" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu">分布式文件存储</strong>:存储实际数据(即100亿个字符串)。这可能是使用亚马逊的S3构建的。</li></ol><p id="6cdb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于面试的范围来说，这是一个足够好的与面试官讨论的话题。需要涵盖一些主题来完成访谈的范围。这些措施如下:</p><p id="d747" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">I .客户端和网络服务器、网络服务器和索引器节点之间的API接口。</p><p id="4afd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">二。解决挑战，例如获得前10个匹配、空字符串的自动完成、处理节点间的故障转移等。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="ff2d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><ol class=""><li id="cfe1" class="mz na it kk b kl mu ko mv kr no kv np kz nq ld ne nf ng nh bi translated"><a class="ae mb" href="https://gist.github.com/jboner/2841832" rel="noopener ugc nofollow" target="_blank">每个程序员都应该知道的延迟数字GitHub </a></li><li id="2af9" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae mb" href="https://www.geeksforgeeks.org/trie-insert-and-search/" rel="noopener ugc nofollow" target="_blank"> Trie |(插入并搜索)</a></li><li id="bc8a" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae mb" href="https://www.geeksforgeeks.org/binary-search-tree-data-structure/" rel="noopener ugc nofollow" target="_blank">二叉查找树</a></li><li id="6e5e" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae mb" href="https://medium.com/system-design-blog/database-sharding-69f3f4bd96db" rel="noopener">数据库分片。数据库分片是…的过程|作者Vivek Kumar Singh |系统设计博客</a></li><li id="eae0" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae mb" href="https://ravisystemdesign.substack.com/p/system-design-challenges-in-distributed" rel="noopener ugc nofollow" target="_blank">系统设计:分布式系统的挑战(可用性)</a></li><li id="fd28" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><a class="ae mb" href="https://ravisystemdesign.substack.com/p/system-design-fundamentals" rel="noopener ugc nofollow" target="_blank">系统设计:基础</a></li></ol></div></div>    
</body>
</html>