<html>
<head>
<title>Go Error Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go错误最佳实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-error-best-practice-f0864c5c2385?source=collection_archive---------0-----------------------#2021-10-06">https://levelup.gitconnected.com/go-error-best-practice-f0864c5c2385?source=collection_archive---------0-----------------------#2021-10-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="106d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以正确的方式创造和处理你的错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45e1c2404a22b1ae38a99253dcb50023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_zMBgq26lIp4x2UB"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自unsplash的Alexander Schimmeck，<a class="ae ky" href="https://unsplash.com/photos/Aohf8gqa7Zc" rel="noopener ugc nofollow" target="_blank"> @alschim </a></figcaption></figure><p id="e8c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">沉迷于围棋相当一段时间，实现了web相关的程序、grpc接口、操作符，我现在好像是高级初学者了。</p><p id="bc07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我还是一个生产环境调试的新手，如果通过查询日志或错误消息来完成，会很麻烦。想象这样一个场景，当错误日志的特定位置丢失时，调用全文搜索。那么当那些错误日志不仅仅在一个地方时会发生什么呢？是的，我的错误日志不再能帮助我快速准确地定位错误。</p><p id="e57f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，缺乏大多数其他高级语言支持的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/golang/go/issues/40432" rel="noopener ugc nofollow" target="_blank">try {…} catch</a></code> <a class="ae ky" href="https://github.com/golang/go/issues/40432" rel="noopener ugc nofollow" target="_blank">结构</a>使得Go在错误处理上的设计备受争议。而下面的代码结构就是Go中随处可见的:每个错误都需要处理，错误是一层一层嵌套的。作为一名多年的Java开发人员，你无法逃避，只能适应。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f829" class="md me it ly b gy mf mg l mh mi">a, err := fn()<br/>if err != nil {<br/>  return err<br/>}</span><span id="2182" class="md me it ly b gy mj mg l mh mi">func fn() error {<br/>  b, err := fn1()<br/>  if  err != nil {<br/>    …<br/>    return err<br/>  }<br/>  if _, err = fn2(); err != nil {<br/>    …<br/>  }<br/>}</span></pre><p id="52a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，我们总能踩着前人的肩膀，想出解决困难的办法。在下面的部分中，我将分享一些错误处理的规则和一些第三方包，它们可以提高效率，这是我总结的。</p><h1 id="191c" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">什么是Go错误？</h1><p id="812a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在Go中，错误只是一个接口。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e89d" class="md me it ly b gy mf mg l mh mi">type error interface {<br/>  Error() string<br/>}</span></pre><p id="6866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，实现，创建，或者抛出一个错误，其实就是实现这个接口。三种最常见的方式是</p><ul class=""><li id="e1d1" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">errors.New</code></li><li id="2ecd" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">fmt.Errorf</code></li><li id="7c99" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">implement error interface</code></li></ul><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="15a2" class="md me it ly b gy mf mg l mh mi">var ErrRecordNotExist   = errors.New("record not exist")</span><span id="083c" class="md me it ly b gy mj mg l mh mi">func ErrFileNotExist(filename string) error {</span><span id="2a63" class="md me it ly b gy mj mg l mh mi">  return fmt.Errorf("%s file not exist", filename)</span><span id="05f6" class="md me it ly b gy mj mg l mh mi">}</span><span id="a2ec" class="md me it ly b gy mj mg l mh mi">type ErrorCallFailed struct {</span><span id="ce4f" class="md me it ly b gy mj mg l mh mi">  Funcname string</span><span id="fef6" class="md me it ly b gy mj mg l mh mi">}</span><span id="063a" class="md me it ly b gy mj mg l mh mi">func (*ErrorCallFailed) Error() string {</span><span id="3894" class="md me it ly b gy mj mg l mh mi">  return fmt.Sprintf(“call %s failed”, funcname)</span><span id="4c59" class="md me it ly b gy mj mg l mh mi">}</span><span id="2aef" class="md me it ly b gy mj mg l mh mi">var ErrGetFailed error = &amp;ErrorCallFailed{ Funcname: "getName", }</span></pre><p id="2d2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且在Go错误中只涉及以下两个逻辑。</p><ul class=""><li id="be07" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><strong class="lb iu">抛出错误</strong>，这涉及到我们如何定义错误。在实现函数时，对于异常情况需要返回合理的错误。</li><li id="b897" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">处理错误</strong>。调用函数时，要根据函数的返回实现不同的逻辑，要考虑到是否有错误，错误是否属于某一类型，错误是否要忽略等等。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="39bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes <a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/29652248ebe229a9dc6f64c3e37c9980cd755bfd/staging/src/k8s.io/apimachinery/pkg/util/yaml/decoder.go#L94" rel="noopener ugc nofollow" target="_blank"> decode.go </a>的这段代码不仅可以直接返回错误，还可以包装错误，要么返回<code class="fe lv lw lx ly b">YAMLSyntaxError</code>，要么干脆忽略<code class="fe lv lw lx ly b">io.EOF</code>。</p><p id="4aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，有三种方法可以确定错误类型。</p><ul class=""><li id="d8f4" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">直接按<code class="fe lv lw lx ly b"><strong class="lb iu">==</strong></code>、<code class="fe lv lw lx ly b">if err == ErrRecordNotExist {}</code>。</li><li id="4714" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><strong class="lb iu">式推断</strong>，<code class="fe lv lw lx ly b">if _, ok := err.(*ErrRecordNotExist); ok {}</code>。</li><li id="9bb1" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">errors.Is</strong></code> <strong class="lb iu"> </strong>和<strong class="lb iu"> </strong> <code class="fe lv lw lx ly b"><strong class="lb iu">errors.As</strong></code>方法，这是从Go 1.13开始增加的。<code class="fe lv lw lx ly b">if errors.Is(err, ErrRecordNotExist)</code>涉及<a class="ae ky" href="https://go.dev/blog/go1.13-errors" rel="noopener ugc nofollow" target="_blank">错误包装</a>，解决定位嵌套错误的麻烦。</li></ul><h1 id="e219" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">要遵循的规则</h1><p id="91e4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在理解了Go错误的基本概念之后，是时候讨论可以遵循的规则，以便更好地练习。让我们从定义开始，然后到错误处理。</p><h2 id="722a" class="md me it bd ml nw nx dn mp ny nz dp mt li oa ob mv lm oc od mx lq oe of mz og bi translated">定义错误</h2><ul class=""><li id="dbd4" class="ng nh it lb b lc nb lf nc li oh lm oi lq oj lu nl nm nn no bi translated"><strong class="lb iu">用</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">fmt.Errorf</strong></code> <strong class="lb iu">战胜</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">errors.New</strong></code></li></ul><p id="e865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">fmt.Errorf</code>提供拼接参数功能，并包裹错误。虽然在处理简单错误时，我们看不到这两种方法有什么不同，但是总是设置<code class="fe lv lw lx ly b">fmt.Errorf </code>因为您的偏好可以保持代码一致。</p><ul class=""><li id="beae" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><strong class="lb iu">封装类似错误</strong></li></ul><p id="f342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">封装同样的错误，比如上面提到的<code class="fe lv lw lx ly b">ErrorCallFailed</code>，是一种常见的代码优化，结合<code class="fe lv lw lx ly b">errors.Is</code>或者<code class="fe lv lw lx ly b">errors.As</code>可以解包各层，更好的确定错误的真正原因。关于<code class="fe lv lw lx ly b">errors.Is</code>和<code class="fe lv lw lx ly b">errors.As</code>的区别，前者需要类型匹配和消息匹配，而后者只需要类型匹配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="8930" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><strong class="lb iu">使用</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">%w</strong></code> <strong class="lb iu">超过</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">%v</strong></code></li></ul><p id="ec4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得一个方法被多个地方调用时的完整调用链，开发者会在返回错误的地方层层包装，通过<code class="fe lv lw lx ly b">fmt.Errorf</code>不断添加当前调用的独有特性，它可能是一个日志，也可能是一个参数。而在错误拼接中偶尔采用<code class="fe lv lw lx ly b">%v</code>代替<code class="fe lv lw lx ly b">%w</code>，会使Go的错误换行特性在Go1.13及以后失效，正确换行后的错误类型如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/c2702f79aeeb6c4581ed147ba499f98e.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*x46Ko7istAXDFqsAWe85KQ.png"/></div></figure><ul class=""><li id="9f0f" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><strong class="lb iu">使错误信息简洁</strong></li></ul><p id="35bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合理的错误信息可以让我们远离层层包装的冗余信息。</p><p id="c031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多人习惯在下面的内容中打印日志，添加参数、当前方法的名称和调用方法的名称，这是不必要的。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="811d" class="md me it ly b gy mf mg l mh mi">func Fn(id string) error {<br/>  err := Fn1()<br/>  if err != nil {<br/>    return fmt.Errorf("Call Fn1 failed with id: %s, %w", id, err<br/>  }<br/>  ...<br/>  return nil<br/>}</span></pre><p id="9154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，一个清晰明了的错误日志只包含<strong class="lb iu">当前操作错误的信息，内部参数和动作</strong>，以及调用者不知道的信息，比如当前的方法和参数。这里有一个<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/endpoint/endpoints_controller.go#L218" rel="noopener ugc nofollow" target="_blank">端点的错误日志，Kubernetes中的go </a>，一个非常好的例子，只打印内部Pod相关的参数和<code class="fe lv lw lx ly b">Unable to get Pod</code>的失败动作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="cffc" class="md me it bd ml nw nx dn mp ny nz dp mt li oa ob mv lm oc od mx lq oe of mz og bi translated">处理错误</h2><p id="c88a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">黄金五法则。</p><ul class=""><li id="4977" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">errors.Is</strong></code> <strong class="lb iu">胜过</strong> <code class="fe lv lw lx ly b"><strong class="lb iu">==</strong></code></li></ul><p id="28cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">==</code>比较容易出错，只能比较当前错误类型，不能解包。所以，<code class="fe lv lw lx ly b">errors.Is</code>或者<code class="fe lv lw lx ly b">errors.As</code>是比较好的选择。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="1601" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">打印错误日志，但不打印正常日志</li></ul><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6e5e" class="md me it ly b gy mf mg l mh mi">buf, err := json.Marshal(conf)<br/>if err != nil {<br/>  log.Printf(“could not marshal config: %v”, err)<br/>}</span></pre><p id="6c83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新手的一个常见错误是使用<code class="fe lv lw lx ly b">log.Printf</code>打印所有日志，包括错误日志，这使得我们无法通过日志级别正确处理日志，增加了调试的难度。并且我们可以从<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/0ac956ff2bef9c84b17d4b9cae2cffe71d5c6386/cmd/dependencycheck/dependencycheck.go" rel="noopener ugc nofollow" target="_blank"> dependencycheck.go </a>中学习正确的方法，这里应用了<code class="fe lv lw lx ly b">log.Fatalf</code>。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="416f" class="md me it ly b gy mf mg l mh mi">if len(args) != 1 {<br/>  log.Fatalf(“usage: dependencycheck &lt;json-dep-file&gt; (e.g. ‘go list -mod=vendor -test -deps -json ./vendor/…’)”)<br/>}</span><span id="9508" class="md me it ly b gy mj mg l mh mi">if *restrict == “” {<br/>  log.Fatalf(“Must specify restricted regex pattern”)<br/>}</span><span id="54bc" class="md me it ly b gy mj mg l mh mi">depsPattern, err := regexp.Compile(*restrict)</span><span id="d3cd" class="md me it ly b gy mj mg l mh mi">if err != nil {<br/>  log.Fatalf(“Error compiling restricted dependencies regex: %v”, err)<br/>}</span></pre><ul class=""><li id="e77a" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">永远不要通过错误处理逻辑</li></ul><p id="a90c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个错误过程的例子。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4b64" class="md me it ly b gy mf mg l mh mi">bytes, err := d.reader.Read()<br/>if err != nil &amp;&amp; err != io.EOF {<br/>  return err<br/>}<br/>row := db.QueryRow(“select name from user where id= ?”, 1)<br/>err := row.Scan(&amp;name)<br/>if err != nil &amp;&amp; err != sql.ErrNoRows{<br/>  return err<br/>}</span></pre><p id="ad06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，<code class="fe lv lw lx ly b">io.EOF</code>和<code class="fe lv lw lx ly b">sql.ErrNoRows</code>两个错误都被忽略了，后者是用错误表示业务逻辑的典型例子(数据不存在)。我反对这样的设计，但是支持<code class="fe lv lw lx ly b">size, err:= row.Scan(&amp;name) if size == 0 {log.Println(“no data”) }</code>的优化，通过增加一个返回参数来辅助，而不是直接抛出一个错误。</p><ul class=""><li id="836e" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><strong class="lb iu">底层方法返回错误，上层方法处理错误。</strong></li></ul><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f220" class="md me it ly b gy mf mg l mh mi">func Write(w io.Writer, buf []byte) error {<br/>  _, err := w.Write(buf)<br/>  if err != nil {<br/>    log.Println(“unable to write:”, err)<br/>    return err<br/>  }<br/>  return nil<br/>}</span></pre><p id="2471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似上面的代码有一个明显的问题。如果在打印日志后返回一个错误，则很可能有重复的日志，因为调用者也可能打印日志。</p><p id="b839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那怎么避免呢？让每个方法只执行一个功能。而这里常见的选择是底层方法只返回错误，上层方法处理错误。</p><ul class=""><li id="438e" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><strong class="lb iu">包装错误消息并添加有助于故障排除的上下文。</strong></li></ul><p id="84f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Go中没有原生stacktrace可以依赖，我们只能通过自实现或者第三方库来获取那些异常的堆栈信息。例如，Kubernetes实现了一个相对复杂的<a class="ae ky" href="https://github.com/kubernetes/kubernetes/blob/0ac956ff2bef9c84b17d4b9cae2cffe71d5c6386/vendor/k8s.io/klog/v2/klog.go#L1473" rel="noopener ugc nofollow" target="_blank"> klog </a>包来支持日志打印、堆栈信息和上下文。而你参考Kubernetes 中的<a class="ae ky" href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/migration-to-structured-logging.md#structured-logging-in-kubernetes" rel="noopener ugc nofollow" target="_blank">结构化日志，如果你开发的是Kubernetes相关的应用，比如Operator。除此之外，那些第三方的错误封装库，比如</a><a class="ae ky" href="https://github.com/pkg/errors" rel="noopener ugc nofollow" target="_blank"> pkg/errors </a>也很受欢迎。</p><h1 id="a2b6" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结束了</h1><p id="9c97" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Go设计哲学的初衷是简化，但有时会使事情变得复杂。然而，你不能认为Go错误处理一无是处，即使它不是那么用户友好。至少，逐错返回是一个好的设计，在最高层的调用位置统一处理错误。此外，我们仍然可以期待即将到来的版本中的改进，这将带来更简单的应用程序。</p><p id="12cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><h1 id="955c" class="mk me it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">参考</h1><p id="f665" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><a class="ae ky" href="https://go.dev/blog/go1.13-errors" rel="noopener ugc nofollow" target="_blank">https://go.dev/blog/go1.13-errors</a></p><p id="59a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://errnil.substack.com/p/wrapping-errors-the-right-way" rel="noopener ugc nofollow" target="_blank">https://errnil.substack.com/p/wrapping-errors-the-right-way</a></p><p id="17e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" rel="noopener ugc nofollow" target="_blank">https://Dave . Cheney . net/2016/04/27/don ' t-just-check-errors-handle-these-gracefully</a></p></div></div>    
</body>
</html>