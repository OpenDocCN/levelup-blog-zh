<html>
<head>
<title>Make Your Java Code Fully Async</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让您的Java代码完全异步</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/make-your-java-code-fully-async-369efa3b0f23?source=collection_archive---------7-----------------------#2021-02-15">https://levelup.gitconnected.com/make-your-java-code-fully-async-369efa3b0f23?source=collection_archive---------7-----------------------#2021-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="de89" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么我们的代码需要异步运行，如何实现？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a04237c341697ff175afd6a595daab0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nk5DArZGY4epe1MABWNMaw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">2021年1月的斯德哥尔摩，作者</figcaption></figure><p id="25d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一名十多年的开发人员，大部分时间都在使用Java，我花了相当长的时间来适应Spotify的代码约定，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/9a5cc352f8758c2718fa3e55a2f1030f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLir4JYDk8LuVvKS0WCUBQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">简单的代码结构。</figcaption></figure><p id="1181" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一小段代码代表了公司里的Java代码转换，用<code class="fe lv lw lx ly b">CompletionStage</code>和<code class="fe lv lw lx ly b">AutoValue</code>构建异步代码。</p><p id="e179" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的文章中，我将描述我理解它们的方式，给出使用它们的例子，最后解释为什么。</p><p id="fd07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关键要点:</p><ul class=""><li id="84af" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">知道为什么我们应该放弃并发编码而拥抱异步编程。</li><li id="a785" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">用AutoValue实践不可变模式。</li><li id="8429" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">通过与Stream的比较来学习CompletionStage APIs。</li><li id="3e8e" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">掌握Java中不同的函数接口类型。</li><li id="9178" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">理解使用CompletionStage进行异步编程的优缺点。</li></ul><h1 id="6b61" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">并发还是异步？</h1><p id="4ad0" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">Java一直被认为是一种安全的高级语言，它提供了各种API来支持锁定、并发甚至异步编程。作为对异步特性的探索，<code class="fe lv lw lx ly b">Future</code>最初是在JDK1.5中引入的。但更像是一种伪异步，当JavaScript、Node.js等其他语言已经通过使用回调支持完全异步时，它并没有让开发人员免于等待。</p><p id="9247" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种尴尬的局面直到<code class="fe lv lw lx ly b">CompletableFuture</code>和<code class="fe lv lw lx ly b">CompletionStage</code>在JDK 1.8(被认为是全球最受欢迎的JDK版本)发布才结束。</p><p id="5392" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们详细讨论异步编程之前，有必要讨论一下并发性。众所周知，人们只有在编码中处理共享数据时才会用到并发。但是正确使用它并不容易，无论是在辨别正确的时间还是掌握并发API方面。</p><p id="431d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Java中有很多解决方案，不限于<code class="fe lv lw lx ly b">synchronized</code>关键字、并发集合、<a class="ae nk" href="https://www.ibm.com/developerworks/java/library/j-jtp11234/" rel="noopener ugc nofollow" target="_blank">原子</a>，以及隐藏复杂逻辑的各种锁，比如<a class="ae nk" href="https://en.wikipedia.org/wiki/Compare-and-swap" rel="noopener ugc nofollow" target="_blank"> CAS </a>、<a class="ae nk" href="https://en.wikipedia.org/wiki/Memory_barrier#:~:text=A%20memory%20barrier%2C%20also%20known,and%20after%20the%20barrier%20instruction." rel="noopener ugc nofollow" target="_blank">内存屏障</a>和<a class="ae nk" href="https://en.wikipedia.org/wiki/CPU_cache" rel="noopener ugc nofollow" target="_blank"> CPU缓存</a>。然而，普通开发人员仍然需要花费数年时间来理解这些库，发现不同用例之间的差异，并在出现性能问题时进行调试。相信我，你不可能完全避免错误和性能问题。</p><p id="8bc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我认为没有人喜欢编写充满锁或<code class="fe lv lw lx ly b">synchronized</code>的代码，这不仅对从事这项工作的人来说是一项艰难的工作，对任何继任者来说也是一种折磨。因此，聪明的开发人员想出了克服障碍的方法:无锁编程，也称为<a class="ae nk" href="https://en.wikipedia.org/wiki/Non-blocking_algorithm" rel="noopener ugc nofollow" target="_blank">非阻塞</a>，有些人可能知道或者至少听说过。我就不深究了，用一句话总结一下。它使用原语或其他底层技术来克服障碍，并在顶层实现无锁。</p><p id="9d87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">老实说，我远不是并发编程主题的专家，但是我知道如何避免落入陷阱。<strong class="la iu">不要使用并发！</strong>那么，如何？</p><p id="6085" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，如果开发人员遵循一些原则，他们的代码很有可能是并发自由的。下面是三个简单的规则:</p><ul class=""><li id="476f" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><strong class="la iu">不共享数据</strong></li><li id="863b" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="la iu">使用不可变的数据结构</strong></li><li id="8f1c" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="la iu">写幂等码</strong></li></ul><p id="b13e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记住这一点，不修改数据，那么就不需要锁。然而，人们无法抗拒快捷方式的诱惑，因为通过编写<code class="fe lv lw lx ly b">var a = 2; a = method(a)</code>来更新变量是如此容易。因此，我们寄希望于<a class="ae nk" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank">不变的构建模式</a>来阻止开发者。</p><blockquote class="nl nm nn"><p id="6230" class="ky kz no la b lb lc ju ld le lf jx lg np li lj lk nq lm ln lo nr lq lr ls lt im bi translated">构造后状态不能改变的对象称为不可变对象。</p></blockquote><p id="39e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">来自Google的<a class="ae nk" href="https://github.com/google/auto" rel="noopener ugc nofollow" target="_blank"> AutoValue </a> lib是实践<a class="ae nk" href="https://lkumarjain.blogspot.com/2016/02/immutable-design-pattern.html" rel="noopener ugc nofollow" target="_blank">不变模式</a>的绝佳选择。</p><p id="8c23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">AutoValue使用一个builder来构造一个对象实例，每个字段只有一个getter，没有setter。典型的自动赋值示例如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/856c3286a271896abc0607f49c970900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*LA7eU_FNKNyy5QlwsRE9hw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">自动赋值人员对象</figcaption></figure><p id="df17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了加速编码，eclipse和IntelliJ都有支持的插件。</p><p id="279f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于AutoValue的信息，请参考这篇<a class="ae nk" href="https://github.com/google/auto/blob/master/value/userguide/index.md" rel="noopener ugc nofollow" target="_blank">文章</a>。我不能做得比它更好。</p><p id="c7b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管不可变模式确实有它的好处，但它还不足以取代并发性。弥补缺陷的一个方法是让你的代码幂等。在当今的架构中随处可见，幂等元是微服务中最重要的角色之一。不同的模块通过REST APIs或者RPC方法调用其他的，无论尝试多少次都不影响最终结果。</p><h1 id="2cc5" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">异步编程</h1><p id="e1ad" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">开发人员希望他们的代码尽可能快地运行，这是人们开始使用并发性的原因之一，将任务分成子任务，并最大程度地探索多核CPU的能力。</p><p id="77c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们采用不可变模式时，数据可以被复制，因此需要更多的内存和CPU资源，程序会变慢。是我们转向异步编程的时候了。</p><blockquote class="nl nm nn"><p id="bdac" class="ky kz no la b lb lc ju ld le lf jx lg np li lj lk nq lm ln lo nr lq lr ls lt im bi translated">异步编程是并行编程的一种方式，其中一个工作单元独立于主应用程序线程运行，并通知调用线程其完成、失败或进度。—来自<a class="ae nk" href="https://visualstudiomagazine.com/articles/2011/03/24/wccsp_asynchronous-programming.aspx#:~:text=Asynchronous%20programming%20is%20a%20means,its%20benefits%20and%20problem%20points." rel="noopener ugc nofollow" target="_blank">异步编程。网络</a></p></blockquote><p id="7277" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">异步编程最常见的例子是我们在JS REST API调用中使用回调。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/7f3467536f9e471f3ff5a407b40f9737.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*y7OtVN_v_f5JDyRd-dWsJg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">单击添加事件句柄</figcaption></figure><p id="0a08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Java中，<code class="fe lv lw lx ly b">CompletionStage</code>是实现全异步编程模式的核心，<code class="fe lv lw lx ly b">CompletableFuture</code>是其实现。让我们看一个简单的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/1ada44c360a7fe8950e3b7208fd445b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*do2UwyrkjMYwlbdP-34ahw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">简单完成阶段代码</figcaption></figure><p id="b051" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Spotify，我们从一开始就使用<code class="fe lv lw lx ly b">CompletionStage</code>构建代码，贯穿每个方法，并最终返回具体的对象。</p><p id="e6e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你缺乏使用<code class="fe lv lw lx ly b">CompletionStage</code>或函数式编程的经验，事情会比看起来更难，如果你误用了API，事情会变得更糟。为了熟悉它，我花了几个月的时间研究和重构了几十个反复审查的PRs。</p><p id="9dfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本质是管道。因此，找出从头到尾使用所有API和函数接口用<code class="fe lv lw lx ly b">CompletionStage&lt;?&gt;</code>构建管道表单的方法是非常重要的。</p><p id="baa3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要掌握API。<code class="fe lv lw lx ly b">CompletionStage</code>有30多种方法，掌握所有这些方法是一个很大的挑战。但是如果你习惯使用Java <code class="fe lv lw lx ly b">Stream</code>，通过与<code class="fe lv lw lx ly b">Stream</code> API比较就很容易理解<code class="fe lv lw lx ly b">CompletionStage</code>。下面是一个图表，列出了一些常用的API进行比较。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/ac3277b660194e4458d87f4bf95d6058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QWH8Pp_xb9ER940r4sE6nA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">流API与完成阶段API</figcaption></figure><p id="f349" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将API分为四大类。</p><ul class=""><li id="194b" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">建设</li><li id="835c" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">中间的</li><li id="d861" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">接触</li><li id="ed0c" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">结束的</li></ul><p id="643a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">构建操作</strong>是关于如何创建<code class="fe lv lw lx ly b">Stream</code>或<code class="fe lv lw lx ly b">CompletionStage.</code> <code class="fe lv lw lx ly b">Stream</code>通常是从一个数组或集合API中生成的，而<code class="fe lv lw lx ly b">CompletionStage</code>依赖于它的实现者<code class="fe lv lw lx ly b">CompletableFuture</code>来完成这项工作。</p><p id="785d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">中间操作</strong>常指输入突变。所有的方法都由一个<code class="fe lv lw lx ly b">Stream</code>或<code class="fe lv lw lx ly b">CompletionStage</code>包装，接受一个<code class="fe lv lw lx ly b">Function</code>对输入进行一些处理并返回一些不同的东西。</p><p id="81ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">触点操作</strong>在<code class="fe lv lw lx ly b">CompletionStage</code>中很常用，但在<code class="fe lv lw lx ly b">Stream</code>中不常用。<code class="fe lv lw lx ly b">CompletionStage</code>有方法接受四种不同的函数式编程接口，并确保几乎所有的行为都得到支持。稍后我会展开它。</p><p id="9e82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">终止操作</strong>，与以上三类相比，不太相似。我们习惯于通过将一个<code class="fe lv lw lx ly b">Stream</code>变成一个收藏或遗产<code class="fe lv lw lx ly b">foreach</code>来结束它。至于<code class="fe lv lw lx ly b">CompletionStage</code>，它没有<code class="fe lv lw lx ly b">Stream</code>那么多的终止方法，它的大部分方法都返回一个<code class="fe lv lw lx ly b">CompletionStage</code>，希望流水线永远不要结束。</p><p id="a90a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了这四个组，<code class="fe lv lw lx ly b">CompletionStage</code>还有两种额外类型的API。</p><ul class=""><li id="e129" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">那些<strong class="la iu">自然支持异步</strong>的。一个API方法通常有三个转换，支持异步和带有执行器的异步。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/08e020f274055fecc0c0bdda9f1a19c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cTPZ4lnx_XpnzDsHoDVT1g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">三种相同功能的API</figcaption></figure><ul class=""><li id="0817" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><strong class="la iu">支持错误处理</strong>的。在<code class="fe lv lw lx ly b">CompletionStage</code>和<code class="fe lv lw lx ly b">CompletableFuture</code>中都有支持异常、失败和超时的API，这对控制流程非常有用。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/ef7da946dee4a155d99551efaa90ff53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ao9gRJqG7MnJXYJr1Vj28w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在CompletableFuture中处理API时出错</figcaption></figure><p id="97d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然<code class="fe lv lw lx ly b">Stream</code>和<code class="fe lv lw lx ly b">CompletionStage</code>有一些共同之处，但它们在范围上有很大不同。<code class="fe lv lw lx ly b">Stream</code>非常有限，仅用于采集操作。然而，<code class="fe lv lw lx ly b">CompletionStage</code>包含了任何操作，给了开发者更多的自由——我们几乎可以在任何环境下构建、组合、联系、变异。想象一下，你输入A和B，下一步得到C，异步运行另一个任务，最终，你得到d。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/a5bb20f25666623ed046e69125106cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z26iAgWgvFSJ1zVeED1ojQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我自己烤饼干！</figcaption></figure><p id="a26b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些操作可以是你能想到的最复杂的，所以试着自己练习一下。</p><h2 id="72e4" class="nz mo it bd mp oa ob dn mt oc od dp mx lh oe of mz ll og oh nb lp oi oj nd ok bi translated">功能P <strong class="ak">编程</strong></h2><p id="dac4" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">使用<code class="fe lv lw lx ly b">CompletionStage</code>的最佳实践是构建一个贯穿整个程序的管道，并最终返回一个特定的结果或错误。</p><p id="5798" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了实现这一点，我们需要深入研究函数式编程。您可能已经注意到，我在上表的联系操作部分突出了四个功能接口，它们是构建管道的真正核心和灵魂。</p><blockquote class="nl nm nn"><p id="bc62" class="ky kz no la b lb lc ju ld le lf jx lg np li lj lk nq lm ln lo nr lq lr ls lt im bi translated"><strong class="la iu">函数式编程</strong>是一种编程范式——一种构建计算机程序结构和元素的风格——将计算视为数学函数的评估，避免改变状态和可变数据— <a class="ae nk" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="fd69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从不同角度和语言阐述函数式编程的文章比比皆是，您可能想知道为什么突然每个人都在谈论它。答案是我们想要简单性回归。</p><p id="5a6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看你的代码。</p><ul class=""><li id="cd41" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">它有包含数百行的功能吗？</li><li id="a822" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">它有包含复杂逻辑的大for循环吗？</li><li id="f55b" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">你被逼疯了去调试或者重构吗？</li></ul><p id="3aab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果答案是肯定的，你可以考虑应用函数式编程。</p><p id="25dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到正题，我想在这里简单解释一下功能接口。在JDK8中引入，它们有<code class="fe lv lw lx ly b">@Functioninterface</code>注释，通常每个只有一个抽象方法。它们在Java中最重要的作用是提供多上下文环境中的转换。根据数学概念，它们分为两种类型，<strong class="la iu">一元</strong>和<strong class="la iu">二元</strong>函数。</p><ul class=""><li id="7420" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">一元函数包括<code class="fe lv lw lx ly b">Function&lt;T, R&gt;, Consumer&lt;T&gt;, Supplier&lt;T&gt;, Predicate&lt;T&gt;, UnaryOperator&lt;T&gt;.</code></li><li id="2f68" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">二进制函数包括<code class="fe lv lw lx ly b">BiFunction&lt;T, U, R&gt;, BiConsumer&lt;T, U&gt;, BiPredicate&lt;T, U&gt;, BiOperator&lt;T&gt;.</code></li></ul><p id="bd72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我一直在思考如何更好地解释函数接口。当然，我可以像在许多其他文章中一样通过例子来说明，但是我确信包含一些关键因素的表格和不同界面之间的比较更实用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/dc67cd8536af7c476527fb271f7238d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4o17ZNoahUi0qItWygZ1g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一元和二元函数接口</figcaption></figure><p id="d488" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">Consumer</code>和<code class="fe lv lw lx ly b">Supplier</code>接口很容易通过名字得到，不管是一元的还是二元的。<code class="fe lv lw lx ly b">Consumer</code>接口运行一个没有返回类型的动作<strong class="la iu">，因此它们将所有的东西传递给<code class="fe lv lw lx ly b">Void</code>。<code class="fe lv lw lx ly b">Supplier</code>接口被认为是生成器，在那里<code class="fe lv lw lx ly b">Stream&lt;T&gt;</code>或<code class="fe lv lw lx ly b">CompletionStage&lt;T&gt;</code>开始。</strong></p><p id="1490" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">Function&lt;T,U&gt; and Function&lt;T,U,R&gt;</code>接口广泛用于不同方法之间的组合和传输，使管道保持活动。</p><p id="e5b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你仍然对我的表感到困惑，在这里阅读一些代码示例<a class="ae nk" href="https://examples.javacodegeeks.com/java-functional-interface-example/" rel="noopener ugc nofollow" target="_blank">可能会有所帮助。再次回到表中，你会对函数接口有进一步的理解。</a></p><p id="0679" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">CompletionStage</code>API大量使用<code class="fe lv lw lx ly b">Consumer</code>、<code class="fe lv lw lx ly b">Function</code>、<code class="fe lv lw lx ly b">BiFunction</code>。因此，关键是如何根据代码的行为将多个阶段组合成一个阶段。我参与的一个项目就是一个很好的例子，它需要读取包含多个资源文件(比如服务、部署和HPA)的Kubernetes文件夹，使用<a class="ae nk" href="https://github.com/fabric8io/kubernetes-client" rel="noopener ugc nofollow" target="_blank"> fabric8 KubernetesClient库</a>将它们应用到客户端，返回结果或错误。为了简化，我把它分成四个阶段:</p><ul class=""><li id="0576" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">读取目录；</li><li id="c958" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">向客户端进行身份验证；</li><li id="cf20" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">应用资源的Yamls</li><li id="05ea" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">最后，回归。</li></ul><p id="49e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同时，所有代码通过<code class="fe lv lw lx ly b">CompletionStage</code>异步运行。</p><p id="15ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是四个阶段之间的一个简单的<code class="fe lv lw lx ly b">CompletionStage</code>转换图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/8a436516a401ac9d0db2cab2c0a35149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHz0N03g6hKpg04G4KQLGg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">划分任务阶段</figcaption></figure><p id="b857" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">限于文章范围，我这里只粘贴一些关键代码。</p><ul class=""><li id="79f2" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">ApplyResource</code>作为主要阶层和入口。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/3f046fe44c92117508129e065f632fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*z3d4dXcPJWCe08iRo6skwg.png"/></div></figure><ul class=""><li id="0ec8" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">为了在阶段之间传递不同的结果，我使用了一个<code class="fe lv lw lx ly b">Pipeline&lt;T&gt;</code>类。这里<code class="fe lv lw lx ly b">T</code>是魔法发生的地方！</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/084fdf32acbbe01dab51042b0cd86ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9-zQDQdDLxASdelYONYqyA.png"/></div></div></figure><ul class=""><li id="7882" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">readFiles</code>方法。流水线从这里开始并返回一个<code class="fe lv lw lx ly b">CompletionStage&lt;Pipeline&lt;Stream&lt;Path&gt;&gt;&gt;.</code></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/e2655b1b0cd449c9dd65fb95d68d48eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gO6J6n_PkvBIXDIPqT9FQ.png"/></div></div></figure><ul class=""><li id="663a" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><code class="fe lv lw lx ly b">authenticate</code>方法。这个方法的结果与前面的<code class="fe lv lw lx ly b">readFiles</code>方法完全无关，所以我们需要将两个结果都转换成一个新的<code class="fe lv lw lx ly b">FileAndAuth</code>对象，并将其(<code class="fe lv lw lx ly b">Pipeline&lt;FileAndAuth&gt;</code>)带入下一个阶段。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/538a5d12cb675842014e6023cbd995e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xWKdvncknRG6awFx4wAm7A.png"/></div></div></figure><ul class=""><li id="4166" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">下一步是用Kubernetes客户机应用带有身份验证信息的所有配置，并最终返回一个<code class="fe lv lw lx ly b">Pipeline&lt;Result&gt;</code>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/855bad7b52755ae0b22e26ccdcb250e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XnerkVPYf9BE-8ouILXMWg.png"/></div></div></figure><ul class=""><li id="769c" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">最后，我们可以处理错误或返回结果。</li></ul><p id="5d7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上的概念和API对于一个新手来说可能有点不知所措，我再分享一个小技巧，就是记住API的param类型——Runnable类型，忽略计算结果。</p><p id="5804" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b"><strong class="la iu">Consumer</strong></code> <strong class="la iu">是纯消费计算结果；</strong> <code class="fe lv lw lx ly b"><strong class="la iu">BiConsumer</strong></code> <strong class="la iu">融合了另一种</strong> <code class="fe lv lw lx ly b"><strong class="la iu">CompletionStage</strong></code> <strong class="la iu">的纯粹消费；</strong> <code class="fe lv lw lx ly b"><strong class="la iu">Function</strong></code> <strong class="la iu">转换计算结果；</strong> <code class="fe lv lw lx ly b"><strong class="la iu">BiFunction</strong></code> <strong class="la iu">结合另一个</strong> <code class="fe lv lw lx ly b"><strong class="la iu">CompletionStage</strong></code> <strong class="la iu">的计算结果进行换算。</strong></p><h1 id="4eb4" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">异步编程的优势</h1><p id="63a4" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">如上所述，使用<code class="fe lv lw lx ly b">AutoValue</code>和<code class="fe lv lw lx ly b">CompletionStage</code>来构建一个完全异步的程序是Spotify的工作方式。关于为什么这样选择，我从我的角度列举了四个原因。</p><ul class=""><li id="e638" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><strong class="la iu">安全</strong></li></ul><p id="d31c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不可变数据模型将开发人员从对并发处理、死锁、糟糕的性能和其他复杂情况的担忧中解放出来。</p><ul class=""><li id="a3f1" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><strong class="la iu">更容易变异</strong></li></ul><p id="ca41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不可变的数据模型和所有的功能接口使得改变数据更加容易。任何东西都是复制的，不是更新的。不再有内存障碍或锁，而是简洁易读的代码。关于函数式编程的更多优势，在这里阅读更多<a class="ae nk" href="https://alvinalexander.com/scala/fp-book/benefits-of-functional-programming/" rel="noopener ugc nofollow" target="_blank">。</a></p><ul class=""><li id="99d6" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><strong class="la iu">性能</strong></li></ul><p id="2836" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至于程序性能，<code class="fe lv lw lx ly b">CompletionStage</code>使程序能够利用多核CPU，摆脱管理线程的负担。与多线程相比，异步显得更加轻量级。此外，工作效率也得到了提高，因为<code class="fe lv lw lx ly b">CompletionStage</code>比并发代码对开发人员更友好。</p><ul class=""><li id="4621" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><strong class="la iu">可扩展性</strong></li></ul><p id="865b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让你的服务保持无状态，让它幂等。为什么？因为您的代码比其他代码更易于扩展。主要的云提供商都支持通过Kubernetes进行自动伸缩，这很适合这种情况。您的程序变得更加云友好！</p><h1 id="916d" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">需要改进的地方</h1><p id="f904" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">没有什么是完美的，这种代码模式也是如此。我在练习中遇到一些麻烦。</p><ul class=""><li id="b7e7" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">很难写</li></ul><p id="8568" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“丑陋的”代码和优雅的代码都可以运行并达到结果。但是后者更具挑战性，除非你有多年的实践经验并对API有深刻的理解。</p><ul class=""><li id="52ef" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">难以编写测试</li></ul><p id="666f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开发人员花三分之二的时间编写测试，在这种情况下你甚至需要更多的时间，因为异步代码总是很难测试。</p><p id="b5f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论如何，在我与AutoValue和<code class="fe lv lw lx ly b">CompletionStage</code>的旅程中有苦有甜。听起来我有自己的选择。🤷‍♀️</p><h1 id="8f67" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">可供选择的事物</h1><p id="7a1f" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">其实已经有很多开放框架采用了这种异步编程模式，比如<a class="ae nk" href="https://www.playframework.com/" rel="noopener ugc nofollow" target="_blank"> Play </a>(一种无状态的web框架)<a class="ae nk" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank">quar kus</a>(Kubernetes Java客户端)<a class="ae nk" href="https://lettuce.io/" rel="noopener ugc nofollow" target="_blank">莴苣</a>(非块Redis客户端)等。</p><p id="7c73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，如果你真的很难开始自己构建东西，那么选择一个合适的库来帮助你开始并从中吸收必要的编码技能。最终，用自己的方式编写完全异步的代码。</p><h1 id="25af" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">待续</h1><p id="8841" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">读完这篇文章后，也许你看到了异步编程的好处，迫不及待地想实践它。我希望我的<code class="fe lv lw lx ly b">CompletionStage</code>学习方法可以帮助你。</p><p id="cddb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我计划详细说明<code class="fe lv lw lx ly b">CompletionStage</code>的内部实现，并在将来提供更多的想法。</p><p id="328c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您有任何建议或问题，请留言。</p><p id="e419" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读！</p></div></div>    
</body>
</html>