<html>
<head>
<title>Node.js Basics — Files and HTTP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js基础—文件和HTTP</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-basics-files-and-http-14cc2626cc07?source=collection_archive---------7-----------------------#2020-06-14">https://levelup.gitconnected.com/node-js-basics-files-and-http-14cc2626cc07?source=collection_archive---------7-----------------------#2020-06-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ea0a56b1b8afc5d51806a486d1c7843c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s1qyhpXNys7tj3Fk"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@ivanjevtic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊万·耶维奇</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="9bd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是世界上最流行的编程语言之一。为了有效地使用它，我们必须了解它的基本知识。</p><p id="c189" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解Node.js的基础知识，包括使用文件、创建web服务器和请求制作服务器。</p><h1 id="7012" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">文件系统模块</h1><p id="49b5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Node.js标准库附带了<code class="fe mh mi mj mk b">fs</code>模块，让我们可以操作文件系统上的项目。</p><p id="9155" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下代码从计算机中读取文件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e940" class="mt lf it mk b gy mu mv l mw mx">const { readFile } = require("fs");<br/>readFile("foo.txt", "utf8", (error, text) =&gt; {<br/>  if (error) throw error;<br/>  console.log(text);<br/>});</span></pre><p id="d59b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从<code class="fe mh mi mj mk b">fs</code>模块中导入了<code class="fe mh mi mj mk b">readFile</code>方法。</p><p id="b52f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用文件路径、编码调用它，用错误或文件内容回调它。</p><p id="f01a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">error</code>遇到错误。</p><p id="b07d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们使用<code class="fe mh mi mj mk b">writeFile</code>方法将文件写入文件系统。</p><p id="450f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6082" class="mt lf it mk b gy mu mv l mw mx">const { writeFile } = require("fs");<br/>writeFile("bar.txt", "hello", (error) =&gt; {<br/>  if (error) {<br/>    throw error;<br/>  }<br/>});</span></pre><p id="fefd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们传入文件路径、文件内容和一个在试图写入文件后调用的回调。</p><p id="58cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">error</code>遇到错误。</p><p id="e5e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有必要指定编码。</p><p id="430e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">writeFile</code>将假设当它把一个字符串写入一个文件时。</p><p id="2b80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些方法有一些很有前途的版本，可以使链接变得更容易。</p><p id="ba8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以通过编写以下代码来使用<code class="fe mh mi mj mk b">readFile</code>的promise版本:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3a50" class="mt lf it mk b gy mu mv l mw mx">const {readFile} = require("fs").promises;</span><span id="3dd3" class="mt lf it mk b gy my mv l mw mx">(async () =&gt; {<br/>  const text = await readFile("foo.txt", "utf8");<br/>  console.log(text);<br/>})()</span></pre><p id="6924" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码需要<code class="fe mh mi mj mk b">readFile</code>的promise版本。</p><p id="c316" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以使用异步函数来读取文件，而不是使用回调。</p><p id="9804" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个同步版本的<code class="fe mh mi mj mk b">readFile</code>叫做<code class="fe mh mi mj mk b">readFileSync</code> /</p><p id="57f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="de6e" class="mt lf it mk b gy mu mv l mw mx">const { readFileSync } = require("fs");<br/>console.log(readFileSync("foo.txt", "utf8"));</span></pre><p id="bd2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">readFileSync</code>只返回文件内容，而不解析为值或用文件内容调用回调。</p><h1 id="5a43" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">HTTP模块</h1><p id="3763" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Node.js还附带了一个HTTP模块，我们可以用它来构建自己的HTTP服务器。</p><p id="48b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要创建一个基本的HTTP服务器，我们可以使用<code class="fe mh mi mj mk b">createServer</code>方法:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6620" class="mt lf it mk b gy mu mv l mw mx">const {createServer} = require("http");<br/>const server = createServer((request, response) =&gt; {<br/>  response.writeHead(200, {"Content-Type": "text/html"});<br/>  response.write(`hello ${request.url}`);<br/>  response.end();<br/>});<br/>server.listen(8000);</span></pre><p id="ec2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用具有<code class="fe mh mi mj mk b">request</code>和<code class="fe mh mi mj mk b">response</code>参数的回调函数调用了<code class="fe mh mi mj mk b">createServer</code>。</p><p id="9085" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们分别包含请求和响应对象。</p><p id="e623" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">response</code>对象可用于做出响应。</p><p id="bea6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">request</code>包含URL、正文、标题等内容。</p><p id="886c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们创建了服务器，我们就必须用一个端口来监听请求，以便客户端可以向它发出请求。</p><p id="1619" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们转到<code class="fe mh mi mj mk b">localhost:8000</code>，应该会显示<code class="fe mh mi mj mk b">hello /</code>。</p><p id="8f6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">request.url</code>有相对网址。</p><p id="063c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">writeHead</code>写入响应报头。200是状态码，代表OK。</p><p id="8d39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">write</code>写回复正文。</p><p id="2088" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们必须调用<code class="fe mh mi mj mk b">end</code>来结束响应。</p><p id="22d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用Node.js应用程序向服务器发出请求，我们可以使用<code class="fe mh mi mj mk b">request</code>方法来完成。</p><p id="f301" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5209" class="mt lf it mk b gy mu mv l mw mx">const { request } = require("http");<br/>const requestStream = request({<br/>  hostname: "example.com",<br/>  path: "/",<br/>  method: "GET",<br/>  headers: { Accept: "text/html" }<br/>}, response =&gt; {<br/>  console.log(response.statusCode);<br/>});<br/>requestStream.end();</span></pre><p id="b685" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从<code class="fe mh mi mj mk b">http</code>模块中获取<code class="fe mh mi mj mk b">request</code>方法。</p><p id="3a7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将一个对象传入带有<code class="fe mh mi mj mk b">hostname</code>的<code class="fe mh mi mj mk b">request</code>函数，这是主机名。</p><p id="7d0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">path</code>具有相对于主机名的路径。</p><p id="2a2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">method</code>是请求方法。</p><p id="d6b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">headers</code>有我们想要设置的标题。</p><p id="95d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们传入一个带有<code class="fe mh mi mj mk b">response</code>参数的回调，该参数有响应。</p><p id="3ad6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">statusCode</code>有状态码。</p><p id="ddb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">https</code>模块中还有一个<code class="fe mh mi mj mk b">request</code>函数，让我们发出HTTPS请求。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/9dd066b0669e2f45980eaa4408f8403c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z4ciZshb0j9fYPzg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">菲尔·古德温在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="93e7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="6643" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过使用<code class="fe mh mi mj mk b">fs</code>模块来操作文件系统。</p><p id="1220" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数有承诺、回调和同步版本。</p><p id="2e7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">HTTP模块让我们创建web服务器。</p><p id="e9b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还有一个发出请求的功能。</p><p id="b5bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mh mi mj mk b">request</code>模块，我们可以通过传递URL、头部和主体来发出请求。</p><p id="ec4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以通过传入回调来获得请求的响应。</p></div></div>    
</body>
</html>