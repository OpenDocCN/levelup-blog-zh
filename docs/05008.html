<html>
<head>
<title>Let’s Supercharge Our CI — Detecting “accidental” secrets early in our code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们增强我们的CI——在代码早期检测“意外”的秘密</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lets-supercharge-our-ci-detecting-accidental-secrets-early-in-our-code-195b753692ed?source=collection_archive---------12-----------------------#2020-07-29">https://levelup.gitconnected.com/lets-supercharge-our-ci-detecting-accidental-secrets-early-in-our-code-195b753692ed?source=collection_archive---------12-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/53f18a2a3ea9e569eca4a837627d9692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0en0Mpov1xm32JkL.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="https://pixabay.com/illustrations/binary-magnifying-glass-hand-http-1607161/" rel="noopener ugc nofollow" target="_blank"> pixabay </a>，作者:<a class="ae kf" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> geralt </a></figcaption></figure><blockquote class="kg kh ki"><p id="b780" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">梳理我们的代码就像大海捞针，那么我们如何定期保持代码的整洁呢？</p></blockquote><p id="fbe0" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated"><strong class="km iu">秘密，秘密，秘密……是我们应用的<em class="kl">【灵丹妙药】</em><em class="kl">【毒药】</em>。我们需要各种应用程序的秘密——API密钥、数据库密码等等。这允许我们授权使用某些资源，特别是当我们为这些资源的使用付费时。</strong></p><p id="86d6" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">然而，“秘密”也是我们应用程序的祸根。如果保护不当，我们有可能将您组织的隐私信息泄露给潜在的恶意方，或者更糟的是，违反我们组织拥有的用户数据的各种隐私法律。</p><p id="bd80" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">之前，我介绍过如何使用Yelp的detect-secrets来防止代码提交秘密，使用预提交钩子。我还介绍了如何使用我创建的名为<a class="ae kf" href="https://www.npmjs.com/package/detect-secrets-node" rel="noopener ugc nofollow" target="_blank"> detect-secrets-node </a>的节点模块，将这个预提交挂钩扩展到开发人员设备上的每个克隆节点项目。</p><p id="3298" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">然而，由于预提交挂钩只存在于本地机器上，并且无法被监控，因此并不总是保证能够工作。<strong class="km iu">因此，需要采取全面的措施，以便在机密泄露到您的远程存储库时有效地监控机密，从而能够及时地对这些机密做出反应并进行轮换。</strong></p></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h1 id="324b" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">重访“探秘”</h1><p id="36e1" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku li ms kx ky lj mt lb lc lk mu lf lg lh im bi translated">回到Yelp的<a class="ae kf" href="https://github.com/Yelp/detect-secrets" rel="noopener ugc nofollow" target="_blank"> detect-secrets </a>，我们知道它可以用于扫描文件的秘密，还可以将误报列入白名单以减少噪音。他们的实现还提供了一个名为<a class="ae kf" href="https://github.com/Yelp/detect-secrets-server" rel="noopener ugc nofollow" target="_blank"> detect-secrets-server </a>的服务器端组件，可用于定期扫描选定的存储库，并在检测到机密时发送警报。</p><p id="7c57" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">将这一工作流程与我们自己的CI工具整合起来怎么样？如果每个构建都是由对某个目标分支的新提交触发的，我们难道不能在它发生时设法捕捉这些事件吗？这也将使我们能够以更一致的方式进行这种验证，确保我们可以在泄露机密的情况下进行轮换。</p></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h1 id="f1a3" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">“容器”和探测秘密</h1><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/fb7ccddbaa616e8c59dfd69d4869ba8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AiAYDwoCXv8Gsxd8.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="https://pixabay.com/photos/container-port-loading-stacked-3118783/" rel="noopener ugc nofollow" target="_blank"> pixabay </a>，作者:<a class="ae kf" href="https://pixabay.com/users/distelAPPArath-2726923/" rel="noopener ugc nofollow" target="_blank">distelaparth</a></figcaption></figure><p id="fed7" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">在决定如何构建这个工具时，我考虑了应该为哪个平台构建它。然后，我突然想到，大多数现代CI工具似乎都支持针对定制需求的定制Docker映像——<a class="ae kf" href="https://cloud.google.com/cloud-build/docs/configuring-builds/use-community-and-custom-builders#creating_a_custom_builder" rel="noopener ugc nofollow" target="_blank">云构建</a>、<a class="ae kf" href="https://circleci.com/docs/2.0/custom-images/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>、<a class="ae kf" href="https://docs.drone.io/pipeline/docker/syntax/images/" rel="noopener ugc nofollow" target="_blank">无人机</a>等等。构建Docker映像来执行扫描，也可以更容易地为不同管道的不同项目进行推广。</p><p id="f69c" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">基于以上内容，我能够从detect-secrets创建<a class="ae kf" href="https://github.com/Weiyuan-Lane/detect-secrets-docker" rel="noopener ugc nofollow" target="_blank"> detect-secrets-docker </a>。让我们看看如何使用这个库来保护您的代码库。</p></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h1 id="ee5a" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">步骤1 —“列入白名单”可接受的内容</h1><p id="8fe2" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku li ms kx ky lj mt lb lc lk mu lf lg lh im bi translated">在我们将secret scanning Docker映像集成到CI之前，我们需要首先将我们的存储库的当前状态列入白名单。为什么？看看下面的图片:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/876312b046ac604c182f17161498df79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0R5Q2732Jep5SvqjRNb4zg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">package-lock.json中的内容示例</figcaption></figure><p id="abfa" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">如果您熟悉使用节点模块的项目，上面的场景应该很熟悉。它代表<a class="ae kf" href="https://docs.npmjs.com/configuring-npm/package-lock-json.html" rel="noopener ugc nofollow" target="_blank"><em class="kl">package-lock . JSON</em></a>文件，可以包含类似于高亮显示的哈希值。如果没有列入白名单，它可能会被检测为潜在机密，从而导致误报。其他语言如Golang，在管理go模块的<a class="ae kf" href="https://blog.golang.org/using-go-modules" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> go.sum </em> </a>文件中也包含类似的内容。</p><p id="dc57" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">要将内容列入白名单，我们需要首先准备好环境。</p><p id="027c" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">从<a class="ae kf" href="https://github.com/Weiyuan-Lane/detect-secrets-docker" rel="noopener ugc nofollow" target="_blank"> detect-secrets-docker </a>存储库中，克隆它，并运行以下命令来构建docker映像:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="1f9d" class="ng lt it nc b gy nh ni l nj nk">docker build -f Dockerfile.base -t detect-secrets-docker .</span></pre><p id="e276" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">一旦构建了上面的映像，转到这个集成的目标代码库的根目录，并运行下面的命令:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="3bd4" class="ng lt it nc b gy nh ni l nj nk">docker run --name detect-secrets-docker -v $(pwd):/opt --entrypoint "create-basefiles" detect-secrets-docker</span></pre><p id="a82e" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">成功返回后，您应该会在本地存储库中看到以下文件:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3e9e39fc15ff3b19277d28dd10f3f78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*gYnbJImY5TMfxF4OmedWDQ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">. secrets.baseline和. secrets.lasthash</figcaption></figure><p id="bd0c" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">上述文件包含对为所有文件生成的基线的引用，以及当前的提交散列。这对我们以后的扫描程序很重要！让我们提交这些文件。</p><h1 id="17d3" class="ls lt it bd lu lv nm lx ly lz nn mb mc md no mf mg mh np mj mk ml nq mn mo mp bi translated">步骤2 —构建自定义配置项映像</h1><p id="4363" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku li ms kx ky lj mt lb lc lk mu lf lg lh im bi translated">接下来，我们需要构建一个映像，它将扫描管道中的代码。回到<a class="ae kf" href="https://github.com/Weiyuan-Lane/detect-secrets-docker" rel="noopener ugc nofollow" target="_blank"> detect-secrets-docker </a>的根目录，运行下面的命令来构建想要的docker映像:</p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="1e26" class="ng lt it nc b gy nh ni l nj nk">docker build -f Dockerfile.ci -t detect-secrets-docker-ci:latest .</span></pre><p id="015f" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">注意，在上面，我已经将<strong class="km iu">图像名称</strong>和<strong class="km iu">标签</strong>分别设置为<code class="fe nr ns nt nc b">detect-secrets-docker-ci</code>和<code class="fe nr ns nt nc b">latest</code>。根据您自己的配置，您可以更改这些值以适合您的图像存储库。例如，在GCP的云构建上，你可以使用容器注册表(参见这里的说明<a class="ae kf" href="https://github.com/Weiyuan-Lane/detect-secrets-docker-cloudbuild#detect-secrets-docker-cloudbuild" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="e0ab" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">将这个Docker映像推送到您的映像存储库，我们将在下一步中使用它。</p><h1 id="908e" class="ls lt it bd lu lv nm lx ly lz nn mb mc md no mf mg mh np mj mk ml nq mn mo mp bi translated">第3步—让我们来测试一下！</h1><p id="1d47" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku li ms kx ky lj mt lb lc lk mu lf lg lh im bi translated">准备好代码库，构建并推送自定义Docker映像后，让我们测试一下管道，看看它是否工作。</p><p id="a645" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">在这一步中，我将使用云构建来满足我的CI需求。但是，您可以将以下任何说明替换为CI工具中的等效说明。</p><p id="7aff" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">从管道配置开始，我们有以下云构建(使用yaml文件):</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="84c9" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">重要的是第7行到第9行，它们将执行对代码库的扫描。仅此而已！</p><p id="9cbc" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated"><em class="kl">(旁注:</em> <strong class="km iu"> <em class="kl">在云构建</em> </strong> <em class="kl">的情况下，第2行到第5行也是必不可少的，这里的代码是一个浅层git克隆，不包含用于所需比较的其他提交)</em></p><p id="f26c" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">让我们来看看这是如何工作的。我在我的代码库中添加了一些虚假的秘密来测试它，这立即导致了一个失败的构建。</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/dc6904f23701005fe88f874c068caad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEmuSCFm76SMa3bhJsHH8Q.png"/></div></div></figure><p id="918f" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">使用detect-secrets，我们能够在第5行显示出<code class="fe nr ns nt nc b">app.js</code>有一个秘密，正如我们预期的那样！这条错误路线是我有意为之的，见这里的<a class="ae kf" href="https://github.com/Weiyuan-Lane/detect-secrets-docker-cloudbuild/commit/7e03b480f92e65305c6a8c980750a52131197435" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="cab7" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated"><strong class="km iu">最明显的解决方法是删除第5行的</strong> <code class="fe nr ns nt nc b"><strong class="km iu">app.js</strong></code> <strong class="km iu">。但是，如果打算添加这一行，您可以在本地运行下面的命令将内容列入白名单:</strong></p><pre class="mw mx my mz gt nb nc nd ne aw nf bi"><span id="a1d3" class="ng lt it nc b gy nh ni l nj nk">docker run --name detect-secrets-docker -v $(pwd):/opt --entrypoint "update-basefiles" detect-secrets-docker</span></pre><p id="aa23" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">提交您的新基线文件，您应该可以开始了！</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/e1925040b9e1e0e3181cefb5061bdb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gQDljVlWth4idRuKvyDZOA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">:D</figcaption></figure></div><div class="ab cl ll lm hx ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="im in io ip iq"><h1 id="b86a" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">还有吗？</h1><p id="d6ad" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku li ms kx ky lj mt lb lc lk mu lf lg lh im bi translated">假设你已经使用上面的方法在你的存储库中发现了秘密，并且成功地移除了秘密，这实际上并不是结束。本地和远程存储库中的悬空提交可能会存在一段时间。例如，在GitHub上，只要散列是已知的，就仍然可以在web控制台上访问提交。有一些方法可以删除这些内容，如这里的<a class="ae kf" href="https://medium.com/dev-genius/its-a-trap-committing-bad-stuff-to-github-and-fixing-the-mistake-12ccb080fa02" rel="noopener">所探讨的</a>。</p><p id="7468" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">就这些，我希望你喜欢我创建的这个附带项目，主要是供我和我的组织使用。我大力提倡易用性，这样我们就可以很容易地扩大使用范围，我希望上面所说的能够快速简单地实现。如果您对此有任何反馈，请告诉我！</p><p id="5537" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku li kw kx ky lj la lb lc lk le lf lg lh im bi translated">Ciao~</p></div></div>    
</body>
</html>