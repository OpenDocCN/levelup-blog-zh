# 面向 JavaScript 开发人员的函数式编程— Map

> 原文：<https://levelup.gitconnected.com/functional-programming-for-javascript-developers-map-3627494cb5a6>

## 你可能完全误解了地图

![](img/d480e86315e3e41e607602d6c76dbcdb.png)

欢迎来到面向 JavaScript 开发人员的函数式编程的第 4 部分。今天我们将讨论`map`函数，以及我们如何在函数式编程(FP)中利用它。当我第一次开始学习`Array.map`方法时，我认为它的主要目的是有一个快捷方式来循环数组中的项目。但是正如你将看到的，`map`实际上根本不是关于循环的。

## 高阶函数

刚开始时，可能很难理解什么是高阶函数以及它是如何工作的。简而言之，高阶函数是以一个或多个函数作为自变量的函数。它可以是以前定义的函数，也可以只是 lambda 函数。让我给你看几个关于`map`的例子。

所以，正如你所料，`map`是一个高阶函数。作为一名函数式程序员，你经常使用高阶函数的概念。这不仅限于`map`，我们还创建了许多自己的高阶函数。如果你也熟悉`filter`和`reduce`，你可能已经用了很多了。

## Array.map 是如何工作的？

我认为现在这种情况可能已经改变了，但是不久前开发人员避免使用`map`并坚持使用他们的旧`for`循环。如果你是一个在操作数组时仍然执着于循环的人，让我举一个例子来比较这两种方法:

希望我们能同意`map`在提高可读性方面做得很好。实际上，在我开始用函数式风格编程之后，我已经完全从我的武器库中移除了`for`循环。我根本不需要它们。我现在有了更好的工具来做这项工作。

简而言之,`Array.map`是这样工作的:它循环遍历每一项，应用一个返回一些新数据的函数，并返回一个包含新数据的新`array`,而不改变您映射的原始`array`。应用的函数可以返回它想要的任何数据。它不必与传入的类型相同。但是，返回的数组将具有与原始数组相同的长度。

## 为数组创建我们自己的映射函数

内置的`Array.map`有一些我们作为函数式程序员不喜欢的限制。如果你读过以前关于[作曲](/functional-programming-for-javascript-developers-compose-508d71b4e7b8)和[奉承](/functional-programming-for-javascript-developers-currying-2d16766909e9)的文章，你可能会明白为什么。

为了使函数可组合，我们希望我们操作的数据是传入的最后一个参数。所以，让我们自己做一个满足这个标准的函数。

```
const map = f => arr => arr.map(f);
```

啊，好多了！现在我们有了自己定制的`map`功能。它是这样工作的:

```
map (*n* => n * 2) ([1, 2, 3]); 
// [2, 4, 6]
```

什么？这怎么更好？嗯，现在我们可以`compose`用它了。而且函数式程序员真的很爱`compose`。让我向你展示我们如何使用新的地图功能。

你看到了吗？我们的新`map`与 compose 完美配合。

## 地图不是关于循环的

正如我在介绍中提到的，这是一个非常普遍的误解，认为`map`是一种编写循环的奇特方式。但是，循环根本不是主要特性。

> Map 是一个函数，允许您访问容器内部的数据并对其进行操作，而不改变原始数据。

到目前为止，我们例子中的容器是`array`。当谈到 JavaScript 中的内置函数时，`array`是唯一拥有`map`方法的类型。

在函数式编程中，我们有其他的容器可以使用。所有这些都有自己的地图功能。在本文中，我不会深入讨论这些容器的细节，那是以后的事了。但是现在，我希望你把容器想象成一个可以包含数据的东西。每个容器都有一些非常有用的能力。

数组有很多不同的能力，让你的生活更轻松。想象一下不用数组编写 JavaScript。所有你需要手动完成的事情。这里有一个引子，在 FP 中，我们可以使用很多不同类型的容器，这让我们的生活变得更容易。所以请继续关注，因为我认为它会让你大吃一惊。

## 容器

为了帮助您更好地理解容器，让我们创建一个不会让您大吃一惊的容器。因为除了不变性，它不会有任何有用的特性。请记住，我现在所做的一切都是为了帮助你明白`map`不仅仅是对数组起作用。在下一篇文章中，我将向你展示一些在 FP 中有用的容器。但是，这是我们无用的容器:

注意，我们在这里将`Container`定义为一个类。但是不要把它当成一门课。把它想象成一个类型，就像一个`array`一样。我鼓励你现在不要担心为什么。同样，我保证在下一篇文章中解释所有这些容器的东西。

让我们创建一个包含数据的容器。

```
const myContainer = Container.of('Hello');
```

容器中的数据可以是任何东西。在这种情况下，它的`string`‘你好’。现在，我们如何访问和操作`myContainer`中的数据呢？嗯，我们可以将`myContainer.$value`设置为一个新值。但是这是一个巨大的禁忌。我们从来都不想改变数据，不是吗？所以我们需要另一种方法。你能想出别的办法吗？我在这篇文章里给了你一些提示…你得到了:`map`！

那么，让我们为容器写一个映射函数:

很好，现在我们可以像这样改变容器内部的值:

现在`myContainer2`是一个新的容器，里面有`string`‘HELLO’。记住在函数式编程中我们从不改变数据，所以`myContainer`仍然是不变的。

## 通用地图功能

你还记得我们增加了一个普通的地图功能来合成吗？实际上，还有一个原因我没有告诉你:我们需要一个除了数组以外的映射函数。我们希望它适用于所有具有`map`功能的类型。

嗯，我们很幸运…我们在开始时制作的函数已经适用于`Container`。我只是想稍微改变一下论点的名称，就像这样:

```
const map = f => a => a.map(f);
```

这就对了，我用`a`替换了`arr`只是为了说明最后一个参数可以接受任何有`map`函数的类型。很酷，对吧？我们现在已经为映射任何类型的容器奠定了基础。很抱歉在没有解释更多的情况下把这个容器概念扔给你。这可能会让你有点困惑。这完全没关系。所有这一切的目的，是为你理解`map`打下基础。一旦您阅读了本系列的下一篇文章，事情就会变得清楚了。

我内心冒泡是因为给你看这个的兴奋。我也花了一些时间才明白这一点。但是我一看到就笑得停不下来。想出这个主意的人太聪明了。那肯定不是我。我只是一个想传播消息的普通人。如果我能理解，你也能！

我真的希望这篇文章能让你对`map`的魔力有所了解。我希望您能继续关注下一部分，在那里我们真正开始使用我们的第一个容器类型`Maybe`。你已经走了很长的路了。我为你们感到兴奋，因为你们即将步入一个新的编程世界。我相信通过理解这些概念，你会成为一名更好的开发人员。你会从中获得更多的乐趣！下次见，地图绘制愉快！