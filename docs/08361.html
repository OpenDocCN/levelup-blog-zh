<html>
<head>
<title>How to (Not) Create a Factory Function in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何(不)在JavaScript中创建工厂函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-not-create-a-factory-function-in-javascript-21a2b40d104c?source=collection_archive---------6-----------------------#2021-04-25">https://levelup.gitconnected.com/how-to-not-create-a-factory-function-in-javascript-21a2b40d104c?source=collection_archive---------6-----------------------#2021-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="af3b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据对象、封装对象、克隆、闭包等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f0ad7dc62d3e064eee7291cf1ca556ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pn_IJI90_S0ptwOMBKNng.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@dariuszsankowski?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Dariusz Sankowski </a>拍摄</figcaption></figure><p id="888a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究如何用JavaScript创建工厂函数(也称为Crockford构造函数)。工厂函数是类的替代品，为了更广泛地比较它们，你可以看看<a class="ae ky" href="https://medium.com/programming-essentials/class-vs-factory-function-exploring-the-way-forward-73258b6a8d15?source=your_stories_page-------------------------------------" rel="noopener">类与工厂函数:探索前进的道路</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f8b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据对象与面向对象对象</h1><p id="5abb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在讨论一些例子之前，我们必须区分数据传输对象和OOP对象。</p><p id="c1e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据传输对象是关于公开他们的数据。它们包含原语和其他<a class="ae ky" href="https://medium.com/dailyjs/7-differences-between-objects-and-maps-in-javascript-bc901dfa9350" rel="noopener">对象</a>。如果它们包含任何方法，它们都是关于从现有方法中计算派生数据的。</p><p id="27c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">OOP对象是关于隐藏数据和公开一小部分处理数据的公共方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a85b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，让我们看看我遇到的一些有问题的工厂函数的例子并讨论它们。</p><h1 id="85c2" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated">可疑示例1</h1><p id="0b65" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能会发现的第一个示例如下所示。它从一个<a class="ae ky" href="https://medium.com/dailyjs/15-fundamentals-you-should-know-on-javascript-objects-90f57cc9d78d" rel="noopener">对象</a>中提取一些属性，然后创建具有相同属性的新对象。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="28c6" class="nj md it nf b gy nk nl l nm nn">const createPerson = ({ fname, lname }) =&gt; ({<br/>  fname,<br/>  lname<br/>});</span></pre><p id="bae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要注意的是，这种例子是关于创建一个新的普通数据对象。从我们可以看到，它只是克隆现有的对象或创建一个与初始道具子集的副本。</p><p id="8fa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想克隆一个简单的对象，我们可以简单地使用扩展操作符。除了函数名之外，我看不出创建一个新函数有什么额外的价值。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="8aa9" class="nj md it nf b gy nk nl l nm nn">const obj = { fname: 'Jhon', lname: 'Locke' };<br/>const clone = { ...obj }</span></pre><p id="e1d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要注意，在这种例子中，属性是原语或普通数据对象，而不是函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f047" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">可疑示例2</h1><p id="76c8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">下面是你可能遇到的另一个类似的例子。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="823a" class="nj md it nf b gy nk nl l nm nn">function person(fname, lname) {<br/>  const person = {};<br/>  person.fname = fname;<br/>  person.lname = lname; <br/>  return person;<br/>}</span></pre><p id="88be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与函数创建普通对象的想法是一样的。</p><p id="9e95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次我们没有输入对象，只有一些值，我们想从这些值创建一个新的对象。</p><p id="ef28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种<a class="ae ky" href="https://medium.com/dailyjs/15-fundamentals-you-should-know-on-javascript-objects-90f57cc9d78d" rel="noopener">对象</a>也可以使用对象的简写符号动态完成。下面是一个例子。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="493d" class="nj md it nf b gy nk nl l nm nn">const fname = 'Jhon';<br/>const lname = 'Locke'</span><span id="9787" class="nj md it nf b gy no nl l nm nn">const obj = { fname, lname };</span></pre><p id="693d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，除了函数名，我看不出使用新函数的价值。我真的不理解这种方法的附加价值，称之为模式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e195" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">可疑示例3</h1><p id="68d4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是你可能遇到的另一个例子。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="f692" class="nj md it nf b gy nk nl l nm nn">function person(fname, lname){<br/>  const fullname = () =&gt; `${fname} ${lname}`;<br/>  return {<br/>    fname,<br/>    lname,<br/>    fullname<br/>  }<br/>}</span><span id="cb9e" class="nj md it nf b gy no nl l nm nn">const person1 = person('John', 'Locke');<br/>person1.fullname();<br/>//John Locke</span></pre><p id="1c11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次有所不同，新对象有了方法。这种例子开始增加一些价值。我们正在创建一个新的对象，但也添加了一些方法来检索数据。</p><p id="b5f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这些方法只不过是计算导数数据。我们仍在构建数据结构。</p><p id="8287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些种类的<a class="ae ky" href="https://betterprogramming.pub/did-you-know-that-almost-everything-is-an-object-in-javascript-f06c3f69faf1" rel="noopener ugc nofollow" target="_blank">对象</a>仍然是关于传输公共数据的。我会说，我们可以添加包含结果的计算属性，而不是在它们上面创建新方法。当这样做时，所有使用数据对象的代码都不必再次计算派生的数据。这些数据传输对象无论如何都应该是不可变的，这样计算出的值就不会改变。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="e1a8" class="nj md it nf b gy nk nl l nm nn">function person(fname, lname){<br/>  const fullname = `${fname} ${lname}`;<br/>  return {<br/>    fname,<br/>    lname,<br/>    fullname<br/>  }<br/>}</span><span id="860a" class="nj md it nf b gy no nl l nm nn">const person1 = person('John', 'Locke');<br/>person1.fullname;<br/>//John Locke</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="773e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">可疑示例4</h1><p id="0eb9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能注意到的另一个示例如下所示。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="83bb" class="nj md it nf b gy nk nl l nm nn">function createPerson(name) {<br/>    function getName() {<br/>        return name;<br/>    }<br/>    <br/>    return Object.freeze({<br/>        name,<br/>        getName<br/>    });<br/>}</span><span id="938c" class="nj md it nf b gy no nl l nm nn">const person = createPerson('John Locke');<br/>console.log(person.name)</span></pre><p id="7d5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下,<code class="fe np nq nr nf b">getName</code>方法毫无意义。它只不过返回与<code class="fe np nq nr nf b">name</code>属性相同的数据。我们仍在构建数据结构。这个例子唯一的好处是，它指出了通过在返回的对象上使用<code class="fe np nq nr nf b">Object.freeze</code>，普通的传输对象应该是不可变的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cf72" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">工厂功能</h1><p id="4a11" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">所有以前的例子都遗漏了一些东西。他们正在构建数据结构，这意味着<a class="ae ky" href="https://betterprogramming.pub/did-you-know-that-almost-everything-is-an-object-in-javascript-f06c3f69faf1" rel="noopener ugc nofollow" target="_blank">对象</a>及其所有的公共属性。</p><p id="9a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建OOP对象的主要思想是隐藏数据和公开公共方法。开创这种模式的道格拉斯·克洛克福特强调，构造函数返回一个包含函数的对象，而不是数据。</p><p id="07ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是你如何做到这一点。</p><p id="8c6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个管理人员列表的商店。人是一个数据传输对象。<code class="fe np nq nr nf b">PersonStore</code>是工厂功能。它创建了一个<a class="ae ky" href="https://medium.com/dailyjs/7-differences-between-objects-and-maps-in-javascript-bc901dfa9350" rel="noopener">对象</a>，隐藏了条目列表并公开了使用它的公共方法。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="4fe7" class="nj md it nf b gy nk nl l nm nn">function PersonStore(){<br/>  let items = [];<br/>  <br/>  function add(person){<br/>    items.push(person);<br/>  }<br/>  <br/>  function removeById(id){<br/>    items = items.filter(p =&gt; p.id !== id);<br/>  }<br/>  <br/>  function getItems(){<br/>    return Object.freeze([...items]);<br/>  }<br/>  <br/>  return Object.freeze({<br/>    add,<br/>    removeById,<br/>    getItems<br/>  });<br/>}</span><span id="dd49" class="nj md it nf b gy no nl l nm nn">const store = PersonStore();<br/>store.add({id:1, name: 'John Lock'});<br/>store.add({id:2, name: 'Jack Shephard'});<br/>store.add({id:3, name: 'James "Sawyer" Ford'});</span><span id="d56f" class="nj md it nf b gy no nl l nm nn">store.removeById(3);<br/>store.getItems();<br/>//[<br/>//{id: 1, name: "John Lock"} <br/>//{id: 2, name: "Jack Shephard"}<br/>//</span></pre><p id="9b7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经看到了模式，有一些事情需要指出。如前所述，它返回一个包含函数的对象。它不返回包含原语或其他对象的对象。</p><p id="0496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回的对象被冻结，所以我们不能改变公共方法的定义。在JavaScript中，默认情况下对象是动态的，这意味着我们可以在创建后更改它们的所有属性。该存储区仅公开方法。通过冻结它，我们不能从外部代码中改变这些方法。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3da4" class="nj md it nf b gy nk nl l nm nn">store.add = function(){ console.log('do nothing'); }<br/>//Cannot assign to read only property 'add' of object</span></pre><p id="6f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe np nq nr nf b">items</code>变量是私有的。它不能从客户端代码中更改。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="d617" class="nj md it nf b gy nk nl l nm nn">store.items = [];<br/>//Cannot add property items, object is not extensible</span></pre><p id="8a8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，我们可以在其他函数中定义函数。<code class="fe np nq nr nf b">removeById</code>、<code class="fe np nq nr nf b">add</code>、<code class="fe np nq nr nf b">getItems</code>是在<code class="fe np nq nr nf b">PersonStore</code>函数中定义的函数。</p><p id="13c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内部函数可以从父函数中访问变量。事实上，这三个方法都是从它们的父级访问<code class="fe np nq nr nf b">items</code>变量的。</p><p id="f560" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在父函数执行之后，内部函数也可以访问这些变量。当然，在执行完<code class="fe np nq nr nf b">PersonStore</code>之后，这三个方法都会访问<code class="fe np nq nr nf b">items</code>变量。</p><p id="6bd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三个方法<code class="fe np nq nr nf b">removeById</code>、<code class="fe np nq nr nf b">add</code>、<code class="fe np nq nr nf b">getItems</code>都是闭包。</p><p id="ad65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您已经注意到的，冻结这个OOP对象的返回值是一个好主意。我们这样做是因为一旦引用超出了封装的对象，外部代码就可以用它来改变OOP对象的内部状态。本质上，从这种封装对象中检索到的数据应该被冻结并用于只读。<code class="fe np nq nr nf b">getItems</code>函数返回隐藏数组的冻结副本。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="0a0b" class="nj md it nf b gy nk nl l nm nn">function getItems(){<br/>  return Object.freeze([...items]);<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="3916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上就是我们如何用JavaScript创建工厂函数的全部内容。关于为什么使用这种模式的更多信息，你可以查看<a class="ae ky" href="https://medium.com/programming-essentials/class-vs-factory-function-exploring-the-way-forward-73258b6a8d15" rel="noopener">类与工厂函数:探索前进的道路</a>和<a class="ae ky" href="https://medium.com/programming-essentials/removing-javascripts-this-keyword-makes-it-a-better-language-here-s-why-db28060cc086" rel="noopener">没有“this”的JavaScript看起来像一种更好的函数式编程语言</a>。</p><p id="f4d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>