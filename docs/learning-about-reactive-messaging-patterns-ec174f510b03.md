# 了解反应式消息传递模式

> 原文：<https://levelup.gitconnected.com/learning-about-reactive-messaging-patterns-ec174f510b03>

![](img/b82bbc89c1f98448273f6fc00edb9fce.png)

# 概观

根据反应宣言，任何反应系统的一个关键要素是它是消息驱动的。但是消息驱动意味着什么呢？

消息驱动系统是那些主要通过异步和非阻塞消息进行通信的系统。消息使我们能够建立既有弹性又有弹性的系统，从而在各种情况下做出响应。

# 消息驱动架构

我们有各种方法来实现同步和异步消息传递。但是当我们试图使用同步消息来完成需要异步消息的任务时，或者反之亦然，事情就变得糟糕了。因此，我们需要确保在工作中使用正确的工具。

## 异步消息传递的使用

当消息无需等待响应即可发送时，使用异步消息传递。它用于避免系统的两个部分互相等待，并且一直消耗资源的情况。使用异步和非阻塞消息、线程、内存等资源。可以立即释放，减少了争用，从而提高了可伸缩性。它提供了更高的可靠性，因为在接收者离线的情况下，消息可以排队等待传递。它还允许我们让系统的一部分脱机一段时间，而让系统的其余部分继续正常运行。

## 异步消息传递的成本

异步消息使事务变得更加困难，因为事务可能长时间保持打开状态，这使得系统非常缓慢和脆弱。应该避免使用跨越微服务边界的事务，因为有些服务可能不可用，或者可能涉及多个数据库，并且长时间运行的事务会增加争用。

## 同步消息的使用

异步消息应该是反应式系统的主干。为了实现这一点，也可以使用同步消息，但是通常可以放宽对它们的要求。因此，与其发送消息并等待响应，我们可以只发送一条消息并让接收者确认他们收到了消息。

## 同步消息传递的成本

从技术上讲，使用完全同步的消息来构建通常非常方便。但是也有相关的成本。这些成本表现为无法扩展和可靠性降低。

因此，我们的目标应该是理解同步和异步消息传递之间的区别，以及在两者之间做出选择的后果。

# 保证消息的传递

当我们构建分布式系统时，我们不得不面对在分布式系统中传递消息是复杂的这一现实。我们需要小心确保有保证的消息传递，也就是说，消息应该按照预期的次数传递给正确的接收者。为了提供这些保证，我们需要新的工具和技术。

## 最多一次交货

*至多一次* delivery 承诺任何消息都不会被传递超过一次。如果出现故障，将不会重试消息传递，这意味着消息不会被复制，但可能会丢失。这种交付技术的优点是非常容易实现，并且不需要存储消息。

## 至少一次交货

*至少一次*传递保证所有消息最终都会被传递。当故障发生时，有两种可能性。一种可能性是消息可能没有被传递。另一种可能性是消息可能已经发送但没有被确认。失败总是导致重试，这意味着消息可能会被传递多次，但它们永远不会丢失。这种传送技术要求在发送方存储消息。

## 恰好一次交货

*恰好一次*传递不容易实现，因为在网络中断或信息丢失的情况下，我们不能保证我们的信息是否被收到。当失败发生时，我们必须重新发送消息以确保有保证的传递，但这可能会产生潜在的重复。因此，为了模拟*恰好一次*递送，使用了*至少一次*递送技术，并且在接收者端执行消息的重复数据删除。这种传送技术要求在发送方和接收方都进行存储。

# 保证交付技术的实施

Akka 默认最多使用*一次*交货。然而， *Akka 持久性*具有至少一次交付*的选项。鉴于 *Lagom* 通过其消息代理 API 支持*至少一次*交付和*最多一次*交付。*

要实现有保证的交付技术，有两种不同的方法。一种方法是，每个微服务可以直接依赖于其他微服务，这意味着以*点对点*的方式发送消息。另一种方法是，每个微服务可以利用*发布/订阅*消息代理从其他服务获取消息。

## 点对点方法

在点对点设置中，每个服务都直接向其他服务发送消息，这意味着它们直接耦合到彼此的 API。这种方法的优点是服务知道它们的依赖关系，这使得容易理解消息流。这个优点也是一个缺点，因为服务之间是高度耦合的。

## 发布/订阅方法

在*发布/订阅*设置中，我们有一系列微服务和一个中央消息总线或消息代理。服务将消息发布到公共消息总线，然后其他服务订阅这些消息。这意味着发布服务不知道订阅服务，反之亦然。因此，这种方法的优点是依赖关系更加灵活，这使得这是一种非常解耦的方法。

Akka actors 通常用*点对点*消息传递来实现。Lagom 还支持服务之间的*点对点*通信。在我们的微服务内部，我们有*发布/订阅*机制，为了使用它，我们可以使用 Akka 持久性。

# 类似文章-

你也可以看看我关于*反应式架构*系列的其他文章——

*   [倾向于反应式架构](/leaning-towards-reactive-architecture-190a6e02d0e1)
*   [投入反应式微服务](/diving-into-reactive-microservices-f9ff6a3f9686)
*   [构建可扩展的系统](/building-scalable-systems-c09374da82d7)