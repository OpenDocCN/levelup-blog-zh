<html>
<head>
<title>Writing effective Pandas code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写有效的熊猫代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-effective-pandas-code-553f1bad921c?source=collection_archive---------6-----------------------#2022-11-06">https://levelup.gitconnected.com/writing-effective-pandas-code-553f1bad921c?source=collection_archive---------6-----------------------#2022-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8efb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编程中的每一件事都可以用多种方式来完成。有些方式比其他方式更好。有些方式更糟糕。一个好的程序员应该选择一个好的方法来解决任务。不一定总是最好的方式，但绝对至少不是最差的方式。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/12eb0d8003f612450980d9416d84ab7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MHCxKKo-NCvm77Y5"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae le" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CHUTTERSNAP </a>拍摄</figcaption></figure><p id="fc2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">先说用熊猫写有效代码，熊猫是数据科学中应用最广泛的Python库之一。</p><p id="9bd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我将通过几个例子来比较一个好的做事方法和一个稍微差一点的做事方法。</p><p id="6b52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从定义我们的测试<em class="lf">数据帧</em>开始，我们将在本文的例子中使用它。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lg"><img src="../Images/5018252ef58014551f17dfc14bbb93fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDgozcN5jQZtC3z0kjjEjA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">作者举例</figcaption></figure><p id="2cd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的示例<em class="lf"> DataFrame </em>非常简单，只包含两列——一个整数列和一个字符串列(即使它看起来像浮点数)。我们的数据结构的大小相当大，包含1000万行，因为我们想要测量处理这个<em class="lf">数据帧</em>的代码的性能。</p><h2 id="75a9" class="lh li it bd lj lk ll dn lm ln lo dp lp kb lq lr ls kf lt lu lv kj lw lx ly lz bi translated">字符串矢量化运算</h2><p id="bf2d" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">首先，我们来谈谈如何使用字符串。</p><p id="69f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">熊猫<em class="lf">系列</em>对象包含一个特殊属性<em class="lf">。str </em>提供了使用字符串的各种功能。使用<em class="lf">的一个有用的例子。str </em>是两个<em class="lf"> DataFrame </em>列的串联。</p><p id="5b76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们想要连接示例<em class="lf"> DataFrame </em>的两列中的值，中间有一个箭头符号。因此，我们希望第一个结果行的值为“0-&gt;0.47138977631”。</p><p id="e009" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有多种方法可以做到这一点。我不会考虑最简单的方法，比如遍历循环中的值并用串联的结果填充一个新列表。一种非常优雅的方法是使用<em class="lf">应用</em>函数:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mf"><img src="../Images/9dfd9009cf760b425645329dd5256ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJfxVmMQ7V-cdemnQZV5IQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">作者举例</figcaption></figure><p id="b955" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这不是最糟糕的方法，因为它是可以理解的，并且不仅可以连接值，还可以进行更复杂的格式化。然而，这种方法的问题是执行时间慢。通过使用<em class="lf"> .str.cat() </em>方法，我们可以更快地进行连接。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mg"><img src="../Images/dd248da0c4894142ff6dc33aad373bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WOhlcJ3xP8zYK0Pg1GTnww.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">作者举例</figcaption></figure><p id="19a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您所看到的，连接的结果是相同的，但是执行时间现在只有9.55秒，而不是以前的一分多钟。</p><p id="9849" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用于连接的<em class="lf"> cat() </em>方法并不是<em class="lf"> str </em>下唯一有用的字符串方法。存取器。它包含许多与Python中内置的<em class="lf">字符串</em>方法具有相同名称和参数的方法。</p><p id="2a53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">字符串。</em>访问器不仅适用于<em class="lf">系列</em>对象，也适用于<em class="lf">索引</em>。这对于转换一个<em class="lf">数据帧的列名很有用。</em></p><pre class="kp kq kr ks gt mh mi mj mk aw ml bi"><span id="a2a9" class="lh li it mi b gy mm mn l mo mp">df<strong class="mi iu">.</strong>columns <strong class="mi iu">=</strong> df<strong class="mi iu">.</strong>columns<strong class="mi iu">.</strong>str<strong class="mi iu">.</strong>lower<strong class="mi iu">().</strong>str<strong class="mi iu">.</strong>replace<strong class="mi iu">(</strong>" "<strong class="mi iu">,</strong> "_"<strong class="mi iu">)</strong></span></pre><h2 id="a639" class="lh li it bd lj lk ll dn lm ln lo dp lp kb lq lr ls kf lt lu lv kj lw lx ly lz bi translated">映射序列中的值</h2><p id="19f7" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">数据科学任务中的一个常见情况是获取一个组的一些聚合值。例如，有一个雇员工资的数据集，我们可能希望每一行都获得相应月份所有雇员的平均工资。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mq"><img src="../Images/c92331408e717bdc8f391728aa65565b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6Vubt9hQ2GDlK_j3"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">马库斯·斯皮斯克在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1e61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们回到我们的示例<em class="lf"> DataFrame </em>中，我们将引入一个新的列——group，表示列“a”中的值有多少位。就像我们现在知道的<em class="lf">。str </em>访问器，将使用它通过取值字符串表示的长度来获得位数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/3cd981e9e2b3b407fff2c983ca76ccde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*ixoNmTSaJaL3PBEJnc1eBA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">作者举例</figcaption></figure><p id="8bf5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个新列将指定每一行所属的组。现在，您将如何创建一个列，包含按列“digits_in_a”分组的列“a”的平均值？最简单的方法是首先用每个组的计算平均值创建一个临时的<em class="lf">数据帧</em>，然后将其合并到原始的<em class="lf">数据帧</em>中。让我们看看它是如何工作的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/f05e128a1f3ae0637b7c7ec273081f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*oVWtw30kjBF7VZfvuD7P1w.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">作者举例</figcaption></figure><p id="5623" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它确实起作用，但是，时间又相当长。幸运的是，这次我们也能更快地得到它。这里的技巧是进行映射，而不是合并<em class="lf">数据帧。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mt"><img src="../Images/508b989bed0e054f1f75b536fead861a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJyAAOlsjygEsnHNiMFqkg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">作者举例</figcaption></figure><p id="8f23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，映射值的方法要快得多。此外，它需要更少的内存，这在处理大型数据集时可能是更重要的考虑因素。</p><p id="fb1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在某些情况下，当需要在没有足够内存(RAM)的机器上合并两个巨大的<em class="lf">数据帧</em>时，另一种方法是将一个<em class="lf">数据帧</em>的所有列映射到另一个<em class="lf">数据帧</em>中。如果有很多列，这种方法不会很快，但是与简单的合并相比，它需要的内存要少得多。</p><h2 id="10e2" class="lh li it bd lj lk ll dn lm ln lo dp lp kb lq lr ls kf lt lu lv kj lw lx ly lz bi translated">更多提示？</h2><p id="db73" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">是的，有更多的最佳实践和技巧来编写有效的熊猫代码，但我将在我的下一篇文章中分享这些，所以不要忘记按下Follow按钮。</p><p id="f989" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读！</p></div></div>    
</body>
</html>