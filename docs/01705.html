<html>
<head>
<title>Animated page transitions with React and GSAP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React和GSAP制作动画页面过渡</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/animated-page-transitions-with-react-and-gsap-538f55fe2b2b?source=collection_archive---------5-----------------------#2020-01-23">https://levelup.gitconnected.com/animated-page-transitions-with-react-and-gsap-538f55fe2b2b?source=collection_archive---------5-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/554a8c166b28e6682ad75e26d04e39f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zZiiK4gDseLpkyVb"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">克里斯·里德在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="0360" class="kn ko it bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">你能做什么</h1><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="lp lq l"/></div></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="ddbe" class="kn ko it bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">CodeSandbox</h1><figure class="ll lm ln lo gt ju"><div class="bz fp l di"><div class="lr lq l"/></div></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="7b73" class="kn ko it bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">属国</h1><p id="754f" class="pw-post-body-paragraph ls lt it lu b lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">为了能够进行如上所示的一些转换，您只需要安装两个额外的依赖项:</p><ol class=""><li id="0e5a" class="mq mr it lu b lv ms lz mt md mu mh mv ml mw mp mx my mz na bi translated"><code class="fe nb nc nd ne b">react-router-dom</code>:用于网站不同页面之间的路由。在我们的例子中，这个依赖关系负责我们的<em class="nf">主页</em>和<em class="nf">关于</em>页面之间的路由。</li><li id="0233" class="mq mr it lu b lv ng lz nh md ni mh nj ml nk mp mx my mz na bi translated"><code class="fe nb nc nd ne b">gsap</code>:这是制作网站动画的最好、最强大的工具之一。在我们的例子中，我们将只探索它的一小部分，这将有助于我们在页面转换之间制作动画。</li></ol><pre class="ll lm ln lo gt nl ne nm nn aw no bi"><span id="52d3" class="np ko it ne b gy nq nr l ns nt">To install these two dependencies execute the following code in your command line:</span><span id="c7b3" class="np ko it ne b gy nu nr l ns nt">yarn add react-router-dom gsap</span><span id="1b98" class="np ko it ne b gy nu nr l ns nt">or</span><span id="5d4a" class="np ko it ne b gy nu nr l ns nt">npm install react-router-dom gsap</span></pre></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><h1 id="2cee" class="kn ko it bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">过渡</h1><h2 id="624a" class="np ko it bd kp nv nw dn kt nx ny dp kx md nz oa lb mh ob oc lf ml od oe lj of bi translated">第一:什么</h2><p id="ea9e" class="pw-post-body-paragraph ls lt it lu b lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">创建过渡的第一步是决定在进入或退出页面时，当前页面中有哪些元素需要动画。在我们的例子中，除了导航菜单之外，我们动画显示了页面的所有组件。但是，您可以决定在转场中包含或排除任何想要的元素。</p><p id="56da" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">这一步很重要，因为当React在虚拟DOM中创建和呈现组件时，GSAP需要处理真实DOM中存在的组件。为了解决这个问题，我们需要使用<strong class="lu iu"> refs </strong>，它提供了一种从React访问DOM节点的方法。</p><p id="7c27" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">让我们看看我们是如何为我们的主页做到这一点的，使用一个组件作为例子——包含<em class="nf">欢迎</em>消息的标题:</p><pre class="ll lm ln lo gt nl ne nm nn aw no bi"><span id="f91f" class="np ko it ne b gy nq nr l ns nt">&lt;div ref={div =&gt; (this.header = div)} className="home-header"&gt;</span><span id="aba7" class="np ko it ne b gy nu nr l ns nt">  &lt;p&gt;Welcome!&lt;/p&gt;</span><span id="c73f" class="np ko it ne b gy nu nr l ns nt">&lt;/div&gt;</span></pre><p id="4a2a" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">具体来说，片段<code class="fe nb nc nd ne b">ref={div =&gt; (this.header = div)}</code>是允许我们访问这个DOM节点的一段代码(当我们用GSAP制作这个节点的动画时，这是必要的)。我们在这里所做的基本上是将这个div(最初位于虚拟DOM中)链接到一个GSAP可以定位的“实际”DOM节点。我们可以通过调用<code class="fe nb nc nd ne b">this.header</code>来访问这个DOM节点，这就是我们对节点的命名方式。</p><p id="7041" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">在我们的例子中，我们对主页中的3个组件都这样做。它们被命名为<code class="fe nb nc nd ne b">this.header</code>、<code class="fe nb nc nd ne b">this.content</code>和<code class="fe nb nc nd ne b">this.footer</code>。看看您能否在下面的代码中找到它们，并理解发生了什么:</p><pre class="ll lm ln lo gt nl ne nm nn aw no bi"><span id="d32f" class="np ko it ne b gy nq nr l ns nt">&lt;div ref={div =&gt; (this.header = div)} className="home-header"&gt;</span><span id="4bf0" class="np ko it ne b gy nu nr l ns nt">  &lt;p&gt;Welcome!&lt;/p&gt;</span><span id="44f0" class="np ko it ne b gy nu nr l ns nt">&lt;/div&gt;</span><span id="fd73" class="np ko it ne b gy nu nr l ns nt">&lt;div ref={div =&gt; (this.content = div)} className="home-content"&gt;</span><span id="420d" class="np ko it ne b gy nu nr l ns nt">  &lt;p&gt;</span><span id="03b0" class="np ko it ne b gy nu nr l ns nt">  Lorem Ipsum is simply dummy text of the printing and typesetting</span><span id="49c0" class="np ko it ne b gy nu nr l ns nt">industry. Lorem Ipsum has been the industry's standard dummy text</span><span id="64ff" class="np ko it ne b gy nu nr l ns nt">ever since the 1500s, when an unknown printer took a galley of</span><span id="2554" class="np ko it ne b gy nu nr l ns nt">type and scrambled it to make a type specimen book. It has</span><span id="5bdc" class="np ko it ne b gy nu nr l ns nt">survived not only five centuries, but also the leap into</span><span id="7272" class="np ko it ne b gy nu nr l ns nt">electronic typesetting, remaining essentially unchanged. It was</span><span id="65b5" class="np ko it ne b gy nu nr l ns nt">popularised in the 1960s with the release of Letraset sheets</span><span id="8988" class="np ko it ne b gy nu nr l ns nt">containing Lorem Ipsum passages, and more recently with desktop</span><span id="e572" class="np ko it ne b gy nu nr l ns nt">publishing software like Aldus PageMaker including versions of</span><span id="040b" class="np ko it ne b gy nu nr l ns nt">Lorem Ipsum.</span><span id="fee1" class="np ko it ne b gy nu nr l ns nt">  &lt;/p&gt;</span><span id="8dbe" class="np ko it ne b gy nu nr l ns nt">&lt;/div&gt;</span><span id="5783" class="np ko it ne b gy nu nr l ns nt">&lt;div ref={div =&gt; (this.footer = div)} className="home-footer"&gt;</span><span id="104f" class="np ko it ne b gy nu nr l ns nt">  &lt;p&gt;January, 2020&lt;/p&gt;</span><span id="9ed3" class="np ko it ne b gy nu nr l ns nt">&lt;/div&gt;</span></pre><p id="0bb1" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">我们对<em class="nf">关于</em>页面做同样的操作。请检查CodeSandbox以进一步探索如何将<strong class="lu iu">引用</strong> <em class="nf"> </em>应用于该页面。</p><p id="ff98" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated"><strong class="lu iu">那么；该如何</strong></p><p id="ed4e" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">创建过渡的下一步是决定如何制作不同组件的动画。这一步是选择你的效果并微调它们。例如，您可以决定让某个元素跳动一秒钟，而另一个元素逐渐出现在屏幕上。这就是这一步所要做的——选择和微调你的效果。这就是GSAP变得非常方便的地方！</p><p id="6c9f" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">让我们来探索一下如何在我们的主页上做到这一点。</p><p id="6e10" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">你需要做的第一件事是创建一个<strong class="lu iu"> GSAP时间线最大值</strong>，正如其名称所示，这是一个动画时间线，让你决定你希望你的动画发生的时间和方式。在我们的主页中，我们在下面这段代码中创建了时间轴，<strong class="lu iu">，它需要在你的类</strong>的构造函数方法中:</p><pre class="ll lm ln lo gt nl ne nm nn aw no bi"><span id="1687" class="np ko it ne b gy nq nr l ns nt">this.timeline = new TimelineMax({ paused: true });</span></pre><p id="0406" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">就这样，你已经创建了你的时间线！现在，我们需要使用它。这里，我们将把上一步中创建的<strong class="lu iu">引用</strong>与我们新创建的<strong class="lu iu">时间线</strong>结合起来。我们使用以下代码来实现这一点:</p><pre class="ll lm ln lo gt nl ne nm nn aw no bi"><span id="24b4" class="np ko it ne b gy nq nr l ns nt">componentDidMount() {</span><span id="b3c4" class="np ko it ne b gy nu nr l ns nt">  this.timeline</span><span id="552a" class="np ko it ne b gy nu nr l ns nt">    .from(this.header, 0.5, {</span><span id="7ec5" class="np ko it ne b gy nu nr l ns nt">      display: "none",</span><span id="1ea8" class="np ko it ne b gy nu nr l ns nt">      autoAlpha: 0,</span><span id="2c9d" class="np ko it ne b gy nu nr l ns nt">      delay: 0.25,</span><span id="2b27" class="np ko it ne b gy nu nr l ns nt">      ease: Power1.easeIn</span><span id="8fcc" class="np ko it ne b gy nu nr l ns nt">    })</span><span id="647d" class="np ko it ne b gy nu nr l ns nt">    .from(this.content, 0.4, {</span><span id="e758" class="np ko it ne b gy nu nr l ns nt">      autoAlpha: 0,</span><span id="ff58" class="np ko it ne b gy nu nr l ns nt">      y: 25,</span><span id="0139" class="np ko it ne b gy nu nr l ns nt">      ease: Power1.easeInOut</span><span id="36ae" class="np ko it ne b gy nu nr l ns nt">    })</span><span id="9e97" class="np ko it ne b gy nu nr l ns nt">    .from(this.footer, 0.4, {</span><span id="f68c" class="np ko it ne b gy nu nr l ns nt">      autoAlpha: 0,</span><span id="643b" class="np ko it ne b gy nu nr l ns nt">      y: 25,</span><span id="453b" class="np ko it ne b gy nu nr l ns nt">      ease: Power1.easeInOut</span><span id="c28b" class="np ko it ne b gy nu nr l ns nt">    });</span><span id="bc32" class="np ko it ne b gy nu nr l ns nt">  this.timeline.play();</span><span id="3b90" class="np ko it ne b gy nu nr l ns nt">}</span></pre><p id="1173" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">那么，我们在这里做什么？</p><p id="291b" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">首先，我们抓取我们的时间线，并告诉它我们希望在屏幕上显示的第一个组件是由<code class="fe nb nc nd ne b">this.header</code>引用的组件，我们希望在动画开始发生之前不显示任何内容<code class="fe nb nc nd ne b">display: "none"</code>，我们希望在动画开始之前有0.25秒的延迟，我们希望效果是一个缓和(特别是Power1 easeIn) <code class="fe nb nc nd ne b">ease: Power1.easeIn</code>，最后但同样重要的是，我们希望动画持续0.5秒(这是在<code class="fe nb nc nd ne b">this.header</code>之后的数字)。</p><p id="6051" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">接下来，我们链接下面要显示的组件:<code class="fe nb nc nd ne b">this.content</code>。当前一个动画结束时，时间轴才会开始这个动画(这可以根据您的需要定制，但是在我们的例子中，它是这样工作的)。<code class="fe nb nc nd ne b">autoAlpha: 0</code>给出一个不透明度从0到1的动画，最后<code class="fe nb nc nd ne b">y: 25</code>给出动画开始的位置。</p><p id="0f05" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">最后，我们需要真正播放时间线，这样一切都开始发生:<code class="fe nb nc nd ne b">this.timeline.play()</code>。如果我们错过了这最后一步，什么都不会发生。</p><p id="3c9b" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">我强烈建议你使用这些变量，看看动画是如何表现的。此外，我鼓励你去探索<a class="ae kf" href="https://greensock.com/docs/v2/Easing" rel="noopener ugc nofollow" target="_blank"> GSAP </a>提供的惊人的缓解效果库。</p><h2 id="f554" class="np ko it bd kp nv nw dn kt nx ny dp kx md nz oa lb mh ob oc lf ml od oe lj of bi translated">最后一步:何时</h2><p id="9a21" class="pw-post-body-paragraph ls lt it lu b lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">在创建转换之前，我们需要考虑的最后一件事是我们希望它们在什么时候发生。在我们的示例中，我们希望它们在我们进入页面时发生(以动画形式显示页面中不同组件的显示方式)以及每当我们退出页面时发生(以动画形式显示组件如何从屏幕上撤回)。在这个例子中，退出一个页面的唯一方法是点击另一个页面的链接。</p><p id="b3a0" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">进入情况是相当容易的。因为React已经为此提供了一个名为ComponentDidMount的方法。这就是为什么我们在ComponentDidMount方法中创建和播放时间轴。每当这一页被安装，我们的时间线将播放。简单。</p><p id="6089" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">然而，现有的情况并不简单，因为React没有提供一种干净的方法来处理它。所以我们基本上破解了它。</p><p id="a2a1" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">首先是考虑退出过渡应该何时发生。正如我们之前所说的，对于我们的例子，每当我们导航到一个不同于我们当前所在的页面时，就会发生这种情况。然后，如果我们现在在家，每当我们点击导航菜单中的About链接(在我们的例子中是一个按钮)时，退出转换就会发生。在代码中，我们的主页是这样的:</p><pre class="ll lm ln lo gt nl ne nm nn aw no bi"><span id="cd15" class="np ko it ne b gy nq nr l ns nt">&lt;header className="navigation"&gt;<br/></span><span id="a65b" class="np ko it ne b gy nu nr l ns nt">  &lt;button className="nav-item"&gt;</span><span id="794b" class="np ko it ne b gy nu nr l ns nt">    &lt;p&gt;Home&lt;/p&gt;</span><span id="bcb2" class="np ko it ne b gy nu nr l ns nt">  &lt;/button&gt;</span><span id="4c6a" class="np ko it ne b gy nu nr l ns nt"><br/>  &lt;button</span><span id="cf7d" class="np ko it ne b gy nu nr l ns nt">    className="nav-item"</span><span id="027f" class="np ko it ne b gy nu nr l ns nt">    onClick={e =&gt; this.changePage(e, "/about")}</span><span id="3ef4" class="np ko it ne b gy nu nr l ns nt">  &gt;</span><span id="e638" class="np ko it ne b gy nu nr l ns nt">    &lt;p&gt;About&lt;/p&gt;</span><span id="9a6c" class="np ko it ne b gy nu nr l ns nt">  &lt;/button&gt;</span><span id="8b54" class="np ko it ne b gy nu nr l ns nt"><br/>&lt;/header&gt;</span></pre><p id="6bde" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">这个标题组件代表我们的导航菜单，它有两个按钮组件:Home和About。因为这是我们主页的代码，所以当我们点击Home按钮时，什么都不会发生。然而，每当我们单击“关于”按钮时，应该会发生两件事:1)退出过渡应该开始，2)在退出过渡完成后，它应该会将我们转到“关于”页面。这两件事发生在changePage函数中，每当点击About按钮(链接)时就会调用这个函数。以下是changePage函数的代码:</p><pre class="ll lm ln lo gt nl ne nm nn aw no bi"><span id="692b" class="np ko it ne b gy nq nr l ns nt">changePage = (e, destination) =&gt; {</span><span id="c2ef" class="np ko it ne b gy nu nr l ns nt">  e.preventDefault();</span><span id="b616" class="np ko it ne b gy nu nr l ns nt">  this.timeline.reverse();</span><span id="1927" class="np ko it ne b gy nu nr l ns nt">  const timelineDuration = this.timeline.duration() * 1000;</span><span id="cf1e" class="np ko it ne b gy nu nr l ns nt">  setTimeout(() =&gt; {</span><span id="f19d" class="np ko it ne b gy nu nr l ns nt">    this.props.history.push(destination);</span><span id="fbbc" class="np ko it ne b gy nu nr l ns nt">  }, timelineDuration);</span><span id="a388" class="np ko it ne b gy nu nr l ns nt">};</span></pre><p id="3763" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">如前所述，这里发生了两件事:</p><ol class=""><li id="1b0a" class="mq mr it lu b lv ms lz mt md mu mh mv ml mw mp mx my mz na bi translated">退出动画开始播放。在我们的例子中，我们决定反转时间轴:<code class="fe nb nc nd ne b">this.timeline.reverse()</code>，但是您可以使用不同的时间轴轻松地制作自己的退出动画。</li><li id="f361" class="mq mr it lu b lv ng lz nh md ni mh nj ml nk mp mx my mz na bi translated">退出动画完成后，由常量<code class="fe nb nc nd ne b">timelineDuration</code>捕捉，我们使用<code class="fe nb nc nd ne b">react-router-dom</code>历史对象从当前页面跳转到about页面:<code class="fe nb nc nd ne b">this.props.history.push(destination)</code> —在本例中，destination是“/about”，对应我们about页面的路线。</li></ol><p id="ad42" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">这里不探讨路由，因为它超出了本文的范围。但是，请在下面的评论区留下关于该部分的任何问题。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="8d27" class="pw-post-body-paragraph ls lt it lu b lv ms lx ly lz mt mb mc md og mf mg mh oh mj mk ml oi mn mo mp im bi translated">感谢您的阅读！我希望这有用！</p></div></div>    
</body>
</html>