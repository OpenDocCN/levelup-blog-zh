<html>
<head>
<title>Flutter State Management in 2021: When to Use What?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021年颤振状态管理:何时使用什么？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-state-management-in-2021-when-to-use-what-98722093b8bc?source=collection_archive---------0-----------------------#2020-11-29">https://levelup.gitconnected.com/flutter-state-management-in-2021-when-to-use-what-98722093b8bc?source=collection_archive---------0-----------------------#2020-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e43c194c12b4211eea46d2a14f15a0e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ucogi1LuiL3NqvtfPIcjog.png"/></div></div></figure><p id="dfb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有时候，国家管理垄断是好的；在React中，实际上只有一两个常见的状态管理解决方案。随着2020年的野兽接近尾声，似乎每个月都有新的国家管理解决方案。这里列出了每个解决方案的优点，因此您可以确信您选择了满足您需求的最佳状态管理解决方案。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e84f" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">基础知识</h1><p id="629d" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">有两种状态管理解决方案你可以不用接触你的<code class="fe mj mk ml mm b">pubspec.yaml</code>文件就可以使用，有时(次数比你想象的要多！)够了。</p><h2 id="25fc" class="mn lh it bd li mo mp dn lm mq mr dp lq km ms mt lu kq mu mv ly ku mw mx mc my bi translated">设置状态</h2><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/4f16abea161850ac9eec1baba26cbd3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RF6r8Orc6ICrbkUh.png"/></div></div></figure><p id="ffc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">SetState只在<em class="ne">本地</em>范围内有用。如果一个小部件正在改变它自己的状态，那么SetState 100%是你想要使用的，不用担心其他任何事情。例如，也许你正在存储一个开关是开还是关，或者也许你正在存储一个文本字段输入的内容。SetState在局部范围内无与伦比，你真的不应该考虑任何其他包。</p><p id="1de5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我的经验是这样的:如果stateful变量只在这个小部件中需要，或者在树的上下1个小部件中需要，那么它属于局部范围。用个<code class="fe mj mk ml mm b">StatefulWidget</code>就开心了。如果需要沿树向下传递状态，只需将变量放在子部件的构造函数中。如果同一个变量通过构造函数2+ widgets深入传递，那么是时候考虑更高范围的状态管理了。</p><h2 id="bcf1" class="mn lh it bd li mo mp dn lm mq mr dp lq km ms mt lu kq mu mv ly ku mw mx mc my bi translated">固有宽度</h2><p id="5b76" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku mi kw kx ky im bi translated">你知道我们在SetState中讨论的那个开关吗？也许它控制着应用程序是处于黑暗模式还是光明模式。在这种情况下，您需要将状态提升到能够更好地沿树向下传播的位置。不过，在开始安装软件包之前，让我们先来看看InheretedWidget。</p><p id="3f3a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">InheretedWidget允许它下面的任何小部件访问它的属性。这意味着您可以有一个类似于以下的变量:</p><pre class="na nb nc nd gt nf mm ng nh aw ni bi"><span id="3626" class="mn lh it mm b gy nj nk l nl nm">enum Theme {<br/>  dark,<br/>  light <br/>}</span></pre><p id="17a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在InheretedWidget内部，任何关心主题的小部件都可以通过<code class="fe mj mk ml mm b">MyInheretedWidget.of(context).theme</code>来访问主题。小部件也将在主题更新时重建，这很好。</p><p id="7de7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">InheretedWidget崩溃的地方在于有很多样板文件。小部件系统需要大量的代码不断重复，因此，如果您正在进行大量更高范围的状态管理，就会变得有些重复。</p><h1 id="4003" class="lg lh it bd li lj nn ll lm ln no lp lq lr np lt lu lv nq lx ly lz nr mb mc md bi translated">那些你必须安装的</h1><h2 id="861c" class="mn lh it bd li mo mp dn lm mq mr dp lq km ms mt lu kq mu mv ly ku mw mx mc my bi translated">BLoC(丘比特？)</h2><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/721f2bfe0765d83b6bb9f0d6c1de3b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJJrfHjb_CRoQA37nqffvQ.png"/></div></div></figure><p id="e32d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Bloc可能是这个列表中最老的解决方案，并且仍然很棒。最近，BLoC在组合中添加了Cubit，这使得BLoC或多或少地过时了，因为Cubit降低了所需的样板文件——好的方面是它们都在同一个包中，这意味着移植非常容易。BLoC擅长两个不同的领域，在我看来:<br/> <strong class="kd iu"> 1。与团队合作:</strong>集团在让事情变得不灵活方面做得非常好。对于很多人来说，这是一件坏事:他们希望能够快速改变他们的应用程序，而不必写太多的代码，或者改变太多的代码。对于团队来说，情况并非如此:通过让事情变得有点不灵活，您可以保证一切都按照最初开发人员的意图运行——如果BLoC中的一个状态只打算具有值1、2和3，您可以对BLoC进行编码，以便事件只将状态更改为这些值，这样其他程序员就不会意外地将其值移动到4。因此，它也非常容易测试。</p><p id="cb1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> 2。事件驱动状态:</strong> BLoC是基于事件的，所以它在事件驱动状态方面做得非常非常好也就不足为奇了。我的意思是你必须定义你的事件。执行API调用可能会触发一个事件，从而推出一个状态<code class="fe mj mk ml mm b">CallingAPIState</code>。然后，当API调用完成时，它会推出一个<code class="fe mj mk ml mm b">HaveAPIResultsState</code>。</p><p id="e795" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您喜欢严格定义事件和状态，那么BLoC适合您。如果您需要灵活性/开发速度，那么BLoC可能不是合适的选择。(我个人更喜欢我的应用中的BLoC和cubit。)</p><h2 id="6743" class="mn lh it bd li mo mp dn lm mq mr dp lq km ms mt lu kq mu mv ly ku mw mx mc my bi translated">供应者</h2><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/a2ede553601e9d5e98d34d509ab8236b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tA6fMbv600Fvaa-4.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">激动人心的经典作品</figcaption></figure><p id="4999" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">出于传统原因，我将提供商放在此列表中。在一段时间内，提供商是必经之路。它很简单，很干净，很棒……但是也有一些不足之处，需要改进。</p><p id="6f61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将提供者视为固有的，样板文件较少。事实上，提供者是建立在固有的边缘之上的。它只是减少了您必须编写的代码量，这太棒了。</p><p id="83a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你的应用已经在使用Provider，你100%可以继续使用它。就其功能而言，这是一个非常好的包，没有理由完全迁移到另一个解决方案。</p><p id="06b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但仍有一些改进的空间，我真的认为RiverPod在继续提供者的工作方面做得很好。</p><h2 id="d192" class="mn lh it bd li mo mp dn lm mq mr dp lq km ms mt lu kq mu mv ly ku mw mx mc my bi translated">RiverPod</h2><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/a5923e6971d77a7ca42b372b2291ebc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sfs4FVGhVTmrPw9O"/></div></div></figure><p id="d3d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在RiverPod的网站上，他们自称“提供商，但与众不同。”这听起来再真实不过了。提供商，即使它删除了许多样板文件，仍然有一些可以进一步减少。此外，Provider依赖于BuildContext——我认为在很多情况下这真的很好(它迫使您使用小部件树),但有时，就像应用程序生命周期一样，在您需要的地方获得build context是不实际的。</p><p id="ab8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">RiverPod在提供商方面的优点和改进如下:</p><ul class=""><li id="ed2c" class="nz oa it kd b ke kf ki kj km ob kq oc ku od ky oe of og oh bi translated">样板文件比提供者少:RiverPod在减少提供者方面做得很好，允许您只注册一个顶级商店，然后就可以完成，而不必单独提供每个提供者。(想到所有东西都在一个地方，你们中的一些人可能会退缩——别担心！如有必要，您可以查看您的pod。)</li><li id="5a31" class="nz oa it kd b ke oi ki oj km ok kq ol ku om ky oe of og oh bi translated">不依赖于BuildContext:这也是一个很好的方法，原因已经提到过了。有时，您就是无法在需要的地方获得BuildContext。这可能是您在<code class="fe mj mk ml mm b">main</code>函数中设置的<code class="fe mj mk ml mm b">onAppClose</code>监听器。</li><li id="ac0d" class="nz oa it kd b ke oi ki oj km ok kq ol ku om ky oe of og oh bi translated">编译安全:到目前为止，这是国家管理中最好的创新。如果你的代码可以编译，你就很棒。我们不会再想为什么在树中找不到我们的提供者。这是一项巨大的创新，将为您节省大量时间。</li></ul><p id="a6e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">RiverPod只是换了一种皮肤——更光滑、更好的皮肤。如果你开始一个新的应用程序，并想走提供商路线，我强烈建议你考虑RiverPod。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="73dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我考虑过这个列表的状态管理解决方案，但最终没有添加:</p><ul class=""><li id="28d3" class="nz oa it kd b ke kf ki kj km ob kq oc ku od ky oe of og oh bi translated">GetX。我不是GetX的粉丝。GetX试图完成很多工作，这限制了您的灵活性。如果你想要一个“完整的应用”包，那么GetX是你的不二之选。我试过了，但不喜欢——但如果它对你有用，那就太好了！</li><li id="34a4" class="nz oa it kd b ke oi ki oj km ok kq ol ku om ky oe of og oh bi translated">盒子上写着呢。get_it不是一个状态管理解决方案——但是人们一直把它当作一个状态管理解决方案来使用。如果用作状态管理解决方案，它会非常混乱，老实说，在文件中声明浮动变量可能会更好。</li><li id="d539" class="nz oa it kd b ke oi ki oj km ok kq ol ku om ky oe of og oh bi translated">redux / fish_redux / mobx:这些都来自React，并且具有非常相似的风格——但是我认为很快就可以看出React和Flutter是两个不同但相似的东西。这些工作，如果你习惯了，那么你可以使用它们，但是在我看来，为Flutter设计的状态管理工作得最干净。</li></ul></div></div>    
</body>
</html>