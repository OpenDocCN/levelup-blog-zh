<html>
<head>
<title>Flutter app from scratch part 3 — building the user interface and managing state</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter应用程序第3部分——构建用户界面和管理状态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-app-from-scratch-part-3-building-the-user-interface-and-managing-state-dd2bb7dffbec?source=collection_archive---------21-----------------------#2022-03-14">https://levelup.gitconnected.com/flutter-app-from-scratch-part-3-building-the-user-interface-and-managing-state-dd2bb7dffbec?source=collection_archive---------21-----------------------#2022-03-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4a00" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">我们的应用增长缓慢但稳定</h2><div class=""/><div class=""><h2 id="9b75" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何从头开始构建Flutter应用程序系列的第3部分。本文涵盖了关于将UI与底层数据链接起来的细节。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/652eb61ae5ab041399299cd8f1c5df3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rq2Ss29Rt7Q9kQ5vrY2Udg.png"/></div></div></figure><p id="527b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这是记录新的Flutter应用程序开发过程的系列文章的第三篇。在上一集中，我们重点定义了满足应用程序需求的模型。对于存储，我们建立了一个数据库，并为我们的应用程序添加了读/写功能。在本文中，我们将把简单的后端与用户界面联系起来。我们还将改进应用程序，以便用户可以在应用程序中执行这些操作。</p><blockquote class="lz"><p id="943e" class="ma mb it bd mc md me mf mg mh mi ly dk translated">💡你更喜欢电子书而不是多媒体文章吗？现在就从我的<a class="ae mj" href="https://xeladu.gumroad.com/" rel="noopener ugc nofollow" target="_blank"> Gumroad商店</a>免费获取<a class="ae mj" href="https://xeladu.gumroad.com/l/scratch" rel="noopener ugc nofollow" target="_blank">电子书</a>！</p></blockquote><blockquote class="mk ml mm"><p id="ba71" class="ld le mn lf b lg mo kd li lj mp kg ll mq mr lo lp ms mt ls lt mu mv lw lx ly im bi translated"><strong class="lf jd">免责声明</strong> <br/>本文描述了实现目标的多种方法之一。当然，还有很多其他可能更适合、更容易或不那么令人困惑的方法。我认为保持开放的心态和尝试新事物是很重要的。只有这样，一个人才会知道什么对他或她最有效。👍</p></blockquote><h2 id="0fa3" class="mw mx it bd my mz na dn nb nc nd dp ne lm nf ng nh lq ni nj nk lu nl nm nn iz bi translated">本文中使用的包</h2><p id="256b" class="pw-post-body-paragraph ld le it lf b lg no kd li lj np kg ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated"><a class="ae mj" href="https://pub.dev/packages/flutter_riverpod" rel="noopener ugc nofollow" target="_blank"> Riverpod </a>状态管理<br/><a class="ae mj" href="https://pub.dev/packages/get" rel="noopener ugc nofollow" target="_blank">获取</a>依赖注入</p><h2 id="4317" class="mw mx it bd my mz na dn nb nc nd dp ne lm nf ng nh lq ni nj nk lu nl nm nn iz bi translated">依赖注入</h2><p id="2d27" class="pw-post-body-paragraph ld le it lf b lg no kd li lj np kg ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">第一个增强是依赖注入。有几种方法可以实现这一点，有些方法比其他方法更适合(这主要取决于你问谁)。由于这个应用程序将相当简单，我们的主要重点是使应用程序可测试。因此，我们必须提供一种模拟依赖关系的方法，这样我们就不需要执行整个应用程序来验证一小部分代码。</p><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-mock-dependencies-in-your-flutter-app-for-testing-54c49251740a"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd jd gy z fp ob fr fs oc fu fw jc bi translated">如何在你的Flutter应用中模拟依赖关系进行测试</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">这里有一个关于如何用mocksito包创建mock，设置它们，并在你的测试中使用它们的教程…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok lb nw"/></div></div></a></div><p id="f33d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最基本的方法是从一个中心源访问所有的依赖项。包<a class="ae mj" href="https://pub.dev/packages/get" rel="noopener ugc nofollow" target="_blank"> get </a>提供了这个功能。请参见下面的设置:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="ec1f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们的app包含一个<code class="fe on oo op oq b">NavigationService</code>和一个<code class="fe on oo op oq b">DatabaseService</code>，使用频率很高。我们用<code class="fe on oo op oq b">putAsync()</code>方法注册它们，并且可以在任何我们想要的地方用<code class="fe on oo op oq b">Get.find&lt;Type&gt;()</code>访问它们。您将在接下来的章节中看到这种模式。我们尽可能早地初始化依赖关系，例如在应用程序启动之前在<code class="fe on oo op oq b">main()</code>方法中初始化。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="2509" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在单元测试中，我们会通过运行一个定制的设置方法来用模拟替换真实的类，这就是我们现在想要的。</p><h2 id="385d" class="mw mx it bd my mz na dn nb nc nd dp ne lm nf ng nh lq ni nj nk lu nl nm nn iz bi translated">没有构建上下文的导航</h2><p id="7f39" class="pw-post-body-paragraph ld le it lf b lg no kd li lj np kg ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">现在，我们有使用<code class="fe on oo op oq b">Navigator</code>对象及其<code class="fe on oo op oq b">pushNamed</code>方法的简单导航。问题是我们总是需要提供<code class="fe on oo op oq b">BuildContext</code>来导航。如果我们在视野之内，那没问题。但是，如果我们想从我们无法访问<code class="fe on oo op oq b">BuildContext</code>的代码的其他部分导航呢？<br/>这是我们新的导航服务类别:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="2c00" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">它与我们在<code class="fe on oo op oq b">main.dart</code>的应用程序中注册的全球导航键配合使用。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="aaae" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，我们可以通过调用</p><pre class="ks kt ku kv gt or oq os ot aw ou bi"><span id="16ea" class="mw mx it oq b gy ov ow l ox oy">Get.find&lt;NavigationService&gt;().navigateTo("page", arguments: "any"); </span></pre><h2 id="23f1" class="mw mx it bd my mz na dn nb nc nd dp ne lm nf ng nh lq ni nj nk lu nl nm nn iz bi translated">状态管理</h2><p id="e0cc" class="pw-post-body-paragraph ld le it lf b lg no kd li lj np kg ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">如果你没有听说过或尝试过，这里有链接到<a class="ae mj" href="https://riverpod.dev/docs/getting_started" rel="noopener ugc nofollow" target="_blank"> riverpod </a>文档。我们将在这个应用程序中使用它进行状态管理。Riverpod定义了不同种类的<a class="ae mj" href="https://riverpod.dev/docs/concepts/providers" rel="noopener ugc nofollow" target="_blank">提供者</a>，我们可以使用它们来检索和更改数据。用户界面可以监听提供者并在发生变化时重新构建。所有的提供者都是不可变的，可以全局定义，但是将它们组织到单独的文件中是很重要的，尤其是当它们的数量增加时。这是一个令人耳目一新的新方法，但一开始可能有点难以理解。</p><h2 id="bd4c" class="mw mx it bd my mz na dn nb nc nd dp ne lm nf ng nh lq ni nj nk lu nl nm nn iz bi translated">获取初始数据</h2><p id="e16b" class="pw-post-body-paragraph ld le it lf b lg no kd li lj np kg ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">我们从从数据库获取一切的提供者开始。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="072d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">提供者使用<code class="fe on oo op oq b">DatabaseService</code>从数据库中获取所有的<code class="fe on oo op oq b">Task</code>对象。与用户界面的集成可能是这样的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="9ecd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们用<code class="fe on oo op oq b">ConsumerWidget</code>或<code class="fe on oo op oq b">ConsumerStatefulWidget</code>来代替<code class="fe on oo op oq b">StatelessWidget</code>或<code class="fe on oo op oq b">StatefulWidget</code>。<code class="fe on oo op oq b">build</code>方法现在有了一个额外的参数<code class="fe on oo op oq b">WidgetRef</code>，我们可以用它来访问我们的提供者。一个<code class="fe on oo op oq b">FutureProvider</code>公开了处理不同状态的简便方法，允许我们为用户显示匹配的小部件。在这种情况下，首先显示一个<code class="fe on oo op oq b">CircularProgressIndicator</code>,然后显示一个<code class="fe on oo op oq b">ListView</code>,每个数据对象有一个<code class="fe on oo op oq b">Card</code>小部件，或者在失败时显示一条简单的错误消息。单击项目会导航到详细信息页面。</p><p id="de0d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">riverpod中所有可用提供商的概述可以在这里找到<a class="ae mj" href="https://riverpod.dev/docs/concepts/providers#different-types-of-providers" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="de76" class="mw mx it bd my mz na dn nb nc nd dp ne lm nf ng nh lq ni nj nk lu nl nm nn iz bi translated">获取特定对象</h2><p id="ab59" class="pw-post-body-paragraph ld le it lf b lg no kd li lj np kg ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">要编辑现有数据，我们需要获得一个单独的<code class="fe on oo op oq b">Task</code>条目。借助riverpod及其提供商，我们可以做到以下几点:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="1009" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个提供者使用了<code class="fe on oo op oq b">family</code>构造函数，在这里我们可以传递额外的参数，在这个例子中，它是一个<code class="fe on oo op oq b">Task</code>对象的标识符。我们还可以利用我们的另一个提供者(通过<code class="fe on oo op oq b">ref</code>参数)返回所有的<code class="fe on oo op oq b">Task</code>对象，这样我们只需要过滤它们以得到正确的元素。让我们来看看风景:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="acab" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">再次，看看提供者处理不同状态的漂亮的<code class="fe on oo op oq b">when()</code>方法。我是你的超级粉丝😊如果我们的<code class="fe on oo op oq b">singleTaskProvider</code>只是<code class="fe on oo op oq b">Provider</code>类的一个实例，这些方法就不可用。必须是<code class="fe on oo op oq b">FutureProvider</code>。视图本身主要包含文本。您可以点击<code class="fe on oo op oq b">FloatingActionButton</code>导航至编辑页面。</p><h2 id="e3b7" class="mw mx it bd my mz na dn nb nc nd dp ne lm nf ng nh lq ni nj nk lu nl nm nn iz bi translated">修改数据</h2><p id="6d02" class="pw-post-body-paragraph ld le it lf b lg no kd li lj np kg ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">编辑页面包含用于数据操作的基本文本字段小部件和开关。有一个按钮可以触发保存操作。看起来是这样的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="e5f4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">一个新的<code class="fe on oo op oq b">Task</code>对象被创建(我们不能编辑它，它是不可变的)并存储在数据库中。方法处理现有数据的修改或新数据的创建。保存后，应用程序导航回最后一页。正如你可能在上面的片段<code class="fe on oo op oq b">home_view.dart</code>或<code class="fe on oo op oq b">task_view.dart</code>中看到的，有一个呼叫<code class="fe on oo op oq b">ref.refresh(taskListProvider)</code>。这样，我们可以触发用户界面的刷新来显示新数据。这是当前状态:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/6937e2bbf736d1d062f6f29ecac71683.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/1*VY84eP4LX8mhm035XyyS6w.gif"/></div><figcaption class="pa pb gj gh gi pc pd bd b be z dk translated">在应用程序中添加和编辑数据</figcaption></figure><h2 id="a050" class="mw mx it bd my mz na dn nb nc nd dp ne lm nf ng nh lq ni nj nk lu nl nm nn iz bi translated">结论</h2><p id="e8df" class="pw-post-body-paragraph ld le it lf b lg no kd li lj np kg ll lm nq lo lp lq nr ls lt lu ns lw lx ly im bi translated">在本文中，我们将简单的后端与用户界面联系起来。我们还改进了应用程序，以便用户可以在应用程序中执行这些操作。下一步，我们将实现实际提醒的逻辑，并将它们集成到我们的应用程序中。</p><p id="b415" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">源代码可以在<a class="ae mj" href="https://github.com/xeladu/flutter_app_example/releases/tag/app-3" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。随着项目的进展，您可能会在存储库中看到不同的代码。</p><p id="8025" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你的下一站是系列的第四部分，玩得开心🎉</p><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/flutter-app-from-scratch-part-4-implementing-logic-and-styling-the-user-interface-c08d2304b399"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd jd gy z fp ob fr fs oc fu fw jc bi translated">Flutter应用程序第4部分——实现逻辑和设计用户界面</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">如何从头开始构建Flutter应用程序系列的第4部分。本文涵盖了通知的实现…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="of l"><div class="pe l oh oi oj of ok lb nw"/></div></div></a></div></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><p id="3521" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你喜欢这篇文章，我会很高兴得到掌声👏(你知道可以拍几次吗？😎)另外，如果你还没有跟上我，我也很感激。</p><p id="6c6b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">🌲|☕咖啡🎁<a class="ae mj" href="https://www.paypal.com/donate/?hosted_button_id=JPWK39GGPAAFQ" rel="noopener ugc nofollow" target="_blank">捐赠</a> |💻GitHub  |🔔<a class="ae mj" href="https://xeladu.medium.com/subscribe" rel="noopener">订阅</a></p><p id="d75c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">顺便说一句:如果你还没有Medium会员，我推荐你使用<a class="ae mj" href="https://medium.com/@xeladu/membership" rel="noopener">│我的推荐链接◀ </a> <strong class="lf jd"> <em class="mn"> </em> </strong>，因为它会让你访问Medium上的所有内容，并以一小部分费用支持我，而不会为你带来任何额外费用。谢谢大家！✨</p></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><h2 id="7e1f" class="mw mx it bd my mz na dn nb nc nd dp ne lm nf ng nh lq ni nj nk lu nl nm nn iz bi translated">本系列的前几篇文章</h2><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/flutter-app-from-scratch-part-2-define-models-and-set-up-database-78a67666527a"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd jd gy z fp ob fr fs oc fu fw jc bi translated">Flutter app从头开始第2部分—定义模型和建立数据库</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">如何从头开始构建Flutter应用程序系列的第2部分。这篇文章是关于模型定义和…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="of l"><div class="pm l oh oi oj of ok lb nw"/></div></div></a></div><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/flutter-app-from-scratch-part-1-planned-features-app-design-app-skeleton-c87f2c21f47a"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd jd gy z fp ob fr fs oc fu fw jc bi translated">Flutter app从零开始第1部分—规划的功能、应用设计、应用框架</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">本文涵盖了计划中的应用程序特性、环境设置以及一个新的Flutter应用程序的第一个应用程序框架。</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="of l"><div class="pn l oh oi oj of ok lb nw"/></div></div></a></div></div></div>    
</body>
</html>