<html>
<head>
<title>RxJS Operator Tips — startWith</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS操作员提示—开始于</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rxjs-operator-tips-startwith-d67109c8883e?source=collection_archive---------1-----------------------#2020-08-09">https://levelup.gitconnected.com/rxjs-operator-tips-startwith-d67109c8883e?source=collection_archive---------1-----------------------#2020-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0536316ebb77c463ef77ed105f2c5c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pD6woKTKMxa2B6_v"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@pabloheimplatz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pablo Heimplatz </a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片—发布大量事件</figcaption></figure><div class=""/><p id="ab94" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结合<code class="fe le lf lg lh b">startWith</code>和<code class="fe le lf lg lh b">EventEmitter</code>创造牛逼</p><p id="cc88" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在RxJS里是相当容易迷路的。有很多操作符可供选择，在我的开发之旅中，我发现很容易忽略一个可能会让您头疼的操作符。</p><p id="9cd0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">继我上一篇讨论<a class="ae jg" href="https://medium.com/swlh/cant-tell-your-flatmaps-from-your-switchmaps-a1f0f497b61a" rel="noopener">平面图与切换图</a>的文章之后，在这篇文章中，我将讨论<code class="fe le lf lg lh b">startWith</code>。</p><p id="291c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来自<a class="ae jg" href="https://rxjs.dev/api/operators/startWith" rel="noopener ugc nofollow" target="_blank"> RxJS文档</a>的官方定义是:</p><blockquote class="li lj lk"><p id="0a84" class="kg kh ll ki b kj kk kl km kn ko kp kq lm ks kt ku ln kw kx ky lo la lb lc ld im bi translated">返回一个可观察对象，它在开始发出由源可观察对象发出的项之前，发出您指定为参数的项。</p></blockquote><h1 id="05cc" class="lp lq jj bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">问题是</h1><p id="8785" class="pw-post-body-paragraph kg kh jj ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">像往常一样，对于编程来说，太容易被“是什么”而不是“为什么”所消耗，所以我们将从问题定义开始。</p><blockquote class="li lj lk"><p id="8c85" class="kg kh ll ki b kj kk kl km kn ko kp kq lm ks kt ku ln kw kx ky lo la lb lc ld im bi translated">假设我有一个查询子值列表的种子值，那么即使种子值不变，我如何订阅刷新事件来更新列表呢？</p></blockquote><p id="42d1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可能会令人困惑，所以，分解成另一种方式:</p><ul class=""><li id="e630" class="ms mt jj ki b kj kk kn ko kr mu kv mv kz mw ld mx my mz na bi translated">我的支持系统显示了开放门票列表<code class="fe le lf lg lh b">path/to/tickets</code></li><li id="b112" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">操作员选择一张票<code class="fe le lf lg lh b">/path/to/tickets/:id</code></li><li id="01f6" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">将显示该票据中的所有评论</li><li id="1c3f" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">当刷新事件被触发时，如何刷新页面？</li></ul><p id="3ed0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的，用户可以刷新页面，但是如果我们在PWA中运行，由于浏览器chrome是不可见的，所以不容易知道如何做。</p><p id="65b6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用刷新事件很有用，因为它可能不仅仅是一个刷新内容的按钮。如果你已经将你的页面连接到某种网络套接字系统，你可能需要在一些外部信号下自动刷新列表。</p><p id="4575" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将向您展示<code class="fe le lf lg lh b">startWith()</code>如何扭转局面，创造出真正优雅的解决方案。</p><h1 id="3bbd" class="lp lq jj bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">TLDR</h1><p id="a012" class="pw-post-body-paragraph kg kh jj ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">将<code class="fe le lf lg lh b">startWith</code>添加到您的<code class="fe le lf lg lh b">EventEmitter</code>订阅管道中，它们会发出一个初始值，无需等待！</p><p id="4720" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想了解更多细节，请继续阅读</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="6b5a" class="lp lq jj bd lr ls nn lu lv lw no ly lz ma np mc md me nq mg mh mi nr mk ml mm bi translated">设置</h1><p id="22c2" class="pw-post-body-paragraph kg kh jj ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">让我们从一个包含两条路线的绿地角度项目开始，门票列表和门票视图。</p><h2 id="459d" class="ns lq jj bd lr nt nu dn lv nv nw dp lz kr nx ny md kv nz oa mh kz ob oc ml od bi translated">门票清单</h2><p id="78e4" class="pw-post-body-paragraph kg kh jj ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">对于这个演示，票列表非常简单，它只包含一个非常简单的票id(1–9)数组和一系列将用户导航到<code class="fe le lf lg lh b">/tickets/:id</code>的<code class="fe le lf lg lh b">&lt;a&gt;</code>标签。</p><figure class="oe of og oh gt iv"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">样板代码</figcaption></figure><p id="752f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的用户界面看起来有点像:</p><h2 id="f831" class="ns lq jj bd lr nt nu dn lv nv nw dp lz kr nx ny md kv nz oa mh kz ob oc ml od bi translated">票证视图</h2><p id="839a" class="pw-post-body-paragraph kg kh jj ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">票证视图是将要解决“问题”的地方。我将讨论类型脚本代码的3种解决方案，然而，HTML将保持不变。</p><p id="f88e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该布局仅包含:</p><ul class=""><li id="aac7" class="ms mt jj ki b kj kk kn ko kr mu kv mv kz mw ld mx my mz na bi translated">票证标题标题</li><li id="e7fb" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">上一张票按钮</li><li id="bbff" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">刷新注释按钮</li><li id="e322" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">下一张票按钮</li><li id="47f6" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">所有评论的列表</li></ul><figure class="oe of og oh gt iv"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="c8be" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为票视图是一个角度组件，所以可以使用<code class="fe le lf lg lh b">ActivatedRoute</code>类提取ID。票证视图的初始存根实现如下所示:</p><figure class="oe of og oh gt iv"><div class="bz fp l di"><div class="oi oj l"/></div></figure><div class="oe of og oh gt ab cb"><figure class="ok iv ol om on oo op paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/434d8cb553e41ad3ff5b370ddffa7f39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*-04ffuheRgZjXXg0H5E8wg.png"/></div></figure><figure class="ok iv oq om on oo op paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/728d41a8c3a601d0dc2c9d1cc6b3ffaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*gkhaxE_3QnnQ9v_sWYmn9w.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk or di os ot translated">2个UI屏幕——忽略完全缺乏设计</figcaption></figure></div><h1 id="1189" class="lp lq jj bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">示例—获取注释</h1><p id="1c53" class="pw-post-body-paragraph kg kh jj ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在每个示例中，我将使用相同的方法来获取实际的票据评论。显然，这只是一个示例，因为它实际上不做任何获取。然而，通过返回结果作为一个<code class="fe le lf lg lh b">Observable&lt;string[]&gt;</code>，这将模拟一个实际的网络调用，因为角度<code class="fe le lf lg lh b">HttpClient</code>将表现得像一个可观测的。</p><figure class="oe of og oh gt iv"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h1 id="168e" class="lp lq jj bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">丑陋的</h1><p id="59fb" class="pw-post-body-paragraph kg kh jj ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">回头看看问题陈述“我如何刷新列表”，最简单的解决方案是只刷新页面。</p><figure class="oe of og oh gt iv"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="0819" class="ns lq jj bd lr nt nu dn lv nv nw dp lz kr nx ny md kv nz oa mh kz ob oc ml od bi translated">赞成的意见</h2><ul class=""><li id="8ad5" class="ms mt jj ki b kj mn kn mo kr ou kv ov kz ow ld mx my mz na bi translated">列表将刷新，任务完成</li></ul><h2 id="f637" class="ns lq jj bd lr nt nu dn lv nv nw dp lz kr nx ny md kv nz oa mh kz ob oc ml od bi translated"><strong class="ak">缺点</strong></h2><ul class=""><li id="ee56" class="ms mt jj ki b kj mn kn mo kr ou kv ov kz ow ld mx my mz na bi translated">整个页面将重新加载，包括其中的所有内容</li><li id="b4f7" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">额外服务器负载</li><li id="31ed" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">没有能力的页面内进度条或UX</li></ul><p id="b68a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着整个网站的所有javascript、HTML和CSS都需要重新计算。而且，如果您的用户正在做其他事情，那么他们的工作可能会丢失。对于这样一个简单的问题来说，这是大材小用，违背了单页面应用程序(SPA)的全部目的。这就是用大锤敲碎坚果的定义。</p><p id="9fd0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，通过使用<code class="fe le lf lg lh b">activatedRoute</code>的<code class="fe le lf lg lh b">snapshot</code>机制，我们也无法使用Angular提供的可重用组件。</p><h1 id="e827" class="lp lq jj bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">坏事</h1><p id="18d0" class="pw-post-body-paragraph kg kh jj ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">接下来，我们转向稍微好一点，但不是很好的实现。在这个例子中，我们将使用一个<code class="fe le lf lg lh b">BehaviorSubject</code>来存储票ID的值。</p><figure class="oe of og oh gt iv"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="a48f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，这要好得多，但是“刷新”逻辑围绕着将<code class="fe le lf lg lh b">currentTicketId</code>行为的值重置为相同的值。这将使管道认为值已经更改，并将强制加载注释。</p><h2 id="cba3" class="ns lq jj bd lr nt nu dn lv nv nw dp lz kr nx ny md kv nz oa mh kz ob oc ml od bi translated">赞成的意见</h2><ul class=""><li id="c041" class="ms mt jj ki b kj mn kn mo kr ou kv ov kz ow ld mx my mz na bi translated">页面无法重新加载</li><li id="65db" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">当导航到不同的票证时，组件被重用</li></ul><h2 id="1841" class="ns lq jj bd lr nt nu dn lv nv nw dp lz kr nx ny md kv nz oa mh kz ob oc ml od bi translated">骗局</h2><ul class=""><li id="0eae" class="ms mt jj ki b kj mn kn mo kr ou kv ov kz ow ld mx my mz na bi translated">使用<code class="fe le lf lg lh b">currentTicketId</code>的所有元素将在注释更改时重新计算</li><li id="3b63" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">需要在页面加载时过滤掉初始空值</li><li id="06ae" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">无法区分页面加载和刷新事件</li></ul><p id="e883" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就我个人而言，我在很多项目中使用行为主体。它们是将价值转化为可观察值并轻松改变它们的好方法。</p><p id="9c61" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，我认为我们可以做得更好。</p><h1 id="af4c" class="lp lq jj bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">好的(或者，可能是伟大的)</h1><p id="ddea" class="pw-post-body-paragraph kg kh jj ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我花了很长时间才到达这里，但我们最终将使用<code class="fe le lf lg lh b">startWith</code>。</p><p id="91b1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">角度<code class="fe le lf lg lh b">EventEmitter</code>是一个非常简单的可观测值。当<code class="fe le lf lg lh b">emit</code>方法被调用时(带有一个可选值)，该事件的所有订阅者都可以执行一个动作。</p><p id="d960" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我的理想目标是以某种方式将传入的票证ID可观察事件和刷新请求事件结合起来。如果触发了票证Id或刷新事件，则结果将是<strong class="ki jk">,注释列表将被更新。</strong></p><p id="93a6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将结合另外两个RxJS概念，以正确的方式解决这个问题:</p><ol class=""><li id="9d9f" class="ms mt jj ki b kj kk kn ko kr mu kv mv kz mw ld ox my mz na bi translated">使用<code class="fe le lf lg lh b">combineLatest</code>操作员监听ID和事件</li><li id="a5fc" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld ox my mz na bi translated">将<code class="fe le lf lg lh b">startWith</code>添加到事件中，这样它就有了初始值</li></ol><figure class="oe of og oh gt iv"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="095f" class="ns lq jj bd lr nt nu dn lv nv nw dp lz kr nx ny md kv nz oa mh kz ob oc ml od bi translated">赞成的意见</h2><ul class=""><li id="5d2b" class="ms mt jj ki b kj mn kn mo kr ou kv ov kz ow ld mx my mz na bi translated">页面无法重新加载</li><li id="ca04" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated">当导航到不同的票证时，组件被重用</li><li id="35aa" class="ms mt jj ki b kj nb kn nc kr nd kv ne kz nf ld mx my mz na bi translated"><strong class="ki jk">可以将刷新事件从票证Id更改中分离出来</strong></li></ul><h2 id="5b73" class="ns lq jj bd lr nt nu dn lv nv nw dp lz kr nx ny md kv nz oa mh kz ob oc ml od bi translated">骗局</h2><ul class=""><li id="60de" class="ms mt jj ki b kj mn kn mo kr ou kv ov kz ow ld mx my mz na bi">?</li></ul><p id="12c6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe le lf lg lh b">combineLatest</code>的好处是可以使用相同的管道来检索评论，无论这是如何触发的。这是一个非常有用的函数，因为它将接受许多可观察对象，并将输出作为单个数组返回，<strong class="ki jk">，但只有当每个可观察对象都发出某种东西时</strong>。</p><p id="e903" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是<code class="fe le lf lg lh b">startWith</code>的用武之地。它确保事件总是发出一些东西，这样评论至少会加载一次。</p><figure class="oe of og oh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/e9704249ebc506713efcf5ac818ef8a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RpyRT9LErCez3YLHY-7y7A.gif"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">输出——我不是UI设计师</figcaption></figure><h1 id="71fb" class="lp lq jj bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">利益</h1><p id="8f64" class="pw-post-body-paragraph kg kh jj ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我认为这样做的主要好处是，它使得使用事件作为管道的一部分变得非常容易。</p><p id="b0fd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在很多情况下，您都希望加载数据并进行刷新。如果没有这个<code class="fe le lf lg lh b">startWith</code>功能，你将需要写一些额外的/古怪的变通方法，这只会让你的代码变得难看。</p><h1 id="3586" class="lp lq jj bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="3bab" class="pw-post-body-paragraph kg kh jj ki b kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><code class="fe le lf lg lh b">startWith</code>操作符在许多场景中都很有用。对于任何没有初始值的可观测值(几乎所有在<code class="fe le lf lg lh b">of() &amp; from() &amp; BehaviorSubject</code>之外的可观测值)来说，有一个初始值是很有意义的。</p><p id="ed3b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像大多数事情一样，这是主观的。我非常喜欢“寻找正确的解决方案”，但是，这并不一定是你的解决方案。无论哪种方式，RxJS操作符的列表都很大，功能丰富，对许多场景都非常有帮助。</p><p id="7f9e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你会用<code class="fe le lf lg lh b">startWith</code>做什么？</p></div></div>    
</body>
</html>