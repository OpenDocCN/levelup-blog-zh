<html>
<head>
<title>Scope Methods, Metaprogramming, and Refactoring in Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rails中的范围方法、元编程和重构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scope-methods-metaprogramming-refactoring-in-rails-60e297b29d4e?source=collection_archive---------3-----------------------#2019-07-26">https://levelup.gitconnected.com/scope-methods-metaprogramming-refactoring-in-rails-60e297b29d4e?source=collection_archive---------3-----------------------#2019-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fc6da2ee7960eb2b5eaa386cc94ab75e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dG9erow5z_YJo3FIVrRVrA.png"/></div></div></figure><p id="540b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="http://wine-log.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">日志</a></p><p id="b2ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">构建范围方法是构建我的rails项目中更具挑战性(也更有回报)的方面之一。</p><p id="1f51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个很简单——在创建新酒的表单中，用户可以将一款酒标记为“最爱”。目标是使用活动记录查询接口查询数据库，并返回一组喜爱的葡萄酒。因为我想返回多个对象，所以<code class="fe la lb lc ld b">where</code>方法是最好的选择。</p><p id="ec46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">scope :is_favorite, -&gt; {where(favorite: true)}</code></p><p id="c2ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还希望能够返回高评级的葡萄酒——即使用户没有将该葡萄酒标记为最爱。<code class="fe la lb lc ld b">where</code>在这里也很完美。</p><p id="f17a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">scope :highly_rated, -&gt; {where("rating &gt; ?", 7)}</code></p><p id="fa2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一组方法更加复杂——我想按类型和平均评级对葡萄酒进行分类，以了解用户平均更喜欢什么类型的葡萄酒。</p><p id="8456" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">构建一个<code class="fe la lb lc ld b">average rating</code>的方法很简单:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="21fb" class="lm ln it ld b gy lo lp l lq lr">def self.average_rating<br/>    average(:rating)<br/>  end</span></pre><p id="5fee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，按葡萄酒类型查询则不然。葡萄酒的种类(红、白、玫瑰红)是有限的——所以我选择不为它创建模型。</p><p id="5692" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管如此，我还是希望能够按类型对葡萄酒进行排序，以便为用户提供见解——所以我创建了一组scope方法，以便我可以基于葡萄酒类型进行查询:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="47b9" class="lm ln it ld b gy lo lp l lq lr">scope :red, -&gt; {where(wine_type: "Red")}<br/>  scope :white, -&gt; {where(wine_type: "White")}      <br/>  scope :rose, -&gt; {where(wine_type: "Rose")}    <br/>  scope :sweet, -&gt; {where(wine_type: "Sweet")}      <br/>  scope :sparkling, -&gt; {where(wine_type: "Sparkling")}     <br/>  scope :other, -&gt; {where(wine_type: "other")}</span></pre><p id="74aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我可以打电话给<code class="fe la lb lc ld b">.red</code>退回所有红酒！</p><p id="a57b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个版本的<code class="fe la lb lc ld b">top_rated</code>类方法是:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="24a1" class="lm ln it ld b gy lo lp l lq lr">def self.top_rated<br/>    averages = {"Red" =&gt; Wine.red.average_rating.to_f,<br/>                "White" =&gt; Wine.white.average_rating.to_f,<br/>                "Rose"=&gt; Wine.rose.average_rating.to_f,<br/>                "Sparkling"=&gt; Wine.sparkling.average_rating.to_f,<br/>                "sweet"=&gt; Wine.sweet.average_rating.to_f}<br/>    top_type = averages.sort_by { |wine_type, avg| avg }.last[0]<br/>  end</span></pre><p id="cae2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它工作了——但是它很长，而且，因为我写了不止一个基于葡萄酒类型的scope方法，所以是重复的。</p><p id="26fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我分两步让代码变得更加枯燥。首先，我消除了散列，以便使用<code class="fe la lb lc ld b">pluck</code>遍历wines表的<code class="fe la lb lc ld b">:wine_type</code>中的值。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="cb92" class="lm ln it ld b gy lo lp l lq lr">def self.top_rated<br/>    averages = {}<br/>    types = Wine.pluck(:wine_type).uniq<br/>    types.each do |type|<br/>      averages[type] = Wine.where(wine_type: type).average_rating.to_f<br/>    end<br/>    top_type = averages.sort_by { |wine_type, avg| avg }.last[0]<br/>end</span></pre><p id="435a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这更干净，但仍不完美。为什么要在数据库中查询一个甚至不是对象的属性，而且我知道可能的选项？</p><p id="d507" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建一个类常量消除了一行代码和对数据库的查询。</p><p id="d624" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">WINE_TYPES = ["Red", "White", "Rose", "Sparkling", "Sweet", "Other"]</code></p><p id="c13a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一种方法如下:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="11e6" class="lm ln it ld b gy lo lp l lq lr">def self.top_rated<br/>    averages = {}<br/>    WINE_TYPES.each do |type|<br/>      averages[type] = Wine.where(wine_type: type).average_rating.to_f<br/>    end<br/>    top_type = averages.sort_by { |wine_type, avg| avg }.last[0]<br/>  end</span></pre><p id="c87c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还能够用类常量来整理葡萄酒表单:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="fb61" class="lm ln it ld b gy lo lp l lq lr">&lt;%= f.label :wine_type, "Type:" %&gt;<br/>&lt;%= f.select :wine_type, options_for_select(Wine::WINE_TYPES, selected: @wine.wine_type) %&gt;</span></pre><p id="aefc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">而不是:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="8ec5" class="lm ln it ld b gy lo lp l lq lr">&lt;%= f.label :wine_type, "Type:" %&gt;<br/>&lt;%= f.select :wine_type, options_for_select(["Red", "White", "Rose", "Sparking", "Sweet", "Other"], selected: @wine.wine_type) %&gt;</span></pre><p id="115f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">能够根据葡萄酒类型进行过滤的scope方法是有效的，但是不优雅且不可伸缩。如果我想创造更多的选择呢？六行代码可能会快速增长，变得枯燥和笨拙。我能够再次重构，使用<a class="ae kz" href="http://https//apidock.com/ruby/Object/singleton_class" rel="noopener ugc nofollow" target="_blank">单例类方法</a>。singleton类是元编程的一种形式，允许更大的灵活性。它在类内部被调用——但不是作为一个方法，因为它定义了一个方法本身。我的应用程序使用的实现如下。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="4076" class="lm ln it ld b gy lo lp l lq lr">self.singleton_class.class_eval do<br/>    WINE_TYPES.each do |wine_type|<br/>      define_method(wine_type.downcase.to_sym) do<br/>        where(wine_type: wine_type)<br/>      end<br/>    end<br/>  end</span></pre><p id="6481" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重构是一个多步骤的过程，它让我的代码更容易理解，更简单，也让我更容易添加额外的方法。</p></div></div>    
</body>
</html>