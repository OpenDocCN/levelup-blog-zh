<html>
<head>
<title>What is state usage tracking? A novel approach to intuitive and performant global state with React hooks and Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是状态使用跟踪？一种利用反应钩子和代理实现直观和高性能全局状态的新方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-state-usage-tracking-a-novel-approach-to-intuitive-and-performant-global-state-with-react-f8d74a061f14?source=collection_archive---------5-----------------------#2019-07-07">https://levelup.gitconnected.com/what-is-state-usage-tracking-a-novel-approach-to-intuitive-and-performant-global-state-with-react-f8d74a061f14?source=collection_archive---------5-----------------------#2019-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ad5f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对于Redux和非Redux</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f5121ccc2c8e36243f85c432eda62aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9-Xc_kEGi5yyY6WDaBCSNw.jpeg"/></div></div></figure><h1 id="dd25" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="b4d9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有许多带有React钩子的全局状态库。React Redux还提供了一个hooks API，非常干净。</p><p id="16a1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一般来说，我会避免使用全局状态。它会降低元件的隔离。对于某些用例来说，多上下文应该可以很好地工作。</p><p id="79c7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">但是，如果我们真的需要一个全球性的国家。</p><h1 id="c20e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">问题</h1><p id="da61" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当状态是一个重要的对象时，不太可能使用对象的所有属性来呈现一个组件。大多数库所做的是提供一个选择器接口。使用选择器接口，开发人员可以指定在组件中使用状态的哪一部分。一般来说，选择器是一个函数，但是也有其他方法来指定状态的一部分。例如，通过属性名或路径。在任何情况下，开发人员都有责任编写合适的选择器。</p><p id="2394" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这不仅仅是关于React Redux，而是适用于大多数库。</p><h1 id="dee5" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">解决方案“状态使用跟踪”</h1><p id="64c1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">状态使用跟踪是为了自动化这个过程。系统跟踪状态是如何被使用的，而不是开发人员指定使用状态的哪一部分。代理API起到跟踪的作用。使用代理API进行跟踪的想法并不新鲜。Immer和MobX使用代理来检测变化。不同的是目的。Immer使用代理来检测突变或说“写操作”然而，状态使用跟踪是针对“读取操作”的</p><p id="8545" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我的提议是将React的反应系统与基于代理的跟踪结合起来。感谢React挂钩，它非常容易使用。我当前的实现提供了<code class="fe mn mo mp mq b">useTrackedState</code>钩子。如果你在render中调用这个钩子，你会得到一个状态。然后，您可以在render中使用该状态。钩子自动跟踪状态在render中的使用。有了跟踪，钩子只有在状态的已用部分改变时才会触发重新渲染。因为如果只改变了状态中未使用的部分，那么重新呈现就没有意义了。</p><h1 id="d81e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">没有语义变化</h1><p id="8bcc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">需要注意的是，状态使用跟踪不会改变任何语义。让我们假设只有状态的未使用部分被改变。在这种情况下，钩子触发重新呈现，但是组件将呈现正确的结果。如果钩子实际上没有跟踪任何东西，我们将得到同样的结果。不同的只是它可能会慢下来。</p><p id="a250" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">重点是useTrackedState挂钩中没有语义变化。它只会优化重新渲染。开发人员需要编码什么，而不是如何编码。这不同于使用选择器来控制重新渲染。</p><h1 id="6bdb" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">表演</h1><p id="160f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">唯一剩下的问题是实践中的优化，因为这是有代价的。这就是为什么基准测试很重要。该挂钩使用起来简单明了。如果它可以在性能相当的情况下使用，那就很好。</p><p id="7373" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">基准测试结果显示<a class="ae mr" href="https://blog.axlight.com/posts/benchmark-react-tracked/" rel="noopener ugc nofollow" target="_blank">状态使用跟踪和选择器</a>一样快。实际上，在某些情况下会更快。</p><h1 id="eb26" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">使用状态使用跟踪的项目</h1><ul class=""><li id="13ba" class="ms mt it lo b lp lq ls lt lv mu lz mv md mw mh mx my mz na bi translated"><a class="ae mr" href="https://github.com/dai-shi/react-tracked" rel="noopener ugc nofollow" target="_blank">反应跟踪</a>:非还原全局状态</li><li id="e34a" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated"><a class="ae mr" href="https://github.com/dai-shi/reactive-react-redux" rel="noopener ugc nofollow" target="_blank">反应-反应-还原</a>:反应还原替代</li></ul><h1 id="126d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结束语</h1><p id="7b00" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这篇短文解释了状态使用跟踪的概念。不像我的其他帖子，没有代码片段。我希望不用代码就能很好地解释这个想法。我感谢任何反馈，以便我可以写一篇后续文章。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="2840" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><em class="nn">原载于2019年7月7日</em><a class="ae mr" href="https://blog.axlight.com/posts/what-is-state-usage-tracking-a-novel-approach-to-intuitive-and-performant-api-with-react-hooks-and-proxy/" rel="noopener ugc nofollow" target="_blank"><em class="nn">https://blog.axlight.com</em></a><em class="nn">。</em></p></div></div>    
</body>
</html>