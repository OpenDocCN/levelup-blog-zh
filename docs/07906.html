<html>
<head>
<title>Extending Xamarin.Forms.Nuke on iOS to load a placeholder for images that fail to load</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扩展Xamarin。iOS上的Forms.Nuke为加载失败的图片加载一个占位符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/extending-xamarin-forms-nuke-on-ios-to-load-a-placeholder-for-images-that-fail-to-load-f024a3f415a2?source=collection_archive---------7-----------------------#2021-03-20">https://levelup.gitconnected.com/extending-xamarin-forms-nuke-on-ios-to-load-a-placeholder-for-images-that-fail-to-load-f024a3f415a2?source=collection_archive---------7-----------------------#2021-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="59bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当我们从网上加载图片时，都有可能加载失败。为了获得更好的用户体验，准备好占位符机制至关重要。在这篇文章中，我将向你展示我如何扩展我的Xamarin分支。Forms.Nuke在iOS上实现这个目标。</p><h2 id="8338" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">什么是Xamarin？表格。核弹？</h2><p id="5947" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated"><a class="ae lj" href="https://www.sharpnado.com/xamarin-forms-nuke/" rel="noopener ugc nofollow" target="_blank"> Xamarin。Forms.Nuke </a>是一个Xamarin。表单实现<a class="ae lj" href="https://github.com/kean/Nuke" rel="noopener ugc nofollow" target="_blank"> Nuke </a>，这是当今iOS上最先进的图像库之一。<a class="ae lj" href="https://github.com/roubachof/Xamarin.Forms.Nuke" rel="noopener ugc nofollow" target="_blank"> Xamarin。表单实现</a>主要关注缓存，而原始库有更多的特性。当我开始通过我以前使用的<a class="ae lj" href="https://github.com/reactiveui/Akavache" rel="noopener ugc nofollow" target="_blank"> Akavache </a>寻找缓存图像的替代方案时，我了解到了这个库(我从来没有在博客上讨论过这个部分，因为它还没有准备好，tbh)。</p><h2 id="20a0" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">为什么我们需要扩建图书馆？</h2><p id="cf6f" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">该库目前只做一件事(相当不错)——处理网页图像的缓存。它使用原生核武器库的默认设置。<code class="fe lk ll lm ln b">Xamarin.Forms</code>实现覆盖了<code class="fe lk ll lm ln b">UriImageSource</code>和<code class="fe lk ll lm ln b">FileImageSource</code>的<code class="fe lk ll lm ln b">ImageSourceHandler</code>(可选)，但是占位符加载的情况在最初的版本中是不允许的。由于我有多个使用占位符的场景，所以我决定扩展这个库——并从现在开始维护我自己的分支。(也许还会有对原始源的拉取请求)。</p><h2 id="7caa" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">给我看看一些代码，最后！</h2><p id="fee1" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">对于我们的扩展，我们修改了<code class="fe lk ll lm ln b">FormsHandler</code>类和<code class="fe lk ll lm ln b">ImageSourceHandler</code>类。先来看看<code class="fe lk ll lm ln b">FormsHandler</code>类。我们正在为占位符添加一个新属性:</p><pre class="lo lp lq lr gt ls ln lt lu aw lv bi"><span id="cdf9" class="kl km iq ln b gy lw lx l ly lz">public static ImageSource PlaceholderImageSource { get; private set; }</span></pre><p id="aa0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我选择了<code class="fe lk ll lm ln b">FormsHandler</code>类，因为设置占位符是一件全局的事情(在我的场景中，您的里程可能会有所不同)。这已经包含了<code class="fe lk ll lm ln b">FormsHandler</code>类中的所有内容，所以让我们来看看<code class="fe lk ll lm ln b">ImageSourceHandler</code>类。</p><p id="73e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们使用默认的<code class="fe lk ll lm ln b">Xamarin.Forms</code> <code class="fe lk ll lm ln b">ImageSourceHandler</code>作为资源图像(这是一个<code class="fe lk ll lm ln b">StreamImageSource</code>)和<code class="fe lk ll lm ln b">FontImageSource</code>，我们需要首先为它们添加静态字段:</p><pre class="lo lp lq lr gt ls ln lt lu aw lv bi"><span id="ead4" class="kl km iq ln b gy lw lx l ly lz">private static readonly StreamImagesourceHandler DefaultStreamImageSourceHandler = new StreamImagesourceHandler();<br/><br/>private static readonly FontImageSourceHandler DefaultFontImageSourcehandler = new FontImageSourceHandler();</span></pre><p id="6bf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们用一个单独的方法来实现占位符的加载:</p><pre class="lo lp lq lr gt ls ln lt lu aw lv bi"><span id="8b28" class="kl km iq ln b gy lw lx l ly lz">private static Task&lt;UIImage&gt; LoadPlaceholderAsync()<br/>{<br/>    switch (FormsHandler.PlaceholderImageSource)<br/>    {<br/>        case StreamImageSource streamImageSource:<br/>            FormsHandler.Warn($"loading placeholder from resource");<br/>            return DefaultStreamImageSourceHandler.LoadImageAsync(streamImageSource);<br/>                    <br/>        case FontImageSource fontImageSource:<br/>            FormsHandler.Warn($"loading placeholder from Font");<br/>            return DefaultFontImageSourcehandler.LoadImageAsync(fontImageSource);<br/>        default:<br/>            FormsHandler.Warn($"no valid placeholder found");<br/>            return null;<br/>    }<br/>}</span></pre><p id="e747" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，这种方法没有什么过于复杂的地方。基于在<code class="fe lk ll lm ln b">FormsHandler</code>类中设置的占位符的类型，我们为占位符图像调用默认的<code class="fe lk ll lm ln b">Xamarin.Forms</code>实现。让我们通过改变<code class="fe lk ll lm ln b">ImageSourceHandler</code>的<code class="fe lk ll lm ln b">LoadImageAsync</code>方法来执行这段代码:</p><pre class="lo lp lq lr gt ls ln lt lu aw lv bi"><span id="5200" class="kl km iq ln b gy lw lx l ly lz">public async Task&lt;UIImage&gt; LoadImageAsync(<br/>    ImageSource imageSource,<br/>    CancellationToken cancellationToken = new CancellationToken(),<br/>    float scale = 1)<br/>{<br/>    var result = await NukeHelper.LoadViaNuke(imageSource, cancellationToken, scale);<br/>    if (result == null)<br/>        result = await LoadPlaceholderAsync();<br/><br/>    return result;<br/>}</span></pre><p id="850e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们需要知道<code class="fe lk ll lm ln b">Nukehelper</code>类是否能够加载图像，所以我们已经通过在这个级别等待它来运行代码。如果结果为空，我们将通过之前实现的方法加载占位符图像。这就是我们在分叉的<code class="fe lk ll lm ln b">Xamarin.Forms.Nuke</code>存储库中需要做的一切。</p><h2 id="5e8c" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">如何在您的Xamarin中使用它。表单— iOS项目</h2><p id="8fa3" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">首先，<a class="ae lj" href="https://github.com/MSiccDev/Xamarin.Forms.Nuke" rel="noopener ugc nofollow" target="_blank">克隆<code class="fe lk ll lm ln b">Xamarin.Forms.Nuke</code>库的我的分支</a>(如果你愿意，也可以分支它)并将其导入到你的<code class="fe lk ll lm ln b">Xamarin.Forms</code>解决方案中，并在你的iOS项目中引用它。一旦完成，我们需要在<code class="fe lk ll lm ln b">AppDelegate</code>的<code class="fe lk ll lm ln b">FinishedLaunching</code>方法中初始化Nuke库(就像在原始源代码中一样):</p><pre class="lo lp lq lr gt ls ln lt lu aw lv bi"><span id="7ac5" class="kl km iq ln b gy lw lx l ly lz">Xamarin.Forms.Nuke.FormsHandler.Init(true, false);</span></pre><p id="e610" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二步是定义占位符图像源。<code class="fe lk ll lm ln b">FontImageSource</code>应该在<code class="fe lk ll lm ln b">LoadApplication</code>方法之后定义。这样，你可以用<code class="fe lk ll lm ln b">Xamarin.Forms</code>的方式加载字体作为资源。</p><pre class="lo lp lq lr gt ls ln lt lu aw lv bi"><span id="e982" class="kl km iq ln b gy lw lx l ly lz">//Resource image<br/>Xamarin.Forms.Nuke.FormsHandler.PlaceholderFromResource("CachedImageTest.MSicc_Logo_Base_Blue_1024px_pad25.png", Assembly.GetAssembly(typeof(MainViewModel)));<br/><br/>//FontImageSource<br/>Xamarin.Forms.Nuke.FormsHandler.PlaceholderFromFontImageSource(new FontImageSource<br/>{<br/>    Glyph = CachedImageTest.Resources.MaterialDesignIcons.ImageBroken,<br/>    FontFamily = "MaterialDesignIcons",<br/>    Color = Color.Red<br/>});</span></pre><p id="6f21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在像往常一样使用<code class="fe lk ll lm ln b">Xamarin.Forms</code> <code class="fe lk ll lm ln b">Image</code>控件。如果无法加载来自web的图像，您将会看到占位符，如以下两个示例所示:</p><figure class="lo lp lq lr gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ma"><img src="../Images/66012142d53fbec5fb6ad30b842231cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ud71J9SN_Bv10Ffijl2klw.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">左:单幅图像加载失败—右:<code class="fe lk ll lm ln b">CollectionView </code>中的图像加载失败</figcaption></figure><p id="0596" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过对<code class="fe lk ll lm ln b">Xamarin.Forms.Nuke</code>库的一些补充，我们实现了一个占位符机制，用于不能加载的图像。一如既往，我希望这篇文章对你们有些人有用。现在我已经在iOS上实现了一个快速缓存的图像，并加载了占位符，我将转向Android，在那里我将尝试使用<a class="ae lj" href="https://github.com/jonathanpeppers/glidex" rel="noopener ugc nofollow" target="_blank"> Glidex来实现同样的功能。窗体</a>库，并扩展它来加载一个占位符。一旦实施，将有一个完整的样本。敬请期待！</p><p id="fa0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">直到下一个帖子，大家编码快乐！</strong></p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="f953" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">扩展Xamarin的帖子<a class="ae lj" href="https://msicc.net/extending-xamarin-forms-nuke-to-load-a-placeholder-for-images-that-fail-to-load/" rel="noopener ugc nofollow" target="_blank">。iOS上的Forms.Nuke为加载失败的图片加载占位符</a>首先出现在<a class="ae lj" href="https://msicc.net" rel="noopener ugc nofollow" target="_blank"> MSicc的博客</a>。</p></div></div>    
</body>
</html>