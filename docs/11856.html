<html>
<head>
<title>Write a Linux packet sniffer from scratch with Raw socket and BPF</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用原始套接字和BPF从头开始写一个Linux包嗅探器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/write-a-linux-packet-sniffer-from-scratch-with-raw-socket-and-bpf-c53734b51850?source=collection_archive---------2-----------------------#2022-04-24">https://levelup.gitconnected.com/write-a-linux-packet-sniffer-from-scratch-with-raw-socket-and-bpf-c53734b51850?source=collection_archive---------2-----------------------#2022-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="4685" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">背景</h1><p id="2372" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当我们提到网络数据包嗅探器时，一些著名和流行的工具会出现在您的脑海中，如<code class="fe lj lk ll lm b">tcpdump</code>。在我以前的文章中，我已经向您展示了如何用这样的工具捕获网络数据包。但是你有没有想过从头开始编写一个不依赖任何第三方库的包嗅探器？我们需要深入挖掘操作系统，找到构建这个工具所需的武器。听起来很复杂，对吧？在这篇文章中，让我们这样做。看完这篇文章，你会发现其实并没有你想象的那么难。</p><p id="6a02" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">注意，不同的操作系统内核有不同的内部网络实现。本文将重点介绍<code class="fe lj lk ll lm b">Linux</code>平台。</p><p id="5151" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">注意这篇文章最初发表在我的个人博客<a class="ae ls" href="https://organicprogrammer.com/2022/03/28/how-to-implement-libpcap-on-linux-with-raw-socket-part2/" rel="noopener ugc nofollow" target="_blank">这里</a>。谢谢</p><h1 id="6710" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="c4cc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，我们需要回顾一下<code class="fe lj lk ll lm b">tcpdump</code>是如何实现的。根据官方<a class="ae ls" href="https://www.tcpdump.org/" rel="noopener ugc nofollow" target="_blank">文件</a> , <code class="fe lj lk ll lm b">tcpdump</code>是在<code class="fe lj lk ll lm b">libpcap</code>库的基础上建造的，该库是基于Berkeley的卓越研究成果开发的，详细内容可以参考<a class="ae ls" href="https://www.tcpdump.org/papers/bpf-usenix93.pdf" rel="noopener ugc nofollow" target="_blank">本文</a>。</p><p id="8a9a" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">如您所知，不同的操作系统有不同的网络堆栈内部实现。<code class="fe lj lk ll lm b">libpcap</code>涵盖了所有这些差异，并为用户级数据包捕获提供了独立于系统的接口。但是在这篇文章中，我想重点介绍Linux平台，那么<code class="fe lj lk ll lm b">libpcap</code>在Linux系统上是如何工作的呢？根据一些<a class="ae ls" href="https://stackoverflow.com/questions/21200009/capturing-performance-with-pcap-vs-raw-socket" rel="noopener ugc nofollow" target="_blank">文档</a>，原来<code class="fe lj lk ll lm b">libpcap</code>在一个网络接口上使用<code class="fe lj lk ll lm b">PF_PACKET</code> socket来抓取数据包。</p><p id="c451" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">那么接下来的问题就是:<code class="fe lj lk ll lm b">PF_PACKET</code>插座是什么？</p><h1 id="7655" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">PF _数据包套接字</h1><p id="c2fa" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我之前的<a class="ae ls" href="https://organicprogrammer.com/2021/07/31/how-to-implement-simple-http-server-golang/" rel="noopener ugc nofollow" target="_blank">文章</a>中，我们提到了socket接口是TCP/IP对世界的窗口。在大多数包含TCP/IP的现代系统中，套接字接口是应用程序使用TCP/IP协议集的唯一方式。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/302462e8967004cb854c2e54c2b07dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/0*Jve0_ga7jhZ3_KTt.png"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">PF _插座</figcaption></figure><p id="6afb" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">这是正确的。这一次，让我们通过检查创建新套接字时执行的系统调用来更深入地了解<code class="fe lj lk ll lm b">socket</code>:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="1d6d" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">当您想要使用上面的系统调用创建一个套接字时，您必须指定您想要使用哪个域(或协议族)作为该套接字的第一个参数。最常用的家族是<code class="fe lj lk ll lm b">PF_INET</code>，用于基于IPv4协议的通信(创建TCP服务器时，使用这个家族)。此外，您必须为您的套接字指定一个类型作为第二个参数。可能的值取决于您指定的系列。例如，在处理<code class="fe lj lk ll lm b">PF_INET</code>家族时，type的值包括<code class="fe lj lk ll lm b">SOCK_STREAM</code>(TCP)和<code class="fe lj lk ll lm b">SOCK_DGRAM</code>(UDP)。有关socket系统调用的其他详细信息，可以参考socket(3)手册页。</p><p id="1258" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">在手册页中，您可以为<code class="fe lj lk ll lm b">domain</code>参数找到一个潜在的值，如下所示:</p><pre class="lu lv lw lx gt mh lm mi mj aw mk bi"><span id="fbbd" class="ml jo iq lm b gy mm mn l mo mp">AF_PACKET    Low-level packet interface</span></pre><p id="0e25" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated"><strong class="kn ir">注</strong> : <code class="fe lj lk ll lm b">AF_PACKET</code>和<code class="fe lj lk ll lm b">PF_PACKET</code>相同。历史上叫<code class="fe lj lk ll lm b">PF_PACKET</code>，后来改名为<code class="fe lj lk ll lm b">AF_PACKET</code>。<code class="fe lj lk ll lm b">PF</code>表示协议族，<code class="fe lj lk ll lm b">AF</code>表示地址族。在本文中，我使用<code class="fe lj lk ll lm b">PF_PACKET</code>。</p><p id="7505" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">不同于<code class="fe lj lk ll lm b">PF_INET</code> socket，可以给你TCP段。通过<code class="fe lj lk ll lm b">PF_PACKET</code>套接字，您可以获得原始的<code class="fe lj lk ll lm b">Ethernet</code>帧，它绕过了TCP/IP堆栈的通常上层处理。这听起来可能有点疯狂。但是，也就是说，收到的任何数据包都将直接传递给应用程序。</p><p id="1965" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">为了更好地理解<code class="fe lj lk ll lm b">PF_PACKET</code> socket，让我们更深入地粗略检查一下从网络接口到应用层的接收包的路径。</p><p id="0d6b" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">(如上图所示)网卡(NIC)收到数据包时，由驱动程序处理。驱动程序在内部维护一个名为<code class="fe lj lk ll lm b">ring buffer</code>的结构。并用直接内存访问(DMA)将数据包写入内核内存(内存预分配有环形缓冲区)。数据包被放在一个名为<code class="fe lj lk ll lm b"><strong class="kn ir">sk_buff</strong></code>的结构中(与内核网络子系统相关的最重要的结构之一)。</p><p id="075f" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">数据包进入内核空间后，逐层进行协议栈处理，如<code class="fe lj lk ll lm b">IP processing</code>、<code class="fe lj lk ll lm b">TCP/UDP processing</code>。数据包通过套接字接口进入应用程序。你已经非常了解这条熟悉的道路了。</p><p id="568e" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">但是对于<code class="fe lj lk ll lm b">PF_PACKET</code>套接字，<code class="fe lj lk ll lm b">sk_buff</code>中的数据包被克隆，然后它跳过协议栈，直接进入应用程序。内核需要克隆操作，因为一个副本由<code class="fe lj lk ll lm b">PF_PACKET</code>套接字使用，另一个副本通过通常的协议栈。</p><p id="2c69" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">在以后的文章中，我将演示更多关于Linux内核网络内部的内容。</p><p id="7cff" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">下一步，让我们看看如何在代码级别创建一个<code class="fe lj lk ll lm b">PF_PACKET</code>套接字。为了简洁，我省略了一些代码，只显示了必要的部分。详细可以参考这个Github <a class="ae ls" href="https://github.com/baoqger/raw-socket-packet-capture-/blob/master/raw_socket.c" rel="noopener ugc nofollow" target="_blank">回购</a>。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="8b72" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">请确保包含系统头文件:<code class="fe lj lk ll lm b">&lt;sys/socket.h&gt; &lt;sys/types.h&gt;</code></p><h1 id="f3dd" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">绑定到一个网络接口</h1><p id="7cf2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果没有额外的设置，嗅探器会捕获所有网络设备上收到的所有数据包。下一步，让我们尝试将嗅探器绑定到特定的网络设备。</p><p id="e331" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">首先，您可以使用<code class="fe lj lk ll lm b">ifconfig</code>命令列出您机器上所有可用的<code class="fe lj lk ll lm b">network interfaces</code>。网络接口是网络硬件的软件接口。</p><p id="ff7e" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">例如，下图显示了网络接口<code class="fe lj lk ll lm b">eth0</code>的信息:</p><pre class="lu lv lw lx gt mh lm mi mj aw mk bi"><span id="0739" class="ml jo iq lm b gy mm mn l mo mp">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br/>        inet 192.168.230.49  netmask 255.255.240.0  broadcast 192.168.239.255<br/>        inet6 fe80::215:5dff:fefb:e31f  prefixlen 64  scopeid 0x20&lt;link&gt;<br/>        ether 00:15:5d:fb:e3:1f  txqueuelen 1000  (Ethernet)<br/>        RX packets 260  bytes 87732 (87.7 KB)<br/>        RX errors 0  dropped 0  overruns 0  frame 0<br/>        TX packets 178  bytes 29393 (29.3 KB)<br/>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span></pre><p id="b7d4" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">让我们将嗅探器绑定到<code class="fe lj lk ll lm b">eth0</code>，如下所示:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="366a" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">我们通过调用<code class="fe lj lk ll lm b">setsockopt</code>系统调用来实现。我把它的详细用法留给你。</p><p id="8d08" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">现在，嗅探器只捕获在指定网卡上接收的网络数据包。</p><h1 id="6e99" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">非混杂和混杂模式</h1><p id="c83f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">默认情况下，每个网卡只关心自己的事情，只读取指向它的帧。意味着网卡丢弃所有不包含自己MAC地址的数据包，这种方式称为<code class="fe lj lk ll lm b">non-promiscuous</code>模式。</p><p id="e3ab" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">接下来，让我们使嗅探器可以在<code class="fe lj lk ll lm b">promiscuous</code>模式下工作。通过这种方式，它检索所有的数据包。即使不是发给它的主机的。</p><p id="e953" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">要将一个网络接口设置为混杂模式，我们所要做的就是向该接口上的一个开放套接字发出<code class="fe lj lk ll lm b">ioctl()</code>系统调用。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2182" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated"><code class="fe lj lk ll lm b">ioctl</code>代表<strong class="kn ir"> I/O控制</strong>，它操纵特定文件的底层设备参数。<code class="fe lj lk ll lm b">ioctl</code>需要三个参数:</p><ul class=""><li id="61e0" class="mq mr iq kn b ko ln ks lo kw ms la mt le mu li mv mw mx my bi translated">第一个参数必须是打开的文件描述符。在我们的例子中，我们使用绑定到网络接口的套接字文件描述符。</li><li id="a37a" class="mq mr iq kn b ko mz ks na kw nb la nc le nd li mv mw mx my bi translated">第二个参数是设备相关的请求代码。你可以看到我们叫了两次<code class="fe lj lk ll lm b">ioctl</code>。第一个调用使用请求代码<em class="ne">SIOC</em><strong class="kn ir"><em class="ne">G</em></strong><em class="ne">if flags</em>来获取标志，第二个调用使用请求代码<em class="ne">SIOC</em><strong class="kn ir"><em class="ne">S</em></strong><em class="ne">if flags</em>来设置标志。不要被这两个拼写相似的常量值所迷惑。</li><li id="254a" class="mq mr iq kn b ko mz ks na kw nb la nc le nd li mv mw mx my bi translated">第三个参数用于向请求进程返回信息。</li></ul><p id="d7e5" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">现在，嗅探器可以检索网卡上收到的所有数据包，而不管这些数据包发往哪台主机。</p><h1 id="a4db" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">BPF包过滤</h1><p id="0668" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">到目前为止，嗅探器捕获网卡上收到的所有网络数据包。但是像<code class="fe lj lk ll lm b">tcpdump</code>这样强大的网络嗅探器应该提供包过滤功能。例如，嗅探器只能捕获<code class="fe lj lk ll lm b">TCP</code>段(并跳过UPD)，或者它只能捕获来自特定源ip地址的数据包。接下来，让我们继续探讨如何做到这一点。</p><h2 id="ca80" class="ml jo iq bd jp nf ng dn jt nh ni dp jx kw nj nk kb la nl nm kf le nn no kj np bi translated">BPF的背景</h2><p id="5e64" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lj lk ll lm b">Berkeley Packet Filter(BPF)</code>是类Unix操作系统中数据包捕获的基本底层技术。在网上以BPF为关键词搜索，结果非常混乱。原来<code class="fe lj lk ll lm b">BPF</code>不断进化，还有<code class="fe lj lk ll lm b">BPF</code><code class="fe lj lk ll lm b">cBPF</code><code class="fe lj lk ll lm b">eBPF</code><code class="fe lj lk ll lm b">LSF</code>等几个关联概念。因此，让我们沿着时间线检查这些概念:</p><ul class=""><li id="87c8" class="mq mr iq kn b ko ln ks lo kw ms la mt le mu li mv mw mx my bi translated">在<strong class="kn ir"> 1992 </strong>，<code class="fe lj lk ll lm b">BPF</code>首次被引入BSD Unix系统，用于过滤不需要的网络数据包。BPF的提议来自劳伦斯柏克莱实验室的研究人员，他们也开发了<code class="fe lj lk ll lm b">libpcap</code>和<code class="fe lj lk ll lm b">tcpdump</code>。</li><li id="7198" class="mq mr iq kn b ko mz ks na kw nb la nc le nd li mv mw mx my bi translated">在<strong class="kn ir"> 1997 </strong>中，Linux Socket Filter(LSF)是基于BPF开发的，并在Linux内核版本2.1.75中引入。注意<code class="fe lj lk ll lm b">LSF</code>和<code class="fe lj lk ll lm b">BPF</code>有一些明显的不同，但是在Linux环境中，当我们谈到BPF或LSF时，我们指的是Linux内核中相同的包过滤机制。我们将在接下来的章节中研究BPF的详细理论和设计。</li><li id="3c98" class="mq mr iq kn b ko mz ks na kw nb la nc le nd li mv mw mx my bi translated">最初，BPF被设计为网络数据包过滤器。但是在<strong class="kn ir"> 2013 </strong>中，BPF得到了广泛的扩展，它可以用于性能分析和故障排除等非联网目的。如今，加长版的BPF被称为<code class="fe lj lk ll lm b">eBPF</code>，而原来已经过时的版本被更名为经典版的BPF ( <code class="fe lj lk ll lm b">cBPF</code>)。<strong class="kn ir">注意，我们在本文中研究的是cBPF，eBPF不在本文的范围之内</strong>。<code class="fe lj lk ll lm b">eBPF</code>是当今软件世界最热门的技术，我将在以后谈到它。</li></ul><h1 id="6439" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">把BPF放在哪里</h1><p id="9d86" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要回答的第一个问题是我们应该在哪里放置过滤器。</p><p id="17e0" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">这个问题的最佳解决方案是在路径中尽可能早地放置过滤器。因为将大量数据从内核空间复制到用户空间会产生巨大的开销，这会极大地影响系统性能。所以BPF是一个核心特性。当网络接口收到数据包时，应立即触发过滤器。正如最初的BPF <a class="ae ls" href="https://www.tcpdump.org/papers/bpf-usenix93.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>所说<strong class="kn ir">为了最小化内存流量，这是大多数现代系统中的主要瓶颈，数据包应该被‘就地’(例如，网络接口DMA引擎放置它的地方)过滤，而不是在过滤之前被复制到一些其他内核缓冲区。</strong> <br/>让我们通过检查如下内核源代码来验证这种行为(<strong class="kn ir">注</strong>本文中展示的内核代码基于2.6版本，其中包含了<code class="fe lj lk ll lm b">cBPF</code>实现。):</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="631c" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated"><code class="fe lj lk ll lm b">packet_create</code>函数在应用程序调用<code class="fe lj lk ll lm b">socket</code>系统调用时处理套接字创建。在第11行和第14行，它将钩子函数附加到套接字上。钩子函数在收到包时执行。</p><p id="9648" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">下面的代码块显示了钩子函数<code class="fe lj lk ll lm b">packet_rcv</code>:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="1252" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated"><code class="fe lj lk ll lm b">packet_rcv</code>函数调用<code class="fe lj lk ll lm b">run_filter</code>，这只是BPF逻辑部分(目前你可以把它看成一个黑盒。在下一节中，我们将研究细节)。基于<code class="fe lj lk ll lm b">run_filter</code>的返回值，数据包可以被过滤掉或放入队列。</p><p id="e530" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">到目前为止，您可以理解BPF(或包过滤)是在内核空间内工作的。但是数据包嗅探器是一个用户空间应用程序。下一个问题是如何将用户空间的过滤规则链接到内核空间的过滤处理程序。</p><p id="e8a9" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">要回答这个问题，我们必须了解BPF本身。现在是了解这部伟大作品的时候了。</p><h1 id="5fb0" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">BPF机器</h1><p id="d8a0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如我上面提到的，<code class="fe lj lk ll lm b">BPF</code>是在伯克利的研究人员写的这篇原创<a class="ae ls" href="https://www.tcpdump.org/papers/bpf-usenix93.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>中介绍的。我强烈推荐你根据我自己的经验阅读这篇伟大的论文。一开始，我觉得读它很疯狂，所以我读了其他相关的文献，试图了解BPF。但是大多数文档只覆盖整个系统的一部分，因此很难将所有信息拼凑在一起。最后看了原纸，把各部分连在一起。<strong class="kn ir">俗话说，有时候花时间其实是一条捷径。</strong></p><h2 id="9856" class="ml jo iq bd jp nf ng dn jt nh ni dp jx kw nj nk kb la nl nm kf le nn no kj np bi translated">虚拟CPU</h2><p id="ced3" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">包过滤器只是包的一个布尔值函数。如果函数值为真，则内核为应用程序复制数据包；如果为假，则忽略该数据包。</p><p id="f519" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">为了尽可能灵活，并且不将应用程序限制在一组预定义的条件下，<code class="fe lj lk ll lm b">BPF</code>实际上被实现为一个运行用户自定义程序的<code class="fe lj lk ll lm b">register-based virtual machine</code>(关于基于堆栈和基于寄存器的虚拟机的区别，可以参考<a class="ae ls" href="http://troubles.md/wasm-is-not-a-stack-machine/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>)。</p><p id="81f2" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">你可以把<code class="fe lj lk ll lm b">BPF</code>看作是<code class="fe lj lk ll lm b">virtual CPU</code>。它由一个<code class="fe lj lk ll lm b">accumulator</code>、一个<code class="fe lj lk ll lm b">index register(x)</code>、一个暂存存储器和一个隐式<code class="fe lj lk ll lm b">program counter</code>组成。如果你不熟悉这些概念，我补充一些简单的例子如下:</p><ul class=""><li id="cb17" class="mq mr iq kn b ko ln ks lo kw ms la mt le mu li mv mw mx my bi translated"><code class="fe lj lk ll lm b">accumulator</code>是一种包含在CPU中的寄存器。在数学和逻辑计算中，它充当保存中间值的临时存储位置。例如，在“1+2+3”的运算中，累加器将保存值1，然后是值3，然后是值6。累加器的好处是它不需要被显式引用。</li><li id="22ae" class="mq mr iq kn b ko mz ks na kw nb la nc le nd li mv mw mx my bi translated">计算机CPU中的<code class="fe lj lk ll lm b">index register</code>是一个处理器寄存器或分配的内存位置，用于在程序运行期间修改操作数地址。</li><li id="e006" class="mq mr iq kn b ko mz ks na kw nb la nc le nd li mv mw mx my bi translated"><code class="fe lj lk ll lm b">program counter</code>是计算机处理器中的CPU寄存器，它具有下一条要从存储器中执行的指令的地址。</li></ul><p id="2415" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">在BPF机器中，累加器用于算术运算，而变址寄存器向包或暂存区提供偏移量。</p><h2 id="565d" class="ml jo iq bd jp nf ng dn jt nh ni dp jx kw nj nk kb la nl nm kf le nn no kj np bi translated">指令集和寻址模式</h2><p id="0c28" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">与物理CPU相同，<code class="fe lj lk ll lm b">BPF</code>提供了一小组算术、逻辑和跳转指令，如下所示，这些指令运行在BPF虚拟机(或CPU)上:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/94b72185429623f324b5e430a81f7dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qlwBMSltPEZYt7eT.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">指令组</figcaption></figure><p id="e116" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">第一列<em class="ne">操作码</em>列出了以汇编语言风格编写的BPF指令。例如<strong class="kn ir"> ld </strong>、<strong class="kn ir"> ldh </strong>和<strong class="kn ir"> ldb </strong>表示将指示值复制到<code class="fe lj lk ll lm b">accumulator</code>中。<strong class="kn ir"> ldx </strong>表示将指示值复制到<code class="fe lj lk ll lm b">index register</code>中。<strong class="kn ir"> jeq </strong>表示如果<code class="fe lj lk ll lm b">accumulator</code>等于指示值，跳转到目标指令。<strong class="kn ir"> ret </strong>表示返回指示值。你可以在论文中详细检查指令集的功能。</p><p id="1dbb" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">这种类似汇编的风格对人类来说可读性更强。但是当我们开发一个应用程序时(比如本文中写的嗅探器)，我们直接使用二进制代码作为BPF指令。这种二进制格式被称为<code class="fe lj lk ll lm b">BPF Bytecode</code>。稍后我将研究将这种汇编语言转换成字节码的方法。</p><p id="0796" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">第二列<em class="ne">地址模式</em>列出了每条指令允许的寻址模式。下表列出了寻址模式的语义:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nv"><img src="../Images/756b37af41916963d95e46cff241d0a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uo2SESkemhYwtyHo.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">地址模式</figcaption></figure><p id="abc6" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">例如，<strong class="kn ir">【k】</strong>表示数据包中字节偏移量为k的数据。<strong class="kn ir"> #k </strong>表示k中存储的文字值，可以详细阅读论文查看其他寻址方式的含义。</p><h2 id="98bb" class="ml jo iq bd jp nf ng dn jt nh ni dp jx kw nj nk kb la nl nm kf le nn no kj np bi translated">BPF计划示例</h2><p id="c8ca" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在让我们根据上面的知识来试着理解下面这个BPF小程序:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="892b" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">BPF程序由一系列BPF指令组成。例如，上面的BPF程序包含四条指令。</p><p id="581a" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">第一条指令<strong class="kn ir"> ldh </strong>从以太网数据包中的偏移量12处将一个半字(16位)值载入累加器。根据下图所示的以太网帧格式，该值就是<code class="fe lj lk ll lm b">Ethernet type</code>字段。以太网类型用于指示哪种协议封装在帧的有效载荷中(例如，ARP的0x0806、<strong class="kn ir">IP v4的0x0800 </strong>和IPv6的0x86DD)。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nw"><img src="../Images/cc1053401d2f4a3efd259d00d498549a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BeOJF_BrP73vHVRC.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">以太网帧</figcaption></figure><p id="d01d" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">第二条指令<strong class="kn ir"> jeq </strong>比较累加器(当前存储<code class="fe lj lk ll lm b">Ethernet type</code>字段)和<code class="fe lj lk ll lm b">0x800</code>(代表IPv4)。如果比较失败，则返回零，数据包被拒绝。如果成功，将返回一个非零值，并接受数据包。<strong class="kn ir">所以小BPF程序过滤并接受所有IP包</strong>。你可以在原文中找到其他BPF计划。去读一读吧，你可以感受到BPF的灵活性以及设计之美。</p><h2 id="e607" class="ml jo iq bd jp nf ng dn jt nh ni dp jx kw nj nk kb la nl nm kf le nn no kj np bi translated">BPF的内核实现</h2><p id="2fee" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，让我们看看内核是如何实现BPF的。如上所述，钩子函数<code class="fe lj lk ll lm b">packet_rcv</code>调用<code class="fe lj lk ll lm b">run_filter</code>来处理过滤逻辑。<code class="fe lj lk ll lm b">run_filter</code>定义如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="26fb" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">你可以发现真正的过滤逻辑在<code class="fe lj lk ll lm b">sk_run_filter</code>里面:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5278" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">和我们提到的一样，<code class="fe lj lk ll lm b">sk_run_filter</code>只是一个包的布尔值函数。它维护累加器、变址寄存器等。作为局部变量。并且在<code class="fe lj lk ll lm b">for</code>循环中处理BPF滤波器指令阵列。每条指令都将更新局部变量的值。这样，它就模拟了一个虚拟CPU。很有趣，对吧？</p><h2 id="fe70" class="ml jo iq bd jp nf ng dn jt nh ni dp jx kw nj nk kb la nl nm kf le nn no kj np bi translated">BPF JIT</h2><p id="3ef0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">由于每个网络数据包都必须经过过滤功能，这就成为了整个系统的性能瓶颈。</p><p id="5384" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">在<strong class="kn ir"> 2011 </strong>内核中引入了一个<code class="fe lj lk ll lm b">just-in-time (JIT)</code>编译器来加速BPF字节码的执行。</p><ul class=""><li id="3255" class="mq mr iq kn b ko ln ks lo kw ms la mt le mu li mv mw mx my bi translated">什么是<code class="fe lj lk ll lm b">JIT</code>编译器？一个<code class="fe lj lk ll lm b">JIT</code>编译器在程序启动后运行<strong class="kn ir">，将代码(通常是字节码或某种类型的VM指令)动态(或及时)编译成一种通常更快的形式，通常是主机CPU的本机指令集。这与在</strong>程序首次运行之前将所有代码编译成机器语言<strong class="kn ir">的<code class="fe lj lk ll lm b">traditional compiler</code>形成对比。</strong></li></ul><p id="82b2" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">在<code class="fe lj lk ll lm b">BPF</code>案例中，<code class="fe lj lk ll lm b">JIT</code>编译器将BPF字节码直接翻译成主机系统的汇编代码，这可以极大地优化性能。我不会在本文中展示关于JIT的细节。可以参考<a class="ae ls" href="https://elixir.bootlin.com/linux/v3.19.8/source/arch/arm/net/bpf_jit_32.c#L868" rel="noopener ugc nofollow" target="_blank">内核代码</a>。</p><h1 id="5cf1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">把BPF放进嗅探器</h1><p id="d7ce" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来，让我们将BPF添加到我们的数据包嗅探器。正如我们上面在应用级提到的，BPF指令应该使用字节码格式，数据结构如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="84ac" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">我们如何将BPF汇编语言转换成字节码？有两种解决方案。首先，有一个叫做<code class="fe lj lk ll lm b">bpf_asm</code>的小助手工具(随Linux内核一起提供)，你可以把它看作是BPF汇编语言解释器。但不推荐给应用开发者。</p><p id="1630" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">其次，我们可以使用<code class="fe lj lk ll lm b">tcpdump</code>，它提供了转换功能。您可以从tcpdump手册页中找到以下信息:</p><ul class=""><li id="85d4" class="mq mr iq kn b ko ln ks lo kw ms la mt le mu li mv mw mx my bi translated">-d:以人类可读的形式将编译后的数据包匹配代码转储到标准输出并停止。</li><li id="6250" class="mq mr iq kn b ko mz ks na kw nb la nc le nd li mv mw mx my bi translated">-dd:将数据包匹配代码作为C程序片段转储。</li><li id="3631" class="mq mr iq kn b ko mz ks na kw nb la nc le nd li mv mw mx my bi translated">-ddd:将数据包匹配代码作为十进制数转储(前面有一个计数)。</li></ul><p id="e0bf" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated"><code class="fe lj lk ll lm b">tcpdump ip</code>意味着我们要捕获所有的IP数据包。使用选项<strong class="kn ir"> -d </strong>、<strong class="kn ir"> -dd </strong>和<strong class="kn ir"> -ddd </strong>，输出如下:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2f26" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">选项<strong class="kn ir"> -d </strong>用汇编语言打印BPF指令(与上面所示的BPF程序示例相同)。选项<strong class="kn ir"> -dd </strong>将字节码打印为C程序片段。<strong class="kn ir">所以当你想获得BPF字节码</strong>时，tcpdump是最方便的工具。</p><p id="bb67" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">BPF过滤器字节码(包装在结构<code class="fe lj lk ll lm b">sock_fprog</code>中)可以通过<code class="fe lj lk ll lm b">setsockopt</code>系统调用传递给内核，如下所示:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="24f4" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated"><code class="fe lj lk ll lm b">setsockopt</code>系统调用触发两个内核函数:<code class="fe lj lk ll lm b">sock_setsockopt</code>和<code class="fe lj lk ll lm b">sk_attach_filter</code>(这两个函数的细节我就不展示了)，这两个函数的<strong class="kn ir">将过滤器绑定到套接字</strong>。并且在<code class="fe lj lk ll lm b">run_filter</code>内核函数中(如上所述)，它可以<strong class="kn ir">从socket </strong>中获取过滤器，<strong class="kn ir">对数据包</strong>执行过滤器。</p><p id="0788" class="pw-post-body-paragraph kl km iq kn b ko ln kq kr ks lo ku kv kw lp ky kz la lq lc ld le lr lg lh li ij bi translated">到目前为止，每一块都是连在一起的。BPF之谜被解开了。<code class="fe lj lk ll lm b">BPF</code>机器允许用户空间应用程序将定制的BPF程序直接注入内核。一旦加载和验证，BPF程序在内核环境中执行。这些BPF程序在内核内存空间中运行，可以访问所有可用的内核内部状态。比如使用网络包数据的<code class="fe lj lk ll lm b">cBPF</code>机。但是这种能力可以扩展为<code class="fe lj lk ll lm b">eBPF</code>，可以用于许多其他不同的应用。正如有人说的那样，eBPF对内核的作用就像Javascript对网站的作用一样:它允许创建各种各样的新应用程序。将来，我打算深入研究eBPF。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5171c6f48894241b2d4e0a281c7f29a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/0*mENf2CZh5BrwXZk5.png"/></div></figure><h1 id="0468" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">处理数据包</h1><p id="8423" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在上一节中，我们检查了内核级的<code class="fe lj lk ll lm b">BPF</code>过滤理论。但是对于我们小小的嗅探器，我们需要做的最后一步是处理网络数据包。</p><ul class=""><li id="5d3d" class="mq mr iq kn b ko ln ks lo kw ms la mt le mu li mv mw mx my bi translated">首先，<code class="fe lj lk ll lm b">recvfrom</code>系统调用从套接字读取包。我们将系统调用放在一个<code class="fe lj lk ll lm b">while</code>循环中，以继续读取传入的包。</li><li id="a06a" class="mq mr iq kn b ko mz ks na kw nb la nc le nd li mv mw mx my bi translated">然后，我们打印数据包中的源和目的地<code class="fe lj lk ll lm b">MAC</code>地址(我们得到的数据包是第2层的原始以太网帧，对吗？).如果这个以太网帧包含的是一个<code class="fe lj lk ll lm b">IP4</code>包，那么我们打印出源地址和目的地<code class="fe lj lk ll lm b">IP</code>地址。要了解更多，可以研究一下各种网络协议的头格式。这里我就不赘述了。</li></ul><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h1 id="9b10" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="c2f8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">本文研究了什么是<code class="fe lj lk ll lm b">PF_PACKET</code> socket，它是如何工作的，以及为什么应用程序可以获得原始的以太网数据包。此外，我们讨论了如何将嗅探器绑定到一个特定的网络接口，以及如何使嗅探器工作在混杂模式下。此外，我们检查如何添加过滤器到我们的嗅探器。首先，我们分析为什么过滤器应该运行在内核空间而不是应用程序空间。然后，在论文的基础上详细讨论了<code class="fe lj lk ll lm b">BPF</code>机的设计与实现。我们回顾了内核源代码，以理解如何实现<code class="fe lj lk ll lm b">BPF</code>虚拟机。我上面提到过，原来的<code class="fe lj lk ll lm b">BPF</code> ( <code class="fe lj lk ll lm b">cBPF</code>)扩展到现在的<code class="fe lj lk ll lm b">eBPF</code>。但是对BPF虚拟机的了解对<code class="fe lj lk ll lm b">eBPF</code>也很有帮助。</p></div></div>    
</body>
</html>