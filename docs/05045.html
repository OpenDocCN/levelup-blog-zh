<html>
<head>
<title>‘Composite’ Pattern in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的“复合”模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/composite-pattern-in-swift-8c7b932fc157?source=collection_archive---------9-----------------------#2020-07-31">https://levelup.gitconnected.com/composite-pattern-in-swift-8c7b932fc157?source=collection_archive---------9-----------------------#2020-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2258189d0a0bb3bd31a0c395c4a18d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDIfJCUX0jj9nnIri8sgEQ.jpeg"/></div></div></figure><h1 id="b6bd" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">定义</h1><p id="e27f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">“复合”模式<strong class="lb iu"> </strong>是一种结构设计模式，对于将类和对象组成一个更大的系统很有用。</p><p id="798d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">“复合”模式定义了一个统一处理对象结构的接口。结构是包含单个对象和对象组合的树的形式。</strong></p><h1 id="c7da" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">我们什么时候应该使用这种模式？</h1><h2 id="8d52" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">通过统一的界面组合多个对象</h2><p id="40d2" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当我们有一个统一处理的对象集合时，应该使用这种模式。客户端不知道它处理的对象的类型，这意味着所有的对象都应该符合相同的接口。它使客户端代码变得简单，因为对象的类型对客户端变得透明。</p><h2 id="ece6" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">将一组物体视为一个整体</h2><p id="fdef" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当我们有一个具有层次关系的对象集合时，应该使用这种模式。对象的集合形成了具有层次结构的树状结构。该结构包含树叶(单个对象)和复合物(对象的组合)。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/b96dfc1ff763109a730e6db2b1bb3f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*K6CxMek_Os8J1ZAjSCYT7Q.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">来自设计模式的图像——可重用面向对象软件的元素</figcaption></figure><p id="226c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在这种结构中，复合对象从其子对象执行操作。这意味着叶子对象定义行为，复合对象将工作委托给它们的子对象。最后，客户机认为它与一个对象通信，尽管在接口后面我们可以有多个对象。</p><h2 id="ade9" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">将对象知识与客户端分离</h2><p id="cc8a" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当客户端知道它使用的对象类型时，应该使用这种模式。通过共享一个接口，对象不需要被单独处理，这就消除了应用程序的复杂性。客户端不需要检查它是否在正确的对象上调用了正确的方法:它在整个对象结构上调用相同的方法。“复合”模式为客户机收集和管理对象，客户机可以与结构中的任何对象一起工作，没有任何耦合。</p><h1 id="d5fe" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">我们应该如何使用这种模式？</h1><p id="5c27" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">客户端通过接口(<strong class="lb iu">组件</strong>)与一组对象进行通信，该接口表示由叶子和组合执行的操作。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/ba1f182bf4540eee4e3b3d35499ce30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yB1vWsGOpK7KSy3pyqcOg.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">来自设计模式的图像——可重用面向对象软件的元素</figcaption></figure><h2 id="0f10" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">具体例子</h2><p id="2d50" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">假设我们有一个移动应用程序，可以根据互联网连接远程或本地加载数据。这是反映上述结构的UML图。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div class="gh gi my"><img src="../Images/3050afb65498debcb9f26f644ca7a252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*d_EImbU_QcHwSv61HgBgDg.jpeg"/></div></figure><p id="f9bf" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们可以使用任何叶对象(LocalLoader或RemoteLoader)为我们的应用程序加载数据。如果我们用一个糟糕的互联网连接发出一个远程请求，我们希望通过加载本地数据来预测任何失败的请求。我们创建一个复合对象(CompositeFallbackLoader ),以便在远程数据加载失败时提供一个后备。</p><h1 id="9a6f" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">履行</h1><pre class="mp mq mr ms gt mz na nb nc aw nd bi"><span id="9def" class="mc kc it na b gy ne nf l ng nh"><strong class="na iu">protocol</strong> LoadData {<br/>    <strong class="na iu">func</strong> load(completion: <strong class="na iu">@escaping</strong> (Result&lt;Data, Error&gt;) -&gt; Void)<br/>}</span></pre><p id="1e32" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在我们的示例中，我们没有定义Add和Remove方法，因为我们希望通过在构造函数中注入单独的对象来保持复合对象不变。我们也不使用getChild方法，因为我们没有使用它。遵循<em class="ni">接口分离原则，我们不实现我们的对象不需要的方法。</em></p><p id="c505" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果您的用例需要这些方法，我们可以抛出异常作为我们方法的默认实现，以便强制我们实现它们。叶子和复合物扮演不同的角色，所以如果我们不编写对对象没有意义的默认实现，那就更有意义了。然而，如果共享接口包含对两种类型对象的操作，我们就失去了安全性，因为对象可能会对某些方法做一些无意义的事情(例如，Add方法在叶子中没有意义)。将职责划分到接口中是一个设计决策。这将使设计安全，因为我们不会调用无意义的方法。然而，我们会失去透明性，因为客户端需要知道它与之通信的对象的类型。根据您的需求，在透明度和安全性之间找到合适的平衡点。</p><h2 id="80cb" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">叶对象</h2><pre class="mp mq mr ms gt mz na nb nc aw nd bi"><span id="660a" class="mc kc it na b gy ne nf l ng nh"><strong class="na iu">class</strong> LoadRemoteData: LoadData {<br/>    <strong class="na iu">func</strong> load(completion: <strong class="na iu">@escaping</strong> (Result&lt;Data, Error&gt;) -&gt; Void) {<br/>        completion(.failure(NSError(domain: "any error", code: 0)))<br/>    }<br/>}</span><span id="1e2d" class="mc kc it na b gy nj nf l ng nh"><strong class="na iu">class</strong> LoadLocalData: LoadData {<br/>    <strong class="na iu">func</strong> load(completion: <strong class="na iu">@escaping</strong> (Result&lt;Data, Error&gt;) -&gt; Void) {<br/>        completion(.success("'my local data'".data(using: .utf8)!))<br/>    }<br/>}</span></pre><p id="76d9" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">每个对象都符合LoadData接口。在这个例子中，我们假装一个远程请求失败和一个成功的本地数据检索来展示复合对象的使用。</p><h2 id="5360" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">复合物体</h2><pre class="mp mq mr ms gt mz na nb nc aw nd bi"><span id="f450" class="mc kc it na b gy ne nf l ng nh"><strong class="na iu">class</strong> CompositeFallbackLoader: LoadData {<br/>    <strong class="na iu">let</strong> remote: LoadData<br/>    <strong class="na iu">let</strong> local: LoadData</span><span id="db7e" class="mc kc it na b gy nj nf l ng nh"><strong class="na iu">    init</strong>(remote: LoadData, local: LoadData) {<br/>        <strong class="na iu">self</strong>.remote = remote<br/>        <strong class="na iu">self</strong>.local = local<br/>    }</span><span id="a687" class="mc kc it na b gy nj nf l ng nh"><strong class="na iu">    func</strong> load(completion: <strong class="na iu">@escaping</strong> (Result&lt;Data, Error&gt;) -&gt; Void) {<br/>        remote.load(completion: { [<strong class="na iu">weak</strong> <strong class="na iu">self</strong>] result <strong class="na iu">in<br/>            switch</strong> result {<br/>            <strong class="na iu">case</strong> .success:<br/>                print("fetch \(result) remotely")<br/>            <strong class="na iu">case</strong> .failure:<br/>                <strong class="na iu">self</strong>?.retrieveLocalData()<br/>            }<br/>        })<br/>    }</span><span id="8ac1" class="mc kc it na b gy nj nf l ng nh"><strong class="na iu">    private func</strong> retrieveLocalData() {<br/>        local.load(completion: { localResult <strong class="na iu">in<br/>            switch</strong> localResult {<br/>            <strong class="na iu">case</strong> <strong class="na iu">let</strong> .success(data):<br/>                let myData = String(data: data, encoding: .utf8)!<br/>                print("fetch \(myData) locally")<br/>            <strong class="na iu">case</strong> <strong class="na iu">let</strong> .failure(error):<br/>                print(error)<br/>            }<br/>        })<br/>    }<br/>}</span></pre><p id="7b7d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">复合对象符合LoadData接口。它实现了一种回退机制，因此当远程请求失败时，可以在本地检索数据。</p><h1 id="8ee1" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">在操场上运行代码</h1><p id="78cd" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这里有一个<a class="ae nk" href="http://online.swiftplayground.run/" rel="noopener ugc nofollow" target="_blank">在线Swift游乐场</a>，所以不必创建Xcode游乐场来测试“复合”模式的实现。然后，复制下面的代码，该代码与我们的移动应用程序的“复合”模式的完整实现相对应，显示了失败的远程请求以及对本地数据的回退。</p><pre class="mp mq mr ms gt mz na nb nc aw nd bi"><span id="9f85" class="mc kc it na b gy ne nf l ng nh"><strong class="na iu">import</strong> Foundation</span><span id="2e27" class="mc kc it na b gy nj nf l ng nh"><strong class="na iu">protocol</strong> LoadData {<br/>    <strong class="na iu">func</strong> load(completion: <strong class="na iu">@escaping</strong> (Result&lt;Data, Error&gt;) -&gt; Void)<br/>}</span><span id="d9c0" class="mc kc it na b gy nj nf l ng nh"><strong class="na iu">class</strong> LoadRemoteData: LoadData {<br/>    <strong class="na iu">func</strong> load(completion: <strong class="na iu">@escaping</strong> (Result&lt;Data, Error&gt;) -&gt; Void) {<br/>        completion(.failure(NSError(domain: "any error", code: 0)))<br/>    }<br/>}</span><span id="86a8" class="mc kc it na b gy nj nf l ng nh"><strong class="na iu">class</strong> LoadLocalData: LoadData {<br/>    <strong class="na iu">func</strong> load(completion: <strong class="na iu">@escaping</strong> (Result&lt;Data, Error&gt;) -&gt; Void) {<br/>        completion(.success("'my local data'".data(using: .utf8)!))<br/>    }<br/>}</span><span id="eee8" class="mc kc it na b gy nj nf l ng nh"><strong class="na iu">class</strong> CompositeFallbackLoader: LoadData {<br/>    <strong class="na iu">let</strong> remote: LoadData<br/>    <strong class="na iu">let</strong> local: LoadData</span><span id="7efd" class="mc kc it na b gy nj nf l ng nh"><strong class="na iu">    init</strong>(remote: LoadData, local: LoadData) {<br/>        <strong class="na iu">self</strong>.remote = remote<br/>        <strong class="na iu">self</strong>.local = local<br/>    }</span><span id="3b28" class="mc kc it na b gy nj nf l ng nh"><strong class="na iu">    func</strong> load(completion: <strong class="na iu">@escaping</strong> (Result&lt;Data, Error&gt;) -&gt; Void) {<br/>        remote.load(completion: { [<strong class="na iu">weak</strong> <strong class="na iu">self</strong>] result <strong class="na iu">in<br/>            switch</strong> result {<br/>            <strong class="na iu">case</strong> .success:<br/>                print("fetch \(result) remotely")<br/>            <strong class="na iu">case</strong> .failure:<br/>                <strong class="na iu">self</strong>?.retrieveLocalData()<br/>            }<br/>        })<br/>    }</span><span id="a2de" class="mc kc it na b gy nj nf l ng nh"><strong class="na iu">    private func</strong> retrieveLocalData() {<br/>        local.load(completion: { localResult <strong class="na iu">in<br/>            switch</strong> localResult {<br/>            <strong class="na iu">case</strong> <strong class="na iu">let</strong> .success(data):<br/>                let myData = String(data: data, encoding: .utf8)!<br/>                print("fetch \(myData) locally")<br/>            <strong class="na iu">case</strong> <strong class="na iu">let</strong> .failure(error):<br/>                print(error)<br/>            }<br/>        })<br/>    }<br/>}</span><span id="ef8d" class="mc kc it na b gy nj nf l ng nh">// Client<br/><strong class="na iu">let</strong> composite = CompositeFallbackLoader(<br/>    remote: LoadRemoteData(), <br/>    local: LoadLocalData()<br/>)</span><span id="8054" class="mc kc it na b gy nj nf l ng nh">composite.load(completion: { result <strong class="na iu">in<br/>    switch</strong> result {<br/>    <strong class="na iu">case</strong> <strong class="na iu">let</strong> .success(data):<br/>        print(data)<br/>    <strong class="na iu">case</strong> <strong class="na iu">let</strong> .failure(error):<br/>        print(error)<br/>    }<br/>})</span></pre><p id="ffdf" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">最后，粘贴并运行代码。</p></div></div>    
</body>
</html>