<html>
<head>
<title>JavaScript Best Practices — Classes and Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—类和模块</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-classes-and-modules-9c11c8c84ae0?source=collection_archive---------3-----------------------#2020-05-23">https://levelup.gitconnected.com/javascript-best-practices-classes-and-modules-9c11c8c84ae0?source=collection_archive---------3-----------------------#2020-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5d8dbb145d39ce5f827fe1173a571458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_7q0Uf2GIiCZV5KT"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> David Clode </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2e15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="2038" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将看看在我们的类方法中应该有什么，以及使用模块的最佳方式。</p><h1 id="c3e3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">类方法应该要么引用它，要么成为静态方法</h1><p id="ccc6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript类可以有静态或实例方法。如果是实例<code class="fe mh mi mj mk b">method</code>，那么应该引用<code class="fe mh mi mj mk b">this</code>。否则，它应该是一个静态方法。</p><p id="b219" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们应该编写一个类似以下代码的类:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e290" class="mt lf it mk b gy mu mv l mw mx">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="3ea3" class="mt lf it mk b gy my mv l mw mx">  static greet() {<br/>    return 'hi'<br/>  }</span><span id="55e6" class="mt lf it mk b gy my mv l mw mx">  greetWithName() {<br/>    return `hi ${this.name}`;<br/>  }<br/>}</span></pre><p id="6b59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有不引用<code class="fe mh mi mj mk b">this</code>的静态<code class="fe mh mi mj mk b">greet</code>方法和引用<code class="fe mh mi mj mk b">this.name</code>的<code class="fe mh mi mj mk b">greetWithName</code>方法。</p><p id="3d06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">静态方法与类的所有实例共享，实例方法是实例的一部分，所以它引用<code class="fe mh mi mj mk b">this</code>是有意义的。</p><h1 id="a85c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在非标准模块系统上使用ES6模块导入和导出</h1><p id="70c4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在ES6中，模块是JavaScript的标准特性。我们可以将我们的代码划分成模块，只导出我们想对外公开的代码。</p><p id="a6ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以有选择地从另一个模块导入成员。</p><p id="398d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在ES6之前，有各种各样的模块系统，如RequireJS和CommonJS。它们类似于今天的ES6模块。然而，ES6模块可以做它们所做的，它们是一个JavaScript标准。</p><p id="b7f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该只使用ES6模块而不使用其他类型的模块，这样我们就不必担心这些类型的模块会消失或者与其他类型的模块系统的兼容性问题。</p><p id="27c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不用编写以下代码来导出和导入模块:</p><p id="d166" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">module.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4055" class="mt lf it mk b gy mu mv l mw mx">module.exports = {<br/>  foo: 1<br/>};</span></pre><p id="8775" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">index.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="462c" class="mt lf it mk b gy mu mv l mw mx">const { foo } = require("./module");<br/>console.log(foo);</span></pre><p id="f015" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><p id="0a11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">module.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="54c2" class="mt lf it mk b gy mu mv l mw mx">export const foo = 1;</span></pre><p id="eaa9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">index.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="700c" class="mt lf it mk b gy mu mv l mw mx">import { foo } from "./module";<br/>console.log(foo);</span></pre><p id="1558" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第一个例子中，我们使用<code class="fe mh mi mj mk b">module.exports</code>将成员导出为对象的属性。</p><p id="bae8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用<code class="fe mh mi mj mk b">require</code>函数导入了<code class="fe mh mi mj mk b">foo</code>属性。这是CommonJS模块的老方法，在JavaScript将模块作为标准特性之前使用。</p><p id="bd52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个例子使用标准的JavaScript模块做同样的事情。我们在<code class="fe mh mi mj mk b">module.js</code>中导出成员<code class="fe mh mi mj mk b">foo</code>，然后在<code class="fe mh mi mj mk b">index.js</code>中导入<code class="fe mh mi mj mk b">foo</code>。</p><p id="ef30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript模块已经成为标准很长时间了，从版本12开始，浏览器和Node.js都支持它，我们可以在任何地方使用常规的JavaScript模块。</p><p id="7a92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有，我们可以使用Browserify、Webpack或package这样的transpilers将模块代码转换成ES5代码。</p><h1 id="8187" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用通配符导入</h1><p id="87fe" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">通配符导入导入所有内容。它用星号表示。</p><p id="f5bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们通过编写以下代码进行通配符导入:</p><p id="f789" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">module.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="878e" class="mt lf it mk b gy mu mv l mw mx">export const foo = 1;</span></pre><p id="2cea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">index.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="84c2" class="mt lf it mk b gy mu mv l mw mx">import * as module from "./module";<br/>console.log(module.foo);</span></pre><p id="e49a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们通过使用<code class="fe mh mi mj mk b">*</code>和<code class="fe mh mi mj mk b">as</code>关键字命名我们导入的模块来导入整个<code class="fe mh mi mj mk b">module.js</code>模块，以便我们可以在下面的行中引用它。</p><p id="a552" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这并不好，因为我们通常不需要一个模块的所有成员，所以导入所有的东西是没有效率的。</p><p id="393c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该只导入我们需要的成员。我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2e57" class="mt lf it mk b gy mu mv l mw mx">import { foo } from "./module";<br/>console.log(foo);</span></pre><p id="6734" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只导入我们需要的<code class="fe mh mi mj mk b">foo</code>成员。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/d6e511923573a6a5a1e74dfbd3d3a84a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e0Z3GN8BEqg7Sir7"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丘特尔snap </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="207a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要直接从导入导出</h1><p id="ec65" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该从进口直接出口。这意味着我们不应该使用<code class="fe mh mi mj mk b">as</code>关键字直接在导出中将导出重命名为其他名称。</p><p id="6ca8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">把他们和自己的线分开更清楚。例如，我们可以编写以下代码来实现这一点:</p><p id="fa51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">module.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a311" class="mt lf it mk b gy mu mv l mw mx">export const foo = 1;</span></pre><p id="4d85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">bar.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ab1b" class="mt lf it mk b gy mu mv l mw mx">export { foo as bar } from "./module";</span></pre><p id="044c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">index.js</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4c94" class="mt lf it mk b gy mu mv l mw mx">import { bar } from "./bar";<br/>console.log(bar);</span></pre><p id="0b44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们通过使用<code class="fe mh mi mj mk b">export</code>语句将<code class="fe mh mi mj mk b">module.js</code>中的<code class="fe mh mi mj mk b">foo</code>成员导出为<code class="fe mh mi mj mk b">bar</code>。</p><p id="5287" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不应该这样做，因为不清楚我们是否同时从<code class="fe mh mi mj mk b">module.js</code>导入并作为<code class="fe mh mi mj mk b">bar</code>导出成员。</p><p id="716c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该在<code class="fe mh mi mj mk b">bar.js</code>中写下以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e2ea" class="mt lf it mk b gy mu mv l mw mx">import { foo } from "./module";<br/>export { foo as bar } from "./module";</span></pre><p id="e04a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，很明显我们在一个模块中导入和导出。</p><h1 id="6ca3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="c41f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果是实例方法，类方法应该引用<code class="fe mh mi mj mk b">this</code>，否则应该是静态的。</p><p id="2da9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该使用ES6模块，因为它是一个JavaScript标准。此外，我们应该将导入和导出分开，不应该从一个模块中导入所有内容。</p></div></div>    
</body>
</html>