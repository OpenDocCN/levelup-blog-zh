<html>
<head>
<title>What could go wrong? How to handle errors in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么会出错？如何处理角度误差</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-could-go-wrong-how-to-handle-errors-in-angular-6089b0c785e0?source=collection_archive---------3-----------------------#2019-07-01">https://levelup.gitconnected.com/what-could-go-wrong-how-to-handle-errors-in-angular-6089b0c785e0?source=collection_archive---------3-----------------------#2019-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ed330b21f7be2aaaa1405c5f28768672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*halKNwr1sVIhAswQQQrY-g.png"/></div></div></figure><p id="149e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大约一年前，我在一个项目上实现了第一个e2e测试。这是一个相当大的应用程序，在后端使用JAVA SpringBoot，在前端使用Angular。我们使用量角器作为测试工具，它使用硒。在前端代码中有一个服务，它有一个错误处理方法。调用该方法时，会弹出一个模态对话框，用户可以看到错误的详细信息和堆栈跟踪。</p><p id="1053" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是，虽然它跟踪了后端发生的每一个错误，但前端却默默无闻地失败了。<em class="kw"> TypeErrors </em>、<em class="kw"> ReferenceErrors </em>和其他未捕获的异常仅记录到控制台。当e2e测试运行期间出现问题时，测试步骤失败时拍摄的屏幕截图完全没有显示任何内容。祝调试愉快！</p><p id="44b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是Angular有一个内置的处理错误的方法，并且非常容易使用。我们只需要创建我们自己的服务，它实现Angular的<code class="fe kx ky kz la b">ErrorHandler</code>接口:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="3323" class="lj lk iq la b gy ll lm l ln lo">import { ErrorHandler, Injectable } from '<a class="ae lp" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';</span><span id="6729" class="lj lk iq la b gy lq lm l ln lo"><a class="ae lp" href="http://twitter.com/Injectable" rel="noopener ugc nofollow" target="_blank">@Injectable</a>({<br/>    providedIn: 'root'<br/>})<br/>export class ErrorHandlerService implements ErrorHandler{<br/>    constructor() {}</span><span id="7652" class="lj lk iq la b gy lq lm l ln lo">handleError(error: any) {<br/>        // Implement your own way of handling errors<br/>    }<br/>}</span></pre><p id="7362" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然我们可以很容易地在我们的<code class="fe kx ky kz la b">AppModule</code>中提供我们的服务，但是在一个单独的模块中提供这个服务可能是一个好主意。这样，我们可以创建自己的库，并在未来的项目中使用它:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="c99f" class="lj lk iq la b gy ll lm l ln lo">// ERROR HANDLER MODULE<br/>import {ErrorHandler, ModuleWithProviders, NgModule} from '@angular/core';<br/>import {ErrorHandlerComponent} from './components/error-handler.component';<br/>import {FullscreenOverlayContainer, OverlayContainer, OverlayModule} from '@angular/cdk/overlay';<br/>import {ErrorHandlerService} from './error-handler.service';<br/>import {A11yModule} from '@angular/cdk/a11y';</span><span id="90c5" class="lj lk iq la b gy lq lm l ln lo">@NgModule({<br/>  declarations: [ErrorHandlerComponent],<br/>  imports: [CommonModule, OverlayModule, A11yModule],<br/>  entryComponents: [ErrorHandlerComponent]<br/>})<br/>export class ErrorHandlerModule {<br/>  public static forRoot(): ModuleWithProviders {<br/>    return {<br/>      ngModule: ErrorHandlerModule,<br/>      providers: [<br/>        {provide: ErrorHandler, useClass: ErrorHandlerService},<br/>        {provide: OverlayContainer, useClass: FullscreenOverlayContainer},<br/>      ]<br/>    };<br/>  }<br/>}</span></pre><p id="4840" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用了<em class="kw"> Angular CLI </em>来生成<code class="fe kx ky kz la b">ErrorHandlerModule</code>，所以我们已经生成了一个组件，它可以作为我们的模态对话框的内容。为了让我们能够把它放在一个有角度的CDK覆盖图中，它需要是一个<code class="fe kx ky kz la b">entryComponent</code>。这就是为什么我们把它放到了<code class="fe kx ky kz la b">ErrorHandlerModule</code>的entryComponents数组中。</p><p id="228e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还增加了一些进口货。<code class="fe kx ky kz la b">OverlayModule</code>和<code class="fe kx ky kz la b">A11yModule</code>来自CDK模块。当我们的错误对话框打开时，需要它们来创建我们的覆盖图和捕捉焦点。如您所见，我们使用<code class="fe kx ky kz la b">FullscreenOverlayContainer</code>类提供了<code class="fe kx ky kz la b">OverlayContainer</code>，因为如果发生错误，我们希望将用户的交互限制在我们的错误模式内。如果我们没有全屏背景，用户可能会与应用程序进行交互，并导致进一步的错误。让我们将新创建的模块添加到我们的<code class="fe kx ky kz la b">AppModule</code>中:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="e897" class="lj lk iq la b gy ll lm l ln lo">// APP MODULE<br/>import {BrowserModule} from '@angular/platform-browser';<br/>import {NgModule} from '@angular/core';</span><span id="bf05" class="lj lk iq la b gy lq lm l ln lo">import {AppRoutingModule} from './app-routing.module';<br/>import {AppComponent} from './app.component';<br/>import {MainComponent} from './main/main.component';<br/>import {ErrorHandlerModule} from '@btapai/ng-error-handler';<br/>import {HttpClientModule} from '@angular/common/http';</span><span id="9fcd" class="lj lk iq la b gy lq lm l ln lo">@NgModule({<br/>  declarations: [ AppComponent, MainComponent ],<br/>  imports: [<br/>    BrowserModule,<br/>    HttpClientModule,<br/>    ErrorHandlerModule.forRoot(),<br/>    AppRoutingModule,<br/>  ],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule {<br/>}</span></pre><p id="f248" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经有了我们的<code class="fe kx ky kz la b">ErrorHandlerService</code>,我们可以开始实现逻辑了。我们将创建一个模态对话框，以一种清晰易读的方式显示错误。这个对话框将有一个覆盖/背景，它将在角度CDK的帮助下被动态放置到DOM中。让我们安装它:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="25a3" class="lj lk iq la b gy ll lm l ln lo">npm install @angular/cdk --save</span></pre><p id="ffc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据<a class="ae lp" href="https://material.angular.io/cdk/overlay/overview" rel="noopener ugc nofollow" target="_blank">文档</a>，<em class="kw">叠加</em>组件需要一些预建的css文件。现在，如果我们在我们的项目中使用棱角分明的材料，那就没有必要了，但情况并非总是如此。让我们在<em class="kw"> styles.css </em>文件中导入覆盖css。注意，如果你已经在你的应用程序中使用了角度材质，你不需要导入这个css。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="d351" class="lj lk iq la b gy ll lm l ln lo">@import '~@angular/cdk/overlay-prebuilt.css';</span></pre><p id="a7ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们使用我们的<em class="kw"> handleError </em>方法来创建我们的模态对话框。重要的是要知道，<code class="fe kx ky kz la b">ErrorHandler</code>服务是Angular的应用程序初始化阶段的一部分。为了避免令人讨厌的<a class="ae lp" href="https://stackoverflow.com/a/39767492" rel="noopener ugc nofollow" target="_blank">循环依赖错误</a>，我们使用注入器作为它唯一的构造函数参数。当实际的方法被调用时，我们使用Angular的依赖注入系统。让我们从CDK导入覆盖图，并将我们的<code class="fe kx ky kz la b">ErrorHandlerComponent</code>附加到DOM中:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="1ca0" class="lj lk iq la b gy ll lm l ln lo">// ... imports</span><span id="3e69" class="lj lk iq la b gy lq lm l ln lo">@Injectable({<br/>   providedIn: 'root'<br/>})<br/>export class ErrorHandlerService implements ErrorHandler {<br/>   constructor(private injector: Injector) {}</span><span id="d706" class="lj lk iq la b gy lq lm l ln lo">   handleError(error: any) {<br/>       const overlay: Overlay = this.injector.get(Overlay);<br/>       const overlayRef: OverlayRef = overlay.create();<br/>       const ErrorHandlerPortal: ComponentPortal&lt;ErrorHandlerComponent&gt; = new ComponentPortal(ErrorHandlerComponent);<br/>       const compRef: ComponentRef&lt;ErrorHandlerComponent&gt; = overlayRef.attach(ErrorHandlerPortal);<br/>   }<br/>}</span></pre><p id="a0f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把注意力转向我们的错误处理程序模型。一个非常简单的解决方案是显示错误消息和堆栈跟踪。让我们也在底部添加一个“解散”按钮。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="423e" class="lj lk iq la b gy ll lm l ln lo">// imports<br/>export const ERROR_INJECTOR_TOKEN: InjectionToken&lt;any&gt; = new InjectionToken('ErrorInjectorToken');</span><span id="cfbc" class="lj lk iq la b gy lq lm l ln lo">@Component({<br/>  selector: 'btp-error-handler',<br/>  // TODO: template will be implemented later<br/>  template: `${error.message}&lt;br&gt;&lt;button (click)="dismiss()"&gt;DISMISS&lt;/button&gt;`<br/>  styleUrls: ['./error-handler.component.css'],<br/>})<br/>export class ErrorHandlerComponent {<br/>  private isVisible = new Subject();<br/>  dismiss$: Observable&lt;{}&gt; = this.isVisible.asObservable();</span><span id="1891" class="lj lk iq la b gy lq lm l ln lo">  constructor(@Inject(ERROR_INJECTOR_TOKEN) public error) {<br/>  }</span><span id="850b" class="lj lk iq la b gy lq lm l ln lo">  dismiss() {<br/>    this.isVisible.next();<br/>    this.isVisible.complete();<br/>  }<br/>}</span></pre><p id="8e66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，组件本身非常简单。我们将在模板中使用两个相当重要的指令，以使对话框可访问。第一个是<code class="fe kx ky kz la b">cdkTrapFocus</code>,它会在对话框呈现时捕获焦点。这意味着用户不能聚焦模式对话框后面的元素。第二个指令是<code class="fe kx ky kz la b">cdkTrapFocusAutoCapture</code>，它将自动聚焦焦点陷阱中的第一个可聚焦元素。此外，当对话框关闭时，它会自动将焦点恢复到先前聚焦的元素。</p><p id="de1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了能够显示错误的属性，我们需要使用构造函数注入它。为此，我们需要自己的<code class="fe kx ky kz la b">injectionToken</code>。我们还创建了一个相当简单的逻辑，使用subject和<code class="fe kx ky kz la b"><em class="kw">dismiss$</em></code>属性发出一个解散事件。让我们将它与服务中的<code class="fe kx ky kz la b">handleError</code>方法连接起来，并做一些重构。</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="243e" class="lj lk iq la b gy ll lm l ln lo">// imports<br/>export const DEFAULT_OVERLAY_CONFIG: OverlayConfig = {<br/>  hasBackdrop: true,<br/>};</span><span id="6a69" class="lj lk iq la b gy lq lm l ln lo">@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class ErrorHandlerService implements ErrorHandler {</span><span id="7f07" class="lj lk iq la b gy lq lm l ln lo">  private overlay: Overlay;</span><span id="06ec" class="lj lk iq la b gy lq lm l ln lo">  constructor(private injector: Injector) {<br/>    this.overlay = this.injector.get(Overlay);<br/>  }</span><span id="88cf" class="lj lk iq la b gy lq lm l ln lo">  handleError(error: any): void {<br/>    const overlayRef = this.overlay.create(DEFAULT_OVERLAY_CONFIG);<br/>    this.attachPortal(overlayRef, error).subscribe(() =&gt; {<br/>      overlayRef.dispose();<br/>    });<br/>  }</span><span id="5b55" class="lj lk iq la b gy lq lm l ln lo">  private attachPortal(overlayRef: OverlayRef, error: any): Observable&lt;{}&gt; {<br/>    const ErrorHandlerPortal: ComponentPortal&lt;ErrorHandlerComponent&gt; = new ComponentPortal(<br/>      ErrorHandlerComponent,<br/>      null,<br/>      this.createInjector(error)<br/>    );<br/>    const compRef: ComponentRef&lt;ErrorHandlerComponent&gt; = overlayRef.attach(ErrorHandlerPortal);<br/>    return compRef.instance.dismiss$;<br/>  }</span><span id="3538" class="lj lk iq la b gy lq lm l ln lo">  private createInjector(error: any): PortalInjector {<br/>    const injectorTokens = new WeakMap&lt;any, any&gt;([<br/>      [ERROR_INJECTOR_TOKEN, error]<br/>    ]);</span><span id="64af" class="lj lk iq la b gy lq lm l ln lo">    return new PortalInjector(this.injector, injectorTokens);<br/>  }<br/>}</span></pre><p id="ae24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先关注作为注入参数提供的误差。如您所见，<code class="fe kx ky kz la b">ComponentPortal</code>类需要一个必备参数，即组件本身。第二个参数是一个<code class="fe kx ky kz la b">ViewContainerRef</code>，它将影响组件在组件树中的逻辑位置。第三个参数是我们的<code class="fe kx ky kz la b">createInejctor</code>方法。如您所见，它返回了一个新的<code class="fe kx ky kz la b">PortalInjector</code>实例。让我们快速看一下它的底层实现:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="3a03" class="lj lk iq la b gy ll lm l ln lo">export class PortalInjector implements Injector {<br/> constructor(<br/>   private _parentInjector: Injector,<br/>   private _customTokens: WeakMap&lt;any, any&gt;) { }</span><span id="971f" class="lj lk iq la b gy lq lm l ln lo"> get(token: any, notFoundValue?: any): any {<br/>   const value = this._customTokens.get(token);</span><span id="db5f" class="lj lk iq la b gy lq lm l ln lo">   if (typeof value !== 'undefined') {<br/>     return value;<br/>   }</span><span id="b60e" class="lj lk iq la b gy lq lm l ln lo">   return this._parentInjector.get&lt;any&gt;(token, notFoundValue);<br/> }<br/>}</span></pre><p id="e7ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，它期望一个<em class="kw">注入器</em>作为第一个参数，以及一个定制令牌的WeakMap。我们正是使用与我们的错误本身相关的<code class="fe kx ky kz la b"><em class="kw">ERROR_INJECTOR_TOKEN</em></code>做到了这一点。创建的<em class="kw"> PortalInjector </em>用于正确实例化我们的<code class="fe kx ky kz la b">ErrorHandlerComponent</code>，它将确保错误本身会出现在组件中。</p><p id="9827" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们的<code class="fe kx ky kz la b">attachPortal</code>方法返回最近实例化的组件的<code class="fe kx ky kz la b">dismiss$</code> <em class="kw"> </em>属性。我们订阅它，当它改变时，我们调用我们的<code class="fe kx ky kz la b">overlayRef</code>上的<code class="fe kx ky kz la b"><em class="kw">.dispose()</em></code>。我们的错误模式对话框被关闭。请注意，我们还在组件内调用了我们主题的complete，因此，我们不需要取消订阅。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><p id="f7eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，这对于clinet端代码出现问题时抛出的错误非常有用。但是我们正在创建web应用程序，并且使用API端点。那么当REST端点返回一个错误时会发生什么呢？</p><p id="5e6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以处理自己服务中的每个错误，但是我们真的想这样做吗？如果一切正常，就不会抛出错误。如果有特定的需求，例如用一个飞行的独角兽来处理<a class="ae lp" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/418" rel="noopener ugc nofollow" target="_blank"> 418状态码</a> <em class="kw"> </em>，你可以在它的服务中实现它的处理程序。但是，当我们面对相当常见的错误时，比如404或503，我们可能希望在同一个错误对话框中显示这些错误。</p><p id="f987" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们快速收集一下当抛出一个<code class="fe kx ky kz la b">HttpErrorResponse</code>时会发生什么。它将异步发生，所以我们可能会面临一些变更检测问题。这种错误类型与简单错误具有不同的属性，因此，我们可能需要一个杀毒方法。现在让我们通过为<code class="fe kx ky kz la b">SanitisedError</code>创建一个相当简单的接口来深入了解它:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="659d" class="lj lk iq la b gy ll lm l ln lo">export interface SanitizedError {<br/>  message: string;<br/>  details: string[];<br/>}</span></pre><p id="a180" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们为我们的<code class="fe kx ky kz la b">ErrorHandlerComponent</code>创建一个模板:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="0d93" class="lj lk iq la b gy ll lm l ln lo">// Imports</span><span id="e714" class="lj lk iq la b gy lq lm l ln lo">@Component({<br/>  selector: 'btp-error-handler',<br/>  template: `<br/>    &lt;section cdkTrapFocus [cdkTrapFocusAutoCapture]="true" class="btp-error-handler__container"&gt;<br/>      &lt;h2&gt;Error&lt;/h2&gt;<br/>      &lt;p&gt;{{error.message}}&lt;/p&gt;<br/>      &lt;div class="btp-error-handler__scrollable"&gt;<br/>        &lt;ng-container *ngFor="let detail of error.details"&gt;<br/>          &lt;div&gt;{{detail}}&lt;/div&gt;<br/>        &lt;/ng-container&gt;<br/>      &lt;/div&gt;<br/>      &lt;button class="btp-error-handler__dismiss button red" (click)="dismiss()"&gt;DISMISS&lt;/button&gt;<br/>    &lt;/section&gt;`,<br/>  styleUrls: ['./error-handler.component.css'],<br/>})<br/>export class ErrorHandlerComponent implements OnInit {<br/> // ...<br/>}</span></pre><p id="951a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将整个模态打包到一个<code class="fe kx ky kz la b"><em class="kw">&lt;section&gt;</em></code>中，并在其中添加了<code class="fe kx ky kz la b">cdkTrapFocus</code>指令。这个指令将阻止用户在我们的overlay/modal后面的DOM中导航。<code class="fe kx ky kz la b">[cdkTrapFocusAutoCapture]="true"</code>确保解散按钮被立即聚焦。当模式关闭时，先前获得焦点的元素将重新获得焦点。我们使用<code class="fe kx ky kz la b"><em class="kw">*ngFor</em></code>简单地显示错误消息和细节。让我们跳回我们的<code class="fe kx ky kz la b">ErrorHandlerService</code>:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="258d" class="lj lk iq la b gy ll lm l ln lo">// Imports</span><span id="68b2" class="lj lk iq la b gy lq lm l ln lo">@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class ErrorHandlerService implements ErrorHandler {<br/>  // Constructor</span><span id="1d9c" class="lj lk iq la b gy lq lm l ln lo">  handleError(error: any): void {<br/>    const sanitised = this.sanitiseError(error);<br/>    const ngZone = this.injector.get(NgZone);<br/>    const overlayRef = this.overlay.create(DEFAULT_OVERLAY_CONFIG);</span><span id="00fe" class="lj lk iq la b gy lq lm l ln lo">    ngZone.run(() =&gt; {<br/>      this.attachPortal(overlayRef, sanitised).subscribe(() =&gt; {<br/>        overlayRef.dispose();<br/>      });<br/>    });<br/>  }<br/>  <br/>  // ...</span><span id="aa01" class="lj lk iq la b gy lq lm l ln lo">  private sanitiseError(error: Error | HttpErrorResponse): SanitizedError {<br/>    const sanitisedError: SanitizedError = {<br/>      message: error.message,<br/>      details: []<br/>    };<br/>    if (error instanceof Error) {<br/>      sanitisedError.details.push(error.stack);<br/>    } else if (error instanceof HttpErrorResponse) {<br/>      sanitisedError.details = Object.keys(error)<br/>        .map((key: string) =&gt; `${key}: ${error[key]}`);<br/>    } else {<br/>      sanitisedError.details.push(JSON.stringify(error));<br/>    }<br/>    return sanitisedError;<br/>  }<br/>  // ...<br/>}</span></pre><p id="eda1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过一个相当简单的<code class="fe kx ky kz la b">sanitiseError</code>方法，我们创建了一个基于我们之前定义的接口的对象。我们检查错误类型并相应地填充数据。更有趣的部分是使用注射器得到<code class="fe kx ky kz la b">ngZone</code>。当错误异步发生时，它通常发生在变更检测之外。我们用<code class="fe kx ky kz la b"><em class="kw">ngZone.run(/* … */)</em>,</code>包装我们的<code class="fe kx ky kz la b">attachPortal</code>，这样当一个<code class="fe kx ky kz la b">HttpErrorResponse</code>被捕获时，它在我们的模态中被正确地呈现。</p><p id="a044" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然当前状态运行良好，但仍然缺乏定制。我们使用来自CDK模块的覆盖，因此为定制配置公开一个注入令牌会很好。这个模块的另一个重要缺点是，当这个模块被使用时，另一个模块不能用于错误处理。例如，集成Sentry需要您实现一个类似的轻量级<code class="fe kx ky kz la b">ErrorHandler</code>模块。为了能够使用这两者，我们应该在错误处理程序中实现使用钩子的可能性。首先，让我们创建我们的<code class="fe kx ky kz la b">InjectionToken</code>和默认配置:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="9a2c" class="lj lk iq la b gy ll lm l ln lo">import {InjectionToken} from '@angular/core';<br/>import {DEFAULT_OVERLAY_CONFIG} from './constants/error-handler.constants';<br/>import {ErrorHandlerConfig} from './interfaces/error-handler.interfaces';</span><span id="4fe8" class="lj lk iq la b gy lq lm l ln lo">export const DEFAULT_ERROR_HANDLER_CONFIG: ErrorHandlerConfig = {<br/>  overlayConfig: DEFAULT_OVERLAY_CONFIG,<br/>  errorHandlerHooks: []<br/>};</span><span id="a729" class="lj lk iq la b gy lq lm l ln lo">export const ERROR_HANDLER_CONFIG: InjectionToken&lt;ErrorHandlerConfig&gt; = new InjectionToken('btp-eh-conf');</span></pre><p id="3470" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后使用我们现有的<code class="fe kx ky kz la b">forRoot</code>方法，用我们的模块提供它:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="2e1a" class="lj lk iq la b gy ll lm l ln lo">@NgModule({<br/>  declarations: [ErrorHandlerComponent],<br/>  imports: [CommonModule, OverlayModule, A11yModule],<br/>  entryComponents: [ErrorHandlerComponent]<br/>})<br/>export class ErrorHandlerModule {</span><span id="a843" class="lj lk iq la b gy lq lm l ln lo">  public static forRoot(): ModuleWithProviders {<br/>    return {<br/>      ngModule: ErrorHandlerModule,<br/>      providers: [<br/>        {provide: ErrorHandler, useClass: ErrorHandlerService},<br/>        {provide: OverlayContainer, useClass: FullscreenOverlayContainer},<br/>        {provide: ERROR_HANDLER_CONFIG, useValue: DEFAULT_ERROR_HANDLER_CONFIG}<br/>      ]<br/>    };<br/>  }<br/>}</span></pre><p id="499b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后将这种配置处理也集成到我们的<code class="fe kx ky kz la b">ErrorHandlerService</code>中:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="7c82" class="lj lk iq la b gy ll lm l ln lo">// Imports<br/>@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class ErrorHandlerService implements ErrorHandler {<br/>  // ...</span><span id="a20b" class="lj lk iq la b gy lq lm l ln lo">  handleError(error: any): void {<br/>    const sanitised = this.sanitiseError(error);<br/>    const {overlayConfig, errorHandlerHooks} = this.injector.get(ERROR_HANDLER_CONFIG);<br/>    const ngZone = this.injector.get(NgZone);</span><span id="0bcf" class="lj lk iq la b gy lq lm l ln lo">    this.runHooks(errorHandlerHooks, error);<br/>    const overlayRef = this.createOverlayReference(overlayConfig);<br/>    ngZone.run(() =&gt; {<br/>      this.attachPortal(overlayRef, sanitised).subscribe(() =&gt; {<br/>        overlayRef.dispose();<br/>      });<br/>    });<br/>  }<br/>  // ...<br/>  private runHooks(errorHandlerHooks: Array&lt;(error: any) =&gt; void&gt; = [], error): void {<br/>    errorHandlerHooks.forEach((hook) =&gt; hook(error));<br/>  }</span><span id="2ad0" class="lj lk iq la b gy lq lm l ln lo">  private createOverlayReference(overlayConfig: OverlayConfig): OverlayRef {<br/>    const overlaySettings: OverlayConfig = {...DEFAULT_OVERLAY_CONFIG, ...overlayConfig};<br/>    return this.overlay.create(overlaySettings);<br/>  }<br/>  // ...<br/>}</span></pre><p id="ad72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们差不多准备好了。让我们将第三方错误处理程序挂钩集成到我们的应用程序中:</p><pre class="lb lc ld le gt lf la lg lh aw li bi"><span id="54bf" class="lj lk iq la b gy ll lm l ln lo">// Imports<br/>const CustomErrorHandlerConfig: ErrorHandlerConfig = {<br/>  errorHandlerHooks: [<br/>    ThirdPartyErrorLogger.logErrorMessage,<br/>    LoadingIndicatorControl.stopLoadingIndicator,<br/>  ]<br/>};</span><span id="94d2" class="lj lk iq la b gy lq lm l ln lo">@NgModule({<br/>  declarations: [<br/>    AppComponent,<br/>    MainComponent<br/>  ],<br/>  imports: [<br/>    BrowserModule,<br/>    HttpClientModule,<br/>    ErrorHandlerModule.forRoot(),<br/>    AppRoutingModule,<br/>  ],<br/>  providers: [<br/>    {provide: ERROR_HANDLER_CONFIG, useValue: CustomErrorHandlerConfig}<br/>  ],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule {<br/>}</span></pre><p id="004a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您所看到的，处理错误是软件开发中极其重要的一部分，但也很有趣。</p><p id="92bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非常感谢你阅读这篇博文。如果你喜欢阅读代码，请查看我的<a class="ae lp" href="https://github.com/TapaiBalazs/angular-reusables" rel="noopener ugc nofollow" target="_blank"> ng-reusables git库</a>。您也可以使用这个<a class="ae lp" href="https://www.npmjs.com/package/@btapai/ng-error-handler" rel="noopener ugc nofollow" target="_blank"> npm包</a>来尝试实现。</p><p id="90d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以在<a class="ae lp" href="https://twitter.com/TapaiBalazs" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或者<a class="ae lp" href="https://github.com/TapaiBalazs" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我。</p></div></div>    
</body>
</html>