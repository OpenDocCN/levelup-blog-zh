<html>
<head>
<title>12 More Tips for Improving your Weak Ass React Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">12个改善你脆弱的代码的技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/12-more-tips-for-improving-your-weak-ass-react-code-be88d0547f21?source=collection_archive---------5-----------------------#2022-08-18">https://levelup.gitconnected.com/12-more-tips-for-improving-your-weak-ass-react-code-be88d0547f21?source=collection_archive---------5-----------------------#2022-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="26ef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第二部分:这些需要一点努力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f7e926afde4a5ff69d9608f143aac783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6b0G121roJLkU_V2"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">雷内·文森特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的第一部分反响很好，所以我决定再写一篇。根据2021年堆栈溢出调查<a class="ae ky" href="https://insights.stackoverflow.com/survey/2021#section-most-popular-technologies-web-frameworks" rel="noopener ugc nofollow" target="_blank">，React.js (40.14%)最近才超过jQuery (34.42%)成为最常用的web框架。反应技能是目前就业市场上最受欢迎的技能之一。能够优化React应用程序是专业开发人员与众不同的一部分。</a></p><p id="7443" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一部分的结论中，我提到了一些东西，比如使用内容分发网络(CDN)、缓存、线框化、树抖动和减少包的大小。我们将在本文中讨论如何做这些事情，以及一些我以前没有想到的优化技巧。</p><h1 id="7e57" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设计</h1><h2 id="bc8a" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">1.首先对响应布局进行线框化</h2><p id="0a7e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果你曾经在React中开始过一个实践项目，你可能会遇到这样的问题，甚至是从哪里开始演示。当然，你可以在JSX盲目地创建视图，然后再填充样式</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/c84131fae652e7311f0580a88930c20c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LmkevmwXhq0fF8Al.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">CSS中的调试</figcaption></figure><p id="ea8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的方法是先从线框开始。线框本质上是任何网站的蓝图。从这些宝贝开始，你会发现更容易坚持下去。Figma to React 是React应用程序线框化的最流行的集成之一。您可以将React组件的设计创建为<a class="ae ky" href="https://www.figma.com" rel="noopener ugc nofollow" target="_blank"> Figma </a>节点，然后将该节点包装在<a class="ae ky" href="https://www.figma.com/blog/introducing-figma-to-react/#gadgets-reusable-code-blobs-that-stick-to-designs" rel="noopener ugc nofollow" target="_blank">小工具包装器</a>中。例如，如果你想设计一个<code class="fe nf ng nh ni b">Button</code>组件，你可以在Figma中将其命名为<code class="fe nf ng nh ni b">#Button</code>。它将触发该节点成为“Gadgetized”；创建一个名为<code class="fe nf ng nh ni b">CButton.js</code>的文件，您可以使用业务逻辑对其进行修改。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="f1fa" class="lv lw it bd lx ly nq ma mb mc nr me mf jz ns ka mh kc nt kd mj kf nu kg ml mm bi translated">编码</h1><h2 id="dfb4" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">2.JS代码优化</h2><p id="fe74" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在学习React.js之前先了解JavaScript是必须的。在理解语言之前一头扎进框架不仅会导致效率低下，而且最糟糕的是，这会给你自己带来更多的工作。所以帮你自己一个忙，不要以为你知道JS，只是因为你知道React。有许多JS设计考虑可以使你的React代码更加<a class="ae ky" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干燥</a>和健壮，但是我在这里将集中于我的前三个:</p><p id="50b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2.1面向对象(OO)模式</strong></p><p id="d55b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能令人震惊，但是OO模式并不是React.js特有的，它们甚至也不是JavaScript特有的。虽然类语法在ES6中只是作为面向对象编程的语法糖出现的，但对于90后的开发人员来说，它仍然是有用的知识。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/1dc88f4ae112311a6486ea7937442949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KGiB0fC6ohBH9W6yQFg-gg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由Initech 提供</figcaption></figure><p id="e6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nw"> 2.1.1工厂方法模式</em></p><p id="28e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以移动电话数据结构为例，它可以是iPhone或Android:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="b1b9" class="mn lw it ni b gy ob oc l od oe">class PhoneFactory {<br/>  static newIPhone(version) {<br/>    return new Phone('iPhone', 'Apple', version);<br/>  }<br/>  static newAndroid(model, manufacturer, version) {<br/>    return new Phone(model, manufacturer, version);<br/>  }<br/>}</span><span id="366b" class="mn lw it ni b gy of oc l od oe">class Phone {<br/>  constructor(model, manufacturer, version) {<br/>    this.model = model;<br/>    this.manufacturer = manufacturer;<br/>    this.version = version;<br/>  }<br/>  static get factory() {<br/>    return new PhoneFactory();<br/>  }<br/>}</span><span id="c795" class="mn lw it ni b gy of oc l od oe">let phone = PhoneFactory.newIPhone('12');<br/>let phoneTwo = PhoneFactory.newAndroid('Galaxy','Samsung','S22');</span><span id="8d32" class="mn lw it ni b gy of oc l od oe">console.log({ phone, phoneTwo });</span><span id="7737" class="mn lw it ni b gy of oc l od oe"><em class="nw">{<br/>  phone: Phone { model: 'iPhone', manufacturer: 'Apple', version: '12' },</em></span><span id="5f22" class="mn lw it ni b gy of oc l od oe"><em class="nw">  phoneTwo: Phone { model: 'Galaxy', manufacturer: 'Samsung', version: 'S22' }<br/>}</em></span></pre><p id="62b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它通过决定创建对象的接口并让子类决定实例化哪个类来内在化抽象。</p><p id="9072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nw"> 2.1.2构建器模式</em></p><p id="5280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我经常使用构建器来组织应用程序中的重复代码。以交货订单为例:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="6ec9" class="mn lw it ni b gy ob oc l od oe">import { v4 as uuid } from 'uuid';<br/><br/>class Order {<br/>  constructor() {<br/>    this.id = uuid();<br/>    this.addressOne = '';<br/>    this.addressTwo = '';<br/>    this.city = '';<br/>    this.state = '';<br/>    this.zipCode = 0; <br/>    this.driver = '';<br/>    this.restaurant = '';<br/>    this.amount = 0;<br/>  }<br/><br/>  toString() {<br/>    return `<br/>      Order number ${this.id} being delivered to:<br/>      ${this.addressOne}${this.addressTwo ? ', ' + this.addressTwo + ', ' : ''}<br/>      ${this.city}, ${this.state} ${this.zipCode}<br/>      <br/>      By ${this.driver}<br/>      from ${this.restaurant} for $${this.amount}<br/>    `;<br/>  }<br/>}</span></pre><p id="3285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过添加构建器来分离大量所需的参数:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="8d8a" class="mn lw it ni b gy ob oc l od oe">class OrderBuilder {<br/>  constructor(order = new Order()) {<br/>    this.order = order;<br/>  }<br/><br/>  get deliveryAddress() {<br/>    return new OrderAddressBuilder(this.order);<br/>  }<br/><br/>  get fulfilledBy() {<br/>    return new OrderFulfilledByBuilder(this.order);<br/>  }<br/><br/>  build() {<br/>    return this.order;<br/>  }<br/>}<br/><br/>class OrderAddressBuilder extends OrderBuilder {<br/>  constructor(order) {<br/>    super(order);<br/>  }<br/><br/>  at({ addressOne, addressTwo }) {<br/>    this.order.addressOne = addressOne;<br/>    this.order.addressTwo = addressTwo;<br/>    return this;<br/>  }<br/><br/>  in({ city, state }) {<br/>    this.order.city = city;<br/>    this.order.state = state;<br/>    return this;<br/>  }<br/><br/>  withZipCode(zipCode) {<br/>    this.order.zipCode = zipCode; <br/>    return this;<br/>  }<br/>}<br/><br/>class OrderFulfilledByBuilder extends OrderBuilder {<br/>  constructor(order) {<br/>    super(order);<br/>  }<br/><br/>  from(restaurant) {<br/>    this.order.restaurant = restaurant;<br/>    return this;<br/>  }<br/><br/>  for(amount) {<br/>    this.order.amount = amount;<br/>    return this;<br/>  }<br/><br/>  by(driver) {<br/>    this.order.driver = driver;<br/>    return this;<br/>  }<br/>}</span></pre><p id="1a61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样使用它们:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="653c" class="mn lw it ni b gy ob oc l od oe">const builder = new OrderBuilder();<br/><br/>const order = builder.deliveryAddress<br/>  .at({ addressOne: '123 Main St' })<br/>  .in({ city: 'Flavortown', state: 'USA' })<br/>  .withZipCode(1234)<br/>  .fulfilledBy<br/>  .by('Alfredo Jr')<br/>  .from('Pizza by Alfredo')<br/>  .for(12.50)<br/>  .build()<br/><br/>console.log(order.toString());</span><span id="30c1" class="mn lw it ni b gy of oc l od oe"><em class="nw">Order number c39233-e85b36-ed5230-c9844 being delivered to:</em></span><span id="2659" class="mn lw it ni b gy of oc l od oe"><em class="nw">      123 Main St<br/>      Flavortown, USA 1234 <br/>      <br/>      By Alfredo Jr<br/>      from Pizza by Alfredo for $12.50</em></span></pre><p id="c204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于更多的面向对象设计模式，我强烈推荐Ravi Sojitra的这篇文章。</p><p id="e326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2.2函数式编程(FP)模式</strong></p><p id="2fac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript的美妙之处在于它是一种多范式语言，可以适应面向对象和浮点模式。一旦你对它稍加练习，函数式编程并不太难掌握。有一些面向对象的经验也会有所帮助，因为FP中函数的使用方式和面向对象中对象的使用方式是一样的。FP鼓励编写没有副作用的纯函数(没有局部静态变量、非局部变量、可变引用参数或输入/输出流的变异)。纯函数使用的唯一变量是传递给它的参数。纯函数唯一能调用的其他函数是其他纯函数。最后，如果函数返回值，它总是一个全新的变量。正如我用OO举例说明的，这里有两个我最喜欢的FP概念:</p><p id="9082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nw"> 2.2.1功能组成</em></p><p id="6139" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数组合是减少按钮和输入处理程序数量的好方法。以这个片段为例:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="e355" class="mn lw it ni b gy ob oc l od oe">const Snippet = () =&gt; {<br/><br/>  <strong class="ni iu">const handleButtonOneClick = (e) =&gt; alert("One!");<br/>  const handleButtonTwoClick = (e) =&gt; alert("Two!");</strong><br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;button type="button" onClick={<strong class="ni iu">handleButtonOneClick</strong>}&gt;<br/>        One<br/>      &lt;/button&gt;<br/>      &lt;button type="button" onClick={<strong class="ni iu">handleButtonTwoClick</strong>}&gt;<br/>        Two<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="df4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们想要创建一个按钮时，我们都必须创建一个处理程序。像这样浪费的会议，难怪地球被污染了。如果我们不必关心标签是什么，那不是很好吗？</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="1e7e" class="mn lw it ni b gy ob oc l od oe">const Snippet = ({ labels }) =&gt; {</span><span id="7804" class="mn lw it ni b gy of oc l od oe">  <strong class="ni iu">const handleClick = (label) =&gt; (e) =&gt; alert(`${label}!`);</strong></span><span id="cce7" class="mn lw it ni b gy of oc l od oe">  return (<br/>    &lt;div&gt;<br/>      {labels.map((label) =&gt; (<br/>        &lt;button type="button" onClick={<strong class="ni iu">handleClick(label)</strong>}&gt;<br/>          {label}<br/>        &lt;/button&gt;<br/>      ))}<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>const App = () =&gt; (<br/>  &lt;div&gt;<br/>    &lt;Snippet labels={['One', 'Two', 'Whatever']} /&gt;<br/>  &lt;/div&gt;<br/>);</span></pre><p id="3e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到我们在那里做了什么吗？向<code class="fe nf ng nh ni b">onClick</code>按钮属性提供了返回事件处理程序的<code class="fe nf ng nh ni b">handleClick(label)</code>的输出。通过组合点击处理程序，我们使组件更灵活、更高效，就像水电站大坝一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/64b979c93e379991073d08da3858e9ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qK-iTtncxJ1lO3H_"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@tejjj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tejj </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="5e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.2.2不变性</p><p id="5769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让变量引用一个不变的值，强制养成好习惯。我们确保我们有我们应该有的值，当我们需要改变那个值时，我们创建一个新的变量来引用我们的新值。这适用于JavaScript中的所有数据类型:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="81ac" class="mn lw it ni b gy ob oc l od oe">'use strict';<br/><br/>const str = 'String';<br/>const num = 1;</span><span id="61b6" class="mn lw it ni b gy of oc l od oe">str = 1; // NOT possible<br/>num = 'String'; // also NOT possible</span><span id="f27e" class="mn lw it ni b gy of oc l od oe">// With let<br/>let obj1 = { foo: 'bar' };<br/><br/>// you can mutate the object<br/>o1.foo = 'something different';<br/><br/>// or reassign it completely<br/>o1 = { message: "I'm a completely new object" };</span><span id="e39b" class="mn lw it ni b gy of oc l od oe">// With const<br/>const obj2 = { foo: 'bar' };<br/><br/>// you can mutate the object<br/>obj2.foo = 'something different';<br/><br/>// Can NOT reassign it completely<br/>obj2 = { message: 'Not possible' }; // ERROR!</span><span id="3bab" class="mn lw it ni b gy of oc l od oe">// With let and Object.freeze<br/>let obj3 = Object.freeze({ foo: 'bar' });</span><span id="fbb0" class="mn lw it ni b gy of oc l od oe">// Can NOT mutate the object<br/>obj3.foo = 'something different'; // ERROR!<br/><br/>// But CAN reassign it completely<br/>obj3 = { message: 'Totally possible' };</span></pre><p id="c80b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在React中，你在核心API中到处都能看到不变性，例如在<code class="fe nf ng nh ni b">useState</code>:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="abf7" class="mn lw it ni b gy ob oc l od oe">const MyComponent = () =&gt; {<br/>  const [value, setValue] = useState(0);<br/><br/>  const addNewValue = (toAdd) =&gt; {<br/>    const newValue = value + toAdd;<br/>    setValue(newValue);<br/>  };<br/><br/>  const setNewValue = () =&gt; addNewValue(Math.ceil(Math.random() * 10));<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;p&gt;{value}&lt;/p&gt;<br/>      &lt;button onClick={setNewValue}&gt;Set new value&lt;/button&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="0870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不能只是重新分配<code class="fe nf ng nh ni b">value</code>，我们必须通过<code class="fe nf ng nh ni b">setValue</code>创建一个新的不可变数字。</p><p id="7b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2.3在平面对象{}上使用Map()</strong></p><p id="39dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我总是回到关于StackOverflow的讨论。如果某个东西只写一次，之后会大量阅读，那么就使用对象。在所有其他情况下，<code class="fe nf ng nh ni b">Map</code>更好是因为它:</p><ul class=""><li id="fa00" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated">提供<code class="fe nf ng nh ni b">get</code>、<code class="fe nf ng nh ni b">set</code>、<code class="fe nf ng nh ni b">has</code>和<code class="fe nf ng nh ni b">delete</code>方法。对象依赖于容易出现缺陷的粗糙的定制实现。</li><li id="840a" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">接受任何类型的键，而不仅仅是字符串。例如，当您想要将多个键映射到同一个值时，将一个排序的数组作为键会很方便。</li><li id="0074" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">提供一个迭代器以方便<code class="fe nf ng nh ni b">for-of</code>的使用，并保持结果的顺序。这也是一种普遍理解的标准化访问方法。</li><li id="61e6" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">在迭代或复制过程中，不会出现带有原型和其他属性的边缘案例</li><li id="e0c7" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">考虑时间和空间复杂性时，可扩展性更好</li></ul><h2 id="e919" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">3.实现React.js特定的设计模式</h2><p id="8830" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><strong class="lb iu"> 3.1无状态/有状态组件</strong></p><p id="ad55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您很可能已经听说过无数次这种类型的组件，但这里有一个复习。</p><p id="2365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无状态组件如下所示:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="8e7c" class="mn lw it ni b gy ob oc l od oe">import React from 'react';</span><span id="608b" class="mn lw it ni b gy of oc l od oe">const Stateless = ({ title, description }) =&gt; (<br/>  &lt;div&gt;<br/>    &lt;h1&gt;{title}&lt;/h1&gt;<br/>    &lt;p&gt;{description}&lt;/p&gt;<br/>  &lt;/div&gt;<br/>);</span></pre><p id="432b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有状态组件看起来像这样:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="680d" class="mn lw it ni b gy ob oc l od oe">import React, { useState } from 'react';</span><span id="9dc5" class="mn lw it ni b gy of oc l od oe">const Stateful = (props) =&gt; {</span><span id="288f" class="mn lw it ni b gy of oc l od oe">  const [title, setTitle] = useState('');<br/>  const [description, setDescription] = useState('');</span><span id="d3eb" class="mn lw it ni b gy of oc l od oe">return (<br/>    &lt;div&gt;<br/>      &lt;input<br/>        value={title}<br/>        onChange={({ target: { value }}) =&gt; setTitle(value)}<br/>      /&gt;<br/>      &lt;input<br/>        value={description}<br/>        onChange={({ target: { value }}) =&gt; setDescription(value)}<br/>      /&gt;<br/>      &lt;Stateless title={title} description={description} /&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="4d6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的经验是尽可能使用功能组件(注意这里没有<code class="fe nf ng nh ni b">class</code>语法)和无状态组件。这是因为无状态组件与服务于它们的数据没有紧密耦合，因此与需要内部状态的组件相比，它们更具可重用性。</p><p id="f024" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3.2上下文</strong></p><p id="aaba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为上下文指出的主要用例是，它可以用来避免将一个道具向下传递数百万层。类似地，它可以用于设置数百万级的状态，以避免重复代码。考虑下面的代码，其中我们有3层嵌套组件和一个全屏阻塞模式:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="561a" class="mn lw it ni b gy ob oc l od oe">import React, { useState } from 'react';<br/>import Modal from './Modal';<br/><br/>const GrandParent = () =&gt; {</span><span id="d94f" class="mn lw it ni b gy of oc l od oe">  const [isOpen, setIsOpen] = useState(false);</span><span id="5b1b" class="mn lw it ni b gy of oc l od oe">  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Grand Parent&lt;/h1&gt;<br/>      &lt;button type="button" onClick={() =&gt; setIsOpen(!isOpen)}&gt;<br/>        Open Modal<br/>      &lt;/button&gt;<br/>      {isOpen &amp;&amp; (<br/>        &lt;Modal content="Opened from GrandParent" /&gt;<br/>      )}<br/>      &lt;Parent /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>const Parent = () =&gt; {</span><span id="98e7" class="mn lw it ni b gy of oc l od oe">  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Parent&lt;/h1&gt;<br/>      &lt;Child /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>const Child = () =&gt; {</span><span id="b3a7" class="mn lw it ni b gy of oc l od oe">  const [isOpen, setIsOpen] = useState(false);</span><span id="9eda" class="mn lw it ni b gy of oc l od oe">  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Child&lt;/h1&gt;<br/>      &lt;button type="button" onClick={() =&gt; setIsOpen(!isOpen)}&gt;<br/>        Open Modal<br/>      &lt;/button&gt;<br/>      {isOpen &amp;&amp; (<br/>        &lt;Modal content="Opened from Child" /&gt;<br/>      )}<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="efbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们重复了几段代码，比如<code class="fe nf ng nh ni b">isOpen</code>状态和模态组件。如果我们修改它以使用React上下文API，它看起来会更简洁一些:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="1777" class="mn lw it ni b gy ob oc l od oe">import React, { useState, createContext, useContext } from 'react';<br/>import Modal from './Modal';<br/><br/>const ModalContext = createContext(undefined);<br/><br/>const ModalContextProvider = ModalContext.Provider;<br/><br/>const GreatGrandParent = () =&gt; {</span><span id="3549" class="mn lw it ni b gy of oc l od oe">  const [modalState, setModalState] = useState({<br/>    isOpen: false,<br/>    content: '',<br/>  });</span><span id="06ba" class="mn lw it ni b gy of oc l od oe">  return (<br/>    &lt;ModalContextProvider value={[modalState, setModalState]}&gt;<br/>      &lt;GrandParent /&gt;<br/>    &lt;/ModalContextProvider&gt;<br/>  )<br/>};<br/><br/>const GrandParent = () =&gt; {</span><span id="a012" class="mn lw it ni b gy of oc l od oe">  const [modalState, setModalState] = useContext(ModalContext);</span><span id="7d85" class="mn lw it ni b gy of oc l od oe">  return (<br/>      &lt;div&gt;<br/>        &lt;h1&gt;Grand Parent&lt;/h1&gt;<br/>        &lt;button<br/>          type="button"<br/>          onClick={() =&gt; setModalState({<br/>            isOpen: !modalState.isOpen,<br/>            content: 'Opened from GrandParent',<br/>          })}<br/>        &gt;<br/>          Open Modal<br/>        &lt;/button&gt;<br/>        {modalState.isOpen &amp;&amp; (<br/>          &lt;Modal content={modalState.content} /&gt;<br/>        )}<br/>        &lt;Parent /&gt;<br/>      &lt;/div&gt;<br/>  );<br/>};<br/><br/>const Parent = () =&gt; {</span><span id="7f05" class="mn lw it ni b gy of oc l od oe">  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Parent&lt;/h1&gt;<br/>      &lt;Child /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/><br/>const Child = () =&gt; {</span><span id="e91a" class="mn lw it ni b gy of oc l od oe">  const [modalState, setModalState] = useContext(ModalContext);</span><span id="88e7" class="mn lw it ni b gy of oc l od oe">  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Child&lt;/h1&gt;<br/>      &lt;button<br/>          type="button"<br/>          onClick={() =&gt; setModalState({<br/>            isOpen: !modalState.isOpen,<br/>            content: 'Opened from Child',<br/>          })}<br/>        &gt;<br/>        Open Modal<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="7828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在只有一个模态组件和一个状态来跟踪模态的打开状态和内容。</p><h2 id="b167" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">4.让钩子对你有利</h2><p id="6c5a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在第一部分中，我谈到了一些有用的React钩子，比如useMemo和useCallback。有一些新的钩子作为React团队的“并发模式”特性的一部分刚刚发布，包括:</p><ul class=""><li id="0821" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated"><code class="fe nf ng nh ni b">useTransition</code>:返回转换挂起状态的有状态值，以及启动转换的函数</li><li id="b797" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><code class="fe nf ng nh ni b">startTransition</code>:允许您将提供的回调中的更新标记为转换</li></ul><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="936d" class="mn lw it ni b gy ob oc l od oe">function App() {<br/>  const [isPending, startTransition] = useTransition();<br/>  const [count, setCount] = useState(0);<br/>  <br/>  function handleClick() {<br/>    startTransition(() =&gt; {<br/>      setCount(c =&gt; c + 1);<br/>    })<br/>  }<br/><br/>  return (<br/>    &lt;div&gt;<br/>      {isPending &amp;&amp; &lt;Spinner /&gt;}<br/>      &lt;button onClick={handleClick}&gt;{count}&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><ul class=""><li id="5234" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated"><code class="fe nf ng nh ni b">useDeferredValue</code>:这个钩子类似于使用去抖动或节流来推迟更新。使用<code class="fe nf ng nh ni b">useDeferredValue</code>的好处是React将在其他工作完成后立即进行更新(而不是等待任意长的时间)，并且像<code class="fe nf ng nh ni b"><a class="ae ky" href="https://reactjs.org/docs/react-api.html#starttransition" rel="noopener ugc nofollow" target="_blank">startTransition</a></code>一样，延迟值可以暂停，而不会触发现有内容的意外回退。</li><li id="0a6f" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><code class="fe nf ng nh ni b">useId</code>:是一个钩子，用于生成跨服务器和客户机稳定的惟一id，同时避免水合不匹配。这不再依赖于<code class="fe nf ng nh ni b">uuid</code>包。</li></ul><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="343c" class="mn lw it ni b gy ob oc l od oe">function Checkbox() {<br/>  const id = useId();<br/>  return (<br/>    &lt;&gt;<br/>      &lt;label htmlFor={id}&gt;Do you like React?&lt;/label&gt;<br/>      &lt;input id={id} type="checkbox" name="react"/&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><h2 id="ed69" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">5.优化与后端的通信</h2><p id="c417" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果你使用的是GraphQL API，有一个很好的叫做Relay的库，它可以让你不需要知道如何以及何时进行特定的API调用。用它自己的话说:</p><blockquote class="ov ow ox"><p id="8765" class="kz la nw lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated">Relay是一个JavaScript框架，用于构建数据驱动的React应用程序。</p><p id="4b5f" class="kz la nw lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><strong class="lb iu">声明性:</strong>不再使用命令式API与您的数据存储进行通信。只需使用GraphQL声明您的数据需求，让Relay决定如何以及何时获取您的数据。</p><p id="ea49" class="kz la nw lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><strong class="lb iu">协同定位:</strong>查询位于依赖它们的视图旁边，因此你可以很容易地对你的应用进行推理。Relay将查询聚合成高效的网络请求，以便只获取您需要的内容。</p><p id="10cc" class="kz la nw lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><strong class="lb iu">突变:</strong> Relay允许您使用GraphQL突变来改变客户机和服务器上的数据，并提供自动数据一致性、乐观更新和错误处理。</p></blockquote><p id="b0bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从下面的示例项目开始，或者使用<code class="fe nf ng nh ni b">npm i react-relay</code>将它安装到现有的React应用程序中。</p><div class="pb pc gp gr pd pe"><a href="https://github.com/facebook/relay" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">GitHub——Facebook/Relay:Relay是一个JavaScript框架，用于构建数据驱动的反应…</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">Relay是一个JavaScript框架，用于构建数据驱动的React应用程序。声明:永远不再与…交流</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">github.com</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps ks pe"/></div></div></a></div><p id="8521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个有用的库是用于高效获取数据的<code class="fe nf ng nh ni b">@tanstack/react-query</code>。例如，通过将后续负载转移到后台进程，可以节省对服务器的重复调用的性能。这只是query的众多好处之一。它比自定义的、手写的数据获取挂钩更强大，我用TypeScript和更漂亮的方式把它放在那里——这是一个应该使用的要求，除非有很好的理由不这样做。</p><div class="pb pc gp gr pd pe"><a href="https://tanstack.com/query/v4" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">过渡查询|反应查询、实体查询、细长查询、真空查询</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">不用编写reducers、缓存逻辑、定时器、重试逻辑、复杂的异步/等待脚本(我可以继续下去...)…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">tanstack.com</p></div></div><div class="pn l"><div class="pt l pp pq pr pn ps ks pe"/></div></div></a></div><h2 id="7808" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">6.使用页面速度洞察API测量速度</h2><p id="d429" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Google提供了一个很好的API来记录像第一次内容丰富的绘制、第一次输入延迟、第一次有意义的绘制、第一次CPU空闲等指标。它确实需要设置一个帐户，生成一个API密匙，并稍微修改您的代码以适应测量。然而，这是一个很好的方法，通过结合来自不同地理位置的各种设备上的多个用户的多个指标来确定需要改进的地方。</p><div class="pb pc gp gr pd pe"><a href="https://developers.google.com/speed/docs/insights/v5/get-started" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">开始使用PageSpeed Insights API | Google开发者</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">使用PageSpeed Insights API可以:测量网页的性能。获取关于如何改进页面的建议…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">developers.google.com</p></div></div><div class="pn l"><div class="pu l pp pq pr pn ps ks pe"/></div></div></a></div></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="c493" class="lv lw it bd lx ly nq ma mb mc nr me mf jz ns ka mh kc nt kd mj kf nu kg ml mm bi translated">构建和捆绑</h1><h2 id="6114" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">7.使用生产版本进行构建</h2><p id="2e46" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">npm和create-react-app鲜为人知的特性之一是设置<code class="fe nf ng nh ni b">NODE_ENV</code>环境变量，作为安装依赖项和构建静态文件的一种方式。当您运行<code class="fe nf ng nh ni b">export NODE_ENV=production</code>并执行<code class="fe nf ng nh ni b">npm install</code>和<code class="fe nf ng nh ni b">npm run build</code>时，它将忽略开发依赖项，并生成文件内容的唯一散列唯一散列，以支持长期缓存。它还根据您实现的代码分割技术干净地分离文件。你不必做任何额外的工作，这只是<code class="fe nf ng nh ni b">create-react-app</code>为你做的事情。这很重要的原因是，如果文件内容没有改变，它允许你使用积极的缓存技术来避免浏览器重新下载你的资源。此外，如果您为您的<code class="fe nf ng nh ni b">index.html</code>和静态文件指定了一个<code class="fe nf ng nh ni b">Cache-Control</code>头，CDN将强制执行该指令，并在指定的时间长度内缓存您的静态资产。生成的散列提供了一种执行比较并决定缓存是否需要更新的方法。稍后我们将更多地讨论CDNs。</p><div class="pb pc gp gr pd pe"><a href="https://create-react-app.dev/docs/production-build/" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">创建生产版本|创建React应用程序</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">npm运行构建创建一个包含应用程序生产版本的构建目录。在构建/静态目录中有…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">创建-反应-应用程序.开发</p></div></div><div class="pn l"><div class="pv l pp pq pr pn ps ks pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a href="https://docs.npmjs.com/cli/v8/commands/npm-install#description" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">NPM-安装| npm文档</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">别名:add，I，in，ins，inst，insta，inst，isnt，isnta，isntal，isntall此命令安装软件包和任何…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">docs.npmjs.com</p></div></div><div class="pn l"><div class="pw l pp pq pr pn ps ks pe"/></div></div></a></div><h2 id="d16f" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">8.分析包的大小</h2><p id="1a87" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">React有一个名为<a class="ae ky" href="https://www.npmjs.com/package/source-map-explorer" rel="noopener ugc nofollow" target="_blank"> Source Map Explorer </a>的工具，它使用源码图分析JavaScript包。这有助于您理解代码膨胀的来源。要将源地图浏览器添加到React应用程序中，只需使用NPM安装即可:</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="0efb" class="mn lw it ni b gy ob oc l od oe">npm install --save source-map-explorer</span></pre><p id="53a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后要分析包，运行生产构建，然后运行分析脚本。</p><pre class="kj kk kl km gt nx ni ny nz aw oa bi"><span id="1834" class="mn lw it ni b gy ob oc l od oe">npm run build<br/>npm run analyze</span></pre><p id="3821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他第三方工具对此很有用，但不是专门针对React应用的。Webpack Bundle Analyzer甚至提供了输出文件大小的交互式可视化。</p><div class="pb pc gp gr pd pe"><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">GitHub—web pack-contrib/web pack-bundle-analyzer:web pack插件和CLI实用程序，代表…</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">使用交互式可缩放树状图可视化webpack输出文件的大小。npm安装—保存-开发…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">github.com</p></div></div><div class="pn l"><div class="px l pp pq pr pn ps ks pe"/></div></div></a></div><p id="fa01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bundlesize有一个Github插件，它会根据您指定的规则设置强制执行您的包的最大大小。</p><div class="pb pc gp gr pd pe"><a href="https://github.com/siddharthkp/bundlesize" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">GitHub — siddharthkp/bundlesize:检查包的大小</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">保持您的包大小在检查npm安装bundlesize —保存—开发纱添加bundlesize —开发将其添加到您的脚本在…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">github.com</p></div></div><div class="pn l"><div class="py l pp pq pr pn ps ks pe"/></div></div></a></div><p id="5476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这些工具的好坏取决于您采取的修复代码膨胀的措施。精确定位和减少包的大小需要更多的努力，我可能会在某一天的另一篇文章中介绍。</p><div class="pb pc gp gr pd pe"><a href="https://medium.com/@ipenywis/how-to-reduce-your-webpack-bundle-size-for-web-app-optimization-02-9b7086e30a6d" rel="noopener follow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">如何减少Webpack捆绑包的大小以优化Web应用程序</h2><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">medium.com</p></div></div><div class="pn l"><div class="pz l pp pq pr pn ps ks pe"/></div></div></a></div></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="6e56" class="lv lw it bd lx ly nq ma mb mc nr me mf jz ns ka mh kc nt kd mj kf nu kg ml mm bi translated">主办；主持</h1><h2 id="8aa9" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">9.使用CDN并利用边缘服务器</h2><p id="176a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">内容分发网络有助于拥有全球用户群的高流量网站。利用它的一种方法是将React应用程序的静态资产缓存在离最终用户最近的物理服务器上。它使得从原点到用户设备的行程更快。这种服务器被认为是边缘服务器，它们开始被用于更多的目的，而不仅仅是缓存静态文件。使用React和服务器端渲染(SSR)为这些边缘服务器提供了一个新的用例，以帮助您的网站执行得更好。Next.js等静态站点生成器支持基于文件的页面路由、动态页面路径和边缘数据获取API。将这项工作卸载到边缘服务器上，以提供更快的用户体验。此外，可以利用边缘服务器将HTTP头附加到页面响应中。像<code class="fe nf ng nh ni b">Cache-Control</code>和<code class="fe nf ng nh ni b">Content-Security-Policy</code> (CSP)这样的头可以按地区配置甚至修改。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="9065" class="lv lw it bd lx ly nq ma mb mc nr me mf jz ns ka mh kc nt kd mj kf nu kg ml mm bi translated">监视</h1><h2 id="b557" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">10.使用React工具调试</h2><p id="285c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这一点在大多数React教程中都有提及，但看在过去的份上，我将在这里再提一下。自2015年以来，React已经包含了一套专门用于调试React应用程序的浏览器工具。它可以作为扩展安装在Chrome上，作为附加组件安装在Firefox上，作为附加组件安装在MS Edge上。React工具中有两个面板可以查看:“⚛️组件”和“⚛️分析器”。第一个将显示整个当前组件树。第二个提供了一种方法来记录React应用程序在渲染、响应状态变化和用户交互等时的性能。最重要的是，您可以记录为什么每个组件在分析时被渲染(或重新渲染)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/c5670f9f814655f2de3dc1c327702ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pxJ3vgUeXHMwqVcAeMoRQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">侧写员</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qb"><img src="../Images/7684850b1f1993013f767378f6205fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lJmEpQPIQmSgLQhYyhoDbQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">准备好大吃一惊吧</figcaption></figure><div class="pb pc gp gr pd pe"><a href="https://alexsidorenko.com/blog/react-performance-tools/" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">我的React应用程序很慢，我不知道为什么</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">2021年9月28日React world中有哪些性能测试工具，如何开始使用？你可以…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">alexsidorenko.com</p></div></div><div class="pn l"><div class="qc l pp pq pr pn ps ks pe"/></div></div></a></div><h2 id="5287" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">11.Lighthouse的性能基准测试</h2><p id="9eb6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">谷歌Chrome Lighthouse是目前网站标杆的标准。它附有一张容易理解的成绩单，让人想起你的学生时代。你可能还记得等待你的分数出来的可怕的悬念，这里没有太大的区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/8ed810f8cfd08195d55c794d53619697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UVrL1FX1S_5yxDU2dTDgEw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qe"><img src="../Images/05b0b84626fa6c17a961247fa16b4b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EhLnegH3EuxdvHi21ypV2g.png"/></div></div></figure><p id="5756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您的lighthouse报告运行时，它可以为您提供在SEO、可访问性、最佳实践等方面需要改进的地方。此外，您可以将lighthouse扫描合并到您的CI/CD流程中，以确保代码更改不会导致基准性能随着时间的推移而退化。</p><div class="pb pc gp gr pd pe"><a href="https://github.com/GoogleChrome/lighthouse" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">GitHub——Google chrome/light house:自动化审计、性能指标和最佳实践…</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">Lighthouse分析web应用程序和网页，收集现代性能指标和对开发者最佳的见解…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">github.com</p></div></div><div class="pn l"><div class="qf l pp pq pr pn ps ks pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a href="https://developers.google.com/speed" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">让网络更快|谷歌开发者</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">帮助您构建高性能网站的工具和信息。</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">developers.google.com</p></div></div><div class="pn l"><div class="qg l pp pq pr pn ps ks pe"/></div></div></a></div></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="b469" class="lv lw it bd lx ly nq ma mb mc nr me mf jz ns ka mh kc nt kd mj kf nu kg ml mm bi translated">了解更多信息</h1><h2 id="515f" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">12.跟随牛逼前端</h2><p id="95ef" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Awesome Frontend是Github上的一个web性能优化主题的开源列表，由一群Awesome软件工程师经常更新。有一个专门针对前端主题的回购，值得一试，尤其是“加速你的网站的最佳实践”链接。</p><div class="pb pc gp gr pd pe"><a href="https://github.com/davidsonfellipe/awesome-wpo#readme" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">GitHub-davidsonfellipe/awesome-WPO:Web性能优化的精选列表。每个人都可以…</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">pencil:Web性能优化的精选列表。大家可以在这里投稿！- GitHub …</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">github.com</p></div></div><div class="pn l"><div class="qh l pp pq pr pn ps ks pe"/></div></div></a></div><div class="pb pc gp gr pd pe"><a href="https://developer.yahoo.com/performance/rules.html" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">加速你的网站的最佳实践-雅虎开发者网络</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">卓越性能团队已经确定了许多提高网页速度的最佳实践。该列表包括…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">developer.yahoo.com</p></div></div></div></a></div></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="4c1a" class="lv lw it bd lx ly nq ma mb mc nr me mf jz ns ka mh kc nt kd mj kf nu kg ml mm bi translated">分级编码</h1><p id="e713" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="2015" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="a379" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">📰查看<a class="ae ky" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="add5" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">🔔关注我们:<a class="ae ky" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae ky" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae ky" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="d152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🚀👉<a class="ae ky" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>