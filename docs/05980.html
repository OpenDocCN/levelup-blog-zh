<html>
<head>
<title>Comparing API Architectural Styles: SOAP vs REST vs GraphQL vs RPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较API架构风格:SOAP vs REST vs GraphQL vs RPC</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/comparing-api-architectural-styles-soap-vs-rest-vs-graphql-vs-rpc-84a3720adefa?source=collection_archive---------0-----------------------#2020-10-16">https://levelup.gitconnected.com/comparing-api-architectural-styles-soap-vs-rest-vs-graphql-vs-rpc-84a3720adefa?source=collection_archive---------0-----------------------#2020-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8307ab46b0eb0ba172217a330e5752f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZwL-A9WTss2u3Pti.jpg"/></div></div></figure><p id="ed3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">两个独立的应用程序需要一个中介来相互通信。因此，开发人员经常搭建桥梁——应用程序编程接口——以允许一个系统访问另一个系统的信息或功能。</p><p id="85b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了快速和大规模地集成应用程序，API使用协议和/或规范来定义通过网络传递的消息的语义和语法。这些规范构成了API架构。</p><p id="6a05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着时间的推移，已经发布了不同的API架构风格。它们都有自己的标准化数据交换模式。大量的选择引发了关于哪种建筑风格是最好的无休止的争论。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/8e8f5c361c52ba2c5144e36d55608f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FjEhEvgBVHUPbO2o.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated"><em class="lg"> API风格随时间变化，来源:</em> <a class="ae kw" href="https://twitter.com/robdcrowley?lang=en" rel="noopener ugc nofollow" target="_blank"> <em class="lg">罗布克劳利</em> </a></figcaption></figure><p id="fa92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，许多API消费者将REST称为“<em class="lh">安息</em>”，为GraphQL欢呼，而十年前，REST成为取代SOAP的赢家是一个反向故事。这些观点的问题在于，他们片面地挑选技术本身，而不是考虑它的实际属性和特征如何与手头的情况相匹配。</p><p id="38f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将保持客观，按照出现的顺序讨论四种主要的API风格，比较它们的优缺点，并强调每种风格最适合的场景。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/a35baccc01e2d0e4d51896739807070b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*48GrlLTgVHuOsqRu.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated"><em class="lg">四大API风格对比</em></figcaption></figure><h1 id="cb0f" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">远程过程调用(RPC):调用另一个系统上的函数</h1><p id="918b" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated"><strong class="ka ir">远程过程调用</strong>是一种规范，允许在不同的上下文中远程执行函数。RPC扩展了本地过程调用的概念，但是将它放在HTTP API的上下文中。</p><p id="eee7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最初的XML-RPC是有问题的，因为确保XML有效载荷的数据类型是困难的。因此，后来一个RPC API开始使用一个更具体的JSON-RPC规范，这被认为是SOAP的一个更简单的替代方案。<a class="ae kw" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>是Google在2015年开发的最新RPC版本。gRPC支持负载平衡、跟踪、健康检查和身份验证，非常适合连接微服务。</p><h2 id="613d" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">RPC如何工作</h2><p id="ab9b" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">客户端调用远程过程，将参数和附加信息序列化为消息，并将消息发送到服务器。收到消息后，服务器反序列化其内容，执行请求的操作，并将结果发送回客户端。服务器存根和客户机存根负责参数的序列化和反序列化。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/1caa999370e8a3cfdf9b7767eab1b716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/0*MGMkYwMzzIGG0imi.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated"><em class="lg">远程程序调用机制，来源:</em> <a class="ae kw" href="https://www.guru99.com/remote-procedure-call-rpc.html#1" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> Guru99 </em> </a></figcaption></figure><h2 id="65ae" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">RPC优点</h2><p id="fbcd" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated"><strong class="ka ir">直白简单的交互。RPC使用GET来获取信息，并为其他所有事情发送信息。服务器和客户端之间的交互机制归结为调用端点并获得响应。</strong></p><p id="6e33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">易于添加的功能。如果我们对我们的API有了新的需求，我们可以很容易地添加另一个端点来执行这个需求:1)编写一个新的函数，并把它放在一个端点之后，2)现在客户端可以点击这个端点并获得满足设置需求的信息。</strong></p><p id="4664" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">高性能。</strong>轻量级有效载荷在网络上轻松运行，提供高性能，这对于共享服务器和在工作站网络上执行的并行计算非常重要。RPC能够优化网络层，并使其非常高效，每天在不同的服务之间发送大量消息。</p><h2 id="914f" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">RPC Cons</h2><p id="6117" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated"><strong class="ka ir">与底层系统紧密耦合。</strong>API的抽象级别有助于其可重用性。它与底层系统越紧密，它对其他系统的可重用性就越低。RPC与底层系统的紧密耦合不允许在系统功能和外部API之间有一个抽象层。这引发了安全问题，因为很容易将底层系统的实现细节泄露到API中。RPC的紧密耦合使得可伸缩性需求和松散耦合的团队难以实现。因此，客户端要么担心调用特定端点可能产生的副作用，要么试图找出调用哪个端点，因为它不理解服务器如何命名其函数。</p><p id="e7e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">可发现性低。</strong>在RPC中，无法自省API或发送请求，也无法根据请求理解要调用什么函数。</p><p id="7de6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">功能爆炸。</strong>创建新功能太容易了。因此，我们没有编辑现有的函数，而是创建了新的函数，结果产生了一大串难以理解的重叠函数。</p><h2 id="6d7e" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">RPC用例</h2><p id="0db8" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">RPC模式大约在80年代开始被使用，但是这并没有自动使它过时。像谷歌、脸书(<a class="ae kw" href="https://thrift.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Thrift </a>)和Twitch ( <a class="ae kw" href="https://twitchtv.github.io/twirp/docs/intro.html" rel="noopener ugc nofollow" target="_blank"> Twirp </a>)这样的大公司正在内部使用RPC高性能变量来执行极高性能、低开销的消息传递。他们的海量微服务系统，要求内部通讯在短消息整理的同时要清晰。</p><p id="1931" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">命令API。</strong>RPC是向远程系统发送命令的合适选择。例如，Slack API非常注重命令:加入通道、离开通道、发送消息。因此，Slack API的设计者以类似RPC的风格对其建模，使其小巧、紧凑且易于使用。</p><p id="0477" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">内部微服务的客户专用APIs】。在单个提供者和消费者之间进行直接集成，我们不想像REST API那样花费大量时间通过网络传输大量元数据。gRPC和Twirp具有较高的消息速率和消息性能，是微服务的理想选择。gRPC在幕后使用HTTP 2，能够优化网络层，使其在不同服务之间每天发送大量消息时非常高效。然而，如果你的目标不是高网络性能，而是发布高度独特的微服务的团队之间的稳定API联系，REST将确保这一点。</strong></p><h1 id="9eee" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">简单对象访问协议(SOAP):使数据作为服务可用</h1><p id="7364" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated"><a class="ae kw" href="https://www.altexsoft.com/blog/engineering/what-is-soap-formats-protocols-message-structure-and-how-soap-is-different-from-rest/?utm_source=MediumCom&amp;utm_medium=referral&amp;utm_campaign=shared#soap-use-cases" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> SOAP </strong> </a>是一种XML格式的、高度标准化的web通信协议。微软在XML-RPC一年后发布的SOAP继承了它的很多东西。当REST出现时，它们首先被并行使用，但很快REST赢得了流行度竞赛。</p><h2 id="a5a7" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">肥皂是如何工作的</h2><p id="f25c" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">XML数据格式落后于许多形式。再加上庞大的消息结构，这使得SOAP成为最冗长的API风格。</p><p id="7003" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SOAP消息由以下部分组成:</p><ul class=""><li id="9f3d" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated">开始和结束每封邮件的信封标签，</li><li id="18dc" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">包含请求或响应的正文</li><li id="d6f0" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">如果消息必须确定任何细节或额外要求，则消息头</li><li id="c408" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">一种故障，通知在整个请求处理过程中可能发生的任何错误。</li></ul><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/8c7c10e4ddaa05826b04f2c8a23686c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MOADcAI4Y3hPfsDP.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated"><em class="lg">SOAP消息的一个例子。来源:</em> <a class="ae kw" href="https://www.ibm.com/support/knowledgecenter/en/SSMKHH_10.0.0/com.ibm.etools.mft.doc/ac55780_.htm" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> IBM </em> </a></figcaption></figure><p id="909c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SOAP API逻辑是用Web服务描述语言(WSDL)编写的。这种API描述语言定义了端点，并描述了所有可以执行的过程。这允许不同的编程语言和ide快速建立通信。</p><p id="3b8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SOAP支持有状态和无状态消息传递。在有状态的场景中，服务器存储接收到的信息可能非常多。但是对于涉及多方和复杂交易的操作来说，这是合理的。</p><h2 id="90de" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">肥皂专家</h2><p id="d994" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">与语言和平台无关。创建基于web的服务的内置功能允许SOAP处理通信，并使响应独立于语言和平台。</p><p id="c476" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">绑定多种传输协议。</strong> SOAP在传输协议方面非常灵活，可以适应多种场景。</p><p id="120c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">内置错误处理。</strong> SOAP API规范允许返回带有错误代码及其解释的重试XML消息。</p><p id="23e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">多个安全扩展。</strong>通过与WS-Security协议集成，SOAP满足了企业级的事务质量。它提供了交易内部的私密性和完整性，同时允许在消息级别进行加密。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d9e9881a0455c99918efdcf47da52703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R8dmtvOpZsld72RN.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated"><em class="lg"> SOAP消息级安全:头元素和加密体中的认证数据</em></figcaption></figure><h2 id="8eb8" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">肥皂骗局</h2><p id="d1ec" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">如今，许多开发人员对必须集成SOAP API的想法感到不寒而栗，原因有几个。</p><p id="809d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">仅XML。</strong> SOAP消息包含大量元数据，并且只支持请求和响应的冗长XML结构。</p><p id="73fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">重量级。</strong>由于XML文件很大，SOAP服务需要很大的带宽。</p><p id="1158" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">狭义的专业知识。</strong>构建SOAP API服务器需要深入理解所有相关的协议及其高度受限的规则。</p><p id="0fb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">繁琐的消息更新。</strong>僵化的SOAP模式需要额外的努力来添加或删除消息属性，从而降低了采用速度。</p><h2 id="21bc" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">SOAP用例</h2><p id="969a" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">目前，SOAP架构最常用于企业内部集成或与他们信任的合作伙伴集成。</p><p id="7d1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">高度安全的数据传输。</strong> SOAP严格的结构、安全性和授权能力使其成为在API和客户端之间执行正式软件合同的最合适的选择，同时遵守API提供者和API消费者之间的法律合同。这就是为什么金融组织和其他企业用户选择SOAP的原因。</p><h1 id="4dc3" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">表述性状态转移(REST):使数据作为资源可用</h1><p id="2ae9" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">REST 是一种自解释的API架构风格，由一组架构约束定义，旨在被许多API消费者广泛采用。</p><p id="4807" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天最常见的API风格最初是由Roy Fielding在2000年的博士论文中描述的。REST使服务器端数据可用，用简单的格式表示，通常是JSON和XML。</p><h2 id="5d10" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">休息是如何工作的</h2><p id="f01c" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">REST不像SOAP那样被严格定义。RESTful架构应该遵守六个架构约束:</p><ul class=""><li id="ad8e" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated"><strong class="ka ir">统一接口:</strong>允许以统一的方式与给定的服务器交互，而不管设备或应用程序类型如何</li><li id="f136" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><strong class="ka ir">无状态</strong>:处理请求本身所包含的请求的必要状态，服务器不存储任何与会话相关的内容</li><li id="db41" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><strong class="ka ir">缓存</strong></li><li id="8fe4" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><strong class="ka ir">客户端-服务器架构:</strong>允许任何一方独立发展</li><li id="a35b" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><strong class="ka ir">分层系统</strong>的应用</li><li id="e30a" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">服务器向客户端提供可执行代码的能力</li></ul><p id="e1dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，有些服务只是在一定程度上是RESTful的。它们以RPC风格为核心，将较大的服务分解成资源，并有效地使用HTTP基础设施。但是关键部分是使用超媒体aka HATEOAS，即<a class="ae kw" href="https://en.wikipedia.org/wiki/HATEOAS" rel="noopener ugc nofollow" target="_blank">超文本的缩写，作为应用程序状态的引擎</a>。基本上，这意味着对于每个响应，REST API都提供了元数据，链接到所有关于如何使用API的相关信息。这就是实现客户端和服务器解耦的原因。因此，API提供者和API消费者都可以独立发展，而不会妨碍他们之间的交流。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/a31abfb954322b668aea8a1d9d185a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fjasRE4pFM8mjTEA.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated"><em class="lg"> Richardson成熟度模型作为实现真正完整和有用的API的标杆，来源:</em><a class="ae kw" href="https://nordicapis.com/what-is-the-richardson-maturity-model/" rel="noopener ugc nofollow" target="_blank"><em class="lg">Kristopher Sandoval</em></a></figcaption></figure><p id="99dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“睡眠是休息的一个重要特征。真的是让休息休息。由于大多数人不使用HATEOAS，他们实际上使用HTTP RPC，"这是在<a class="ae kw" href="https://www.reddit.com/r/golang/comments/7qvi0w/twirp_a_sweet_new_rpc_framework_for_go_twitch_blog/dstkrnm/" rel="noopener ugc nofollow" target="_blank"> Reddit </a>上表达的一些激进观点。的确，HATEOAS是REST最成熟的版本。然而，要求比现在通常使用和构建的API客户机更高级和更智能的API客户机是很难实现的。因此，即使今天非常好的REST APIs也不总是这样做。这就是为什么HATEOAS主要是作为RESTful API设计的长期发展的一个愿景。</p><p id="f439" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个服务实现了REST的一些特性和RPC的一些特性时，REST和RPC之间可能真的存在一个灰色地带。REST是基于资源或名词而不是基于动作或动词。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/6087969a6cf480e8db2aa435064a11f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gyxh_zIFA2jU0DG4.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated"><em class="lg">以动词为中心的RPC中的操作与以名词为中心的REST中的操作相反</em></figcaption></figure><p id="6557" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在REST中，事情是使用HTTP方法完成的，比如GET、POST、PUT、DELETE、OPTIONS，希望还有PATCH。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/41adce0344b5dddd7010dd377e96fa88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/0*5-VuvD8xxV0VrNjs.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated"><em class="lg">来源:Thomas Davis </em></figcaption></figure><h2 id="163a" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">休息专家</h2><p id="043e" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated"><strong class="ka ir">分离的客户端和服务器。</strong>REST尽可能地将客户端和服务器解耦，比RPC提供了更好的抽象。具有抽象层次的系统能够封装其细节，以便更好地识别和维护其属性。这使得REST API足够灵活，可以随着时间的推移而发展，同时保持一个稳定的系统。</p><p id="f796" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">可发现性。</strong>客户机和服务器之间的通信描述了一切，因此不需要外部文档来理解如何与REST API交互。</p><p id="39aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缓存友好。REST重用了许多HTTP工具，是唯一允许在HTTP级别缓存数据的样式。相比之下，任何其他API上的缓存实现都需要配置一个额外的缓存模块。</strong></p><p id="ca64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">多种格式支持。</strong>支持多种格式存储和交换数据的能力是REST目前成为构建公共API的主流选择的原因之一。</p><h2 id="90e3" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">其余缺点:</h2><p id="04bf" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated"><strong class="ka ir">没有单一的休息结构。</strong>构建REST API没有确切的正确方法。如何对资源建模以及对哪些资源建模将取决于每个场景。这使得REST在理论上简单，但在实践中很难。</p><p id="08cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">大有效载荷。REST返回了大量丰富的元数据，这样客户端就可以从应用程序的响应中了解应用程序状态的所有必要信息。对于具有大量带宽容量的大型网络管道来说，这种喋喋不休并不是什么大问题。但事实并非总是如此。这是脸书在2012年提出GraphQL风格描述的关键驱动因素。</strong></p><p id="09f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">超量提取和欠量提取问题。REST响应要么包含太多的数据，要么包含的数据不够多，通常会产生对另一个请求的需求。</strong></p><h2 id="de55" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">REST用例</h2><p id="fe47" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated"><strong class="ka ir">管理API。</strong>专注于管理系统中的对象并面向许多消费者的API是最常见的API类型。REST有助于这样的API具有很强的可发现性，很好的文档化，也很适合这种对象模型。</p><p id="2cde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单的资源驱动的应用程序。 REST是连接资源驱动的应用程序的一种有价值的方法，它不需要查询的灵活性。</p><h1 id="4e21" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">GraphQL:只查询需要的数据</h1><p id="5395" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">它需要多次调用REST API来返回所需的人员。所以GraphQL的发明是为了改变游戏规则。</p><p id="e72e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.altexsoft.com/blog/engineering/graphql-core-features-architecture-pros-and-cons/?utm_source=MediumCom&amp;utm_medium=referral&amp;utm_campaign=shared" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> GraphQL </strong> </a>是一种描述如何进行精确数据请求的语法。对于有许多复杂实体相互引用的应用程序数据模型来说，实现GraphQL是值得的。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c269ebb95dce4dabd0b480bf166a0d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Xl1F4riGJN4RaHBC.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated"><em class="lg">如何从GraphQL端点只检索需要的数据，来源:</em> <a class="ae kw" href="https://medium.com/@mohittikoo/rest-vs-graphql-will-graphql-do-to-rest-what-xml-did-to-json-c99e4fa639c3" rel="noopener"> <em class="lg"> Mohit Tikoo </em> </a></figcaption></figure><p id="7fc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些天来，GraphQL生态系统正在随着诸如Apollo、GraphQL和GraphQL Explorer之类的库和强大工具而扩展。</p><h2 id="c6cd" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">GraphQL如何工作</h2><p id="3904" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">GraphQL从构建一个<em class="lh">模式</em>开始，这个模式描述了您可能在GraphQL API中进行的所有查询以及它们返回的所有<em class="lh">类型</em>。模式构建是困难的，因为它需要模式定义语言(SDL)中的强类型。</p><p id="8469" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在查询之前有了模式，客户端可以验证他们的查询，以确保服务器能够响应它。到达后端应用程序后，GraphQL操作将根据整个模式进行解释，并使用前端应用程序的数据进行解析。向服务器发送一个大规模的查询，API返回一个JSON响应，其中包含我们所请求的数据的确切形状。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/4fcbdc0d699469c1a338bd13916bf556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xQQ-afmLh4Yxq2P9.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated"><em class="lg">graph QL中的查询执行，来源:</em><a class="ae kw" href="https://www.apollographql.com/blog/graphql-explained-5844742f195e" rel="noopener ugc nofollow" target="_blank"><em class="lg">Jonas Helfer</em></a></figcaption></figure><p id="9434" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了RESTful CRUD操作，GraphQL还有<em class="lh">订阅</em>，允许来自服务器的实时通知。</p><h2 id="1ad4" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">GraphQL pros</h2><p id="8813" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated"><strong class="ka ir">类型化模式。</strong> GraphQL提前公布自己能做什么，提高了可发现性。通过将客户机指向GraphQL API，我们可以发现哪些查询是可用的。</p><p id="1bf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">非常适合类似图表的数据。</strong>深入链接关系但对平面数据不利的数据。</p><p id="0fdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">没有版本。版本控制的最佳实践是根本不对API进行版本控制。</strong></p><p id="8641" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然REST提供了多个API版本，但GraphQL使用一个不断发展的版本，该版本提供了对新特性的持续访问，并有助于创建更干净、更易维护的服务器代码。</p><p id="b98d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">详细错误信息。与SOAP类似，GraphQL提供了发生的错误的细节。它的错误消息包括所有解析器，并引用出错的确切查询部分。</strong></p><p id="26b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">灵活的权限。</strong> GraphQL允许有选择地公开某些功能，同时保留私人信息。与此同时，REST架构不显示部分数据。要么全有，要么全无。</p><h2 id="1385" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">图表一致性</h2><p id="3bb5" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated"><strong class="ka ir">性能问题。</strong> GraphQL用复杂性换取了强大的功能。在一个请求中有太多嵌套字段会导致系统过载。因此，对于复杂查询，REST仍然是更好的选择。</p><p id="74ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缓存复杂性。</strong>由于GraphQL没有重用HTTP缓存语义，它需要定制缓存。</p><p id="a527" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">大量的发展前教育。没有足够的时间来搞清楚GraphQL利基操作和SDL，许多项目决定遵循众所周知的REST之路。</strong></p><h2 id="94f9" class="mm lk iq bd ll mn mo dn lp mp mq dp lt kj mr ms lx kn mt mu mb kr mv mw mf mx bi translated">GraphQL用例</h2><p id="746c" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated"><strong class="ka ir">移动API。</strong>在这种情况下，网络性能和单消息有效载荷的优化很重要。因此，GraphQL为移动设备提供了更有效的数据加载。</p><p id="40bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">复杂系统和微服务。</strong> GraphQL能够将多系统集成的复杂性隐藏在其API背后。聚合来自多个地方的数据，将它们合并到一个全局模式中。这与<a class="ae kw" href="https://www.altexsoft.com/whitepapers/legacy-system-modernization-how-to-transform-the-enterprise-for-digital-future/?utm_source=MediumCom&amp;utm_medium=referral&amp;utm_campaign=shared" rel="noopener ugc nofollow" target="_blank">传统基础设施</a>或随时间扩展的第三方API尤其相关。</p><h1 id="f1a1" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">哪种API模式最适合您的用例？</h1><p id="42e0" class="pw-post-body-paragraph jy jz iq ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">每个API项目都有不同的需求和需要。通常，架构选择取决于</p><ul class=""><li id="d385" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated">正在使用的编程语言，</li><li id="c51f" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">你发展的环境，以及</li><li id="6bb0" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">你必须节约的资源，包括人力和财力。</li></ul><p id="6574" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">了解了每种设计风格的所有权衡之后，API设计者可以选择最适合项目的风格。</p><p id="dac4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">凭借其紧密耦合，RPC适用于内部微服务，但它不是强大的外部API或API服务的选项。</p><p id="701b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SOAP很麻烦，但是它丰富的安全特性对于计费操作、预订系统和支付来说仍然是不可替代的。</p><p id="6167" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">REST具有最高的抽象和最好的API建模。但是，它往往更重，更健谈——如果你在移动设备上工作，这是一个缺点。</p><p id="5b32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GraphQL在数据获取方面向前迈进了一大步，但并不是每个人都有足够的时间和精力来掌握它。</p><p id="2b9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一天结束时，尝试一些具有特定风格的小用例是有意义的，看看它是否适合您的用例并解决您的问题。如果是的话，试着扩展一下，看看它是否适合更多的用例。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="8075" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lh">最初发表于AltexSoft tech博客“</em> <a class="ae kw" href="https://www.altexsoft.com/blog/soap-vs-rest-vs-graphql-vs-rpc/?utm_source=MediumCom&amp;utm_medium=referral&amp;utm_campaign=shared" rel="noopener ugc nofollow" target="_blank"> <em class="lh">比较API架构风格:SOAP vs REST vs graph QL vs RPC</em></a><em class="lh"/></p></div></div>    
</body>
</html>