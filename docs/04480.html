<html>
<head>
<title>Distributed Tracing with OpenTelemetry — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenTelemetry的分布式跟踪—第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/distributed-tracing-with-opentelemetry-part-2-cc5a9a8aa88c?source=collection_archive---------6-----------------------#2020-06-29">https://levelup.gitconnected.com/distributed-tracing-with-opentelemetry-part-2-cc5a9a8aa88c?source=collection_archive---------6-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4ada" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">分布式系统中的跟踪请求</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3a4bf2304a7888ac8e982b121fe6525e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DY-UbXdQpYuhSHaQ"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@srd844?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯蒂芬·道森</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e77f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将重点关注在<a class="ae ky" href="https://medium.com/@ricardo.linck/distributed-tracing-with-opentelemetry-part-1-6719df95a364" rel="noopener">上一篇文章</a>中提出的架构的实现。慢慢复习吧。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/@ricardo.linck/distributed-tracing-with-opentelemetry-part-1-6719df95a364" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">使用OpenTelemetry的分布式跟踪—第1部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">了解OpenTelemetry和分布式跟踪</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="5ecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的代码可以在我的<a class="ae ky" href="https://github.com/RicardoLinck/distributed-tracing-otel" rel="noopener ugc nofollow" target="_blank"> github repo </a>上找到。我将在这里创建并粘贴一些gists以供参考，这些将只包含最相关和最重要的代码片段。所以我真的鼓励你去我的github上看看完整的参考资料。由于很多人每天都在努力使OpenTelemetry变得更好，而且该项目仍处于早期阶段，所以这里共享的代码可能很快就会过时。</p><blockquote class="mn mo mp"><p id="ee3f" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">OpenTelemetry仍处于测试阶段，因此还不能用于生产系统。</p></blockquote><p id="9d34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里又是图，不用一直在文章间切换；)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/2cacde1882d92f5126c96fe8394aa5c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*nCd2RjWGBqrWj7HEiKkosQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">架构图</figcaption></figure><h2 id="7b4a" class="mv mw it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">客户</h2><p id="d28f" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">这些请求将来自我们的客户端应用程序。这是一个用go编写的简单控制台应用程序，主要目标是通过gRPC调用<em class="mq">天气服务</em>。该应用程序将启动将被传播(上下文传播)到<em class="mq">天气服务</em>的跨度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面代码中的几个重要部分。在第18行，我们正在为我们的跟踪配置导出器。在下一个要点中，我将添加特定函数的代码。在第20行，我们正在为这个应用程序创建跟踪器。在第22行，我们添加了gRPC调用的拦截器。这个拦截器会在将请求发送到gRPC服务器之前将span信息添加到上下文中。这也被称为<strong class="lb iu">上下文传播</strong>。在处理分布式跟踪时，这是一个关键部分，因为这是如何将跨度捆绑在一起的。幸运的是OpenTelemetry提供了插件来做这件事，所以我们只需要添加拦截器，所有的信息都会被注入到请求中。在第39行，我们创建了一个新的span，我们推迟了第40行的<code class="fe nv nw nx ny b">.End()</code>函数。我们还使用返回的上下文作为传递给gRPC请求的上下文。在<code class="fe nv nw nx ny b">getCurrentWeather</code>函数的最后，我们将响应作为一个事件添加到我们创建的span中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ba02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个要点上，我们可以看到如何为耶格出口配置。我们依赖于OpenTelemetry提供的官方导出包。我们将使用相同的函数从<em class="mq">客户端</em>和<em class="mq">天气服务</em>创建导出器，因为两者都在go中实现。</p><h2 id="2b08" class="mv mw it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">气象服务</h2><p id="3238" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">这个服务也是在go中实现的，所以很多东西会和<em class="mq">客户端</em>类似。该服务对请求中提供的位置执行快速查找，并调用<em class="mq">温度服务</em>来获取随机温度。它返回两条信息，<code class="fe nv nw nx ny b">condition</code>和<code class="fe nv nw nx ny b">temperature</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="dd85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来与我们在<em class="mq">客户端</em>上看到的非常相似。我们对gRPC调用使用了一个拦截器。主要区别在于，它将做与它为<em class="mq">客户端</em>所做的相反的事情，而不是将跨度信息<code class="fe nv nw nx ny b">injecting</code>到上下文中，它将把该信息<code class="fe nv nw nx ny b">extract</code>出上下文。当我们能够在第40行上调用<code class="fe nv nw nx ny b">span := trace.SpanFromContext(ctx)</code>时，我们可以看到这一点。该调用只返回一个有效的跨度，因为上下文(ctx)包含拦截器提取的跨度信息。全部由<code class="fe nv nw nx ny b">grpctrace</code>包完成。在后台，该包使用<a class="ae ky" href="https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/context/api-propagators.md" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry规范</a>中指定的<code class="fe nv nw nx ny b">Extract</code>和<code class="fe nv nw nx ny b">Inject</code>方法。出于故障排除的目的，我们在本例中向span添加了不同的事件。我们在第32行添加所选选项(或者记录错误，以防在第28行的位置地图中找不到该位置)。同样，在第37行调用了<em class="mq">温度服务</em>之后，我们正在做同样的事情，处理错误以防出错，或者用返回的温度向span添加一个事件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6e5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是调用<em class="mq">温度服务</em>的代码。在这种情况下，由于服务是在rest api中实现的，我们使用<code class="fe nv nw nx ny b">httptrace</code>包将span信息(包含在<code class="fe nv nw nx ny b">ctx</code>参数中)转换成HTTP请求。使用<code class="fe nv nw nx ny b">W3C</code>标准传播上下文。这让我们看到了样本的最后一部分。</p><h2 id="2883" class="mv mw it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">温度服务</h2><p id="0d42" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">这个服务只是在用C#实现的rest api上提供一个温度端点。控制器实现或任何东西都没有什么特别的。魔力全在<code class="fe nv nw nx ny b">Startup.cs</code>上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a0cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，这个实现与我们在go中的实现非常相似。我们为Jaeger配置了导出器，将采样设置为总是采样，并使用<code class="fe nv nw nx ny b">.AddRequestCollector</code>添加请求收集器。这个调用设置一个中间件，将遥测添加到所有接收到的请求中。这个中间件也理解<code class="fe nv nw nx ny b">W3C</code>格式和<code class="fe nv nw nx ny b">extracts</code> span信息，如果它存在的话。因此，基本上这与我们的其他服务完美契合。</p><h2 id="fced" class="mv mw it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">跟踪请求</h2><p id="d458" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">如果我们继续一起运行所有的东西，所有的跨度最终都应该被发送到Jaeger。如果我们切换到Jager UI，选择<em class="mq">客户端</em>服务，然后点击<strong class="lb iu"> Find Traces，</strong>我们将得到如下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/c9f39cd1aa62d147418351df8b18da61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_vRogP6oeR8xHwpWgE7XA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">出现在Jaeger用户界面中的跨度</figcaption></figure><p id="1b42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个初始视图将显示与该特定服务相关的所有跨度。从这个视图中，我们已经可以看到，来自客户端的跨度实际上包含来自其他服务的跨度。如果我们单击该span以查看其详细信息，我们将看到如下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/a79b2352ce38708951889d7ce9a79ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrxN2-WJX0xBKVNkQhko3g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Jaeger UI中的跨度细节</figcaption></figure><p id="e23a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在顶部，我们可以看到一个时间表，其中包含这个特定请求的所有跨度。这非常有助于识别瓶颈和性能问题。例如，我们可以看到我们的大部分时间都花在调用<em class="mq">温度服务</em>上。如果我们想进一步研究每个跨度，只需单击其中一个跨度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/b94a4d7f345421eb6184f0741372a6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k69n4OaKoKawqbk8gFVbig.png"/></div></div></figure><p id="6773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是来自主要<em class="mq">气象服务</em>时段的细节。正如我们所看到的，添加到span中的事件在这里显示为日志。这对于故障诊断和理解这个特定请求发生了什么非常有帮助。我们可以看到，这个span首先是通过gRPC接收的，紧接着我们选择了位置的条件，然后我们从外部服务获取温度，将所有内容打包，并将响应发送回客户端。当您处理多个正在执行的并发函数时，这种方法非常有用。如果我们每个并发函数有一个span(go routine ),我们可以很容易地理解日志属于哪一个。当我们只处理裸日志时，这是非常棘手的，因为它们可能会被无序记录，并且没有太多的上下文。不要害怕利用这一点，根据需要创建尽可能多的跨度，以便理解您的请求正在发生什么。</p><p id="80b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个具体的例子中，我们没有同时向不同的服务请求东西，但是这在真实的系统中肯定会发生。这显示了OpenTelemetry和分布式跟踪的威力。</p><h2 id="7ff8" class="mv mw it bd mx my mz dn na nb nc dp nd li ne nf ng lm nh ni nj lq nk nl nm nn bi translated">最后的想法</h2><p id="b0d1" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">分布式系统很难监控和排除故障。日志和度量虽然是非常有用的东西，但有时不足以让我们理解给定请求或给定场景中发生了什么。关联事物是很困难的，当你必须手动地或者跨不同的技术和平台来做时，就更困难了。OpenTelemetry提供了一个很好的标准，具有现成的功能来帮助解决这些情况。</p><p id="68df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该标准允许我们使用不同的协议和编程语言进行几乎无缝的通信。只要你依靠标准，事情就会在两端起作用，一切都会很容易关联起来。</p></div></div>    
</body>
</html>