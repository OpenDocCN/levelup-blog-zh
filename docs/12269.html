<html>
<head>
<title>A Sip of Go Log</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一口围棋日志</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-sip-of-go-log-94b968071ed8?source=collection_archive---------2-----------------------#2022-05-27">https://levelup.gitconnected.com/a-sip-of-go-log-94b968071ed8?source=collection_archive---------2-----------------------#2022-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d709" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">揭示关于Go log包和流行的开源选择的细节</h2></div><blockquote class="ki kj kk"><p id="bb73" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">记录很重要。<br/>伐木很辛苦。<br/> —来自戴夫·陈西</p></blockquote><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/77da1676af21e007fb83bf310661c6c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3O1Pc46isOnxkrIZ"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">来自unsplash，<a class="ae ly" href="https://unsplash.com/photos/PJzc7LOt2Ig" rel="noopener ugc nofollow" target="_blank">@ hope _ house _ press _ leather _ diary _ studio</a></figcaption></figure><p id="4ae7" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">日志记录在任何代码中都是不可或缺的，我们在调试和统计中都需要它的支持。然而，一个填充了打印各种消息的<code class="fe mc md me mf b">fmt.Println/fmt.Printf</code>的包永远不能被认为是一个可被读取的包，它可以通过一个简单的改变来优化，使用Golang的原生<a class="ae ly" href="https://pkg.go.dev/log" rel="noopener ugc nofollow" target="_blank">日志包</a>来将信息打印到标准输出或一个文件。</p><p id="5f59" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">那么，如何应用日志包呢？有什么限制吗？如果有，可以寻求开源包吗？让我们一起来寻找答案。</p><h1 id="c9f6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">戈朗日志</h1><pre class="lj lk ll lm gt my mf mz na aw nb bi"><span id="fe27" class="nc mh it mf b gy nd ne l nf ng">package main<br/><br/>import "log"<br/><br/>func main() {<br/>   log.Println("Log println") <em class="kn">// Fatalln, Panicln<br/>   </em>log.Print("Log print")     <em class="kn">// Fatal, Panic<br/>   </em>str := "Log Printf"<br/>   log.Printf("%s", str) <em class="kn">// Fatalf, Panicf<br/></em>}</span></pre><p id="8458" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">该代码基本涵盖了所有的日志打印用法，对应于<code class="fe mc md me mf b">fmt</code>使用模式，包括<code class="fe mc md me mf b">Print/Fatal/Panic</code>、<code class="fe mc md me mf b">Printf/Fatalf/Panicf,</code>、<code class="fe mc md me mf b">Println/Fatalln/Panicln</code>9种方法。</p><p id="9bbd" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">组<code class="fe mc md me mf b">Fatal</code>和<code class="fe mc md me mf b">Panic</code>在完成打印后是不同的。</p><ul class=""><li id="92a8" class="nh ni it ko b kp kq ks kt lz nj ma nk mb nl lh nm nn no np bi translated"><code class="fe mc md me mf b">Fatal</code>调用<code class="fe mc md me mf b">os.Exist(1)</code>退出。</li><li id="0fd5" class="nh ni it ko b kp nq ks nr lz ns ma nt mb nu lh nm nn no np bi translated"><code class="fe mc md me mf b">Panic</code>调用<code class="fe mc md me mf b">panic</code>方法退出。</li></ul><p id="f628" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">所以最核心的区别就是<code class="fe mc md me mf b">defer</code>函数是否被调用:<code class="fe mc md me mf b">Panic</code>会逐层返回，在每一层调用<code class="fe mc md me mf b">defer</code>函数；而，<code class="fe mc md me mf b">os.Exist</code>直接退出。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ea79" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><code class="fe mc md me mf b">log.Panic</code>会在上述情况下触发<code class="fe mc md me mf b">defer</code>函数的调用。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nx"><img src="../Images/3feb64c5715e17cc82363d37525e836f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MEl8PagCak1stlA_"/></div></div></figure><p id="7d83" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">但是使用<code class="fe mc md me mf b">logFatal</code>方法时，只显示一行日志，没有堆栈跟踪。<a class="ae ly" href="https://go.dev/play/p/6bOb5ABtbA2" rel="noopener ugc nofollow" target="_blank">此处测试</a>。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/af04c7e4afede2946a92e2579d003354.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/0*vHzPK2sDxvQI-SIC"/></div></figure><h2 id="81c2" class="nc mh it bd mi nz oa dn mm ob oc dp mq lz od oe ms ma of og mu mb oh oi mw oj bi translated">用户化</h2><ul class=""><li id="b46f" class="nh ni it ko b kp ok ks ol lz om ma on mb oo lh nm nn no np bi translated">设置前缀。</li></ul><blockquote class="ki kj kk"><p id="a4e4" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">func(l *<a class="ae ly" href="https://pkg.go.dev/log#Logger" rel="noopener ugc nofollow" target="_blank">Logger</a>SetPrefix(前缀<a class="ae ly" href="https://pkg.go.dev/builtin#string" rel="noopener ugc nofollow" target="_blank">字符串</a>)</p><p id="ceda" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">SetPrefix设置记录器的输出前缀。</p></blockquote><p id="2b28" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">这是在启动一个方法时添加一些需要的一般信息的常用方法，比如添加方法名、参数等。</p><ul class=""><li id="97b3" class="nh ni it ko b kp kq ks kt lz nj ma nk mb nl lh nm nn no np bi translated">SetFlags</li></ul><blockquote class="ki kj kk"><p id="5540" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">func (l * <a class="ae ly" href="https://pkg.go.dev/log#Logger" rel="noopener ugc nofollow" target="_blank">记录器</a> ) SetFlags(flag <a class="ae ly" href="https://pkg.go.dev/builtin#int" rel="noopener ugc nofollow" target="_blank"> int </a>)</p><p id="947a" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">SetFlags设置记录器的输出标志。标志位为Ldate、Ltime等。</p></blockquote><p id="ee8c" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><code class="fe mc md me mf b">log</code>软件包提供以下可配置标志。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi op"><img src="../Images/d021c252feb61ae9e82b7c425e5403c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9D6qai7vfPgQZ7Wx"/></div></div></figure><p id="423f" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">常见的应用有:</p><p id="bc9b" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><code class="fe mc md me mf b">log.SetFlags(log.Ldate|log.Lshortfile)</code>，输出日期+行号；</p><p id="9d86" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><code class="fe mc md me mf b">log.SetFlags(log.Ldate|log.Ltime |log.LUTC)</code>，输出日期+ UTC时间；</p><p id="6e20" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><code class="fe mc md me mf b">log.SetFlags(log.LstdFlags)</code>，输出日期+时间，等于<code class="fe mc md me mf b">log.Ldate</code>和<code class="fe mc md me mf b">log.Ltime</code>的总和。</p><ul class=""><li id="f809" class="nh ni it ko b kp kq ks kt lz nj ma nk mb nl lh nm nn no np bi translated">设置输出</li></ul><blockquote class="ki kj kk"><p id="c692" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">功能设置输出(带<a class="ae ly" href="https://pkg.go.dev/io" rel="noopener ugc nofollow" target="_blank"> io </a>)。<a class="ae ly" href="https://pkg.go.dev/io#Writer" rel="noopener ugc nofollow" target="_blank">作家</a></p><p id="3524" class="kl km kn ko b kp kq ju kr ks kt jx ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated">SetOutput为标准记录器设置输出目的地。</p></blockquote><p id="78e2" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">它可用于将日志重定向到文件。</p><pre class="lj lk ll lm gt my mf mz na aw nb bi"><span id="0819" class="nc mh it mf b gy nd ne l nf ng">file, err := os.OpenFile("logs.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)<br/>if err != nil {<br/>  log.Fatal(err)<br/>}<br/>log.SetOutput(file)</span></pre><h2 id="63b5" class="nc mh it bd mi nz oa dn mm ob oc dp mq lz od oe ms ma of og mu mb oh oi mw oj bi translated">内部日志</h2><p id="d034" class="pw-post-body-paragraph kl km it ko b kp ok ju kr ks ol jx ku lz oq kx ky ma or lb lc mb os lf lg lh im bi translated">现在来看日志实现。<code class="fe mc md me mf b">log</code>库定义了一个默认的<code class="fe mc md me mf b">Logger</code> <code class="fe mc md me mf b"><a class="ae ly" href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.2:src/log/log.go;l=87" rel="noopener ugc nofollow" target="_blank">std</a></code>，标准日志，当我们直接调用日志库的方法时，会在内部调用其对应的方法。</p><p id="8ce3" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">而<code class="fe mc md me mf b"><a class="ae ly" href="https://cs.opensource.google/go/go/+/refs/tags/go1.18.2:src/log/log.go;l=172" rel="noopener ugc nofollow" target="_blank">Output</a></code>功能就在Logger的内核中。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/e05723ed7db77c8ec90d05d5b0cd9122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/0*pUcm_R8dBBaHFRx6"/></div></figure><p id="5116" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">正如所见，日志是线程安全的，因为在整个过程中，除了在获取<code class="fe mc md me mf b">Caller</code>信息时释放锁之外，它都处于互斥锁的保护之下。</p><p id="7b6b" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><code class="fe mc md me mf b">buf</code>的部分是我们可以借鉴的，它通过日志中定义的<code class="fe mc md me mf b">[]byte</code>组装日志，然后写入writer，从而减少io。</p><h2 id="b802" class="nc mh it bd mi nz oa dn mm ob oc dp mq lz od oe ms ma of og mu mb oh oi mw oj bi translated">缺点</h2><p id="e7c1" class="pw-post-body-paragraph kl km it ko b kp ok ju kr ks ol jx ku lz oq kx ky ma or lb lc mb os lf lg lh im bi translated">我们不喜欢谈论缺点，但我们必须这样做。</p><ul class=""><li id="d448" class="nh ni it ko b kp kq ks kt lz nj ma nk mb nl lh nm nn no np bi translated">不平整-原木支持。<a class="ae ly" href="https://dave.cheney.net/2015/11/05/lets-talk-about-logging" rel="noopener ugc nofollow" target="_blank">让我们来谈谈日志|戴夫·切尼</a>指出这是<code class="fe mc md me mf b">log</code>一揽子计划的最大缺点。</li></ul><p id="6825" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">即<code class="fe mc md me mf b">Info</code>、<code class="fe mc md me mf b">Error</code>、<code class="fe mc md me mf b">Debug</code>等分级日志的信息无法打印，导致所有日志都输出到同一个地方，不利于后续的日志分析和监控。</p><ul class=""><li id="9f53" class="nh ni it ko b kp kq ks kt lz nj ma nk mb nl lh nm nn no np bi translated">对格式的支持不足。在我们既需要文本格式的日志，又需要<code class="fe mc md me mf b">key=value</code>格式的JSON日志来进行未来的日志分析和统计的场景中，这并不友好。</li></ul><h1 id="cc8f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">开源日志包</h1><p id="0a69" class="pw-post-body-paragraph kl km it ko b kp ok ju kr ks ol jx ku lz oq kx ky ma or lb lc mb os lf lg lh im bi translated"><code class="fe mc md me mf b">log</code>包在大多数情况下已经足够了，但是在那些复杂的系统中，它的局限性是显而易见的。因此，我们应该求助于各种开源日志包，其中一些我想带您浏览一下。</p><h2 id="8529" class="nc mh it bd mi nz oa dn mm ob oc dp mq lz od oe ms ma of og mu mb oh oi mw oj bi translated">格洛格</h2><p id="9444" class="pw-post-body-paragraph kl km it ko b kp ok ju kr ks ol jx ku lz oq kx ky ma or lb lc mb os lf lg lh im bi translated"><a class="ae ly" href="https://github.com/golang/glog/blob/master/glog.go" rel="noopener ugc nofollow" target="_blank"> glog </a>最初是Google内部使用的go log框架。它最大的特点是分级——原木支撑，四级分别是<code class="fe mc md me mf b">Info</code>、<code class="fe mc md me mf b">Warning</code>、<code class="fe mc md me mf b">Error</code>、<code class="fe mc md me mf b">Fatal</code>。</p><pre class="lj lk ll lm gt my mf mz na aw nb bi"><span id="98a7" class="nc mh it mf b gy nd ne l nf ng">func main() {<br/>   flag.Parse()<br/>   defer glog.Flush()<br/>   glog.Info("This is a log,", "level", "info")<br/>   glog.Warning("This is a log,", "level", "warning")<br/>   glog.Error("This is a log,", "level", "error")<br/>   glog.Fatal("This is a log,", "level", "fatal")<br/>}</span></pre><p id="1490" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">同时，<code class="fe mc md me mf b">glog</code>还支持<code class="fe mc md me mf b">Infof</code>等格式化输出，以及<code class="fe mc md me mf b">Infoln</code>等换行符输出。</p><p id="8844" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><code class="fe mc md me mf b">glog</code>的独特之处在于<code class="fe mc md me mf b">V</code>设置和过滤调试级日志，这极大地方便了大型系统的开发。在它之前，我没有看到类似的实现。</p><pre class="lj lk ll lm gt my mf mz na aw nb bi"><span id="5c9b" class="nc mh it mf b gy nd ne l nf ng">glog.V(1).Infoln("level 1")</span><span id="9abd" class="nc mh it mf b gy ou ne l nf ng">glog.V(2).Infoln("level 2")</span></pre><p id="1d34" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><code class="fe mc md me mf b">// -v=0 // Enable V-leveled logging at the specified level</code>，V的默认值为<code class="fe mc md me mf b">0</code>。</p><p id="cbdf" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">通过将这两行添加到上面的示例中，我们可以看到下面的输出。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ov"><img src="../Images/590cdfa038d1fb526e98f5118bceb721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*68wVM8X9BKA6f3Nu"/></div></div></figure><p id="9ff7" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">如果<code class="fe mc md me mf b">-v =1</code>被传入，则<code class="fe mc md me mf b">level 2</code>行将不会显示。</p><p id="d3c7" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">此外，<code class="fe mc md me mf b">glog</code>还支持根据级别将日志写入多级。运行<code class="fe mc md me mf b">go run main.go -log_dir=.</code>在本地生成多个日志文件。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ow"><img src="../Images/4923461b7270815a39f6110e0f11a2eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1dXmcMi2J5AeFAlG"/></div></div></figure><p id="2362" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">日志内容向上兼容:<code class="fe mc md me mf b">main.INFO</code>包含<code class="fe mc md me mf b">ERROR</code>、<code class="fe mc md me mf b">WARNING</code>和<code class="fe mc md me mf b">FATAL</code>级别的日志，而<code class="fe mc md me mf b">main.FATAL</code>只有<code class="fe mc md me mf b">FATAL</code>级别的日志。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ox"><img src="../Images/9f88b5303dba681f45deb1986ecdd52a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fp0IcoK1uPcWj6ef"/></div></div></figure><p id="4341" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">此外，一旦日志文件大小超过<a class="ae ly" href="https://github.com/golang/glog/blob/9ef845f417d839250ceabbc25c1b26101e772dd7/glog.go#L815" rel="noopener ugc nofollow" target="_blank"> Maxsize </a>，<code class="fe mc md me mf b">glog</code>会自动<a class="ae ly" href="https://github.com/golang/glog/blob/9ef845f417d839250ceabbc25c1b26101e772dd7/glog.go#L835" rel="noopener ugc nofollow" target="_blank">创建</a>一个新的日志文件。</p><pre class="lj lk ll lm gt my mf mz na aw nb bi"><span id="caa3" class="nc mh it mf b gy nd ne l nf ng">func (sb *syncBuffer) Write(p []byte) (n int, err error) {<br/>   if sb.nbytes+uint64(len(p)) &gt;= MaxSize {<br/>      if err := sb.rotateFile(time.Now()); err != nil {<br/>         sb.logger.exit(err)<br/>      }<br/>   }<br/>   <em class="kn">//...<br/></em>}<br/><br/><em class="kn">// rotateFile closes the syncBuffer's file and starts a new one.<br/></em>func (sb *syncBuffer) rotateFile(now time.Time) error {<br/>   <em class="kn">// ...<br/>   </em>sb.file, _, err = create(severityName[sb.sev], now)<br/>   sb.nbytes = 0<br/>   if err != nil {<br/>      return err<br/>   }<br/>   <em class="kn">// ...<br/></em>}</span></pre><p id="0cb0" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><code class="fe mc md me mf b">glog</code>可以看作是原生日志的升级版，它们有一个共同的特点:<strong class="ko iu">开发人员需要将每个字段传入类似</strong> <code class="fe mc md me mf b"><strong class="ko iu">Printf/Errorf/Fatalf</strong></code> <strong class="ko iu">这样的API中，形成一个非结构化的日志，有助于搜索和分析，但无助于机器排序和收集度量。</strong></p><h2 id="a721" class="nc mh it bd mi nz oa dn mm ob oc dp mq lz od oe ms ma of og mu mb oh oi mw oj bi translated">logrus</h2><p id="3e3d" class="pw-post-body-paragraph kl km it ko b kp ok ju kr ks ol jx ku lz oq kx ky ma or lb lc mb os lf lg lh im bi translated"><code class="fe mc md me mf b">logrus</code>是另一个最火的日志框架，其<a class="ae ly" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> github页面</a>上有20.5k的明星和90k的用户。它能够直接输出<code class="fe mc md me mf b">key=value</code>格式的JSON日志，这使它有别于<code class="fe mc md me mf b">glog</code>。当然，它也支持文本格式。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a80b" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><code class="fe mc md me mf b">logrus</code>支持<code class="fe mc md me mf b">Trace</code>、<code class="fe mc md me mf b">Debug</code>、<code class="fe mc md me mf b">Info</code>、<code class="fe mc md me mf b">Warn</code>、<code class="fe mc md me mf b">Error</code>、<code class="fe mc md me mf b">Fatal</code>、<code class="fe mc md me mf b">Panic</code>七级调试日志，但不支持<code class="fe mc md me mf b">V</code>级调试日志。</p><p id="a126" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">对于日志打印，<code class="fe mc md me mf b">logrus</code>不仅支持常规的<code class="fe mc md me mf b">Info</code>、<code class="fe mc md me mf b">Infof</code>、<code class="fe mc md me mf b">Infoln</code>三种方式，还支持<code class="fe mc md me mf b">LogFunction func() []interface{}</code>，提高了效率。对于大消息，它只在级别匹配时生成日志；否则，跳过。</p><p id="d70b" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><code class="fe mc md me mf b">WithFields</code>函数可以将日志打印的参数作为单独的键和值传入，以便进一步分析。</p><p id="7540" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><code class="fe mc md me mf b">logrus.SetFormatter(&amp;logrus.JSONFormatter{})</code>启用JSON格式日志的打印。</p><p id="576d" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">取消上述代码的注释并重新运行它，您将得到下面的JSON日志。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi oy"><img src="../Images/99338923630b4eecf86a92513db66c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rxSjg8hpHVl-HkPy"/></div></div></figure><p id="a506" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">除了默认的<code class="fe mc md me mf b">TextFormatter</code>和<code class="fe mc md me mf b">JSONFormatter</code>，还支持可以插入第三方的<code class="fe mc md me mf b">Formatters</code>，比如<a class="ae ly" href="https://github.com/antonfisher/nested-logrus-formatter" rel="noopener ugc nofollow" target="_blank">nested-logrus-formatter</a>提供了一组额外的标志来控制输出格式。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi oz"><img src="../Images/c331d19f1881533e94f1f6c9187f3de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mWGtbJQBEBnt37JG"/></div></div></figure><p id="134d" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">使用<code class="fe mc md me mf b">TimestampFormat: time.RFC3339</code>，您可以打印<code class="fe mc md me mf b">2022–05–26T15:40:07+02:00</code>格式的日志。</p><p id="0fc3" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">使用日志钩子，我们可以设置钩子来响应我们感兴趣的日志级别，操作日志内容，添加和修改日志的特定键值参数等。可以试试那些第三方实现的<code class="fe mc md me mf b">Loghook</code>，比如用<a class="ae ly" href="https://github.com/rogierlommers/logrus-redis-hook" rel="noopener ugc nofollow" target="_blank"> logrus-redis-hook </a>把日志转发到redis。</p><p id="46cd" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">显然，<code class="fe mc md me mf b">logrus</code>比上面列出的所有函数更具可伸缩性。但是它的日志级别设置并不像<code class="fe mc md me mf b">glog’s</code> <code class="fe mc md me mf b">V</code> log那样简洁，以至于戴夫·切尼甚至认为“没人需要警告日志级别。”</p><h2 id="745c" class="nc mh it bd mi nz oa dn mm ob oc dp mq lz od oe ms ma of og mu mb oh oi mw oj bi translated">活力</h2><p id="ad15" class="pw-post-body-paragraph kl km it ko b kp ok ju kr ks ol jx ku lz oq kx ky ma or lb lc mb os lf lg lh im bi translated">zap最初是为优步内部使用而引入的，之后才被贡献给社区。与<code class="fe mc md me mf b">glog</code>和<code class="fe mc md me mf b">logrus</code>相比，它的最大目标是在提供结构化和分级日志时“更快”。</p><p id="f23f" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">它提供了两种不同类型的记录器，<code class="fe mc md me mf b">Logger</code>和<code class="fe mc md me mf b">SugaredLogger</code>。</p><ul class=""><li id="5a31" class="nh ni it ko b kp kq ks kt lz nj ma nk mb nl lh nm nn no np bi translated">在具有高性能要求和内存限制的场景中使用<code class="fe mc md me mf b">Logger</code>。与<code class="fe mc md me mf b">SugaredLogger</code>相比，它的性能更快，内存分配更少，但是它只支持强类型结构化日志记录。</li><li id="d045" class="nh ni it ko b kp nq ks nr lz ns ma nt mb nu lh nm nn no np bi translated">当性能要求较低时，使用<code class="fe mc md me mf b">SugaredLogger</code>。它支持结构化和printf风格的日志记录，同时在内存开销和速度方面仍然胜过其他日志包。</li></ul><p id="379d" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">下面展示其在Github上相对于其他框架的<a class="ae ly" href="https://github.com/uber-go/zap#performance" rel="noopener ugc nofollow" target="_blank">优势</a>。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi pa"><img src="../Images/f8e464eac3ecf2a5185cfd49eb7ee9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/0*AsRTSIjq47oajOJo"/></div></div></figure><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8578" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">zap logger支持三种创建方式，<code class="fe mc md me mf b">NewProduction</code>、<code class="fe mc md me mf b">NewDevelopment</code>、<code class="fe mc md me mf b">NewExample</code>，分别对应不同的输出格式。</p><ul class=""><li id="9550" class="nh ni it ko b kp kq ks kt lz nj ma nk mb nl lh nm nn no np bi translated"><code class="fe mc md me mf b">NewProduction</code>和<code class="fe mc md me mf b">NewExample</code>支持JSON输出。</li><li id="0e99" class="nh ni it ko b kp nq ks nr lz ns ma nt mb nu lh nm nn no np bi translated"><code class="fe mc md me mf b">NewDevelopment</code>支持文字。</li><li id="b4a4" class="nh ni it ko b kp nq ks nr lz ns ma nt mb nu lh nm nn no np bi translated"><code class="fe mc md me mf b">NewExample</code>可以打印各级日志，但不显示日期、文件、行号等。</li><li id="5f2e" class="nh ni it ko b kp nq ks nr lz ns ma nt mb nu lh nm nn no np bi translated"><code class="fe mc md me mf b">NewDevelopment</code>打印warn级别及以上的日志，结果包括日期、时间戳、文件、行号和一个JSON格式的参数列表(如果存在的话)。</li><li id="5f7e" class="nh ni it ko b kp nq ks nr lz ns ma nt mb nu lh nm nn no np bi translated"><code class="fe mc md me mf b">NewProduction</code>打印信息级别及以上的日志，显示日期、时间戳以及紧急和错误日志的跟踪堆栈信息。</li></ul><p id="eb80" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated"><code class="fe mc md me mf b">zap</code>还支持“写入文件”，但不支持日志旋转，只有像<a class="ae ly" href="https://github.com/natefinch/lumberjack" rel="noopener ugc nofollow" target="_blank">伐木工</a>这样的第三方日志程序才能实现。zap FAQ提供了一个<a class="ae ly" href="https://github.com/uber-go/zap/blob/master/FAQ.md#does-zap-support-log-rotation" rel="noopener ugc nofollow" target="_blank">答案</a>。</p><h1 id="994b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">包裹</h1><p id="78a6" class="pw-post-body-paragraph kl km it ko b kp ok ju kr ks ol jx ku lz oq kx ky ma or lb lc mb os lf lg lh im bi translated">日志在开发中起着重要的作用。何时记录日志以及遵循哪个框架是一件大事，最近的Java log4j进一步强化了这一信念。</p><p id="2761" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">Go native log包提供了所需的大部分功能，但是使用那些第三方日志框架，如<code class="fe mc md me mf b">logrus</code>、<code class="fe mc md me mf b">glog</code>和<code class="fe mc md me mf b">zap</code>，我们可以通过更好的日志体验实现更多功能。</p><p id="ca68" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">本文只是日志包的一小部分，还有更多具有各种功能的日志包。如果有兴趣，可以尝试探索更多，比如研究Kubernetes控制器-运行时<a class="ae ly" href="https://github.com/kubernetes-sigs/controller-runtime/tree/master/pkg/log" rel="noopener ugc nofollow" target="_blank">日志包</a>或者定制自己的日志器。</p><p id="6155" class="pw-post-body-paragraph kl km it ko b kp kq ju kr ks kt jx ku lz kw kx ky ma la lb lc mb le lf lg lh im bi translated">感谢阅读！</p></div></div>    
</body>
</html>