<html>
<head>
<title>Optimize your recursive approach using memoization!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用记忆优化你的递归方法！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optimize-your-recursive-approach-using-memoization-ef4c64ceae00?source=collection_archive---------13-----------------------#2021-06-09">https://levelup.gitconnected.com/optimize-your-recursive-approach-using-memoization-ef4c64ceae00?source=collection_archive---------13-----------------------#2021-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2904" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对于初学者来说！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dbbdf898682e2348ca87e974eb9a37e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ditCo9pDmuAinnrT"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cookiethepom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Cookie在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的Pom </a>拍摄</figcaption></figure><p id="044f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将学到的内容:</p><ul class=""><li id="59b6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如何在斐波那契函数中实现记忆？</li></ul><p id="9b3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要什么:</p><ul class=""><li id="8e87" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">没什么！</li></ul><p id="33cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">推荐:</p><ul class=""><li id="89d1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">编程语言知识。</li></ul><h1 id="8177" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">什么是斐波那契？</h1><p id="c856" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">斐波纳契数列是这样一个数列，其中下一个数字是前两个数字的和，前两个数字是1。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5f75" class="ng mf it nc b gy nh ni l nj nk"><strong class="nc iu">First 5 numbers of Fibonacci:</strong></span><span id="8621" class="ng mf it nc b gy nl ni l nj nk">1, 1, 2, 3, 5</span></pre><h1 id="ee2a" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">递归斐波纳契</h1><p id="5650" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">每个递归函数都应该有一个基本用例，以确保函数不会无休止地调用自己。</p><p id="f25c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们将检查它是1还是2，因为我们知道这两个必须是1。</p><p id="cca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">☝下面的代码存根将用Python编写。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="59c6" class="ng mf it nc b gy nh ni l nj nk">def fib(n):<br/>    if n == 1 or n == 2:<br/>        return 1</span></pre><p id="4855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">斐波那契数是后面两个数的和，所以我们可以再次调用这个函数，但是用<code class="fe nm nn no nc b">n — 1</code>和<code class="fe nm nn no nc b">n — 2</code>代替。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="57e8" class="ng mf it nc b gy nh ni l nj nk">def fib(n):<br/>    if n == 1 or n == 2:<br/>        return 1</span><span id="273d" class="ng mf it nc b gy nl ni l nj nk">    <em class="np">return fib(n-1) + fib(n-2)</em></span></pre><p id="508e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个功能运行得很好，数字<code class="fe nm nn no nc b">7</code>和<code class="fe nm nn no nc b">10</code>看起来运行正常。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="bffd" class="ng mf it nc b gy nh ni l nj nk"><strong class="nc iu"># Input</strong></span><span id="1190" class="ng mf it nc b gy nl ni l nj nk">print(fib(7))</span><span id="531b" class="ng mf it nc b gy nl ni l nj nk">print(fib(10))</span><span id="4586" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu"># Output</strong></span><span id="d4ba" class="ng mf it nc b gy nl ni l nj nk">13</span><span id="9776" class="ng mf it nc b gy nl ni l nj nk">55</span></pre><p id="02fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们执行一个更大的数字，程序就会挂起。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="1c60" class="ng mf it nc b gy nh ni l nj nk"><strong class="nc iu"># Input</strong></span><span id="f1c3" class="ng mf it nc b gy nl ni l nj nk">print(fib(50))</span><span id="62ea" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu"># Output</strong></span><span id="10a9" class="ng mf it nc b gy nl ni l nj nk">...</span></pre><p id="1a93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你熟悉大o符号，你会发现它有一个指数运行时间，O(2^n).</p><p id="a1d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们可以在这个功能上做哪些改进呢？</p><h1 id="0d81" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">记忆化的斐波那契！</h1><p id="8201" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">优化函数的一个方法是识别我们在哪里做不必要的计算。让我们看看我们的函数在调用什么。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="21bf" class="ng mf it nc b gy nh ni l nj nk">print(fib(7))</span><span id="ec0b" class="ng mf it nc b gy nl ni l nj nk">7 = <strong class="nc iu">fib(6)</strong> + <strong class="nc iu">fib(5)</strong></span><span id="a3d3" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">fib(6)</strong> + <strong class="nc iu">fib(5)</strong> = <strong class="nc iu">fib(5)</strong> + <strong class="nc iu">fib(4)</strong> + <strong class="nc iu">fib(3)</strong> + <strong class="nc iu">fib(4)</strong></span><span id="7396" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">fib(5)</strong> + <strong class="nc iu">fib(4)</strong> + <strong class="nc iu">fib(3)</strong> + <strong class="nc iu">fib(4)</strong> = <strong class="nc iu">fib(3)</strong> + <strong class="nc iu">fib(4)</strong> + 1 + <strong class="nc iu">fib(3)</strong> + 2 + 1 + <strong class="nc iu">fib(3)</strong></span><span id="95ad" class="ng mf it nc b gy nl ni l nj nk">and so on...</span></pre><p id="1983" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎每个调用都会重复多次，这给我们的程序带来了很多额外的计算。</p><p id="30f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该将它们存储在一个散列表中，如果已经存在的话就访问它们，而不是运行它们。</p><p id="e239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们称之为memo，当我们没有为它传入参数时，我们应该将它初始化为一个空的hashmap。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="610f" class="ng mf it nc b gy nh ni l nj nk">def fib(n, memo = {}):<br/>    if n == 1 or n == 2:<br/>        return 1</span><span id="acfb" class="ng mf it nc b gy nl ni l nj nk"><em class="np">    return fib(n-1) + fib(n-2)</em></span></pre><p id="8387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加另一个检查，看看我们是否已经计算了这个数字。如果它是，我们将归还它。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="7063" class="ng mf it nc b gy nh ni l nj nk">def fib(n, memo = {}):<br/>    <strong class="nc iu">if <em class="np">n</em> in <em class="np">memo</em>: <br/>        return <em class="np">memo</em>[<em class="np">n</em>]</strong><br/>    if n == 1 or n == 2:<br/>        return 1</span><span id="cfd8" class="ng mf it nc b gy nl ni l nj nk"><em class="np">    return fib(n-1) + fib(n-2)</em></span></pre><p id="f685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，每次我们计算一个数字，让我们把它存储在hashmap中。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="2f67" class="ng mf it nc b gy nh ni l nj nk">def fib(n, memo = {}):<br/>    if <em class="np">n</em> in <em class="np">memo</em>: <br/>        return <em class="np">memo</em>[<em class="np">n</em>]<br/>    if n == 1 or n == 2:<br/>        return 1<br/>    <strong class="nc iu"><em class="np">memo[n] = fib(n-1, memo) + fib(n-2, memo)</em></strong></span><span id="0992" class="ng mf it nc b gy nl ni l nj nk"><em class="np">    return fib(n-1) + fib(n-2)</em></span></pre><p id="430d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们再次调用这个函数时，我们还会传入我们的hashmap，这样我们存储在那里的值就会被保存下来。</p><p id="0506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将在函数结束时返回<code class="fe nm nn no nc b">memo[n]</code>。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="beb6" class="ng mf it nc b gy nh ni l nj nk">def fib(n, memo = {}):<br/>    if <em class="np">n</em> in <em class="np">memo</em>: <br/>        return <em class="np">memo</em>[<em class="np">n</em>]<br/>    if n == 1 or n == 2:<br/>        return 1<br/>    <em class="np">memo[n] = fib(n-1, memo) + fib(n-2, memo)</em></span><span id="1b28" class="ng mf it nc b gy nl ni l nj nk"><em class="np">    </em><strong class="nc iu"><em class="np">return memo[n]</em></strong></span></pre><p id="1172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再试试我们的测试设备。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="8af6" class="ng mf it nc b gy nh ni l nj nk"><strong class="nc iu"># Input</strong></span><span id="a62a" class="ng mf it nc b gy nl ni l nj nk">print(fib(7))<br/>print(fib(50))</span><span id="c28b" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu"># Output</strong></span><span id="1e6e" class="ng mf it nc b gy nl ni l nj nk">13<br/>12586269025</span></pre><p id="3c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功了！</p><h1 id="81db" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">结论</h1><p id="a8f6" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">谢谢！</p><p id="bb8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您喜欢阅读本文，并且您的代码工作正常。如果您有任何问题、建议或总体反馈，请随时发表评论！</p><p id="09ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>