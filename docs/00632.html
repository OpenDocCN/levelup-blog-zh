<html>
<head>
<title>Binary encoding of variable length options with Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Golang对可变长度选项进行二进制编码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/binary-encoding-of-variable-length-options-with-golang-4481ff59e767?source=collection_archive---------1-----------------------#2019-06-13">https://levelup.gitconnected.com/binary-encoding-of-variable-length-options-with-golang-4481ff59e767?source=collection_archive---------1-----------------------#2019-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="20df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用Go读写TLV编码的消息</p><p id="96a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最近，我在工作中实现了一个高吞吐量的网络组件。为了节省CPU时间和减少负载大小，该服务使用二进制编码作为网络格式。我们实现的协议的一个属性是消息<em class="ko">可以</em>包括可变长度的可选字段。我了解到，这并不像听起来那么简单。</p><p id="1c53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在基于文本的编码(如CSV或JSON)中，向消息添加额外的字段是非常简单的。以JSON为例，如果我们想在消息中添加一个额外的字段，比如:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="8cb7" class="ky kz it ku b gy la lb l lc ld">{<br/>  "hello": "world"<br/>}</span></pre><p id="698c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们只需要在第一行数据之后和终止的花括号<code class="fe le lf lg ku b">}</code>之前添加<code class="fe le lf lg ku b">,"favorite_number": 42</code>。</p><p id="2d92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当在二进制协议中工作时，我们通常不会选择一些字符作为字段或消息之间的分隔符。这是因为当传输任意数据流时，您选择的任何分隔符都可能包含在数据流中。您不能保留一个字节中可能出现的八个0和1的256种排列中的任何一种作为分隔符，因为它们可能出现在数据中。</p><p id="770d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，如果我们决定使用一个转义字符，也可以选择一个分隔符(同样，如果我们在JSON字符串中添加一个反斜杠，我们可以在字符串中使用引号，例如:<code class="fe le lf lg ku b">"giant \"laser\""</code>)。</p><figure class="kp kq kr ks gt li gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/01aaaebeb3f654307f86769922b0a2bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*yDrlArWcnhnv3wWv.jpg"/></div></figure><p id="6bcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，这样做的话，我们现在必须付出实际逐字节读取消息的代价，寻找这些分隔符并考虑转义字符。在我看来，使用二进制协议的一个主要原因是能够将字节从网络接口直接复制到内存中，而根本不需要使用CPU来解析。</p><p id="2c3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，二进制协议通常跳过使用定界符来确定字段边界的放纵，而求助于固定长度的字段消息结构，用一个特殊的字段来表示有效载荷长度。例如，IPv6报头总是40字节长，第5–6字节保留给有效负载长度的16位无符号整数。</p><p id="f9e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这允许包的解析器从读取头的40字节开始，然后查看第5-6字节，并确切地知道在包的末尾要读取多少。</p><figure class="kp kq kr ks gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ll"><img src="../Images/ae199c1841a7002cb6d43c6b7e9fc956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5R8aQQT6s60Slkx17k2dw.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">IPv6报头结构，来源:<a class="ae lu" href="https://tools.ietf.org/html/rfc2460#section-3" rel="noopener ugc nofollow" target="_blank"> IETF RFC 2460 </a></figcaption></figure><p id="3af6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">手头的问题需要一些更复杂的东西。在我们的例子中，我们有<em class="ko">可选的</em>字段，并且数量众多。我们可以有可选的、可变长度的字段而不使用分隔符吗？</p><p id="5846" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">常见的解决方案是一种称为TLV的编码，是<a class="ae lu" href="https://en.wikipedia.org/wiki/Type-length-value" rel="noopener ugc nofollow" target="_blank">类型-长度-值</a>的简写，它在网络协议中非常常见，实际上是在<a class="ae lu" href="https://tools.ietf.org/html/rfc2460#section-4.2" rel="noopener ugc nofollow" target="_blank"> IPv6扩展报头</a>中指定选项的方式。</p><p id="afaa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TLV编码的消息由3部分组成:表示其类型的字节，表示有效载荷长度的字节，以及零个或多个有效载荷字节。类型字段和长度字段的长度必须在解析消息之前预先确定，以允许读者知道每个字段的边界是什么。</p><p id="b9d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何用Golang实现这样的东西。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="3072" class="ky kz it ku b gy la lb l lc ld"><strong class="ku iu">package </strong>tlv</span><span id="a1a3" class="ky kz it ku b gy lv lb l lc ld">// ByteSize is the size of a field in bytes. Used to define the size of the type and length field in a message.<br/><strong class="ku iu">type </strong>ByteSize int<br/><br/><strong class="ku iu">const </strong>(<br/>   <em class="ko">OneByte    </em>ByteSize = 1<br/>   <em class="ko">TwoBytes   </em>ByteSize = 2<br/>   <em class="ko">FourBytes  </em>ByteSize = 4<br/>   <em class="ko">EightBytes </em>ByteSize = 8<br/>)</span></pre><p id="56af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先定义一个自定义的<code class="fe le lf lg ku b">ByteSize</code>类型，这个类型将在我们的配置对象<code class="fe le lf lg ku b">Codec</code>中使用，以指示我们的<em class="ko">类型</em>和<em class="ko">长度</em>有多大。选择这些字段的正确大小是未来兼容性和总有效载荷大小之间的权衡。例如，如果您选择<code class="fe le lf lg ku b">OneByte</code>作为您的长度字段大小，您将被限制为有效载荷最大为256字节。如果您为类型字段选择一个<code class="fe le lf lg ku b">EightByte</code>大小，对于一个您只希望有少量不同类型的协议，您将最终总是在每个消息中发送七个零的浪费带宽。因此，选择适合您的协议。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="e787" class="ky kz it ku b gy la lb l lc ld">// Record represents a record of data encoded in the TLV message.<br/><strong class="ku iu">type </strong>Record <strong class="ku iu">struct </strong>{<br/>   Payload []byte<br/>   Type    uint<br/>}<br/><br/>// Codec is the configuration for a specific TLV encoding/decoding tasks.<br/><strong class="ku iu">type </strong>Codec <strong class="ku iu">struct </strong>{<br/><br/>   // TypeBytes defines the size in bytes of the message type field.<br/>   TypeBytes ByteSize<br/><br/>   // LenBytes defines the size in bytes of the message length field.<br/>   LenBytes  ByteSize<br/>}</span></pre><p id="da44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的数据容器叫做<code class="fe le lf lg ku b">Record</code>，有一个无符号整型字段<code class="fe le lf lg ku b">Type</code>(<code class="fe le lf lg ku b">TLV</code>中的<code class="fe le lf lg ku b">T</code>)和一个用于<code class="fe le lf lg ku b">Payload</code>的字节片。</p><p id="ffd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何对一些消息进行编码:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="7c19" class="ky kz it ku b gy la lb l lc ld">// Writer encodes records into TLV format using a Codec and writes them into a provided io.Writer<br/><strong class="ku iu">type </strong>Writer <strong class="ku iu">struct </strong>{<br/>   writer io.Writer<br/>   codec  *Codec<br/>}<br/><br/><strong class="ku iu">func </strong>NewWriter(w io.Writer, codec *Codec) *Writer {<br/>   <strong class="ku iu">return </strong>&amp;Writer{<br/>      codec:  codec,<br/>      writer: w,<br/>   }<br/>}<br/><br/>// Write encodes records into TLV format using a Codec and writes them into a provided io.Writer<br/><strong class="ku iu">func </strong>(w *Writer) Write(rec *Record) (error) {<br/>   err := writeUint(w.writer, w.codec.TypeBytes, rec.Type)<br/>   <strong class="ku iu">if </strong>err != nil {<br/>      <strong class="ku iu">return </strong>err<br/>   }<br/><br/>   ulen := uint(len(rec.Payload))<br/>   err = writeUint(w.writer, w.codec.LenBytes, ulen)<br/>   <strong class="ku iu">if </strong>err != nil {<br/>      <strong class="ku iu">return </strong>err<br/>   }<br/><br/>   _, err = w.writer.Write(rec.Payload)<br/>   <strong class="ku iu">return </strong>err<br/>}<br/><br/><strong class="ku iu">func </strong>writeUint(w io.Writer, b ByteSize, i uint) error {<br/>   <strong class="ku iu">var </strong>num <strong class="ku iu">interface</strong>{}<br/>   <strong class="ku iu">switch </strong>b {<br/>   <strong class="ku iu">case </strong><em class="ko">OneByte</em>:<br/>      num = uint8(i)<br/>   <strong class="ku iu">case </strong><em class="ko">TwoBytes</em>:<br/>      num = uint16(i)<br/>   <strong class="ku iu">case </strong><em class="ko">FourBytes</em>:<br/>      num = uint32(i)<br/>   <strong class="ku iu">case </strong><em class="ko">EightBytes</em>:<br/>      num = uint64(i)<br/>   }<br/>   <strong class="ku iu">return </strong>binary.Write(w, binary.BigEndian, num)<br/>}</span></pre><p id="0a8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们运行一些测试代码来看看它是如何工作的:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="b492" class="ky kz it ku b gy la lb l lc ld"><strong class="ku iu">package </strong>main<br/><br/><strong class="ku iu">import </strong>(<br/>   "bytes"<br/>   "encoding/hex"<br/>   "fmt"<br/>   "tlv"<br/>)<br/><br/><strong class="ku iu">func </strong>main() {<br/>   buf := new(bytes.Buffer)<br/>   codec := &amp;tlv.Codec{TypeBytes: tlv.<em class="ko">TwoBytes</em>, LenBytes: tlv.<em class="ko">TwoBytes</em>}<br/>   wr := tlv.NewWriter(buf, codec)<br/><br/>   record := &amp;tlv.Record{<br/>      Payload: []byte("hello, go!"),<br/>      Type: 8,<br/>   }<br/><br/>   wr.Write(record)<br/><br/>   fmt.Println(hex.Dump(buf.Bytes()))<br/>}</span></pre><p id="4379" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它打印:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="01b6" class="ky kz it ku b gy la lb l lc ld">00000000 00 08 00 0a 68 65 6c 6c 6f 2c 20 67 6f 21 |....hello, go!|</span></pre><p id="bf62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来分析一下输出。根据我们的编解码器定义，前两个字节将指示消息的类型，十六进制的<code class="fe le lf lg ku b">00 08</code>是十进制的<code class="fe le lf lg ku b">8</code>，这就是我们想要的。接下来的两个字节表示有效载荷的长度，六进制的<code class="fe le lf lg ku b">00 0a</code>是十进制的<code class="fe le lf lg ku b">10</code>，是<code class="fe le lf lg ku b">hello, go!</code>的字符长度。最后，接下来的字节是我们的有效载荷，<code class="fe le lf lg ku b">68 65 6c 6c 6f 2c 20 67 6f 21</code>是ASCII码中<code class="fe le lf lg ku b">hello, go!</code>的六进制值(0x68 = 104 = <code class="fe le lf lg ku b">h</code>)。</p><p id="cce8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的下一步是编写代码，将TLV编码的消息解析回<code class="fe le lf lg ku b">Record</code>结构:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="e440" class="ky kz it ku b gy la lb l lc ld">// Reader decodes records from TLV format using a Codec from provided io.Reader<br/><strong class="ku iu">type </strong>Reader <strong class="ku iu">struct </strong>{<br/>   codec  *Codec<br/>   reader io.Reader<br/>}<br/><br/><strong class="ku iu">func </strong>NewReader(reader io.Reader, codec *Codec) *Reader {<br/>   <strong class="ku iu">return </strong>&amp;Reader{codec: codec, reader: reader}<br/>}<br/><br/>// Next tries to read a single Record from the io.Reader<br/><strong class="ku iu">func </strong>(r *Reader) Next() (*Record, error) {<br/>   // get type<br/>   typeBytes := make([]byte, r.codec.TypeBytes)<br/>   _, err := r.reader.Read(typeBytes)<br/>   <strong class="ku iu">if </strong>err != nil {<br/>      <strong class="ku iu">return </strong>nil, err<br/>   }<br/>   typ := readUint(typeBytes, r.codec.TypeBytes)<br/><br/>   // get len<br/>   payloadLenBytes := make([]byte, r.codec.LenBytes)<br/>   _, err = r.reader.Read(payloadLenBytes)<br/>   <strong class="ku iu">if </strong>err != nil &amp;&amp; err != io.EOF {<br/>      <strong class="ku iu">return </strong>nil, err<br/>   }<br/>   payloadLen := readUint(payloadLenBytes, r.codec.LenBytes)<br/><br/>   <strong class="ku iu">if </strong>err == io.EOF &amp;&amp; payloadLen != 0 {<br/>      <strong class="ku iu">return </strong>nil, err<br/>   }<br/><br/>   // get value<br/>   v := make([]byte, payloadLen)<br/>   _, err = r.reader.Read(v)<br/>   <strong class="ku iu">if </strong>err != nil &amp;&amp; err != io.EOF {<br/>      <strong class="ku iu">return </strong>nil, err<br/>   }<br/><br/>   <strong class="ku iu">return </strong>&amp;Record{<br/>      Type: typ,<br/>      Payload: v,<br/>   }, nil<br/><br/>}<br/><br/><strong class="ku iu">func </strong>readUint(b []byte, sz ByteSize) uint {<br/>   reader := bytes.NewReader(b)<br/>   <strong class="ku iu">switch </strong>sz {<br/>   <strong class="ku iu">case </strong><em class="ko">OneByte</em>:<br/>      <strong class="ku iu">var </strong>i uint8<br/>      binary.Read(reader, binary.BigEndian, &amp;i)<br/>      <strong class="ku iu">return </strong>uint(i)<br/>   <strong class="ku iu">case </strong><em class="ko">TwoBytes</em>:<br/>      <strong class="ku iu">var </strong>i uint16<br/>      binary.Read(reader, binary.BigEndian, &amp;i)<br/>      <strong class="ku iu">return </strong>uint(i)<br/>   <strong class="ku iu">case </strong><em class="ko">FourBytes</em>:<br/>      <strong class="ku iu">var </strong>i uint32<br/>      binary.Read(reader, binary.BigEndian, &amp;i)<br/>      <strong class="ku iu">return </strong>uint(i)<br/>   <strong class="ku iu">case </strong><em class="ko">EightBytes</em>:<br/>      <strong class="ku iu">var </strong>i uint64<br/>      binary.Read(reader, binary.BigEndian, &amp;i)<br/>      <strong class="ku iu">return </strong>uint(i)<br/>   <strong class="ku iu">default</strong>:<br/>      <strong class="ku iu">return </strong>0<br/>   }<br/>}</span></pre><p id="c903" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg ku b">Next()</code>，我们的函数将尝试在<code class="fe le lf lg ku b">io.Reader</code>上向前移动以读取一个完整的<code class="fe le lf lg ku b">Record,</code>，首先将第一个字节读入<code class="fe le lf lg ku b">typ</code>变量，接着将有效载荷长度读入<code class="fe le lf lg ku b">payloadLenBytes</code>，最后，一旦我们知道了有效载荷长度，我们就读取那么多字节并放入<code class="fe le lf lg ku b">Record</code>对象并返回。</p><p id="2635" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们试着解析我们的TLV编码信息:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="7bae" class="ky kz it ku b gy la lb l lc ld">func main() {<br/>  // continuing from previous main(), redacted for brevity<br/>  // ...<br/>  reader := bytes.NewReader(buf.Bytes())<br/>  tlvReader := tlv.NewReader(reader, codec)<br/>  next, _ := tlvReader.Next()<br/>  fmt.Println("type:", next.Type)<br/>  fmt.Println("payload: ", string(next.Payload))</span><span id="01c1" class="ky kz it ku b gy lv lb l lc ld">}</span></pre><p id="bced" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它打印出:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="916a" class="ky kz it ku b gy la lb l lc ld">type: 8<br/>payload:  hello, go!</span></pre><p id="f034" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">万岁！我们设法将我们的TLV编码信息读回我们的<code class="fe le lf lg ku b">Record</code>！</p><p id="837f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们以波拉特的传统祝贺作为结束:</p><figure class="kp kq kr ks gt li"><div class="bz fp l di"><div class="lw lx l"/></div></figure></div></div>    
</body>
</html>