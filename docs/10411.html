<html>
<head>
<title>Flutter State Management: 2022 Edition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振状态管理:2022版</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-state-management-2022-edition-2580d8095f0b?source=collection_archive---------1-----------------------#2021-12-02">https://levelup.gitconnected.com/flutter-state-management-2022-edition-2580d8095f0b?source=collection_archive---------1-----------------------#2021-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0719e3ac71b7d04defb89e92757dc118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y-HAXNSkjZXqLwLlf2m2lg.png"/></div></div></figure><p id="fd6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">今天对我来说标志着又一个颤振年——我已经深入颤振社区近3年了(时间过得真快！)现在。</p><p id="0768" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你对我去年的建议感兴趣，请在这里随意阅读。</p><p id="5662" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将仔细检查我使用过的每个状态管理解决方案(我将在文章底部留下我没有使用或停止使用的解决方案的简短评论，并让您知道为什么),并写下它的优点和缺点——然后，您将看到评论并询问我的意见。</p><p id="f7bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">值得注意的是，你不必将自己局限于一种解决方案:我发现有些应用程序更容易使用，只需快速输入<code class="fe la lb lc ld b">Provider</code>，或者使用<code class="fe la lb lc ld b">setState</code>。其他的需要完全成熟的<code class="fe la lb lc ld b">Bloc</code>或者<code class="fe la lb lc ld b">Cubit</code>。我在这里的一般建议是，一旦你确定你需要状态，就从可行的最小状态管理解决方案开始:然后，慢慢地向上移动复杂性栈，直到你找到适合当前问题的解决方案。</p><p id="34a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对我来说，今年是“回归基础”的一年，经典的国家管理解决方案再次出现。以下是我对2022年州管理层的建议。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="67aa" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">设置状态</h1><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/bbfdaef209e03d14d4a9c6774a885526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AMBh46C1HDexCHMf.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">设置状态</figcaption></figure><p id="c01a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果每次有人告诉我<code class="fe la lb lc ld b">setState</code>不足以作为国家管理解决方案时，我都能得到一枚硬币…</p><p id="33ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事实是，对于大多数小型应用程序来说,<code class="fe la lb lc ld b">setState</code>可能是一个很好的状态管理解决方案——如果你是一个单独的开发者，你可能正在构建这些应用程序。我一直在学习函数式编程，OCaml很快成为我的首选脚本语言之一。</p><p id="d442" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">函数式编程的一个核心概念是不变性。按照这种思路，状态的存在实际上是负面的——理想情况下，我们拥有的状态越少，我们的应用程序就越容易管理和测试。</p><p id="8b83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也就是说，几乎不可能有一个无状态的现代应用程序:比方说，我们如何无状态地表示文本字段的内容？</p><p id="2173" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">(我知道你可以——在我看来，这只是多劳多得。)</p><p id="e037" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Flutter已经为<code class="fe la lb lc ld b">setState</code>设置好了——如果你将一个(原始)状态变量传递给一个子部件，那么这个子部件会重新构建。(记住这一点——这是我们首先引入状态管理解决方案的原因)但是，我们越是在本地保存状态，应用程序就越好，也越不复杂。一般来说，如果state是local，就使用<code class="fe la lb lc ld b">setState</code>！</p><p id="2695" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">易用性:</strong> ⭐⭐⭐⭐⭐</p><p id="9c70" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然状态不是一个容易理解的概念，但<code class="fe la lb lc ld b">setState</code>是迄今为止最简单的学习方法。</p><p id="5f6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">可伸缩性/可测试性:</strong> ⭐⭐</p><p id="9991" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你<em class="ms">可以</em>只使用<code class="fe la lb lc ld b">setState</code>来构建大规模的应用。仅仅因为你能做某事并不意味着你应该做。测试有点痛苦，因为您不能直接操纵起始状态，所以每次测试都需要一些开销。</p><p id="2cae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">样本: ⭐⭐⭐</p><p id="95ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一个可能会令人惊讶——这里有三颗星。将一个<code class="fe la lb lc ld b">StatelessWidget</code>转换成一个<code class="fe la lb lc ld b">StatefulWidget</code>会引入大量代码，并且会增加复杂性。我也不太喜欢<code class="fe la lb lc ld b">widget.&lt;prop&gt;</code>。</p><p id="3b81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">总体:</strong> ⭐⭐⭐</p><p id="2bfb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我发现我喜欢测试和编写<code class="fe la lb lc ld b">StatelessWidget</code> s，当我开始必须处理状态时，我更喜欢寻求不同的状态管理解决方案。我最大的项目总共有67个独特的小部件，其中57个是<code class="fe la lb lc ld b">StatelessWidget</code> s。</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/f24fb335c4c32ed70354d68429937f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*LCNfSNWQ0gZFtcptIb0lHw.png"/></div></figure><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/532008bf2084320c55c7e96fb15738a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*UV2QWOCYkWk8yzNwMCWKgg.png"/></div></figure><p id="53cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您的状态是本地化的，并且不会传递给多个小部件，请使用<code class="fe la lb lc ld b">setState</code>。比如动画，或者你在任何地方都可以使用的库部件。</p><p id="1d36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我正在构建一个玩具项目，我会将<code class="fe la lb lc ld b">setState</code>作为一个完整的解决方案。除此之外，我开始关注软件包——但是即使是我最大的应用程序也至少在某些地方使用<code class="fe la lb lc ld b">setState</code>。</p><h1 id="7242" class="ll lm it bd ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me mz mg mh mi bi translated"><strong class="ak">供应商</strong></h1><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/5199ff2dc66d19fb432cf68ad0dbfbba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bL8T5FmEdUEZKx94.png"/></div></div></figure><p id="1707" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我要第一个说，去年我确实给了他们很大的伤害。我认为这是一个多余的解决方案，覆盖了<code class="fe la lb lc ld b">InheritedWidget</code>已经做过的领域，没有任何新的东西。</p><p id="deed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我决定看看Bloc的依赖性——我惊讶地发现Bloc依赖于提供商！如果我决定在我的<code class="fe la lb lc ld b">pubspec.yaml</code>中添加Provider，我的大小不会增加，所以我继续将它添加到apps toolbart—<em class="ms">中，以防万一。</em></p><p id="9e04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">嗯——它并不太具有开创性。我肯定是正确的，它涵盖了与<code class="fe la lb lc ld b">InheritedWidget</code>相同的领域——他们做类似的事情，除了提供者有很多额外的，允许一些灵活性。</p><p id="3e15" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">提供商知识提供理想解决方案的一个地方是:</p><p id="5fc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面有一个块，提供了一个对象。那个物体是由一个低肘的建造者所依赖的。然而，cubit并不监视它的构造函数属性，所以每当对象改变时，cubit现在都会有该对象的旧版本。痛苦的调试——解决方案？<code class="fe la lb lc ld b">ProxyProvider</code>！</p><p id="93a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在其他情况下，提供商是一个简单的解决方案。也许你有一个引用相同属性的子树，你正在<a class="ae kz" href="http://InheritedWidget" rel="noopener ugc nofollow" target="_blank"> prop drilling </a>(一个从React借用的问题)。你可以建造一个完整的腕尺，但是当一个简单的<code class="fe la lb lc ld b">Provider</code>就足够了，你为什么要这样做呢？</p><p id="a4a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">易用性:</strong> ⭐⭐⭐⭐</p><p id="b307" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">提供商不是<code class="fe la lb lc ld b">setState</code>，但是很接近。有了<code class="fe la lb lc ld b">context.watch</code>，你节省了大量的时间，而且反应式的应用程序也能很好的工作<em class="ms">。</em>这是沿着小部件树提供值的最简单的方法。</p><p id="f4d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">可伸缩性/可测试性:</strong> ⭐⭐⭐</p><p id="1239" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">肯定比<code class="fe la lb lc ld b">setState</code>要好。但是提供商有它自己的一大堆问题——你把业务逻辑放在哪里？在小部件中，唯一的作用就是改变提供者的状态？也许吧，但是我更喜欢保持我的业务逻辑完全独立，这样它很容易测试。另外，<code class="fe la lb lc ld b">test</code>比<code class="fe la lb lc ld b">widgetTest</code>跑得快！</p><p id="01f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一个问题是沿着树向下提供相同的对象——您用较低的对象完全遮蔽了顶部的对象。</p><p id="6908" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它也比Bloc更难测试——但是我们可以注入依赖项，并且不需要测试提供者本身，所以你真的减少了样板文件。</p><p id="20ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">样板文件: ⭐⭐⭐⭐⭐</p><p id="2f46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">来自提供商的绝对五星。我甚至不知道大多数Bloc都是使用Provider构建的。迄今为止最简单的状态管理解决方案！大多数时候，集成一个提供者是完全不可能的。</p><p id="97b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">总体:</strong> ⭐⭐⭐⭐ + 0.5(无半星表情符号)</p><p id="ded6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当Bloc太大而<code class="fe la lb lc ld b">setState</code>太小时，这是一个很好的解决方案。我在很多地方都不用提供商。我的大多数特征文件夹里都有一个cubit或者一个bloc。但是，有时候，当我查看我的cubit时，会发现它是空的——它看起来像一个java类，只有getters和setters。在那里，我宁愿去找一个简单的供应商，避免所有的锅炉板。</p><h1 id="ac3b" class="ll lm it bd ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me mz mg mh mi bi translated">BLoC(和Cubit！)</h1><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/5ba180f6b61e43cfae6fc619514eb13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_AuwCOcOvRK6Vuzp.png"/></div></div></figure><p id="25d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我去年把我的集团板块命名为“集团(或肘？)”—区别在于运算符。这一次，我称之为集团<em class="ms">和</em>肘。</p><p id="c04d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我完全被丘比特迷住了。这实际上只是一个更好的集团，处理了一些集团憎恨者提出的问题:即大量的锅炉板。</p><p id="1573" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你以前没有讨论过这个问题，我来为你演示一下:Bloc是Flutter的FizzBuzzEnterprise，至少有5个(！) (每个块1个，抽象+具体事件，抽象+具体状态)类，以及<code class="fe la lb lc ld b">mapEventToState</code>中的大量样板文件。</p><p id="b223" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">后来Cubit出现了，完全去掉了<code class="fe la lb lc ld b">Event</code>类，去掉了<code class="fe la lb lc ld b">mapEventToState</code>，取而代之的是简单的函数调用。一开始我并没有被说服，因为我正好在“集团太复杂”的列车上。</p><p id="db20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，我很难找到合适的替代品:我真的很高兴我的业务逻辑从UI中抽象出来，并且非常容易测试，所以我不情愿地回到了Bloc的世界，并开始探索新的Cubit。</p><p id="24de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我真的很喜欢丘比特！这使得国家管理起来简单多了，但也减少了很多麻烦。当要求UI /逻辑分离时，只有这么多脂肪你可以修剪，直到你回到把你的逻辑放回UI。</p><p id="2af0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Bloc本身(如in，而不是cubit)从v8开始有了新的版本:<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/flutter-bloc-v8-0-is-here-and-will-change-the-way-you-handle-state-forever-72ddb4da9e1d">我不打算深入研究它，但是如果你感兴趣的话，我已经写了另一篇文章。</a>总之，Bloc并没有完全被Cubit掩盖，它仍然有自己的位置——在Bloc v8中，我们去掉了<code class="fe la lb lc ld b">mapEventToState</code>,以支持发射器，使Bloc本质上成为一个Cubit——只是用事件作为输入而不是函数调用，以及更多的可监控性等等。</p><p id="16cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">易用性:</strong> ⭐⭐</p><p id="ef47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里要学的东西很多，有点让人目不暇接。熟练的阻塞器会觉得这是第二天性，但是回头看看一些阻塞代码，这些代码实际上做了什么并不直观。</p><p id="0750" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更重要的是，bloc在幕后使用了provider，这意味着一旦您学习了Bloc，您就对provider有了一定的了解——所以这有点像必须同时学习两种状态管理解决方案的细微差别。</p><p id="a458" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">可伸缩性/可测试性:</strong> ⭐⭐⭐⭐⭐</p><p id="4689" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我一直向团队推荐Bloc。阻塞的缺点是需要编写大量的代码。好处是它保持有组织性，并且易于测试。对于工程师团队来说，这是一个完美的权衡，因为他们有更多的人手——而更多的代码通常意味着更细粒度的工作单元！</p><p id="835a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Blocs也非常擅长在项目中扩展。它们自然地有助于拥有“每个特性一个块”类型的架构，因此，您正走在一条阻力最小的道路上，允许您构建大型的、解耦的移动应用程序。如果你正在处理一个复杂的特性，那么Bloc就是状态管理之王。</p><p id="09ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">样板:</strong> ⭐⭐</p><p id="ecc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">丘比特在这方面做得非常好，但毫无疑问，Bloc是迄今为止最样板的。</p><p id="f677" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">总体:</strong> ⭐⭐⭐⭐ + 0.5</p><p id="ce63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与此处的提供商得分相同。Bloc擅长更复杂的特性，拥有大量的业务逻辑和存储库处理。它允许你将你的UI层与你的业务逻辑很好的分离，因此，对于一个相当复杂的应用程序，Bloc是我第一个快速的选择。</p><h2 id="53bb" class="nb lm it bd ln nc nd dn lr ne nf dp lv km ng nh lz kq ni nj md ku nk nl mh nm bi translated">其余的</h2><p id="d927" class="pw-post-body-paragraph kb kc it kd b ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky im bi translated">看看我的名单与去年相比有什么变化，这很有趣。这里有一些关于其他状态管理解决方案的简短段落。</p><p id="66ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您正在使用这些解决方案中的一种，那很好！我不会用你使用的任何解决方案来评判你的应用程序——如果它对你有用，那就是完美的:使用你的解决方案，并感到快乐。</p><p id="5973" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以上是我对其他一些国家管理方案的看法。</p><p id="7950" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> InheritedWidget: </strong>完全被提供者盖过，句号。如果你走这条路，几乎没有理由的样板。如果你正在构建一个非常小的应用程序，并且只需要提供一两个值，那么就选择<code class="fe la lb lc ld b">InheritedWidget</code>！否则，打开您的<code class="fe la lb lc ld b">pubspec.yaml</code>并添加提供商。</p><p id="e0db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> RiverPod: </strong> Riverpod还是很棒的。我仍然喜欢Riverpod，喜欢回到使用它的旧项目中去。它不再是街区里的新成员了，但是它确实仍然做着它承诺要做的事情。我想在RiverPod上花更多的时间，但是我太迷恋Bloc了，因此不认为在同一个项目中包含Bloc和Riverpod是可行的。如果你是新手并且渴望学习，Riverpod可能是你要去的地方！</p><p id="2fc5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> GetX: </strong>我试过GetX。我真的尽力了。对我来说，当一个图书馆试图做太多的事情时，这是一种厌恶。请把我的主题和电子邮件验证器分开！我更喜欢我的库做一件事，并且做得很好，我感觉GetX做了很多。我不知道为什么，但是我看到很多新开发人员被GetX吸引——也许这是新的亮点，而我正在变成一个老格林奇。</p><p id="f9f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">后两种观点自去年以来没有改变，所以我将它们复制并粘贴到下面:</p><p id="71c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">盒子上写着呢。get_it不是一个状态管理解决方案——但是人们一直把它当作一个状态管理解决方案来使用。如果用作状态管理解决方案，它会非常混乱，老实说，在文件中声明浮动变量可能会更好。</p><p id="2491" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> redux / fish_redux / mobx: </strong>这些都来自React，并且具有非常相似的风格——但是我认为很快就可以看出React和Flutter是两种不同但相似的野兽。这些工作，如果你习惯了，那么你可以使用它们，但是为Flutter设计的状态管理工作得最干净。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="fddd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原来如此！我的2022年州管理文章到此结束。有什么意见你认为我应该知道，或者你认为我做错了什么？给我和其他读者留言吧！</p></div></div>    
</body>
</html>