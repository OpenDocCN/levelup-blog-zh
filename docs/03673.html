<html>
<head>
<title>Comparing different ways to store data on the client-side with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较使用JavaScript在客户端存储数据的不同方式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/comparing-different-ways-to-store-data-on-the-client-side-with-javascript-37cde47ee003?source=collection_archive---------1-----------------------#2020-05-22">https://levelup.gitconnected.com/comparing-different-ways-to-store-data-on-the-client-side-with-javascript-37cde47ee003?source=collection_archive---------1-----------------------#2020-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0677" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从老式饼干到新的替代品。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/9b4723b92411daed1a5e50062b53c617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bGWXbmLWlJTfZZOqmM_ug.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">安东尼的磁带影像</figcaption></figure><p id="7201" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，浏览器支持不同的方式在用户的计算机上存储数据，然后在必要时检索数据，让您保存数据进行长期存储，保存用户特定的设置，保存网站供脱机使用，等等。客户端存储由JavaScript APIs组成，允许您在客户端存储不同类型的数据，然后在需要时检索这些数据。这篇文章描述了这些方法的基本原理。</p><h2 id="f2e6" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">索引</h2><ul class=""><li id="24d1" class="ly lz it js b jt ma jx mb kb mc kf md kj me kn mf mg mh mi bi translated">饼干</li><li id="d6f4" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">Web存储API(本地存储和会话存储)</li><li id="f56c" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">索引数据库</li><li id="8a5f" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">缓存存储</li></ul><h2 id="c2c9" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">饼干</h2><p id="5192" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">HTTP cookie或cookie只是数据，存储在计算机上的小文本文件中，它们是web上常用的客户端存储的最早形式。</p><p id="db02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Cookies是由网景通信公司的创始工程师Lou Montulli于1994年设计的，它使电子商务购物车成为可能。最初，cookies被所有支持的浏览器默认接受，很少有终端用户知道它们的存在会带来风险。</p><p id="37e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这是一项古老的技术，所以它有许多影响用户安全和隐私的问题。这些问题非常严重，以至于当您第一次访问一个网站时，您会收到一条警告消息，告知您是否允许它使用cookies来存储数据。</p><p id="d665" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种大量的安全问题和它无法存储复杂数据的能力使它不适合今天使用，特别是当有更好和更现代的方法来存储数据时。</p><h2 id="af77" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">Web存储API</h2><p id="468b" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">Web存储或DOM存储提供了用于存储客户端数据的web应用程序和API，支持持久数据存储，与cookies相当，但具有更好的编程接口、更大的容量(至少5MB)，并且没有信息存储在请求头中或传输到服务器。</p><p id="fc0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Web存储是基于源的(基于域和协议)。来自同一个源的所有页面可以存储和访问相同的数据。</p><p id="c511" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API" rel="noopener ugc nofollow" target="_blank">网络存储API </a>使用起来很简单。您存储简单的数据键值对，并在需要时检索这些值。</p><p id="689c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要存储对象，您必须将它们转换为字符串。为此，我们在传递给setItem()之前使用JSON.stringify()方法:</p><pre class="kp kq kr ks gt mr ms mt mu aw mv bi"><span id="096d" class="lf lg it ms b gy mw mx l my mz">const car = {<br/>    brand: "Ford",<br/>    model: "Sierra",<br/>}</span><span id="c035" class="lf lg it ms b gy na mx l my mz">window.localStorage.setItem('car', JSON.stringify(car));</span></pre><p id="d42c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要再次使用该值，您必须将其转换回对象:</p><pre class="kp kq kr ks gt mr ms mt mu aw mv bi"><span id="6688" class="lf lg it ms b gy mw mx l my mz">JSON.parse(window.localStorage.getItem('car'));<br/>//{brand: "Ford", model: "Sierra"}</span></pre><p id="afdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">浏览器中的两种结构包含两种主要的web存储类型:本地存储和会话存储。第一种方法在浏览器关闭然后重新打开后仍然保存数据，第二种方法在浏览器打开时保存数据。</p><p id="9c49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用localStorage的示例:</p><p id="93b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1:检查浏览器支持。<br/> 2:将值“Rick”存储在密钥名称中<br/> 3:通过关键字“name”检索值<br/> 4。如果您的浏览器不支持Web存储API，请记录一个错误。</p><p id="0209" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用以下代码创建一个exampleWebStorage.html文件，并使用浏览器打开它:</p><pre class="kp kq kr ks gt mr ms mt mu aw mv bi"><span id="afc9" class="lf lg it ms b gy mw mx l my mz">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;body&gt;</span><span id="5de1" class="lf lg it ms b gy na mx l my mz">&lt;h1&gt;Example using WebStorage (local-storage)&lt;/h1&gt;</span><span id="fb8c" class="lf lg it ms b gy na mx l my mz">&lt;script&gt;</span><span id="202c" class="lf lg it ms b gy na mx l my mz">//1<br/> if (typeof(Storage) !== "undefined") {</span><span id="16fd" class="lf lg it ms b gy na mx l my mz">//2<br/>  localStorage.setItem("name", "Rick");<br/> <br/>  //3 <br/>  console.log(localStorage.getItem("name"));<br/>  //Rick</span><span id="fbc7" class="lf lg it ms b gy na mx l my mz">}else{<br/>  //4   <br/>  console.log("your browser doesn’t support local storage!");    <br/>}</span><span id="36b4" class="lf lg it ms b gy na mx l my mz">&lt;/script&gt;</span><span id="1e19" class="lf lg it ms b gy na mx l my mz">&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="2a72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，如果你在chrome等现代浏览器中加载index.html文件，并在应用程序选项卡中打开开发工具，你可以看到你的键值“名称”存储在你的浏览器本地存储中:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nb"><img src="../Images/0e2b64c18bcd6f79ddc4adf3decd6cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7grR1r909pOJJVouAOwtWw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">DevTools应用程序选项卡</figcaption></figure><p id="2f31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，在控制台选项卡的开发工具中执行以下命令，从localStorage中删除“name”属性:</p><pre class="kp kq kr ks gt mr ms mt mu aw mv bi"><span id="8753" class="lf lg it ms b gy mw mx l my mz">localStorage.removeItem("name");</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nc"><img src="../Images/6a3703307db70c32e1390b41c7efc430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ue27hCF-IR0a0V5TSXBxQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">开发工具控制台选项卡</figcaption></figure><p id="ca8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后的结果是:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nd"><img src="../Images/48d5b454eccdb257775f81a5e23d5f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YL3XopCIlFlG3_8pKQLbJw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">DevTools应用程序选项卡</figcaption></figure><p id="5fa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">sessionStorage对象等效于localStorage对象，但它只存储一个会话的数据，当用户关闭浏览器选项卡时，数据将被删除。</p><p id="9626" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您使用npm或另一个依赖项管理器，您可以使用构建在Web存储API之上的许多库中的一个，它为我们使用Web存储提供了有用的帮助方法。</p><h2 id="0646" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">索引数据库</h2><p id="ae55" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">IndexedDB是一个NoSQL数据库(基本上是一个简单的平面文件数据库)，您可以在所有现代浏览器上使用它来存储“无限”数量的数据，并像在NoSql数据库中一样进行查询。(如果要用SQL，就不能用IndexDB。)</p><p id="7622" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之前我们有WebSQL，一个围绕着<a class="ae le" href="https://www.sqlite.org/index.html" rel="noopener ugc nofollow" target="_blank"> SQLite </a>的包装器，但是现在这个已经被弃用，并且在一些现代浏览器上不受支持。此外，它从来都不是一个公认的标准，所以它不应该被使用。</p><p id="2106" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在IndexDB中，一个数据库对于一个域是私有的，因此任何其他站点都不能访问其他IndexedDB存储。IndexDB支持事务和版本控制，他的API大部分是异步的，这意味着进行昂贵的操作不会阻塞UI线程，从而给用户带来糟糕的体验。</p><p id="2d65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">IndexDB使用商店的概念。一个存储区包含几个具有唯一键的项目，该键表示可以识别一个对象的方式。</p><p id="1a43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的商场，我们可以使用一组数据，如:</p><ul class=""><li id="0c7f" class="ly lz it js b jt ju jx jy kb ne kf nf kj ng kn mf mg mh mi bi translated">数字</li><li id="46c6" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">线</li><li id="c8f8" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">目标</li><li id="3cda" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">数组</li><li id="d6c0" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">日期</li></ul><p id="7e9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一个例子。用下面的代码创建一个exampleIndexDB.html文件(或者你想要的任何名字),并用你的浏览器打开它:</p><p id="3c6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nh">注意，我们使用事件监听器，因为IndexedDB使用异步API。</em></p><pre class="kp kq kr ks gt mr ms mt mu aw mv bi"><span id="5a7e" class="lf lg it ms b gy mw mx l my mz">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;body&gt;</span><span id="5b12" class="lf lg it ms b gy na mx l my mz">&lt;h1&gt;Example using IndexDB&lt;/h1&gt;</span><span id="f099" class="lf lg it ms b gy na mx l my mz">&lt;div id="divId"&gt;&lt;/id&gt;</span><span id="165c" class="lf lg it ms b gy na mx l my mz">&lt;script&gt;<br/>let myRId= document.getElementById('myResultId');<br/>let i = 0;<br/>const versionDB = 1;</span><span id="96e7" class="lf lg it ms b gy na mx l my mz">//1<br/>let indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB;</span><span id="c084" class="lf lg it ms b gy na mx l my mz">//2<br/>var open = indexedDB.open("CarDatabase", versionDB);</span><span id="a457" class="lf lg it ms b gy na mx l my mz">//3<br/>open.onupgradeneeded = function(){<br/> let db = open.result;<br/> let store = db.createObjectStore("CarsTable", {keyPath: "id"});<br/> let index = store.createIndex("CIndex", ["brand", "model"]);<br/>};</span><span id="4aef" class="lf lg it ms b gy na mx l my mz">//4<br/>open.onsuccess = function(){</span><span id="4c61" class="lf lg it ms b gy na mx l my mz">//5<br/> let db = open.result;</span><span id="e976" class="lf lg it ms b gy na mx l my mz">//6<br/> let tx = db.transaction("CarsTable", "readwrite");</span><span id="7e9e" class="lf lg it ms b gy na mx l my mz">//7<br/> let store = tx.objectStore("CarsTable");</span><span id="3424" class="lf lg it ms b gy na mx l my mz">//8  <br/> let index = store.index("CIndex");</span><span id="060a" class="lf lg it ms b gy na mx l my mz">//9<br/> store.put({id: 1, brand: "Ford", model: "Sierra"});<br/> store.put({id: 2, brand: "Mercedes", model: "500"});<br/> <br/> //10<br/> let getAll = store.getAll();</span><span id="364f" class="lf lg it ms b gy na mx l my mz">getAll.onsuccess = function(){<br/>  for(i=0; i&lt;getAll.result.length ;i++)<br/>    divId.innerHTML += getAll.result[i].brand+"- <br/>    "+getAll.result[i].model+<br/>    " &lt;br&gt;";<br/> }</span><span id="aae5" class="lf lg it ms b gy na mx l my mz">//11 <br/> tx.oncomplete = function(){<br/>  db.close();<br/> };</span><span id="4742" class="lf lg it ms b gy na mx l my mz">}</span><span id="6a0c" class="lf lg it ms b gy na mx l my mz">&lt;/script&gt;</span><span id="94e1" class="lf lg it ms b gy na mx l my mz">&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><ol class=""><li id="0e7d" class="ly lz it js b jt ju jx jy kb ne kf nf kj ng kn ni mg mh mi bi translated">获取indexDB。我们包括您想要测试的实现的前缀。</li><li id="2ffc" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn ni mg mh mi bi translated">我们在版本1中打开一个名为CarDatabase的数据库，并返回一个对数据库的请求(异步请求)。</li><li id="dbd5" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn ni mg mh mi bi translated"><em class="nh"> IDBOpenDBRequest </em>接口的“onupgradeneeded”属性是“upgradeneeded”事件的事件处理程序，当加载版本号大于现有存储数据库的数据库时触发。</li><li id="2e35" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn ni mg mh mi bi translated"><em class="nh"> IDBRequest </em>接口的“onsuccess”事件处理程序处理成功事件，该事件在请求的结果成功返回时触发。</li><li id="344c" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn ni mg mh mi bi translated">启动一个事务并进行读取操作。</li><li id="1780" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn ni mg mh mi bi translated">对于只读属性，如果请求失败并且结果不可用，则抛出<em class="nh"> InvalidStateError </em>异常。</li><li id="55f7" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn ni mg mh mi bi translated"><em class="nh"> IDBTransaction </em>接口的objectStore()方法返回一个已经添加到该事务范围的Store对象。</li><li id="6ebc" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn ni mg mh mi bi translated"><em class="nh">idbobobjectstore</em>接口的index()方法在当前对象存储中创建一个命名索引。</li><li id="1aea" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn ni mg mh mi bi translated">补充一些数据。</li><li id="e0ca" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn ni mg mh mi bi translated">查询以获取所有数据。</li><li id="66d2" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn ni mg mh mi bi translated"><em class="nh"> IDBTransaction </em>接口的“oncomplete”事件处理程序处理完成事件，该事件在事务完成时触发。</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/d9be280309773f8afa84e884b2b447cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FLBjAICwxDHby1mS5wgBw.png"/></div></div></figure><p id="7223" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过id从数据库中删除记录:</p><pre class="kp kq kr ks gt mr ms mt mu aw mv bi"><span id="7846" class="lf lg it ms b gy mw mx l my mz">store.delete(2);</span></pre><h1 id="d7c2" class="nk lg it bd lh nl nm nn lk no np nq ln nr ns nt lq nu nv nw lt nx ny nz lw oa bi translated">缓存存储</h1><p id="d7b0" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">CacheStorage是浏览器中使用的一种存储机制，用于存储和检索网络请求-响应，不应与浏览器缓存混淆。它保存了一对请求和响应对象——请求作为键，响应作为值。</p><p id="f910" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然我们习惯于将CacheStorage与服务工作者联系起来，但是CacheStorage并不是服务工作者API。尽管如此，它使服务人员能够缓存网络请求-响应，以便在用户没有连接时提供离线功能。</p><p id="5675" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">CacheStorage也可以在DOM中用作存储工具。</p><p id="808e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一个在DOM中使用CacheStorage的例子。用下面的代码创建一个exampleCS.html文件(或者你想要的任何名字),并用你的浏览器打开它:</p><pre class="kp kq kr ks gt mr ms mt mu aw mv bi"><span id="166f" class="lf lg it ms b gy mw mx l my mz">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;body&gt;</span><span id="e8c9" class="lf lg it ms b gy na mx l my mz">&lt;h1&gt;Example using WebStorage (local-storage)&lt;/h1&gt;</span><span id="013f" class="lf lg it ms b gy na mx l my mz">&lt;script&gt;</span><span id="6daa" class="lf lg it ms b gy na mx l my mz"><strong class="ms iu">const CACHE_NAME = 'myCache’;</strong></span><span id="cdd5" class="lf lg it ms b gy na mx l my mz">//1<br/> if ('caches' in window) {</span><span id="7d41" class="lf lg it ms b gy na mx l my mz">//2<br/>  caches.open(CACHE_NAME).then((cache) =&gt; {<br/>     <br/>    console.log("Cached created");<br/>      <br/>    //3  <br/>    cache.add("Character", { name: "Rick", lastName: "grimes"   <br/>    }).then( () =&gt; console.log("character added"));</span><span id="ed94" class="lf lg it ms b gy na mx l my mz">}).catch((err) =&gt; {<br/>      //error<br/>  })</span><span id="f1d5" class="lf lg it ms b gy na mx l my mz">}&lt;/script&gt;</span><span id="a20d" class="lf lg it ms b gy na mx l my mz">&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><ol class=""><li id="f7b1" class="ly lz it js b jt ju jx jy kb ne kf nf kj ng kn ni mg mh mi bi translated">检查浏览器支持。</li><li id="43f1" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn ni mg mh mi bi translated">我们使用带有缓存名称的“open”方法在缓存列表中搜索缓存名称。如果缓存存在，则返回引用缓存名称的缓存，否则创建新的缓存。</li><li id="af95" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn ni mg mh mi bi translated">向缓存中添加一个条目。</li></ol><p id="5cf0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重试缓存中的条目:</p><pre class="kp kq kr ks gt mr ms mt mu aw mv bi"><span id="18e9" class="lf lg it ms b gy mw mx l my mz">function get(cacheName, entry) {<br/>  return window.caches.open(cacheName).then(function(cache) {<br/>    return cache.match(entry);<br/>  });<br/>}</span></pre><p id="a3bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从缓存中删除条目:</p><pre class="kp kq kr ks gt mr ms mt mu aw mv bi"><span id="958c" class="lf lg it ms b gy mw mx l my mz">function remove(cacheName, entry) {<br/>  return window.caches.open(cacheName).then(function(cache) {<br/>    return cache.delete(entry);<br/>  });<br/>}</span><span id="9bcc" class="lf lg it ms b gy na mx l my mz">remove("Rirck");</span></pre><h2 id="2171" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">结论</h2><p id="92db" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">在这篇短文中，我们回顾了在客户端持久化数据的最常见方式。正如我们在不同的例子中看到的，所有形式的缓存都非常容易使用，但是在indexDB和CacheStorage中，存储限制更大。</p><p id="1fd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用会话存储，数据仅在页面会话期间可用，但在其他情况下，数据会一直存在，直到被显式删除。最后，这完全取决于你需要什么。对于不需要存储大量数据的简单事情，使用Web Storage API可能已经足够了，但在其他情况下，可能需要使用IndexDB。</p><p id="5492" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管您可以在DOM中使用CacheStorage，但是它也可以用于服务工作者。相反，web工作人员或服务工作人员无法访问LocalStorage/SessionStorage。</p><h2 id="d1f6" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">参考</h2><div class="ob oc gp gr od oe"><a href="https://developer.mozilla.org/" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">MDN Web文档</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">MDN Web Docs站点提供了关于开放Web技术的信息，包括HTML、CSS和用于这两个网站的APIs</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">developer.mozilla.org</p></div></div><div class="on l"><div class="oo l op oq or on os ky oe"/></div></div></a></div><p id="0b6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢你阅读我的文章，照顾好自己！</p></div></div>    
</body>
</html>