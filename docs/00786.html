<html>
<head>
<title>Design Patterns — Singleton</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式—单例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-singleton-4476879ea1b0?source=collection_archive---------2-----------------------#2019-07-29">https://levelup.gitconnected.com/design-patterns-singleton-4476879ea1b0?source=collection_archive---------2-----------------------#2019-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="c90e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">带有Singleton的全局接入点</h1><p id="d9ea" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">假设你管理着一个大型银行系统。银行需要交易的安全性和所有可能发生的系统错误的可追溯性。在这个系统中，有一个单独的类负责写日志(日志用于记录系统中所做的事情)。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/dad521cd29a32081117bd02a8702784f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fYMSdQH1RJdSOhPBeLiAw.png"/></div></div></figure><p id="af7a" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">在每个操作中，也就是说，在系统上执行的几乎所有操作，都会用各种信息写入一个日志。然而，随着用户数量的增加，系统开始遇到性能问题。所有用户都不断抱怨速度太慢。</p><p id="5a09" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">这个问题的原因之一是，每次我们需要写日志时，我们必须再次实例化这个类；每个新实例都会占用一个服务器内存空间。因为系统接收了相当多的并发用户，最终将系统的物理内存使用推到了极限。</p><p id="55ba" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">在得出大量日志类实例是性能问题的主要原因的结论后，需要减少现有并发实例的数量。如果您可以实例化这个日志对象一次，并在整个系统运行时(计算机程序保持运行的时期)共享它，我们将解决这个问题；这就是单例模式的由来。</p><h1 id="2e4d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">独生子女标准</h1><h2 id="0f04" class="md jr it bd js me mf dn jw mg mh dp ka kz mi mj ke ld mk ml ki lh mm mn km mo bi translated">定义</h2><p id="1df3" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">就像前面提到的银行系统问题一样，我们有一个应用程序性能问题，因为我们有一个类的大量实例——随着对服务器的每个请求同时创建——我们需要对一个类的不受控制的实例的创建进行更好的控制。</p><p id="16bc" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">Singleton旨在确保这种控制，管理为给定类创建的实例数量，并在单个全局访问点上集中创建这些对象(可以从系统中的任何地方访问)。</p><p id="b2fe" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">互联网上有几个单例实现的例子，其中主类控制其他类的实例。然而，这并不能保证对一个类的实例的实际控制，因为不知情的开发人员可能会忽略Singleton类(它控制实例的创建)并创建新的对象，要么是因为他们不知道它们的存在，要么是因为不想使用它们。</p><p id="2bdb" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">正确的是，遵循这种设计模式的类控制它自己的实例的创建，所以不可能创建它的实例。限制创建类本身的新实例的方法因语言而异。我们将看到用PHP 7+实现这一点的所有步骤。</p><h2 id="862b" class="md jr it bd js me mf dn jw mg mh dp ka kz mi mj ke ld mk ml ki lh mm mn km mo bi translated">Singleton，反模式</h2><blockquote class="mp mq mr"><p id="62de" class="ko kp ms kq b kr ly kt ku kv lz kx ky mt ma lb lc mu mb lf lg mv mc lj lk ll im bi translated">对于许多人来说，单例模式被认为是一种反模式，因为它以静态形式使用(调用类而不必实例化它)，尤其是通过对类实例的全局访问。使用静态类的问题很多:我们不能使用接口，我们的代码耦合性更高，等等。</p><p id="306e" class="ko kp ms kq b kr ly kt ku kv lz kx ky mt ma lb lc mu mb lf lg mv mc lj lk ll im bi translated">我们也有与实例变量的全局访问相关的问题。这使得人们很难理解为什么变量不直接与特定的系统范围相关联。我们还面临着这样的风险，即在系统中的任何一点可以改变的变量都会影响到其他部分。</p></blockquote><p id="e8e4" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">尽管有这些缺点，任何标准的应用都应该根据实际需要来衡量。在Singleton的情况下，如果需要对共享资源进行同步访问控制，或者如果我们确实需要一个实例，就需要使用Singleton。</p><h2 id="fd59" class="md jr it bd js me mf dn jw mg mh dp ka kz mi mj ke ld mk ml ki lh mm mn km mo bi translated">类图</h2><p id="eab4" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面是根据我们的例子的单例模式类图:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/706822f83d00cba028ba61073d475290.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*glNneNPTG8oMfoql56akmw.png"/></div></figure><h2 id="aecd" class="md jr it bd js me mf dn jw mg mh dp ka kz mi mj ke ld mk ml ki lh mm mn km mo bi translated">单一元素的元素</h2><p id="da83" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Singleton是一个类，负责控制自身实例的创建，并允许在整个应用程序中全局访问这些实例。这不同于稍后将会看到的Adapter，因为它由单个元素组成。</p><h1 id="ea1c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">用单个实例解决日志问题</h1><p id="f137" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在下面的例子中，我们将编写负责解决银行系统多实例问题的代码。这个想法是创建一个将日志写入文本文件的类。每次出现日志时，该日志将被写入文件。</p><p id="feda" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">这个类将遵循单例模式，无论使用多少次，都只允许创建一个实例。在下面的代码中，我们将开始构建LogsSingleton类，它将是我们模式的基础。我建议您创建一个名为singleton的文件夹，并将所有文件插入其中进行测试。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8284d22a468633edb6e55380d3e49c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*XrmYusF7PX3jPnRpBMh1ew.png"/></div></figure><p id="5799" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">第一点是创建<em class="ms"> $instance </em> (attribute)属性，它将存储类的单个实例。从示例中可以看出，属性已经设置为static，因为将实例存储在静态属性中确保了类实例所在的单点。</p><p id="0c18" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">该属性已被设置为受保护的隐私级别。通过这种方式，我们无法从外部直接访问它。</p><p id="e93c" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">如前所述，我们将把日志存储在一个文本文件中，文件名为<em class="ms"> logs.txt </em>，数据为JSON格式。这种格式是跨系统存储和交换数据的简单结构，允许您以结构化的方式组织信息，甚至定义数据类型。</p><p id="0843" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">我们还需要调用将日志记录到文本文件的方法。让我们看看它会是什么样子，记住<em class="ms"> recordLog() </em>方法应该在您之前创建的<em class="ms"> LogsSingleton() </em>类中。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi my"><img src="../Images/7e2abd8b5b6d3589a351b943870525fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*xpW0eQksgz50wHCQ4NxWeQ.png"/></div></div></figure><p id="ae51" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated"><em class="ms"> recordLog() </em>方法接受数组类型的参数(<em class="ms"> $data </em>)。在这个参数中，我们将接收要写入文本文件的数据。</p><p id="0136" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">在下面的代码中，我们将<em class="ms"> $previousLogs </em>变量声明为空数组(如果日志文件为空，这将避免错误)。然后，使用<em class="ms"> filesize() </em>方法，我们检查文本文件中是否存储了任何内容；如果大小大于零，则内部有数据(日志)。</p><p id="b29f" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">我们将从PHP的本机<em class="ms"> file_get_contents() </em>函数中获取内容，然后用<em class="ms"> json_decode() </em>函数将该内容(以JSON格式存储)转换成一个数组。最后，如果文件中没有内容，变量<em class="ms"> $previousLogs </em>将包含一个空数组，或者一个包含以前在其他运行中写入的日志的数组。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/421604d51fc8c9a22cfb75a482192694.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*J2fUyxRqwZhdTZAovDKV9g.png"/></div></figure><p id="9f5a" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">在代码<em class="ms">中，$ previous logs[]= $ data；</em>我们正在增加日志数组并添加新日志，即使它是空的或已经包含日志。我们打开文本文件，这样我们就可以在行<em class="ms"> $file = fopen ($ filename，' w ')中再次键入文本；</em>。</p><p id="1306" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">然后我们把JSON写到文本文件，fwrite code <em class="ms"> ($file，JSON _ encode($ previous logs))；</em><em class="ms">JSON _ encode()</em>函数将日志数组转换成以下格式的文本。最后，我们调用函数<em class="ms"> fclose() </em>，负责关闭已经打开进行写入的文件。</p><p id="3fed" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">到目前为止，我们已经构建了一个可以将日志写入文本文件的类，并且有一个静态的全局变量来存储它自己的实例。但是，我们需要控制这个实例，所以让我们为此创建一个方法:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/6d093c1a25fe20c4c51945026fe9437c.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*rQP2td2woqxUCgKUJQ08Lg.png"/></div></figure><p id="9709" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">像<em class="ms"> $instance </em>属性一样，<em class="ms"> obtainInstance() </em>方法也是静态声明的。让我们调用它来请求一个新的实例(不实例化log类)，只有这个方法将具有对$ instance属性的外部访问。</p><p id="a660" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">在它里面的第一行，if，我们用比较结果<em class="ms"> empty(self::$instance)验证<em class="ms"> $instance </em>是否为空。</em>如果是，这意味着还没有创建日志类<em class="ms"> LogsSingleton() </em>的实例；如果这个条件成立，那么我们实例化这个类，用代码<em class="ms">self::$ instance = new self()；</em>。New <em class="ms"> self() </em>将与new <em class="ms"> LogsSingleton() </em>相同，但是由于它在类本身内部，我们可以这样使用它。</p><p id="1298" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">最后，用return<em class="ms">self::$ instance；我们总是返回类本身的实例。第一次调用它时，它总是在if内部传递并实例化该类，但在其他时候，它只会返回以前创建的实例。</em></p><p id="9e66" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">现在，我问你，如果我们执行下面的代码会发生什么？</p><pre class="ln lo lp lq gt nb nc nd ne aw nf bi"><span id="9214" class="md jr it nc b gy ng nh l ni nj">$ InstanceLogs = new LogsSingleton ();</span></pre><p id="c969" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">与预期相反，代码会起作用，我们会有一个新的LogsSingleton实例。这不符合提议的单一/受控实例。为了避免这种意外行为，我们必须声明具有私有类型可见性的类构造函数方法:</p><pre class="ln lo lp lq gt nb nc nd ne aw nf bi"><span id="793e" class="md jr it nc b gy ng nh l ni nj">private function __construct () {}</span></pre><p id="7a5c" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">因此，有了新的<em class="ms"> LogsSingleton() </em>，我们只能通过调用<em class="ms"> obtainInstance() </em>方法来获取类实例。除了private构造函数之外，PHP中还有其他特定的方法允许您获取类的新实例，并且所有方法都必须声明为private，如下所示:</p><pre class="ln lo lp lq gt nb nc nd ne aw nf bi"><span id="a5ef" class="md jr it nc b gy ng nh l ni nj">private function __clone () {}</span></pre><p id="1146" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">因此，我们避免创建<em class="ms"> LogsSingleton() </em>类的新实例。通过到目前为止开发的代码，我们已经有了单例标准的完整实现。</p><h2 id="9e89" class="md jr it bd js me mf dn jw mg mh dp ka kz mi mj ke ld mk ml ki lh mm mn km mo bi translated">神奇的方法</h2><blockquote class="mp mq mr"><p id="3c1c" class="ko kp ms kq b kr ly kt ku kv lz kx ky mt ma lb lc mu mb lf lg mv mc lj lk ll im bi translated">agic方法是PHP 5中可用的函数。它们是在PHP开始向面向对象发展时创建的。它们可以通过以__开头来识别，并且每个都有特定的功能，例如__construct，用作类构造函数，或者__toString(类似于Java)，在尝试打印对象(将其转换为字符串)时调用。</p></blockquote><p id="31ab" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">为了测试这个类，让我们创建一个index.php文件并插入以下代码:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/35cdb818a9b355afdb29fc07a11cdf01.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*ffAT6CgrwaYW-g8VvM4leg.png"/></div></figure><p id="65de" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">无论是第一次还是第二次运行<em class="ms">LogsSingleton::obtain instance()</em>，该方法都会返回相同的实例。不仅值相同，而且两个变量(<em class="ms"> $instance </em>和<em class="ms"> $newInstance </em>)都将指向相同的内存地址。</p><p id="22c2" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">比较结果<em class="ms">$ instance = = = $ new instance</em>为真，我们应该看到消息“实例完全相同！”。</p><h1 id="4219" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="74d2" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">除了给出的示例日志类之外，另一个非常常见的情况是数据库连接类的实例。这些类通常在整个系统中使用。</p><p id="a88c" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">同样值得注意的是，在一些实现中，Singleton类允许多个实例。但是，它始终是一个有限的、受控的数字，仍然符合模式。</p><p id="f8df" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">尽管它的所有缺点导致开发人员将Singleton视为反模式，但了解它的操作和用途仍然是有效的。</p><h2 id="9ad9" class="md jr it bd js me mf dn jw mg mh dp ka kz mi mj ke ld mk ml ki lh mm mn km mo bi translated">知识库和参考资料</h2><p id="d2ac" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Github代码库:<a class="ae nl" href="https://github.com/cesarkohl/design-patterns" rel="noopener ugc nofollow" target="_blank">https://github.com/augustkohl/design-patterns</a></p><p id="48b6" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">编程Python:强大的面向对象编程。2011.</p><p id="09c0" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">面向对象的思维过程。艾迪森-卫斯理专业，2019。</p><p id="abe0" class="pw-post-body-paragraph ko kp it kq b kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll im bi translated">伽马，e；赫尔姆河；设计模式:可重用面向对象软件的要素。艾迪森-韦斯利专业版，1994年。</p></div></div>    
</body>
</html>