<html>
<head>
<title>Dynamic Channels for Video Chat Using Agora RTM on React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Native上使用Agora RTM进行视频聊天的动态频道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dynamic-channels-for-video-chat-using-agora-rtm-on-react-native-8ea18addae2b?source=collection_archive---------4-----------------------#2021-03-22">https://levelup.gitconnected.com/dynamic-channels-for-video-chat-using-agora-rtm-on-react-native-8ea18addae2b?source=collection_archive---------4-----------------------#2021-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e9b1b5c9d4558e4e8c498a06400c7c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTo0GfZHFaCLxw1jHachnw.jpeg"/></div></div></figure><p id="7019" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Agora RTC(实时通信)SDK使在React Native上构建视频聊天应用变得非常容易。我们可以让多个用户在视频聊天室中使用同一个频道名称进行交流。</p><p id="a971" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您正在构建一个社交视频聊天应用程序，您可能希望让您的用户创建其他用户可以浏览、加入和交流的房间。您可以使用后端服务器来处理这些请求，并向其他用户更新关于已创建房间的信息，但这将涉及编写后端代码和托管您自己的服务器。</p><p id="8db4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将看到通过使用Agora RTM(实时消息传递)SDK实现相同目标的另一种方法。我们将使用用户发送的消息来交流动态视频聊天室的创建和更新，所有这些都使用前端代码。</p><p id="41fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这非常方便，因为当您不想构建后端服务器时，可以使用消息向其他用户更新房间的状态。这种方法可以很容易地扩展到拥有完全管理的房间，以及像管理员允许/拒绝用户、静音另一个用户和从房间中删除用户这样的功能。</p><p id="e352" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我们将使用<a class="ae kw" href="https://www.npmjs.com/package/react-native-agora/" rel="noopener ugc nofollow" target="_blank"> Agora RTC SDK </a>和<a class="ae kw" href="https://www.npmjs.com/package/agora-react-native-rtm" rel="noopener ugc nofollow" target="_blank"> Agora RTM SDK </a>进行React Native。在撰写本文时，我使用的是RTC SDK的v3.2.2和RTM SDK的v 1 . 2 . 2-α3。</p><h1 id="ca5e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">项目概述</h1><ul class=""><li id="3456" class="lv lw iq ka b kb lx kf ly kj lz kn ma kr mb kv mc md me mf bi translated">我们有一个称为“大厅”的RTM房间。当有人创建了一个新房间或者房间中的成员发生变化时，我们将使用它来通知用户。</li><li id="66e6" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated">我们的方法是让视频聊天室中最资深的成员给其他人发送消息。房间里年龄最大的成员被认为是资深成员，稍后会详细介绍。</li><li id="c93c" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated">我们将以“roomName:memberCount”的形式发送消息，其他用户可以处理这些消息，将房间名称和成员计数作为字典存储在他们的应用程序状态中。我们将使用它来呈现一个包含成员数量的房间列表。</li><li id="71ea" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated">一旦我们有了列表，我们就可以使用RTC SDK加入房间。我们还需要监听用户的加入和离开，以更新其他人的成员数。这仅由高级成员完成，以避免开销。</li><li id="7a74" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated">我们还需要考虑两种情况来为其他用户更新房间信息。首先，当新用户加入大厅时，每个通道中级别最高的成员会向该用户发送一条对等消息。第二，当频道的成员数更新时，我们向连接到大厅的所有用户发送频道消息，以更新他们的房间列表。</li></ul><h1 id="c91d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建Agora帐户</h1><p id="1ce1" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated"><a class="ae kw" href="https://sso.agora.io/en/signup?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=dynamic-channels-for-video-chat-using-agora-rtm-on-react-native" rel="noopener ugc nofollow" target="_blank">注册</a>账户并登录仪表板。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/470feb99e4e02dbc30b1e8d7a4a7a0fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*YFtAcuBfRmPXr8DGEA79SA.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">网站上的项目管理选项卡</figcaption></figure><p id="6c67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">导航到“项目管理”选项卡下的“项目列表”选项卡，并通过单击蓝色的“创建”按钮来创建项目。(当系统提示使用应用ID +证书时，请仅选择应用ID。)在您开发应用程序时，应用程序ID将用于授权您的请求，而不会生成令牌。将应用ID复制到安全的地方，我们稍后会用到它。</p><p id="551a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mx">注意:</em>本指南不实施令牌认证，建议在生产环境中运行的所有RTE应用程序都实施令牌认证。有关Agora平台中基于令牌的认证的更多信息，请参见<a class="ae kw" href="https://docs.agora.io/en/Video/token?platform=All%20Platforms" rel="noopener ugc nofollow" target="_blank">https://docs.agora.io/en/Video/token?平台=所有% 20平台</a>。</p><h1 id="7428" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">下载源代码</h1><p id="d0b3" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">如果你喜欢，你可以跳到代码。代码是开源的，可以在<a class="ae kw" href="https://github.com/EkaanshArora/Agora-Dynamic-VideoChat-Rooms" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。要亲自尝试，请参阅自述文件，了解如何运行该应用程序的步骤。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/a29ec4f8a2957decca7a0d60c8e4de51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2lAf3cd44aDRrr-2T5Xv7Q.jpeg"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">安卓模拟器上运行的应用截图</figcaption></figure><h1 id="1b22" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们示例的结构</h1><p id="c64e" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">这是我们正在构建的应用程序的结构:</p><pre class="mp mq mr ms gt mz na nb nc aw nd bi"><span id="3631" class="ne ky iq na b gy nf ng l nh ni"><strong class="na ir">.</strong><br/>├── android<br/>├── components<br/>│ └── <strong class="na ir">Permission.ts</strong><br/>│ └── <strong class="na ir">Style.ts</strong><br/>├── ios<br/>├── <strong class="na ir">App.tsx<br/>.</strong></span></pre><h2 id="df90" class="ne ky iq bd kz nj nk dn ld nl nm dp lh kj nn no ll kn np nq lp kr nr ns lt nt bi translated">App.tsx</h2><p id="f479" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">App.tsx将成为应用的入口。我们将所有的代码都放在这个文件中。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7528" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从编写导入语句开始。接下来，我们为应用程序状态定义一个包含以下内容的接口:</p><ul class=""><li id="9a98" class="lv lw iq ka b kb kc kf kg kj nw kn nx kr ny kv mc md me mf bi translated"><code class="fe nz oa ob na b"><strong class="ka ir">appId</strong></code>:我们的Agora应用ID</li><li id="5e60" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated"><code class="fe nz oa ob na b"><strong class="ka ir">token</strong></code>:生成加入通道的令牌</li><li id="07d6" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated"><code class="fe nz oa ob na b"><strong class="ka ir">inCall</strong></code> <strong class="ka ir"> : </strong>当我们在一个活跃的视频聊天室时存储的布尔值</li><li id="ca28" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated"><code class="fe nz oa ob na b"><strong class="ka ir">inLobby</strong></code> <strong class="ka ir"> : </strong>如果我们在大厅，布尔型要存储</li><li id="8e7e" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated"><code class="fe nz oa ob na b"><strong class="ka ir">input</strong></code> <strong class="ka ir"> : </strong>创建新房间时输入的存储字符串</li><li id="b740" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated"><code class="fe nz oa ob na b"><strong class="ka ir">peerIdsRTC</strong></code>:存放视频聊天室其他用户RTC UIDs的数组</li><li id="5104" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated"><code class="fe nz oa ob na b"><strong class="ka ir">seniors</strong></code> <strong class="ka ir"> : </strong>存储在我们之前加入视频聊天室的RTM成员的数组</li><li id="de15" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated"><code class="fe nz oa ob na b"><strong class="ka ir">myUsername</strong></code>:登录RTM的本地用户名</li><li id="c134" class="lv lw iq ka b kb mg kf mh kj mi kn mj kr mk kv mc md me mf bi translated"><code class="fe nz oa ob na b"><strong class="ka ir">rooms</strong></code> <strong class="ka ir"> : </strong>存储房间名称及其成员数的字典</li></ul><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="18f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们定义了一个基于类的组件:<code class="fe nz oa ob na b">_rtcEngine</code>变量将存储RtcEngine类的实例，<code class="fe nz oa ob na b">_rtmEngine</code>变量将存储RtmEngine类的实例，我们可以用它来访问SDK函数。</p><p id="25e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在构造函数中，我们设置状态变量并请求在Android上录制音频的权限。(我们使用来自<code class="fe nz oa ob na b">permission.ts</code>的一个助手函数，如下所述。)当组件被挂载时，我们调用<code class="fe nz oa ob na b">initRTC</code> <strong class="ka ir"> </strong>和<code class="fe nz oa ob na b">initRTM</code>函数，这些函数使用App ID初始化RTC和RTM引擎。当组件卸载时，我们销毁我们的引擎实例。</p><h2 id="bf6a" class="ne ky iq bd kz nj nk dn ld nl nm dp lh kj nn no ll kn np nq lp kr nr ns lt nt bi translated">RTC初始化</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2fcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用App ID来创建引擎实例。我们使用<code class="fe nz oa ob na b">enableVideo</code>方法将SDK设置为视频模式。</p><p id="5ae7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们加入通道时，RTC会为在场的每个用户以及随后加入的每个新用户触发一个<code class="fe nz oa ob na b">userJoined</code>事件。当用户离开频道时，触发<code class="fe nz oa ob na b">userOffline</code>事件。我们使用事件侦听器来用uid更新peerIds数组。我们稍后将使用这个数组来呈现来自其他用户的视频提要。</p><p id="c205" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们加入了一个频道，SDK就会触发<code class="fe nz oa ob na b">JoinChannelSuccess</code>事件。我们将状态变量<code class="fe nz oa ob na b">inCall</code>设置为true来呈现视频聊天UI。</p><p id="dbd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一名新用户加入我们的视频聊天室时，如果我们是之前讨论过的高级会员，我们会使用<code class="fe nz oa ob na b">lobby</code> RTM频道向所有频道成员发送一条频道消息，其中包含更新后的用户数。</p><h2 id="6845" class="ne ky iq bd kz nj nk dn ld nl nm dp lh kj nn no ll kn np nq lp kr nr ns lt nt bi translated">RTM初始化</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="55d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用RTM发送房间名称和成员数量。我们保留了一批年长者，即在我们之前加入号召的成员。如果老年人数组大小&lt; 2，这意味着我们是最高级的成员，负责信号。(本地用户也是阵列的一部分。)</p><p id="c31b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们附加了<code class="fe nz oa ob na b">channelMemberJoined</code>和<code class="fe nz oa ob na b">channelMemberLeft</code>监听器，它们在用户加入或离开RTM通道时被触发。当用户加入大厅频道时，如果我们是级别最高的成员，我们会向他们发送一条同级消息。如果用户离开当前的视频聊天频道，我们会更新老年人数组(如果他们比我们先到，就将他们从数组中删除)。如果我们是高级会员，我们还会向大厅发送频道消息来更新计数。</p><p id="407b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们附加<code class="fe nz oa ob na b">channelMessageReceived</code>和<code class="fe nz oa ob na b">messageReceived</code>事件监听器，它们分别在我们接收到通道消息和对等消息时被触发。我们分割<code class="fe nz oa ob na b">channelName:memberCount</code>字符串(例如，<code class="fe nz oa ob na b">‘helloWorld:5’</code>)，并使用这两段数据来更新我们的字典。(例如，<code class="fe nz oa ob na b">rooms: { ‘helloWorld’: 5, ‘roomTwo’: 3 }</code>)。</p><h2 id="e1fa" class="ne ky iq bd kz nj nk dn ld nl nm dp lh kj nn no ll kn np nq lp kr nr ns lt nt bi translated">加入通话</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9933" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们定义了一个函数来加入调用，该函数将通道名作为参数。我们使用通道名更新状态，并使用<code class="fe nz oa ob na b">joinChannel</code>方法加入RTM和RTC上的通道。</p><p id="4f0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用RTM上的<code class="fe nz oa ob na b">getChannelMembersBychannelId</code>方法来获取通道上用户的uid。如果我们是唯一的成员，我们将向RTM上的大厅频道发送频道消息，以向每个人更新创建的房间。</p><h2 id="4b5c" class="ne ky iq bd kz nj nk dn ld nl nm dp lh kj nn no ll kn np nq lp kr nr ns lt nt bi translated">离开电话</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2a5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们离开了RTM和RTC视频聊天室频道，但仍与RTM上的大厅频道保持连接，以不断接收更新。我们通过清除<code class="fe nz oa ob na b">peerIds</code>数组、<code class="fe nz oa ob na b">seniors</code>数组和<code class="fe nz oa ob na b">channelName</code>来更新我们的状态。我们还将<code class="fe nz oa ob na b">inCall</code>设置为false，将<code class="fe nz oa ob na b">inLobby</code>设置为true，以呈现大厅UI。</p><h2 id="f91d" class="ne ky iq bd kz nj nk dn ld nl nm dp lh kj nn no ll kn np nq lp kr nr ns lt nt bi translated">呈现我们的用户界面</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="dfac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们定义了显示按钮的渲染函数，以便在通话或大厅中显示状态。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="250e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用<code class="fe nz oa ob na b">_renderRooms</code>函数来呈现一个滚动视图，该视图遍历rooms字典来显示已创建房间的列表及其成员计数。用户可以点击任何房间加入，这将调用<code class="fe nz oa ob na b">joinCall</code>功能。我们还呈现一个文本输入，让用户创建一个房间，用该输入调用同一个<code class="fe nz oa ob na b">joinCall</code>函数。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="6570" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦连接到视频聊天室，我们就使用<code class="fe nz oa ob na b">_renderCall</code>功能来呈现视频。我们使用SDK中的<code class="fe nz oa ob na b">RtcLocalView</code>组件来呈现我们自己的(本地用户的)视频。我们在滚动视图中使用<code class="fe nz oa ob na b">RtcRemoteView</code>来呈现使用存储在<code class="fe nz oa ob na b">peerIds</code>数组中的uid连接的用户的视频。我们还显示一个离开房间的按钮。</p><h2 id="4906" class="ne ky iq bd kz nj nk dn ld nl nm dp lh kj nn no ll kn np nq lp kr nr ns lt nt bi translated">Permission.ts</h2><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b908" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在导出一个助手函数，向Android操作系统请求麦克风权限。</p><h2 id="1852" class="ne ky iq bd kz nj nk dn ld nl nm dp lh kj nn no ll kn np nq lp kr nr ns lt nt bi translated">Style.ts</h2><p id="b36b" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">Style.ts文件包含组件的样式。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="b290" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">下一步是什么？</h1><p id="7eac" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">同样的技术也可以用来传递其他信息，比如连接的用户名、房间描述和房间标题。我们甚至可以使用相同的机制，通过发送RTM消息来将用户踢出呼叫，该消息在被评估后调用远程用户设备上的离开通道方法。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="e696" class="kx ky iq bd kz la oj lc ld le ok lg lh li ol lk ll lm om lo lp lq on ls lt lu bi translated">结论</h1><p id="0dfd" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">您已经看到了我们如何利用Agora RTM SDK来共享信息和动态创建视频聊天室。您可以参考<a class="ae kw" href="https://docs.agora.io/en/Video/API%20Reference/react_native/index.html" rel="noopener ugc nofollow" target="_blank">Agora React Native API Reference</a>，了解可以帮助您快速向下一个实时互动应用添加更多功能的方法。</p></div></div>    
</body>
</html>