<html>
<head>
<title>Get your application fully observed, monitored, traced, and secured using Openshift Service Mesh Operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Openshift Service Mesh Operator对您的应用进行全面观察、监控、跟踪和保护</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/get-your-application-fully-observed-monitored-traced-and-secured-using-openshift-service-mesh-43300ffe6aa8?source=collection_archive---------10-----------------------#2020-05-16">https://levelup.gitconnected.com/get-your-application-fully-observed-monitored-traced-and-secured-using-openshift-service-mesh-43300ffe6aa8?source=collection_archive---------10-----------------------#2020-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="151c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">迁移到微服务方法几乎没有什么挑战，这主要是因为应用程序有很多活动部件。当您拥有一个整体式应用程序时，您已经将所有组件组合成一个整体—更易于部署、监控、观察和保护。</p><p id="232f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着微服务变得非常受欢迎，Kubernetes/Openshift等容器编排引擎也变得非常受欢迎，其中每个微服务实际上是一个pod(一般来说)，所有微服务都位于Kubernetes集群中。有了这些小组件，监控、观察、跟踪和保护您的应用程序变得越来越困难。例如，您有一个应用程序，您的客户苦于响应时间长，您如何跟踪有问题的组件？你从哪里开始？</p><p id="7578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我想和你谈谈服务网格运营商的原因。使用最新版本的Openshift，只需点击几下鼠标，您就可以观察、跟踪、保护和监控您的微服务应用，为此，我们将使用5种操作方法:</p><h1 id="1053" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">相关组件</h1><ul class=""><li id="f9da" class="lj lk iq jp b jq ll ju lm jy ln kc lo kg lp kk lq lr ls lt bi translated"><strong class="jp ir">基亚里操作员</strong>——负责观察，将实时呈现架构</li><li id="ab6d" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated"><strong class="jp ir">耶格操作员</strong>——负责追踪，将帮助我们找到分布式追踪的瓶颈</li><li id="2876" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated"><strong class="jp ir"> Elasticsearch Operator </strong> —收集请求，与Jaeger集成以跟踪请求</li><li id="ed50" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated"><strong class="jp ir">服务网状运营商</strong> —整个包，将上述所有内容收集到一个CR中，并提供Istio管理系统</li><li id="0351" class="lj lk iq jp b jq lu ju lv jy lw kc lx kg ly kk lq lr ls lt bi translated"><strong class="jp ir"> Portshift </strong> <strong class="jp ir">操作员</strong> —负责自动化运行时安全。</li></ul><h1 id="3947" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">Bookinfo应用程序</h1><p id="8fa9" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">在我们的演示中，我们将使用bookinfo应用程序。Bookinfo是一个版本化的应用程序，其中每个请求都会将我们带到应用程序的不同版本。通过访问产品页面，我们将在每次页面刷新时点击不同版本的reviews微服务，草图:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/8479f5205fdc12e7e92a24fdaa042be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*J8I_ns-n8SQrXl5wGqRQag.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Bookinfo应用程序架构</figcaption></figure><p id="24f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从进入我们的Openshift UI仪表板开始，安装那些操作符(我推荐使用RedHat提供的那些)。安装Elasticsearch，Kiali，Jaeger，Service Mesh，Portfish操作器，集群方式。</p><p id="df1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装完这些操作符后，转到<code class="fe mo mp mq mr b">Installed operators</code>，您应该会看到类似这样的内容:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/3164899ae9bb09e9da478af0d9b799d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M8Wq1dzYEHgPjBh3RSb72g.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">已安装的操作员</figcaption></figure><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="906b" class="nb km iq mr b gy nc nd l ne nf">$ oc new-project istio-system</span></pre><p id="ea4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了项目，让我们创建一个CR来创建服务网格运营商的管理系统，该CR将创建所有提到的组件:</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="1e62" class="nb km iq mr b gy nc nd l ne nf">$ oc create -f - &lt;&lt;EOF <br/>apiVersion: maistra.io/v1<br/>kind: ServiceMeshControlPlane<br/>metadata:<br/>  name: basic-install<br/>  namespace: istio-system<br/>spec:<br/>  version: v1.1<br/>  istio:<br/>    gateways:<br/>      istio-egressgateway:<br/>        autoscaleEnabled: false<br/>      istio-ingressgateway:<br/>        autoscaleEnabled: false<br/>        ior_enabled: false<br/>    mixer:<br/>      policy:<br/>        autoscaleEnabled: false<br/>      telemetry:<br/>        autoscaleEnabled: false<br/>    pilot:<br/>      autoscaleEnabled: false<br/>      traceSampling: 100<br/>    kiali:<br/>      enabled: true<br/>    grafana:<br/>      enabled: true<br/>    tracing:<br/>      enabled: true<br/>      jaeger:<br/>        template: all-in-one</span><span id="7897" class="nb km iq mr b gy ng nd l ne nf">EOF</span></pre><p id="2976" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，在最后几行，我们可以启用/禁用创建基亚利、格拉夫纳和耶格。这意味着如果我们选择启用它，服务网格运营商将为我们创建到其他运营商的CR。创建CR后，让我们验证我们的管理系统是否已完全安装:</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="a5a7" class="nb km iq mr b gy nc nd l ne nf">$ oc get pods <br/>                                                                                       <br/>NAME                                      READY   STATUS    RESTARTS   AGE<br/>grafana-5b6d886976-vnh5p                  2/2     Running   0          25s<br/>istio-citadel-6784798885-x2dvr            1/1     Running   0          3m16s<br/>istio-egressgateway-b8d7d6fcf-l7sck       1/1     Running   0          68s<br/>istio-galley-7549bb654b-4h7rx             1/1     Running   0          2m22s<br/>istio-ingressgateway-7f6fcf4bc9-h9krz     1/1     Running   0          68s<br/>istio-pilot-75d4fdb54f-rd5td              2/2     Running   0          87s<br/>istio-policy-7cb97db7c8-5fhzj             2/2     Running   0          2m3s<br/>istio-sidecar-injector-866fccd4d9-ntxxw   1/1     Running   0          38s<br/>istio-telemetry-6585f4479c-pq9b6          2/2     Running   0          2m3s<br/>jaeger-6599dbb7c6-kd9cp                   2/2     Running   0          2m20s<br/>kiali-694c9ff744-q4zm8                    1/1     Running   0          4m<br/>prometheus-6df66d57cd-jbqrd               2/2     Running   0          2m51s</span></pre><p id="136e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！我们有Prometheus &amp; Grafana用于监控，Istio用于服务网格，Kiali用于观察，Jaeger用于分布式跟踪。一个CR中的整个堆栈！现在我们已经有了管理系统，让我们创建一个示例应用程序，这样我们就可以看到我们的管理系统如何对它做出反应:</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="930b" class="nb km iq mr b gy nc nd l ne nf">$ oc new-project bookinfo</span></pre><p id="c7ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们创建实际的<code class="fe mo mp mq mr b">ServiceMeshMemberRoll</code> CR，它将告诉我们的<code class="fe mo mp mq mr b">ServiceMeshControlPlane</code>我们有一个要管理的候选对象，这实际上是我们的bookinfo项目。一旦我们创建了这个CR，我们的管理系统将开始管理bookinfo项目。它将注入Istio的sidecars，并开始收集我们应用程序的信息:</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="c614" class="nb km iq mr b gy nc nd l ne nf">$ oc create -f - &lt;&lt;EOF<br/>apiVersion: maistra.io/v1<br/>kind: ServiceMeshMemberRoll<br/>metadata:<br/>  name: default<br/>  namespace: istio-system<br/>spec:<br/>  members:<br/>    - bookinfo<br/>EOF</span></pre><p id="872b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们创建实际的应用程序。bookinfo应用程序是一个简单的基于web的应用程序，分为几个版本。通过这个应用程序，我们将看到如何使用Istio在版本之间均匀地路由流量(强调canary部署)，如何观察我们的架构并跟踪请求和响应时间。</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="5bf9" class="nb km iq mr b gy nc nd l ne nf">$ oc apply -n bookinfo -f <a class="ae nh" href="https://raw.githubusercontent.com/Maistra/istio/maistra-1.1/samples/bookinfo/platform/kube/bookinfo.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/Maistra/istio/maistra-1.1/samples/bookinfo/platform/kube/bookinfo.yaml</a> -n bookinfo</span></pre><p id="4449" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们验证我们的应用程序已经启动并正在运行:</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="1b66" class="nb km iq mr b gy nc nd l ne nf">$ oc get pods -n bookinfo<br/>                                                                                        <br/>NAME                              READY   STATUS    RESTARTS   AGE<br/>details-v1-d7db4d55b-8sx24        2/2     Running   0          54s<br/>productpage-v1-5f598fbbf4-v9q2j   2/2     Running   0          47s<br/>ratings-v1-85957d89d8-slh99       2/2     Running   0          52s<br/>reviews-v1-67d9b4bcc-2cdw2        2/2     Running   0          50s<br/>reviews-v2-67b465c497-cjftq       2/2     Running   0          50s<br/>reviews-v3-7bd659b757-brlnn       2/2     Running   0          49s</span></pre><p id="602a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们的pod中有2个容器在运行，其中一个用于应用程序，另一个是应用程序启动时注入的Istio的边车。现在，我们将创建一个网关，它将告诉Istio我们希望为我们的应用程序创建一个入口规则，以便客户可以在我们的Openshift集群之外访问它:</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="e1c8" class="nb km iq mr b gy nc nd l ne nf">$ oc apply -n bookinfo -f <a class="ae nh" href="https://raw.githubusercontent.com/Maistra/istio/maistra-1.1/samples/bookinfo/networking/bookinfo-gateway.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/Maistra/istio/maistra-1.1/samples/bookinfo/networking/bookinfo-gateway.yaml</a> -n bookinfo</span></pre><p id="5cdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们为我们的服务创建目的地规则，基本上，这些目的地规则将决定Istio如何在我们的微服务之间路由其流量:</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="9fc4" class="nb km iq mr b gy nc nd l ne nf">oc apply -n bookinfo -f <a class="ae nh" href="https://raw.githubusercontent.com/Maistra/istio/maistra-1.1/samples/bookinfo/networking/destination-rule-all.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/Maistra/istio/maistra-1.1/samples/bookinfo/networking/destination-rule-all.yaml</a> -n bookinfo</span></pre><p id="849a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！我们的应用程序已完全运行，现在让我们创建一个无限循环，这样我们将有一些基本流量流向我们的应用程序，该循环将尝试获取productpage，默认情况下它使用所有其他服务:</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="40e2" class="nb km iq mr b gy nc nd l ne nf">$ while :; do curl -s $(oc get route -n istio-system | grep istio-ingressgateway | awk '{print $2}')/productpage | grep -o "&lt;title&gt;.*&lt;/title&gt;"; sleep 1; done</span></pre><h2 id="912f" class="nb km iq bd kn ni nj dn kr nk nl dp kv jy nm nn kz kc no np ld kg nq nr lh ns bi translated">自动化运行时安全性的Portshift</h2><p id="3ae8" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">在我们创建了<code class="fe mo mp mq mr b">Portshift CR</code>之后，我们看到我们的bookinfo应用程序现在为每个pod提供了3个容器，pod中的第三个容器被Portshift用来应用我们为阻止/检测运行时漏洞(针对连接、pod安全策略等)而创建的规则:</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="246e" class="nb km iq mr b gy nc nd l ne nf">$ oc get pods -n bookinfo<br/>                                                        <br/>NAME                              READY   STATUS    RESTARTS   AGE<br/>details-v1-d7db4d55b-z74kp        3/3     Running   0          45s<br/>productpage-v1-5f598fbbf4-kw792   3/3     Running   0          47s<br/>ratings-v1-858bf6d7b6-vmhsm       3/3     Running   0          46s<br/>reviews-v1-67d9b4bcc-gmnwg        3/3     Running   0          51s<br/>reviews-v2-67b465c497-6dkx6       3/3     Running   0          44s<br/>reviews-v3-7bd659b757-mgmkv       3/3     Running   0          75s</span></pre><p id="60dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何分析应用程序中的风险，为此，我们将打开Portshift仪表板并导航到<code class="fe mo mp mq mr b">Navigator</code>，在这里我们可以看到我们的网状架构正在被实时分析:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nt"><img src="../Images/beb5f8b15b840210c7f52b84cbba29a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87WFDIZM3ruGI4ynqn8Q7g.png"/></div></div></figure><p id="0dd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，Portshift在我们的应用程序中标记了有问题的服务，风险属于连接类型，我们可以看到检测漏洞的规则。该规则是由管理员创建的，以防止pod之间的不安全连接，这样我们可以减轻检测到的风险并阻止潜在的攻击。</p><p id="2430" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们为我们的应用收集风险评估，导航到<code class="fe mo mp mq mr b">risk assessment</code>，在这里您可以看到我们的网格风险摘要:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/6d986eb075c74292b47cbdd6a8f01d64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bu7dad4BBDXryBQj-h0Zyw.png"/></div></div></figure><p id="b73b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的应用程序中，有6个关键风险和36个高风险，很可怕吧？没有那么多，我们可以使用<code class="fe mo mp mq mr b">Policy Advisor</code>，它会建议做一些修改，以解决我们的问题:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f810612e2efde6f0d0a37a9d4c142377.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*GtfvzB9P7G79nAn_-tESEw.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">政策顾问</figcaption></figure><p id="7a71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过点击<code class="fe mo mp mq mr b">apply</code>，我们可以阻止漏洞，这样我们的微服务应用将得到保护，<code class="fe mo mp mq mr b">Policy Advisor</code>将采取行动并应用策略。</p><h2 id="2851" class="nb km iq bd kn ni nj dn kr nk nl dp kv jy nm nn kz kc no np ld kg nq nr lh ns bi translated">可观测性的Kiali</h2><p id="4da1" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">基本上，我们现在有一个客户端执行对我们的产品页面的请求，这样我们将开始观察我们的应用程序。对于可观测性部分，我们将使用Kiali，收集已创建的Kiali路线:</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="6a2a" class="nb km iq mr b gy nc nd l ne nf">$ oc get routes -n istio-system | grep kiali | awk '{print $2}'</span></pre><p id="465c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在打开您的浏览器并粘贴结果以进入Kiali仪表板。当我们进入Kiali仪表板时，我们看到我们的服务网格管理系统管理的每个应用程序都有一个摘要图表，单击<code class="fe mo mp mq mr b">Graph</code>查看您的微服务架构:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nv"><img src="../Images/054817045e9a9516e76ab9826006629a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sF1jFTjd9jUwGJ8-rFo8cw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Kiali入口页面</figcaption></figure><p id="fb7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们观察一下我们的架构，并开始收集一些关于我们的<code class="fe mo mp mq mr b">bookinfo</code>应用程序的信息:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nw"><img src="../Images/19a4212eeba8c9c8f39250668a0a5285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jg-nnkI861uIf86z4fYQ-w.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">基亚里图</figcaption></figure><p id="9839" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们有一个完整的应用程序架构，实时显示路线百分比。我们看到，默认情况下，Istio在我们的版本之间均衡地负载流量，这与我们几次刷新页面会发生的情况非常相似(评论下的星星会将其颜色从红色变为黑色再变为白色)。</p><p id="872c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果我们导航到Kiali仪表板中的<code class="fe mo mp mq mr b">workloads</code>，在<code class="fe mo mp mq mr b">Metrics</code>下，我们将看到反映<code class="fe mo mp mq mr b">details</code>微服务的响应时间和每秒操作数的图表(我们可以对我们应用中的每个微服务都这样做)。我们还可以点击<code class="fe mo mp mq mr b">View in Grafana</code>链接，该链接会自动将我们转到Grafana中的相关仪表板，如果我们遇到一些问题，我们可以在那里进行进一步调查。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nx"><img src="../Images/d681903daa893a75f3feebf408ef39ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESj5MydFXZUcbd1nCHxcxw.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Kiali工作量</figcaption></figure><p id="ba21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，导航到<code class="fe mo mp mq mr b">Services</code>并单击<code class="fe mo mp mq mr b">details</code>服务，除了我们之前看到的图表之外，我们还可以跟踪对我们服务的请求，因此我们会看到一个迷你Jaeger仪表板，向我们显示该特定服务的响应时间，我们可以再次单击<code class="fe mo mp mq mr b">View in Tracing</code>链接，它会自动将我们重定向到Jaeger仪表板:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ny"><img src="../Images/66a52cf4c8ea5b8d4b82de5fefa88fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mUn1tJUkbvkDmmu5fK8LCA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">基亚里服务公司</figcaption></figure><h2 id="69ad" class="nb km iq bd kn ni nj dn kr nk nl dp kv jy nm nn kz kc no np ld kg nq nr lh ns bi translated">用于分布式跟踪的Jaeger</h2><p id="752a" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">现在让我们与Jaeger仪表板交互，收集仪表板的端点:</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="812f" class="nb km iq mr b gy nc nd l ne nf">$ oc get routes -n istio-system | grep jaeger | awk '{print $2}'</span></pre><p id="8e4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在打开浏览器，粘贴结果进入Jaeger仪表板。当我们输入它时，我们看到左侧面板用于查询定义，我们可以通过HTTP状态代码、响应持续时间以及微服务名称进行过滤。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nz"><img src="../Images/e4de92fc881956dec674bcae05e790e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*de_f18QwyG3P7s0691Obmg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">耶格仪表板</figcaption></figure><p id="82e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择<code class="fe mo mp mq mr b">service</code>下的<code class="fe mo mp mq mr b">productpage</code>，点击<code class="fe mo mp mq mr b">Find Traces</code>。您将看到一个图表，显示了该特定微服务的响应时间。选择最高的点并单击它，这将显示一个图表，显示每个微服务的响应时间:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oa"><img src="../Images/8298f13ab32e6344f6e231245028de4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YWp-QFV8Syo5w12lb1umRQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">耶格请求响应时间</figcaption></figure><h2 id="13c3" class="nb km iq bd kn ni nj dn kr nk nl dp kv jy nm nn kz kc no np ld kg nq nr lh ns bi translated">普罗米修斯·格拉夫纳用于监控</h2><p id="7389" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">在我们了解了如何跟踪和观察我们的<code class="fe mo mp mq mr b">bookinfo</code>应用程序之后，让我们看看如何深入Grafana提供的现成性能仪表盘，收集Grafana路线:</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="0366" class="nb km iq mr b gy nc nd l ne nf">$ oc get routes -n istio-system | grep grafana | awk '{print $2}'</span></pre><p id="0d05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在打开您的浏览器，粘贴结果以进入Grafana仪表板，浏览您的仪表板，您会看到有几个自动加载的仪表板:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ob"><img src="../Images/44cb0e94d3328fec20bd84ef021ecc23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HzqNrzjawUiw2UwcycCFVA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Grafana Istio仪表板</figcaption></figure><p id="0637" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">点击<code class="fe mo mp mq mr b">Istio Mesh Dashboard</code>，确认您看到了与我们的bookinfo应用程序相关的仪表板:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oc"><img src="../Images/ea0183ae00cfd56581f49cc0805359f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hdPL8q6I8pXMYKDIGBmrQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Istio网状仪表板</figcaption></figure><h2 id="089a" class="nb km iq bd kn ni nj dn kr nk nl dp kv jy nm nn kz kc no np ld kg nq nr lh ns bi translated">小费</h2><p id="1dcf" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">有时，性能问题是由资源不足(RAM/CPU)引起的，如果是这样，您只会看到响应时间很长，但不知道为什么。要解决这个问题，您可以使用Openshift集群使用的中央Grafana，它是安装的一部分:</p><pre class="md me mf mg gt mx mr my mz aw na bi"><span id="e66f" class="nb km iq mr b gy nc nd l ne nf">$ oc get route -n openshift-monitoring | grep grafana | awk '{print $2}'</span></pre><p id="0a0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开浏览器并粘贴结果以进入中央Grafana仪表板。在您的仪表盘中，使用<code class="fe mo mp mq mr b">Compute resources / Namespace (Workloads)</code>仪表盘:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi od"><img src="../Images/f2e170959b8c997dbe5020c5bf5deb07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kuzrx_0HgyVnk1rjvmt1YQ.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">中央Grafana资源仪表板</figcaption></figure><p id="e564" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在将名称空间上下文更改为我们的<code class="fe mo mp mq mr b">bookinfo</code>应用程序，您会看到:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi oe"><img src="../Images/090b5ad6d88712918ddf7cb56211d5f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-m1P-BeQcwxMEhoFZ5VBA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">Bookinfo资源消耗</figcaption></figure><p id="b5a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，您可以通过获得应用程序资源的完全可观察性来更好地调查性能问题。恭喜你！您已经观察、监控、跟踪了您的应用程序，安装只需点击几下鼠标！</p><h1 id="8041" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="b846" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我们看到了如何使用Kiali、Jaeger、Service Mesh和Grafana为我们的Openshift应用程序获得一个完整的管理系统。我们可以继续水平添加应用程序，我们的<code class="fe mo mp mq mr b">ServiceMeshControlPlane</code>将像对我们的<code class="fe mo mp mq mr b">bookinfo</code>应用程序那样做。希望你喜欢这个演示，下次再见:)</p></div></div>    
</body>
</html>