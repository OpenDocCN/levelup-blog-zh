<html>
<head>
<title>Demystifying complex queries for Django ORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘Django ORM的复杂查询</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/demystifying-complex-queries-for-django-orm-2297d3bfbd2f?source=collection_archive---------2-----------------------#2020-01-21">https://levelup.gitconnected.com/demystifying-complex-queries-for-django-orm-2297d3bfbd2f?source=collection_archive---------2-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1164" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Django中创建复杂SQL查询的权威指南。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/130f647213eceebf54e309bdafd187e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XaLSrpR-dNDVgcQDNeWPkg.png"/></div></div></figure><h1 id="b0f5" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">动机</h1><p id="b939" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">因此，当我在写一个特定的查询时，我遇到了一个障碍。我对SQL本身很有经验，但是当我试图将这种逻辑转换成经典的Django对象关系映射(ORM)时，我感到很困惑。这让我经历了痛苦的几个小时，直到一位先生最终回答了我关于堆栈溢出的具体问题。根据这个答案，我决定浏览几个参考资料和Django的简洁文档，编写一个小指南，在提供的ORM中创建复杂的SQL逻辑，这样您就不必这么做了。</p><h1 id="97d1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">介绍</h1><p id="db00" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">本文假设您对Django和基本SQL有基本的了解。我打算涵盖的<strong class="js iu">主要主题</strong>是:<strong class="js iu">聚合、函数、子查询、窗口函数</strong>。我的目标是添加更多的概念，因为我觉得个人需要使用它们。<strong class="js iu">经验法则</strong>:任何比你的可用带宽更复杂或消耗更多时间的表达式？只需将原始SQL写入Django游标。这不是最好的方法，因为它很容易受到SQL注入的攻击。然而，遵循适当的规则和函数式编程，也可以防范注入攻击。</p><p id="4d80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将主要参考一个<strong class="js iu">问题</strong>和一个<strong class="js iu">答案</strong>模型，其模式在上方最上面的图像中定义<strong class="js iu">。</strong></p><h1 id="a66c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">聚集</h1><p id="a03d" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">与common SQL一样，可以执行聚合来获取整个queryset的摘要结果，也可以为queryset中的每个对象获取单独的摘要。</p><h2 id="8bd2" class="md lb it bd lc me mf dn lg mg mh dp lk kb mi mj lo kf mk ml ls kj mm mn lw mo bi translated">聚合()</h2><p id="799f" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">假设您有一个问题模型，每个问题与用户保持一个ManyToMany字段，表示一种“追随者”关系。如果我想要一个问题得到的<strong class="js iu">upvotes摘要，我可以执行下面的查询:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="0455" class="md lb it mq b gy mu mv l mw mx">&gt;&gt;&gt; from django.db.models import Count<br/>&gt;&gt;&gt; Question.objects.aggregate(<br/>        avg_followers = Avg(Count('followers')),<br/>        highest_followers = Max(Count('followers'))<br/>        lowest_followers = Min(Count('followers'))<br/>    )</span><span id="e1a2" class="md lb it mq b gy my mv l mw mx"><em class="mz">{'avg_</em>followers<em class="mz">' : 14.23, 'highest_</em>followers<em class="mz">' : 1523, 'lowest_</em>followers<em class="mz">' : 0}</em></span></pre><p id="1d2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我不得不导入一个计数函数并用它包装“followers”字段。Followers是ManyToManyField，Count函数返回关注该问题的用户数。基于该结果，在完整的问题查询集中找到相应的最小、最大和平均追随者。</p><h2 id="f599" class="md lb it bd lc me mf dn lg mg mh dp lk kb mi mj lo kf mk ml ls kj mm mn lw mo bi translated">批注()</h2><p id="d9ae" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">正如上面简要解释的，annotate用于为queryset中的每个对象生成单独的摘要。这意味着，聚合的结果是为每条记录计算的，这些记录可能相同，也可能不同。如果我想在<strong class="js iu">答案模型</strong>中为一个答案的所有支持者创建一个“支持投票”计数:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="0124" class="md lb it mq b gy mu mv l mw mx">&gt;&gt;&gt; from django.db.models import Count<br/>&gt;&gt;&gt; query = Answers.objects.annotate(upvotes = Count('upvoters'))<br/>&gt;&gt;&gt; query[0]<br/>&lt;Answer : 1&gt;<br/>&gt;&gt;&gt; query[0].upvotes<br/>143<br/>&gt;&gt;&gt; query[1]<br/>&lt;Answer : 2&gt;<br/>&gt;&gt;&gt; query[1].upvotes<br/>23</span></pre><h1 id="ee43" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">f()表达式</h1><p id="80e2" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">F()表达式表示模型的字段/带注释的列的值。它用于有效地引用模型字段值，而不必实际将它们提取到Python内存中。这导致数据库而不是Python来执行工作。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="d4a6" class="md lb it mq b gy mu mv l mw mx">&gt;&gt;&gt; from django.db.models import F<br/>&gt;&gt;&gt; query = Answer.objects.get(author__username='keshavvinayak01')<br/>&gt;&gt;&gt; query.answer<br/>Yes, Math is in fact related to Science.<br/>&gt;&gt;&gt; query.update(answer = F('answer') + " [Anonymous]")<br/>&gt;&gt;&gt; query.answer<br/>Yes, Math is in fact related to Science. [Anonymous]</span></pre><p id="9a83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以在注释、过滤器或引用外键中使用这些表达式。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="3b41" class="md lb it mq b gy mu mv l mw mx">&gt;&gt;&gt; from django.db.models import F</span><span id="b00d" class="md lb it mq b gy my mv l mw mx"># In Annotations<br/>&gt;&gt;&gt; answer = Answer.objects.annotate(<br/>        interest = Count(F('followers') + Count(F('requested')<br/>    )</span><span id="ee0f" class="md lb it mq b gy my mv l mw mx"><br/># In Filters<br/>&gt;&gt;&gt; own_qa = Answer.objects.filter(<br/>        question__asker = F('author')<br/>    )</span><span id="8d33" class="md lb it mq b gy my mv l mw mx"><br/># Referencing Foreign Key <br/>&gt;&gt;&gt; answer = Answer.objects.annotate(<br/>        question_id = F('question')<br/>    )<br/>&gt;&gt;&gt; answer.question<br/>Is Math related to Science?<br/>&gt;&gt;&gt; answer.question_id<br/>3</span></pre><h1 id="f2cd" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Func()表达式</h1><p id="c5ee" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这些表达式包括LOWER或COALESCE等数据库函数。一些例子可以是:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="d84b" class="md lb it mq b gy mu mv l mw mx">                             <strong class="mq iu">LOWER</strong></span><span id="2345" class="md lb it mq b gy my mv l mw mx">&gt;&gt;&gt; from django.db.models import F, Func, Coalesce<br/>&gt;&gt;&gt; quest = Question.objects.annotate(<br/>        lower_question = Func(F('question')),<br/>        function = 'LOWER'<br/>    )<br/># All the question text cases will be in lower case.</span><span id="0d1e" class="md lb it mq b gy my mv l mw mx"><br/>                            <strong class="mq iu">COALESCE</strong></span><span id="940d" class="md lb it mq b gy my mv l mw mx">&gt;&gt;&gt; from datetime import datetime<br/>&gt;&gt;&gt; q = Answer.objects.annotate(<br/>            updated_at = Coalesce(F('updated_at'), datetime.now())<br/>        )<br/></span></pre><p id="1941" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第一个查询结果中，问题文本字段被转换成小写。这相当于在SQL中选择LOWER(question.question)。在第二个查询中，如果updated_at字段的值为空，我们只需将其设置为当前日期时间，否则只需获取它。</p><h1 id="f1fd" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">子查询()表达式</strong></h1><p id="2e16" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们可以使用子查询()表达式将显式子查询添加到查询集中。例如，如果我们只想获取一个问题及其最高投票答案，我们就必须包含选择这样一个答案的子查询的结果。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="0da8" class="md lb it mq b gy mu mv l mw mx">&gt;&gt;&gt; from django.db.models import OuterRef, Subquery</span><span id="0f6c" class="md lb it mq b gy my mv l mw mx">&gt;&gt;&gt; answer_subquery = Answer.objects.filter(<br/>        question=OuterRef('pk')).annotate(<br/>            upvotes=Count(F('upvoters')<br/>        )<br/>    ).order_by('-upvotes')</span><span id="f46b" class="md lb it mq b gy my mv l mw mx"># What's happening here?<br/>&gt;&gt;&gt; questions = Questions.objects.annotate(<br/>        answer=Subquery(answer_subquery.values('answer')[-1])<br/>    )</span></pre><p id="52fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们将其分解为原始SQL。我们希望获取每个问题及其最高票数的答案。因此，首先，我们创建了一个子查询，该子查询获取OuterRef中引用的给定问题的每个答案，然后根据它们的支持票数按降序排序。</p><p id="7bc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第二部分中，我们添加了一个带注释的答案字段，它基本上是限制为1的子查询的结果，以获取最高的投票答案。</p><p id="6aa6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个单独的表是为upvotes维护的，可以很容易地通过一个答案进行分组计数。为了简单起见，现在可以忽略这个查询。</p><p id="a060" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">SQL可能如下所示:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="b0b6" class="md lb it mq b gy mu mv l mw mx"># Missing some details on upvoters, as it is a many-to-many field.</span><span id="ecf3" class="md lb it mq b gy my mv l mw mx">SELECT "question"."id", (<br/>    SELECT "answer"."answer",COUNT("answer.upvoters") as "upvotes" <br/>    FROM "answer"<br/>    WHERE "answer"."question" = "question"."id"<br/>    GROUP BY 1<br/>    ORDER BY COUNT("answer.upvoters") DESC <br/>    LIMIT 1<br/>) as "answer" from "question"</span></pre><p id="7b1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了这些基本概念之外，如果您已经理解了以上所有内容，那么现在您可以自己编写互连查询。您可以在子查询、带有过滤器的子查询等等中编写聚合。</p><p id="57c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时，您可能需要执行不能完全映射到模型的查询，或者直接执行更新、插入或删除查询。在这种情况下，您可以直接访问数据库，完全远离模型层。示例:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="0a75" class="md lb it mq b gy mu mv l mw mx"><strong class="mq iu">from</strong> <strong class="mq iu">django.db</strong> <strong class="mq iu">import</strong> connection<br/><br/><strong class="mq iu">def</strong> my_custom_sql(self):<br/>    <strong class="mq iu">with</strong> connection.cursor() <strong class="mq iu">as</strong> cursor:<br/>        cursor.execute("""<br/>        UPDATE x <br/>        SET a = 1 <br/>        WHERE bar = %s<br/>        """,[self.a])</span><span id="e761" class="md lb it mq b gy my mv l mw mx">        cursor.execute("""<br/>        SELECT foo <br/>        FROM x <br/>        WHERE bar = <strong class="mq iu">%s<br/>        </strong>""", [self.a])<br/>        <br/>        row = cursor.fetchone()<br/><br/>    <strong class="mq iu">return</strong> row</span></pre><p id="f84c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对象<strong class="js iu"> django.db.connection </strong>表示默认的数据库连接。若要使用数据库连接，请调用connection.cursor()来获取游标对象。然后，调用<strong class="js iu"> cursor.execute(SQL，&lt; params &gt; ) </strong>执行SQL，调用<strong class="js iu"> cursor.fetchone() </strong>或<strong class="js iu"> cursor.fetchall() </strong>返回结果行。</p><h1 id="91be" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="a8e7" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在这篇简短的指南中，我们介绍了执行高级SQL hacks的一些关键基础知识，最后还讨论了如何执行定制SQL。如果本文没有解释清楚什么，我强烈建议浏览Django官方文档，以获得更多关于Django ORM提供的其他可用特性和技巧的知识。我希望这有所帮助，如果有任何疑问或反馈，请留下回复。感谢你的阅读！</p></div></div>    
</body>
</html>