<html>
<head>
<title>Using Cypress with Cucumber to test your app as if you were a user</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Cypress和cumber来测试你的应用程序，就像你是一个用户一样</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-cypress-with-cucumber-to-test-your-app-as-if-you-were-a-user-15288900a1a6?source=collection_archive---------2-----------------------#2020-02-16">https://levelup.gitconnected.com/using-cypress-with-cucumber-to-test-your-app-as-if-you-were-a-user-15288900a1a6?source=collection_archive---------2-----------------------#2020-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fcaa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何编写自动化的端到端测试，类似于用户导航应用程序的方式</h2></div><p id="70ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你可以只写<strong class="kh ir"> <em class="lb">“假设我登录应用程序，当我点击设置图标时，我会看到设置菜单，我会在上面看到我的名字”</em> </strong>，那不是很好吗？在这篇文章中，我将指导你使用你需要的工具和你应该遵循的步骤来完成这种测试。</p><h1 id="0231" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">遇见赛普拉斯</h1><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lu"><img src="../Images/5714d523d69f1df41f5e70c682cff6bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ckM24GNp_o-BRfGp.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">截图来自cypress网站</figcaption></figure><p id="c8bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你没听说过<a class="ae mk" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank">柏树</a>，那么写端到端测试就是当前的<em class="lb">热门事</em>。它取代了Selenium，极大地改善了开发人员编写测试的体验。您将它作为一个简单的npm包(<code class="fe ml mm mn mo b">npm install -D cypress</code>)安装，并使用一个简单的命令(<code class="fe ml mm mn mo b">npx cypress open</code>)运行它。它还作为Docker映像分发，因此您甚至可以在容器中测试您的应用程序，以获得更好的一致性。</p><h1 id="8c06" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">那么，黄瓜是什么？</h1><p id="a1e2" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">不，不是这个🥒。</p><p id="b0a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae mk" href="https://cucumber.io" rel="noopener ugc nofollow" target="_blank"> Cucumber </a>是<a class="ae mk" href="https://en.wikipedia.org/wiki/Behavior-driven_development" rel="noopener ugc nofollow" target="_blank"> BDD </a>的测试框架。通过使用<a class="ae mk" href="https://cucumber.io/docs/gherkin/reference/" rel="noopener ugc nofollow" target="_blank">小黄瓜</a>语言，它允许你编写看起来像<a class="ae mk" href="https://en.wikipedia.org/wiki/Natural_language" rel="noopener ugc nofollow" target="_blank">自然语言</a>的测试。这并不神奇，它依赖于你为你声明的每个新步骤编写步骤定义。步骤定义是将普通英语(“我按下提交按钮”)翻译成JavaScript ( <code class="fe ml mm mn mo b">cy.find("Submit").click()</code>)的方式。</p><p id="7ba4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你甚至可以用你自己的口语写测试<a class="ae mk" href="https://cucumber.io/docs/gherkin/reference/#spoken-languages" rel="noopener ugc nofollow" target="_blank">！</a></p><h2 id="5520" class="mu ld iq bd le mv mw dn li mx my dp lm ko mz na lo ks nb nc lq kw nd ne ls nf bi translated">优势</h2><ul class=""><li id="388c" class="ng nh iq kh b ki mp kl mq ko ni ks nj kw nk la nl nm nn no bi translated">您可以轻松地与非技术团队成员、客户、利益相关者分享您的测试，以展示应用程序在特定条件下的表现。</li><li id="61ba" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">当特性请求到达时，您几乎可以立即无缝地将它们转换成黄瓜测试，并开始开发！</li></ul><h1 id="2063" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">设置您的测试环境</h1><p id="baa2" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">首先，你需要安装Cypress和<a class="ae mk" href="https://github.com/TheBrainFamily/cypress-cucumber-preprocessor" rel="noopener ugc nofollow" target="_blank">黄瓜预处理器</a>:</p><pre class="lv lw lx ly gt nu mo nv nw aw nx bi"><span id="5547" class="mu ld iq mo b gy ny nz l oa ob">npm i -D cypress cypress-cucumber-preprocessor</span></pre><p id="c353" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后你需要设置Cypress来开始读取你的<code class="fe ml mm mn mo b">feature</code>文件。在<code class="fe ml mm mn mo b">cypress.json</code>中，添加:</p><pre class="lv lw lx ly gt nu mo nv nw aw nx bi"><span id="5bcf" class="mu ld iq mo b gy ny nz l oa ob">{<br/>  "baseUrl": "http://localhost:8080",<br/>  <strong class="mo ir">"testFiles": "**/*.{feature,features}"</strong><br/>}</span></pre><p id="204c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(<code class="fe ml mm mn mo b">baseUrl</code>应该设置为无论您的应用程序在哪里运行)</p><p id="1e55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦你得到了这些，你还需要配置cypress-cucumber-preprocessor来停止使用全局步骤定义(他们承诺这将是未来的默认设置)。在您的<code class="fe ml mm mn mo b">package.json</code>中，您需要添加:</p><pre class="lv lw lx ly gt nu mo nv nw aw nx bi"><span id="1d4e" class="mu ld iq mo b gy ny nz l oa ob">"cypress-cucumber-preprocessor": {<br/>  "nonGlobalStepDefinitions": true<br/>}</span></pre><p id="e39b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！让我们开始测试。</p><h1 id="600b" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">编写您的第一个测试</h1><p id="c400" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">要开始使用Cypress和cumber的组合编写测试，您需要理解几个东西。我将尝试引导您完成第一个测试，向您介绍新概念(Cypress命令、步骤定义、黄瓜表达式等)。</p><p id="c726" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您的应用程序中有一个登录页面，看起来像这样:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi oc"><img src="../Images/2589bf9c3f8735bd3a09d292b32bbb65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuVtc2cTOVCPAxndFefO4Q.png"/></div></div></figure><p id="cd6b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还假设您已经有了一个开发环境，它有一个种子数据库，现有用户<code class="fe ml mm mn mo b">user@example.org</code>有一个已知的密码。</p><p id="8d13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想测试应用程序是否可以正常登录。让我们首先编写这个测试，假设我们只使用Cypress:</p><pre class="lv lw lx ly gt nu mo nv nw aw nx bi"><span id="e77a" class="mu ld iq mo b gy ny nz l oa ob">cy.visit('/login')<br/>  .findByPlaceholder(/email/)<br/>  .type('user@example.org')<br/>  .findByPlaceholder(/password/)<br/>  .type('this is my password')<br/>  .findByText('Log in')<br/>  .click()<br/>  .url()<br/>  .should('eq', '/')<br/>  .window()<strong class="mo ir">.</strong>its('localStorage.email')<br/>  .should('eq', 'user@example.org')</span></pre><p id="730d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(注意:我正在使用<a class="ae mk" href="https://github.com/testing-library/cypress-testing-library" rel="noopener ugc nofollow" target="_blank">cypress-testing-library</a>编写DOM查询，我建议您也这样做，以加强更好的实践)</p><p id="f8aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个测试非常简单:它导航到<code class="fe ml mm mn mo b">/login</code>(使用您在<code class="fe ml mm mn mo b">cypress.json</code>中设置的<code class="fe ml mm mn mo b">baseUrl</code>)，它填写用户名和密码并点击“登录”按钮。然后，它检查url是否是应用程序<code class="fe ml mm mn mo b">/ </code>的根，并且登录用户的电子邮件是否在<code class="fe ml mm mn mo b">localStorage</code>中。</p><p id="8e1b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Cypress中，您可以将多个命令组合成一个单独的定制命令，以便于重用和更整洁的测试。为此，我们需要创建一个名为<code class="fe ml mm mn mo b">cypress/support/commands.js</code>的文件，并添加:</p><pre class="lv lw lx ly gt nu mo nv nw aw nx bi"><span id="fdad" class="mu ld iq mo b gy ny nz l oa ob">Cypress.Commands.add('loginWith', ({ email, password }) =&gt;<br/>  cy.visit('/login')<br/>    .findByPlaceholderText(/email/)<br/>    .type(email)<br/>    .findByPlaceholderText(/password/)<br/>    .type(password)<br/>    .findByText('Log in')<br/>    .click()<br/>)</span></pre><p id="08e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后打开<code class="fe ml mm mn mo b">cypress/support/index.js</code>并添加:</p><pre class="lv lw lx ly gt nu mo nv nw aw nx bi"><span id="6f18" class="mu ld iq mo b gy ny nz l oa ob">import './commands'</span></pre><p id="4dcc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦您这样做了，您就可以在测试中使用定制命令:</p><pre class="lv lw lx ly gt nu mo nv nw aw nx bi"><span id="0e39" class="mu ld iq mo b gy ny nz l oa ob">cy.loginWith({<br/>  email: 'user@example.org',<br/>  password: 'this is my password'<br/>})<br/>  .url()<br/>  .should('eq', '/')<br/>  .window()<strong class="mo ir">.</strong>its('localStorage.email')<br/>  .should('eq', 'user@example.org')</span></pre><h2 id="3b58" class="mu ld iq bd le mv mw dn li mx my dp lm ko mz na lo ks nb nc lq kw nd ne ls nf bi translated">翻译成小黄瓜</h2><p id="6245" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">记住这个测试，我们需要弄清楚如何用黄瓜语言，小黄瓜，来写它。我建议尝试一下如何感觉更自然，而不要考虑它如何转化为底层代码。创建一个<code class="fe ml mm mn mo b">cypress/integration/login.feature</code>文件并写入:</p><pre class="lv lw lx ly gt nu mo nv nw aw nx bi"><span id="f153" class="mu ld iq mo b gy ny nz l oa ob">Feature: Login</span><span id="863e" class="mu ld iq mo b gy od nz l oa ob">Scenario:<br/>  When I login<br/>  Then the url is /<br/>  And I'm logged</span></pre><p id="cbb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个特殊的测试中，我跳过了<code class="fe ml mm mn mo b">Given</code>阶段，因为它没有用(<code class="fe ml mm mn mo b">Given I open the app</code>？).</p><p id="7f3b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们定义了3个步骤:“我登录”、“url是{word}”和“我已登录”。因此，我们需要创建3个步骤定义。为此，在名为特征文件 ( <code class="fe ml mm mn mo b">login/login.js</code>)的目录<strong class="kh ir">中创建一个js文件，并编写:</strong></p><pre class="lv lw lx ly gt nu mo nv nw aw nx bi"><span id="0fbf" class="mu ld iq mo b gy ny nz l oa ob">import { When, Then } from 'cypress-cucumber-preprocessor/steps'</span><span id="fbf4" class="mu ld iq mo b gy od nz l oa ob">When('I login', () =&gt; {<br/>  cy.loginWith({ email: 'user@example.org', password: 'this is my password'})<br/>})</span><span id="9453" class="mu ld iq mo b gy od nz l oa ob">Then('the url is {word}', (url) =&gt; {<br/>  cy.url()<br/>    .should('eq', `${Cypress<strong class="mo ir">.</strong>config()<strong class="mo ir">.</strong>baseUrl}${url}`)<br/>})</span><span id="1336" class="mu ld iq mo b gy od nz l oa ob">Then('I\'m logged', () =&gt; {<br/>  cy.window()<strong class="mo ir">.</strong>its('localStorage.email')<br/>    .should('eq', 'user@example.org')<br/>})</span></pre><p id="3d31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原来如此！现在Cucumber知道如何将这三个步骤翻译成Cypress命令。</p><p id="4091" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你运行测试，它是这样的:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi oe"><img src="../Images/a985d6c34537829bfd8a67f1330322bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4z2RYdcY7kf8HOr9MgD52Q.gif"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">你的机器人正在进行测试</figcaption></figure><p id="e75b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行测试时，命令日志显示:</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi of"><img src="../Images/46ec74f103f96321ea84490ec97428bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4t7vC_lXsj3bReYxLnalGg.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">Cypress命令日志显示了我们的特征文件中定义的3个步骤</figcaption></figure><p id="d69c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以选择每个命令，并在那时看到应用程序的快照，这对调试非常有用。</p><h1 id="bae8" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">一些最后的笔记</h1><h2 id="dc42" class="mu ld iq bd le mv mw dn li mx my dp lm ko mz na lo ks nb nc lq kw nd ne ls nf bi translated">首先编写您的测试</h2><p id="92fe" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">测试驱动开发(test-driven development)的一般实践是首先编写你的测试，然后实现这些东西来通过这些测试。</p><p id="3b0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我的经验是，对于前端开发和大多数创造性类型的开发，很难预见在实现之前你将需要什么样的<strong class="kh ir">单元测试</strong>。</p><p id="bf53" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但事实证明，这不是我对<strong class="kh ir">端到端</strong>测试的体验！作为前端开发人员，我们通常会处理复杂的屏幕流和许多变化的状态，我们需要将应用程序设置在某个状态，以开始开发新功能(例如，我们正在设置部分创建一个新的下拉菜单:为此，您需要登录，单击设置菜单，导航到特定部分，等等。以便查看我们需要的应用程序部分)。当然，热重装很有帮助。但它也失败了很多。有时，我们所做的更改会以一种不“可热加载”的方式影响应用程序的状态。</p><p id="4f96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是Cypress真正派上用场的地方:你可以在开始开发之前在测试中编写前提条件，然后在Cypress本身中进行实际的开发(毕竟，它是Chrome！).将特性请求/错误报告转换成黄瓜测试真的很容易，所以你可以在实现整个测试之前编写整个测试。然后你只要瞄准绿灯提交你的代码。</p><h2 id="7cac" class="mu ld iq bd le mv mw dn li mx my dp lm ko mz na lo ks nb nc lq kw nd ne ls nf bi translated">打破既定/何时/然后规则</h2><p id="5ed5" class="pw-post-body-paragraph kf kg iq kh b ki mp jr kk kl mq ju kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">据我理解，<strong class="kh ir"> BDD </strong>的核心是你应该通过设置前提条件(给定部分的<strong class="kh ir">)、指定动作(当</strong>语句时的<strong class="kh ir">)然后断言结果(然后是<strong class="kh ir">部分的</strong>)来编写你的测试。</strong></p><p id="1db4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，正如Cypress最佳实践所述，<a class="ae mk" href="https://docs.cypress.io/guides/references/best-practices.html#Creating-%E2%80%9Ctiny%E2%80%9D-tests-with-a-single-assertion" rel="noopener ugc nofollow" target="_blank">您不应该像编写单元测试一样编写端到端测试</a>，因为设置每个场景都会有性能损失。</p><p id="aa06" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我所做的(我认为这不会损害测试的质量)是编写一系列的步骤和断言，例如:</p><pre class="lv lw lx ly gt nu mo nv nw aw nx bi"><span id="8e33" class="mu ld iq mo b gy ny nz l oa ob">Given I login<br/><strong class="mo ir">Then the url is /</strong><br/>When I click on Settings<br/><strong class="mo ir">Then the url is /settings</strong><br/><strong class="mo ir">And the auto-save toggle is set to false</strong><br/>When I click on the auto-save toggle<br/>Then the auto-save toggle is set to true</span></pre><p id="432d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使我可以省略中间断言(用粗体标记)，我认为这可以更好地理解失败，以防测试在中间步骤失败(在这个例子中，如果它在设置导航部分失败，我将在<code class="fe ml mm mn mo b">Then the url is /settings</code>断言中而不是在<code class="fe ml mm mn mo b">I click on the auto-save toggle</code>步骤中有一个更好的错误。)</p><p id="830c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，就这样，我希望这篇文章向你介绍使用自然语言的端到端测试的奇妙世界。</p><p id="8e2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我打算以后多写一些这方面的文章，敬请关注！</p></div></div>    
</body>
</html>