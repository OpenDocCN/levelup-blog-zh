<html>
<head>
<title>iOS Touch Drawing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS触摸绘画</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ios-touch-drawing-4d5b715d2d35?source=collection_archive---------5-----------------------#2020-05-23">https://levelup.gitconnected.com/ios-touch-drawing-4d5b715d2d35?source=collection_archive---------5-----------------------#2020-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fa0c32289f259b2b61affa17c63d30e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H8ulRg8ThBtwsy5uWlLHIg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片摘自<a class="ae kf" href="https://code.tutsplus.com/tutorials/ios-sdk-advanced-freehand-drawing-techniques--mobile-15602" rel="noopener ugc nofollow" target="_blank">https://code . tuts plus . com/tutorials/IOs-SDK-advanced-freehand-drawing-techniques-mobile-15602</a></figcaption></figure><p id="7865" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我最近参与的一个项目中，我们需要为用户提供一种通过触摸屏幕在照片上绘画的方式。用户将能够在图像上自由绘制，并且他们还能够简单地通过触摸擦除按钮然后触摸图形来<strong class="ki iu">擦除</strong>他们之前的任何图形。</p><p id="ee90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事实证明，最难的部分并不是绘画本身，因为快速的互联网搜索在Ray Wenderlich网站上抛出了一个奇妙的绘画教程，对我们来说最难的是擦除一幅特定的绘画。</p><h1 id="389b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">UIGraphicsContext</h1><p id="d2ff" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Ray Wenderlich教程有三个主要函数，它们构成了大部分绘图逻辑。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="d2bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中<code class="fe mn mo mp mq b">lastPoint</code>用于保存要绘制的线的<em class="mr">最后已知点</em>(在这种情况下，最后已知点也是初始点)。</p><p id="94f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mn mo mp mq b">touchesMoved</code>:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="0c66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所看到的，绘制一条线实际上非常简单，您只需创建一个自定义UIView并粘贴这些代码，该视图就可以作为用户的绘图画布了。</p><p id="ee36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用这种方法的问题是，<code class="fe mn mo mp mq b">UIGraphicsGetImageFromCurrentImageContext</code>返回一个大小为<code class="fe mn mo mp mq b">view.frame.size</code>的<code class="fe mn mo mp mq b">UIImage?</code>，所有生成的图像将具有相同的大小和位置，这使得几乎不可能区分彼此，进一步使单个绘图的擦除变得复杂。</p><p id="b093" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这让我们想到了第二个选择:</p><h1 id="fbeb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">卡沙皮勒</h1><p id="351e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用与之前相同的<code class="fe mn mo mp mq b">touchesBegan/Moved/Ended</code>函数，我们可以创建<code class="fe mn mo mp mq b">CGPaths</code>，它描述了用户移动手指的所有点，然后我们将这个路径添加到一个<code class="fe mn mo mp mq b">CAShapeLayer</code>，并将这个新层添加为“画布”视图的子层，这样我们就可以为每个单独的绘图获取图像(层)。</p><p id="f2d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们来看看使用<code class="fe mn mo mp mq b">CGPath</code>与使用<code class="fe mn mo mp mq b">UIGraphicContext</code>相比有什么不同。</p><p id="7daf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">给我看看代码！</p><p id="837b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们创建了一个名为<code class="fe mn mo mp mq b">DrawingView</code>的自定义视图，并用这个视图替换了<code class="fe mn mo mp mq b">touchesBegan</code>函数:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="df44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mn mo mp mq b">touchesMoved</code>函数与之前的示例保持一致，而<code class="fe mn mo mp mq b">drawLine</code>被改为:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用CGPath和CAShapeLayer apis的新drawLine函数</figcaption></figure><blockquote class="ms mt mu"><p id="a172" class="kg kh mr ki b kj kk kl km kn ko kp kq mv ks kt ku mw kw kx ky mx la lb lc ld im bi translated">比较以前的实现(CGContext)和现在的实现(CALayer ),你会发现它们非常相似。它们都进行几乎相同的函数调用，但是在不同的上下文中。我们用<code class="fe mn mo mp mq b">currentPath.move(to: fromPoint)</code>代替<code class="fe mn mo mp mq b">context.move(to: fromPoint)</code>，我们现在用<code class="fe mn mo mp mq b">currentLayer.lineCap = .round</code>代替<code class="fe mn mo mp mq b">context.setLineCap(.round)</code>。</p></blockquote><p id="4f49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，<code class="fe mn mo mp mq b">touchesEnded</code>函数变成这样，因为我们需要渲染添加的子层:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="fc5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此时，用户可以通过在屏幕上移动手指来绘画，每幅画都是独立的，并且与一个<code class="fe mn mo mp mq b">CAShapeLayer</code>链接。</p><p id="a702" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们如何擦除特定的绘图？这是我们一开始就想解决的问题，所以让我们开始吧！</p><h1 id="a7ee" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">清除</h1><p id="1a28" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">首先，我们将创建一个函数来帮助我们找到包含接触点的层:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="69f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果你以前使用过<code class="fe mn mo mp mq b">CAShapeLayers</code>，你可能使用过<code class="fe mn mo mp mq b">hitTest</code>功能来检查该层是否包含一个<code class="fe mn mo mp mq b">CGPoint</code>。</p><p id="fe55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的具体例子中，这不起作用，因为对于<code class="fe mn mo mp mq b">hitTest</code>函数来说，要求<code class="fe mn mo mp mq b">layer</code>有一个<code class="fe mn mo mp mq b">frame</code>，而我们没有给它分配一个，因为如果用户在屏幕上画一条长对角线，包含整个图形的框架将是一个非常大的矩形，即使手指远离实际画出的线，它也会检测到触摸。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e9fde2007d165d9ada919d11d2c9d53f.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*b8-vmnOtGVFUc1TTY-Cz3w.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">红线是用户绘制的路径，蓝线是包含路径的图层的框架</figcaption></figure><p id="969f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中红线是用户画的线，蓝色矩形是框架。</p><p id="bcc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在前面的代码中弹出的另一件事是，我们正在创建一个<code class="fe mn mo mp mq b">shapeLayer.path</code>的<em class="mr">轮廓</em>，然后在上面调用<code class="fe mn mo mp mq b">contains(point)</code>函数，为什么不直接在路径上调用<strong class="ki iu">包含</strong>函数，为什么我们需要创建一个轮廓？</p><p id="62d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原来<code class="fe mn mo mp mq b">contains(point)</code>函数只在封闭路径上有效，所以如果用户画一条直线，这个函数将总是返回<code class="fe mn mo mp mq b">false</code>。</p><p id="0697" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大纲大概是这样的:</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/9a081f27bdfa051f92c1878f5271369a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gVdDDfKOSmqrUNKI1ZIILw.png"/></div></div></figure><p id="4fc3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你看到的轮廓<strong class="ki iu">是</strong>一个<strong class="ki iu"> </strong>闭合的形状，所以当通过点击删除形状时，它给了我们想要的精度。</p><p id="6381" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此处<a class="ae kf" href="https://stackoverflow.com/questions/45532330/cashapelayer-does-the-line-pass-through-the-point" rel="noopener ugc nofollow" target="_blank">大解说</a>。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="5e75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，让我们继续，<code class="fe mn mo mp mq b">findLayer</code>函数返回被触动的<code class="fe mn mo mp mq b">layer</code>，所以现在我们需要删除它:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="4b5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这两个新函数，我们需要一种在绘制和擦除之间切换的方法，所以我们添加了一个控件属性，并用它来限制<code class="fe mn mo mp mq b">touchesBegan</code>中的绘制能力:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="ee2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和<code class="fe mn mo mp mq b">touchesMoved</code>:</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="ff41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mn mo mp mq b">touchesEnded</code>我们称<code class="fe mn mo mp mq b">findLayer</code>为<code class="fe mn mo mp mq b">isDrawing == false</code></p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a1eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果是这样的:</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/3386d31cf5e6bfdd42ca71ab8dd83584.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/1*Tqx3p0fljYuUO_yj4aq5Xw.gif"/></div></figure><p id="1926" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来挺不错的！这是在iOS中绘画的基础，代码可以在这里找到<a class="ae kf" href="https://github.com/ManuelEMR/DrawingTutorial" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="b09d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个非常简单的例子，说明了绘制和擦除是如何工作的，这个代码可以进一步扩展和重构，为用户提供更多的绘制选项，比如绘制正方形或圆形，或者显示两条线之间的角度。这些选项将在下一篇文章中讨论。</p><p id="8f17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你喜欢它！感谢阅读！</p></div></div>    
</body>
</html>