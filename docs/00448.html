<html>
<head>
<title>What Does Create-React-App Actually Do?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Create-React-App实际上是做什么的？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-does-create-react-app-actually-do-73c899443d61?source=collection_archive---------1-----------------------#2019-03-07">https://levelup.gitconnected.com/what-does-create-react-app-actually-do-73c899443d61?source=collection_archive---------1-----------------------#2019-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cd262bc53fb0cc73b3f6d52170e95c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xEs3peCN2harvQ-K"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@olloweb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">通讯社跟随</a>于<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b75b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多人使用create-react-app作为创建react应用程序的简单起点。有些人并不确切知道随之而来的一切，或者为什么它会在那里。这篇文章是写给那些不知道发生在引擎盖下的每件事，但想了解更多的人的。</p><p id="812c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我会先说这是用create-react-app 2.1.5写的，因此当你读到这篇文章时，事情可能已经发生了变化。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/b8ecc967b80394a51f13063cd20e8809.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*S2vTjqY3Pz1EhqU22JK1Eg.png"/></div></figure><p id="67cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行<code class="fe lg lh li lj b">npx create-react-app yourApp</code>后，你会发现你的应用根目录有三个文件夹和四个文件。文件夹是<code class="fe lg lh li lj b">node_modules/</code>、<code class="fe lg lh li lj b">public/</code>和<code class="fe lg lh li lj b">src/</code>。这些文件是<code class="fe lg lh li lj b">.gitignore</code>、<code class="fe lg lh li lj b">package.json, README.md</code>和<code class="fe lg lh li lj b">yarn.lock</code></p><h1 id="0329" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">运行创建React应用程序</h1><p id="91d6" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">让我们来分析一下你刚才到底做了什么。输出中的第一行来自<code class="fe lg lh li lj b">npx</code>。当您给它一个命令时，npx可以做两件事。它首先在您的本地机器上寻找要运行的包。如果没有找到，它就会开始查看npm的包列表。输出中的第一条消息只是让您知道它处理了。</p><p id="6ca1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，在create-react-app (CRA)中，您的命令将通过一系列检查。它会查找关于您的系统的信息，查看您是否附加了任何标志，并确保您指定了要输出的文件夹。然后实际的<code class="fe lg lh li lj b">createApp</code>功能运行。这将检查您选择的目录是否安全。它通过查找日志文件之类的东西来做到这一点。如果你没有通过任何检查，你会收到一个错误信息，然后CRA将退出。</p><p id="d29e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，它开始用默认值<code class="fe lg lh li lj b">name:&lt;YOURAPP'SNAME&gt;</code>、<code class="fe lg lh li lj b">version: '0.1.0'</code>和<code class="fe lg lh li lj b">private: true</code>组成<code class="fe lg lh li lj b">package.json</code>。这将被写入您指定的目录。在这里，它会根据您的系统来决定是应该使用<code class="fe lg lh li lj b">yarn</code>还是<code class="fe lg lh li lj b">npm</code>。如果你已经安装了<code class="fe lg lh li lj b">yarn</code>将会被使用。对<code class="fe lg lh li lj b">node</code>、<code class="fe lg lh li lj b">yarn</code>和<code class="fe lg lh li lj b">npm</code>的版本进行一系列检查，以选择要使用的<code class="fe lg lh li lj b">react-scripts </code>的正确版本。</p><p id="9b3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个函数叫做<code class="fe lg lh li lj b">run()</code>。这将继续安装。现在唯一出现在你面前的是npx行和“在&lt;你的目录&gt;中创建一个新的React应用”。依赖性列表被创建。默认包括:<code class="fe lg lh li lj b">react, react-dom</code>和您指定的<code class="fe lg lh li lj b">react-scripts</code>版本。如果您添加了TypeScript标志，它也会添加对该标志的依赖。</p><p id="7f6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">新的一行被写入控制台。“正在安装软件包。这可能需要几分钟时间。”使用之前确定的一切，它运行你的软件包管理器来安装正确版本的<code class="fe lg lh li lj b">react-scripts</code>,如果你在线的话从互联网安装，如果你不在线的话从本地缓存安装。</p><p id="8641" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是“安装react、react-dom和react-scripts…”一行出现的地方。安装是异步完成的。如果失败，package.json、yarn.lock和node_modules都会在打印警告后被删除。</p><p id="ad5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果到现在为止一切都成功了，我们就移动到一个新文件:<code class="fe lg lh li lj b">react-scripts</code>。它做的第一件事是检查<code class="fe lg lh li lj b">package.json</code>和<code class="fe lg lh li lj b">yarn.lock</code>。它将<code class="fe lg lh li lj b">package.json</code>加载到一个json格式的变量<code class="fe lg lh li lj b">appPackage</code>中。完成此操作后，它会检查TypeScript是否为依赖项。接下来，它开始添加json。</p><p id="ad95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先是剧本。这些可能与启动、构建、测试和弹出类似。这些脚本实际上位于与我们当前正在浏览的init.js相同的目录中。接下来是eslinstConfig，然后是deafultBrowsers。这些默认是' &gt; 0.2% '，'没死'，'不是ie &lt;= 11’, ‘not op_mini all’. Basically this means target all browsers that are higher then .2% market share, in active use, not bellow IE 11, or Opera Mini. This is actually a separate package located <a class="ae kc" href="https://www.npmjs.com/package/browserslist" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="1446" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe lg lh li lj b">package.json</code>被写出来，不会再被触摸。到目前为止，还没有其他事情发生。检查自述文件，如果存在，则将其重命名。然后，模板文件夹中指定的文件被复制到工作目录中。这是<code class="fe lg lh li lj b">public</code>、<code class="fe lg lh li lj b">src</code>、<code class="fe lg lh li lj b">README.md</code>和<code class="fe lg lh li lj b">gitignore</code>。这里没有打字错误，gitignore是在没有。前面后来改名了。这里有一条评论指出这是为了防止npm错误。</p><p id="4baa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在检查React是否真正安装后，它继续检查存储库是否已经用git初始化。这会运行git init，并添加第一次提交。这就是“初始化git存储库”一行出现的地方。</p><p id="4fe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">init.js在结束前做的最后一件事是打印成功消息和指令。这些向您介绍了基本的<code class="fe lg lh li lj b">react-scripts</code>命令，并建议您进入刚刚创建的目录。</p><h1 id="90c3" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">Create React App的许多依赖项(以及它们的作用)</h1><p id="8117" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">然后问题变成了，那么<code class="fe lg lh li lj b">react</code>、<code class="fe lg lh li lj b">react-dom</code>和<code class="fe lg lh li lj b">react-scripts</code>带来了什么？对于<code class="fe lg lh li lj b">react</code>和<code class="fe lg lh li lj b">react-dom</code>，列表是相同的。<code class="fe lg lh li lj b">loose-envify</code>、<code class="fe lg lh li lj b">object-assign</code>、<code class="fe lg lh li lj b">prop-types</code>和<code class="fe lg lh li lj b">scheduler.</code></p><p id="1e57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lg lh li lj b"><a class="ae kc" href="https://github.com/zertosh/loose-envify" rel="noopener ugc nofollow" target="_blank">loose-envify</a></code> —替换process.env变量<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/object-assign" rel="noopener ugc nofollow" target="_blank">object-assign</a></code> — Object.assign()用于不支持的浏览器/节点版本<br/><code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/prop-types" rel="noopener ugc nofollow" target="_blank">prop-types</a></code>—React props的类型检查器<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/scheduler" rel="noopener ugc nofollow" target="_blank">scheduler</a></code> — React自己的调度器</p><p id="df12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看着这四个你可能会奇怪为什么你的node_modules文件夹这么大。这可归结为<code class="fe lg lh li lj b">react-scripts</code>。它的依赖列表是:</p><blockquote class="mn mo mp"><p id="33a9" class="kd ke mq kf b kg kh ki kj kk kl km kn mr kp kq kr ms kt ku kv mt kx ky kz la ij bi translated">" @babel/core": "7.2.2 "、<br/> "@svgr/webpack": "4.1.0 "、<br/>" babel-core ":" 7 . 0 . 0-bridge . 0 "、<br/> "babel-eslint": "9.0.0 "、<br/> "babel-jest": "23.6.0 "、<br/> "babel-loader": "8.0.5 "、<br/> "babel <br/>" jest-watch-type ahead ":" 0 . 2 . 1 "、<br/>" mini-CSS-extract-plugin ":" 0 . 5 . 0 "、<br/>" optimize-CSS-assets-web pack-plugin ":" 5 . 0 . 1 "、<br/>" PNP-web pack-plugin ":" 1 . 2 . 1 "、<br/>" post CSS-flex bugs-fixes ":" 4 . 1 . 0 "、<br/> "postcss-loader " "</p></blockquote><p id="79f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事态升级得很快。我们来分析一下。</p><h2 id="bfc5" class="mu ll iq bd lm mv mw dn lq mx my dp lu ko mz na ly ks nb nc mc kw nd ne mg nf bi translated">巴比伦式的城市</h2><p id="1254" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">巴别塔改变你的代码。也就是说，它会做一些事情，如添加polyfills，使您的ES2015+代码可以与旧浏览器一起工作。package.json通过<em class="mq"> browserslist定义它的目标。</em></p><p id="4e63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lg lh li lj b"><a class="ae kc" href="https://babeljs.io/docs/en/next/" rel="noopener ugc nofollow" target="_blank">@babel/core</a></code> —巴别塔的核心库<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/babel-core" rel="noopener ugc nofollow" target="_blank"><em class="mq">babel-core</em></a></code> <em class="mq"> — </em>从巴别塔的第7版开始，命名方案发生了变化。并非所有内容都已更新，这是为那些尚未更新到新的@ naming <br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://github.com/babel/babel-eslint" rel="noopener ugc nofollow" target="_blank">babel-eslint</a></code>的包提供的桥梁——这是一个规则集，允许您在Babel解析的代码<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/babel-jest" rel="noopener ugc nofollow" target="_blank">babel-jest</a></code>上运行eslint允许Jest(JS的测试库)与Babel <br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://github.com/babel/babel-loader" rel="noopener ugc nofollow" target="_blank">babel-loader</a></code>很好地配合——一个告诉Webpack(我们将进入Webpack)在代码<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/babel-plugin-named-asset-import" rel="noopener ugc nofollow" target="_blank">babel-plugin-named-asset-import</a></code>上运行Babel预处理器的加载程序——一个允许命名导入<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/babel-preset-react-app" rel="noopener ugc nofollow" target="_blank">babel-preset-react-app</a></code>的CRA特定插件——这是预设</p><h2 id="34e8" class="mu ll iq bd lm mv mw dn lq mx my dp lu ko mz na ly ks nb nc mc kw nd ne mg nf bi translated">埃斯林特</h2><p id="3e5c" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">ESLint是一个linter，意思是根据一组规则扫描你的代码。如果你违反了这些规则之一，它会警告你。这些警告是CRA在控制台中出现许多错误的原因。</p><p id="5ce3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lg lh li lj b"><a class="ae kc" href="https://github.com/eslint/eslint" rel="noopener ugc nofollow" target="_blank">eslint</a></code>—ESLint的基础库<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/eslint-config-react-app" rel="noopener ugc nofollow" target="_blank">eslint-config-react-app</a></code> — CRA的默认ESLint规则<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/eslint-loader" rel="noopener ugc nofollow" target="_blank">eslint-loader</a></code> —类似于上面的Babel-loader，这允许ESLint由WebPack <br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/eslint-plugin-flowtype" rel="noopener ugc nofollow" target="_blank">eslint-plugin-flowtype</a></code>运行——向ESLint <br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/eslint-plugin-import" rel="noopener ugc nofollow" target="_blank">eslint-plugin-import</a></code>添加flowtype语法——添加对ES2015+ import/exports <br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/eslint-plugin-jsx-a11y" rel="noopener ugc nofollow" target="_blank">eslint-plugin-jsx-a11y</a></code>的林挺支持——对JSX的屏幕阅读器之类的东西实施可访问性规则<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/eslint-plugin-react" rel="noopener ugc nofollow" target="_blank">eslint-plugin-react</a></code> —为React添加ESLint规则</p><h2 id="459a" class="mu ll iq bd lm mv mw dn lq mx my dp lu ko mz na ly ks nb nc mc kw nd ne mg nf bi translated">玩笑</h2><p id="a99d" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">Jest是一个Javascript测试库。它也是由脸书和CRA一样做出反应的</p><p id="1b74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/jest" rel="noopener ugc nofollow" target="_blank">jest</a></code>—Jest<br/><code class="fe lg lh li lj b"><a class="ae kc" href="https://github.com/arcanis/jest-pnp-resolver" rel="noopener ugc nofollow" target="_blank">jest-pnp-resolver</a></code>的基本依赖关系—为Jest <br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/jest-resolve" rel="noopener ugc nofollow" target="_blank">jest-resolve</a></code>添加了<a class="ae kc" href="https://gist.github.com/arcanis/02b49752c385908479734d8027d7a6c7" rel="noopener ugc nofollow" target="_blank">即插即用</a>支持—这是一个为Jest添加了一些东西的脸书。很抱歉我没有更好的细节，但没有自述文件，并且代码在repo <br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/jest-watch-typeahead" rel="noopener ugc nofollow" target="_blank">jest-watch-typehead</a></code>中没有解释——允许过滤Jest测试</p><h2 id="b198" class="mu ll iq bd lm mv mw dn lq mx my dp lu ko mz na ly ks nb nc mc kw nd ne mg nf bi translated">PostCSS</h2><p id="803e" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">PostCSS允许将规则应用到您的CSS文件中。一个简单的例子是，它可以添加供应商前缀到您的CSS，以节省您这样做的努力。</p><p id="7914" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/postcss-flexbugs-fixes" rel="noopener ugc nofollow" target="_blank">postcss-flexbugs-fixes</a></code> —修复特定于浏览器的flexbox错误<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/postcss-loader" rel="noopener ugc nofollow" target="_blank">postcss-loader</a></code> —向Webpack添加一个运行PostCSS <br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/postcss-preset-env" rel="noopener ugc nofollow" target="_blank">postcss-preset-env</a></code>的加载程序—添加polyfills以允许较新的CSS在缺少该功能的较旧浏览器上工作<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/postcss-safe-parser" rel="noopener ugc nofollow" target="_blank">postcss-safe-parser</a></code> —发现并修复CSS错误</p><h2 id="a899" class="mu ll iq bd lm mv mw dn lq mx my dp lu ko mz na ly ks nb nc mc kw nd ne mg nf bi translated">网络包</h2><p id="14a5" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">一个高度可修改的捆绑JS文件的工具。正如您从这个列表中的大量依赖项中看到的，它有很多用途。Webpack也是运行Babel、ESLint和PostCSS的工具。</p><p id="1786" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/@svgr/webpack" rel="noopener ugc nofollow" target="_blank">@svgr/webpack</a></code> —将SVG转换为React组件<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/case-sensitive-paths-webpack-plugin" rel="noopener ugc nofollow" target="_blank">case-sensitive-paths-webpack-plugin</a></code> —阻止区分大小写的操作系统和不区分大小写的操作系统相互产生问题<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/css-loader" rel="noopener ugc nofollow" target="_blank">css-loader</a></code> —允许@import url() 使用CSS文件<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/file-loader" rel="noopener ugc nofollow" target="_blank">file-loader</a></code> —解析导入/请求URL并将文件添加到目录<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/html-webpack-plugin" rel="noopener ugc nofollow" target="_blank">html-webpack-plugin</a></code> —为您的所有webpack捆绑包<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/mini-css-extract-plugin" rel="noopener ugc nofollow" target="_blank">mini-css-extract-plugin</a></code>创建一个HTML文件—为每个包含CSS <br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin" rel="noopener ugc nofollow" target="_blank">optimize-css-assets-webpack-plug</a></code>的JS创建一个CSS文件—使用<a class="ae kc" href="https://github.com/cssnano/cssnano" rel="noopener ugc nofollow" target="_blank"> cssnano </a>来缩小和优化CSS代码<br/><code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/pnp-webpack-plugin" rel="noopener ugc nofollow" target="_blank">pnp-webpack-plugin</a></code>—Webpack的Yarn Plug'n'Play插件<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/sass-loader" rel="noopener ugc nofollow" target="_blank">sass-loader</a></code> —这允许web pack将Sass转换为普通的CSS文件。 使用上面的<code class="fe lg lh li lj b">css-loader</code>输出文件<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/style-loader" rel="noopener ugc nofollow" target="_blank">style-loader</a></code> —将CSS添加到样式标签<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/terser-webpack-plugin" rel="noopener ugc nofollow" target="_blank">terser-webpack-plugin</a></code> —允许缩小Javascript <br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/url-loader" rel="noopener ugc nofollow" target="_blank">url-loader</a></code> —将文件转换为base64 URIs。这使您不必请求第二个文件，因为数据是在HTML文档<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/webpack" rel="noopener ugc nofollow" target="_blank">webpack</a></code>中传输的——这里的所有内容都插入了这个文档。允许转换和捆绑JS文件<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/webpack-dev-server" rel="noopener ugc nofollow" target="_blank">webpack-dev-server</a></code> —向Webpack添加实时重新加载。这意味着它将在您每次保存<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/webpack-manifest-plugin" rel="noopener ugc nofollow" target="_blank">webpack-manifest</a></code>时运行——从您的文件<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin" rel="noopener ugc nofollow" target="_blank">workbox-webpack-plugin</a></code>中创建一个<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json" rel="noopener ugc nofollow" target="_blank">manifest . JSON</a>——这与服务工作者有关，添加工具来生成，以及添加一个到它</p><h2 id="5007" class="mu ll iq bd lm mv mw dn lq mx my dp lu ko mz na ly ks nb nc mc kw nd ne mg nf bi translated">其他人</h2><p id="6f51" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这些是非Webpack或Babel相关的插件<br/><code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/bfj" rel="noopener ugc nofollow" target="_blank">bfj</a></code>——友好的JSON。它允许解析大型JSON文件，而不会使您的JS陷入停顿<br/><code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank">dotenv</a></code>——允许从。环境文件<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/dotenv-expand" rel="noopener ugc nofollow" target="_blank">dotenv-expand</a></code> —允许变量在JSON格式中使用。env文件<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/fs-extra" rel="noopener ugc nofollow" target="_blank">fs-extra</a></code> —替换节点的FS方法，增加了额外的方法<br/> <code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/react-app-polyfill" rel="noopener ugc nofollow" target="_blank">react-app-polyfill</a></code> —为CRA使用的旧浏览器增加了polyfill<br/><code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/react-dev-utils" rel="noopener ugc nofollow" target="_blank">react-dev-util</a></code>—由CRA <br/>维护的实用程序库<code class="fe lg lh li lj b"><a class="ae kc" href="https://www.npmjs.com/package/resolve" rel="noopener ugc nofollow" target="_blank">resolve</a></code> —为require.resolve()增加了异步支持</p><p id="5861" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的,<code class="fe lg lh li lj b">react-scripts</code>为你做的大部分事情都与设置和运行Webpack有关。这里列出的几乎所有其他依赖项要么插入到Webpack中，要么插入到Webpack的插件中。</p><h1 id="693f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">反应脚本开始</h1><p id="7eff" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">现在你知道了<code class="fe lg lh li lj b">react-scripts</code>包含什么，但是它做什么呢？使用最多的命令大概是<code class="fe lg lh li lj b">yarn start</code>或者<code class="fe lg lh li lj b">npm start</code>。这在package.json中被定义为用于运行<code class="fe lg lh li lj b">react-scripts start</code>。接下来会发生什么。</p><p id="3dd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先<code class="fe lg lh li lj b">react-scripts.js</code>被称为开始过程。它查找参数，如start或test。如果它找到一个有效的参数，那么它运行<code class="fe lg lh li lj b">/scripts/&lt;THE ARGUMENT YOU GAVE&gt;.js</code>，在本例中是<code class="fe lg lh li lj b">start.js.</code></p><p id="e74a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一系列的检查和导入之后，它开始读取。环境文件。这将检查设置的端口和主机IP。接下来，它查看您想要支持的浏览器，确保您的端口是空闲的(如果不是，您可以选择更改它)，然后运行createCompiler函数。</p><p id="1580" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">createCompiler函数位于<code class="fe lg lh li lj b">react-dev-utils</code>中，它的作用是创建一个函数来监听来自Webpack的消息。这是输出到控制台消息的内容，如“正在编译…”和“编译失败”这对于经常使用CRA的人来说是很熟悉的。这不是实际的Webpack配置，而是与Webpack接口的方法。然后使用配置文件为WebpackDev服务器生成一个配置文件。</p><p id="9cf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建了来自同名库的WebpackDevServer的新实例，传递了编译器和配置。Webpack在这里由WebpackDevServer运行。调用实例上的侦听器方法，传入端口和主机值。然后，这将清除控制台并显示文本“启动开发服务器…”。浏览器以正确的开发URL打开。最后，添加了两个侦听器，用于在进程被终止时关闭web服务器，并退出start.js进程。</p><p id="cb11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢Create React应用程序的这种外观，现在把它看作一个不那么黑的盒子。除了这里所描述的，还有更多，例如构建、测试和弹出脚本都没有涉及到。像往常一样，如果我做错了什么或者有什么变化，请告诉我。</p></div></div>    
</body>
</html>