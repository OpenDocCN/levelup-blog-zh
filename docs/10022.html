<html>
<head>
<title>A-Star (A*) Search for Solving a Maze using Python (with visualization)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python解决迷宫的A-Star (A*)搜索(带可视化)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-star-a-search-for-solving-a-maze-using-python-with-visualization-b0cae1c3ba92?source=collection_archive---------0-----------------------#2021-10-18">https://levelup.gitconnected.com/a-star-a-search-for-solving-a-maze-using-python-with-visualization-b0cae1c3ba92?source=collection_archive---------0-----------------------#2021-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e63aec5a2527ae7080d11986d5079976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQ9z4KDJVKH5-dv8XM2jNA.jpeg"/></div></div></figure><p id="0a74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> A-Star (A*) </strong>搜索算法是解决一个图问题的智能算法。与<strong class="ka ir">深度优先搜索(DFS) </strong>和<strong class="ka ir">广度优先搜索(BFS) </strong>相反，A*是一种<strong class="ka ir">通知</strong>搜索算法，这意味着它在搜索时考虑了目标的位置/地点，因此它搜索相当多的节点以到达目标。</p><p id="dd45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在<strong class="ka ir"> Python </strong>中开发A*算法来解决<strong class="ka ir">迷宫问题。</strong>这是我们将要开发的代码的一个示例输出:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><h1 id="a07c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">a*搜索算法的理论背景:</strong></h1><p id="60e8" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">我们将在下面的迷宫中讨论A*搜索算法的逻辑:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/bb98747ea3f79740912f18918628e0f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*HnCpte3Ti2z9fKhnL5mz2w.png"/></div></figure><p id="9efe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">A*的工作方式是，它为迷宫的每个单元分配一个<strong class="ka ir">成本</strong>，算法选择具有最小成本的路径。单元的成本<strong class="ka ir"> (n) </strong>有两个部分，定义为:</p><p id="9e4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> f(n) = g(n)+h(n) </strong></p><p id="1f40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中<strong class="ka ir"> f(n) </strong>是到达单元<strong class="ka ir"> n </strong>和<strong class="ka ir"> g(n) </strong>和<strong class="ka ir"> h(n) </strong>的总成本定义为:</p><p id="91c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> g(n) → </strong>从<strong class="ka ir">开始</strong>单元格到达<strong class="ka ir"> n </strong>单元格的<strong class="ka ir">实际成本</strong>。</p><p id="9509" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> h(n) → </strong>从小区<strong class="ka ir"> n </strong>到达<strong class="ka ir">目标</strong>小区是<strong class="ka ir">启发式代价</strong>。从单元格<strong class="ka ir"> n </strong>到达目标单元格的<strong class="ka ir">估计成本</strong>。</p><p id="5497" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更好地理解<strong class="ka ir"> g(n) </strong>和<strong class="ka ir"> h(n) </strong>，让我们看看下面的单元格(3，3)的情况:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/cdfe4a85e0da47d329e04e5b1f9f53aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*j-HdWDd0ucK6aA05zCtbkw.png"/></div></figure><p id="6734" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单元格(3，3)的<strong class="ka ir"> g(n) </strong>成本是2，因为从起始单元格开始，我们可以分两步到达单元格(3，3)。那么<strong class="ka ir"> h(n) </strong>就是从小区(3，3)到达目标小区(1，1)的估计代价。我们不知道到达目标单元的成本，所以我们将简单地估计它。可以有两个函数来估计该成本:</p><p id="9632" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1-欧几里德距离:</strong></p><p id="20ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是单元格和目标单元格之间的直线距离，如下所示:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/c22d9924bf4100c2816994f7cc236778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*sUNBpCKgFdXi6p1n8zBMzQ.png"/></div></figure><p id="16c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2-曼哈顿距离:</strong></p><p id="94c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个选项可以是单元格和目标单元格之间的<strong class="ka ir">曼哈顿距离</strong>，它是两个单元格之间的水平加垂直距离。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/2cad65e529ca7a2d881175cdc9046ce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*CoUG0Sku3dtGQhuaDFGj2g.png"/></div></figure><p id="3c1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">启发式成本只是对成本的估计，合理选择启发式函数是A*算法的一个关键参数。我们将使用曼哈顿距离作为启发式函数。</p><p id="cb2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像元(3，3)和目标像元之间的曼哈顿距离为4，因此像元(3，3)的总成本为:</p><p id="5db6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> f(n)=g(n)+h(n)=2+4=6 </strong></p><blockquote class="mg mh mi"><p id="189e" class="jy jz mj ka b kb kc kd ke kf kg kh ki mk kk kl km ml ko kp kq mm ks kt ku kv ij bi translated">与BFS或DFS相比，A*算法中包含的<strong class="ka ir">启发式成本</strong>使其更有效，因为该算法选择具有最小成本(实际成本+估计成本)的单元，因此它将更快地接近目标。</p></blockquote><p id="422a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看A*算法如何从起始单元格扩展到目标单元格。</p><p id="57ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是迷宫的起始位置，红色方块表示我们当前所在的单元格，也就是起始单元格。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/7e2a556f9db3fd54da6ddbad801cfa1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EePWAime3olQx2Rp9Itn4g.png"/></div></div></figure><p id="ea62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从起始信元开始，起始信元的<strong class="ka ir"> g(n) </strong>为0，因为从起始信元到达起始信元的成本明显为零。并且起始单元的<strong class="ka ir"> h(n) </strong>是6，这是起始单元和目标单元之间的曼哈顿距离。</p><p id="8c8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于其他细胞，我们不知道成本；<strong class="ka ir"> g(n) </strong>和<strong class="ka ir"> h(n) </strong>两者，因此我们将假设它们为无穷大。这是整个迷宫的成本值，其中每个单元的成本显示为两个值<strong class="ka ir"> g(n)+h(n) </strong>:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/d3e4714006797a750a62efb10fd39f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*Q8XLxnsSrQHQGBWc9DyOqA.png"/></div></div></figure><p id="bbc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将探索当前小区的相邻小区。当前小区只有一个相邻小区(3，4 ),我们将计算该小区的成本。单元格(3，4)的<strong class="ka ir"> g(n) </strong>将为1，因为我们从起始单元格到单元格(3，4)需要一步，而<strong class="ka ir"> h(n) </strong>为5。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/6979c6f02338af7da59609b2d1380e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*D0gvsT3qSygWjzcv92KfbA.png"/></div></figure><p id="3f57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还在开始通话。现在，A*算法将选择具有最小成本的单元，用于下一次移动，在这种情况下是单元(3，4)，因此它将移动到那里。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/ce21debd82a3f2064eef5d3ae0ed076f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*O1KQO1dxljaSyj-w4utc8Q.png"/></div></figure><p id="9753" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像元(3，4)有3个邻居，它们的成本计算如下:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/c323e33756fef1d20245572afc1c7997.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Orlk0tyaEUeoAMzWiVYrng.png"/></div></div></figure><p id="9c54" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单元(4，4)的新成本是8，高于旧成本6，因此我们不会更新它。</p><blockquote class="mg mh mi"><p id="e21a" class="jy jz mj ka b kb kc kd ke kf kg kh ki mk kk kl km ml ko kp kq mm ks kt ku kv ij bi translated">它只是意味着我们不希望从单元格(4，4)移动到单元格(3，4)，然后从单元格(3，4)返回到单元格(4，4)。其他两个单元(2，4)和(3，3)的成本优于无穷大，因此我们将更新它们的成本，而不会更新单元(4，4)的成本。</p></blockquote><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/ec1e84c10ea2a1df534b9dfe8fdb3e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*sUbgt4dFPFOGgTu6m_m3XQ.png"/></div></figure><p id="b3b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在单元(3，4)上，下一个单元将被选择为具有最小成本的单元。我们将不考虑单元(4，4 ),因为它已经被访问过，并且它的成本在那之后没有更新。在单元格内显示为黄色条。</p><p id="9e2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在其他单元中，两个单元(3，3)和(2，4)的成本最低，为6。<strong class="ka ir">现在选择哪一个？</strong>在这种情况下，我们应该倾向于选择具有较低<strong class="ka ir">启发式成本</strong>的单元，因为这表明该单元更接近目标单元。在本例中，两个单元都具有相同的启发式成本4，因此我们可以选择两个单元中的任何一个，假设我们选择单元(2，4)。我们将移动到那里，这将是迷宫的更新状态。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/910aa45d506e8aa8884e9a9d9bfbe7b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*jNtfEr_01NUP7JJRagpzuQ.png"/></div></figure><p id="79f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">计算相邻单元的成本，然后选择具有最小成本的单元的过程将继续，直到我们到达目标单元。下图显示了接下来的步骤:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/410a53d8e0a2216bb0c2bef9bf885986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZlzg0Xmdfvb5MeDVwPenw.jpeg"/></div></div></figure><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/11b5f6916278ba215fd04619780f2c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJijW1NP04vCXJX2NSnfQw.jpeg"/></div></div></figure><p id="d9d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们到达目标单元格，有一种方法可以让我们只选择高亮显示的路径，这是从起始单元格到目标单元格的最短路径。</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/735df3abcddf1e8c771dacf70caa5ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*j4mYw6y4Sya7ESKA4LRBgg.png"/></div></figure><h1 id="e1fb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">a*算法的伪代码:</strong></h1><p id="ba27" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">现在让我们看看A*搜索的伪代码是什么。</p><p id="973f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们必须选择成本最小的单元，所以我们将使用数据结构<strong class="ka ir">优先级队列</strong>来实现A*算法。与按照<strong class="ka ir"> FIFO </strong>(先进先出)原理工作的<strong class="ka ir">队列</strong>不同，优先级队列中的元素是根据优先级取出的。优先级可以是元素的值(最高或最低)。在Python中，我们在模块<strong class="ka ir">队列</strong>中有可用的优先级队列，优先级是最低值，因此最适合实现A*。</p><p id="1a2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">这是A*搜索的伪代码:</strong></p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/b2720b6bf5024ac018973da9a6cd1c42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8Mhli8YFZ875t6TgCWeMQ.png"/></div></div></figure><blockquote class="mg mh mi"><p id="2fc3" class="jy jz mj ka b kb kc kd ke kf kg kh ki mk kk kl km ml ko kp kq mm ks kt ku kv ij bi translated">在上面的伪代码中需要注意的重要一点是我们在优先级队列中存储开销和信元信息的方式。它被存储为一个元组<code class="fe my mz na nb b">(f_score(start), h(start), start)</code>。元组基于它们内部的第一个元素进行比较，如果相同，则基于下一个元素进行比较，依此类推。因此，存储的第一个值是单元的成本，第二个值是单元的启发式成本，这样，如果两个或更多单元的成本相同，将对启发式成本进行比较。第三是细胞本身的价值。</p></blockquote><h1 id="5a18" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">用Python实现:</strong></h1><p id="9ece" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">为了用Python实现这个算法，我们将使用<a class="ae nc" href="https://github.com/MAN1986/pyamaze" rel="noopener ugc nofollow" target="_blank"> pyamaze </a>模块。关于这个模块的使用，有一个详细的<a class="ae nc" href="https://towardsdatascience.com/a-python-module-for-maze-search-algorithms-64e7d1297c96" rel="noopener" target="_blank">帖子</a>和一个<a class="ae nc" href="https://youtu.be/McMU-WuJwG0" rel="noopener ugc nofollow" target="_blank">视频</a>，但是没有那个细节你也可以继续。</p><p id="e4f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里提供了完整的代码，然后是对它的逐步讨论:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="nd lb l"/></div></figure><p id="36d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要创建任意大小的迷宫，例如5x5的迷宫，我们可以使用如下所示的模块。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="ne lb l"/></div></figure><p id="a1c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码将生成一个随机的5x5迷宫。下面是一个例子:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/1cdbea6ec978fb077af28eb5ca6b2470.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*sq06IWL8_jhdouu27o0kLQ.jpeg"/></div></figure><p id="36f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你需要知道的迷宫论证是:</p><p id="444a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1- <strong class="ka ir"> rows → </strong> m.rows将返回迷宫的行数。上面的例子是5英镑。</p><p id="0ba0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2- <strong class="ka ir"> cols → </strong> m.cols将返回迷宫的列数。上面的例子是5英镑。</p><p id="b757" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3- <strong class="ka ir"> grid → </strong> m.grid将返回迷宫中所有单元格的列表。在上面的例子中，它是一个包含25个单元格的列表，从(1，1)到(5，5)。</p><p id="1fd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4- <strong class="ka ir"> maze_map → </strong> m.maze_map会将迷宫打开和关闭的墙壁信息作为字典返回。键将是单元格，值将是另一个字典，其中包含东、西、北、南四个方向的四面墙的信息。对于上述情况，这将是输出:</p><pre class="kw kx ky kz gt ng nb nh ni aw nj bi"><span id="f3d4" class="nk ld iq nb b gy nl nm l nn no">{(1, 1): {'E': 0, 'W': 0, 'N': 0, 'S': 1}, (2, 1): {'E': 0, 'W': 0, 'N': 1, 'S': 1}, (3, 1): {'E': 1, 'W': 0, 'N': 1, 'S': 0}, (4, 1): {'E': 1, 'W': 0, 'N': 0, 'S': 1}, (5, 1): {'E': 1, 'W': 0, 'N': 1, 'S': 0}, (1, 2): {'E': 1, 'W': 0, 'N': 0, 'S': 1}, (2, 2): {'E': 1, 'W': 0, 'N': 1, 'S': 0}, (3, 2): {'E': 0, 'W': 1, 'N': 0, 'S': 1}, (4, 2): {'E': 0, 'W': 1, 'N': 1, 'S': 0}, (5, 2): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (1, 3): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (2, 3): {'E': 1, 'W': 1, 'N': 0, 'S': 1}, (3, 3): {'E': 0, 'W': 0, 'N': 1, 'S': 1}, (4, 3): {'E': 1, 'W': 0, 'N': 1, 'S': 0}, (5, 3): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (1, 4): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (2, 4): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (3, 4): {'E': 0, 'W': 0, 'N': 0, 'S': 1}, (4, 4): {'E': 0, 'W': 1, 'N': 1, 'S': 0}, (5, 4): {'E': 1, 'W': 1, 'N': 0, 'S': 0}, (1, 5): {'E': 0, 'W': 1, 'N': 0, 'S': 0}, (2, 5): {'E': 0, 'W': 1, 'N': 0, 'S': 1}, (3, 5): {'E': 0, 'W': 0, 'N': 1, 'S': 1}, (4, 5): {'E': 0, 'W': 0, 'N': 1, 'S': 1}, (5, 5): {'E': 0, 'W': 1, 'N': 1, 'S': 0}}</span></pre><p id="59ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用上面给出的伪代码，该算法可以实现为:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/a9dd507cd2a4346d351c5d5822e52865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfR2rUXDomRIR1mw4_dJSg.png"/></div></div></figure><p id="6fb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码中，我们刚刚打印了<strong class="ka ir"> g(n) </strong>和<strong class="ka ir"> h(n) </strong>的值，但是我们需要从起始单元格到目标单元格的路径信息。我们可以将这些信息存储为字典。一个显而易见的方法是在每次选择新的单元时存储信息。在我们之前考虑过的迷宫中，字典的前三个键值对如下所示:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/07cf0a1b3fa3c2ab69b540bfaf4b0f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*o-yTdeuactKSnSmSglysOQ.jpeg"/></div></figure><p id="c3e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在字典中，我们不能有一个键的重复值，所以在上面的例子中，我们不能存储两对，(3，4):(2，4)和(3，4):(3，3)。解决方案是以相反的顺序保存路径，因为我们可以在字典中有重复的值。所以这条路径是反向路径，然后我们可以反过来得到正向路径。</p><p id="b2b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，<code class="fe my mz na nb b">agent</code>类用于创建一个代理，然后使用迷宫类的<code class="fe my mz na nb b">tracePath</code>方法，代理将跟踪由A*算法计算的路径。</p><p id="4340" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以观看详细的<a class="ae nc" href="https://youtu.be/W9zSr9jnoqY" rel="noopener ugc nofollow" target="_blank">视频</a>进一步澄清。此外，还有另一个<a class="ae nc" href="https://github.com/MAN1986/pyamaze/blob/main/Demos/A-Star/aStarDemo.py" rel="noopener ugc nofollow" target="_blank">代码</a>，它对算法进行了更多的可视化处理，模拟了不同迷宫单元的搜索。</p><p id="79be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建模块<strong class="ka ir"> pyamaze </strong>是为了通过简单的代码来促进迷宫生成，然后可以用于编码任何搜索算法，如<strong class="ka ir">广度优先搜索、深度优先搜索、A*、Dijkstra或一些遗传或强化学习</strong>搜索算法。你可以观看这个<a class="ae nc" href="https://www.youtube.com/playlist?list=PLWF9TXck7O_zsqnufs62t26_LJnLo4VRA" rel="noopener ugc nofollow" target="_blank">播放列表</a>，用pyamaze模块实现不同的搜索算法。</p><p id="5a3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谢谢！</p></div></div>    
</body>
</html>