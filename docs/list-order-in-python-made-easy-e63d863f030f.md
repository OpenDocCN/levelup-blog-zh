# Python 中的二进制搜索

> 原文：<https://levelup.gitconnected.com/list-order-in-python-made-easy-e63d863f030f>

## 你不需要记住二分搜索法是如何工作的

![](img/116fa01bc0bf054ea7f93dde32398942.png)

安德烈·泰森在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

当我看到涉及排序列表的问题时，我总是很焦虑，因为我知道这将不可避免地涉及到使用二分搜索法。

这种恐惧是完全不理智的，我总是为自己有这种感觉而自责，因为二分搜索法很美。给定一个排序列表，你可以在 log(N)时间内找到任何值的索引，因为每次查找你都可以将搜索空间减半。

![](img/4e85a24f3dfe7148a20b8a687832aded.png)

【geeksforgeeks.org/binary-search 

准确地说，这种操作使得排序列表在解决需要查找的问题以及确定有多少条目大于或小于目标值时在空间和时间上都非常高效。

现在，如果你想利用你的排序列表，你可能会想写你自己的二分搜索法并插入函数，就像我到目前为止所做的那样，不可避免地要尝试几次才能让它正常工作。谢天谢地，有一个内置的库已经做了同样的事情，只用一行代码就完成了，而且速度更快。

# 把…分为两个部分

二分库很小，但它做了两件事，而且做得很好；**搜索**和**插入**。

对于搜索，我们有**对分 _ 左**和**对分 _ 右**，这两个函数执行二分搜索法，以找到在我们的目标的右侧或左侧之前插入值的位置。在**二等分 _ 右**的情况下，它将超出一个索引，以显示您应该在哪里插入新值来保持顺序。

列表:[1，2，3，4，5]，目标= 4

> ***平分 _ 左:****【1，2，3】****_****，4，5】index = 3*
> 
> ***平分 _ 右:****【1，2，3，4】**_**，5】index = 3+1*

对于插入，我们有 **insort_left** 和 **insort_right** ，它们执行二进制插入，在目标的左边或右边插入我们的值，并就地操作我们的列表。

> ***insort _ left:****【1，2，3】 ***4*** *，4，5】插入索引= 3**
> 
> ***insort _ right:****【1，2，3，4，* ***4*** *，5】插入索引= 3+1*

除了**二等分**和 **insort** 在功能上分别等同于**二等分 _ 右**和**insort _ 右**中的**、**外，这些是该库中仅有的可用功能。然而，它们完全取代了为查找和插入编写自己的函数的需要。

# 平分很快

以下是我对二分搜索法的基本实现

这是它和平分之间的二元竞赛。我们将寻找值 0，因为讽刺的是，它将花费最长的时间来寻找二分搜索法，因为 0 从不在任何事情中间。

> 搜索在 1.6927719116210938e-05 秒内在索引 0 处找到 0
> 平分在 2.6266701171875 e-06 秒内在索引 0 处找到 0

这里我们可以看到，二等分比我的实现快 6 倍

因为等分是在 C 中实现的，所以速度更快，尽管两个函数使用完全相同的算法。Python 只是在数字加法上比 C 慢很多，因为 Python 中的所有数字实际上都是整数类，而整数类又需要时间来调用它们的加法函数，而在 C 中，整数只是 4 字节的数据类型，由 CPU 非常高效地处理。当您开始按顺序执行许多查找或插入时，时间上的差异会开始复合成性能上的显著提升。

## 结论

section 是一个小而有用的库，它帮助维护列表中的排序顺序，并以快速有效的方式提供查找。知道它的存在可以节省实现和运行时间，对于很多编码面试来说，它是一个不可或缺的工具，因为关于排序列表的问题经常会出现。