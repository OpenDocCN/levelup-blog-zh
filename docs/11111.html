<html>
<head>
<title>Scanning Microservices for Dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扫描微服务的依赖性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scanning-microservices-for-dependencies-d612096a4052?source=collection_archive---------13-----------------------#2022-02-16">https://levelup.gitconnected.com/scanning-microservices-for-dependencies-d612096a4052?source=collection_archive---------13-----------------------#2022-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3f47" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在您的团队中应用自动化依赖管理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fa7d9bc2c9c6f6acdaedb5b887ce2004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xx72YJUPHTKu5fgM"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/52gEprMkp7M" rel="noopener ugc nofollow" target="_blank">照片</a>由<a class="ae ky" href="https://unsplash.com/@dekubaum?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼斯·库默</a>在Unsplash上拍摄</figcaption></figure><p id="404e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将介绍什么是软件依赖，以及如何在微服务架构中管理它们。然后，我们将看看在处理依赖性管理时要遵循的一些风险和良好实践。</p><p id="b0a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">📝<em class="lv">在本文中，我将使用术语包来指代一段代码，但是也可以使用其他术语来代替包(例如，库)。</em></p><p id="b40e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从说明什么是依赖和存在什么类型的依赖开始。</p><p id="f341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖项可以是一个外部包，它本身可以有零个或多个依赖项。一旦包含在项目中，它就成为该项目的依赖项。同样的情况也会发生在它的所有依赖项上。</p><p id="7fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个代表在线商店的<a class="ae ky" href="https://martinfowler.com/articles/microservices.html" rel="noopener ugc nofollow" target="_blank">微服务架构</a>的例子。在订单购买过程中，系统需要处理一笔付款。为此，支付网关包作为外部依赖项包含在内。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/f01c4cb8da4ef420bdac2a15b2a1169a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/0*X2JQivF4lrDeTDmm"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://microservices.io/i/Microservice_Architecture.png" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="a4ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当支付网关包被添加到项目中时，它被称为直接依赖。如果它有链接到其他包的依赖项，这些依赖项被称为<a class="ae ky" href="https://en.wikipedia.org/wiki/Transitive_dependency" rel="noopener ugc nofollow" target="_blank">传递依赖项</a>。</p><p id="21f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经知道了依赖关系及其类型的基本知识，让我们来看看如何管理它们。</p><h1 id="f5e1" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">依赖性管理</h1><p id="56c2" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">现在，假设上面例子中的微服务数量开始增长，开发团队为每个微服务创建不同的代码存储库。直接的和可传递的依赖关系的数量将变得难以管理，团队无法手动处理。</p><p id="f95b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个可能的解决方案是使用一个免费的工具，比如自动扫描依赖关系的<a class="ae ky" href="https://www.whitesourcesoftware.com/free-developer-tools/renovate" rel="noopener ugc nofollow" target="_blank">white source renewal</a>，把开发团队的负担带走。这样，就有可能检测到易受攻击的依赖版本，并将它们更新到最新版本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/38fbe3c623aafbf7dbdb04b9838d6070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s721uwTnQKVJt0Tw"/></div></div></figure><p id="1b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当一个依赖项需要更新时，renew做两件事:它创建一个新分支，并打开一个包含新分支中的变化的<a class="ae ky" href="https://en.wikipedia.org/wiki/Distributed_version_control#Pull_requests" rel="noopener ugc nofollow" target="_blank"> pull请求</a>。</p><p id="e3c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，它通知开发团队已经创建了一个新的拉请求，团队成员可以决定是否要通过合并拉请求来修复依赖关系。</p><p id="68e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着项目的不断发展，翻新将:</p><ul class=""><li id="84bc" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">持续搜索易受攻击的依赖项。</li><li id="0700" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">在主分支中包括变更日志和依赖性变更的提交历史。</li><li id="fd83" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">在每次更新时运行测试，以避免回归错误。</li></ul><p id="da37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还有一个<a class="ae ky" href="https://docs.renovatebot.com/key-concepts/dashboard/" rel="noopener ugc nofollow" target="_blank">依赖仪表板</a>，显示了存储库依赖状态的概述，允许团队跟踪和管理项目依赖。</p><p id="1c04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如果没有建立一个适当的依赖关系管理过程，会出现什么问题。</p><h1 id="1696" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">存在易受攻击的依赖关系的风险</h1><p id="0a58" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">当项目开始增长时，依赖项的数量也在增长，存在易受攻击的依赖项的风险也在增长。让我们来看看其中的一些风险。</p><ul class=""><li id="6dbc" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated"><strong class="lb iu">安全</strong>:某些软件包在特定版本中可能存在安全漏洞。不更新到已修复漏洞的较新版本会使项目易受攻击。</li><li id="5b73" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><strong class="lb iu">性能</strong>:使用旧的包可能意味着那些包的最新版本中的一些性能优化被错过了。因此，项目的整体绩效也可能达不到其全部潜力。</li><li id="60fa" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">质量:有些包可能已经过时了。在项目中使用这些包会产生一个漏洞，如果过时的包突然变得不可用，项目可能会崩溃。</li><li id="49ab" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><strong class="lb iu">许可</strong>:一个软件项目不仅绑定到它的直接依赖项的许可，还绑定到正在使用的传递依赖项的许可。跟踪所有依赖关系的<a class="ae ky" href="https://en.wikipedia.org/wiki/Software_license" rel="noopener ugc nofollow" target="_blank">许可证</a>很重要，这样公司就不会因为使用不兼容的软件许可证而产生高额费用。</li></ul><p id="7e10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来看看一些与依赖管理相关的良好实践。</p><h1 id="5a07" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">良好做法</h1><p id="3a5e" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">管理项目依赖关系可能会带来一些挑战。您如何知道依赖项何时容易受到攻击？识别易受攻击的依赖项后，与依赖项更新相关的更改将如何影响现有的代码库？</p><p id="994b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看开发团队可以实施的一些好的实践。</p><ul class=""><li id="28f3" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated"><strong class="lb iu">自动化</strong>:对于开发团队来说，保持依赖关系的更新是一项耗时的任务。正如我们之前看到的，为此目的采用自动化工具可以使开发团队的生活更加轻松。</li><li id="9f2c" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><strong class="lb iu">优先化</strong>:从了解哪些依赖项与系统核心紧密相关开始，花更多时间调查更新这些依赖项的影响。</li><li id="f87a" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><strong class="lb iu">写一个策略</strong>:写一个关于处理易受攻击的依赖项的策略可以帮助开发团队在更新易受攻击的依赖项时，不用怀疑要跟踪的路径。</li></ul><p id="7d8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用上述实践将减少易受攻击的依赖项的风险。</p><h1 id="baab" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">包扎</h1><p id="cef3" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">每当一个新的软件项目开始时，依赖管理自动化应该成为一个优先事项。</p><p id="6b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果公司有专门的安全或基础设施团队，这些团队将有适当的程序来处理依赖性管理。然而，在公司依赖于负责项目整个生命周期的自给自足的团队的情况下，那么就要由团队来关注这个主题，并为他们自己的利益建立一个自动化的过程。</p><p id="b9b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个过程，开发团队跟踪易受攻击的依赖项并解决它们就容易多了。</p><p id="afa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该应用一个简单的规则:<strong class="lb iu">越早、越频繁地查看依赖关系，越好</strong>。</p><p id="20fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="4e5a" class="lx ly it bd lz ma nq mc md me nr mg mh jz ns ka mj kc nt kd ml kf nu kg mn mo bi translated">分级编码</h1><p id="2cee" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="c814" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="4595" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">📰查看<a class="ae ky" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="0b1a" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">🔔关注我们:<a class="ae ky" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ky" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ky" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="6edd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🚀👉<a class="ae ky" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>