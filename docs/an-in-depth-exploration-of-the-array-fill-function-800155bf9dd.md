# 对 Array.fill()函数的深入探究

> 原文：<https://levelup.gitconnected.com/an-in-depth-exploration-of-the-array-fill-function-800155bf9dd>

## Javascript 数组方法完全指南

![](img/18b7153dfa872b920856a7806c4331d9.png)

照片由[特雷西·亚当斯](https://unsplash.com/@tracycodes?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/javascript?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

在过去的几年中，Javascript `Array`全局对象中增加了许多有用的函数，当开发人员编写使用数组的代码时，这些函数为他们提供了各种各样的选择。这些函数提供了许多优势，其中最值得一提的是，虽然过去开发人员必须实现自己的复杂逻辑来执行各种数组操作，但现在所有这些新函数都消除了对这种自主实现的需求。本文将探讨的有用函数之一是`[fill()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)`函数。

# 功能概述

`fill()`函数提供了将数组中给定范围内的所有元素更改为特定值的能力。这个函数不仅就地修改数组，而且在函数完成时返回数组的更新版本。如果您选择使用`fill()`函数，需要记住的一件非常重要的事情是，如果不事先制作一个全新的副本，您将无法维护原始数组。同样值得指出的是，这个函数不会改变原始数组的长度。

`fill()`功能最多有三个参数，第一个参数是*必需的*，第二个和第三个参数是*可选的*。虽然第一个参数可以是任何所需的值，但第二个和第三个参数是从零开始的索引。如果这些参数中的任何一个有负值，它将从数组的末尾开始计数，而不是从开始计数。这意味着参数值`-3`实际上会导致该参数值`3`小于数组长度(`Array.length + -3`)。

第一个参数是`value`参数。该参数可以具有任何所需的值，并且相同的精确值将用于填充指定范围内的数组。第二个参数是`start`参数。该参数是将被指定值填充的范围的起始索引，范围 ***将包括该索引处的项目。因为这个参数是可选的，它有一个默认值`0`，如果没有指定这个参数，数组将从数组的开始处填充。第三个参数是`end`参数。该参数是范围的结束索引，将用指定的值填充，范围 ***不包括*** 在该索引的项目。因为这个参数是可选的，它有一个数组长度的默认值(`Array.length`)，如果没有指定这个参数，数组将被填充到数组的末尾。***

# 原始值

在介绍了一般的函数行为之后，让我们来看看`fill()`函数在实践中是如何工作的一些例子。以下示例演示了仅指定原始`value`参数值的情况:

```
var array = [1, 2, 3, 4, 5];
array.fill(0);
// array: [**0, 0, 0, 0, 0**]
```

使用`0`的`value`参数值调用`fill()`函数。考虑到可选参数默认值，该函数调用与`fill(0, 0, 5)`相同。这意味着指定值的填充范围是从头到尾的整个数组。

这个代码示例演示了前面提到的关于`fill()`函数不改变数组长度的内容。尽管没有明确指定填充范围的界限，但填充范围只是默认为数组的确切大小，并且该函数只使用指定的值填充每个现有的数组项，仅此而已。

# 原始值，正开始

以下示例演示了指定原始`value`参数值和正`start`参数值的情况:

```
var array = [1, 2, 3, 4, 5];
array.fill(0, 2);
// array: [1, 2, **0, 0, 0**]
```

使用`0`的`value`参数值和`2`的`start`参数值调用`fill()`函数。考虑到可选参数默认值，该函数调用与`fill(0, 2, 5)`相同。这意味着指定值的填充范围从索引`2`开始，一直延续到数组的末尾。

# 原始值，负开始

下面的例子演示了一个原始的`value`参数值和一个负的`start`参数值被指定的情况:

```
var array = [1, 2, 3, 4, 5];
array.fill(0, -2);
// array: [1, 2, 3, **0, 0**]
```

使用参数值为`0`的`value`和参数值为`-2`的`start`调用`fill()`函数。考虑到可选参数默认值以及如何计算负参数值，该函数调用与`fill(0, 3, 5)`相同。这意味着指定值的填充范围从索引`3`开始，一直延续到数组的末尾。在指定负的`start`参数值时要记住的一件重要事情是，如果该值导致`start`参数值在添加到数组长度时小于`0`，那么`fill()`函数将忽略`start`参数值，而是从数组的开始处填充指定的值。

# 原始值，正开始，正结束

以下示例演示了原始`value`参数值和正`start`和`end`参数值被指定的情况:

```
var array = [1, 2, 3, 4, 5];
array.fill(0, 2, 4);
// array: [1, 2, **0, 0**, 5]
```

使用`0`的`value`参数值、`2`的`start`参数值和`4`的`end`参数值调用`fill()`函数。指定值的填充范围从索引`2`开始到索引`3`结束，只有从索引`2`开始的两个索引被指定值填充。在指定一个正的`end`参数值时要记住的一件重要事情是，如果该值大于数组的长度，那么`fill()`函数将忽略`end`参数值，而是将指定的值填充到数组的末尾。

# 原始值，正开始，负结束

以下示例演示了指定原始`value`参数值、正`start`参数值和负`end`参数值的情况:

```
var array = [1, 2, 3, 4, 5];
array.fill(0, 2, -3);
// array: [1, 2, 3, 4, 5]
```

使用参数值为`0`的`value`、参数值为`1`的`start`和参数值为`-3`的`end`调用`fill()`函数。考虑到负参数值如何计算，该函数调用与`fill(0, 2, 2)`相同。这个代码样本是我们在本文中看到的第一个例子，其中的`start`和`end`参数值是相同的。由于这两个参数值引用同一个索引，所以没有用指定的值填充数组项，导致数组处于与函数执行前完全相同的状态。

当使用`fill()`函数时，在以下任何情况下，都会出现结果数组处于与函数执行前完全相同的状态的相同行为:`end`参数索引落在`start`参数索引之前；`start`参数值等于或大于数组长度；并且`end`参数值等于或小于`0`。

# 目标值

以下示例演示了指定对象`value`参数值的情况:

```
var array = [1, 2, 3];
array.fill({ a: 1, b: 2 });
// array: [{ a: 1, b: 2 }, { a: 1, b: 2 }, { a: 1, b: 2 }]
```

使用对象`value`参数值调用`fill()`函数。考虑到可选参数默认值，该函数调用与`fill({ a: 1, b: 2 }, 0, 3)`相同。这意味着指定值的填充范围是从头到尾的整个数组。尽管前面所有的代码示例都只使用原始值`0`作为`value`参数值，但是这个代码示例表明，如果需要用这样的值填充数组中的某个范围，使用对象也是可以接受的。

# 经验教训

从这篇关于`fill()`函数的文章中可以学到一些东西。首先要记住的是，无论为`start`和`end`参数指定什么值，`fill()`函数 ***都不会*** 改变原始数组的大小。要记住的第二件事是，`fill()`函数 ***将*** 就地修改原始数组，此外还返回对修改后的数组的引用。这意味着，如果您出于任何原因需要维护原始数组的状态，那么在执行该函数之前，您必须制作原始数组的全新副本。

本文的另一个收获是，不再需要实现任何类型的定制逻辑来用单个值替换数组中的所有项或项的子集。在这种情况下，第一个想法可能是使用 for 循环来实现这种逻辑，这当然会很好，但它远不如使用`fill()`函数紧凑和易读。另一个类似的用例可能是需要创建一个特定大小的数组，并为该数组中的每个索引设置默认值。同样，第一个冲动可能是创建数组，然后使用 for 循环用默认值填充整个数组。然而，使用`fill()`函数，就像编写下面的语句一样简单:`Array(10).fill(0)`。

关于`fill()`函数要记住的最后一件事是它如何处理作为`value`参数值传递的对象。当将任何值作为`value`参数值传递时，数组中填充了该值的所有项将完全相同。在对象的情况下，所有被填充的项目将具有对同一精确对象的引用。这意味着更新数组中已填充的任何一个对象也将更新所有其他已填充的对象。以下示例展示了这一功能的实际应用:

```
var array1 = [1, 2, 3];
array1.fill([1, 2, 3]);// array1: [[1, 2, 3], [1, 2, 3], [1, 2, 3]]array1[0].fill(0);// array1: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]var array2 = [1, 2, 3];
array2.fill({ a: 1, b: 2});// array2: [{ a: 1, b: 2 }, { a: 1, b: 2 }, { a: 1, b: 2 }]array2[1].a = 3;
array2[2].b = 4;// array2: [{ a: 3, b: 4 }, { a: 3, b: 4 }, { a: 3, b: 4 }]
```

在第一个数组的情况下，原始数组用三个数组填充，然后这些数组中的第一个用零填充。这导致其他两个数组也用零填充。在第二个数组中，原始数组填充了三个对象，第二个和第三个对象都被修改。这导致所有三个对象以相同的方式被改变。当然，如前所述，这是每个填充的数组或对象在填充数组或对象的所有地方引用完全相同的对象的结果。改变任何数组或对象只会改变实际被引用的单个数组或对象。

# 结论

非常感谢您阅读这篇文章。我希望这次对 Javascript `Array`全局对象上的`fill()`函数的探索能够提供一些信息，并且我希望在获得一些关于它的知识之后，你能够在你自己的代码中很好地使用它。如果您对`fill()`功能的工作原理还有任何疑问，我建议您参考下面的资源链接，了解与该功能相关的所有信息。请在将来停下来阅读更多关于 Javascript `Array`全局对象上有趣且有用的函数的文章。

# 资源

[Javascript Array.fill()函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)