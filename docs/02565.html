<html>
<head>
<title>Using React Higher-Order Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React高阶组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-react-higher-order-components-eda81ffe9b3e?source=collection_archive---------8-----------------------#2020-03-22">https://levelup.gitconnected.com/using-react-higher-order-components-eda81ffe9b3e?source=collection_archive---------8-----------------------#2020-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ab676169ffc18bd657c6dca4dc52637f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LRmWUzncBUOQCDe1"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@quickorder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> QuickOrder </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6df5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React是一个用于创建前端视图的库。它有一个庞大的图书馆生态系统与之合作。此外，我们可以用它来增强现有的应用程序。</p><p id="2ca2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何使用高阶组件将公共代码重构到一个公共位置。</p><h1 id="e0b4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么我们需要高阶元件？</h1><p id="a88d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">高阶分量(hoc)是接受一个分量并返回一个新分量的函数。</p><p id="3798" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要hoc来重用组件逻辑。这是可行的，因为hoc只是普通的函数，通过用新的组件包装传入的组件，向传入的组件添加一些新的东西。</p><p id="da77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">hoc的例子包括Redux的<code class="fe mh mi mj mk b">connect</code>等等。</p><h1 id="e50a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">定义hoc</h1><p id="848f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">例如，我们可以定义一个为每个传入的组件设置相同数据的特设，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b597" class="mt lf it mk b gy mu mv l mw mx">class Foo extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        {this.props.data.map((d, i) =&gt; (<br/>          &lt;p key={i}&gt;{d}&lt;/p&gt;<br/>        ))}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="668e" class="mt lf it mk b gy my mv l mw mx">class Bar extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;ul&gt;<br/>        {this.props.data.map((d, i) =&gt; (<br/>          &lt;li key={i}&gt;{d}&lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>    );<br/>  }<br/>}</span><span id="2174" class="mt lf it mk b gy my mv l mw mx">const withData = (Component, data) =&gt; {<br/>  return class extends React.Component {<br/>    render() {<br/>      return &lt;Component data={data} /&gt;;<br/>    }<br/>  };<br/>};</span><span id="99af" class="mt lf it mk b gy my mv l mw mx">const DataFoo = withData(Foo, ["apple", "orange"]);<br/>const DataBar = withData(Bar, ["apple", "orange"]);</span><span id="f708" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/><br/>    return (<br/>      &lt;div&gt;<br/>        &lt;DataFoo /&gt;<br/>        &lt;DataBar /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="0c35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe mh mi mj mk b">Foo</code>和<code class="fe mh mi mj mk b">Bar</code>组件，它们是我们将使用<code class="fe mh mi mj mk b">withData</code> HOC操作的组件。</p><p id="d27c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们都只是显示一些来自道具的数据。</p><p id="6f58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有了<code class="fe mh mi mj mk b">withData</code> HOC，这只是一个普通的函数，其中<code class="fe mh mi mj mk b">Component</code>参数是一个组件，第二个<code class="fe mh mi mj mk b">data</code>参数是一些数据，我们假设它们是一个数组。</p><p id="f846" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">withData</code>返回一个新组件，该组件将传入的<code class="fe mh mi mj mk b">Component</code>和传入<code class="fe mh mi mj mk b">Component</code>的<code class="fe mh mi mj mk b">data</code>作为道具。</p><p id="08ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">App</code>组件中，我们用同一个数组的<code class="fe mh mi mj mk b">Foo</code>和<code class="fe mh mi mj mk b">Bar</code>道具调用了<code class="fe mh mi mj mk b">withData</code>组件。</p><p id="7e68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们只渲染从<code class="fe mh mi mj mk b">withData</code>返回的组件，分别是<code class="fe mh mi mj mk b">DataFoo</code>和<code class="fe mh mi mj mk b">DataBar</code>。</p><p id="4d25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如我们所见，我们没有改变原始组件。我们只是在原始组件周围包装了一个新组件。</p><p id="eee6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这降低了改变原始组件的风险。当我们在一个元件上缠绕多个hoc时，这将变得更加重要。</p><p id="91dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从返回的组件向<code class="fe mh mi mj mk b">withData</code>中的<code class="fe mh mi mj mk b">Component</code>传递属性，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5feb" class="mt lf it mk b gy mu mv l mw mx">class Bar extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;ul&gt;<br/>        {this.props.data.map((d, i) =&gt; (<br/>          &lt;li key={i}&gt;{d}&lt;/li&gt;<br/>        ))}<br/>        &lt;li&gt;{this.props.bar}&lt;/li&gt;<br/>      &lt;/ul&gt;<br/>    );<br/>  }<br/>}<br/>const withData = (Component, data) =&gt; {<br/>  return class extends React.Component {<br/>    render() {<br/>      return &lt;Component data={data} {...this.props} /&gt;;<br/>    }<br/>  };<br/>};</span><span id="03d3" class="mt lf it mk b gy my mv l mw mx">const DataFoo = withData(Foo, ["apple", "orange"]);<br/>const DataBar = withData(Bar, ["apple", "orange"]);</span><span id="8878" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;DataFoo /&gt;<br/>        &lt;DataBar bar="bar" /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="f84a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从<code class="fe mh mi mj mk b">withData</code>返回的组件中获取道具，然后通过编写<code class="fe mh mi mj mk b">{…this.props}</code>将它传播到<code class="fe mh mi mj mk b">Component</code>中。</p><p id="781d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="67b1" class="mt lf it mk b gy mu mv l mw mx">&lt;li&gt;{this.props.bar}&lt;/li&gt;</span></pre><p id="9b77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">Bar</code>中显示数据。</p><p id="0437" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还是一样离开了<code class="fe mh mi mj mk b">Foo</code>。</p><p id="7a29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">hoc也可以用作向屏幕呈现数据的组件的容器组件。</p><h1 id="7f94" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">容器组件</h1><p id="1bff" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">容器组件处理诸如订阅和状态之类的逻辑，并通过props将项目传递给处理数据显示的低层组件。</p><p id="2bfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a040" class="mt lf it mk b gy mu mv l mw mx">class Foo extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        {this.props.data.map((d, i) =&gt; (<br/>          &lt;p key={i}&gt;{d}&lt;/p&gt;<br/>        ))}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}<br/>class Bar extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;ul&gt;<br/>        {this.props.data.map((d, i) =&gt; (<br/>          &lt;li key={i}&gt;{d}&lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>    );<br/>  }<br/>}<br/>const withData = Component =&gt; {<br/>  return class extends React.Component {<br/>    constructor(props) {<br/>      super(props);<br/>      this.state = { data: [] };<br/>    }<br/>    componentDidMount() {<br/>      if (Math.random() &gt; 0.5) {<br/>        this.setState({ data: ["apple", "orange"] });<br/>      } else {<br/>        this.setState({ data: ["mango", "grape"] });<br/>      }<br/>    }<br/>    render() {<br/>      return &lt;Component data={this.state.data} {...this.props} /&gt;;<br/>    }<br/>  };<br/>};</span><span id="fbbe" class="mt lf it mk b gy my mv l mw mx">const DataFoo = withData(Foo);<br/>const DataBar = withData(Bar);</span><span id="a74e" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;DataFoo /&gt;<br/>        &lt;DataBar /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="84e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们让由<code class="fe mh mi mj mk b">withData</code>返回的组件通过调用<code class="fe mh mi mj mk b">componentDidMount</code>钩子中的<code class="fe mh mi mj mk b">setState</code>来处理逻辑。</p><p id="1c76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用<code class="fe mh mi mj mk b">this.state.data</code>设置<code class="fe mh mi mj mk b">data</code>道具的值。</p><p id="e8a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mh mi mj mk b">Foo</code>和<code class="fe mh mi mj mk b">Bar</code>组件显示道具中的物品。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/b5aefb36b98a7414e5a7ec9d5437b8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V9I49vxqc0lXjPJ3"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@carlevarino?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">塞萨尔·卡里诺·阿拉贡</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="81da" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">包装显示名称以便于调试</h1><p id="afa5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">HOCs创建的容器组件像其他组件一样出现在React开发工具中。</p><p id="ad33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过设置组件的<code class="fe mh mi mj mk b">displayName</code>属性来选择要在React开发人员工具中显示的显示名称。</p><p id="9842" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以将上面的示例更改如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f7bf" class="mt lf it mk b gy mu mv l mw mx">const getDisplayName = WrappedComponent =&gt; {<br/>  return WrappedComponent.displayName || WrappedComponent.name || "Component";<br/>};</span><span id="f964" class="mt lf it mk b gy my mv l mw mx">const withData = Component =&gt; {<br/>  class WithData extends React.Component {<br/>    constructor(props) {<br/>      super(props);<br/>      this.state = { data: [] };<br/>    }<br/>    componentDidMount() {<br/>      if (Math.random() &gt; 0.5) {<br/>        this.setState({ data: ["apple", "orange"] });<br/>      } else {<br/>        this.setState({ data: ["mango", "grape"] });<br/>      }<br/>    }</span><span id="e8ed" class="mt lf it mk b gy my mv l mw mx">    render() {<br/>      return &lt;Component data={this.state.data} {...this.props} /&gt;;<br/>    }<br/>  }<br/>  WithData.displayName = `WithData(${getDisplayName(Component)})`;<br/>  return WithData;<br/>};</span></pre><p id="dfc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们创建了一个新的<code class="fe mh mi mj mk b">getDisplayName</code>函数来获取<code class="fe mh mi mj mk b">WrappedComponent</code>的<code class="fe mh mi mj mk b">displayName</code>属性。这显示在Chrome开发者控制台的组件选项卡下的React开发者工具中。</p><p id="a612" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过改变<code class="fe mh mi mj mk b">displayName</code>属性的值来设置它，就像我们在新的<code class="fe mh mi mj mk b">withData</code>特设函数中所做的那样。</p><p id="1544" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将名称<code class="fe mh mi mj mk b">WithData</code>添加到类中，而不是返回一个匿名类。</p><p id="1ba1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们补充道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="db57" class="mt lf it mk b gy mu mv l mw mx">WithData.displayName = `WithData(${getDisplayName(Component)})`;</span></pre><p id="a23d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样组件旁边就会显示出<code class="fe mh mi mj mk b">WithData</code>标签。</p><p id="ddaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在应该看到如下所示的内容:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi na"><img src="../Images/4387effb04f26d441f74e3ad73ab3a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*Jy61uAYBrc3LbvnVh2uT1A.png"/></div></figure><h1 id="d763" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要在render方法中使用hoc</h1><p id="1388" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该在<code class="fe mh mi mj mk b">render</code>方法中使用HOCs，因为它会导致在每次渲染时挂载/重新挂载整个DOM子树。</p><p id="8b37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很慢，并且重新安装组件会导致组件及其所有子组件的状态丢失。</p><h1 id="4a14" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">静态方法必须被复制</h1><p id="fe67" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们必须手动复制静态方法。</p><p id="0b2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="56a7" class="mt lf it mk b gy mu mv l mw mx">class Bar extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;ul&gt;<br/>        {this.props.data.map((d, i) =&gt; (<br/>          &lt;li key={i}&gt;{d}&lt;/li&gt;<br/>        ))}<br/>      &lt;/ul&gt;<br/>    );<br/>  }<br/>}</span><span id="e126" class="mt lf it mk b gy my mv l mw mx">Bar.static = () =&gt; console.log("static");</span><span id="e921" class="mt lf it mk b gy my mv l mw mx">const withData = (Component, data) =&gt; {<br/>  class WithData extends React.Component {<br/>    render() {<br/>      return &lt;Component data={data} /&gt;;<br/>    }<br/>  }</span><span id="1eb1" class="mt lf it mk b gy my mv l mw mx">  WithData.static = Component.static;<br/>  return WithData;<br/>};</span><span id="213e" class="mt lf it mk b gy my mv l mw mx">const DataFoo = withData(Foo, ["apple", "orange"]);<br/>const DataBar = withData(Bar, ["apple", "orange"]);</span><span id="b33b" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/>    DataBar.static();<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;DataFoo /&gt;<br/>        &lt;DataBar /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="b25d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们通过编写以下代码来定义<code class="fe mh mi mj mk b">Bar.static</code>方法:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d40b" class="mt lf it mk b gy mu mv l mw mx">Bar.static = () =&gt; console.log("static");</span></pre><p id="4dfe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mh mi mj mk b">withData</code>函数中，我们有一个新的行来复制<code class="fe mh mi mj mk b">static</code>静态方法，通过写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f052" class="mt lf it mk b gy mu mv l mw mx">WithData.static = Component.static;</span></pre><p id="76f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，在<code class="fe mh mi mj mk b">render</code>方法中，我们可以调用<code class="fe mh mi mj mk b">Bar.static</code>方法。</p><h1 id="998a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">裁判没有通过</h1><p id="798e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">React.forwardRef</code>在hoc中传递ref。</p><p id="f1f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下编写一个<code class="fe mh mi mj mk b">logProp</code>组件来实现这一点:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0896" class="mt lf it mk b gy mu mv l mw mx">function logProps(Component) {<br/>  class LogProps extends React.Component {<br/>    componentDidMount() {<br/>      console.log(this.props);<br/>    }</span><span id="7fe8" class="mt lf it mk b gy my mv l mw mx">    render() {<br/>      const { forwardedRef, ...rest } = this.props;<br/>      return &lt;Component forwardedRef={forwardedRef} {...rest} /&gt;;<br/>    }<br/>  }</span><span id="674f" class="mt lf it mk b gy my mv l mw mx">  return React.forwardRef((props, ref) =&gt; {<br/>    return &lt;LogProps {...props} forwardedRef={ref} /&gt;;<br/>  });<br/>}</span></pre><p id="b1e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1df2" class="mt lf it mk b gy mu mv l mw mx">return React.forwardRef((props, ref) =&gt; {<br/>  return &lt;LogProps {...props} forwardedRef={ref} /&gt;;<br/>});</span></pre><p id="5ea7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在回调的<code class="fe mh mi mj mk b">return</code>语句中，我们传入来自<code class="fe mh mi mj mk b">Component</code>组件的<code class="fe mh mi mj mk b">props</code>，以及来自<code class="fe mh mi mj mk b">Component</code>的<code class="fe mh mi mj mk b">forwardedRef</code>。</p><p id="54cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后ref被传入<code class="fe mh mi mj mk b">Component</code>并被设置为我们想要访问的任何元素的ref值。</p><h1 id="9c90" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="462a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">高阶组件或简称hoc，让我们通过创建一个函数来为多个组件添加可重用的逻辑，该函数接受一个组件，然后返回另一个组件。</p><p id="e4cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">组织HOC的最佳方式是将逻辑放在由HOC返回的组件中，然后通过props将数据传递给传递到函数中的组件。</p><p id="5863" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还必须设置静态方法，并通过转发引用从包装的组件中获取引用。</p></div></div>    
</body>
</html>