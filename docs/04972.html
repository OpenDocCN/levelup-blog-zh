<html>
<head>
<title>Building a Microservice From the Ground up With Quarkus, Kotlin, and Debezium</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Quarkus、Kotlin和Debezium从头开始构建微服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-microservice-from-the-ground-up-with-quarkus-kotlin-and-debezium-83ae5c8a8bbc?source=collection_archive---------9-----------------------#2020-07-27">https://levelup.gitconnected.com/building-a-microservice-from-the-ground-up-with-quarkus-kotlin-and-debezium-83ae5c8a8bbc?source=collection_archive---------9-----------------------#2020-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/008557b7af38590e45a77e673ccc4a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8S6iyGmyixahSFiGBkEE3A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@starburst1977?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">斯文·里德</a>在<a class="ae kc" href="https://unsplash.com/s/photos/network?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="2b16" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi li translated"><span class="l lj lk ll bm lm ln lo lp lq di"> T </span>这是一个关于从零开始创建微服务的多部分系列。这将是一个生产质量的应用程序，将突出以下技术的使用:</p><ul class=""><li id="ba8f" class="lr ls iq km b kn ko kr ks kv lt kz lu ld lv lh lw lx ly lz bi translated">夸库斯</li><li id="1d63" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">GraalVM</li><li id="ffc0" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">科特林</li><li id="f957" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">Postgres(持久性)</li><li id="9ba2" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">派头(JPA)</li><li id="a66e" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">数据库迁移</li><li id="9f06" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">卡夫卡(信息)</li><li id="a88e" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">Debezium，Kafka Connect(事务发件箱模式)</li><li id="646b" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">奥克塔(OIDC)</li><li id="108a" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">开放API</li><li id="34a9" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">码头工人</li><li id="529b" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">测试容器</li><li id="6e71" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">Wiremock</li></ul><p id="df66" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">该应用程序将分阶段构建，每个阶段都会添加额外的功能。每个版本都是可部署的和经过全面测试的，但是服务直到最后阶段才会投入生产。</p><h2 id="e85c" class="mf mg iq bd mh mi mj dn mk ml mm dp mn kv mo mp mq kz mr ms mt ld mu mv mw mx bi translated">为什么是夸库斯？</h2><p id="e804" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">我已经使用spring boot很多年了，它是一个很棒的框架。在过去的几年里，更多的框架已经开始在同一个领域竞争，比如<a class="ae kc" href="https://micronaut.io/" rel="noopener ugc nofollow" target="_blank"> Micronaut </a>和<a class="ae kc" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>和<a class="ae kc" href="https://helidon.io/docs/latest/#/about/01_overview" rel="noopener ugc nofollow" target="_blank"> Helidon </a>。尤其是Quarkus，看起来非常适合微服务架构，它承诺“超音速”启动时间和“亚原子”内存使用。此外，它与GraalVM和Kotlin配合得很好。这个用例将是一个测试使用Quarkus构建应用程序的机会。为了有用，它需要包含REST服务、持久性、消息传递、安全性、配置和其他有用的通用特性。</p><h2 id="cb5f" class="mf mg iq bd mh mi mj dn mk ml mm dp mn kv mo mp mq kz mr ms mt ld mu mv mw mx bi translated">为什么是科特林？</h2><p id="df29" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">如今，成为一名通晓多种语言的程序员是明智之举，而且有越来越多优秀且成熟的Java替代品。其中最流行的是Kotlin，Quarkus为该语言提供了一流的支持。</p><h2 id="1f7a" class="mf mg iq bd mh mi mj dn mk ml mm dp mn kv mo mp mq kz mr ms mt ld mu mv mw mx bi translated">为什么是Debezium？</h2><p id="bafb" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">当数据在微服务中持久化时，该服务和其他微服务中的消费者对持久化的数据变化感兴趣。变更数据捕获(CDC)是一种监控和捕获这些变更的方法。Debezium提供的服务可以捕获数据变化，并将它们作为事件发出。与替代轮询方法相比，CDC避免了频繁轮询所增加的CPU负载，并且可以可靠地维护事件的顺序。</p><h1 id="2d77" class="nd mg iq bd mh ne nf ng mk nh ni nj mn nk nl nm mq nn no np mt nq nr ns mw nt bi translated">使用案例</h1><p id="9468" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi li translated">ost平台需要通过短信与用户交流。这可能是为了通知他们某些操作或事件，或者在用作双因素登录或升级安全的一部分时，经常发送一次性密码(OTP)。短信服务是微服务的绝佳候选，因为它只需要做一件事:发送短信。</p><p id="c0ce" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">最简单的方法是SMS微服务只代理选择的SMS提供商。该服务:</p><ul class=""><li id="41be" class="lr ls iq km b kn ko kr ks kv lt kz lu ld lv lh lw lx ly lz bi translated">接收发送SMS消息的请求</li><li id="d771" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">将其转换为所选SMS提供商所需的格式</li><li id="32c7" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">发送REST请求</li><li id="5991" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">将转换后的响应传递回调用者</li></ul><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/10c3112ca2f2bbc8b247b0e7bfa6926e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*x2Sp2-1hNqx2VsR9ytJb8Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图表1。作为第三方提供商代理的Sms服务</figcaption></figure><p id="a0e4" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这种方法没有太大的灵活性。服务的调用者必须等待来自第三方提供者的同步回复。如果存在网络故障，那么呼叫者必须再次发送消息或者继续重试。资源池耗尽导致级联故障的风险很高。最好是将调用解耦，并给服务的调用者一种检查状态的方法。</p><p id="f6c2" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为此，我们必须将持久性引入服务和消息传递，以保证交付。我们给流程增加了一些延迟，但增加了灵活性，使系统更有用。这让我们有机会在构建服务的同时尝试一些有趣的技术。</p><p id="ea20" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">最终的架构将如下所示:</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/b7ccb474d4bcd5ade8e281f637175fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqffmhAVmFPH44EajcE6SA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图2:最终架构</figcaption></figure><p id="5e1e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">对于这样一个简单的服务来说，这可能看起来很重要，但它允许我们练习在微服务平台的其他部分有用的模式。</p><p id="a06b" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们将分几个阶段进行构建:</p><ul class=""><li id="7604" class="lr ls iq km b kn ko kr ks kv lt kz lu ld lv lh lw lx ly lz bi translated">第1部分编写REST端点并添加持久性</li><li id="df75" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">第2部分通过添加Kafka和Debezium实现事务发件箱模式</li><li id="5dc9" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">第3部分添加SMS提供者和路由逻辑</li><li id="a648" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">第4部分使用OAuth保护端点</li><li id="590e" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated">第5部分使用GraalVM构建和部署本机映像</li></ul><h2 id="bea3" class="mf mg iq bd mh mi mj dn mk ml mm dp mn kv mo mp mq kz mr ms mt ld mu mv mw mx bi translated">第一阶段。编写REST端点</h2><p id="5b46" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">你可以把<a class="ae kc" href="https://github.com/iainporter/sms-service" rel="noopener ugc nofollow" target="_blank">代码</a>拉出来，我来浏览一下有趣和重要的部分。</p><pre class="nv nw nx ny gt oa ob oc od aw oe bi"><span id="f372" class="mf mg iq ob b gy of og l oh oi">git clone <a class="ae kc" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:iainporter/sms-service.git<br/>git checkout part_one</span></pre><p id="dfdb" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这是一个多模块maven项目，包含以下模块:</p><pre class="nv nw nx ny gt oa ob oc od aw oe bi"><span id="3bae" class="mf mg iq ob b gy of og l oh oi">&lt;modules&gt;<br/>    &lt;module&gt;sms-openapi&lt;/module&gt;<br/>    &lt;module&gt;sms-service&lt;/module&gt;<br/>    &lt;module&gt;component-test&lt;/module&gt;<br/>&lt;/modules&gt;</span></pre><h2 id="3843" class="mf mg iq bd mh mi mj dn mk ml mm dp mn kv mo mp mq kz mr ms mt ld mu mv mw mx bi translated">OpenApi</h2><p id="78af" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">遵循<a class="ae kc" href="https://swagger.io/resources/articles/adopting-an-api-first-approach/" rel="noopener ugc nofollow" target="_blank"> API优先</a>的方法，sms-openapi模块定义了服务的API。OpenAPI允许我们描述API并发布它，以便其他人可以使用它。在本模块中，我们将定义微服务将发布的所有端点。</p><p id="6a2d" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">定义了三个端点:</p><ul class=""><li id="7e12" class="lr ls iq km b kn ko kr ks kv lt kz lu ld lv lh lw lx ly lz bi translated"><strong class="km ir">/v1/短信发布</strong>【用于发送短信请求】</li><li id="1371" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated"><strong class="km ir"> /v1/sms/{messageId} GET </strong>【获取详细信息，包括消息的状态】</li><li id="362b" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated"><strong class="km ir"> /v1/sms GET </strong>【用于消息列表的查询和分页】</li></ul><p id="09dd" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">添加/v1/sms GET可能不是完全必要的，但它给了我们尝试Panache分页功能的机会。</p><p id="0998" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">下面是/v1/sms POST的定义</p><figure class="nv nw nx ny gt jr"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="0784" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">请求体被定义为</p><figure class="nv nw nx ny gt jr"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7222" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">模块中有一些实用程序，用于根据规范生成html API文档。如果要生成文档，则必须安装节点和NPM。执行以下操作:</p><pre class="nv nw nx ny gt oa ob oc od aw oe bi"><span id="612d" class="mf mg iq ob b gy of og l oh oi">cd sms-openapi<br/>mvn package<br/>npx redoc-cli bundle  ./target/classes/openapi/sms-openapi.yaml -t ./custom-template.hbs -o sms-openapi.html</span></pre><p id="b29e" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">然后，您可以查看生成的API文档，它看起来类似于:</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/4cf7eb8f236af31bd222a7e32a35c649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jA7nSExV8ohd4h16S1TrkA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图3 OpenAPI</figcaption></figure><p id="77c8" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">一旦构建了这个模块，那么生成的POJOs就被打包到一个jar中，并且可以被sms服务模块引用</p><h2 id="d532" class="mf mg iq bd mh mi mj dn mk ml mm dp mn kv mo mp mq kz mr ms mt ld mu mv mw mx bi translated">资源类</h2><figure class="nv nw nx ny gt jr"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="be96" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">需要注意的事项:</p><p id="da24" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">第11–18行创建新SMS消息的POST调用SmsService，后者保存请求，然后添加一个位置头以允许调用者检索消息细节。注意生成的POJO类SendSmsRequest的使用。<br/>第22–23行检索邮件列表最有用的查询参数是号码和状态</p><h2 id="8a75" class="mf mg iq bd mh mi mj dn mk ml mm dp mn kv mo mp mq kz mr ms mt ld mu mv mw mx bi translated">SMS服务类</h2><figure class="nv nw nx ny gt jr"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="03eb" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">持久层使用<a class="ae kc" href="https://quarkus.io/guides/hibernate-orm-panache-kotlin" rel="noopener ugc nofollow" target="_blank"> Panache </a>，它是Hibernate ORM之上的一层。任何习惯使用Spring数据的人在习惯使用Panache时都不会有问题。下面是存储库类:</p><pre class="nv nw nx ny gt oa ob oc od aw oe bi"><span id="4840" class="mf mg iq ob b gy of og l oh oi">@ApplicationScoped<br/>class MessageRepository : PanacheRepositoryBase&lt;SmsMessage, UUID&gt;</span></pre><p id="9653" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">使用存储库模式时，所有预期的查找器方法都是可用的。第45–48行演示了分页功能。</p><h2 id="ffdc" class="mf mg iq bd mh mi mj dn mk ml mm dp mn kv mo mp mq kz mr ms mt ld mu mv mw mx bi translated">候鸟迁徙所经的路径</h2><p id="c91a" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">数据库迁移由一个<a class="ae kc" href="https://flywaydb.org/" rel="noopener ugc nofollow" target="_blank"> flyway </a>扩展处理，并遵循定义良好的命名约定</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/02d8e681b617811bd4e4219380427672.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*bC9sNhgVGdl6R6qAimJFyw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图4飞行路线迁移</figcaption></figure><h2 id="f80f" class="mf mg iq bd mh mi mj dn mk ml mm dp mn kv mo mp mq kz mr ms mt ld mu mv mw mx bi translated">组件测试</h2><p id="a37a" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">我们还没有构建足够的组件测试，但测试服务是否可以在docker容器中成功运行仍然是有用的，因为到目前为止它只依赖于一个真实的数据库，而不是H2。</p><h2 id="ff3b" class="mf mg iq bd mh mi mj dn mk ml mm dp mn kv mo mp mq kz mr ms mt ld mu mv mw mx bi translated">测试容器</h2><p id="5274" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">我多么喜欢测试容器。它极大地简化了在docker容器中运行和测试栈的过程。目前我们只有两个容器，所以我们可以使用docker-compose文件来描述这些服务并启动它们</p><h2 id="041d" class="mf mg iq bd mh mi mj dn mk ml mm dp mn kv mo mp mq kz mr ms mt ld mu mv mw mx bi translated">docker-compose.yml</h2><figure class="nv nw nx ny gt jr"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="0eee" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">然后我们可以在组件测试的设置中引用这个文件</p><figure class="nv nw nx ny gt jr"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="8a13" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在第5行，我们获得了testcontainers公开的映射端口，并将其设置为RestAssured的基本Url</p><p id="4d11" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">下面是一个测试，证明我们可以发送消息并检索结果</p><figure class="nv nw nx ny gt jr"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h2 id="c8e7" class="mf mg iq bd mh mi mj dn mk ml mm dp mn kv mo mp mq kz mr ms mt ld mu mv mw mx bi translated">运行服务</h2><p id="87f3" class="pw-post-body-paragraph kk kl iq km b kn my kp kq kr mz kt ku kv na kx ky kz nb lb lc ld nc lf lg lh ij bi translated">我们还可以使用docker-compose来启动我们需要的所有组件。<br/>从父目录</p><pre class="nv nw nx ny gt oa ob oc od aw oe bi"><span id="aff1" class="mf mg iq ob b gy of og l oh oi">mvn clean install<br/>cd sms-service<br/>docker-compose up</span></pre><p id="6bca" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">服务运行后，您可以向它发送消息</p><pre class="nv nw nx ny gt oa ob oc od aw oe bi"><span id="5725" class="mf mg iq ob b gy of og l oh oi">curl 'http://localhost:8080/v1/sms' -i -X POST  \<br/>   -H 'Content-Type: application/json'  \<br/>   -d '{"text":"Foo Bar!", "fromNumber": "+1234567890", "toNumber": "+1234567891"}'</span></pre><p id="0448" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">您应该会收到带有位置的响应</p><pre class="nv nw nx ny gt oa ob oc od aw oe bi"><span id="7e48" class="mf mg iq ob b gy of og l oh oi">HTTP/1.1 202 Accepted<br/>Content-Length: 0<br/>Location: <a class="ae kc" href="http://localhost:8080/v1/sms/bbb07300-4b30-45ed-97c5-a4c1b72f3fc2" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v1/sms/bbb07300-4b30-45ed-97c5-a4c1b72f3fc2</a></span></pre><p id="33c4" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">您可以使用它来获取消息细节</p><pre class="nv nw nx ny gt oa ob oc od aw oe bi"><span id="2f86" class="mf mg iq ob b gy of og l oh oi">curl '<a class="ae kc" href="http://localhost:8080/v1/sms/bbb07300-4b30-45ed-97c5-a4c1b72f3fc2" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v1/sms/bbb07300-4b30-45ed-97c5-a4c1b72f3fc2</a>' -i -X GET</span></pre><p id="f8b3" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">期待类似以下内容的响应</p><pre class="nv nw nx ny gt oa ob oc od aw oe bi"><span id="5061" class="mf mg iq ob b gy of og l oh oi">HTTP/1.1 200 OK<br/>Content-Length: 218<br/>Content-Type: application/json</span><span id="6855" class="mf mg iq ob b gy on og l oh oi">{"createdAt":"2020-07-18T08:42:43.772795Z","fromNumber":"+1234567890","id":"bbb07300-4b30-45ed-97c5-a4c1b72f3fc2","status":"WAITING","text":"Foo Bar!","toNumber":"+1234567891","updatedAt":"2020-07-18T08:42:43.772808Z"}</span></pre><p id="13b3" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">第一部分完成了。虽然离生产就绪还有一段距离，但框架已经到位。我们现在可以在数据库中捕获消息，并对这些消息的状态给出一些反馈。作为奖励，我们可以查询邮件和页面的结果。在下一篇文章中，我们将介绍消息传递和事件处理，这样我们就可以处理被持久化的消息。</p><p id="95fd" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">本文的代码库可以在<a class="ae kc" href="https://github.com/iainporter/sms-service/tree/part_one" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><p id="8c3a" class="pw-post-body-paragraph kk kl iq km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">该系列的其他部分包括:</p><ul class=""><li id="b842" class="lr ls iq km b kn ko kr ks kv lt kz lu ld lv lh lw lx ly lz bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/implementing-the-transactional-outbox-pattern-with-debezium-in-quarkus-f2680306951">第二部分:使用Kafka Connect和Debezium实现CDC</a></li><li id="5684" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/building-a-resilient-microservice-with-quarkus-and-wiremock-de59b2a4fac7">第三部分:连接到第三方API并用Wiremock进行测试</a></li><li id="4dcc" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/securing-a-microservice-in-quarkus-with-openid-connect-505204d1c9a9">第四部分:使用OpenID Connect保护服务</a></li><li id="e4d5" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated"><a class="ae kc" href="https://medium.com/@changeant/running-a-microservice-in-quarkus-on-graalvm-52d6b42a5840" rel="noopener">第五部分:使用GraalVM本机运行</a></li><li id="9227" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated"><a class="ae kc" href="https://medium.com/@changeant/containerizing-your-microservice-in-quarkus-with-jib-fae0f62bd57e" rel="noopener">第六部分:用Jib封装你的微服务</a></li><li id="d5b0" class="lr ls iq km b kn ma kr mb kv mc kz md ld me lh lw lx ly lz bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/building-a-ci-pipeline-for-a-microservice-in-quarkus-with-circleci-11e9b679423f">第七部分:使用CircleCI为微服务构建CI管道</a></li></ul></div></div>    
</body>
</html>