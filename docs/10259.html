<html>
<head>
<title>Serverless Event-Driven Systems 🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器事件驱动系统🚀</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/serverless-event-driven-systems-9617c6406064?source=collection_archive---------0-----------------------#2021-11-14">https://levelup.gitconnected.com/serverless-event-driven-systems-9617c6406064?source=collection_archive---------0-----------------------#2021-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/16a17eea0abc1bfce0ee1a89715ad6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hCOi2_Su1nyj5E9fnP5uXA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/s/photos/event?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jd" href="https://unsplash.com/@noiseporn?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Noiseporn </a>拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="c14a" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">如何以及为什么应该首先使用Amazon EventBridge构建事件驱动的无服务器架构，以及需要考虑的一些陷阱；包括视觉效果和使用TypeScript和无服务器框架的相关代码报告。</h2></div><h1 id="a2c7" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">介绍</h1><p id="ba75" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这篇文章旨在解释为什么在构建无服务器架构时，你应该有一个事件驱动优先的心态，以及为什么<a class="ae jd" href="https://aws.amazon.com/eventbridge/" rel="noopener ugc nofollow" target="_blank"> Amazon EventBridge </a>应该支持它们。我们还将讨论在使用最终一致的事件驱动系统时可能遇到的一些陷阱。这篇文章的基本代码可以在这里找到:<a class="ae jd" href="https://github.com/leegilmorecode/serverless-event-bridge" rel="noopener ugc nofollow" target="_blank">https://github.com/leegilmorecode/serverless-event-bridge</a></p><blockquote class="mj"><p id="4325" class="mk ml jg bd mm mn mo mp mq mr ms mi dk translated">这篇文章旨在解释为什么在构建无服务器架构时应该有一个事件驱动优先的心态</p></blockquote><p id="1293" class="pw-post-body-paragraph ln lo jg lp b lq mt kh ls lt mu kk lv lw mv ly lz ma mw mc md me mx mg mh mi ij bi translated">我们将继续上一篇关于“无服务器威胁建模”的文章，在这篇文章中，我们构建了我们虚构的<strong class="lp jh"> <em class="my"> LeeJames HR </em> </strong>软件</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mz"><img src="../Images/0b9b88e739bd8a2a8a922c79d1167f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n33boCXNmni-lS0B.png"/></div></div></figure><p id="81c6" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">这将在以下文章中介绍:</p><div class="ip iq gp gr ir nj"><a href="https://leejamesgilmore.medium.com/serverless-threat-modelling-df8e4028ef6d" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd jh gy z fp no fr fs np fu fw jf bi translated">无服务器威胁建模🚀</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">您应该如何以及为什么在AWS上对您的无服务器解决方案进行威胁建模，并提供真实生活中的可视化示例</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">leejamesgilmore.medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ix nj"/></div></div></a></div><p id="f814" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">如果您已经很好地掌握了如何将Amazon EventBridge与TypeScript结合使用，那么可以直接跳到下面一节:<strong class="lp jh"> <em class="my">解决方案中的问题&amp;缓解措施！</em>😈</strong></p><h2 id="7072" class="ny kw jg bd kx nz oa dn lb ob oc dp lf lw od oe lh ma of og lj me oh oi ll oj bi translated">索引</h2><ol class=""><li id="445e" class="ok ol jg lp b lq lr lt lu lw om ma on me oo mi op oq or os bi translated">我们在建造什么？</li><li id="5c29" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated">同步与异步</li><li id="71c5" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated">事件驱动系统的主要好处是什么？</li><li id="8bf7" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated">事件和命令</li><li id="634e" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated">使用Amazon EventBridge的事件驱动系统</li><li id="d4f3" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated">部署解决方案</li><li id="2584" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated">测试解决方案</li><li id="6262" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated">解决方案中的问题和缓解措施！😈</li></ol><p id="c6f6" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">我们开始吧！🚀</p><h2 id="ecae" class="ny kw jg bd kx nz oa dn lb ob oc dp lf lw od oe lh ma of og lj me oh oi ll oj bi translated">我们在建造什么？🏗️</h2><p id="d4da" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们将构建<strong class="lp jh"> LeeJames HR </strong>系统的一部分，它负责从我们的客户端应用程序上传客户工资单，以及生成PDF版本并将其存储在<a class="ae jd" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank">亚马逊S3 </a>的独立域服务。</p><p id="1225" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">💡<em class="my">请注意，这是允许我们讨论文章要点的最基本的代码和架构，因此这不是生产就绪，也不符合编码最佳实践</em>。<em class="my">(例如，在端点上没有认证)。我也尽量不把代码分割得太多，这样下面的例子文件很容易查看，所有的依赖关系都在一个文件中。</em></p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oy"><img src="../Images/dea80323308092d72a61f93bbbd31727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUGhgBWhiDpC9HdkxOXUSw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">我们将构建的示例</figcaption></figure><h1 id="abc7" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">同步与异步🚀</h1><p id="9c97" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">当开始使用无服务器时，使用像<a class="ae jd" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> Amazon API Gateway </a>和<a class="ae jd" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>这样的服务来构建域服务是相当容易的，然后通过使用HTTPS请求在它们之间同步调用来构建更大的企业架构。然而这:</p><ol class=""><li id="a6d2" class="ok ol jg lp b lq ne lt nf lw oz ma pa me pb mi op oq or os bi translated"><strong class="lp jh">增加延迟</strong>。增加了终端用户的呼叫延迟，因为他们要等待所有HTTPS请求按顺序解决。</li><li id="bec5" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated"><strong class="lp jh">非常脆</strong>。这使得整个体系结构高度耦合——对于任何故障都非常脆弱。</li></ol><p id="f1c6" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">如下图所示:</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pc"><img src="../Images/4d78ac74a6b255259c332072129fdc79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VtqBWb5YaoKZfj1D"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">许多域服务同步地相互调用</figcaption></figure><p id="f188" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">当其中一个下游服务出现问题时(例如一个数据库的CPU或内存出现问题时)，我们会发现所有东西都坏了，因为它们都是完全耦合的:</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pc"><img src="../Images/4dc643bb66389d8c9a6ab46c36d8b592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3c7BKKr-4IN9ahXt"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">一个域服务关闭会影响所有其他服务</figcaption></figure><p id="d9e4" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">这是因为所有的域服务都知道彼此的存在，并且有着内在的联系——所以当一个服务出现问题时，您会发现会产生多米诺骨牌效应。<strong class="lp jh">领域驱动开发的一个更好的方法</strong>是让您的服务松散耦合，尽可能只通过使用事件进行通信(如下所示<em class="my"/>):</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pd"><img src="../Images/2e8edafa9cc39827179c151ee11012f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tbg5okmkr-i4AYRN"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">使用EventBridge的松散耦合的域服务</figcaption></figure><p id="0cca" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">这确保了如果一个系统停机或有问题，当服务仅返回时，事件可以被重新处理，即最终一致和异步；其他域服务不受影响。这通常是使用死信队列来完成的，其中在可配置的重试次数之后，未处理的记录跟随错误前进。当域服务重新联机时，可以安全地重新处理它们。</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pd"><img src="../Images/ad9f02daa42feb3a4a13511190265072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M27GXOFhifwpDQqGflsOxQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">一旦域服务重新联机，就可以使用死信队列处理失败的事件</figcaption></figure><p id="1c73" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">从上图中可以看到，除了右下角的一个服务外，所有域服务都保持在线，但是它的失败记录被安全地保存起来以供重新处理，因此您的客户不会意识到任何问题。</p><h1 id="b586" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">事件驱动系统的主要好处是什么？💭</h1><p id="67f0" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">事件驱动系统有许多好处，下面将讨论:</p><ol class=""><li id="dc63" class="ok ol jg lp b lq ne lt nf lw oz ma pa me pb mi op oq or os bi translated"><strong class="lp jh">域服务是可单独测试的</strong>。您可以孤立地测试一个域服务，而不需要与其他几个团队协作，也不需要多个依赖项。</li><li id="4a1e" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated"><strong class="lp jh">域服务可以单独部署</strong>。同样，只要事件模式没有改变，您可以独立地部署您的域服务，而不依赖于其他团队。</li><li id="a045" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated"><strong class="lp jh">事件的共享版本化模式</strong>。历史上，团队会通过Nuget或NPM包与实际代码共享契约，而现在，团队可以简单地共享版本化的模式，以便以松散耦合的方式开发、测试和部署工作。这减少了团队之间的整体依赖性。</li><li id="0f66" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated">他们有自己的数据存储。域服务应该有自己的数据存储(<em class="my">通常是数据库</em>)，所以它们在数据层没有这种依赖性。如果域服务有一个共享的数据库，它们就会变得紧密耦合，冒着交叉感染bug、部署问题和安全风险的风险。</li><li id="0f27" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated"><strong class="lp jh">完全解耦</strong>。域服务不应该互相知道。生产者可以生产事件，而不关心哪些消费者在使用它们。消费者也不关心谁制造了这些事件。</li><li id="bc84" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated"><strong class="lp jh">它们可以独立伸缩</strong>。领域服务可以独立扩展，不需要其他团队和领域服务之间的关注和协调。</li></ol><h1 id="ca92" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">事件和命令</h1><p id="9dd6" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">因此，我们已经在上面讨论了拥有“事件驱动”的思维模式，事件驱动架构的好处，以及通过“事件”构建您的架构，使其解耦并最终保持一致— <strong class="lp jh">但什么是事件</strong>？</p><blockquote class="mj"><p id="71bb" class="mk ml jg bd mm mn mo mp mq mr ms mi dk translated">“通过使用事件消息，您可以很容易地在身份(您广播事件而不关心谁响应它们)和时间(当接收者准备好处理事件时，事件可以排队并转发)方面分离发送者和接收者。由于这种松散耦合，这种架构提供了大量的可伸缩性和可修改性。”—马丁·福勒</p></blockquote><h2 id="c92d" class="ny kw jg bd kx nz pe dn lb ob pf dp lf lw pg oe lh ma ph og lj me pi oi ll oj bi translated">事件</h2><p id="eaf8" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">一个<strong class="lp jh">事件</strong>是一个域内的状态变化(<em class="my">过去已经发生的并且不可改变的</em>)。一个例子是'<em class="my">订单生成</em>或'<em class="my">发票生成</em>'。这通常意味着一个或多个消费者可以对该事件做出反应。</p><h2 id="67d1" class="ny kw jg bd kx nz oa dn lb ob oc dp lf lw od oe lh ma of og lj me oh oi ll oj bi translated">命令</h2><p id="99bf" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">一个<strong class="lp jh">命令</strong>是一个针对另一个域的意图，它导致一些输出(<em class="my">将来会发生的事情</em>)。例如'<em class="my">发送电子邮件</em>或'<em class="my">生成pdf </em>'。这通常是一对一的映射，生产者希望消费者处理重试和失败。</p><p id="82dd" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">如下图所示:</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/4b11ddee290b2b31625e9b837ad6bbf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/0*Ev6blB9K0F8_lAqh"/></div></figure><h1 id="e192" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">使用Amazon EventBridge的事件驱动系统</h1><blockquote class="pk pl pm"><p id="bd08" class="ln lo my lp b lq ne kh ls lt nf kk lv pn ng ly lz po nh mc md pp ni mg mh mi ij bi translated">“Amazon EventBridge是一种无服务器事件总线，使用您的应用程序、集成的软件即服务(SaaS)应用程序和AWS服务生成的事件，可以更轻松地构建大规模事件驱动的应用程序。”——AWS</p></blockquote><p id="ac95" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">现在，我们已经讨论了为什么我们要设计事件驱动的无服务器架构，并且讨论了什么是事件和命令。</p><p id="8b3e" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">现在让我们来看看Amazon EventBridge作为AWS上的一个无服务器事件总线，以及它在无服务器世界中如此重要的原因。</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="pq pr l"/></div></figure><p id="be95" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">Amazon EventBridge应该是无服务器事件驱动架构的默认选择，原因如下:</p><ol class=""><li id="eeea" class="ok ol jg lp b lq ne lt nf lw oz ma pa me pb mi op oq or os bi translated"><strong class="lp jh">没有需要维护或管理的服务器</strong>。它是完全无服务器的，允许我们以最小的开销分离我们的域服务。</li><li id="3fe5" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated"><strong class="lp jh">使用注册表的模式发现</strong>。共享事件模式在历史上一直很困难，但是模式注册中心允许我们在一个地方轻松地在域和团队之间找到和共享模式结构。<a class="ae jd" href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-schema.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/event bridge/latest/user guide/e b-schema . html</a></li><li id="6c6e" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated"><strong class="lp jh">模式代码生成</strong>。EventBridge允许团队查看他们需要的事件模式版本，并自动下载代码绑定以直接拉入他们的代码。<a class="ae jd" href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-schema-code-bindings.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/event bridge/latest/user guide/e b-schema-code-bindings . html</a></li><li id="c1d6" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated"><strong class="lp jh">基于内容的过滤</strong>。基于内容的过滤，甚至在正文级别，允许我们只消费我们感兴趣的事件。<br/><a class="ae jd" href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-patterns-content-based-filtering.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/event bridge/latest/user guide/EB-event-patterns-content-based-filtering . html</a></li><li id="586f" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated"><strong class="lp jh">输入转换</strong>。输入转换允许我们转置事件结构来满足消费者的需求，而不需要编写特定的粘合代码。</li><li id="c654" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated"><strong class="lp jh">存档和回放</strong>。EventBridge允许您将事件存档，并在以后重放它们。当您需要在bug修复后重放事件，或者填充新域服务的读取存储时，这是非常棒的。<a class="ae jd" href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-archive.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/event bridge/latest/user guide/e b-archive . html</a></li><li id="018e" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated"><strong class="lp jh">静止加密。</strong> EventBridge对其存储的事件元数据和消息数据进行加密。默认情况下，EventBridge使用256位高级加密标准(<em class="my"> AES-256 </em>)在<a class="ae jd" href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk" rel="noopener ugc nofollow" target="_blank"> AWS拥有的密钥</a>下加密数据，这有助于保护您的数据免受未经授权的访问。使用AWS拥有的密钥加密您的数据无需额外付费。<br/><a class="ae jd" href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-data-protection.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/event bridge/latest/user guide/e b-data-protection . html</a></li><li id="b4ef" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated"><strong class="lp jh">传输中的加密</strong>。EventBridge通过使用传输层安全性(<em class="my"> TLS </em>)对EventBridge和其他服务之间传递的数据进行加密。</li></ol><h1 id="81f0" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">部署解决方案！👨‍💻</h1><blockquote class="pk pl pm"><p id="5986" class="ln lo my lp b lq ne kh ls lt nf kk lv pn ng ly lz po nh mc md pp ni mg mh mi ij bi translated"><em class="jg"> 🛑 </em> <strong class="lp jh"> <em class="jg">注意</em> </strong> <em class="jg"> : </em>运行以下命令将在您的AWS账户上产生费用。</p></blockquote><p id="ae3a" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">让我们在这里部署您可以克隆的代码示例:<a class="ae jd" href="https://github.com/leegilmorecode/serverless-event-bridge" rel="noopener ugc nofollow" target="_blank">https://github.com/leegilmorecode/serverless-event-bridge</a></p><p id="6cd5" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">一旦您克隆了存储库，您就可以运行<code class="fe ps pt pu pv b">npm i</code>来安装所有的依赖项，然后运行<code class="fe ps pt pu pv b">npm run deploy:develop</code>来将代码部署到AWS。</p><h1 id="d9bb" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">测试解决方案🎯</h1><p id="1351" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">一旦您部署了解决方案，您就可以使用<code class="fe ps pt pu pv b">./postman/serverlerss-event-bridge.postman_collection.json</code>中的postman文件来调用POST API端点来上传一个虚构的工资单。</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pw"><img src="../Images/a352a1b99b49e44525ea5d7f76a669d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X5UzwcoiTfxh0XInR5aVGQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">示例调用Postman来调用我们的API</figcaption></figure><blockquote class="pk pl pm"><p id="b6b9" class="ln lo my lp b lq ne kh ls lt nf kk lv pn ng ly lz po nh mc md pp ni mg mh mi ij bi translated"><em class="jg"> 🛑 </em> <strong class="lp jh"> <em class="jg">注</em> </strong>:您需要将Postman中的API变量更新为部署中为您的端点返回的任何无服务器框架:</p></blockquote><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi px"><img src="../Images/41740f20fc1f292a0e3f9cdc53d93189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V2-nYoJFq8UobuTqr_MJJg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">来自端点服务框架的API响应示例</figcaption></figure><p id="3bd8" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">现在，当您调用API时，您将得到一条<code class="fe ps pt pu pv b">‘Created’</code>消息(<em class="my"> 201状态代码</em>)，当您导航到存储PDF的S3存储区时，您应该会看到每个工资单PDF的以下内容:</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi py"><img src="../Images/f6726a60f873342f3e4aa76ae8c11f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bUJ26fH3VdNYlDA2Bvxaw.png"/></div></div></figure><p id="26f7" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated"><strong class="lp jh">好吧，好吧..不是世界上最好看的工资条PDF文件，但足以展示架构，我相信你会同意！</strong>😅</p><p id="42fe" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">同样值得注意的是，本演示的工资条模式本身在<a class="ae jd" href="https://www.staffology.co.uk/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh"> Staffology </strong> </a>记入团队名下，这里:【https://app.staffology.co.uk/api/docs/models/payslip】T4</p><h1 id="45fe" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">解决方案中的问题和缓解措施！😈</h1><p id="948b" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">当构建新的无服务器架构或从单片服务器迁移时，有必要规划以下部分，以确保您的解决方案能够<strong class="lp jh"> <em class="my">应对故障</em> </strong>。您刚刚部署的解决方案展示了以下内容:</p><h2 id="205c" class="ny kw jg bd kx nz oa dn lb ob oc dp lf lw od oe lh ma of og lj me oh oi ll oj bi translated">考虑幂等性</h2><p id="3a28" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">将您的服务构建为<a class="ae jd" href="https://en.wikipedia.org/wiki/Idempotence" rel="noopener ugc nofollow" target="_blank">等幂</a>，这样如果您不止一次地获得相同的事件输入，您将总是获得相同的结果。例如，如果您错误地收到两个付款事件，您不想对您的客户进行两次计费！呀!..</p><p id="4d0c" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">EventBridge保证至少传递一次，但是消费者可以多次获得相同的消息。</p><blockquote class="pk pl pm"><p id="726a" class="ln lo my lp b lq ne kh ls lt nf kk lv pn ng ly lz po nh mc md pp ni mg mh mi ij bi translated">Amazon EventBridge向目标提供至少一次事件交付，包括长达24小时的指数补偿重试。事件跨多个可用性区域(az)持久存储，为您的事件发送到目的地提供了额外的保证。Amazon EventBridge还提供99.99%可用性服务级别协议(SLA)，确保您的应用程序能够可靠地访问服务。</p></blockquote><p id="c3de" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">有几种方法可以减轻这种情况(<em class="my">或它们的组合</em>):</p><ol class=""><li id="fbce" class="ok ol jg lp b lq ne lt nf lw oz ma pa me pb mi op oq or os bi translated"><strong class="lp jh">等幂键</strong>。您可以允许API的消费者在头或数据体中传递幂等键，这允许您在域服务中检查该请求是否已经被处理，并相应地采取行动而不会引起问题。这允许消费者重试请求，而不用担心副作用。</li><li id="6ae3" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated"><strong class="lp jh">使用UUID v5 </strong>。您可以在有效载荷中使用带有名称空间和唯一属性的UUID版本5(<em class="my">无论它是事件、消息还是API </em>)，并且您将总是得到相同的生成的UUID。在我看来，这是一个非常好的方法，我们在回购中使用了这种方法。</li><li id="cb84" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated">控制数据库。您可以使用DynamoDB之类的控制数据库来存储成功的请求(<em class="my">使用幂等键或V5生成的UUIDs，例如</em>)，如果您两次收到相同的请求，您可以简单地吞下请求并返回前一个成功的有效负载响应。错误响应也是如此。</li></ol><p id="d3be" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">在我们的代码回购示例中，我们使用员工ID和工资单期间以及UUID名称空间(<em class="my">以防止UUID冲突)</em>，然后使用这个“工资单ID”来检查代码，看我们之前是否已经创建了工资单PDF。这使我们能够确保您只能上传一次工资单，并保证只生成一次。我通常会使用DynamoDB之类的数据存储来完成这项工作，但是对于这个简单的演示，我们只需检查该文件是否已经存在于S3。</p><h2 id="8d0e" class="ny kw jg bd kx nz oa dn lb ob oc dp lf lw od oe lh ma of og lj me oh oi ll oj bi translated">使用FIFO队列重复删除事件消息</h2><p id="6406" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在我们的例子中，事件从EventBridge直接流向SQS FIFO队列，并且打开了<code class="fe ps pt pu pv b">Content-based deduplication</code>，同时将<code class="fe ps pt pu pv b">Deduplication scope</code>设置为<code class="fe ps pt pu pv b">Queue</code>级别；这意味着在五分钟的时间内，如果我们在队列中获得具有相同有效负载的相同SQS消息，它将被忽略。也就是说，注意在这个场景中，消息复制id是'<strong class="lp jh">可选的</strong>'。(<em class="my">见下文</em>)</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pz"><img src="../Images/1ca6090d929517ddeb1778046d58f83a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJ_SwE5LXnffJ6pQT9H0hQ.png"/></div></div></figure><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qa"><img src="../Images/844ef57490f89ac18f95e4983f156b1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LPBHVGl80n8LJkj3Eo6iZA.png"/></div></div></figure><blockquote class="pk pl pm"><p id="fb4f" class="ln lo my lp b lq ne kh ls lt nf kk lv pn ng ly lz po nh mc md pp ni mg mh mi ij bi translated">为队列启用基于内容的重复数据删除(您的每封邮件都有唯一的正文)。生成器可以省略消息重复数据删除ID—<a class="ae jd" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/awssimplequeuservice/latest/SQSDeveloperGuide/using-messagededuplicationid-property . html</a></p></blockquote><p id="8e79" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">这里有一个问题，假设我们的EventBridge规则中的事件以我们的FIFO SQS队列为目标，这意味着SQS将默认在五分钟内基于相同的事件主体对我们的事件进行重复数据删除。</p><p id="70e6" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">碰巧在这个规则集成中，Amazon EventBridge规则默认发送<em class="my">MessageDeduplicationId</em><strong class="lp jh"/>，所以如果我们在<code class="fe ps pt pu pv b">putEvents</code>命令中用完全相同的主体将相同的条目添加到entries数组中，每个条目都将获得自己的<em class="my"> MessageDeduplicationId </em>，<strong class="lp jh">，并且它们不会像您可能期望的那样在FIFO队列</strong>中进行重复数据删除。</p><p id="1946" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">这是因为EventBridge自动将<code class="fe ps pt pu pv b">PutEventsRequestEntry</code>的<code class="fe ps pt pu pv b">EventID</code>属性设置为一个随机UUID，该出现在SQS消息正文中，所以当MessageDeduplicationID作为正文的SHA256哈希生成时，它每次都是不同的！</p><blockquote class="pk pl pm"><p id="d806" class="ln lo my lp b lq ne kh ls lt nf kk lv pn ng ly lz po nh mc md pp ni mg mh mi ij bi translated">调用PutEvents后，EventBridge会为每个事件分配一个唯一的ID—<a class="ae jd" href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-putevents.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/event bridge/latest/user guide/e b-put events . html</a></p></blockquote><p id="28f3" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated"><strong class="lp jh">我们如何解决这个</strong>？我们可以使用输入转换来省略事件中的<code class="fe ps pt pu pv b">Event ID</code>,就像这样，这意味着我们所有的事件现在都在FIFO队列中进行重复数据删除:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="qb pr l"/></div></figure><h2 id="f7e6" class="ny kw jg bd kx nz oa dn lb ob oc dp lf lw od oe lh ma of og lj me oh oi ll oj bi translated">SQS和失败的消息</h2><p id="fc46" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">当您使用亚马逊SQS对来自EventBridge的事件消息进行批处理时，您需要考虑如果批处理中的一个或多个记录失败(<em class="my">，即通过您的Lambda代码抛出一个错误</em>)，那么整个批处理将回到队列中重新处理。这意味着:</p><ol class=""><li id="440b" class="ok ol jg lp b lq ne lt nf lw oz ma pa me pb mi op oq or os bi translated">您的代码需要是等幂的，以确保同一批记录可以被多次处理，而不会导致问题。(<em class="my">例如多次从客户处获得相同的付款</em>)。</li><li id="79c8" class="ok ol jg lp b lq ot lt ou lw ov ma ow me ox mi op oq or os bi translated">理想情况下，您需要一种方法来忽略批处理中已经成功处理的记录。</li></ol><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/d9a8553c695aa008d0f1f9ddce074fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*oFJbmjhoPXCmYEO5.png"/></div></figure><p id="2c67" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">对于第二点，您可以使用<a class="ae jd" href="https://www.npmjs.com/package/@middy/sqs-partial-batch-failure" rel="noopener ugc nofollow" target="_blank">Middy‘SQS部分批处理失败’</a>中间件，在批处理进入DLQ之前，成功地从批处理中删除已处理的记录。这意味着当Lambda选择批处理进行重新处理时，只有失败的记录保留下来。</p><h2 id="a3ea" class="ny kw jg bd kx nz oa dn lb ob oc dp lf lw od oe lh ma of og lj me oh oi ll oj bi translated">模式注册表的版本事件</h2><p id="87aa" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">仅在开发阶段使用模式注册表自动发现模式，因为如果在生产阶段继续使用，成本会很高！</p><p id="ff58" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">您还可以将自己的OpenAPI 3.0模式手动添加到模式注册中心，以便在域服务和团队之间共享它们。这是我采取的方法。</p><h2 id="375d" class="ny kw jg bd kx nz oa dn lb ob oc dp lf lw od oe lh ma of og lj me oh oi ll oj bi translated">事件携带状态转移</h2><p id="c0dd" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">EventBridge的最大消息大小是256kb，这对于大多数应用程序来说通常是合适的，但请记住，对于大于这个大小的消息，AWS建议将事件有效负载放入亚马逊S3，并在事件中包含指向它的链接或元数据。</p><blockquote class="mj"><p id="be3c" class="mk ml jg bd mm mn mo mp mq mr ms mi dk translated">当您希望以这样一种方式更新系统的客户机，使它们不需要联系源系统来做进一步的工作时，就会出现这种模式。每当客户更改他们的详细信息(如地址)时，客户管理系统可能会用包含已更改数据详细信息的事件来触发事件。然后，接收方可以用这些更改更新它自己的客户数据副本，这样它就永远不需要为了将来的工作而与主客户系统通信。</p><p id="74e3" class="mk ml jg bd mm mn mo mp mq mr ms mi dk translated">这种模式的一个明显的缺点是有大量的数据和副本。但在一个储存丰富的时代，这不是什么问题。我们获得的是更大的弹性，因为如果客户系统变得不可用，接收系统可以运行。—马丁·福勒</p></blockquote><p id="4a19" class="pw-post-body-paragraph ln lo jg lp b lq mt kh ls lt mu kk lv lw mv ly lz ma mw mc md me mx mg mh mi ij bi translated">在我们的示例中，当两个独立的域服务需要工资单徽标(<em class="my">图像</em>)时，我们会这样做，该徽标是通过API网关(<em class="my">显示在</em>下方)上传的，但是徽标正文不适合事件本身。</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qd"><img src="../Images/631ca601c9e5cee9f559bbaac091f554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HV6qh3yPT-MobX13MK8oyQ.png"/></div></div></figure><p id="211e" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">在我们的场景中，我们将图像存储在S3桶中，并将桶和键作为数据添加到<code class="fe ps pt pu pv b">payslip.uploaded</code>事件本身中(<em class="my">，因为图像本身无法容纳在256kb的事件</em>中)，因此当PDF Generation lambda使用该事件时，它可以从S3桶中获取PDF所需的徽标。</p><h2 id="8a94" class="ny kw jg bd kx nz oa dn lb ob oc dp lf lw od oe lh ma of og lj me oh oi ll oj bi translated">发布路由事件</h2><p id="9656" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">有时，由于IAM问题，Amazon EventBridge可能无法将事件路由到目标，例如，如果引入了错误，那么您可以使用标准SQS队列作为死信队列来存储失败的事件，直到您解决了问题:</p><div class="ip iq gp gr ir nj"><a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rule-dlq.html" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd jh gy z fp no fr fs np fu fw jf bi translated">事件重试策略和使用死信队列</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">有时，事件没有成功传递到规则中指定的目标。这可能发生在，例如…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">docs.aws.amazon.com</p></div></div></div></a></div><p id="54df" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">如果我们在我们的解决方案中实现了这一点，那么它应该在这里，添加一个DLQ，以防EventBridge无法将事件路由到我们的PDF生成SQS FIFO队列:</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qe"><img src="../Images/cb5bfe2063952ce359f71b1b9833f0da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ly_GPM5GwkG5jOogbrxmg.png"/></div></div></figure><p id="09eb" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">下面的视频对此进行了进一步的探讨:</p><figure class="na nb nc nd gt is"><div class="bz fp l di"><div class="pq pr l"/></div></figure><h2 id="3496" class="ny kw jg bd kx nz oa dn lb ob oc dp lf lw od oe lh ma of og lj me oh oi ll oj bi translated">潜在地使用亚马逊社交网络来处理低延迟/高频率的消息</h2><p id="6ab4" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">对于需要低延迟和高消息频率的架构，可能值得看看Amazon EventBridge上的Amazon SNS，但这是在特殊情况下。Amazon EventBridge通常有大约半秒的延迟。</p><blockquote class="pk pl pm"><p id="b949" class="ln lo my lp b lq ne kh ls lt nf kk lv pn ng ly lz po nh mc md pp ni mg mh mi ij bi translated">当您想要构建一个对其他应用程序或微服务发布的高吞吐量或低延迟消息做出反应的应用程序时(因为Amazon SNS提供几乎无限的吞吐量)，或者对于需要非常高的扇出(数千或数百万个端点)的应用程序，建议使用Amazon SNS。消息是非结构化的，可以是任何格式。亚马逊SNS支持向六种不同类型的目标转发消息，包括AWS Lambda、亚马逊SQS、HTTP/S端点、短信、移动推送和电子邮件。亚马逊社交网络的典型延迟低于30毫秒。——【https://aws.amazon.com/eventbridge/faqs/ T4】</p></blockquote><h2 id="e063" class="ny kw jg bd kx nz oa dn lb ob oc dp lf lw od oe lh ma of og lj me oh oi ll oj bi translated">使用EventBridge了解异步和同步Lambda调用</h2><p id="9bb1" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">根据事件源映射和所涉及的服务，Lambda可能被同步调用<strong class="lp jh"> <em class="my">或异步调用</em> </strong>，这决定了在事件驱动的系统中如何管理失败的处理。</p><p id="ceb6" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">例如，通过我们的SQS FIFO队列与Lambda的集成，Lambda被调用<code class="fe ps pt pu pv b">synchronously</code>，因此我们不使用Lambda目的地，而是使用与FIFO队列本身相关联的死信队列。</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/44f2824aa3740ceb5d5ec300d0402f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/0*PL-Qz5_7T8hsdF1G.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-sync.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/lambda/latest/DG/invocation-sync . html</a></figcaption></figure><p id="ec90" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">对于EventBridge中的Lambda目标，这将被调用<code class="fe ps pt pu pv b">asynchronously</code>，因此您需要显式定义如何处理错误。默认情况下，将有两次重试尝试，然后事件消失，即默认情况下，它不会进入DLQ！</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/8946d967475e32410288d3ab2d1368a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/0*OrfoMRSEosk6-XfI.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/lambda/latest/DG/invocation-async . html</a></figcaption></figure><p id="0552" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">在这种情况下，您应该使用Lambda Destinations，以便将失败的执行发送到另一个服务，如SQS DLQ:</p><div class="ip iq gp gr ir nj"><a rel="noopener  ugc nofollow" target="_blank" href="/serverless-lambda-destinations-146f8b3c3456"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd jh gy z fp no fr fs np fu fw jf bi translated">无服务器Lambda目的地🚀</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">充分利用lambda目的地粘合代码..</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ns l"><div class="qh l nu nv nw ns nx ix nj"/></div></div></a></div><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi qi"><img src="../Images/a3ed61f09aaeffd6492b55d634c1e75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/0*zUFab1PERZHqZZ-f.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/lambda/latest/DG/invocation-async . html</a></figcaption></figure><p id="2f31" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">您也可以为Lambda设置异步调用配置，在这里您可以设置一个SNS主题或队列，以便进一步处理错误。</p><p id="c912" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">还要确保不要同时设置两者，因为消息会在队列中重复出现！</p><h1 id="af8a" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">包扎👋</h1><p id="f745" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我希望您发现这对于为什么您应该有一个事件驱动的思维模式，并使用Amazon EventBridge作为任何无服务器架构的默认设置是有用的！</p><p id="12aa" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">请<a class="ae jd" href="https://www.youtube.com/channel/UC_Bi6eLsBXpLnNRNnxKQUsA" rel="noopener ugc nofollow" target="_blank"> <strong class="lp jh">前往我的YouTube频道</strong> </a>订阅类似内容！</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/67fb57384745447103caa4678e21c6e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d_4XWIqTCYEAMMQg.png"/></div></figure><p id="0923" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">我很乐意就以下任何一个方面与您联系:</p><p id="fc25" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated"><a class="ae jd" href="https://www.linkedin.com/in/lee-james-gilmore/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/lee-james-gilmore/</a><br/>T12】https://twitter.com/LeeJamesGilmore</p><p id="9c7a" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">如果你喜欢这些帖子，请关注我的简介<a class="ae jd" href="https://medium.com/u/2906c6def240?source=post_page-----39c4f4ae5aff----------------------" rel="noopener">李·詹姆斯·吉尔摩</a>以获取更多的帖子/系列，不要忘记联系我并打招呼👋</p><p id="1620" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">如果你喜欢，也请使用帖子底部的“鼓掌”功能！(<em class="my">可以不止一次鼓掌！！</em>)</p><p id="60c6" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated"><strong class="lp jh">本文由</strong><a class="ae jd" href="https://www.sedai.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lp jh">sedai . io</strong></a>赞助</p><figure class="na nb nc nd gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qk"><img src="../Images/4c77bc2d275bd557dda90aa2fe842d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJqkQYFI-KAGHOI3cHWxJQ.png"/></div></div></figure><h1 id="05ad" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">关于我</h1><p id="77c7" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">"<em class="my">大家好，我是Lee，英国的AWS社区构建者、博客作者、AWS认证云架构师和首席软件工程师；目前是一名技术云架构师和首席无服务器开发人员，过去5年主要从事AWS上的全栈JavaScript工作。</em></p><p id="7083" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">我认为自己是一个无服务器的布道者，热爱AWS、创新、软件架构和技术。”</p><p id="837d" class="pw-post-body-paragraph ln lo jg lp b lq ne kh ls lt nf kk lv lw ng ly lz ma nh mc md me ni mg mh mi ij bi translated">提供的信息是我个人的观点，我对信息的使用不承担任何责任。*** </p><div class="ip iq gp gr ir nj"><a href="https://leejamesgilmore.medium.com/serverless-threat-modelling-df8e4028ef6d" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd jh gy z fp no fr fs np fu fw jf bi translated">无服务器威胁建模🚀</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">您应该如何以及为什么在AWS上对您的无服务器解决方案进行威胁建模，并提供真实生活中的可视化示例</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">leejamesgilmore.medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ix nj"/></div></div></a></div><div class="ip iq gp gr ir nj"><a href="https://leejamesgilmore.medium.com/serverless-content-46ef5b562d8e" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd jh gy z fp no fr fs np fu fw jf bi translated">无服务器内容🚀</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">我的所有无服务器内容的索引，可以在一个地方轻松浏览，包括视频、博客文章等..</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">leejamesgilmore.medium.com</p></div></div><div class="ns l"><div class="ql l nu nv nw ns nx ix nj"/></div></div></a></div><div class="ip iq gp gr ir nj"><a href="https://leejamesgilmore.medium.com/serverless-synthetic-canaries-7946dc5216ba" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd jh gy z fp no fr fs np fu fw jf bi translated">无服务器合成金丝雀🚀</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">使用CloudWatch合成金丝雀来监控你的无服务器应用程序的实际例子，有视觉效果和…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">leejamesgilmore.medium.com</p></div></div><div class="ns l"><div class="qm l nu nv nw ns nx ix nj"/></div></div></a></div><div class="ip iq gp gr ir nj"><a rel="noopener  ugc nofollow" target="_blank" href="/serverless-s3-object-lambda-88c923a8a771"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd jh gy z fp no fr fs np fu fw jf bi translated">无服务器S3对象Lambda🚀</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">一个使用AWS S3对象Lambda的实际例子，使用Amazon动态地用元数据给图像加水印…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ns l"><div class="qn l nu nv nw ns nx ix nj"/></div></div></a></div><div class="ip iq gp gr ir nj"><a rel="noopener  ugc nofollow" target="_blank" href="/documenting-your-serverless-solutions-509f1928564b"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd jh gy z fp no fr fs np fu fw jf bi translated">记录您的无服务器解决方案🚀</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">一个生成和托管你的无服务器文档的例子，比如OpenAPI/Swagger，ADRs和code…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ns l"><div class="qo l nu nv nw ns nx ix nj"/></div></div></a></div><div class="ip iq gp gr ir nj"><a rel="noopener  ugc nofollow" target="_blank" href="/serverless-api-to-api-authentication-d4cb4472721e"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd jh gy z fp no fr fs np fu fw jf bi translated">无服务器API到API认证🚀</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">使用OAuth2客户端凭证使用Amazon Cognito验证API到API集成的实用指南…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ns l"><div class="qp l nu nv nw ns nx ix nj"/></div></div></a></div></div></div>    
</body>
</html>