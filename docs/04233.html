<html>
<head>
<title>How to traverse a tree using JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用JavaScript遍历一棵树</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-traverse-a-tree-using-javascript-c9a79826e819?source=collection_archive---------1-----------------------#2020-06-16">https://levelup.gitconnected.com/how-to-traverse-a-tree-using-javascript-c9a79826e819?source=collection_archive---------1-----------------------#2020-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/98106374afa77e33652ab65b0d20574b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCjnKmA6IQEKdpGdkr8SPA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">弗雷德里克·佩雷斯摄</figcaption></figure><div class=""/><p id="e66e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="la">最初发表于</em><a class="ae lb" href="https://blog.purnimagupta.com/traverse-binaryTree/" rel="noopener ugc nofollow" target="_blank"><em class="la">【https://blog.purnimagupta.com】</em></a><em class="la">。</em></p><p id="8562" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi lc translated">欢迎来到我的二叉树编程教程系列的第二部分！在本文中，您将学习树遍历背后的概念。您将了解一些流行的树遍历技术以及它们是如何工作的，并且您还将学习使用JavaScript来实现它们。</p><ul class=""><li id="baf6" class="ll lm jf ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated">对什么是二叉树的基本理解。如果你是这个概念的新手或者想要复习一下，请阅读本系列的第一部分<a class="ae lb" href="https://medium.com/swlh/implement-binary-search-tree-in-javascript-897dcbcc5616" rel="noopener">这里</a>，稍后访问这篇文章！</li><li id="a72b" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">对JavaScript有一些基本的了解</li></ul><h1 id="b79f" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">在接下来的20分钟里，你将学到以下内容:</h1><h2 id="8780" class="mx ma jf bd mb my mz dn mf na nb dp mj kn nc nd mn kr ne nf mr kv ng nh mv ni bi translated">#1:常用的树遍历技术</h2><p id="aa38" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">广度优先搜索(BFS)和深度优先搜索(DFS)</p><h2 id="8692" class="mx ma jf bd mb my mz dn mf na nb dp mj kn nc nd mn kr ne nf mr kv ng nh mv ni bi translated">#2:深入研究深度优先搜索算法:</h2><ul class=""><li id="4450" class="ll lm jf ke b kf nj kj nk kn no kr np kv nq kz lq lr ls lt bi translated">有序遍历</li><li id="d875" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">前序遍历</li><li id="9a06" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">后序遍历</li></ul><p id="a246" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下一个教程中，你将学习广度优先搜索。</p><p id="ac84" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">准备好了吗？我们走吧！</p><p id="be94" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">下面就是</strong> <a class="ae lb" href="https://en.wikipedia.org/wiki/Tree_traversal" rel="noopener ugc nofollow" target="_blank"> <strong class="ke jg">维基</strong> </a> <strong class="ke jg">所说的</strong></p><blockquote class="nr ns nt"><p id="baee" class="kc kd la ke b kf kg kh ki kj kk kl km nu ko kp kq nv ks kt ku nw kw kx ky kz ij bi translated"><em class="jf">在计算机科学中，树遍历(也称为树搜索和树行走)是图遍历的一种形式，指的是</em>访问(检查和/或更新)树数据结构中每个节点<em class="jf">、</em>、<strong class="ke jg">、<em class="jf">恰好一次</em>、</strong>、<em class="jf">的过程。这种遍历按照节点被访问的</em> <strong class="ke jg"> <em class="jf">顺序</em> </strong> <em class="jf">进行分类。</em></p></blockquote><p id="c107" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">树遍历算法可以大致分为两种类型:</p><ul class=""><li id="095d" class="ll lm jf ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated"><strong class="ke jg">广度优先搜索</strong></li></ul><p id="fa06" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种技术的工作原理是，在进入下一层之前，先访问一层中的所有节点一次。之所以称之为“广度优先”，是因为这个搜索<strong class="ke jg">拓宽了</strong>的搜索策略。</p><ul class=""><li id="c3e1" class="ll lm jf ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated"><strong class="ke jg">深度优先搜索</strong></li></ul><p id="6a1b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一方面，深度优先搜索的工作方式是“深入”到图的一部分，并一直访问它的所有节点。一旦该子树没有更多的节点可访问，它<strong class="ke jg">返回</strong>到可以做出不同选择的最新点，然后从那里开始探索。</p><p id="6e8b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于二叉树，这种方法通常是从左到右的顺序。也就是说，搜索评估树的最左边的分支/子树，然后进行到它右边的分支/子树，依此类推，直到访问了所有分支。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="4e50" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> T </strong> rees是一个<strong class="ke jg">图</strong>数据结构的特例。这就是为什么像深度优先搜索(DFS)和广度优先搜索(BFS)这样的算法也可以应用于它们。需要记住的重要一点是，虽然图遍历通常可以从任何节点/顶点开始，但是树遍历总是从根节点开始。</p><h1 id="ad8e" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">深度优先搜索树遍历的应用</h1><p id="8f59" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">在您开始深入研究实现细节之前，我觉得从问题<em class="la">为什么开始总是有帮助的。</em>为什么我们甚至首先需要知道这些算法，它们的应用是什么？</p><p id="47d2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我很想知道，因为我以前只听说过DFS，并且知道它们是如何工作的，但从来没有真正理解它们在哪里或者为什么存在。事实证明，应用程序的数量惊人地庞大！</p><p id="b2f3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是DFS经常用作构造块的几个应用程序:</p><h2 id="95cb" class="mx ma jf bd mb my mz dn mf na nb dp mj kn nc nd mn kr ne nf mr kv ng nh mv ni bi translated">在基于策略的游戏中:</h2><p id="d970" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">像国际象棋、数独、阿尔法围棋这样的棋盘游戏，棋盘配置通常以<a class="ae lb" href="https://en.wikipedia.org/wiki/Game_tree" rel="noopener ugc nofollow" target="_blank">游戏树</a>的形式表示。在这种情况下，DFS的变化通常用于寻找最短或最佳的一组移动。</p><h2 id="cbd8" class="mx ma jf bd mb my mz dn mf na nb dp mj kn nc nd mn kr ne nf mr kv ng nh mv ni bi translated"><strong class="ak">查找连接组件:</strong></h2><p id="6656" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">你可以使用DFS在一个<strong class="ke jg">无向图</strong>中找到连接的组件。我找不到无向图在现实世界中应用的好例子，所以如果你有这方面的具体例子，我很想知道:)</p><h2 id="c92e" class="mx ma jf bd mb my mz dn mf na nb dp mj kn nc nd mn kr ne nf mr kv ng nh mv ni bi translated"><strong class="ak">寻找强连通分量:</strong></h2><ul class=""><li id="379f" class="ll lm jf ke b kf nj kj nk kn no kr np kv nq kz lq lr ls lt bi translated">DFS在社交图中也有应用。一个例子是，当你想向喜欢相似网页或相似视频的人推荐或宣传特定内容时。这可以表示为一个强连通图，它使用DFS来搜索彼此相似的实体。</li><li id="fbd8" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">另一个有趣的应用是<a class="ae lb" href="https://developers.google.com/optimization/routing/vrp" rel="noopener ugc nofollow" target="_blank">车辆路线问题</a>，它有助于为访问一组地点的多辆车找到最佳(最小化总成本)路线。</li></ul><h2 id="30e2" class="mx ma jf bd mb my mz dn mf na nb dp mj kn nc nd mn kr ne nf mr kv ng nh mv ni bi translated"><strong class="ak">寻找路径:</strong></h2><p id="d7fe" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">它可以用来查看从顶点<code class="fe oe of og oh b">u</code>到顶点<code class="fe oe of og oh b">v</code>是否存在路径。</p><h2 id="bf32" class="mx ma jf bd mb my mz dn mf na nb dp mj kn nc nd mn kr ne nf mr kv ng nh mv ni bi translated"><strong class="ak">拓扑排序算法:</strong></h2><p id="bcf6" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated"><strong class="ke jg">有向无环图(DAG) </strong>可以用来维护任务的<strong class="ke jg">线性排序</strong>。例如，图的顶点可以表示要执行的任务，而边可以表示一个任务必须在另一个任务之前执行的约束。这里有几个例子:</p><ul class=""><li id="8f2a" class="ll lm jf ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated">在自动柜员机交易中，任务按一定的顺序发生。首先，我们需要插入ATM，输入PIN并验证您自己，只有稍后才能提取金额。连插卡/扫卡都不能取钱。这种操作顺序可以用DAG来表示，其中可以使用拓扑排序。</li><li id="b9f2" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">使用博弈树的回合制游戏如国际象棋也是另一个例子，其中只有当玩家达到某个棋盘配置时，某些棋步才可用。</li><li id="ade2" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">如果你使用的是基于Debian的UNIX系统，那么使用<code class="fe oe of og oh b">apt-get</code>命令是不可避免的，它利用拓扑排序来确定安装或删除软件包的最佳方式。</li></ul><blockquote class="nr ns nt"><p id="d6a6" class="kc kd la ke b kf kg kh ki kj kk kl km nu ko kp kq nv ks kt ku nw kw kx ky kz ij bi translated"><strong class="ke jg"> <em class="jf">注意</em> </strong> <em class="jf">:理解上述应用中使用的搜索算法严格来说并不完全是DFS，这一点很重要。更准确地说，这些算法是DFS的变体，经过进一步优化，在一些任务中比其他任务表现得更好。</em></p><p id="e96d" class="kc kd la ke b kf kg kh ki kj kk kl km nu ko kp kq nv ks kt ku nw kw kx ky kz ij bi translated"><em class="jf">其中一些甚至还与传统的BFS(广度优先搜索)算法结合使用，如</em> <a class="ae lb" href="https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search" rel="noopener ugc nofollow" target="_blank"> <em class="jf">迭代深化深度优先搜索</em> </a> <em class="jf">。但稍后会详细介绍。</em></p></blockquote><p id="05f0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们已经看了一些应用程序，让我们看看DFS中使用的一些常见的遍历模式:</p><h1 id="e206" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">用于DFS的常见遍历模式:</h1><p id="9643" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">如前所述，二叉树可以从左到右遍历，也可以从右到左遍历。但是我们将要讨论的最常用的遍历技术将以从左到右的方式进行。这些遍历可以使用递归技术，也可以迭代完成(为此，您需要使用堆栈，一种特殊的数据结构)。</p><p id="bcb9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于本教程，您将学习使用<strong class="ke jg">递归</strong>来实现这些遍历。</p><h1 id="36d8" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">有序遍历(左-根-右)</h1><p id="2f4f" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">有序遍历的工作方式如下:</p><ol class=""><li id="177f" class="ll lm jf ke b kf kg kj kk kn ln kr lo kv lp kz oi lr ls lt bi translated">我们将从根节点开始，递归遍历整个左侧子树。</li><li id="38d3" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz oi lr ls lt bi translated">访问根节点的数据值，并对它做任何需要做的事情。出于本教程的目的，我们将只打印值。</li><li id="3aa0" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz oi lr ls lt bi translated">然后递归遍历整个右子树。</li></ol><h1 id="6237" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">这里有一个gif和一个流程图来帮助你形象化它:</h1><figure class="ok ol om on gt is gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/6d26232419c1911b0143e7ac65b57385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*gIonhJjvlBE-SBlv.gif"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">树的有序遍历</figcaption></figure><blockquote class="nr ns nt"><p id="4975" class="kc kd la ke b kf kg kh ki kj kk kl km nu ko kp kq nv ks kt ku nw kw kx ky kz ij bi translated"><strong class="ke jg"> <em class="jf">注意:</em> </strong> <em class="jf">这个遍历总是按照</em> <strong class="ke jg"> <em class="jf">排序</em> </strong> <em class="jf">的顺序打印节点值。这是因为左子树中的值</em> <strong class="ke jg"> <em class="jf">比根节点中的</em> </strong> <em class="jf">小，而右子树中的值</em> <strong class="ke jg"> <em class="jf">比根节点中的</em> </strong> <em class="jf">大。</em></p></blockquote><figure class="ok ol om on gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/186c1ae8d2de8d3cce43e177d86e6b33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*67Gf4LaczQXwSorhEaKH-w.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">顺序遍历流程图</figcaption></figure><p id="08c1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您将从上一篇教程<a class="ae lb" href="https://medium.com/swlh/implement-binary-search-tree-in-javascript-897dcbcc5616" rel="noopener">继续，在上一篇教程</a>中，您用JavaScript编写了一个BST，并扩展该程序以实现DFS。如果你需要复习，请再读一遍。</p><h1 id="3262" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">下面是一个inorder遍历的JS实现的样子:</h1><pre class="ok ol om on gt op oh oq or aw os bi"><span id="3398" class="mx ma jf oh b gy ot ou l ov ow">function inOrder(root) { <br/>   root.left &amp;&amp; inOrder(root.left) <br/>   console.log(root.val) <br/>   root.right &amp;&amp; inOrder(root.right) <br/>} </span><span id="8ff5" class="mx ma jf oh b gy ox ou l ov ow"><br/>&lt;!-- Call the inorder function. Remember, we're referring above gif's BST for reference--&gt; </span><span id="dbd3" class="mx ma jf oh b gy ox ou l ov ow">node.inOrder(node) // 13, 15, 18, 20, 25, 30</span></pre><p id="a211" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要想理解清楚，你必须知道<em class="la">递归</em>是如何工作的。我会尽力详细说明。</p><ol class=""><li id="30e5" class="ll lm jf ke b kf kg kj kk kn ln kr lo kv lp kz oi lr ls lt bi translated">我们将从根节点开始。在我们的gif 中，我们的根节点包含值<code class="fe oe of og oh b">20</code>。</li><li id="4bf6" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz oi lr ls lt bi translated">接下来，检查这个节点是否有左子节点。如果是，那么我们将从左边的子树开始搜索。这将在包含值<code class="fe oe of og oh b">15</code>的节点上再次调用<code class="fe oe of og oh b">inorder()</code>方法。</li><li id="224d" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz oi lr ls lt bi translated">同样，它检查它是否有一个左孩子。是的，的确我们在左边有一个值为<code class="fe oe of og oh b">13</code>的节点。</li><li id="bd1d" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz oi lr ls lt bi translated">它在节点<code class="fe oe of og oh b">13</code>上调用<code class="fe oe of og oh b">inorder()</code>。但是它的左边没有子节点。所以控制转到下一行，它在这一点打印<code class="fe oe of og oh b">13</code>。最后，我们检查节点<code class="fe oe of og oh b">13</code>的右子树，它也不存在！所以没有更多的事情要做，程序返回到调用它的父<code class="fe oe of og oh b">inorder</code>函数，在值为<code class="fe oe of og oh b">15</code>的节点上。</li><li id="b3f8" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz oi lr ls lt bi translated">这样，当我们调用<code class="fe oe of og oh b">inOrder(root.left)</code>时，已经遍历了节点<code class="fe oe of og oh b">15</code>的整个左子树。接下来，<code class="fe oe of og oh b">15</code>被打印出来，然后程序继续计算节点的右子树。</li><li id="2f8c" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz oi lr ls lt bi translated">重复同样的过程，直到整棵树都被覆盖！</li></ol><p id="f755" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">希望你能全部跟上！如果你没有，去看这个关于递归的视频。</p><p id="8fc9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">继续下一个遍历模式:</p><h1 id="2bb4" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">前序(根-左-右)</h1><p id="9e58" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">它是这样工作的，从根节点开始，就像inorder一样:</p><ol class=""><li id="b4ba" class="ll lm jf ke b kf kg kj kk kn ln kr lo kv lp kz oi lr ls lt bi translated">首先，获取当前节点值，比如说，打印出来。</li><li id="bc87" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz oi lr ls lt bi translated">然后，我们对左子树进行前序遍历。</li><li id="7337" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz oi lr ls lt bi translated">最后，对右边的子树做同样的操作。</li></ol><p id="6d4e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">基本上，我们首先打印父节点，然后是左节点，最后是右节点。冲洗并重复，直到我们覆盖了整棵树。</p><h1 id="1127" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">这是一个视频，后面是一个流程图:</h1><figure class="ok ol om on gt is gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/dfd788ca7c28a2d56cec127960e64ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*PaTE01wN4ToA40Co.gif"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">树的前序遍历</figcaption></figure><figure class="ok ol om on gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/e27b002b94d46c7cf098d9abe102e2b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-OXxr9eRpP9AqR8c5W95w.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">前序遍历流程图</figcaption></figure><h1 id="5876" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">所以JavaScript实现看起来会像这样:</h1><pre class="ok ol om on gt op oh oq or aw os bi"><span id="052c" class="mx ma jf oh b gy ot ou l ov ow">preOrder(node) { <br/>  console.log(node.val) <br/>  node.left &amp;&amp; this.preOrder(node.left) <br/>  node.right &amp;&amp; this.preOrder(node.right) <br/>} </span><span id="fb3a" class="mx ma jf oh b gy ox ou l ov ow">&lt;!-- Call the preorder function. We're referring above gif for reference --&gt; </span><span id="0c89" class="mx ma jf oh b gy ox ou l ov ow">node.preOrder(node) // 20, 15, 13, 18, 25, 30</span></pre><h1 id="ccf5" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">后序(左—右—根)</h1><p id="7da5" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">这种遍历是这样进行的:</p><ol class=""><li id="7a94" class="ll lm jf ke b kf kg kj kk kn ln kr lo kv lp kz oi lr ls lt bi translated">首先，递归遍历左边的子树。</li><li id="6548" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz oi lr ls lt bi translated">然后递归遍历右边的子树。</li><li id="a03b" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz oi lr ls lt bi translated">最后，访问当前节点值并打印出来。</li></ol><h1 id="f849" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">它看起来是这样的:</h1><figure class="ok ol om on gt is gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/cc674869535699634e18d499658d602d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*najybdVtx7wCsu_u.gif"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">树的后序遍历</figcaption></figure><figure class="ok ol om on gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/45c3b85e7d36c35572c961376511dddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rk8uf95dsepPr90cgK7LJA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">后序遍历流程图</figcaption></figure><h1 id="f7e6" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">程序是这样的:</h1><pre class="ok ol om on gt op oh oq or aw os bi"><span id="eeb7" class="mx ma jf oh b gy ot ou l ov ow">postOrder(node) { <br/>  node.left &amp;&amp; this.postOrder(node.left) <br/>  node.right &amp;&amp; this.postOrder(node.right) <br/>  console.log(node.val); <br/>} </span><span id="4085" class="mx ma jf oh b gy ox ou l ov ow">&lt;!-- Call the postorder function. We're referring above gif for reference --&gt; </span><span id="2b11" class="mx ma jf oh b gy ox ou l ov ow">node.postOrder(node) // 13, 18, 15, 30, 25, 20</span></pre><blockquote class="nr ns nt"><p id="24d6" class="kc kd la ke b kf kg kh ki kj kk kl km nu ko kp kq nv ks kt ku nw kw kx ky kz ij bi translated"><strong class="ke jg"> <em class="jf">注意:</em> </strong> <em class="jf">您可能已经注意到了，这些遍历模式在实际代码中并没有太大的不同。然而，在某些情况下，使用一种遍历可能比其他遍历更好。</em></p></blockquote><h1 id="9318" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">DFS树遍历模式的一些用途:</h1><h2 id="ce4b" class="mx ma jf bd mb my mz dn mf na nb dp mj kn nc nd mn kr ne nf mr kv ng nh mv ni bi translated">序列化和反序列化</h2><p id="5f7e" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">这是维基百科<a class="ae lb" href="https://en.wikipedia.org/wiki/Serialization" rel="noopener ugc nofollow" target="_blank">的定义。</a>:</p><blockquote class="nr ns nt"><p id="a5a2" class="kc kd la ke b kf kg kh ki kj kk kl km nu ko kp kq nv ks kt ku nw kw kx ky kz ij bi translated"><em class="jf">在计算中，串行化是将数据结构或对象状态翻译成可以</em> <strong class="ke jg"> <em class="jf">存储</em> </strong> <em class="jf">(例如，在文件或内存缓冲区中)或</em> <strong class="ke jg"> <em class="jf">传输</em> </strong> <em class="jf">(例如，通过网络连接链路)和</em> <strong class="ke jg"> <em class="jf">重构</em> </strong> <em class="jf">(可能在不同的计算机环境中)的格式的过程。</em></p><p id="46ef" class="kc kd la ke b kf kg kh ki kj kk kl km nu ko kp kq nv ks kt ku nw kw kx ky kz ij bi translated"><em class="jf">当根据串行化格式重新读取所得到的一系列位时，它可用于创建原始对象的语义上</em> <strong class="ke jg"> <em class="jf">相同的克隆</em> </strong> <em class="jf">。</em></p></blockquote><p id="604c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在二叉树的上下文中，您可以将序列化视为将树结构转换成一个<strong class="ke jg">字符串</strong>或一个<strong class="ke jg">数组</strong>格式。例如，一个后序遍历给了我们这个输出:<code class="fe oe of og oh b">13, 18, 15, 30, 25, 20</code>。这可以存储为一个字符串或一个数组(序列化)，以后可以用它来构造一个新的相同的BST(反序列化)。</p><p id="4076" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以使用以下组合来创建BST:</p><ul class=""><li id="91c6" class="ll lm jf ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated">前序和后序遍历都可以用来创建(反序列化)原始BST。</li><li id="2edb" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">还可以结合使用postorder和inorder来创建BST。</li><li id="7d63" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">您可以同时使用preorder和inorder来创建BST。</li><li id="c56a" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated">您可以只使用postorder来创建BST。</li></ul><h2 id="ed0b" class="mx ma jf bd mb my mz dn mf na nb dp mj kn nc nd mn kr ne nf mr kv ng nh mv ni bi translated">以下是一些更进一步的应用:</h2><h1 id="1759" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">前序遍历:</h1><p id="9c22" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">它可以用来从表达式树中创建前缀表达式(<strong class="ke jg">波兰语符号</strong>)。如果你不知道，我建议你在维基百科上阅读这篇文章。</p><p id="6633" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">例如:- </strong></p><p id="a472" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个中缀表达式<code class="fe oe of og oh b"><strong class="ke jg">A - (B + C) + (D + E)</strong></code>可以转换成前缀表达式为<code class="fe oe of og oh b"><strong class="ke jg">"+ * A - B C + D E"</strong></code>。与inorder表达式相比，这种转换使得编译器计算带有前缀/后缀表达式的算术/代数方程变得极其容易。</p><p id="aebc" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">人类真的很擅长扫描事物，记住传统的结合律和优先规则，然后我们评估方程。我们只需要观察它。但是对于一个编译器来说，它会更复杂，因为在计算方程时，它必须考虑结合律和优先规则。这可能是不必要的开销。</p><p id="85b3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，建议在编译器解析表达式之前，将inorder表达式转换为postfix或prefix，因为这样就不需要知道这两个表达式的运算符的优先级。</p><p id="f8b7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">前缀表达式从<strong class="ke jg">右到左</strong>求值，它们使用堆栈数据结构。</p><h1 id="f5ae" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">后序遍历:</h1><p id="6408" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">就像如何使用前序遍历从树中生成前缀表达式一样，我们使用后序遍历来生成后缀表达式<a class="ae lb" href="https://en.wikipedia.org/wikiReverse_Polish_notation" rel="noopener ugc nofollow" target="_blank"> <strong class="ke jg">反向波兰符号</strong> </a>。例如，这个中缀表达式<code class="fe oe of og oh b"><strong class="ke jg">A - (B + C) + (D + E)</strong></code>可以使用堆栈数据结构转换成后缀表达式<code class="fe oe of og oh b"><strong class="ke jg">"A B C - * D E + +"</strong></code>。</p><p id="8997" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当您想要首先探索<strong class="ke jg">叶节点</strong>时，也可以使用后序遍历。例如，当您需要<strong class="ke jg">删除</strong>一个节点时，在删除节点本身之前，必须先访问并删除它的子节点以释放内存！</p><p id="95bc" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">后缀表达式从<strong class="ke jg">左到右</strong>读取，求值时也使用栈数据结构。</p><h1 id="8818" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">有序遍历:</h1><p id="f172" class="pw-post-body-paragraph kc kd jf ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz ij bi translated">这是二分搜索法树最常用的遍历技术之一，因为它返回的值与最初用来创建树的顺序相同。因此，如果您需要按排序顺序访问值，您将使用inorder遍历。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="dfb2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi lc translated">基于图的数据结构和算法数不胜数，我们在这里仅仅触及了皮毛！在下一个教程中，我们将讨论广度优先搜索。</p><p id="0121" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你有任何反馈，请在评论中告诉我，或者在<a class="ae lb" href="https://twitter.com/pooyax14" rel="noopener ugc nofollow" target="_blank">推特</a>上联系我。</p><p id="38a9" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你喜欢这个教程，一定要给它一个大拇指🙂。回头见！</p><p id="4fb2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg">如果你想做进一步的阅读，去看看这些教程。</strong></p><p id="0103" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> #1。深度优先搜索</strong></p><ul class=""><li id="6264" class="ll lm jf ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated"><a class="ae lb" href="https://brilliant.org/wiki/depth-first-search-dfs/" rel="noopener ugc nofollow" target="_blank">辉煌</a></li><li id="8e2c" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated"><a class="ae lb" href="https://www.hackerearth.com/practice/algorithms/graphs/depth-first-search/tutorial/" rel="noopener ugc nofollow" target="_blank">黑客地球</a></li><li id="60ec" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated"><a class="ae lb" href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener ugc nofollow" target="_blank">维基百科</a></li></ul><p id="053a" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> #2。树遍历</strong></p><ul class=""><li id="42a7" class="ll lm jf ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated"><a class="ae lb" href="https://en.wikibooks.org/wiki/A-level_Computing/AQA/Paper_1/Fundamentals_of_algorithms/Tree_traversal" rel="noopener ugc nofollow" target="_blank"> Wikibooks </a></li><li id="2ced" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated"><a class="ae lb" href="https://opendsa-server.cs.vt.edu/ODSA/Books/CS3/html/BinaryTreeTraversal.html" rel="noopener ugc nofollow" target="_blank"> ODSA关于二叉树遍历的书</a></li></ul><p id="ec1c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> #3。算法书籍</strong></p><ul class=""><li id="65ec" class="ll lm jf ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated"><a class="ae lb" href="https://www.oreilly.com/library/view/algorithms-in-a/9780596516246/ch07s02.html" rel="noopener ugc nofollow" target="_blank">奥雷利</a></li><li id="26d0" class="ll lm jf ke b kf lu kj lv kn lw kr lx kv ly kz lq lr ls lt bi translated"><a class="ae lb" href="https://www.coursera.org/learn/algorithms-part2#syllabus" rel="noopener ugc nofollow" target="_blank"> Coursera </a></li></ul><p id="8706" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke jg"> #4。DFS的应用</strong></p><ul class=""><li id="e42d" class="ll lm jf ke b kf kg kj kk kn ln kr lo kv lp kz lq lr ls lt bi translated"><a class="ae lb" href="https://www.geeksforgeeks.org/applications-of-depth-first-search/?ref=lbp" rel="noopener ugc nofollow" target="_blank">深度优先搜索在geeksforgeeks上的应用</a></li></ul><h1 id="6be6" class="lz ma jf bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">感谢您的阅读！</h1></div></div>    
</body>
</html>