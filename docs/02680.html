<html>
<head>
<title>Binary Search Tree: Inserting a Value Using JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉查找树:使用JavaScript插入值</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/binary-search-tree-inserting-a-value-using-javascript-501f44c6a1e4?source=collection_archive---------8-----------------------#2020-03-29">https://levelup.gitconnected.com/binary-search-tree-inserting-a-value-using-javascript-501f44c6a1e4?source=collection_archive---------8-----------------------#2020-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2a56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated"><span class="l km kn ko bm kp kq kr ks kt di"/><strong class="jp ir">二叉树</strong>数据结构是一种树形数据结构，其中每个元素最多有2个子元素。该数据结构将由三个主要元素组成:</p><ol class=""><li id="d28e" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">数据</li><li id="bb11" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">指向左边子节点的指针</li><li id="439d" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">指向正确子节点的指针</li></ol><p id="c862" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<strong class="jp ir">二叉查找树</strong>是一个基于节点的二叉树数据结构，它具有特定的属性，允许以更有效的方式进行搜索和寻找最大值或最小值等操作。这些属性如下所示:</p><ul class=""><li id="1b63" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk li la lb lc bi translated">节点的左子树和左子树只包含键小于该节点键的节点</li><li id="1162" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk li la lb lc bi translated">一个节点的右子节点以及随后的右子树只包含键大于该节点键的节点</li><li id="20ce" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk li la lb lc bi translated">子树也必须是二分搜索法树</li><li id="9b92" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk li la lb lc bi translated">没有重复的节点</li></ul><p id="ac3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通俗地说，从树的顶端(<strong class="jp ir">根</strong>)开始，左子就会小于根，右子就会大于根。因此，一个节点的右边子树将只包含比该节点更少的键，反之亦然。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/fd309543fe8fe4ddc220c090ec717aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7mYxjhYF19Nc4RfR.png"/></div></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><p id="c533" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设二叉树节点是这样定义的:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/d706b6e6c20185027b2e5680c979c514.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*mYqIF-G_rppLPYU6VSWaig.png"/></div></figure><p id="b194" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给定二叉树和一个值，要插入该值，我们必须从树的根开始。我们获取根的值，并将其保存到一个变量中，以便用给定的值进行检查。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi md"><img src="../Images/66deb7baae2a20cb8f4043d25d67d7a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*CoFxBSFIF1rXlB0NwfdfkQ.png"/></div></figure><p id="2138" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用一个<em class="me"> while循环</em>，我们将遍历树，检查当前节点的值。如果值大于节点，我们检查节点的右子节点是否存在。如果它不存在，我们创建一个新节点，它是当前节点的右子节点。如果存在一个右子节点，我们将'<em class="me"> current </em>'值设置为当前节点的值，并继续遍历树。如果值小于节点，同样的过程也是正确的，只是现在我们将检查左边的子节点。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/4a0bc5c5f0f0690f7a3a4116a0e3270e.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*c83Yk9cTGQO9x8gP-VVbEg.png"/></div></figure><p id="a89c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦创建了新节点，while循环<em class="me">将中断，当前值将与给定值相同。下面是完整的函数:</em></p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi md"><img src="../Images/cded3d74c9e5e0b29355ddc54c8e3a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*jkOa2AWUaUKaQL-UKQwfFg.png"/></div></figure><p id="66a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">涉及递归的不同实现也是可能的:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/990a17df7cae973686b33a44a916972b.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*sz1zPb87AQBFrrR3sVYKEA.png"/></div></figure><p id="fc32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">逻辑是相同的，但是我们不是将当前节点保存到变量中，而是简单地再次调用函数并传递节点和我们想要插入的值。</p></div></div>    
</body>
</html>