<html>
<head>
<title>Lodash Array Methods That Can Easily Be Implemented in Plain JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">易于用普通JavaScript实现的Lodash数组方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lodash-array-methods-that-can-easily-be-implemented-in-plain-javascript-9a701e5e25c1?source=collection_archive---------4-----------------------#2020-05-02">https://levelup.gitconnected.com/lodash-array-methods-that-can-easily-be-implemented-in-plain-javascript-9a701e5e25c1?source=collection_archive---------4-----------------------#2020-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1f87d19a8fb1ad44a7833ffd67a7a3ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ggpt6FhdF27IRYoF"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@kasya?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kasya Shahovskaya </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="1a0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Lodash是一个非常有用的工具库，让我们可以轻松地处理对象和数组。</p><p id="7fcc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，现在JavaScript标准库正在赶上诸如Lodash之类的库，我们可以用简单的方法实现许多功能。</p><p id="62bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些可以很容易地用普通JavaScript替换的数组访问方法。</p><h1 id="e27b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">头</h1><p id="b095" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">head</code>方法只获取数组的第一个元素。从JavaScript的第一个版本开始，我们就可以毫不费力地做到这一点。</p><p id="80d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以创建自己的<code class="fe mh mi mj mk b">head</code>函数，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6aad" class="mt lf it mk b gy mu mv l mw mx">const head = (arr) =&gt; arr[0]</span></pre><p id="93ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以这样说:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7c39" class="mt lf it mk b gy mu mv l mw mx">const result = head([1, 2, 3]);</span></pre><p id="6ac6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而<code class="fe mh mi mj mk b">result</code>得到1。</p><h1 id="9df9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">索引Of</h1><p id="b489" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Lodash <code class="fe mh mi mj mk b">indexOf</code>方法从我们可以选择指定的第一个索引或者数组开始和数组结束之间的位置找到值。</p><p id="e4ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">普通JavaScript <code class="fe mh mi mj mk b">indexOf</code>做同样的事情。唯一的区别是它是数组实例的一部分，而不是像我们使用Lodash那样将数组传递给<code class="fe mh mi mj mk b">indexOf</code>方法。</p><p id="6f52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以轻松地使用普通JavaScript的<code class="fe mh mi mj mk b">indexOf</code>方法来创建我们自己的Lodash的<code class="fe mh mi mj mk b">indexOf</code>方法，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ef06" class="mt lf it mk b gy mu mv l mw mx">const indexOf = (arr, val, start = 0) =&gt; arr.indexOf(val, start);</span></pre><p id="2bd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在<code class="fe mh mi mj mk b">arr</code>上调用了普通JavaScript的<code class="fe mh mi mj mk b">indexOf</code>。然后我们只需传入<code class="fe mh mi mj mk b">val</code>来搜索条目，传入<code class="fe mh mi mj mk b">start</code>来搜索可选的起始索引。</p><p id="585d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">两个<code class="fe mh mi mj mk b">indexOf</code>方法都返回第一个匹配的索引。那么我们可以这样称呼它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0ff5" class="mt lf it mk b gy mu mv l mw mx">const result = indexOf([1, 2, 3], 2, 1);</span></pre><p id="504d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为2在索引1中，所以我们为<code class="fe mh mi mj mk b">result</code>得到1。如果在指定的索引范围内没有找到项目，两个<code class="fe mh mi mj mk b">indexOf</code>方法都返回-1。</p><h1 id="3dae" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mh mi mj mk b">initial</code></h1><p id="4faf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Lodash <code class="fe mh mi mj mk b">initial</code>方法返回数组中除最后一个元素之外的所有元素。我们可以用<code class="fe mh mi mj mk b">slice</code>方法轻松实现这一点。</p><p id="1eb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下实现它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d741" class="mt lf it mk b gy mu mv l mw mx">const initial = (arr) =&gt; arr.slice(0, -1);</span></pre><p id="1d5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用0和-1作为参数调用了since，以包含第一个到倒数第二个元素。负索引从-1开始，表示最后一个元素。那么倒数第二个就是-2，依此类推。</p><p id="9d9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，当我们这样称呼它时:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bf89" class="mt lf it mk b gy mu mv l mw mx">const result = initial([1, 2, 3]);</span></pre><p id="ecf0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe mh mi mj mk b">[1, 2]</code>作为<code class="fe mh mi mj mk b">result</code>的值。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/63484f7a07aec104e7e42a2e41a40a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EuoNHlY63zMg40jQ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@vitalisit?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维塔利·西尼克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="6b46" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mh mi mj mk b">intersection</code></h1><p id="4046" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Lodash <code class="fe mh mi mj mk b">intersection</code>方法创建一个包含唯一值的数组，这些值包含在使用SameValueZero相等比较给出的所有数组中，这与<code class="fe mh mi mj mk b">===</code>类似，只是<code class="fe mh mi mj mk b">+0</code>和<code class="fe mh mi mj mk b">-0</code>被认为是不同的，而<code class="fe mh mi mj mk b">NaN</code>与自身相同。</p><p id="2fd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Lodash的<code class="fe mh mi mj mk b">intersection</code>方法接受零个或多个数组参数。我们可以得到所有数组中的所有元素，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6d9a" class="mt lf it mk b gy mu mv l mw mx">const intersection = (...arrs) =&gt; {<br/>  let vals = [];<br/>  const longestArr = arrs.sort((a, b) =&gt; b.length - a.length)[0]<br/>  for (const a of longestArr) {<br/>    const inAllArrs = arrs.every((arr) =&gt; arr.includes(a))<br/>    if (inAllArrs) {<br/>      vals.push(a)<br/>    }<br/>  }<br/>  return [...new Set(vals)];<br/>}</span></pre><p id="4ef1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们首先将参数分布到一个数组中。</p><p id="96d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们遍历最长的数组，并使用普通JavaScript的<code class="fe mh mi mj mk b">every</code>方法和回调<code class="fe mh mi mj mk b">(arr) =&gt; arr.includes(a)</code>检查其他数组是否与第一个数组具有相同的条目，回调函数检查传入的所有数组是否都包含给定的条目<code class="fe mh mi mj mk b">a</code>。</p><p id="e2ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不需要检查所有数组中的所有条目，因为如果我们循环的数组中没有条目，那么它就不应该包含在内。</p><p id="f04c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果它包含在所有数组中，那么我们将其推送到<code class="fe mh mi mj mk b">vals</code>。<code class="fe mh mi mj mk b">includes</code>使用SameValueZero算法，因此我们不需要做任何其他的比较检查。</p><p id="7ee7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么当我们这样称呼它的时候:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3fcb" class="mt lf it mk b gy mu mv l mw mx">const result = intersection([1, 2, 3], [1, 2], [1, 3, 5]);</span></pre><p id="7823" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe mh mi mj mk b">[1]</code>作为<code class="fe mh mi mj mk b">result</code>的值。</p><h1 id="6c90" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="20a7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">自从JavaScript的第一个版本以来，Lodash <code class="fe mh mi mj mk b">head</code>方法不需要太多的努力来实现我们自己。</p><p id="14c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用普通JavaScript的<code class="fe mh mi mj mk b">indexOf</code>方法也可以很容易地实现<code class="fe mh mi mj mk b">indexOf</code>方法。</p><p id="69a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">slice</code>方法来实现Lodash的<code class="fe mh mi mj mk b">initial</code>方法。</p><p id="2de3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用spread操作符将参数扩展到一个数组中，然后使用<code class="fe mh mi mj mk b">for...of</code>循环遍历最长的数组并检查其他数组是否有给定的条目，可以实现<code class="fe mh mi mj mk b">intersection</code>方法。</p></div></div>    
</body>
</html>