<html>
<head>
<title>How to build a Heap in linear time complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在线性时间复杂度下建立堆</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-heap-in-linear-time-complexity-c923466c6fbd?source=collection_archive---------1-----------------------#2022-06-15">https://levelup.gitconnected.com/how-to-build-a-heap-in-linear-time-complexity-c923466c6fbd?source=collection_archive---------1-----------------------#2022-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="3b91" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">背景</h1><p id="ef7a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文中，我将重点讨论<code class="fe lj lk ll lm b">data structure and algorithms</code>(在我看来，软件工程师最重要的技能之一)这个话题。有一天我遇到了一个<a class="ae ln" href="https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity" rel="noopener ugc nofollow" target="_blank">问题</a>是这样的:<em class="lo">构建一个堆怎么可能是O(n)时间复杂度？</em>这个问题让我困惑了一段时间，我就此做了一些调查和研究。本文将分享我在此过程中所学到的东西，包括以下几点:</p><ul class=""><li id="6f18" class="lp lq iq kn b ko lr ks ls kw lt la lu le lv li lw lx ly lz bi translated">什么是堆数据结构？堆的行为如何？</li><li id="6571" class="lp lq iq kn b ko ma ks mb kw mc la md le me li lw lx ly lz bi translated">C编程中如何实现一个完整的堆？</li><li id="46ad" class="lp lq iq kn b ko ma ks mb kw mc la md le me li lw lx ly lz bi translated">如何进行堆构建的时间复杂度分析？</li></ul><h1 id="bd3b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">堆的基础</h1><p id="11b0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们深入到实现和时间复杂度分析之前，让我们先了解一下<code class="fe lj lk ll lm b">heap</code>。</p><p id="1871" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">作为一种数据结构，<code class="fe lj lk ll lm b">heap</code>是很久以前为heapsort排序算法创建的。除了堆排序之外，<code class="fe lj lk ll lm b">heaps</code>还被用于许多著名的算法中，例如用于寻找最短路径的<a class="ae ln" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="noopener ugc nofollow" target="_blank"> Dijkstra算法</a>。从本质上来说，<em class="lo">堆是当您希望能够非常快速地访问最大值或最小值元素时想要使用的数据结构。</em></p><p id="2f42" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">在计算机科学中，<code class="fe lj lk ll lm b">heap</code>是一种专门的基于树的数据结构。一个<code class="fe lj lk ll lm b">heap</code>的常见实现是<em class="lo">二进制堆</em>，其中的树是一个<em class="lo">二叉树</em>。</p><p id="652b" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">因此<code class="fe lj lk ll lm b">heap</code>可以被定义为一棵二叉树，但是有两个额外的属性(这就是为什么我们说它是一棵特化的树):</p><ul class=""><li id="417a" class="lp lq iq kn b ko lr ks ls kw lt la lu le lv li lw lx ly lz bi translated"><strong class="kn ir">形状属性</strong>:二叉堆是一棵<em class="lo">完整的</em>二叉树。那么什么是<em class="lo">完全</em>二叉树呢？这是树的所有级别，除了可能最后一级(最深的)被完全填充，并且如果树的最后一级不完整，则该级的节点从左到右被填充。完全二叉树是二叉树的一种，详细的，你可以参考这个<a class="ae ln" href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" rel="noopener ugc nofollow" target="_blank">文档</a>来了解更多。</li><li id="697d" class="lp lq iq kn b ko ma ks mb kw mc la md le me li lw lx ly lz bi translated"><strong class="kn ir">堆属性</strong>:每个节点中存储的关键字要么大于等于(max-heaps)要么小于等于(min-heaps)该节点子节点中的关键字。</li></ul><p id="f40a" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">下图显示了基于树表示的二进制最大堆:</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/dd042ef7c5cb8e278afc8c929ed02056.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/0*rPircC0vbrm99EDK.png"/></div></figure><p id="5112" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated"><code class="fe lj lk ll lm b">heap</code>是一个强大的数据结构；因为您可以插入一个元素，并从最小堆或最大堆中提取(移除)最小或最大的元素，只需要<strong class="kn ir"> O(log N) </strong>时间。这就是为什么我们说如果你想快速访问最大或最小元素，你应该求助于<code class="fe lj lk ll lm b">heaps</code>。在下一节中，我将通过在C编程中实现一个堆来研究堆是如何工作的。</p><p id="0778" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">注意:堆与另一种叫做<code class="fe lj lk ll lm b"><a class="ae ln" href="https://en.wikipedia.org/wiki/Priority_queue" rel="noopener ugc nofollow" target="_blank">priority queue</a></code>的数据结构密切相关。<code class="fe lj lk ll lm b">priority queue</code>可以用多种方式实现，但是<code class="fe lj lk ll lm b">heap</code>是一种最有效的实现方式，事实上，优先级队列通常被称为“堆”，不管它们是如何实现的。</p><h1 id="d2b7" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">堆的实现</h1><p id="8547" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">由于堆的<code class="fe lj lk ll lm b">shape property</code>，我们通常将其实现为数组，如下所示:</p><ul class=""><li id="d9cd" class="lp lq iq kn b ko lr ks ls kw lt la lu le lv li lw lx ly lz bi translated">数组中的每个元素代表堆的一个节点。</li><li id="d306" class="lp lq iq kn b ko ma ks mb kw mc la md le me li lw lx ly lz bi translated">父/子关系可以由数组中元素的索引来定义。给定索引<code class="fe lj lk ll lm b">i</code>处的一个节点，左边的子节点在索引<code class="fe lj lk ll lm b">2*i + 1</code>处，右边的子节点在索引<code class="fe lj lk ll lm b">2*i + 2</code>处，其父节点在索引<code class="fe lj lk ll lm b">⌊(i-1)/2⌋</code> ( <code class="fe lj lk ll lm b">⌊⌋</code>表示Floor操作)。</li></ul><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/5f29c9813df1e3c2128855566a2ccd04.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/0*J2UR4TkjQ01IbAfp.png"/></div></figure><p id="891a" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">基于上面的模型，让我们开始实现我们的堆。正如我们提到的，有两种类型的堆:最小堆和最大堆，在本文中，我将研究<code class="fe lj lk ll lm b">max-heap</code>。max-heap和min-heap之间的区别是微不足道的，您可以在理解本文之后尝试写出min-heap。</p><p id="7439" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">完整的代码实现在这个Github <a class="ae ln" href="https://github.com/baoqger/max-heap-in-c" rel="noopener ugc nofollow" target="_blank"> repo </a>里面。</p><p id="5546" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">首先，让我们在头文件中定义max-heap的接口如下:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c80b" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">我们将max-heap定义为<code class="fe lj lk ll lm b">struct _maxheap</code>，并将其实现隐藏在头文件中。并通过一个处理程序(它是一个指针)<code class="fe lj lk ll lm b">maxheap</code>在接口中公开这个结构。这种技术在C程序中被称为<code class="fe lj lk ll lm b"><a class="ae ln" href="https://stackoverflow.com/questions/2301454/what-defines-an-opaque-type-in-c-and-when-are-they-necessary-and-or-useful" rel="noopener ugc nofollow" target="_blank">opaque type</a></code>。<code class="fe lj lk ll lm b">Opaque type</code>模拟OOP编程的封装概念。以便类型的内部细节可以更改，而使用它的代码不必更改。具体实现如下:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="a514" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">max-heap元素存储在<code class="fe lj lk ll lm b">array</code>字段中。数组的容量被定义为字段<code class="fe lj lk ll lm b">max_size</code>，数组中的当前元素数为<code class="fe lj lk ll lm b">cur_size</code>。</p><p id="aa50" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">接下来，我们一个一个的来看一下接口(大部分接口都很简单，所以我就不做过多的解释了)。第一个是<code class="fe lj lk ll lm b">maxheap_create</code>，通过为其分配内存来构造<code class="fe lj lk ll lm b">maxheap</code>的实例。</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3f67" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">max-heap的初始容量设置为64，当需要向堆中插入更多元素时，我们可以动态地扩大容量:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ef28" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">这是一个内部API，所以我们将其定义为一个<code class="fe lj lk ll lm b"><a class="ae ln" href="https://www.tutorialspoint.com/static-functions-in-c" rel="noopener ugc nofollow" target="_blank">static</a></code>函数，将访问范围限制在它的对象文件上。</p><p id="508b" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">当程序不再使用max-heap数据时，我们可以如下销毁它:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="654a" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">不要忘记通过调用<code class="fe lj lk ll lm b">free</code>来释放分配的内存。</p><p id="a527" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">接下来，让我们处理困难但有趣的部分:在<strong class="kn ir"> O(log N) </strong> time中插入一个元素。解决方案如下:</p><ul class=""><li id="bc78" class="lp lq iq kn b ko lr ks ls kw lt la lu le lv li lw lx ly lz bi translated">将元素添加到数组的末尾。(数组的结尾对应于树的底层最左边的空白区域)。</li><li id="0f65" class="lp lq iq kn b ko ma ks mb kw mc la md le me li lw lx ly lz bi translated">将添加的元素与其父元素进行比较；如果它们的顺序正确(在max-heap中，parent应该大于或等于child，对吗？)，停。</li><li id="8f1a" class="lp lq iq kn b ko ma ks mb kw mc la md le me li lw lx ly lz bi translated">如果没有，将元素与其父元素交换，并返回到上面的步骤，直到到达树的顶部(树的顶部对应于数组中的第一个元素)。</li></ul><p id="7317" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">向数组末端添加元素的第一步首先符合<strong class="kn ir"> shape属性</strong>。然后<strong class="kn ir">堆属性</strong>通过遍历堆来恢复。递归遍历和交换过程称为<code class="fe lj lk ll lm b">heapify-up</code>。这可以用下面的伪代码来说明:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6d03" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">实现过程如下:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b438" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated"><code class="fe lj lk ll lm b">heapify-up</code>中所需的操作数量取决于新元素必须上升多少级才能满足堆属性。所以最坏情况下的时间复杂度应该是二进制堆的高度，也就是<strong class="kn ir"> log N </strong>。并且通过使用<code class="fe lj lk ll lm b">cur_size</code>作为索引，可以用常数时间将一个新元素追加到数组的末尾。因此，插入操作的总时间复杂度应该是<strong class="kn ir"> O(log N) </strong>。</p><p id="7243" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">类似地，接下来，让我们继续工作:从堆中提取根，同时在<strong class="kn ir"> O(log N) </strong>时间内保留堆属性。解决方案如下:</p><ul class=""><li id="265a" class="lp lq iq kn b ko lr ks ls kw lt la lu le lv li lw lx ly lz bi translated">用末尾的元素替换数组的第一个元素。然后删除最后一个元素。</li><li id="3860" class="lp lq iq kn b ko ma ks mb kw mc la md le me li lw lx ly lz bi translated">将新根与其子根进行比较；如果顺序正确，就停下来。</li><li id="d095" class="lp lq iq kn b ko ma ks mb kw mc la md le me li lw lx ly lz bi translated">否则，将该元素与其子元素交换，并重复上述步骤。</li></ul><p id="d255" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">这种类似的向下遍历和交换过程被称为<code class="fe lj lk ll lm b">heapify-down</code>。<code class="fe lj lk ll lm b">heapify-down</code>比<code class="fe lj lk ll lm b">heapify-up</code>稍微复杂一点，因为父元素需要与max堆中的<em class="lo">较大的</em>子元素交换。实现过程如下:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="e700" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">基于<code class="fe lj lk ll lm b">heapify-up</code>的分析，同样，提取的时间复杂度也是<strong class="kn ir"> O(log n) </strong>。</p><p id="ebbc" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">下一节，让我们回到本文开头提出的问题。</p><h1 id="0359" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">构建堆的时间复杂度</h1><p id="7c9b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">构建一个堆的时间复杂度是多少？我想到的第一个答案是<strong class="kn ir"> O(n log n) </strong>。由于插入一个元素的时间复杂度为<em class="lo"> O(log n) </em>，对于n个元素，插入重复n次，所以时间复杂度为<em class="lo"> O(n log n) </em>。对吗？</p><p id="b5f1" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">我们可以使用另一种最佳解决方案来构建堆，而不是重复插入每个元素。内容如下:</p><ul class=""><li id="92eb" class="lp lq iq kn b ko lr ks ls kw lt la lu le lv li lw lx ly lz bi translated">任意将n个元素放入数组，以尊重<strong class="kn ir">形状属性</strong>。</li><li id="08a4" class="lp lq iq kn b ko ma ks mb kw mc la md le me li lw lx ly lz bi translated">从最低层开始向上移动，像在<code class="fe lj lk ll lm b">heapify-down</code>过程中一样向下筛选每个子树的根，直到<strong class="kn ir">堆属性</strong>被恢复。</li></ul><p id="08e3" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">下图说明了这一过程:</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/a7f00fc13316c5908a3ff2c6fd7298e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/0*4PTS-qZXccGlJ330.png"/></div></figure><p id="458b" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">该算法可以如下实现:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="edfa" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">接下来，我们来分析一下上面这个过程的时间复杂度。假设堆中有<em class="lo"> n </em>个元素，堆的高度为<em class="lo"> h </em>(上图中的堆，高度为3)。那么我们应该有如下关系:</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/a9d79ccf72276b09e9ef2b299e887408.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*M_tR-fwtF2y26Y7_Z6QK2w.png"/></div></figure><p id="5d60" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">当最后一级只有一个节点时，则n = 2ʰ.并且当树的最后一级被完全填满时，则n = 2ʰ⁺ -1</p><p id="446a" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">并且从底层开始为级别<em class="lo"> 0 </em>(根节点为级别<em class="lo"> h </em>)，在级别<em class="lo"> j </em>中，最多有2ʰ⁻ʲ节点。并且每个节点最多进行<em class="lo"> j </em>次交换操作。所以在j级中，运算的总数是j×2ʰ⁻ʲ.</p><p id="303f" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">因此，构建堆的总运行时间与以下各项成正比:</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/5ddc4b3cc09248c8920241970d6a9911.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*jKKqzGHf8ZzzGusGQGKGRQ.png"/></div></figure><p id="12ab" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">如果我们去掉2ʰ项，那么我们得到:</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/cccd66253e4c0b6f86721bc307eda855.png" data-original-src="https://miro.medium.com/v2/resize:fit:308/format:webp/1*8WuZMwmOLfWZ0S1nVaQCfg.png"/></div></figure><p id="e448" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">我们知道，∑j/2ʲ是一个收敛于2的级数(详细内容，可以参考本<a class="ae ln" href="https://en.wikipedia.org/wiki/Series_(mathematics)" rel="noopener ugc nofollow" target="_blank"> wiki </a>)。</p><p id="2004" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">本<a class="ae ln" href="https://en.wikipedia.org/wiki/Series_(mathematics)" rel="noopener ugc nofollow" target="_blank">维基</a>)。</p><p id="608b" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">利用这一点，我们可以:</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/ed47ba7e0a7b62fadf2c27f1bfab0a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*bseIhk1t4D9RcSdtmm_wBw.png"/></div></figure><p id="9585" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">基于条件2ʰ &lt;= n &lt;=2ʰ⁺ -1，所以我们有:</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/07a51006bf4cf954b127ea3ae6f2d51d.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*OvcX62KzZMpcf3ZtW-Pq5A.png"/></div></figure><p id="ab49" class="pw-post-body-paragraph kl km iq kn b ko lr kq kr ks ls ku kv kw mf ky kz la mg lc ld le mh lg lh li ij bi translated">现在我们证明了建立一个堆是一个线性操作。</p><h1 id="f87a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="fa92" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文中，我们研究了什么是<code class="fe lj lk ll lm b">Heap</code>，并通过实现它来理解它的行为(<code class="fe lj lk ll lm b">heapify-up</code>和<code class="fe lj lk ll lm b">heapify-down</code>)。更重要的是，我们分析了建立一个堆的时间复杂度，并证明了它是一个线性操作。</p></div></div>    
</body>
</html>