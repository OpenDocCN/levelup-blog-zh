<html>
<head>
<title>How to Mint 100,000 NFTs For Free</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何免费铸造100，000 NFT</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-mint-100-000-nfts-for-free-62d83888ff6?source=collection_archive---------2-----------------------#2022-01-20">https://levelup.gitconnected.com/how-to-mint-100-000-nfts-for-free-62d83888ff6?source=collection_archive---------2-----------------------#2022-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2866" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用JavaScript以编程方式将NFT上传到OpenSea.io</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b1e9d7a18da9b06996c925c1c8ee0ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rcoRXIeUTQzFxlXlhRdEWg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">迪伦·卡勒伊在<a class="ae le" href="https://unsplash.com/s/photos/apes-yacht-club?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="95b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在接下来的文章中，我将讲述我如何使用一个简单的脚本在<a class="ae le" href="https://opensea.io/" rel="noopener ugc nofollow" target="_blank"> OpenSea.io </a>上以编程方式创建一组独特的NFT。请注意，这仅仅是关于如何使用dAppeteer/Puppeteer和JavaScript(更具体地说是TypeScript)来自动化网站的概念证明。<strong class="js iu">我不鼓励使用以下任何代码与OpenSea.io或任何其他第三方网站进行交互</strong>。请确保明确检查与您互动的网站的相应服务条款，以避免被永久禁止和删除您的内容。请不要用这个脚本在OpenSea.io上铸造100，000个代币——那只是一个浮华的标题，试图抓住你的注意力，\_(ツ)_/。话虽如此，使用脚本来自动化手动任务是学习JavaScript、HTML以及如何以编程方式与第三方网站交互的好方法。</p><h1 id="6ee2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么选择OpenSea.io？</h1><p id="7edd" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在精心制作了你的NFT图片后，你可能想发布并在市场上出售它们。通常，在这一点上，你会发现铸造大量的NFT实际上是最困难的部分。如果你不想创建一个<a class="ae le" href="https://docs.soliditylang.org/en/v0.8.11/" rel="noopener ugc nofollow" target="_blank">可靠性合同</a>，用<a class="ae le" href="https://www.pinata.cloud/" rel="noopener ugc nofollow" target="_blank"> Pinata </a>和<a class="ae le" href="https://www.alchemy.com/" rel="noopener ugc nofollow" target="_blank"> Alchemy </a>建立账户，并积累数百美元的汽油费，那么OpenSea.io提供了一个方便、免费的替代方案，甚至不需要智能合同。是的，在OpenSea.io上铸造是完全免费的，而且非常容易做到！</p><p id="a014" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不幸的是，OpenSea.io不提供上传/铸造令牌的API。使用他们的网站创建新的令牌很快，但仍然是一个手动和繁琐的过程。手动创建数百个NFT肯定会花费一些时间…因此，我试图找出如何自动化这些步骤。</p><h1 id="3fb9" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">先决条件</h1><p id="620c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">你将需要<a class="ae le" href="https://metamask.zendesk.com/hc/en-us/articles/360015290032-How-to-reveal-your-Secret-Recovery-Phrase" rel="noopener ugc nofollow" target="_blank">的助记短语作为你的元掩码钱包</a>(又名“秘密恢复短语”)来接收新生成的NFTs。下面的代码将使用该短语来自动设置和连接您的钱包。然而，这个短语是一个秘密，所以确保不要和任何人分享，也不要把它提交给git。</p><p id="fef6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你还需要一个OpenSea.io账户，连接同一个MetaMask钱包和<a class="ae le" href="https://opensea.io/collection/create" rel="noopener ugc nofollow" target="_blank">创建一个新的空收藏</a>。记下收藏的名称和URL。下面你会需要的。</p><p id="1cbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，不言而喻，您还需要一组图像(或视频/音频文件),您希望将它们转换成一个NFT集合。</p><h1 id="a366" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">安装软件包</h1><p id="6830" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们首先创建一个新目录，它将保存我们想要转换成NFT的代码和图像。切换到新文件夹，安装第一套NPM软件包:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="01e3" class="mn lg it mj b gy mo mp l mq mr">npm install esbuild esbuild-register dotenv</span></pre><p id="9d70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将安装<a class="ae le" href="https://esbuild.github.io/" rel="noopener ugc nofollow" target="_blank"> ESBuild </a>，一个速度极快的JS捆绑器，内置了对TypeScript的支持，以及<a class="ae le" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> DotEnv </a>来初始化环境变量，以避免硬编码任何秘密。</p><p id="f8f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了实现自动化，我们使用<a class="ae le" href="https://pptr.dev/" rel="noopener ugc nofollow" target="_blank">木偶师</a>来“遥控”Chome或Chromium，并且可以在你能想象到的网站上实现几乎任何事情的自动化。dappeter是一个基于web3的测试和自动化库:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="2461" class="mn lg it mj b gy mo mp l mq mr">npm install @chainsafe/dappeteer@2.3.0 puppeteer</span></pre><p id="47d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我们明确指定了dAppeteer的2.3.0版本，因为在撰写本文时，最新版本与MetaMask存在一些兼容性问题。当涉及到dAppeteer和MetaMask版本时，您需要非常具体，以确保兼容性并避免安装潜在的不支持或不可信的版本。</p><h1 id="317d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">设置您的配置</h1><p id="eeb4" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">创建一个新文件<code class="fe ms mt mu mj b">.env</code>并添加下面的内容。将这些值替换为您的OpenSea集合的名称，添加描述和URL，以及您的元掩码秘密恢复短语:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="9c65" class="mn lg it mj b gy mo mp l mq mr">METAMASK_MNEMONIC_PHRASE="add your twelve word secret metamask recovery phrase here"<br/>COLLECTION_NAME="my-first-collection"<br/>DESCRIPTION="My first NFT created in OpenSea"<br/>URL=<a class="ae le" href="https://example.com" rel="noopener ugc nofollow" target="_blank">https://example.com</a></span></pre><p id="03ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">保存文件，但不要提交给git！为了安全起见，将其添加到您的<code class="fe ms mt mu mj b">.gitignore</code>中。在下面的脚本中，我们将使用恢复短语来自动设置元掩码。这是绝对安全的，它永远不会离开你的本地机器。尽管如此，我还是建议使用备用钱包，以避免在实验和测试过程中意外损坏主钱包。</p><h1 id="8a77" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建脚本</h1><p id="4599" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">为了更容易地解释逻辑，我将把脚本分成几个部分。首先，在项目文件夹中创建一个新文件，并将其命名为<code class="fe ms mt mu mj b">index.ts</code>。然后，让我们创建脚本的标题:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="93ec" class="mn lg it mj b gy mo mp l mq mr">import puppeteer, { Page } from "puppeteer";<br/>import * as dappeteer from "<a class="ae le" href="http://twitter.com/chainsafe/dappeteer" rel="noopener ugc nofollow" target="_blank">@chainsafe/dappeteer</a>";<br/>import * as DotEnv from "dotenv";<br/>import fs from "fs";<br/>import path from "path";<br/>DotEnv.config();</span><span id="7249" class="mn lg it mj b gy mv mp l mq mr">const seed = process.env.METAMASK_MNEMONIC_PHRASE;<br/>const collectionName = process.env.COLLECTION_NAME;<br/>const createAssetURL = `<a class="ae le" href="https://opensea.io/collection/${collectionName}/assets/create`" rel="noopener ugc nofollow" target="_blank">https://opensea.io/collection/${collectionName}/assets/create`</a>;<br/>const description = process.env.DESCRIPTION;<br/>const link = process.env.URL;<br/>const imageDir = path.join(__dirname, "images");</span></pre><p id="6add" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们正在导入木偶师、dAppeteer、DotEnv和一些文件系统助手。调用<code class="fe ms mt mu mj b">DotEnv.config()</code>将自动加载<code class="fe ms mt mu mj b">.env</code>文件的内容并初始化我们的环境变量。</p><p id="0bdf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在初始化依赖关系之后，我们设置了两个静态变量:秘密短语、集合名称、描述和一个将被添加到每个铸造的NFT的链接。都是基于之前创建的<code class="fe ms mt mu mj b">.env</code>环境文件。<code class="fe ms mt mu mj b">imageDir</code>是包含我们上传的所有图片的文件夹。</p><p id="562e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们定义几个稍后会用到的辅助函数:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="b4b9" class="mn lg it mj b gy mo mp l mq mr">async function connectWallet(page: Page, metamask: dappeteer.Dappeteer) {<br/>  // OpenSea gives us a list of different wallet options. MetaMask is the first one.<br/>  console.log("Connecting to Metamask...");</span><span id="fe6c" class="mn lg it mj b gy mv mp l mq mr">  // Force list of wallets to refresh as otherwise OpenSea sometimes doesn't detect MetaMask properly<br/>  const moreButton = await page.$x('//button[contains(.,"Show more options")]');<br/>  await moreButton[0].click();<br/>  await page.waitForTimeout(1000);</span><span id="42c9" class="mn lg it mj b gy mv mp l mq mr">  // Find the MetaMask button and click it<br/>  const metaMaskButton = await page.$x(<br/>    '//button[.//span[contains(text(),"MetaMask")]]'<br/>  );<br/>  await metaMaskButton[0].click();<br/>  await page.waitForTimeout(2000);</span><span id="1d08" class="mn lg it mj b gy mv mp l mq mr">  await metamask.approve();<br/>  console.log("Wallet connected");<br/>}</span></pre><p id="da31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ms mt mu mj b">connectWallet</code>正在寻找当前<code class="fe ms mt mu mj b">page</code>上的“MetaMask”按钮，点击它，连接您的MetaMask钱包。我在测试中发现了一个警告:有时OpenSea不能正确识别元掩码插件。因此，我们首先在钱包列表上发起另一次单击，以确保它正确刷新所有选项。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="93d2" class="mn lg it mj b gy mo mp l mq mr">async function uploadImage(page: Page, filepath: string) {<br/>  const elementHandle = await page.$("#media");<br/>  await elementHandle.uploadFile(filepath);<br/>}</span></pre><p id="e12b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ms mt mu mj b">uploadImage</code>执行实际的文件上传。它将当前图像<code class="fe ms mt mu mj b">page</code>和图像<code class="fe ms mt mu mj b">filepath</code>作为输入参数。</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="8d19" class="mn lg it mj b gy mo mp l mq mr">async function fillFields(<br/>  page: Page,<br/>  name: string,<br/>  description: string,<br/>  link: string<br/>) {<br/>  // Get and fill in the input name<br/>  await page.focus("#name");<br/>  await page.keyboard.type(name, { delay: 25 });</span><span id="94b4" class="mn lg it mj b gy mv mp l mq mr">// Get and fill in the description<br/>  await page.focus("#description");<br/>  await page.keyboard.type(description, { delay: 25 });</span><span id="6d4d" class="mn lg it mj b gy mv mp l mq mr">await page.focus("#external_link");<br/>  await page.keyboard.type(link, { delay: 25 });<br/>}</span></pre><p id="af77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后<code class="fe ms mt mu mj b">fillFields</code>通过填写<code class="fe ms mt mu mj b">name</code>、<code class="fe ms mt mu mj b">description</code>和外部<code class="fe ms mt mu mj b">link</code>字段来完成OpenSea输入表单。</p><p id="58b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">准备就绪后，现在开始主要功能:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="204c" class="mn lg it mj b gy mo mp l mq mr">async function main() {<br/>  // Launch the browser with MetaMask<br/>  const browser = await dappeteer.launch(puppeteer, {<br/>    metamaskVersion: "v10.1.1",<br/>  });<br/>  const metamask = await dappeteer.setupMetamask(browser, { seed });</span><span id="6e97" class="mn lg it mj b gy mv mp l mq mr">  // Open OpenSea.io website in a new tab<br/>  console.log("Launching OpenSea...");<br/>  const page = await browser.newPage();<br/>  await page.goto(createAssetURL, { waitUntil: "networkidle0" });<br/>  await page.bringToFront();</span><span id="59bf" class="mn lg it mj b gy mv mp l mq mr">  // Close first empty tab<br/>  const tabs = await browser.pages();<br/>  await tabs[0].close();</span><span id="eb97" class="mn lg it mj b gy mv mp l mq mr">  // Connect OpenSea with MetaMask<br/>  await connectWallet(page, metamask);<br/>  await page.waitForTimeout(2000);</span><span id="e2dc" class="mn lg it mj b gy mv mp l mq mr">  // The first request will need to be signed explicitly<br/>  console.log("Sign initial request...");<br/>  await metamask.sign();<br/>  await page.bringToFront();<br/>  await page.waitForTimeout(2000);</span><span id="f247" class="mn lg it mj b gy mv mp l mq mr">  // Read the contents of the images folder<br/>  const files = fs.readdirSync(imageDir);</span><span id="d226" class="mn lg it mj b gy mv mp l mq mr">// Start the loop on each image of images folder<br/>  for (const file of files) {<br/>    if (file === ".DS_Store") {<br/>      continue; // Skip macOS hidden file<br/>    }</span><span id="ff29" class="mn lg it mj b gy mv mp l mq mr">    // On every iteration (re-)open the asset creation page<br/>    console.log("Creating new asset...");<br/>    const filepath = path.join(imageDir, file);<br/>    await page.bringToFront();<br/>    await page.goto(createAssetURL);<br/>    await page.waitForSelector("#media"); // wait for the upload button to be available</span><span id="1008" class="mn lg it mj b gy mv mp l mq mr">    // Upload the current image file<br/>    await uploadImage(page, filepath);</span><span id="44f9" class="mn lg it mj b gy mv mp l mq mr">    // Fill the fields using the asset name with the count<br/>    const name = file.split(".")[0];<br/>    await fillFields(page, name, description, link);</span><span id="fe05" class="mn lg it mj b gy mv mp l mq mr">    console.log(`Minting NFT: ${name}...`);<br/>    const createButton = await page.$x('//button[contains(., "Create")]');<br/>    await createButton[0].click();</span><span id="caa7" class="mn lg it mj b gy mv mp l mq mr">    // Now wait for the success popup to appear<br/>    console.log("Waiting for success popup...");<br/>    await page.waitForSelector(<br/>      "div.AssetSuccessModalContentreact__DivContainer-sc-1vt1rp8-1"<br/>    );<br/>    await page.waitForTimeout(1000);</span><span id="14c8" class="mn lg it mj b gy mv mp l mq mr">    // Delete the local files to remember which ones we already uploaded<br/>    fs.rmSync(filepath);<br/>  }</span><span id="0d25" class="mn lg it mj b gy mv mp l mq mr">  console.log("Successfully minted all NFTs");<br/>}</span><span id="2b9f" class="mn lg it mj b gy mv mp l mq mr">main();</span></pre><p id="53a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们更详细地看看这个:</p><ol class=""><li id="3355" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">首先，我们启动浏览器并设置元掩码。这里我们使用<code class="fe ms mt mu mj b">process.env.METAMASK_MNEMONIC_PHRASE</code>环境变量来避免在我们的代码中硬编码它。</li><li id="ceba" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">然后，我们在一个新的浏览器窗口中打开OpenSea.io，并将其连接到我们的MetaMask钱包。</li><li id="7f0c" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">一旦连接了钱包，OpenSea会自动要求我们在初始请求上签名。所以，我们也会这么做。</li><li id="0031" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">现在我们可以读取<code class="fe ms mt mu mj b">imageDir</code>的内容，然后遍历每个文件来创建各自的新NFT资产。</li><li id="ca7c" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">对于每个资产，我们首先重新加载资产创建网站，上传本地图像文件，然后填写表单的其余部分。资产的名称基于文件名。我们只需断开文件扩展名(即<code class="fe ms mt mu mj b">.png</code>或<code class="fe ms mt mu mj b">.jpg</code>)并使用剩余部分作为我们的名称。你可以把这种逻辑运用到任何对你有意义的事情上。</li><li id="8767" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">最后，我们使用<a class="ae le" href="https://www.testim.io/blog/xpath-vs-css-selector-difference-choose/" rel="noopener ugc nofollow" target="_blank"> XPath选择器</a>找到页面底部的“创建”按钮并点击它。这将启动铸造，可能需要几秒钟才能完成。</li><li id="65ec" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">创建资产后，我们必须等待OpenSea来确认我们令牌的成功铸造。我们通过等待一个特定的弹出窗口出现来做到这一点。然后我们可以继续下一个令牌。</li><li id="06d5" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">一旦在OpenSea中创建了一个新的资产，我们就会删除本地图像文件，以跟踪我们之前上传过的图像文件，并避免意外创建副本。</li></ol><p id="319f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在不同的步骤之间有几个睡眠周期(<code class="fe ms mt mu mj b">page.waitForTimeout</code>)，在这个周期中，我们只是等待浏览器和元掩码完成加载。</p><p id="00dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码应该相对容易跟踪和更新。如果您想对资产进行更改并添加更多信息，您可以简单地用自己的逻辑扩展<code class="fe ms mt mu mj b">fillFields</code>函数。</p><h1 id="f4cd" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">利润！</h1><p id="f853" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">有了我们的脚本，是时候最终运行它了！</p><p id="dea6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在与<code class="fe ms mt mu mj b">index.ts</code>文件相同的层次上创建一个新的子目录<code class="fe ms mt mu mj b">images</code>。然后把你想转换成NFTs的所有图片的拷贝放到那个文件夹里。每个文件的名称(没有文件扩展名)将被用作OpenSea中的NFT资产名称。请为您的原始图像制作一个<em class="nk">副本</em>，因为脚本将删除<code class="fe ms mt mu mj b">images</code>文件夹中的内容，以跟踪它已经处理过的图像。</p><p id="fc16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后是关键时刻...运行脚本:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="d501" class="mn lg it mj b gy mo mp l mq mr">node -r esbuild-register index.ts</span></pre><p id="e107" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将使用ESBuild编译我们的脚本，并使用Node.js运行它。您将看到一个新的浏览器窗口打开，脚本发挥了它的魔力。不要手动操作任何窗口，让它不受干扰地运行。否则，您可能会中断流程或中止进程。给它一些时间，因为我们创建了一个又一个资产，给OpenSea.io足够的时间来加载和处理，而不会使它过载。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/43a58403f25abe4205043c09a84b5a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*aoWRjS8n0vTcLIlWm_Cv_w.gif"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我们的剧本在发挥作用！</figcaption></figure><h1 id="7d70" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">下一步是什么？</h1><p id="885d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">上面的代码可以在GitHub中找到:<a class="ae le" href="https://github.com/arabold/opensea-uploader" rel="noopener ugc nofollow" target="_blank">https://github.com/arabold/opensea-uploader</a>:</p><div class="nm nn gp gr no np"><a href="https://github.com/arabold/opensea-uploader" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">arabold/open sea-上传程序</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ky np"/></div></div></a></div><p id="c70c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这应该可以让你在OpenSea中创建一个新的NFT集合的最乏味的工作自动化。但是，整个脚本仍然非常简单，只能填充基本的属性。将来您可能希望扩展它来设置自定义属性和其他元数据。</p></div></div>    
</body>
</html>