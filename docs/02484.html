<html>
<head>
<title>JavaScript Clean Code — Functions and Convention Heuristics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript干净代码—函数和约定试探法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-clean-code-functions-and-convention-heuristics-cb223c323a7e?source=collection_archive---------10-----------------------#2020-03-16">https://levelup.gitconnected.com/javascript-clean-code-functions-and-convention-heuristics-cb223c323a7e?source=collection_archive---------10-----------------------#2020-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/747a061a783a5ae7865963a86480764d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a7AkMI-l6elYiy0I"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@chupzzz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ruslan Zh </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a08a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">糟糕的代码有许多独特的字符。在这篇文章中，我们将看看每一个和他们是什么。我们看更一般的代码味道。</p><h1 id="7b11" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用解释变量</h1><p id="964b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">变量应该有自己的名字。例如，不具有解释性的东西是像<code class="fe mh mi mj mk b">x</code>或<code class="fe mh mi mj mk b">y</code>这样的东西。我们不知道它们是什么意思。</p><p id="d730" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，<code class="fe mh mi mj mk b">numOranges</code>或<code class="fe mh mi mj mk b">numApples</code>是解释性的，因为它们告诉我们要在这些变量中存储什么。我们知道我们将它分别设置为橘子和苹果的数量。</p><h1 id="8cf1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">函数名应该说明它们是做什么的</h1><p id="cefc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数名需要告诉我们它们在做什么，这样我们就不用猜了。</p><p id="3515" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不知道<code class="fe mh mi mj mk b">date.add(2)</code>是做什么的？它可以增加秒、分、小时、天、月，或者任何我们还没有想到的东西。</p><p id="7ee7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该将其重命名为更清晰的名称，如<code class="fe mh mi mj mk b">addDays</code>或<code class="fe mh mi mj mk b">addMonths</code>，这样我们就知道我们添加了什么。</p><p id="11bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们必须查看代码或文档才能知道它在高层次上做了什么，那么也许它应该被重命名。</p><h1 id="1e93" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">理解算法</h1><p id="a5e0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该理解我们写的代码。否则，我们可能偶尔会侥幸成功，但如果我们不知道它到底在做什么，那么我们最终会遇到问题。</p><p id="42e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们遇到问题时，我们不知道如何解决它们，因为我们一开始就不明白我们写的是什么。</p><p id="b496" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，通过猜测来编写代码会产生混乱的代码，因为我们为了让它们工作而对它们进行了处理，但是我们担心当我们清理代码时，它会再次失败。</p><p id="a5e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该在编写代码之前和期间进行思考和理解。</p><h1 id="c1d3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">更喜欢多态而不是条件</h1><p id="e95d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">条件句又长又乱。嵌套的更糟糕。如果我们只是用它们来调用不同的对象，我们应该尽可能少地使用它们。</p><h1 id="f1da" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">遵循标准惯例</h1><p id="9e22" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">每个人都应该遵循基于行业规范的编码标准。在JavaScript中，有命名变量、常量和函数的约定。</p><p id="5594" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，文件之间的间距和最大行长度是标准化的。</p><p id="54dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过使用Linters和代码格式化程序来自动处理这些问题。</p><p id="f0db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像垂直格式、函数和变量的放置等其他事情必须手动处理。</p><h1 id="c2f9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用命名常数替换幻数</h1><p id="5ea7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当一个数没有被赋值给一个常数时，很难知道它意味着什么。</p><p id="801d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，如果我们用一个数作为常数，就要把它赋值给一，这样我们就知道它们的意思了。</p><p id="8990" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个每天小时数的常数，我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="082d" class="mt lf it mk b gy mu mv l mw mx">const HOURS_PER_DAY = 24;</span></pre><p id="ff9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而不仅仅是<code class="fe mh mi mj mk b">24</code>。</p><p id="ca14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他问题包括需要精度的浮点数。为了保持精度不变，我们应该将它们赋为常数。</p><p id="d16f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像<code class="fe mh mi mj mk b">PI</code>和<code class="fe mh mi mj mk b">E</code>这样的东西应该被赋值给常量，这样它们总是有相同的精度。</p><p id="f685" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了数字，它们还适用于重复使用的任何其他常数值。例如，如果我们总是使用字符串<code class="fe mh mi mj mk b">'Joe'</code>编写测试，那么我们可以将它赋给一个常量，并在任何地方引用它。</p><p id="4f5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过这种方式，我们避免了输入错误，减少了产生bug的机会。</p><h1 id="e5e8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">精确</h1><p id="7c21" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该对代码中的所有内容保持精确。例如，我们不应该在变量名中使用<code class="fe mh mi mj mk b">array</code>这个词，除非它是一个数组。</p><p id="1325" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们期望某些东西返回<code class="fe mh mi mj mk b">null</code>或<code class="fe mh mi mj mk b">undefined</code>，那么我们应该检查它们。</p><p id="8764" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们应该期望任何东西的第一个匹配都是正确的匹配。我们实际上应该检查我们正在寻找的条件。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/512adbfdeccddbf0ddd01b96c9c85880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b96u7de1lbzZZN42"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@brookecagle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁克·卡吉尔</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="c943" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">传统之上的结构</h1><p id="d6c2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该加强结构而不是传统。我们可以通过测试和评审来塑造结构。</p><h1 id="30e1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">封装条件</h1><p id="a0cf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们有一个包含多个条件的条件时，考虑将它们封装在一个函数中。</p><p id="2608" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="16ee" class="mt lf it mk b gy mu mv l mw mx">if (employee.type === 'FULL_TIME' &amp;&amp; employee.hasHealthBenefits) {</span><span id="6b17" class="mt lf it mk b gy mz mv l mw mx">}</span></pre><p id="c67a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将布尔表达式放入如下函数中:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="98a6" class="mt lf it mk b gy mu mv l mw mx">const hasFullTimeHealthBenefits = (employee) =&gt; {<br/>  return employee.type === 'FULL_TIME' &amp;&amp; employee.hasHealthBenefits;<br/>}</span><span id="8dc1" class="mt lf it mk b gy mz mv l mw mx">if (hasFullTimeHealthBenefits(employee)) {</span><span id="7006" class="mt lf it mk b gy mz mv l mw mx">}</span></pre><h1 id="82b3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免消极条件句</h1><p id="1ccf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">否定对我们的大脑来说很难，所以我们应该尽可能使用肯定的布尔表达式。例如:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a06b" class="mt lf it mk b gy mu mv l mw mx">if (isEmployed) {</span><span id="fb5c" class="mt lf it mk b gy mz mv l mw mx">}</span></pre><p id="dfa1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">优于:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d036" class="mt lf it mk b gy mu mv l mw mx">if (!isNotEmployed) {</span><span id="6f77" class="mt lf it mk b gy mz mv l mw mx">}</span></pre><h1 id="8d80" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">函数应该做一件事</h1><p id="3622" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数应该只做一件事。如果一个函数做多件事，那么我们应该把它分成更小的函数。</p><p id="17d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="126a" class="mt lf it mk b gy mu mv l mw mx">const calculateTotalPay = (employees) =&gt; {<br/>  let totalPay = 0;<br/>  for (let employee of employees) {<br/>    totalPay += employee.regularPay;<br/>    totalPay += employee.overtimePay;<br/>    totalPay += employee.bonus;<br/>  }<br/>  return totalPay;<br/>}</span></pre><p id="37b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将<code class="fe mh mi mj mk b">totalPay</code>计算移到它自己的函数中，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b69e" class="mt lf it mk b gy mu mv l mw mx">const calculateEmployeePay = (employee) =&gt; {<br/>  return employee.regularPay +<br/>    employee.overtimePay +<br/>    employee.bonus;<br/>}</span><span id="fa16" class="mt lf it mk b gy mz mv l mw mx">const calculateTotalPay = (employees) =&gt; {<br/>  let totalPay = 0;<br/>  for (let employee of employees) {<br/>    totalPay += calculateEmployeePay(employee);<br/>  }<br/>  return totalPay;<br/>}</span></pre><p id="827d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有一个函数来获取总工资和员工工资，而不是一个大函数来获取员工工资和所有员工的总工资。</p><h1 id="7248" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="c44c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">编写代码时，我们应该遵循标准惯例。名字应该是清楚的，他们也应该遵循同样的情况。</p><p id="dcdb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">双重否定也很难理解，要避免。</p><p id="b38c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果常量被重复使用，我们应该给它们赋值。</p><p id="95ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，函数应该只做一件事来简化它们。</p></div></div>    
</body>
</html>