# 云设计模式——简单解释

> 原文：<https://levelup.gitconnected.com/cloud-design-patterns-explained-simply-113c788b33ff>

> 只有模式，模式之上的模式，影响其他模式的模式。被模式隐藏的模式。模式中的模式…”
> 
> 恰克·帕拉尼克

也许描述一个模式的最简单的方式是可预测地重复自身的规律性。图案之美在于它们的无处不在——从最小的微生物中细胞器的排列方式到星系中恒星的排列方式，图案无处不在。你根本无法逃脱这些支配我们物质世界大多数(如果不是全部)法则的模式。

毫不奇怪，设计模式也存在于软件设计领域。*软件设计模式是对常见问题的可重用解决方案(模板)。*20 世纪 70 年代，世界上第一次注意到软件中的设计模式，就像他们现在构建的技术一样，模式从那时起就一直在发展。

![](img/7be18fcc5165d3bd53564612a49471d5.png)

构建高效且可伸缩的软件很像砌一堵砖墙——砌砖工人非常小心地确保他们的墙的模式和对称性得以保持。这使得地基足够坚固，能够支撑堆放在其上的所有东西的重量。它允许建造一堵更高、更强、更“可伸缩”的墙(原谅这个双关语)。像砖块层一样，如果软件工程师要创建一个既高效又可伸缩的解决方案，他们需要关注指导底层软件的设计模式。

随着云计算越来越受欢迎，各地工程师的注意力现在已经转移到利用管理这些过程的模式上。

这里是我发现对我反复有用的云设计模式的汇编。我承认这个列表根据我自己的经验是有偏见的，但是当我了解更多的时候，我会试着补充它。希望这能帮助你更好地理解设计模式。

# ***1。异步请求和应答*和**

**问题陈述**

当我们谈论云应用时，微服务经常会出现在脑海中。这是一种架构风格，其中多个微服务(即远程 API 或第三方服务)被组合以执行专用功能，从而向客户端应用提供特定功能。

在这样的设置中，在所有后端工作完成之前同步处理客户机请求可能并不总是可行的。对于长时间运行的流程来说尤其如此。此外，当对客户端的响应需要几毫秒时，*延迟*也成为一个考虑因素。

**解决方案:异步处理(HTTP 轮询或事件通知)**

*   客户端发出一个 API 请求
*   应用程序现在将工作卸载到另一个后端服务或消息队列
*   客户端可以使用 HTTP GET (HTTP 轮询)定期轮询资源/进程状态，以适合客户端应用程序
*   状态 API 返回“进行中”,表示后端进程仍在运行
*   一旦流程完成，状态将返回所需的输出或对资源的另一个引用
*   一旦流程完成，应用程序还可以推送事件通知，而无需客户端重复轮询

让我们用一个例子来简化一下

*   想象一下，你太累了，不想做饭，决定在你最喜欢的餐馆打电话订外卖(API 请求)
*   餐厅为您提供订单号(确认和参考标识符)
*   你到达餐厅取你点的菜，给他们订单号，餐厅员工告诉你你点的菜还没有完成
*   如果你特别饿，你可以每隔 5-10 分钟回到前台询问你的订单(HTTP 轮询)
*   或者，餐厅可以为您提供一个寻呼机，一旦您的订单完成，它就会发出蜂鸣声(事件通知)

![](img/a4ebe2ce4e6df67861b9d3ce2095a40a.png)

# **2*。命令和查询责任分离(CQRS)***

**问题陈述**

传统上，人们通过 CRUD 数据存储与信息系统进行交互。读取和写入数据模型通常是相同的。随着应用程序复杂性的增加，创建了信息的多种表示，所有表示都引用一个公共数据(概念)模型。这可能会导致数据/资源争用、性能下降，在某些情况下还会导致安全问题。

**解决方案:分离读取和写入模型**

*   这可以通过为读写操作创建单独的模式或不同的数据库来实现。从单个数据存储中的所有读取和对单独数据存储的所有写入/更新
*   创建单独的数据库提供了额外的隔离，有助于提高可伸缩性和性能
*   写数据库可以是关系数据库，而读数据库可以不是基于 SQL 文档的
*   这种方法不仅提供了关注点的分离，还允许每个数据存储根据其工作负载独立扩展
*   在这个模型中，重要的考虑是保持读和写存储之间的同步。这通常是通过从写存储区发布事件并由读存储区使用来实现的

**让我们用一个例子来简化**

*   想象一下，你还在同一家餐馆等你点的菜……当你等外卖的时候，你的肚子饿得咕咕叫。
*   您会注意到延迟是由于只有一个服务员负责所有的用餐者和外卖订单
*   当我们非常忙碌的服务员罗杰正在为一位用餐者点餐时，其他用餐者都在等着点菜
*   然后，一些人(像你一样)正在等待他们外卖订单上的状态，而其他人已经下了订单，现在正在等待服务
*   可悲的是，罗杰已经成为这项业务的瓶颈，餐厅的整体表现已经下降
*   谢天谢地，查理结束休息回来了，开始接受外卖和堂食订单，而罗杰继续为餐桌和外卖食客提供食物

![](img/bc9c5f9dce5933b16cd833e3e0736797.png)

# ***3。事件采购***

**问题陈述**

当与数据交互时，大多数应用程序存储数据的当前状态。对数据元素的更新通常被最新的覆盖。如果需要所有更新的历史记录，需要构建应用程序来维护历史记录表。每次发出更新请求时，当前数据都会在被覆盖之前被移动到历史表中。这增加了拥有强大历史备份的开销，并确保应用程序扩展计划也包括扩展历史存储。

**解决方案—事件存储**

*   将应用程序更改定义为一系列事件，并按照应用的顺序将它们记录在事件存储中(审计跟踪)
*   事件是不可变的，存储为仅追加，但可以发布给消费者，消费者可以根据需要处理它们
*   该模型不仅存储应用程序状态的历史记录，还允许重放这些事件以获得应用程序的当前状态—以下之一

*-完整重建
-时间点重建
-反向事件*

*   这里的技巧是以一种他们不知道真实事务和重放之间的区别的方式处理外部系统

**让我们用一个例子来简化**

*   活动采购的工作很像簿记:簿记员将记录一天的财务交易，如某个组织进行的付款、收款、采购等，并将其记录在供应商或总帐中
*   所有的财务事项，资金进出现在都可以在这些分类账中获得(..审计跟踪)
*   会计可以使用这些信息来创建任何自定义时间段的报告
*   通过交易(重放)，会计师可能会多次重新创建相同的报告，但在指定期间仍会得到相同的结果

![](img/55c24c2a15082ff94d24bfc03f06c3a6.png)

# ***4。重试***

**问题陈述**

由于网络速度慢、超时等原因，分布式环境容易出现瞬时错误。但这些问题通常会自我纠正，如果再次触发该操作，它很可能会成功。在这种情况下，应用程序需要在不影响最终用户体验的情况下处理这些短暂的故障。

**解决方案——试了又试**

*   有 3 种方法可以处理暂时故障

*停止并报告异常:*如果故障不是暂时的，或者重复出现时无法成功，应用程序可以发出警报并记录异常

*立即重试:*如果故障很少，应用程序可以立即重试失败的请求，请求可能会成功

*延迟重试:*如果故障是由连接问题或可能需要很短时间的问题引起的，应用程序可以在经过一段合理的时间后重试失败的请求

*   可以配置时间延迟和重试次数，以满足应用需求
*   如果在期望的重试次数后请求仍然失败，应用程序会将其报告为错误并发出警报

**让我们用一个例子来简化**

*   今天是你亲爱的朋友的生日！你想成为第一个祝福他们的人，所以你会在钟声敲响 12 点的时候给他们打电话
*   电话占线…你以为有人捷足先登了。你挂断电话(有点失望)
*   但是你也知道电话不会占线太久。所以你重拨，这次你接通了，祝他们。#万岁

![](img/bb13a1b43046fb7f35c20d5c56c40dcc.png)

# ***5。*断路器**

**问题陈述**

有些情况下，故障可能是由意外情况引起的，需要相对较长的时间来修复。重试或等待请求超时可能不是最佳选择，因为这可能会导致进一步的级联问题，如资源争用和/或线程阻塞。

**解决方案—快速失败**

防止应用程序重试可能失败的操作

*   断路器充当监视最近操作失败的代理
*   代理维护一个失败计数，如果它超过设置的阈值，它被置于开放状态
*   在打开状态下，请求会立即失败，并由应用程序进行适当的处理
*   但是，仍然允许有限的请求通过，以检查操作是仍然失败还是已经成功(已修复)
*   如果操作继续返回失败，打开状态将继续
*   如果操作成功，则认为问题已经解决，断路器切换到闭合状态
*   这种模式中的错误和失败处理需要仔细考虑，以创建可接受的最终用户体验

**让我们用一个例子来简化**

*   这种模式的灵感来自于家中或办公室电线中的实际断路器
*   电路断路器是在电流过载的情况下防止电路损坏的保护措施
*   它连接到您的电路板，如果检测到电流中有故障，就会中断电流
*   出现故障时，断路器开关会自动断开，阻止电流流过电路(开路)
*   如果没有断路器，在电涌的情况下，你会剩下烧断的保险丝
*   有了断路器，你所要做的就是拔掉一些引起电涌的电器，然后把断路器开关扳回到“开”的位置(闭合)

![](img/087abff14ad5e2c320a81b111174739a.png)

# ***6。边车***

**问题陈述**

监控、日志记录等外围任务对于大多数应用程序来说至关重要，并且通常集成在这些应用程序中。然而，这些任务与应用程序在同一个流程中运行，这可能会导致效率低下，并导致关注点分离不当。此外，这些监控和日志记录组件导致的停机可能会严重影响整个应用程序的功能。

**解决方案:作为边车共置**

*   将一组任务与应用程序放在一起，但是将它们放在它们的流程或容器中，作为一个侧柜
*   Sidecars 通常是小型/可插拔组件，可以用不同的语言编写
*   应用程序和边车都作为一个单元部署，因此延迟很低
*   sidecar 可用于修改应用程序容器的工作方式，而无需对代码进行任何更改
*   边车是固定在应用程序上的，它的生命周期依赖于应用程序
*   如果 sidecar 容器逻辑变得复杂或者与主应用程序紧密耦合，那么它最好与主应用程序的代码集成在一起

**让我们用一个例子来简化**

*   边车的一个常见例子是附在摩托车上的边车——作为一个单元工作
*   边车通过增加载客量来提高摩托车的可用性
*   边车可以由另一家公司制造，不需要从摩托车制造商那里购买——提供了选择的模块化和灵活性
*   它没有自己的发动机，而是依靠实际摩托车的发动机。如果摩托车停下来，边车也停下来

![](img/c4c917559732ed79e08c3a174f47eb5a.png)

虽然我们只是触及了这里的皮毛，但我真的希望这个列表对你有所帮助。

*您发现自己经常使用哪些设计模式？—我很想听到更多关于他们的信息。*

请在下面的评论中发表你的建议，我会尽最大努力更新这个列表，把它们包括进来。