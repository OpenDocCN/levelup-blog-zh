<html>
<head>
<title>HTTPS Every Programmer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTPS每个程序员都应该知道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/https-every-programmer-should-know-7b6d03033873?source=collection_archive---------8-----------------------#2022-04-12">https://levelup.gitconnected.com/https-every-programmer-should-know-7b6d03033873?source=collection_archive---------8-----------------------#2022-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0c3f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们看看你对HTTPS的不了解</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1b81851f17ced927582b8512cf7a366a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1sC_IlZI82LakfYpolfmpw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="1a1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">超文本传输协议(HTTP)是用于传输超媒体文档(如HTML)的应用层协议。它最初是为web浏览器和web服务器之间的通信而设计的，但随着后来的发展，它的应用并不局限于此，成熟的软硬件环境使它成为了互联网的基础设施。我相信你一定接触过它，它就像软件开发中的水或空气一样，太普通了。</p><p id="4beb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但作为程序员，我们可能会因为其共性而忽略很多关键信息，导致日常工作开发中出现一些问题，不知道如何解决。然后，本文将向您介绍其中一个关键信息— HTTPS。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="a4f8" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">为什么是HTTPS？</h1><p id="15f0" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">为什么会出现？它似乎能解决什么问题？</p><p id="57fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要回答以上问题，我们需要先分析一下HTTP的特点。</p><p id="a283" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">HTTP的特点是简单、灵活、易于扩展，但同时又是无状态的(可以使用Cookie技术实现“有状态”)，而且是明文传输，也就是说它的数据是完全可见的，容易被窃听或伪造。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/8a79074392984821cc4d4a2cdd5de87a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*tAlxucAkMU8kpXeC6j6hDQ.png"/></div></figure><p id="8e8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同时，HTTP应用广泛，因此网上支付等高安全要求的场景需要相应的安全措施，于是HTTPS出现了。</p><h1 id="d785" class="mb mc it bd md me mz mg mh mi na mk ml jz nb ka mn kc nc kd mp kf nd kg mr ms bi translated">什么是HTTPS？</h1><p id="cfda" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">HTTPS的RFC文档内容非常少。它指定了一个新的协议名“HTTPS”，默认端口号为443，这是为了在TCP和HTTP之间插入一个“安全层”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/a781b02a033a18e9763fff52a22ecf9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*Npe1Jp7ko9biPAo74-yNog.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="858a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顾名思义，这个安全层对发送的数据进行加密，对接收的数据进行解密，这样中间人就无法窃取信息。<br/>那么只要你理解了这个安全层，你也就理解了HTTPS。</p><p id="831d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SSL是安全套接字层，位于<a class="ae nf" href="https://en.wikipedia.org/wiki/OSI_model" rel="noopener ugc nofollow" target="_blank"> OSI模型</a>的第6层(表示层)。它是网景公司在1994年发明的。有两个版本，v2和v3，v1因为有瑕疵一直没有公开。</p><p id="9b9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SSL发展到v3的时候，证明了自己是一个非常好的安全通信协议，于是互联网工程组IETF在1999年将其改名为TLS(传输层安全)，并正式标准化，从1.0开始重新计算版本号，所以TLS1.0实际上就是SSL 3.1。</p><p id="ad66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前TLS已经开发了三个版本，分别是2006年的1.1，2008年的1.2，2018年的1.3，每个新版本都在不断增强安全性和性能。目前应用最广泛的TLS 1.2，那么我们来揭开TLS 1.2的秘密吧！</p><h1 id="e762" class="mb mc it bd md me mz mg mh mi na mk ml jz nb ka mn kc nc kd mp kf nd kg mr ms bi translated">HTTPS (TLS 1.2)秘密</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/8b0f61dc69bd2e85551b0e9c898eff8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5DP-iQ-4imoziktWLgKAMA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="7e3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我先解释一下上图:</p><p id="f5b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">握手阶段:</p><ol class=""><li id="f687" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">客户端生成一个客户端随机密码，然后将其支持的对称密码套件和非对称密码套件传递给服务器。</li><li id="ff00" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">在服务器收到它之后，它将从加密套件中选择要使用的加密算法，生成一个服务器随机数，并将服务证书传递给客户端。</li><li id="d596" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">客户端收到后，会先验证证书。如果证书有效，它会生成一个预主随机数，用证书中的公钥和选择的<strong class="la iu">非对称加密算法</strong>加密，然后传给服务器。它还会附带一条客户端完成确认消息。</li><li id="1d36" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">服务器接收加密的预主控，并可以使用私钥对其进行解密。然后，服务器完成的确认消息将被传递给客户端。</li></ol><p id="e007" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">转移阶段:</p><p id="7340" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在握手阶段之后，两端已经有了客户端随机、服务器随机和pre-master。将它们混合生成最终的主秘密，使用之前选择的<strong class="la iu">对称加密算法</strong>对需要传输的数据进行加密和解密。</p><p id="b9c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">天啊，我就是想发数据就这么麻烦吗？我第一次看的时候也是这么想的。</p><p id="1558" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们耐心点，仔细看看，其实没那么难。</p><h1 id="8d20" class="mb mc it bd md me mz mg mh mi na mk ml jz nb ka mn kc nc kd mp kf nd kg mr ms bi translated">什么是对称加密和非对称加密？</h1><p id="748b" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我们先来解释一下上面提到的对称加密和非对称加密。</p><p id="34d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对称加密意味着加密和解密使用相同的密钥。非对称加密有A和B两个密钥，如果用A密钥加密，只能用B密钥解密；反过来，如果要B密钥加密，只能用A密钥解密。</p><p id="2e33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在HTTPS的握手阶段，我们使用非对称加密，为什么？假设我们使用对称加密:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/d124a8a8c8164e9948fc9b239420cdbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vD43F8oTolK3BTh6bxWmGQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="4bfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上图可以看出，传入的client-random和service-random和symmetric加密套件都是明文的，这就导致了如果黑客得到了数据，他们可以生成相同的密钥，可以是被破解的数据。</p><p id="44ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们使用非对称加密，客户端加密的预主只能解密服务器存储的密钥。</p><h1 id="0ee2" class="mb mc it bd md me mz mg mh mi na mk ml jz nb ka mn kc nc kd mp kf nd kg mr ms bi translated">什么是CA证书？为什么要在握手阶段添加CA证书？</h1><p id="876e" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">因为一旦黑客使用DNS劫持，用黑客的IP地址替换用户想要访问的IP地址，请求就会直接发送到黑客的服务。他在自己的服务上实现了公钥和私钥，客户端完全不知道！</p><p id="e073" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们需要CA (Certificate Authority)认证机构来帮助我们证明这个服务是我们想要访问的服务！</p><h1 id="d9ef" class="mb mc it bd md me mz mg mh mi na mk ml jz nb ka mn kc nc kd mp kf nd kg mr ms bi translated">如何检查CA证书的有效性？</h1><p id="f3dd" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">客户端将按照以下流程进行验证:</p><ol class=""><li id="e1ba" class="nh ni it la b lb lc le lf lh nj ll nk lp nl lt nm nn no np bi translated">检查证书是否已过期</li><li id="9e40" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">检查是否被CA吊销</li><li id="899e" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">检查证书是否由CA颁发机构颁发。我们将使用原始证书信息计算消息摘要，使用CA公钥解密证书中的数字签名，然后将消息摘要与数字签名进行比较。</li><li id="0217" class="nh ni it la b lb nq le nr lh ns ll nt lp nu lt nm nn no np bi translated">证明CA组织的合法性。CA认证链是一个树形结构，根CA证书是一步一步找到的。根CA证书(自签名证书)内置于系统中。要求很严格。如果根CA证书有效，也证明该证书有效。但是如果恶意软件将非法的根CA证书注入用户的系统，那就没有办法了。</li></ol><h1 id="c872" class="mb mc it bd md me mz mg mh mi na mk ml jz nb ka mn kc nc kd mp kf nd kg mr ms bi translated">为什么传输相位是对称加密？</h1><p id="4634" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这是因为对称加密算法通常使用比特运算，而非对称加密主要是RSA中一些大数乘法的计算，所以非对称加密的效率很低，会严重影响传输速度，让用户体验很差。并且我们在握手阶段生成的主秘密足够安全，所以我们可以在传输阶段使用对称加密。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="36ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天就到这里。我是Zachary，我会继续输出与web开发相关的故事，如果你喜欢这样的故事并想支持我，请考虑成为 <a class="ae nf" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nw">中级会员</em> </a> <em class="nw">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae nf" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nw">我的链接</em> </a> <em class="nw">报名，我会得到一点佣金。</em></p><p id="4dc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你的支持对我来说非常重要——谢谢。</p></div></div>    
</body>
</html>