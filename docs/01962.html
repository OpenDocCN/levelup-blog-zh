<html>
<head>
<title>Functional Programming: Currying in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程:在TypeScript中运行</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/devmade-curry-ing-powder-recipe-in-functional-programming-c6e0e45cfbae?source=collection_archive---------4-----------------------#2020-02-09">https://levelup.gitconnected.com/devmade-curry-ing-powder-recipe-in-functional-programming-c6e0e45cfbae?source=collection_archive---------4-----------------------#2020-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class="io ip gp gr iq ab cb"><figure class="ir is it iu iv iw ix paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><img src="../Images/ccf87e8dc00e52fa154d50e42b679395.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*to-RFUQpL26jOyuO-hTImA.png"/></div></figure><figure class="ir is je iu iv iw ix paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><img src="../Images/430c2ae94b36b84233bf97b18468c020.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*O84fc8dF35GJV1A1CbGETA.jpeg"/></div></figure><figure class="ir is jf iu iv iw ix paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><img src="../Images/0552156f224b2554d388ae83fdd1cf2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*1s6x-jdTW7bRkyFWXepRwg.png"/></div><figcaption class="jg jh gj gh gi ji jj bd b be z dk jk di jl jm translated">将一个给定了多个参数的函数转换成一系列函数，每个函数需要一个参数</figcaption></figure></div><h2 id="2276" class="jn jo jp bd b dl jq jr js jt ju jv dk jw translated" aria-label="kicker paragraph">用函数式编程开发咖喱粉配方</h2><div class=""/><div class=""><h2 id="324a" class="pw-subtitle-paragraph kv jy jp bd b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dk translated">什么是curry和curry函数，如何在<strong class="ak"> Java、JavaScript库、React.js、React Native中转换为curry和curry函数，为什么要使用它</strong></h2></div><p id="48b4" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">成分:</p><ul class=""><li id="5966" class="mj mk jp lp b lq lr lt lu lw ml ma mm me mn mi mo mp mq mr bi translated"><strong class="lp jz">愿意理解currying】在函数式编程中，</strong></li><li id="5695" class="mj mk jp lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">任何语言，如JavaScript、Java、…，</li><li id="c1b6" class="mj mk jp lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated"><strong class="lp jz">以固定arity作为输入的正常函数</strong>。</li></ul><h1 id="94b7" class="mx my jp bd mz na nb nc nd ne nf ng nh le ni lf nj lh nk li nl lk nm ll nn no bi translated">我在掩盖什么</h1><p id="b059" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">在<strong class="lp jz">动机</strong>部分，我已经提到了一些原因来回答<strong class="lp jz">为什么</strong>使用<strong class="lp jz">驱动</strong>和<strong class="lp jz">驱动功能</strong>，</p><p id="ade9" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">接下来用<strong class="lp jz">遍历</strong>部分中的一个例子，我将解释<strong class="lp jz">如何</strong>将一个普通函数转换成一个简化函数(这非常简单，不需要特别了解JavaScript)，</p><p id="cfe4" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">最后，在<strong class="lp jz">其他演示</strong>部分，我演示了这种转换和在其他一些语言中的使用，如<strong class="lp jz"> Java </strong>和<strong class="lp jz"> JavaScript，如Lodash、Folktale、Ramda和Sanctuary、React.js和React Native </strong>，以及一些众所周知的事实，如部分应用、解弯曲和同构。</p><h1 id="5be1" class="mx my jp bd mz na nb nc nd ne nf ng nh le ni lf nj lh nk li nl lk nm ll nn no bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="51c8" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated"><strong class="lp jz">定义:</strong> Currying是通过固定的arity(给定参数的数量)将一个函数转换为一个嵌套返回函数序列的函数，每个函数一次接受其中一个参数。</p><p id="0bec" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">func([1..n]) -&gt; func[1..n](1)</p><p id="77a4" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><strong class="lp jz">代码:</strong>如果我们有这个功能:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="6216" class="od my jp nz b gy oe of l og oh">const soakIn = (a: string, b: string) =&gt; b + " " + a;<br/>soakIn("soaked in BBQ sauce", "beef"); // beef soaked in BBQ sauce</span></pre><p id="5dff" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们可以把它形成一个固定的功能:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="14e1" class="od my jp nz b gy oe of l og oh">const soakIn = (a: string) =&gt; (b: string) =&gt; b + " " + a;<br/>soakIn("soaked in BBQ sauce")("beef"); // beef soaked in BBQ sauce</span></pre><p id="0b1e" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">简而言之，这就是currying所做的，但是更多的细节在👉<strong class="lp jz">走查</strong>部分。</p><blockquote class="oi oj ok"><p id="fc78" class="ln lo ol lp b lq lr kz ls lt lu lc lv om lx ly lz on mb mc md oo mf mg mh mi ij bi translated">我的一个叫<a class="ae op" href="https://twitter.com/_Sohayl" rel="noopener ugc nofollow" target="_blank"> Soheyl </a>的朋友相信烧烤酱让一切都变得完美！(真实故事)<em class="jp">😀</em></p><p id="1bb6" class="ln lo ol lp b lq lr kz ls lt lu lc lv om lx ly lz on mb mc md oo mf mg mh mi ij bi translated"><em class="jp">他可以通过</em> <code class="fe oq or os nz b">const soakedInBBQ = soakIn("soaked in BBQ sauce");</code> <em class="jp">创建一个特定的函数，并通过他想要的每一个参数调用新的函数，就像</em> <code class="fe oq or os nz b">soakedInBBQ("chicken"); // chicken soaked in BBQ sauce</code>一样</p></blockquote></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><h1 id="9a7a" class="mx my jp bd mz na pa nc nd ne pb ng nh le pc lf nj lh pd li nl lk pe ll nn no bi translated">动机</h1><p id="70a1" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated"><strong class="lp jz">为什么在函数式编程中使用curried函数很重要？</strong></p><p id="41a1" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><strong class="lp jz">以下是curried functions给你的一些关键优势:</strong></p><p id="ea14" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><em class="ol">如果他们中的一些人首先不清楚，请尝试在</em> <strong class="lp jz"> <em class="ol">演练</em> </strong> <em class="ol">或</em> <strong class="lp jz"> <em class="ol">已知事实</em> </strong> <em class="ol">章节</em>中了解他们中其他部分的组成部分</p><h2 id="d214" class="od my jp bd mz pf pg dn nd ph pi dp nh lw pj pk nj ma pl pm nl me pn po nn jv bi translated"><strong class="ak">利用依赖注入进行测试</strong></h2><p id="d9b7" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">例如，如果您有一个函数使用了API这样的副作用，您可以通过curry并期望API作为curry函数中的一个参数来使该函数抽象。这样你可以通过模仿API来测试你的curried函数。</p><p id="097c" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">之前:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="0640" class="od my jp nz b gy oe of l og oh">import * as api from 'whatever';</span><span id="394a" class="od my jp nz b gy pp of l og oh">function saveData(payload: any) {  <br/>  return api.save('Route', payload);<br/>}</span></pre><p id="2213" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">之后:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="7bc9" class="od my jp nz b gy oe of l og oh">import * as api from 'whatever';<br/>import * as R from 'ramda';</span><span id="351e" class="od my jp nz b gy pp of l og oh">function _saveData(apiDep: any, payload: any) {  <br/>  return apiDep.save('Route', payload);<br/>}</span><span id="64ad" class="od my jp nz b gy pp of l og oh">export const saveData = R.curry(_saveData)(api);</span></pre><p id="661a" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">简化版，灵感源自这篇中型文章:</p><p id="3cf3" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><a class="ae op" href="https://medium.com/@curtistatewilkinson/dependency-injection-currying-and-partial-application-for-easy-unit-tests-ded40c39016c" rel="noopener">medium.com/@curtistatewilkinson</a></p><h2 id="1ba1" class="od my jp bd mz pf pg dn nd ph pi dp nh lw pj pk nj ma pl pm nl me pn po nn jv bi translated"><strong class="ak">简易专用功能</strong></h2><p id="6a28" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">你可以更早地将一些输入硬编码成函数(从一个简化的函数开始)，这个<strong class="lp jz">可以让你灵活地使用不同的专用函数</strong>来满足你的需求。因此，它<strong class="lp jz">使代码更加简洁明了</strong>(例如，在高阶函数上使用特殊函数时):</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="cf5f" class="od my jp nz b gy oe of l og oh">const sum = (a: number, b: number) =&gt; a + b;<br/>const curriedSum = _.curry(sum);</span></pre><p id="c14c" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">之前:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="ce75" class="od my jp nz b gy oe of l og oh">[1, 2, 3].map((x: number) =&gt; curriedSum(2)(x));</span></pre><p id="b67d" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">之后:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="8c34" class="od my jp nz b gy oe of l og oh">const addedBy2 = curriedSum(2);<br/> <br/>[1, 2, 3].map(addedBy2);</span></pre><h2 id="26a8" class="od my jp bd mz pf pg dn nd ph pi dp nh lw pj pk nj ma pl pm nl me pn po nn jv bi translated"><strong class="ak">通过整体储存和新鲜研磨最大限度地增加香料风味</strong>😀</h2><p id="13d7" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">制造专门的功能并使用它，就像研磨某种东西以添加到其他需要时研磨过的成分中(某种)</p><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi pq"><img src="../Images/58db3df44f170c71f0bbb0ee74eb3802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuYjgJa5G8D81hYKbp-ErA.jpeg"/></div></div></figure><blockquote class="oi oj ok"><p id="1438" class="ln lo ol lp b lq lr kz ls lt lu lc lv om lx ly lz on mb mc md oo mf mg mh mi ij bi translated">香料的味道部分来源于暴露在空气中时会氧化或蒸发的化合物(挥发性油)。研磨香料会大大增加其表面积，从而提高氧化和蒸发的速度。因此，通过储存整个香料并在需要时研磨，风味被最大化。一整支干香料的保质期大致是两年；大概六个月的时间。磨碎的香料的“风味寿命”会短得多。磨碎的香料最好避光保存。</p><p id="5b7c" class="ln lo ol lp b lq lr kz ls lt lu lc lv om lx ly lz on mb mc md oo mf mg mh mi ij bi translated"><a class="ae op" href="https://en.wikipedia.org/wiki/Spice" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Spice</a></p></blockquote><h2 id="4689" class="od my jp bd mz pf pg dn nd ph pi dp nh lw pj pk nj ma pl pm nl me pn po nn jv bi translated"><strong class="ak">它帮助我们创建抽象函数，并带来了许多类似于面向对象程序设计中抽象的优点，</strong></h2><h2 id="1caf" class="od my jp bd mz pf pg dn nd ph pi dp nh lw pj pk nj ma pl pm nl me pn po nn jv bi translated"><strong class="ak">它让我们更灵活地将函数组合成高阶函数，… </strong></h2></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><h1 id="f05e" class="mx my jp bd mz na pa nc nd ne pb ng nh le pc lf nj lh pd li nl lk pe ll nn no bi translated">走查</h1><p id="1d13" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">让我们来看看这个正常的函数:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="c549" class="od my jp nz b gy oe of l og oh">function grind(a: string, b: string, c: string, d: string) {<br/>  return (a + b + c + d).shuffle();<br/>}</span></pre><p id="9110" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这个函数将获得咖喱粉的4种成分，将它们连接在一起，然后混洗(粉碎)它们，并返回一个混洗的字符串(混合物)。</p><p id="498f" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">来洗牌(为什么？这里不重要，串联就够了，可以跳过<code class="fe oq or os nz b">.shuffle()</code>部分)我用的是StackOverflow的<a class="ae op" href="https://stackoverflow.com/a/3943985/9470990" rel="noopener ugc nofollow" target="_blank">这个答案</a>作者<em class="ol"> Andy E </em>。这只是一个打乱或混淆字符串的函数。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="0809" class="od my jp nz b gy oe of l og oh">String.prototype.shuffle = function () {<br/>  var a = this.split(""),<br/>    n = a.length;<br/><br/>  for(var i = n - 1; i &gt; 0; i--) {<br/>    var j = Math.floor(Math.random() * (i + 1));<br/>    var tmp = a[i];<br/>    a[i] = a[j];<br/>    a[j] = tmp;<br/>  }<br/>  return a.join("");<br/>}</span></pre><p id="b46b" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这里我们传递4种香料:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="e4cd" class="od my jp nz b gy oe of l og oh">grind("Chillies ", "Ginger ", "Turmeric ", "MellB!"); // I love currying!</span></pre><p id="b294" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe oq or os nz b">Mell B</code>？Nop！这并没有发生！实际上这是函数调用:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="2b13" class="od my jp nz b gy oe of l og oh">grind("Chillies", "Ginger", "Turmeric", "Coriander"); // dGorslgrcianhrireeernTliCiiuemC</span></pre><p id="f82b" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">是啊！这是地面输出！</p><p id="41de" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">让我们把研磨函数转换成一个<code class="fe oq or os nz b">curried</code>函数:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="b10c" class="od my jp nz b gy oe of l og oh">function grind(a: string) {<br/>  return (b: string) =&gt; {<br/>    return (c: string) =&gt; {<br/>      return (d: string) =&gt; {<br/>        return (a + b + c + d).shuffle()<br/>      }<br/>    }<br/>  }<br/>}<br/>grind("Chillies")("Ginger")("Turmeric")("Coriander") // dGorslgrcianhrireeernTliCiiuemC</span></pre><p id="6421" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如你所见，我们现在这样调用研磨函数👆有多个函数调用。每个调用都返回一个新的包装器(像函数(b))需要用一个参数来实现。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="fd7d" class="od my jp nz b gy oe of l og oh">const groundByChillies = grind("Chillies");<br/>const groundByChilliesAndGinger = groundByChillies("Ginger");<br/>const groundByChilliesAndGingerAndTurmeric = groundByChilliesAndGinger("Turmeric");<br/>const result = groundByChilliesAndGingerAndTurmeric("Coriander"); <br/>log(result); // dGorslgrcianhrireeernTliCiiuemC</span></pre><p id="0aac" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">通过调用第一个参数:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="51c2" class="od my jp nz b gy oe of l og oh">grind("Chillies");</span></pre><p id="f6ad" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">该函数返回:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="4fa1" class="od my jp nz b gy oe of l og oh">return (b: string) =&gt; {<br/>  return (c: string) =&gt; {<br/>    return (d: string) =&gt; {<br/>      return (a + b + c + d).shuffle()<br/>    }<br/>  }<br/>}</span></pre><p id="85d0" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">现在，通过传递第二个参数:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="5a3d" class="od my jp nz b gy oe of l og oh">groundByChillies("Ginger");</span></pre><p id="0bfe" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">该函数将被返回:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="55f6" class="od my jp nz b gy oe of l og oh">return (c: string) =&gt; {<br/>  return (d: string) =&gt; {<br/>    return (a + b + c + d).shuffle()<br/>  }<br/>}</span></pre><p id="d136" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这将持续到最后一次调用，并且通过每个参数，将保持对该词法环境(参数)的闭包(每个函数都可以访问其父函数的范围)，这意味着它具有先前传递的其他参数，最后，它返回结果。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="99a4" class="od my jp nz b gy oe of l og oh">log(result); // dGorslgrcianhrireeernTliCiiuemC</span></pre><h1 id="c93c" class="mx my jp bd mz na nb nc nd ne nf ng nh le ni lf nj lh nk li nl lk nm ll nn no bi translated">其他演示</h1><p id="4c4a" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">如果您对其他语言(如Java)的实现以及React.js和React Native等框架或库不感兴趣，您可以直接跳到众所周知的事实。</p><h1 id="ecd0" class="mx my jp bd mz na nb nc nd ne nf ng nh le ni lf nj lh nk li nl lk nm ll nn no bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h1><p id="03ac" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">在Java中，如果你有这个函数:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="6284" class="od my jp nz b gy oe of l og oh">public static int <strong class="nz jz">sum(</strong>int a<strong class="nz jz">,</strong> int b<strong class="nz jz">)</strong> <strong class="nz jz">{<br/>  </strong>return a <strong class="nz jz">+</strong> b<strong class="nz jz">;<br/>}</strong></span></pre><p id="c47b" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">你可以把它变成一个咖喱功能</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="39a6" class="od my jp nz b gy oe of l og oh">public static Function<strong class="nz jz">&lt;</strong>Integer<strong class="nz jz">,</strong> Function<strong class="nz jz">&lt;</strong>Integer<strong class="nz jz">,</strong> Integer<strong class="nz jz">&gt;&gt;</strong> <strong class="nz jz">curriedSum()</strong> <strong class="nz jz">{<br/>  </strong>return x <strong class="nz jz">-&gt;</strong> y <strong class="nz jz">-&gt;</strong> x <strong class="nz jz">+</strong> y<strong class="nz jz">;<br/>}</strong></span></pre><p id="a76c" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">调用第一个sum函数:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="c56d" class="od my jp nz b gy oe of l og oh">sum<strong class="nz jz">(</strong>1<strong class="nz jz">,</strong> 2<strong class="nz jz">); </strong><em class="ol">// gives 3</em></span></pre><p id="67ee" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">把咖喱称为:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="5329" class="od my jp nz b gy oe of l og oh">curriedSum<strong class="nz jz">(); </strong><em class="ol">// returns a function<br/></em>curriedSum<strong class="nz jz">().</strong>apply<strong class="nz jz">(</strong>1<strong class="nz jz">); </strong><em class="ol">// returns a function<br/></em>curriedSum<strong class="nz jz">().</strong>apply<strong class="nz jz">(</strong>1<strong class="nz jz">).</strong>apply<strong class="nz jz">(2) </strong><em class="ol">// returns 3</em></span></pre><h1 id="3c19" class="mx my jp bd mz na nb nc nd ne nf ng nh le ni lf nj lh nk li nl lk nm ll nn no bi translated"><strong class="ak"> React.js和React Native </strong></h1><p id="4bd3" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">除了input和div元素(事件处理程序在这里很重要，这是相同的)，React.js和React Native之间的所有内容都是相同的。</p><h2 id="77b5" class="od my jp bd mz pf pg dn nd ph pi dp nh lw pj pk nj ma pl pm nl me pn po nn jv bi translated"><strong class="ak">反应和还原</strong></h2><p id="4a22" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">react-redux <code class="fe oq or os nz b">connect()</code>函数是一个定制函数的例子。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="a18b" class="od my jp nz b gy oe of l og oh">export default connect(mapStateToProps)(MyComponent)</span></pre><h2 id="82b9" class="od my jp bd mz pf pg dn nd ph pi dp nh lw pj pk nj ma pl pm nl me pn po nn jv bi translated">事件处理</h2><p id="f738" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">React上的事件处理程序已经像curried一样被处理了，所以在<code class="fe oq or os nz b">handleChange</code>的定义中，你可以使用传递的事件参数。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="8fb4" class="od my jp nz b gy oe of l og oh">const handleChange = (fieldName: string) =&gt; (event: any) =&gt; {<br/>  saveField(fieldName, event.target.value)<br/>}<br/>&lt;input type="text" onChange={() =&gt; handleChange('username')} /&gt;</span></pre><p id="7d50" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">React在后台这样调用事件处理程序:<code class="fe oq or os nz b">(event) =&gt; handleChange(param)(event)</code>。</p><p id="bf11" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们可以更进一步。如果我们想将这个处理程序传递给不同的输入字段组件，我们可以将<code class="fe oq or os nz b">saveField</code>和<code class="fe oq or os nz b">fieldName</code>硬编码成<code class="fe oq or os nz b">handleChange</code>化的函数。这样，即使<code class="fe oq or os nz b">saveField</code>功能已经与<code class="fe oq or os nz b">handleChange</code>合并，它也保持了代码的整洁。我使用钩子‘T5’来实现<code class="fe oq or os nz b">saveField</code>,所以<code class="fe oq or os nz b">handleChange</code>被重构为<code class="fe oq or os nz b">handleState</code>,而<code class="fe oq or os nz b">fieldName</code>被重构为状态<code class="fe oq or os nz b">username</code>。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="f7b1" class="od my jp nz b gy oe of l og oh">import React, { useState } from 'react';</span><span id="bec5" class="od my jp nz b gy pp of l og oh">function Username({handleState}: {handleState: any}) {<br/>  return (<br/>    <!-- -->&lt;input type="text" onChange={handleState} /&gt;<br/>  );<br/>}</span><span id="2eb8" class="od my jp nz b gy pp of l og oh">function Main() {<br/>  const [username, setUsername] = useState(''); </span><span id="ca7d" class="od my jp nz b gy pp of l og oh">  const handleState = (setState: any) =&gt; (state: string) =&gt; (event: any) =&gt; {<br/>    setState(event.target.value);<br/>  };</span><span id="5a20" class="od my jp nz b gy pp of l og oh">  const setUsernameState = handleState(setUsername)(username);  </span><span id="a369" class="od my jp nz b gy pp of l og oh">  return (<br/>    &lt;div&gt;<br/>      &lt;Username handleState={setUsernameState} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><h1 id="5cac" class="mx my jp bd mz na pa nc nd ne pb ng nh le pc lf nj lh pd li nl lk pe ll nn no bi translated">众所周知的事实</h1><h2 id="0740" class="od my jp bd mz pf pg dn nd ph pi dp nh lw pj pk nj ma pl pm nl me pn po nn jv bi translated"><strong class="ak">使用任意arity的函数</strong></h2><p id="b7d8" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">以下是能够用多参数调用的curry实现(这意味着curry函数可以被称为普通或完全curry):</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="e9cd" class="od my jp nz b gy oe of l og oh">function curry(func: Function) {<br/>  return function curried(...args: any[]) {<br/>    if (args.length &gt;= func.length) {<br/>      return func.apply(this, args);<br/>    } else {<br/>      return function(...args2: any[]) {<br/>        return curried.apply(this, args.concat(args2));<br/>      }<br/>    }<br/>  };<br/>}</span><span id="a71c" class="od my jp nz b gy pp of l og oh">function sum(a: number, b: number, c: number) {<br/>  return a + b + c;<br/>}</span><span id="e01b" class="od my jp nz b gy pp of l og oh">let curriedSum = curry(sum);</span><span id="7c9a" class="od my jp nz b gy pp of l og oh">alert( curriedSum(1, 2, 3) ); // 6, still callable normally<br/>alert( curriedSum(1)(2,3) ); // 6, currying of 1st arg<br/>alert( curriedSum(1)(2)(3) ); // 6, full currying</span></pre><p id="434f" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><a class="ae op" href="https://javascript.info/currying-partials#advanced-curry-implementation" rel="noopener ugc nofollow" target="_blank"> javascript.info </a></p><h2 id="adad" class="od my jp bd mz pf pg dn nd ph pi dp nh lw pj pk nj ma pl pm nl me pn po nn jv bi translated"><strong class="ak">解开绳索</strong></h2><p id="0240" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">uncurry函数与curry函数正好相反，它接受一个curried函数并返回一个普通的uncurried函数。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="5f89" class="od my jp nz b gy oe of l og oh">function uncurry(fn: Function) {<br/>  return function(a: any, b: any) {<br/>    return fn(a)(b);<br/>  }<br/>}</span></pre><p id="61a5" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这是为了不携带任何arity函数:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="a1b2" class="od my jp nz b gy oe of l og oh">function uncurry(fn: Function) {<br/>  return function(...args: any[]) {<br/>    return args.reduce((fn: Function, arg: any) =&gt; fn(arg), fn);<br/>  }<br/>}</span></pre><p id="5a87" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">例如，如果你认为curriedSum是一个curried，并不担心:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="f2d1" class="od my jp nz b gy oe of l og oh">const curriedSum = (a: number) =&gt; {<br/>    return (b: number) =&gt; {<br/>        return a + b;<br/>    }<br/>}</span><span id="7217" class="od my jp nz b gy pp of l og oh">const uncurriedSum = uncurry(curriedSum);<br/>uncurriedSum(1, 2); // 3</span></pre><p id="328e" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">uncurriedSum相当于一个普通的uncurried函数，如下所示:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="71ae" class="od my jp nz b gy oe of l og oh">const sum = (a: number, b: number) =&gt; return a + b;</span></pre><h2 id="52b0" class="od my jp bd mz pf pg dn nd ph pi dp nh lw pj pk nj ma pl pm nl me pn po nn jv bi translated"><strong class="ak">同构</strong></h2><p id="da24" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">如定义所说<em class="ol"> isos的意思是</em>“相等”，<em class="ol"> morphe </em>相当于“形式”或“形状”。curry和uncurry互为反义词，某一特定功能的curry和un curry等价于同一个特定功能。</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="bc75" class="od my jp nz b gy oe of l og oh">function curry&lt;X, Y, R&gt;(fn : <strong class="nz jz">(X, Y) =&gt; R</strong>) : <strong class="nz jz">X =&gt; Y =&gt; R</strong> {<br/>  ...<br/>};<br/> <br/>function uncurry&lt;X, Y, R&gt;(fn : <strong class="nz jz">X =&gt; Y =&gt; R</strong>) : <strong class="nz jz">(X, Y) =&gt; R</strong> {<br/>  ...<br/>};</span></pre><p id="7468" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe oq or os nz b">(X, Y) =&gt; R</code>和<code class="fe oq or os nz b">X =&gt; Y =&gt; R</code>是由<code class="fe oq or os nz b">curry</code>和<code class="fe oq or os nz b">uncurry</code>函数同构的<strong class="lp jz">。这种关系被称为一个<strong class="lp jz">同构。</strong></strong></p><h2 id="3306" class="od my jp bd mz pf pg dn nd ph pi dp nh lw pj pk nj ma pl pm nl me pn po nn jv bi translated"><strong class="ak">性能成本</strong></h2><p id="72a5" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">当我们处理函数时，我们创建了包装到其他函数的函数。在高阶函数中，无论是组合它们还是不使用curried函数，都会导致创建数百或数千个额外的函数，这会导致明显的性能开销，因此最好在需要时使用curried函数。</p><h2 id="ae30" class="od my jp bd mz pf pg dn nd ph pi dp nh lw pj pk nj ma pl pm nl me pn po nn jv bi translated"><strong class="ak">部分应用</strong></h2><p id="4369" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">部分应用与不同的curry函数相关，并且可以通过固定(硬编码)函数的一些自变量并减少该数目来获得。</p><p id="05a5" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如果我们有一个像<code class="fe oq or os nz b">sum</code>一样的普通函数:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="7f17" class="od my jp nz b gy oe of l og oh">function sum(a: number, b: number, c: number) {<br/>  return a + b + c;<br/>}</span><span id="9f27" class="od my jp nz b gy pp of l og oh">function sum2(b: number, c: number) {<br/>  return sum(2, b, c)<br/>}</span></pre><p id="e9b6" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe oq or os nz b">sum2</code>是部分功能应用。在JavaScript中，这种修复也可以通过内置的绑定函数来实现:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="d673" class="od my jp nz b gy oe of l og oh"><em class="ol">function</em>.bind(<em class="ol">thisValue</em>, [<em class="ol">arg1</em>], [<em class="ol">arg2</em>], ...)</span><span id="d7a8" class="od my jp nz b gy pp of l og oh">const sum2 = sum.bind(null, 2)</span></pre><h2 id="c814" class="od my jp bd mz pf pg dn nd ph pi dp nh lw pj pk nj ma pl pm nl me pn po nn jv bi translated"><strong class="ak">JavaScript库中的库里</strong></h2><p id="9616" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">在JavaScript中，可以从Lodash、Folktale、Ramda和Sanctuary等库中使用Curry。签名是一样的，除了我在这里提到的几个:</p><p id="ab07" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在民间故事中，你可以这样称呼它:<code class="fe oq or os nz b">curry(arity, fn)</code>，</p><p id="de56" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Sanctuary有curry2、curry3、curry4和curry5函数。</p><p id="755b" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这是洛达什的一个例子:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="42ae" class="od my jp nz b gy oe of l og oh">import * as _ from 'lodash'; </span><span id="8332" class="od my jp nz b gy pp of l og oh">function sum(a: number, b: number) {<br/>  return a + b;<br/>}<br/><br/>let curriedSum = _.curry(sum);</span></pre></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><h1 id="2d09" class="mx my jp bd mz na pa nc nd ne pb ng nh le pc lf nj lh pd li nl lk pe ll nn no bi translated">夏天似的</h1><p id="74ae" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">如果您将一个提供固定数量参数的普通函数转换为一个嵌套返回函数序列，每个函数每次接受其中一个参数，那么您可以从curried函数中受益。</p><p id="9979" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如果我们有这个函数:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="803b" class="od my jp nz b gy oe of l og oh">function grind(a: string, b: string, c: string, d: string) {<br/>  return (a + b + c + d).shuffle();<br/>}</span></pre><p id="b62a" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe oq or os nz b"><em class="ol">shuffle</em></code> <em class="ol">在前面的</em> <strong class="lp jz"> <em class="ol">走查</em> </strong> <em class="ol">章节</em>中有定义</p><p id="af14" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们可以把它形成一个<code class="fe oq or os nz b">curried</code>函数:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="3501" class="od my jp nz b gy oe of l og oh">function grind(a: string) {<br/>  return (b: string) =&gt; {<br/>    return (c: string) =&gt; {<br/>      return (d: string) =&gt; {<br/>        return (a + b + c + d).shuffle()<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="41e4" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">可以这样称呼:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="03c7" class="od my jp nz b gy oe of l og oh">grind("Chillies")("Ginger")("Turmeric")("Coriander") // dGorslgrcianhrireeernTliCiiuemC</span></pre><p id="a43d" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">此外，我们可以通过删除一些参数并对其他参数进行硬编码来实现一个专门化的函数:</p><pre class="nu nv nw nx gt ny nz oa ob aw oc bi"><span id="c8dc" class="od my jp nz b gy oe of l og oh">const groundByFirst3 = grind("Chillies")("Ginger")("Turmeric");<br/>groundByFirst3("Coriander"); // dGorslgrcianhrireeernTliCiiuemC</span></pre><p id="9bc9" class="pw-post-body-paragraph ln lo jp lp b lq lr kz ls lt lu lc lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">通过使用定制函数，你可以获得一些好处，比如通过创建一个像<code class="fe oq or os nz b">groundByFirst3</code>这样的专用函数来增加灵活性，或者定制函数可以在高阶函数中组合。</p></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><h1 id="acfd" class="mx my jp bd mz na pa nc nd ne pb ng nh le pc lf nj lh pd li nl lk pe ll nn no bi translated">进一步阅读</h1><p id="5bb4" class="pw-post-body-paragraph ln lo jp lp b lq np kz ls lt nq lc lv lw nr ly lz ma ns mc md me nt mg mh mi ij bi translated">如果你对函数式编程感兴趣，并且希望<strong class="lp jz">让你的代码更可预测、更安全、性能更好</strong>，我有另一篇关于函数式编程中<a class="ae op" href="https://medium.com/@zareanmasoud/what-is-immutability-in-functional-programming-6b307ee8641" rel="noopener">不变性的文章</a>。</p></div></div>    
</body>
</html>