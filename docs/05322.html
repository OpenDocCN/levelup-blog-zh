<html>
<head>
<title>Learning C++: Variable Scope</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习C++:可变范围</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-variable-scope-8e11cd49cb4e?source=collection_archive---------3-----------------------#2020-08-19">https://levelup.gitconnected.com/learning-c-variable-scope-8e11cd49cb4e?source=collection_archive---------3-----------------------#2020-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b753ef0192b3c212907fadd995900b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wwQFoqQgNjgBeJTn"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@dannyavilamedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼·阿维拉</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1252" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量作用域指的是变量在程序中“可见”的能力。如果在程序的特定位置，程序员可以访问变量的值，那么这个变量就是可见的。C++程序中有不同的作用域级别，作用域级别决定了一个变量在程序中的可见范围。在这篇文章中，我将讨论变量作用域的不同层次，以及它们为什么重要。</p><h1 id="71c5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">范围级别</h1><p id="36e0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">C++程序中有三个层次的作用域:全局、局部和块。Global是最大的作用域，意味着用global作用域声明的任何变量都可以在程序中的任何地方看到。局部作用域通常指函数中定义的变量，在整个函数中都可以看到，但在其他函数中看不到。块范围意味着一个变量被定义在一个代码块中，比如一个<code class="fe mh mi mj mk b">for</code>循环或者一个<code class="fe mh mi mj mk b">if</code>语句。</p><p id="0bb0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">抛开这些定义，让我们看看这些不同的作用域级别是如何影响C++程序的。</p><h1 id="d39f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">全球范围</h1><p id="05a0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">具有全局范围的变量可以在C++程序的任何其他部分看到，从函数定义到代码块。在主函数之外定义的变量是全局变量。</p><p id="f1ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示全局范围如何工作的示例:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="21ca" class="mt lf it mk b gy mu mv l mw mx">#include &lt;iostream&gt;<br/>using namespace std;</span><span id="deac" class="mt lf it mk b gy my mv l mw mx">// global space</span><span id="9321" class="mt lf it mk b gy my mv l mw mx">int number = 1;</span><span id="356f" class="mt lf it mk b gy my mv l mw mx">void showValue() {<br/>  cout &lt;&lt; "Number accessed from a function: " &lt;&lt; number &lt;&lt; endl;<br/>}</span><span id="0113" class="mt lf it mk b gy my mv l mw mx">int main ()<br/>{<br/>  showValue();<br/>  cout &lt;&lt; "Number accessed from the main function: "<br/>       &lt;&lt; number &lt;&lt; endl;<br/>  for (int i = 1; i &lt;= 1; i++) {<br/>    cout &lt;&lt; "Number accessed from a block: " &lt;&lt; number &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="2f47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e24c" class="mt lf it mk b gy mu mv l mw mx">Number accessed from a function: 1<br/>Number accessed from the main function: 1<br/>Number accessed from a block: 1</span></pre><p id="cbae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">全局变量的主要问题是，因为它们可以从程序中的任何地方访问，所以它们可以在程序中的任何地方更改，这导致了难以发现的逻辑错误。当程序使用全局变量时，它也使得阅读和理解程序变得更加困难，因为读者不得不经常回到全局空间去查看变量是从哪里产生的。</p><h1 id="45f1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">局部变量</h1><p id="157d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">局部变量是在函数定义中定义的变量。函数中定义的变量仅对函数定义中的代码可见。该变量被称为函数的“局部”变量。</p><p id="bd9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示局部作用域如何工作的示例:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2558" class="mt lf it mk b gy mu mv l mw mx">// global space</span><span id="f3c8" class="mt lf it mk b gy my mv l mw mx">int number = 1;</span><span id="9924" class="mt lf it mk b gy my mv l mw mx">void defineNumber() {<br/>  int number = 2;<br/>  cout &lt;&lt; "Number accessed from defining function: "<br/>       &lt;&lt; number &lt;&lt; endl;<br/>}</span><span id="0dda" class="mt lf it mk b gy my mv l mw mx">int main ()<br/>{<br/>  cout &lt;&lt; "Accessing global number: " &lt;&lt; number<br/>       &lt;&lt; endl; // this is the global variable<br/>  defineNumber(); // this is the local version<br/>  number = 2; // changing global variable<br/>  cout &lt;&lt; "Accessing global number: " &lt;&lt; number<br/>       &lt;&lt; endl; // this is the global variable<br/>  return 0;<br/>}</span></pre><p id="5ac2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a4ef" class="mt lf it mk b gy mu mv l mw mx">Accessing global number: 1<br/>Number accessed from defining function: 2<br/>Accessing global number: 2</span></pre><p id="42f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<code class="fe mh mi mj mk b">defineNumber</code>定义了一个名为number的变量，但是是在局部范围而不是全局范围。<code class="fe mh mi mj mk b">main</code>中的代码访问第一个输出语句的全局编号，调用<code class="fe mh mi mj mk b">defineNumber</code>函数来显示该编号变量的值，然后给全局编号赋一个新值。</p><p id="e9b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个例子演示了使用全局变量时可能引起的混乱。</p><h1 id="5fd5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">块范围</h1><p id="ab93" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">第三个作用域级别是块作用域。代码块中定义的变量只能在该代码块内部看到。块是任何用花括号括起来的代码。当然，全局空间和函数定义都有块，但是对于块级别的范围，我们通常讨论更紧密的代码空间，比如for循环。</p><p id="edbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下简短程序演示了全局、本地和数据块范围之间的差异:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8743" class="mt lf it mk b gy mu mv l mw mx">// global space</span><span id="88be" class="mt lf it mk b gy my mv l mw mx">int number = 1;</span><span id="c53f" class="mt lf it mk b gy my mv l mw mx">int main ()<br/>{<br/>  cout &lt;&lt; "Global number: " &lt;&lt; number &lt;&lt; endl;<br/>  int number = 2;<br/>  cout &lt;&lt; "Local number: " &lt;&lt; number &lt;&lt; endl;<br/>  {<br/>    int number = 3;<br/>    cout &lt;&lt; "Block number: " &lt;&lt; number &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="dc46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d36d" class="mt lf it mk b gy mu mv l mw mx">Global number: 1<br/>Local number: 2<br/>Block number: 3</span></pre><p id="e19a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">main</code>中的代码演示了你可以创建一个仅仅是代码的块，它不必附加到一个结构上，比如一个循环。</p><h1 id="1ce7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对于循环和块范围</h1><p id="c882" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">块级作用域最重要的用途之一是约束循环控制变量的值。很多时候你会看到一个<code class="fe mh mi mj mk b">for </code>循环是这样写的:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d789" class="mt lf it mk b gy mu mv l mw mx">int main ()<br/>{<br/>  const int numElements = 5;<br/>  int grades[numElements] = {81, 77, 91, 88, 78};<br/>  int i = 0;<br/>  for (; i &lt; numElements; i++) {<br/>    cout &lt;&lt; grades[i] &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="c1d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不管出于什么原因，作者没有选择在For循环中利用块级范围。这意味着变量<code class="fe mh mi mj mk b">i </code>在循环外是可见的和可访问的，并且在没有重新赋值的情况下不能再次使用。</p><p id="3f5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更好的方法是通过在循环内部初始化循环控制变量，使其始终处于块级别:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6992" class="mt lf it mk b gy mu mv l mw mx">int main ()<br/>{<br/>  const int numElements = 5;<br/>  int grades[numElements] = {81, 77, 91, 88, 78};<br/>  for (int i = 0; i &lt; numElements; i++) {<br/>    cout &lt;&lt; grades[i] &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="3e1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过将循环控制变量<code class="fe mh mi mj mk b">i</code>定义为块范围的变量，我也可以使它的长度为一个字母。这被认为不是好的编程实践，但是在短块中是可以接受的，比如这个块，其中变量的初始化语句接近于它在程序中的用法。</p><h1 id="d282" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">函数参数的范围</h1><p id="b377" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数参数具有局部范围。这意味着它们在函数定义中是可见的，而在其他地方是不可见的。这非常有意义，因为函数定义必须能够访问其参数值，以便在函数中使用它们。</p><h1 id="c016" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何使用可变范围</h1><p id="dddf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">作为一名程序员，你的目标是在不荒谬的情况下，将变量控制在你能控制的最严格的范围内。许多变量必然会被定义为局部变量，但你应该尽可能在块级别定义变量。当然，for循环控制变量应该在块中定义，其他地方不需要的其他循环变量也应该定义为块变量。</p><p id="74b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在块级定义<code class="fe mh mi mj mk b">if</code>语句中的变量时要小心。您经常会收到来自编译器的错误消息，指出在<code class="fe mh mi mj mk b">if</code>中定义的一个或多个变量不可达。这是因为如果被测试的条件不为真，并且变量声明被放在了<code class="fe mh mi mj mk b">if</code>语句的那一部分，那么变量就不能被使用。</p><p id="5c53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量作用域有时会让初学编程的学生感到困惑，但这是一个非常重要的话题，也是一个你在编程教育过程中应该确保理解的话题。</p><p id="17f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请给我发电子邮件提出意见和建议。如果你对我的在线编程课程感兴趣，请访问<a class="ae kf" href="https://learningcpp.teachable.com" rel="noopener ugc nofollow" target="_blank">https://learningcpp.teachable.com</a>。</p></div></div>    
</body>
</html>