<html>
<head>
<title>Implementing A Reverse Proxy Server In Kubernetes Using The Sidecar</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Sidecar在Kubernetes中实现反向代理服务器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implemeting-a-reverse-proxy-server-in-kubernetes-using-the-sidecar-eebba956801a?source=collection_archive---------2-----------------------#2020-02-26">https://levelup.gitconnected.com/implemeting-a-reverse-proxy-server-in-kubernetes-using-the-sidecar-eebba956801a?source=collection_archive---------2-----------------------#2020-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e219" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">本文原载于</em><a class="ae kp" href="https://www.magalix.com/blog/implemeting-a-reverse-proxy-server-in-kubernetes-using-the-sidecar-pattern" rel="noopener ugc nofollow" target="_blank">https://www . magalix . com/blog/implementing-a-reverse-proxy-server-in-kubernetes-using-the-sidecar-pattern</a></p><h1 id="1768" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">什么是边车？</h1><p id="a5fb" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated"><a class="ae kp" href="https://www.magalix.com/blog/the-sidecar-pattern" rel="noopener ugc nofollow" target="_blank">边车</a>指的是附在自行车或摩托车上的座位，这样它们可以用三个轮子行驶。边车通常用来运送乘客或设备。除了军事用途，边车在体育运动中也有很多用途。不管你想在哪里使用边车，概念都是一样的:一个物体附在另一个物体上，从而成为它的一部分。辅助对象的主要目的是帮助主对象。</p><h1 id="1e36" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">什么是Kubernetes边车模式？</h1><p id="fbbb" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">从上面的定义，我们明白了什么是边车，它是用来做什么的。在<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-101-concepts-and-why-it-matters" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>中，我们有边车模式，它利用了Kubernetes最强大的组件之一:<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-pods-101-the-cluster-sailors" rel="noopener ugc nofollow" target="_blank">吊舱</a>。pod的一个重要特性是，在同一个pod上托管的容器共享相同的网络地址和文件系统。同一个pod上的所有容器都可以通过本地主机地址相互连接，就像同一台机器上的进程通过HTTP相互通信一样。因此，我们可以通过应用程序容器创建一个承载主应用程序的pod，并在同一个pod上添加一个sidecar容器来提供额外的功能层。像边车座位一样，同一个pod上的容器被视为一个单元:它们被一起创建、销毁并从一个节点移动到另一个节点。那么，边车模式有哪些可能的用途呢？有很多。例如，我们可以向运行Nginx的应用程序pod添加一个sidecar容器。有了Nginx，我们可以在应用程序中添加一个HTTPS层，只支持HTTP。另一个用例是为uWSGI应用程序(例如Python Flask)提供前端反向代理，这是本文的主题。</p><h1 id="17eb" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">建筑</h1><p id="677f" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们有一个非常简单的API，它是使用Python Flask微框架和Gunicorn服务器构建的。应用程序托管在一个容器中，但是我们需要在它前面有一个web服务器。web服务器接收HTTP请求，在内部将其路由到应用程序pod，并将响应转发回客户端。你可能会问web服务器在这里有什么用，为什么不用Flask呢？这里有一个极好的<a class="ae kp" href="https://www.reddit.com/r/Python/comments/68phcu/why_nginxgunicornflask/" rel="noopener ugc nofollow" target="_blank"> Reddit讨论</a>，可能会解决你的问题。目前，这里是我们的建筑看起来像什么的描述:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/4a74d5f735531ac89cd3abd5bd254ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dLUCeIlAYZtvQkio.png"/></div></div></figure><p id="532d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们开始编写应用程序。</p><h1 id="9377" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">代码</h1><p id="923f" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">如前所述，我们的应用程序是一个简单的Python Flask API。应用程序本身由两个文件组成:一个包含应用程序启动时运行的实际代码(mainapp.py)，另一个包含<a class="ae kp" href="https://gunicorn.org/" rel="noopener ugc nofollow" target="_blank"> Gunicorn </a>运行我们的应用程序所需的指令(wsgi.py)。mainapp.py的内容包括:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="c0b5" class="mk kr it mg b gy ml mm l mn mo">from flask import Flask<br/>from flask import jsonify<br/><br/>app = Flask(__name__)<br/><br/>@app.route("/")<br/>def hello():<br/>   response = {"message":"Hello World!"}<br/>   return jsonify(response)<br/><br/>if __name__ == "__main__":<br/>   app.run(host='0.0.0.0')</span></pre><p id="bb88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">wsgi.py文件看起来像这样:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="e5fd" class="mk kr it mg b gy ml mm l mn mo">from mainapp import app<br/><br/>if __name__ == "__main__":<br/>   app.run()</span></pre><p id="d0f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是docker文件:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="4837" class="mk kr it mg b gy ml mm l mn mo">FROM python:3<br/>RUN pip install gunicorn flask<br/>ADD mainapp.py wsgi.py /app/<br/>EXPOSE 5000<br/>WORKDIR /app<br/>ENTRYPOINT [ "gunicorn","--bind","0.0.0.0:5000","wsgi:app" ]</span></pre><p id="a233" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能希望首先在您的机器上进行本地测试。这可以通过构建映像来实现:</p><p id="c786" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">docker build-t magalix/flask sidecar。</p><p id="9708" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后从映像运行容器:</p><p id="df8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">docker run-d-p 5000:5000 magalixcorp/flask sidecar</p><p id="3a6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，您可以通过发出HTTP请求(使用任何客户端)来确认API正在工作。在本实验中，我们使用旋度:</p><p id="d4fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">$ curl localhost:5000<br/>{ " message ":" Hello World！"}</p><h1 id="82f6" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">Kubernetes部署和服务</h1><p id="4f29" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">在应用我们的<a class="ae kp" href="https://www.magalix.com/blog/kubernetes-deployments-101" rel="noopener ugc nofollow" target="_blank">部署</a>之前，我们需要推送我们的Docker映像，以便它可用于Kubernetes:</p><p id="e6fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">码头推送杂志公司/烧瓶侧车</p><p id="a506" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以将我们的部署和服务组合在一个文件中(让我们称之为deploy.yml):</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="3e8a" class="mk kr it mg b gy ml mm l mn mo"><strong class="mg iu">apiVersion: v1<br/>kind: Service<br/>metadata:<br/> name: hello-svc<br/>spec:<br/> selector:<br/>   role: app<br/> ports:<br/>   - protocol: TCP<br/>     port: 80<br/>     targetPort: 5000<br/>     nodePort: 32001<br/> type: NodePort<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/> name: hello-deployment<br/> labels:<br/>   role: app<br/>spec:<br/> replicas: 2<br/> selector:<br/>   matchLabels:<br/>     role: app<br/> template:<br/>   metadata:<br/>     labels:<br/>       role: app<br/>   spec:<br/>     containers:<br/>     - name: app<br/>       image: "magalixcorp/flasksidecar"</strong></span></pre><p id="ec7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，现在我们的服务正在侦听端口32001上的连接(在我们的任何节点上),并将连接中继到端口5000上的一个后端pod(我们有两个副本)。部署创建了两个pod，每个pod都托管一个使用magalixcorp/sidecar映像的容器。</p><p id="032b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们将这个配置应用到我们的集群:kubectl apply -f deploy.yml</p><p id="9c38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们可以通过向端口32001上的任何集群节点的IP地址发出HTTP请求来测试我们的设置:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="7b06" class="mk kr it mg b gy ml mm l mn mo">$ curl 35.223.240.101:32001<br/>{"message":"Hello World!"}</span></pre><p id="df7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完美！现在，让我们添加我们的边车容器。</p><h1 id="830d" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">添加反向代理边车容器</h1><p id="86f8" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">既然现在一切都很好，你可能会问:为什么我们需要一个反向代理？答案很简单:因为Gunicorn不是web服务器。它可以被认为是一个应用服务器。需要web服务器有几个原因。例如:</p><ul class=""><li id="75db" class="mp mq it js b jt ju jx jy kb mr kf ms kj mt kn mu mv mw mx bi translated">提供静态内容。在本实验中，我们将创建一个通过AJAX调用连接到后端API的HTML页面。放置静态内容(HTML、JS、CSS、图片、PDF文件等)要高效得多。)而不是将其作为应用服务器任务列表的一部分。</li><li id="5da6" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">它可以用作有效的缓存层来提高性能。</li><li id="9a6a" class="mp mq it js b jt my jx mz kb na kf nb kj nc kn mu mv mw mx bi translated">终止HTTPS的交通。您可以在web服务器上安装证书和配置SSL，减轻应用服务器的负担。</li></ul><p id="a916" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，现在我们知道了使用web服务器的一些优点，让我们添加一个。在本实验中，我们使用Nginx，因此您要更改的关键文件是nginx.conf。该文件的内容应该是:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="eda0" class="mk kr it mg b gy ml mm l mn mo">server {<br/>   listen       80;<br/>   server_name  localhost;<br/>   location / {<br/>       root   /usr/share/nginx/html;<br/>       index  index.html index.htm;<br/>   }<br/>   location /api/ {<br/>       proxy_pass  http://localhost:5000/;<br/>   }<br/>   error_page   500 502 503 504  /50x.html;<br/>   location = /50x.html {<br/>       root   /usr/share/nginx/html;<br/>   }<br/>}</span></pre><p id="26a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该文件简单地指示Nginx缺省地提供来自/usr/share/nginx/html的内容和来自localhost:5000的任何动态内容(对/api的任何调用),我们的Flask应用程序正在该处运行。现在，让我们从index.html页面开始添加一些静态内容:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="fdc0" class="mk kr it mg b gy ml mm l mn mo">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/><br/>&lt;head&gt;<br/>   &lt;meta charset="utf-8"&gt;<br/>   &lt;title&gt;Hello World&lt;/title&gt;<br/>&lt;/head&gt;<br/><br/>&lt;body&gt;<br/>   &lt;h1<strong class="mg iu">&amp;Message</strong> from backend API&lt;/h1&gt;<br/>   &lt;div id="backend"&gt;&lt;/div&gt;<br/>   &lt;script src="http://code.jquery.com/jquery-1.9.1.min.js"&gt;&lt;/script&gt;<br/>   &lt;script src="script.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/><br/>&lt;/html&gt;</span></pre><p id="b5c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">进行AJAX调用所需的JavaScript可以在script.js文件中找到:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="4a03" class="mk kr it mg b gy ml mm l mn mo">$(document).ready(function () {<br/>   $.getJSON("/api/", function (result) {<br/>       $("#backend").text(<br/>           result['message']<br/>       );<br/>   });<br/>});</span></pre><p id="747c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如你所见，我们试图把事情做得尽可能简单，这样我们就可以专注于更重要的事情。该页面只显示一个标题，后面是从后端API动态检索的内容。</p><p id="5603" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们把整个事情记录下来。我们的docker文件应该如下所示:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="ed7f" class="mk kr it mg b gy ml mm l mn mo">FROM nginx<br/>ADD default.conf /etc/nginx/conf.d/<br/>ADD index.html script.js /usr/share/nginx/html/</span></pre><p id="bbaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没什么复杂的，只是Nginx配置和静态文件。让我们建立并推广这个形象:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="79d8" class="mk kr it mg b gy ml mm l mn mo"><strong class="mg iu">docker build -t magalixcorp/nginxsidecar .<br/>docker push magalixcorp/nginxsidecar</strong></span></pre><p id="e753" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，让我们修改deploy.yml文件以添加新容器:</p><pre class="lu lv lw lx gt mf mg mh mi aw mj bi"><span id="e1ce" class="mk kr it mg b gy ml mm l mn mo">apiVersion: v1<br/>kind: Service<br/>metadata:<br/> name: hello-svc<br/>spec:<br/> selector:<br/>   role: app<br/> ports:<br/>   - protocol: TCP<br/>     port: 80<br/>     targetPort: 80<br/>     nodePort: 32001<br/> type: NodePort<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/> name: hello-deployment<br/> labels:<br/>   role: app<br/>spec:<br/> replicas: 2<br/> selector:<br/>   matchLabels:<br/>     role: app<br/> template:<br/>   metadata:<br/>     labels:<br/>       role: app<br/>   spec:<br/>     containers:<br/>     - name: app<br/>       image: "magalixcorp/flasksidecar"<br/>     - name: web<br/>       image: "magalixcorp/nginxsidecar"</span></pre><p id="dea5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，我们做了两处修改:指示我们的服务在端口80而不是5000连接到pod。因为我们的pod现在托管两个容器，并且因为同一个pod上的容器共享同一个网络，所以连接到端口80上的pod类似于连接到正在侦听端口80的容器(nginx)。我们做的第二个更改是将该容器添加到我们的pod中(第34和35行)。</p><p id="2ff8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们将修改后的配置应用到集群:</p><p id="b272" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">kubectl apply -f deploy.yml</p><p id="d0bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们可以使用任何web浏览器测试我们的工作，并导航到端口32001上的一个IP地址:</p><blockquote class="nd"><p id="e300" class="ne nf it bd ng nh ni nj nk nl nm kn dk translated">“与社区分享您的经验并赚钱”</p><p id="32e4" class="ne nf it bd ng nh ni nj nk nl nm kn dk translated"><a class="ae kp" href="https://www.magalix.com/write-for-cloud-native" rel="noopener ugc nofollow" target="_blank">https://www.magalix.com/write-for-cloud-native</a></p></blockquote><figure class="no np nq nr ns ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nn"><img src="../Images/486c92e11a74f4c9bb0c782f01e21469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ekSVhNxOPQmV-vRn.png"/></div></div></figure><h1 id="5619" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="62a5" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">在本文中，我们讨论了Kubernetes边车模式。每当您想要将应用程序所需的额外功能委托给单独的容器而不是单独的pod时，您都可以使用这种模式。在整个实验中，我们探索了使用sidecar容器的一个可能的用例，即在应用服务器前面添加一个web服务器。</p><p id="084f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也许在这里使用sidecar的主要优点是，您可以很容易地用任何其他应用服务器(例如NodeJS、Go、Ruby等)替换Python Flask。)只要它监听相同的端点并遵循相同的业务逻辑。你可以在这里找到这个实验室的源代码<a class="ae kp" href="https://github.com/MagalixCorp/sidecar" rel="noopener ugc nofollow" target="_blank">https://github.com/MagalixCorp/sidecar</a></p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="e08d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">原载于2020年2月26日</em><a class="ae kp" href="https://www.magalix.com/blog/implemeting-a-reverse-proxy-server-in-kubernetes-using-the-sidecar-pattern" rel="noopener ugc nofollow" target="_blank"><em class="ko">【https://www.magalix.com】</em></a><em class="ko">。</em></p></div></div>    
</body>
</html>