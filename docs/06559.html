<html>
<head>
<title>The Mediator Pattern In Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的中介模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-mediator-pattern-in-go-344ee5c8c2f4?source=collection_archive---------9-----------------------#2020-12-06">https://levelup.gitconnected.com/the-mediator-pattern-in-go-344ee5c8c2f4?source=collection_archive---------9-----------------------#2020-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="85ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为繁忙的机场进行交通管制！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1b1d34f3899eac8612e53ba5d4709fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ya-JErXWOg4AGRG5.jpg"/></div></div></figure><p id="cafd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi la translated">当您有一组不能或不应该直接相互通信的实体时，中介模式可以提供帮助。它允许您有一个信息流的中心点，以便您的其他对象或方法可以专注于它们自己的业务逻辑。当主动使用时，中介模式可以防止紧密耦合，分离职责，并为您的代码提供一个灵活的扩展基础。</p><p id="6ec5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文将分为三个主要部分——我们将探索中介模式的真实用例，它的UML和序列图，并以它在Go中的实现结束。</p><p id="230b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们开始吧！</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="77a9" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">真实世界的例子</h1><p id="3748" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">仲裁者模式适用于无数不同的情况。随着程序的扩展，在许多不同的包和对象之间进行通信会变得很困难，尤其是直接进行通信时。为了鼓励松散耦合，中介充当中间人来处理信息流。</p><p id="08ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一些例子包括:</p><ul class=""><li id="e154" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated"><strong class="js iu">聊天室</strong> —聊天室的不同用户之间的交流通过聊天室对象本身来进行。这样可以确保信息不会发送给错误的人，避免使用不恰当的语言等等。</li><li id="9332" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><strong class="js iu">交通控制</strong> —无论是火车、汽车还是我们示例中的飞机，控制交通流动都是中介模式的一个重要应用。</li><li id="9cf9" class="mt mu it js b jt nc jx nd kb ne kf nf kj ng kn my mz na nb bi translated"><strong class="js iu">电信</strong> —手机、无线电发射塔等现代通信的几乎所有形式。由另一种资源调节。不要再直接打电话给亚历山大·格雷厄姆·贝尔！</li></ul></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="1517" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">UML和序列图</h1><p id="e658" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">中介模式有清晰直观的图表。UML图将<code class="fe nh ni nj nk b">Mediator</code>和<code class="fe nh ni nj nk b">Colleague</code>作为其实现的基本接口。回想一下，Go中没有类，所以我们没有从这两个接口继承特征，而是简单地实现它们的方法。</p><p id="2f37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，<code class="fe nh ni nj nk b">Mediator</code>接口要求方法<code class="fe nh ni nj nk b">mediate()</code>在具体对象中实现。你猜对了，这个方法将在同事们执行一些由<code class="fe nh ni nj nk b">action()</code>方法描述的动作时处理他们之间的某种形式的通信。注意<code class="fe nh ni nj nk b">Colleague</code>是如何引用<code class="fe nh ni nj nk b">Mediator</code>接口的，而具体的<code class="fe nh ni nj nk b">Mediator1</code>引用了两个具体的同事。这代表了<code class="fe nh ni nj nk b">Mediator</code>对象将如何作为同事交流的中间件。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/028db8b622a76a91431fa0916f1dc104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*rFWwT1dPJYDYqrK1.jpg"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">来自<a class="ae nq" href="https://en.wikipedia.org/wiki/Mediator_pattern" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="904c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于序列图，第一步是一些<code class="fe nh ni nj nk b">Colleague c1</code>尝试通信。这导致<code class="fe nh ni nj nk b">Mediator1</code>通过<code class="fe nh ni nj nk b">mediate(c1)</code>处理请求，其中它通过<code class="fe nh ni nj nk b">getState()</code>获得必要的信息，并通过其<code class="fe nh ni nj nk b">action()</code>方法将请求从<code class="fe nh ni nj nk b">c1</code>传递到<code class="fe nh ni nj nk b">c2</code>。</p><p id="3573" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，一旦来自<code class="fe nh ni nj nk b">c2</code>的<code class="fe nh ni nj nk b">action()</code>被执行，我们<code class="fe nh ni nj nk b">mediate()</code>返回信息，并通过链将信息发送回<code class="fe nh ni nj nk b">c1</code>。在任一方向上，调解人确保沟通是标准化的，并保持同事之间相互独立。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="21d8" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">Go中的实现</h1><p id="b978" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">为了保持示例的直观性，我们将播放一个机场的交通控制。上面说的同事会是飞机，调解人会是空管塔台。</p><p id="7889" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是中介模式的一个很好的用例，因为飞机试图通过彼此直接对话来协调它们的着陆时间是疯狂的。这将需要每个飞行员与几十个其他人通话，这将成为一个非常危险的情况。</p><p id="2dea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">取而代之的是，飞行员会向控制塔发出着陆信号，控制塔会向飞行员发回何时何地着陆的信号。</p><p id="662e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有道理？让我们构建我们的项目结构:</p><pre class="kp kq kr ks gt nr nk ns nt aw nu bi"><span id="e366" class="nv lr it nk b gy nw nx l ny nz">$ mkdir mediator-pattern-go<br/>$ cd mediator-pattern-go<br/>$ touch airplane.go airbusA380.go boeing737.go mediator.go<br/>$ touch airTower.go main.go</span></pre><h2 id="71e8" class="nv lr it bd ls oa ob dn lw oc od dp ma kb oe of me kf og oh mi kj oi oj mm ok bi translated">飞机，去吧</h2><p id="b4f1" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">对于我们的第一个包，我们将定义一个具有三个方法<code class="fe nh ni nj nk b">requestArrival()</code>、<code class="fe nh ni nj nk b">departure()</code>和<code class="fe nh ni nj nk b">permitArrival()</code>的<code class="fe nh ni nj nk b">airplane</code>接口。这代表前面提到的<code class="fe nh ni nj nk b">Colleague</code>接口。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="5440" class="nv lr it bd ls oa ob dn lw oc od dp ma kb oe of me kf og oh mi kj oi oj mm ok bi translated">空中巴士380 .走</h2><p id="0435" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">接下来，我们需要实现飞机接口。我们将通过下面的<code class="fe nh ni nj nk b">airbusA380</code>和<code class="fe nh ni nj nk b">boeing737</code>来实现。注意，Go没有类，所以为了实现接口，我们必须创建一个结构来实现<code class="fe nh ni nj nk b">airplane.go</code>中描述的每个方法。</p><p id="dcf7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们创建了扩展中介对象的struct <code class="fe nh ni nj nk b">airbusA380</code>(我们一会儿会讲到)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="cdc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还在<code class="fe nh ni nj nk b">airplane</code>接口中实现了这三个方法。请注意，这个类中没有任何真正的逻辑，我们只是简单地询问<code class="fe nh ni nj nk b">mediator</code>我们是否可以着陆(第12行)，或者通知<code class="fe nh ni nj nk b">departure()</code>机场的跑道是空闲的(第21行)。除此之外，这架飞机不知道其他飞机在做什么，这是中介模式的主要目标。</p><h2 id="9d19" class="nv lr it bd ls oa ob dn lw oc od dp ma kb oe of me kf og oh mi kj oi oj mm ok bi translated">波音737 .走</h2><p id="435b" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">这与之前的飞机几乎相同。你可以扩展这些平面的细节，但为了举例，我们将保持简单。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="3065" class="nv lr it bd ls oa ob dn lw oc od dp ma kb oe of me kf og oh mi kj oi oj mm ok bi translated">调解人，去吧</h2><p id="650d" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">这个接口将作为中介的基本结构。飞机会询问他们是否<code class="fe nh ni nj nk b">canLand()</code>，一旦一架飞机离开跑道，他们会呼叫<code class="fe nh ni nj nk b">notifyFree()</code>，以便发出信号，告知下一架飞机可以降落了。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="f8c1" class="nv lr it bd ls oa ob dn lw oc od dp ma kb oe of me kf og oh mi kj oi oj mm ok bi translated">airTower.go</h2><p id="b78b" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">这里我们将实现我们的<code class="fe nh ni nj nk b">mediator</code>接口。<code class="fe nh ni nj nk b">airTower</code>将有一个布尔值<code class="fe nh ni nj nk b">isRunwayFree</code>以及一个请求到达的飞机队列。</p><p id="856b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还有Go形式的构造函数，其中我们简单地用一个函数返回一个新的<code class="fe nh ni nj nk b">airTower</code>实例，默认值<code class="fe nh ni nj nk b">isRunwayFree</code>设置为<code class="fe nh ni nj nk b">true</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="7397" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还实现了<code class="fe nh ni nj nk b">canLand</code>方法，方法是传递<code class="fe nh ni nj nk b">airTower</code>结构，然后将<code class="fe nh ni nj nk b">airplane</code>作为函数参数。该方法将根据跑道是否空闲返回true或false。如果跑道不空闲，我们将追加到机场塔台的飞机队列中，并返回false。</p><p id="d993" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在飞机起飞后会直接调用<code class="fe nh ni nj nk b">notifyFree()</code>方法，从而产生一条空闲的跑道。所以如果跑道不空闲，我们就把它设为空闲。然后，我们在第27行检查我们的队列中是否还有飞机。如果有，那么我们得到队列中的第一架飞机，然后缩短等待队列。队列中的第一架飞机最终被允许到达30号线的跑道上。</p><h2 id="c81f" class="nv lr it bd ls oa ob dn lw oc od dp ma kb oe of me kf og oh mi kj oi oj mm ok bi translated">main.go</h2><p id="18fb" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">我们的客户端代码将简单地初始化我们的<code class="fe nh ni nj nk b">airTower</code>和两个平面。然后，我们从每架飞机上调用<code class="fe nh ni nj nk b">requestArrival()</code>，导致第一架<code class="fe nh ni nj nk b">boeing737</code>立即开始着陆，而<code class="fe nh ni nj nk b">airbus380</code>则存储在航空塔台的飞机队列中。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="48bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用<code class="fe nh ni nj nk b">go run *.go</code>运行这个程序，我们将得到以下输出:</p><pre class="kp kq kr ks gt nr nk ns nt aw nu bi"><span id="f0a2" class="nv lr it nk b gy nw nx l ny nz">Boeing737: Landing<br/>AirbusA380: Waiting<br/>Boeing737: Leaving<br/>AirbusA380: Arrival Permitted. Landing<br/>AirbusA380: Leaving</span></pre></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><p id="54dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章是基于<a class="ae nq" href="https://golangbyexample.com/mediator-design-pattern-golang/" rel="noopener ugc nofollow" target="_blank"> Golang by Example </a>的，其中他们还通过在试图访问受保护的资源时使用互斥锁来实现线程安全。本文的主要目的是给出中介模式及其最佳实践的完整总结。</p><p id="c13a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这篇文章或者想看更多的例子，我鼓励你在下面留下评论。感谢阅读！</p></div></div>    
</body>
</html>