<html>
<head>
<title>Helm 101 for Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向开发者的101号头盔</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/helm-101-for-developers-1c28e734937e?source=collection_archive---------2-----------------------#2021-07-07">https://levelup.gitconnected.com/helm-101-for-developers-1c28e734937e?source=collection_archive---------2-----------------------#2021-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e764" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">非Kubernetes专家如何使用、创建和发布舵图</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/dc16b95d6733c58aeab25f406e7ccc21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8etX0Rkm7hpw1VgC1PA-wg.png"/></div></div></figure><p id="a238" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着Kubernetes继续蚕食容器编排领域，开发人员不可避免地被迫与Kubernetes进行本地开发或代码交付。即使在拥有专门的平台团队或DevOps工程师的组织中，开发人员仍然需要在一定程度上与Docker和Kubernetes合作，以帮助将他们的功能和应用程序推广到生产中。对于大多数组织来说，这种互动是通过<a class="ae la" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> <em class="lb">掌舵</em> </a>促成的。</p><p id="d666" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Helm是Kubernetes应用程序的包管理器，提供了将Kubernetes清单模板化和分组为版本化包的机制。自从加入<a class="ae la" href="https://www.cncf.io/" rel="noopener ugc nofollow" target="_blank">云本地计算基金会</a> (CNCF)后，Helm成为首选的软件包经理，超过60%的CNCF调查受访者更喜欢Helm而不是替代解决方案。作为其受欢迎程度的证明，Helm拥有大量开源图表，可以在一个命令中轻松部署有用的应用程序，如<a class="ae la" href="https://github.com/bitnami/charts/tree/master/bitnami/postgresql" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>、<a class="ae la" href="https://github.com/bitnami/charts/tree/master/bitnami/redis" rel="noopener ugc nofollow" target="_blank"> Redis </a>、<a class="ae la" href="https://github.com/kubernetes/ingress-nginx" rel="noopener ugc nofollow" target="_blank"> Nginx </a>和<a class="ae la" href="https://github.com/prometheus-community/helm-charts" rel="noopener ugc nofollow" target="_blank"> Prometheus </a>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lc"><img src="../Images/6307610d4ba842e03fbd7ff606b49105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZIzi3m10W834dLEQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片来源:<a class="ae la" href="https://www.cncf.io/wp-content/uploads/2020/11/CNCF_Survey_Report_2020.pdf" rel="noopener ugc nofollow" target="_blank">2020年CNCF调查</a></figcaption></figure><p id="45c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，对于在DevOps或Kubernetes方面经验不多的开发人员来说，我们如何适应使用Helm呢？在本帖中，我们将分解理解舵结构的关键概念和最佳实践，以轻松驾驭舵世界。</p><h1 id="8362" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">关键概念</h1><p id="5f7b" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">Helm将应用程序打包成<strong class="js iu">图表</strong>，这是一个YAML和助手模板的集合，按照以下方式组织:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="5f4e" class="mp li it ml b gy mq mr l ms mt">my-chart/<br/>├── .helmignore      # Contains patterns to ignore <br/>├── Chart.yaml       # Information about your chart<br/>├── values.yaml      # The default values for your templates<br/>├── charts/          # Charts that this chart depends on<br/>└── templates/       # The template files<br/>    └── tests/       # The test files<br/>    ...</span></pre><p id="8e1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来分解每个文件:</p><ul class=""><li id="6ca3" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated"><strong class="js iu">。helmignore </strong>:类似<code class="fe nd ne nf ml b">.gitignore</code>，包含打包舵图时要忽略的模式(如<code class="fe nd ne nf ml b">.vscode/</code>、<code class="fe nd ne nf ml b">.git</code>等)。</li><li id="0065" class="mu mv it js b jt ng jx nh kb ni kf nj kj nk kn mz na nb nc bi translated"><strong class="js iu"> Chart.yaml </strong>:与Node中的<code class="fe nd ne nf ml b">package.json</code>类似，包含关于图表的元数据(如版本、作者等)，如果该图表打包了多个图表(如部署我的应用程序+ MySQL)，还包含依赖关系。</li><li id="f80b" class="mu mv it js b jt ng jx nh kb ni kf nj kj nk kn mz na nb nc bi translated"><strong class="js iu"> values.yaml </strong>:图表所有模板化部分的默认值。这些值可以通过<code class="fe nd ne nf ml b">--values</code>或<code class="fe nd ne nf ml b">--set</code>标志覆盖。</li><li id="f073" class="mu mv it js b jt ng jx nh kb ni kf nj kj nk kn mz na nb nc bi translated"><strong class="js iu">图表:</strong>保存相关图表，如果在<code class="fe nd ne nf ml b">Chart.yaml</code>中指定</li><li id="809a" class="mu mv it js b jt ng jx nh kb ni kf nj kj nk kn mz na nb nc bi translated"><strong class="js iu">模板</strong>:包含所有定义应用程序行为的Kubernetes清单(如部署、服务、自动缩放、配置映射等)以及其他模板助手、注释和测试文件。</li></ul><p id="aa37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在很大程度上，要使用公共图表，开发人员需要熟悉<code class="fe nd ne nf ml b">values.yaml</code>上的YAML语法。常见任务可能包括更新Docker图像标签、设置新的环境变量或添加图表预期的秘密值:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="3832" class="mp li it ml b gy mq mr l ms mt">$ helm upgrade --install demo-app --set image.tag=v1.2.0 </span></pre><p id="88cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个<code class="fe nd ne nf ml b">install</code>或<code class="fe nd ne nf ml b">upgrade</code>命令触发一个舵<strong class="js iu">发布，</strong>是一个版本化、模板化图表的部署。由于每个图表都是独立的，因此在一个名称空间或一个集群中可能会有同一个图表的多个版本。</p><p id="1d9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，舵图被打包成tar文件并存储在<strong class="js iu">库</strong>中，类似于Docker注册表。一些库管理器如Artifactory <strong class="js iu"> </strong>可以自动索引掌舵图，或者开发者可以使用<a class="ae la" href="https://chartmuseum.com/" rel="noopener ugc nofollow" target="_blank"> ChartMuseum </a>在S3、谷歌云存储或Azure Blob存储上提供公共或私人掌舵图。</p><h1 id="bdc4" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">赫尔姆最佳实践</h1><p id="3b10" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">现在我们对什么是舵有了一个基本的了解，我们将回顾一些最佳实践和有用的提示，开始创建和部署我们的第一个舵图。</p><h2 id="e1f6" class="mp li it bd lj nl nm dn ln nn no dp lr kb np nq lv kf nr ns lz kj nt nu md nv bi translated">使用头盔创建</h2><p id="a7d3" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">通常，当我和一个不熟悉Kubernetes的开发人员一起工作时，他们的第一反应是从Kubernetes文档中复制一些清单，然后从头开始手工制作他们的头盔图。虽然这是快速部署单个Kubernetes清单(如<code class="fe nd ne nf ml b">pod.yaml</code>或<code class="fe nd ne nf ml b">deployment.yaml</code>)的好方法，但这种方法容易出错且很麻烦。</p><p id="4f03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相反，利用内置的Helm命令来引导您的图表:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="ed45" class="mp li it ml b gy mq mr l ms mt">$ helm create &lt;my-chart&gt;</span></pre><p id="edd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将提供所有常见的Kubernetes清单(<code class="fe nd ne nf ml b">deployment.yaml</code>、<code class="fe nd ne nf ml b">hpa.yaml</code>、<code class="fe nd ne nf ml b">ingress.yaml</code>、<code class="fe nd ne nf ml b">service.yaml</code>和<code class="fe nd ne nf ml b">serviceaccount.yaml</code>)以及助手模板，以规避资源命名约束和标签/注释。默认情况下，这将为<code class="fe nd ne nf ml b">nginx</code>提供可伸缩的部署。只需编辑<code class="fe nd ne nf ml b">values.yaml</code>文件来部署您的docker映像。</p><h2 id="32f9" class="mp li it bd lj nl nm dn ln nn no dp lr kb np nq lv kf nr ns lz kj nt nu md nv bi translated">线头，模板，模拟运行</h2><p id="cf12" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">在幕后，Helm使用go模板语言来生成Kubernetes清单。习惯这种语法需要一段时间，但在大多数情况下，Helm问题是由缩进、空值或错误的YAML类型(例如，maps vs array)引起的。为了更早地捕捉这些错误，Helm提供了一些有用的命令:</p><ol class=""><li id="3ef5" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn nw na nb nc bi translated"><code class="fe nd ne nf ml b">helm lint &lt;my-chart&gt;</code>:检查图表中可能存在的问题，包括YAML问题(如缩进)或舵模板问题(如缺少图表版本)。您可以运行这个带有<code class="fe nd ne nf ml b">--debug</code>标志的命令来获得更多信息。不幸的是，stacktrace中的行号经常会产生误导，因此通常需要进一步的调查。</li><li id="a764" class="mu mv it js b jt ng jx nh kb ni kf nj kj nk kn nw na nb nc bi translated"><code class="fe nd ne nf ml b">helm template &lt;my-chart&gt;</code>:使用<code class="fe nd ne nf ml b">values.yaml</code>在本地渲染模板。要覆盖任何值，使用<code class="fe nd ne nf ml b">--set</code>标志或通过<code class="fe nd ne nf ml b">--values</code>或<code class="fe nd ne nf ml b">-f</code>标志提供另一个包含自定义值的YAML文件。要关注单个模板(例如，只想呈现<code class="fe nd ne nf ml b">deployment.yaml</code>，使用<code class="fe nd ne nf ml b">-s</code>标志，如果图表随着大量模板而变大，这将很有帮助:<code class="fe nd ne nf ml b">helm template my-chart -s templates/deployment.yaml</code></li><li id="b0b4" class="mu mv it js b jt ng jx nh kb ni kf nj kj nk kn nw na nb nc bi translated"><code class="fe nd ne nf ml b">--dry-run</code>:由于<code class="fe nd ne nf ml b">lint</code>和<code class="fe nd ne nf ml b">template</code>命令只捕捉模板问题，一些错误没有被捕捉到，直到Kubernetes API被调用。在执行<code class="fe nd ne nf ml b">upgrade</code>或<code class="fe nd ne nf ml b">install</code>命令之前，使用<code class="fe nd ne nf ml b">--dry-run</code>标志运行以检查其他错误(例如，弃用的Kubernetes API版本)</li></ol><p id="de76" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有关go模板和舵功能的更多信息，请查看“海图模板指南”下的舵文档:</p><div class="nx ny gp gr nz oa"><a href="https://helm.sh/docs/chart_template_guide/functions_and_pipelines/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">模板函数和管道</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">到目前为止，我们已经看到了如何将信息放置到模板中。但是这些信息被放入模板中…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">helm.sh</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ky oa"/></div></div></a></div><h2 id="486e" class="mp li it bd lj nl nm dn ln nn no dp lr kb np nq lv kf nr ns lz kj nt nu md nv bi translated">浏览公共图表</h2><p id="5320" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">也许Helm最大的卖点是它庞大的社区。当你陷入困境时，花些时间去探索一些公共图表，以获得灵感或常见任务的简洁解决方案(例如，如何处理AWS SSL入口重定向、定义存储类、挂钩)。</p><p id="199d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要搜索图表，你可以直接谷歌或者使用内置的<code class="fe nd ne nf ml b">helm search</code>命令:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="ccb5" class="mp li it ml b gy mq mr l ms mt">$ helm search hub redis</span></pre><p id="da2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要从存储库中下载图表，首先将其添加到本地设置中:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="5958" class="mp li it ml b gy mq mr l ms mt">$ helm repo add bitnami https://charts.bitnami.com/bitnami</span></pre><p id="0063" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于舵图只是简单的tar文件，您也可以在本地下载并检查它:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="5ebc" class="mp li it ml b gy mq mr l ms mt">$ helm pull bitnami/nginx-ingress-controller --version 5.3.19</span></pre><p id="1b46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想检查已经部署的舵图，您也可以使用:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="5d93" class="mp li it ml b gy mq mr l ms mt">$ helm get all RELEASE_NAME</span></pre><p id="a2d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将打印出与部署打包在一起的所有Kubernetes清单、注释和用户提供的值。</p><h2 id="078b" class="mp li it bd lj nl nm dn ln nn no dp lr kb np nq lv kf nr ns lz kj nt nu md nv bi translated">带有子图表的包装</h2><p id="b441" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">虽然每个舵图表都是独立的(即可以单独部署)，但有时将图表组合在一个部署中是有意义的。例如，Django应用程序可能与PostgreSQL和Redis打包在一起。要定义这些依赖关系，请在<code class="fe nd ne nf ml b">Chart.yaml</code>中列出它们:</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="f9eb" class="mp li it ml b gy mq mr l ms mt">apiVersion: v2<br/>name: django-app<br/>description: A Helm chart for my django-app</span><span id="281a" class="mp li it ml b gy op mr l ms mt">...</span><span id="8b44" class="mp li it ml b gy op mr l ms mt">dependencies:<br/> - name: postgresql<br/>   version: "10.3.18"<br/>   repository: "<a class="ae la" href="http://twitter.com/bitnami" rel="noopener ugc nofollow" target="_blank">@bitnami</a>"<br/> - name: redis<br/>   version: "14.6.5"<br/>   repository: "<a class="ae la" href="http://twitter.com/bitnami" rel="noopener ugc nofollow" target="_blank">@bitnami</a>"<br/>   condition: global.redis.enabled</span></pre><p id="a1e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过<code class="fe nd ne nf ml b">values.yaml</code>可以有条件地禁用/启用相关图表。在上面的例子中，可以通过将<code class="fe nd ne nf ml b">global.redis.enabled</code>设置为<code class="fe nd ne nf ml b">false</code>来禁用Redis。定义完依赖项后，要下载这些图表，运行<code class="fe nd ne nf ml b">helm dep up &lt;my-chart&gt;</code>来生成<code class="fe nd ne nf ml b">Chart.lock</code>文件以及tar文件。或者，我们可以直接将图表放在<code class="fe nd ne nf ml b">charts/</code>目录下，省略<code class="fe nd ne nf ml b">Chart.yaml</code>中的<code class="fe nd ne nf ml b">version</code>和<code class="fe nd ne nf ml b">repository</code>字段，使用本地图表。</p><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="a49b" class="mp li it ml b gy mq mr l ms mt">django-app/<br/>├── Chart.yaml    <br/>├── values.yaml <br/>├── templates/<br/>└── charts/<br/>    └── postgres/ <br/>    └── redis/</span></pre><h2 id="9d0a" class="mp li it bd lj nl nm dn ln nn no dp lr kb np nq lv kf nr ns lz kj nt nu md nv bi translated">了解舵的极限</h2><p id="0298" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">尽管Helm很有用，但它是一个<strong class="js iu">包管理器</strong>，而不是一个完整的<strong class="js iu">持续部署(CD) </strong>工具。换句话说，对于Kubernetes应用程序的CI/CD策略，您不应该只依赖Helm，而是应该将其与其他工具(例如ArgoCD、Spinnaker等)集成。也就是说，有一些方法可以最大限度地发挥Helm的优势:</p><ul class=""><li id="4ec5" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">通过分别使用<code class="fe nd ne nf ml b">helm upgrade --install</code>命令而不是<code class="fe nd ne nf ml b">install</code>和<code class="fe nd ne nf ml b">upgrade</code>命令来保持部署幂等。</li><li id="71cc" class="mu mv it js b jt ng jx nh kb ni kf nj kj nk kn mz na nb nc bi translated">如果部署失败，使用<code class="fe nd ne nf ml b">--atomic</code>标志自动回滚。</li><li id="5460" class="mu mv it js b jt ng jx nh kb ni kf nj kj nk kn mz na nb nc bi translated"><a class="ae la" href="https://helm.sh/docs/howto/charts_tips_and_tricks/#automatically-roll-deployments" rel="noopener ugc nofollow" target="_blank">当配置图或密码改变时自动滚动部署</a>:</li></ul><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="09c6" class="mp li it ml b gy mq mr l ms mt"><strong class="ml iu">kind</strong>: Deployment<br/><strong class="ml iu">spec</strong>:<br/>  <strong class="ml iu">template</strong>:<br/>    <strong class="ml iu">metadata</strong>:<br/>      <strong class="ml iu">annotations</strong>:<br/>        <strong class="ml iu">checksum/config</strong>: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}<br/>[...]</span></pre><ul class=""><li id="7553" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">使用Helm注释保留资源(对不删除机密或名称空间最有用):</li></ul><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="7cce" class="mp li it ml b gy mq mr l ms mt"><strong class="ml iu">kind:</strong> Secret<br/><strong class="ml iu">metadata:</strong><br/>  <strong class="ml iu">annotations:</strong><br/>    <strong class="ml iu">"helm.sh/resource-policy"</strong>: keep<br/>[...]</span></pre><ul class=""><li id="9311" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">使用<a class="ae la" href="https://helm.sh/docs/topics/charts_hooks/#helm" rel="noopener ugc nofollow" target="_blank">头盔挂钩</a>在安装、升级、回滚或删除之前或之后触发作业</li></ul><pre class="kp kq kr ks gt mk ml mm mn aw mo bi"><span id="cf8f" class="mp li it ml b gy mq mr l ms mt"><strong class="ml iu">apiVersion</strong>: batch/v1<br/><strong class="ml iu">kind</strong>: Job<br/><strong class="ml iu">metadata</strong>:<br/>  <strong class="ml iu">annotations</strong>:<br/>    <em class="lb"># This is what defines this resource as a hook. Without this line, the</em><br/>    <em class="lb"># job is considered part of the release.</em><br/>    <strong class="ml iu">"helm.sh/hook": </strong>post-install<br/>    <strong class="ml iu">"helm.sh/hook-weight": </strong>"-5"<br/>    <strong class="ml iu">"helm.sh/hook-delete-policy": </strong>hook-succeeded</span></pre><ul class=""><li id="9cb8" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated">由于Helm使用明文YAML，通常机密在外部处理(例如Kubernetes机密、Vault、external-secrets、AWS机密管理器)。但是组织可以将加密的秘密签入版本控制，查看<a class="ae la" href="https://github.com/jkroepke/helm-secrets" rel="noopener ugc nofollow" target="_blank">头盔秘密</a>(使用SOPS或KMS)。</li></ul><h2 id="b052" class="mp li it bd lj nl nm dn ln nn no dp lr kb np nq lv kf nr ns lz kj nt nu md nv bi translated">生成文档</h2><p id="2b7b" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">和任何软件一样，文档是可用性的关键。在舵图中，有三个选项可以添加此信息:</p><ul class=""><li id="49fc" class="mu mv it js b jt ju jx jy kb mw kf mx kj my kn mz na nb nc bi translated"><strong class="js iu">行内注释</strong>:因为所有的清单和值文件都是用YAML语言编写的，所以可以用<code class="fe nd ne nf ml b">#</code>添加行内注释</li><li id="6533" class="mu mv it js b jt ng jx nh kb ni kf nj kj nk kn mz na nb nc bi translated"><strong class="js iu"> NOTES.txt </strong>:这是一个特殊的文件，一旦图表被部署，就会在控制台中打印出来。它通常包含与部署交互的信息，如服务/入口信息或如何提取密码(如果密码是自动生成的)。内容也可以用Helm函数模板化。</li><li id="26a0" class="mu mv it js b jt ng jx nh kb ni kf nj kj nk kn mz na nb nc bi translated"><strong class="js iu">自述:</strong>大多数公共舵图表都包含一个描述<code class="fe nd ne nf ml b">values.yaml</code>中默认值的部分。它通常列出一个包含变量的键、类型、默认值和描述的表。要在markdown中轻松生成此表，您可以使用名为<a class="ae la" href="https://github.com/norwoodj/helm-docs" rel="noopener ugc nofollow" target="_blank"> helm-docs </a>的工具。它检查来自<code class="fe nd ne nf ml b">values.yaml</code>的行内注释并输出一个表格。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/0380656c0fd749f6b2955c401738c114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rtsvCgX7abqfHquwwSe5xw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">示例值. yaml</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi or"><img src="../Images/532bfb795a1602691171407ae5e7afb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LPU4DQsRiKbPohOihY6mow.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">helm-docs的输出示例</figcaption></figure><h2 id="473c" class="mp li it bd lj nl nm dn ln nn no dp lr kb np nq lv kf nr ns lz kj nt nu md nv bi translated">阅读文件</h2><p id="fe56" class="pw-post-body-paragraph jq jr it js b jt mf jv jw jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn im bi translated">最后，阅读Helm的<a class="ae la" href="https://helm.sh/docs/chart_best_practices/conventions/" rel="noopener ugc nofollow" target="_blank">官方文档，了解更多最佳实践和常见问题解答</a>，为Kubernetes应用创建和管理生产就绪的Helm图表。Kubernetes是一个复杂的工具，具有陡峭的学习曲线，但Helm可以承担一些操作负担，使过程变得稍微容易一些，即使对于那些害怕任何操作工作的开发人员来说。</p></div></div>    
</body>
</html>