<html>
<head>
<title>Sharing context between tests with Cypress in 3 steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Cypress在3个步骤中共享测试之间的上下文</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/sharing-context-between-tests-with-cypress-in-3-steps-15f1a8c3dc4b?source=collection_archive---------2-----------------------#2021-01-29">https://levelup.gitconnected.com/sharing-context-between-tests-with-cypress-in-3-steps-15f1a8c3dc4b?source=collection_archive---------2-----------------------#2021-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fd2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我想写一篇简短的帖子，讲述如何使用<em class="kl"> Cypress — </em>在三个步骤中<strong class="jp ir">共享测试间的上下文🤩</strong>。如果你从未听说过这个工具，根据<a class="ae km" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank">官方网站</a>:<strong class="jp ir"><em class="kl">Cypress是为现代web </em> </strong>打造的下一代前端测试工具。它在前端被大量使用，因为它是一个非常清晰和简单的工具。它使用了<em class="kl">柴</em>断言库以及<em class="kl"> Sinon </em>和<em class="kl"> jQuery </em>扩展，但锦上添花的是<em class="kl"> Cypress </em>使我们能够编写端到端(E2E)、集成和单元测试。🤯</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/cbe12f265154709c393d57874e4aee71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*gtewiJKsLuYwQLfpoMQo-Q.png"/></div></figure><p id="c7cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也许你想知道"<em class="kl">嘿Jenni，我们不能在测试之间共享数据，它们必须是独立的… </em>🤭".是的，这是非常正确的，但有时我们会在同一个文件中多次使用一些静态数据。<em class="kl">规格)。</em> 在<strong class="jp ir"> </strong>这篇文章中，我们将使用这个场景:<strong class="jp ir">分享一些个人网站的信息(名称和链接)，并且能够在我们想要的任何时候使用它们</strong>。</p><h1 id="83a1" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">第一步——在钩住☝️之前</h1><p id="9eef" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">首先，所有的测试组都被一个<code class="fe ly lz ma mb b">describe</code> <strong class="jp ir"> </strong>块包装起来，在其中，我们使用<code class="fe ly lz ma mb b">it</code> <em class="kl">块</em>来声明每个测试。还有<strong class="jp ir"> <em class="kl">挂钩</em> </strong>我们可以用在测试上:<code class="fe ly lz ma mb b">before()</code>、<code class="fe ly lz ma mb b">beforeEach()</code>、<code class="fe ly lz ma mb b">after()</code>和<code class="fe ly lz ma mb b">afterEach()</code>。在我们的例子中，我们必须使用<code class="fe ly lz ma mb b">before</code> <em class="kl"> </em>钩子<strong class="jp ir"> <em class="kl"> </em> </strong>，因为它使我们能够在所有测试之前运行代码块，并确保数据在全局上下文中是可访问的。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/1d1ba116352f3363fb4b19acdd9eaf65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWfzqmIsMpL8jCCyis47VQ.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">要测试的基本结构。</figcaption></figure><h1 id="b613" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">步骤2-给🗣加别名</h1><p id="48d8" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">现在我们有了对象<code class="fe ly lz ma mb b">pesonalWebsites</code>，它包含网站名称作为键，网站链接作为值。为了使数据在<em class="kl"> Cypress </em>中可访问，我们需要<strong class="jp ir">使用</strong> <code class="fe ly lz ma mb b"><strong class="jp ir">cy.as()</strong></code>将其分配给一个别名。</p><blockquote class="ml mm mn"><p id="dd21" class="jn jo kl jp b jq jr js jt ju jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj kk ij bi translated">在幕后，别名基本对象和原语利用了Mocha的共享上下文对象:也就是说，别名作为<code class="fe ly lz ma mb b">this</code> <strong class="jp ir">可用。<br/> </strong>此外，这些别名和属性会在每次测试后自动清除。</p></blockquote><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mr"><img src="../Images/9b7958ae5e8d15d4a9248d0c26f682d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lJYOxNXtpBydg2Q8XOB8XA.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">假冒网站的数据。</figcaption></figure><p id="98c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，在<code class="fe ly lz ma mb b">cy.wap(websiteLink).as(websiteName)</code> <strong class="jp ir"> <em class="kl"> </em> </strong>行中，我们创建了一个别名，将网站名称作为键，将网站链接作为值。命令<code class="fe ly lz ma mb b">cy.wrap()</code> <em class="kl"> </em>只是产生一些… <strong class="jp ir"> <em class="kl"> "cy.as()" </em>不在链中就不起作用</strong>。</p><p id="376f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，当我们运行测试时，别名将如下图所示:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ms"><img src="../Images/2e47b0c5ea46520093dad0245f8df48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WpGP2qUgZOkd7NAP40aeTg.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">Cypress run上的别名。</figcaption></figure><h1 id="1504" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">步骤3—传统函数表达式🌝</h1><p id="609e" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">别名可以通过使用<code class="fe ly lz ma mb b">@aliasName</code>来访问，但是在<strong class="jp ir">共享上下文场景中，我们只能使用关键字</strong> <code class="fe ly lz ma mb b"><strong class="jp ir">this</strong></code> <em class="kl">来访问它。</em>你一定知道<strong class="jp ir">箭头函数并不绑定自己的</strong> <code class="fe ly lz ma mb b"><strong class="jp ir">this</strong></code> <strong class="jp ir">，所以我们需要在我们的测试块里面使用传统的函数表达式</strong>。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mt"><img src="../Images/4f72b1fd605cead8e281f818b2d90382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WOS6vynivaPCMFMj7CXoPQ.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">使用这个和传统的函数表达式访问全局上下文。</figcaption></figure><blockquote class="mu"><p id="88ec" class="mv mw iq bd mx my mz na nb nc nd kk dk translated">你有它！长话短说:我们需要在before hook上别名化我们想要共享的数据，将arrow函数替换为传统的函数表达式，并使用<code class="fe ly lz ma mb b">this</code>这个可爱的小东西访问全局上下文！</p></blockquote><p id="a995" class="pw-post-body-paragraph jn jo iq jp b jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">我希望你喜欢这篇文章！所以，如果对你有所帮助，请鼓掌50次左右；)再见，注意安全！🤟👩🏻‍💻</p></div></div>    
</body>
</html>