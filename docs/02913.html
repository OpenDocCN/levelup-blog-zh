<html>
<head>
<title>There is no such thing as the Spread Operator in JavaScript!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript里没有Spread运算符这种东西！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/there-is-no-such-thing-as-the-spread-operator-in-javascript-9c4e4dbd8a02?source=collection_archive---------4-----------------------#2020-04-10">https://levelup.gitconnected.com/there-is-no-such-thing-as-the-spread-operator-in-javascript-9c4e4dbd8a02?source=collection_archive---------4-----------------------#2020-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1a297fde18fbbce558c32be77001bd58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-pbsgWyWqKlJrzGNwweUQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">放松，深呼吸……——瓦莱丽娅·布加约娃在Unsplash上的照片</figcaption></figure><p id="f4e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">听说过<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">传播语法</a>吗？在ES2015中推出，由于其简单的语义和无处不在的用例，我们很喜欢它。那么<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Spread_operator" rel="noopener ugc nofollow" target="_blank">传播算子</a>呢？没错，就是Spread语法用的<a class="ae kc" href="https://guide.freecodecamp.org/javascript/es6/spread-operator/" rel="noopener ugc nofollow" target="_blank">三个点</a> ( <code class="fe lb lc ld le b">...</code>)！</p><p id="8643" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…通过说这样的话，我们开始挖掘一只虫子生活的可怕世界<a class="ae kc" href="https://www.youtube.com/watch?v=cXWRAb84TTE" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="e2aa" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Spread语法快速回顾</h1><p id="1557" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以利用Spread语法的一个简单用例是当我们想要连接多个数组时。查看以下代码片段:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="fce9" class="mq lg iq le b gy mr ms l mt mu">const clientErrors = ['err1', 'err2', 'err3'];<br/>const serverErrors = ['err4', 'err5'];</span><span id="52c2" class="mq lg iq le b gy mv ms l mt mu"><br/>function numberOfErrors(clientErrors, serverErrors) {<br/>  // Assuming that both inputs are arrays to prevent TypeErrors.<br/>  return [...clientErrors, ...serverErrors].length;<br/>}</span><span id="5606" class="mq lg iq le b gy mv ms l mt mu">numberOfErrors(clientErrors, serverErrors); // =&gt; 5</span></pre><p id="008f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数<code class="fe lb lc ld le b">numberOfErrors</code>连接两个数组并返回新数组的长度。但是如果参数是假值，比如<code class="fe lb lc ld le b">null</code>或<code class="fe lb lc ld le b">undefined</code>，那该怎么办呢？</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0d5b" class="mq lg iq le b gy mr ms l mt mu">const clientErrors = ['err1', 'err2', 'err3'];<br/>const serverErrors = null;</span><span id="18ff" class="mq lg iq le b gy mv ms l mt mu">function numberOfErrors(clientErrors, serverErrors) {<br/>  return [...clientErrors, ...serverErrors].length;<br/>}</span><span id="8ded" class="mq lg iq le b gy mv ms l mt mu">numberOfErrors(clientErrors, serverErrors);</span><span id="a2d0" class="mq lg iq le b gy mv ms l mt mu">// =&gt; TypeError</span></pre><p id="64f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们知道，如果我们试图传播一个<code class="fe lb lc ld le b">null</code>或<code class="fe lb lc ld le b">undefined</code>变量，这将使解释器变得唠叨。在现实世界的场景中，我们希望保护自己免受这种边缘情况的影响。稍加修改，我们最终会写出这样的代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="22c8" class="mq lg iq le b gy mr ms l mt mu">const clientErrors = ['err1', 'err2', 'err3'];<br/>const serverErrors = null</span><span id="f501" class="mq lg iq le b gy mv ms l mt mu">function numberOfErrors(clientErrors, serverErrors) {<br/>  return [...(clientErrors || []), ...(serverErrors || [])].length;<br/>}</span><span id="b837" class="mq lg iq le b gy mv ms l mt mu">numberOfErrors(clientErrors, serverErrors) // =&gt; 3</span></pre><p id="23c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe lb lc ld le b">serverErrors</code>是falsy，所以逻辑OR操作符将返回一个空数组，然后该数组将被优雅地展开。调用<code class="fe lb lc ld le b">numberOfErrors</code>的最终结果等于<code class="fe lb lc ld le b">clientErrors</code>数组的长度，也就是<code class="fe lb lc ld le b">3</code>。</p><h1 id="7de1" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">扩展运算符优先级</h1><p id="5bc0" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">现在我们已经讨论了一个基本的例子，让我们来看一些更有趣的东西。针对以下每个问题，标记正确答案。解决方案将在之后立即呈现。<em class="mw"> ( </em> <strong class="kf ir"> <em class="mw">提示</em> </strong> <em class="mw">:可以自己运行代码片段看看结果！)</em></p><h2 id="eb6a" class="mq lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated">问题A</h2><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2c1a" class="mq lg iq le b gy mr ms l mt mu">const a1 = null;<br/>const b1 = [1, 2];</span><span id="0485" class="mq lg iq le b gy mv ms l mt mu">const c1 = [...a1 || b1];</span></pre><p id="58a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">c1</code>的值是多少？</p><ol class=""><li id="19bc" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated"><code class="fe lb lc ld le b">c1</code>没有价值。表情<code class="fe lb lc ld le b">...a1</code>会丢<code class="fe lb lc ld le b">TypeError</code>，因为<code class="fe lb lc ld le b">a1</code>是<code class="fe lb lc ld le b">null</code>。</li><li id="50fc" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><code class="fe lb lc ld le b">c1</code>就是<code class="fe lb lc ld le b">[1, 2]</code>。表达式<code class="fe lb lc ld le b">a1 || b1</code>将首先被求值，然后返回<code class="fe lb lc ld le b">[1, 2]</code>，它将被展开。</li></ol><h2 id="247e" class="mq lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated">问题B</h2><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0351" class="mq lg iq le b gy mr ms l mt mu">const a2 = [1, 2];<br/>const b2 = null;</span><span id="da7e" class="mq lg iq le b gy mv ms l mt mu">const c2 = [...a2 || b2];</span></pre><ol class=""><li id="a4bd" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated"><code class="fe lb lc ld le b">c2</code>就是<code class="fe lb lc ld le b">[1, 2]</code>。先对表达式<code class="fe lb lc ld le b">a2 || b2</code>求值，会展开。</li><li id="904d" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><code class="fe lb lc ld le b">c2</code>就是<code class="fe lb lc ld le b">[1, 2]</code>。先对表达式<code class="fe lb lc ld le b">…a2</code>求值，会展开。</li></ol><h2 id="a29a" class="mq lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated">问题C</h2><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6303" class="mq lg iq le b gy mr ms l mt mu">const a3 = null;<br/>const b3 = null;</span><span id="48db" class="mq lg iq le b gy mv ms l mt mu">const c3 = [...a || b];</span></pre><ol class=""><li id="8380" class="ni nj iq kf b kg kh kk kl ko nk ks nl kw nm la nn no np nq bi translated"><code class="fe lb lc ld le b">c3</code>没有价值。表达式<code class="fe lb lc ld le b">...a3</code>会抛出<code class="fe lb lc ld le b">TypeError</code>，因为<code class="fe lb lc ld le b">a3</code>就是<code class="fe lb lc ld le b">null</code>。</li><li id="295b" class="ni nj iq kf b kg nr kk ns ko nt ks nu kw nv la nn no np nq bi translated"><code class="fe lb lc ld le b">c3</code>没有价值。表达式<code class="fe lb lc ld le b">a3 || b3</code>将首先求值，返回<code class="fe lb lc ld le b">null</code>，然后展开语法将抛出<code class="fe lb lc ld le b">TypeError</code>。</li></ol><h2 id="6a0f" class="mq lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated">答案</h2><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="9c7b" class="mq lg iq le b gy mr ms l mt mu">A. 2<br/>B. 1 <br/>C. 2</span></pre><p id="ab8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果碰巧你对上述问题中的至少一个回答不正确，那么你可能陷入了运算符优先级的陷阱。点标点符号<code class="fe lb lc ld le b">…</code>比逻辑OR <code class="fe lb lc ld le b">||</code>优先级高，还是反过来？传播运算符的优先级是什么？正确答案是:<strong class="kf ir">没关系，因为JavaScript中没有Spread运算符这种东西！</strong></p><h1 id="8a91" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">跨页符不存在！</h1><p id="3180" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">当我们试图评估像<code class="fe lb lc ld le b">[…array || []]</code>这样的表达式时，检查操作符的优先级是合乎逻辑的。关于Spread语法，Web中存在一个常见的误解，它被表示为一个操作符。</p><p id="0329" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<a class="ae kc" href="https://stackoverflow.com/a/44934830" rel="noopener ugc nofollow" target="_blank">很棒的回答</a>由<a class="ae kc" href="https://stackoverflow.com/users/5647260" rel="noopener ugc nofollow" target="_blank">李国能</a>发布在Stack Overflow，值得一提，总结了Spread语法的本质。</p><p id="4207" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ECMAScript 2015规范本身可以直接检索到最令人难忘的论点之一:</p><blockquote class="nw"><p id="e0ee" class="nx ny iq bd nz oa ob oc od oe of la dk translated">完整的运算符列表在<a class="ae kc" href="http://www.ecma-international.org/ecma-262/6.0/" rel="noopener ugc nofollow" target="_blank"> ECMAScript 2015语言规范</a>的第12.5至12.15条中列出，该规范中引入了<code class="fe lb lc ld le b">`…</code>，但未提及<code class="fe lb lc ld le b">`...</code>。— <a class="ae kc" href="https://stackoverflow.com/a/44934830" rel="noopener ugc nofollow" target="_blank">李国能回答</a></p></blockquote><p id="a96e" class="pw-post-body-paragraph kd ke iq kf b kg og ki kj kk oh km kn ko oi kq kr ks oj ku kv kw ok ky kz la ij bi translated">另外值得一提的一点是<em class="mw">“操作符是一个内置函数[..]表示</em> <strong class="kf ir"> <em class="mw">的计算结果正好是一个值。"</em> </strong>。如果我们试图在Web控制台中运行类似于<code class="fe lb lc ld le b">const a = …b</code>的语句，其中<code class="fe lb lc ld le b">b</code>是一个数组，那么我们将<code class="fe lb lc ld le b">SyntaxError</code>。</p><p id="d629" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Spread语法的工作方式是首先评估其参数，然后传播结果。因此，<code class="fe lb lc ld le b">[…a || b]</code>的行为与<code class="fe lb lc ld le b">[…(a || b)]</code>完全相同。在<code class="fe lb lc ld le b">a || b</code>表达式周围放一组括号有助于消除歧义。</p><blockquote class="nw"><p id="8103" class="nx ny iq bd nz oa ob oc od oe of la dk translated">作为一个实用的参考，首先评估Spread Syntax的参数，然后进行扩展。</p></blockquote></div></div>    
</body>
</html>