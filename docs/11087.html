<html>
<head>
<title>Big O Notation And Binary Search — Why You Should Care About Them As A Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号和二分搜索法——作为开发人员为什么要关心它们</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/big-o-notation-and-binary-search-why-should-you-care-about-them-as-a-developer-8da90778988b?source=collection_archive---------18-----------------------#2022-02-13">https://levelup.gitconnected.com/big-o-notation-and-binary-search-why-should-you-care-about-them-as-a-developer-8da90778988b?source=collection_archive---------18-----------------------#2022-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="734d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">算法简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb5cd0d564ec3317474074c457514f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*euSMvlWzW3aKGIC9d1YMYA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com/photos/FXFz-sW0uwo" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="f41e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">大O符号是开发人员理解的基础，因为它分析算法的成本和速度。由于你可能会使用其他人的算法，你可能会想知道他们有多有效。另一方面，二分搜索法算法将帮助我们更好地理解大O符号，而不会让我们的大脑从一开始就爆炸。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="ffcc" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">什么是二分搜索法</h2><p id="2029" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">假设我们正在浏览我们的电话联系人，寻找一个名字以字母“K”开头的人。逻辑上，我们从联系人列表的中间开始寻找那个人，因为这比从字母“A”开始要快，因为我们清楚地知道这个名字不会在那里。</p><p id="8255" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因此，如果事实确实如此，我们希望在搜索数据集时也能有同样的效率，不是吗？这就是二分搜索法算法发挥作用的地方。</p><p id="b436" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">然而，重要的是要记住，为了使用二分搜索法，我们需要从元素的排序列表开始。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="26a0" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">它是如何工作的</h2><p id="23a4" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">想象一下，有人告诉你他们脑子里有一个1到50之间的数字，你需要猜猜他们。假设你从数字1开始向上，你可能要猜50次才能找到正确的数字。这就是所谓的简单搜索，它是非常低效的，我们一会儿会说为什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/82c5b90e118558638a9acbc4bcd28270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJo4aFGLqC80A2I_sDYIcQ.png"/></div></div></figure><p id="8433" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">另一方面，二分搜索法从列表的中间开始，检索元素并检查值是大于还是小于我们要找的值。</p><p id="967d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">例如，假设我们想到的数字是41。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/786a19b5aa2072606ecf014326a59d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEeOq96BCimuWavoxhoz7Q.png"/></div></div></figure><p id="bec6" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这里我们从25开始，因为数字41更高，我们选择38，因为它在25和50之间。然后我们再重复两次，仅用4次运算就找到了这个数字，而使用简单的搜索我们需要41次运算。很棒吧。越来越好了！</p><p id="2004" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">想象一下，你正在登录一个拥有500，000活跃用户的网站，软件需要找到你的用户名，这样你才能登录这个网站。最坏的情况是500，000次操作，但是如果我们使用二分搜索法会发生什么呢？让我想想。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/d449d382b6343f0168a6c741d53f4e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6UoKaY7dZiXN0hEGEU__g.png"/></div></div></figure><p id="fb2f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">因此，在最坏的情况下，在500，000个元素中，我们需要19次操作来找到我们要找的东西，而不是最多500，000次操作。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="87ae" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">对数</h2><p id="1f71" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">使用对数，我们可以帮助确定找到我们要寻找的元素所需的最大运算次数。对于普通搜索，该数字等于列表中元素的数量。但是对于二分搜索法，它等于log(n)(其中基数总是2，因为我们除以2以消除每个操作的一半元素)。例如，16个元素可能需要我们进行16次尝试，或者log (16)等于4，因为2的4次方是16。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="d488" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">执行时间</h2><p id="82f4" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">运行时间对性能很重要，因为您希望选择最佳算法，优化系统中的时间或空间。</p><blockquote class="nd ne nf"><p id="084a" class="lg lh ng li b lj lk ju ll lm ln jx lo nh lq lr ls ni lu lv lw nj ly lz ma mb im bi translated"><strong class="li iu">线性时间— </strong>如果一个算法的时间复杂度为<em class="it"> O </em> ( <em class="it"> n </em>)，则称该算法需要<strong class="li iu">线性时间</strong>，或者<em class="it"> O </em> ( <em class="it"> n </em>时间。通俗地说，这意味着运行时间最多随着输入的大小线性增加。</p><p id="946f" class="lg lh ng li b lj lk ju ll lm ln jx lo nh lq lr ls ni lu lv lw nj ly lz ma mb im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Time_complexity#Linear_time" rel="noopener ugc nofollow" target="_blank">维基百科上对线性时间的描述</a></p><p id="27f3" class="lg lh ng li b lj lk ju ll lm ln jx lo nh lq lr ls ni lu lv lw nj ly lz ma mb im bi translated"><strong class="li iu">对数时间- </strong>一个算法据说取<strong class="li iu">对数时间</strong>当<em class="it">T</em>(<em class="it">n</em>)=<strong class="li iu"><em class="it">O</em>(log<em class="it">n</em>)</strong>。由于log<em class="it">a</em>T30】n和log<em class="it">b</em>T34】n通过一个常数乘数相关联，并且该乘数与big-O分类无关，因此对数时间算法的标准用法是<em class="it"> O </em> (log <em class="it"> n </em>)而不考虑出现在<em class="it"> T </em>表达式中的对数的底数。</p><p id="d97c" class="lg lh ng li b lj lk ju ll lm ln jx lo nh lq lr ls ni lu lv lw nj ly lz ma mb im bi translated">需要对数时间的算法通常出现在二叉树的运算中或使用二分搜索法时。</p><p id="6b00" class="lg lh ng li b lj lk ju ll lm ln jx lo nh lq lr ls ni lu lv lw nj ly lz ma mb im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Time_complexity#Logarithmic_time" rel="noopener ugc nofollow" target="_blank">维基百科上对对数时间的描述</a></p></blockquote></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="4ff1" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">什么是大O符号</h2><p id="31e9" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">我们已经说过，大O符号帮助我们确定算法的速度，所以让我们看看这是如何发生的。</p><p id="45da" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">假设你给自己买了一辆漂亮的新特斯拉，并且很高兴使用自动驾驶仪。对于这个例子，让我们假设有100个变量需要考虑，如果一棵树跟在我们200米之外，挡住了道路。</p><p id="776c" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">让我们假设我们的汽车在撞上树之前有10秒钟的反应时间，每个操作是1毫秒，现在我们可以有下面的思维过程。</p><p id="6b03" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">普通搜索的最坏情况是100次操作或100毫秒，而二分搜索法只需要7毫秒。因为两者都低于10秒，我们可以选择普通搜索，因为它更容易，对不对？</p><p id="fde5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">但是如果变量是，比如说，100万，会发生什么呢？在这种情况下，二分搜索法大约需要20毫秒。如果我们使用前一个例子中的比例，我们可以假设正常的搜索需要20 x (100/7 ),相当于大约280毫秒，这仍然比我们需要反应的10秒少得多。现在，你可能会认为这种逻辑有极大的缺陷，你是对的。对于1，000，000个元素，正常搜索的最坏情况是1，000，000毫秒，这使得二分搜索法快了50，000毫秒，这表明当输入的大小增加时，差异有多大。</p><p id="13db" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">大O符号向您显示算法的速度，不是以秒为单位，而是比较操作的数量，并分析算法在增长/扩展到巨大数量时的速度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/bf992f98acce535f966632b39d34590a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSefiN-7yQMjZav-EM0Puw.png"/></div></div></figure><p id="2d18" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">上表向我们展示了当数据变得更大时，二分搜索法有多好。印象深刻吧。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="fb4f" class="mc md it bd me mf mg dn mh mi mj dp mk lp ml mm mn lt mo mp mq lx mr ms mt mu bi translated">结论</h2><p id="2ec0" class="pw-post-body-paragraph lg lh it li b lj mv ju ll lm mw jx lo lp mx lr ls lt my lv lw lx mz lz ma mb im bi translated">大O符号和二分搜索法算法是软件开发人员必须知道的。大O符号关注算法的速度，除非你想看到世界燃烧，你应该希望你的应用程序很快！另一方面，二分搜索法算法是进入算法的一个简单步骤，它准确地展示了我们如何从大O符号中获益。</p></div></div>    
</body>
</html>