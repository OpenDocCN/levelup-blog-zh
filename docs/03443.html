<html>
<head>
<title>SOLID Design Principles simplified with UML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用UML简化了可靠的设计原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solid-design-principles-simplified-with-uml-8432a3406248?source=collection_archive---------5-----------------------#2020-05-09">https://levelup.gitconnected.com/solid-design-principles-simplified-with-uml-8432a3406248?source=collection_archive---------5-----------------------#2020-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="b459" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">让我们用一个大例子来学习坚实的原理。这也是最常见的面试问题。首先，我们需要分解缩写。</p></blockquote><p id="3ad3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi ks translated"><span class="l kt ku kv bm kw kx ky kz la di"> S. </span>单一责任原则</p><p id="d75c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi ks translated"><span class="l kt ku kv bm kw kx ky kz la di"> O. </span>开放封闭原则</p><p id="2af8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi ks translated"><span class="l kt ku kv bm kw kx ky kz la di"> L. </span>利斯科夫替代原理</p><p id="02b9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi ks translated"><span class="l kt ku kv bm kw kx ky kz la di"> I. </span>界面偏析原理</p><p id="4004" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi ks translated"><span class="l kt ku kv bm kw kx ky kz la di"> D. </span>依存倒置原则</p><h1 id="e290" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">很酷吧？让我们逐一探究。</h1><p id="6883" class="pw-post-body-paragraph jq jr iq jt b ju lz jw jx jy ma ka kb kp mb ke kf kq mc ki kj kr md km kn ko ij bi ks translated"><span class="l kt ku kv bm kw kx ky kz la di"> 1。</span> <strong class="jt ir">单一责任原则:</strong>一个类必须有一个具体的责任，没有别的。它应该改变只有一个原因。因此责任实际上被封装在类中，说我们的类有一个责任。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi me"><img src="../Images/90eb6fd29bb31fe1a1141f6b4216a9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*Mw1cp9RgrhPWz5OtT0QYUg.jpeg"/></div></figure><p id="3c84" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">正如您在这个UML: class中看到的，IPhone具有可以定义IPhone的属性。但是等等，CalculateTotal_Sale()在这里做什么？</p><p id="b8e9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">你看出问题了吗？计算总销售额不是IPhone类的责任</p><p id="13f5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">问题:</strong>如果明天我有IPad类，我将不得不为那个类重新编写相同的方法。</p><p id="158b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">解决方案:</strong>相反，我们可以将计算总销售额的责任转移到新的sale类中。IPhone可以封装销售额来计算其总销售额。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/a47b04279bacda819c95202ab0fbc5ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*4yhba99pdSDFqVyiR0OZSA.jpeg"/></div></figure><p id="1f79" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这里，现在一个销售正在管理计算TotalSale()的责任。而我们的IPhone类只是简单的重用这个责任而不是自己创造一个。因此IPhone有了TotalSale() 。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="942b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi ks translated"><span class="l kt ku kv bm kw kx ky kz la di"> 2。</span> <strong class="jt ir">开-关原理:</strong>开为扩展，关为修改。软件实体(对象、<em class="js">模块、功能</em>)应该对扩展开放，但对修改关闭。这仅仅意味着一个实体应该容易扩展而不需要修改它们自己。</p><p id="2186" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">问题:</strong>我们知道不同的IPhone型号有不同的规格，对吧？<strong class="jt ir"> IPhone XR </strong>与<strong class="jt ir">IPhone x</strong>的规格不同</p><p id="3384" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">解决方案:</strong>我们必须抽象我们的问题，以便我们的IPhone类可以基于模型类型委托它的实现。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/d10071986f81f67f549932bc9fd4cafb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*aywxHtwlF-SrLPeIDmUPPw.jpeg"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">现在，IPhone可以要求特定的型号，并根据它得到的型号设置规格。</figcaption></figure><p id="554a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">这里的IPhone类是封闭的修改，但它是开放的扩展。请注意，IPhone类现在封装了一个IModel。所以ModelName属性不再是IPhone类的责任。我们再次使用我们的第一个设计原则(单一责任)。我们的抽象足够通用，可以满足苹果创造的任何模型。</p><p id="316d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们的客户:一部IPhone不需要仅仅因为苹果决定推出新型号<strong class="jt ir">(关闭修改)</strong>而改变。苹果现在可以有“n”个型号<strong class="jt ir">(开放延期)</strong>。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="ef97" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi ks translated"><span class="l kt ku kv bm kw kx ky kz la di"> 3。</span> <strong class="jt ir">利斯科夫的替换原则:</strong>父类应该很容易被它们的子类替换。</p><p id="68ff" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">在我们上面的UML中，我们可以看到，我们已经创建了IModel接口，现在任何继承IModel的类都必须定义它的所有方法，以满足IS-A关系，否则会出现编译时错误。但是当你继承类而不是接口时，你的编译器就不存在了。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/d3a4d507d26cbec6c74ab53c3a5ffdc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*AXUnzdkDXMfc7hP-bvlY5A.jpeg"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">IPhone有一个CPU类，IPhone可以有仿生芯片，但没有一个IPhone与骁龙兼容。</figcaption></figure><p id="b61b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">问题:</strong>你见过有骁龙的IPhone吗？<strong class="jt ir">见鬼不！！！，对吧？</strong></p><p id="fded" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">因此，当我们试图将骁龙的CPU组装到我们的IPhone类时，它会抛出一个错误，正如你在Snapdragon865类中看到的那样，它会抛出未实现的异常。因为IPhone X &amp; XR只兼容仿生芯片。</p><p id="fb50" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">解决方案:</strong>我们不应该拥有没有完全实现其父类行为的子类。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/d4735fab704bc62146fee88611ca8c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*x9pqxUBzEKNxIbxula-F5A.jpeg"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">苹果用A8代替骁龙，用于IPhone 6。因此，它与Iphone兼容。</figcaption></figure></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="9a13" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi ks translated"><span class="l kt ku kv bm kw kx ky kz la di"> 4。</span> <strong class="jt ir">界面隔离原则:</strong>记住单责任原则？这是相同的原则，但这一原则适用于接口。</p><p id="4885" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">问题:</strong>我们不应该有更一般化的接口。也就是说，我们必须避免在一个单一的接口中混淆所有的东西，然后强迫它们的具体类定义那些它们可能不需要的方法，它们最终会抛出NotImplementedException。</p><p id="49f4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">相反，我们必须有许多特定于客户端的接口，而不是一个通用接口。</p><p id="e613" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">我们有2部Iphone XR &amp; X:<strong class="jt ir">Iphone XR有单摄像头</strong>而<strong class="jt ir"> IPhone X有双摄像头</strong>。因此，IPhoneXR定义双摄像头是错误的，因为它没有双摄像头。这里IPhone XR只定义了单摄像头，DualCamera抛出了一个异常。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/62c01660137369a2c375af414e0f8618.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*NiqsC6R2P_y5R3vJw6BWzA.jpeg"/></div></figure><p id="7f22" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">解决方案:</strong>如前所述，我们不应该有一个一般化的接口。我们可以有顶级的抽象，但是实现必须根据他们的需求分解成小块。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/520f6024d9b2647486b93ee6a077834d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*Vw4xDP3WlhPOdV2sYWAmVg.jpeg"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">在这里类IPhone可以设置相机基于他们的模型。</figcaption></figure><p id="a3de" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">类别IPhone有一个摄像头，根据型号类型可以是单双摄像头。对于XR，它是单摄像头设置&amp;对于X，它是双摄像头设置。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="6a90" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi ks translated"><span class="l kt ku kv bm kw kx ky kz la di"> 5。</span> <strong class="jt ir">依赖反转原则:</strong>我们的应用必须是松耦合的。类应该依赖于抽象而不是具体。因为随着应用程序的增长，紧密耦合的应用程序会变得更加复杂。</p><p id="66ad" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">问题:</strong>我们在IOSUpdate &amp; IPhone之间有紧密耦合。因此，如果明天苹果需要为IPad进行IOS更新，那么我们将不得不建立一个更紧密的耦合关系，随着应用程序越来越多，维护变得越来越困难。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/02a478a2f3edf264524622110b09dc67.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*3KXVp_q6ZgQCzJtpjxvXQg.jpeg"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">IOSUpdate与IPhone紧密耦合。</figcaption></figure><p id="86ac" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated"><strong class="jt ir">解决方案:</strong>一个抽象。应该有松散耦合的类，而不是直接与具体的类通信。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi na"><img src="../Images/8677aeef91212dde12d7ef848cf30d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*dti77y_qD6E2Hn-BrA4WyQ.jpeg"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">IUpdate:抽象。IPhoneUpdate和IPadUpdate是抽象的具体类。</figcaption></figure><p id="ba31" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">正如你在上面看到的，IUpdate是一个有2个具体类的接口。当我们的客户端(在本例中是IPhone)请求更新时，我们可以简单地在构造函数或方法中注入IPhoneUpdate依赖项。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi na"><img src="../Images/26d0f695721cd9b9540ac154944ab19e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*j-assLhxplYm8fCrADQo9w.jpeg"/></div></figure><p id="3c82" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">对于一个IPad来说，就是注入了IPadUpdate依赖。</p><p id="9781" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kp kd ke kf kq kh ki kj kr kl km kn ko ij bi translated">所以将来，当苹果需要一个新产品，比如MacBook，我们可以简单地创建一个MacBookUpdate类，它将是IUpdate接口的具体表示。而客户端MacBook可以解决<iupdate macbookupdate="">依赖。</iupdate></p><blockquote class="jn jo jp"><p id="6f3d" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">依赖倒置本身是一个需要学习的广泛话题。</p><p id="6d39" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">我已经在我的另一个博客中提到过，如果你想了解它的工作原理，请随意访问:</p></blockquote><div class="nb nc gp gr nd ne"><a href="https://www.c-sharpcorner.com/blogs/what-is-dependency-injection-and-what-are-its-types2" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">什么是依赖注入，依赖注入有哪些类型？如何实现DI？</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">IOC和DI帮助我们摆脱对代码的依赖。为什么我应该使用依赖注入？假设我们有一个…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">www.c-sharpcorner.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns mk ne"/></div></div></a></div><h1 id="b99b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">与我联系:</h1><blockquote class="jn jo jp"><p id="48db" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><a class="ae nt" href="https://github.com/RikamPalkar" rel="noopener ugc nofollow" target="_blank"><strong class="jt ir">https://github.com/RikamPalkar</strong></a></p><p id="5d6b" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><a class="ae nt" href="https://www.linkedin.com/in/rikampalkar/" rel="noopener ugc nofollow" target="_blank"><strong class="jt ir"><em class="iq">https://www.linkedin.com/in/rikampalkar/</em></strong></a></p><p id="767a" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><a class="ae nt" href="https://www.c-sharpcorner.com/members/rikam-palkar" rel="noopener ugc nofollow" target="_blank"><strong class="jt ir">【https://www.c-sharpcorner.com/members/rikam-palkar】T21</strong></a></p><p id="d732" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated"><a class="ae nt" href="https://twitter.com/rikam_cz" rel="noopener ugc nofollow" target="_blank"><strong class="jt ir"><em class="iq">https://twitter.com/rikam_cz</em></strong></a></p></blockquote></div></div>    
</body>
</html>