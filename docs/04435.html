<html>
<head>
<title>Switching to Kotlin for Java developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java开发人员转向Kotlin</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/switching-to-kotlin-for-java-developers-1ce67aa08094?source=collection_archive---------8-----------------------#2020-06-26">https://levelup.gitconnected.com/switching-to-kotlin-for-java-developers-1ce67aa08094?source=collection_archive---------8-----------------------#2020-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="30f4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">简洁、安全、可互操作且工具友好</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/31016a167c7766a3406b2f8a9ba534e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PzHHFgOfWEe7OscdcLlXA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自科特林的最新消息(截止到2020年6月23日)</figcaption></figure><p id="72a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Java是最古老和最流行的编程语言之一。它已经被组织用于软件开发很多年了。然而，在现代软件开发场景中，这种突出的语言是滞后的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/aad264eb3d4d14f08ee20c218cecd88e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EqTUqNl9z5ZVL2QbSckBg.png"/></div></div></figure><h1 id="5c61" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">科特林是什么？</h1><p id="2564" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">2011年，JetBrains宣布开发Kotlin编程语言，这是一种替代用Java或Scala等语言编写代码以在Java虚拟机上运行的语言。六年后，谷歌宣布Kotlin将成为Android操作系统的官方支持开发路径。</p><h1 id="5210" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们为什么要爱科特林？</h1><p id="5504" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">使用Kotlin开发程序的开发人员不仅喜欢这种语言，而且热爱它😍。原因是什么？</p><p id="a76e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Kotlin是少数几种可用于服务器端、前端开发和移动应用的语言之一。源代码可以编译成Java字节码，也可以转换成JavaScript。它还支持包括iOS、macOS、Linux、windows在内的目标平台将源代码编译成本地二进制文件。因此，我们可以使用Kotlin进行全栈开发。</p><p id="e13f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Kotlin，更好的Java。Kotlin在Java上提供了很多功能，但没有带走任何东西。</p><p id="284f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Kotlin从第一天起就有出色的IDE支持Kotlin来自JetBrains，他们还开发了一个著名的Java集成开发环境(IDE): IntelliJ IDEA。JetBrains的开发人员确保Kotlin在IDEA中有一流的支持。</p><h1 id="c98a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">从Java切换到Kotlin</h1><p id="091d" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">有经验的Java开发人员在学习Kotlin的细微差别时，不得不放弃一些Java实践。</p><h2 id="d98f" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">你会少打字</h2><p id="bf58" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><strong class="la iu"> <em class="ne">分号在Kotlin中是可选的。</em> </strong>编译器可以计算出该行的结束位置。事实上，如果您在行尾放置分号，您会得到一个编译器警告。</p><p id="5d26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下示例是Kotlin中的有效语法，可以独立编写。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="2758" class="ms lw it ng b gy nk nl l nm nn">println(“Hello, world!”)</span></pre><p id="53c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不仅Kotlin，Python也不需要分号。</p><p id="5489" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="ne">可变类型规格在Kotlin中是可选的。在Java中，你用一个类型开始一个变量声明。这对Kotlin不起作用，因为它允许您从许多变量声明中省略类型。我们可以在不指定类型的情况下定义一个变量，然后像下面这样请求该变量的类型。</em></strong></p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="0b02" class="ms lw it ng b gy nk nl l nm nn">val​ greet = ​"hello"</span><span id="6d91" class="ms lw it ng b gy no nl l nm nn">println(greet)​ // hello<br/>println(greet::​class​)​ // class kotlin.String<strong class="ng iu">​</strong><br/>println(greet.javaClass) // class java.lang.String</span></pre><p id="1e24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Kotlin具有smarts类型推理，可以根据上下文确定变量的类型。但是如果您愿意，也可以显式指定类型。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="ecfc" class="ms lw it ng b gy nk nl l nm nn">val greet: String = “hello”</span></pre><p id="c055" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="ne">在Kotlin中，类和函数是可选的。</em> </strong>与Java之类的语言不同，Kotlin不要求一个语句或表达式属于一个方法，一个方法属于一个类，至少在我们写的源代码中是这样。</p><p id="e69e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的源代码中，函数不属于某个类，函数下面的代码是独立的，不属于任何函数。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="617d" class="ms lw it ng b gy nk nl l nm nn">fun hello(name: String) {<br/>    println("hello $name")<br/>}</span></pre><p id="2724" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="ne">在Kotlin中，Try-catch是可选的。Kotlin不强迫你捕捉任何检查过或未检查过的异常。如果您没有在函数调用周围放置一个try-catch，并且如果该函数失败，异常会自动传播到您的函数或代码的调用方。如果一个异常没有被处理，它将导致你的程序致命的终止。</em></strong></p><p id="8812" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，在Java中，<code class="fe np nq nr ng b">Thread class</code>的<code class="fe np nq nr ng b">sleep()</code>方法抛出一个检查过的异常，编译器强迫我们处理它。但是在科特林，我们可以这样写。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="f089" class="ms lw it ng b gy nk nl l nm nn">Thread.sleep(500)</span></pre><p id="eeaf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上。代码没有任何try和catch关键字。</p><h2 id="6e9c" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">Kotlin编译器在给出警告时是明智的</h2><p id="e0c4" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">例如，如果在函数或方法中收到的参数没有被使用，那么编译器会给出警告。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="4778" class="ms lw it ng b gy nk nl l nm nn">fun​ ​compute​(n: Int) = 0​ ​ <br/>println(compute(4))</span></pre><p id="3091" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您运行这个脚本时，除了显示结果之外，Kotlin还会报告任何关于未使用参数的警告。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="fb26" class="ms lw it ng b gy nk nl l nm nn">0​ <br/>unused.kts:1:13: warning: parameter ’n’ is never used​ <br/>fun compute(n: Int) = 0​ <br/>      ^</span></pre><h2 id="5814" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated"><strong class="ak">更喜欢val而不是var </strong></h2><p id="1453" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">要定义一个不可变的变量，也就是常量或值，使用<code class="fe np nq nr ng b">val</code>关键字。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="a73e" class="ms lw it ng b gy nk nl l nm nn">val​ pi = 3.14</span></pre><p id="3edc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe np nq nr ng b">pi</code>的值可以修改，<code class="fe np nq nr ng b">val</code>关键字就像Java中的<code class="fe np nq nr ng b">final</code>关键字。</p><p id="190a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想改变一个变量的值呢？让我们使用var关键字。就像下面的例子，我们创建一个可变变量，然后修改它的值。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="dda6" class="ms lw it ng b gy nk nl l nm nn">var​ length = 10<br/>println(length) ​//10​<strong class="ng iu">​   ​   </strong></span><span id="705a" class="ms lw it ng b gy no nl l nm nn">length = 15<strong class="ng iu">  <br/></strong>println(length) ​//15</span></pre><p id="137b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">多变性使得代码难以推理。具有可变性的代码也有更高的出错几率。具有可变性的代码更难并行化。一般情况下，尽量使用<code class="fe np nq nr ng b">val</code>而不是<code class="fe np nq nr ng b">var</code>。在Kotlin中，默认为val和不变性。</p><p id="1d46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe np nq nr ng b">val</code>，它只使变量或引用成为常量，而不是被引用的对象。所以<code class="fe np nq nr ng b">val</code>只保证引用的不变性，并不阻止对象的改变。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="8c3c" class="ms lw it ng b gy nk nl l nm nn">val​ message = StringBuilder(​"hello"​)​ ​ ​<br/>//message = StringBuilder("another") // ERROR​​ ​ <br/>message.append(​"there")</span></pre><p id="1a8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，<code class="fe np nq nr ng b">val</code>只关注手头的变量或引用，而不关注它所引用的内容。然而，尽可能选择<code class="fe np nq nr ng b">val</code>而不是<code class="fe np nq nr ng b">var</code>。</p><h2 id="cb58" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">改进的相等检查</h2><p id="ee93" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">就像Java一样，在Kotlin中有两种类型的等式。</p><ul class=""><li id="5478" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated">结构相等(Java中的<code class="fe np nq nr ng b">equals()</code>方法，或者Kotlin中的<code class="fe np nq nr ng b">==</code>操作符)，是值的比较。</li><li id="7d6c" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">引用相等(Java中的<code class="fe np nq nr ng b">==</code>操作符，或者Kotlin中的<code class="fe np nq nr ng b">===</code>)是引用的比较。</li></ul><p id="c29a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是Kotlin中的结构等式运算符<code class="fe np nq nr ng b">==</code>比Java中的<code class="fe np nq nr ng b">equals() </code>方法多。比如你表演<code class="fe np nq nr ng b">a.equals(b)</code>；在Java中，如果引用<code class="fe np nq nr ng b">a</code>是<code class="fe np nq nr ng b">null</code>，你可能会遇到一个<code class="fe np nq nr ng b">NullPointerException</code>。当你在Kotlin中使用<code class="fe np nq nr ng b">==</code>时就不是这样了。按照惯例，Kotlin中类似<code class="fe np nq nr ng b">a == b</code>的表达式被翻译成。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="3835" class="ms lw it ng b gy nk nl l nm nn">a?.equals(b) ?: (b === null)</span></pre><p id="0434" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<code class="fe np nq nr ng b">a</code>不为<code class="fe np nq nr ng b">null</code>，则调用<code class="fe np nq nr ng b">equals(Any?)</code>函数，否则(即<code class="fe np nq nr ng b">a</code>为<code class="fe np nq nr ng b">null</code>)检查<code class="fe np nq nr ng b">b</code>是否等于<code class="fe np nq nr ng b">null</code>。</p><h2 id="fe22" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">科特林的弦乐</h2><p id="fc2a" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">和Java一样，Kotlin中的字符串是不可变的。这意味着一旦字符串被创建，我们就没有办法改变它的单个字符。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="3256" class="ms lw it ng b gy nk nl l nm nn">var myString = "Hello"<br/>myString[0] = 'h' // ERROR</span></pre><p id="4e2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，我们可以从一个给定的字符串导出另一个字符串。Kotlin用额外的功能丰富了Java String类。例如，方法<code class="fe np nq nr ng b">padEnd()</code>允许我们格式化一个字符串，以便表达式。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="f434" class="ms lw it ng b gy nk nl l nm nn">"Hello".padEnd(10, '!') // “Hello!!!!!”</span></pre><p id="89c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者我们可以重新分配一个字符串变量，如果你使用关键字<code class="fe np nq nr ng b">var</code>声明变量的话。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="30ac" class="ms lw it ng b gy nk nl l nm nn">var myString = "Hey!" // Hey!<br/>myString = "Hello!" // Hello!</span></pre><h2 id="1a5e" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">字符串模板</h2><p id="fed6" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">Kotlin有一个很棒的特性叫做字符串模板，它允许字符串包含模板表达式。字符串模板表达式以美元符号<code class="fe np nq nr ng b">$</code>开始。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="80cb" class="ms lw it ng b gy nk nl l nm nn">val myInt = 5<br/>val myString = "myInt = $myInt"<br/>println(myString) //myInt = 5</span></pre><p id="8f4d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">字符串模板中可以使用任何有效的Kotlin表达式。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="d091" class="ms lw it ng b gy nk nl l nm nn">val n = 5<br/>val message = "n + 1 = ${n + 1}" // n + 1 = 6</span></pre><h2 id="0cab" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">原始字符串</h2><p id="69be" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">此外，在Kotlin中，我们有三重引用的原始字符串，可以包含特殊字符，而不需要对它们进行转义。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="bf21" class="ms lw it ng b gy nk nl l nm nn">val​ raw = ​”””My friend asked, “How are you today, $name?””””​</span></pre><p id="ec4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用这种符号来创建多行字符串。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="ab23" class="ms lw it ng b gy nk nl l nm nn">val receipt = """Item 1: $1.00<br/>Item 2: $0.50"""</span></pre><h2 id="e81c" class="ms lw it bd lx mt mu dn mb mv mw dp mf lh mx my mh ll mz na mj lp nb nc ml nd bi translated">多表达，少陈述</h2><p id="c801" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">像Java、C#和JavaScript这样的语言，语句比表达式多(if语句、for语句、try等等)。另一方面，像Ruby、F#、Groovy、Haskell和许多其他语言的表达式比语句多。</p><p id="c37b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们编写一段Kotlin代码，就像在Java等语言中一样。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="f4c2" class="ms lw it ng b gy nk nl l nm nn">fun canVote​(name: String, age: Int): String {<br/>    ​<br/>    var ​ status: String<br/>    if​ (age &gt; 17) {<br/>        status = ​"yes, please vote"​<br/>    } else​ {<br/>        status = ​"nope, please come back"​<br/>    }<br/>    return​ ​"$name, $status"​<br/>}</span></pre><p id="ec04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们重新编写前面的代码，使用if作为表达式而不是语句。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="6d00" class="ms lw it ng b gy nk nl l nm nn">val​ status = ​if​ (age &gt; 17) ​”yes, please vote”​ ​else​ ​”nope, please come back”​​ ​ <br/>​return​ ​”$name, $status”​</span></pre><h1 id="925e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="86a8" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在本文中，我们考虑了Java中没有的Kotlin语言的一个特性。</p><p id="49ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很简单，对吧？</p><h1 id="7d29" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><p id="3a7e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">[1]<a class="ae og" href="https://blog.jetbrains.com/kotlin/2011/08/why-jetbrains-needs-kotlin/" rel="noopener ugc nofollow" target="_blank">https://blog . jetbrains . com/kot Lin/2011/08/why-jetbrains-needs-kot Lin/</a></p><p id="c61f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[2]<a class="ae og" href="https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/" rel="noopener ugc nofollow" target="_blank">https://blog . jetbrains . com/kot Lin/2017/05/kot Lin-on-Android-now-official/</a></p></div></div>    
</body>
</html>