<html>
<head>
<title>How we created a real-time Leaderboard for a million Users</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何为一百万用户创建实时排行榜</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-we-created-a-real-time-leaderboard-for-a-million-users-555aaa3ccf7b?source=collection_archive---------0-----------------------#2020-03-31">https://levelup.gitconnected.com/how-we-created-a-real-time-leaderboard-for-a-million-users-555aaa3ccf7b?source=collection_archive---------0-----------------------#2020-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3eae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几年前，在Rocket Languages工作时，我被分配了一项任务，要重写我们正在开发的应用程序的排行榜和积分系统，这是我们从遗留代码库向由Laravel支持的现代PHP应用程序迁移的一部分。这个看似相对简单的任务最终揭示了一系列必须克服的挑战，以满足我们排行榜的功能性和非功能性要求。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/256c6ee7b09b9a25c6dce1e075a82b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQl56KvSACL2zOUSFWW8hQ.jpeg"/></div></div></figure><p id="80fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">排行榜是一个非常简单的系统:用户在应用程序中做<em class="kx">件事情</em>就可以获得积分，然后这些积分被累加并显示在排行榜中。可以根据需要增加不同的复杂程度。例如，如果需要跟踪用户执行的单个操作，或者如果我们只对他们获得的总积分感兴趣，那么数据的底层表示就会不同。复杂性也随着数据检索方式的不同而增加:我们是只对前10名用户感兴趣，还是希望能够告诉应用程序中的每个用户他在排行榜中的位置？我们是在为相对较少的用户群做这件事，还是在考虑将其扩展到数百万人？</p><h1 id="5824" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我们所拥有的</h1><p id="e54b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">广义地说，<a class="ae mb" href="https://www.rocketlanguages.com/" rel="noopener ugc nofollow" target="_blank">火箭语言</a>应用程序是一个在线语言学习服务。有几门课程，每门课程包括几十章，每一章都有一系列学生必须完成的练习。这些练习在本质上是不同的，与它们互动会产生分数。此外，解决一个练习会给学生加分，同时标记一些材料为已读，回答论坛中的问题，等等。一般来说，使用该应用程序会产生一连串的积分，这些积分会收集在学生的个人资料中，并显示在不同的区域:在使用该应用程序时，作为他们姓名旁边的徽章，在专用的排行榜区域，以及在学生在论坛上发布的每条消息的页脚。</p><p id="62f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">排行榜区域特别有趣，因为它提供了在不同时间范围(每天、每周、每月)过滤积分的可能性，还提供了查找特定用户的可能性，以及随时在排行榜中显示登录用户的位置。</p><p id="8cd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遗留实现非常简单，通过使用由cron jobs每隔一段时间更新一次的中间MySQL表来解决问题，这种组合听起来很容易出错，更不用说它还会在数据库和应用程序之间产生紧密耦合。因为需要cron作业来更新排行榜，所以应用程序中显示的数据不是实时的，而是有一条消息表明它只是“定期”更新。</p><h1 id="0ba7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我们被要求做的</h1><p id="4b70" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">要求非常简单。传统排行榜必须进行调整，以适应新的代码库，这是使用Laravel构建的。功能将保持不变，无论我们提出什么样的模式更改，旧数据都必须导入到新数据库中。</p><p id="6ba0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了增加趣味性，并遵循我们在行业中类似应用中看到的情况，我们决定通过增加额外要求来挑战自己，这些要求将为排行榜带来更多价值，并使整个任务对我们来说更具挑战性。因此，我们决定新的排行榜必须<strong class="jp ir">实时显示数据</strong>，在用户使用该应用程序时向他们提供即时反馈。无论有多少人在玩实时数据，无论我们有多少不同的分类，实时数据都是可用的(想想基于时间的排行榜和基于类别的排行榜)。</p><h1 id="568e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">问题是</h1><p id="fba3" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">事实证明，排行榜的核心是非常简单的数据结构。将会有一个<strong class="jp ir">点数</strong>表，看起来是这样的:</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="d814" class="mh kz iq md b gy mi mj l mk ml">&lt;Int&gt; user_id, &lt;Int&gt; amount, &lt;Timestamp&gt; created_at</span></pre><p id="ff46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当用户因做某事而获得积分时，我们只需向该表添加一个条目。然后，如果我们想获得某个用户当月的总积分，我们只需执行如下操作:</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="8862" class="mh kz iq md b gy mi mj l mk ml">select sum(amount) from Points where user_id = ? and created_at &gt;= "2020-03-01"</span></pre><p id="ede9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kx">(以上只是伪代码sql风格，我还没有真正测试过。)</em></p><p id="110b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当您将这个解决方案推广到一个拥有1亿行的表，并且每天都有10万个新行时，事情就变得有趣了。事实证明，SQL类型的数据库在保持一致性、以设计良好的模式存储信息、生成报告和查询数据方面非常出色。但是，当它需要处理大量信息时，它的性能并不好。随着越来越多的用户向表中输入信息，不管服务器有多快，也不管模式中添加了什么索引，上面公开的解决方案很快就会变得毫无用处。</p><p id="7b3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，开发排行榜系统的真正挑战是:</p><ul class=""><li id="9458" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">为可扩展的数据集提供<strong class="jp ir">排行榜报告(谈到数百万用户)。</strong></li><li id="4950" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">支持用户不断赚取积分，每天产生数千个新的积分(在我们的例子中，大约是15万)。也就是说，<strong class="jp ir">对数据结构的写入必须非常高效</strong>。</li><li id="a48d" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">报告必须实时可用。也就是说，从数据结构中读取数据必须非常高效。</li></ul><p id="b3e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在进行这项工作时，我们为自己设置了一些额外的挑战:</p><ul class=""><li id="9afd" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">随时了解任何给定用户在排行榜中的位置和分数的可能性。</li><li id="c060" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">能够获取排行榜的任何范围，而不仅仅是前X名。</li><li id="7227" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">获取排行榜应该不到...一秒钟？在这里很难设置一个基于时间的指标，但这个想法是加载排行榜应该像从数据库的小表中加载条目一样快。</li></ul><h1 id="17ca" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">解决方案</h1><p id="d6d1" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">下面是我们为特定用例实现的解决方案的演练。然而，我将省略特定于语言的内容，并尽可能使示例通用化。我们使用Redis和MySQL，但是只要它们提供适当的数据结构，任何与持久存储结合的缓存系统都可以工作。</p><h2 id="5827" class="mh kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">持久存储</h2><p id="92c1" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">首先，我们将暂时忘记实时显示数据的要求，而专注于我们的数据存储。一般来说，这是解决问题的推荐方法:首先你写出你能想到的最简单的解决方案，然后你迭代它来改进它。</p><p id="669d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">永久存储器是我们存储用户获得的所有积分的地方。因为这将是我们的数据，而且因为数据是有价值的，所以我们需要确保我们将它存储在一个数据库中，该数据库易于表示它，以一致的方式存储它，并且有一个经过验证的读写机制。SQL或NoSQL数据库系统都可以，但我个人在SQL方面更有经验，所以我们选择了SQL作为我们的解决方案。</p><p id="7c9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将保存用户获得的所有积分的表的模式如下所示:</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="ee19" class="mh kz iq md b gy mi mj l mk ml">CREATE TABLE `user_points` (<br/> `id` int(10) unsigned NOT NULL,<br/> `user_id` int(11) NOT NULL,<br/> `amount` int(11) NOT NULL,<br/> `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP<br/>) ENGINE=MyISAM DEFAULT CHARSET=utf8;</span></pre><p id="2172" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据项目的特性，上面的模式也可能包含一些索引(例如在<em class="kx"> user_id </em>列上，可能在<em class="kx"> created_at </em>列上包含另一个索引)。在我们的例子中，我们有额外的列来表示每个点的来源。</p><p id="251d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们有了Points表，我们就可以开始在每次用户在应用程序中做一些事情时插入数据来填充它。</p><h1 id="18e1" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">快速阅读</h1><p id="0cdd" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在我们有了我们的积分表，我们的用户在给它提供信息，问题是我们如何从它提取信息并呈现给我们的用户？为了解决这个问题，我们需要一个额外的数据结构来支持Points表。该数据结构将包含点表中信息的汇总，并且将以不同的方式组织。我们的Points表仍然是真实的来源，但是新的数据结构将用于访问数据。</p><h2 id="9039" class="mh kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">关于Redis及其排序集和散列</h2><p id="12c9" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Redis是一个内存数据库软件，它主要在计算机的RAM内存中工作，读写速度非常快。它还提供了一些非常有用的数据结构的实现。其中一些是众所周知的，比如集合、散列和映射。Redis中最简单的数据结构是键-值存储，其中键和值是String类型。</p><p id="23fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">他们的<a class="ae mb" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank">网站</a>包含非常可靠的文档，并提供了一个在线CLI来与基于云的Redis服务器进行交互，因此在浏览文档的同时，很容易立即开始使用不同的命令进行练习。</p><p id="bf5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Redis提供的最不为人知的数据结构之一是<strong class="jp ir"> </strong> <a class="ae mb" href="http://Data types – Redis" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">排序集</strong> </a> <strong class="jp ir">。事实上，这是一个非常有用的数据结构，但也是一个不容易自己实现的数据结构。排序集基本上是字符串类型的键和数字类型的分数之间的映射。键总是唯一的，分数可以是任意数字。排序集支持的大多数操作需要O(log(n))的对数时间，这意味着即使对于巨大的数据集，它的执行时间也将非常低。</strong></p><p id="9f55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的排行榜实现，排序集将存储每个用户的总分数。因为user_id是一个惟一的字段，所以它很有可能成为有序集合的键。分数就是分数。</p><p id="9b42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，Redis也实现了散列。哈希是访问信息的优秀结构。它们使用具有关联值的键来存储数据。如果您知道密钥，访问存储在该密钥中的值需要常数时间O(1)。检查一个键是否存在也需要O(1)时间，在散列中插入一个新的键也是如此。与键相关联的值可以是任何值，尽管最好将存储的数据量保持在最小。记住，这些结构都将存在于计算机的RAM中，这是一种非常有限的资源。</p><p id="d436" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，现在我们已经介绍了这两种数据结构，我们将如何使用它来创建我们的排行榜呢？回想一下前面的段落，从MySQL获取信息是不可能的，因为它效率不高，最重要的是不可伸缩。然而，<strong class="jp ir">可以只做一次</strong>。</p><p id="04f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的想法将如下:</p><ul class=""><li id="9183" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">从MySQL的积分表中提取构建排行榜所需的所有信息。我们在这里提取的是数据库中每个用户的总积分。结果集将包含用户的id以及他们获得的总积分。</li><li id="f356" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">在Redis中创建一个排序集，并将上一步中获得的结果集提供给它。如前所述，用户的ID成为排序集合条目的关键字，总点数成为分数。要添加一个条目到一个有序集合中，你需要使用<a class="ae mb" href="https://redis.io/commands/zadd" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> ZADD </em>命令</a>。<em class="kx"> ZADD </em>采用三个参数:排序集的名称、分数和密钥，执行时间为O(log(n))。</li></ul><p id="25ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的伪代码显示了所描述的两个步骤:</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="a10f" class="mh kz iq md b gy mi mj l mk ml"><strong class="md ir">MYSQL<br/></strong>select user_id, sum(amount) as score from user_points group by user_id order by score desc</span><span id="f07d" class="mh kz iq md b gy nl mj l mk ml"><strong class="md ir">CODE<br/></strong>// lets assume $rows contains the resultset from the query above<br/>foreach ($row in $rows)<br/>  storeInLeaderboard($row-&gt;user_id, $row-&gt;score);<br/>endforeach</span><span id="2ae9" class="mh kz iq md b gy nl mj l mk ml">// the helper function goes like this<br/>function storeInLeaderboard(userId, score) {<br/>  $redisLibrary-&gt;zadd("leaderboard", score, userId)<br/>}</span></pre><p id="e188" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，排行榜被加载到一个排序集合中。在Redis中，要查询已排序的集合，我们必须使用<a class="ae mb" href="https://redis.io/commands/zrevrange" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> zrevrange </em> </a>或<em class="kx"> zrange </em>命令。这两个命令本质上是相同的，除了<em class="kx"> zrevrange </em>首先获取最高分，这就是我们需要的排行榜:</p><pre class="km kn ko kp gt mc md me mf aw mg bi"><span id="0bf7" class="mh kz iq md b gy mi mj l mk ml">zrevrange leaderboard 0 9 withscores</span></pre><p id="6178" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kx"> zrevrange ( </em>以及<em class="kx"> zrange) </em>取<em class="kx"> </em> O(log(N)+M)执行，其中N是集合中的总条目数，M是要返回的元素数。对于我们的排行榜，M可以忽略不计，因为我们通常会对前10个条目或某个关键字周围的条目感兴趣，但不会对非常大的M感兴趣(非常大的M往往会使执行时间更接近线性)。该命令的输出如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/26a104d7e41f97820ffee459efa16167.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*1XA2C-O8kS6TyvqVk2G0lA.png"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">我们在排行榜上排名前10的条目，以及它们的分数。你看这个结果的方式是，比如用户11有190分，用户10有160分，用户7有24分，以此类推。<strong class="bd la">注意，最左边的数字没有意义，只代表结果集中的行号。</strong></figcaption></figure><p id="3808" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解释上述输出的方式是为每个条目分配两行。例如，第1行和第2行分别包含user_id (key)和total points(score)——这转化为<strong class="jp ir"> user_id: 11在此排行榜中有190分</strong>。</p><p id="9bdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要注意的是，在示例中，我们使用了<em class="kx"> zrevrange </em>来获取使用0和9作为参数的前10个条目，但是我们可以在相同的执行时间内获取排行榜的任何范围。</p><p id="1d8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">排序后的集合提供的另一个有用的命令是<em class="kx"> zrevrank </em>(以及相反的<em class="kx"> zrank </em>)，它以一个键作为参数，返回相关的分数。这样做要花O(log(n))时间。因此，zrevrank 构成了我们排行榜的关键部分:我们可以用它来获取任何用户在对数时间内的位置。</p><p id="d82f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们能够在很短的执行时间内获取每个用户的分数，我们只需要获取在排行榜中显示信息所需的额外数据，如用户的姓名和其他可能需要的特定于应用程序的数据(例如，在我们的例子中，我们需要显示用户注册的课程)。由于用户的ID在排序后的集合中是可用的，所以可以使用标准的MySQL查询来检索附加信息(Users表将使用用户ID进行索引，因此读取操作将足够快)。</p><h2 id="3ef1" class="mh kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">缓存用户信息以加快访问速度</h2><p id="b3a2" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">尽管在MySQL中访问用户信息通常很快，但对于一些需要多个连接来获取必要数据的应用程序来说，使用另一种数据结构来提高查询速度可能更方便。我们之前介绍过<strong class="jp ir">哈希</strong>，它们是缓存用户所需的额外数据的绝佳解决方案。</p><p id="14de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哈希唯一的缺点是占用大量内存，所以我们不能一次就把所有用户信息都转储掉。根据排行榜的具体要求，可以采用不同的策略。例如，在我们的实现中，默认情况下只显示排行榜的前20名条目。这是最常见的用例，因此我们希望这些用户的信息在Hash中随时可用。最终，排行榜可能会改变，新用户可能会进入前20名。在这种情况下，新用户的信息被添加到哈希中。</p><h2 id="9afa" class="mh kz iq bd la na nb dn le nc nd dp li jy ne nf lm kc ng nh lq kg ni nj lu nk bi translated">实时访问我们的排行榜</h2><p id="8644" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">实时访问排行榜数据的关键是，一旦排序集的初始设置完成，每次用户在应用程序中获得积分时，都要保持更新。在最简单的实现中，每次在Points表中创建新条目时，都会调用z <em class="kx"> add </em>方法。对于具有大量数据流的应用程序，可能需要利用缓冲区来减少对Redis存储的写入(也可能不需要，这是需要测试的东西。我们的应用程序不需要这样做，它管理了相当大量的数据)。</p><p id="d4a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图概述了如何将所有部分组合在一起，以呈现一个排行榜样本:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/c0c2eeb53e07bdc1e738bbef604f47f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EpPUn4umyjHISSTnzv_sNA.png"/></div></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">这个例子来自一个帝国时代的游戏。在这些游戏中，玩家在很长一段时间内(平均一场游戏40分钟)不断获得积分。注意，这个例子中的N(玩家数量)非常小，所以执行时间会非常好。然而，插入积分表的数据量将是巨大的，从MySQL重新计算排行榜将是不可能的。</figcaption></figure><h1 id="4efa" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的话</h1><p id="ab57" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">非常有趣的是，当有非常简单的解决方案的问题扩展到大量数据时，会变成一个巨大的挑战。当数据流量如此之大时，建议的解决方案的每一步都需要格外小心。我们必须确保数据在合理的执行时间内可用，因此我们的存储必须提供非常快速的读取操作。如果来自应用程序的数据流很大，存储也需要支持快速写入。同时，我们必须注意数据的一致性，因为无论我们检索数据的速度有多快，如果数据不一致，它就变得毫无价值。</p><p id="445a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个快速总结中，我向您展示了如何使用有序集合来实现影子数据结构，以备份您的持久存储，从而为解决游戏行业中一个非常常见的问题提供令人难以置信的执行时间。排序集是使一切成为可能的数据结构，在我们的例子中，我们使用Redis作为实现的方法，尽管其他库，甚至一个定制库，也能提供同样的好处。</p><p id="604d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kx">股票图片由</em><a class="ae mb" href="https://unsplash.com/@crisovalle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="kx">Cris Ovalle</em></a><em class="kx"/><a class="ae mb" href="https://unsplash.com/s/photos/speed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="kx">Unsplash</em></a></p></div></div>    
</body>
</html>