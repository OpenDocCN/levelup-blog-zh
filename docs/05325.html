<html>
<head>
<title>Concurrent programming using Python’s Async IO</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的异步IO进行并发编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/concurrent-programming-using-pythons-async-io-f3f83b0c7544?source=collection_archive---------6-----------------------#2020-08-19">https://levelup.gitconnected.com/concurrent-programming-using-pythons-async-io-f3f83b0c7544?source=collection_archive---------6-----------------------#2020-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a5cd4ab4965a0d3b83506852ed0cd8e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W1zBxRE4AcAL9Dc9iU04ug.png"/></div></div></figure><p id="b215" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很长一段时间，在Python中实现并发性是一项困难的任务。Python开发人员经常不得不使用线程来并发运行任务。然而，随着异步IO的出现，Python大大简化了并发性。</p><p id="3a74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了更好地理解异步IO，我们举个例子。有一个函数将延迟和字符串作为参数。该函数在指定的延迟后每次打印字符串五次。如果我们将2和“First”作为参数传递，那么该函数应该在每次等待2秒后打印“First”五次。</p><h1 id="7c17" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">同步运行这些功能</h1><p id="c9e5" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果我们再次调用这个函数，传递2和" Second "作为参数，我们将首先打印" first "五次，然后" Second "将打印五次。这个程序总共需要20秒钟。我们现在的目标是同时运行这两个，这样“第一个”和“第二个”将几乎同时打印。该程序应该在10秒钟内完成打印。</p><p id="b017" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们试着用Python实现这个函数。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="b5d0" class="ml la it mh b gy mm mn l mo mp">def delayedPrint(delay, text): <br/>  i = 0 <br/>  while(i&lt;5): <br/>    sleep(delay) <br/>    print(text) <br/>    i+=1</span></pre><p id="c84e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们调用<code class="fe mq mr ms mh b">delayedPrint</code>,传递2和“First”作为参数，然后用2和“Second”再次调用它，输出将如下所示。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/99bd2e18f3518a327b3a5811a5d0389d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*-IL_RhwOTcrKIiO2"/></div></figure><p id="5c64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这表明程序正在顺序调用这些函数。现在，让我们试着同时运行它们。为了让它们并发运行，我们必须将<code class="fe mq mr ms mh b">delayedPrint</code>变成一个异步函数。</p><h1 id="ff53" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用异步IO异步运行这些函数</h1><p id="5337" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">从Python 3.7开始，我们有了<code class="fe mq mr ms mh b">async</code>和<code class="fe mq mr ms mh b">await</code>关键字来异步运行函数。要将<code class="fe mq mr ms mh b">delayedPrint</code>声明为异步函数，让我们使用<code class="fe mq mr ms mh b">async</code>关键字。你必须进口。在能够使用<code class="fe mq mr ms mh b">async</code>关键字之前，<code class="fe mq mr ms mh b">asyncio</code>库。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="5d5e" class="ml la it mh b gy mm mn l mo mp">async def delayedPrint(delay, text): <br/>  pass</span></pre><p id="e564" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们称这样的函数为协程。</p><p id="a582" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Python使用事件循环异步运行函数。当调用异步函数时，事件循环运行它。当函数到达一个耗时的任务时，事件循环暂停该函数，并继续执行下一个函数。一旦耗时的任务完成，该功能将恢复运行。</p><h1 id="89eb" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">异步IO中的可用资源</h1><p id="f50a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">耗时的任务被称为“可预见的”。可评估对象可以是协程、任务或未来。<code class="fe mq mr ms mh b">await</code>关键字与awaitables一起使用，告诉事件循环不要在该任务处阻塞，并继续执行下一个函数。</p><p id="649a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的例子中，耗时的任务是睡眠功能。事件循环应该移动到下一个函数，并在两秒钟后返回，而不是在那里等待几秒钟。为了让Python做到这一点，我们需要在sleep函数中使用<code class="fe mq mr ms mh b">await</code>关键字。</p><p id="bcb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，不幸的是，原生睡眠功能不是一个可唤醒的。因此，我们将不得不使用“asyncio”库提供的睡眠功能。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6c16" class="ml la it mh b gy mm mn l mo mp">def delayedPrint(delay, text): <br/>  i = 0 <br/>  while(i&lt;5): <br/>    await asyncio.sleep(delay) <br/>    print(text) <br/>    i+=1</span></pre><p id="8d98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们的异步函数(协程)已经准备好了。但是不能像调用普通函数一样直接调用。要么需要在另一个协程中用awaitable关键字调用它，要么我们应该使用<code class="fe mq mr ms mh b">asyncio.run()</code>来运行它。</p><p id="212d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe mq mr ms mh b">asyncio.run()</code>,我们将只能调用协程一次。因为我们需要调用协程两次，所以我们必须在另一个协程中使用<code class="fe mq mr ms mh b">await</code>关键字来调用它们。因此，让我们创建另一个名为<code class="fe mq mr ms mh b">main</code>的协程，并在其中调用<code class="fe mq mr ms mh b">delayedPrint</code>协程。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="0660" class="ml la it mh b gy mm mn l mo mp">async def main(): <br/>  await delayedPrint(2, "First") <br/>  await delayedPrint(2, "Second")</span></pre><p id="7286" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以使用<code class="fe mq mr ms mh b">asyncio.run()</code>来运行<code class="fe mq mr ms mh b">main</code>协程。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="ec88" class="ml la it mh b gy mm mn l mo mp">asyncio.run(main())</span></pre><p id="7a81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你运行这个程序，你会发现它和我们之前运行的程序没有什么不同。首先，“第一”将被打印五次，然后是“第二”。</p><p id="4782" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是因为两个协程都在一个协程内被调用。当事件循环到达第一个<code class="fe mq mr ms mh b">await</code>命令时，它没有另一个协程可以执行。因此，它在那里暂停，直到第一个协程完成，然后移动到下一个协程。这是同步发生的。</p><h1 id="75fa" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用异步IO中的任务实现并发</h1><p id="33e0" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">为了让<code class="fe mq mr ms mh b">delayedPrint</code>协程并发运行，我们需要将协程封装在任务中。任务用于并发调度协同程序。我们可以使用<code class="fe mq mr ms mh b">asyncio.create_task()</code>方法在任务中包装一个协程。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3c09" class="ml la it mh b gy mm mn l mo mp">async def main(): <br/>  task1=asyncio.create_task(delayedPrint(2, "First")) <br/>  task2=asyncio.create_task(delayedPrint(2, "Second"))</span></pre><p id="2b9c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当我们运行程序时，我们将在控制台中得不到任何输出！发生这种情况是因为这两行一执行完，<code class="fe mq mr ms mh b">main</code>协程就退出了。任务一被调用就开始运行。在第二个任务被调用后，协程退出，结束程序。</p><p id="f56a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了防止这种情况，我们需要等到<code class="fe mq mr ms mh b">task1</code>和<code class="fe mq mr ms mh b">task2</code>完成。为此，我们可以使用<code class="fe mq mr ms mh b">await</code>。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="157a" class="ml la it mh b gy mm mn l mo mp">async def main(): <br/>  task1=asyncio.create_task(delayedPrint(0, "First")) <br/>  task2=asyncio.create_task(delayedPrint(0, "Second")) </span><span id="2a82" class="ml la it mh b gy mu mn l mo mp">  await task1 <br/>  await task2</span></pre><p id="d0ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，<code class="fe mq mr ms mh b">main</code>协程不会退出，直到<code class="fe mq mr ms mh b">task1</code>和<code class="fe mq mr ms mh b">task2</code>完成。同时，这两项任务将同时运行。因此，控制台的输出如下所示。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/b7504c261709a53e7b040e1762ee9f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*rjvFmIlYPy8YytSs"/></div></figure><p id="2135" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与以前不同的是，这里“第一”和“第二”都是一个接一个打印出来的，整个程序只需要大约10秒钟。这是因为两个协同程序同时运行。</p><h1 id="48c1" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用asyncio.gather</h1><p id="0417" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们可以使用<code class="fe mq mr ms mh b">asyncio.gather</code>以更简单的方式编写相同的程序。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="acd5" class="ml la it mh b gy mm mn l mo mp">async def main(): <br/>  await asyncio.gather(delayedPrint(2, "First"), delayedPrint(2, "Second"))</span></pre><p id="1ea7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mq mr ms mh b">asyncio.gather</code>并发运行awaitables。如果可调度的是一个协程，就像这里的情况一样，这个方法会自动将它们调度为任务。</p><p id="357a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在GitHub的可用库<a class="ae mv" href="https://github.com/thivi/pythonAsyncio" rel="noopener ugc nofollow" target="_blank">这里</a>找到上面使用的代码。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="6a1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nd">原载于2020年8月19日</em><a class="ae mv" href="https://www.thearmchaircritic.org/tech-journals/concurrent-programming-using-pythons-async-io" rel="noopener ugc nofollow" target="_blank"><em class="nd"/></a><em class="nd">。</em></p></div></div>    
</body>
</html>