<html>
<head>
<title>Creating an E-commerce Frontend with Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Vue.js创建电子商务前端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-an-e-commerce-frontend-with-vue-js-631870bbae4?source=collection_archive---------17-----------------------#2021-01-25">https://levelup.gitconnected.com/creating-an-e-commerce-frontend-with-vue-js-631870bbae4?source=collection_archive---------17-----------------------#2021-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0893" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第3部分:显示所有图片并上传新图片的图库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5866af2df1a936155a02452adcfe7cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-M2tuc9ArdaQur8A"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">乔·杜德克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="607c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="4205" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">图像是任何电子商务业务中非常重要的一部分。产品图片是最先抓住顾客注意力的东西。我们正在从头开始创建一个<a class="ae ky" href="http://remotedevs.org:8000/" rel="noopener ugc nofollow" target="_blank">电子商务应用</a>。</p><p id="04db" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们有一系列的教程解释它的不同方面，现在是时候设计一个图片库了。我们的图像库将显示所有产品和类别的图像，并为我们提供添加新图像的功能。我们之前使用Vue.js创建了产品和类别显示页面。</p><div class="ms mt gp gr mu mv"><a href="https://medium.com/javascript-in-plain-english/lets-link-product-with-category-for-our-ecommerce-app-28100657a848" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">让我们创建一个Vue.js电子商务应用程序</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">我们将创建一个Vue.js应用程序来显示我们的产品和类别。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">medium.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div><h1 id="754f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">演示</h1><p id="479b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了更好地理解我们将要做的事情，快速浏览一下我们的web应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/17af743433038d6859cf9fbc3425ad05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gdvitOlF0SAfr9CaP85QSw.png"/></div></div></figure><div class="ms mt gp gr mu mv"><a href="http://remotedevs.org:8000/admin/gallery" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">Webtutsplus电子商务应用程序</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">编辑描述</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">remotedevs.org</p></div></div></div></a></div><p id="d599" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们的应用程序前端的存储库可以在<a class="ae ky" href="https://github.com/webtutsplus/ecommerce-vuejs" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="cbf2" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">先决条件</h1><ol class=""><li id="5dd5" class="nx ny it lt b lu lv lx ly ma nz me oa mi ob mm oc od oe of bi translated">JavaScript和Vue.js框架基础知识</li><li id="9f5d" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">代码编辑器(类似于VS代码)</li><li id="7654" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">浏览器(如谷歌浏览器)</li></ol><p id="2292" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">本教程是我们系列的一部分——<a class="ae ky" href="https://nilmadhab.medium.com/" rel="noopener"><strong class="lt iu">前端与Vue.js/JavaScript</strong></a><strong class="lt iu">。</strong>我们将<strong class="lt iu">扩展我们在本系列之前的教程</strong>中开发的代码。所以，如果你对我们之前开发的东西有任何疑问，你可以参考我们之前的教程。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="8971" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">项目结构</h1><p id="d774" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你没有看过我们的<strong class="lt iu">前端with Vue.js </strong>系列之前的教程，不用担心。这部分是专门为你准备的。我们将使用我们在以前的教程中创建的项目结构，所以在添加我们的图库功能之前，让我们先看一下它。这将有助于你更好地理解代码库。</p><p id="5772" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们应用程序的项目结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/dc3b848fd42ce281c38cd7f6ec4cfefb.png" data-original-src="https://miro.medium.com/v2/resize:fit:398/format:webp/1*0n2JGvgpbEflgd0KRifZpw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">项目结构</figcaption></figure><ul class=""><li id="b28b" class="nx ny it lt b lu mn lx mo ma om me on mi oo mm op od oe of bi translated"><strong class="lt iu"> public </strong> —包含我们项目的主HTML文件</li><li id="73eb" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm op od oe of bi translated"><strong class="lt iu"> src/assets </strong> —存储图像、徽标等媒体文件。</li><li id="b569" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm op od oe of bi translated">src/components  —存储我们项目的所有可重用组件。这些组件并不是某些特定路线所独有的。</li><li id="f55c" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm op od oe of bi translated"><strong class="lt iu">src/router</strong>——包含index.js文件，该文件记录了所有路由</li><li id="68fc" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm op od oe of bi translated"><strong class="lt iu"> src/views </strong> —存储所有路由器组件。这些是按照当前路线渲染的组件。</li></ul><p id="51bb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">除此之外，我们还有一些重要的文件</p><ul class=""><li id="13aa" class="nx ny it lt b lu mn lx mo ma om me on mi oo mm op od oe of bi translated">App.vue  —它是我们项目的根组件</li><li id="f0c6" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm op od oe of bi translated"><strong class="lt iu"> main.js </strong> —是我们项目的起点。这里我们导入我们的根组件<strong class="lt iu"> App.vue </strong>，我们的路由器文件<strong class="lt iu"> index.js </strong>和<strong class="lt iu"> createApp </strong>方法。然后，我们将根组件挂载到DOM。</li></ul><h1 id="0019" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">API设计</h1><p id="b294" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们有<a class="ae ky" href="https://medium.com/javarevisited/how-to-develop-file-upload-service-from-scratch-using-java-and-springboot-3a442f4636d5" rel="noopener">这个</a>教程解释我们如何创建我们的文件上传API。使用下面的链接看看我们的应用程序的后端API。</p><div class="ms mt gp gr mu mv"><a href="http://remotedevs.org:8080/api/swagger-ui.html#/" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">Swagger UI</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">后端API</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">remotedevs.org</p></div></div></div></a></div><p id="250c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里使用的<a class="ae ky" href="https://swagger.io/tools/swagger-ui/" rel="noopener ugc nofollow" target="_blank"> Swagger UI </a>允许可视化API及其端点。</p><p id="d4dc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本教程中，我们将与以下端点进行交互。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/7cbbc862ebb1aa8c0b0365965ecfbc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3pE5SFNNQupQC92FhbBCvA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用于处理图像的API端点</figcaption></figure><p id="37f8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当我们发出GET请求从API获取图像时，我们的响应对象将数据存储为一个对象数组，每个对象描述一个单独的图像。GET请求的响应如下所示</p><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="5071" class="ow la it os b gy ox oy l oz pa">[<br/> {<br/>    name: "89516583-5247-42ba-be4f-ae9435e73421.jpg",<br/>    url: "http://remotedevs.org:8080/api/fileUpload/files/89516583-           5247-42ba-be4f-ae9435e73421.jpg"<br/> },<br/> {<br/>    name: "89516583-5247-42ba-be4f-ae9435e73421.jpg",<br/>    url: "http://remotedevs.org:8080/api/fileUpload/files/89516583- 5247-42ba-be4f-ae9435e73421.jpg"<br/> }<br/>]</span></pre><p id="284a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当我们上传图片时，我们必须发送一个<strong class="lt iu"> FormData </strong>对象作为POST请求的主体。这个<strong class="lt iu"> FormData </strong>对象应该有一个名为<em class="pb"> file </em>的键，其值应该是要上传的图像文件。</p><p id="744e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们后端API的基本URL <strong class="lt iu"> </strong>是</p><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="a835" class="ow la it os b gy ox oy l oz pa">http://remotedevs.org:8080/api/</span></pre><p id="143b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个URL存储在每个组件的<code class="fe pc pd pe os b">baseURL</code>数据字段中。例如，为了从我们的后端API获取所有文件，我们将把我们的请求发送到</p><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="50d7" class="ow la it os b gy ox oy l oz pa">this.baseURL + "fileUpload/"</span></pre><h1 id="8b1c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">让我们开始吧</h1><p id="f9aa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你熟悉使用Vue.js或其他前端框架，你会意识到我们使用组件一点一点地制作我们的应用程序。为了更好地理解不同组件之间的交互，我们首先设计一个组件树。因此，我们的图库的组件树如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/97bbd3382acc1c7227eb96774e247dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*Ctb0YwM60X81pAW8Un2dnw.png"/></div></figure><p id="deca" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">绿框代表我们应用程序的根组件。橙色框是路由器视图组件，与一些预定义的路由相关联。蓝色的<code class="fe pc pd pe os b">ImageBox</code>组件表示一个可重用的组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/b9c82a81a9b5bf4686fe617e1ce9e459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lARnKeCeEtr13xVLv3Syfg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">路由器视图</figcaption></figure><ul class=""><li id="f3ee" class="nx ny it lt b lu mn lx mo ma om me on mi oo mm op od oe of bi translated">app . vue——它是我们应用程序的根组件。在<code class="fe pc pd pe os b">App.vue</code>中，我们使用了基于URL路径呈现组件的路由器视图标签。</li><li id="741a" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm op od oe of bi translated"><strong class="lt iu"> Gallery.vue </strong> -这是一个路由器视图组件。在这里，我们显示我们所有的图像，并提供一个按钮到<code class="fe pc pd pe os b">AddImage</code>组件。</li><li id="ff4c" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm op od oe of bi translated"><strong class="lt iu"> AddImage.vue </strong> -它也是一个路由器视图组件。它为我们提供了上传新图像的功能。</li><li id="f947" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm op od oe of bi translated">ImageBox.vue  -这是一个可重用的组件，为我们所有的图像渲染。</li></ul><p id="f011" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以现在，我们有两条新路线添加到我们的<strong class="lt iu"> index.js文件</strong>中。</p><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="8dc2" class="ow la it os b gy ox oy l oz pa">{<br/>  path : '/admin/gallery',<br/>  name : 'Gallery',<br/>  component : Gallery<br/>},<br/>{<br/>  path : '/admin/gallery/add',<br/>  name : 'AddImage',<br/>  component : AddImage <br/>}</span></pre></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="8dd6" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">画廊组件</h1><p id="9a2d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们开始处理<em class="pb">图库</em>组件，首先我们为<code class="fe pc pd pe os b">AddImage</code>路由器视图提供一个按钮。我们将这个按钮放在由<a class="ae ky" href="https://v3.vuejs.org/guide/routing.html#official-router" rel="noopener ugc nofollow" target="_blank"> Vue路由器</a>提供的<code class="fe pc pd pe os b">router-link</code>标签上。接下来，我们必须显示应用程序的所有图像。为此，我们首先必须向后端API发送一个请求来获取所有图像。</p><h2 id="46e1" class="ow la it bd lb ph pi dn lf pj pk dp lj ma pl pm ll me pn po ln mi pp pq lp pr bi translated">获取我们的图像📷</h2><p id="5e62" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在之前的教程中，我们使用了<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取API </a>来发出HTTP请求。但是现在我们将使用<a class="ae ky" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a> HTTP客户端。它为我们提供了Fetch API上的一些附加特性，包括JSON数据的自动转换。还记得在Fetch API中，我们必须在响应中使用异步的<strong class="lt iu"> json() </strong>方法来获取json数据。</p><p id="5486" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们在组件的<code class="fe pc pd pe os b">data()</code>方法中有一个数据字段<code class="fe pc pd pe os b">images</code>。这里声明的数据字段可以在组件的模板中使用。这个<code class="fe pc pd pe os b">images</code>字段将存储我们所有的图像。在开始创建我们的组件时，该字段被设置为<code class="fe pc pd pe os b">null</code>。获取图像后，我们会将它们存储在该数据字段中。因此，让我们看看如何使用Axios发出HTTP请求。</p><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="dc16" class="ow la it os b gy ox oy l oz pa">axios({<br/>   method : "get",<br/>   url : this.baseURL + "fileUpload/"<br/>})<br/>.then(res =&gt; this.images = res.data)<br/>.catch(err =&gt; console.log(err));</span></pre><p id="a109" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们必须调用Axios方法，并传递一个描述请求配置的对象。这里我们提到了请求方法、URL、头、参数、需要发送的数据等细节。为了我们的方便，Axios也提供了一种微型方式来实现相同的任务。</p><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="13a0" class="ow la it os b gy ox oy l oz pa">axios.get(this.baseURL + "fileUpload/")<br/>.then(res =&gt; this.images = res.data)<br/>.catch(err =&gt; console.log(err));</span></pre><p id="3dbc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">发送HTTP请求是一个异步任务，因此axios方法返回一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>。一旦承诺得到解决，我们的服务器做出适当的响应，发送给<code class="fe pc pd pe os b">then</code>方法的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Callback_function" rel="noopener ugc nofollow" target="_blank">回调</a>就会被执行。这个回调获取响应对象作为参数。如前所述，Axios客户端自动转换JSON数据，然后存储在<code class="fe pc pd pe os b">res.data</code>中。在我们的例子中，<code class="fe pc pd pe os b">res.data</code>是一个数组，它存储了描述一个图像的<code class="fe pc pd pe os b">name</code>和<code class="fe pc pd pe os b">url</code>的多个对象。</p><p id="a1f0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当我们没有得到<em class="pb"> OK </em>状态的响应或者在发出请求时出现错误时，就会调用<code class="fe pc pd pe os b">catch</code>方法。</p><p id="4331" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们可以显示我们的图像了。在组件的<code class="fe pc pd pe os b">template</code>中，我们将使用<code class="fe pc pd pe os b">v-for</code>指令遍历所有图像。对于images数组中的每个对象，我们调用<code class="fe pc pd pe os b">ImageBox</code>组件，将对象作为<a class="ae ky" href="https://v3.vuejs.org/guide/component-props.html#props" rel="noopener ugc nofollow" target="_blank">属性</a>传递。<code class="fe pc pd pe os b">ImageBox</code>组件将负责显示图像。</p><p id="89f3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们现在已经完成了我们的<code class="fe pc pd pe os b">Gallery.vue</code>组件。让我们看一下我们的档案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ps pt l"/></div></figure><p id="2789" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意，我们的<a class="ae ky" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#mounted" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">挂载的</strong> </a>生命周期钩子的前几行与用户认证相关。访问画廊页面和上传图像的能力是管理员独有的功能。因此，如果我们没有找到与管理员用户相关联的唯一令牌，这意味着该用户没有登录，我们重定向到<strong class="lt iu">登录</strong>页面。</p><p id="3c2f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了更好地理解身份验证是如何工作的，请看一下介绍其实现的教程。</p><div class="ms mt gp gr mu mv"><a href="https://medium.com/javascript-in-plain-english/creating-an-ecommerce-frontend-with-vue-js-c64481a65941" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">用Vue.js创建电子商务前端</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">第2部分:电子商务应用程序的注册和登录</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">medium.com</p></div></div><div class="ne l"><div class="pu l ng nh ni ne nj ks mv"/></div></div></a></div><p id="f730" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另外，请注意，我已经编写了代码，用于在专用方法<strong class="lt iu"> fetchData </strong>中发出HTTP请求，并从挂载的<strong class="lt iu"> </strong>生命周期钩子中调用它。这样，如果需要的话，我们可以重用这些代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/17af743433038d6859cf9fbc3425ad05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gdvitOlF0SAfr9CaP85QSw.png"/></div></div></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="ea6b" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">ImageBox组件</h1><p id="3ae0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">组件<code class="fe pc pd pe os b">ImageBox</code>从其父组件<code class="fe pc pd pe os b">Gallery</code>接收一个图像作为道具。<code class="fe pc pd pe os b">ImageBox</code>只是显示图像。我们还在图像上添加了一个按钮，将图像地址复制到我们的剪贴板中。只有当我们将鼠标悬停在图像上时，此按钮才可见。</p><p id="8fb0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还使用了<a class="ae ky" href="https://sweetalert.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> Sweetalert </strong> </a>库来替换JavaScript的<strong class="lt iu">“alert”</strong>。这个库为我们提供了一些很酷的可定制的提醒。一旦用户点击<em class="pb">复制地址</em>按钮，就会调用一个方法来处理这个操作。完成后，我们会显示一个<em class="pb"> sweetalert </em>来传达同样的信息。要在您的Vue项目中安装<em class="pb"> Sweetalert </em>，请运行以下命令:</p><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="3e10" class="ow la it os b gy ox oy l oz pa">npm i sweetalert</span></pre><p id="40c6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">之后在<strong class="lt iu"> main.js </strong>文件中添加它的导入语句</p><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="abd8" class="ow la it os b gy ox oy l oz pa"><em class="pb">import</em> swal <em class="pb">from</em> 'sweetalert'</span></pre><p id="2ab6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们可以访问<code class="fe pc pd pe os b">swal()</code>方法，它的工作方式类似于JavaScript提供的<code class="fe pc pd pe os b">alert()</code>方法。这个<code class="fe pc pd pe os b">swal()</code>方法接受一个描述我们的sweetalert的对象。</p><pre class="kj kk kl km gt or os ot ou aw ov bi"><span id="ce77" class="ow la it os b gy ox oy l oz pa">swal({<br/>  text: "Image Address copied to Clipboard!",<br/>  icon: "success",<br/>  closeOnClickOutside: false<br/>});</span></pre><p id="8ced" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是我们如何执行复制到剪贴板的操作呢？要将一些文本复制到我们的剪贴板，我们要做的第一件事就是选择文本。然后我们执行复制操作(Ctrl+C)。</p><p id="ebfc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们的案例中，我们遵循的过程也是类似的。首先，我们创建一个HTML <code class="fe pc pd pe os b">textarea</code>元素。我们将它的值设置为图像的来源。一旦我们创建了元素，我们就把它附加到DOM的某个远程位置(这样它就被隐藏了)。然后我们使用<code class="fe pc pd pe os b">select()</code>方法选择这个元素的文本，并执行<code class="fe pc pd pe os b">document.execCommand(‘copy’)</code>命令。我们现在可以从DOM中移除<code class="fe pc pd pe os b">textarea</code>元素。我们完了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ps pt l"/></div></figure><div class="kj kk kl km gt ab cb"><figure class="pv kn pw px py pz qa paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/ab230620bc1f11588f9b500f7da825dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*WhVQqeTqKyaQUl5UFptmPw.png"/></div></figure><figure class="pv kn qb px py pz qa paragraph-image"><img src="../Images/9a080788cff1e35fbcd7278a810592e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*LpWmUy3MziidRv1Qubd5Fg.png"/><figcaption class="ku kv gj gh gi kw kx bd b be z dk qc di qd qe translated">无悬停和有悬停</figcaption></figure></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="qf pt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">复制图像地址</figcaption></figure></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="6229" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">AddImage组件</h1><p id="00e3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe pc pd pe os b">AddImage</code>组件是一个路由器视图组件。它让我们上传一张新的图像到我们的数据库。这里我们使用了带有类型<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">文件</strong> </a> <strong class="lt iu">，</strong>的输入标签，这让我们可以从本地设备中选择一个文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/d23bfeabe93dae891519e959265059d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*yaaGo0YAvEyG8bVPEMfRMg.png"/></div></figure><p id="acc0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还声明了一个数据字段<strong class="lt iu"> selectedFile </strong>，用于存储我们选择的文件。然后我们将<code class="fe pc pd pe os b">@change</code>事件监听器附加到我们的输入标签上。每当用户选择文件时，无论是第一次还是之后发生更改，都会触发该事件。当这个事件发生时，我们调用方法<strong class="lt iu"> onFileSelected </strong>。该方法接收<strong class="lt iu">事件</strong>对象作为参数。这个事件对象存储我们选择的文件的细节。用户选择的所有文件都存储在<code class="fe pc pd pe os b">event.target.files</code>中，它是一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/FileList" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">文件列表</strong> </a>对象。该对象中存储的每一项都是<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/File" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">文件</strong> </a> <strong class="lt iu"> </strong>类型。最近选择的文件存储在<code class="fe pc pd pe os b">event.target.files[0]</code>中。因此，每次用户更新文件时，我们都会在我们的<strong class="lt iu"> selectedFile </strong>数据字段中反映这些变化。</p><p id="f43a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在当用户点击<em class="pb">上传</em> <strong class="lt iu"> </strong>按钮时，我们调用<strong class="lt iu"> onUpload </strong>方法。这个方法向我们的后端API发出POST请求来添加我们的文件。我们使用了一些if块来验证用户已经选择了一个文件，并且它是<strong class="lt iu"> image/jpeg </strong>类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/09f3f4ed53b374d53c918df7527340d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*1q6TmysvVvS5kcYRCn0e0Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">文件上传API端点</figcaption></figure><p id="99b5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要发送我们的文件，我们必须用一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> FormData </strong> </a>对象来包装它。FormData对象使用表示字段及其值的键值对来表示HTML表单数据。我们的API端点需要一个FormData对象，其文件参数设置为<strong class="lt iu">文件</strong>。因此，一旦我们创建了FormData对象，我们就必须将我们的文件附加到它上面。然后，我们使用axios方法发出POST请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qi"><img src="../Images/2de99e42ce46aa9543aa8b65ee6287e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tPYGChiYdJ9T_L6DO7JOhQ.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ps pt l"/></div></figure><h1 id="5d56" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">恭喜你！！</h1><p id="0301" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">恭喜🎉你已经坚持到了教程的最后。现在我们有了功能齐全的图片库。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="03cb" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">建议的PRs</h1><p id="bb45" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您想为我们的应用前端做出贡献，克隆我们的<a class="ae ky" href="https://github.com/webtutsplus/ecommerce-vuejs" rel="noopener ugc nofollow" target="_blank">库</a>并尝试以下功能</p><ul class=""><li id="ab89" class="nx ny it lt b lu mn lx mo ma om me on mi oo mm op od oe of bi translated">每张图片都有一个从数据库中删除的选项</li></ul><p id="3e6d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">实现该功能后，请将您的PR发送给我们。我们将对其进行审查，并将其合并到我们的主分支中。万事如意！</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="71af" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">资源</h1><ul class=""><li id="8a84" class="nx ny it lt b lu lv lx ly ma nz me oa mi ob mm op od oe of bi translated">Vue . js 3:Vue 3的官方文档</li><li id="60ed" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm op od oe of bi translated"><a class="ae ky" href="https://github.com/webtutsplus/ecommerce-vuejs" rel="noopener ugc nofollow" target="_blank">前端代码</a>:前端代码库的Github repo</li><li id="7fab" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm op od oe of bi translated"><a class="ae ky" href="https://github.com/webtutsplus/ecommerce-backend" rel="noopener ugc nofollow" target="_blank">后端API仓库</a>:后端API代码库的Github repo</li><li id="b3ff" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm op od oe of bi translated">API的Swagger-UI:在这里可视化API</li><li id="f500" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm op od oe of bi translated"><a class="ae ky" href="https://sweetalert.js.org/" rel="noopener ugc nofollow" target="_blank"> Sweetalert </a>:用于定制提醒</li></ul><h2 id="a8be" class="ow la it bd lb ph pi dn lf pj pk dp lj ma pl pm ll me pn po ln mi pp pq lp pr bi translated">感谢您的阅读📙😊</h2></div></div>    
</body>
</html>