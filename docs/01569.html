<html>
<head>
<title>Implementing an LRU Cache With A Doubly Linked List — A Use Case for the ‘Unpopular’ Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用双向链表实现LRU缓存——一个“冷门”数据结构的用例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-an-lru-cache-with-a-doubly-linked-list-a-use-case-for-the-unpopular-data-dea81f2c46f0?source=collection_archive---------12-----------------------#2020-01-13">https://levelup.gitconnected.com/implementing-an-lru-cache-with-a-doubly-linked-list-a-use-case-for-the-unpopular-data-dea81f2c46f0?source=collection_archive---------12-----------------------#2020-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a6d7b078f8a2b5e821ac22e7eb290847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GVz6bLndZHOXqCxtarAVhw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">这是一篮苹果——安妮·斯普拉特在<a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="c3a8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我遇到过一些人，他们说除了列表或者散列映射，他们从来没有真正找到数据结构的用例。很多时候，这导致了不学习这些数据结构和它们如何工作的错误理由。但我也不是圣人。大多数时候，我无法为这些数据结构提供任何令人信服的论据。我是说，如果成功了，为什么还要过度设计呢？</p><p id="6df2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我在解决我的“日常”算法挑战时，我遇到了一个有点令人深思的问题。经过一段时间的头脑风暴和白板讨论，我终于想出了一些办法。我意识到我可以使用双向链表来缓解这个问题。如果我没有学过双向链表是如何工作的，我就不会想到它。</p><p id="6c5a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我与你分享这个挑战，我的思考过程和解决方案。</p><h2 id="7b75" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">这篇文章不会涉及的内容</h2><ul class=""><li id="61b5" class="lu lv jg kf b kg lw kk lx ko ly ks lz kw ma la mb mc md me bi translated">本文没有解释如何实现双向链表。</li><li id="cd3d" class="lu lv jg kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">本文没有展示任何实现代码，尽管我提供了一个到我的实现的链接。</li></ul><h2 id="dcae" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">挑战</h2><p id="e03f" class="pw-post-body-paragraph kd ke jg kf b kg lw ki kj kk lx km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">这个问题是Google问的。</p><p id="0d82" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实现LRU(最近最少使用)缓存。它应该能够使用缓存大小n进行初始化，并包含以下方法:</p><ul class=""><li id="30da" class="lu lv jg kf b kg kh kk kl ko mn ks mo kw mp la mb mc md me bi translated">set(key，value):将key设置为value。如果缓存中已经有n个条目，我们要添加一个新条目，那么它也应该删除最近最少使用的条目。</li><li id="1bb2" class="lu lv jg kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">get(key):获取key处的值。如果不存在这样的键，则返回null。</li></ul><p id="f411" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个操作应该在O(1)时间内运行。</p><p id="3c58" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">【顺便说一句，这些挑战是我订阅了<a class="ae jd" href="https://www.dailycodingproblem.com/" rel="noopener ugc nofollow" target="_blank"><em class="mq"/></a><em class="mq">后每日发给我的。</em></p><h2 id="a77a" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">挑战回顾</h2><p id="f074" class="pw-post-body-paragraph kd ke jg kf b kg lw ki kj kk lx km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">面对这样的挑战，首先想到的自然是使用散列映射来存储数据。这是一个非常合理的猜测。但是当您考虑如何实现最近最少使用的部分时，真正的挑战出现了。当缓存已满时，我们如何用新的键-值对替换最近最少使用的数据？</p><p id="66a1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我马上想到，我们必须存储一些元数据。该元数据将保存关于最后一次使用键-值对的时间的信息。比方说，对于每个键值对，我们存储它最后一次被使用的时间。当需要删除最近最少使用的数据时，我们必须遍历所有数据，找到最后使用时间最早的数据。这种解决方案效率不高，甚至无法应对挑战。</p><p id="8b2d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了提高效率，我们使用了一个巧妙的双向链表。现在我们知道双向链表中的每个节点都可以访问它的前一个和下一个节点。如果我们使用双向链表来保存每个数据最后被使用的顺序，那么头部将总是最近最少被使用的。但是我们还有一个问题。</p><p id="a709" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在链表中找到一个条目，我们需要遍历链表。这是我们扭转的地方。我们没有保存每个键值对最后一次使用的时间，而是将它的节点作为元数据保存在双向链表中。通过保存节点，我们总是可以访问它在列表中的位置，从而消除了对循环的需要。从那里开始，一切都井井有条了。我们只需要把最后访问的数据一直移到双向链表的后面(尾部)，头部永远是最近最少使用的。</p><h2 id="c804" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">该算法</h2><p id="d802" class="pw-post-body-paragraph kd ke jg kf b kg lw ki kj kk lx km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">在给出步骤之前，让我详细说明一下数据将如何存储。将有两种数据结构；</p><ul class=""><li id="a011" class="lu lv jg kf b kg kh kk kl ko mn ks mo kw mp la mb mc md me bi translated">Dictionary:存储键值对和元数据。</li><li id="372b" class="lu lv jg kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">双向链表:存储项目最后被访问的顺序。每个节点的值将是其表示的键-值对的键。</li></ul><p id="e6b7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">设定</strong>:</p><ul class=""><li id="6d44" class="lu lv jg kf b kg kh kk kl ko mn ks mo kw mp la mb mc md me bi translated">如果字典中已经存在该键，则替换该值，不做任何其他事情。</li><li id="c94a" class="lu lv jg kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">如果存储在缓存中的数据数量等于设置的限制，则使用存储在链表头中的值，从字典中删除相应的键-值对。也删除链表的头。</li><li id="bd60" class="lu lv jg kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">在链表前添加一个新节点。新节点的值必须是新的键-值对的键。</li><li id="0804" class="lu lv jg kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">在对象中，存储新添加的节点(元数据)和值(数据)。该对象将作为新值保存在字典中。下面是保存三个键值对后的数据表示。</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="8b6c" class="lb lc jg mw b gy na nb l nc nd">LinkedList = Node(key3) &lt;-&gt; Node(key2) &lt;-&gt; Node(key1)</span><span id="a7bf" class="lb lc jg mw b gy ne nb l nc nd">dictionary = {<br/>    "key1": {<br/>        "data": value1,<br/>        "metadata": Node(key1),<br/>    }<br/>    "key2": {<br/>        "data": value2,<br/>        "metadata": Node(key2),<br/>    }<br/>    "key3": {<br/>        "data": value3,<br/>        "metadata": Node(key3),<br/>    }<br/>}</span></pre><p id="b126" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">得到</strong>:</p><ul class=""><li id="53ac" class="lu lv jg kf b kg kh kk kl ko mn ks mo kw mp la mb mc md me bi translated">从字典中获取键的相应值(保存的对象)。</li><li id="d4f5" class="lu lv jg kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">从双向链表中删除节点(保存对象的元数据)。这通常是通过将前一个节点指向下一个节点并将下一个节点指向前一个节点来完成的。</li><li id="5c4a" class="lu lv jg kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">用这个键创建一个新节点，就像在<code class="fe nf ng nh mw b">set</code>中所做的那样。但是这一次，把它附加到双向链表中。新节点将成为双向链表的尾部。换句话说，把新节点移到后面。</li><li id="c895" class="lu lv jg kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">用新节点替换元数据。</li></ul><h2 id="7ab0" class="lb lc jg bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">结论</h2><p id="2881" class="pw-post-body-paragraph kd ke jg kf b kg lw ki kj kk lx km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我的实现只是双向链表的众多用例之一，它有助于提高效率。</p><p id="359b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读。您可能会在本文中发现一个错误，或者意识到我的解决方案可以改进。我邀请您发送回复，以便我们可以开始讨论。您也可以通过twitter 联系我进行进一步的讨论。</p><div class="ip iq gp gr ir ni"><a href="https://github.com/IyiKuyoro" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd jh gy z fp nn fr fs no fu fw jf bi translated">IyiKuyoro —概述</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">在GitHub上注册您自己的个人资料，这是托管代码、管理项目和与40…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ix ni"/></div></div></a></div></div></div>    
</body>
</html>