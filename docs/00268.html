<html>
<head>
<title>Async/Await vs Promises — A Guide and Cheat Sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步/等待vs承诺—指南和备忘单</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/async-await-vs-promises-4fe98d11038f?source=collection_archive---------0-----------------------#2018-11-28">https://levelup.gitconnected.com/async-await-vs-promises-4fe98d11038f?source=collection_archive---------0-----------------------#2018-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d394" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的第一份全职工作是软件工程师，已经工作了几个月了(这是一个值得庆祝的时刻:🎉 🤓)在现实世界中，我首先处理的事情之一就是async/await。</p><p id="1c28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我觉得我对JavaScript 中的<a class="ae kl" href="https://medium.com/@kvosswinkel/is-javascript-synchronous-or-asynchronous-what-the-hell-is-a-promise-7aa9dd8f3bfb" rel="noopener">异步工作流有了很好的理解，并且已经做了很多承诺，但是我在切换到async/await时遇到了一些困惑，所以我整理了一个指南和备忘单来说明两者之间的区别。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4850fc7e67e123df1c7df4f24ed012c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAFctUA8useVWRbC-nWhBA.png"/></div></div></figure><blockquote class="ky kz la"><p id="ff2e" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated"><strong class="jp ir">关于语法糖的一个提示:</strong>在我们开始之前，重要的是要提到async/await只是一个重新设计代码的包装器，使承诺在某些情况下更容易阅读和使用。在其核心，async/await仍然使用承诺。如果您不确定承诺是如何工作的，或者需要更好地理解JavaScript中的异步，请查看<a class="ae kl" href="https://medium.com/@kvosswinkel/is-javascript-synchronous-or-asynchronous-what-the-hell-is-a-promise-7aa9dd8f3bfb" rel="noopener">这篇概述</a>。</p></blockquote><p id="9b15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">示例时间。假设我们想用一个承诺来打印一个字符串。我们将通过用我们的字符串记录一条消息来解析这个承诺，如果我们得到的不是字符串，我们将拒绝这个承诺。这很傻，但它能很清楚地说明我们在做什么:</p><pre class="kn ko kp kq gt lf lg lh li aw lj bi"><span id="2ccf" class="lk ll iq lg b gy lm ln l lo lp">const returnsAPromise = function(string) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    if (typeof string === 'string') {<br/>      resolve(`${string} is a resolved promise now`);<br/>    } else {<br/>      reject('Not a string!');<br/>    }<br/>  });<br/>};</span></pre><p id="6cc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想要一个稍微实用一点的例子，可以看看这个异步调用数据库的小要点:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h1 id="9035" class="ls ll iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">范围</h1><p id="54e9" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">我注意到承诺和async/await之间最大的区别是异步的范围。</p><h2 id="b0c2" class="lk ll iq bd lt mu mv dn lx mw mx dp mb jy my mz mf kc na nb mj kg nc nd mn ne bi translated">承诺</h2><p id="537a" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">如果我们使用我们的承诺返回函数，并将结果保存在一个标准的承诺链中，它将类似于下面的函数。这里的异步都包含在承诺链中。像任何回调一样运行，同步运行。在<code class="fe nf ng nh lg b">returnsAPromise</code>解析之前，我们的最后一个日志将打印“我在这里同步运行”。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ni"><img src="../Images/84e3d3b43fd8de62cc81d303f8a6d7fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xt_kSc5t1QH8oeF4GeIZew.jpeg"/></div></div></figure><h2 id="3637" class="lk ll iq bd lt mu mv dn lx mw mx dp mb jy my mz mf kc na nb mj kg nc nd mn ne bi translated">异步/等待</h2><p id="35a8" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">现在，使用async/await，我们的代码可能看起来像下面的函数。在我们的async/await版本中，我们必须使我们的<em class="lb">整个包装函数</em>异步。这有几个影响——现在，<code class="fe nf ng nh lg b">myAsyncFunction</code>返回一个承诺，我们想要运行的任何同步代码都必须完全从函数中取出。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nj"><img src="../Images/fdd80f1ec99c9b1d558ceda2bc0ff401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ktmJ30vivdMsrAgHwtuynw.jpeg"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><a class="ae kl" href="https://gist.github.com/k-vosswinkel/53329056e449da640b9598a6d1b8990c" rel="noopener ugc nofollow" target="_blank">查看代码片段的要点</a></figcaption></figure><h1 id="0c72" class="ls ll iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">逻辑流程</h1><p id="3cef" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">因为promise chains和async/await之间的范围略有变化，所以我们可以看到代码的逻辑也将发生变化。说明这种方法转变的一个很好的方式是，看看这两种方法是如何解决多重承诺的。我们再用<code class="fe nf ng nh lg b">returnsAPromise</code>吧。</p><h2 id="4132" class="lk ll iq bd lt mu mv dn lx mw mx dp mb jy my mz mf kc na nb mj kg nc nd mn ne bi translated">承诺</h2><p id="2a5f" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">要使用承诺链解决多个承诺，我们可以使用<code class="fe nf ng nh lg b">Promise.all()</code> <em class="lb"> : </em></p><pre class="kn ko kp kq gt lf lg lh li aw lj bi"><span id="8892" class="lk ll iq lg b gy lm ln l lo lp">const myFirstString = "Kait's first string";<br/>const mySecondString = "Kait's second string";</span><span id="a782" class="lk ll iq lg b gy no ln l lo lp">// Operation A &amp; Operation B can run in parallel<br/>Promise.all([returnsAPromise(str1), returnsAPromise(str2)])<br/> .then(res =&gt; {<br/>   // Operation C needs info from Operations A &amp; B<br/>   console.log(`Promise.all() gives us an array: ${res}`)   <br/>})</span></pre><h2 id="fe78" class="lk ll iq bd lt mu mv dn lx mw mx dp mb jy my mz mf kc na nb mj kg nc nd mn ne bi translated">异步/等待</h2><p id="1d8e" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">要使用async/await解析多个承诺，我们可以简单地等待两个承诺，将结果存储在变量中，稍后在代码块中使用它们。</p><pre class="kn ko kp kq gt lf lg lh li aw lj bi"><span id="1076" class="lk ll iq lg b gy lm ln l lo lp">const multipleAwaits = async (str1, str2) =&gt; {<br/>  // Operation A runs<br/>  const promiseResult1 = await returnsAPromise(str1); <br/>  // Then Operation B runs<br/>  const promiseResult2 = await returnsAPromise(str2);<br/>    <br/>  // Then, Operation C runs<br/>  console.log(`With multiple awaits, we can use the variables <br/>  directly: ${promiseResult1} AND ${promiseResult2}`);<br/>}<br/>multipleAwaits(myFirstString, mySecondString);</span></pre><blockquote class="ky kz la"><p id="7212" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated"><strong class="jp ir">关于Promise.all() </strong>的说明:使用多个await语句与我们的promise chain方法略有不同。在这里，操作B将等待操作a的完成。如果你真的希望你的承诺同时运行，你仍然可以使用Promise.all()和你的异步函数，并使用<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">数组析构</a>来获取结果。它看起来像这样:</p></blockquote><pre class="kn ko kp kq gt lf lg lh li aw lj bi"><span id="9ac2" class="lk ll iq lg b gy lm ln l lo lp">const multipleAwaits = async (str1, str2) =&gt; {<br/>  // Operation A &amp; Operation B can run in parallel<br/>  const [promiseResult1, promiseResult2] = await  <br/>    Promise.all([returnsAPromise(str1), returnsAPromise(str2)]);<br/>    <br/>  // Then, Operation C runs<br/>  console.log(`With multiple awaits, we can use the variables <br/>  directly: ${promiseResult1} AND ${promiseResult2}`);<br/>}<br/>multipleAwaits(myFirstString, mySecondString);</span></pre><h1 id="ba40" class="ls ll iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">使用Catch &amp; Finally处理错误</h1><p id="f24e" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">promises和async/await的错误处理非常相似。对于成功解决的承诺，我们将使用<code class="fe nf ng nh lg b">then</code>或<code class="fe nf ng nh lg b">try</code>。对于拒绝的承诺，我们将使用<code class="fe nf ng nh lg b">catch</code>。对于我们希望在承诺被处理后运行的代码，不管它是被解决还是被拒绝，我们将使用<code class="fe nf ng nh lg b">finally</code>:</p><h2 id="1f6f" class="lk ll iq bd lt mu mv dn lx mw mx dp mb jy my mz mf kc na nb mj kg nc nd mn ne bi translated">承诺</h2><pre class="kn ko kp kq gt lf lg lh li aw lj bi"><span id="96ed" class="lk ll iq lg b gy lm ln l lo lp">let isOurPromiseFinished = false;<br/>returnsAPromise(str)<br/>  .then(res =&gt; {<br/>    // If the promise resolves, we enter this code block<br/>    console.log(`using promise chains, ${res}`);<br/>  })<br/>  .catch(err =&gt; {<br/>    /* If the promise rejects, or if any of the code in our .then <br/>    statement throws, we enter this code block */<br/>    console.log(err);<br/>  })<br/>  .finally(() =&gt; {<br/>    /* This is for code that doesn't rely on the outcome of the <br/>    promise but still needs to run once it's handled */<br/>  isOurPromiseFinished = true;   <br/> })</span></pre><h2 id="b249" class="lk ll iq bd lt mu mv dn lx mw mx dp mb jy my mz mf kc na nb mj kg nc nd mn ne bi translated">异步/等待</h2><pre class="kn ko kp kq gt lf lg lh li aw lj bi"><span id="de0f" class="lk ll iq lg b gy lm ln l lo lp">let isOurPromiseFinished = false;</span><span id="e0ac" class="lk ll iq lg b gy no ln l lo lp">const myAsyncAwaitBlock = async (str) =&gt; {<br/>  try {<br/>    // If the promise resolves, we enter this code block<br/>    const myPromise = await returnsAPromise(str);<br/>    console.log(`using async/await, ${res}`);<br/>  } catch(err) {<br/>    // If the promise rejects, we enter this code block<br/>    console.log(err);<br/>  } finally {<br/>    /* This is for code that doesn't rely on the outcome of the    <br/>    promise but still needs to run once it's handled */<br/>    isOurPromiseFinished = true;<br/>  }<br/>}<br/>myAsyncAwaitBlock(myFirstString);</span></pre><h1 id="0c6c" class="ls ll iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">摘要</h1><h2 id="9f81" class="lk ll iq bd lt mu mv dn lx mw mx dp mb jy my mz mf kc na nb mj kg nc nd mn ne bi translated">但是真的…我该用哪一个呢？？？</h2><p id="ec7d" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">虽然承诺链和async/await都是建立在承诺之上的，但是它们之间的语法差异会对代码的逻辑和布局产生真正的影响。</p><p id="f891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你试图快速简洁地从承诺中获得结果，用一两种不同的方式使用它们，承诺链可能仍然是一个不错的选择。当一个简单的<code class="fe nf ng nh lg b">.then</code>就可以了，承诺链将允许你避免写一堆不必要的包装函数。</p><p id="df7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您发现自己正在编写又长又复杂的<code class="fe nf ng nh lg b">.then</code>语句，Async/await是一个很好的选择。Async/await将允许您将其整理成一个可读的异步回调函数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e693930ec75901e93b5740e785c931c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*CEJTKx7lUjf-1LaZsn8D1w.gif"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">猫税。</figcaption></figure></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nj"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="nx ny gp gr nz oa"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd ir gy z fp of fr fs og fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">前45名React教程。课程由开发人员提交并投票，使您能够找到最佳反应…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">gitconnected.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo kw oa"/></div></div></a></div></div></div>    
</body>
</html>