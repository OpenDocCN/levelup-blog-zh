<html>
<head>
<title>Practical DDD in Golang: Domain Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗实用DDD:域名服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-ddd-in-golang-domain-service-4418a1650274?source=collection_archive---------1-----------------------#2021-08-31">https://levelup.gitconnected.com/practical-ddd-in-golang-domain-service-4418a1650274?source=collection_archive---------1-----------------------#2021-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c4f3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">领域驱动设计</h2><div class=""/><div class=""><h2 id="e0d4" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Go中DDD的故事继续呈现了无状态构建块之一——域服务。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/9000145ba867c4ff59f2469302e069e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GeYP_SK5BtgSzcey1Bc23A.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@nate_dumlao" rel="noopener ugc nofollow" target="_blank">内森·杜姆劳</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="522a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在讨论了实体和值对象之后，我将在本文中介绍一组领域建模模式中的第三个。它的名字是域名服务。</p><p id="b95b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">服务可能是最被滥用的DDD模式。对域服务目的的误解来自许多不同的web框架。在大多数框架中，服务就是一切。</p><p id="154f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它是为了保持业务逻辑。它创建UI组件，如表单域。它处理会话和HTTP请求。有时它只是扮演一个巨大的“utils”类的角色。有时保留最简单的值对象可以拥有的代码。定期执行数据库迁移。</p><p id="709b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的例子几乎都不是域服务的一部分。直到本文结束，我会尽量更好地解释它的用途和用法。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="09fc" class="mj mk it mf b gy ml mm l mn mo">Other articles from DDD series:</span><span id="423c" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="a66b" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span></pre><h1 id="1ebe" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">它代表行为</h1><p id="2b33" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">域服务代表来自<a class="ae lh" href="https://www.definitions.net/definition/problem+domain" rel="noopener ugc nofollow" target="_blank">问题域</a>的行为。它为过于复杂而无法存储在单个实体或值对象中的业务不变量提供了解决方案。</p><p id="5f0b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时，一个特定的行为可能与多个实体或值对象交互。在这些情况下，很难找到该行为属于哪个实体。当遇到这种情况时，域服务就是解决方案。</p><blockquote class="nm nn no"><p id="2780" class="li lj np lk b ll lm kd ln lo lp kg lq nq ls lt lu nr lw lx ly ns ma mb mc md im bi translated">域服务不处理会话或请求。它对UI组件一无所知。它不执行数据库迁移。它不验证用户输入。域服务只管理业务逻辑。</p></blockquote><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">域服务的示例</figcaption></figure><p id="cf0c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的例子中，有一个<code class="fe nv nw nx mf b">ExchangeRateService</code>的情况。每当我提供一些应该注入到另一个对象内部的无状态结构时，我就定义了一个接口。它有助于稍后的单元测试。</p><p id="f368" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该服务处理货币兑换的完整业务逻辑。它包含<code class="fe nv nw nx mf b">ExchangeRateRepository</code>来获取所有的利率，因此它可以转换任何金额的货币。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">一个行为复杂的案例</figcaption></figure><p id="4318" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如前所述，域服务包含的业务不变量太复杂，无法存储在单个实体或值对象中。在上面的例子中，<code class="fe nv nw nx mf b">CasinoService</code>持有复杂的逻辑，每当有来自某个<code class="fe nv nw nx mf b">Account</code>的新赌注时就应用<code class="fe nv nw nx mf b">Bonuses</code>。</p><p id="873e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们应该创建一个域服务，而不是强迫<code class="fe nv nw nx mf b">Account</code>或<code class="fe nv nw nx mf b">Bonus</code>实体相互依赖，或者更糟糕的是，为实体的方法提供预期的存储库或服务。该服务可以封装完整的业务逻辑，用于将<code class="fe nv nw nx mf b">Bonuses</code>应用于任何必要的<code class="fe nv nw nx mf b">Account</code>。</p><h1 id="72e9" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">它代表合同</h1><p id="cf80" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">有时候，我们的<a class="ae lh" href="https://martinfowler.com/bliki/BoundedContext.html" rel="noopener ugc nofollow" target="_blank">有界上下文</a>依赖于其他的。一个典型的例子是一个微服务集群，其中一个微服务通过REST API访问另一个微服务。</p><p id="446f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在大多数情况下，从外部API接收的数据对于初始有界上下文的工作至关重要。因此，在我们的领域层中，我们应该能够访问这些数据。</p><blockquote class="nm nn no"><p id="2a79" class="li lj np lk b ll lm kd ln lo lp kg lq nq ls lt lu nr lw lx ly ns ma mb mc md im bi translated">我们必须始终将领域层从技术细节中分离出来。这意味着，如果我们将外部API或数据库集成到我们的业务逻辑中，就会产生代码味道。</p></blockquote><p id="7d6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，域服务进入适当的位置。在领域层，我总是为服务提供一个接口，作为外部集成的契约。然后，我们可以在我们的业务逻辑中注入该接口，但是实现是在基础设施层。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">作为契约的域服务</figcaption></figure><p id="7df1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，我在域层定义了<code class="fe nv nw nx mf b">AccountService</code>接口。它表示其他域服务可以调用的契约。但是，我们以<code class="fe nv nw nx mf b">AccountAPIService</code>的形式提供实现。</p><p id="f378" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx mf b">AccountAPIService</code>向外部<a class="ae lh" href="https://financesonline.com/what-are-examples-of-crm-different-tool-types-you-should-know-about/" rel="noopener ugc nofollow" target="_blank"> CRM系统</a>或我们内部的微服务发送HTTP请求，专用于<code class="fe nv nw nx mf b">Accounts</code>。我们可以为<code class="fe nv nw nx mf b">AccountService</code>提供一个额外的实现，它将使用这种方法在一个隔离的测试环境中与来自一个文件的测试<code class="fe nv nw nx mf b">Accounts</code>一起工作。</p><h1 id="bcdb" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">无国籍的</h1><p id="8806" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated"><strong class="lk jd">域服务不能保持状态。域服务也不能包含任何具有状态的字段。</strong></p><p id="6f4f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个规律可能是显而易见的，但不幸的是，事实并非如此。根据每个开发人员的背景，他们中的一些人拥有使用为每个请求运行独立流程的语言进行web开发的经验。</p><p id="2609" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，服务是否包含状态并不重要。但是，当您使用Go时，您可能会为整个应用程序使用一个域服务实例。因此，您可以想象如果许多不同的客户端访问内存中的同一个值会发生什么。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">域服务与实体和值对象的比较</figcaption></figure><p id="e957" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们在上面的例子中看到的，实体和值对象持有状态。实体可以在运行时改变状态，而值对象总是保持不变。当我们需要一个新的值对象时，我们创建一个新的值对象。</p><p id="b2f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">域服务不包含任何有状态的对象。它只保存其他无状态的结构，比如存储库、其他服务、工厂、配置值。它可以启动一个状态的创建或它的持续，但它不持有它。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">在域服务中存储状态的错误方法</figcaption></figure><p id="aa15" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，<code class="fe nv nw nx mf b">TransactionService</code>以<code class="fe nv nw nx mf b">Money</code>值对象的形式保存一个有状态字段。每当我们想要进行新的存款时，我们执行应用<code class="fe nv nw nx mf b">Bonuses</code>的逻辑，然后将其添加到最终结果中，最终结果是服务中的一个字段。</p><p id="6c97" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种做法是错误的。无论何时，只要有人存款，结果就会改变。我们不想这样做，但是要按照<code class="fe nv nw nx mf b">Account</code>保持这种总结。相反，我们应该将计算结果作为方法的结果返回，如下例所示。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">从域服务返回状态的正确方法</figcaption></figure><p id="69c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">新的<code class="fe nv nw nx mf b">TransactionService</code>总是产生最新的计算结果，而不是把它们存储在里面。不同的用户不能共享内存中的同一个对象，域服务可以再次像单个实例一样工作。</p><p id="1755" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个服务的客户端现在负责保存新的结果，并在发生存款时刷新它。</p><h1 id="d3cf" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">域名服务与其他类型的服务</h1><p id="32cd" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">到目前为止，提供域服务的理由是很清楚的。但是，在某些情况下，不清楚某些服务是否也是域服务。或者更好地说，服务属于哪一层？</p><p id="e03a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基础设施服务是最容易识别的。它们总是包含技术细节、与数据库的集成或外部API。在大多数情况下，它们是来自其他层的接口的实际实现。</p><p id="56e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">表象服务也很容易识别。它们总是提供一些与UI组件或验证用户输入相关的逻辑。<a class="ae lh" href="https://symfony.com/doc/current/forms.html" rel="noopener ugc nofollow" target="_blank">表单服务</a>就是一个典型的例子。</p><p id="eb74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当要区分应用程序和域服务时，问题就出现了。我发现很难区分这两种类型。</p><p id="e735" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据我的经验，我使用应用程序服务只是为了提供处理会话或请求的一般逻辑。将授权和访问权限放在应用层中也很好。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">应用服务的一个例子</figcaption></figure><p id="df68" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在许多情况下，我将应用服务作为域服务的包装结构。每当我想在会话中缓存一些东西并使用域服务作为数据的后备时，我就使用这种方法。这种方法你可以在上面的例子中找到。</p><p id="f606" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在那里，<code class="fe nv nw nx mf b">AccountSessionService</code>是一个应用服务，它从领域层包装了<code class="fe nv nw nx mf b">AccountService</code>。它负责从会话存储中提取一个值，然后使用它在下面的服务中查找<code class="fe nv nw nx mf b">Account</code>细节。</p><h1 id="61f6" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">结论</h1><p id="4894" class="pw-post-body-paragraph li lj it lk b ll nh kd ln lo ni kg lq lr nj lt lu lv nk lx ly lz nl mb mc md im bi translated">域服务代表了一种无状态的结构，它提供了真实商业世界中的行为。它与许多不同的对象交互，如实体和值对象。这需要它们的复杂行为，或者至少是我们不知道它们属于哪里的行为。</p><p id="0a22" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">域服务与其他层的服务没有任何相似之处，除了名称。它只与业务逻辑相关，不应该与技术细节、会话、请求或任何其他特定于应用程序的细节相联系。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="915f" class="mj mk it mf b gy ml mm l mn mo">Other articles from DDD series:</span><span id="2844" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="8722" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span></pre><h1 id="71db" class="mq mk it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">有用的资源:</h1><ul class=""><li id="7386" class="ny nz it lk b ll nh lo ni lr oa lv ob lz oc md od oe of og bi translated"><a class="ae lh" href="https://martinfowler.com/" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/</a></li><li id="3832" class="ny nz it lk b ll oh lo oi lr oj lv ok lz ol md od oe of og bi translated"><a class="ae lh" href="https://www.domainlanguage.com/" rel="noopener ugc nofollow" target="_blank">https://www.domainlanguage.com/</a></li></ul></div></div>    
</body>
</html>