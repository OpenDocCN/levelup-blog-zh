<html>
<head>
<title>Using Generators in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用生成器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-generators-in-javascript-157420258408?source=collection_archive---------0-----------------------#2019-11-06">https://levelup.gitconnected.com/using-generators-in-javascript-157420258408?source=collection_archive---------0-----------------------#2019-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/06958f6c7287d64fd0ecd5858bc61c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1Kt2pcrAQAISpQhd"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@karsten_wuerth?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡斯滕·伍尔特(@karsten.wuerth) </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="bd23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，生成器是返回生成器对象的特殊函数。生成器对象包含可迭代对象的<code class="fe le lf lg lh b">next</code>值。它用于让我们通过在一个<code class="fe le lf lg lh b">for...of</code>循环中使用generator函数来遍历一个对象集合。这意味着返回的生成器函数符合iterable协议。</p><h1 id="8b82" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">同步发电机</h1><p id="b542" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">任何符合iterable协议的东西都可以被一个<code class="fe le lf lg lh b">for...of</code>循环遍历。像<code class="fe le lf lg lh b">Array</code>或<code class="fe le lf lg lh b">Map</code>这样的对象符合这个协议。生成器函数也符合迭代器协议。这意味着它以标准的方式产生一系列值。它实现了<code class="fe le lf lg lh b">next</code>函数，该函数返回一个对象至少两个属性— <code class="fe le lf lg lh b">done</code>和<code class="fe le lf lg lh b">value</code>。<code class="fe le lf lg lh b">done</code>属性是一个布尔值，它返回迭代器超过迭代序列末尾的<code class="fe le lf lg lh b">true</code>。如果它能产生序列中的下一个项目，那么它就是<code class="fe le lf lg lh b">false</code>。<code class="fe le lf lg lh b">value</code>是迭代器返回的项。如果<code class="fe le lf lg lh b">done</code>是<code class="fe le lf lg lh b">true</code>，那么<code class="fe le lf lg lh b">value</code>可以省略。<code class="fe le lf lg lh b">next</code>方法总是返回具有上述两个属性的对象。如果返回非对象值，那么<code class="fe le lf lg lh b">TypeError</code>将被抛出。</p><p id="176b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了编写一个生成器函数，我们使用下面的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="12ca" class="mt lj it lh b gy mu mv l mw mx">function* strGen() { <br/>  yield 'a';<br/>  yield 'b';<br/>  yield 'c';<br/>}<br/><br/>const g = strGen();<br/>for (let letter of g){<br/>  console.log(letter)<br/>}</span></pre><p id="62f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">function关键字后的星号表示该函数是一个生成器函数。生成器函数将只返回生成器对象。使用生成器函数，<code class="fe le lf lg lh b">next</code>函数是自动生成的。生成器还有一个<code class="fe le lf lg lh b">return</code>函数返回给定值并结束生成器，还有一个<code class="fe le lf lg lh b">throw</code>函数抛出错误并结束生成器，除非在生成器中捕获到错误。为了从生成器返回下一个值，我们使用了<code class="fe le lf lg lh b">yield</code>关键字。每次调用<code class="fe le lf lg lh b">yield</code>语句时，发生器暂停，直到再次请求<code class="fe le lf lg lh b">next</code>值。</p><p id="302d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当执行上述示例时，我们记录了‘a’、‘b’和‘c’，因为生成器在<code class="fe le lf lg lh b">for...of</code>循环中运行。每次运行时，调用下一个<code class="fe le lf lg lh b">yield</code>语句，从<code class="fe le lf lg lh b">yield</code>语句列表中返回下一个值。</p><p id="cc31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以编写一个生成器来生成无限个值。我们可以在生成器内部建立一个无限循环来不断返回新值。因为<code class="fe le lf lg lh b">yield</code>语句直到请求下一个值时才运行，所以我们可以保持无限循环运行，而不会使浏览器崩溃。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6a65" class="mt lj it lh b gy mu mv l mw mx">function* genNum() {<br/>  let index = 0;<br/>  while(true){<br/>    yield index += 2;<br/>  }<br/>}</span><span id="3576" class="mt lj it lh b gy my mv l mw mx">const gen = genNum();<br/>console.log(<!-- -->gen<!-- -->.next().value);<br/>console.log(<!-- -->gen<!-- -->.next().value);<br/>console.log(<!-- -->gen<!-- -->.next().value);</span></pre><p id="563e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，我们可以使用一个循环来重复运行<code class="fe le lf lg lh b">yield</code>。<code class="fe le lf lg lh b">yield</code>语句必须在代码的顶层运行。这意味着它们不能嵌套在另一个回调函数中。<code class="fe le lf lg lh b">next</code>函数自动包含在生成器对象中，该对象用于从生成器中获取下一个值。</p><p id="d237" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">迭代器结束时，调用<code class="fe le lf lg lh b">return</code>方法。也就是说，当获得最后一个值时，或者当用<code class="fe le lf lg lh b">thrown</code>方法抛出一个错误时。如果我们不想让它结束，我们可以将<code class="fe le lf lg lh b">yield</code>语句包装在<code class="fe le lf lg lh b">try...finally</code>子句中，如下面的代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b1a2" class="mt lj it lh b gy mu mv l mw mx">function*<!-- --> <!-- -->genFn()<!-- --> <!-- -->{<br/>  <!-- -->try<!-- --> <!-- -->{<br/>    <!-- -->yield;<br/>  <!-- -->}<!-- --> <!-- -->finally<!-- --> <!-- -->{<br/>    <!-- -->yield<!-- --> <!-- -->'Keep running';<br/>  <!-- -->}<br/>}</span></pre><p id="9de5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当运行生成器时调用<code class="fe le lf lg lh b">throw</code>方法，错误将停止生成器，除非在生成器函数中捕获到错误。为了捕捉、抛出和捕获错误，我们可以编写类似下面的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="32ab" class="mt lj it lh b gy mu mv l mw mx">function*<!-- --> <!-- -->genFn()<!-- --> <!-- -->{<br/>  <!-- -->try<!-- --> <!-- -->{<br/>    <!-- -->console.log('Start');<br/>    <!-- -->yield;<!-- --> <em class="mz">// (A)</em><br/>  <!-- -->}<!-- --> <!-- -->catch<!-- --> <!-- -->(error)<!-- --> <!-- -->{<br/>    <!-- -->console.log(`Caught: ${error}`);<br/>  <!-- -->}<br/>}</span><span id="83ac" class="mt lj it lh b gy my mv l mw mx">const g = genFn();<br/>g.next();<br/>g.throw(new<!-- --> <!-- -->Error('Error'))</span></pre><p id="2184" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所看到的，如果我们运行上面的代码，我们可以看到当第一行运行时记录了“Start ”,因为我们只是从生成器对象获取第一个值，这是<code class="fe le lf lg lh b">g.next()</code>行。然后运行抛出错误的<code class="fe le lf lg lh b">g.throw(new Error('Error'))</code>行，该错误记录在<code class="fe le lf lg lh b">catch</code>子句中。</p><p id="dbd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了生成器函数，我们还可以用<code class="fe le lf lg lh b">yield*</code>关键字调用它内部的其他生成器函数。以下示例不起作用:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a715" class="mt lj it lh b gy mu mv l mw mx">function* genFn() {<br/>  yield 'a'<br/>}</span><span id="f8b6" class="mt lj it lh b gy my mv l mw mx">function* genFnToCallgenFn() {<br/>  while (true) {<br/>    yield genFn();<br/>  }<br/>}</span><span id="e87e" class="mt lj it lh b gy my mv l mw mx">const g = genFnToCallgenFn()<br/>console.log(g.next())<br/>console.log(g.next())</span></pre><p id="0402" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，如果我们运行上面的代码，记录的<code class="fe le lf lg lh b">value</code>属性是生成器函数，这不是我们想要的。这是因为<code class="fe le lf lg lh b">yield</code>关键字没有直接从其他生成器中检索值。这就是<code class="fe le lf lg lh b">yield*</code>关键字有用的地方。如果我们用<code class="fe le lf lg lh b">yield* genFn();</code>替换<code class="fe le lf lg lh b">yield genFn();</code>，那么<code class="fe le lf lg lh b">genFn</code>返回的来自生成器的值将被检索。在这种情况下，它将不断获得字符串' a '。例如，如果我们改为运行以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c59b" class="mt lj it lh b gy mu mv l mw mx">function* genFn() {<br/>  yield 'a'<br/>}</span><span id="2c26" class="mt lj it lh b gy my mv l mw mx">function* genFnToCallgenFn() {<br/>  while (true) {<br/>    yield* genFn();<br/>  }<br/>}</span><span id="ee06" class="mt lj it lh b gy my mv l mw mx">const g = genFnToCallgenFn()<br/>console.log(g.next())<br/>console.log(g.next())</span></pre><p id="43fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将看到两个记录的对象中的<code class="fe le lf lg lh b">value</code>属性都将<code class="fe le lf lg lh b">value</code>属性设置为‘a’。</p><p id="15ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了生成器，我们可以编写一个迭代方法来递归地遍历一棵树。例如，我们可以这样写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a9fb" class="mt lj it lh b gy mu mv l mw mx">class<!-- --> Tree<!-- -->{<br/>  <!-- -->constructor(value,<!-- --> <!-- -->left=null, center=null, right=null)<!-- --> <!-- -->{<br/>    <!-- -->this.value<!-- --> <!-- -->=<!-- --> <!-- -->value;<br/>    <!-- -->this.left<!-- --> <!-- -->=<!-- --> <!-- -->left;<br/>    this.center<!-- --> <!-- -->=<!-- --> <!-- -->center;<br/>    <!-- -->this.right<!-- --> <!-- -->=<!-- --> <!-- -->right;<br/>  <!-- -->}<br/><br/>  <!-- -->*[Symbol.iterator]()<!-- --> <!-- -->{<br/>    <!-- -->yield<!-- --> <!-- -->this.value;<br/>    <!-- -->if<!-- --> <!-- -->(this.left)<!-- --> <!-- -->{<br/>      <!-- -->yield*<!-- --> <!-- -->this.left;<br/>    <!-- -->}<br/>    if<!-- --> <!-- -->(this.center)<!-- --> <!-- -->{<br/>      <!-- -->yield*<!-- --> <!-- -->this.center;<br/>    <!-- -->}<br/>    <!-- -->if<!-- --> <!-- -->(this.right)<!-- --> <!-- -->{<br/>      <!-- -->yield*<!-- --> <!-- -->this.right;<br/>    <!-- -->}<br/>  <!-- -->}<br/>}</span></pre><p id="2f8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们拥有的唯一方法是一个生成器，它返回树的当前节点的左、中和右节点。注意，我们使用了关键字<code class="fe le lf lg lh b">yield*</code>而不是<code class="fe le lf lg lh b">yield</code>，因为JavaScript类是生成器函数，我们的类是生成器函数，因为我们有由符号<code class="fe le lf lg lh b">Symbol.iterator</code>表示的特殊函数，这意味着该类将创建一个生成器。</p><p id="6cfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">符号是ES2015的新功能。这是一个唯一且不可变的标识符。一旦创建，就无法复制。每次你创造一个新的符号，它都是独一无二的。它主要用于对象中的唯一标识符。这是一个符号的唯一目的。</p><p id="f6f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一些它自己的静态属性和方法公开全局符号注册表。它就像一个内置对象，但是它没有构造函数，所以我们不能写<code class="fe le lf lg lh b">new Symbol</code>用<code class="fe le lf lg lh b">new</code>关键字构造一个符号对象。</p><p id="822b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Symbol.iterator</code>是一个特殊符号，表示该函数是迭代器。它内置于JavaScript标准库中。</p><p id="32a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们已经定义了下面的代码，那么我们就可以建立树形数据结构了:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0dff" class="mt lj it lh b gy mu mv l mw mx">const tree = new Tree('a',<br/>  new Tree('b',<br/>    new Tree('c'),<br/>    new Tree('d'),<br/>    new Tree('e')<br/>  ),<br/>  new Tree('f'),<br/>  new Tree('g',<br/>    new Tree('h'),<br/>    new Tree('i'),<br/>    new Tree('j')<br/>  )<br/>);</span></pre><p id="0d40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们跑的时候:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="35dd" class="mt lj it lh b gy mu mv l mw mx">for<!-- --> <!-- -->(const<!-- --> str <!-- -->of<!-- --> <!-- -->tree)<!-- --> <!-- -->{<br/>    <!-- -->console.log(str);<br/>}</span></pre><p id="f890" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们按照定义树的顺序记录树的所有值。定义递归数据结构比没有生成器函数要容易得多。</p><p id="7f00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在一个生成器函数中混合使用<code class="fe le lf lg lh b">yield</code>和<code class="fe le lf lg lh b">yield*</code>。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0961" class="mt lj it lh b gy mu mv l mw mx">function* genFn() {<br/>  yield 'a'<br/>}</span><span id="4865" class="mt lj it lh b gy my mv l mw mx">function* genFnToCallgenFn() {<br/>  yield 'Start';<br/>  while (true) {<br/>    yield* genFn();<br/>  }<br/>}</span><span id="e4ae" class="mt lj it lh b gy my mv l mw mx">const g = genFnToCallgenFn()<br/>console.log(g.next())<br/>console.log(g.next())<br/>console.log(g.next())<br/>console.log(g.next())</span></pre><p id="0bcd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，我们得到“Start”作为由<code class="fe le lf lg lh b">g.next()</code>返回的第一个项目的<code class="fe le lf lg lh b">value</code>属性。那么记录的其他项目都有“a”作为<code class="fe le lf lg lh b">value</code>属性。</p><p id="39db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以使用<code class="fe le lf lg lh b">return</code>语句来返回您想要从迭代器返回的最后一个值。它的行为与生成器函数中的最后一个<code class="fe le lf lg lh b">yield</code>语句完全一样。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e99c" class="mt lj it lh b gy mu mv l mw mx">function* genFn() {<br/>  yield 'a';<br/>  return 'result';<br/>}<br/>const g = genFn()<br/>console.log(g.next())<br/>console.log(g.next())<br/>console.log(g.next())<br/>console.log(g.next())</span></pre><p id="55ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们查看控制台日志，我们可以看到我们记录的前两行在<code class="fe le lf lg lh b">value</code>属性中返回了‘a ’,在前两行<code class="fe le lf lg lh b">console.log</code>的<code class="fe le lf lg lh b">value</code>属性中返回了‘result’。那么剩下的一个有<code class="fe le lf lg lh b">undefined</code>作为<code class="fe le lf lg lh b">value</code>。第一个<code class="fe le lf lg lh b">console.log</code>的<code class="fe le lf lg lh b">done</code>设置为<code class="fe le lf lg lh b">false</code>，其余的<code class="fe le lf lg lh b">done</code>设置为<code class="fe le lf lg lh b">true</code>。这是因为<code class="fe le lf lg lh b">return</code>语句结束了生成器函数的执行。它下面的任何东西都像常规的<code class="fe le lf lg lh b">return</code>语句一样不可达。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/d5789c419a9f7dd70bf33d56bf3d9ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_X-vbg8G8_9fHUTs"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">美国公共电力协会在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="2bee" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">异步发电机</h1><p id="750c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">生成器也可以用于异步代码。要为异步代码创建一个生成器函数，我们可以用特殊符号<code class="fe le lf lg lh b">Symbol.asyncIterator</code> function表示的方法创建一个对象。例如，我们可以编写以下代码来循环遍历一系列数字，每次迭代间隔1秒钟:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2701" class="mt lj it lh b gy mu mv l mw mx">const rangeGen = (from = 1, to = 5) =&gt; {<br/>  return {<br/>    from,<br/>    to,<br/>    [Symbol.asyncIterator]() {<br/>      return {<br/>        currentNum: this.from,<br/>        lastNum: this.to,<br/>        async next() {<br/>          await new Promise(resolve =&gt; setTimeout(<br/>            resolve, 1000));</span><span id="f732" class="mt lj it lh b gy my mv l mw mx">          if (this.currentNum &lt;= this.lastNum) {<br/>            return {<br/>              done: false,<br/>              value: this.currentNum++<br/>            };<br/>          } else {<br/>            return {<br/>              done: true<br/>            };<br/>          }<br/>        }<br/>      };<br/>    }<br/>  };</span><span id="c275" class="mt lj it lh b gy my mv l mw mx">}</span><span id="a49d" class="mt lj it lh b gy my mv l mw mx">(async () =&gt; {<br/>  for await (let value of rangeGen()) {<br/>    console.log(value);<br/>  }<br/>})()</span></pre><p id="5138" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，promise解析的值在<code class="fe le lf lg lh b">return</code>语句中。<code class="fe le lf lg lh b">next</code>函数应该总是返回一个承诺。我们可以通过使用<code class="fe le lf lg lh b">for await...of</code>循环来迭代生成器生成的值，该循环适用于迭代异步代码。这非常有用，因为可以循环异步代码，就像同步代码一样，这在我们有异步生成器函数和<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>语法之前是做不到的。与同步发电机一样，我们返回一个具有<code class="fe le lf lg lh b">done</code>和<code class="fe le lf lg lh b">value</code>属性的对象。</p><p id="c62f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过编写以下代码来缩短上面的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b028" class="mt lj it lh b gy mu mv l mw mx">async function* rangeGen(start = 1, end = 5) {<br/>  for (let i = start; i &lt;= end; i++) {<br/>    await new Promise(resolve =&gt; setTimeout(resolve, 1000));<br/>    yield i;<br/>  }<br/>}</span><span id="2c82" class="mt lj it lh b gy my mv l mw mx">(async () =&gt; {<br/>  for await (let value of rangeGen(1, 10)) {<br/>    console.log(value);<br/>  }<br/>})()</span></pre><p id="359e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们可以将<code class="fe le lf lg lh b">yield</code>操作符与<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>一起使用。在<code class="fe le lf lg lh b">rangeGen</code>的结尾仍然会返回一个承诺，但是这是一个更短的方法。它做的事情和前面的代码完全一样，但是它更短，更容易阅读。</p><p id="9e29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成器函数对于创建可用于<code class="fe le lf lg lh b">for...of</code>循环的迭代器非常有用。<code class="fe le lf lg lh b">yield</code>语句将获得迭代器从您选择的任何源返回的下一个值。这意味着我们可以把任何东西变成一个可迭代的对象。此外，我们可以通过使用符号<code class="fe le lf lg lh b">Symbol.iterator</code>表示的方法定义一个类来使用它遍历树结构，这将创建一个生成器函数，该函数使用<code class="fe le lf lg lh b">yield*</code>关键字获取下一级中的项目，该关键字直接从生成器函数中获取项目。此外，我们使用了<code class="fe le lf lg lh b">return</code>语句来返回生成器函数中的最后一项。对于异步代码，我们有<code class="fe le lf lg lh b">AsyncIterators</code>，我们可以通过使用<code class="fe le lf lg lh b">async</code>、<code class="fe le lf lg lh b">await</code>和<code class="fe le lf lg lh b">yield</code>来定义它，就像我们在上面所做的那样，来顺序地解析承诺。</p></div></div>    
</body>
</html>