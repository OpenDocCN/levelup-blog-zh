<html>
<head>
<title>Machine Learning and Rust (Part 3): Smartcore, Dataframe, and Linear Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习和Rust(第三部分):智能核心、数据框架和线性回归</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/machine-learning-and-rust-part-3-smartcore-dataframe-and-linear-regression-10451fdc2e60?source=collection_archive---------1-----------------------#2021-06-30">https://levelup.gitconnected.com/machine-learning-and-rust-part-3-smartcore-dataframe-and-linear-regression-10451fdc2e60?source=collection_archive---------1-----------------------#2021-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f646" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本教程中:我们能拥有铁锈中的熊猫吗？什么是smartcore？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7338fcc1de8821d5aa54820a56988d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FWvYtbhvGUBmObPWpsZIgA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片由<a class="ae le" href="https://unsplash.com/@clorisyy" rel="noopener ugc nofollow" target="_blank"> Cloris Ying </a>在<a class="ae le" href="https://unsplash.com/photos/SckmWxP8ImQ" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><div class="lf lg gp gr lh li"><a href="https://medium.com/@stefanobosisio1/membership" rel="noopener follow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">通过我的推荐链接加入Medium-Stefano Bosisio</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">medium.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw ky li"/></div></div></a></div><p id="a7a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">欢迎回到Rust及其在ML中的应用的第三个教程！今天我们将学习<a class="ae le" href="https://docs.rs/polars/0.14.2/polars/index.html" rel="noopener ugc nofollow" target="_blank"> Polars </a>一个处理数据帧和系列的神奇Rust软件包和<a class="ae le" href="https://docs.rs/smartcore/0.2.0/smartcore/" rel="noopener ugc nofollow" target="_blank"> smartcore </a>，它将是我们最好的ML Rust朋友之一:)</p><ul class=""><li id="d0fd" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated"><strong class="js iu">今日教程参考Github repo在这里:</strong><a class="ae le" href="https://github.com/Steboss/ML_and_Rust/tree/master/tutorial_2" rel="noopener ugc nofollow" target="_blank">https://Github . com/ste boss/ML _ and _ Rust/tree/master/tutorial _ 1</a></li><li id="ac34" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">在这里你可以找到我对Rus的简介</li><li id="0521" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated"><a class="ae le" href="https://stefanobosisio1.medium.com" rel="noopener">之前的教程—第二部分—关于</a> <code class="fe ml mm mn mo b"><a class="ae le" href="https://stefanobosisio1.medium.com" rel="noopener">rusty_machine</a></code> <a class="ae le" href="https://stefanobosisio1.medium.com" rel="noopener">和线性回归</a></li><li id="81fc" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">今天我们将处理<a class="ae le" href="https://en.wikipedia.org/wiki/Linear_regression" rel="noopener ugc nofollow" target="_blank">线性回归</a>和著名的<a class="ae le" href="https://www.cs.toronto.edu/~delve/data/boston/bostonDetail.html" rel="noopener ugc nofollow" target="_blank">波士顿房屋数据集</a>。</li><li id="3597" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">为了测试Rust online的功能，我可以向你推荐这个神奇的应用程序<a class="ae le" href="https://play.rust-lang.org" rel="noopener ugc nofollow" target="_blank">https://play.rust-lang.org</a>。</li></ul><p id="e067" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本教程结束时，您将学到什么？</p><ul class=""><li id="6bd4" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">在Rust中处理数据帧和序列及其操作</li><li id="ea47" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">使用smartcore实施线性回归</li><li id="8b93" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">在同一代码中混合使用smartcore和polars</li></ul></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="00c1" class="mw mx it bd my mz na dn nb nc nd dp ne kb nf ng nh kf ni nj nk kj nl nm nn no bi translated">铁锈色数据框</h2><p id="26a4" class="pw-post-body-paragraph jq jr it js b jt np jv jw jx nq jz ka kb nr kd ke kf ns kh ki kj nt kl km kn im bi translated">一个最常用的数据科学-d对象是<code class="fe ml mm mn mo b">dataframe</code>。如果你是一名数据科学家或者是一名Pythonist爱好者，你肯定玩过<code class="fe ml mm mn mo b">Pandas</code>和数据帧。顾名思义，这些计算对象是“插入”在表格框架中的数据，这允许简单的数据可视化和数据管理操作。Rust有自己的dataframe管理包，其中一个是<a class="ae le" href="https://docs.rs/polars/0.14.4/polars/index.html" rel="noopener ugc nofollow" target="_blank"> Polars </a>。</p><p id="2973" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Polars是一个完全并行的数据处理器，基于由<a class="ae le" href="https://www.ritchievink.com/blog/2021/02/28/i-wrote-one-of-the-fastest-dataframe-libraries/" rel="noopener ugc nofollow" target="_blank"> Ritchie Vink </a>编写的<a class="ae le" href="https://github.com/apache/arrow" rel="noopener ugc nofollow" target="_blank"> Apache Arrow </a>。这个软件包已经记录了相对于流行的数据帧软件包如R中的<code class="fe ml mm mn mo b">data.table</code>和<code class="fe ml mm mn mo b">Spark</code>的快速性能。Polars的目标是处理对熊猫来说太大而对Spark来说太小的数据。Polars存在于两个API中:<code class="fe ml mm mn mo b">eager</code>，在这里操作被立即执行，就像在pandas中一样，还有<code class="fe ml mm mn mo b">lazy, </code>，它针对查询和数据连接进行了优化。深入研究Polars超出了本教程的范围，但是我肯定很快会写一些关于这方面的东西，并提供关于复杂数据操作的很好的基准。</p><p id="01a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看看机器学习的人能用这个包做什么，所以<code class="fe ml mm mn mo b">cargo new polars_learning</code>！而数据集可以在这里找到:<a class="ae le" href="https://github.com/Steboss/ML_and_Rust/tree/master/tutorial_2/datasets" rel="noopener ugc nofollow" target="_blank">https://github . com/ste boss/ML _ and _ Rust/tree/master/tutorial _ 2/datasets</a>和代码在这里:<a class="ae le" href="https://github.com/Steboss/ML_and_Rust/tree/master/tutorial_2/polars_learning" rel="noopener ugc nofollow" target="_blank">https://github . com/ste boss/ML _ and _ Rust/tree/master/tutorial _ 2/polars _ learning</a></p><p id="2422" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一件事是:如何处理<code class="fe ml mm mn mo b">Cargo.toml</code>？<a class="ae le" href="https://github.com/Steboss/ML_and_Rust/blob/master/tutorial_2/smartcore_linear_regression/Cargo.toml" rel="noopener ugc nofollow" target="_blank">让我们添加第一个必需的依赖项:</a></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8982" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目前polars的最新版本是<code class="fe ml mm mn mo b">0.14.2</code></p><blockquote class="nw nx ny"><p id="a98f" class="jq jr nz js b jt ju jv jw jx jy jz ka oa kc kd ke ob kg kh ki oc kk kl km kn im bi translated">我们如何读取一个csv文件，并把它作为一个数据帧？</p></blockquote><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="3ce4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好的，这里有很多信息。首先让我们来看看进口:</p><ul class=""><li id="8275" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">我们需要处理<code class="fe ml mm mn mo b">polars</code>的所有东西都在<code class="fe ml mm mn mo b">prelude</code>(或多或少)，所以我们可以从那里<code class="fe ml mm mn mo b">use polars::prelude::*;</code>导入所有东西，或者我们可以只导入我们需要的东西(例如<code class="fe ml mm mn mo b">CsvReader, DataType, DataFrame</code>……)</li><li id="ff85" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">然后<code class="fe ml mm mn mo b">use std::fs::File</code>和<code class="fe ml mm mn mo b">use std::path::{Path}</code>用于读取给定的文件，如<code class="fe ml mm mn mo b">iris.csv</code></li><li id="f60b" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">最后，<code class="fe ml mm mn mo b">use polars::prelude::SerReader</code>包含了我们需要让<code class="fe ml mm mn mo b">CsvReader</code>与方法<code class="fe ml mm mn mo b">::new</code>一起工作的所有特征。记住，我们从<code class="fe ml mm mn mo b">CsvReader</code>返回一个数据帧，所以没有<code class="fe ml mm mn mo b">;</code></li></ul><p id="7808" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要读取csv文件，我们可以利用<code class="fe ml mm mn mo b">CsvReader</code>:</p><ul class=""><li id="8ca9" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">用<code class="fe ml mm mn mo b">let file = File::open(path).expect("Cannot open file.");</code>定义输入文件</li><li id="9b4a" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">检查是否存在一些割台<code class="fe ml mm mn mo b">.has_header</code></li><li id="54fd" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">并收集所有内容<code class="fe ml mm mn mo b">.finish()</code>。最终输出是<code class="fe ml mm mn mo b">PolarResult&lt;DataFrame&gt;</code>类型，即一个数据帧</li></ul><p id="4d00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后<code class="fe ml mm mn mo b">Some</code>类似于Haskell的<code class="fe ml mm mn mo b">Just</code>和<code class="fe ml mm mn mo b">Nothing</code>，它是一个<code class="fe ml mm mn mo b">variant enum</code>，允许读取前5行。</p><p id="f4cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">读取数据帧后:</p><blockquote class="nw nx ny"><p id="4805" class="jq jr nz js b jt ju jv jw jx jy jz ka oa kc kd ke ob kg kh ki oc kk kl km kn im bi translated">我们想知道更多关于它的大小和形状。</p></blockquote><p id="9bf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里没有什么太复杂的，步骤类似于Python的Pandas，如在这个函数中:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="6a1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们没有从这个函数返回任何东西，所以<code class="fe ml mm mn mo b">-&gt; ()</code>。一旦创建了数据帧，我们就可以得到<code class="fe ml mm mn mo b">df.shape()</code>并将其打印为<code class="fe ml mm mn mo b">{:#?}</code>以允许正确的解析。此外，我们可以检查每一列的<code class="fe ml mm mn mo b">schema</code>和<code class="fe ml mm mn mo b">dtype</code>，<code class="fe ml mm mn mo b">width</code> —即列数，以及<code class="fe ml mm mn mo b">height</code> —即行数。</p><blockquote class="nw nx ny"><p id="b9d2" class="jq jr nz js b jt ju jv jw jx jy jz ka oa kc kd ke ob kg kh ki oc kk kl km kn im bi translated">我们可以检查柱子，看看它们的样子:</p></blockquote><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ae95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe ml mm mn mo b">get_columns()</code>我们可以读取数据帧的所有列，<code class="fe ml mm mn mo b">get_column_names()</code>检索所有标题。此外，我们可以遍历列值，像Python一样打印列名及其值。</p><p id="5e68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在更性感的东西:</p><blockquote class="nw nx ny"><p id="5996" class="jq jr nz js b jt ju jv jw jx jy jz ka oa kc kd ke ob kg kh ki oc kk kl km kn im bi translated">将数据帧堆叠在一起。</p></blockquote><p id="d2a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们经常需要堆叠不同的数据帧，尤其是当我们读取一个巨大的文件时(Polars也会这样吗？我们很快就会回来):</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9a6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么我们有什么？</p><ul class=""><li id="607a" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">使用<code class="fe ml mm mn mo b">vstack</code>的垂直堆栈，我们可以将两个数据帧连接在一起(在Pandas中这是<code class="fe ml mm mn mo b">pd.concat([df1, df2])</code>)</li><li id="2035" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">我们可以从列<code class="fe ml mm mn mo b">df3.column("sepal.length").unwrap()</code>中提取一个<code class="fe ml mm mn mo b">&amp;series</code>类型</li><li id="07bb" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">更重要的是我们可以考虑提取一个序列来执行一些操作，这样我们就可以得到一个<code class="fe ml mm mn mo b">series</code>类型:</li></ul><p id="f4c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ml mm mn mo b">let sepal_length = df3.drop_in_place("sepal.length").unwrap();</code></p><ul class=""><li id="11c9" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">然后，我们可以对<code class="fe ml mm mn mo b">sepal_length</code>进行一些操作，并将其重新添加回<code class="fe ml mm mn mo b">df</code>，如下所示:</li></ul><p id="4d0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ml mm mn mo b">let _df4 = df3.insert_at_idx(0, sepal_length).unwrap()</code></p><p id="cb44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(这里的下划线在<code class="fe ml mm mn mo b">df4</code>之前，因为在Rust中——为了最佳实践——未使用的变量必须有<code class="fe ml mm mn mo b">_</code>)</p><p id="82ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在你知道如何处理级数了，</p><blockquote class="nw nx ny"><p id="c759" class="jq jr nz js b jt ju jv jw jx jy jz ka oa kc kd ke ob kg kh ki oc kk kl km kn im bi translated">让我们来看看如何对序列进行实际操作。</p></blockquote><p id="6895" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我们希望对dataframe列进行对数转换:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="708c" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">首先，我们可以直接对带有<code class="fe ml mm mn mo b">apply_at_idx</code>——第22行的列应用闭包。这是一个dataframe方法，我们需要给出我们想要修改的列的索引，以及映射操作，例如<code class="fe ml mm mn mo b">|s| s+1</code>给列加1</li><li id="08e5" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">否则我们可以直接对该系列采取行动。在这种情况下，我们可以考虑使用一个可变的数据帧和一个函数<code class="fe ml mm mn mo b">numb_to_log</code> : <strong class="js iu"> a) </strong>在第4行我们将一个序列转换成一个<em class="nz">分块数组</em> — <em class="nz">即一个类型化数组，它允许对数据应用闭包并收集类型为</em> <code class="fe ml mm mn mo b">T</code>的结果。<strong class="js iu"> b) </strong>操作<code class="fe ml mm mn mo b">drop_in_place.unwrap().rename()</code>从<code class="fe ml mm mn mo b">sepal.length</code>创建一个系列，并将其重命名为<code class="fe ml mm mn mo b">log10.sepal.length</code>。然后，<code class="fe ml mm mn mo b">.f64().unwrap()</code>指定该系列的类型，<code class="fe ml mm mn mo b">unwrap</code>将该系列转换为<code class="fe ml mm mn mo b">ChunkedArray</code>。<strong class="js iu"> c) </strong>最后，我们可以将这个数组转换为log10-array: <code class="fe ml mm mn mo b">cast::&lt;Float64Type&gt;()</code>转换为正确的数字类型并返回一个类似于<code class="fe ml mm mn mo b">Result&lt;&gt;</code>的对象，因此我们必须<code class="fe ml mm mn mo b">unwrap</code>得到一个f64数组，然后<code class="fe ml mm mn mo b">apply(|s| s.log10())</code>对数字进行对数转换。<code class="fe ml mm mn mo b">log10</code>是一个f64号式的锈法。d)重要的是，我们可以用<code class="fe ml mm mn mo b">into_series()</code>将一个<code class="fe ml mm mn mo b">ChunkedArray</code>转换回一个系列，并返回到主函数，用<code class="fe ml mm mn mo b">df.with_column()</code>将新系列添加为一列</li><li id="debe" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">上面是一个关于直接处理序列和分块数组的很好的例子，但是我们能直接在数据帧上做同样的事情吗？当然我们可以-第31行-:首先<code class="fe ml mm mn mo b">apply_at_idx</code>告诉dataframe我们想要对一列应用操作，然后我们可以用<code class="fe ml mm mn mo b">|s|</code>映射这个列，将它转换成一个分块数组，<code class="fe ml mm mn mo b">s.f64().unwrap()</code>，最后应用操作so <code class="fe ml mm mn mo b">apply(|t| t.log10()))</code>，其中<code class="fe ml mm mn mo b">|t|</code>是指列元素。</li></ul><p id="6b11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想给你看的关于polars的最后一样东西是与<code class="fe ml mm mn mo b">Cargo.toml</code>文件相关的东西，即<code class="fe ml mm mn mo b">features</code>的概念。在Rust中，任何包都有额外的特性，比如说方法，可以在需要的时候使用。例如，<code class="fe ml mm mn mo b">polars</code>能够将一个数字数据帧转换成一个名为<code class="fe ml mm mn mo b">to_ndarray</code>的数组:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9c93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如果没有明确添加到</strong> <code class="fe ml mm mn mo b">Cargo.toml</code>中，特性不会立即生效。这是为了确保最终编译的Rust包没有过大的尺寸，并且有助于减少编译时间。我们可以看到<code class="fe ml mm mn mo b">polars</code>有大量可以使用的附加功能:<a class="ae le" href="https://github.com/pola-rs/polars/blob/master/polars/Cargo.toml" rel="noopener ugc nofollow" target="_blank">https://github . com/pola-RS/polars/blob/master/polars/cargo . toml</a></p><p id="6956" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要添加包含在<code class="fe ml mm mn mo b">polars-core</code>中的<code class="fe ml mm mn mo b">to_ndarray</code>——所有数据帧操作的核心——我们需要将其显式添加到Cargo文件中:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b129" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只有这样，我们才能使用<code class="fe ml mm mn mo b">to_ndarray</code>作为数据框架。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="3d05" class="mw mx it bd my mz na dn nb nc nd dp ne kb nf ng nh kf ni nj nk kj nl nm nn no bi translated">Smartcore + Polars:用数据帧实现线性回归！</h2><p id="ae3d" class="pw-post-body-paragraph jq jr it js b jt np jv jw jx nq jz ka kb nr kd ke kf ns kh ki kj nt kl km kn im bi translated"><a class="ae le" href="https://docs.rs/smartcore/0.2.0/smartcore/" rel="noopener ugc nofollow" target="_blank"> Smartcore </a>是一个相当新的Rust包，有很多用于机器学习的应用程序，并且有一个非常活跃的社区。smartcore中的机器学习算法从分类到聚类，再到模型评估的指标——关于<code class="fe ml mm mn mo b">rusty machine</code>还有几个</p><p id="9511" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，smartcore与不同的Rust代数库进行了优化集成，如<code class="fe ml mm mn mo b">ndarray</code>或<code class="fe ml mm mn mo b">nalgebra</code>，这使得该软件包在处理不同的数据类型时更加灵活。与smartcore的积极贡献者Lorenzo 讨论，在实现更通用的数据解析方面仍有差距，因此我们将很快看到在smartcore中集成polars数据帧的更快方法，但现在我们利用这个机会了解Rust中的更多数据！</p><p id="1b57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们用Smartcore来弄脏我们的手:<code class="fe ml mm mn mo b">cargo new smartcore_linear_regression</code>代码可以在这里找到:<a class="ae le" href="https://github.com/Steboss/ML_and_Rust/tree/master/tutorial_2/smartcore_linear_regression" rel="noopener ugc nofollow" target="_blank">https://github . com/ste boss/ML _ and _ Rust/tree/master/tutorial _ 2/smart core _ linear _ regression</a></p><p id="9d9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们准备好<code class="fe ml mm mn mo b">Cargo.toml</code>所需的依赖项和特性:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1218" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二，让我们跳到<code class="fe ml mm mn mo b">main.rs</code>上，想出实施线性回归的4个步骤:</p><ul class=""><li id="8f37" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">读取输入<code class="fe ml mm mn mo b">boston_dataset.csv</code>并解析成Polars数据帧</li><li id="16fc" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">提取相关的培训特征和目标</li><li id="1e23" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">将功能和目标转换为smartcore <code class="fe ml mm mn mo b">DenseMatrix</code>格式</li><li id="0f77" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">运行<code class="fe ml mm mn mo b">LinearRegression</code>:)</li></ul><p id="4319" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae le" href="https://github.com/Steboss/ML_and_Rust/blob/2cdff2152cfa7337571114ee980b857395a0aaf0/tutorial_2/smartcore_linear_regression/src/main.rs#L2" rel="noopener ugc nofollow" target="_blank">在所有常用的导入中，我们要导入</a> <code class="fe ml mm mn mo b"><a class="ae le" href="https://github.com/Steboss/ML_and_Rust/blob/2cdff2152cfa7337571114ee980b857395a0aaf0/tutorial_2/smartcore_linear_regression/src/main.rs#L2" rel="noopener ugc nofollow" target="_blank">smartcore</a></code> <a class="ae le" href="https://github.com/Steboss/ML_and_Rust/blob/2cdff2152cfa7337571114ee980b857395a0aaf0/tutorial_2/smartcore_linear_regression/src/main.rs#L2" rel="noopener ugc nofollow" target="_blank">功能</a>，即<code class="fe ml mm mn mo b">LinearRegression</code>、<code class="fe ml mm mn mo b">DenseMatrix</code>、<code class="fe ml mm mn mo b">BaseMatrix</code>、<code class="fe ml mm mn mo b">train_test_split</code>和<code class="fe ml mm mn mo b">mean_squared_error</code>。正如我们将看到的,<code class="fe ml mm mn mo b">smartcore</code>需要一个基于<code class="fe ml mm mn mo b">nalgebra</code>包的矩阵类型<code class="fe ml mm mn mo b">DenseMatrix</code>或<code class="fe ml mm mn mo b">BaseMatrix</code>作为输入。</p><p id="c282" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前两步是从Rust学习更多新知识的好机会:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="c882" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">在<code class="fe ml mm mn mo b">read_csv</code>中，我留下了可能有用的方法<code class="fe ml mm mn mo b">with_delimiter</code>。然而，对于这个数据集来说，情况并非如此，<code class="fe ml mm mn mo b">with_delimiter</code>只需要字节作为输入。例如，考虑一个散列作为列之间的分隔符:<code class="fe ml mm mn mo b">with_delimiter(b'#')</code>——注意我们使用的是<code class="fe ml mm mn mo b">'</code>而不是引号<code class="fe ml mm mn mo b">"</code>，因为引号会引起错误</li><li id="12f4" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">从<code class="fe ml mm mn mo b">feature_and_target</code>开始，我们第一次同时返回两个变量。简单地将变量及其类型括在括号中<code class="fe ml mm mn mo b">()</code></li><li id="5b6a" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">在这里你可以看到<code class="fe ml mm mn mo b">polars</code>比<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/machine-learning-and-rust-part-2-linear-regression-d3b820ed28f9">定制csv阅读器</a>更方便，在那里我们可以<code class="fe ml mm mn mo b">select</code>我们想要的列。要选择多列，我们需要通过一个Rust <code class="fe ml mm mn mo b">vec</code>，因此<code class="fe ml mm mn mo b">vec![col1, col2, ...]</code></li></ul><p id="dfa9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">步骤3:将特征数据框和目标列转换为所需的smartcore格式<code class="fe ml mm mn mo b">DenseMatrix</code></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><ul class=""><li id="3806" class="lx ly it js b jt ju jx jy kb lz kf ma kj mb kn mc md me mf bi translated">如您所见，在第7行，我们使用<code class="fe ml mm mn mo b">ndarray</code>将数据帧转换为数组。从那里我们可以初始化一个零矩阵<code class="fe ml mm mn mo b">xmatrix</code>。</li><li id="4a24" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">这个矩阵属于带有<code class="fe ml mm mn mo b">&lt;f64&gt;</code>个数字的<code class="fe ml mm mn mo b">DenseMatrix</code>类型。<a class="ae le" href="https://docs.rs/smartcore/0.2.0/smartcore/linalg/trait.BaseMatrix.html" rel="noopener ugc nofollow" target="_blank">要创建零矩阵，我们可以简单地使用</a> <code class="fe ml mm mn mo b"><a class="ae le" href="https://docs.rs/smartcore/0.2.0/smartcore/linalg/trait.BaseMatrix.html" rel="noopener ugc nofollow" target="_blank">BaseMatrix::zeros</a></code>。</li><li id="2536" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">然后稍微注意一下Rust类型，我们初始化两个计数器，一个用于行<code class="fe ml mm mn mo b">row</code>，一个用于列<code class="fe ml mm mn mo b">col</code>，我们遍历数组值。</li><li id="26bc" class="lx ly it js b jt mg jx mh kb mi kf mj kj mk kn mc md me mf bi translated">迭代过程是<code class="fe ml mm mn mo b">features_res</code>是一个1D数组。在每次迭代中，我们通过使用<code class="fe ml mm mn mo b">*val</code><em class="nz">解引用借用的</em>值，将一个值<code class="fe ml mm mn mo b">set</code>到<code class="fe ml mm mn mo b">xmatrix</code>中，这样就不会有错误:<code class="fe ml mm mn mo b">expected f64 not &amp;f64</code>。最后，我们可以用<code class="fe ml mm mn mo b">Ok</code>返回<code class="fe ml mm mn mo b">DenseMatrix</code></li></ul><p id="0581" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似的方法也被用于将<code class="fe ml mm mn mo b">target</code>数组转换为<code class="fe ml mm mn mo b">vector</code>——注意在Rust中的向量中插入一个值看起来与C++ <code class="fe ml mm mn mo b">push</code>相似</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="300c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，强调所有这些变量的<code class="fe ml mm mn mo b">mut</code>很重要，因为我们已经将它们初始化为零，然后填充它们。在github代码中，我还保留了——注释——不使用函数在<code class="fe ml mm mn mo b">main</code>中做同样事情的过程。</p><p id="a386" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后在smartcore中进行线性回归和拟合！这超级简单，它记得我的方法，使<code class="fe ml mm mn mo b">smartcore</code>成为一个很棒的库——至于<code class="fe ml mm mn mo b">rusty_machine</code>,我们不必担心<code class="fe ml mm mn mo b">train_test_split</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="367d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就这么简单！</p><h1 id="a1bf" class="od mx it bd my oe of og nb oh oi oj ne ok ol om nh on oo op nk oq or os nn ot bi translated">准备，稳住，开始！</h1><p id="3999" class="pw-post-body-paragraph jq jr it js b jt np jv jw jx nq jz ka kb nr kd ke kf ns kh ki kj nt kl km kn im bi translated">现在我们已经为运行代码做好了一切准备。像往常一样，你可以在Rust文件夹中运行<code class="fe ml mm mn mo b">cargo run</code>。如果一切顺利，您应该会看到一个<code class="fe ml mm mn mo b">Cargo.lock</code>文件和<code class="fe ml mm mn mo b">target</code>文件夹，其中包含我们编译的代码。此外<code class="fe ml mm mn mo b">cargo run</code>将运行我们的<code class="fe ml mm mn mo b">main.rs</code></p><p id="459d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你足够高兴，你可以用<code class="fe ml mm mn mo b">cargo build</code>构建整个包，它将对我们的代码运行进一步的优化，瞧！</p><p id="6989" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi">🎊🎊🎊</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="4edf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">暂时就这些吧！绝对是今天学习Rust的一个显著进步！敬请期待下一期教程！</p><p id="5bc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请随时给我发电子邮件询问问题或评论，地址:stefanobosisio1@gmail.com</p><p id="1b43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者，你可以在Instagram上联系我:<a class="ae le" href="https://www.instagram.com/a_pic_of_science/" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/a_pic_of_science/</a></p></div></div>    
</body>
</html>