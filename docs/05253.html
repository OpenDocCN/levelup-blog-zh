<html>
<head>
<title>Why Code Evolve from Procedural to Object-Oriented to Functional Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么代码从过程化到面向对象再到函数式编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-code-evolve-from-procedural-to-object-oriented-to-functional-programming-13a88292307e?source=collection_archive---------1-----------------------#2020-08-15">https://levelup.gitconnected.com/why-code-evolve-from-procedural-to-object-oriented-to-functional-programming-13a88292307e?source=collection_archive---------1-----------------------#2020-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5c95" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">探索编程世界</h2><div class=""/><div class=""><h2 id="6922" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过实际的代码示例学习不同风格的编程范式</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c0380b797f6eb8c0072214ccccfd6afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XTA3ydwTKGyhgVCuuXMJxA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="98b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi me translated">函数式编程是当今的趋势！但是等等，为什么它会成为潮流？我们是怎么来到这里的？它不容易理解，不知道与以前的范例相比它有什么好处。</p><p id="cfd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从一开始就知道编程范式是如何转变的，将有助于我们更好地欣赏它，并能够在前进的道路上把握变化的美妙和需要。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="d8ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我第一次学习编程时，C语言知识被认为是所有喜欢学习编程的人的标准语言。这就是所谓的程序设计时代。</p><p id="4510" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，那时候C++是最先进的。类、继承、封装、多态……我的脑袋在困惑为什么需要它们。我就不能用函数做所有的事情吗！</p><p id="a029" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我花了一段时间才完全理解面向对象编程(也称为OOP)，认为我已经掌握了编程的技巧。我以为我现在可以统治世界，学习任何编程语言。</p><p id="863d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">直到最近(最近几年)，每个人都在谈论函数式编程(又名FP)。这是什么？功能？那不就是程序化编程吗？</p><p id="eff7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">曾经感到困惑的我，现在试图分享我在这个过程中学到的东西，用实际的代码例子(用JavaScript)来演示代码是如何进化的，如下所示。</p><p id="e2f6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">加入我的编码之旅，并希望它能更清晰地展示它们的差异和范式转换的需要。</p><h1 id="fcc6" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated"><a class="ae lh" href="https://en.wikipedia.org/wiki/Structured_programming" rel="noopener ugc nofollow" target="_blank">结构化编程</a></h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nm"><img src="../Images/7a84d7827303eab349723bd95394ef30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lLQAX7NHFFrYZBRPi9SgLg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由作者提供</figcaption></figure><p id="bbca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在程序化编程出现之前，有一种东西叫做结构化编程。它大量使用控制流，如if-else和for-loop。</p><p id="56a3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面让我们开始我们的编码之旅。</p><p id="43b5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我有一个数字数组<code class="fe nn no np nq b">[1, 2, 3, 4, 5]</code>，我喜欢把它们相加。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="bcb3" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">numbers1 </em>= [1, 2, 3, 4, 5]<br/><strong class="nq jd">let <em class="oa">sumOfNumbers1 </em>= 0<br/>for (let index = 0;index &lt; <em class="oa">numbers1</em>.length; index++) {<br/>    <em class="oa">sumOfNumbers1 </em>+= <em class="oa">numbers1</em>[index]<br/>}</strong><br/><em class="oa">console</em>.log(<em class="oa">sumOfNumbers1</em>)</span></pre><p id="f522" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[ <a class="ae lh" href="https://github.com/elye/demo_javascript_language_evolution/blob/master/structural1.js" rel="noopener ugc nofollow" target="_blank">完整代码在此处</a></p><p id="52d6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单，如上所示的for循环，累加所有的数得到总和。</p><h2 id="134d" class="nv mv it bd mw ob oc dn na od oe dp ne lr of og ng lv oh oi ni lz oj ok nk iz bi translated">需要对不同的数据再次做同样的事情</h2><p id="90ed" class="pw-post-body-paragraph li lj it lk b ll ol kd ln lo om kg lq lr on lt lu lv oo lx ly lz op mb mc md im bi translated">后来我又有了一组数字<code class="fe nn no np nq b">[6, 7, 8, 9, 10]</code>。我也想总结一下。我需要再次做同样的事情。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="e1c1" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">numbers1 </em>= [1, 2, 3, 4, 5]<br/><strong class="nq jd">let <em class="oa">sumOfNumbers1 </em>= 0<br/>for (let index = 0;index &lt; <em class="oa">numbers1</em>.length; index++) {<br/>    <em class="oa">sumOfNumbers1 </em>+= <em class="oa">numbers1</em>[index]<br/>}</strong><br/><em class="oa">console</em>.log(<em class="oa">sumOfNumbers1</em>)</span><span id="6954" class="nv mv it nq b gy oq nx l ny nz">const <em class="oa">numbers2 </em>= [6, 7, 8, 9, 10]<br/><strong class="nq jd">let <em class="oa">sumOfNumbers2 </em>= 0<br/>for (let index = 0;index &lt; <em class="oa">numbers2</em>.length; index++) {<br/>    <em class="oa">sumOfNumbers2 </em>+= <em class="oa">numbers2</em>[index]<br/>}</strong><br/><em class="oa">console</em>.log(<em class="oa">sumOfNumbers2</em>)</span></pre><p id="43f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[ <a class="ae lh" href="https://github.com/elye/demo_javascript_language_evolution/blob/master/structural2.js" rel="noopener ugc nofollow" target="_blank">完整代码在此处</a></p><p id="1960" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以看到一个共同的模式如下</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="33c6" class="nv mv it nq b gy nw nx l ny nz">let <strong class="nq jd"><em class="oa">sumOfNumbers </em></strong>= 0<br/>for (let index = 0;index &lt; <strong class="nq jd"><em class="oa">numbers</em></strong>.length; index++) {<br/>    <strong class="nq jd"><em class="oa">sumOfNumbers </em></strong>+= <strong class="nq jd"><em class="oa">numbers</em></strong>[index]<br/>}</span></pre><p id="d4aa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">吃两次也没那么糟。然而，想象一下，如果我们必须对100组数字进行这样的操作，那么这将是非常重复的。因此，我们需要一种新的编程方法。</p><h1 id="30f6" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated"><a class="ae lh" href="https://en.wikipedia.org/wiki/Procedural_programming" rel="noopener ugc nofollow" target="_blank">程序化编程</a></h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/bb3db70e6a486a759d436776180e8b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7mk4OY3PaYi7Iqbr_JU3w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由作者提供</figcaption></figure><p id="c491" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上面结构化编程中的例子所示，我们有一些重复的代码。</p><p id="f413" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了解决这个问题，我们可以将公共代码分离出来，放在一个不同的地方，我们称之为函数(或方法，或例程，或过程)。然后让主逻辑流程调用这个函数。</p><p id="720c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过这种方法，我们可以<strong class="lk jd">一次又一次地重用</strong>代码(函数),而不用在多个地方重复使用它。这种方法后来被称为过程化编程。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="f03f" class="nv mv it nq b gy nw nx l ny nz"><strong class="nq jd">function sumOfNumbers(numbers) {<br/>    let sumOfNumbers = 0<br/>    for (let index = 0;index &lt; numbers.length; index++) {<br/>        sumOfNumbers += numbers[index]<br/>    }<br/>    return sumOfNumbers<br/>}</strong></span><span id="5504" class="nv mv it nq b gy oq nx l ny nz">const <em class="oa">numbers1 </em>= [1, 2, 3, 4, 5]<br/><em class="oa">console</em>.log(sumOfNumbers(<em class="oa">numbers1</em>))<br/>const <em class="oa">numbers2 </em>= [6, 7, 8, 9, 10]<br/><em class="oa">console</em>.log(sumOfNumbers(<em class="oa">numbers2</em>))</span></pre><p id="957b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[ <a class="ae lh" href="https://github.com/elye/demo_javascript_language_evolution/blob/master/procedural1.js" rel="noopener ugc nofollow" target="_blank">完整代码在此处</a></p><p id="3a7e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了避免重复之外，这种做法还降低了出现bug的可能性。如果函数中有bug，更容易被发现和修复。修复将适用于所有人。太好了！</p><h2 id="3e9c" class="nv mv it bd mw ob oc dn na od oe dp ne lr of og ng lv oh oi ni lz oj ok nk iz bi translated">需要对相同的数据再次做不同的事情</h2><p id="0ecc" class="pw-post-body-paragraph li lj it lk b ll ol kd ln lo om kg lq lr on lt lu lv oo lx ly lz op mb mc md im bi translated">有一天，我们决定除了对数字求和之外，还要计算数字的乘积(所有数字的乘积)。</p><p id="752a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为此，我们现在可以轻松地编写另一个函数来编译。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="cde4" class="nv mv it nq b gy nw nx l ny nz">function sumOfNumbers(numbers) {<br/>    let sumOfNumbers = 0<br/>    for (let index = 0;index &lt; numbers.length; index++) {<br/>        sumOfNumbers += numbers[index]<br/>    }<br/>    return sumOfNumbers<br/>}</span><span id="5f0e" class="nv mv it nq b gy oq nx l ny nz"><strong class="nq jd">function productOfNumbers(numbers) {<br/>    let productOfNumbers = 1<br/>    for (let index = 0;index &lt; numbers.length; index++) {<br/>        productOfNumbers *= numbers[index]<br/>    }<br/>    return productOfNumbers<br/>}</strong></span><span id="2480" class="nv mv it nq b gy oq nx l ny nz">const <em class="oa">numbers1 </em>= [1, 2, 3, 4, 5]<br/><em class="oa">console</em>.log(sumOfNumbers(<em class="oa">numbers1</em>))<br/><em class="oa">console</em>.log(productOfNumbers(<em class="oa">numbers1</em>))<br/>const <em class="oa">numbers2 </em>= [6, 7, 8, 9, 10]<br/><em class="oa">console</em>.log(sumOfNumbers(<em class="oa">numbers2</em>))<br/><em class="oa">console</em>.log(productOfNumbers(<em class="oa">numbers2</em>))</span></pre><p id="4756" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[ <a class="ae lh" href="https://github.com/elye/demo_javascript_language_evolution/blob/master/procedural2.js" rel="noopener ugc nofollow" target="_blank">完整代码在此处</a> ]</p><p id="fa23" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很好，只需一个函数，我们就能轻松做到。在帕斯卡的时代，生活是美好的。</p><p id="a425" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是程序员就是程序员，他们很懒。他们开始思考，为什么我们要一次又一次地为如下所示的每个函数提供数字呢？</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="2069" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">numbers1 </em>= [1, 2, 3, 4, 5]<br/><em class="oa">console</em>.log(sumOfNumbers(<strong class="nq jd"><em class="oa">numbers1</em></strong>))<br/><em class="oa">console</em>.log(productOfNumbers(<strong class="nq jd"><em class="oa">numbers1</em></strong>))<br/>const <em class="oa">numbers2 </em>= [6, 7, 8, 9, 10]<br/><em class="oa">console</em>.log(sumOfNumbers(<strong class="nq jd"><em class="oa">numbers2</em></strong>))<br/><em class="oa">console</em>.log(productOfNumbers(<strong class="nq jd"><em class="oa">numbers2</em></strong>))</span></pre><p id="8ad8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个简单的解决方案是将这两个函数合并成一个大函数</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="1347" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">numbers1 </em>= [1, 2, 3, 4, 5]<br/><em class="oa">console</em>.log(<strong class="nq jd">sumOfNumbersAndProductOfNumbers</strong>(<em class="oa">numbers1</em>))<br/>const <em class="oa">numbers2 </em>= [6, 7, 8, 9, 10]<br/><em class="oa">console</em>.log(<strong class="nq jd">sumOfNumbersAndProductOfNumbers</strong>(<em class="oa">numbers2</em>))</span></pre><p id="3384" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是结合功能的想法不好。它消除了让它们(和与积)在不同时间或顺序独立计算的灵活性。例如，组合功能将无法灵活满足以下需求。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="0ae1" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">numbers1 </em>= [1, 2, 3, 4, 5]<br/><em class="oa">console</em>.log(<strong class="nq jd">sumOfNumbers</strong>(<em class="oa">numbers1</em>))<br/><em class="oa">console</em>.log(<strong class="nq jd">sumOfNumbers</strong>(<em class="oa">numbers2</em>))<br/>const <em class="oa">numbers2 </em>= [6, 7, 8, 9, 10]<br/><em class="oa">console</em>.log(<strong class="nq jd">productOfNumbers</strong>(<em class="oa">numbers1</em>))<br/><em class="oa">console</em>.log(<strong class="nq jd">productOfNumbers</strong>(<em class="oa">numbers2</em>))</span></pre><h1 id="68d4" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated"><a class="ae lh" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">面向对象编程</a></h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/14b887f7dc018480039f6b43c79fbf0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NLF2jvbatqeFktLBjpviZw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由作者提供</figcaption></figure><p id="258e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随着这个问题在过程编程中的共享，面向对象编程的诞生来拯救。</p><p id="594c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">整个想法是，对象(或数字)能够做自己的操作，而不需要调用者担心它是如何做的。这叫做…</p><h2 id="c921" class="nv mv it bd mw ob oc dn na od oe dp ne lr of og ng lv oh oi ni lz oj ok nk iz bi translated">包装</h2><p id="eeaf" class="pw-post-body-paragraph li lj it lk b ll ol kd ln lo om kg lq lr on lt lu lv oo lx ly lz op mb mc md im bi translated">在面向对象编程中，对象将包含它自己的数据，以及它可以对数据进行操作的一组函数。物体通常被定义为<code class="fe nn no np nq b">class</code></p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="e3a9" class="nv mv it nq b gy nw nx l ny nz">class <strong class="nq jd">Numbers</strong> {<br/>    constructor(numbers) {<br/>        this.numbers = numbers<br/>    }</span><span id="c2c3" class="nv mv it nq b gy oq nx l ny nz">    <strong class="nq jd">sumOf</strong>() {<br/>        let sumOfNumbers = 0<br/>        for (let index = 0;index &lt; this.numbers.length; index++) {<br/>            sumOfNumbers += this.numbers[index]<br/>        }<br/>        return sumOfNumbers<br/>    }</span><span id="9dbe" class="nv mv it nq b gy oq nx l ny nz">    <strong class="nq jd">productOf</strong>() {<br/>        let productOfNumbers = 1<br/>        for (let index = 0;index &lt; this.numbers.length; index++) {<br/>            productOfNumbers *= this.numbers[index]<br/>        }<br/>        return productOfNumbers<br/>    }<br/>}</span></pre><p id="4a54" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们的对象将拥有<code class="fe nn no np nq b">numbers</code>以及函数<code class="fe nn no np nq b">sumOf</code>和<code class="fe nn no np nq b">productOf</code>。</p><p id="49dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些数据和函数对使用该对象的代码是隐藏的。这也被称为<strong class="lk jd"> <em class="oa">封装</em> </strong>。</p><p id="6b68" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有了这个类对象，我们可以使用<code class="fe nn no np nq b">new</code>命令创建它们，并向它提供编号。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="94fe" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">numbers1 </em>= <strong class="nq jd">new Numbers([1, 2, 3, 4, 5])</strong><br/><em class="oa">console</em>.log(<em class="oa">numbers1</em>.sumOf())<br/><em class="oa">console</em>.log(<em class="oa">numbers1</em>.productOf())<br/>const <em class="oa">numbers2 </em>= <strong class="nq jd">new Numbers([6, 7, 8, 9, 10])</strong><br/><em class="oa">console</em>.log(<em class="oa">numbers2</em>.sumOf())<br/><em class="oa">console</em>.log(<em class="oa">numbers2</em>.productOf())</span></pre><p id="e964" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[ <a class="ae lh" href="https://github.com/elye/demo_javascript_language_evolution/blob/master/oop1.js" rel="noopener ugc nofollow" target="_blank">完整代码在此处</a></p><p id="a2fc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有了它，我们可以随时调用<code class="fe nn no np nq b">sumOf</code>或<code class="fe nn no np nq b">productOf</code>，而不需要再次向它提供号码。懒惰的程序员现在很开心，因为他不需要一次又一次地提供数字…直到…</p><h2 id="cd4d" class="nv mv it bd mw ob oc dn na od oe dp ne lr of og ng lv oh oi ni lz oj ok nk iz bi translated">遗产</h2><p id="25e6" class="pw-post-body-paragraph li lj it lk b ll ol kd ln lo om kg lq lr on lt lu lv oo lx ly lz op mb mc md im bi translated">我们决定再次添加另一组数字进行计算。这一次，我们希望有<code class="fe nn no np nq b">[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]</code>，或者换句话说，10个2。</p><p id="c0c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单的方法是我们可以做如下</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="a442" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">numbers1 </em>= <strong class="nq jd">new Numbers([1, 2, 3, 4, 5])</strong><br/><em class="oa">console</em>.log(<em class="oa">numbers1</em>.sumOf())<br/><em class="oa">console</em>.log(<em class="oa">numbers1</em>.productOf())<br/>const <em class="oa">numbers2 </em>= <strong class="nq jd">new Numbers([6, 7, 8, 9, 10])</strong><br/><em class="oa">console</em>.log(<em class="oa">numbers2</em>.sumOf())<br/><em class="oa">console</em>.log(<em class="oa">numbers2</em>.productOf())<br/>const <em class="oa">numbers3 </em>= <strong class="nq jd">new Numbers([</strong><strong class="nq jd">2, 2, 2, 2, 2, 2, 2, 2, 2, 2</strong><strong class="nq jd">])<br/></strong><em class="oa">console</em>.log(<em class="oa">numbers3</em>.sumOf())<br/><em class="oa">console</em>.log(<em class="oa">numbers3</em>.productOf())</span></pre><p id="010f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然这是可行的，但它让程序员看起来很愚蠢。原因是</p><blockquote class="ot ou ov"><p id="e85d" class="li lj oa lk b ll lm kd ln lo lp kg lq ow ls lt lu ox lw lx ly oy ma mb mc md im bi translated">为什么我们要打这么多2？在JavaScript中，我们可以使用<code class="fe nn no np nq b"><em class="it">Array(times).fill(value)</em></code>来实现，其中value是2，times是10。</p></blockquote><p id="fbd5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以做如下</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="eb2c" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">numbers3 </em>= <strong class="nq jd">new Numbers(<em class="oa">Array</em>(10).fill(2))<br/></strong><em class="oa">console</em>.log(<em class="oa">numbers3</em>.sumOf())<br/><em class="oa">console</em>.log(<em class="oa">numbers3</em>.productOf())</span></pre><p id="47a7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是也许我们可以隐藏<code class="fe nn no np nq b"><em class="oa">Array</em>(times).fill(value)</code>在类构造函数中完成。</p><p id="8be3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么我们是否应该编写一个新的类对象来实现这一点呢？它不是一个真正的新类对象，因为它应该有相同的<code class="fe nn no np nq b">sumOf</code>和<code class="fe nn no np nq b">productOf</code>值，同时它也有<code class="fe nn no np nq b">numbers</code>。</p><p id="ff3a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在面向对象编程中，我们可以使用<strong class="lk jd"> <em class="oa">继承</em> </strong>的概念来解决这个问题。</p><p id="0ad8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然<code class="fe nn no np nq b">[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]</code>可以是一个<code class="fe nn no np nq b">Numbers</code>对象，但它有一些并非所有<code class="fe nn no np nq b">Numbers</code>都有的特殊属性。它是<code class="fe nn no np nq b">Numbers</code>的子集。</p><p id="fbe1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我称之为<code class="fe nn no np nq b">SameNumbers</code>。它是<code class="fe nn no np nq b">Numbers</code>的一部分，将继承<code class="fe nn no np nq b">Number</code>所拥有的一切，同时拥有自己构造对象的方式。</p><p id="9aef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在JavaScript中，我们可以使用如下所示的<code class="fe nn no np nq b">extends</code>进行继承。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="0580" class="nv mv it nq b gy nw nx l ny nz">class <strong class="nq jd">SameNumbers</strong> extends <strong class="nq jd">Numbers</strong> {<br/>    constructor(value, times) {<br/>        super(<em class="oa">Array</em>(times).fill(value));</span><span id="34bc" class="nv mv it nq b gy oq nx l ny nz">        // Note: we also store `value` and `times` now<br/>        // To explain our next bit of idea: Polymorphism<br/>        this.value = value<br/>        this.times = times<br/>    }<br/>}</span></pre><p id="6b28" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用它，现在我们可以编码如下</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="dbeb" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">numbers3 </em>= <strong class="nq jd">new SameNumbers(2, 10)</strong><br/><em class="oa">console</em>.log(<em class="oa">numbers3</em>.sumOf())<br/><em class="oa">console</em>.log(<em class="oa">numbers3</em>.productOf())</span></pre><p id="1d5d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[ <a class="ae lh" href="https://github.com/elye/demo_javascript_language_evolution/blob/master/oop2.js" rel="noopener ugc nofollow" target="_blank">完整代码在此处</a></p><p id="79c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们可以继续使用<code class="fe nn no np nq b">sumOf</code>和<code class="fe nn no np nq b">productOf</code>，因为<code class="fe nn no np nq b">SameNumbers</code>从<code class="fe nn no np nq b">Numbers</code>继承了它们。</p><h2 id="661a" class="nv mv it bd mw ob oc dn na od oe dp ne lr of og ng lv oh oi ni lz oj ok nk iz bi translated">多态性</h2><p id="648d" class="pw-post-body-paragraph li lj it lk b ll ol kd ln lo om kg lq lr on lt lu lv oo lx ly lz op mb mc md im bi translated">一位数学家来检查我们的工作。代码看起来是正确的，因为<code class="fe nn no np nq b">sumOf</code>和<code class="fe nn no np nq b">productOf</code>计算正确。但是数学家不喜欢我们为<code class="fe nn no np nq b">SameNumbers</code>计算<code class="fe nn no np nq b">sumOf</code>和<code class="fe nn no np nq b">productOf</code>的方式</p><p id="c2d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是评论</p><blockquote class="ot ou ov"><p id="63dc" class="li lj oa lk b ll lm kd ln lo lp kg lq ow ls lt lu ox lw lx ly oy ma mb mc md im bi translated">为了计算<code class="fe nn no np nq b"><em class="it">SameNumbers</em></code>的和与积，我们不需要遍历这些数字。我们可以通过<code class="fe nn no np nq b"><em class="it">sum = value * times</em></code>和<code class="fe nn no np nq b"><em class="it">product = value ^ times</em></code>更快地完成</p></blockquote><p id="7dba" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">哦天哪！但都是<code class="fe nn no np nq b">Numbers</code>。我们如何解决这个问题，让他们与众不同？</p><p id="799d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">也许我们把<code class="fe nn no np nq b">Numbers</code>的<code class="fe nn no np nq b">sumOf</code>和<code class="fe nn no np nq b">productOf</code>中的<code class="fe nn no np nq b">if-else</code>放在下面？</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="feef" class="nv mv it nq b gy nw nx l ny nz">class Numbers {<br/>    constructor(numbers) {<br/>        this.numbers = numbers<br/>    }</span><span id="3dff" class="nv mv it nq b gy oq nx l ny nz">    sumOf() {<br/><strong class="nq jd">        if (this instanceof SameNumbers) {<br/>            return this.numbers[0] * this.numbers.length  <br/>        } </strong><br/>        let sumOfNumbers = 0<br/>        for (let index = 0;index &lt; this.numbers.length; index++) {<br/>            sumOfNumbers += this.numbers[index]<br/>        }<br/>        return sumOfNumbers<br/>    }</span><span id="5fcf" class="nv mv it nq b gy oq nx l ny nz">    productOf() {<br/><strong class="nq jd">        if (this instanceof SameNumbers)  {<br/>            return <em class="oa">Math</em>.pow(this.numbers[0], this.numbers.length)<br/>        }</strong><br/>        let productOfNumbers = 1<br/>        for (let index = 0;index &lt; this.numbers.length; index++) {<br/>            productOfNumbers *= this.numbers[index]<br/>        }<br/>        return productOfNumbers<br/>    }<br/>}</span></pre><p id="cf3c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然这是正确的，但它看起来很粗糙！！废弃它！</p><p id="e6f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好消息是由于<code class="fe nn no np nq b">SameNumbers</code>是<code class="fe nn no np nq b">Numbers</code>类的子类，它可以<strong class="lk jd"> <em class="oa">覆盖</em> </strong>它的父类函数来执行它独特的行为。这使用了<strong class="lk jd"> <em class="oa">多态</em> </strong>的概念，其中子对象可以将其功能变形为不同于父对象的另一种形式。</p><p id="c93b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为此，我们只需要在我们的<code class="fe nn no np nq b">SameNumbers</code>类中重新定义<code class="fe nn no np nq b">sumOf</code>和<code class="fe nn no np nq b">productOf</code>函数，如下所示。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="753a" class="nv mv it nq b gy nw nx l ny nz">class SameNumbers extends Numbers {<br/>    constructor(value, times) {<br/>        super(<em class="oa">Array</em>(times).fill(value));<br/>        this.value = value<br/>        this.times = times<br/>    }</span><span id="fd8a" class="nv mv it nq b gy oq nx l ny nz">    sumOf() {<br/><strong class="nq jd">        return this.value * this.times</strong><br/>    }</span><span id="e976" class="nv mv it nq b gy oq nx l ny nz">    productOf() {<br/><strong class="nq jd">        return <em class="oa">Math</em>.pow(this.value, this.times)</strong><br/>    }<br/>}</span></pre><p id="543f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在可以回去告诉数学家，当它是<code class="fe nn no np nq b">SameNumbers</code>时，我们的程序将优化它的<code class="fe nn no np nq b">sumOf</code>和<code class="fe nn no np nq b">productOf</code>计算。加油</p><h2 id="cd0a" class="nv mv it bd mw ob oc dn na od oe dp ne lr of og ng lv oh oi ni lz oj ok nk iz bi translated">将所有数字视为对象数组。</h2><p id="b728" class="pw-post-body-paragraph li lj it lk b ll ol kd ln lo om kg lq lr on lt lu lv oo lx ly lz op mb mc md im bi translated">为了完成前面所有的计算，我们可以写下面。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="3646" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">numbers1 </em>= new Numbers([1, 2, 3, 4, 5])<br/><em class="oa">console</em>.log(<em class="oa">numbers1</em>.sumOf())<br/><em class="oa">console</em>.log(<em class="oa">numbers1</em>.productOf())<br/>const <em class="oa">numbers2 </em>= new Numbers([6, 7, 8, 9, 10])<br/><em class="oa">console</em>.log(<em class="oa">numbers2</em>.sumOf())<br/><em class="oa">console</em>.log(<em class="oa">numbers2</em>.productOf())<br/><strong class="nq jd">const <em class="oa">numbers3 </em>= new SameNumbers(2, 10)<br/><em class="oa">console</em>.log(<em class="oa">numbers3</em>.sumOf())<br/><em class="oa">console</em>.log(<em class="oa">numbers3</em>.productOf())</strong></span></pre><p id="f1d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了更简洁，我们将使用结构化编程的概念，将它们组合成一个数组，并遍历它们。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="8aba" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">arrayOfNumbers </em>= [<br/><strong class="nq jd">    new Numbers([1, 2, 3, 4, 5]),<br/>    new Numbers([6, 7, 8, 9, 10]),<br/>    new SameNumbers(2, 10),</strong><br/>]</span><span id="c8cd" class="nv mv it nq b gy oq nx l ny nz">for (let index = 0;index &lt; <em class="oa">arrayOfNumbers</em>.length; index++) {<br/><strong class="nq jd">    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].sumOf())<br/>    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].productOf())</strong><br/>}</span></pre><p id="9027" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[ <a class="ae lh" href="https://github.com/elye/demo_javascript_language_evolution/blob/master/oop3.js" rel="noopener ugc nofollow" target="_blank">完整代码在此处</a></p><p id="e4c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，上面的<code class="fe nn no np nq b">SameNumbers</code>和<code class="fe nn no np nq b">Numbers</code>可以被视为同一个<code class="fe nn no np nq b">Numbers</code>对象，它有<code class="fe nn no np nq b">sumOf</code>和<code class="fe nn no np nq b">productOf</code>。因此，将它们组合在一起并很好地循环是可能的。万岁！</p><p id="b3c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">快乐的生活了很多年…直到一个年轻的、精力充沛的、进步的CEO接管了我们的项目。他的口号是“改变或被改变”…</p><h1 id="a7a9" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated"><a class="ae lh" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">功能编程</a></h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oz"><img src="../Images/f63a4c921366b2d8af8cc3d2e327143e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZm9OMQ84bBt5fwuxseTqA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由作者提供</figcaption></figure><p id="a353" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">面向对象编程很好。它允许某种程度的重用。我们可以在这里和这里进行一些小的改动，或者应用于整个<code class="fe nn no np nq b">Numbers</code>类，或者使用<em class="oa">继承</em>和<em class="oa">多态</em>的概念进行一些小的功能转移。</p><p id="c52c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们尽量保持<code class="fe nn no np nq b">Numbers</code>尽可能稳定，变化最小。<code class="fe nn no np nq b">Numbers</code>类的用户必须让我们知道他们是否需要新功能，所以我们为他们添加了新功能。但这需要时间。</p><p id="e54e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，新的首席执行官对我们的进展感到沮丧。外部世界变化如此之快，敏捷开发是一个新概念。变化必须迅速发生。</p><p id="4bd2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首席执行官建议我们进行以下改进。</p><ul class=""><li id="55ff" class="pa pb it lk b ll lm lo lp lr pc lv pd lz pe md pf pg ph pi bi translated"><code class="fe nn no np nq b">Numbers</code>类应该有一个通用函数来适应任何操作，而不是让我们在<code class="fe nn no np nq b">Numbers</code>类中显式编码它们。</li><li id="79c2" class="pa pb it lk b ll pj lo pk lr pl lv pm lz pn md pf pg ph pi bi translated">具体的操作将由<code class="fe nn no np nq b">Numbers</code>类的用户来定义，并通过上面提到的通用操作来发送。</li></ul><p id="4cd1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在面向对象的世界中，我们将不得不创建另一个类，也许叫做<code class="fe nn no np nq b">Operation</code>类，并发送。</p><p id="4323" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">哦，又一个要维护的类！？而且我们的<code class="fe nn no np nq b">Numbers</code>类还会有另一个依赖！？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi po"><img src="../Images/850e1cc0cfbac40268904564ac38b40a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*xDAH1u4yeQmaGncUS96ALw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由于注入，数字类依赖于操作类。</figcaption></figure><h2 id="7461" class="nv mv it bd mw ob oc dn na od oe dp ne lr of og ng lv oh oi ni lz oj ok nk iz bi translated">高阶函数</h2><p id="a3ee" class="pw-post-body-paragraph li lj it lk b ll ol kd ln lo om kg lq lr on lt lu lv oo lx ly lz op mb mc md im bi translated">不过，还好，我确实是跟着编程的潮流走的。JavaScript现在能够将函数作为参数。我们可以避免为此创建新的类。因此，<code class="fe nn no np nq b">Numbers</code>类将不再依赖新的依赖项。</p><p id="6860" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，我创建了一个函数<code class="fe nn no np nq b">operation</code>，它接受一个<code class="fe nn no np nq b">operator</code>函数。而<code class="fe nn no np nq b">operation</code>函数将遍历所有元素并执行<code class="fe nn no np nq b">operator</code>函数提供的必要工作。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="0602" class="nv mv it nq b gy nw nx l ny nz">class Numbers {<br/>    constructor(numbers) {<br/>        this.numbers = numbers<br/>    }<br/><br/>    sumOf() { /* Previous code */ }<br/>    productOf() { /* Previous code */ }<br/><br/><strong class="nq jd">    operation(operator) {<br/>        let result = null<br/>        for (let index = 0;index &lt; this.numbers.length; index++) {<br/>            result = operator(result, this.numbers[index])<br/>        }<br/>        return result<br/>    }</strong><br/>}</span></pre><p id="d9c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">算子函数是什么样子的？让我们试着创建一个返回最大值的操作函数。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="ecc3" class="nv mv it nq b gy nw nx l ny nz">function max(result, current) {<br/>    if (result === null) result = <em class="oa">Number</em>.MIN_SAFE_INTEGER<br/><strong class="nq jd">    if (result &gt; current) return result<br/>    else return current</strong><br/>}</span></pre><p id="19c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为操作符值是在单个项目级别处理的，所以它只需要关心单个项目的处理，在我们的例子中，将较高的数作为最大数。</p><p id="6898" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，让我们试着创建另一个函数，它返回最小值。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="585b" class="nv mv it nq b gy nw nx l ny nz">function min(result, current) {<br/>    if (result === null) result = <em class="oa">Number</em>.MAX_SAFE_INTEGER<br/><strong class="nq jd">    if (result &lt; current) return result<br/>    else return current</strong><br/>}</span></pre><p id="c49b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为操作符值是在单个项目级别处理的，所以它只需要关心单个项目的处理，在我们的例子中，将较小的数作为最大数。</p><p id="9fa2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">酷毙了。现在我们有了通用的<code class="fe nn no np nq b">operation</code>函数，还有上面显示的<code class="fe nn no np nq b">max</code>和<code class="fe nn no np nq b">min</code>函数。让我们在我们的<code class="fe nn no np nq b">Numbers</code>对象的接口上把它们粘在一起。</p><p id="e7b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们只是重用了我们在<em class="oa">面向对象编程</em>部分的代码，并通过为<code class="fe nn no np nq b">operation</code>函数提供<code class="fe nn no np nq b">max</code>和<code class="fe nn no np nq b">min</code>函数来添加两个额外的调用。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="278e" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">arrayOfNumbers </em>= [<br/>    new Numbers([1, 2, 3, 4, 5]),<br/>    new Numbers([6, 7, 8, 9, 10]),<br/>    new SameNumbers(2, 10),<br/>]<br/><br/>for (let index = 0;index &lt; <em class="oa">arrayOfNumbers</em>.length; index++) {<br/>    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].sumOf())<br/>    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].productOf())<br/><strong class="nq jd">    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].operation(max))<br/>    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].operation(min))</strong><br/>}</span></pre><p id="740d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[ <a class="ae lh" href="https://github.com/elye/demo_javascript_language_evolution/blob/master/functional1.js" rel="noopener ugc nofollow" target="_blank">完整代码在此处</a></p><p id="52e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">瞧啊。！这是可行的，因为它正确地返回了数字数组中的<code class="fe nn no np nq b">max</code>和<code class="fe nn no np nq b">min</code>。</p><p id="b9b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">真正好的一点是，<code class="fe nn no np nq b">Numbers</code>类不再需要担心详细的操作，因为它只需要执行一般的操作。<code class="fe nn no np nq b">Numbers</code>对象的用户将定义细节。</p><p id="96a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这真的很好，就像现在一样</p><ul class=""><li id="72b8" class="pa pb it lk b ll lm lo lp lr pc lv pd lz pe md pf pg ph pi bi translated"><code class="fe nn no np nq b">Numbers</code>不再是瓶颈，因为新功能是在<code class="fe nn no np nq b">Numbers</code>之外定义的。</li><li id="2576" class="pa pb it lk b ll pj lo pk lr pl lv pm lz pn md pf pg ph pi bi translated">我们现在变得更加敏捷，因为我们现在可以动态地改变操作，而不需要为它修改<code class="fe nn no np nq b">Numbers</code>。</li></ul><p id="d247" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首席执行官现在很高兴，因为我们可以更快地做出改变。我们已经改变，我们将不会改变:)</p><h2 id="7a19" class="nv mv it bd mw ob oc dn na od oe dp ne lr of og ng lv oh oi ni lz oj ok nk iz bi translated">删除<code class="fe nn no np nq b">sumOf</code>和<code class="fe nn no np nq b">productOf</code></h2><p id="5b1f" class="pw-post-body-paragraph li lj it lk b ll ol kd ln lo om kg lq lr on lt lu lv oo lx ly lz op mb mc md im bi translated">鉴于我要添加的新函数<code class="fe nn no np nq b">Numbers</code>较少，我不会什么都不做，而是查看我们现有的<code class="fe nn no np nq b">sumOf</code>和<code class="fe nn no np nq b">productOf</code>函数。</p><p id="948b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">哇，我发现这两个函数都符合通用<code class="fe nn no np nq b">operation</code>函数的行为。我只需要定义类似于<code class="fe nn no np nq b">min</code>和<code class="fe nn no np nq b">max</code>函数的东西，它在单位项目级别处理如下。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="8f5d" class="nv mv it nq b gy nw nx l ny nz">function sum(result, current) {<br/>    if (result === null) result = 0<br/>    return result + current<br/>}<br/><br/>function product(result, current) {<br/>    if (result === null) result = 1<br/>    return result * current<br/>}</span></pre><p id="64c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">找到了。！！</p><p id="fa29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我现在也可以删除<code class="fe nn no np nq b">Number</code>中的<code class="fe nn no np nq b">sumOf</code>和<code class="fe nn no np nq b">productOf</code>功能。相反，我用通用的<code class="fe nn no np nq b">operation</code>函数替换它们，参数为上面定义的<code class="fe nn no np nq b">sum</code>和<code class="fe nn no np nq b">product</code>函数。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="8d91" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">arrayOfNumbers </em>= [<br/>    new Numbers([1, 2, 3, 4, 5]),<br/>    new Numbers([6, 7, 8, 9, 10]),<br/>    new SameNumbers(2, 10),<br/>]</span><span id="2cd4" class="nv mv it nq b gy oq nx l ny nz">for (let index = 0;index &lt; <em class="oa">arrayOfNumbers</em>.length; index++) {<br/><strong class="nq jd">    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].operation(sum))<br/>    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].operation(product))</strong><br/>    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].operation(max))<br/>    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].operation(min))<br/>}</span></pre><p id="ad71" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[ <a class="ae lh" href="https://github.com/elye/demo_javascript_language_evolution/blob/master/functional2.js" rel="noopener ugc nofollow" target="_blank">完整代码在此处</a></p><p id="a5b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">庆祝！！！我们缩小<code class="fe nn no np nq b">Numbers</code>类的规模！</p><h2 id="9b1b" class="nv mv it bd mw ob oc dn na od oe dp ne lr of og ng lv oh oi ni lz oj ok nk iz bi translated">具有ForEach操作函数的声明式编程</h2><p id="8b75" class="pw-post-body-paragraph li lj it lk b ll ol kd ln lo om kg lq lr on lt lu lv oo lx ly lz op mb mc md im bi translated">因为我现在有更多的空闲时间，所以我读更多的书。我发现有一个函数会用这个函数性的<code class="fe nn no np nq b">forEach</code>语句来代替正常的结构<code class="fe nn no np nq b">for-loop</code>。</p><p id="c11b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我现在可以改变下面的</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="c60a" class="nv mv it nq b gy nw nx l ny nz"><strong class="nq jd">for (let index = 0; index &lt; <em class="oa">arrayOfNumbers</em>.length; index++)</strong> {<br/>    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].operation(sum))<br/>    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].operation(product))<br/>    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].operation(max))<br/>    <em class="oa">console</em>.log(<em class="oa">arrayOfNumbers</em>[index].operation(min))<br/>}</span></pre><p id="a8c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到下面，在这里我们不需要显示如何通过每个项目循环。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="48ad" class="nv mv it nq b gy nw nx l ny nz"><em class="oa">arrayOfNumbers</em>.<strong class="nq jd">forEach</strong>(runAllOperations)<br/><br/>function runAllOperations(item) {<br/>    <em class="oa">console</em>.log(item.operation(sum))<br/>    <em class="oa">console</em>.log(item.operation(product))<br/>    <em class="oa">console</em>.log(item.operation(max))<br/>    <em class="oa">console</em>.log(item.operation(min))<br/>}</span></pre><p id="c301" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[ <a class="ae lh" href="https://github.com/elye/demo_javascript_language_evolution/blob/master/functional3.js" rel="noopener ugc nofollow" target="_blank">完整代码在此处</a></p><p id="bd06" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这叫做<a class="ae lh" href="https://en.wikipedia.org/wiki/Declarative_programming" rel="noopener ugc nofollow" target="_blank"> <em class="oa">声明式编程</em> </a>，因为我们只是声明我们做什么，而不是隐式编码我们如何做<code class="fe nn no np nq b">for-loop</code>(也称为<a class="ae lh" href="https://en.wikipedia.org/wiki/Imperative_programming" rel="noopener ugc nofollow" target="_blank"> <em class="oa">命令式编程</em> </a>)。</p><blockquote class="ot ou ov"><p id="abc9" class="li lj oa lk b ll lm kd ln lo lp kg lq ow ls lt lu ox lw lx ly oy ma mb mc md im bi translated">注意:有一些状态表明Loop的性能较慢。我在这里只是举例说明功能方法，而不是关注性能。</p></blockquote><h2 id="73bd" class="nv mv it bd mw ob oc dn na od oe dp ne lr of og ng lv oh oi ni lz oj ok nk iz bi translated">函数数组</h2><p id="3fb2" class="pw-post-body-paragraph li lj it lk b ll ol kd ln lo om kg lq lr on lt lu lv oo lx ly lz op mb mc md im bi translated">如果我们现在更仔细地观察，下面的内容似乎非常重复。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="8589" class="nv mv it nq b gy nw nx l ny nz"><em class="oa">console</em>.log(item.operation(<strong class="nq jd">sum</strong>))<br/><em class="oa">console</em>.log(item.operation(<strong class="nq jd">product</strong>))<br/><em class="oa">console</em>.log(item.operation(<strong class="nq jd">max</strong>))<br/><em class="oa">console</em>.log(item.operation(<strong class="nq jd">min</strong>))</span></pre><p id="4283" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">唯一的区别是函数名。你知道吗，我们现在也可以将函数存储为数组了！</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="91d3" class="nv mv it nq b gy nw nx l ny nz">const <strong class="nq jd"><em class="oa">mapOfFunctions </em></strong>= [<br/>    <strong class="nq jd">sum, product, max, min,</strong><br/>]</span></pre><p id="6121" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，现在不用显式地执行每个操作，我们可以将它们放入一个循环中(再次使用<code class="fe nn no np nq b">forLoop</code>),如下所示。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="3a79" class="nv mv it nq b gy nw nx l ny nz">const <em class="oa">arrayOfNumbers </em>= [<br/>    new Numbers([1, 2, 3, 4, 5]),<br/>    new Numbers([6, 7, 8, 9, 10]),<br/>    new SameNumbers(2, 10),<br/>]<br/><br/><strong class="nq jd">const <em class="oa">mapOfFunctions </em>= [<br/>    sum, product, max, min,<br/>]</strong><br/><br/><em class="oa">arrayOfNumbers</em>.forEach(runAllOperations)<br/><br/>function runAllOperations(item) {<br/><strong class="nq jd">    <em class="oa">mapOfFunctions</em>.forEach(functionItem =&gt;<br/>        <em class="oa">console</em>.log(item.operation(functionItem))<br/>    )</strong><br/>}</span></pre><p id="cdcf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[ <a class="ae lh" href="https://github.com/elye/demo_javascript_language_evolution/blob/master/functional4.js" rel="noopener ugc nofollow" target="_blank">完整代码在此处</a></p><p id="e7dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">哈利路亚。！这么好看又整洁！</p><h2 id="8f67" class="nv mv it bd mw ob oc dn na od oe dp ne lr of og ng lv oh oi ni lz oj ok nk iz bi translated">消除整个“数字”类！</h2><p id="9438" class="pw-post-body-paragraph li lj it lk b ll ol kd ln lo om kg lq lr on lt lu lv oo lx ly lz op mb mc md im bi translated">与我发现JavaScript提供的<code class="fe nn no np nq b">forLoop</code>函数类似，还有另一个函数<code class="fe nn no np nq b">reduce</code>，它的主要功能是遍历所有元素，并根据提供的函数执行操作。哦，听起来是不是很熟悉？</p><p id="9b25" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">显然，这正是我的<code class="fe nn no np nq b">Numbers</code>操作函数所做的事情！</p><p id="e1d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我不再需要<code class="fe nn no np nq b">Numbers</code>类，因为所有的功能都被删除了(即<code class="fe nn no np nq b">sumOf</code>、<code class="fe nn no np nq b">productOf</code>和<code class="fe nn no np nq b">operation</code>)。此外，要使用<code class="fe nn no np nq b">reduce</code>，它必须应用于数组对象(而不是<code class="fe nn no np nq b">Numbers</code>对象)。</p><p id="eec8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">拜拜<code class="fe nn no np nq b">Numbers</code>。我们将回到最初的数字数组，如下所示。</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="9fc8" class="nv mv it nq b gy nw nx l ny nz"><strong class="nq jd">const <em class="oa">arrayOfNumbers </em>= [<br/>    [1, 2, 3, 4, 5],<br/>    [6, 7, 8, 9, 10],<br/>    <em class="oa">Array</em>(10).fill(2)<br/>]</strong><br/><br/>const <em class="oa">mapOfFunctions </em>= [<br/>    sum, product, max, min,<br/>]<strong class="nq jd"><br/></strong><br/><em class="oa">arrayOfNumbers</em>.forEach(runAllOperations)<br/><br/>function runAllOperations(item) {<br/>    <em class="oa">mapOfFunctions</em>.forEach(functionItem =&gt;<br/>        <em class="oa">console</em>.log(<strong class="nq jd">item.reduce(functionItem)</strong>)<br/>    )<br/>}</span></pre><p id="8979" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[ <a class="ae lh" href="https://github.com/elye/demo_javascript_language_evolution/blob/master/functional5.js" rel="noopener ugc nofollow" target="_blank">完整代码在此处</a></p><p id="f069" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">雅虎！！又短又甜。</p><h2 id="16a4" class="nv mv it bd mw ob oc dn na od oe dp ne lr of og ng lv oh oi ni lz oj ok nk iz bi translated">链接功能</h2><p id="50b9" class="pw-post-body-paragraph li lj it lk b ll ol kd ln lo om kg lq lr on lt lu lv oo lx ly lz op mb mc md im bi translated">函数式编程的另一个好处是，我们可以让函数返回一个对象，该对象包含要调用的后续函数。</p><p id="e076" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了实现连续操作，我们可以将我们的操作从</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="b894" class="nv mv it nq b gy nw nx l ny nz"><em class="oa">arrayOfNumbers</em>.<strong class="nq jd">forEach</strong>(runAllOperations)<br/><br/>function runAllOperations(item) {<br/>    <em class="oa">mapOfFunctions</em>.<strong class="nq jd">forEach</strong>(functionItem =&gt;<br/>        <em class="oa">console</em>.log(item.reduce(functionItem))<br/>    )<br/>}</span></pre><p id="8597" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到</p><pre class="ks kt ku kv gt nr nq ns nt aw nu bi"><span id="429d" class="nv mv it nq b gy nw nx l ny nz"><em class="oa">arrayOfNumbers</em><strong class="nq jd"><em class="oa"><br/>    </em></strong>.<strong class="nq jd">map</strong>(it =&gt; <em class="oa">mapOfFunctions</em><strong class="nq jd"><em class="oa"><br/>        </em></strong>.<strong class="nq jd">map</strong>(functionItem =&gt;<br/>            it.reduce(functionItem)))<br/>    .<strong class="nq jd">flatMap</strong>(it =&gt; it)<br/>    .forEach(it =&gt; <em class="oa">console</em>.log(it))</span></pre><p id="4d7a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[ <a class="ae lh" href="https://github.com/elye/demo_javascript_language_evolution/blob/master/functional6.js" rel="noopener ugc nofollow" target="_blank">完整代码在此处</a></p><p id="339b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用<code class="fe nn no np nq b">forEach</code>通常是终端函数，因为它不返回任何东西。为了帮助链接，我们将使用<code class="fe nn no np nq b">map</code>来代替，因为它将返回另一个数组。</p><p id="183f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">结果的<code class="fe nn no np nq b">reduce</code>是一个数组的数组。然后我们使用<code class="fe nn no np nq b">flatMap</code>将它们放入一个数组中，然后<code class="fe nn no np nq b">console.log</code>取出数组中的每个元素(以产生与链接前相同的结果)</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/44bf1c5297b3af236c20062ea24101f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*k8i8CEwQekB_FIxEti31zw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">函数链的图示</figcaption></figure><p id="a3b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">又短又甜！！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="19ae" class="mu mv it bd mw mx pq mz na nb pr nd ne ki ps kj ng kl pt km ni ko pu kp nk nl bi translated">直到现在…</h1><p id="c3dd" class="pw-post-body-paragraph li lj it lk b ll ol kd ln lo om kg lq lr on lt lu lv oo lx ly lz op mb mc md im bi translated">我希望您从不同时代的编程范例中获得了愉快的经历。他们都在定义我们今天所拥有的东西中扮演了重要的角色，尽管他们中的大多数并不完美，却为今天编程的形成留下了巨大的足迹。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pv pw l"/></div></figure></div></div>    
</body>
</html>