<html>
<head>
<title>SwiftUI: Create an Image Carousel using a Timer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI:使用定时器创建一个图像轮播</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/swiftui-create-an-image-carousel-using-a-timer-ed546aacb389?source=collection_archive---------7-----------------------#2020-01-08">https://levelup.gitconnected.com/swiftui-create-an-image-carousel-using-a-timer-ed546aacb389?source=collection_archive---------7-----------------------#2020-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f0d2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在SwiftUI中构建一个带有计时器的自动变化图像转盘。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/932e33651f399aa6c45ef082fa507c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wBZLEVN_yWYqsv1b"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@loic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Djim Loic </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="5c3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图像传送带是在iPhone上以最小的空间向用户显示多张照片的好方法。</p><p id="1563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这就是我们在本教程中要完成的任务:</strong> <br/>每三秒钟图像就会切换一次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/44160c6302b95c64dfc2de2f7a5f71e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*iamHCt4l_OJabDKKMv7gFw.gif"/></div></figure><h1 id="edd6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">入门指南</h1><p id="e0a7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Xcode中创建新的SwiftUI项目。确定您运行的是macOS Catalina，并且安装了Xcode 11。(允许您使用SwiftUI)</p><p id="fcbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开Xcode →文件→新建→项目</p><p id="ebad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">确保用户界面设置为SwiftUI </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/86b76e9e1844253d4006dafaee87c227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rA-ESq2N25vbq5zTbvwyzQ.png"/></div></div></figure><p id="4a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想看我正在使用的图片，这里有链接:</p><p id="b3a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> ///背景</strong></p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="91d4" class="mz lx it mv b gy na nb l nc nd">https://www.pexels.com/photo/man-in-bus-247929/<br/>https://www.pexels.com/photo/black-crt-tv-showing-gray-screen-704555/<br/>https://www.pexels.com/photo/black-cassette-tape-on-top-of-red-and-yellow-surface-1626481/</span></pre><p id="c47c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> ///人</strong></p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="4eb5" class="mz lx it mv b gy na nb l nc nd"><a class="ae ky" href="https://www.pexels.com/photo/adolescent-adult-black-and-white-casual-270968/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/photo/adolescent-adult-black-and-white-casual-270968/</a></span></pre><p id="5132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦创建了项目，打开<code class="fe ne nf ng mv b">ContentView.swift</code>并添加下面的代码来创建这个项目的布局框架。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="571c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码会产生这样的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/c0d4d3980556e6416ab334262105c04c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wA4HoNqMLFgPjRTkmgFa4w.png"/></div></div></figure><p id="4227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要创建我们的<code class="fe ne nf ng mv b">ImageCarouselView</code>,它将包含必要的逻辑，以动画显示图像随时间的变化。</p><h1 id="a320" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">我们如何做到这一点？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/b44b0fa87abec96cf72cbd21b7c58fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gdA-XPxQEYGDscSOmZvhsA.png"/></div></div></figure><p id="52c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的HStack(粉红色的框架)将有一个当前的索引，显示当前有多少张照片。对于这个例子，我有3个图像，我们的开始索引是0，结束索引是2。</p><p id="348c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们的3秒计时器触发时，我们将获取下一个索引，并将其乘以我们的帧的宽度。这将给我们新的偏移量，这将是下一幅图像的起始<code class="fe ne nf ng mv b">(x:y:)</code>坐标。</p><p id="bf6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该视图现在看起来类似于:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/e3b2d361c2d01b27e0f43d09a472c54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gu_PV2L-Z_GdyV-J5AvJEg.png"/></div></div></figure><p id="1756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将继续这种模式，直到我们达到我们的最终索引，在这种情况下，下一个索引将从0开始。</p><p id="54c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个新的Swift文件并将其命名为<code class="fe ne nf ng mv b">ImageCarouselView.swift</code>。</p><p id="5cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将以下代码添加到新创建的Swift文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><ol class=""><li id="5f26" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">确保导入SwiftUI和Combine，因为下面的代码不起作用。</li><li id="7520" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">我们声明了一个名为<code class="fe ne nf ng mv b">ImageCarouselView</code>的<code class="fe ne nf ng mv b">Struct</code>，其中包含在名称<code class="fe ne nf ng mv b">Content</code>中的视图属于视图类型。这基本上允许我们创建一个容器视图，看起来像这样:<code class="fe ne nf ng mv b">ImageCarouselView {</code> <br/> <code class="fe ne nf ng mv b"> Text("Hello World")</code> <br/> <code class="fe ne nf ng mv b">}</code> <br/>在这种情况下，我们的<code class="fe ne nf ng mv b">private var content: Content</code>是对上面声明中的<code class="fe ne nf ng mv b">{ }</code>之间的所有内容的引用，即<br/> <code class="fe ne nf ng mv b">Text(“Hello World”)</code></li><li id="13ba" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">我们需要知道将会有多少图像，还需要为将要呈现的内容存储一个变量。如上文第2点所述。</li><li id="737a" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">保持状态，以我们的变化指数。这将允许我们的视图在这个变量更新时更新。</li><li id="8549" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">一个<code class="fe ne nf ng mv b">Time.Publisher</code>将使用<code class="fe ne nf ng mv b">.main</code>运行循环选项(因为它正在更新我们的用户界面)和<code class="fe ne nf ng mv b">.common</code>模式在我们的应用程序中与其他事件一起运行。<br/>我们还使用<code class="fe ne nf ng mv b">.autoConnect()</code>来自动化与可连接发布者的连接或断开的过程。</li><li id="15bf" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">我们的自定义<code class="fe ne nf ng mv b">init()</code>接受图像的数量并利用<code class="fe ne nf ng mv b">@ViewBuilder</code>。<code class="fe ne nf ng mv b">ViewBuilder</code>是一个很棒的工具，它允许我们创建一个定制的视图容器来在这个容器中呈现特定的视图。(修卡)</li><li id="8fe3" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">创建我们的<code class="fe ne nf ng mv b">PreviewProvider</code>。因为我们已经利用了内容闭包来呈现这个容器中的孩子，所以我们需要传入一个视图。在这种情况下，<code class="fe ne nf ng mv b">Text(“Hello World”)</code>。</li></ol><p id="585c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在应该在屏幕右侧的实时预览中心呈现文本“Hello World”。</p><p id="ddd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，添加以下代码来创建滚动效果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><ol class=""><li id="150c" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">我们添加一个几何阅读器来获取包含该视图的父视图框架。</li><li id="ff18" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">创建一个HStack。这将容纳我们所有的3个图像。我们指定间距为0，这样边缘就对齐了。</li><li id="d1f7" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">我们现在呈现来自<code class="fe ne nf ng mv b">@ViewBuilder</code>的内容。在我们的<code class="fe ne nf ng mv b">PreviewProvider</code>中指定的内容将是包含在<code class="fe ne nf ng mv b">HStack</code>中的彼此相邻的3幅图像。</li><li id="2e71" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">我们将<code class="fe ne nf ng mv b">HStack</code>的框架指定为父视图的宽度和高度。在我们这里，<code class="fe ne nf ng mv b">(width: UIScreen.main.bounds.width, height: 300)</code>。这将只在屏幕上显示一个图像，另外两个在它的右边。</li><li id="ee5c" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">我们用当前索引乘以父索引宽度的倒数来得到偏移量。这将提供向左的偏移，因此新图像看起来像是从右边移动过来的。</li><li id="4d48" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">添加一个<code class="fe ne nf ng mv b">.spring()</code>的动画。这将为我们自动更新对我们的<code class="fe ne nf ng mv b"> HStack()</code>的所有更改，并显示一个spring动画。</li><li id="ecd3" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">每当我们的出版商改变时，就会调用<code class="fe ne nf ng mv b">.onReceive(self.timer) { _ in }</code>。在这种情况下，我们的发布者将每3秒发布一次更新。这将接收更新，然后在我们的闭包中，我们可以更新当前的索引。我们使用当前的索引，并使用mod运算符将范围保持在0–2之间。我们的索引顺序如下:0 → 1 → 2 → 0 …等等。</li></ol><p id="99b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是您的视图当前应该看起来的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c55dedd66c11b9bd30faa8dbad58ff7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ndCA-7whDwhpNkNPfYiVVA.gif"/></div></figure><p id="0c6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以回到<code class="fe ne nf ng mv b">ContentView.swift </code>并将<br/> <code class="fe ne nf ng mv b">// Add the ImageCarouselView Here.</code>替换为</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="083e" class="mz lx it mv b gy na nb l nc nd">GeometryReader { geometry in<br/> ImageCarouselView(numberOfImages: 3) {<br/>    Image(“image_carousel_1”)<br/>      .resizable()<br/>      .scaledToFill()<br/>      .frame(width: geometry.size.width, height:geometry.size.height)<br/>      .clipped()<br/>     Image(“image_carousel_2”)<br/>     .resizable()<br/>      .scaledToFill()<br/>     .frame(width: geometry.size.width, height:         geometry.size.height)<br/>     .clipped()<br/>    Image(“image_carousel_3”)<br/>     .resizable()<br/>     .scaledToFill()<br/>     .frame(width: geometry.size.width, height: geometry.size.height)<br/>     .clipped()<br/>    }<br/> }.frame(height: 300, alignment: .center)</span></pre><p id="e23a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们真正做的是向我们的视图容器中添加3个子容器，这3个子容器都是具有父容器的指定宽度和高度的图像。</p><p id="9ef6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们剪辑图像，使它们不会超出我们给它们的框架，因为它们是<code class="fe ne nf ng mv b">.scaledToFill()</code>。</p><p id="bf41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们在<code class="fe ne nf ng mv b">ImageCarouselView.swift PreviewProvider</code>中所拥有的。</p><p id="88fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们目前的应用程序是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/a6156babf14c61203b2443d5286bc7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*N95hpHjNPZ3hxKZ_PoWOXw.gif"/></div></figure><h1 id="ce5b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">底部的当前页面指示器呢？</h1><p id="3b33" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们可以为转盘中的每个图像创建一个新的圆形视图。根据当前显示的索引，我们可以将圆形背景图像更新为不同的颜色。</p><p id="e291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当当前索引改变时，这将“重新渲染”,从而自动更新我们的背景颜色。</p><p id="6aac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这段代码添加到<code class="fe ne nf ng mv b">ImageCarousel.swift</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><ol class=""><li id="6849" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">我们将图像的<code class="fe ne nf ng mv b">HStack</code>和新创建的<code class="fe ne nf ng mv b">HStack</code>包装在一个<code class="fe ne nf ng mv b">ZStack</code>中。这将允许我们把我们的页面视图指示点放在我们的图像上面。</li><li id="4a67" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">增加间距为3的<code class="fe ne nf ng mv b">HStack</code>。这将在每个圆形视图之间放置3px的间距。</li><li id="ff77" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">从<code class="fe ne nf ng mv b">0..&lt;self.numberOfImages</code>开始循环范围。在这种情况下，我们将从0 → 2。我们为创建的每个视图分配一个惟一的id。在这种情况下，它只是我们每次迭代得到的索引。这由<code class="fe ne nf ng mv b">\.self</code>表示。</li><li id="b202" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">根据正在显示的视图是否为活动视图，创建一个宽度和高度均为8x8或10x10的<code class="fe ne nf ng mv b">Circle()</code>视图。<br/>我们还根据它是否是活动视图来改变前景色。<br/>底部加少量填充，添加动画视图修改器。当图像的索引从我们的<code class="fe ne nf ng mv b">Time.Publisher.</code>改变时，这将自动显示颜色和帧的变化</li></ol><h1 id="4ca3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">就是这样！</h1><p id="42d3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您已经成功创建了页面视图。这可以通过在<code class="fe ne nf ng mv b">@ViewBuilder</code>闭包内添加图像并增加图像的数量来扩展到更多的图像。</p><h1 id="a1a9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">概述</h1><p id="9359" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><code class="fe ne nf ng mv b">GeometryReader</code>非常适合创建基于父视图的视图。</p><p id="53fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng mv b">ViewBuilder</code>允许我们创建一个与<code class="fe ne nf ng mv b">HStack</code>、<code class="fe ne nf ng mv b">VStack</code>和<code class="fe ne nf ng mv b">ZStack</code>非常相似的容器视图。</p><p id="7b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在SwiftUI中，重新渲染之间的动画非常容易。</p><p id="1fe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击这里查看完整的源代码。</p><div class="oa ob gp gr oc od"><a href="https://github.com/bbaars/SwiftUI-Image-Carousel" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">bbaars/swift ui-图像-旋转木马</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="om l"><div class="on l oo op oq om or ks od"/></div></div></a></div></div></div>    
</body>
</html>