<html>
<head>
<title>React Tips — Data Flow and Pure Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React提示—数据流和纯组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-tips-data-flow-and-pure-components-5995274eeb54?source=collection_archive---------15-----------------------#2020-05-17">https://levelup.gitconnected.com/react-tips-data-flow-and-pure-components-5995274eeb54?source=collection_archive---------15-----------------------#2020-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b524777d1d9cbf95bb50d80039bf54e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S2u5SG4fKkUo3UPj"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@chilipeper?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ariel Schmunck </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="437a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React是最常用的前端库，用于构建现代的交互式前端web应用程序。它还可以用来构建移动应用程序。</p><p id="f270" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何在组件之间共享数据，以及如何用纯组件加速渲染。</p><h1 id="b468" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">有流量的数据流</h1><p id="8e05" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Flux architecture是一种在JavaScript应用程序中创建数据层的方法。它的工作原理是在一个集中的数据存储中添加数据层。对存储的更新是通过将更新存储状态的动作分派给存储来完成的。</p><p id="dc45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何需要数据的组件都可以订阅数据存储的最新更新，以获得相关的状态。</p><p id="616b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是组织我们的数据层结构的好方法，因为它消除了在组件之间直接共享数据的需要。所有数据都在一个地方。</p><p id="6e95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这减少了在组件之间共享数据所引起的混乱，特别是当我们需要通过在一系列相关组件之间传递数据来在不相关的组件之间传递数据时。</p><p id="cc54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现Flux架构最常见的库是Redux。我们可以通过编写以下代码来使用它:</p><p id="991d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">index.js</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4dab" class="mt lf it mk b gy mu mv l mw mx">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { createStore } from "redux";<br/>import App from "./App";<br/>import { Provider } from "react-redux";</span><span id="2565" class="mt lf it mk b gy my mv l mw mx">const counter = (state = 0, action) =&gt; {<br/>  switch (action.type) {<br/>    case "INCREMENT":<br/>      return state + 1;<br/>    default:<br/>      return state;<br/>  }<br/>};</span><span id="e1ed" class="mt lf it mk b gy my mv l mw mx">const store = createStore(counter);</span><span id="fd72" class="mt lf it mk b gy my mv l mw mx">const rootElement = document.getElementById("root");<br/>ReactDOM.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;Provider store={store}&gt;<br/>      &lt;App /&gt;<br/>    &lt;/Provider&gt;<br/>  &lt;/React.StrictMode&gt;,<br/>  rootElement<br/>);</span></pre><p id="795a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">App.js</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4004" class="mt lf it mk b gy mu mv l mw mx">import React from "react";<br/>import { useSelector, useDispatch } from "react-redux";</span><span id="5fdd" class="mt lf it mk b gy my mv l mw mx">export default function App() {<br/>  const count = useSelector(state =&gt; state);<br/>  const dispatch = useDispatch();</span><span id="f332" class="mt lf it mk b gy my mv l mw mx">  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={() =&gt; dispatch({ type: "INCREMENT" })}&gt;Increment&lt;/button&gt;<br/>      &lt;p&gt;{count}&lt;/p&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="50fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用了React-Redux API的React hooks版本。首先，我们用以下内容创建了商店:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9870" class="mt lf it mk b gy mu mv l mw mx">const counter = (state = 0, action) =&gt; {<br/>  switch (action.type) {<br/>    case "INCREMENT":<br/>      return state + 1;<br/>    default:<br/>      return state;<br/>  }<br/>};</span><span id="4d20" class="mt lf it mk b gy my mv l mw mx">const store = createStore(counter);</span></pre><p id="349c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们将<code class="fe mh mi mj mk b">Provider</code>组件包装在<code class="fe mh mi mj mk b">index.js</code>中我们应用程序的入口点周围。我们传入<code class="fe mh mi mj mk b">store</code>对象，这样我们就可以访问它。</p><p id="15b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过首先创建<code class="fe mh mi mj mk b">counter</code>减速器来创建<code class="fe mh mi mj mk b">store</code>，减速器更新<code class="fe mh mi mj mk b">state</code>。然后我们将<code class="fe mh mi mj mk b">counter</code>减速器传递给<code class="fe mh mi mj mk b">createStore</code>来创建商店。</p><p id="2274" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mh mi mj mk b">App</code>中，我们通过使用<code class="fe mh mi mj mk b">useDispatch</code>钩子来访问存储，这样我们就可以用返回的函数来分派动作。然后我们使用<code class="fe mh mi mj mk b">useSelector</code>钩子通过回调从我们的存储中返回状态。</p><p id="9c56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们这样做了，当我们点击增量按钮时，我们调用<code class="fe mh mi mj mk b">dispatch</code>。在<code class="fe mh mi mj mk b">dispatch</code>函数调用中，我们用<code class="fe mh mi mj mk b">'INCREMENT'</code>动作传入了<code class="fe mh mi mj mk b">type</code>属性，这意味着<code class="fe mh mi mj mk b">counter</code>减速器中的<code class="fe mh mi mj mk b">'INCREMENT'</code>动作将被完成。</p><p id="a041" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们单击增量时，<code class="fe mh mi mj mk b">count</code>将会更新，因为每次调度<code class="fe mh mi mj mk b">'INCREMENT'</code>动作时，我们都会用<code class="fe mh mi mj mk b">state + 1</code>更新存储。</p><h1 id="0a22" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">纯成分</h1><p id="789b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">纯组件是实现<code class="fe mh mi mj mk b">shouldComponentUpdate</code>方法的React组件。</p><p id="c5a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现<code class="fe mh mi mj mk b">shouldComponentUpdate</code>的总是基于类的组件。我们还可以通过返回从传入的属性中派生的结果来创建不实现该功能的组件。</p><p id="0fa1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般来说，如果一个组件的返回值仅仅由它的输入值决定，那么这个组件就是纯的。</p><p id="3860" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以创建一个基于类别的组件，并按如下方式使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2f4a" class="mt lf it mk b gy mu mv l mw mx">import React from "react";</span><span id="73b0" class="mt lf it mk b gy my mv l mw mx">class Pecentage extends React.PureComponent {<br/>  render() {<br/>    const { score, total } = this.props;<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;span&gt;{Math.round((score / total) * 100)}%&lt;/span&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="a332" class="mt lf it mk b gy my mv l mw mx">export default function App() {<br/>  return &lt;Pecentage score={70} total={100} /&gt;;<br/>}</span></pre><p id="8c8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe mh mi mj mk b">Percentage</code>组件，它实现了<code class="fe mh mi mj mk b">React.PureComponent</code>。</p><p id="5a42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它需要两个道具，<code class="fe mh mi mj mk b">score</code>和<code class="fe mh mi mj mk b">total</code>，我们返回从<code class="fe mh mi mj mk b">score</code>除以<code class="fe mh mi mj mk b">total</code>得到的百分点。</p><p id="ecff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">shouldComponentUpdate</code>是自动包含的，它对数据进行简单的比较，所以我们不需要自己写一个来做比较，因为两个道具都是数字。因此，只有当属性的值改变时，React才会重新渲染组件。</p><p id="c6ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果道具是对象，那么我们需要自己实现方法并进行检查。</p><p id="baaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">给定相同的输入，它返回相同的输出，所以它是一个纯组件。</p><p id="3272" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以如下实现纯函数组件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bf22" class="mt lf it mk b gy mu mv l mw mx">import React from "react";</span><span id="3d1c" class="mt lf it mk b gy my mv l mw mx">const Pecentage = ({ score, total }) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;span&gt;{Math.round((score / total) * 100)}%&lt;/span&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="9b06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只是在需要的时候传入道具，给定相同的输入，它也会返回相同的输出，所以这是一个纯组件。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/8e8144385ac7db2109e2f5ea65466bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yy213suYH_ANmdl2"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kf" href="https://unsplash.com/@jernejgraj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jernej Graj </a>拍摄的照片</figcaption></figure><h1 id="4851" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="7da1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们的应用程序有多个组件需要共享数据，那么我们需要Flux架构。要实现它，最好的方法是使用像Redux这样流行的现有库。</p><p id="1768" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">纯组件通过React进行优化，以加快渲染速度。他们只在道具改变时才渲染。变化检测是通过浅层比较完成的。</p></div></div>    
</body>
</html>