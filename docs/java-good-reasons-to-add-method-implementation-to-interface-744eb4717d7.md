# Java:向接口添加方法实现的好理由

> 原文：<https://levelup.gitconnected.com/java-good-reasons-to-add-method-implementation-to-interface-744eb4717d7>

## 通过实现接口中定义的方法，创建更干净、更健壮的代码。

![](img/86984d4bbf9cc977da1e9f40fbce5654.png)

照片由[迈克·多纳](https://unsplash.com/@dorner?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

Java 和其他编程语言中定义的*接口*概念背后的思想是定义类必须实现或符合的契约或行为。通过定义一个*接口*，服务提供者可以列出一组需求，任何类都应该遵循这些需求来使用所提供的服务。

在 2014 年发布的 Java 8 之前的 Java 版本中，*接口*允许您定义方法签名和常量，而无需任何实现。符合特定接口的类为声明的方法提供了实际的实现。

考虑一个具体的例子，为了能够使用`Arrays`类的`sort`方法对一组对象进行排序，所有的对象都必须为`Comparable`接口提供一个实现

如果你在一个数组中存储了一个`Vehicle` 对象，要使用数组的排序方法，你必须实现这个`Comparable` 接口并提供实际的代码实现来执行`Vehicle` 对象的比较。

Java 8 和更高版本不仅仅允许您定义允许的方法签名，还允许您在接口定义中提供一些代码实现。例如，除了在`Comparable` 接口中定义`compareTo(Object other);`声明之外，现在还允许在接口中提供实际的实现。

你为什么需要这么做？为什么不在接口中定义可用操作列表和实现类中的实际实现之间保持严格的分离呢？

能够在接口定义中提供代码实现可以产生不太复杂、更干净和更健壮的代码。有几种方法可以实现这一点。

# 通过静态方法降低复杂性

通常情况下，作为服务提供者，当你为了访问某些特定的服务而提供需要符合的接口时，你还需要提供一些方法来提供与你所提供的服务相关的一些实用功能。

遵循的方法是提供一个接口和另一个包含所需实用函数的实用类。任何需要这些服务的消费对象都需要首先符合接口，然后从附带的实用程序类中访问所需的功能。

更干净的方法可能是直接在接口中创建这些实用函数作为静态方法，这样就不再需要实用类了。

在 Java 实现的`Path`接口和相应的`Paths` 实用程序类中可以找到一个很好的例子

一个`Path`接口代表了一个可以用来在文件系统中定位文件的对象，它由目录和文件名元素的层次序列组成。

在 Java 11 之前，配套的实用程序类 Paths 提供了`get` 方法，可用于从字符串或 URI 构建文件或目录的路径。

然而，从 Java 11 开始，这个功能现在是定义为静态方法的路径接口的一部分。

因此不再需要`Paths` 实用程序类。现在，您可以通过调用 path 接口的静态`of` 方法来构建路径

`Path.of(“/foo/bar/gus”)`

作为开发人员，当您实现自己的接口时，您不需要为实用程序方法提供单独的伴生类，只需将这些方法作为静态类移动到接口中。这将确保您的代码不那么复杂，并且更加整洁。

# 使用默认方法的未来代码

假设您提供了一些定义了接口的服务，几年后，您决定在发布新版本时向接口添加一些新方法。

像这样添加一个新方法会破坏实现您的接口的所有客户端代码，并且该类将不再编译，因为没有新方法的实现。

避免这种情况的方法是为任何接口方法提供默认实现。这被称为*接口进化*，它确保您能够在不破坏任何现有代码的情况下向您的接口定义添加新方法。

例如，考虑 Java 中定义的`Iterable` 接口。在 Java 8 中，更新了这个接口，并添加了一个新方法`forEach`

像这样添加一个新方法会导致这个接口的所有实现类都无法编译，并出现编译错误。为了避免这个错误，这个方法被定义为一个默认方法，并且在接口定义代码中提供了一个默认实现。

# 参考

核心 Java 第 1 卷-基础，第 11 版

[Java 平台版本 14 API 规范](https://docs.oracle.com/en/java/javase/14/docs/api/index.html)

# 结论

利用后 Java 8 的能力将代码实现添加到接口定义中有助于创建更干净和更健壮的代码。我试图分享一些例子和见解，以支持向接口添加代码实现。感谢您抽出时间阅读我的文章