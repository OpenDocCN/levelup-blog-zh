<html>
<head>
<title>Implementing a dark theme toggle with react-redux and styled-components 💅</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用react-redux和styled-components实现深色主题切换💅</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-a-dark-theme-toggle-with-react-redux-and-styled-components-e637c4d41e2f?source=collection_archive---------1-----------------------#2020-04-08">https://levelup.gitconnected.com/implementing-a-dark-theme-toggle-with-react-redux-and-styled-components-e637c4d41e2f?source=collection_archive---------1-----------------------#2020-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="febf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速的谷歌搜索显示，已经有很多很多关于这个话题的帖子。然而，为了磨练我的技能，我决定自己从头开始构建它。</p><p id="083a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是我们将构建的内容:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ac4b97a69d54ed736d40425b956b3b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9xYmio685jE4FYIBViHO7g.gif"/></div></div></figure><h2 id="51ef" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">创建-反应-应用</h2><p id="d476" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">为了保持简单明了，我们将从<code class="fe lv lw lx ly b">npx create-react-app dark-toggle</code>开始。当我们在命令行中时，让我们也把npm包拿出来:</p><p id="d850" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lv lw lx ly b">npm install styled-components styled-theming redux react-redux</code></p><ol class=""><li id="3fff" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated"><strong class="jp ir"> styled-components </strong>:我们将使用这个库来创建封装了它们自己样式的独立组件</li><li id="9be0" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">样式化主题化:这个库提供了一个非常干净的API来处理你的样式化组件中的多个主题</li><li id="93aa" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated"><strong class="jp ir"> redux </strong>和<strong class="jp ir"> react-redux </strong>将承担状态管理的重任</li></ol><p id="610e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们<code class="fe lv lw lx ly b">App.js</code>的初稿，显示了标题和一个复选框:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/46ec04a6b9ce1528273c1e3f08af7f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIVfQP7Z2fy5en_NazRKWw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">太神奇了。</figcaption></figure><h2 id="861e" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">现在，提供一个主题</h2><p id="0075" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">我们需要告诉我们的组件如何根据当前的主题来设计自己的风格。</p><p id="d434" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，styled-components有<a class="ae mu" href="https://gist.github.com/btodts/4142f03e6808a90aa1bcc77e4f99888e" rel="noopener ugc nofollow" target="_blank">内置的主题支持</a>。你只需用一个<code class="fe lv lw lx ly b">ThemeProvider</code>组件包装你的组件，一个<code class="fe lv lw lx ly b">theme</code>道具就可供所有人使用。</p><p id="3318" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们更新后的<code class="fe lv lw lx ly b">App.js</code>的样子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b467" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意到奇怪的事情了吗？我们传递给<code class="fe lv lw lx ly b">ThemeProvider</code>的<code class="fe lv lw lx ly b">theme</code>道具的对象看起来不像主题。这就是<strong class="jp ir">风格化主题</strong>的用武之地。这里我们没有传递整个主题对象，而是传递给提供者一个带有“主题”属性的对象。在我们的例子中，可能的主题是<code class="fe lv lw lx ly b">light</code>和<code class="fe lv lw lx ly b">dark</code>。</p><p id="ba78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管这个对象是任意的。例如，在一个多品牌的应用程序中，您可以传递一个带有属性<code class="fe lv lw lx ly b">brand</code>的对象，或者甚至将两者结合起来(以支持每个品牌的亮/暗模式)。让我们在应用程序中实现这两个主题:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">我完全没有从StackOverflow的黑暗主题里偷深色🙊</figcaption></figure><p id="a728" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">花点时间欣赏一下<strong class="jp ir">风格化主题</strong>提供的<code class="fe lv lw lx ly b">theme</code> -api的整洁:</p><pre class="km kn ko kp gt mv ly mw mx aw my bi"><span id="35a8" class="kx ky iq ly b gy mz na l nb nc">export const backgroundColor = theme("theme", {  <br/>  light: "#eff2f9",  <br/>  dark: "#2d2d2d",<br/>});</span><span id="8909" class="kx ky iq ly b gy nd na l nb nc">const Container = styled.div`<br/>  ...<br/>  background-color: ${backgroundColor};<br/>`;</span></pre><p id="be2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个api使得组件可以非常容易地根据当前活动的主题改变它们的样式。再次使用我们的多品牌示例，这样维护您的不同风格要容易得多(另外，它仍然完全由组件自己决定样式)。</p><p id="cbde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更改您传递给<code class="fe lv lw lx ly b">ThemeProvider</code>的主题以查看不同的风格:</p><div class="km kn ko kp gt ab cb"><figure class="ne kq nf ng nh ni nj paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/60ffdf87d788388acbc83dd46fa10110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*cIVfQP7Z2fy5en_NazRKWw.png"/></div></figure><figure class="ne kq nk ng nh ni nj paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><img src="../Images/3558d2f60890a7a9639e0e740082a691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*BT1mxjJtJd_nekwNr46g3g.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk nl di nm nn translated">{主题:"光明" }对{主题:"黑暗" }</figcaption></figure></div><p id="083f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很好，我们的<code class="fe lv lw lx ly b">ThemeProvider</code>只是将一个外延(一个我们可以按照自己认为合适的方式构造的对象)传递给我们的组件，告诉它们当前什么样式是活动的。</p><p id="f0ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过一个非常简洁的<code class="fe lv lw lx ly b">theme</code> api，我们的组件根据<code class="fe lv lw lx ly b">ThemeProvider</code>传递的对象决定应用什么样式。现在，对复选框！</p><h2 id="c119" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">输入react-redux</h2><p id="e872" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">为了实现切换功能，我们需要一个地方来存储当前选择的主题和切换它的方法。理想情况下，这应该在我们的应用程序中可用。这就是<strong class="jp ir"> react-redux </strong>发挥作用的地方。</p><p id="c6ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">诚然，对于我们的简单应用程序，redux是非常大材小用。然而，我计划在这个应用程序的后面使用redux进行状态管理，所以现在就让我们开始吧。</p><p id="0456" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要三样东西:</p><ol class=""><li id="ec9b" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">一个真正的<code class="fe lv lw lx ly b">store</code>来守住这个州</li><li id="c401" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">派遣意图的行动</li><li id="7ffa" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">一个减速器来处理这个意图</li></ol><p id="f30f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这很简单:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">在真实的应用程序中，你可能不应该把所有的reducers放在一个文件中。</figcaption></figure><p id="947e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用这个商店，只需用来自<code class="fe lv lw lx ly b">react-redux</code>的<code class="fe lv lw lx ly b">Provider</code>包装您的<code class="fe lv lw lx ly b">App</code>组件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="55e8" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">DarkThemeProdiver</h2><p id="78c4" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">我们需要某种方式将redux商店中的状态连接到应用程序中的<code class="fe lv lw lx ly b">ThemeProvider</code>。为了清楚起见，我决定引入一个单独的提供者来处理这个问题。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="acef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们仔细看看:</p><ol class=""><li id="1116" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">我们使用<code class="fe lv lw lx ly b">useSelector</code>钩子通过选择器函数从我们的存储中获取状态</li><li id="4cff" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">我们返回我们的<code class="fe lv lw lx ly b">ThemeProvider</code>,并根据redux存储中的状态为它提供一个主题</li></ol><p id="5427" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们更新<code class="fe lv lw lx ly b">App.js</code>，以便它使用我们新实现的<code class="fe lv lw lx ly b">DarkThemeProvider</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="f121" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">让我们切换</h2><p id="b67a" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">太好了！现在剩下的就是每当复选框被点击时调度<code class="fe lv lw lx ly b">TOGGLE_DARKTHEME</code>动作。为此，我将复选框重构为一个单独的组件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="cd8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lv lw lx ly b">DarkThemeToggle</code>组件从我们的存储中提取所需的状态，同样使用<code class="fe lv lw lx ly b">useSelector</code>钩子。我们还使用了来自<strong class="jp ir"> react-redux </strong>的另一个名为<code class="fe lv lw lx ly b">useDispatch</code>的钩子。每当我们的复选框改变时，我们用它来调度<code class="fe lv lw lx ly b">TOGGLE_DARKTHEME</code>动作。</p><p id="2b18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，这是应用程序的外观:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ac4b97a69d54ed736d40425b956b3b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9xYmio685jE4FYIBViHO7g.gif"/></div></div></figure><h2 id="3167" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">还有一点</h2><p id="cab7" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">这里还有最后一个问题，这是一个UX问题。每当我离开页面，它就会“忘记”我喜欢的主题。</p><p id="321d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有很多方法可以解决这个问题，但是我决定将选择的<code class="fe lv lw lx ly b">theme</code>存储在<code class="fe lv lw lx ly b">localStorage</code>中，并在应用程序启动时使用它重新合并redux存储。</p><p id="f6be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">神奇的事情发生在<code class="fe lv lw lx ly b">store.js</code>文件中:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mn mo l"/></div></figure><ol class=""><li id="4f70" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">当构建我们商店的初始状态时，我们检查<code class="fe lv lw lx ly b">localStorage</code>是否有任何存储的主题</li><li id="3dc2" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">每当偏好发生变化时，我们使用一个redux <code class="fe lv lw lx ly b">subscriber</code>来更新<code class="fe lv lw lx ly b">localStorage</code>。</li></ol><p id="3367" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">全部完成！</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="7d92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！👏</p></div></div>    
</body>
</html>