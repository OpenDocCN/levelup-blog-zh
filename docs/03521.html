<html>
<head>
<title>JavaScript Best Practices for Writing More Robust Code — Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更健壮代码的JavaScript最佳实践—函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-functions-3303584a6d3a?source=collection_archive---------14-----------------------#2020-05-13">https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-functions-3303584a6d3a?source=collection_archive---------14-----------------------#2020-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/33a4a8743464dd6c6fa3033aa5b578be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Imlx4DAzajkR5WCy"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">paweczerwiński</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e67e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="4694" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将探讨编写不太可能出错的函数的最佳方式。</p><h1 id="2617" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">尽可能使用箭头功能</h1><p id="9753" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript箭头函数很棒。它们让我们以更短更简洁的方式编写函数。</p><p id="3cc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们不必担心函数内部<code class="fe mh mi mj mk b">this</code>的值。考虑<code class="fe mh mi mj mk b">this</code>的值总是很痛苦，因为它在不同的位置有不同的值。</p><p id="b791" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不必担心<code class="fe mh mi mj mk b">arguments</code>对象的值，因为它没有绑定到它。</p><p id="cdfd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，要尽量用。例如，我们可以这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="29c9" class="mt lf it mk b gy mu mv l mw mx">const arr = [1, 2, 3];<br/>const arr2 = arr.map(x =&gt; x * 2);</span></pre><p id="a220" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe mh mi mj mk b"> x =&gt; x * 2</code>是我们的箭头函数。正如我们所看到的，它很短，因为它只有一行，所以我们不必显式地写<code class="fe mh mi mj mk b">return</code>来返回<code class="fe mh mi mj mk b">x * 2</code>。单行函数要简洁得多。</p><p id="b089" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不必一直写出<code class="fe mh mi mj mk b">function</code>关键字来声明一个函数。</p><p id="bb9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们也不能用它调用<code class="fe mh mi mj mk b">bind</code>、<code class="fe mh mi mj mk b">call</code>或<code class="fe mh mi mj mk b">apply</code>，这样我们也不用担心那些方法。这是我们应该尽可能使用箭头函数的另一个原因，因为调用这些方法出错的风险更小。</p><p id="ec6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们也不能用作构造函数，所以我们不能对它们使用<code class="fe mh mi mj mk b">new</code>关键字。这很好，因为不想在新的类语法中使用构造函数。</p><p id="6099" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一件好事是它们没有<code class="fe mh mi mj mk b">prototype</code>属性，因为它们不能用作构造函数。这是另一个我们不能在代码中犯错误的地方。</p><p id="ba51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，没有带箭头函数的函数声明，所以它们不能被提升。这意味着它们只能在定义后被引用。这消除了我们在哪里可以调用或引用箭头函数的许多困惑。</p><p id="5f26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们可以用作顶级函数，对象的方法，或者嵌套在任何地方。</p><p id="0362" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4f81" class="mt lf it mk b gy mu mv l mw mx">const obj = {<br/>  foo: () =&gt; {<br/>    console.log('foo');<br/>  }<br/>}</span></pre><p id="e899" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以调用<code class="fe mh mi mj mk b">obj.foo</code>方法来记录<code class="fe mh mi mj mk b">'foo'</code>。</p><p id="6086" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d8eb" class="mt lf it mk b gy mu mv l mw mx">const bar = () =&gt; {<br/>  const foo = () =&gt; {<br/>    console.log('foo');<br/>  }<br/>}</span></pre><p id="4312" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将<code class="fe mh mi mj mk b">foo</code>窝在<code class="fe mh mi mj mk b">bar</code>里面。</p><p id="e180" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，除了构造函数之外，它们还适合用在其他地方。我们其实并不想使用构造函数，因为类语法会主动检查代码中的错误，而不是让错误随着构造函数一起消失。</p><p id="c15f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们从另一个构造函数继承时，这一点甚至更加重要。</p><h1 id="8e71" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用Rest操作符获取长参数列表</h1><p id="efbf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们有一个很长的参数列表传递给我们的函数，rest操作符应该总是用来代替<code class="fe mh mi mj mk b">arguments</code>对象。</p><p id="fdbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在函数签名中用<code class="fe mh mi mj mk b">...</code>表示，它返回额外的参数，这些参数没有被设置为数组形式的指定参数的值。</p><p id="0181" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们使用箭头函数和传统函数。例如，我们可以使用rest运算符，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c52b" class="mt lf it mk b gy mu mv l mw mx">function f(a, b, ...args) {<br/>  console.log(args);<br/>}</span></pre><p id="1eab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们调用<code class="fe mh mi mj mk b">f(1, 2, 3, 4, 5);</code>时，那么<code class="fe mh mi mj mk b">args</code>就是<code class="fe mh mi mj mk b">[3, 4, 5]</code>，因为1被设置为<code class="fe mh mi mj mk b">a</code>而2被设置为<code class="fe mh mi mj mk b">b</code>。</p><p id="3e71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以将它们与箭头函数一起使用:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f375" class="mt lf it mk b gy mu mv l mw mx">const f = (a, b, ...args) =&gt; {<br/>  console.log(args);<br/>}</span></pre><p id="0936" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到和以前一样的结果。</p><p id="461b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们就不必使用<code class="fe mh mi mj mk b">arguments</code>对象来获取参数，或者使用<code class="fe mh mi mj mk b">call</code>或<code class="fe mh mi mj mk b">apply</code>来调用带有额外参数的函数。</p><p id="867b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何数组一样，我们可以对它使用析构语法。例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="462e" class="mt lf it mk b gy mu mv l mw mx">const f = (a, b, ...[d, e]) =&gt; {<br/>  console.log(d, e);<br/>}</span></pre><p id="e421" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么当我们这样称呼它的时候:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="62c6" class="mt lf it mk b gy mu mv l mw mx">f(1, 2, 3, 4, 5);</span></pre><p id="81f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe mh mi mj mk b">d</code>是3，<code class="fe mh mi mj mk b">e</code>是4。注意，我们不必析构所有传入的参数。</p><p id="f21d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比<code class="fe mh mi mj mk b">arguments</code>对象好得多，因为它是一个数组而不是类似数组的对象，我们可以对它使用析构语法。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/c487c013779b9f51986d877265631d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W2JY6eiEb8nQf0oL"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@ango?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dro Troll </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="bb94" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="a75c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">箭头函数应该在我们的JavaScript代码中使用，除非我们需要创建构造函数或者在对象方法中引用<code class="fe mh mi mj mk b">this</code>。</p><p id="b164" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">rest操作符是获取没有赋给命名参数的函数参数的最佳方式。</p></div></div>    
</body>
</html>