<html>
<head>
<title>Heroku — My New Home</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">heroku——我的新家</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/heroku-my-new-home-f8ecfbc33886?source=collection_archive---------5-----------------------#2020-08-28">https://levelup.gitconnected.com/heroku-my-new-home-f8ecfbc33886?source=collection_archive---------5-----------------------#2020-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/97adb1f27cc86bdf3e77ef75949adefa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MXWfyjEN252MgtY9jXHs7w.png"/></div></div></figure><p id="72b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">在本系列的最后一部分，作者回顾了第一次使用Heroku的过程，详细介绍了新的设计和经验教训。</strong></p><p id="e7f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在“<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/moving-away-from-aws-and-onto-heroku-d84852b9884d">从AWS迁移到Heroku </a>”一文中，我介绍了我想从亚马逊流行的AWS解决方案迁移到Heroku的应用程序。随后，“<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/destination-heroku-86a5811a199c"> Destination Heroku </a>”一文展示了一个新Heroku帐户的建立，并重点介绍了一个Java API(在Spring Boot编写),它连接到这个新的平台即服务(PaaS)生态系统中的一个ClearDB实例。</p><p id="4875" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本系列的第三篇文章(“<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/using-heroku-for-static-web-content-b7f5ce0712b1">将Heroku用于静态web内容</a>”)提供了一种静态Web文件也可以由Heroku提供服务的方式。我这个系列的主要目标是找到一个解决方案，让我能够将有限的时间集中在提供业务解决方案上，而不是跟上开发运维流程。</p><p id="a91f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在一切都在Heroku中运行，是时候后退一步，对我的新应用程序之旅进行回顾了。</p><h1 id="9233" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">详述新设计</h1><p id="dc3f" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">从应用程序和设计的角度来看，应用程序实际上没有任何变化，现在100%在Heroku中运行:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi md"><img src="../Images/2918f73ba2aba1d0ea3c941648f57ca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQxzsOzq2v8DO6gxoVodrg.png"/></div></div></figure><p id="d586" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的图像是这个系列的第一部分中的图像的一个相同的副本。我报告这些信息的目的是，我能够非常容易地在AWS S3和AWS Elastic Beanstalk中找到我现有的应用程序，并将准确的源代码迁移到Heroku。</p><h1 id="2e76" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">事情发生了怎样的变化</h1><p id="0368" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">虽然应用程序很容易移植到Heroku，但是现在应用程序更新和部署的方式发生了变化。</p><p id="7856" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二部分和第三部分讨论了我如何简单地执行一个额外的基于git的命令，以便将更改部署到运行在Heroku上的API和客户机实例:</p><p id="3b12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mi mj mk ml b">git push Heroku</code></p><p id="eddd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">自从本系列的第二和第三部分发表以来，我花了几分钟时间来了解更多关于GitLab CI/CD的内容，并介绍了一些非常简单的自动化。现在，当一个拉请求被合并到我的Spring Boot API存储库的<code class="fe mi mj mk ml b">master</code>分支时，一个类似于下面所示的<code class="fe mi mj mk ml b">.gitlab-ci.yml</code>文件被自动执行:</p><p id="97f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mm">外壳</em></p><pre class="me mf mg mh gt mn ml mo mp aw mq bi"><span id="463f" class="mr lb it ml b gy ms mt l mu mv">stages:</span><span id="ec0a" class="mr lb it ml b gy mw mt l mu mv">- build</span><span id="84b1" class="mr lb it ml b gy mw mt l mu mv">- deploy</span><span id="5612" class="mr lb it ml b gy mw mt l mu mv">maven-build:</span><span id="c0dc" class="mr lb it ml b gy mw mt l mu mv">image: maven:3-jdk-8</span><span id="f901" class="mr lb it ml b gy mw mt l mu mv">stage: build</span><span id="e9f6" class="mr lb it ml b gy mw mt l mu mv">script: "mvn package -B -DskipTests"</span><span id="583e" class="mr lb it ml b gy mw mt l mu mv">deploy:</span><span id="5b51" class="mr lb it ml b gy mw mt l mu mv">stage: deploy</span><span id="5f51" class="mr lb it ml b gy mw mt l mu mv">image: ruby:latest</span><span id="0fa2" class="mr lb it ml b gy mw mt l mu mv">script:</span><span id="e939" class="mr lb it ml b gy mw mt l mu mv">- apt-get update -qy</span><span id="a4a6" class="mr lb it ml b gy mw mt l mu mv">- apt-get install -y ruby-dev</span><span id="cc3d" class="mr lb it ml b gy mw mt l mu mv">- gem install dpl</span><span id="fb18" class="mr lb it ml b gy mw mt l mu mv">- dpl --provider=heroku --app=$HEROKU_APP --api-key=$HEROKU_API_KEY</span><span id="f64f" class="mr lb it ml b gy mw mt l mu mv">only:</span><span id="88cc" class="mr lb it ml b gy mw mt l mu mv">- master</span></pre><p id="82d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，GitLab CI/CD进程使用包含Maven的Java 8容器来构建Spring Boot框架，该框架充当我的应用程序的API。一旦构建完成，CI/CD流程将利用Ruby执行部署到应用程序名称，该应用程序名称使用$HEROKU_API_KEY变量中提供的API键匹配$HEROKU_APP变量。</p><p id="0f9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我在这个项目上的工作现在是100%基于特征的。我可以遵循Git-Flow策略，为我的工作创建一个特性分支。然后，当准备好时，我将发出一个拉请求，并将我的更改合并到主分支中。在那个时候(也只有在那个时候), CI/CD管道将启动并将更改推送到Heroku，Heroku将部署API的新版本。</p><p id="b60a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Angular客户端存储库也进行了更新，以包括类似于下面列出的管道:</p><p id="87db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mm">外壳</em></p><pre class="me mf mg mh gt mn ml mo mp aw mq bi"><span id="3276" class="mr lb it ml b gy ms mt l mu mv">image: node:8.10.0</span><span id="2b52" class="mr lb it ml b gy mw mt l mu mv">cache:</span><span id="de79" class="mr lb it ml b gy mw mt l mu mv">paths:</span><span id="f696" class="mr lb it ml b gy mw mt l mu mv">- node_modules/</span><span id="ee3d" class="mr lb it ml b gy mw mt l mu mv">stages:</span><span id="f122" class="mr lb it ml b gy mw mt l mu mv">- deploy_production</span><span id="d2bb" class="mr lb it ml b gy mw mt l mu mv">Production:</span><span id="4128" class="mr lb it ml b gy mw mt l mu mv">image: ruby:latest</span><span id="7cab" class="mr lb it ml b gy mw mt l mu mv">only:</span><span id="0dac" class="mr lb it ml b gy mw mt l mu mv">- master</span><span id="946a" class="mr lb it ml b gy mw mt l mu mv">stage: deploy_production</span><span id="d10f" class="mr lb it ml b gy mw mt l mu mv">script:</span><span id="62f7" class="mr lb it ml b gy mw mt l mu mv">- apt-get update -qy</span><span id="44dd" class="mr lb it ml b gy mw mt l mu mv">- apt-get install -y ruby-dev</span><span id="0db4" class="mr lb it ml b gy mw mt l mu mv">- gem install dpl</span><span id="3ded" class="mr lb it ml b gy mw mt l mu mv">- dpl --provider=heroku --app=$HEROKU_APP --api-key=$HEROKU_API_KEY</span></pre><p id="8823" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于客户机来说，实际上只有一个部署阶段，它也利用Ruby和相同的变量合并到Heroku目标存储库中。推送完成后，Heroku会自动部署新版本的web客户端。</p><p id="008c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GitLab用户:如果您的存储库启用了Heroku CI功能，这项工作实际上是自动完成的。对于启用此功能的用户，可以自动部署成功通过测试阶段的主分支的所有更新。</p><h1 id="f630" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">保障性和维修性</h1><p id="d675" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">有了所有这些变化，部署就变得容易了，这让我可以专注于向应用程序添加新功能。事实上，在整点后的18分钟，我收到了我岳母发来的一条短信，指出这个应用程序不能正常工作。在几分钟内，我隐藏了我的更改，并在GitLab和一个bugfix分支中创建了问题(从主存储库中)。在这种情况下，我需要对API和Angular客户端做一点小小的改动。</p><p id="3e0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在15分钟内，使用API和Angular客户端的本地实例识别、修复并验证了问题。两个存储库的代码都被签入，我创建了一个PR，尽管我是这个项目中唯一的工作人员。一旦分支被合并到两个存储库中，CI/CD处理就开始了。不到五分钟后，Heroku中的两个应用程序都重新启动并正常工作。</p><p id="fd4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用Heroku，我能够在不到20分钟的时间内解决问题并部署修复程序。在那段时间里，我专注于开发和标准的git使用。我没有花时间去理解和记住与DevOps相关的内容，这些内容与为我的应用程序所有者提供功能和支持毫无关系。</p><p id="50f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，另一种选择是恢复到服务的早期部署。Heroku提供了一种令人印象深刻的方式，通过这种方式，托管的应用程序可以回滚到以前的状态。事实上，这就像在应用程序中单击一个链接一样简单:</p><p id="2de7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下面的屏幕截图中，单击“回滚到此处”链接将启动将服务恢复到先前状态的过程。</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/74fa483f2510e359cf2423f83534afe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lApBk6GUxrPtjisOP6D6cA.png"/></div></div></figure><p id="65ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用CLI,“heroku releases”命令提供部署摘要:</p><p id="e8b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mm">壳牌</em></p><pre class="me mf mg mh gt mn ml mo mp aw mq bi"><span id="499c" class="mr lb it ml b gy ms mt l mu mv">$ heroku releases</span><span id="c9a7" class="mr lb it ml b gy mw mt l mu mv">=== amhs Releases - Current: v12</span><span id="ff1b" class="mr lb it ml b gy mw mt l mu mv">v12  Deploy 1somekey johnjvester@gmail.com  2020/05/24 14:34:51 -0400</span><span id="b192" class="mr lb it ml b gy mw mt l mu mv">v11  Deploy 2somekey johnjvester@gmail.com  2020/05/23 15:21:56 -0400</span></pre><p id="fb7b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如果我希望回滚到v11，只需执行以下命令:</p><p id="9d19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mi mj mk ml b">heroku rollback v11</code></p><p id="49a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和往常一样，回滚应该只在极少数情况下使用，而不是永久的解决方案。</p><h1 id="7fbe" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">成本差异</h1><p id="962f" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">当我完成本系列的第三部分时，我确信Heroku将是我这个应用程序的目的地。为了节省成本，我决定关闭我的Elastic Beanstalk实例，并将最大实例数设置为零。我的想法是，我将产生零成本，因为应用程序没有运行。结果，我的假设是错误的，我最终得到了一张18.49美元的发票，其中包含了与保持弹性Beanstalk实例可用相关的数据库成本和费用。AWS S3也有小额费用。同样，我需要时间来理解一个比我真正需要的复杂得多的计费结构…或者有时间去担心。</p><p id="15e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Heroku方面，我决定升级到两个应用程序的爱好计划。我期望每月支付的14美元比AWS的标准费用节省了40%。我现在不必担心数据库，因为使用率非常低，应用程序中的所有历史数据只占Ignite选项数据库大小的6%。现在没什么好担心的。</p><p id="ffcb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我选择使用业余爱好计划，主要是为了避免我的岳母不得不等待系统启动。她每个月只使用这个应用程序几天，所以我确信每次她试图访问系统时，她都必须等待。经验提示，让婆婆等从来都不是什么好事。:)</p><p id="b324" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我也喜欢从爱好计划开始展示的应用指标:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/e09b5e002099ce66ef2bb53f3adf8ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A3ue6TrhJoZPRIXK9GHLHw.png"/></div></div></figure><p id="26b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我的应用程序真正需要的是了解当前的响应时间和基本的使用水平。</p><p id="225b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在数据库方面,(免费的)Ignite MySQL ClearDB实例提供了一个基本的仪表板，也满足了我的需求:</p><figure class="me mf mg mh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/94a95480be20220374e6ef036e14367c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HioxBypmhwYxQ5zE8Z1gMA.png"/></div></div></figure><h1 id="9752" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">heroku-buildpack-static</h1><p id="9512" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">虽然Node.js的方法对我来说工作得很好，但我想提出<a class="ae kz" href="https://github.com/heroku/heroku-buildpack-static" rel="noopener ugc nofollow" target="_blank"> heroku-buildpack-static </a>项目，它是为类似于我的Angular客户端的单页面静态web应用程序设计的。为了阅读更多关于这个非常酷的项目的信息，<a class="ae kz" href="https://gist.github.com/hone" rel="noopener ugc nofollow" target="_blank"> Terence Lee </a>创建了一个<a class="ae kz" href="https://gist.github.com/hone/24b06869b4c1eca701f9" rel="noopener ugc nofollow" target="_blank">入门文档</a>。</p><p id="ec9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我在旅途中早点发现这个项目，我会考虑使用这种方法。虽然buildpack是实验性的，不是Heroku团队的产品，但我觉得它的稳定性肯定达到了我的应用程序所信任的水平。</p><h1 id="23f4" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="4af5" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">上大学时，我遇到了一个叫斯泰西的人。当时，我们都很认真地想在音乐行业建立一个专业的地位。然而，命运为我们安排了一段不同的旅程。我最终在信息技术行业工作，斯泰西回到大学成为一名牙医。一晃三十年过去了，我们都在事业上有所建树。时间允许的话我们还是会聊。</p><p id="ef7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我提到史黛西的原因是，他总是把时间花在朋友和家人身上。这超越了牙科保健，涵盖了他多年来提供的各种援助。其实是他的启发，让我想用自己的技能和能力，为婆婆提供更好的应用体验。虽然她可能不理解为她提供改进的做生意方式所涉及的一切，但她对我的帮助表示感谢。</p><p id="bed6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与此同时，我觉得Heroku的团队与Stacy和我有着相似的使命。他们利用自己的专业知识提供一个平台，开发人员可以在这个平台上快速建立应用程序。一旦就位，支持和增强应用程序就像检入代码本身一样简单。事实上，这种方法正是我所需要的。</p><p id="125a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不管我们在生活中做什么，保持专注是很重要的。保持专注的一个方法是消除竞争的优先权。对于AWS，我觉得我需要继续了解他们生态系统的各个方面，这并没有给我的应用程序带来新的特性。有了Heroku，我的全部时间都可以用来为我的客户提供价值。</p><p id="a5bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">祝你今天过得愉快！</p></div></div>    
</body>
</html>