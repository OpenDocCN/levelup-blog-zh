<html>
<head>
<title>Small Tips to Write Better React Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更好的React代码的小技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/small-tips-to-write-better-react-code-5230472e786f?source=collection_archive---------6-----------------------#2020-07-29">https://levelup.gitconnected.com/small-tips-to-write-better-react-code-5230472e786f?source=collection_archive---------6-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="02f1" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">更好的编程</h2><div class=""/><div class=""><h2 id="2229" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解如何使用一些JavaScript特性来清理代码</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d5f1a464e496c8cd03205b4a1cf5d6aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h1p71f7yFTzCatzzftF3yA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@emilep?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">埃米尔·佩龙</a>在<a class="ae lh" href="https://unsplash.com/s/photos/simple-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="76e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">今天我们将讨论一些我最喜欢的技巧，它们非常容易实现或遵循，并且可以让你的JavaScript代码更干净。还要记住，我们今天要学习的一些内容通常适用于JavaScript，尽管本文将重点关注React。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="e3e2" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">对象析构</h1><p id="8607" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">首先，我们将回顾对象析构，这实际上是我最喜欢的方法之一，它有助于保持代码短小、整洁和优雅。我非常喜欢这个话题，所以我在这里发了一整篇文章:</p><div class="ni nj gp gr nk nl"><a href="https://medium.com/better-programming/write-cleaner-code-by-using-javascript-destructuring-cd6b55c25bac" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd jd gy z fp nq fr fs nr fu fw jc bi translated">使用JavaScript析构编写更简洁的代码</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">通过在JavaScript中析构对象和数组，增加代码的清晰度并降低代码的复杂性</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz lb nl"/></div></div></a></div><p id="6051" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">析构允许你将复杂的结构分解成简单的部分。让我们来看一个例子:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="1e91" class="of mm it ob b gy og oh l oi oj">const { title } = props<br/>console.log(title);</span></pre><p id="6185" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">React开发人员使用这种技术的一个常见地方是props。虽然有些人可能会认为在拆分变量时会丢失上下文，但在React中，上下文通常是由组件本身继承的。让我们看一个例子来说明我的意思。</p><p id="1346" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，让我们编写一个简单的组件在屏幕上显示任务信息:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="1fba" class="of mm it ob b gy og oh l oi oj">function TaskView(props) {<br/>    return (<br/>        &lt;h1&gt;{props.task.title}&lt;/h1&gt;<br/>        &lt;p&gt;{props.task.description}&lt;/p&gt;<br/>        &lt;span&gt;{props.task.completed ? 'Completed' : 'Pending'}&lt;/span&gt;<br/>    )<br/>}</span></pre><p id="3c9a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这确实很简单，但是，看看我们是如何一直重复道具的，不是很漂亮。让我们看看实现这一点的另一种方法:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="7fa4" class="of mm it ob b gy og oh l oi oj">function TaskView(props) {<br/>    const task = props.task<br/>    return (<br/>        &lt;h1&gt;{task.title}&lt;/h1&gt;<br/>        &lt;p&gt;{task.description}&lt;/p&gt;<br/>        &lt;span&gt;{task.completed ? 'Completed' : 'Pending'}&lt;/span&gt;<br/>    )<br/>}</span></pre><p id="fef0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好一点了，但是我们在任何地方都有任务。现在，一些可能不知道析构的人可能会尝试这样做:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="83d1" class="of mm it ob b gy og oh l oi oj">const title = props.task.title<br/>const description = props.task.description</span></pre><p id="2623" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这给声明增加了太多的开销。现在让我们看看使用析构时组件是什么样子的。</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="fd05" class="of mm it ob b gy og oh l oi oj">function TaskView(props) {<br/>    const { title, description, completed } = props.task<br/>    return (<br/>        &lt;h1&gt;{title}&lt;/h1&gt;<br/>        &lt;p&gt;{description}&lt;/p&gt;<br/>        &lt;span&gt;{completed ? 'Completed' : 'Pending'}&lt;/span&gt;<br/>    )<br/>}</span></pre><p id="c697" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在代码非常简单，我们保持JSX与其他部分非常干净，我们仍然在上下文中。完全可以理解的是，当我们说<code class="fe ok ol om ob b">title</code>时，我们谈论的是<code class="fe ok ol om ob b">Task</code>，因为这是组件的全部内容。因此，保持你的名字干净，组织好你的组件，你会喜欢这个特性的。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="cf69" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">简化你的条件语句</h1><p id="89fc" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在这一节中，我想谈谈3种不同的场景，它们可以帮助我们提高代码的可读性，这非常简单，尽管很多时候我们会忘记这样做。</p><h2 id="6b93" class="of mm it bd mn on oo dn mr op oq dp mv lr or os mx lv ot ou mz lz ov ow nb iz bi translated">条件执行</h2><p id="8ab6" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在某些时候，只有当某个条件恰好为真时，我们才需要运行一个语句，这是很正常的。通常是这样的:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="f6d8" class="of mm it ob b gy og oh l oi oj">const isFive = (num) =&gt; num === 5<br/>if (isFive(5)) {<br/>    console.log('It is the number five!')<br/>}</span></pre><p id="21fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，这段代码本身没有任何问题，但是，它可以简化一点:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="5cf1" class="of mm it ob b gy og oh l oi oj">const isFive = (num) =&gt; num === 5<br/>isFive(5) &amp;&amp; console.log('It is the number five!')</span></pre><p id="4b32" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很好，但是它是如何工作的呢？JavaScript和许多其他语言一样，按照从左到右的顺序读取条件语句，如<code class="fe ok ol om ob b">&amp;&amp;</code>或<code class="fe ok ol om ob b">||</code>，当它们可以使参数无效时就退出。</p><p id="278f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看一个所有条件句的例子:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="938b" class="of mm it ob b gy og oh l oi oj">const t = 1<br/>t === 1 &amp;&amp; t === 2 &amp;&amp; t === 3</span></pre><p id="8406" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在那个例子中，JS将首先获取第一个表达式<code class="fe ok ol om ob b">t === 1</code>，因为那个表达式是真的，并且我们有一个<code class="fe ok ol om ob b">and</code>条件，它需要评估下一个表达式，因为我们需要保证它们都是真的。当它对<code class="fe ok ol om ob b">t === 2</code>求值时，它根本不需要对<code class="fe ok ol om ob b">t === 3</code>求值，因为我们知道整个语句恰好是<code class="fe ok ol om ob b">false</code>。</p><p id="2e23" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">太神奇了！现在让我们了解更多这方面的知识。这种例子在互联网上很常见，但是，你知道你也可以使用<code class="fe ok ol om ob b">||</code>操作符吗？</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="5fe8" class="of mm it ob b gy og oh l oi oj">const isFive = (num) =&gt; num === 5<br/>isFive(5) || console.log('It is the number five!') // does not execute the console.log<br/>isFive(10) || console.log('It is not the number five!') // it executes the console.log</span></pre><p id="12a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你注意到了吗，我们刚才做的等同于对我们的第一个例子应用一个not。</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="5249" class="of mm it ob b gy og oh l oi oj">const isFive = (num) =&gt; num === 5<br/>isFive(5) &amp;&amp; console.log('It is the number five!') // it executes the console.log<br/>!isFive(10) &amp;&amp; console.log('It is not the number five!') // it executes the console.log</span></pre><h2 id="9888" class="of mm it bd mn on oo dn mr op oq dp mv lr or os mx lv ot ou mz lz ov ow nb iz bi translated">三元运算符</h2><p id="d0c4" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">条件(三元)操作符是唯一接受三个操作数的JavaScript操作符:一个条件后跟一个问号(？)，然后是条件为true时要执行的表达式，后跟冒号(:)，最后是条件为falsy时要执行的表达式。</p><p id="0d74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这通常用于根据条件语句向用户显示不同的状态或组件。虽然我并不总是推荐使用三元运算符，但有时这是一种很好的老方法，可以很好地完成工作。它对小东西非常有用。</p><p id="66a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看看下面的例子:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="2b3c" class="of mm it ob b gy og oh l oi oj">if (completed) {<br/>    return 'Completed'<br/>} else {<br/>    return 'Pending'<br/>}</span></pre><p id="b8d7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一种变化，我仍然在周围看到的是:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="45f0" class="of mm it ob b gy og oh l oi oj">if (completed) { return 'Completed'} else { return 'Pending' }</span></pre><p id="e7c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我不是来评判的，但那会变得很混乱。让我们来看看使用三元运算符的一种方法</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="fbb0" class="of mm it ob b gy og oh l oi oj">return completed ? 'Completed' : 'Pending'</span></pre><p id="f830" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好多了！</p><h2 id="8727" class="of mm it bd mn on oo dn mr op oq dp mv lr or os mx lv ot ou mz lz ov ow nb iz bi translated">可选链接</h2><p id="105a" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">最后但并非最不重要的是，我们有可选的链接(<code class="fe ok ol om ob b">?.</code>)，它允许读取位于连接对象链深处的属性值，而不必明确验证每个引用。</p><p id="88c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单地说，这有助于避免仅仅为了确保我们在嵌套属性上有一个值而使用一堆<code class="fe ok ol om ob b">if</code>语句。让我们看一个例子:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="04ad" class="of mm it ob b gy og oh l oi oj">const juan = {<br/>    name: 'Juan',<br/>    marriedTo: {<br/>        name: 'Diana'<br/>    }<br/>}</span><span id="191f" class="of mm it ob b gy ox oh l oi oj">console.log(juan.marriedTo.name) // Diana<br/>console.log(juan.divorcedFrom.name) // Cannot read property 'name' of undefined</span></pre><p id="cffd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Ups…当我们试图访问与我们离婚的人的名字时，我们得到一个错误，因为<code class="fe ok ol om ob b">divorcedFrom</code>在我们的例子中是未定义的。通常我们会这样解决它:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="2947" class="of mm it ob b gy og oh l oi oj">if (juan.divorcedFrom) {<br/>    console.log(juan.divorcedFrom.name)<br/>}</span></pre><p id="ae26" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，如果仅仅为了这个目的而增加许多“如果”,那也可能会失去控制。使用可选链接有一个更好的方法。</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="9841" class="of mm it ob b gy og oh l oi oj">const juan = {<br/>    name: 'Juan',<br/>    marriedTo: {<br/>        name: 'Diana'<br/>    }<br/>}</span><span id="55c5" class="of mm it ob b gy ox oh l oi oj">console.log(juan.marriedTo?.name) // Diana<br/>console.log(juan.divorcedFrom?.name) // undefined</span></pre><p id="6e18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这适用于多个层面</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="0d1f" class="of mm it ob b gy og oh l oi oj">juan.marriedTo?.disvorcedFrom?.kids</span></pre><p id="a2c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">非常好！让我们继续下一个话题。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b1ca" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">传播算子</h1><p id="b0de" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">没有不使用spread操作符的react应用程序，这可能有些夸张，但是spread操作符在React应用程序中被广泛使用，尤其是在使用reducers时，尽管它不仅仅是这样。这是我在文章中广泛涉及的另一个主题:</p><div class="ni nj gp gr nk nl"><a href="https://medium.com/@bajcmartinez/how-to-use-the-spread-operator-in-javascript-3aff104adb71" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd jd gy z fp nq fr fs nr fu fw jc bi translated">如何在JavaScript中使用扩展运算符(…)</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">ES6详细传播算子，它是如何工作的，好的，坏的，丑陋的</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nu l"><div class="oy l nw nx ny nu nz lb nl"/></div></div></a></div><p id="6ed3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我真的推荐你读读它，它很酷，而且详细地涵盖了这个话题。</p><p id="9cde" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">spread操作符允许您将一个iterable对象展开为它的单个元素的列表。让我们来看一些例子:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="3d27" class="of mm it ob b gy og oh l oi oj">function sum(x, y, z) {<br/>  return x + y + z<br/>}</span><span id="062c" class="of mm it ob b gy ox oh l oi oj">const numbers = [1, 2, 3]</span><span id="7c21" class="of mm it ob b gy ox oh l oi oj">console.log(sum(...numbers)) // 6</span></pre><p id="6f60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，我们所做的是将一个<code class="fe ok ol om ob b">array</code>转换成单独的变量，并传递给我们的<code class="fe ok ol om ob b">sum</code>函数。这是一个非常巧妙的技巧。但是我们也可以把它应用到物体上:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="1d24" class="of mm it ob b gy og oh l oi oj">const obj1 = { foo: 'bar', x: 42 }<br/>const obj2 = { foo: 'baz', y: 13 }</span><span id="fcc6" class="of mm it ob b gy ox oh l oi oj">const copyObj1 = { ...obj1 } // This copies all the properties of obj1 into a new object.</span><span id="b122" class="of mm it ob b gy ox oh l oi oj">const merged = { ...obj1, ...obj2 } // This merges all the properties of obj1 and obj2 into a new object.</span><span id="baaa" class="of mm it ob b gy ox oh l oi oj">console.log(merged) // {foo: "baz", x: 42, y: 13}</span></pre><p id="18f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为我们可以用它来创建新的对象或数组，所以使用Redux是理想的，因为我们可以避免改变原始对象。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="794b" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">模板文字</h1><p id="5619" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">虽然很受欢迎，对初学者也很友好，但是没有它们，任何列表都是不完整的。模板文字基本上是字符串，但不是任何字符串，它们允许嵌入表达式。让我们来看看。</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="43f1" class="of mm it ob b gy og oh l oi oj">console.log(`this is a string literal`)</span></pre><p id="4e9c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在其更基本的形式中，字符串文字只是一个字符串，但是，注意，要成为字符串文字，它必须使用<code class="fe ok ol om ob b">\`` instead of </code> " <code class="fe ok ol om ob b">or</code>' `。这是一个小细节，但却有着巨大的影响。</p><p id="72e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，字符串文字支持多行字符串:</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="f9e4" class="of mm it ob b gy og oh l oi oj">console.log(`line 1<br/>line 2`)</span></pre><p id="43ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者你也可以嵌入表达式</p><pre class="ks kt ku kv gt oa ob oc od aw oe bi"><span id="ef23" class="of mm it ob b gy og oh l oi oj">const a = 10<br/>const b = 25</span><span id="dfca" class="of mm it ob b gy ox oh l oi oj">console.log(`a: ${a} and b: ${b} but more importantly a+b = ${a+b}`) // a: 10 and b: 25 but more importantly a+b = 35</span></pre><p id="58f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">真的很酷！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="2ec6" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">结论</h1><p id="795d" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">JavaScript包含有用的操作符、表达式和技巧，可以增强我们的开发技能，编写更简洁的代码。我提到的一些事情可能是个人判断，这也是事实，但是如果你看一看在非常受欢迎的项目上编写的React代码，你会看到他们到处都在应用这些小东西。因此，当您编写下一个React组件时，学习和实现它们真的很好。</p><p id="0c83" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读</p></div></div>    
</body>
</html>