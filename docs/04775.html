<html>
<head>
<title>From JSON to uint32 to Tensors: The Advanced Programmer’s Data Type Reference Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从JSON到uint32再到Tensors:高级程序员数据类型参考指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/from-json-to-uint32-to-tensors-the-advanced-programmers-data-type-reference-guide-cbe554b86971?source=collection_archive---------6-----------------------#2020-07-14">https://levelup.gitconnected.com/from-json-to-uint32-to-tensors-the-advanced-programmers-data-type-reference-guide-cbe554b86971?source=collection_archive---------6-----------------------#2020-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5a7218e10438ccd40e8a657a44c03031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hbx9It_82k7mrv0E"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://unsplash.com/photos/JKUTrJ4vK00" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><div class=""/><div class=""><h2 id="20cb" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">41种重要的数据类型，已解释</h2></div><p id="9034" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理解数据类型对于在代码中创建和建立变量的存在是必不可少的。但是除了数据类型对于初学者的重要性之外，选择正确的数据类型不仅仅是这样，它对于优化代码的性能和效率是不可或缺的。选择一种基本的数据类型，它可以立即天真地完成您想要做的基本任务，这可能会完成任务，但是更明智地选择数据类型是区分有经验的程序员和初学者以及区分优秀代码和优秀代码的一个关键区别。</p><p id="444c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这篇文章是专门针对Python的，但是这些数据类型中有许多是通用的，可以移植到其他语言和库中。这些语言翻译将在适用的情况下进一步概述。</p><ul class=""><li id="9249" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><em class="md">标准内置奇异值</em>:科学记数法，复数，+</li><li id="724d" class="lu lv jj la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><em class="md">标准内置多重/代码</em> : lambdas、tuples、sets、+</li><li id="41d9" class="lu lv jj la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><em class="md">高级数值数据类型</em>:双精度、无符号整数、+</li><li id="5675" class="lu lv jj la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><em class="md">日期和时间</em>:日期时间、时间增量、+</li><li id="d5f2" class="lu lv jj la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><em class="md">数据科学/表格数据</em>:序数数据、名义数据、+</li><li id="673e" class="lu lv jj la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><em class="md">张量流特殊化类型</em>:秩2张量、参差张量、+</li><li id="d20c" class="lu lv jj la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><em class="md">文件类型/数据容器</em> : XML、CSV、DataFrames、+</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="cf93" class="mq mr jj bd ms mt mu mv mw mx my mz na kp nb kq nc ks nd kt ne kv nf kw ng nh bi translated">标准内置奇异值</h1><p id="684f" class="pw-post-body-paragraph ky kz jj la b lb ni kk ld le nj kn lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated"><strong class="la jk">整数</strong>包括负整数、正整数和零。在Python中，调用<code class="fe nn no np nq b">int()</code>可以将浮点数或字符串转换成整数。在浮点数上使用整数有助于加速计算时间，因为它不需要和浮点数一样的开销。</p><p id="0a59" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">浮点包括整数，也包括任何其他实数。“浮点”指的是小数点及其后的十进制数字。调用<code class="fe nn no np nq b">float()</code>将数据类型转换成浮点数。</p><p id="9d68" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">科学记数法</strong>是一种用10的幂来表示极大或极小数字的方法(十亿是1×10⁹，而不是10亿)。尽管从技术上来说它要么是整数，要么是浮点数，但是可以通过使用<code class="fe nn no np nq b">e</code>来触发Python的科学符号表示。例如，你可以把5600000写成5.6×10⁶，或者用Python写<code class="fe nn no np nq b">5.6e6</code>。对该值的所有进一步操作将保留在科学记数法中。在需要手写大值的情况下，使用这种初始化非常有用。</p><p id="ae14" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">十六进制</strong>类似于位，但是以16为基数而不是以2为基数进行运算。0到9用于表示10个数字，而字母A到F可以表示剩余的6个可能的数字。十六进制应该只用于长整数或者过大的整数——否则，使用它们真的没有意义。另一方面，它们可以用来寻找颜色值(十六进制代码利用十六进制)。</p><p id="fa46" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">复数</strong>超越了浮点数所代表的实数，具有一个虚部。可以使用内置函数<code class="fe nn no np nq b">complex(x)</code>将任何数据类型转换成复数。要从头开始创建一个复数值，使用<code class="fe nn no np nq b">j</code>来表示虚部。例如，一个实部为3、虚部为-2的复数将被创建为<code class="fe nn no np nq b">3 ˗ 2j</code>。</p><p id="1c05" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">布尔值</strong>被设置为<code class="fe nn no np nq b">True</code>或<code class="fe nn no np nq b">False</code>。转换为整数时，结果分别为1和0，通过<code class="fe nn no np nq b">bool(x)</code>将整数转换为布尔值时，1对应True，0对应False。</p><p id="6f16" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">字符串</strong>是用单引号或双引号括起来的任何字符的序列。两者可以互换使用，字符串中的引号可以使用转义符进行转义:<code class="fe nn no np nq b">‘I don\’t like double quotes.’</code>这样，转义符后面的字符将被视为字符串，而不是系统命令。</p><p id="0812" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">多行字符串</strong>允许字符串跨越几行。这对于像分段文本或存储HTML数据这样的任务很有帮助。多行字符串可以用三个引号开始，再用三个引号结束，在文本中存储换行符。</p><h1 id="7c8a" class="mq mr jj bd ms mt nr mv mw mx ns mz na kp nt kq nc ks nu kt ne kv nv kw ng nh bi translated">标准内置多重/代码值</h1><p id="5ede" class="pw-post-body-paragraph ky kz jj la b lb ni kk ld le nj kn lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated"><strong class="la jk">对象</strong>可以使用类方法在Python中创建。对象包含内部变量和函数，可以通过调用<code class="fe nn no np nq b">object.variable</code>或<code class="fe nn no np nq b">object.function()</code>来引用。使用面向对象的编程可以使编写和阅读代码更加干净和有条理。</p><p id="72c5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">函数</strong>是指定的代码序列，可以根据它们的名字来调用，而不需要在它们的主体中写出代码，因此是干净且不重复的代码的组成部分。在Python中，函数既可以用<code class="fe nn no np nq b">def func_name: do_something</code>跨多行创建，也可以用<code class="fe nn no np nq b">func_name = lambda x:something(x)</code>在一行中创建。</p><p id="5b71" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">列表</strong>是项目的有序列表。它们可以用方括号(<code class="fe nn no np nq b">[]</code>)初始化，内部元素用逗号分隔。</p><p id="f91f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">元组</strong>是成对的项，可以用<code class="fe nn no np nq b">(a, b)</code>初始化。元组不需要列表数据类型中具有未设置的最大列表长度所提供的开销空间，因此如果只需要存储两个值，它们会更有效。为了保持这种效率优势，它们也是不可变的，或者一旦被创建就不能被改变或变更。元组可以很容易地解包，参见下面的例子:</p><pre class="nw nx ny nz gt oa nq ob oc aw od bi"><span id="485b" class="oe mr jj nq b gy of og l oh oi">for i, j in [(1,2), (3,4), (5, 6)]:<br/>     print(i+j)</span></pre><p id="fde4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">字典</strong>是<code class="fe nn no np nq b">key:value</code>项的列表，其中每个值都可以通过其对应的键来访问。字典有助于保存双值，用花括号<code class="fe nn no np nq b">{key1:value1, key2:value2}</code>创建。另一种方法是将<code class="fe nn no np nq b">dict()</code>应用于另一个变量。</p><p id="0446" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">集合</strong>本质上是列表，但是更加严格，因此具有更多的信息能力。该集合支持诸如并集、交集和对称差之类的数学运算(尽管为NumPy保留复杂的数学运算可能更有效)。一个集合是无序的，有不可变的(不可改变的)项，并且不能有一个以上的相同元素。要初始化它，使用括号(像字典一样)，但是把它当作一个列表。</p><p id="01dc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">集合有助于从其他数据集中获取信息。如果我们想在列表<code class="fe nn no np nq b">list_a</code>中找到唯一的元素，我们可以用<code class="fe nn no np nq b">set(list_a)</code>将它转换成一个集合，并查看集合的值。由于集合不能有多个相同的值，Python自动为我们完成了数据类型转换的重任。</p><h1 id="53f8" class="mq mr jj bd ms mt nr mv mw mx ns mz na kp nt kq nc ks nu kt ne kv nv kw ng nh bi translated">高级数字</h1><p id="20b2" class="pw-post-body-paragraph ky kz jj la b lb ni kk ld le nj kn lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">NumPy是Python中的一个科学计算库，其根源是c。因为它的编程效率比纯原生Python更高，所以建议在重型计算中使用它，这也是从web scrapers到机器学习模块的许多大计算库使用NumPy的原因。NumPy如此成功的部分原因是因为它对变量的数据类型非常具体——给予了足够的利用自由，但不足以产生过多的开销。理解它们至关重要。</p><p id="73bf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">前驱—比特</strong>:比特是机器的关键单位，是二进制的0或1，物理上用一个电子(或另一个分子项)的有无来表示。所有信息都表示为位的组合:一个4位的字符串可以容纳2×2×2×2=16个可能的值。一个8位字节可以保存2⁸=256值。供参考:</p><ul class=""><li id="00f7" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">千字节:2个值(13位)</li><li id="1ba8" class="lu lv jj la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated">兆字节:2个值(23位)</li><li id="772e" class="lu lv jj la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated">千兆字节:2个值(33位)</li><li id="44af" class="lu lv jj la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated">太字节:2⁴值(43位)</li><li id="7977" class="lu lv jj la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated">拍字节:2⁵值(53位)</li></ul><p id="e5b1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">许多更具体讨论的数据类型都围绕着保存特定位数的能力。当一个变量被初始化时，它所能接受的最大大小被保留在内存空间中，所以选择正确的大小而不超过它是很重要的。</p><p id="aebe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> np.array </strong>表示数组对象，是元素的集合，可以是任何数据类型，包括子数组。数组对编程语言至关重要，因为它们是数据和信息的计算机表现形式。使用基于数组的计算比使用循环系统和手写条件要快得多。带有子阵列的阵列称为矩阵。在某些条件和上下文中，数组可以被认为是张量，是机器学习所必需的数据类型。</p><p id="ec82" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> np.int8到np.int64 </strong>包含可能的以2为基数的整数类型(<code class="fe nn no np nq b">int8</code>、<code class="fe nn no np nq b">int16</code>、<code class="fe nn no np nq b">int32</code>、<code class="fe nn no np nq b">int64</code>)。这些值存储负值和正值，并且可以保存2ˣ，其中<em class="md"> x </em>表示整数值，例如，int8可以保存从-128到127的值(总共256个值)。</p><p id="8c2f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> np.uint8到np.uint64 </strong>包含无符号整数类型，这意味着它不能保存负值。相反，这些数据类型的范围仅限于等于或大于0的整数。例如，<code class="fe nn no np nq b">np.uint16</code>可以表示从0到2 ⁶-1=65535.的所有整数</p><p id="434b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> np.int_ </strong>表示NumPy中的默认整数类型，与c中的<code class="fe nn no np nq b">long</code>类型相同。这种“动态”类型支持int64或int32，具体取决于它的设置值。</p><p id="6456" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> np.float16到np.float64 </strong>代表NumPy浮点类型。<code class="fe nn no np nq b">np.float16</code>表示具有10位尾数(3.141×10⁴的3.141)和5位指数(3.141×10⁴).的4)的半精度浮点数<code class="fe nn no np nq b">np.float32</code>表示“单精度浮点”，可以包含23位尾数和8位指数。<code class="fe nn no np nq b">np.float64</code>是‘双精度浮点’，可以保存52位的尾数和11位的指数。这些精度浮点测量几乎是通用的，起源于c语言的创建。</p><ul class=""><li id="68f4" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe nn no np nq b">np.float16</code>与<code class="fe nn no np nq b">np.half</code>相同</li><li id="fed4" class="lu lv jj la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><code class="fe nn no np nq b">np.float32</code>与<em class="md"> </em> <code class="fe nn no np nq b">p.single</code>相同</li><li id="29f5" class="lu lv jj la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><code class="fe nn no np nq b">np.float64</code>与<code class="fe nn no np nq b">np.double</code>相同</li></ul><p id="49fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">NP . complex 64&amp;NP . complex 128</strong>是NumPy中复数的实现。<code class="fe nn no np nq b">np.complex64</code>可以保存两个32位浮点，一个用于复数(实数和虚数)中的每个分量。<code class="fe nn no np nq b">np.complex128</code>可以容纳两个64位浮点。128位复杂是Python实现的形式，尽管可以想象如果不需要128位精度，指定一个<code class="fe nn no np nq b">complex64</code>数据类型会快多少。</p><p id="6fe1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> np.ufunc </strong>表示一个所谓的‘通用函数’，这是一个已经用C编译过的函数，使得它对数组数据类型的操作非常高效。这些通用函数接受一个标量(单个)值，但是按元素方式应用于数组。Python函数可以通过NumPy的<code class="fe nn no np nq b">frompyfunc</code>函数转换成通用函数。</p><p id="1551" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，这些高级数值数据类型由大型库处理和优化，但如果您需要编写更专业的低级代码(许多高级开发人员就是这种情况)，理解每种数据类型的含义是很重要的。了解这些数据类型可以让您避免因选择不正确的数据类型来存储数值数据而导致的计算错误、内存溢出或大量开销问题。</p><h1 id="36ac" class="mq mr jj bd ms mt nr mv mw mx ns mz na kp nt kq nc ks nu kt ne kv nv kw ng nh bi translated">日期和时间</h1><p id="a448" class="pw-post-body-paragraph ky kz jj la b lb ni kk ld le nj kn lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated"><strong class="la jk"> datetime.date </strong>是最基本的日期对象，有三个属性:年、月、日。当时间不是一个因素时，处理日期对象比处理其他对象更容易。</p><p id="c617" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> datetime.time </strong>是最基本的时间对象，不考虑日期。相反，它由小时、分钟、秒、微秒和tzinfo表示，tz info表示时区信息。</p><p id="95d1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> datetime.datetime </strong>可能是最常见的测量时间的数据类型，它由<code class="fe nn no np nq b">date</code>和<code class="fe nn no np nq b">time</code>对象组成，包含这两个对象的参数。</p><p id="c402" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> datetime.timedelta </strong>是请求两个时间点之间的差异时返回的对象，精确到微秒。可以在任何两个有效的datetime对象之间请求timedelta，只要它们的比较有效。</p><p id="9848" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以用Python的<code class="fe nn no np nq b">+</code>和<code class="fe nn no np nq b">-</code>操作符将日期、时间、日期时间和时间增量相加或相减。</p><h1 id="429a" class="mq mr jj bd ms mt nr mv mw mx ns mz na kp nt kq nc ks nu kt ne kv nv kw ng nh bi translated">数据科学/表格数据</h1><p id="c022" class="pw-post-body-paragraph ky kz jj la b lb ni kk ld le nj kn lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated"><strong class="la jk">数字数据</strong>由数字组成，可以是整数、浮点数、复数等等。数字列或特征完全由数字组成。</p><p id="f74f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">分类数据</strong>由无法在数字尺度上测量的数据组成，如字符串(“猫”和“狗”)，并且具有有限数量的可能唯一值。如果一个特征只包含分类数据，那么它就是分类的。</p><p id="d32f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">顺序数据</strong>是指数据不一定是它所代表的数字，但仍然保持一定的数字关系，如等级。虽然A比B好(A &gt; B关系)，但是数据不是数值。序数数据只显示顺序关系。</p><p id="003f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">名义数据</strong>是分类数据的数字表示，其中每个值相对于其他值毫无意义。举个例子，考虑[1，2，3，2，3，1]，其中1代表“猫”，2代表“狗”，3代表“鱼”。</p><h1 id="daf8" class="mq mr jj bd ms mt nr mv mw mx ns mz na kp nt kq nc ks nu kt ne kv nv kw ng nh bi translated">TensorFlow专用类型</h1><p id="9e43" class="pw-post-body-paragraph ky kz jj la b lb ni kk ld le nj kn lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">TensorFlow可以说是使用最广泛的机器学习库。TensorFlow植根于Python，应用于JavaScript，是人工智能项目从概念到部署的基础。因为机器学习是一项计算量非常大的任务，TensorFlow有自己的高效实现值的系统。</p><p id="9c05" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> tf.tensor(num) </strong>表示零维张量(秩-0)，或者标量(奇异值)。根据<code class="fe nn no np nq b">num</code>的大小，TensorFlow会自动确定大小，虽然默认是int32。张量是不可变的，或者说不可改变的；相反，只能创建新的张量。所有张量都可以使用<code class="fe nn no np nq b">tf.constant(value)</code>创建。</p><p id="58ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> tf.tensor(list) </strong>表示一个一维张量(秩-1)，或者一个列表。现在可能很清楚了，TensorFlow构造张量(数据)都来自<code class="fe nn no np nq b">tf.constant</code>，通过传递给它的构造函数的数据的维数来推断张量的形状。</p><p id="6aae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> tf.tensor(列表数组)</strong>表示二维张量(秩-2)。这类似于矩阵，因为它有两个轴。这种增加维度的模式可以继续到三维数据(例如，RGB图像，其中每个像素由三个值表示)、四维数据(批量大小)等。</p><p id="11d3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> tf.sparse.SparseTensor </strong>是一种张量类型，专门创建用于计算极其稀疏或多数空/0张量。</p><p id="23ae" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> tf.ragged.RaggedTensor </strong>是可以容纳非矩形数组的张量类型；也就是说，并非所有行的长度都相同。这在分析或建模的情况下可能是有用的，例如，用不同大小的数字表示的文本串(可能使用递归神经网络建模，这对于输入大小是不变的)。</p><p id="4b1d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> tf.uint16等。</strong> : TensorFlow的高级数字数据类型(如无符号整数、浮点数以及在相应章节中讨论的其他数据类型)的实现与NumPy中的实现相同，它们只是针对TensorFlow操作进行了优化的重新创建。事实上，<code class="fe nn no np nq b">np.uint16==tf.uint16</code>将返回<code class="fe nn no np nq b">True</code>，因为TensorFlow数据本质上是建立在NumPy之上的。</p><h1 id="f932" class="mq mr jj bd ms mt nr mv mw mx ns mz na kp nt kq nc ks nu kt ne kv nv kw ng nh bi translated">文件类型/数据容器</h1><p id="6b05" class="pw-post-body-paragraph ky kz jj la b lb ni kk ld le nj kn lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">JSON或JavaScript Object Notation是一种标准的文件和数据交换格式，强调可读性。作为一种应用广泛的常见数据格式，JSON几乎出现在任何与web应用程序或交互有关的地方。JSON语法非常简单:花括号(<code class="fe nn no np nq b">{}</code>)表示“字典”，如<code class="fe nn no np nq b">key</code> : <code class="fe nn no np nq b">value</code>，方括号表示列表。在下面的示例中，有一个“employees”表，有两列<code class="fe nn no np nq b">firstName</code>和<code class="fe nn no np nq b">lastName</code>，三行。</p><pre class="nw nx ny nz gt oa nq ob oc aw od bi"><span id="3ecf" class="oe mr jj nq b gy of og l oh oi">{“employees”:[<br/> { “firstName”:”John”, “lastName”:”Doe” },<br/> { “firstName”:”Anna”, “lastName”:”Smith” },<br/> { “firstName”:”Peter”, “lastName”:”Jones” }<br/>]}</span></pre><p id="ae09" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pandas是流行的数据操作库，可以从带有<code class="fe nn no np nq b">pd.read(‘filename.json’)</code>或<code class="fe nn no np nq b">pd.read(‘url’)</code> ( <code class="fe nn no np nq b">pd</code>是<code class="fe nn no np nq b">import pandas as pd</code>中pandas的缩写)的文件或互联网URL中读取JSON数据。请注意，尽管JSON可读性很强，但它可能会被批评为效率低下，因为表中的列重复了几次。如果数据太大，可能有必要将JSON转换成更“有效”的数据类型，如CSV。</p><p id="e828" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">XML是网页使用的另一种数据存储形式。虽然它已经普遍失宠，但许多网站仍在使用它，而且是基于标签的。上面JSON表中的数据可以用XML表示为:</p><pre class="nw nx ny nz gt oa nq ob oc aw od bi"><span id="9d62" class="oe mr jj nq b gy of og l oh oi">&lt;employees&gt;<br/> &lt;employee&gt;<br/> &lt;firstName&gt;John&lt;/firstName&gt; &lt;lastName&gt;Doe&lt;/lastName&gt;<br/> &lt;/employee&gt;<br/> &lt;employee&gt;<br/> &lt;firstName&gt;Anna&lt;/firstName&gt; &lt;lastName&gt;Smith&lt;/lastName&gt;<br/> &lt;/employee&gt;<br/> &lt;employee&gt;<br/> &lt;firstName&gt;Peter&lt;/firstName&gt; &lt;lastName&gt;Jones&lt;/lastName&gt;<br/> &lt;/employee&gt;<br/>&lt;/employees&gt;</span></pre><p id="839a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pandas不直接支持读取xml文件，尽管有一个Python库——<a class="ae jg" href="https://pypi.org/project/pandas-read-xml/" rel="noopener ugc nofollow" target="_blank">pandas-read-XML</a>——可以将XML文件转换成数据帧。</p><p id="50e6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">CSV或逗号分隔值是一种高效的数据存储方法。这种数据类型使用逗号来分隔每行中的值，并使用新行来分隔每行。例如，上面的JSON表将以CSV格式表示为:</p><pre class="nw nx ny nz gt oa nq ob oc aw od bi"><span id="37c3" class="oe mr jj nq b gy of og l oh oi">‘firstName’,’lastName’<br/>'John','Doe'<br/>'Anna','Smith'<br/>'Peter','Jones'</span></pre><p id="bfa9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Excel数据以CSV格式存储——您可以通过保存扩展名为<code class="fe nn no np nq b">.csv</code>的excel工具箱并在记事本或其他纯文本编辑器中查看该文件来亲自尝试一下。CSV(和Excel)数据可以用带<code class="fe nn no np nq b">pd.read_csv(‘file_path’)</code>和<code class="fe nn no np nq b">pd.read_excel(‘file_path’)</code>的熊猫读取。</p><p id="21eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> HTML表格</strong>是在维基百科等HTML网站中使用的表格。这些表格通常在专门的表格标签内，熊猫用<code class="fe nn no np nq b">pd.read_html(‘url’)</code>就可以读取。这将返回一个数据帧列表，对应于Pandas在网页上找到的表。</p><p id="f949" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据帧是熊猫的表格。使用Pandas读取的任何外部数据源都被转换为DataFrame。数据帧中的数据可以使用各种方法进行修改，如应用函数、重命名列、删除单元格值、设置索引、连接数据帧等等。</p><figure class="nw nx ny nz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/4bad5c47b5f74a4ebc8e23e313be3b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DEzKetG-UPDbvZYGKiiDQw.png"/></div></div></figure><p id="f581" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe nn no np nq b">to_datatype(‘file_path’)</code>可以将数据帧导出为其他数据类型。例如，要将名为“data”的数据帧转换为CSV格式，需要运行下面的代码:<code class="fe nn no np nq b">data.to_csv(‘file_path.csv’)</code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="a200" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果这份参考资料有所帮助，您可能会喜欢其他一些备忘单:</p><div class="is it gp gr iu ok"><a href="https://towardsdatascience.com/your-ultimate-data-mining-machine-learning-cheat-sheet-9fce3fa16" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd jk gy z fp op fr fs oq fu fw ji bi translated">您的终极数据挖掘和机器学习备忘单</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">特性重要性、分解、转换等</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">towardsdatascience.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ja ok"/></div></div></a></div><div class="is it gp gr iu ok"><a href="https://towardsdatascience.com/your-ultimate-data-manipulation-cleaning-cheat-sheet-731f3b14a0be" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd jk gy z fp op fr fs oq fu fw ji bi translated">您的终极数据操作和清理备忘单</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">解析日期、输入、异常检测等等</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">towardsdatascience.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy ja ok"/></div></div></a></div></div></div>    
</body>
</html>