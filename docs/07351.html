<html>
<head>
<title>States of Thread in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中线程的状态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/states-of-thread-in-java-6f7bc1c628b9?source=collection_archive---------8-----------------------#2021-02-11">https://levelup.gitconnected.com/states-of-thread-in-java-6f7bc1c628b9?source=collection_archive---------8-----------------------#2021-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9615" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">"设计一个线程安全的类要比以后为了线程安全而改造它容易得多。"布瑞恩·戈茨</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/528104cb3eaab74a386c1f6037b2e870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZB4kgrJkAN-eVv1OIwMrpw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">codeGym的线程状态</figcaption></figure><p id="9b10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在并发编程中，Java线程扮演着重要的角色。一个java线程在任何时候都应该处于下列状态中的任何一点。一个线程在任何时候都只能处于下列状态之一。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/0e8770c629ec002af3c1cf944003b0c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*WmBqphsz7SpHknALxsS8Eg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">线程生命周期</figcaption></figure><p id="f98f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们深入讨论线程状态之前，先了解一下我之前的博客<a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/world-of-concurrent-be30b5a269c1"> <strong class="la iu">中的并发编程基础知识。</strong></a></p><h2 id="5944" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">1.新的</h2><p id="2f13" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">当一个新线程被创建时，它将处于新状态，而线程还没有开始运行。当线程处于新状态时，它的代码还没有运行，还没有开始执行。</p><p id="47e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例:创建了一个新线程，但没有启动，所以让它像这样，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d725" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">线程对象为空，资源不可用于该线程。如果用户调用start()以外的任何方法，将会出现IllegalThreadStateExecption错误。</p><h2 id="4ff8" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">2.可追捕的</h2><p id="1ca9" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">准备运行的线程被移入可运行状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f459" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种状态下，线程可能正在运行，或者随时准备运行。线程调度器负责给出运行线程的时间。在大多数操作系统中，每个线程都有少量的处理器时间。当这种情况发生时，所有准备运行的线程，等待CPU和当前正在运行的线程都处于可运行状态。</p><h2 id="db78" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">3.堵塞的</h2><p id="18b4" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">当一个可运行线程试图执行一个在给定时间内无法完成的任务时，它可以转换到阻塞状态。它应该暂时等待，直到任务完成。</p><p id="3843" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，当一个线程正在等待I/O完成时，它就处于阻塞状态。线程调度器负责重新激活和调度一个阻塞/等待的线程。处于这种状态的线程不能继续执行，直到它被转移到runnable状态。处于这些状态的任何线程都不会消耗任何CPU周期。</p><h2 id="385b" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">4.等待</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/22f2f0cd85cde8fbef02ad90d484fc8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ip5igGDZA20rRh1n_2CcQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">快速线程正在等待线程</figcaption></figure><p id="c8bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当一个线程在等待另一个线程时处于等待状态。当这个条件被满足时，调度器被通知，(当<strong class="la iu"> notify () </strong>或<strong class="la iu"> notifyAll() </strong>方法被调用时)，等待线程被转移到可运行状态。</p><p id="df84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果当前运行的线程被转移到阻塞/等待状态，线程调度器将调度另一个处于可运行状态的线程运行。确定运行哪个线程是线程调度器的责任。</p><h2 id="6b82" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">5.等待时间</h2><p id="7651" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">线程处于可运行状态，然后调用方法<strong class="la iu"> sleep(t) </strong>、<strong class="la iu"> wait(t) </strong>或<strong class="la iu"> join(t) </strong>，以持续时间作为参数，线程进入时间等待状态。线程处于这种状态，直到超时结束或收到通知。例如，当一个线程调用sleep或条件等待时，它将进入定时等待状态。一旦时间到了，线程将回到可运行状态。</p><h2 id="50dc" class="lw lx it bd ly lz ma dn mb mc md dp me lh mf mg mh ll mi mj mk lp ml mm mn mo bi translated">6.结束的</h2><p id="bf19" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">由于下列原因之一，线程终止。</p><p id="1384" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">线程正常存在。当线程的代码完全由程序执行时，就会发生这种情况。</p><p id="c45a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当线程发生异常错误事件时，如分段错误或未处理的异常。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="2a78" class="ne lx it bd ly nf ng nh mb ni nj nk me jz nl ka mh kc nm kd mk kf nn kg mn no bi translated">线程调度。</h1><p id="aaa2" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh mr lj lk ll ms ln lo lp mt lr ls lt im bi translated">当我们谈论java线程和线程状态时，我们不应该忘记线程调度。</p><p id="5bb7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">线程调度用于调度线程间的<strong class="la iu">优先级</strong>。当线程启动时，它继承的优先级为<strong class="la iu"> MAX_PRIORITY= 10 </strong>和<strong class="la iu"> MIN_PRIORITY = 1 </strong>。</p><p id="342c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正常优先级为5 ( <strong class="la iu">正常优先级=5 </strong>)。</p><p id="9f50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据线程调度规则，它总是将其访问权给予高优先级线程。如果在那种情况下，如果当前有低优先级线程运行，就会进入线程等待状态。</p><p id="cd43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果线程具有相同的优先级，那么它将按照进程选择的循环方法运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="baa2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在给定的场景中，racer[0]和racer[1]设置为优先级7，racer[3]设置为优先级3。</p><p id="b980" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在这种情况下，racer[0]和racer[1]将作为第一个线程运行，因为它在处于可运行状态的线程中具有最高的优先级。</p><p id="5dbc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至于循环法，如果racer[0]选择先运行，其他人将在其让步后等待，racer[1]将开始执行。它们将一直运行，直到它们的进程终止，并且在具有最低优先级的racer[3]线程运行之后，没有任何中断地执行它的进程。</p><p id="58f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望您对Java线程状态和调度有了清晰的理解。</p><p id="e91f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="np">快乐编码！！！</em></p></div></div>    
</body>
</html>