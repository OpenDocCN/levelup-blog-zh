<html>
<head>
<title>Android Nightmares 😱 | Base classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安卓噩梦😱|基本类别</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/android-nightmares-base-classes-ccf55dbd0604?source=collection_archive---------0-----------------------#2022-02-19">https://levelup.gitconnected.com/android-nightmares-base-classes-ccf55dbd0604?source=collection_archive---------0-----------------------#2022-02-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/39e710920daee6c75d5cc1a448847fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XRqYBs3Fw6xShVZNCKyT4w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">别做那种人</figcaption></figure><p id="2e46" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我开始作为Android开发人员工作时，还没有片段、回收视图、视图模型和协程。在这十年里，一切都变了，除了一件事:<strong class="ke ir">classes🥶基地</strong>。</p><p id="0be0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您从未遇到过BaseActivity、BaseFragment或BaseViewModel，那么您应该感到幸运🌟。</p><blockquote class="la lb lc"><p id="f85e" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">这些类是软件开发中一个正确原则的错误结果:<strong class="ke ir">不要重复自己</strong></p></blockquote><blockquote class="lh"><p id="df11" class="li lj iq bd lk ll lm ln lo lp lq kz dk translated"><strong class="ak">“不要重复自己</strong>”(<strong class="ak">DRY</strong>)是软件开发的一个原则，旨在减少软件模式的重复，用抽象来代替，或者使用数据规范化来避免冗余。(<a class="ae lr" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></blockquote><p id="3025" class="pw-post-body-paragraph kc kd iq ke b kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv lw kx ky kz ij bi translated">一个常见的场景是，当您需要跟踪应用程序的分析时，或者可能在每个活动上注册一个BroadcastReceiver。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">坏习惯的坏例子</figcaption></figure><p id="3610" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">看起来不错，现在每个扩展BaseActivity的活动都可以跟踪和注销，而不需要任何新的代码行。<br/>但是如果你需要一个不需要跟踪日志就能自动注销的活动呢？如果您需要一个无需自动注销就能跟踪日志的活动呢？</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><blockquote class="la lb lc"><p id="3874" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">不，答案不是<strong class="ke ir">特征标志🙄</strong></p></blockquote><p id="e180" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Kotlin(甚至Java，带有一些额外的代码行)和Android生命周期组件可以通过<a class="ae lr" href="https://kotlinlang.org/docs/delegation.html#overriding-a-member-of-an-interface-implemented-by-delegation" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">委托</strong> </a>将你从这个噩梦中解救出来</p><blockquote class="lh"><p id="2d9d" class="li lj iq bd lk ll mk ml mm mn mo kz dk translated">D <strong class="ak">继承模式</strong>是一种面向对象的设计模式，允许对象组合实现与继承相同的代码重用。(<a class="ae lr" href="https://en.wikipedia.org/wiki/Delegation_pattern" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></blockquote><p id="9c2e" class="pw-post-body-paragraph kc kd iq ke b kf ls kh ki kj lt kl km kn lu kp kq kr lv kt ku kv lw kx ky kz ij bi translated">您可以实现一个接口并将实际代码委托给另一个类。此外，由于生命周期组件，我们可以将我们的逻辑绑定到生命周期。</p><p id="3705" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你只需要</p><ul class=""><li id="26a4" class="mp mq iq ke b kf kg kj kk kn mr kr ms kv mt kz mu mv mw mx bi translated">每个功能的接口和实现(单一责任原则💓)</li><li id="6fee" class="mp mq iq ke b kf my kj mz kn na kr nb kv nc kz mu mv mw mx bi translated">您的活动/片段实现了接口，委托给Impl并附加了生命周期。</li></ul><p id="ee72" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最终结果:</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="cef4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您的代理将如下所示:</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="7bc1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你以前用过委托吗？请在评论中告诉我你最糟糕的基类体验！😎</p></div></div>    
</body>
</html>