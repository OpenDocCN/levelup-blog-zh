<html>
<head>
<title>Have you been hurt by lambdas in Python?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你被Python里的lambdas伤害过吗？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/have-you-been-hurt-by-lambdas-in-python-c0165136d023?source=collection_archive---------24-----------------------#2022-02-16">https://levelup.gitconnected.com/have-you-been-hurt-by-lambdas-in-python-c0165136d023?source=collection_archive---------24-----------------------#2022-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d0ce" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">拯救默认值</h2></div><p id="afd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">奇普·肯特</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/45f79f5d1a17bc23469aeec604e26de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SnzivuTDxUKGEB31"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@simmerdownjpg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰克逊在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上煨</a></figcaption></figure><p id="518e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Python中使用lambdas可以节省开发人员的时间和精力，因为它创造了更高阶的思维，而无需定义一个全新的函数。然而，在某些情况下，lambdas的行为令人困惑，甚至会导致意想不到的或不正确的结果。</p><p id="c64a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae lr" href="https://deephaven.io/blog/2022/02/10/python-default-args/" rel="noopener ugc nofollow" target="_blank">Python默认参数</a>中的小精灵中，我们看到了<a class="ae lr" href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment#:~:text=The%20principle%20of%20least%20astonishment,will%20expect%20it%20to%20behave." rel="noopener ugc nofollow" target="_blank">最小惊讶原则(POLA) </a>以及它与<a class="ae lr" href="https://python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>中默认参数的关系。在接下来的文章中，让我们来看一个有趣的例子，用<a class="ae lr" href="https://python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a> lambdas展示如何调试匿名函数的行为。</p><p id="944d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你认为这段代码会打印出什么？</p><pre class="lc ld le lf gt ls lt lu lv aw lw bi"><span id="93e4" class="lx ly iq lt b gy lz ma l mb mc">def f():<br/>  lambdas = []</span><span id="96b4" class="lx ly iq lt b gy md ma l mb mc">for i in range(5):<br/>    lambdas.append(lambda x: x+i)</span><span id="b03a" class="lx ly iq lt b gy md ma l mb mc">for l in lambdas:<br/>    print(l(3))</span><span id="352a" class="lx ly iq lt b gy md ma l mb mc">f()</span></pre><p id="8d44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数用户希望看到:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi me"><img src="../Images/02ab7f7ddace90826db58261b94f75e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*ODxlnUlSuPStmzTZ1MbJ1w.png"/></div></figure><p id="afd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实上，你会看到:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi me"><img src="../Images/f8ce351d917fb35437705bb406974f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*M9011xVqgSjsX_Nead_vkA.png"/></div></figure><p id="4ce4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很奇怪。在评估时，所有的lambdas都有<code class="fe mf mg mh lt b">i = 4</code>，即使它们是用值为0、1、2、3和4的<code class="fe mf mg mh lt b">i</code>创建的。</p><p id="eec9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许<a class="ae lr" href="https://python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>正在为整个循环创建一个lambda。一个快速的测试表明事实并非如此。</p><pre class="lc ld le lf gt ls lt lu lv aw lw bi"><span id="c00d" class="lx ly iq lt b gy lz ma l mb mc">def f():<br/>  lambdas = []</span><span id="68ed" class="lx ly iq lt b gy md ma l mb mc">for i in range(5):<br/>    lambdas.append(lambda x: x+i)</span><span id="9629" class="lx ly iq lt b gy md ma l mb mc">for l in lambdas:<br/>    print(l)<br/>    print(l(3))</span><span id="06eb" class="lx ly iq lt b gy md ma l mb mc">f()</span></pre><p id="8755" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可能会发生什么？</p><p id="6ce1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用计算机科学的行话来说，这个例子中的lambdas是<a class="ae lr" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)#:~:text=In%20programming%20languages%2C%20a%20closure,function%20together%20with%20an%20environment." rel="noopener ugc nofollow" target="_blank">闭包</a>。lambda函数使用了其定义范围内的绑定变量——在本例中是<code class="fe mf mg mh lt b">i</code>变量。</p><p id="3132" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更好地理解，让我们来看看绑定到lambdas的变量。在<a class="ae lr" href="https://docs.python.org/3/reference/datamodel.html" rel="noopener ugc nofollow" target="_blank"> Python的数据模型</a>中，<code class="fe mf mg mh lt b">__closure__</code>是一个元组，包含函数关闭的变量。这里，我打印了lambdas的闭包变量的地址加上来自<code class="fe mf mg mh lt b">__closure__</code>的<code class="fe mf mg mh lt b">i</code>的值。</p><pre class="lc ld le lf gt ls lt lu lv aw lw bi"><span id="6a4b" class="lx ly iq lt b gy lz ma l mb mc">def f():<br/>  lambdas = []</span><span id="9b0a" class="lx ly iq lt b gy md ma l mb mc">for i in range(5):<br/>    lambdas.append(lambda x: x+i)</span><span id="4886" class="lx ly iq lt b gy md ma l mb mc">for l in lambdas:<br/>    print(l)<br/>    print(f"i_addr={hex(id(l.__closure__[0]))} i={l.__closure__[0].cell_contents}")<br/>    print(l(3))</span><span id="9ffc" class="lx ly iq lt b gy md ma l mb mc">f()</span></pre><p id="c1dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将很快注意到所有的lambda共享相同的闭包变量元组，因为闭包内容有相同的地址，并且所有的lambda都有<code class="fe mf mg mh lt b">i = 4</code>！所以，所有的lambdas都是不同的，但它们都有相同的变量。lambda从创建时就与变量名<code class="fe mf mg mh lt b">i</code>相关联，而不是与变量值<code class="fe mf mg mh lt b">i</code>相关联。这解释了为什么只打印值7。</p><p id="9c31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当内部函数被定义时，闭包也可以被创建。他们也有同样奇怪的行为吗？是的，他们有。</p><pre class="lc ld le lf gt ls lt lu lv aw lw bi"><span id="b42d" class="lx ly iq lt b gy lz ma l mb mc">def f():<br/>  funcs = []</span><span id="ae0a" class="lx ly iq lt b gy md ma l mb mc">for i in range(5):<br/>    def inner(x):<br/>      return x+i<br/>      <br/>    funcs.append(inner)</span><span id="6af3" class="lx ly iq lt b gy md ma l mb mc">for l in funcs:<br/>    print(l(3))</span><span id="66ca" class="lx ly iq lt b gy md ma l mb mc">f()</span></pre><p id="abf5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过使用默认值为每个lambda绑定一个新变量来解决这个问题。这种情况下，<code class="fe mf mg mh lt b">ii</code>。</p><pre class="lc ld le lf gt ls lt lu lv aw lw bi"><span id="8acd" class="lx ly iq lt b gy lz ma l mb mc">def f():<br/>  lambdas = []</span><span id="a9ea" class="lx ly iq lt b gy md ma l mb mc">for i in range(5):<br/>    lambdas.append(lambda x, ii=i: x+ii)</span><span id="cc7a" class="lx ly iq lt b gy md ma l mb mc">for l in lambdas:<br/>    print(l(3))</span><span id="e838" class="lx ly iq lt b gy md ma l mb mc">f()</span></pre><p id="bd07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在幕后，lambda现在在<code class="fe mf mg mh lt b">__closure__</code>中不再有值，因为没有变量被封闭，但是它现在在<code class="fe mf mg mh lt b">__defaults__</code>中有预期的值。</p><pre class="lc ld le lf gt ls lt lu lv aw lw bi"><span id="923f" class="lx ly iq lt b gy lz ma l mb mc">def f():<br/>  lambdas = []</span><span id="b007" class="lx ly iq lt b gy md ma l mb mc">for i in range(5):<br/>    lambdas.append(lambda x, ii=i: x+ii)</span><span id="7b91" class="lx ly iq lt b gy md ma l mb mc">for l in lambdas:<br/>    print(l)<br/>    print(f"closure={l.__closure__} defaults={l.__defaults__}")<br/>    print(l(3))</span><span id="3a66" class="lx ly iq lt b gy md ma l mb mc">f()</span></pre><p id="0019" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这能对难以调试的情况提供一些见解。当心lambdas和带有循环的内部函数。</p><p id="ce8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你认为这违反了<a class="ae lr" href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment#:~:text=The%20principle%20of%20least%20astonishment,will%20expect%20it%20to%20behave." rel="noopener ugc nofollow" target="_blank">最小惊讶原则(POLA) </a>？请在我们的<a class="ae lr" href="https://gitter.im/deephaven/deephaven" rel="noopener ugc nofollow" target="_blank"> Gitter讨论</a>或<a class="ae lr" href="https://join.slack.com/t/deephavencommunity/shared_invite/zt-11x3hiufp-DmOMWDAvXv_pNDUlVkagLQ" rel="noopener ugc nofollow" target="_blank"> Slack社区中告诉我们。</a></p></div></div>    
</body>
</html>