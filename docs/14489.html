<html>
<head>
<title>Unexpected pitfalls of comparing floats</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较浮点数的意外陷阱</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unexpected-pitfalls-of-comparing-floats-ea8d35bd51b1?source=collection_archive---------14-----------------------#2022-12-01">https://levelup.gitconnected.com/unexpected-pitfalls-of-comparing-floats-ea8d35bd51b1?source=collection_archive---------14-----------------------#2022-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="052e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一次我检查代码，被问及在单元测试中互换使用double和integers值的不一致性。你应该坚持一种类型。这里没有使用整数的理由！”——评审员说。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4519110b63e5194ed1b8a567c7ea3b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AAnPqASSmcWDITMflxFbMw.png"/></div></div></figure><p id="6a27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这并不明显，但是当你使用浮点数据类型时，你可能会因为小数部分的内部表示而在比较数字时遇到特殊的错误。让我举个例子来说明。</p><pre class="kn ko kp kq gt ky kz la bn lb lc bi"><span id="6b61" class="ld le iq kz b be lf lg l lh li">let a = 0.5;<br/>let b = 0.5;<br/>console.log(a == b); // true</span></pre><p id="5a4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个看起来不错。结果果然没错。然而，浮点的内部表示并不是代码中写的<em class="kl"> 0.5 </em>，而是某处的<em class="kl"> 0.5000000000034 </em>。换句话说，一个实际的数字接近于0.5，在最后一位数附近有一些小的额外值。</p><p id="5317" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用如上例中的显式值初始化，您可能一开始没有捕捉到额外的数字。但是让我们把0.5改写成一系列的0.01:</p><pre class="kn ko kp kq gt ky kz la bn lb lc bi"><span id="3a7d" class="ld le iq kz b be lf lg l lh li">let a = 0.0;<br/>for (let i = 0; i &lt; 50; i++) {<br/>  a += 0.01;<br/>}<br/>let b = 0.5;<br/>console.log(a);<br/>console.log(b);<br/>console.log(a == b);</span></pre><p id="d199" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果您运行代码，输出将类似于:</p><pre class="kn ko kp kq gt ky kz la bn lb lc bi"><span id="88f7" class="ld le iq kz b be lf lg l lh li">0.5000000000000002<br/>0.5<br/>false</span></pre><p id="f60d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，该值不是预期的<em class="kl"> 0.5 </em>，而是<em class="kl"> 0.5000000000000002。所有编程语言都是如此，不仅仅是JavaScript。</em>考虑下面的Java片段:</p><pre class="kn ko kp kq gt ky kz la bn lb lc bi"><span id="81af" class="ld le iq kz b be lf lg l lh li">class T {<br/>  public static void main(String[] argsc) {<br/>    float a = 0.25f + 0.25f;<br/>    float b = 0.5f;<br/>    System.out.println(a == b); // true<br/>  }<br/>}</span></pre><p id="88c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将导致true(至少在我的例子中)，但是如果0.5被表示为一个更长的小值序列:</p><pre class="kn ko kp kq gt ky kz la bn lb lc bi"><span id="9120" class="ld le iq kz b be lf lg l lh li">class T {<br/>  public static void main(String[] argsc) {<br/>    float a = 0.0f;<br/>    for (int i = 0; i &lt; 50; i++) {<br/>      a += 0.01;<br/>    }<br/>    float b = 0.5f;<br/>    System.out.println(a == b);<br/>  }<br/>}</span></pre><p id="5124" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将导致比较结果为<em class="kl">假</em>！因此，应该避免直接比较<em class="kl">浮点数</em>(<em class="kl">double</em>)的相等性，因为这容易出错。</p><p id="8cdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最简单的解决方案是使用整数(长整型)的显式转换，并乘以10的幂:</p><pre class="kn ko kp kq gt ky kz la bn lb lc bi"><span id="21ac" class="ld le iq kz b be lf lg l lh li">class T {<br/>  public static void main(String[] argsc) {<br/>    float a = 0.0f;<br/>    for (int i = 0; i &lt; 50; i++) {<br/>      a += 0.01;<br/>    }<br/>    float b = 0.5f;<br/><br/>    int timesA = (int) Math.round(a * 10);<br/>    int timesB = (int) Math.round(b * 10);<br/><br/>    System.out.println(timesA == timesB);<br/>  }<br/>}</span></pre><p id="8415" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，结果会如预期的那样<em class="kl">为真</em>。还要注意，需要进行舍入，因为结果可能比目标值<em class="kl"> 0.5 </em>大0.5000000034 或小0.499999934。</p><p id="a189" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您不能<strong class="jp ir">使用浮点包装类来比较这个值</strong>。考虑以下内容:</p><pre class="kn ko kp kq gt ky kz la bn lb lc bi"><span id="9955" class="ld le iq kz b be lf lg l lh li">class T {<br/>  public static void main(String[] argsc) {<br/>    float a = 0.0f;<br/>    for (int i = 0; i &lt; 50; i++) {<br/>      a += 0.01;<br/>    }<br/>    float b = 0.5f;<br/>    boolean wrapperCmp = Float.valueOf(a).equals(b);<br/>    System.out.println(wrapperCmp);<br/>  }<br/>}</span></pre><p id="0d92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果为<em class="kl">假</em>！</p><p id="1009" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">BigDecimal类也是如此。</p><pre class="kn ko kp kq gt ky kz la bn lb lc bi"><span id="209c" class="ld le iq kz b be lf lg l lh li">import java.math.BigDecimal;<br/><br/>class T {<br/>  public static void main(String[] argsc) {<br/>    float a = 0.0f;<br/>    for (int i = 0; i &lt; 50; i++) {<br/>      a += 0.01;<br/>    }<br/>    float b = 0.5f;<br/><br/>    BigDecimal aBigDecimal = BigDecimal.valueOf(a);<br/>    boolean wrapperCmp = aBigDecimal.equals(b);<br/>    System.out.println(BigDecimal.valueOf(a));<br/>    System.out.println(wrapperCmp);<br/>  }<br/>}</span></pre><p id="1829" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果为<em class="kl">假:</em></p><pre class="kn ko kp kq gt ky kz la bn lb lc bi"><span id="30b4" class="ld le iq kz b be lf lg l lh li">0.4999998211860657<br/>false</span></pre><p id="81ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种解决方案是应用某种epsilum <em class="kl"> e </em>值:</p><pre class="kn ko kp kq gt ky kz la bn lb lc bi"><span id="d969" class="ld le iq kz b be lf lg l lh li">if |a - b| &lt; e then true</span></pre><p id="936e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可能认为价值是相等的:</p><pre class="kn ko kp kq gt ky kz la bn lb lc bi"><span id="fa2a" class="ld le iq kz b be lf lg l lh li">class T {<br/>  public static void main(String[] argsc) {<br/>    float a = 0.0f;<br/>    for (int i = 0; i &lt; 50; i++) {<br/>      a += 0.01;<br/>    }<br/>    float b = 0.5f;<br/><br/>    float epsilum = 0.0001f;<br/>    boolean epsilumCompare = Math.abs(a - b) &lt; epsilum;<br/><br/>    System.out.println(b);<br/>    System.out.println(a);<br/>    System.out.println(epsilumCompare);<br/>  }<br/>}</span></pre><p id="550d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码会导致:</p><pre class="kn ko kp kq gt ky kz la bn lb lc bi"><span id="9530" class="ld le iq kz b be lf lg l lh li">0.5<br/>0.49999982<br/>true</span></pre><p id="3359" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们可以只保留<em class="kl">浮点</em>类型<em class="kl"> </em>，而不使用<em class="kl">数学循环</em>和转换为<em class="kl">整数</em>。似乎我的评论家在他的评论中有一点。</p></div></div>    
</body>
</html>