<html>
<head>
<title>Essential Terms for a React Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React开发人员的基本术语</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/essential-terms-for-a-react-developer-feb88be0206b?source=collection_archive---------2-----------------------#2019-12-20">https://levelup.gitconnected.com/essential-terms-for-a-react-developer-feb88be0206b?source=collection_archive---------2-----------------------#2019-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/602bc945b722fc39d265e5dfb2ede218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cBUQThaa6pu24BRF.png"/></div></div></figure><p id="1502" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文是React for软件开发的概述。它为希望使用React或了解更多相关知识的人提供了基本的术语和概念。我一年多前开始使用<a class="ae kw" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React.js </a>，并用它构建了<a class="ae kw" href="https://spandraw.com" rel="noopener ugc nofollow" target="_blank"> Spandraw </a>。这篇文章涵盖了我在这个过程中学到的最重要的东西。</p><p id="bd52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你正在寻找现代web开发术语的概述，你可能会发现我之前关于web开发的文章很有用。它解释了React是什么以及为什么使用它。</p><h2 id="2fe1" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">JSX (JavaScript XML)</h2><p id="bb79" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">JSX文件代表包含XML语法(如HTML)的JavaScript文件。使用React时，所有组件都应该用JSX语法编写。JSX使得将HTML、JS和CSS组合成一个组件成为可能，通常作为一个单独的文件，这是React的主要目的之一。</p><h2 id="bca8" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">文档对象模型</h2><p id="19e0" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">界面中表示网页上HTML元素的DOM。例如，文章中的每一段可以在一个<code class="fe lv lw lx ly b">&lt;p /&gt;</code>元素中表示，而一个图像可以在一个<code class="fe lv lw lx ly b">&lt;img /&gt;</code>元素中表示。</p><p id="5b0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React在网页上对这些元素有自己的表示。这被称为React DOM，这个概念被称为虚拟DOM。其他前端框架如Angular和Vue使用类似的虚拟DOM原理来操作网页上的HTML。</p><h2 id="bac8" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">SPA(单页应用)</h2><p id="6dac" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">单页应用程序是单个网页，当导航到URL内的子域时，它会更改自己的内容，而不是从web服务器加载不同的网页。这是因为JavaScript能够改变页面上的HTML来响应用户的动作。</p><h2 id="174e" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">入口点</h2><p id="f962" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">入口点是托管应用程序的基本URL。以我自己在<a class="ae kw" href="https://app.spandraw.com" rel="noopener ugc nofollow" target="_blank">app.spandraw.com</a>的应用为例，这将是入口点，这个位置将包含根目录中的一个index.html文件。这个index.html只需要包含一个<code class="fe lv lw lx ly b">&lt;div id=”root” /&gt;</code>元素，以及适当的头。加载了整个“应用程序”的JavaScript，然后可以将这个div元素作为目标，并替换为必要的内容。通常，根组件被称为“index.jsx”。</p><h2 id="a13f" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">路由器</h2><p id="5904" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">当用户导航到react应用程序中的页面<a class="ae kw" href="https://app.spandraw.com/draw" rel="noopener ugc nofollow" target="_blank">app.spandraw.com/draw</a>时，位于<a class="ae kw" href="https://app.spandraw.com" rel="noopener ugc nofollow" target="_blank">app.spandraw.com</a>的index.html仍然被加载。子url '/draw '被客户端路由器识别，所需的组件呈现在根div元素中。</p><p id="b357" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在同一个应用程序内更改页面意味着可以使用相同的组件，并且可以在这个应用程序内的不同页面之间以“状态”共享数据。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="3df8" class="kx ky iq ly b gy mh mi l mj mk">&lt;Switch&gt;<br/>  &lt;Route exact path="/" component={Home} /&gt;<br/>  &lt;Route exact path="/draw" component={Draw} /&gt;<br/>&lt;/Switch&gt;</span></pre><h2 id="1530" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">生命周期方法</h2><p id="7070" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">生命周期方法是在React类组件内部的特定场景中被调用的函数。这些仅在类组件中可用，在使用钩子的函数组件中不可用。最常见的生命周期方法是<code class="fe lv lw lx ly b">componentDidMount()</code>、<code class="fe lv lw lx ly b">render()</code>和<code class="fe lv lw lx ly b">componentDidUpdate()</code>。</p><h2 id="1454" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">componentDidMount()</h2><p id="e6b9" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated"><code class="fe lv lw lx ly b">componentDidMount()</code>在组件创建时被调用。这对于执行只需要在页面加载时执行一次的操作非常有用，例如，检查用户是否登录。</p><h2 id="b5d2" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">渲染()</h2><p id="5cfe" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated"><code class="fe lv lw lx ly b">render()</code>在组件每次更新时被调用，包括创建时。React仅在组件的“状态”或“属性”改变时更新组件。任何需要显示的文本和HTML元素都需要从这个方法返回，使用JSX语法。</p><p id="4469" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自<a class="ae kw" href="https://reactjs.org/docs/react-component.html#overview" rel="noopener ugc nofollow" target="_blank">官方React文档的示例:</a></p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="364c" class="kx ky iq ly b gy mh mi l mj mk">render() {<br/>  return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;<br/>}</span></pre><h2 id="ff74" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">componentDidUpdate(prevProps，prevState)</h2><p id="b2c0" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated"><code class="fe lv lw lx ly b">componentDidUpdate()</code>在每次组件更新时被调用，而不是在创建组件时被调用。Render()只能访问当前状态和属性，而componentDidUpdate()也可以访问以前的状态和属性。</p><p id="eb9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当render()被调用时，你知道有些东西已经改变了，但是你不知道是什么。在componentDidUpdate()中，您可以具体检查发生了什么变化，并只执行该条件的逻辑。</p><p id="d7c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自<a class="ae kw" href="https://reactjs.org/docs/react-component.html#componentdidupdate" rel="noopener ugc nofollow" target="_blank">官方React文档的示例:</a></p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="b245" class="kx ky iq ly b gy mh mi l mj mk">componentDidUpdate(prevProps) {<br/>  // Typical usage (don't forget to compare props):<br/>  if (this.props.userID !== prevProps.userID) {<br/>    this.fetchData(this.props.userID);<br/>  }<br/>}</span></pre><h2 id="8adc" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">反应组分</h2><p id="4e43" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">React的一个主要目的是重用代码，通过将代码分组到一个“组件”中，该组件对应于要呈现给页面的元素。有两种主要类型的组件,“类”组件(标准的React组件)或“功能”组件。</p><p id="3163" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类组件有内置的生命周期方法(ComponentDidMount、ComponentDidUpdate等，见上文)。Function组件是一个标准的JavaScript函数，它使用react挂钩来访问状态和React生命周期功能，而不使用类。</p><h2 id="2142" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">小道具</h2><p id="2c0e" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">Props用于在连接的组件之间传递数据(父组件与子组件，反之亦然)。react中的约定是在一个名为“props”的对象中传递数据。对于类组件，可以在生命周期方法中使用“this.props”来访问它。对于函数组件，对象“props”作为参数传递给函数。</p><p id="7cb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当传递给组件的任何道具发生变化时，组件都会更新(重新渲染)，因此任何相关的生命周期方法都会被调用，比如render()和componentDidUpdate()等等。</p><h2 id="3e20" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">状态</h2><p id="dde0" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">状态在组件中用于保存更改的数据，但不需要向其他组件公开。props和state的主要区别在于组件能够更新自己的状态，但是props只能在传入时更改。在类组件中，通过调用<code class="fe lv lw lx ly b">this.setstate({…})</code>来改变状态。在函数组件中，通过使用React中的useState钩子来改变状态。</p><p id="5525" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与props一样，如果任何状态发生变化，组件将更新并调用相关的React生命周期方法。</p><h2 id="235d" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">纯成分</h2><p id="21cc" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">使用React。PureComponent类似于我们熟悉的React。除了PureComponent实现了“shouldComponentUpdate()中的浅层属性和状态比较”。使用“Component”要求用户在必要时手动执行shouldComponentUpdate()来优化更新。这实际上意味着React自动为PureComponent中的所有属性和状态实现类似这样的东西:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="c19f" class="kx ky iq ly b gy mh mi l mj mk">shouldComponentUpdate(nextProps, nextState) {<br/>  // update component if any of the props or state is changed using a shallow comparison<br/>  If (this.props.isLoading !== nextProps.isLoading) return true;<br/>  If (this.state.isButtonClicked !== nextState.isButtonClicked) return true;<br/><br/>  // otherwise do not update component<br/>  return false;<br/>}</span></pre><p id="ddf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于大多数组件来说，PureComponent通常比Component更具性能，因为它避免了不必要的更新，除非相关的属性或状态发生了变化。</p><p id="8726" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果使用更复杂的数据，并且有必要检查项目引用(而不仅仅是值)是否发生了变化，则应该使用“组件”。当组件包含一个props或state中的对象或数组时，那么您应该考虑是否可以接受浅层比较。使用PureComponent的风险是组件不会在预期的时候更新。</p><h2 id="70c8" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">事件绑定</h2><p id="c579" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">作为React初学者，一个特别令人困惑的领域是如何在React中绑定事件处理程序。您可能希望向函数传递三种类型的数据来进行事件处理，它们是:</p><ol class=""><li id="d5e5" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">访问React组件上的属性或状态</li><li id="1e27" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">“事件”本身(通常是点击、按键或表单值)</li><li id="ff9a" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">任何其他自定义值</li></ol><p id="4fd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这让我很困惑，因为有太多的方法可以做到这一点，特别是从ES6开始就有了箭头功能，而且不同的人用不同的方法做这件事。然而，滥用arrow函数会导致代码可读性差，并触发不必要的渲染，损害性能。</p><p id="24cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我个人的方法是:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="055b" class="kx ky iq ly b gy mh mi l mj mk">handleClick() {<br/>  console.log(‘handleClick does not need to be an arrow function’)<br/>}<br/><br/>render() {<br/>  return &lt;SomeButton onClick={this.handleClick} /&gt;<br/>}</span></pre><p id="39fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您忘记将“this”绑定到要传递给该方法的组件，您将得到类似“无法读取undefined的property 'props'”的错误，因为“this”是未定义的。当您收到这个错误时，首先要检查的是您已经为您的事件处理方法绑定了“this”。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="ad53" class="kx ky iq ly b gy mh mi l mj mk">constructor(props) {<br/>  super(props);<br/>  this.handleGetDataFromProps = this.handleGetDataFromProps.bind(this);<br/>}<br/><br/>handleGetDataFromProps() {<br/>  const { data } = this.props;<br/>  console.log(‘handleGetDataFromProps has access to data from component props: ’, data)<br/>}<br/><br/>render() {<br/>  return &lt;SomeButton onClick={this.handleGetDataFromProps} /&gt;<br/>}</span></pre><p id="20df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在案例3中，在事件处理方法中，通常会基于输入值执行setState或触发redux操作。</p><p id="dc5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">github 上的<a class="ae kw" href="https://github.com/airbnb/javascript/tree/master/react" rel="noopener ugc nofollow" target="_blank"> airbnb react风格指南是在react上使用现代javascript的良好实践的良好参考来源。</a></p><h2 id="ef1a" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">反应钩</h2><p id="e43c" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">React挂钩是在v16.8中引入的(2019年2月)。React文档的描述是“它们让你不用写类就能使用状态和其他React特性”。下面是一个例子(摘自<a class="ae kw" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"> react文档</a>):</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="59f4" class="kx ky iq ly b gy mh mi l mj mk">const [count, setCount] = useState(0);<br/><br/>  // Similar to componentDidMount and componentDidUpdate:<br/>  useEffect(() =&gt; {<br/>    // Update the document title using the browser API<br/>    document.title = `You clicked ${count} times`;<br/>  });</span></pre><p id="551d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">钩子和类的工作方式完全不同，下面的内容可以帮助您决定使用哪一种:</p><ul class=""><li id="d978" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mz mr ms mt bi translated">类通过生命周期事件工作。</li><li id="7810" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mz mr ms mt bi translated">钩子通过同步工作。</li></ul><p id="9650" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">截至目前(2019年12月)，react挂钩仍然相对较新，因此与类组件相比，现有的文档和文章较少。如果您有时间，那么尽一切可能尝试一下钩子并阅读文档。据我所知，钩子可以做类能做的任何事情，除了ComponentDidCatch生命周期事件。</p><h2 id="b592" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">Redux</h2><p id="ea7a" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">在创建React应用程序时，很可能需要在组件之间共享状态。一种方法是将状态作为道具传递给子组件。然而，当引入更多要传递的状态和更多的组件层时，这很快就会变得混乱。还有一个问题是跟踪状态在哪里被改变，并试图跟踪哪个组件改变了状态，这在复杂的应用程序中也会很快变得混乱。</p><p id="9a38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Redux(link)是一个库，采用了管理所有这些状态的最佳实践，采用了脸书创建的“Flux”架构。它通过三个主要原则做到这一点:</p><ol class=""><li id="3235" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">使用中央“存储”来保存所有“状态”(有时称为Redux存储)。</li><li id="393b" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">Redux存储中的所有“状态”都是只读的。若要更改存储中的任何状态，必须调度Redux操作。</li><li id="1ae3" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">为了改变Redux存储，使用“reducer”来寻找动作的类型，并相应地改变状态。建议返回一个新的状态，而不是突变之前的状态(即。纯函数)，这在使用数组和对象时尤为重要。</li></ol><p id="1439" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">使用Redux </strong></p><p id="5b19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用“mapStateToProps”和“mapDispatchToProps”并将组件包装在“connect”中，可以从任何组件访问此存储。动作通过mapDispatchToProps作为函数属性传入。“选择器”函数的使用是可选的，但是我建议您使用它，因为如果您希望重命名存储中的状态或嵌套，您可以只更改选择器函数，而不是转到使用该状态的每个组件并在那里更改mapStateToProps。对于复杂的app，建议将Redux store划分为对应其用途的多个部分，每个部分都有自己的reducer。</p><p id="3560" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用Redux的一个主要好处是Chrome的devtools插件的强大。它允许您查看Redux存储中的所有状态、任何被触发的动作，以及存储如何响应动作(即检查减速器是否正常工作)。在我看来，如果你需要构建一个需要伸缩的React app，那么你需要Redux。</p><h2 id="3950" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">Redux传奇</h2><p id="78f6" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">如果你正在使用Redux，并且你需要使用异步动作(例如，获取API，链接动作)，你将会想要使用某种类型的中间件来处理这个。Redux Saga是一个中间件，它可以拦截Redux动作，并根据API调用的结果异步执行逻辑。我个人使用Redux Saga，并发现它非常有用，但根据用例的范围，还有其他选择。</p><p id="74eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，您可以使用Sagas来监听“Get API”操作，然后调用REST API，监听响应。如果得到状态200的响应，则返回“API成功”动作，如果得到状态400，则返回“API失败”动作。这个动作然后可以被减速器拾取，并且状态可以相应地改变。当等待API请求的响应时，这是设置“加载”状态以呈现微调器的好方法。</p><h2 id="6259" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">以打字打的文件</h2><p id="cbd6" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated"><a class="ae kw" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>基本上就是带有类型定义的JavaScript。TypeScript文件以*结尾。ts(或*。tsx如果替换a *。jsx文件)，这被自动编译成可以在web浏览器中运行的JavaScript文件。它是由微软创建的，与用TypeScript编写的VS代码编辑器配合得特别好。</p><h2 id="9ee1" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated"><strong class="ak">优点:</strong></h2><ul class=""><li id="b217" class="ml mm iq ka b kb lq kf lr kj na kn nb kr nc kv mz mr ms mt bi translated">在代码编辑器中捕获由于不正确的类型而导致的错误，而不是在运行时捕获。</li><li id="c315" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mz mr ms mt bi translated">协助代码完成(智能感知)和编辑器工具，如“跳转到定义”，节省开发人员大量时间</li><li id="ff65" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mz mr ms mt bi translated">它帮助团队交流代码库和构建应用程序</li><li id="c841" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mz mr ms mt bi translated">帮助文档库——几乎每个主要的npm包都有typescript定义</li></ul><p id="7b78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">缺点:</strong></p><ul class=""><li id="bed5" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mz mr ms mt bi translated">更详细，需要输入更多</li><li id="1269" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mz mr ms mt bi translated">编译错误会阻止应用程序运行，在原型开发新功能时会令人沮丧，并且只需要记录一些结果</li><li id="b46d" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mz mr ms mt bi translated">不容易从其他地方复制和粘贴</li></ul><p id="ee75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我看来，TypeScript的好处远远大于坏处，如果没有它，我不会考虑构建一个新的React应用程序。当我构建自己的应用程序Spandraw时，我开始只使用jsDoc，这对于一个小应用程序来说是可以的，但在扩展时很快就遇到了问题。然后转行做TypeScript，渐渐的学了个里里外外。我用得越多，就越觉得它有价值，这只能是一个好现象。</p><p id="0ce0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2019年的TypeScript比2017/2018年好了很多，React社区也真正拥抱了它。如果你正在构建一个需要伸缩的应用程序，并且有很多组件，那么你真的应该考虑使用TypeScript和Redux。</p><h2 id="8fb5" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">样式组件</h2><p id="2e4b" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">Styled Components是一个用JavaScript编写CSS组件的库，也称为CSS-in-JS。这允许使用变量，变量可以作为道具传递到“样式组件”中，或者作为常量直接导入。样式化的组件可以和React组件包含在同一个文件中，这是我喜欢的样式。这避免了在开发过程中必须在React和CSS文件之间切换。</p><p id="0b86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与内联css相比，它的一个优势是使用与css相同的语法，而使用React的内联CSS需要将CSS转换成JS对象。这需要将名称中的破折号转换为骆驼大小写，将值转换为字符串，在进行这种转换时很容易出错。</p><p id="bdd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有许多方法可以在React应用中实现CSS，因为默认的CSS在使用变量方面有限制。其他一些方法包括SCSS，较少，CSS模块。我个人推荐使用React的风格化组件，因为它们可以很好地相互补充。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="42d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你觉得React的概述有用，请<a class="ae kw" href="https://www.linkedin.com/in/howanto/" rel="noopener ugc nofollow" target="_blank">在LinkedIn上联系我</a>或<a class="ae kw" href="https://medium.com/@ho.wan" rel="noopener">在Medium上关注我</a>。我曾经是一名结构工程师，我打算把它和计算一起写下来。在Spandraw.com<a class="ae kw" href="https://app.spandraw.com" rel="noopener ugc nofollow" target="_blank"/>查看我自己的React应用程序的进度</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="49ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nk">原载于2019年12月20日</em><a class="ae kw" href="https://spandraw.com/blog/overview-of-react-553" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://spandraw.com</em></a><em class="nk">。</em></p></div></div>    
</body>
</html>