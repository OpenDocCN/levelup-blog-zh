<html>
<head>
<title>Implementing Interactive Pop Gesture in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS中实现交互式Pop手势</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-interactive-pop-gesture-in-ios-3012fa958545?source=collection_archive---------6-----------------------#2020-04-14">https://levelup.gitconnected.com/implementing-interactive-pop-gesture-in-ios-3012fa958545?source=collection_archive---------6-----------------------#2020-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/41bc8dc736acb4bc0b1f72a82892b320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RAuX4x6ZQHQjYNoOtD86Lg.png"/></div></div></figure><p id="498d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">交互式弹出手势是一个核心交互，它使导航回上一个屏幕变得更加容易。设备越大，它提供的价值就越大。</p><p id="08b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">苹果声称这是开箱即用的默认行为，对于一个标准应用来说确实如此。尽管如此，如果你正在构建一个定制的应用程序，正如我发现自己大部分时间都在做的那样，你会发现这不再适用。</p><p id="3727" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果您有一个自定义的后退按钮，或者不希望用户从某个屏幕向后导航，那么您就无法控制默认实现。在本文中，我们将通过某种方式实现它，让您完全控制用户是否应该能够从一个屏幕返回。</p><h1 id="4286" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">屏幕什么时候能导航回来？</h1><p id="7f28" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在我们的BaseViewController子类中的所有视图控制器)中，我们添加了一个默认函数来确定屏幕是否应该向后导航。有些应用程序可能没有BaseViewController，如果你是这样，你可以跳过这一步。不过，我建议考虑在中添加一个，以提供对常用功能的屏幕访问。在我们的例子中，我们有一个函数来决定这个屏幕是否应该阻止向后导航。当满足以下条件时，我们允许屏幕向后导航:</p><ul class=""><li id="fe69" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">导航栏是可见的</li><li id="e76f" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">自定义后退按钮可见</li><li id="87e6" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">屏幕上没有显示加载器</li></ul><p id="91e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这显示在下面的代码片段中。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="3536" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">导航控制器什么时候可以导航回来？</h1><p id="829f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这需要在整个应用程序中使用一个子类化的UINavigationController，或者至少在您想要实现pop手势功能的地方使用。我添加到的应用程序已经在生产中，没有一个，所以我用一个新创建的BaseNavigationController替换了所有手动创建的UINavigationController。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0aab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这有一个存储的属性<code class="fe mt mu mv mw b">duringPushAnimation</code>,它允许我们跟踪一个屏幕何时被激活到视图控制器的堆栈上。</p><p id="5bcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到，我们在viewDidLoad函数中设置了两个委托。第一个是需要的，因为我们需要知道一个屏幕什么时候被推送到视图控制器的堆栈上。第二个是用于弹出手势的手势识别器。我们在下一步中遵守协议。</p><h2 id="2ba7" class="mx kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">实现UINavigationControllerDelegate</h2><p id="57c7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我个人喜欢使用每个协议的扩展来确认一个协议的类。这整齐地分离了不同的关注点，鼓励相关的逻辑被分组，并使另一个开发人员更容易阅读。通过实现这个委托函数，我们可以洞察UIViewController何时显示。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="7fac" class="mx kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">实现UIGestureRecognizerDelegate</h2><p id="6c2e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这是所有神奇的事情发生的地方，这是我们决定允许用户是否可以返回的地方。在三种主要情况下，我们不希望他们导航回来。</p><ul class=""><li id="d50f" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">如果视图控制器不允许的话。这可以通过调用我们之前在基本视图控制器上编写的<code class="fe mt mu mv mw b">preventInteractivePopGesture</code>函数来完成</li><li id="8533" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">当堆栈上只有一个屏幕时</li><li id="6c73" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">或者，如果我们是在一个推动动画，这是当一个屏幕上的动画。如果我们允许用户在这段时间返回，可能会打乱屏幕的顺序。</li></ul><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="1a0f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">就成了</h1><p id="13e3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在你的应用程序应该有一个很棒的交互，允许用户从屏幕的左边缘滑动，导航回上一个。自从最近升级我的iPhone以来，屏幕变得相当大，我发现自己比以前更频繁地使用这个功能。</p><p id="f490" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，一旦知道该怎么做，这个特性就不难实现。我发现在定制应用程序中实现这一点的在线资源非常缺乏，这需要一点点的尝试和错误。虽然在生产中的两个相当大的应用程序中实现了这一点，但我可以确认它非常有效。希望这已经教会了你一些新的东西，并且当你决定在你的应用中实现它的时候可以节省你的时间。</p></div></div>    
</body>
</html>