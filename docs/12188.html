<html>
<head>
<title>Quilt — A module federation library and web-component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">quilt——一个模块联合库和web组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/quilt-a-module-federation-library-and-web-component-9fe7999b4a19?source=collection_archive---------4-----------------------#2022-05-22">https://levelup.gitconnected.com/quilt-a-module-federation-library-and-web-component-9fe7999b4a19?source=collection_archive---------4-----------------------#2022-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="cdb3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="6da6" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最近，我对网络中的平台和框架不可知论有些着迷。也许是我经历了JQuery的衰落，AngularJS的崛起和随后的衰落(1。x)，以及目前React的黄金时代。在许多方面，感觉前端经常处于Gartner炒作周期的顶峰，新框架以震耳欲聋的速度出现。</p><p id="cc67" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这促使我去探索我们可以追溯到JavaScript根源的方法，我偶然发现了web组件。我以前写过关于web组件[ <a class="ae lo" href="https://dev.to/cawfeecoder/web-components-an-introspective-363c" rel="noopener ugc nofollow" target="_blank"> 1 </a> ]的文章，以及我所看到的拥有一组基本原语的好处，这些原语可以存在于现在和将来的任何框架中。把它当成一种对冲，防止React在5到10年后成为最热门的东西。</p><p id="d88c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">随后，我也一直在探索模块联合。几年前，我曾经写过一个框架，利用模块联合将应用程序动态地交付给我正在构建的智能镜像平台。现在，随着对微前端的兴趣达到临界质量，我看到了许多动态联邦非常有意义的情况。</p><h1 id="3ad3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是被子</h1><p id="c528" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Quilt是我创作的一个web组件和库，用于简化微前端和模块联合。主机(或消费)应用程序不需要在“主机”模式下设置Webpack w/Module Federation，也不需要担心如何将动态模块联邦(例如，在运行时动态地拉取模块)集成到它们的特定框架中，而Quilt既提供了一个库(面向除UI组件之外的任何联邦对象)又提供了一个web组件(消除了许多麻烦)。</p><p id="3dc9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我一直在计划——并与之斗争——web pack和一个名为“atomico”<a class="ae lo" href="https://atomicojs.github.io" rel="noopener ugc nofollow" target="_blank">2</a>的鲜为人知的微型库，以使web组件部分成为现实。其中一部分是因为我自己注意到，在Webpack的规范中使用联邦模块很容易，但是实现动态加载要困难得多(在我看来，这需要一点神秘的知识)。我希望在未来进一步扩展Quilt，以涵盖诸如“vite模块联盟”或模块联盟规范之类的东西，这比将自己与webpack捆绑在一起更不可知</p><h1 id="56e2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">它是如何工作的？</h1><p id="c1b1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">棉被的库web组件所依赖的——是一个简单的函数[ <a class="ae lo" href="https://github.com/seam-dev/quilt/blob/main/src/lib.ts" rel="noopener ugc nofollow" target="_blank"> 3 </a> ]，看起来与webpack自己的例子[ <a class="ae lo" href="https://github.com/module-federation/module-federation-examples/blob/master/dynamic-system-host/app1/src/App.js" rel="noopener ugc nofollow" target="_blank"> 4 </a>有些相似。主要区别在于，我们没有使用React Lazyloader之类的特定于框架的加载，而是选择通过动态生成的脚本标签进行加载。</p><p id="4218" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你看，当一个Webpack模块通过一个脚本标签加载时，它把它的内容放入DOM对象的窗口中，使用它的名字作为键。这意味着在window[name]下，我们会发现我喜欢称之为“模块容器”的东西。这个容器公开了两个函数:init()和get()。init()函数用于初始化模块将与宿主应用程序共享的共享范围。如果您没有绑定依赖项，而是希望宿主应用程序与加载的模块“共享”它们，这可能会很有帮助(这会大大减少包的大小)。另一个函数get()允许我们检索已经公开的特定JavaScript模块的内容——一个Webpack模块可以公开一个或多个JavaScript模块。这个get()函数的结果是一个工厂，当它被构造时，允许我们从模块中获取对象、函数和其他语言原语，就像我们是一个普通的JavaScript模块一样。</p><p id="0ff7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">web组件采用了这一概念，并将其专门应用于应用程序中的联合——尽管我更喜欢称它们为“小应用程序”,因为我认为人们会希望根据微前端实践将多个应用程序紧密地结合在一个页面上。web组件附加提供了模块加载失败时的处理—允许用户提供的元素在失败场景中显示—以及允许定制在模块被获取和加载时显示的元素。</p><p id="3bc2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我还没有用Astro [ <a class="ae lo" href="https://astro.build" rel="noopener ugc nofollow" target="_blank"> 5 </a> ]之类的东西测试过服务器端渲染，不过我打算很快看看你是否能两全其美(或者做些调整让它成为可能)。</p><p id="c606" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我真的认为Quilt擅长于实现或促进以下场景:</p><ul class=""><li id="9020" class="lp lq iq kn b ko lj ks lk kw lr la ls le lt li lu lv lw lx bi translated">多个小软件团队的“小程序”需要在一个页面上集合在一起</li><li id="f764" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">交付一个“小应用程序”作为框架的强大替代(为了可访问性和更好的集成)</li><li id="5cd0" class="lp lq iq kn b ko ly ks lz kw ma la mb le mc li lu lv lw lx bi translated">在运行时动态调整哪些模块被联合，以支持每个用户或A/B测试的不同配置</li></ul><p id="26ac" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我确信整个社区将会提出更多我无法预见的用例，我期待着看到它们:)</p><h1 id="3443" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">例子</h1><p id="8783" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了演示Quilt，我想我应该展示一些代码作为例子。请注意，我已经公开了一个模块联合模板<a class="ae lo" href="https://github.com/seam-dev/federation-template" rel="noopener ugc nofollow" target="_blank">这里</a>可以很容易地引导你制作你的第一个模块，并将其联合到另一个应用程序:)</p><p id="9620" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">首先，我们要去https://github.com/seam-dev/federation-template的<a class="ae lo" href="https://github.com/seam-dev/federation-template" rel="noopener ugc nofollow" target="_blank">克隆存储库。您同样可以选择使用它作为模板存储库来形成您自己的存储库:</a></p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7f54" class="mm jo iq mi b gy mn mo l mp mq">git clone <a class="ae lo" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:seam-dev/federation-template.git</span></pre><p id="3207" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">package.json中提供了6个主要命令，但实际上我们只关心其中的两个:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="6ddf" class="mm jo iq mi b gy mn mo l mp mq">npm run start - Uses webpack-dev-server to give you a "hot-reload" development experience, sans module federation</span><span id="5db0" class="mm jo iq mi b gy mr mo l mp mq">npm run serve:watch - Uses webpack --watch, Vercel serve, and concurrently to continually rebuild the federated module in a "hot-reload" fashion (though the consuming host application requires a manually reload each time to load the new file)</span></pre><p id="2244" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">否则，在这些命令之外，这是一个没有开发陷阱的普通标准Preact(尽管您可以轻松地替换掉框架)应用程序。</p><p id="0246" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">要使用该应用程序，您可以使用以下内容创建一个index.html页面。注意，您必须使用<code class="fe ms mt mu mi b">npm run serve:watch</code>运行您的联邦模块(如上),这样我们就有一个本地文件服务器来托管文件:</p><figure class="md me mf mg gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d889" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">您现在可以在浏览器中打开index.html(或者使用类似browser-sync [ <a class="ae lo" href="https://browsersync.io" rel="noopener ugc nofollow" target="_blank"> 6 </a> ])并实时查看您的模块联邦:)</p><p id="eb48" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">关于上面的一些注意事项:我通常将UI加载作为默认导出从导出I name”中公开。/loadApp”，如webpack.config.ts中所示。这纯粹是我自己的命名约定:</p><figure class="md me mf mg gt mv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="568d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">去哪里拿？</h1><p id="3237" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您目前可以通过多种方式获得被子:</p><p id="7cc4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><code class="fe ms mt mu mi b">npm install @seam-dev/quilt</code></p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="2d48" class="mm jo iq mi b gy mn mo l mp mq">https://unpkg.com/@seam-dev/quilt@latest/fed.wc.js</span></pre><p id="ee1f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">或者去仓库:<a class="ae lo" href="https://github.com/seam-dev/quilt" rel="noopener ugc nofollow" target="_blank">https://github.com/seam-dev/quilt</a></p><p id="c9a1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我期待看到它开始在那里被使用:)</p><p id="56dc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">期待未来系列展示Quilt真正发挥作用的业务用例示例。</p></div></div>    
</body>
</html>