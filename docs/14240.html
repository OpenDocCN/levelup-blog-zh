<html>
<head>
<title>Huge course about networking, web and everything in between</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">庞大的网络课程，网络和其间的一切</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/huge-course-about-networking-web-and-everything-in-between-d6f425ceea13?source=collection_archive---------12-----------------------#2022-11-10">https://levelup.gitconnected.com/huge-course-about-networking-web-and-everything-in-between-d6f425ceea13?source=collection_archive---------12-----------------------#2022-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="80b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">哦，我亲爱的learners✌️.你想了解更多关于网络和web: OSI，ARP，MAC，DNS等吗？然后阅读这篇文章，通过例子了解大量新信息。</p><p id="a8b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想对<a class="ku kv ep" href="https://medium.com/u/e4cbe924ccb?source=post_page-----d6f425ceea13--------------------------------" rel="noopener" target="_blank">侯赛因·纳赛尔</a>表示感谢，他的YouTube频道帮我浏览了所有资料，并提供了进一步的研究步骤:<a class="ae kw" href="https://www.youtube.com/c/HusseinNasser-software-engineering" rel="noopener ugc nofollow" target="_blank">https://www . YouTube . com/c/Hussein Nasser-软件工程</a></p><p id="6b92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有的图片都是侯赛因·纳赛尔的视频截图，我会在每一部分的开头提到。👏</p><h2 id="afe4" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">包含各部分链接的目录📌：</h2><ul class=""><li id="ffd1" class="lq lr iq jp b jq ls ju lt jy lu kc lv kg lw kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#7424" rel="noopener"> OSI模型</a>和:<br/>-<a class="ae kw" href="https://medium.com/p/d6f425ceea13#5347" rel="noopener">PDU</a><br/>-<a class="ae kw" href="https://medium.com/p/d6f425ceea13#6ed1" rel="noopener">ARP</a><br/>-<a class="ae kw" href="https://medium.com/p/d6f425ceea13#254c" rel="noopener">NAT</a><br/>-<a class="ae kw" href="https://medium.com/p/d6f425ceea13#acb4" rel="noopener">公有与私有IP地址</a> <br/> - <a class="ae kw" href="https://medium.com/p/d6f425ceea13#24dd" rel="noopener"> TCP/IP视频链接</a></li><li id="707e" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#49fd" rel="noopener">域名系统</a></li><li id="5a41" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#ba3f" rel="noopener"> TCP和UDP协议</a></li><li id="5e62" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#4f67" rel="noopener"> TCP握手</a></li><li id="be58" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#1707" rel="noopener"> HTTP </a>同:<br/>-<a class="ae kw" href="https://medium.com/p/d6f425ceea13#46fe" rel="noopener">HTTP 1.0</a><br/>-<a class="ae kw" href="https://medium.com/p/d6f425ceea13#b596" rel="noopener">HTTP 1.1</a><br/>-<a class="ae kw" href="https://medium.com/p/d6f425ceea13#5401" rel="noopener">HTTP 2</a><br/>-<a class="ae kw" href="https://medium.com/p/d6f425ceea13#1b46" rel="noopener">HTTP 3</a><br/>-<a class="ae kw" href="https://medium.com/p/d6f425ceea13#b61e" rel="noopener">GET VS POST</a></li><li id="eb73" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#00b2" rel="noopener">带有电子标签的HTTP缓存</a></li><li id="e4c4" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#891a" rel="noopener"> TLS </a> : <br/> - <a class="ae kw" href="https://medium.com/p/d6f425ceea13#013d" rel="noopener"> ver。1.2</a>-<a class="ae kw" href="https://medium.com/p/d6f425ceea13#46c3" rel="noopener">版本1.3</a>-<a class="ae kw" href="https://medium.com/p/d6f425ceea13#8122" rel="noopener">DNS over HTTPS又名DoH </a></li><li id="fece" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#27f5" rel="noopener">证书和证书颁发机构</a></li><li id="fb6b" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#f252" rel="noopener"> SNI，埃斯尼</a></li><li id="9ada" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#f42d" rel="noopener"> Web服务器</a>和<br/> - <a class="ae kw" href="https://medium.com/p/d6f425ceea13#fa80" rel="noopener">有状态与无状态应用</a></li><li id="c6a1" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">CORS  +飞行前请求</li><li id="07e8" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#fcca" rel="noopener">HTTP cookie</a></li><li id="a825" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#92ed" rel="noopener">代理vs反向代理</a>和:<br/> - <a class="ae kw" href="https://medium.com/p/d6f425ceea13#3728" rel="noopener"> L4 vs L7负载平衡器</a> <br/> - <a class="ae kw" href="https://medium.com/p/d6f425ceea13#0c67" rel="noopener"> TLS/SSL终止</a> <br/> - <a class="ae kw" href="https://medium.com/p/d6f425ceea13#d655" rel="noopener"> TLS直通</a></li><li id="d276" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#ccdb" rel="noopener"> HSTS </a></li><li id="7d39" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#74e5" rel="noopener">哑剧嗅探</a></li></ul><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/f02eae277476a65c2055663266579bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S1q-rDYP6BaRpZf3"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">福蒂斯·福托普洛斯</a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="6599" class="nd ky iq bd kz ne nf ng lc nh ni nj lf nk nl nm li nn no np ll nq nr ns lo nt bi translated">简介和免责声明</h1><p id="285b" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">最近，作为一名软件工程师，我在当前的工作中遇到了一个问题:我需要为一个负责负载测试的系统进行设置。又名扮演DevOps工程师。然而，在开始之前，我的团队领导告诉我:排练/学习OSI、L4与L7负载平衡器、SNI之类的东西。嗯，我想大概要花几天时间。但是OSI把我引到了NAT，ARP等等。总之，我每天花2.5周的时间学习网络和网络相关的东西。</p><p id="240a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我花了几十个小时，但我只触及了表面，因为我现在不需要深入研究一些主题。这就是为什么我不会讨论“第二层的片段如何变形为第一层”的原因，因为我根本不需要它+我还有其他对now‼️更重要的东西要学</p><p id="c7db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果你在文章中发现任何错误或者想问任何问题，请随时在评论中给我留言或者通过文章末尾提供的来源给我写信📣</p><p id="3a7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我将在每个部分提供相应的资源。通常，这是侯赛因·纳赛尔的视频💻</p><h1 id="29d5" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">1.带有ARP、NAT、公有与私有IP地址的OSI模型</h1><h2 id="ec2b" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">1.开放式系统互联参考模型(Open System Interconnect Reference Model)</h2><p id="e938" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频1:<a class="ae kw" href="https://www.youtube.com/watch?v=7IS7gigunyI" rel="noopener ugc nofollow" target="_blank">T3【https://www.youtube.com/watch?v=7IS7gigunyI】T5</a></p><p id="b0cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视频二:<a class="ae kw" href="https://www.youtube.com/watch?v=eNF9z5JNl-A" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=eNF9z5JNl-A</strong></a></p><p id="d6a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">进一步阅读以更好地理解<strong class="jp ir"> MAC地址</strong>:</p><div class="oc od gp gr oe of"><a href="https://people.richland.edu/dkirby/141macaddress.htm#:~:text=The%20MAC%20address%20is%20an,like%20TCP%2FIP%20to%20function" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">mac地址</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">在计算机网络中，媒体访问控制(MAC)地址与IP地址一样重要。在…中学习</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">people.richland.edu</p></div></div></div></a></div><p id="1890" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> OSI </strong> —开放系统互通模型。它是一个模型，负责定义数据如何从最高层(例如，当我们发出GET请求时)流向最底层(跨越全球的物理电缆)。</p><p id="01bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模型中有7层，其中1层是最低层(也称为物理层)，第7层是最高层(也称为应用层)。对于软件工程师来说，最重要的是第7层和第4层。我们可以说每一层都给数据添加了一些头。</p><p id="a590" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看所有的order➿:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oo"><img src="../Images/7cf88401d184705a9778968a89b51736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PFvMILseQFirwY-iNGs3Mg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><strong class="bd kz"> OSI </strong>模型图像</figcaption></figure><p id="5fc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">7.第7层—应用层。这是我们在应用程序中发出HTTP/HTTPS协议请求的层。例如，我们发出GET请求(所有这些东西都来自不同的层，但它看起来就像你从你的应用程序发送一些请求):</p><ul class=""><li id="fd58" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">GET/ —请求的类型</li><li id="b868" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir"> HTTP协议</strong> +带有cookies的标题，内容类型</li></ul><p id="a218" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们发送POST/ request，那么我们也在这个级别上序列化数据。</p><p id="6db5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6.第6层—表示层。这一层负责:</p><ul class=""><li id="3651" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">用ASCII编码</li><li id="0d4e" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir">加密/解密:SSL，TCL </strong>(但这是灰色地带)</li><li id="1b3e" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">压缩</li></ul><p id="015c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，TLS介于4层和7层之间:介于TCP和HTTP之间。因此，以上所有数据(最多7层)将被加密。</p><p id="b2b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.第5层—会话层。该层标记数据以进一步识别它。例如，当数据将来自第1层到第7层时，这一层检查它是否是该TCP连接的会话，因为可能有到单个服务器的多个TCP连接。</p><p id="4f8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.第4层—传输层。在这一层之前，所有的请求都是一个数据块。在这一层，它将被分割成<strong class="jp ir">段</strong>。此外，在这一层，所有的数据段都被<em class="os">前置</em>和<em class="os">分别附加</em>源端口和目的端口。看起来像是:<strong class="jp ir">源端口段目的端口</strong>。此外，该层添加序列，以便在接收到这些<em class="os">段</em>时对其进行排序。为了添加这个序列，你需要<strong class="jp ir">标题</strong></p><p id="096a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.第3层—网络层(IP协议)。这一层只是接收来自<strong class="jp ir">传输层</strong>的数据段(而且，它对端口一无所知)并添加更多的头:端口。所以，这一层之后的数据将会是这样的:</p><p id="a0b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ot ou ov ow b"><strong class="jp ir">source IP Address — IP Packet — destination IP Address</strong></code></p><p id="cb0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一层，我们将数据称为<strong class="jp ir"> IP数据包</strong>(在第4层，它是数据段)。</p><p id="aa73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.第2层—数据链路。在这一层，IP数据包被分成更小的部分。在这一层上，我们形成所谓的<strong class="jp ir">帧</strong>，看起来像:</p><p id="8306" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ot ou ov ow b"><strong class="jp ir">MAC Source — IP PACKET — MAC Destination</strong></code></p><p id="e194" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，这是唯一一层有一个拖车:它包含错误检测和错误纠正位。它也被称为帧校验序列(FCS)。</p><p id="425f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，像<code class="fe ot ou ov ow b">01100010</code>这样的比特被推到最低层。</p><ul class=""><li id="5305" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">像往常一样，如果IP包很大，很容易出现多个T21碎片</li><li id="4e0c" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">如果我们不知道<strong class="jp ir"> MAC的</strong>地址，那么就让<a class="ae kw" href="https://medium.com/@SleeplessChallenger/d6f425ceea13#684b" rel="noopener"> <strong class="jp ir"> ARP </strong> <strong class="jp ir">请求</strong> </a>找到目的地的网关</li><li id="8e31" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">如果请求不发送到我们的子网，那么连接我们和外部世界的路由器的MAC地址。</li></ul><ol class=""><li id="4102" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">第1层—物理层。它接受来自第二层的<strong class="jp ir">帧</strong>,并将它们放入物理设备中:以太网也就是电缆，WiFi也就是无线电波。</li></ol><h2 id="5347" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak"> PDU </strong></h2><p id="0ae7" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">协议数据单元。它描述了不同级别的数据:</p><ul class=""><li id="d1fe" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">7–5:<em class="os">数据</em></li><li id="1849" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">4 —如果是UDP，那么<em class="os">数据报</em>。如果是TCP那么<em class="os">段</em></li><li id="33fb" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">3: <em class="os">数据包</em></li><li id="a885" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">2: <em class="os">框架</em></li></ul><p id="e8da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这种<strong class="jp ir">PDU</strong>在一次连接中数量很大。然后，在第3层，我们将这些<strong class="jp ir">PDU</strong>分割成更小的部分——<strong class="jp ir">片段</strong>。对于每个被认为已传送的数据包，所有的<strong class="jp ir">片段</strong>都必须传送。</p><h2 id="6ed1" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">2.空袭预防措施</h2><h2 id="684b" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">地址分辨协议</h2><p id="8afa" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:<a class="ae kw" href="https://youtu.be/mqWEWye-8m8" rel="noopener ugc nofollow" target="_blank">https://youtu.be/mqWEWye-8m8</a></p><p id="f995" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得我说过要从OSI模型的第3层到第2层，我们需要得到目的地的<strong class="jp ir"> MAC地址</strong>吗？但是，怎么可能得到那一个呢？<strong class="jp ir"> ARP </strong>是为给定的<strong class="jp ir"> IP地址</strong>找到<strong class="jp ir"> MAC </strong>的东西。</p><p id="e8f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每台机器都有ARP表，ARP表有映射:<strong class="jp ir"> IP地址— MAC地址</strong>。但是如果我们现在的IP没有MAC呢？没问题！</p><p id="65e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想看看两个案例🔍：</p><ol class=""><li id="e962" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">在我们的子网内</li></ol><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oy"><img src="../Images/22b949a9bd91692b0ccd76bdf9bef7b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Qjc9pYZjZh-LDEIcnjxhQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">路由器的ARP示例</figcaption></figure><ul class=""><li id="0165" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">在上图中，你可以看到每台机器旁边的ARP表。</li><li id="585f" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">首先，机器向路由器请求所需的<strong class="jp ir"> IP地址</strong>。</li><li id="e80a" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">路由器通知子网中的所有机器，如果成功，其中一台机器用<strong class="jp ir"> MAC地址</strong>进行响应。</li><li id="e959" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">路由器给我们这个MAC地址，我们将它缓存在<strong class="jp ir"> ARP表</strong>中。</li><li id="7743" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">而我们的机器可以向给定的<strong class="jp ir"> MAC地址</strong>发送数据(看OSI第二层和第一层)</li></ul><p id="449c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.在我们的子网之外:</p><p id="53e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这里有点不同</strong></p><ul class=""><li id="4dcb" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">当我们向外部子网发送数据时(我们通过计算目的IP地址的掩码知道这一点)，我们需要通过路由器来完成。</li><li id="3bef" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">首先向路由器发出ARP请求，接收路由器的MAC地址并缓存在表中。</li><li id="d535" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">使用这个<strong class="jp ir"> MAC </strong>地址构建请求(又名来自OSI第2层的<strong class="jp ir">片段</strong>)并发送给路由器。</li><li id="89f0" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">路由器在第2层解封装数据，然后移动到第3层。它查看<strong class="jp ir"> IP地址</strong>。</li><li id="9c91" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">路由器交换我们机器的IP地址并把它自己。因此，它代表自己向外部世界发出请求。为了匹配回来，它需要<a class="ae kw" href="https://medium.com/p/d6f425ceea13#2d26" rel="noopener"> <strong class="jp ir"> NAT </strong> </a>。</li></ul><p id="53b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，路由器不使用<strong class="jp ir"> MAC </strong>，而是使用<strong class="jp ir"> IP </strong>。它使用存储在其<em class="os">路由表</em>中的每一个<em class="os">子网掩码</em>，并开始计算寻找出站IP的匹配。</p><p id="79d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">路由表包括:1 .<strong class="jp ir"> DNA </strong> 2。<strong class="jp ir">下一跳</strong> 3。<strong class="jp ir">公制</strong></p><p id="7b41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果路由器没有找到与目的IP匹配的<strong class="jp ir"> DNA </strong>，它将使用<code class="fe ot ou ov ow b">0.0.0.0</code>的DNA</p><p id="41c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS: <strong class="jp ir"> MITM </strong>(中间人攻击)可能发生在有人伪装成路由器的情况下。在下一节中阅读关于<a class="ae kw" href="https://medium.com/p/d6f425ceea13#27f5" rel="noopener">的更多信息</a></p><h2 id="254c" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">3.精灵</h2><h2 id="2d26" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">网络地址转换</h2><p id="db87" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:<a class="ae kw" href="https://www.youtube.com/watch?v=RG97rvw1eUo" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=RG97rvw1eUo</strong></a></p><p id="979d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">延伸阅读:</p><ul class=""><li id="47d1" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">【https://serverfault.com/a/14587 T4】</li><li id="e835" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://networkengineering.stackexchange.com/a/3342" rel="noopener ugc nofollow" target="_blank">https://networkengineering.stackexchange.com/a/3342</a></li></ul><p id="4352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是将一个<strong class="jp ir"> IP地址</strong>映射到另一个<strong class="jp ir"> IP地址</strong>的过程。事实上，这更困难，这就是为什么我们要深入研究。</p><p id="18a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，⚙️:国家公园的目的是什么</p><ul class=""><li id="bbd3" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">私有到公共IP转换(解决IPV4地址不足的问题)</li><li id="7ebc" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">端口转发</li><li id="2d5b" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">L4负载平衡</li></ul><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi oz"><img src="../Images/b603b4155dc8fed3b6be3db1ddfc323c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ggGjvgl_uKsOyRXK76d7pQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><strong class="bd kz"> NAT </strong>示例</figcaption></figure><ol class=""><li id="1a1f" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">子网中的机器向子网外的机器发出请求。它从计算掩码中知道。所以，我们不能向我们网络外的机器发出<strong class="jp ir"> ARP请求</strong>。</li><li id="16bb" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">首先，我们的机器向路由器发出<strong class="jp ir"> ARP请求</strong> ( <a class="ae kw" href="https://medium.com/p/d6f425ceea13#6ed1" rel="noopener">阅读上文</a>)。</li><li id="ab3c" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">然后我们把数据发给路由器(也叫<strong class="jp ir">默认网关</strong>)。路由器将<strong class="jp ir">源IP地址</strong>换成自己的:</li></ol><ul class=""><li id="91fa" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><em class="os">来源</em><strong class="jp ir"><em class="os"/></strong><em class="os">IP地址:端口→路由器IP地址:端口(端口可以与第一个相同，也可以不同)</em>还有，路由器互换<strong class="jp ir"> IP地址</strong>用于外网(路由器有<strong class="jp ir"> IP地址</strong>用于内网，用于外网)，而不是子网。</li><li id="6e03" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><em class="os">路由器IP地址:端口→目的IP地址:端口</em></li></ul><p id="c7e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，路由器有这个表，它可以将响应匹配回子网中机器的<strong class="jp ir"> IP </strong>。如果什么也没有找到，则表明这台机器实际上没有发送任何东西。</p><h2 id="acb4" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">4.公共与私有IP地址</h2><p id="4c1e" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:【https://www.youtube.com/watch?v=92b-jjBURkw T42】</p><p id="58e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">延伸阅读:</p><ul class=""><li id="bd46" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><a class="ae kw" href="https://superuser.com/a/801107" rel="noopener ugc nofollow" target="_blank">https://superuser.com/a/801107</a></li><li id="c643" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://superuser.com/a/801321" rel="noopener ugc nofollow" target="_blank">https://superuser.com/a/801321</a></li></ul><p id="6bf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">公共IP地址</strong>如今相当昂贵，所以我们可以使一个诡计:购买一个<strong class="jp ir">公共IP地址</strong>并创建一堆<strong class="jp ir">私有IP地址</strong>，它们在内部网络/子网(LAN)中的公共IP地址之后。当然，路由器也有<strong class="jp ir">私有IP </strong>地址，供子网中的机器相互通信。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi pa"><img src="../Images/c506686a06727074e84d2db037a552a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptsjOqBq1eyBzJbcLgaBSA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">公有和私有IP地址示例</figcaption></figure><p id="6294" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了辨别来自外部世界的请求的内部机器，我们给每台机器分配唯一的端口。所以，叫做<strong class="jp ir">端口转发</strong>。引擎盖下使用<a class="ae kw" href="https://medium.com/p/d6f425ceea13#254c" rel="noopener"> <strong class="jp ir"> NAT </strong> </a>。</p><p id="7b01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">管道:<em class="os">路由器公网IP地址+ 8080 </em>从外界调用→ 192.168.x.x:8080(又名内部机)</p><p id="41d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，内部子网中的机器有不同的<strong class="jp ir"> IP地址</strong>。</p><h2 id="24dd" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">5.传输控制协议</h2><p id="6df3" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">也许，你听说过TCP/IP模型，想了解更多。然后给这个酷哥一个手表:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="pb pc l"/></div></figure><h1 id="49fd" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">2.域名服务器(Domain Name Server)</h1><p id="29ed" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:<a class="ae kw" href="https://www.youtube.com/watch?v=tgWx81_NGcg" rel="noopener ugc nofollow" target="_blank">T19】https://www.youtube.com/watch?v=tgWx81_NGcgT21】</a></p><p id="3253" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多阅读:<a class="ae kw" href="https://superuser.com/a/1075081" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://superuser.com/a/1075081</strong></a></p><p id="8f77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> DNS </strong> —域名系统。这是一个系统来寻找我们在浏览器中输入的域名的IP地址。为什么这样做？我们亲爱的机器不能阅读文本并将其转换成数据，所以它们需要一些数字来工作。回想一下OSI模型，我们也不处理文本，而是处理端口、IP、MAC等。</p><p id="dc85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">DNS 作为一个数据库工作(实际上是一个数据库)，但是非常聪明和设计良好。如果不是这样，想象一下处理一个请求需要多长时间。</p><blockquote class="pd pe pf"><p id="4f83" class="jn jo os jp b jq jr js jt ju jv jw jx pg jz ka kb ph kd ke kf pi kh ki kj kk ij bi translated">“要处理数十亿行，你需要避免处理数十亿行”——作者<a class="ku kv ep" href="https://medium.com/u/e4cbe924ccb?source=post_page-----d6f425ceea13--------------------------------" rel="noopener" target="_blank">侯赛因·纳赛尔</a></p></blockquote><p id="f937" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是为什么它被设计成一种非常聪明的方式。</p><p id="179b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个站点链接分为两个部分:</p><ul class=""><li id="ec30" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir">。com/。org </strong>等——顶级域名<br/>——知道了这一点，你就排除了很多结果(也就是说，你寻找<strong class="jp ir">)。org </strong>，因此无需筛选<strong class="jp ir">。net/。com </strong>等)= &gt;快得多</li><li id="4661" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">实际域和子域<br/> -使用它们来寻找<strong class="jp ir"> IP地址</strong></li></ul><p id="028b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">流程是什么样的？</p><p id="2ce5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">重要提示:一起阅读下面的两部分，第一部分更像是图表，第二部分是解释</strong></p><p id="2abd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="os">第一大块</em> ❗️ <em class="os"> : </em></p><p id="70b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ot ou ov ow b">-&gt;</code>表示提出要求</p><ol class=""><li id="5838" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">客户端→解析器(您机器的DNS服务器)→根服务器<br/>根服务器→解析器(TLD服务器的IP)</li><li id="b085" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">解析器→ TLD服务器<br/> TLD服务器→解析器(授权NS的IP)</li><li id="53d7" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">解析器→认证服务器<br/>认证服务器→解析器(被请求服务器的IP)</li><li id="f6cd" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">解析程序→客户端</li></ol><p id="0df5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="os">第二大块</em> ❗️ <em class="os"> : </em></p><ol class=""><li id="1a50" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">你只知道能告诉你顶级域名=&gt; <strong class="jp ir">根服务器</strong><br/>——一共有13个根服务器<br/>——你让他们给你比如说<strong class="jp ir">。com </strong>服务器，<strong class="jp ir">。io </strong> server etc = &gt; <strong class="jp ir">所需服务器的IP地址</strong>—称为<strong class="jp ir"> TLD </strong>(顶级域服务器)<br/>——在这种情况下，客户端使用UDP</li><li id="d33b" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">对给定的<strong class="jp ir"> IP服务器</strong> <br/>的另一个请求——该服务器不会给你所请求的域(即example.com)<br/>的IP——它将对另一个名为<strong class="jp ir"> auth NS </strong>(完整— <strong class="jp ir">权威名称服务器</strong> ) <br/>的服务器IP地址进行回指，也称为响应——这个<strong class="jp ir"> auth NS </strong>将有所请求的服务器的答案</li><li id="6667" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">解析器将结果返回给客户端</li></ol><p id="72ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="os">关于DNS的注意事项:</em></p><ol class=""><li id="72cf" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">如果您为服务器再添加一个IP地址，它将只接触<strong class="jp ir">认证号</strong></li><li id="654d" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">有可能<strong class="jp ir">解析器</strong>已经向特定的IP地址发出请求，并且它位于解析器的缓存中。但它会导致神经毒素中毒</li><li id="70b3" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">DNS中使用的协议— <strong class="jp ir"> UDP <br/> - </strong>因为它是<strong class="jp ir">无状态</strong>，我们需要定义谁是请求<br/>的发起者—生成随机数，称为<strong class="jp ir"> DNS查询id </strong>(又名<strong class="jp ir">事务id </strong>)，并添加到UDP请求(标记请求)<br/>—它将被缓存在<strong class="jp ir">解析器缓存</strong>中</li></ol><p id="727a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="os">生理盐水中毒:</em></p><ol class=""><li id="29fb" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">攻击者将向解析器发送一堆<strong class="jp ir"> UDP请求</strong>，以获取<strong class="jp ir"> DNS查询id </strong></li><li id="1250" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">客户端最终位于攻击者的站点，因为来自DNS的缓存域将指向攻击者指定的站点</li><li id="00f6" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">此外，攻击者需要知道从<strong class="jp ir">解析器</strong>发送的<strong class="jp ir">目的IP </strong>。它通常是随机生成的</li></ol><h1 id="ba3f" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">3.TCP和UDP协议</h1><p id="dda3" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:<a class="ae kw" href="https://www.youtube.com/watch?v=qqRYkcta6IE" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=qqRYkcta6IE</a></p><p id="8bb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，有两种类型的协议使用最广泛:TCP和UDP。它们发生在OSI模型的第4层。</p><p id="c62b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请一起阅读第3部分和第4部分，因为会有很多链接指向另一个 ‼️</p><p id="1dd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> TCP </strong> —传输控制协议。</p><p id="46b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点:</strong></p><ul class=""><li id="9b64" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir">确认:</strong>在消息中添加信息，定义服务器是否收到数据。什么信息？更多关于<a class="ae kw" href="https://medium.com/p/d6f425ceea13#4f67" rel="noopener"> TCP握手</a>的内容</li><li id="e058" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir">保证交付:</strong>如果没有确认，那么它将重新发送信息(要么数据包没有到达，要么它们已损坏)</li><li id="b2ae" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir">基于连接:</strong> <em class="os">客户端-服务器</em>需要在它们之间建立唯一的连接</li><li id="f7fa" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir">拥塞控制:</strong>在能够处理数据时发送数据，否则等待</li><li id="0134" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir">有序数据包:</strong>数据将被分割成无序的数据包。也在<a class="ae kw" href="https://medium.com/p/d6f425ceea13#4f67" rel="noopener"> TCP握手</a>中讨论</li></ul><p id="7d69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缺点:</p><ul class=""><li id="7ad0" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">所有来自专业的东西都是小包</li><li id="3983" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">更多带宽</li><li id="a649" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">比UDP慢</li><li id="c508" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir">有状态:</strong>如果<em class="os">客户端</em>已连接，并且您销毁了<em class="os">服务器</em>——连接关闭。无状态意味着这样的操作不会破坏连接</li><li id="44ce" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir">服务器内存</strong>(易受<strong class="jp ir"> DOS </strong> —拒绝服务攻击):<em class="os">服务器</em>需要为每个连接分配内存= &gt;限制连接数。什么？服务器和连接？阅读<a class="ae kw" href="https://medium.com/p/d6f425ceea13#f42d" rel="noopener">网络服务器章节</a></li></ul><p id="c335" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> UDP </strong> —用户数据报协议</p><p id="deb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点:</strong></p><ul class=""><li id="0188" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">没有确认</li><li id="1cde" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir">没有保证交付:</strong>只有一些校验和来判断数据包是坏还是好</li><li id="c1bf" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir">无连接:</strong>客户端和服务器之间没有物理连接</li><li id="8986" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">无拥塞控制</li><li id="34bd" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">没有有序的数据包</li><li id="2b49" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir">安全性:</strong>不信任连接，因为实际上没有连接</li></ul><p id="deba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点:</strong></p><ul class=""><li id="e748" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">较小的数据包</li><li id="bc7d" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">更少的带宽</li><li id="6373" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">无国籍的</li></ul><p id="c245" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="os">关于TCP和UDP的注意事项:</em></p><ul class=""><li id="21c7" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">在大多数情况下，数据库不能使用<strong class="jp ir"> UDP </strong></li><li id="dbed" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir"> UDP </strong>是可扩展的(因为您可以在没有真实连接和TCP的情况下向服务器发送数据— <strong class="jp ir">有状态的</strong>)</li></ul><h1 id="4f67" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">4.TCP握手</h1><p id="5ade" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:<a class="ae kw" href="https://www.youtube.com/watch?v=bW_BILl7n0Y" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=bW_BILl7n0Y</a></p><p id="acc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在上面讨论了TCP的一般情况。现在我想向您展示实际上是如何在TCP中建立连接的(记住，UDP是无状态的)。回想一下<strong class="jp ir"> TCP </strong>是OSI中的第4层。</p><p id="3e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速概述🌪：</p><ol class=""><li id="c07c" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated"><em class="os">客户端</em>发送请求，例如，通过<code class="fe ot ou ov ow b">CURL GET/</code>。</li><li id="0cf7" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">数据将被分成<strong class="jp ir">个包</strong> <br/> -每个<strong class="jp ir">个包</strong>都有一个<strong class="jp ir"> <em class="os">序列号</em> </strong>以便在它们被分割和网格化后对包进行排序，因为web不能保证它们的严格排序和交付<br/> - <em class="os">服务器</em>在收到每个<strong class="jp ir">包</strong>后对<em class="os">客户端</em>做出响应— <strong class="jp ir">确认</strong>(回忆上一节)。如果没有收到—重新发送。喊出<strong class="jp ir">保证送货上门。</strong></li><li id="e0a9" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">服务器将等待所有<strong class="jp ir">数据包</strong>到达</li></ol><p id="de45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更深入的概述:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi pj"><img src="../Images/094eac5967efa518984cbde8d55da95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lPw61E3iXNT69xE-vdK-hg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">TCP握手示例:前3步</figcaption></figure><p id="8f29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是<em class="os">服务器</em>怎么理解这个序列是以<strong class="jp ir"> x </strong>开始，以<strong class="jp ir"> y </strong>结束？= &gt; <em class="os">服务器</em>和<em class="os">客户端</em>需要就这些<strong class="jp ir">序列号</strong> — <strong class="jp ir">同步</strong>达成一致</p><ol class=""><li id="c8e4" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated"><em class="os">客户端</em>想出了一个<strong class="jp ir">序列</strong>——随机性来保护免受攻击。即这个数字是700</li><li id="71e8" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated"><em class="os">客户端</em>发送<strong class="jp ir"> syn序列号:700 </strong></li><li id="b98b" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated"><em class="os">服务器</em>响应:<br/> - <strong class="jp ir"> syn另一个序列号:即200 <br/> -确认</strong>:<em class="os">客户端</em>的<strong class="jp ir"> syn序列号</strong>+此第一个请求中为1的数据包长度= &gt; 701</li><li id="9ff9" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">现在<em class="os">客户端</em>发送<strong class="jp ir">确认</strong> : <em class="os">服务器</em> <strong class="jp ir"> syn序列号</strong> +数据包<strong class="jp ir">的长度</strong>，也是1，因为它是来自<em class="os">服务器= &gt; 201 </em>的第一个请求</li></ol><p id="01db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">重要提示:</strong>第3步由2个请求组成1个请求。它被称为<strong class="jp ir"> syn/ack </strong>，所以结果中有一个<strong class="jp ir">包</strong>。</p><p id="d591" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;在所有这些之后:第一个真正的GET请求(或者POST，你得到了它)</p><ol class=""><li id="ec6b" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">GET(数据包长度为10)和<strong class="jp ir"> syn序列号</strong> 701</li><li id="66f5" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">服务器发送回一个确认:701 +数据包的长度，在我们的例子中是10</li></ol><h1 id="1707" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">5.超文本传送协议</h1><p id="01ae" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频1:<a class="ae kw" href="https://www.youtube.com/watch?v=0OrmKCB0UrQ" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=0OrmKCB0UrQ</strong></a></p><p id="246d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视频2(关于HTTP 2的模式):<a class="ae kw" href="https://www.youtube.com/watch?v=fVKPrDrEwTI&amp;list=WL&amp;index=10" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=fVKPrDrEwTI&amp;list = WL&amp;index = 10</strong></a></p><h2 id="a987" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">1.一般关于HTTP:</h2><p id="8955" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated"><strong class="jp ir"> HTTP </strong>代表超文本传输协议:</p><ul class=""><li id="562e" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir"> HTTP </strong>请求属性:URL、方法类型、头(内容的种类、cookies、主机)、主体(对于某些方法类型)</li><li id="5417" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir"> HTTP </strong>响应:状态码、标题、正文</li></ul><p id="a1ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">略谈<strong class="jp ir"> HTTP </strong>聚会💨<strong class="jp ir"> : </strong></p><ul class=""><li id="9d9a" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><em class="os">客户端</em>(例如Java应用)发出请求</li><li id="d565" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><em class="os"> HTTP服务器</em>(需要知道如何处理HTTP请求的服务器)接受请求</li><li id="ea4d" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">HTTP是OSI模型的第7层协议</li><li id="3d6b" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir"> TCP </strong>是一种为我们传输字符串(数据)的工具，也就是<strong class="jp ir"> HTTP </strong>，因为TCP是第4层，HTTP是第7层</li></ul><p id="1627" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简要介绍一下<strong class="jp ir"> HTTP </strong>中的数据交换:</p><ol class=""><li id="7dac" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">打开客户端与服务器的连接:<strong class="jp ir"> GET/some-step.com </strong>。回忆<a class="ae kw" href="https://medium.com/p/d6f425ceea13#4f67" rel="noopener"> <strong class="jp ir"> TCP握手</strong> </a></li><li id="6c36" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">该字符串将被转换为101010位</li><li id="6299" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated"><em class="os">服务器</em>处理请求并通过<strong class="jp ir"> TCP </strong>连接发送响应:<strong class="jp ir">头</strong>、<strong class="jp ir">。html </strong>文件。<br/> -当<strong class="jp ir"> TCP </strong>将数据分成<strong class="jp ir">个数据包</strong>时，可能会有多个数据包。回忆关于<a class="ae kw" href="https://medium.com/p/d6f425ceea13#ba3f" rel="noopener">的章节<strong class="jp ir">TCP</strong>T44】</a></li><li id="1f96" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">如果没有更多的请求，请关闭连接</li></ol><p id="cb9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么<strong class="jp ir"> HTTPS </strong>呢？是怎么做到的？哦，孩子，这是一个相当沉重的东西，因此它是一个单独的部分，将在下面。但是如果你不耐烦，那么访问关于<a class="ae kw" href="https://medium.com/p/d6f425ceea13#891a" rel="noopener"> TLS </a>的部分</p><p id="0c1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="os"> HTTP版本:</em></p><ul class=""><li id="46fe" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir"> HTTP 1.0 </strong>:</li></ul><p id="7728" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="os">请求/响应如何工作:</em> <br/> -请求:<strong class="jp ir"> GET /index.html. <br/> - </strong>响应<br/> -连接关闭。</p><p id="0b8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;每次请求/响应后，我们都会关闭连接。<br/>但是想象一下在前面步骤中发送的<strong class="jp ir">index.html</strong>页面中有一个图像。你再做一个请求来得到它:<strong class="jp ir"> GET /image1.jpg </strong> = &gt;记住<strong class="jp ir"> TCP </strong>默认情况下启动很慢，这里我们有这么多打开/关闭。</p><ul class=""><li id="b596" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir"> HTTP 1.1 </strong></li></ul><p id="8b54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="os">和HTTP 1.0相比有什么区别:</em><br/>——它发明了<strong class="jp ir"> keep-alive头</strong>，这个头从<em class="os">客户端</em>发送到<em class="os">服务器</em> = &gt;我们不会在每个请求/响应周期后关闭连接，而是保持连接打开。</p><p id="96b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="os">请求/响应如何工作:</em> <br/> -请求:<strong class="jp ir"> GET /index.html <br/> - </strong>响应<br/> - <strong class="jp ir">保持连接打开<br/> - </strong>最终完成后关闭连接</p><p id="2047" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="os">HTTP 1.1中的更多内容:</em> <br/> -还引入了缓存、<a class="ae kw" href="https://medium.com/p/d6f425ceea13#00b2" rel="noopener"> <strong class="jp ir">电子标签</strong> </a> <strong class="jp ir"> <br/> -带分块传输的流</strong>:一旦<em class="os"> html页面</em>的一部分准备好，就开始分块发送<strong class="jp ir">页面</strong>:第1部分、第2部分等<br/> -现代浏览器允许每个请求6个TCP连接。为什么这么多？在对页面的一个请求中，它实际上有许多其他请求来检索页面的数据。看看一个简单的页面加载是什么样子的:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi pk"><img src="../Images/8aaaf844b652c5bb0197ee4ae9f2b235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cvldtf1X59L9tYTcv1M7fA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">示例一个请求如何触发页面上的多个请求</figcaption></figure><ul class=""><li id="5401" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir"> HTTP 2 </strong>(又名<strong class="jp ir"> SPDY </strong>)</li></ul><p id="3545" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点:</strong></p><ul class=""><li id="bd2c" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir">复用:</strong>多个请求被挤入一个通道= &gt;结果一个请求(但是在<strong class="jp ir"> TCP </strong>中照常有很多<strong class="jp ir">包</strong>)。即，您发出6个GET请求来获取不同的资源。每个HTTP <strong class="jp ir">数据包</strong>将被标记为<strong class="jp ir">流id </strong>(因为一个请求有多个<strong class="jp ir">数据包</strong>)，它允许<em class="os">服务器</em>将响应映射回特定请求。和<em class="os">客户端</em>来理解哪个响应映射到初始请求。</li></ul><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi pl"><img src="../Images/720e13cdbda1690072bb94b84e2b36aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsDsO9FEH_6O1eZ86qx-lA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">多路复用示例</figcaption></figure><ul class=""><li id="bd8f" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir">压缩:</strong>协议缓冲区(又名二进制格式)允许这样做。由于<strong class="jp ir">流id </strong>在<strong class="jp ir"> <em class="os">复用</em> </strong>中，我们甚至可以压缩<strong class="jp ir">头</strong>(在HTTP 1.1中无法做到)</li><li id="f225" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir">服务器推送</strong>(默认禁用)——你不必等待响应，因为服务器会这么做。<br/> <em class="os">客户端</em>要求<strong class="jp ir">index.html</strong>:得到index.html。如果<em class="os">服务器</em>配置正确，它不仅可以推送该文件，还可以推送<code class="fe ot ou ov ow b">main.js</code>、<code class="fe ot ou ov ow b"> main.css</code>等。尽管如此，<em class="os">客户端</em>必须支持<strong class="jp ir"> HTTP 2 </strong>来完成这个动作。</li><li id="e905" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">默认安全:<strong class="jp ir"> HTTPS </strong></li><li id="52dd" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">在<a class="ae kw" href="https://medium.com/p/d6f425ceea13#891a" rel="noopener"> <strong class="jp ir"> TLS </strong> </a>期间的协议协商由于一些老服务器不支持<strong class="jp ir">HTTP 2.0</strong>(NPN/ALPN)<br/>——这个东西允许<em class="os">服务器</em>在<a class="ae kw" href="https://medium.com/p/d6f425ceea13#891a" rel="noopener"> <strong class="jp ir"> TLS握手</strong> </a> = &gt;期间告诉<em class="os">客户端</em>它支持<strong class="jp ir"> HTTP 2 </strong>不需要另外请求升级到<strong class="jp ir"> HTTP 2 </strong></li></ul><p id="8be1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点:</strong></p><ul class=""><li id="fd7b" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><em class="os">服务器</em>推送可能被滥用:如果<em class="os">客户端</em>不需要额外数据，并且<em class="os">服务器</em>配置不正确= &gt;额外带宽</li><li id="4c32" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">在混合模式下可能会慢一些(后端是<strong class="jp ir"> HTTP 2 </strong>，但负载平衡器是<strong class="jp ir"> HTTP 1 </strong>，反之亦然)。快速解决方案是使用<em class="os">第4层HTTP代理</em></li></ul><p id="2449" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哇，甚至HTTP 3也存在，而且它实际上是通过UDP，而不是TCP。是啊，太疯狂了。就几个词。</p><ul class=""><li id="1b46" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir"> HTTP 3(又名HTTP 2 over QUIC): </strong> <br/> -用QUIC(带拥塞控制的UDP)替换TCP<br/>-所有HTTP 2特性</li></ul><h2 id="b61e" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">2.HTTP中的POST与GET请求</h2><p id="1c99" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:<a class="ae kw" href="https://www.youtube.com/watch?v=K8HJ6DN23zI" rel="noopener ugc nofollow" target="_blank">T38】https://www.youtube.com/watch?v=K8HJ6DN23zIT40】</a></p><p id="efe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对HTTP动词一无所知，那就去看看MDN:<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods</a></p><p id="5612" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果您想总结GET和POST之间的区别:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi pm"><img src="../Images/12fc286e44733c753d8f46a94595634a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3l9P-M11REcs8E_SVr51g.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">POST与GET请求</figcaption></figure><h1 id="00b2" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">6.使用电子标签的HTTP缓存</h1><p id="eded" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:<a class="ae kw" href="https://www.youtube.com/watch?v=TgZnpp5wJWU" rel="noopener ugc nofollow" target="_blank">T44】https://www.youtube.com/watch?v=TgZnpp5wJWUT46】</a></p><p id="5f85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">电子标签</strong> —验证网络缓存以提高性能的机制。</p><p id="16ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是如何工作的🧐:</p><ol class=""><li id="016c" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated"><em class="os">客户端</em>发出请求:<strong class="jp ir">获取/用户/鲍勃</strong></li><li id="624e" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated"><a class="ae kw" href="https://medium.com/p/d6f425ceea13#f42d" rel="noopener"> <em class="os">网络服务器</em> </a> <em class="os"> </em>在<strong class="jp ir">电子标签</strong>出现的地方用JSON响应</li></ol><ul class=""><li id="af81" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir">电子标签</strong>:“10c 32–434g-creg”(只是一个例子)</li><li id="dea9" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><em class="os">客户端</em>责任(无论是我们编写的<strong class="jp ir">浏览器</strong>还是<strong class="jp ir"> HTTP </strong>客户端)来坚持它</li></ul><p id="5c35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.下次我们请求相同的<em class="os">端点</em>时，添加<strong class="jp ir">头</strong><strong class="jp ir">【If-None-Match:" 10c 32–434g-creg "】<br/>-示例:GET /user/bob </strong> +头<strong class="jp ir">【If-None-Match:" 10 vfv-34cd-23f "】</strong></p><p id="adc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.如果文件未更改，服务器将以响应代码:<strong class="jp ir"> 304未修改</strong>进行响应</p><p id="2a63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">优点:</strong></p><ul class=""><li id="4f12" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">快速响应</li><li id="18bd" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">更少的带宽</li><li id="2a35" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">数据库的一致性:如果多个事务不修改同一个资源，可以并行执行</li></ul><p id="1458" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点:</strong></p><ul class=""><li id="3fe5" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir">电子标签</strong>由每台服务器生成，因此，如果您有:</li></ul><pre class="mh mi mj mk gt pn ow po pp aw pq bi"><span id="6740" class="kx ky iq ow b gy pr ps l pt pu">client — load balancer<br/>          /          \<br/>      server 1      server 2</span></pre><p id="ffc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">=&gt; <em class="os">客户端</em>从<strong class="jp ir"> <em class="os">服务器1 </em> </strong>获取<strong class="jp ir">电子标签</strong>。由于<em class="os">负载平衡器</em>，具有相同<strong class="jp ir">端点</strong>和具有<strong class="jp ir"> If-None-Match </strong>的下一个请求将被重定向到另一个<em class="os">服务器</em>。而<strong class="jp ir">服务器2 </strong>没有这个<strong class="jp ir">电子标签</strong> = &gt;它会自己生成。<br/>通过将服务器配置为跨服务器具有相似的电子标签，这是可以解决的</p><ul class=""><li id="45a0" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir">电子标签</strong>允许<em class="os">服务器</em>通过总是发送未修改的<strong class="jp ir">304</strong>来跟踪<em class="os">客户端</em>，因为<strong class="jp ir">电子标签</strong>存在于浏览器中</li></ul><h1 id="891a" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">7.坦克激光瞄准镜（Tank Laser-Sight的缩写）🔑</h1><p id="c25c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频1:<strong class="jp ir"/><a class="ae kw" href="https://www.youtube.com/watch?v=Z3FwixsBE94" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=Z3FwixsBE94</strong></a></p><p id="40e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视频二:<a class="ae kw" href="https://www.youtube.com/watch?v=AlE5X1NlHgg" rel="noopener ugc nofollow" target="_blank">T55】https://www.youtube.com/watch?v=AlE5X1NlHggT57】</a></p><p id="883f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视频三:<a class="ae kw" href="https://www.youtube.com/watch?v=ntytZy3i-Jo" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=ntytZy3i-Jo</strong></a></p><p id="90a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更多可供阅读的资源:</p><ul class=""><li id="bcb6" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">甲骨文网站:<a class="ae kw" href="https://docs.oracle.com/cd/E19509-01/820-3503/ggbgc/index.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/CD/e 19509-01/820-3503/gg bgc/index . html</a></li></ul><h2 id="ff3b" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">对称与非对称加密</h2><p id="2427" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">说白了，如果我们使用对称加密，那么客户端和服务器将使用相同的密钥→不安全，因为有人可以拦截密钥。</p><p id="a309" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，在非对称加密中:公钥用于加密消息，私钥用于解密消息。</p><p id="16b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在TLS中，我们两者都有。阅读下面的<a class="ku kv ep" href="https://medium.com/u/d53dd768d047?source=post_page-----d6f425ceea13--------------------------------" rel="noopener" target="_blank">堆栈溢出</a>帖子:</p><div class="oc od gp gr oe of"><a href="https://stackoverflow.com/a/37791162/16543524" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">HTTPS使用不对称还是对称加密？</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">感谢贡献一个堆栈溢出的答案！请务必回答问题。提供详细信息并分享…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">stackoverflow.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa mq of"/></div></div></a></div><p id="29d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">看看我在GitHub上关于TLS的笔记:</strong></p><div class="oc od gp gr oe of"><a href="https://github.com/SleeplessChallenger/SystemsExpert/blob/main/22%29%20Security%20And%20HTTPS.md" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">主服务器上的安全和HTTPS.md</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">当客户端通过HTTP与服务器交互时，我们假设这个连接是私有的，但这是不正确的。有人…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="pv l"><div class="qb l px py pz pv qa mq of"/></div></div></a></div><p id="fa55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速而简短:</p><p id="1891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> HTTP(端口80): </strong> <br/> 1。断开连接<br/> 2。发送请求(即GET/) <br/> 3。<strong class="jp ir"> Headers + html </strong>页面返回<br/> 4。如果需要则关闭否则保持活动状态<br/> <strong class="jp ir"> HTTPS(端口443): </strong> <br/> 1。打开连接<br/> 2。握手(在GitHub上看我的笔记)<br/> 3。发送加密请求(即GET/)(发生在OSI第6层)<br/> 4。服务器解密并处理<br/> 5。发送响应<br/> 6。需要时关闭，否则保持活动状态</p><p id="4369" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前使用的TLS主要有两个版本:1.2和1.3。在安全性方面，前者比后者更差。</p><h2 id="013d" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak"> 1。TLS 1.2 </strong></h2><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qc"><img src="../Images/246b603d8c44b5693fe935131a708647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aF6wni-iFrpV-s4PZj0z9Q.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">TLS 1.2流程示例</figcaption></figure><ol class=""><li id="6a59" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated"><em class="os">客户您好</em>来自客户</li><li id="4b32" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated"><em class="os">服务器hello </em>从服务器发送<em class="os">证书:信息+服务器公钥</em></li></ol><ul class=""><li id="cf19" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><em class="os">客户端</em>检查<em class="os">证书</em>(下面将进行解释)</li></ul><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qd"><img src="../Images/74f9d113ead22d93c204994cb90f4222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m33BaDW91Sy_x180dv3jZA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">Google.com服务器<strong class="bd kz">证书</strong>示例</figcaption></figure><ul class=""><li id="c141" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><em class="os">客户端</em>将使用此<em class="os">公钥</em>对客户端生成的<em class="os">对称密钥</em>进行加密(生成对称密钥的预主密钥)</li><li id="3cd0" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">从上面用<em class="os">公钥</em>将密钥发送给锁定的服务器<strong class="jp ir"/></li><li id="d352" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">只有服务器的<em class="os">私钥</em>才能解密服务器的<em class="os">公钥</em></li></ul><p id="a0d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.服务器用自己的私钥<em class="os">解密来自<em class="os">客户端</em>的密钥；现在它也有了<em class="os">对称密钥</em></em></p><p id="e103" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.可以开始安全通信(服务器向客户端发送类似OK的消息)</p><h2 id="46c3" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak"> 2。TLS 1.3 </strong></h2><h2 id="e48d" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">TLS 1.2的问题:</h2><ul class=""><li id="8946" class="lq lr iq jp b jq ls ju lt jy lu kc lv kg lw kk lx ly lz ma bi translated">我们加密对称密钥并通过网络发送。如果有人得到服务器的<em class="os">私钥</em>——侵犯隐私</li><li id="2748" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">高延迟:在<em class="os">客户端</em>和<em class="os">服务器</em>之间需要大量的来回通信来建立连接</li></ul><p id="e97a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">TLS 1.3的Diffie-Hellman:</strong></p><p id="ba48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TLDR: 发送关于密钥的信息，但不是密钥</p><ol class=""><li id="6563" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">客户端的私钥</li><li id="27fa" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">客户端的公钥(但这取决于具体情况)</li><li id="7ccc" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">客户端的私钥</li></ol><p id="f9a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;所有3个的合并产生私有的对称密钥<strong class="jp ir"/></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qc"><img src="../Images/1829fa07b7e37473a985d66665d2ca5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QrajVFod55LqW0gsx20D3A.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">Diffie Hellman密钥生成</figcaption></figure><p id="b5a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1和2:公开/不可破解—好的</p><p id="5880" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2和3:公开/不可破解—好的</p><p id="2b29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> TLS 1.3流程:</strong></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qc"><img src="../Images/5d0ddbe823afe7810ee19673ff9c6372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvMAqGYisBsL2yu88h6eew.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">TLS 1.3流程示例</figcaption></figure><ol class=""><li id="3c2f" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated"><em class="os">客户端</em>向<em class="os">服务器</em> : <strong class="jp ir">公钥</strong>和<strong class="jp ir">公钥+私钥</strong> = &gt;的合并2部分被发送<br/> - <em class="os">客户端</em>拥有自身的<strong class="jp ir">私钥</strong></li><li id="4749" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated"><em class="os">服务器</em>为自己<br/>生成<strong class="jp ir">私钥</strong>-它接受来自<em class="os">客户端</em>的2个密钥的合并:客户端的<strong class="jp ir">私钥</strong>和客户端<br/>的<strong class="jp ir">公钥</strong>-添加自己的<em class="os">私钥</em> → <strong class="jp ir">对称密钥</strong></li><li id="307e" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated"><em class="os">服务器</em>发送客户端<strong class="jp ir">公钥</strong>和服务器<strong class="jp ir">私钥</strong>的合并。<em class="os">客户端</em>将其与自身的<em class="os">私有</em>=&gt;<strong class="jp ir">对称密钥</strong>合并</li><li id="a9f0" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">现在<em class="os">客户端</em>和<em class="os">服务器</em>可以通过<strong class="jp ir">对称密钥</strong>相互通信</li></ol><p id="8047" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;比TLS 1.2快得多，因为只有两次往返</p><h2 id="8122" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">3.HTTPS域名系统</h2><p id="ba7d" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频1:<a class="ae kw" href="https://www.youtube.com/watch?v=SudCPE1Cn6U" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=SudCPE1Cn6U</strong></a></p><p id="3ca0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视频二:<a class="ae kw" href="https://www.youtube.com/watch?v=flnw78uhFkE" rel="noopener ugc nofollow" target="_blank">T52】https://www.youtube.com/watch?v=flnw78uhFkET54】</a></p><p id="2080" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">延伸阅读:</p><ul class=""><li id="8968" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><a class="ae kw" href="https://www.cloudflare.com/learning/ssl/what-is-encrypted-sni/" rel="noopener ugc nofollow" target="_blank">https://www . cloud flare . com/learning/SSL/what-is-encrypted-sni/</a></li><li id="51a0" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://blog.cloudflare.com/encrypted-sni/" rel="noopener ugc nofollow" target="_blank">https://blog.cloudflare.com/encrypted-sni/</a></li></ul><blockquote class="pd pe pf"><p id="f57f" class="jn jo os jp b jq jr js jt ju jv jw jx pg jz ka kb ph kd ke kf pi kh ki kj kk ij bi translated">ISP —互联网服务提供商</p></blockquote><p id="3457" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果客户使用普通的HTTP协议——互联网服务提供商和政府可以看到一切。</p><p id="2084" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在example.com连接政府只能看到域名(ISP可以):<a class="ae kw" href="http://example.com" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a>。他们可以给你伪造的IP地址或者屏蔽域名，因为他们可以筛选域名系统。</p><p id="192e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> DoH </strong>很难实现，因为您需要在以下设备之间建立安全连接(又称TLS ):</p><ul class=""><li id="acad" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><em class="os"> DNS解析器</em>和<em class="os">客户端</em></li><li id="e4a2" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><em class="os">客户端</em>和<em class="os">服务器</em></li></ul><p id="90f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">流程:</p><ol class=""><li id="fcdd" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">与DNS提供商合作(如Cloudfare)</li><li id="d29e" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">建立TCP连接</li><li id="363c" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">建立TLS</li><li id="9093" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">提出要求</li></ol><p id="3d84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">=&gt; ISP甚至不知道您已经发出了DNS请求</p><p id="6288" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是<a class="ae kw" href="https://medium.com/p/d6f425ceea13#f252" rel="noopener"><strong class="jp ir">【SNI】</strong></a>仍然是ISP屏蔽你的有效途径= &gt; <a class="ae kw" href="https://medium.com/p/d6f425ceea13#f252" rel="noopener"> <strong class="jp ir"> ESNI </strong> </a>是一条路要走</p><h1 id="27f5" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">8.<strong class="ak">证书和证书颁发机构</strong>📝</h1><p id="1b0a" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频1:<a class="ae kw" href="https://www.youtube.com/watch?v=x_I6Qc35PuQ" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=x_I6Qc35PuQ</strong></a></p><p id="0d38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视频二:<a class="ae kw" href="https://www.youtube.com/watch?v=r1nJT63BFQ0" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=r1nJT63BFQ0</strong></a></p><p id="eab5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当<em class="os">客户端hello </em>从<em class="os">客户端</em>到<em class="os">服务器</em>时，可以被拦截。这就是众所周知的中间人攻击，也就是MITM。它发生在OSI模型的第4层。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qe"><img src="../Images/b8dac0b8a98e322cd414951810bb94cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SAw1TmuwHW2D2F-BhiPf_Q.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">MITM的例子</figcaption></figure><p id="b6f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，反派用谷歌的<strong class="jp ir"> IP地址</strong>来回应(代表谷歌)。现在，这个响应又多了一个<strong class="jp ir"> TLS params </strong>(用来冒充Google)。<br/> <strong class="jp ir"> <em class="os">而且，</em> </strong>反派会有双面交际:</p><ul class=""><li id="b35a" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">使用谷歌(使用键)</li><li id="5d5e" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">使用<em class="os">客户端</em>(使用另一个键)</li></ul><p id="5dfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;所以，它充当了隐形代理</p><p id="0e7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要一些第三方来验证服务器是合法的。它被称为<strong class="jp ir">认证机构，又名CA。</strong></p><p id="2751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即谷歌，要启动<em class="os">服务器</em>，需要某种<strong class="jp ir">证书</strong>。</p><ol class=""><li id="1d6a" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">它说:“这是我的<em class="os">公钥</em>和我的信息。给我一个<strong class="jp ir">证书</strong>。”</li><li id="1402" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated"><strong class="jp ir"> CA </strong>获取这些信息，用它的<em class="os">私钥</em>加密(也就是签名)并反馈给Google ( <em class="os">服务器</em>)</li><li id="5139" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated"><strong class="jp ir">用服务器的<em class="os">公钥</em>签署证书</strong>。</li></ol><p id="5bf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续之前，请阅读上面关于<a class="ae kw" href="https://medium.com/p/d6f425ceea13#891a" rel="noopener"> <strong class="jp ir"> TLS </strong> </a>的章节</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qd"><img src="../Images/af3da056042ecf9ef5cbef674248c418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rvzBB1vLvSkuGB2TqQuNg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><strong class="bd kz"> CA </strong>证书示例</figcaption></figure><p id="946e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.<em class="os">客户端</em>接收到<em class="os">服务器hello </em>带<strong class="jp ir">证书</strong>的<em class="os">公钥</em>后，需要验证。<br/> 2。它需要服务器<br/> 3的<em class="os">公钥</em>。查看<em class="os">证书</em>中的<strong class="jp ir"> CA </strong>，转到CA【CA证书】4的<strong class="jp ir">证书</strong>。使用<strong class="jp ir"> CA </strong>的<em class="os">公钥</em>，加密<em class="os">服务器</em>的<em class="os">公钥</em>:</p><ul class=""><li id="dc61" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">查看它是否与初始的<em class="os">服务器证书</em>匹配</li><li id="0005" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">另一种方法:取<strong class="jp ir"> CA </strong>的<em class="os">公钥</em>，解密服务器的证书，看服务器的<em class="os">公钥</em>是否与<em class="os">服务器</em>给出的相匹配</li><li id="93dc" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">与<strong class="jp ir">根证书</strong>的过程相同，根证书在<strong class="jp ir"> CA证书</strong>之后。实际上，<strong class="jp ir">根证书</strong>安装在我们的机器上。</li></ul><p id="4f0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么上面有<strong class="jp ir"> CA </strong>的过程甚至是合格的:没有人能伪造签名，因为没有人有<strong class="jp ir"> CA </strong>的<em class="os">私钥</em>。</p><h1 id="f252" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">9.🗝</h1><p id="a837" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated"><strong class="jp ir"> SNI </strong> —服务器名称指示</p><p id="0fc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视频1:<a class="ae kw" href="https://www.youtube.com/watch?v=t0zlO5-NWFU" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=t0zlO5-NWFU</strong></a></p><p id="1550" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视频二:<a class="ae kw" href="https://www.youtube.com/watch?v=manTiXESYG0" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=manTiXESYG0</strong></a></p><p id="44d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> SNI </strong>是一个<strong class="jp ir"> TLS扩展</strong>，它允许<em class="os">客户端</em>在<strong class="jp ir"> TLS握手</strong> = &gt;期间指定它想要连接哪个<em class="os">主机</em>多个网站/域被托管在单个<em class="os">公共</em> <strong class="jp ir"> IP地址</strong>中。<a class="ae kw" href="https://medium.com/p/d6f425ceea13#acb4" rel="noopener">回忆关于公共/私有IP地址的章节</a>。</p><p id="6aba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="os">为什么是SNI: </em></p><ul class=""><li id="43e2" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir">公共IP </strong>昂贵:多个网站合并成一个<em class="os">公共IP地址</em>:<br/>——使<strong class="jp ir"> TCP </strong>与<em class="os">服务器</em>的<em class="os">公共IP地址</em>连接</li><li id="e810" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir"><em class="os"><strong class="jp ir">HTTP 1.1</strong>中的</em> </strong>主机头被引入，现在你可以指定你想要连接的主机。这是一个普通的标题。</li></ul><p id="d755" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;不安全。我们需要HTTPS。但是在<strong class="jp ir"> TLS </strong>期间我们没有任何信息。</p><p id="fc46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">流程:</p><ol class=""><li id="a981" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated"><strong class="jp ir">下面未加密</strong>又名普通HTTP: <br/> -首先我们发送请求，即<strong class="jp ir">GET/a.com<br/>-</strong>在<strong class="jp ir"> DNS </strong>中我们找到服务器的<em class="os">IP</em>+我们也发送<em class="os">头:{HOST — site domain} </em>。<br/>-然后我们建立<strong class="jp ir"> TCP </strong>。我们路由到<em class="os">服务器</em>。<br/> -想象一个<em class="os"> IP地址</em>有多个域:1.2.3.4/a.com; 1.2.3.4/b.com.，因此<em class="os">报头</em>将导航我们到单个公共<em class="os"> IP地址</em>中的期望域。</li><li id="0056" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated"><strong class="jp ir">加密</strong>又名HTTPS: <br/> -建立TLS(看上面这个)<br/> - <strong class="jp ir">但是:</strong>不是简单的<em class="os">客户端你好</em>，而是<em class="os">客户端你好</em> +那个<em class="os">公共IP地址</em>内的特定网站。即TLS + SNI(a.com) <br/> - <em class="os">服务器</em>将从<strong class="jp ir"> SNI </strong>发回<em class="os">a.com</em>的<strong class="jp ir">证书</strong>。如果我们指定b.com→b.com<em class="os">的证书</em>。<a class="ae kw" href="https://medium.com/@SleeplessChallenger/d6f425ceea13#891a" rel="noopener"><strong class="jp ir">TLS 1.3</strong></a><strong class="jp ir"/>东西照常，但是有了那个特别的<em class="os">服务器</em>。<br/> - <em class="os">客户端</em>除了SNI会告诉哪个<strong class="jp ir">加密</strong>它不支持</li></ol><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qf"><img src="../Images/982443289201e251a68070a2c1bbff8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtV1Vo3XfHo6Wmn9Ccf0pg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">HTTP/HTTPS进程中的SNI</figcaption></figure><p id="e4a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">SNI问题:</strong></p><ul class=""><li id="fad0" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir"> SNI </strong>以明文发送主机名</li><li id="7915" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">没有隐私(大家可以看看<em class="os">客户端您好</em>)</li></ul><p id="2027" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">遇见<strong class="jp ir"> ESNI: </strong></p><ul class=""><li id="5656" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">加密<em class="os">客户端你好</em></li><li id="3c7e" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">从<strong class="jp ir"> DNS </strong>接收<em class="os">服务器</em>的<em class="os">公钥</em>。<em class="os">客户端你好</em>用它加密</li><li id="9377" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir"> ESNI </strong>必须通过<strong class="jp ir"> DoH/DoT </strong>完成，因为对<strong class="jp ir"> DNS </strong>的请求是未加密的——UDP</li></ul><h1 id="f42d" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">10.Web服务器和应用程序的状态</h1><h2 id="aba1" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">1.网络服务器🗃</h2><p id="5eea" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:<a class="ae kw" href="https://www.youtube.com/watch?v=JhpUch6lWMw" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=JhpUch6lWMw</strong></a></p><p id="d97e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么是<em class="os">网络服务器</em>:</p><ul class=""><li id="4afa" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">提供网页内容的软件:html页面、图像、音频、视频等。由知道如何处理特定内容的<em class="os">客户端</em>使用</li><li id="f83d" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">使用HTTP协议— <strong class="jp ir">第7层</strong></li><li id="46e8" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">有2种类型的内容:<br/> - <em class="os">静态内容</em> : html、js代码、pdf、css <br/> - <em class="os">动态内容</em>:博客帖子—查询到每个人都有不同内容的数据库。内容取决于很多因素:地点、用户等</li><li id="ac5d" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">用于托管网页、博客、构建API</li></ul><p id="258b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="os">网络服务器如何工作:</em></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qg"><img src="../Images/3901f788243a0e76fe4e5c2d4b251ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lh2Z61UVv1x3b2IYvK0jMg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">客户端-服务器通信</figcaption></figure><ul class=""><li id="f7e2" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><em class="os">客户端</em>，例如在<em class="os">公共IP</em>44.1.1.1上，发出请求:<strong class="jp ir"> GET /index.html </strong>。</li><li id="4e47" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><em class="os">服务器</em>，例如具有域和端口example.com:80，使用<em class="os"> html页面</em>和<em class="os">标题</em>做出响应</li><li id="91d2" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">由于<strong class="jp ir"> TCP </strong>，<em class="os">服务器</em>在内存中为这个<em class="os">连接/客户端</em> : <strong class="jp ir"> TCP套接字</strong>保留位置</li><li id="db2a" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">如果另一个<em class="os">客户端</em>发出请求:为这个<em class="os">客户端</em>建立新的<strong class="jp ir"> TCP连接</strong>(现在有2个连接)并且<em class="os">服务器</em>为这个第二个<em class="os">客户端</em>保留第二个<strong class="jp ir"> TCP套接字</strong>。</li><li id="22db" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">在阻塞单线程<em class="os">服务器</em>时，它一次只处理一个TCP套接字</li></ul><h2 id="fa80" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">2.有状态与无状态应用程序</h2><p id="ac99" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:<a class="ae kw" href="https://www.youtube.com/watch?v=nFPzI_Qg3FU&amp;list=WL&amp;index=16" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=nFPzI_Qg3FU&amp;榜单=WL &amp;指数=16 </strong> </a></p><p id="286b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有状态:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qh"><img src="../Images/1c0f0d05dd9e912281835545056ed74f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_4zzMYdbXuuA6to_IIXNQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">有状态应用程序</figcaption></figure><ol class=""><li id="d65f" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated"><em class="os">客户端</em>发送登录请求</li><li id="6673" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated"><em class="os">服务器</em>在数据库的帮助下认证用户，并为该用户交换标志</li><li id="97ef" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">但是，如果我们有<strong class="jp ir"> LB </strong>并且用户的下一个调用，即查看他的简档，将被重定向到第二个服务器，该怎么办呢？= &gt; <strong class="jp ir">失败</strong></li></ol><p id="acbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;所以，当我们有一台机器时，<strong class="jp ir">有状态的</strong>是没问题的。它节省了一些对数据库的调用，因为你不需要进行额外的调用，只需要在服务器端保存一些数据。但是你不能扩展</p><p id="3854" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无状态:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qi"><img src="../Images/7073c33cc17b2206c3fa23bd23b452e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G5oJDUsDpwzUEPuA6Io3nA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">无状态应用程序</figcaption></figure><ol class=""><li id="6465" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated"><em class="os">客户端</em>发送登录请求</li><li id="8c22" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated"><strong class="jp ir"> LB </strong>认证并使用<strong class="jp ir">令牌</strong>响应用户</li><li id="b4ac" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">下次<em class="os">客户端</em>将发出请求时，他需要将<strong class="jp ir">令牌</strong>添加到调用中</li><li id="52c0" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated"><strong class="jp ir"> LB </strong> → <strong class="jp ir">服务器</strong>，其中<em class="os">服务器</em>查询数据库以检查<strong class="jp ir">令牌</strong>是否有效<br/>——一般来说，<strong class="jp ir">令牌</strong>有到期日期，而<em class="os">客户端</em>必须获取新的<br/> - <strong class="jp ir">无状态</strong>——在后端比<strong class="jp ir">有状态</strong>慢，但<strong class="jp ir">更具可伸缩性。例如休息就是一个例子</strong></li></ol><h1 id="b6e7" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">11.克-奥二氏分级量表</h1><p id="bc97" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:<a class="ae kw" href="https://www.youtube.com/watch?v=Ka8vG5miErk&amp;list=WL&amp;index=15" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=Ka8vG5miErk&amp;榜单=WL &amp;指数=15 </strong> </a></p><p id="0ed0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，CORS是关闭的。所以，我们来看看CORS是否开启</p><p id="808a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">延伸阅读:</p><ul class=""><li id="8b86" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://developer . Mozilla . org/en-US/docs/Glossary/Preflight _ request</strong></a></li><li id="36b3" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://stackoverflow.com/a/29954326/16543524" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://stackoverflow.com/a/29954326/16543524</strong></a></li><li id="2ccc" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><a class="ae kw" href="https://stackoverflow.com/a/35850184/16543524" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/35850184/16543524<strong class="jp ir">T4</strong></a></li></ul><p id="f85c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> CORS </strong> —跨产地资源共享。</p><p id="428c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> CORS </strong> —提供配置以配置对共享资源的访问的机制。<strong class="jp ir"> CORS </strong>适用于当<em class="os">网页</em>向另一个<em class="os">服务器</em>而不是其<em class="os">源服务器</em>发出请求时，这可能意味着<strong class="jp ir">域</strong>、<strong class="jp ir">协议</strong>或<strong class="jp ir">端口</strong>不同。</p><ol class=""><li id="29bb" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">除非您设置了头:<strong class="jp ir">“访问-控制-允许-来源”</strong>，否则将禁止访问其他站点资源。这意味着请求方可以访问被请求方。</li></ol><p id="0aef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不指定，将出现错误:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qj"><img src="../Images/6d3e97669d4f5a68847bebc07906ec5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovkq6E7eqM6J87OQDKO2xA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">如果没有标题，则出现错误</figcaption></figure><p id="a706" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.如果发现类似于<strong class="jp ir">" Access-Control-Allow-Origin "</strong>的错误，并且没有当前域，这使得请求被指定，那么您需要或者写它或者甚至在头值中使用<strong class="jp ir"> "*" </strong>来允许每个人。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qk"><img src="../Images/b6fa2577da38b921cf852b0819030c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U8EdoyQFX5aF_9B9YscC2w.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">为<strong class="bd kz">访问控制允许来源</strong>指定域</figcaption></figure><p id="f0c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.如果你发送一些<em class="os">复杂的请求</em>(有简单请求的列表)，那么浏览器首先会发出所谓的<strong class="jp ir"> <em class="os">预检请求</em> </strong> — <strong class="jp ir"> CORS </strong>请求，看看该请求是否合格。在我们的简单例子中，我们可以做如下的事情(如果需要的话，你需要<strong class="jp ir">Access-Control-Allow-Origin</strong>和其他头):</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ql"><img src="../Images/de9d726321d269348e75e0f6a1f51549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ekzjT-Scqcxe8kyrKfEYw.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">选项请求</figcaption></figure><p id="1b47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单的请求:</p><div class="oc od gp gr oe of"><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">跨来源资源共享(CORS) - HTTP | MDN</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">跨源资源共享(CORS)是一种基于HTTP头的机制，允许服务器指示任何源…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">developer.mozilla.org</p></div></div><div class="pv l"><div class="qm l px py pz pv qa mq of"/></div></div></a></div><h1 id="fcca" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">12.HTTP cookies🍪</h1><p id="0d91" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:<a class="ae kw" href="https://www.youtube.com/watch?v=sovAIX4doOE" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=sovAIX4doOET42</a></p><p id="da50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于<code class="fe ot ou ov ow b">samesite</code>饼干的视频:<a class="ae kw" href="https://www.youtube.com/watch?v=aUF2QCEudPo&amp;list=WL&amp;index=18" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=aUF2QCEudPo&amp;榜单=WL &amp;指数=18 </strong> </a></p><p id="40b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于僵尸饼干的视频:<a class="ae kw" href="https://www.youtube.com/watch?v=lq6ZimHh-j4&amp;list=WL&amp;index=17" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=lq6ZimHh-j4&amp;榜单=WL &amp;指数=17 </a></p><p id="e530" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Cookies </strong> —作为存储介质的数据片段，随每个请求发送到服务器。用于会话管理。</p><ol class=""><li id="c974" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">创建cookies:</li></ol><p id="a37e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建cookies有两种方法:</p><ul class=""><li id="a2a0" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">浏览器控制台中的Javascript方式:<code class="fe ot ou ov ow b">document.cookie = “someName=76”</code></li><li id="3c70" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">Web服务器方式(cookie头):</li></ul><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="qn pc l"/></div></figure><p id="cf51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.Cookie属性</p><ul class=""><li id="dbb5" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">cookie范围:<br/> 1。域:<strong class="jp ir">super.example.com</strong>会有一个<strong class="jp ir"> <em class="os">桶</em> </strong>带cookies。<strong class="jp ir">example.com</strong>会有<strong class="jp ir">T20】另一个斗会有</strong>。<a class="ae kw" href="http://www.super.example.com" rel="noopener ugc nofollow" target="_blank">www.super.example.com</a>是另一个带有cookies <br/> - <strong class="jp ir">的域，但是:</strong>如果你使<code class="fe ot ou ov ow b">document.cookie = “someName=76; domain = .example.com”</code>-将使它对<strong class="jp ir"> <em class="os">所有子域</em> </strong>可用。<br/> -由于HTTP是无状态的<strong class="jp ir"/>，所有的cookies都将与每个请求<br/> 一起发送<em class="os">2。路径:/app1将有特定的cookie，/app2将有另一个cookie =&gt;需要更少的带宽:<code class="fe ot ou ov ow b">document.cookie = “someName = 76; <strong class="jp ir">path</strong> = /path1<em class="os">”</em></code></em></li><li id="3000" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><code class="fe ot ou ov ow b">Expires</code> <em class="os">，</em> <code class="fe ot ou ov ow b">Max-age</code>。如果不指定这些属性，浏览器关闭后cookies将被销毁。如果您指定，那么cookie就被称为<strong class="jp ir">永久cookie</strong>(是的，很奇怪，但是MDN这样称呼它们)。然后，如果你<strong class="jp ir">关闭浏览器</strong>，cookies仍然存在:<code class="fe ot ou ov ow b">document.cookie = “someName = 76; max-age = 3min”</code></li><li id="c3df" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><code class="fe ot ou ov ow b">samesite</code> cookies: <br/> - <code class="fe ot ou ov ow b">document.cookie = “someName=76; samesite=strict”</code>:如果你点击了某个可疑网站的链接，你的<strong class="jp ir"> cookies </strong>也会被发送。但是如果您指定了<strong class="jp ir"> samesite=strict </strong>，那么您将永远无法从该站点获得cookies(它们不会被发送到服务器)，除非您在该站点上。也就是说，如果你直接从浏览器访问链接，你会得到cookies。但是如果你点击了某个网站的链接，这个链接指向了这个网站——<strong class="jp ir">没有cookies。</strong> <strong class="jp ir"> <br/> - </strong> <code class="fe ot ou ov ow b">document.cookie = “someName=76; samesite=lax”</code> : <em class="os">这个cookie会发</em>。然而，即图像，不会出现在网站上，因为它是在另一个领域。</li></ul><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/40dc96d9743257c03bb01ad735da8152.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*h58GOZlJabMhIfm2-Ukhvw.png"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">使用<code class="fe ot ou ov ow b"><strong class="bd kz"><em class="qp">samesite=lax</em></strong></code>时图像将会是什么样子</figcaption></figure><p id="cdeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管如此，点击链接将导航到这个页面。因此，您不能从其他站点/域检索数据，但是您可以访问它们和那里的观察者数据。<code class="fe ot ou ov ow b">samesite=lax</code> <em class="os"> ==完全没有相同的地点</em>。如果<code class="fe ot ou ov ow b">samesite=none</code> = &gt;真的没有。所以，你在某个网站上，图像被加载到其中:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qq"><img src="../Images/6520ed404d3e0c7781c0439c7c745c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htX4yPU7E6CRJ30YjAcgnA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">没有相同的站点示例</figcaption></figure><p id="df1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.Cookie类型</p><ul class=""><li id="2c92" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">会话cookie<br/>-没有<code class="fe ot ou ov ow b">max-age</code>，<code class="fe ot ou ov ow b">expires</code>-浏览器关闭= &gt;随着会话结束而销毁</li><li id="f394" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">永久饼干<br/> -有<code class="fe ot ou ov ow b">expires</code>、<code class="fe ot ou ov ow b">max-age</code></li><li id="d284" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">Httponly只能从服务器<br/>设置-浏览器不能读取它们(安全问题)<br/> -不能从浏览器端的<code class="fe ot ou ov ow b">document.cookie</code>访问</li></ul><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="qn pc l"/></div></figure><p id="ab9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;如果你输入<code class="fe ot ou ov ow b">document.cookie</code> = &gt;这个cookie就看不到了。你可以在开发者工具的cookies部分看到它们，但是<strong class="jp ir"> JS无法读取它们</strong>。令牌、会话id很酷</p><ul class=""><li id="79b6" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">安全cookie:仅适用于HTTPS网站。换句话说——普通饼干</li><li id="77a0" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">第三方cookies:用于跟踪服务。他们来自其他网站，但坐在你的领域(例如，从一些添加页面)。他们不能访问你的领域，但他们知道他们在你的领域:跟踪你的IP，网站。通常用于分析等</li><li id="705a" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated"><strong class="jp ir">僵尸cookies: </strong>如果你删除它们，它们会用相同的值重新创建自己。它们有很多实现方式，但其中之一是通过电子标签。<a class="ae kw" href="https://medium.com/p/d6f425ceea13#00b2" rel="noopener">如果您错过了</a>，请阅读上面的部分。另一种方法是使用其他存储材料:本地存储、会话存储、索引数据库、Web SQL</li></ul><p id="6067" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.安全性</p><ul class=""><li id="d687" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">窃取cookies:读取<code class="fe ot ou ov ow b">document.cookie</code>并发送到某处的应用程序</li><li id="85e2" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">跨站点请求伪造:<code class="fe ot ou ov ow b">samesite</code> <em class="os"> </em>就是为了安全起见而开发出来的。否则:你点击了一些可疑网站的链接。此链接导致，即银行网站，浏览器将召回您的cookies，如果存在= &gt;坏:((</li></ul><h1 id="92ed" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">13.代理和反向Proxy⛓</h1><h2 id="2f99" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">1.代理和反向代理</h2><p id="bf02" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:<a class="ae kw" href="https://www.youtube.com/watch?v=SqqrOspasag" rel="noopener ugc nofollow" target="_blank">T27】https://www.youtube.com/watch?v=SqqrOspasagT29】</a></p><p id="9005" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视频大概只有反向代理:<a class="ae kw" href="https://www.youtube.com/watch?v=ylkAc9wmKhc" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=ylkAc9wmKhc</strong></a></p><p id="858d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于负载均衡器的视频:<a class="ae kw" href="https://www.youtube.com/watch?v=aKMLgFVxZYk" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=aKMLgFVxZYk</strong></a></p><p id="3cf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于TLS/SSL终止的视频:【https://www.youtube.com/watch?v=H0bkLsUe3no】<strong class="jp ir"/></p><p id="12e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于TLS穿越的视频:<a class="ae kw" href="https://www.youtube.com/watch?v=iLHhL-vAPqo" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=iLHhL-vAPqo</strong></a></p><p id="0763" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">代理</strong> —代表客户端发出请求的软件。</p><p id="14c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">客户端→代理</strong> → <strong class="jp ir">服务器</strong></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qr"><img src="../Images/5ff35230c68ab75f7faccd20f11a37e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Awa2XQUcsZAdrrzCAYMGwQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">代理的例子</figcaption></figure><ul class=""><li id="053e" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">在一些组织中，代理服务器会阻止你访问某些网站</li><li id="9287" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">另一个客户端使用相同的代理并请求相同的信息。<strong class="jp ir">代理</strong>将从缓存中取出它，而不是再次发出请求。</li><li id="0223" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">用例:1。缓存2。匿名3。记录4。阻止站点5。微服务:即边车代理</li></ul><p id="66c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">反向代理</strong> —为<em class="os">客户端</em>隐藏最终目的地的软件。因此，<em class="os">客户端</em>不知道请求的确切位置。实际上，<em class="os">客户端</em>认为他知道去哪里，但实际上请求被映射到另一个<em class="os">服务器</em>。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qc"><img src="../Images/8556ad5ba6551fefe426a60571bcbe4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7lvr_nYGXUjeABrDdg4oZg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">反向代理示例</figcaption></figure><ul class=""><li id="62f0" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">用例:1。缓存(<strong class="jp ir">反向</strong> <strong class="jp ir">代理</strong>会回复客户端而不会实际访问后端)2 .负载平衡3。入口:Kubernetes的东西4。金丝雀部署5。微服务:代理和反向代理的sidecar</li><li id="62a1" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">服务网格(侧车代理)—代理和反向代理同时使用</li></ul><h2 id="3728" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">2.第4级与第7级负载平衡器</h2><p id="e2b5" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated"><strong class="jp ir">负载平衡器(简称LB)</strong>—将负载(在我们的例子中是请求)分配给多个服务器以防止过载的软件。通常，<strong class="jp ir">反向代理</strong>也被用作负载平衡器(即NGINX)。</p><p id="205b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个定义:<strong class="jp ir"> LB </strong>通过各种技术将负载分成不同的<em class="os">服务器</em>。即<em class="os">循环赛</em></p><p id="5aec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本节开始之前，请务必查看关于OSI 的<a class="ae kw" href="https://medium.com/p/d6f425ceea13#29d5" rel="noopener">第一节。</a></p><p id="4a07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面将有2个关于L4和L7的相似组块，包含各种信息。看看吧。</p><p id="c813" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总而言之:</p><ol class=""><li id="5fe5" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">TCP端接:第4层(在第7层很明显)</li><li id="60af" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">TLS终止:第4层—仅代理流量(加密或解密)。第7层—收集所有数据包，然后决定如何处理。</li><li id="226e" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">TCP穿越:第4层</li><li id="d222" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">TLS直通:第4层和第7层——仍然<strong class="jp ir">解密</strong>流量</li></ol><p id="617f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第一大块:</strong></p><p id="ab9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第七层</strong></p><ol class=""><li id="e3e1" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">向<strong class="jp ir">反向代理<br/> -与<strong class="jp ir">反向代理</strong>建立的TLS </strong>发送请求</li><li id="7646" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">请求是一个包含<strong class="jp ir">数据包</strong>和<br/>的复合物——只有在<strong class="jp ir">反向代理</strong>收到所有<strong class="jp ir">数据包</strong>后，请求才完成</li><li id="a096" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">由于是第七层<strong class="jp ir"><em class="os"/></strong><strong class="jp ir">反向代理</strong>终止<strong class="jp ir"> TLS <br/> </strong>📛 📛 📛 📛 📛<br/>在这一层我们也可以做<strong class="jp ir">穿越</strong>T30】📛 📛 📛 📛 📛</li><li id="adf7" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">接下来，<strong class="jp ir">反向代理</strong>将发送新的<strong class="jp ir">数据包</strong>到服务器N <br/>，与<em class="os">客户端</em>使用<strong class="jp ir">反向代理</strong>做同样的事情</li></ol><p id="1696" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第四层</strong></p><p id="9a11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">📛 📛 📛 📛 📛</p><p id="4b67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">更新:</strong>但是，您可以执行<strong class="jp ir"> TCP终止</strong>，因此您也将拥有2个TCP连接。但是没有智能平衡</p><p id="b673" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">📛 📛 📛 📛 📛</p><ol class=""><li id="d8e6" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk ox ly lz ma bi translated">向<strong class="jp ir">反向代理发送请求</strong> : <strong class="jp ir"> <em class="os">数据包<br/>-</em>-</strong>第4层称为<strong class="jp ir">-<em class="os">数据包级代理<br/>-</em>-</strong>它不查看数据，因为它是<strong class="jp ir">加密的</strong>在这一级</li><li id="6a3f" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">在第一个<strong class="jp ir">数据包</strong>被<strong class="jp ir">反向代理</strong>接收后，它将被发送到<em class="os">服务器N </em>，而不等待第二个<strong class="jp ir">数据包</strong>。接下来，第二个<strong class="jp ir">数据包</strong>将做同样的事情，第三个<br/>也是如此——当客户端IP地址相同时，<strong class="jp ir">反向代理</strong>将始终向同一服务器发送数据<br/>——响应以同样的方式完成:<strong class="jp ir">数据包</strong>将被发送到<strong class="jp ir">反向代理</strong>，然后发送到<em class="os">客户端</em>。然后，下一个数据包等等</li><li id="9802" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk ox ly lz ma bi translated">第4层不需要理解请求/响应。<br/>当你不想/不需要<strong class="jp ir">反向代理</strong>理解协议时，这是好的:即<strong class="jp ir"> gRPC </strong>是可以的</li></ol><p id="556e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二块:</strong></p><p id="dc9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第4层<strong class="jp ir">负载均衡器</strong>:我们只知道<strong class="jp ir"> IP地址</strong>和<strong class="jp ir">端口</strong>:</p><ul class=""><li id="2668" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">将<strong class="jp ir"> IP地址</strong>从其自身更改为其中一个服务器。它是通过<strong class="jp ir">NAT</strong>(<a class="ae kw" href="https://medium.com/p/d6f425ceea13#254c" rel="noopener">read section above</a>):源IP(客户端的——图上是44.1.1.1)到数据目的IP(图上是44 . 3 . 3 . 3)——一个<strong class="jp ir"> TCP </strong>连接从<em class="os">客户端</em>到<em class="os">服务器</em></li></ul><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qs"><img src="../Images/101328c5f5734824433c14039f8c016d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qPqCgLIEhk0ixlwAStyUUw.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">L4负载平衡器示例</figcaption></figure><ul class=""><li id="02f1" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><em class="os">客户端</em>不知道请求被转发到哪里，因为它是反向代理</li></ul><p id="8e3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优点:</p><ul class=""><li id="a1b4" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">更简单的<strong class="jp ir">负载均衡</strong>(不需要看数据)</li><li id="d9b1" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">高效(不需要看数据)</li><li id="73ba" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">更安全，因为没有<strong class="jp ir"> TLS终止</strong></li><li id="de89" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">一个TCP连接</li></ul><p id="5313" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缺点:</p><ul class=""><li id="a46b" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">没有智能<strong class="jp ir">负载平衡</strong>:没有URL重写，因为你只知道IP地址</li><li id="8856" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">不适用于微服务(即入口使用路径转发到各种服务)</li><li id="71aa" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">多用户无缓存</li></ul><p id="804c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第七层<strong class="jp ir">负载均衡器:</strong></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qs"><img src="../Images/da0df771162305f919512a0428af5377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AB6HT_llluf_5-h_K3kHKg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">从客户端到LB的TCP连接</figcaption></figure><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qs"><img src="../Images/6b76249504d5f661f71baaf55ea44f3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gq0B_Km52NaCDDM4mS9jVg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">从LB到服务器的TCP连接</figcaption></figure><ul class=""><li id="93e5" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><em class="os">客户端</em>向<strong class="jp ir">负载均衡器</strong>发出请求:<strong class="jp ir">IP _ address</strong>_<strong class="jp ir">source</strong><em class="os">GET/pictures</em><strong class="jp ir">IP _ address _ destination</strong>:一个到<strong class="jp ir">负载均衡器</strong>的TCP连接，另一个从<strong class="jp ir">负载均衡器</strong>到<em class="os">服务器</em>的TCP连接(一条路径可能有多个，即7个服务器用于/image</li><li id="ab43" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">所以，<strong class="jp ir"> 2个连接</strong>看似为<strong class="jp ir">一个连接</strong></li></ul><p id="4142" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">优点:</p><ul class=""><li id="c362" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">智能<strong class="jp ir">负载平衡</strong>(基于一定的逻辑；即表头)</li><li id="d932" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">贮藏</li><li id="8d7a" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">非常适合微服务</li></ul><p id="264d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缺点:</p><ul class=""><li id="61ed" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">昂贵(将数据视为TLS终止)</li><li id="fc4c" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">解密(终止TLS)</li><li id="ff11" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">两个TCP连接</li><li id="72bc" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">必须共享TLS证书:即客户端到负载平衡器</li></ul><p id="80bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">中注意。cfg </strong>文件:如果第4层-由于TCP是连续的，所以不会循环调度，而在第7层-由于循环调度是活动的，所以会不断变化。</p><p id="5ec4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面你可以看到第7层LB (HAProxy)的例子</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="qn pc l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">第7层配置</figcaption></figure><h2 id="0c67" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">3.TLS/SSL termination⚔️</h2><p id="7e94" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated"><strong class="jp ir"> TLS终止</strong> —结束TLS连接并向主服务器发送未加密数据的过程。只有在<strong class="jp ir">第7层</strong>和<strong class="jp ir">第4层</strong>数据加密时才有可能。</p><p id="0829" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ot ou ov ow b">Client &lt;-&gt; Load Balancer (Reverse Proxy) &lt;-&gt; Original Server</code></p><p id="2cc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="os">客户端</em>和<strong class="jp ir">反向代理</strong>之间有TLS。<br/>为了让<em class="os">服务器</em>帮助<em class="os">客户端</em>:缓存数据，选择更好的服务器(如果有多个)，需要<strong class="jp ir">终止TLS </strong>又名解密数据。</p><p id="b2f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> TLS转发代理</strong>——解密来自<em class="os">客户端</em>的数据，然后<strong class="jp ir">再次加密</strong>发送到<em class="os">原服务器</em>的过程。这被认为是<strong class="jp ir"> TLS终止</strong>的一种方式，但更安全，因为<strong class="jp ir">反向代理</strong>和<strong class="jp ir">原始服务器</strong>之间的数据是安全的。</p><p id="1450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ot ou ov ow b"><em class="os">Client &lt;-&gt; Load Balancer (Reverse Proxy)</em></code> —它们之间有TLS连接。</p><p id="b42e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ot ou ov ow b"><em class="os">Proxy &lt;-&gt; Original Server</em></code> —也有安全连接，但不是第一种。</p><p id="4b27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在我们的<strong class="jp ir">代理</strong>中放入各种东西:入侵检测系统，http加速器完成工作(像Varnish)，Kafka触发一些事件——因为数据是未加密的。</p><p id="fc19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> TLS终止/TLS转发代理的优点</strong>:</p><ul class=""><li id="a254" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">将代理放在比真实服务器更靠近客户端的位置</li><li id="bb6b" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">作为解密数据的HTTP加速器(即Varnish)</li><li id="9712" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">入侵检测系统:嗅探数据以检测此类问题</li><li id="0c41" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">第7层/服务网格的负载平衡</li></ul><p id="cc45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缺点:</p><ul class=""><li id="fc24" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">数据可能会受到危害</li></ul><h2 id="d655" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">4.TLS直通</h2><p id="7ca4" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">同样，<strong class="jp ir">第四层代理</strong>只能查看IP地址和端口。</p><p id="b540" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">预演上一节:</strong> <em class="os">客户端</em>向<em class="os">服务器</em>发出请求。<strong class="jp ir">反向代理</strong>将:</p><ul class=""><li id="d290" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">第一种变体:仅仅向后端之一发送请求(例如，通过循环法)——一个没有终止的<strong class="jp ir"> TCP连接</strong></li><li id="a737" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">第二种变体:建立与<em class="os">客户端</em>及其自身的连接(因此，您将证书放在<em class="os">反向代理</em>中)。然后建立与自身和其中一个<em class="os">服务器</em>的另一个<strong class="jp ir"> TCP连接</strong></li></ul><p id="e598" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> TLS直通:</strong></p><p id="ef07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在第4层和第7层可用</strong></p><ul class=""><li id="adad" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated"><strong class="jp ir">反向代理</strong>将破解<em class="os">客户端你好</em>查看<strong class="jp ir"> SNI </strong>参数找到域名</li><li id="c8b4" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">传递到期望的域，但<strong class="jp ir">被加密</strong></li><li id="c3d9" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">接收来自<em class="os">服务器</em>之一的响应，但什么都不明白</li><li id="eaf9" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">现在，<strong class="jp ir">反向代理</strong>只是在<em class="os">客户端</em>和<em class="os">服务器</em>之间转发消息，而不理解内容</li></ul><p id="d191" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;第4层反向代理</p><p id="20a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有，我推荐看下面的视频，自己试着用HAProxy玩:<a class="ae kw" href="https://www.youtube.com/watch?v=qYnA2DFEELw" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www.youtube.com/watch?v=qYnA2DFEELw</strong></a></p><h1 id="ccdb" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">14.HSTS🔩</h1><p id="8d28" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated"><strong class="jp ir"> HSTS </strong> — http严格的运输安全</p><p id="199e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> SSL剥离:</strong></p><ul class=""><li id="59a5" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">大多数<em class="os">网络服务器</em>支持HTTP和HTTPS</li><li id="fee1" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">如果<em class="os">客户端</em>与HTTP连接，他将被服务器重定向到HTTPS</li><li id="97ea" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">问题:在来自<em class="os">客户端</em>的第一个HTTP请求期间，请求可能会被<strong class="jp ir"> MITM </strong>处理，攻击者会将请求重定向到他的站点，看起来很像，也可能是HTTPS</li></ul><p id="7b06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;解决方案是<strong class="jp ir"> HSTS </strong></p><ul class=""><li id="41a7" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">浏览器保存着所有强迫用户在HTTPS工作的网站列表。它叫做<strong class="jp ir"> HSTS排行榜</strong></li><li id="9dfa" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">所以，如果你输入<em class="os"> http site </em>，浏览器会自动把你连接到HTTPS版本</li><li id="5ab1" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">你网站应该返回<strong class="jp ir">严格传输安全</strong>头，让浏览器更新HSTS列表</li><li id="695b" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">即使你的一些网页在HTTP上，其他网页在HTTPS = &gt;也要通过HTTPS与网站连接</li></ul><p id="1db4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">局限性:</p><ul class=""><li id="14c3" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">请求的速度较低</li><li id="1c52" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">降级攻击(TLS) <br/>不起作用——攻击者拦截<strong class="jp ir">客户端hello </strong>来降级<em class="os">客户端</em>的加密算法，使<em class="os">服务器</em>无法选择最新最好的加密算法</li><li id="2b42" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">如果<em class="os">客户端</em>第一次去站点，可以支持HTTPS，但是<em class="os">客户端</em>去HTTP版→浏览器在<strong class="jp ir"> HSTS列表中没有这个站点</strong> = &gt; <strong class="jp ir"> MITM </strong>可能性(<strong class="jp ir"> ARP中毒</strong>，准确的说。<a class="ae kw" href="https://medium.com/p/d6f425ceea13#6ed1" rel="noopener">阅读上一节</a>中关于ARP的内容。这就是为什么要看证书(必须由我们进入的<strong class="jp ir">非常站点</strong>出具，即google.com<a class="ae kw" href="http://google.com" rel="noopener ugc nofollow" target="_blank">T42T44】</a></li></ul><h1 id="74e5" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">15.哑剧嗅探🌫</h1><p id="975f" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">视频:<a class="ae kw" href="https://www.youtube.com/watch?v=eq6R6dxRuiU" rel="noopener ugc nofollow" target="_blank">T46】https://www.youtube.com/watch?v=eq6R6dxRuiUT48】</a></p><p id="8de5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">延伸阅读:<a class="ae kw" href="https://www.coalfire.com/the-coalfire-blog/mime-sniffing-in-browsers-and-the-security" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://www . coal fire . com/the-coal fire-blog/mime-snughing-in-browsers-and-the-security</strong></a></p><p id="4bfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> MIME </strong> —多用途互联网邮件交换</p><p id="c4e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> MIME嗅探</strong>是浏览器用来识别所提供内容类型的一种方法。浏览器依靠这个<em class="os">内容类型</em>来知道做什么。</p><p id="cac4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不指定返回内容的<strong class="jp ir">类型，那么浏览器不知道该做什么。因此，它试图嗅出内容的主体，并解析它以知道该做什么。</strong></p><p id="ebe7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看下图:</p><ul class=""><li id="8214" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">扩展是一个简单的路径，它不指定任何东西(我的意思是内容类型)</li></ul><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qt"><img src="../Images/973d86cba4f96fb3b7cc19228261fe0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NLiPa4mzxjWjseLixqOTTw.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">资源请求</figcaption></figure><p id="627e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">但是</strong> : <em class="os">客户端</em>请求资源，<em class="os">服务器</em>响应<em class="os"> html </em>页面，其中没有指定<strong class="jp ir">内容类型</strong>。浏览器试图解析它，发现它是<em class="os"> html </em>。但是在那个<em class="os"> html </em>里面有一个糟糕的javascript代码。<strong class="jp ir">你被黑了</strong></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi qt"><img src="../Images/1ad7793bfc79e29f3acadfffc286aef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*imLjDfv0h_RXNL_ICbRxdQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">来自服务器的响应</figcaption></figure><h1 id="48cb" class="nd ky iq bd kz ne nx ng lc nh ny nj lf nk nz nm li nn oa np ll nq ob ns lo nt bi translated">结尾部分🙌</h1><p id="6397" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy nu ka kb kc nv ke kf kg nw ki kj kk ij bi translated">如果你到了这一步，那么非常感谢你的耐心和对你好奇心的认可🎉。请随意写评论或通过提供的资源联系我📩：</p><ul class=""><li id="e2a0" class="lq lr iq jp b jq jr ju jv jy op kc oq kg or kk lx ly lz ma bi translated">领英:<a class="ae kw" href="http://www.linkedin.com/in/sleeplesschallenger" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/sleeplesschallenger</a></li><li id="2e29" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">GitHub:<a class="ae kw" href="https://github.com/SleeplessChallenger" rel="noopener ugc nofollow" target="_blank">https://github.com/SleeplessChallenger</a></li><li id="9692" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">leet code:【https://leetcode.com/SleeplessChallenger/】T21</li><li id="141f" class="lq lr iq jp b jq mb ju mc jy md kc me kg mf kk lx ly lz ma bi translated">电报:@无眠挑战者</li></ul></div></div>    
</body>
</html>