<html>
<head>
<title>Learning Typescript with Web Components: Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Web组件学习Typescript:第3部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-typescript-with-web-components-part-3-a599c8d26213?source=collection_archive---------22-----------------------#2022-07-18">https://levelup.gitconnected.com/learning-typescript-with-web-components-part-3-a599c8d26213?source=collection_archive---------22-----------------------#2022-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c777697654ba5f9cbe4fbcfb9cad7965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DckELhlA_S09K_o2B_HRdw.png"/></div></div></figure><h1 id="e5f2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">第3部分:使用JSON对象</h1><blockquote class="kw kx ky"><p id="2667" class="kz la lb lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">到目前为止，在这个系列中，我们已经看到了数据绑定，将数据存储在对象中，并用数组对其进行映射。在这一集里，我们将看看如何切分<em class="iq">Typescript对象中的数据，以及如何编写和调用在内部处理对象的函数。</em></p></blockquote><p id="51e2" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated"><strong class="lc ir">快速索引<br/> </strong>第1部分:<a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/learning-typescript-with-web-components-lit-4f38fae47e27">属性，值，&amp;数据绑定</a> <br/>第2部分:<a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/learning-typescript-with-web-components-part-2-9798ec0b67e2">使用数组</a> <br/>第3部分:<a class="ae mb" rel="noopener ugc nofollow" target="_blank" href="/learning-typescript-with-web-components-part-3-a599c8d26213">使用JSON对象</a></p><h1 id="b54d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">函数内部太暗，无法阅读</h1><p id="d9d2" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">如果你一直和我们在一起，你会听到我以前说过，一切都是物体。我们稍后将再次讨论这个想法，但是对于这个讨论的大部分，我们将讨论JSON对象——在一个键下保存数据值的对象。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/78d363c68beebbfea28a0b6564393f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PD_nrq3I_EBDpYc1UXa47A.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">美国著名诗人、《草叶集》的作者沃尔特·惠特曼曾说过:“除了狗，书是一个人最好的朋友。在狗的肚子里，太暗了，没法看书。”</figcaption></figure><p id="266c" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">在第2部分中，我们使用了一个对象来存储通用调色板的颜色。然后我们用一个键从那个对象中调用值，这个键就是，<strong class="lc ir"> </strong>本身，<strong class="lc ir">变量</strong>。这部分很重要。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/929a834229fff81ae69bf8ec63e2342f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*depWIqBD42NaJEc0WcSxlQ.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">这里定义的常量<strong class="bd ka">颜色</strong>…</figcaption></figure><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/c4bea4a3bcc9e393bb5e500f0aae9243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8RmYtwHEIWDOlTM9yMfoTg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">…可以使用我们模型中的任何变量通过键进行访问。这里，是这个颜色。</figcaption></figure><p id="460f" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">我们会经常用到这种技术，因为在函数内部，我们通常会对一个变量值进行操作。从外部传入的东西，一个<a class="ae mb" href="https://en.wikipedia.org/wiki/Parameter_(computer_programming)" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">参数</strong> </a>，就变成了变量的值。在我们之前的例子中，那是<code class="fe ms mt mu mv b">color=</code>属性。保持这种想法…</p><h1 id="5b3e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">将对象添加到对象</h1><p id="4697" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">前面，我们看了如何遍历或<a class="ae mb" href="https://en.wikipedia.org/wiki/Iteration" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">迭代</strong> </a>数组中的键，以从相应的对象键中获取值。让我们扩展我们的模型，为颜色添加名称。这将需要重新思考架构。</p><p id="3f36" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">JSON对象中的每个键只能有一个值。但是，该值可以是一个在自己的键下有多个值的对象！这使我们能够将每种颜色重新定义为一个对象，而不仅仅是一个十六进制值。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/84481db2abe4286655372636e7a8171c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WrTeVru15-8fqXy0jp1TaA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">将红色重新定义为一个对象让我们在其中存储两个值，每个值都有自己的键。</figcaption></figure><p id="1a88" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">这里我把每种颜色都改成了两个值，一个在<code class="fe ms mt mu mv b">hex</code>下面，一个在<code class="fe ms mt mu mv b">name</code>下面。每当我们改变模型时，我们也需要改变视图，所以让我们更新<code class="fe ms mt mu mv b">dta-chip.ts</code>:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/33195bfdbce82575289d344ead35f10f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7Q0u-MCpLu5rlcyIgqSQw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">我们可以得到十六进制颜色，但那真的很丑！有更好的方法…</figcaption></figure><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/63674d48b7cee3fb68baf29a9b696c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zle9Oh5lPFJXcZoXywseSg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">在迈克尔·克莱顿的<strong class="bd ka">球体</strong>中，科学家们在深海中发现了一个来自未来的结构中的结构——它似乎是在过去被放置在那里的！这很像处理对象。</figcaption></figure><p id="21ed" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">因此，要获得“三层深度”并找到实际的十六进制值，我们现在必须编写一个又长又讨厌的访问器。在伪代码中，我们可以说我们:</p><ol class=""><li id="ce0d" class="mz na iq lc b ld le lh li ly nb lz nc ma nd lx ne nf ng nh bi translated">从<code class="fe ms mt mu mv b">dta.colors</code>中取出对象，即<code class="fe ms mt mu mv b">this.color</code>键的值。</li><li id="75f5" class="mz na iq lc b ld ni lh nj ly nk lz nl ma nm lx ne nf ng nh bi translated">从中返回<code class="fe ms mt mu mv b">hex</code>键的值。</li></ol><p id="ade9" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">这不是史上最烂的存取器，但却是<a class="ae mb" href="https://en.wikipedia.org/wiki/Code_smell" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">码闻</strong> </a>的例子。这是一个早期警告，表明这段代码以后可能会有问题。在这里，问题在于步骤的复杂性。实际上，它们构成了一个“配方”，我们可以用这个想法将它们重构为一个函数。</p><h1 id="5f0a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">有不止一种方法…</h1><p id="49eb" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">在编程中，总是有不止一种方法可以实现同样的事情。最好的开始是对你来说最容易推理的。然后，你可以将<a class="ae mb" href="https://en.wikipedia.org/wiki/Code_refactoring" rel="noopener ugc nofollow" target="_blank"><strong class="lc ir"/></a><strong class="lc ir"/>重构成更好的东西。让我们来看看将“获取颜色的十六进制值”的方法转移到函数中的几种方法。</p><h1 id="8806" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用函数对象</h1><p id="216b" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">在Typescript中，另一种主要类型的对象(除了我们已经存储的JSON数据)是一个<strong class="lc ir"> function </strong>对象。函数和所有其他对象的区别在于函数<strong class="lc ir">做一些事情</strong>。</p><p id="8532" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">JSON数据不“做”任何事情。它像一个粮仓一样坐在那里，等着你把小麦放进去，又把它拿出来。功能是<em class="lb">执行者</em>，它们遵循我们的食谱。在第2部分中，我们看了当我们在一个数组上<code class="fe ms mt mu mv b">map()</code>时“做某事”的<em class="lb">箭头函数</em>。</p><p id="ebb9" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">在这种情况下，我们需要一个独立的<strong class="lc ir">函数，这样我们就可以从任何组件应用它的配方。你可能已经注意到我们已经写了几个像<code class="fe ms mt mu mv b">map()</code>这样以括号结尾的函数调用。这就是你(和Typescript)区分JSON数据对象和函数对象的方式。数据不以父母结尾。函数有。</strong></p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/e07bcd152c48bca6791156fce9a0c8a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L8Ipkbfmr07M_VpICWwr7Q.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">在第44行，我们只访问数据。对象后没有父对象。第45行是一个<strong class="bd ka">函数调用</strong>，圆括号中有一个参数。(相同的)结果显示在每个结果的右侧。</figcaption></figure><p id="672a" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">这里我们可以看到从模型中访问数据(第44行)和<strong class="lc ir">运行</strong>或<strong class="lc ir">调用</strong>一个带参数的函数(第45行)之间的语法差异。在我们的特定模型中，有两种获取相同(固定)数据的方式。</p><p id="3c38" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">我们如何调用一个函数从一个<strong class="lc ir">变量</strong>键中获得一个十六进制值？在<code class="fe ms mt mu mv b">dta-chip.ts</code>中，让我们用对一个新函数<code class="fe ms mt mu mv b">dta.getColor(thisColor)</code>的调用来替换背景色<code class="fe ms mt mu mv b">dta.colors[this.color].hex</code>，这个函数我们还没有定义。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/5b352dcb25e5adfb2a14e86f1ef14b82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCgfLl_sgkQD2MEGre2gSA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated"><strong class="bd ka">重构</strong>背景色使用一个我们还没写的函数。</figcaption></figure><h1 id="35bf" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">定义和导出函数</h1><p id="3cf0" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">让我们写函数定义。最理想的地方是我们已经做好并进口的<code class="fe ms mt mu mv b">colors.ts</code>模块。如果我们<code class="fe ms mt mu mv b">export</code>了函数定义，它将可用我们导入它。食谱如下:</p><ol class=""><li id="b771" class="mz na iq lc b ld le lh li ly nb lz nc ma nd lx ne nf ng nh bi translated">给定一种颜色(键)…</li><li id="be40" class="mz na iq lc b ld ni lh nj ly nk lz nl ma nm lx ne nf ng nh bi translated">从我们现有的颜色对象中返回它的十六进制值。</li></ol><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/9952adeb3cd24e05bdde696b7a105ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tkl8SxKqzUbZDJ--EY37Iw.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">我们黄色的新函数引入了一个颜色键(蓝色)。在第31行，它从同一个键返回<strong class="bd ka">DTA . colors</strong><strong class="bd ka">hex</strong>值。</figcaption></figure><p id="56dc" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">为了从我们的模型中访问<code class="fe ms mt mu mv b">dta.colors</code>对象，我们需要在第4行<code class="fe ms mt mu mv b">import</code>它(或者模块加载器)。</p><blockquote class="kw kx ky"><p id="a38f" class="kz la lb lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">这个截屏还展示了一个VSCode技巧…你可以用第6行的<code class="fe ms mt mu mv b">&gt;</code>右角符号折叠一大段代码(比如<code class="fe ms mt mu mv b">export const colors</code>)。</p></blockquote><h1 id="f135" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">定义和使用参数值</h1><p id="e3ad" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">我们配方的第一行说我们“被给了一个颜色键”我们得到的任何东西都变成了参数。在第29行，我们定义了在函数中使用的参数名称<strong class="lc ir">。这个名字在任何其他上下文中都没有意义。它只适用于这个食谱。这段代码表示参数名为<code class="fe ms mt mu mv b">color</code>。</strong></p><p id="eca7" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">当我们稍后在配方的第31行访问同一个<code class="fe ms mt mu mv b">color</code>变量时，我们会得到一个特定函数调用传入的任何值。所以如果我们用<code class="fe ms mt mu mv b">getColor(“green”)</code>调用这个函数，我们会得到<code class="fe ms mt mu mv b">dta.colors[green].hex</code>。</p><h1 id="0fcc" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">今日回报</h1><p id="adf7" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">Typescript函数可以<strong class="lc ir">返回</strong>一个值，尽管这不是必需的。如果一个函数有一个类似于第31行的<code class="fe ms mt mu mv b">return</code>语句，那么无论返回什么，都将成为替代使用它的函数调用的值。另一种说法是，返回值<em class="lb">替换代码中相同位置的函数调用</em>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/696dab53476a9ff678676c4484e07844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*xnDgDRm6rtexrR1umOvWCw.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">第45行的<strong class="bd ka">函数调用</strong>的返回值被绑定到<strong class="bd ka"> &lt; div &gt; </strong>的内容。</figcaption></figure><p id="6e69" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">最终结果是，我们新的<code class="fe ms mt mu mv b">getColor</code>函数将接收一个键并返回我们需要的十六进制颜色，从而正确地插入我们放在芯片上的<code class="fe ms mt mu mv b">background-color</code>值。这里再次供参考:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/416fc623aeeba2cb2662b5a086a50cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ENw_lWyHaV8dJavhvoHc1g.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">用这个组件的颜色属性作为参数调用我们的新函数。</figcaption></figure><p id="3920" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">浏览器“看到”背景色属性，就好像只有函数的<strong class="lc ir">返回值</strong>存在一样。函数本身不会出现在任何地方。如果我们看看我们的产量，它应该是不变的！</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/b371126a0a50759415da4888a6b1331d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAXIa17M23LaeK7dfnx0LA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">一次成功的重构的结果应该是…什么都没有！</figcaption></figure><p id="fcd8" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">现有代码的成功重构或改进(相对于新特性)应该不会对现有输出产生<strong class="lc ir">变化</strong>。换句话说，这种获取十六进制代码的新方法应该和旧方法完全一样。在引擎盖下，我们为每种颜色添加了一个新的<code class="fe ms mt mu mv b">name</code>(一个新特性)，所以让我们把它添加到视图中。</p><h1 id="271d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">从模型中添加新数据</h1><p id="7f5d" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">为了得到我们模型中现在的颜色名称，让我们在<code class="fe ms mt mu mv b">colors.ts</code>中写另一个函数。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/1798975b99855e6b8aca14d2d9fbfcb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PVf8OMkW0eqiRVZW2ZWp8g.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">新的<strong class="bd ka"> getName </strong>函数采用相同的颜色键并返回名称。</figcaption></figure><p id="f920" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">我可以通过调用我的新函数来访问组件视图中的名称。在这里，我把它放在了芯片内部的一个<code class="fe ms mt mu mv b">&lt;div&gt;</code>里面。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/aa4740cf0fd3f8a3eca7c26034d8ab83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2jdK3G9Vg8p-EKOr_I3UQA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">通过调用我们的新函数，添加一个<strong class="bd ka"> &lt; div &gt; </strong>来显示颜色名称。</figcaption></figure><h1 id="e09c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">把它放在线上！</h1><p id="05f9" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">通过芯片组件上的一些CSS，我可以显示芯片内部的颜色名称。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/01a9b899243b553c42eead7b4309d227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*7SLDSbDPo7nSDzU0zPXxsQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">下面不太完美的渲染是由<strong class="bd ka"> dta-chip.ts </strong>中的这个CSS带给你的。</figcaption></figure><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/8e230f779d113eb707b252d6575213b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-L8MCXu9EP0YZLRNPzRUow.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">我还更新了<strong class="bd ka"> &lt; dta-page &gt; </strong>组件，通过引用<strong class="bd ka"> Pages </strong>常量中单词“palette”样式中的<strong class="bd ka"> dta.getColor('seaGreen') </strong>来使用我的自定义颜色之一。</figcaption></figure><p id="5329" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">这个例子也演示了在你的输出中的其他地方使用颜色，比如我在这里应用了<code class="fe ms mt mu mv b">dta.getColor(“seaGreen”)</code>的单词<em class="lb">调色板</em>。</p><h1 id="d2be" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">这么多功能</h1><p id="6632" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">看起来好像我们在为简单的事情创造很多功能。毕竟，我们已经有了两个函数，只是为了从同一个对象中得到两个不同的东西。这引出了你的建筑设计中的一个重点。只有你知道有多少功能是太多了，只有你能决定什么时候你应该重构到一个更好的方法来完成同样的事情。在我继续之前，让我们想一想这种设计可以改变的几种方式:</p><ol class=""><li id="f06e" class="mz na iq lc b ld le lh li ly nb lz nc ma nd lx ne nf ng nh bi translated">根据参数的不同，单个函数可以返回名称或十六进制值。</li><li id="1bb4" class="mz na iq lc b ld ni lh nj ly nk lz nl ma nm lx ne nf ng nh bi translated">一个简单的函数可以返回在关键位置的颜色对象，并让我们把我们需要的关键点去掉。</li><li id="ac74" class="mz na iq lc b ld ni lh nj ly nk lz nl ma nm lx ne nf ng nh bi translated">我们可以在需要时直接访问<code class="fe ms mt mu mv b">dta.colors</code>,尽管需要多层密钥。</li></ol><p id="6b8d" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">这些比我们现在拥有的更吸引你吗？当你完成自己的设计时，你可以自由地思考它或编写代码。</p><p id="f890" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">如果你决定重构你的代码，在你添加新的特性之前，首先在输出中实现<strong class="lc ir">无变化</strong>来证明你的重构是有效的。到目前为止，我们的代码可以用这些方法中的任何一种(以及其他几种)进行重构，而不会改变输出。选择你最容易理解的设计。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/4e367f97377928c36a387f22954ae534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-qXuJJKFaw4fnHIs6iOCkA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">校舍摇滚的<a class="ae mb" href="https://www.youtube.com/watch?v=4AyjKgz9tKg" rel="noopener ugc nofollow" target="_blank">连词连词</a>问:“你的功能是什么？”答案？"连接单词、短语和从句."虽然这不是编程中函数的精确定义，但也不远了！</figcaption></figure><h1 id="9c2b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">创建渐变组件</h1><p id="9bed" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">让我们看看是否能在调色板之外构建一些更高级的东西。作为使用对象的一个练习，让我们构建一个渐变组件，显示我们传递给它的两个颜色键之间的颜色范围。像往常一样，在编写组件的功能之前，我将编写我希望如何使用组件的代码。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/38f51cb0562e80b9c007dc4823b8c98f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nve7__WnsCW_GY9E2tz-wA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">添加一个<strong class="bd ka"> &lt; dta渐变&gt; </strong>我想要的开始和结束颜色。</figcaption></figure><p id="e19e" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">在我的新<code class="fe ms mt mu mv b">dta-gradient.ts</code>文件中，我需要添加两个属性，它们将从这两个属性中接收数据。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/11ee2d7fb4a7a3399cce32a42628a741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyJ4NWdYpqq-Tru5Ig-W0Q.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">创建一个<strong class="bd ka"> dta-gradient </strong>组件，并向其添加与我传递的属性相匹配的属性。</figcaption></figure><p id="fd15" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">在我的<code class="fe ms mt mu mv b">&lt;dta-gradient&gt;</code>元素中，我只想传递<code class="fe ms mt mu mv b">start=</code>和<code class="fe ms mt mu mv b">end=</code>的颜色<strong class="lc ir">键</strong>。但是要绘制梯度，我需要更深入地挖掘并获得十六进制值。让我们看看如何“挖掘”一个对象，从它的值中创建变量。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/a8b133459f417274449b5c29561d933d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zVDIEICHCAIgRW5W"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">很少有人知道玛雅金字塔，比如位于科巴的这座，大多是在废墟中发现的。正面是通过猜测重建的。背面，一点也不！有了TS中的析构，你可以分解复杂的对象，而不会丢失部件的轨迹。</figcaption></figure><h1 id="a26e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">解构对象</h1><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/c18ed61b7164f761290dbb33d59f3814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eJqthxBE8HFo6yteXSTy2A.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">这里，键名<strong class="bd ka">名</strong>(黄色)将进入名为<strong class="bd ka"> startName </strong>(绿色)的变量。它的值将是键<strong class="bd ka"> this.start(蓝色)</strong>处的颜色对象。</figcaption></figure><p id="3b99" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">这段代码看起来可能很奇怪，但是它展示了Typescript最强大的特性之一:<a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">析构赋值</strong> </a>。这听起来有点拗口，就像这段代码一样，但实际上它非常简单而强大。</p><p id="1909" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">传入start和end键后，我希望将每个键的名称和十六进制颜色放入单独的变量中。但是，这些都在每个颜色对象中的相同键上！换句话说，开始和结束十六进制颜色都在<code class="fe ms mt mu mv b">hex</code>键下。</p><p id="8f2f" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">在一个析构任务中，我告诉Typescript如何分解它。第30行表示获取名为<code class="fe ms mt mu mv b">name</code>的键并将其赋给名为<code class="fe ms mt mu mv b">startName</code>的新变量，获取键<code class="fe ms mt mu mv b">hex</code>并将其赋给新变量<code class="fe ms mt mu mv b">startHex</code>。“那个钥匙叫<code class="fe ms mt mu mv b">name</code>关<strong class="lc ir">关<em class="lb">什么</em>关</strong>关？，你可能会问。”而答案在赋值语句的另一边，在<code class="fe ms mt mu mv b">=</code>等号后面。</p><p id="c295" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">通过将右侧的<code class="fe ms mt mu mv b">dta.colors[this.start]</code>赋值给左侧的析构参数，我们告诉TS在<code class="fe ms mt mu mv b">dta.colors[this.start]</code>处获取<strong class="lc ir">对象</strong>，并按照我们所描述的方式对其进行划分。第31行以同样的方式处理结束值。</p><p id="a1c0" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">下面是相同的<a class="ae mb" href="https://en.wikipedia.org/wiki/Assignment_(computer_science)" rel="noopener ugc nofollow" target="_blank">赋值</a>语句在没有析构的情况下的样子:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/057bf3d086744255e7f7bc5ca860f437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HnEHY8glMiep3Ex3pMX2FQ.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">这是完全可以接受的，但是比析构时间长，出错的机会多。你打电话。</figcaption></figure><p id="208c" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">这两个都是Igor  的<strong class="lc ir"> <em class="lb">配方，但是析构是一种更紧凑的形式，具有更少的重复文本和更少的出错机会。这提出了Typescript中的一个重要原则。通常，最短的代码是最好的，因为每段代码都有潜在的错误——甚至是简单的打字错误或顺序错误，很难发现。任何时候，只要我们能构思出代码更少的设计，就能减少可能出错的代码。最终，Typescript是给人类阅读的(计算机使用<a class="ae mb" href="https://en.wikipedia.org/wiki/Machine_code" rel="noopener ugc nofollow" target="_blank">机器语言</a>)，所以编写你最容易阅读和推理的代码。</em></strong></p><p id="c42c" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">如果我们不需要给变量起一个新名字，我们可以写一个更短的对象析构版本:</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/baac8f1a814b4f9b5e711cb37a8b989d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*3CHGaUsSFwFBKmKLBAHQpw.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">要创建与对象键同名的变量，只需析构你想要的键。</figcaption></figure><p id="c7b5" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">如果我们只写键名，我们就创建了一个同名的变量。您可以根据需要从对象中获取任意数量的关键点。只有当你想为新变量取一个不同的名字时，才需要使用<code class="fe ms mt mu mv b">:newName</code>语法(见第30–31行)。析构还有许多其他强大的特性，我们将在另一篇文章中探讨。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/12f86a4bef015ab7fc53e35e385d6518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pRVeGH-nu2bDmMsF"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">今天，埃菲尔铁塔的客人们乘坐的是由<a class="ae mb" href="https://en.wikipedia.org/wiki/Elisha_Otis" rel="noopener ugc nofollow" target="_blank"> Elisha Otis </a>为1899年世界博览会<a class="ae mb" href="https://en.wikipedia.org/wiki/Exposition_Universelle_(1889)" rel="noopener ugc nofollow" target="_blank">开幕式设计的电梯</a>。令人惊讶的是，这些漂亮的汽车在弯曲、倾斜的轨道上行驶。CSS也能够在web组件设计中承担一些重要的“重担”。</figcaption></figure><h1 id="b858" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">让CSS来做繁重的工作</h1><p id="768e" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">CSS拥有惊人数量的能力。其中一个是渐变，MDN有一个<a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images/Using_CSS_gradients" rel="noopener ugc nofollow" target="_blank">很棒的介绍</a>。</p><p id="d03b" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">让我们的新渐变组件输出两个色卡——起始色和结束色。在两者之间，我们将绘制渐变框。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/a4e5df629e1a085b167935f09195b6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YneIJwnncAs8rcV4pOU6NA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">顶部和底部的<strong class="bd ka"> &lt; dta-chip &gt; </strong>元素(黄色)具有<strong class="bd ka">开始</strong>和<strong class="bd ka">结束</strong>属性。中间的<strong class="bd ka"> &lt;格&gt; </strong>从<strong class="bd ka"> ${startHex} </strong>和<strong class="bd ka"> ${endHex} </strong>(蓝色)绘制渐变。</figcaption></figure><p id="ad15" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">我们需要开始和结束键(芯片)和十六进制值(梯度)。多亏了析构赋值，我们可以插入这些变量。渐变本身是相当容易阅读的，即使我们不知道CSS。</p><p id="99d8" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">易于阅读是析构的另一个好处(通常也是好的命名)。我们可能不知道第35行CSS渐变中参数的顺序，但我们可以阅读<code class="fe ms mt mu mv b">${startHex}</code>并知道它代表什么。</p><p id="3cc9" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">这个新组件的一半是<strong class="lc ir">我们的另一个组件</strong>，被重用。目的从名字就很明显:<code class="fe ms mt mu mv b">&lt;dta-chip&gt;</code>。对人类来说，阅读<code class="fe ms mt mu mv b">${startHex}</code>和<code class="fe ms mt mu mv b">&lt;dta-chip&gt;</code>比阅读它们所代表的代码更容易。随着你的程序变得越来越复杂，这种想法会变得更加有益。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/a1567aa6d8460ab05bc64fb82c635077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*UJYGIqjRieApLMJwgX5TKQ.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">通过一点CSS，开始和结束芯片之间的渐变会呈现得很好。</figcaption></figure><h1 id="6179" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">而且还管用！</h1><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/0daf4976293d9ee9833f74dde9d160f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xgq7HBZGZp2xxoiyhFfu7w.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">我们的渐变和调色板组件使用相同的<strong class="bd ka"> dta.colors </strong>对象，并且都呈现了我们的自定义<strong class="bd ka"> &lt; dta-chip &gt; </strong>的多个实例。</figcaption></figure><p id="73c9" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">我可以通过在<code class="fe ms mt mu mv b">dta-page.ts</code>中添加那个键和一些内容，将这个渐变重构为一个<code class="fe ms mt mu mv b">palette</code>页面。内容只是我的新渐变组件的几个实例！然后，我可以在浏览器中单独访问该页面。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/c278dde13b24084a07090d7b698ad9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVGWnl3hVw1PWwzT-ngnRA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">添加带有三种渐变的新调色板页面。</figcaption></figure><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/02265820eee7d42f0b712cd712ca6bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsWPIa1yY2nS0JUIPPsBWA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">使用<strong class="bd ka"> /palette </strong> URL访问浏览器中的调色板页面，显示代码中定义的三种渐变。</figcaption></figure><h1 id="3da4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">那都是乡亲们！</h1><p id="2689" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">那么，我们取得了什么成就？在本系列中，我们已经看到了用web组件学习Typescript的几种方法。所有这些都是围绕首先设计数据模型(JSON对象和数组的组合)的思想构建的。然后，我们传递带有属性的模型部分，以从组件视图内部访问数据。通过在Typescript和Lit中组合数组和对象的特殊属性，我们可以用最少的重复代码创建复杂的UI元素集。最后，我们可以在这些组件的内部和外部定义自定义函数，使我们的代码更容易阅读和调试。</p><p id="5070" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated">下次见，感谢阅读！</p><p id="6b83" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk ly lm ln lo lz lq lr ls ma lu lv lw lx ij bi translated"><em class="lb"> — D </em></p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><h2 id="9269" class="or jz iq bd ka os ot dn ke ou ov dp ki ly ow ox km lz oy oz kq ma pa pb ku pc bi translated">分级编码</h2><p id="7ed6" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk ly me ln lo lz mf lr ls ma mg lv lw lx ij bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae mb" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>。<br/>跟随:<a class="ae mb" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank"> Twitter </a>，<a class="ae mb" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>，<a class="ae mb" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">迅</a> <br/>升一级就是转型科技招聘👉<a class="ae mb" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>