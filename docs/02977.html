<html>
<head>
<title>Bubble Sort Algorithm 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">冒泡排序算法101</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/bubble-sort-algorithm-101-b1864d5b509f?source=collection_archive---------11-----------------------#2020-04-13">https://levelup.gitconnected.com/bubble-sort-algorithm-101-b1864d5b509f?source=collection_archive---------11-----------------------#2020-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f6dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用JavaScript实现<strong class="jp ir"> <em class="kl">冒泡排序算法</em> </strong>的简单指南。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4c64b3d976853c98ad4c7feb75da0745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pVdo6RCswCqtJTK6"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@sharonmccutcheon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">莎伦·麦卡琴</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h2 id="d976" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">什么是冒泡排序算法(BSA)？</h2><p id="157c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl"> BSA </em> </strong>是理解和实现起来相对简单的算法。<strong class="jp ir"> <em class="kl">它的设计目的是对一组未排序的数字进行排序。不幸的是，它不是一个特别有效的排序算法，并且很少(如果曾经)在企业级代码中使用。</em></strong></p><h2 id="226a" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">它是如何工作的？</h2><p id="8994" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl"> BSA </em> </strong>的工作原理是将数组中的每个元素与其紧邻元素进行比较，以确定哪个元素更大。两个元素中较大的一个在右边，较小的一个在左边。重复该过程，直到整个阵列被排序并且不再发生交换。</p><p id="ddfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个非常棒的可视化过程(只需点击页面顶部的气泡排序按钮就能看到它的工作):</p><div class="mb mc gp gr md me"><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">比较排序可视化</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">编辑描述</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">www.cs.usfca.edu</p></div></div></div></a></div><p id="c4f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个很好的逐步说明，您可以按照自己的步调来执行:</p><div class="mb mc gp gr md me"><a href="https://www.hackerearth.com/practice/algorithms/sorting/bubble-sort/visualize/" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">冒泡排序可视化|排序|算法|黑客地球</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">关于冒泡排序的详细教程，以提高您对{{ track }}的理解。也尝试练习问题来测试&amp;…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">www.hackerearth.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms kw me"/></div></div></a></div></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="23c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，希望您对<strong class="jp ir"> <em class="kl"> BSA </em> </strong>的样子以及它如何对一个数字列表或数组进行排序有一个很好的了解。现在让我们深入研究这个算法的一个基本例子，使用一个JavaScript数组来巩固这个概念。</p><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="8050" class="ld le iq nb b gy nf ng l nh ni"><strong class="nb ir">let unsortedArray = [2,5,4,3];</strong></span><span id="644e" class="ld le iq nb b gy nj ng l nh ni"><strong class="nb ir">// Start bubble sort algorithm<br/>1. Is 2 &gt; 5<br/>2. No, so move to the next element in the array<br/>3. Is 5 &gt; 4<br/>4. Yes, so swap the elements<br/>5. Updated array --&gt; [2,4,5,3];<br/>6. Restart the process<br/>7. Is 2 &gt; 4<br/>8. No, so move to the next element in the array<br/>9. Is 4 &gt; 5 <br/>10. No, so move to the next element in the array<br/>11. Is 5 &gt; 3<br/>12. Yes, so swap the elements<br/>13. Updated array --&gt; [2,4,3,5]<br/>14. Restart the process<br/>15. Is 2 &gt; 4<br/>16. No, so move to the next element in the array<br/>17. Is 4 &gt; 3<br/>18. Yes, so swap the elements<br/>19. Updated array --&gt; [2,3,4,5]<br/>20. Restart the process<br/>21. We run through each comparison again and no swaps are made,<br/>    therefore we have a sorted array</strong></span></pre><blockquote class="nk nl nm"><p id="c767" class="jn jo kl jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated"><strong class="jp ir">挑战#1:使用上面的步骤自己实现一个BSA！</strong></p></blockquote></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="17af" class="nq le iq bd lf nr ns nt li nu nv nw ll nx ny nz lo oa ob oc lr od oe of lu og bi translated">履行</h1><p id="ef8b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">好了，这是你们期待已久的时刻！下面是一个<strong class="jp ir"> <em class="kl"> BSA </em> </strong>在JavaScript中的两个实现，一个使用<strong class="jp ir"> <em class="kl">递归</em> </strong>另一个使用<strong class="jp ir"> <em class="kl">迭代</em> </strong>。</p><h2 id="00ec" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">但是我们首先需要的是一个<strong class="ak"> <em class="oh">交换函数</em> </strong>，它将帮助我们在满足特定条件时移动数组中的元素。</h2><h2 id="e914" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">交换功能</h2><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="0c11" class="ld le iq nb b gy nf ng l nh ni"><strong class="nb ir"><br/></strong>// swap the elements at the first and second index given<strong class="nb ir"><br/>const swap = (arr, first, second) =&gt; {<br/>  let temp = arr[first];<br/>  arr[first] = arr[second];<br/>  arr[second] = temp;<br/>};</strong></span></pre><h2 id="f9de" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">冒泡排序(递归)</h2><p id="5de7" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">让我们来看看这里发生了什么:</p><ol class=""><li id="4559" class="oi oj iq jp b jq jr ju jv jy ok kc ol kg om kk on oo op oq bi translated">虚拟检查，如果数组只有一个元素，它的排序。</li><li id="56a5" class="oi oj iq jp b jq or ju os jy ot kc ou kg ov kk on oo op oq bi translated">创建一个默认设置为false的检查变量</li><li id="e4f8" class="oi oj iq jp b jq or ju os jy ot kc ou kg ov kk on oo op oq bi translated">遍历数组。如果第一个元素大于下一个相邻的元素，交换它们并将check改为true</li><li id="e9b1" class="oi oj iq jp b jq or ju os jy ot kc ou kg ov kk on oo op oq bi translated">循环完成后，如果check仍然为false，这意味着没有进行交换，并且数组已排序，则返回数组</li><li id="009a" class="oi oj iq jp b jq or ju os jy ot kc ou kg ov kk on oo op oq bi translated">如果check为真，则发生交换，我们再次运行bubbleSortRecursive()，直到数组排序完毕</li></ol><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="016b" class="ld le iq nb b gy nf ng l nh ni"><strong class="nb ir">const bubbleSortRecursive = (array) =&gt; {</strong></span><span id="e1d5" class="ld le iq nb b gy nj ng l nh ni">  // Dummy check for single element in the array<strong class="nb ir"><br/>  if (array.length &lt;= 1) return array;</strong></span><span id="219a" class="ld le iq nb b gy nj ng l nh ni"><strong class="nb ir"> </strong> // Boolean represents whether elements in the array have <br/>  // been swapped<br/>  <strong class="nb ir">let check = false;</strong></span><span id="ec5d" class="ld le iq nb b gy nj ng l nh ni"><strong class="nb ir">  </strong>// Run through array and swap elements if second element <br/>  // is greater than the first<strong class="nb ir"><br/>  for(let i = 0; i &lt; array.length; i++) {<br/>    if (array[i + 1] &lt; array[i]) {<br/>      swap(array, i, i + 1);<br/>      check = true<br/>    }<br/>  };</strong></span><span id="e165" class="ld le iq nb b gy nj ng l nh ni">  // If the elements haven't been swap the array is <br/>  // sorted, return array<br/>  // else recursively call bubbleSortRecursive()<br/>  <strong class="nb ir">if (!check) {<br/>    return array<br/>  } else {<br/>    return bubbleSortRecursive(array);<br/>  }<br/>};</strong></span></pre><p id="a4a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘭！一个漂亮、干净的递归实现！</p><h2 id="c195" class="ld le iq bd lf lg lh dn li lj lk dp ll jy lm ln lo kc lp lq lr kg ls lt lu lv bi translated">冒泡排序(迭代)</h2><p id="4d0c" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这是上面函数的迭代版本。逻辑有点复杂，所以让我们一起来看一下:</p><ol class=""><li id="b172" class="oi oj iq jp b jq jr ju jv jy ok kc ol kg om kk on oo op oq bi translated">创建一个停止变量，该变量将根据外部循环运行的次数进行更新，并缩短内部循环扫描的数组的距离。<strong class="jp ir"> <em class="kl">为什么会这样？</em> </strong>因为<strong class="jp ir"> <em class="kl"> BSA </em> </strong>总是把最大的元素推到数组末尾。所以在我们第一次迭代之后，最大的数字已经在数组的末尾了。我们可以从未来的扫描中消除它，以降低时间复杂度并创建有效的退出条件。</li><li id="1a1a" class="oi oj iq jp b jq or ju os jy ot kc ou kg ov kk on oo op oq bi translated">我们在外部循环中遍历整个数组来检查每个元素。</li><li id="a550" class="oi oj iq jp b jq or ju os jy ot kc ou kg ov kk on oo op oq bi translated">对于每个外部循环，我们运行一个内部循环来执行相邻元素的实际比较。如果第一个元素大于下一个元素，使用<strong class="jp ir"> <em class="kl">交换功能</em> </strong>就地交换它们。</li><li id="c19f" class="oi oj iq jp b jq or ju os jy ot kc ou kg ov kk on oo op oq bi translated">一旦整个过程完成，返回排序后的数组。</li></ol><pre class="kn ko kp kq gt na nb nc nd aw ne bi"><span id="09b2" class="ld le iq nb b gy nf ng l nh ni"><strong class="nb ir">const bubbleSort2 = (array) =&gt; {</strong></span><span id="6476" class="ld le iq nb b gy nj ng l nh ni"><strong class="nb ir">  </strong>// Initialize a stop variable that will be used as<br/>  // the stopping point for the inner loop.<br/>  // Once an inner cycle is complete, the last variable <br/>  // will become the largest number in the array.<br/>  // We can therefore ignore it and leave it in place, <br/>  // and shorten the area our loop scans during the next<br/>  // iteration. Hence the array.length - i;</span><span id="cbe9" class="ld le iq nb b gy nj ng l nh ni"><strong class="nb ir">  let stop;</strong></span><span id="9749" class="ld le iq nb b gy nj ng l nh ni"><strong class="nb ir">  for (let i = 0; i &lt; array.length; i++) {<br/>    for (let j = 0, stop = array.length - i; j &lt; stop; j++) {<br/>      if (array[j] &gt; array[j + 1]){<br/>        swap(array, j, j + 1);<br/>      }<br/>    }<br/>  };<br/>  return array;<br/>};</strong></span></pre><h1 id="19db" class="nq le iq bd lf nr ow nt li nu ox nw ll nx oy nz lo oa oz oc lr od pa of lu og bi translated">结论</h1><p id="d5bf" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">太好了，我们又完成了另一个算法教程，干得好。</p><p id="4c2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些对<strong class="jp ir"><em class="kl"/></strong>BSA的<strong class="jp ir"> <em class="kl">时间复杂度</em> </strong>感兴趣的人，准备好失望吧…对于<strong class="jp ir"> <em class="kl"> BSA </em> </strong>来说，最好的情况是<strong class="jp ir"> O(n) </strong>并且它可能变得更糟，当未排序的数组前端加载所有最大的数，后端加载所有</p><p id="2865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很有可能你永远不会在产品级代码中使用这种算法，但是知道这一点是很好的，并且肯定会在初级开发人员的技术面试中有所帮助。</p><p id="8d58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有几个很好的资源可供选择的解释，对于那些想深入研究的人来说:</p><p id="4834" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">一篇关于气泡排序的伟大文章由</strong> <a class="ae lc" href="https://medium.com/@kylejensen" rel="noopener"> <strong class="jp ir">凯尔·詹森</strong> </a> <strong class="jp ir"> — </strong></p><div class="mb mc gp gr md me"><a href="https://medium.com/javascript-algorithms/javascript-algorithms-bubble-sort-3d27f285c3b2" rel="noopener follow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">Javascript算法—冒泡排序</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">Javascript算法系列中的下一个算法是冒泡排序。像插入排序一样，冒泡排序是一种比较…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">medium.com</p></div></div><div class="mn l"><div class="pb l mp mq mr mn ms kw me"/></div></div></a></div><p id="a758" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">一篇关于冒泡排序的惊人清晰的维基百科文章— </strong></p><div class="mb mc gp gr md me"><a href="https://en.wikipedia.org/wiki/Bubble_sort" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">冒泡排序</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">冒泡排序，有时也称为下沉排序，是一种简单的排序算法，它重复遍历…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">en.wikipedia.org</p></div></div><div class="mn l"><div class="pc l mp mq mr mn ms kw me"/></div></div></a></div></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="3059" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常感谢您的阅读，如果您想要上面的完整代码库，请查看我的Github Repo并尝试我的实现:</p><div class="mb mc gp gr md me"><a href="https://github.com/twjsanderson/bubbleSortAlgo" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">twjsanderson/bubbleSortAlgo</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">在GitHub上创建一个帐户，为twjsanderson/bubbleSortAlgo的开发做出贡献。</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">github.com</p></div></div><div class="mn l"><div class="pd l mp mq mr mn ms kw me"/></div></div></a></div><p id="bce1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">好好玩，继续编码！</em>T3】</strong></p></div></div>    
</body>
</html>