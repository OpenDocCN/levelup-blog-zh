<html>
<head>
<title>Golang GUI Client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang GUI客户端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/golang-gui-client-6b0edbfb0875?source=collection_archive---------9-----------------------#2020-03-29">https://levelup.gitconnected.com/golang-gui-client-6b0edbfb0875?source=collection_archive---------9-----------------------#2020-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="74ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这个场景需要一个桌面应用客户端</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b6cda61c18359087a3942c55bebf201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OzfyUa7_tl-OnI5-"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>拍摄的照片</figcaption></figure><h2 id="d9dc" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">AccTrakII</h2><p id="ea9a" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">该项目名为AccTrakII，是一个服务器应用程序，带有一个PostgreSQL数据库来跟踪用户活动。最初的用户界面需要在桌面上点击一个图标来发送一个RESTful API调用到服务器。尽管最终会包含通过JSON的确认，但是不需要处理服务器响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/4710c457ae6b0dba1efb6f370969326a.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*eIt99LzeumGIzkRisHS5Hg.png"/></div></figure><p id="2e48" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">最初的想法是有一个发送API调用的桌面图标集合。这在Linux桌面上运行良好。服务器应用尽职尽责地收集和处理输入。通过一个可下载的bash脚本，可以轻松实现生成和刷新桌面图标的功能。这个脚本删除了旧的图标，并放置了新的图标。每个图标代表用户的一项活动或任务。常见的活动或任务有电子邮件、会议、午餐、茶歇、编码、测试，</p><p id="6737" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">虽然这在Linux机器上可以工作，但MacOS或Windows的用户可能不会觉得这么方便。讨论了关于小型桌面客户机开发工作的各种建议。作为Golang的支持者，我考虑对我为测试目的开发的命令行客户端进行一些改进。这个客户端运行在本地桌面上，发送RESTful API调用来模拟用户与服务器的交互。易于管理、操作和处理。没有混乱，没有大惊小怪。它做了它应该做的事情。</p><h2 id="e80e" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Guitrak客户端</h2><p id="223e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">现在，我如何将这个想法变成应用程序的一个更完整的开发部分呢？我不得不考虑如何实现这一点的一些新的方面。要做的第一件事是命名这个新客户。因为这是我和我的决定，我给她取名为吉特拉克。虽然有许多不同的方法和技术可以用来支持我对基于Golang的方法的坚持，但这意味着我必须拥有某种Golang GUI工具包。快速搜索发现了这条线索。Io库。这看起来是我需要开始的所有东西，并承诺对Android和iOS移动工作都有用。除了几个网页之外，我没有做过很多GUI工作，也不认为自己有任何艺术才能。尽管如此，我还是想尝试一下，看看能做些什么。</p><h2 id="d400" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">要求</h2><p id="f4b1" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">当然，我们希望从几个要求开始。guitrak的更新应该来自服务器，所以每次用户登录到客户端应用程序时，它都会查询服务器来更新用户的任务列表。用户场景是这样陈述的，她将打开guitrak作为开始工作的第一件事，并且随着工作日的展开，向服务器发送关于正在工作的任务或活动的事件。服务器应用程序将这些事件保存到Postgres数据库中，用于发票创建和计费。不是每个任务都是收费的。服务器计算每项任务花费的时间，并生成报告供管理层和主要开发人员使用。</p><p id="7804" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">这里是用Fyne.io库创建的登录窗口的截图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/4710c457ae6b0dba1efb6f370969326a.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*eIt99LzeumGIzkRisHS5Hg.png"/></div></figure><p id="93c6" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">许多提到的任务可以从应用程序网页上执行。例如添加、删除和更新新任务。guitrak很难完成这项工作，因此推迟了这项工作。此时，使用Fyne在Go中构建初始GUI客户端就足够了。Io库。Guitrak必须提供登录userid和pwd，以便向服务器进行身份验证。更新的例程将从服务器下载用户分配的任务，这些任务也基于用户被分配到一个或多个项目。预计guitrak应用程序将在用户的桌面上保持打开，并方便地允许用户单击代表先前分配的任务的按钮，以跟踪在每个任务上花费的时间。</p><p id="c638" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">成功登录后，该窗口为用户显示从服务器检索的所有任务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/e18bea08dad30e3fd532bc958028d18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*LK3Rvuiny0rjkKaYcqBfKA.png"/></div></figure><p id="c8d6" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">这个任务列表反映了我的个人任务和我一直从事的开发活动。这就要求guitrak屏幕能够容纳可变数量的任务，并以某种方式显示所有这些任务，以便了解哪个按钮与哪个任务相关，并尽可能方便地点击按钮，从而开始跟踪新的活动。指出哪个任务当前是“活动的”任务并显示这种情况已经持续了多长时间也是有帮助的。为了避免潜在的“失控”活动，如果持续时间超过50分钟，guitrak应用程序应该向任何正在进行的“活动”任务发出信号。50分钟后，短暂的休息是合适的，或者用户可以重置计时器并继续进行相同的任务。</p><p id="141c" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">时钟显示显示任务的活动时间和注销按钮，并且随着开发的进展，可能会在以后添加暂停功能。</p><p id="9cfd" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">我发现Fyne.io库非常容易使用，他们的文档写得很好，也很容易使用。</p><p id="2baf" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">下面是显示初始登录窗口和字段的窗口代码。请注意，submit按钮实际上调用了authenticate func，如果成功，将显示tasks窗口。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="8ed3" class="kz la it mw b gy na nb l nc nd">myApp := app.New()<br/>if !authenticated {<br/>   myWindow := myApp.NewWindow("VBox Layout")<br/>   myWindow.SetTitle("Guitrak Client Login")<br/>   uidLabel := widget.NewLabel("User ID")<br/>   uidText := widget.NewEntry()<br/>   uidText.SetPlaceHolder("ivank2139@gmail.com")<br/>   row1 := fyne.NewContainerWithLayout(layout.NewHBoxLayout())<br/>   row1.AddObject(uidLabel)<br/>   row1.AddObject(uidText)<br/><br/>   row2 := fyne.NewContainerWithLayout(layout.NewHBoxLayout())<br/>   pwdLabel := widget.NewLabel("Password")<br/>   pwdText := widget.NewPasswordEntry()<br/>   row2.AddObject(pwdLabel)<br/>   row2.AddObject(pwdText)<br/><br/>   row3 := fyne.NewContainerWithLayout(layout.NewHBoxLayout())<br/>   authLabel := widget.NewLabel("Authenticate")<br/>   authButton := widget.NewButton("Submit", func() {<br/>      log.Info.Println("auth func()")<br/>      authenticated = true<br/>      myWindow.Hide()<br/>      go showTasks(myApp)<br/>   })<br/>   row3.AddObject(authLabel)<br/>   row3.AddObject(authButton)<br/><br/>   vbox := fyne.NewContainerWithLayout(layout.NewVBoxLayout(), row1, row2, row3)<br/>   myWindow.SetContent(vbox)<br/>   myWindow.ShowAndRun()<br/>}</span></pre><p id="4758" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">该窗口包括几个嵌套的容器，第1-3行是水平的方框布局。</p><p id="a9ce" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">“任务”窗口以单选按钮阵列的形式列出了22项任务。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="3f0c" class="kz la it mw b gy na nb l nc nd"><em class="ne">//myApp := app.New()<br/></em>myWindow := a.NewWindow("Tasks")<br/>myWindow.SetTitle("Guitrak Client")<br/>updateTasks("1")<br/>rt := []string{}<br/>for _, task := range tasks {<br/>   rt = append(rt, task.Name)<br/>}<br/>radio := widget.NewRadio(rt, func(value string) {<br/>   log.Info.Println("Radio set to", value)<br/>   changeActivity(value)<br/>})<br/><em class="ne">//taskLabel := widget.NewLabel("Tasks")<br/></em>vbox := fyne.NewContainerWithLayout(layout.NewVBoxLayout(), radio)<br/>myWindow.SetContent(vbox)<br/>myWindow.Show()</span></pre><p id="117e" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">对服务器进行RESTful调用来检索用户分配的任务运行得相当好。这是API和处理程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">API和处理程序</figcaption></figure><p id="53ec" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">我惊喜地发现只用Golang创建一个最小的GUI是多么容易。根据Fyne.io文档，这个客户端可以编译成Android和iOS。因此，我将能够提供移动和桌面版本的客户端。</p><p id="b9e9" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在生产就绪之前，还有相当多的工作要做，但在这一点上，只是有很多工作，但没有什么是真正未知或不太了解的。服务器和客户端都需要更多的努力来完成它们，但这至少表明原型不仅是可行的，而且很有趣。</p><p id="6fcf" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">我还没有展示认证细节。我真的很想使用第三方提供商的OAuth，如谷歌，脸书，Github和其他人，以及作为最后手段的用户id，电子邮件和密码。我还要指出，服务器是启用https的，我在guitrak客户机中使用了一个简单的设置来信任服务器的自签名证书，这样客户机就不会抱怨了。</p></div></div>    
</body>
</html>