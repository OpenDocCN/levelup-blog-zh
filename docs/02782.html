<html>
<head>
<title>What exactly is a Closure in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的闭包到底是什么？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-exactly-is-a-closure-in-javascript-1dc6b5e6e375?source=collection_archive---------9-----------------------#2020-04-04">https://levelup.gitconnected.com/what-exactly-is-a-closure-in-javascript-1dc6b5e6e375?source=collection_archive---------9-----------------------#2020-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ed0919b74da0fe6be0c96004e295ef2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RGV84Axp7uPlsS3i"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">凯文·Ku在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1a8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">我相信每个接触JavaScript很短时间的人都一定听说过'</em> <strong class="ki iu"> <em class="le">闭包</em> </strong> <em class="le">'这个术语。在这篇文章中，我将尝试揭示关于闭包的一切，但不会频繁使用这个术语:)</em></p><p id="0738" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑下面的代码:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8f1a" class="lo lp it lk b gy lq lr l ls lt">1- function greeting(){</span><span id="cb45" class="lo lp it lk b gy lu lr l ls lt">2- var message="Hello World";</span><span id="9f33" class="lo lp it lk b gy lu lr l ls lt">3- return message; }</span><span id="98ab" class="lo lp it lk b gy lu lr l ls lt">4- const message=greeting();</span></pre><p id="4dd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">那么，当上面的代码执行时，会发生什么呢？</em></p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lv"><img src="../Images/e3256d6979974c4dc5dc44d8440d80dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MLxs6TL0zfIwzp0u9fOfYQ.jpeg"/></div></div></figure><p id="e061" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">让我们介绍一些有助于我们追踪上面这段代码的字符。:)</em></p><p id="a12f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">执行线程:</strong>为了简单起见，假设这个人会一行一行地检查我们的代码并执行。</p><blockquote class="lw lx ly"><p id="ec22" class="kg kh le ki b kj kk kl km kn ko kp kq lz ks kt ku ma kw kx ky mb la lb lc ld im bi translated">好了，当我们的朋友“执行线程”在第一行时，会发生什么呢？ </p></blockquote><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/60a55ed2badf646ac5b7b2f3e49dcd33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ICHBdvQo9H14_Ggj01cBgA.jpeg"/></div></div></figure><ul class=""><li id="74f8" class="md me it ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated">执行线程从第1行开始，找到关键字'<strong class="ki iu"> function' </strong></li><li id="32b1" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">它将创建一个名为“<em class="le">问候</em>的标签，并将整个函数存储在<strong class="ki iu">全局内存</strong>中</li><li id="30ad" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">现在，执行线程跳过函数内部的代码，转到下一行。</li><li id="330c" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">因此，在我们的例子中,“执行线程”将跳过第2行和第3行，到达第4行。</li></ul><blockquote class="lw lx ly"><p id="1d14" class="kg kh le ki b kj kk kl km kn ko kp kq lz ks kt ku ma kw kx ky mb la lb lc ld im bi translated">好了，现在我们的朋友在第四排。现在怎么办？？？？？？</p></blockquote><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/500a8f8d5a3f50685653ace7d8bc4271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGempvWV6qZMLYbgr5FfsA.jpeg"/></div></div></figure><ul class=""><li id="99ac" class="md me it ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated">我们的朋友，'<strong class="ki iu">执行</strong> <strong class="ki iu">线程</strong>'找到标签名为' message '的关键字const。</li><li id="f1e6" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">他很清楚自己在<strong class="ki iu">全局内存</strong>中分配新内存空间的责任。</li><li id="1de2" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">目前，我们的朋友不确定这个标签中会存储什么值。</li><li id="ee51" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">我们的朋友现在在问候后会看到“()”符号。</li></ul><blockquote class="lw lx ly"><p id="2f47" class="kg kh le ki b kj kk kl km kn ko kp kq lz ks kt ku ma kw kx ky mb la lb lc ld im bi translated"><strong class="ki iu"><em class="it"/></strong>每当我们的朋友看到“函数调用”或俗称的“调用函数”时，他都很清楚自己需要做什么</p></blockquote><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mr"><img src="../Images/ec23facdfa47f49fc65d62ada30afdc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PX9IhxRFF6NZLMt7E8mtkQ.jpeg"/></div></div></figure><ul class=""><li id="b575" class="md me it ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated">是时候介绍我们的新朋友'<strong class="ki iu">调用堆栈'</strong>了，它也被称为<strong class="ki iu">、【执行堆栈】、</strong>或<strong class="ki iu">程序堆栈。</strong></li><li id="1143" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">调用堆栈用于几个相关的目的，但使用它的主要原因是为了跟踪每个活动函数在完成执行时应该返回控制的点。</li><li id="9ca5" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">因此，我们的问候函数被推入调用堆栈，并创建了一个新的'<strong class="ki iu">执行上下文'</strong>'，现在我们的老朋友'<strong class="ki iu">执行线程'</strong>'被困在这个全新的世界中。</li><li id="9b56" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">我们的朋友不知道如何走出这个新世界。所以，他开始做他擅长的事情。(<strong class="ki iu"> <em class="le">逐行读取代码并执行</em> </strong> <em class="le"> ) </em></li></ul><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lv"><img src="../Images/d1946b04e21b35a2b236e27f0e678cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5TiBXWWRzztFfAQI0RRpQ.jpeg"/></div></div></figure><ul class=""><li id="8c92" class="md me it ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated">因此，我们的朋友将标签为<em class="le">‘消息’</em>的变量存储在我们的“<strong class="ki iu">执行上下文”</strong>的<strong class="ki iu">‘本地内存’</strong>中</li><li id="deeb" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">现在，<strong class="ki iu">'执行线程'</strong>到达第3行，找到一个<em class="le">'</em><strong class="ki iu"><em class="le">return '</em></strong><em class="le">关键字。</em></li><li id="0740" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">我们的朋友检查他是否认识标签为“<em class="le">消息</em>的人。他首先检查执行上下文的'<strong class="ki iu">本地存储器'</strong>'内部。</li><li id="1612" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">他找到了它，并高兴地将值返回给我们的“<strong class="ki iu">全局范围”中的“消息”标签。</strong></li></ul><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/16c5ee84e36811bb72fce67940e8dd0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*swLid1V5mLaH1bRioWPGMQ.jpeg"/></div></div></figure><ul class=""><li id="f207" class="md me it ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated">结果，“问候”从“<strong class="ki iu">调用堆栈”</strong>中弹出</li></ul><h1 id="0ef6" class="mt lp it bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">最后，“执行上下文”被破坏</h1><blockquote class="lw lx ly"><p id="1788" class="kg kh le ki b kj kk kl km kn ko kp kq lz ks kt ku ma kw kx ky mb la lb lc ld im bi translated">你可能会想:</p><p id="15b8" class="kg kh le ki b kj kk kl km kn ko kp kq lz ks kt ku ma kw kx ky mb la lb lc ld im bi translated">“好了，足够的‘炫耀’了，但是鸭子在哪里才是‘终结’呢？这是正常函数的执行方式！！</p><p id="43c8" class="kg kh le ki b kj kk kl km kn ko kp kq lz ks kt ku ma kw kx ky mb la lb lc ld im bi translated"><strong class="ki iu"> <em class="it">耶耶！！我知道你们都很聪明，已经知道了这一切。但是坚持住，伙计们，这将是我接下来解释闭包的基础:)</em> </strong></p></blockquote><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="91c9" class="lo lp it lk b gy lq lr l ls lt">Let us take a bit more complex code now:</span><span id="aff6" class="lo lp it lk b gy lu lr l ls lt">1- function IamaSimpleFunction(){<br/>2-     var message="Hello everyone!";<br/>3-  function greeting(){<br/>4-       return message;<br/>     }<br/>5- return greeting;<br/>}<br/>6- const greetEveryOne=IamaSimpleFunction();<br/>7- greetEveryOne();</span></pre><p id="ef4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，让我们开始追踪我们的'<strong class="ki iu">不那么简单的函数':)</strong></p><ul class=""><li id="a9be" class="md me it ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated">我们将再次需要我们的朋友'<strong class="ki iu">执行线程'</strong>的帮助</li><li id="ef63" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">执行线程开始逐行读取我们的代码。在第1行，它遇到了关键字'<strong class="ki iu"> function '。</strong>像往常一样，它转到<strong class="ki iu">‘全局内存’</strong>，内存被分配给名为’<strong class="ki iu">IamaSimpleFunction’</strong>的函数</li><li id="6998" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">它现在将跳过第2、3、4和5行，转到第6行。它创建了一个存储'<strong class="ki iu"> greetEveryOne' </strong>的内存空间，但是像往常一样，他现在不知道在这个标签中存储什么:(</li><li id="c40d" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">现在，它看到了函数的执行。创建一个新的<strong class="ki iu">‘执行上下文’</strong>，并将其推入到<strong class="ki iu">调用栈中</strong></li><li id="4ab0" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">现在'<strong class="ki iu">执行线程'</strong>将值' Hello everyone '存储在'<strong class="ki iu">本地内存'</strong>内的标签消息中，如我们在前面的示例中所讨论的。</li><li id="5b1f" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">类似地，在第3行<strong class="ki iu">上，函数‘问候’</strong>也存储在我们的’<strong class="ki iu">执行上下文’</strong>的本地内存中</li><li id="25e3" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">现在在下一行'<strong class="ki iu"> return' </strong>就在那里。执行线程在本地存储器中检查他是否找到任何名为“greeting”的东西。</li><li id="dcef" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">它将存储的值(函数)返回到存储在'<strong class="ki iu">全局内存' ' greetEveryOne <em class="le">'中的标签。</em> </strong></li><li id="bf97" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">现在，我最喜欢的部分来了。</li></ul><h1 id="48b5" class="mt lp it bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">摧毁一切！！！！</h1><p id="20dd" class="pw-post-body-paragraph kg kh it ki b kj nq kl km kn nr kp kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated"><strong class="ki iu">‘执行上下文’</strong>被破坏，随之其本地内存也被破坏。该函数从“CallStack”中弹出。</p><h1 id="3229" class="mt lp it bd mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np bi translated">好了，有趣的部分来了。你认为输出是什么？？？？</h1><p id="3a72" class="pw-post-body-paragraph kg kh it ki b kj nq kl km kn nr kp kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">一些合理的推理。我会想出类似这样的东西</p><p id="1a32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">“是的，所以函数‘IamaSimpleFunction’被返回，它的</em> <strong class="ki iu"> <em class="le">执行上下文</em> </strong> <em class="le">被销毁，随之，它的本地内存中的所有内容也被销毁。简单来说，就是将</em> <strong class="ki iu"> <em class="le">未定义</em> </strong> <em class="le">或某些错误与</em> <strong class="ki iu"> <em class="le">消息</em> </strong> <em class="le">【变量未找到】</em></p><p id="e1f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，出乎所有人意料的是，输出是:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="133f" class="lo lp it lk b gy lq lr l ls lt"><strong class="lk iu">Hello everyone!</strong></span></pre><p id="ea05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的，我知道我知道你对这个很着迷！！！</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e60ebe6fdae9d290faf60650674c62ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/1*--i046dqvNoy9QWiiT6dig.gif"/></div></figure><p id="643d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，别闹了！！让我们解开这个输出背后的谜团。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/7cf48b28ba1b21483cc27b77c7c79bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gFHL5ZdsRRELC0R29tNxiA.jpeg"/></div></div></figure><ul class=""><li id="4f6a" class="md me it ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated">因此，在返回“greeting”时，检查它是否需要来自当前“<strong class="ki iu">当前词法范围”</strong>(代码驻留的地方)的任何东西在我们的例子中，“greeting”在函数“IamaSimpleFunction”内部</li><li id="da95" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">因此，它将所有东西打包在一个名为'<strong class="ki iu"> [[scope]]'的私有属性中。</strong></li><li id="7919" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">因此，现在即使外部函数被返回并且<strong class="ki iu">执行上下文</strong>被销毁，问候语也将在“<strong class="ki iu">[[scope]]”</strong>中存储“消息”值</li><li id="db27" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">当从全局上下文中调用它时，它知道在哪里寻找“消息”值。是的，伙计们！在<strong class="ki iu">'[[范围]]' </strong>内</li></ul><blockquote class="lw lx ly"><p id="f276" class="kg kh le ki b kj kk kl km kn ko kp kq lz ks kt ku ma kw kx ky mb la lb lc ld im bi translated"><strong class="ki iu">是的，JavaScript的这个特性被称为‘闭包’</strong></p></blockquote><p id="80f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没什么花哨的！！！是的，我知道:)它只是一个从高阶函数返回的函数，可以存储存在于其词法范围内的变量和对象。</p><p id="4caa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，各位，就这样:)</p><p id="6941" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我的第一个博客。表现出一些爱:)反馈将不胜感激。</p><p id="56a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以通过<a class="ae kf" href="https://www.linkedin.com/in/omkar-nath-mandal/" rel="noopener ugc nofollow" target="_blank"> Omkar Nath Mandal </a>与我联系</p></div></div>    
</body>
</html>