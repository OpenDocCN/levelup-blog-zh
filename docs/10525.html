<html>
<head>
<title>Boost RecyclerView Performance with DiffUtil</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用DiffUtil提升回收查看性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/boost-recyclerview-performance-with-diffutil-4110b668e534?source=collection_archive---------5-----------------------#2021-12-18">https://levelup.gitconnected.com/boost-recyclerview-performance-with-diffutil-4110b668e534?source=collection_archive---------5-----------------------#2021-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗨，在本文中，我将展示如何使用DiffUtil实用程序类来帮助我们以优化的方式更新RecyclerView列表。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/201328556ba8e89207c1570f7fc8c2b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SL7njQijDbifyO-0KovI7g.png"/></div></div></figure><h2 id="d18d" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">它是如何工作的？</h2><p id="a11a" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated"><em class="lv"> DiffUtil，使用Eugene W. Myers的差分算法计算将一个列表转换为另一个列表的最小更新次数。</em></p><h2 id="a21d" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">实现</strong></h2><p id="4009" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">首先，让我们为RecyclerView适配器创建数据模型。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="fccb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们将通过扩展DiffUtil来创建MovieDiffUtil类。回调抽象类，它有4个抽象方法要覆盖。</p><p id="c0b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看哪些方法将被覆盖，以及我们如何使用它们。</p><p id="db59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">getOldListSize(): 它返回旧的列表大小。</p><p id="5757" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">getNewListSize(): 它返回新的列表大小</p><p id="ee5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> areItemsTheSame(): </strong>返回一个布尔值，判断两个对象是否代表同一个项目。在这个方法中，我们可以通过两个对象的唯一值(如id)来比较它们。</p><p id="74ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> areContentsTheSame(): </strong>返回一个布尔值，表明两个项目是否有相同的数据。在这个方法中，我们可以直接比较对象引用。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6433" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成这些步骤后，我们将能够在我们的MovieAdapter中使用MovieDiffUtil。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="58de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在setData()方法中，我们使用calculateDiff()方法计算两个列表之间的差异，然后将结果保存在DiffResult对象中，使用该对象，我们使用dispatchUpdatedTo()方法将更新后的列表发送到适配器。</p><p id="b89a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，每当我们的列表改变时，我们可以在片段或活动中调用setData()方法。</p><h1 id="cb06" class="ly ky iq bd kz lz ma mb lc mc md me lf mf mg mh li mi mj mk ll ml mm mn lo mo bi translated">asynclistdifferent</h1><p id="97a4" class="pw-post-body-paragraph jn jo iq jp b jq lq js jt ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk ij bi translated">当我们的列表中有大量数据时，计算两个列表之间的差异的操作可能需要很长时间，因此我们应该异步地执行这些操作，以免阻塞主线程。幸运的是，有了AsyncListDiffer，我们可以很容易地在后台线程上实现它。</p><h2 id="8ad2" class="kx ky iq bd kz la lb dn lc ld le dp lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated">履行</h2><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c086" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一次，我们使用扩展DiffUtil的匿名类创建了一个DiffUtil对象。然后实现了它的成员。</p><blockquote class="mp mq mr"><p id="9b7b" class="jn jo lv jp b jq jr js jt ju jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj kk ij bi translated">val list differ = AsyncListDiffer(this，diffUtil)</p></blockquote><p id="fa00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这段代码，我们在一个后台线程上进行所有的比较，并将结果分配给一个名为list different的对象。</p><p id="9ec6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用这个对象，</p><p id="ae04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用<strong class="jp ir">list different . current list</strong>访问更新后的列表，并使用<strong class="jp ir">list different . submit list(movie list)</strong>将新列表提交给适配器</p><p id="be68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，只要我们的列表发生变化，我们就可以在片段或活动中调用setData()方法。</p><p id="6292" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读，下次见😎</p></div></div>    
</body>
</html>