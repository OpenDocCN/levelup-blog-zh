<html>
<head>
<title>How to Become Better at Program Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何更好地掌握程序结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-develop-better-program-structure-3a57f48bf971?source=collection_archive---------6-----------------------#2021-02-16">https://levelup.gitconnected.com/how-to-develop-better-program-structure-3a57f48bf971?source=collection_archive---------6-----------------------#2021-02-16</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="0346" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">改善程序结构的几个简单技巧</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/67b7e35a535eea0b7eccf358bcb9a9fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W9kn_WCdAl_02I7E"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">里卡多·戈麦斯·安吉尔在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="66ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">解决计算问题需要编写程序。程序的布局取决于程序员。程序的执行依赖于计算机，我们无法控制执行。</p><p id="539b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">没有人喜欢纠结的代码，和加班加点弄清楚它是做什么的。您应该编写结构化代码，对代码有清晰的理解。</p><p id="7439" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结构化程序可以理解代码，这导致了结构化编程。我们能做什么来组织我们的程序？让我们继续展开这个话题。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="d812" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">分解</h2><blockquote class="mw"><p id="8171" class="mx my iu bd mz na nb nc nd ne nf lv dk translated">我们能做什么来缩短静态程序文本和相应的时间计算之间的概念差距？埃德格·w·迪杰斯特拉</p></blockquote><p id="3480" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">学习计算机科学，我们知道程序是无用的，如果不执行。代码是<em class="nl">‘程序文本’。</em>该计划实现的目标是我们所关心的。</p><p id="e001" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们如何近距离观察这个程序的功能？我们可以把它分解成子状态。然后我们可以比较子状态，看看结果。</p><blockquote class="nm nn no"><p id="c73d" class="la lb nl lc b ld le jv lf lg lh jy li np lk ll lm nq lo lp lq nr ls lt lu lv in bi translated">怎样才能分解程序？</p></blockquote><p id="ccfc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有三类顺序分解:</p><ul class=""><li id="44da" class="ns nt iu lc b ld le lg lh lj nu ln nv lr nw lv nx ny nz oa bi translated"><em class="nl">串联</em></li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ob"><img src="../Images/4f0b8ba49196d338abe39e9534605b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*TFVWeuaLg8EMy6ChKeESqw.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD249.PDF" rel="noopener ugc nofollow" target="_blank">第22页。—子状态的连接—结构化编程注释</a></figcaption></figure><ul class=""><li id="59f8" class="ns nt iu lc b ld le lg lh lj nu ln nv lr nw lv nx ny nz oa bi translated"><em class="nl">选择</em></li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oc"><img src="../Images/464be5da6f34d3c0529566d51d3e50e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*UF7OiD_ogWx6UjAhuOiJow.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD249.PDF" rel="noopener ugc nofollow" target="_blank">第23页。—结构化编程的选择注释</a></figcaption></figure><ul class=""><li id="277f" class="ns nt iu lc b ld le lg lh lj nu ln nv lr nw lv nx ny nz oa bi translated"><em class="nl">重复</em></li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj od"><img src="../Images/c8d97f8961b7dda8bf0987cd17f95fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*6hooIPiE4gp2rmcnLHFewQ.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD249.PDF" rel="noopener ugc nofollow" target="_blank">第25页。——重复——结构化编程笔记</a></figcaption></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><p id="8a77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">把它分解成一系列的动作，我们可以对每一个动作进行推理。</p><h2 id="203e" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">枚举子状态</h2><p id="6ef6" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">列举子状态来推理if-else和switch-case块。拥有两个或多个状态让我们更容易分解程序。将程序分解成子状态创造了一种万无一失的测试方法。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oc"><img src="../Images/6ed76eaaff5e2c1f7bcddbd009627b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*8Ac26icQR2XVJ3HG1UEZ2Q.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD249.PDF" rel="noopener ugc nofollow" target="_blank">第24页。——结构化编程注释</a></figcaption></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="0355" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">归纳思维</h2><p id="4736" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">数学归纳法有助于解决重复问题。取几个案例并浏览程序可以揭示子状态。然后，我们可以将子状态推理为前一个子状态的继承者。子状态(<em class="nl"> S1 </em>)由子状态(<em class="nl"> S0 </em>)上完成的子动作(<em class="nl"> S </em>)生成。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="3ca1" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">单一入口—单一出口点</h2><p id="87a2" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">这些程序块按顺序构建结构化程序。我们可以将程序块连接在一起，创建结构化的程序。</p><p id="1670" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">可以注意到，虚线框中有一个入口和一个出口。有了这些，我们就可以构建一个结构化的块拓扑。避免单入口和单出口块会导致非结构化代码。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="d2c3" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">结论</h2><p id="32db" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">我将在最后留下参考资料，这样您可以更深入地了解此事。</p><p id="17ef" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对任何代码进行逐步分解都会有所帮助。这将创建您可以测试、推理和维护的结构化程序。为结构化程序创建测试更加容易。</p><p id="c98c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">许多难以测试的入口点是没有结构的程序的特征。我们都使用过这种代码。测试是不存在的，因为测试并不是一件小事。</p><p id="3d87" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个问题上，我将引用伟大的计算机科学家埃德格的话来结束我的发言:</p><blockquote class="nm nn no"><p id="e153" class="la lb nl lc b ld le jv lf lg lh jy li np lk ll lm nq lo lp lq nr ls lt lu lv in bi translated">这个故事的寓意是，当我们承认我们有责任控制计算(理智上！)通过程序文本唤起它们，然后我们应该谦卑地将自己限制在最系统的排序机制，确保“通过计算的进展”以最直接的方式映射到“通过文本的进展”。埃德格·w·迪杰斯特拉</p></blockquote></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="4f14" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">资源:</h2><p id="6f74" class="pw-post-body-paragraph la lb iu lc b ld oe jv lf lg of jy li lj og ll lm ln oh lp lq lr oi lt lu lv in bi translated">埃德加·w·迪杰斯特拉的笔记。</p><p id="41cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://softwareengineering.stackexchange.com/questions/118703/where-did-the-notion-of-one-return-only-come-from" rel="noopener ugc nofollow" target="_blank">关于换垛的问题</a></p></div></div>    
</body>
</html>