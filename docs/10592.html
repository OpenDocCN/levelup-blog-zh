<html>
<head>
<title>Exploring AppleScript — Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索AppleScript —第4部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/exploring-applescript-part-4-4cefee82935c?source=collection_archive---------11-----------------------#2021-12-23">https://levelup.gitconnected.com/exploring-applescript-part-4-4cefee82935c?source=collection_archive---------11-----------------------#2021-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="ff79" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://gentille.us/applescript-articles-7f82c319d46?sk=0ad4bf43fb9356f9e647c970cb12c31f" rel="noopener ugc nofollow" target="_blank"> AppleScript课程</a></h2><div class=""/><div class=""><h2 id="cb71" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">使脚本可读、可靠和可重用</h2></div><p id="3436" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果我们等待操作完成，脚本变得更加可靠，如果我们使用函数，它们变得更加可重用和可读。当我们这样做时，有一些意想不到的陷阱我们想要避免。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/eb8013560ec9c0dcc149c6659aadcf5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CdBd1UlGa5DYmAmD6HxFTg.jpeg"/></div></div></figure><p id="b567" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><em class="lw">本文中显示的所有代码都可以通过</em> <a class="ae lx" href="https://github.com/Rolias/discover-applescript/tree/main/04-Exploring" rel="noopener ugc nofollow" target="_blank"> <em class="lw">关联的GitHub repo获得。</em> </a></p><h1 id="3635" class="ly lz iq bd ma mb mc md me mf mg mh mi kf mj kg mk ki ml kj mm kl mn km mo mp bi translated">前情提要…</h1><p id="1f56" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">在前面的<a class="ae lx" href="https://gentille.us/applescript-articles-7f82c319d46?sk=0ad4bf43fb9356f9e647c970cb12c31f" rel="noopener ugc nofollow" target="_blank">部分</a>中，我们专注于构建可以用作工具的简短脚本，并学习一些可以帮助我们探索AppleScript的附带工具。在这一集里，我们将重点写一个更可靠、可重用和可读的脚本。</p><p id="c841" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们之前构建了这个脚本:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/d540038023004192fac9f85cc922a94e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*B6Fb2YqxzCpLG6xd6nozwQ.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">第3部分中构建的脚本</figcaption></figure><h1 id="fce3" class="ly lz iq bd ma mb mc md me mf mg mh mi kf mj kg mk ki ml kj mm kl mn km mo mp bi translated">可靠性</h1><p id="5edd" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">我想做的第一件事是让这个更可靠。如前所述，这个脚本可能会在正确的<code class="fe na nb nc nd b">Systems Preferences</code>窗格和选项卡显示之前尝试单击<code class="fe na nb nc nd b">Scaled</code>单选按钮。如果我们检查预期的UI元素是否存在，效果会更好。在<code class="fe na nb nc nd b">System Preferences</code>的<code class="fe na nb nc nd b">Standard Suite</code>中定义的<code class="fe na nb nc nd b">exists</code>动词就是这么做的。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/7d1200e511f11527308df7c11c0a5b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*i73MOJf9jnf3jQ_L_tBSqA.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">“exists”动词的字典条目</figcaption></figure><p id="7957" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">问题是我们需要反复调用<code class="fe na nb nc nd b">exists</code>直到窗口存在。最简单的方法之一是使用如下所示的<code class="fe na nb nc nd b"><a class="ae lx" href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_control_statements.html#//apple_ref/doc/uid/TP40000983-CH6g-128014" rel="noopener ugc nofollow" target="_blank">repeat until</a></code>语句:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e1896db93a996e06f8c94e0b25ceba48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*TIugaJdoI1VxXcLdWrFs0Q.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">如果需要，永远等待</figcaption></figure><p id="8b06" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我在这里使用了我的窗口名。如果你不想永远等下去，你需要替换你的窗口名。如果你厌倦了永远等待，请记住工具栏中的<code class="fe na nb nc nd b">Stop</code>按钮。这种方法可能是可以接受的，但是根据脚本的执行方式，永远等待可能不太方便。我们也可以使用<code class="fe na nb nc nd b"><a class="ae lx" href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_cmds.html#//apple_ref/doc/uid/TP40000983-CH216-SW10" rel="noopener ugc nofollow" target="_blank">delay</a></code>命令等待一段特定的时间。我们可以把这两种方法结合起来，等一会儿再放弃。除了比永远等待更快之外，我们还学会了使用<code class="fe na nb nc nd b"><a class="ae lx" href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_control_statements.html#//apple_ref/doc/uid/TP40000983-CH6g-128843" rel="noopener ugc nofollow" target="_blank">exit</a></code>语句。下面我们在每个重复循环中延迟，但在一组尝试次数后放弃。<em class="lw">请注意，我确实将我正在等待的窗口的名称改为了一个在我的系统上不存在的窗口，以验证退出代码是否有效。我将在后续脚本中把它改回来。</em></p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/5c6fe9cbbcc8bed4ad3296d728f5a4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*p7fYOaTsDjX86anLgFt48g.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">延迟0.02秒尝试100次</figcaption></figure><h1 id="f7fa" class="ly lz iq bd ma mb mc md me mf mg mh mi kf mj kg mk ki ml kj mm kl mn km mo mp bi translated">通过处理程序(也称为函数)获得可重用性</h1><p id="7436" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">内联添加了所有这些代码后，我们开始混淆脚本的主要逻辑。让我们稍微重构一下我们的代码，使它更易读，更容易维护。</p><p id="55f0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我将采用一种简单的方法，将等待代码直接移入一个函数，也称为<code class="fe na nb nc nd b"><a class="ae lx" href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html#//apple_ref/doc/uid/TP40000983-CH206-CJBIDBJH" rel="noopener ugc nofollow" target="_blank">handler</a>.</code>，我将特别使用一个带有位置参数的<a class="ae lx" href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html#//apple_ref/doc/uid/TP40000983-CH206-SW13" rel="noopener ugc nofollow" target="_blank">处理程序。在下图中，我创建了一个名为<code class="fe na nb nc nd b">waitFor()</code>的处理程序，它接受等待的窗口的名称。</a></p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/c0d234c19d1d1ffd0f099fba10c94167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*4rIE0705-ZipTuljthEmng.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">使用函数——但会引入错误</figcaption></figure><p id="14d8" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">注意，在主脚本中，我在tell块中调用我的<a class="ae lx" href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html#//apple_ref/doc/uid/TP40000983-CH206-SW1" rel="noopener ugc nofollow" target="_blank">处理程序。我在处理程序的名字前使用了关键字<code class="fe na nb nc nd b">my</code>，否则脚本会认为我试图在<code class="fe na nb nc nd b">System Preferences</code>上调用一个(不存在的)<code class="fe na nb nc nd b">waitFor()</code>，它是我的内部tell块的目标。</a></p><h1 id="e479" class="ly lz iq bd ma mb mc md me mf mg mh mi kf mj kg mk ki ml kj mm kl mn km mo mp bi translated">添加返回值</h1><p id="63c7" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">这段代码似乎可以点击<code class="fe na nb nc nd b">Scaled</code>按钮，但是它并没有像我们期望的那样找到窗口。我们可以向处理程序添加一个返回值来证明这一点。在下面的代码中，我突出显示了所做的更改，以表明如果达到计数器极限，我将返回<code class="fe na nb nc nd b">false</code>，否则返回<code class="fe na nb nc nd b">true</code>。在主脚本中，我捕获了<code class="fe na nb nc nd b">waitFor</code>的结果并记录下来。我们可以在<code class="fe na nb nc nd b">Messages</code>窗格中看到返回了false。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/55561ee15ee2484c33c2647db2931369.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*GjvFHuPFyycAokiTnGQZlA.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">waitFor()函数返回一个指示成功或失败的值</figcaption></figure><h1 id="1326" class="ly lz iq bd ma mb mc md me mf mg mh mi kf mj kg mk ki ml kj mm kl mn km mo mp bi translated">发生了什么事？</h1><p id="06eb" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">为什么这段代码在主脚本中可以工作，但是当我们将它移到处理程序中时却失败了？问题源于or主脚本的<code class="fe na nb nc nd b">tell</code>块目标。<code class="fe na nb nc nd b">waitFor</code>实际上已经忘记了它正在使用<code class="fe na nb nc nd b">System Preferences</code>的事实。幸运的是，AppleScript同时拥有<a class="ae lx" href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_fundamentals.html#//apple_ref/doc/uid/TP40000983-CH218-DontLinkElementID_360" rel="noopener ugc nofollow" target="_blank"> it和me关键字</a>。我们可以将<code class="fe na nb nc nd b">it</code>传递给我们的函数来跟踪当前目标。在下面的代码中，我们现在传递<code class="fe na nb nc nd b">it,</code>并将其作为名为<code class="fe na nb nc nd b">target</code>的参数接收。(步骤1和2)。添加了使用新的<code class="fe na nb nc nd b">target</code>参数的tell块(步骤3)。<code class="fe na nb nc nd b">tell target/end tell</code>块内的代码没有改变。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ff2a79e753c02d822bf21a414033ba3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*nbmnl39hpWr-pTc03nRPaw.png"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">工作函数</figcaption></figure><h1 id="268a" class="ly lz iq bd ma mb mc md me mf mg mh mi kf mj kg mk ki ml kj mm kl mn km mo mp bi translated">Try控制语句</h1><p id="36b2" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">AppleScript提供了一个<a class="ae lx" href="https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_control_statements.html#//apple_ref/doc/uid/TP40000983-CH6g-DontLinkElementID_889" rel="noopener ugc nofollow" target="_blank"> try控制语句</a>来处理意外错误，我们可以添加它来使我们的最终函数更加健壮。我们需要将感兴趣的代码包装在一个<code class="fe na nb nc nd b"> try/end try</code>块中(如箭头所示)，并添加一个on error部分来处理任何出错的情况(如方框所示)。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nk"><img src="../Images/1efdd2efc469baa62f3a636223bd3754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRFPf_f8qrh1V7DX14Oc8w.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">带有try控制语句的waitFor()函数</figcaption></figure><h1 id="2943" class="ly lz iq bd ma mb mc md me mf mg mh mi kf mj kg mk ki ml kj mm kl mn km mo mp bi translated">下一个</h1><p id="568c" class="pw-post-body-paragraph ko kp iq kq b kr mq ka kt ku mr kd kw kx ms kz la lb mt ld le lf mu lh li lj ij bi translated">我开始这个AppleScript之旅是因为我试图解决一个特定的问题。在下一篇文章中，我们将最终创建一个完整的脚本来解决这个问题，并使用到目前为止我们所学的许多技术。</p><p id="ebeb" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">参见本系列(目前)所有文章的<a class="ae lx" href="https://gentille.us/7f82c319d46?sk=0ad4bf43fb9356f9e647c970cb12c31f" rel="noopener ugc nofollow" target="_blank">概述。</a></p><p id="2fa0" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">感谢阅读，和平编码。</p></div></div>    
</body>
</html>