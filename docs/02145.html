<html>
<head>
<title>Lifecycle Hooks of the Vue Instance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue实例的生命周期挂钩</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lifecycle-hooks-of-the-vue-instance-19a2b06dc694?source=collection_archive---------4-----------------------#2020-02-21">https://levelup.gitconnected.com/lifecycle-hooks-of-the-vue-instance-19a2b06dc694?source=collection_archive---------4-----------------------#2020-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/88ad150f58012b1247f84ef995d68a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VSC7EqZE9kqg8jwh"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@beataratuszniak?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Beata Ratuszniak </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="7b9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Vue.js是一个易于使用的web应用框架，我们可以用它来开发交互式前端应用。</p><p id="2cc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究Vue实例的生命周期挂钩。</p><h1 id="e2fb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Vue实例生命周期挂钩</h1><p id="aa94" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">每个Vue实例都经历一个生命周期。生命周期事件可以用函数来处理，这些函数是生命周期挂钩。</p><p id="dd72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，当创建一个Vue实例时，调用<code class="fe mh mi mj mk b">created</code>钩子。</p><p id="aba8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下处理Vue.js发出的<code class="fe mh mi mj mk b">created</code>事件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="577f" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  data: {<br/>    foo: "bar"<br/>  },<br/>  created() {<br/>    console.log(`foo is ${this.foo}`);<br/>  }<br/>});</span></pre><p id="0d4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们应该从<code class="fe mh mi mj mk b">console.log</code>中看到<code class="fe mh mi mj mk b">foo is bar</code>。一旦创建了Vue实例并设置了初始数据，就会调用<code class="fe mh mi mj mk b">created</code>钩子。</p><p id="81f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是为什么我们会从<code class="fe mh mi mj mk b">console.log</code>看到这样的输出。</p><p id="ec75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们不能对生命周期挂钩使用箭头函数，因为我们引用了来自<code class="fe mh mi mj mk b">this</code>的属性，它是Vue实例。</p><p id="76d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有其他生命周期挂钩，如<code class="fe mh mi mj mk b">mounted</code>、<code class="fe mh mi mj mk b">updated</code>、<code class="fe mh mi mj mk b">destroyed</code>。</p><h1 id="6ba6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">生命周期图</h1><p id="727b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">完整的生命周期图如下。它概述了创建新Vue实例的整个工作流程。</p><p id="2c57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">红色的圆角矩形有一个钩子叫做。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/a09f15311841def8c09e7fceafcdd233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byyX8EW6mIhRsCBWwByNYg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">vuejs.org的好意</figcaption></figure><h1 id="5761" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创作挂钩</h1><p id="a39f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当Vue实例开始它的初始化过程时，创建钩子被调用。它让我们在Vue实例被添加到DOM之前做一些事情。</p><p id="6698" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个钩子也在服务器端渲染时运行</p><p id="8089" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不能访问这个钩子中的<code class="fe mh mi mj mk b">this.$el</code>(目标挂载元素)或DOM，因为此时没有进行任何DOM操作。</p><h2 id="08fb" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">创建前</h2><p id="a676" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">beforeCreate</code>钩子在初始化期间运行。<code class="fe mh mi mj mk b">data</code>已被激活，<code class="fe mh mi mj mk b">events</code>尚未设置。</p><p id="6316" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7d7e" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  data: {<br/>    foo: "bar"<br/>  },<br/>  beforeCreate() {<br/>    console.log("beforeCreated called");<br/>  },<br/>  created() {<br/>    console.log(`foo is ${this.foo}`);<br/>  }<br/>});</span></pre><p id="d47f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们看到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a669" class="mt lf it mk b gy mu mv l mw mx">beforeCreated called<br/>foo is bar</span></pre><p id="c7a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这确认了<code class="fe mh mi mj mk b">beforeCreate</code>在<code class="fe mh mi mj mk b">created</code>之前被调用。</p><h2 id="89f2" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">创造</h2><p id="3a9d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">由于Vue实例已经初始化，所以<code class="fe mh mi mj mk b">data</code>和<code class="fe mh mi mj mk b">events</code>在<code class="fe mh mi mj mk b">created</code>钩子中可用。</p><p id="1f43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="99c1" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  data: {<br/>    foo: "bar"<br/>  },<br/>  created() {<br/>    this.foo = "baz";<br/>    console.log(`foo is ${this.foo}`);<br/>  }<br/>});</span></pre><p id="4292" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="eb28" class="mt lf it mk b gy mu mv l mw mx">foo is baz</span></pre><p id="1297" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们在记录值之前改变了<code class="fe mh mi mj mk b">created</code>钩子中<code class="fe mh mi mj mk b">this.foo</code>的值。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/a6f65329a6e572c328c5f16eb7c3984b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8WSOWLd3Zz2Dzol1"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@applexue?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维多利亚迪化薛</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="64bb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">安装挂钩</h1><p id="af8a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">挂载钩子在DOM操作完成时运行，包括将Vue实例挂载到指定的元素。</p><p id="e6f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用它来访问或修改组件的DOM。</p><h2 id="0075" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">安装前</h2><p id="9dc6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">beforeMount</code>钩子在初始渲染发生之前和模板或渲染函数编译之后运行。</p><p id="15f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在服务器端渲染期间不会调用它。</p><p id="c204" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b806" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    foo: "bar"<br/>  },<br/>  created() {<br/>    console.log(`created called`);<br/>  },<br/>  beforeMount() {<br/>    console.log(`beforeMount called`);<br/>  }<br/>});</span></pre><p id="6901" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7d5e" class="mt lf it mk b gy mu mv l mw mx">created called<br/>beforeMount called</span></pre><h2 id="813c" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">安装好的</h2><p id="bc98" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当调用<code class="fe mh mi mj mk b">mounted</code>钩子时，我们可以访问组件、模板和DOM。</p><p id="353f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它经常用于初始化我们自己的数据，比如通过网络获取数据和集成非Vue库。</p><p id="1839" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们在<code class="fe mh mi mj mk b">src/index.js</code>中有以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ade2" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    foo: "bar"<br/>  },<br/>  beforeMount() {<br/>    console.log(this.$el.textContent);<br/>  }<br/>});</span></pre><p id="34c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以及<code class="fe mh mi mj mk b">index.html</code>中的以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1d75" class="mt lf it mk b gy mu mv l mw mx">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Hello&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kf" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;</span><span id="b18d" class="mt lf it mk b gy nl mv l mw mx">  &lt;body&gt;<br/>    &lt;div id="app"&gt;foo&lt;/div&gt;<br/>    &lt;script src="./src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="c669" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们让<code class="fe mh mi mj mk b">foo</code>登录，因为我们在ID为<code class="fe mh mi mj mk b">app</code>的<code class="fe mh mi mj mk b">div</code>中有<code class="fe mh mi mj mk b">foo</code>。</p><h1 id="5f6b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">更新挂钩</h1><p id="b25f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们的组件使用的一个反应属性改变或者我们手动触发重新渲染时，更新钩子被调用。</p><p id="699f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们对于检查组件何时被重新渲染很有用。</p><p id="5727" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，我们应该使用计算属性或观察器来跟踪反应性属性的变化。</p><h2 id="a132" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">更新前</h2><p id="1105" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">beforeUpdate</code>在组件中的数据更改之后运行，就在DOM更新和重新呈现之前。</p><p id="59d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它让我们在DOM重新呈现之前获得新的状态。</p><p id="1d25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们在<code class="fe mh mi mj mk b">src/index.html</code>中有以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5efe" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    foo: "bar"<br/>  },<br/>  beforeUpdate() {<br/>    console.log(this.foo);<br/>  },<br/>  methods: {<br/>    toggle() {<br/>      this.foo = this.foo === "bar" ? "baz" : "bar";<br/>    }<br/>  }<br/>});</span></pre><p id="0331" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以及<code class="fe mh mi mj mk b">index.html</code>中的以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="25e3" class="mt lf it mk b gy mu mv l mw mx">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Hello&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kf" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;</span><span id="5778" class="mt lf it mk b gy nl mv l mw mx">  &lt;body&gt;<br/>    &lt;div id="app"&gt;<br/>      &lt;p&gt;{{foo}}&lt;/p&gt;<br/>      &lt;button <a class="ae kf" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>="toggle"&gt;Toggle&lt;/button&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="./src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="daa6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们单击切换按钮时，我们可以看到在<code class="fe mh mi mj mk b">beforeUpdate</code>方法的<code class="fe mh mi mj mk b">console.log</code>调用中记录的值变化。</p><h2 id="59d4" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">更新</h2><p id="a20e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在我们的Vue实例上的数据改变和DOM重新呈现之后,<code class="fe mh mi mj mk b">updated</code>钩子运行。</p><p id="46f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们在<code class="fe mh mi mj mk b">src/index.js</code>中有以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1641" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    foo: "bar"<br/>  },<br/>  updated() {<br/>    console.log(this.$refs.foo.textContent);<br/>  },<br/>  methods: {<br/>    toggle() {<br/>      this.foo = this.foo === "bar" ? "baz" : "bar";<br/>    }<br/>  }<br/>});</span></pre><p id="b89f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以及<code class="fe mh mi mj mk b">index.html</code>中的以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="27ab" class="mt lf it mk b gy mu mv l mw mx">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Hello&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kf" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;</span><span id="3e13" class="mt lf it mk b gy nl mv l mw mx">  &lt;body&gt;<br/>    &lt;div id="app"&gt;<br/>      &lt;p ref="foo"&gt;{{foo}}&lt;/p&gt;<br/>      &lt;button <a class="ae kf" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>="toggle"&gt;Toggle&lt;/button&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="./src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="faba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以通过记录如下值来获取<code class="fe mh mi mj mk b">ref</code>设置为<code class="fe mh mi mj mk b">foo</code>的<code class="fe mh mi mj mk b">p</code>元素的文本内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fd1a" class="mt lf it mk b gy mu mv l mw mx">console.log(this.$refs.foo.textContent);</span></pre><p id="3a96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">updated</code>钩子中，当我们点击切换按钮时，我们可以看到它的新值。</p><h1 id="1e70" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">破坏钩</h1><p id="b8d3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这些钩子在Vue实例被销毁时运行。因此，我们可以在那里运行清理代码。</p><p id="6a66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些钩子在服务器端渲染时不会运行。</p><h2 id="54c0" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">销毁前</h2><p id="8f2a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">beforeDestroy</code>在拆卸前运行。我们的Vue实例仍然存在并正常工作。</p><p id="fc56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可以在这里运行清理代码。</p><p id="8696" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2145" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    foo: "bar"<br/>  },<br/>  beforeDestroy() {<br/>    this.foo = null;<br/>  }<br/>});</span></pre><h2 id="3bf3" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">破坏</h2><p id="ec0e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这是在销毁Vue实例后调用的。所有指令都被解除绑定，事件监听器被移除，子Vue实例被销毁。</p><p id="fb06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e57d" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    foo: "bar"<br/>  },<br/>  destroyed() {<br/>    this.foo = null;<br/>  }<br/>});</span></pre><h1 id="49fe" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="9268" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">生命周期挂钩对于在Vue实例的生命周期中做事情很有用。</p><p id="ad7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建钩子可以用来运行任何初始化代码。</p><p id="a211" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当Vue实例被挂载到DOM中时，挂载挂钩就会运行。</p><p id="17cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当Vue实例的数据更新时，更新挂钩，销毁挂钩在销毁Vue实例时运行。</p></div></div>    
</body>
</html>