<html>
<head>
<title>React Hooks in 20 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">20分钟后反应钩子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-hooks-in-depth-eb0bed232c8e?source=collection_archive---------1-----------------------#2019-06-18">https://levelup.gitconnected.com/react-hooks-in-depth-eb0bed232c8e?source=collection_archive---------1-----------------------#2019-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4f04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">钩子</em>是React 16.8中新增的。它们允许您使用状态和其他React特性，而无需编写类组件。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/961286e888f682072de57bfe4e4d3f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Ijet6kVJqGgul6adezDLQ.png"/></div></div></figure><p id="8f93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在本文中深入探讨它们。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="69a7" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是钩子？</h1><p id="bcc1" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">挂钩是让您从功能组件“挂钩”React状态和生命周期特性的功能。钩子在类内部不起作用——它们让你在没有类的情况下使用React。事实上，它们只能用于功能组件。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="4b82" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">钩子背后的动机是什么？</h1><ul class=""><li id="a7dc" class="mi mj iq jp b jq md ju me jy mk kc ml kg mm kk mn mo mp mq bi translated">很难在组件之间重用有状态逻辑。<strong class="jp ir">钩子允许你在不改变组件层次的情况下重用有状态逻辑。</strong></li><li id="eab7" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">复杂的组件变得难以理解。<strong class="jp ir">钩子允许你根据相关的部分将一个组件分割成更小的功能(比如设置订阅或者获取数据)</strong>，而不是根据生命周期方法强制分割。</li><li id="8fc3" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">类混淆了人和机器。<strong class="jp ir">钩子让你不用类就能使用更多的React特性。</strong></li></ul></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="8996" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">钩子是JavaScript函数，但是它们强加了两个额外的规则:</p><ul class=""><li id="57a6" class="mi mj iq jp b jq jr ju jv jy mw kc mx kg my kk mn mo mp mq bi translated">只调用顶层的钩子<strong class="jp ir">。不要在循环、条件或嵌套函数中调用钩子。</strong></li><li id="75fa" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">仅从React函数组件调用钩子<strong class="jp ir">。不要从常规的JavaScript函数或类组件中调用钩子。(只有一个地方可以调用钩子——你自己的定制钩子。稍后将详细介绍。)</strong></li></ul></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="615b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来，以下4个React挂钩可以覆盖99%的用例:</p><ul class=""><li id="edea" class="mi mj iq jp b jq jr ju jv jy mw kc mx kg my kk mn mo mp mq bi translated">📌状态挂钩— <code class="fe mz na nb nc b">useState</code></li><li id="2ad0" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">⚡️效应挂钩— <code class="fe mz na nb nc b">useEffect</code></li><li id="8353" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">⭕️上下文挂钩— <code class="fe mz na nb nc b">useContext</code></li><li id="0acf" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">☝️Ref胡克— <code class="fe mz na nb nc b">useRef</code></li></ul></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="99c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将这些归类为深度挂钩:</p><ul class=""><li id="c115" class="mi mj iq jp b jq jr ju jv jy mw kc mx kg my kk mn mo mp mq bi translated"><code class="fe mz na nb nc b">useReducer</code></li><li id="a42e" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe mz na nb nc b">useMemo</code> —性能优化</li><li id="0cf7" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe mz na nb nc b">useCallback</code> —性能优化</li><li id="8c6c" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe mz na nb nc b">useLayoutEffect</code></li><li id="a5da" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe mz na nb nc b">useImperativeHandle</code></li></ul></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nd"><img src="../Images/a9b267c7c2adc77342328ac616e38465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y48AOrGux2HoPLznHtbFzw.jpeg"/></div></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="80ed" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">📌状态挂钩—使用状态</h1><p id="d043" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">允许我们使我们的组件有状态。我们在函数组件内部调用它，为它添加一些本地状态。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="ab gu cl ne"><img src="../Images/dec494c640608fc5abcfb3fa0aaacce3.png" data-original-src="https://miro.medium.com/v2/format:webp/1*SfXrcDkOMOZweX9mjXwBdg.png"/></div></figure><p id="59c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以前使用状态需要使用类组件，而钩子给了我们只使用函数来编写状态的能力。它允许我们拥有更灵活的组件。</p><p id="0808" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React将在重新渲染之间保持这种状态。</p><ul class=""><li id="a2de" class="mi mj iq jp b jq jr ju jv jy mw kc mx kg my kk mn mo mp mq bi translated"><code class="fe mz na nb nc b">useState</code>钩子通过在新的every渲染中被馈送最新状态来维持状态。</li><li id="946f" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe mz na nb nc b">useState</code>返回一个元组对:<em class="kl">当前</em>状态值和一个让您更新状态的函数。</li><li id="b2c2" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">传递给<code class="fe mz na nb nc b">useState</code>的唯一参数是初始状态。与<code class="fe mz na nb nc b">this.state</code>不同，这里的状态不必是一个对象——尽管如果你愿意，它可以是。初始状态参数仅在第一次渲染时使用。</li><li id="d54f" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">在一个函数中，你可以有尽可能多的钩子；所以多种状态都有自己的更新函数。</li></ul><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/6cac7aa650b321a7bdf590b61168e49c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/1*YyiSfEbWe4jah0tUSsELjw.gif"/></div></figure><p id="4022" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mz na nb nc b">useState</code>的例子——当你点击按钮时，它增加数值:</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="15f1" class="nk lg iq nc b gy nl nm l nn no">import React, { useState } from 'react';</span><span id="36cb" class="nk lg iq nc b gy np nm l nn no">function Example() {<br/>  // Declare a new state variable, which we'll call "count"<br/>  const [count, setCount] = useState(0);</span><span id="e281" class="nk lg iq nc b gy np nm l nn no">  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>        Click me<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="9488" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等价类示例—如果您以前使用过React类，这段代码应该看起来很熟悉:</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="93e8" class="nk lg iq nc b gy nl nm l nn no">class Example extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      count: 0<br/>    };<br/>  }</span><span id="6a43" class="nk lg iq nc b gy np nm l nn no">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;<br/>        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;<br/>          Click me<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}<!-- --> </span></pre><div class="nq nr gp gr ns nt"><a href="https://codesandbox.io/s/react-hooks-in-depth-usestate-qq0s5?fontsize=14" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">React Hooks深入&gt;使用状态-代码沙盒</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">为web应用程序定制的在线代码编辑器</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">codesandbox.io</p></div></div><div class="oc l"><div class="od l oe of og oc oh kw nt"/></div></div></a></div><p id="b82f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以在单个组件中多次使用<code class="fe mz na nb nc b">useState</code>:</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="a071" class="nk lg iq nc b gy nl nm l nn no">function ExampleWithManyStates() {<br/>  // Declare multiple state variables!<br/>  const [age, setAge] = useState(42);<br/>  const [fruit, setFruit] = useState('banana');<br/>  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);<br/>  // ...<br/>}</span></pre><p id="25d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果新的状态是用以前的状态计算出来的，你可以传递一个函数给<code class="fe mz na nb nc b">setState</code>。该函数将接收以前的值，并返回更新后的值。下面是一个使用两种形式的<code class="fe mz na nb nc b">setState</code>的计数器组件的例子:</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="6072" class="nk lg iq nc b gy nl nm l nn no">function Counter({initialCount}) {<br/>  const [count, setCount] = useState(initialCount);<br/>  return (<br/>    &lt;&gt;<br/>      Count: {count}<br/>      &lt;button onClick={() =&gt; setCount(initialCount)}&gt;Reset&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount + 1)}&gt;+&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount - 1)}&gt;-&lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="9af5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与类组件中的<code class="fe mz na nb nc b">setState</code>函数不同，<code class="fe mz na nb nc b">useState</code>不会自动合并更新对象。您可以通过将函数更新器形式与对象扩展语法相结合来复制这种行为:</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="cae8" class="nk lg iq nc b gy nl nm l nn no">setState(prevState =&gt; {<br/>  // Object.assign would also work<br/>  return {...prevState, ...updatedValues};<br/>});</span></pre><p id="ae2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">惰性初始状态——<code class="fe mz na nb nc b">initialState</code>是初始渲染期间使用的状态，在后续渲染中，它被忽略。</p><p id="48f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果初始状态是开销很大的计算结果，您可以提供一个函数来代替，该函数将仅在初始渲染时执行:</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="6d32" class="nk lg iq nc b gy nl nm l nn no">const [state, setState] = useState(() =&gt; {<br/>  const initialState = someExpensiveComputation(props);<br/>  return initialState;<br/>});</span></pre></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oi"><img src="../Images/1de120d9e5e93c3efa55f941f6d2a5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lxJxTNqmOLgy0_pEe71hOQ.jpeg"/></div></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="4ff5" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">⚡️效应挂钩——使用效应</h1><p id="94b6" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">您可能以前执行过数据获取、订阅或从React组件手动更改DOM。我们称这些操作为“副作用”(或简称“效果”)，因为它们会影响其他组件，并且在渲染过程中无法完成。</p><p id="8bac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">效果挂钩<code class="fe mz na nb nc b">useEffect</code>，增加了从功能组件执行副作用的能力。它的作用与React类中的<code class="fe mz na nb nc b">componentDidMount</code>、<code class="fe mz na nb nc b">componentDidUpdate</code>和<code class="fe mz na nb nc b">componentWillUnmount</code>相同，但是统一到一个API中。</p><ul class=""><li id="55dc" class="mi mj iq jp b jq jr ju jv jy mw kc mx kg my kk mn mo mp mq bi translated">当您调用<code class="fe mz na nb nc b">useEffect</code>时，您是在告诉React在刷新对DOM的更改后运行您的“effect”函数。效果是在组件内部声明的，因此它们可以访问其属性和状态。默认情况下，React在每次渲染后运行效果— <em class="kl">包括</em>第一次渲染。</li><li id="9ccb" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">React一直在安排这个。</li><li id="d8a4" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">还可以使用第二个参数给它一个依赖项列表。作为第二个参数的空数组将运行一次<code class="fe mz na nb nc b">useEffect</code>函数。</li><li id="5a9d" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">效果也可以选择指定如何通过返回一个函数来“清理”它们。所以如果使用<code class="fe mz na nb nc b">setTimeout</code>返回<code class="fe mz na nb nc b">clearTimeout</code>。这是为了在卸载时React可以运行清理功能。所以对于Ajax请求，你可以取消一个请求。</li><li id="b1af" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">依赖项数组不作为参数传递给效果函数。从概念上讲，这就是它们所代表的:effect函数中引用的每个值也应该出现在dependencies数组中。</li></ul><p id="1526" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mz na nb nc b">useEffect</code>的例子—该组件在React更新DOM后设置文档标题:</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="9494" class="nk lg iq nc b gy nl nm l nn no">import React, { useState, useEffect } from 'react';</span><span id="04f4" class="nk lg iq nc b gy np nm l nn no">function Example() {<br/>  const [count, setCount] = useState(0);</span><span id="a613" class="nk lg iq nc b gy np nm l nn no">  // Similar to componentDidMount and componentDidUpdate:<br/>  useEffect(() =&gt; {<br/>    // Update the document title using the browser API<br/>    document.title = `You clicked ${count} times`;<br/>  });</span><span id="7a2e" class="nk lg iq nc b gy np nm l nn no">  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>        Click me<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="1df5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像使用<code class="fe mz na nb nc b">useState</code>一样，您可以在一个组件中使用多个效果:</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="0573" class="nk lg iq nc b gy nl nm l nn no">function FriendStatusWithCounter(props) {<br/>  const [count, setCount] = useState(0);<br/>  <br/>  useEffect(() =&gt; {<br/>    document.title = `You clicked ${count} times`;<br/>  });</span><span id="ed66" class="nk lg iq nc b gy np nm l nn no">  const [isOnline, setIsOnline] = useState(null);</span><span id="e61a" class="nk lg iq nc b gy np nm l nn no">useEffect(() =&gt; {<br/>    Cht.subscribeToStatus(props.friendId, handleStatusChange);</span><span id="31f8" class="nk lg iq nc b gy np nm l nn no">return () =&gt; {<br/>      Cht.unsubscribeFromStatus(props.friendId, handleStatusChange);<br/>    };</span><span id="0a75" class="nk lg iq nc b gy np nm l nn no">});</span><span id="08c9" class="nk lg iq nc b gy np nm l nn no">  function handleStatusChange(status) {<br/>    setIsOnline(status.isOnline);<br/>  }<br/>  // ...</span></pre></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oj"><img src="../Images/66b325dd6f5a017d7a18501fb47f06ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*suMBGoaqV2xf65UyY7CB-w.jpeg"/></div></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="041f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">⭕️上下文挂钩—使用上下文</h1><p id="4b3b" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">Context解决了“prop drilling”的问题，涵盖了Redux通常想要控制应用程序状态的内容。它允许你创造全球通用的价值。</p><p id="97ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">关于“prop drilling”的旁注—这是指当您有一个顶层组件和一个在层次结构中处于底层的子组件需要相同的数据时。对于每个中间组件，您可以将数据从父组件传递到子组件，但这很糟糕，因为现在组件层次结构中的每一层都必须知道被传递的对象，即使他们自己并不需要它，只是他们的子组件需要它。</em></p><p id="fa54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了创建一个上下文，我们可以使用<code class="fe mz na nb nc b">createContext</code>函数——传递对象的形状和一个更新函数(从技术上讲，它叫做identity函数)。</p><p id="fcad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将一个<code class="fe mz na nb nc b">Provider</code>放在顶层组件的顶部，并使用<code class="fe mz na nb nc b">useContext</code>来读取组件需要来自顶层组件的数据时的上下文。</p><p id="f53b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，上下文允许你创建一个东西进入的虫洞和一个子组件中的虫洞，同样的数据出来，中间的东西不知道它在那里。现在数据在<code class="fe mz na nb nc b">Provider</code>中的任何地方都是可用的。<code class="fe mz na nb nc b">useContext</code>当给定一个上下文对象作为参数时，只提取数据。我们不必一起使用<code class="fe mz na nb nc b">useState</code>和<code class="fe mz na nb nc b">useContext</code>(数据可以是任何形状，而不仅仅是<code class="fe mz na nb nc b">useState</code>形状)。</p><p id="10c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一般来说，上下文给应用程序增加了相当多的复杂性。一点道具钻是好的。</p><p id="1885" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在钩子被引入之前，这是一个我们如何实现上下文的例子:</p><div class="nq nr gp gr ns nt"><a href="https://codesandbox.io/s/react-hooks-in-depth-reacts-context-api-q5ccq?fontsize=14" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">React钩子深度&gt; React的上下文API - CodeSandbox</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">请注意，版本是16.3.0-alpha.0</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">codesandbox.io</p></div></div><div class="oc l"><div class="ok l oe of og oc oh kw nt"/></div></div></a></div><p id="900b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用钩子，瞧！：</p><div class="nq nr gp gr ns nt"><a href="https://codesandbox.io/s/react-hooks-in-depth-usecontext-s7uh3?fontsize=14" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">React Hooks深入&gt;使用上下文代码沙盒</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">请注意，版本是16.3.0-alpha.0</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">codesandbox.io</p></div></div><div class="oc l"><div class="ol l oe of og oc oh kw nt"/></div></div></a></div></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi om"><img src="../Images/658519566da0fa8d98f643e7e11285bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLZEJITBjQ6eRyaRH3i6Bw.jpeg"/></div></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="0af7" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">☝️ref·胡克— <code class="fe mz na nb nc b">useRef</code></h1><p id="a171" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">这个和下面的钩子有点难理解，但是请耐心听我说。</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="adaa" class="nk lg iq nc b gy nl nm l nn no">const refContainer = useRef(initialValue);</span></pre><p id="9c47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mz na nb nc b">useRef</code>返回一个可变的ref对象，其<code class="fe mz na nb nc b">.current</code>属性被初始化为传递的参数(<code class="fe mz na nb nc b">initialValue</code>)。返回的对象将在组件的整个生存期内保持不变。</p><p id="6493" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请看这个例子CodeSandBox来说明一个问题以及为什么useRef是方便的:</p><div class="nq nr gp gr ns nt"><a href="https://codesandbox.io/s/react-hooks-in-depth-useref-v1cp1?fontsize=14" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">React钩子深度&gt; useRef - CodeSandbox</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">为web应用程序定制的在线代码编辑器</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">codesandbox.io</p></div></div></div></a></div><p id="3494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的组件中，当用户单击“delay logging”按钮时，它会设置一个超时时间，在一秒钟后记录状态和ref的编号。需要记住的一点是<strong class="jp ir">状态和裁判的号码总是相同的</strong>。因为它们是同时更新的，所以永远不会步调不一致。</p><p id="fbb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">然而</em>，由于我们将日志记录延迟了一秒钟，当它发出新值警报时，它将捕获我们第一次调用超时时的状态(因为它由闭包保存)，但它将始终记录当前值，因为该ref是在一个对象上，该对象始终如一地将相同的对象返回给您。因为它是同一个对象，并且数字是对象的一个属性，所以它总是最新的，不受闭包范围的限制。</p><p id="7342" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您有多个闭包问题，并且希望保持相同的状态时，Refs非常有用。使用<code class="fe mz na nb nc b">useRef</code>来引用完全正确的一个，它可以在完全正确的上下文中被调用。</p><p id="671d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这为什么有用？这对于像保存DOM对象、<code class="fe mz na nb nc b">setInterval</code>和<code class="fe mz na nb nc b">setTimeout</code>id这样的事情很有用，这样它们可以在以后被清除。或者<strong class="jp ir"> <em class="kl">可以</em> </strong>改变的任何一点状态，但你不希望它在改变时导致重新呈现。</p><p id="761c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你在做一个类组件，你会在组件上使用一个实例变量，这就是你如何处理它。</p><p id="9686" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给我们一个对象，这个对象上有一个东西叫做T7。如果您尝试添加任何其他属性，它实际上会出错——字面意思是，通过密封对象来限制您只能使用电流。</p><p id="c963" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本质上，<code class="fe mz na nb nc b">useRef</code>就像一个“盒子”,可以在它的<code class="fe mz na nb nc b">.current</code>属性中保存一个可变值。</p><p id="5d18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，当内容发生变化时，<code class="fe mz na nb nc b">useRef</code>不会通知您。</p><p id="b548" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">变异<code class="fe mz na nb nc b">.current</code>不会导致重新渲染。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="83c6" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">用户教育</h1><p id="deea" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated"><code class="fe mz na nb nc b">useReducer</code>允许我们做Redux式的异径管，但是在钩子里面。</p><p id="e527" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们没有用一堆函数来更新我们的各种属性，而是用一个reducer来处理基于动作类型的所有更新。如果您有复杂的状态更新，或者如果您有这样的情况，这是一个更好的方法:所有的状态更新都非常相似，所以将它们包含在一个函数中是有意义的。</p><p id="93b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，术语<code class="fe mz na nb nc b">reducer</code>是一个接受旧状态、采取某种行动并返回新状态的函数。</p><p id="ca2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用<code class="fe mz na nb nc b">useReducer</code>你传递一个动作和初始状态。使用Redux，您希望缩减器在第一次运行，但这并没有发生。它返回给我们两样东西:新的状态和一个调度函数，它允许我们将一个函数调度给reducer。</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="0cff" class="nk lg iq nc b gy nl nm l nn no">const [state, dispatch] = useReducer(reducer, initialArg, init);</span></pre><p id="8cfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是上面<code class="fe mz na nb nc b">useState</code>中的反例，改写后使用了一个减速器:</p><div class="nq nr gp gr ns nt"><a href="https://codesandbox.io/s/react-hooks-in-depth-usereducer-trjer?fontsize=14" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">React Hooks深入&gt; useReducer - CodeSandbox</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">为web应用程序定制的在线代码编辑器</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">codesandbox.io</p></div></div><div class="oc l"><div class="on l oe of og oc oh kw nt"/></div></div></a></div></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="fc12" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用备忘录</h1><p id="a7e0" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">下面的<code class="fe mz na nb nc b">useMemo</code>和<code class="fe mz na nb nc b">useCallback</code>主要用于性能优化。</p><p id="2b86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅当您已经有性能问题时才使用它们，而不是预先使用它们。否则会增加不必要的复杂性。</p><p id="0da6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mz na nb nc b">useMemo</code>记忆昂贵的函数调用，以便仅在需要时才重新评估它们。</p><p id="989f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React的工作方式是，如果您重新渲染父组件，您也将重新渲染所有子组件。</p><p id="f7a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe mz na nb nc b">useMemo</code>,你给它一个关于如何计算的函数，你给它依赖关系，只有当依赖关系改变时，它才会重新计算。</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="ca15" class="nk lg iq nc b gy nl nm l nn no">const memoizedValue = useMemo(()=&gt;computeExpensiveValue(a, b),[a,b])</span></pre><p id="9998" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">传递一个“创建”函数和一组依赖项。<code class="fe mz na nb nc b">useMemo</code>仅当其中一个依赖关系发生变化时，才会重新计算记忆值。这种优化有助于避免每次渲染时进行昂贵的计算。</p><p id="e1ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有提供数组，每次渲染都会计算一个新值。</p><p id="d84f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住传递给<code class="fe mz na nb nc b">useMemo</code>的函数在渲染时运行。不要做任何渲染时通常不会做的事情。比如副作用属于<code class="fe mz na nb nc b">useEffect</code>，不属于<code class="fe mz na nb nc b">useMemo</code>。</p><p id="e46c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用这个代码沙箱来演示一下。</p><div class="nq nr gp gr ns nt"><a href="https://codesandbox.io/s/react-hooks-in-depth-usememo-ky6jz?fontsize=14" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">React Hooks深入&gt;使用Memo - CodeSandbox</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">为web应用程序定制的在线代码编辑器</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">codesandbox.io</p></div></div><div class="oc l"><div class="oo l oe of og oc oh kw nt"/></div></div></a></div><p id="db73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意这个体验:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/a754ff4c55b6944ea48a10147b6e82f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*i0J1ViWJRJc1A9fz2duWYg.gif"/></div><figcaption class="oq or gj gh gi os ot bd b be z dk translated">使用备忘录—快乐的例子</figcaption></figure><p id="4f64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从一个昂贵的计算开始——Fibonacci(40)——在我们做任何事情之前，如果我们单击<strong class="jp ir"> useMemo示例</strong>标题，我们可以看到标题文本颜色从绿色变为红色。</p><p id="19d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，当我们再次点击增量按钮时——斐波那契(41)——需要一段时间进行计算。计算完成后点击标题，颜色会立即改变。</p><p id="547f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们交换，</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="fbdf" class="nk lg iq nc b gy nl nm l nn no">const fib = useMemo(() =&gt; fibonacci(num), [num]);</span></pre><p id="0b23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="1773" class="nk lg iq nc b gy nl nm l nn no">const fib = fibonacci(num)</span></pre><p id="ed61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们会注意到用户体验差得多——点击标题文本不会像以前一样立即改变颜色——因为每次渲染都要进行昂贵的计算。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/acf217ad2978ac33d911a993c3db9b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*NViRClHfqj_Y0pfdCffo9Q.gif"/></div><figcaption class="oq or gj gh gi os ot bd b be z dk translated">使用备忘录—悲伤的例子</figcaption></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="1409" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用回调</h1><p id="43d6" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated"><code class="fe mz na nb nc b">useCallback</code>与<code class="fe mz na nb nc b">useMemo </code>非常相似，实际上它是用与<code class="fe mz na nb nc b">useMemo</code>相同的机制实现的。</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="8ce3" class="nk lg iq nc b gy nl nm l nn no">const memoizedCallback = useCallback(<br/>  () =&gt; {<br/>    doSomething(a, b);<br/>  },<br/>  [a, b],<br/>);</span></pre><p id="d449" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">传递内联回调和依赖项数组。<code class="fe mz na nb nc b">useCallback</code>将返回回调的记忆化版本，该版本仅在其中一个依赖关系发生变化时才会发生变化。这在向依赖引用相等的优化子组件传递回调以防止不必要的渲染时很有用(例如<code class="fe mz na nb nc b">shouldComponentUpdate</code>)。</p><p id="a3c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mz na nb nc b">useCallback(fn, deps)</code>相当于<code class="fe mz na nb nc b">useMemo(() =&gt; fn, deps)</code>。</p><p id="2cc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，每当React检测到应用程序上层发生变化时，它会重新呈现其下的所有内容。这通常没什么大不了的，因为在正常情况下，反应非常快。但是，有时您会遇到性能问题，因为有些组件不适合毫无理由地重新渲染。</p><p id="c767" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看我们的代码沙箱。</p><div class="nq nr gp gr ns nt"><a href="https://codesandbox.io/s/react-hooks-in-depth-usecallback-b02xk?fontsize=14" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">React Hooks深入&gt;使用回调- CodeSandbox</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">为web应用程序定制的在线代码编辑器</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">codesandbox.io</p></div></div><div class="oc l"><div class="ou l oe of og oc oh kw nt"/></div></div></a></div><p id="7a0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在使用React的一个叫做<code class="fe mz na nb nc b">React.memo</code>的新特性。这类似于<code class="fe mz na nb nc b">PureComponent</code>,一个组件会对它的道具做一个简单的检查，看看它们是否改变了，如果没有，它不会重新渲染这个组件(或者它的孩子，这会咬你一口。)<code class="fe mz na nb nc b">React.memo</code>为功能组件提供此功能。</p><p id="6d29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">鉴于此，我们需要确保给予<code class="fe mz na nb nc b">ExpensiveComputationComponent</code>的函数本身每次都是同一个函数。我们可以使用<code class="fe mz na nb nc b">useCallback</code>来确保React每次都将同一个斐波那契数列传递给<code class="fe mz na nb nc b">ExpensiveComputationComponent</code>，这样它每次都会通过<code class="fe mz na nb nc b">React.memo</code>检查。现在只有当<code class="fe mz na nb nc b">count</code>改变时，它才会真正重新渲染(时间证明了这一点。)</p><p id="65f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，React的<code class="fe mz na nb nc b">memo</code>和<code class="fe mz na nb nc b">useMemo</code>是两码事。</p><p id="b78e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mz na nb nc b">memo</code>的意思是，只要属性没有变化，就不要重新渲染。</p><p id="3a87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe mz na nb nc b">useCallback</code>,你给它一个函数以及你希望这个函数多久更新一次的依赖关系。</p><p id="9f1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意这个体验:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/8f81a203c7d04956bc2ebd142291bf08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*SuQEu3yKSiHrbuz2GM5GPA.gif"/></div><figcaption class="oq or gj gh gi os ot bd b be z dk translated">useCallback —快乐的例子</figcaption></figure><p id="3907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">计时器开始计时，当我们单击按钮时，它会计算斐波那契数列，并更新计算值和上次重新渲染值。</p><p id="b38d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果我们在代码沙箱中交换，</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="6a88" class="nk lg iq nc b gy nl nm l nn no">&lt;ExpensiveComputationComponent</span><span id="b098" class="nk lg iq nc b gy np nm l nn no">compute={useCallback(fibonacci, [])}</span><span id="faf3" class="nk lg iq nc b gy np nm l nn no">count={count}</span><span id="b297" class="nk lg iq nc b gy np nm l nn no">/&gt;</span></pre><p id="2274" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="6152" class="nk lg iq nc b gy nl nm l nn no">&lt;ExpensiveComputationComponent compute={fibonacci} count={count} /&gt;</span></pre><p id="b9f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们会注意到，用户体验要差得多，因为所有渲染都要进行昂贵的计算。计时器不在计时，最后一次重新渲染滞后了。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/6f5bd9d0b8a50c9da163440e9bc65517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ms7PlKsnYLblcUxuF5xppQ.gif"/></div><figcaption class="oq or gj gh gi os ot bd b be z dk translated">useCallback — sad示例</figcaption></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="0937" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">useLayoutEffect</h1><p id="db98" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated"><code class="fe mz na nb nc b">useLayoutEffect</code>与<code class="fe mz na nb nc b">useEffect</code>几乎相同，除了它是同步渲染，而不是像<code class="fe mz na nb nc b">useEffect</code>那样按计划渲染。如果你从一个类组件迁移到一个使用钩子的函数组件，这也会很有帮助，因为<code class="fe mz na nb nc b">useLayoutEffect</code>与<code class="fe mz na nb nc b">componentDidMount</code>和<code class="fe mz na nb nc b">componentDidUpdate</code>同时运行，而<code class="fe mz na nb nc b">useEffect</code>被安排在之后。</p><p id="1b6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你<em class="kl">应该</em>使用<code class="fe mz na nb nc b">useLayoutEffect</code>的唯一时间是测量DOM节点，比如动画。在这个例子中，我们在你每次点击它之后测量文本区域(onClick是为了强制重新渲染。)这意味着您运行了两次render，但也有必要能够捕捉正确的测量值。</p><p id="0718" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有当你需要测量DOM中的东西时，它才非常有用。与<code class="fe mz na nb nc b">useEffect</code>不同，它是同步的。</p><div class="nq nr gp gr ns nt"><a href="https://codesandbox.io/s/react-hooks-in-depth-uselayouteffect-k4l1z?fontsize=14" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">React钩子深度&gt; useLayoutEffect - CodeSandbox</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">为web应用程序定制的在线代码编辑器</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">codesandbox.io</p></div></div><div class="oc l"><div class="ov l oe of og oc oh kw nt"/></div></div></a></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/c7b3f6507afca67b29085fd1081e7dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Wqq2S7t57qSxikFBdtOZuQ.gif"/></div><figcaption class="oq or gj gh gi os ot bd b be z dk translated">useLayoutEffect示例</figcaption></figure><p id="eb02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你使用服务器渲染，记住在JavaScript下载完成之前<em class="kl"/><code class="fe mz na nb nc b">useLayoutEffect</code>和<code class="fe mz na nb nc b">useEffect</code>都不能运行。这就是为什么React在服务器渲染的组件包含<code class="fe mz na nb nc b">useLayoutEffect</code>时会发出警告。要解决这个问题，要么将该逻辑移动到<code class="fe mz na nb nc b">useEffect</code>(如果第一次呈现不需要的话)，要么延迟显示该组件，直到客户端呈现之后(如果HTML在<code class="fe mz na nb nc b">useLayoutEffect</code>运行之前看起来不完整的话)。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="a6bd" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">useImperativeHandle</h1><p id="80cb" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">最有可能永远不会用这个；可能只有库作者使用。</p><pre class="kn ko kp kq gt ng nc nh ni aw nj bi"><span id="1f5d" class="nk lg iq nc b gy nl nm l nn no">useImperativeHandle(ref, createHandle, [deps])</span></pre><p id="3475" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mz na nb nc b">useImperativeHandle</code>定制使用<code class="fe mz na nb nc b">ref</code>时暴露给父组件的实例值。和往常一样，在大多数情况下应该避免使用引用的命令式代码。</p><p id="93ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React有自上而下的数据传递，但是<code class="fe mz na nb nc b">useImperativeHandle</code>颠倒了模型——你实际上可以让一个子节点控制父节点。</p><p id="c3a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将它与另一个名为<code class="fe mz na nb nc b">forwardRef</code>的特性结合使用，同样，你可能不会使用它，但是库将会代表你使用它。让我们先用例子解释它做什么，然后我们再解释运动部件。</p><div class="nq nr gp gr ns nt"><a href="https://codesandbox.io/s/angry-https-71482?fontsize=14" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">React Hooks深入&gt; useImperativeHandle—code sandbox</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">为web应用程序定制的在线代码编辑器</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">codesandbox.io</p></div></div></div></a></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ow"><img src="../Images/7c529bea499ffe12a58b0713dba1a277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xyTyBP5-yzSVyl91_AsHwg.gif"/></div></div><figcaption class="oq or gj gh gi os ot bd b be z dk translated">useImperativeHandle</figcaption></figure><p id="6eb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，每当你有一个<em class="kl">无效的</em>表单，它会立即聚焦第一个无效的字段。</p><p id="7bf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你看一下代码，<code class="fe mz na nb nc b">ElaborateInput</code>是一个子元素，所以父组件不应该对组件中包含的输入有任何访问权。那些组件对他们的父母来说是黑盒。他们能做的就是传道具。那么我们如何完成它呢？</p><p id="dbdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先用的是<code class="fe mz na nb nc b">useImperativeHandle</code>。这允许我们在一个对象上定制方法，通过<code class="fe mz na nb nc b">useRef</code> API提供给父对象。</p><p id="6cf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mz na nb nc b">ElaborateInput</code>中，我们有两个引用:一个是将由父节点提供的引用，通过将<code class="fe mz na nb nc b">ElaborateInput</code>组件包装在<code class="fe mz na nb nc b">forwardRef</code>调用中转发，该调用通常会在函数调用中提供第二个<code class="fe mz na nb nc b">ref</code>参数，然后是用于直接访问DOM的<code class="fe mz na nb nc b">inputRef</code>，这样我们就可以直接在DOM节点上调用<code class="fe mz na nb nc b">focus</code>。</p><p id="57a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从父节点，我们通过<code class="fe mz na nb nc b">useRef</code>给每个<code class="fe mz na nb nc b">ElaborateInput</code>分配一个ref，然后通过<code class="fe mz na nb nc b">forwardRef</code>转发给每个。现在，在父组件中的这些引用上，我们有了在子组件中创建的那些方法，所以我们可以在需要时调用它们。在这种情况下，当父母知道孩子有错误时，我们调用焦点。</p><p id="157c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，你可能会直接使用它，但知道它的存在是件好事。通常情况下，最好不要使用这个钩子，尝试通过道具来完成同样的事情，但有时它可能会有用。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="5291" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乡亲们！谢谢你一直陪着我。希望这能让你在React Hooks上有一个良好的基础。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/ed938cd8470ef104b573193ffba508b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/0*Nyvm-RfAA_0t5kY9.png"/></div></figure><p id="0755" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好👋我是said ur Rahman——Atlassian Growth Team的软件工程师。</p><p id="aa62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Twitter或LinkedIn上与我联系，讨论软件工程和增长黑客技术。</p><p id="dd41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢你花时间来看我的文章！如果你喜欢这篇文章，请把这篇文章推荐给你的朋友。我很想听听你的想法。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><div class="kn ko kp kq gt nt"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">排名前51的React教程-免费学习React。课程由开发人员提交并投票，使您能够…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">gitconnected.com</p></div></div><div class="oc l"><div class="oz l oe of og oc oh kw nt"/></div></div></a></div></div></div>    
</body>
</html>