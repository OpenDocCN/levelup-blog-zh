# Go 中的仿制药:革命万岁！

> 原文：<https://levelup.gitconnected.com/generics-in-go-viva-la-revolution-e27898bf5495>

一个特性可以改变所有这些。

![](img/1d947e97dddb5e361ec5a12bc7104c62.png)

安特·罗泽茨基在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

在我们选择的编程语言中，我们多久经历一次彻底的改变？有些语言更频繁地引入变化，但有些比[温布尔登](https://www.wimbledon.com/)更传统。

这样的语言是过时的。有时候对我来说，它看起来太死板了。“这不是该走的路！”是我梦寐以求的一句话。大多数新的 Go 版本都是同一方向的改进。

一开始，我不会说我喜欢这样的道路。当没有刺激的时候，做一些事情就开始变得无聊。以至于有时候我宁愿看*跟上卡戴珊*。

(*我是开玩笑的。我没有电视的原因之一是为了避免这些电视节目污染我美丽的眼睛。*)

然后…它[发生了](https://go.dev/blog/12years)。Go 团队宣布了一个消息，Go 中的泛型正在成为我们的现实。它不仅仅是关于我们是否应该做和如何做的窃窃私语和无限阐述。

振作起来，革命就要来了。

[](https://blog.ompluscator.com/membership) [## 通过我的推荐链接加入媒体——马尔科·米洛耶维奇

### 作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…

blog.ompluscator.com](https://blog.ompluscator.com/membership) 

# 那么，什么是泛型呢？

![](img/423e125dc091b3b3ae737cf6796cb083.png)

桑迪·米勒在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

> 泛型使我们能够在定义接口、函数、结构时参数化类型。

仿制药[与新概念](https://en.wikipedia.org/wiki/Generic_programming)相去甚远。从 Ada 的第一个版本，到 C++中的模板，再到 Java 和 C#中的现代实现，我们都在使用它。

为了避免任何复杂的定义，让我们检查一下真实的例子——在这里，它给我们一个机会，而不是像这样的许多`Max`或`Min`函数:

只声明一个方法，就像这样:

等等，刚刚发生了什么？我们没有为 Go 中的每种类型定义一个方法，而是使用了泛型——我们使用泛型类型，参数`T`，作为方法的参数。通过这个小小的调整，我们支持所有可订购的类型。

参数`T`代表满足`Ordered`约束的任何类型(稍后，我们将触及约束的主题)。所以，最初，我们需要定义`T`是哪种类型。

接下来，我们定义在哪里使用参数化类型。这里，我们确定输入参数和输出都是`T`类型。如果我们通过将`T`定义为整数来执行该方法，那么这里的所有内容都是整数:

而且不止于此。我们可以提供尽可能多的参数化类型。我们可以把它们分配给不同的输入和输出参数，只要我们喜欢:

这里我们有三个参数，`R`、`S`和`T`。正如我们从约束`any`(其行为类似于`interface{}`)中看到的，这些类型可以是任何类型。

*所以，直到现在，我们都应该清楚什么是泛型，以及在 Go 中如何使用泛型。让我们专注于更令人兴奋的结果。*

## 如何在本地环境中启用泛型？

*当这篇文章公之于众时，泛型还不是 Go 的任何稳定版本的一部分。因此，一些调整是必要的，这样我们可以在本地测试它们。*

为了支持泛型的使用，我使用了 Jetbrains 的 Goland。我在他们的网站上找到了一篇有用的文章，是关于在 Goland 建立一个环境来运行 un 代码的。

与那篇文章唯一的不同是，我使用了带有`master`分支的 Go 源代码([https://go.googlesource.com/go](https://go.googlesource.com/go))而不是文章中的那个。

在`master`分支上，我们可以在新的包中享受来自标准围棋库的[约束](https://go.googlesource.com/go/+/refs/heads/master/src/constraints/constraints.go)。

# 斯比德，给我我想要的。

![](img/a169d233b3f3c27364ecfebe397e85c6.png)

照片由[斯潘塞·戴维斯](https://unsplash.com/@spencerdavis?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

> Go 中的泛型和反射不一样。

在跳到一些复杂的例子之前，检查一下泛型的基准分数是很重要的。从逻辑上讲，我们不期望性能接近[反射](https://gist.github.com/nfisher/a9aa2d34fedb338667bf)，因为在这种情况下，我们不需要泛型。

当然，泛型无论如何都不接近反射。这也不是我的本意。如果有什么不同的话，至少在某些用例中，泛型是生成代码的一种替代方法。

所以，这意味着我们的期望是，基于泛型的代码与“传统”执行的代码具有相同的基准测试结果。因此，让我们检查一个基本情况:

以下是将一种类型转换成另一种类型的小方法。`Number`我们的约束是建立在来自 Go 标准库的`Integer`和`Float`约束之上的吗(同样，我们将处理这个主题)。

`Number`可以是围棋中的任意数值类型:从`int`的任意导数，到`uint`、`float`等等。方法`Trasforms`期望以第一个参数化数值类型`S`作为切片基的切片，并将其转换为以第二个参数化类型`T`作为切片基的切片。

简而言之，如果我们想将`ints`的一部分转换成`floats`的一部分，我们可以像在`main`函数中那样调用这个方法。

对于我们的函数来说，非泛型的替代方法应该是期望一部分整型数并返回一部分浮点型数的方法。这就是我们将在基准测试中测试的内容:

没有惊喜。这两种方法的执行时间实际上是一样的，所以使用泛型不会影响我们应用程序的性能。但是，对结构有什么影响吗？

让我们试试。现在，我们将使用结构并给它们附加方法。任务是相同的—将一个切片转换成另一个切片:

同样，没有惊喜。使用泛型或经典实现不会给 Go 代码的性能带来任何影响。是的，事实是我们没有测试太复杂的情况，但是如果有显著的差异，我们已经体验到了。

所以，我们可以安全地走了。

# 限制

![](img/2926a62df0eb99a792d387795850cd78.png)

照片由[阿玛多·洛雷罗](https://unsplash.com/@amadorloureiroblanco?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

> 如果我们想测试更复杂的例子，添加任何参数化的类型并运行应用程序是不够的。

如果我们决定对一些变量做一个简单的例子而不进行任何复杂的计算，那么我们就不需要添加任何特殊的东西:

除了我们的方法`Max`不计算它的输入的最大值，而是返回它们，在上面的例子中没有什么奇怪的。为此，我们使用一个参数化类型`T`，定义为`interface{}`。

在这个例子中，我们不应该把`interface{}`看作一个类型，而是一个约束。我们使用约束来定义参数化类型的规则，并给 Go 编译器一些背景知识。

重复一下:我们在这里不使用`interface{}`作为类型，而是作为约束。我们为参数化类型定义规则，在这种情况下，该类型必须支持`interface{}`所做的一切。因此，实际上，我们也可以在这里使用`any`约束。

*(老实说，在所有的例子中，我更倾向于使用* `*interface{}*` *而不是* `*any*` *，因为我的 Goland IDE 不支持新的保留字(* `*any*` *，* `*comparable*` *)，然后我的 IDE 中出现了大量的错误消息，并破坏了自动完成功能。)*

在编译时，编译器可以接受一个约束，并使用它来检查参数化类型是否支持我们希望在下面的代码中执行的操作符和方法。

由于编译器在运行时进行大部分优化(因此，我们不会影响运行时，正如我们在基准测试中看到的)，它只允许为特定约束定义的操作符和函数。

因此，为了了解约束的重要性，让我们完成`Max`方法的实现，并尝试比较`a`和`b`变量:

当我们试图触发应用程序时，我们得到一个错误— *操作符>没有在 T* 上定义。因为我们将`T`类型定义为`any`，所以最终类型可以是任何类型。从那时起，编译器不知道如何处理这个操作符。

为了解决这个问题，我们需要将参数化类型`T`定义为允许这种操作符的约束。感谢漂亮的围棋团队，我们已经有了包[约束](https://go.googlesource.com/go/+/refs/heads/master/src/constraints/constraints.go)，有这样的约束。

我们想要使用的约束的名称是`Ordered`，经过修改后，我们的代码非常好用:

通过使用`Ordered`约束，我们得到了我们的结果。这个例子中的好处是我们可以看到编译器如何解释最终的类型 T，这取决于我们传递给方法的值。

不需要像前两种情况那样在方括号中定义实际类型，编译器就可以识别用于参数的类型——在 Go 的情况下，应该是`int`和`float64`。

另一方面，如果我们想使用一些非默认类型，比如`int64`或`float32`，我们应该严格地将这些类型放在方括号中。然后我们给编译器确切的信息，告诉它要做什么。

如果需要，我们可以扩展函数`Max`中的功能，以支持在数组中搜索最大值:

在这个例子中，我们可以看到两个有趣的点:

1.  在方括号中定义了类型 T 之后，我们可以在函数签名中以许多不同的方式使用它:简单类型、切片类型，甚至是映射的一部分。
2.  当我们想要返回一个特定类型的零值时，我们可以使用`T(0)`。Go 编译器足够聪明，可以将零值转换成所需的类型，就像第一种情况下的空字符串一样。

我们有机会看到比较某种类型的值是一种什么样的约束。有了`Ordered`约束，我们可以使用在整数、浮点和字符串上定义的任何操作符。

如果我们想使用操作符`==`，我们可以使用一个新的保留字`comparable`，这是一个唯一的约束，只支持这样的操作符，不支持其他操作符:

在上面的例子中，我们可以看到我们应该如何使用`comparable`约束。同样，编译器可以识别实际类型，即使没有在方括号中严格定义它们。

在示例中要提到的一点是，我们在两种不同的方法`Equal`和`Dummy`中对两种参数化类型使用了同一个字母 *T* 。

每个`T`类型只在方法的作用域(或结构及其方法)中定义，我们不谈论其作用域之外的同一个`T`类型。我们可以用不同的方法重复同一个字母，类型仍然是相互独立的。

## 自定义约束

我们可以定义自定义约束，这非常简单。约束可以是我们想要的任何类型，但是最好的选择可能是使用接口:

我们定义了一个接口 Greeter，这样我们就可以在 Greetings 方法中使用它作为约束。在这里，我们可以直接使用 Greeter 类型的变量，而不是泛型，但这对于演示来说是可以接受的。

## 类型集

> 每种类型都有一个关联的类型集。一个普通的非接口类型`T`的类型集合就是只包含`T`本身的集合`{T}`。接口类型的类型集(在这一节我们只讨论普通的接口类型，没有类型列表)是声明接口所有方法的所有类型的集合。

上述定义来自[类型组](https://github.com/golang/go/issues/45346)的建议。它已经存在于 Go 源代码中，所以我们可以在任何我们喜欢的地方使用它。

这个显著的变化为我们带来了新的可能性:我们的接口类型也可以嵌入基本类型，像`int`、`float64`、`byte`而不仅仅是其他接口。这个特性使我们能够定义更灵活的约束。

让我们看看下面的例子:

我们定义了我们的`Comparable`约束。那种类型看起来有点奇怪，对吗？

Go 中使用类型集的新方法允许我们定义一个应该是类型联合的接口。为了描述两个类型之间的联合，我们应该将它们放在接口中，并在它们之间放置一个操作符`|`。

所以，在我们的例子中，可比接口是类型的并集:`rune`、`float64`和……我猜是`int`？是的，它的确是`int`，但是这里定义为*近似元素*。

正如你在类型集的建议中看到的，近似元素`T`的类型集是类型`T`的类型集，以及所有底层类型为`T.`的类型

因此，仅仅因为我们使用了`~int`近似元素，我们就可以向比较方法提供我们的`customInt`类型的变量。如您所见，我们将`customInt`定义为自定义类型，其中`int`是底层类型。

如果我们不添加一个操作符`~`，编译器会抱怨，不执行应用程序。

*所以，这就开始严重了。*

# 我们能走多远？

![](img/ece7726689111abed4e64c7d6e00f30a.png)

由 [YUCAR FotoGrafik](https://unsplash.com/@yucar?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

> 我们想去哪就去哪。

说真的，这个特性彻底改变了语言。我是说，很多新代码[不断出现](https://github.com/golang/go/issues/45955)。这可能会对依赖代码生成的包产生重大影响，比如 [Ent](https://entgo.io/docs/getting-started/) 。

从标准库开始，我已经可以看到许多代码在未来版本中被重构以使用泛型。泛型甚至可能导致一些 ORM 的发展，我们过去在理论中看到的，例如。

例如，让我们考虑一个来自 [Gorm](https://gorm.io/index.html) 包的模型:

假设我们想在 Go 中为两个模型(`ProductGorm`和`UserGorm`)实现[存储库](https://deviq.com/design-patterns/repository-pattern)模式。对于目前稳定版的 Go，我们只能做以下一种解决方案:

1.  编写两个独立的存储库结构
2.  编写应该使用模板来创建这两个存储库结构的代码生成器
3.  决定不使用存储库

现在，有了泛型，horizon with opportunities 转向了更灵活的方法，我们可以这样做:

所以，我们有我们的`Repository`结构，带有参数化类型`T`，可以是任何东西。注意，我们只在`Repository`类型定义中定义了`T`，并且我们只是传递了它的指定函数。

这里我们只能看到两种方法，`Create`和`Get`，只是为了演示。为了便于演示，让我们创建两个独立的方法来初始化不同的`Repositories`:

这两个方法返回预定义类型的存储库实例，就像快捷方式一样。让我们对我们的小应用程序进行最后的测试:

是的，这很有效。一个存储库实现，支持两种模型。零反射，零代码生成。我以为在围棋里再也看不到这样的东西了。

*我好开心。我想我会哭。*

# 结论

毫无疑问，泛型在 Go 中是一个巨大的变化。能够迅速改变 Go 使用方式的变化，以及能够在短期内在 Go 社区中引起许多重构的变化。

虽然我几乎每天都在玩泛型，试图看看我们可以期待更多的东西，但我已经迫不及待地想在稳定的 Go 版本中看到它们了。革命万岁！