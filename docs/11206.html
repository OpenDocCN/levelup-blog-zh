<html>
<head>
<title>Towards Analytics with Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redis进行分析</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/towards-analytics-with-redis-f2bccb6db77c?source=collection_archive---------2-----------------------#2022-02-25">https://levelup.gitconnected.com/towards-analytics-with-redis-f2bccb6db77c?source=collection_archive---------2-----------------------#2022-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9c66" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用散列和二进制数据结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4bf1e1bffa15d18ccee9425969e415f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DgrG1ysbUABvMSXMrlbwA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。Redis标识通过<a class="ae ky" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank">https://redis.io/</a>。版权Redis有限公司</figcaption></figure><p id="53bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能想知道为什么有人会直接在Redis中进行任何类型的分析处理。为什么不坚持传统的OLAP风格的SQL呢？</p><p id="9df2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很高兴你问了。Redis已经存在了一段时间，是一个经过验证的高性能、低维护的数据库和优秀的多用途缓存。Redis很特别，因为它实际上是一个<strong class="lb iu">数据结构</strong>存储，具有对复杂数据表示的高级随机访问能力:从<a class="ae ky" href="https://redis.io/commands#bitmap" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">位图</strong> </a>和<a class="ae ky" href="https://redis.io/commands#hash" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">哈希</strong> </a>集到实时<a class="ae ky" href="https://redis.io/commands#stream" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">流</strong> </a>类型，本质上是一个按照插入时间顺序排序的行的<a class="ae ky" href="https://redis.io/commands#sorted-set" rel="noopener ugc nofollow" target="_blank">排序集</a>，其中每一行都由一个类似哈希集的条目表示。</p><p id="f776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到正题，Redis支持传统分析处理数据库所不具备的访问模式，这意味着您可以灵活运用您的创造力来解决问题，否则您将需要支持多个替代数据库、流平台(Kafka/Pulsar)和API服务来实现*相同的结果。</p><p id="28e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将看看如何使用位图、散列和流数据类型来解决实际问题。</p><h2 id="342d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">让Redis在Docker上运行</h2><p id="13a3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您可以使用Docker从您的终端(或最喜欢的shell程序)使用下面的命令启动一个单节点Redis集群。(*要求<a class="ae ky" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> Docker安装在您的机器上</a>)。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="bb24" class="lv lw it mu b gy my mz l na nb">docker network create --driver bridge analytics<br/>docker run --network analytics -p 6379:6379 --name redis6 -e ALLOW_EMPTY_PASSWORD=yes -dP redis redis-server</span></pre><p id="26f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令(您刚才运行的)将下载<a class="ae ky" href="https://hub.docker.com/_/redis" rel="noopener ugc nofollow" target="_blank">最新的官方稳定Redis映像</a>(在撰写本文时为6.2.6)，除非您已经将redis:latest下载到docker映像缓存(您可以使用:<code class="fe nc nd ne mu b">docker images redis</code>进行检查)，然后它将使用一个名为<em class="nf"> analytics </em>的桥启动容器(运行)到您的主机(笔记本电脑/计算机)网络，作为一个分离的d进程。分离的进程只是意味着stdout / stderr容器日志不会通过管道传输到您的终端，如果需要，您可以稍后重新附加到容器。</p><p id="c3d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将对Redis的运行做一个简单的健全性检查。在同一个终端窗口中，您可以使用docker exec命令来访问和执行<strong class="lb iu"> redis-cli </strong>(又名redis shell)程序。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1715" class="lv lw it mu b gy my mz l na nb">docker exec -it redis6 redis-cli</span></pre><p id="1eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会看到<em class="nf"> 127.0.0.1:6379 &gt; </em>提示，这意味着你已经准备好摇滚我的朋友！</p><blockquote class="ng nh ni"><p id="0957" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated"><strong class="lb iu">关于容器行为的说明:</strong> <em class="it">我们在前面的<code class="fe nc nd ne mu b">docker run</code> <em class="it">命令中创建了一个名为</em> <strong class="lb iu"> <em class="it"> redis6 </em> </strong>的命名容器。这让我们可以使用docker exec命令，使用您提供的名称(redis6)而不是docker运行时给出的随机名称轻松访问容器。副作用是您将不得不停止并删除这个容器来修改容器配置。例如，如果您尝试再次运行该命令(从上面),您将看到以下错误消息:</em></p><p id="dfd6" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">docker:来自守护程序的错误响应:冲突。容器名称“/redis6”已被容器“{长容器uuid}”使用。您必须删除(或重命名)该容器才能重用该名称。</p><p id="a8d8" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated"><em class="it">您可以通过简单地执行以下命令来解决这个小问题:</em> <code class="fe nc nd ne mu b"><em class="it">docker stop redis6 &amp;&amp; docker rm redis6.</em></code></p><p id="2309" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">最后一个关于数据持久性的小问题</em> </strong> <em class="it">。因为Redis数据库(存储为一个</em> rdb <em class="it">文件)是在容器(redis6)内部创建和存储的，这更重要地意味着当您执行stop &amp; </em> remove <em class="it">命令时，您也将删除存储在数据库中的任何数据。</em></p><p id="a390" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated"><em class="it">这是因为</em>容器<em class="it">被设计为对于特定标签和sha256对的生命周期是不可变的(不可更改的),而容器可以使用环境变量和卷装载来临时增加容器。实际的容器映像对您的修改没有任何记忆。这保证了在文件系统、操作系统等方面遵循严格的无意外规则的容器状态方面，您将拥有一个可靠且一致的运行时环境。</em></p><p id="948d" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated"><em class="it">您可以使用</em> <a class="ae ky" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank"> <em class="it">卷</em> </a> <em class="it">来解决数据持久性问题，缺乏数据持久性——这些卷是附加到容器中特定路径的持久性磁盘(或内存)片。卷通常用于将机密和其他配置安装到公共基础容器映像。</em></p></blockquote><p id="ac6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">创建和使用持久卷</strong> <em class="nf"> <br/> </em>现在在我们开始之前修改东西。如果您之前创建了redis6容器，您可以停止并删除它，然后继续使用以下命令创建redis6卷。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1b03" class="lv lw it mu b gy my mz l na nb">docker volume create redis6</span></pre><p id="2126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经创建了一个持久卷，您可以将该卷挂载到Redis容器，然后您将有一种方法返回数据(除非您丢失了磁盘)。</p><blockquote class="ng nh ni"><p id="abb5" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:主机上为Docker运行时分配的总磁盘空间将用于这个卷。您可以使用<code class="fe nc nd ne mu b">docker volume ls</code>查看所有docker卷，使用<code class="fe nc nd ne mu b">docker volume inspect redis6</code>查看redis6卷的特定信息。</p></blockquote><h2 id="48da" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用持久卷和一致的Redis映像启动Redis备份</h2><p id="70be" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">就像我在上面关于容器行为的说明中提到的，第一个快速启动命令创建了一个临时Redis容器，它会忘记在容器运行期间对它所做的任何更改。幸运的是，使用持久卷意味着您的数据将在停止/删除周期之间存在，因此您可以在最小的顾虑下更改容器配置等。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2fad" class="lv lw it mu b gy my mz l na nb">docker run \<br/> — name redis6 \<br/> — network analytics \<br/> -v redis6:/data \<br/> -p 6379:6379 \<br/> -e ALLOW_EMPTY_PASSWORD=yes \<br/> -dP \ redis:6.2.6@sha256:eaa2697033320e8b58b920f5f4aa0c56e8fa5eacf9094168504c7eeabbac8468 redis-server</span></pre><p id="ebc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们继续学习使用Redis散列存储每日和每周数据。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="e6df" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">数据结构模式:存储每日和每周每小时的总数</h2><p id="085c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">很高兴你还在阅读。</p><p id="2987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据结构</strong> : <a class="ae ky" href="https://redis.io/topics/data-types#hashes" rel="noopener ugc nofollow" target="_blank">哈希</a> <br/> <strong class="lb iu">密钥模式</strong> : <code class="fe nc nd ne mu b">{key-prefix}:{version}:{region}:{dataset}:{identifier_tag}:{date-pattern}<br/></code> <strong class="lb iu">示例密钥</strong> : <code class="fe nc nd ne mu b">acme:v1:us:carts:completed:2022:w:1</code></p><p id="aeea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的示例关键字中，我们使用的是一年中的<em class="nf">数字周</em>。这样，没有人需要为日期计算而烦恼，我们可以让Redis有效地压缩全局Redis键空间中较短的键。日期模式的值是2022年第1周的{w:1}。<em class="nf">*日期模式也可以简化为您自己的用例。只要确保您尝试了一些东西来看看什么是有效的，或者遵循其他最佳实践，比如使用yyyy:MM:dd样式的字符串模式。</em></p><blockquote class="ng nh ni"><p id="6d42" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">目标:存储一周7天中的小时数，以获得小时总数</p></blockquote><p id="184b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我们的键(<strong class="lb iu">acme:v1:us:carts:completed:w:1</strong>)相关联的Redis散列集存储一个星期几(0–6)和一天中的小时(0–23)指针的集合，例如[0–6]:[0–23]存储与一周中特定一天的某个小时的[已完成购物车总数]相关联的数值。</p><p id="cccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何设置这个值呢？</p><h2 id="aa76" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用HSET编写每小时购物车数据</h2><p id="729c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">使用Redis cli，您可以将Sunday @ 00:00:00–00:59:59完成的购物车交易总数设置到散列中:将一个或多个键值对添加到公共散列的签名是<code class="fe nc nd ne mu b">HSET key field value [field value...]</code></p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="527e" class="lv lw it mu b gy my mz l na nb">127.0.0.1:6379&gt; HSET <!-- -->acme:v1:us:carts:completed:w:1<!-- --> 0:0 100000<br/>~~~</span></pre><blockquote class="ng nh ni"><p id="0b9b" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">T <!-- --> ip:现在，您不会期望有人手动输入所有这些数据，而是希望将这些分析数据作为管道作业或流聚合的副产品写入Redis，以便从您的数据生态系统中的其他数据系统快速访问，从而实现以下目标:a)缓存数据以用于更复杂的用例，或者b)保护对真实数据源的更昂贵的调用。</p></blockquote><h2 id="bd67" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用HGETALL获取购物车数据</h2><p id="128a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">要收集哈希映射中可用的所有键和已完成的购物车总数(如果我们对一周中的所有小时记录执行<em class="nf">0–6:0–23</em>，则总共有168个可能的键)，或者要收集一个子集或部分一周的数据，您可以使用<strong class="lb iu"> <em class="nf"> HGETALL </em> </strong>来获取与<em class="nf">键</em>相关联的<strong class="lb iu"> <em class="nf">哈希</em> </strong>中的所有元组。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2dad" class="lv lw it mu b gy my mz l na nb">127.0.0.1:6379&gt; HGETALL <!-- -->acme:v1:us:carts:completed:w:1<br/> 1) "0:0"<br/> 2) "100000"<br/> 3) "0:1"<br/> 4) "120000"<br/> 5) "0:2"<br/> 6) "150000"<br/> 7) "0:3"<br/> 8"250000"<br/> 9) "0:4"<br/>10) "290000"<br/>11) "0:5"<br/>12) "450000"<br/>13) "0:6"<br/>14) "450000"<br/>15) "0:7"<br/>16) "450000"<br/>17) "0:8"<br/>18) "450000"<br/>19) "0:9"<br/>20) "1200000"<br/>21) "0:10"<br/>22) "1800000"<br/>23) "0:11"<br/>24) "2300000"<br/>25) "0:12"<br/>26) "2900000"<br/>27) "0:13"<br/>28) "3600000"<br/>29) "0:14"<br/>30) "2600000"<br/>31) "0:15"<br/>32) "2200000"<br/>33) "0:16"<br/>34) "1200000"<br/>35) "0:17"<br/>36) "900000"<br/>37) "0:18"<br/>38) "1000000"<br/>39) "0:19"<br/>40) "1200000"<br/>41) "0:20"<br/>42) "1600000"<br/>43) "0:21"<br/>44) "1300000"<br/>45) "0:22"<br/>46) "600000"<br/>47) "0:23"<br/>48) "650000"<br/>...</span></pre><p id="38df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面输出中显示的底层指标(购物车总数)都作为无符号整数有效地存储在内部，除非您添加负数<em class="nf">(除非您开始考虑退货，否则您不会希望添加负数，因为0销售是最小的数量——但这将在解释的这一点上使事情变得复杂)</em>。除了能够获取用于内部或外部客户的仪表板或其他API的分析数据之外，您还可以通过签名(day_of_week:hour_of_day)获取单个元组作为比较的基础，以通过简单地比较存储在简单Redis数据结构中的其他简单值来构成更高阶的分析(如放弃率，或每小时完成的与开始的购物车的百分比)。</p><p id="8d57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我为周日生成一整天[0:0…0:23],并后退一步查看Redis中的开销。我可以使用debug object特性来获取前面的键所表示的数据结构的<em class="nf">编码</em>和<em class="nf"> serializedlength </em>属性，只对键模式做了微小的修改(d表示一天，而w表示一周——该模式允许您使用一年中的几天或几周——而不改变键的共享公共前缀(<em class="nf"> acme:v1:us:carts:{…} </em>)。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7b30" class="lv lw it mu b gy my mz l na nb">127.0.0.1:6379&gt; debug object <!-- -->acme:v1:us:carts:completed:d:1<br/>Value at:0x7ff7c4866670 refcount:1 encoding:ziplist serializedlength:217 lru:8641926 lru_seconds_idle:30</span></pre><p id="db05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用debug对象的输出告诉我们，存储一整天的无符号整数每天只占用217个字节。此外，由于散列集的大小(24个字符串/uint32个元组), Redis使用<a class="ae ky" href="https://redis.com/ebook/part-2-core-concepts/01chapter-9-reducing-memory-use/9-1-short-structures/9-1-1-the-ziplist-representation/" rel="noopener ugc nofollow" target="_blank"> ziplist </a>编码对数据进行编码，最多默认512个条目。</p><p id="c51f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，回到使用散列数据结构。</p><h2 id="2b0b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">获取星期日下午12点(UTC)的小时总数</h2><p id="2982" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了获取一个条目，我们只需要知道位置。星期日是0(而星期六是6)，第12个小时的小时偏移量是11。为了清楚起见，您也可以将指针调整为从1开始。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f057" class="lv lw it mu b gy my mz l na nb">127.0.0.1:6379&gt; HGET acme:v1:us:carts:completed:w:1 0:12<br/>"2300000"</span></pre><blockquote class="ng nh ni"><p id="7906" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">提示:创建一个RedisKey Builder库或特定的高级SDK可以帮助解决使用Redis带来的复杂性，就像我在这里展示的那样。</p></blockquote><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="cd81" class="lv lw it mu b gy my mz l na nb">val total = Carts({version:1,region:us,path:acme})<br/>  .weekOf("2022-02-21")<br/>  .completed()<br/>  .getOrElse(...)</span></pre><p id="c47e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个。我们将看看如何使用位域存储布尔数据。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h2 id="5c93" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">数据结构模式:存储日常用户活动</h2><p id="b1b4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">下一个模式将向您展示如何在Redis中使用位图有效地存储日常用户活动。</p><blockquote class="ng nh ni"><p id="a9e8" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>我们很多人都写过或者至少读过关于如何建立注册系统的文章。基于整数的标识符和UUIDs可能是一个热门话题。假设最大的整数值约为21亿，让我们假设您有一个分布式注册系统，确保系统中的每个客户(用户)都有自己的自动递增id，您的规模小于21.4亿。如果我们使用整数来表示用户，那么我们会得到一个更小的密钥，这有助于减少密钥空间的开销，否则UUID v4可以，但会带来额外的开销。</p></blockquote><p id="8064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据结构</strong>:二进制字符串(带位操作的字节数组)<br/> <strong class="lb iu">密钥模式</strong> : <code class="fe nc nd ne mu b">{key-prefix}:{version}:{region}:{dataset}:{identifier_tag}:{date-pattern:yyyy:MM}<br/></code> <strong class="lb iu">示例密钥</strong> : <code class="fe nc nd ne mu b">acme:v1:us:users:active:0:2022-02</code></p><p id="2231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的示例键对应于整数id为0的用户。如果使用UUIDs，那么您可能会看到像<code class="fe nc nd ne mu b">acme:v1:us:users:active:917dfa61–3c56–4e59-a595–37bb20c40a1d:2022–02</code>这样的键，由于键的长度，它会有一些额外的内存开销。</p><h2 id="3898" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">设置每日活动位</h2><p id="81b7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">去掉繁文缛节(见上面的注释)。让我们从零号用户开始。我们将使用SETBIT为用户设置活动/非活动状态。</p><p id="4f89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从设置每月的前3天开始。[0–2]，在2022年2月1日和3日有效。我们将添加第一条记录，检查内存开销，然后添加另外两天。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7d85" class="lv lw it mu b gy my mz l na nb">127.0.0.1:6379&gt; SETBIT acme:v1:us:users:active:2022–02 0 1</span></pre><p id="4546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里检查内存开销。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8e68" class="lv lw it mu b gy my mz l na nb">127.0.0.1:6379&gt; memory usage acme:v1:us:users:active:2022–02<br/>(integer) 76</span></pre><p id="72c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在再加两天。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="17ba" class="lv lw it mu b gy my mz l na nb">127.0.0.1:6379&gt; SETBIT acme:v1:us:users:active:2022–02 1 0<br/>127.0.0.1:6379&gt; SETBIT acme:v1:us:users:active:2022–02 2 1</span></pre><p id="92a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程现在可能越来越乏味了。鉴于此，我们可以使用<a class="ae ky" href="https://redis.io/commands/bitfield" rel="noopener ugc nofollow" target="_blank">位域</a>命令给位图添加更多的值。让我们使用Bitfield命令将剩下的日子设置为二月的前7天。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="f700" class="lv lw it mu b gy my mz l na nb">BITFIELD acme:v1:us:users:active:2022–02 SET u1 3 1 SET u1 4 1 SET u1 5 0 SET u1 6 0</span></pre><blockquote class="ng nh ni"><p id="8dd4" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">BITFIELD命令是<em class="it">可变的，</em>意味着它可以接受零个或多个附加的SET {encoding} {offset} {value}对。在这里，我们为用户设置第3-6天。有趣的是，因为我们在这里处理的是位，所以由于在初始字节数组上设置了&lt; 8值，我们没有改变存储这些信息所需的内存开销。1字节是8位，我们也需要一些缓冲空间。我们可以通过调用<code class="fe nc nd ne mu b">debug object acme:v1:us:users:active:2022–02.</code>来确认这一点，你会看到serializedlength仍然是2个字节。</p><p id="6e3b" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">127.0.0.1:6379 &gt;调试对象acme:v1:us:users:active:2022–02<br/>值at:0xf55d8330 refcount:1编码:raw serialized length:2 LRU:1578061 LRU _ seconds _ idle:46</p></blockquote><p id="d335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设每个位的默认值为0，那么对于非活动日，我们实际上不需要做任何事情。我们只需要最终分配一个足够大的二进制字符串来保存未来几天的偏移量。Redis位图只是二进制编码字符串上的访问方法。</p><p id="688b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设我们的用户在这个用例中(上面)去度假7天，然后开始断断续续地回来你提供的任何令人敬畏的服务。我们不需要做任何事情，直到下次用户激活时添加一个值。接下来让我们看看对“稀疏”字段的支持。</p><h2 id="ed61" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">稀疏字段支持</h2><p id="6ffe" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">今年二月有28天。我们的位偏移指数是0–27个值，以最终说明。我们已经填写了前7天的活动/不活动位[0–6]。由于用户正在度假，我们跳过接下来的7天[7–14]。他们在本月16日回来时又开始了服务。<em class="nf">*是的，写这个和读这个一样令人困惑，但是我们不想浪费时间！</em></p><p id="9a2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下内容设置了该月16日、19日、24日和28日的活动用户位。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0427" class="lv lw it mu b gy my mz l na nb">BITFIELD acme:v1:us:users:active:2022–02 SET u1 15 1 SET u1 18 1 SET u1 23 1 SET u1 27 1</span></pre><p id="ec3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以看到Redis后台是如何分配内存的，这使得支持字节数组能够动态增长，因为我们的用户在二月的28天中的特定几天是活动的。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9228" class="lv lw it mu b gy my mz l na nb">127.0.0.1:6379&gt; memory usage acme:v1:us:users:active:2022–02<br/>(integer) 84</span><span id="11af" class="lv lw it mu b gy nt mz l na nb">127.0.0.1:6379&gt; debug object acme:v1:us:users:active:2022–02<br/>Value at:0xf55d8330 refcount:1 encoding:raw serializedlength:5 lru:1579962 lru_seconds_idle:53</span></pre><h2 id="152c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">查找一个月的总活动天数</h2><p id="5a1e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这里有趣的是，我们可以计算出用户是活动的还是非活动的(整个月)，因为在没有创建密钥的情况下，没有用户的记录。检查。有趣的是，我们还可以通过检查位图的<a class="ae ky" href="https://redis.io/commands/bitcount" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">位计数</strong> </a>来计算出用户已经活动了多少天(总共)。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ed55" class="lv lw it mu b gy my mz l na nb">127.0.0.1:6379&gt; bitcount acme:v1:us:users:active:2022–02<br/>(integer) 7</span></pre><p id="ed31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们知道用户已经活跃了7天。bitcount运算是O(N ),但是由于它的大小很小，所以它的作用类似于O(1)。我不知道常量时间分析的许多替代方法。考虑一下这样做的效率有多高(是的，这样做更困难，但是也不简单……)这种方法的替代方法需要查询用户活动，这可能是对存储在您的数据仓库或数据湖中的活动数据的计算开销很大的查询！</p><h2 id="f6f5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">计算用户在一个月的某一天是否活跃</h2><p id="f601" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">最后一个例子展示了如何使用BITFIELD命令通过偏移量获得一个特定的值，在我们的例子中是第一天的索引。我们将检查两天，我们显式地设置了该月24日的值，但从未为22日添加记录。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="60ee" class="lv lw it mu b gy my mz l na nb">127.0.0.1:6379&gt; BITFIELD acme:v1:us:users:active:2022–02 GET u1 21<br/>1) (integer) 0</span><span id="7166" class="lv lw it mu b gy nt mz l na nb">127.0.0.1:6379&gt; BITFIELD acme:v1:us:users:active:2022–02 GET u1 23<br/>1) (integer) 1</span></pre><p id="bc5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到一个整数响应数组。这是因为我们可以选择从位图返回多个值(就像SET功能是可变的一样，GET也是可变的)。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e999" class="lv lw it mu b gy my mz l na nb">127.0.0.1:6379&gt; BITFIELD acme:v1:us:users:active:2022–02 GET u1 21 GET u1 23<br/>1) (integer) 0<br/>2) (integer) 1</span></pre><h2 id="5791" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">Redis流</h2><p id="afd0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我将在2022年4月出版的一本名为《使用Apache Spark的现代数据工程》的书中介绍如何使用Redis流数据类型。它涵盖了比这篇博文更高级的用例，无论你的职业生涯走向何方，你都可以随身携带实践材料。</p><div class="nu nv gp gr nw nx"><a href="https://www.amazon.com/Modern-Engineering-Apache-Spark-Hands/dp/1484274512/" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">使用Apache Spark的现代数据工程:构建关键任务流的实践指南…</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">Amazon.com:使用Apache Spark的现代数据工程:构建关键任务流的实践指南…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">www.amazon.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><h2 id="9888" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="b5d1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我希望这篇关于在Docker上使用Redis进行分析的介绍让你感到兴奋，或者至少是有趣的。Redis是您的数据工程和工程工具箱中一把迷人的瑞士军刀。它也很可爱。我很幸运地在2012年“不得不”使用Redis，十年后，我仍然热爱我的工作。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><blockquote class="ng nh ni"><p id="6de0" class="kz la nf lb b lc ld ju le lf lg jx lh nj lj lk ll nk ln lo lp nl lr ls lt lu im bi translated">*是的。我有意跳过关于Redis集群的局限性、内存成本与闪存成本与ssd成本与hdd成本、拥有数百万个关键字的海量数据存储的规模经济、OLAP数据库(如<a class="ae ky" href="https://druid.apache.org/" rel="noopener ugc nofollow" target="_blank">德鲁伊</a> / <a class="ae ky" href="https://pinot.apache.org/" rel="noopener ugc nofollow" target="_blank">皮诺</a> / <a class="ae ky" href="https://clickhouse.com/" rel="noopener ugc nofollow" target="_blank"> ClickHouse </a>)的利与弊的讨论，并以实际的事实来证实我上面关于使用Redis简化数据堆栈的论点。数据决策和技术选择是多方面的，这篇文章旨在向您介绍一种细微的数据服务方法。</p></blockquote></div></div>    
</body>
</html>