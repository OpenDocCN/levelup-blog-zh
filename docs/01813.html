<html>
<head>
<title>A reduced explanation of Redux. (Reducers, Actions, and Store)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux的简化解释。(减少器、动作和存储)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-reduced-explanation-of-redux-reducers-actions-and-store-9b7819c5d064?source=collection_archive---------12-----------------------#2020-01-30">https://levelup.gitconnected.com/a-reduced-explanation-of-redux-reducers-actions-and-store-9b7819c5d064?source=collection_archive---------12-----------------------#2020-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/35a9c0667322df82116d16aa95c50976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87dJ5EB3ydD7_AbhKb4UOQ.png"/></div></div></figure><h2 id="e805" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">介绍</h2><p id="d4c8" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">当我在钻研Redux的时候，我认为写这篇博客有两个目的是个好主意，边写边学，也许还能帮助其他程序员理解这个概念。起初这很奇怪(就像我学到的所有编程知识一样)，但实际上非常简单。因此，没有进一步应有的让我们深入了解Redux的力量。</p><h2 id="deae" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">Redux的威力到底有多大？</h2><p id="1c0a" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">所以如果你以前用过React，你就会知道有一种东西叫做状态。这个“状态”是一个非常有用的工具，用于管理我们希望在组件中显示或使用的某些东西，要在子组件中使用这个状态，我们必须以道具的形式传递它。这可能会变得有点乏味，你必须多次向下传递它，计算机必须多次向上移动到它的父组件才能改变状态。</p><p id="400b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">所以Redux在这里可以在一个地方管理状态！使用normal React，应用程序中的状态可以通过许多组件传递，这使得简单的状态更改有时成为一项有点繁重的任务。也许你有一个状态，它必须移动10次到子组件来改变状态，那么这个过程将会一直移动10次回到这个状态，然后改变它。有了Redux，状态可以存在于一个叫做“store”的地方。商店将托管所有的状态，这样无论何时调用状态的更改过程都只是一个单步过程，并且您可以从应用程序的任何组件访问状态，这使得应用程序更加动态和快速。我们将在几个段落中了解更多关于商店的内容。</p><div class="lu lv gp gr lw lx"><a href="https://media0.giphy.com/media/3o84sq21TxDH6PyYms/giphy.gif" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd ir gy z fp mc fr fs md fu fw ip bi translated">星球大战中西斯力量的复仇</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">发现并与你认识的每个人分享这张星球大战GIF。GIPHY是你搜索、分享、发现和创建gif的方式。</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">media0.giphy.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml jw lx"/></div></div></a></div></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h2 id="68fb" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">行动</h2><p id="9867" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">动作是负责定义状态变化的对象，它们是JS对象，带有一个<code class="fe mt mu mv mw b">type</code>键和一个<code class="fe mt mu mv mw b">payload</code>键，前者包含要执行的动作的名称，后者包含用于操作状态的内容。</p><p id="cb2e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">例如:</p><p id="c898" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><code class="fe mt mu mv mw b">./src/actions/functionActions</code></p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/4676e7d8133156433732f6a533f16e52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mTcX0Ryt-QVnPqKXfwCJgw.png"/></div></div></figure><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/9a6dd4e1b256b06cbc59fb70e20d4d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCfgvnQppYuUZy1kvUas7Q.png"/></div></div></figure><p id="1307" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">所以这里我们用我们的“type:”键和“payload:”键来定义我们的动作函数。哇哦！<code class="fe mt mu mv mw b">FETCH_PAINTINGS</code>到底是从哪里来的？所以<code class="fe mt mu mv mw b">FETCH_PAINTINGS</code>实际上就是一个字符串，它被导出并保存在另一个文件夹的常量中。最佳实践是将保存在不同文件夹中的类型键值分开，一个文件夹定义了action函数，另一个文件夹用于将类型键值保存为常量。</p><p id="2a57" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">就像这样:</p><p id="a2be" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><code class="fe mt mu mv mw b">./src/actions/constants</code></p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/6da88d7830d5d93fe98b33cffa1bf4bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oYASWSmMhE-u71T4RQUCKA.png"/></div></div></figure><p id="7ebd" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">但是我们为什么要这么做呢？将类型键值设置为函数动作中的字符串不是更容易吗？嗯……的确是！但是有一个问题，当我们在下一部分学习减速器时，我们可以更好地理解这个问题。</p><h2 id="2f35" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">还原剂</h2><p id="de9f" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">缩减器是一个将状态和动作作为参数的函数，负责根据具体的<code class="fe mt mu mv mw b">action.type</code>改变当前状态。Reducers是纯函数，这意味着如果给定相同的输入，它们将总是返回相同的输出。在reducer函数中，检查动作类型，根据动作类型，会发生不同的状态突变。</p><p id="bacc" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">像这样:</p><p id="b342" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><code class="fe mt mu mv mw b">./src/reducers</code></p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/b59f34ce85cdd76cd582d774ac5c02e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AhOFU4UV0hUJk0YypXwGUg.png"/></div></div></figure><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/9a3f2b1a9954f246945b5c6792ee7100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ABi9pkIlW_WU47mu-m_YuQ.png"/></div></div></figure><p id="cb3c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">这里我们可以看到，我们正在声明一个名为<code class="fe mt mu mv mw b">paintingsReducer</code>的新函数，那么它在做什么呢？它把两个东西作为论点:一个状态，和一个动作。注意，我们在顶部导入了动作类型值常量。这里是我们之前定义的动作将被使用的地方。在函数内部，我们可以看到一个<code class="fe mt mu mv mw b">switch</code>语句评估不同的动作类型并返回不同的状态值，所以这就是为什么将我们的类型保存为保存的常量而不是字符串很重要。如果你给它一个未声明的变量，React会给你一个错误，但如果你的字符串有一个错别字，它不会给你一个错误，所以你可能不会得到你所期望的，不知道为什么，也许你需要一段时间来找到错别字，与变量的错误可以直接指向你的错误。</p><p id="3764" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">减速器是纯函数；纯函数是给定相同输入将总是返回相同输出的函数。Reducers负责查看动作类型并适当地改变状态。那么状态实际上是如何改变的呢？</p><p id="c980" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">首先我们需要一个<code class="fe mt mu mv mw b">rootReducer</code>常量来存储状态。这个根reducers调用了一个从redux库中导入的方法，那么这看起来像什么呢？像这样:</p><p id="19af" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><code class="fe mt mu mv mw b">./src/reducers</code></p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/f2779790bcfb30604c6d66ae1ca638a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dLHasK5FEe6sCvwDNsOdzQ.png"/></div></div></figure><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/fffe53da5ee4eac74391f270afa81e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AcBn6oxza62fuUHsDf87Rw.png"/></div></div></figure><figure class="my mz na nb gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/523416cd7c2c3e6848a1e4213d00b1f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*EZmoBT5ixLemx4WhbDdKDQ.png"/></div></figure><p id="248f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">所以我们正在导入我们的<code class="fe mt mu mv mw b">combineReducers</code>方法，并且在我们的常量<code class="fe mt mu mv mw b">rootReducer</code>中使用它。这个方法允许我们将状态设置为reducer函数的返回值，所以请注意，有一个名为<code class="fe mt mu mv mw b">paintings</code>的键被设置为我们之前定义的<code class="fe mt mu mv mw b">paintingsReducer</code>方法。从现在开始，每次我们调用我们的<code class="fe mt mu mv mw b">paintingsReducer</code>缩减器时，无论我们得到什么返回值，它都将被存储在一个名为<code class="fe mt mu mv mw b">paintings</code>的状态中。</p><h2 id="5a06" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">商店</h2><p id="31ea" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">存储基本上是保存状态的空间。商店是用从Redux库中导入的名为<code class="fe mt mu mv mw b">createStore</code>的函数创建的。这个函数返回一个新的商店。按照惯例，在这种情况下，最好将新的<code class="fe mt mu mv mw b">createStore</code>函数放在一个名为<code class="fe mt mu mv mw b">configureStore</code>的单独文件中。</p><p id="9247" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><code class="fe mt mu mv mw b">./src/configureStore</code></p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/5277a4126cac1be4aded3a03b92554f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4FECwEg7SK0Vut7eO44bw.png"/></div></div></figure><p id="927b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">这个<code class="fe mt mu mv mw b">createStore</code>方法接受一个我们之前定义的<code class="fe mt mu mv mw b">rootReducer</code>参数，这个参数是从我们的reducers文件导入的。那么我们实际上如何改变状态呢？我们甚至如何启动这些“动作”和“缩减器”来设置新的状态。</p><p id="02f4" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们将不得不导入我们希望在文件中使用的动作，我们希望使状态改变，然后我们添加我们选择的事件，并将有效负载作为参数传递。但这还不是全部，我们还需要在文件的底部有一个connect函数，它将负责从事件中分派动作调用，并将其发送到reducers文件，在那里它将采取行动将类型与reducer方法进行比较，并返回新的有效载荷。然后，当这个reducer方法被触发时，<code class="fe mt mu mv mw b">rootReducer</code>函数将再次触发，保存新的状态值。</p><h2 id="ce40" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h2><p id="6ca4" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">Redux是一个帮助我们在一个单独的位置管理状态的工具，允许我们从任何组件改变它，而不必将它作为道具传递给子组件。编码快乐！</p></div></div>    
</body>
</html>