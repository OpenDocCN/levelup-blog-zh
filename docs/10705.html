<html>
<head>
<title>Queues: Data Structures in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">队列:JavaScript中的数据结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/queues-data-structures-in-javascript-478d2cede718?source=collection_archive---------16-----------------------#2022-01-03">https://levelup.gitconnected.com/queues-data-structures-in-javascript-478d2cede718?source=collection_archive---------16-----------------------#2022-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c56d980a57febda4b0c8551cd1ba43b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n36AUx-kc4_7WXrACKZ0jg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">拉里·詹姆斯·贝勒斯在<a class="ae kc" href="https://unsplash.com/s/photos/traffic-jam?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b896" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">队列</strong>和<strong class="kf ir">堆栈</strong>一样，是许多原始数据结构中的一种。在本文中，我们将讨论队列及其实际实现，当然还有JavaScript语言中的实现。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="94db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">队列数据结构的行为就像一个普通的真实队列，从它的名字就可以猜到。在队列中，被删除的元素总是在集合中存在时间最长的元素:队列实现了先进先出(FIFO)策略，这与使用堆栈的LIFO(后进先出)策略不同。</p><p id="d7a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用队列上的插入操作<strong class="kf ir">入队</strong>，调用删除操作<br/>出列<strong class="kf ir">。L </strong>像堆栈操作<strong class="kf ir">弹出</strong>，<strong class="kf ir">出列</strong>不接受元素参数。</p><p id="4f8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">队列的FIFO属性使其作为一排等待向收银员付款的顾客进行操作。队列有一个<strong class="kf ir">头</strong>和一个<strong class="kf ir">尾</strong>。当一个元素进入队列时，它会在队列的尾部占据它的位置，就像一个新到达的客户在队列的末尾占据一个位置一样。出列的元素总是在队列的最前面，因为在队列最前面的客户等待的时间最长。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/7759b2a1a4c999750d6f92ff2493aae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ia_ZpF6JUSsvBb56CqCV4A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">长队</figcaption></figure><p id="f17a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上图中可以看到的一种实现方式是使用一个长度为<strong class="kf ir"> n </strong>的数组来实现最多有 <strong class="kf ir"> n-1 </strong>个元素的<strong class="kf ir">队列。队列有一个属性<strong class="kf ir"> head </strong>，它索引或者指向它的头。属性<strong class="kf ir"> tail </strong>索引新到达的元素将被插入队列的下一个位置。</strong></p><p id="c97e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">队列中的元素驻留在位置<strong class="kf ir"> <em class="ln"> head、head+1、…、tail-1 </em> </strong>中，这里我们“回绕”的意思是位置<strong class="kf ir"> 1 </strong>以循环顺序紧跟在位置<strong class="kf ir"> n </strong>之后。</p><p id="2b90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开始时，我们有<strong class="kf ir"> </strong>头=尾= 1。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/3c083d512f5fb82b587ae3fbe9fcae0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eqWSSiHfYJwMM1qZpu54kQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">队列的初始外观</figcaption></figure><p id="616b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<strong class="kf ir"> </strong>头=尾时，意味着队列是空的。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/f94b2e442accfb011ce1deae9b29d089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3NRWFtT2z2ofXccSsWVtfw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">空队列情况</figcaption></figure><p id="0631" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们试图将一个元素添加到一个已填充的队列(head = tail + 1)时，会发生队列溢出。但是当我们试图从一个空队列(head = tail)中删除一个元素时，就会发生队列下溢。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="5fa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们开始创建队列。</p><h1 id="6407" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">初始化队列</h1><p id="c832" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">首先，您应该初始化您的队列。堆栈逻辑对4个主要参数起作用。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/ae396a879013ee8fea9fa3d8bd285719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j3n9AskfetThwIpmsTOQSA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用类初始化队列</figcaption></figure><ol class=""><li id="f010" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">队列本身(this.queueList)</li><li id="9743" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">队列中的起始位置(this.head)</li><li id="fd3a" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">队列中的结束位置(this.tail)</li><li id="38cf" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">队列的最大可能长度(this.maxLength)(可选)</li></ol><p id="46b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您也可以将您的<strong class="kf ir">头部</strong>和<strong class="kf ir">尾部</strong>参数分别命名为<strong class="kf ir"> topIndex </strong>和<strong class="kf ir"> lastIndex </strong>。当您没有用链表实现队列时，这是一个更好的命名。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="6cd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">队列的主要操作有<em class="ln">空队列检查</em>、<em class="ln">入队(推送)</em>和<em class="ln">出列(移位)</em>操作。</p><p id="8db4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在传递给main operations之前，我写了一个小的实用程序方法来检查并返回给定元素位置的下一个位置，当我们没有达到队列中最大项目数量的限制时，否则返回1(队列中第一个项目的位置)。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/413a7b84329914e2e19fa5ba9730d18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2_Yu29V_z5_-6CxeNY_4QA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">队列中的“下一个”方法</figcaption></figure><h1 id="1ad2" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">空队列</h1><p id="f29e" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">空队列操作检查队列是否为空。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/1942ac48f60d3591950d15b5a0671c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6QwiZQR5IGiWTLP_iMKjsw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">队列中的isEmptyQueue操作</figcaption></figure><h1 id="67ea" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使…入队</h1><p id="db38" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">入队操作在队列末尾添加一个元素。</p><p id="e1ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们检查是否达到了队列的大小限制。如果没有，那么我们在队列数组的末尾添加新元素，更新尾部索引(最后一项的位置)并返回更新后的队列数组。否则我们会显示错误信息。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/4b718b50c41908a201eb6c40893b2f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FRRBzVHS0yhPhlFM4CxvSw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">队列中的入队(推送)操作</figcaption></figure><h1 id="d2d0" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">出列</h1><p id="c495" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">出列操作删除队列的第一个元素。</p><p id="4615" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，首先，我们检查我们的队列中是否有要删除的项目。如果是，那么我们将一个空字符串赋给队列数组的第一个元素，更新头部索引并返回更新后的队列数组。否则我们会显示错误信息。</p><figure class="lj lk ll lm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/dbf8ac29316a9bd8f4596fdc023ae0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgOnT1uZv689ohvSM3cTgA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">队列中的出列(移位)操作</figcaption></figure><p id="a989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，通过这样做，我们就像用现有值向右移动我们的队列<strong class="kf ir">。我们的<strong class="kf ir">队列列表</strong>数组的长度保持不变。只是起点变了。</strong></p><p id="a7f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们如何用数组实现队列，但是你可以用链表数据结构更优雅地实现它。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="f79c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在这个队列中添加了更多的实用方法，您可以通过导航<a class="ae kc" href="https://github.com/danomov/DataStructuresAndAlgorithmImplementations/blob/master/Queue/queue.js" rel="noopener ugc nofollow" target="_blank">这里的</a>来观察。</p><p id="c440" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读，我们很快会再见的🤟</p><blockquote class="nk nl nm"><p id="4de3" class="kd ke ln kf b kg kh ki kj kk kl km kn nn kp kq kr no kt ku kv np kx ky kz la ij bi translated"><em class="iq">我讲述的其他数据结构主题:</em></p><p id="3bbd" class="kd ke ln kf b kg kh ki kj kk kl km kn nn kp kq kr no kt ku kv np kx ky kz la ij bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/stacks-data-structures-in-javascript-106ecc0e147e">堆栈</a></p><p id="1ee2" class="kd ke ln kf b kg kh ki kj kk kl km kn nn kp kq kr no kt ku kv np kx ky kz la ij bi translated"><a class="ae kc" href="https://link.medium.com/hu38fRRvAbb" rel="noopener"> <em class="iq">单链表</em> </a></p><p id="2142" class="kd ke ln kf b kg kh ki kj kk kl km kn nn kp kq kr no kt ku kv np kx ky kz la ij bi translated"><a class="ae kc" href="https://link.medium.com/z8tBxNIvAbb" rel="noopener"> <em class="iq"> LRU缓存</em> </a></p></blockquote></div></div>    
</body>
</html>