<html>
<head>
<title>Don’t Use FileInputStream to Transfer Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要使用FileInputStream传输文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dont-use-fileinputstream-to-transfer-files-5990805de28e?source=collection_archive---------6-----------------------#2022-10-20">https://levelup.gitconnected.com/dont-use-fileinputstream-to-transfer-files-5990805de28e?source=collection_archive---------6-----------------------#2022-10-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0e66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了提高效率，请使用FileChannel。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/9f0fe7f688588b08fce1e96c265f7b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEVUieA-cO52uSQzb845YA.jpeg"/></div></div></figure><p id="cd39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个人都熟悉文件的复制。我假设每个人都像我一样使用输入和输出流来操作。从源文件创建输入流，然后从目标文件创建输出流，最后将输入流的数据读入输出流。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="367a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">高级Java开发人员应该知道输入/输出流有很多缺点。输入/输出流阻塞了IO，通常称为BIO。当系统调用发生时，当前线程将被阻塞，直到数据完全复制到用户模式缓冲区。而且由于java虚拟机的原因，每次复制一个文件，都需要在用户态和内核态之间多次复制文件。整个文件复制过程如下图所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lc"><img src="../Images/e33c56fb8cfd44ebb7ce938d3b9b386a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*138iXi9gQBNEQ6TcWTcoHw.png"/></div></div></figure><p id="a304" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在程序中并不真正使用这些文件数据。我们只是复制了一个文件。数据从磁盘中读取，并在一系列操作后完好无损地返回到磁盘。难道我们就不能省略这么多不必要的副本吗？答案是肯定的。</p><p id="4e24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Java NIO是在Java 1.4之后提出的，其中FileChannel给了我们一种新的传输文件的方式。</p><h2 id="44af" class="ld le it bd lf lg lh dn li lj lk dp ll kb lm ln lo kf lp lq lr kj ls lt lu lv bi translated">使用直接内存</h2><p id="8165" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">FileChannel是一种通道技术，用于读取、写入、映射和操作文件。数据不会被直接传输。需要和ByteBuffer结合使用。可以通过getChannel获取频道。</p><p id="6bf3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ByteBuffer有堆缓冲实现和直接内存缓冲实现。如果使用直接内存，可以直接省略上图中的步骤③和④，从而提高文件传输效率。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="9c0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">读写数据时，内存是在JVM堆中分配的，JVM堆内存伴随着不规则的GC。因此，在读写数据时，需要将数据从JVM堆复制到另一个与JVM运行时无关的缓冲区，然后进行用户态内核态切换，将数据从用户空间复制到内核空间缓冲区，防止GC移动对象导致内存地址变化。直接内存只是避免了java IO的缺点。</p><h2 id="5e78" class="ld le it bd lf lg lh dn li lj lk dp ll kb lm ln lo kf lp lq lr kj ls lt lu lv bi translated">mmap+写</h2><p id="771b" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">后来mmap技术可以进一步减少数据副本的数量。使用mmap的目的是将内核中读缓冲区的地址映射到用户空间中的缓冲区，这样内核缓冲区就可以与应用程序内存共享，省去了将数据从内核读缓冲区复制到用户缓冲区的过程。但是，内核读缓冲区仍然需要将数据传输到内核写缓冲区。一般流程如下图所示。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lc"><img src="../Images/9a5482d20e244409467a32ba48bcad0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3c82AQb8SfzYvkx473hgfg.png"/></div></div></figure><ul class=""><li id="46f3" class="mb mc it js b jt ju jx jy kb md kf me kj mf kn mg mh mi mj bi translated">通过mmap启动一个系统调用，映射用户进程内核空间的读缓冲区和用户空间的用户缓冲区的内存地址。</li><li id="5105" class="mb mc it js b jt mk jx ml kb mm kf mn kj mo kn mg mh mi mj bi translated">CPU使用DMA控制器将数据从主存或硬盘复制到内核空间的读缓冲区。</li><li id="5ec0" class="mb mc it js b jt mk jx ml kb mm kf mn kj mo kn mg mh mi mj bi translated">用户进程通过write()函数向内核发起系统调用，上下文从用户空间切换到内核空间。</li><li id="ed15" class="mb mc it js b jt mk jx ml kb mm kf mn kj mo kn mg mh mi mj bi translated">CPU将读缓冲区中的数据复制到写缓冲区。</li></ul><p id="2c99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相比以上，mmap+write减少了一个数据副本。在Java中，mmap是通过MappedByteBuffer实现的。具体代码如下:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="45f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然mmap可以提高文件传输效率，但是当mmap一个文件时，如果该文件被另一个进程截获，那么写操作就会被访问非法地址的SIGBUS信号终止。默认情况下，SIGBUS会终止进程并生成一个coredump，服务器可以相应地终止。</p><h2 id="7f7c" class="ld le it bd lf lg lh dn li lj lk dp ll kb lm ln lo kf lp lq lr kj ls lt lu lv bi translated">发送文件</h2><p id="1d68" class="pw-post-body-paragraph jq jr it js b jt lw jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj ma kl km kn im bi translated">虽然mmap减少了一份数据来提高效率，但是有些朋友会问，在没有内存映射的情况下，是否可以在内核状态下只复制一次相同的数据。答案是肯定的，可以使用sendfile。对应Java中的<code class="fe mp mq mr ms b">FileChannel.transforTo()</code>函数。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="ec7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文简要介绍如何通过FileChannel操作文件IO。当我们需要传输或复制文件时，我们不需要使用低效的BIO APIs。请使用Java NIO来替换它们。是时候放弃过时的BIO APIs了。最后，感谢您的阅读。</p><div class="mt mu gp gr mv mw"><a href="https://medium.com/javarevisited/five-api-performance-optimization-tricks-that-every-java-developer-must-know-75324ee1d244" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">每个Java开发人员都必须知道的五个API性能优化技巧</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">为什么你的API响应这么慢？也许你需要解决这些问题。</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk ky mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="https://medium.com/javarevisited/ten-optimization-tricks-to-make-your-java-application-run-faster-9742f568ed6f" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">让Java应用程序运行更快的十个优化技巧</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">这些技巧可能会将应用程序的性能提高几倍。</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="nl l nh ni nj nf nk ky mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="https://medium.com/javarevisited/5-best-java-libraries-every-java-developer-should-know-28a1c080bbf" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">每个Java开发人员都应该知道的5个最佳Java库</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">你知道这些优秀的Java库吗？</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="nm l nh ni nj nf nk ky mw"/></div></div></a></div></div></div>    
</body>
</html>