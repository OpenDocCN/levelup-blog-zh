<html>
<head>
<title>Javascript Closures Simple Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript闭包简单指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-closures-simple-guide-d83dfc0a02d4?source=collection_archive---------14-----------------------#2020-03-30">https://levelup.gitconnected.com/javascript-closures-simple-guide-d83dfc0a02d4?source=collection_archive---------14-----------------------#2020-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/0c9af28d18f41dfbcae08c474e336cff.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*dnlLJe1JNQ1M2QGUpPBKqQ.png"/></div></figure><p id="6da4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">今天我们将讨论Javascript中闭包的惊人力量，我们如何利用它们，以及几个例子。</p><p id="ee8d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">闭包是JavaScript面试官最喜欢问的问题之一。大多数中级/有经验的开发人员都知道这个概念，如果不知道，这就给他们敲响了警钟。但是闭包有什么特别的地方让每个人都想测试它呢？</p></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="52f2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们从闭包的官方解释开始:</p><blockquote class="kz la lb"><p id="3dfe" class="ju jv lc jw b jx jy jz ka kb kc kd ke ld kg kh ki le kk kl km lf ko kp kq kr ij bi translated">一个<strong class="jw ir">闭包</strong>是一个函数与对其周围状态的引用捆绑在一起(封闭)的组合<strong class="jw ir">词法环境</strong>。换句话说，闭包允许您从内部函数访问外部函数的范围。在JavaScript中，闭包是在每次创建函数时创建的。(<a class="ae lg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Closures</a>)</p></blockquote><p id="a17e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么，用更简单的话来说，这意味着什么呢？</p><blockquote class="kz la lb"><p id="5ec7" class="ju jv lc jw b jx jy jz ka kb kc kd ke ld kg kh ki le kk kl km lf ko kp kq kr ij bi translated"><strong class="jw ir">闭包</strong>是两个函数之间的空间，一个函数定义在另一个函数中，允许我们在两个函数之间存储数据，并从两个函数中访问数据。</p></blockquote><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">函数示例中的函数</figcaption></figure></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="2a6b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们深入研究一组例子，从<strong class="jw ir">去抖</strong>开始。我基于一个闭包和一个用来测试知识的问题。使用反跳的最好例子是当用户键入自动完成时。我们不想在他输入的每封信上都发送请求，我们只想在完成输入后发送请求。</p><p id="2793" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么我们如何通过终结来实现这一点呢？</p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">最简单的去抖实现</figcaption></figure></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="5618" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们继续另一个概念<strong class="jw ir">处理函数</strong>，并通过实现一个简单的<strong class="jw ir"> EventEmmiter </strong>来演示它。<strong class="jw ir"> </strong>在注册<strong class="jw ir"> </strong>到一个事件时，我们想要接收一个函数来处理我们对事件的注册，如果不再需要的话，我们不想为它定义一个特殊的函数。</p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">简单的EventEmmiter实现</figcaption></figure></div><div class="ab cl ks kt hu ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ij ik il im in"><p id="ab84" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后一个例子是我在日常工作中遇到的。我想打开一个模态，并设置模态的类型，我希望一个函数只做一次。所以，我用了<strong class="jw ir">和</strong>的结尾。</p><p id="e50c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一个概念的例子:</p><figure class="lh li lj lk gt jr"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">每次点击复选框时更新一些状态</figcaption></figure><p id="0981" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以我希望你喜欢阅读关于<strong class="jw ir">闭包</strong>和一点点<strong class="jw ir">奉承</strong>的内容，并且希望你现在更加熟悉它。对于我们中的<strong class="jw ir"> React </strong>开发人员，这里有一篇关于<code class="fe lr ls lt lu b">Hooks</code>以及他们如何实现<strong class="jw ir">闭包功能的文章。</strong></p><div class="lv lw gp gr lx ly"><a href="https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd ir gy z fp md fr fs me fu fw ip bi translated">深潜:React钩子到底是怎么工作的？网络生活</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">在本文中，我们通过构建一个React钩子的微型克隆来重新引入闭包。这将达到两个目的——为了…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">www.netlify.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm js ly"/></div></div></a></div></div></div>    
</body>
</html>