<html>
<head>
<title>Generative Adversarial Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生成对抗网络</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/generative-adversarial-network-c34cbd25f07f?source=collection_archive---------29-----------------------#2020-06-08">https://levelup.gitconnected.com/generative-adversarial-network-c34cbd25f07f?source=collection_archive---------29-----------------------#2020-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5ab7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2014年，Ian Goodfellow和其他人在Yoshua Bengio的实验室里首次报道了“生成敌对网络”。从那以后，GANs开始流行起来。这里有几个例子可供参考:</p><ul class=""><li id="cfa5" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated"><a class="ae ko" href="https://affinelayer.com/pixsrv/" rel="noopener ugc nofollow" target="_blank"> Pix2Pix </a></li><li id="1fe6" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://github.com/junyanz/pytorch-CycleGAN-and-pix2pix" rel="noopener ugc nofollow" target="_blank">朱俊彦PyTorch的cycle gan&amp;pix 2 pix</a></li><li id="99f3" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated"><a class="ae ko" href="https://github.com/wiseodd/generative-models" rel="noopener ugc nofollow" target="_blank">生成模型列表</a></li></ul><p id="9e70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GANs背后的想法是一个人有两个网络，一个生成器<em class="ld">𝐺</em>和一个鉴别器<em class="ld"> 𝐷 </em>，相互竞争。生成器生成“假”数据传递给鉴别器。鉴别器还可以看到真实的训练数据，并预测它收到的数据是真是假。</p><ul class=""><li id="b0b0" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">生成器被训练来欺骗鉴别器，它想要输出看起来尽可能接近真实训练数据的数据。</li><li id="d613" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">鉴别器是一个分类器，它被训练来找出哪些数据是真实的，哪些是虚假的。</li></ul><p id="47fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终发生的情况是，生成器学习生成与鉴别器的真实数据无法区分的数据。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/3fada5587a1846dff949b8c6808b145c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aAsh_gYDCDZ63OUmqKf19g.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">图片来源:Udacity</figcaption></figure><h2 id="1e4c" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">构建GAN:</h2><p id="6846" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">在这里，我们将尝试建立一个简单的甘产生新的手写图像的基础上MNIST数据集。</p><p id="681a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">步骤1:加载必要的库，我们将为这个模型使用PyTorch。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="cdc7" class="lu lv it mt b gy mx my l mz na">%matplotlib inline<br/>import numpy as np<br/>import torch<br/>import matplotlib.pyplot as plt<br/>from torchvision import datasets<br/>import torchvision.transforms as transforms<br/>import torch.nn as nn<br/>import torch.nn.functional as F<br/>import torch.optim as optim<br/>import pickle as pkl</span></pre><p id="7fa3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">步骤2:现在我们将加载内置的MNIST数据集，并创建一个批量大小为64的train_loader。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="edfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">步骤3:可视化数据</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">可视化数据的代码</figcaption></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/80d099107a6be9673c68c30d6d2c81b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*b0Jo4ZOIxr9V2tj-FraxSQ.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">上述代码的输出</figcaption></figure><h2 id="042a" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">定义模型</h2><p id="731f" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">一个GAN由两个对立的网络组成，一个鉴别器和一个生成器。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ne"><img src="../Images/b50c48fe5938d7e404e8b37b39324bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBRiW5y71sSJTjhRbpIWhw.png"/></div></div></figure><h2 id="dbc2" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">鉴别器</h2><p id="83cf" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">鉴别器网络将会是一个非常典型的线性分类器。为了使这个网络成为一个通用的函数挪用器，我们至少需要一个隐藏层，并且这些隐藏层应该有一个关键属性。这里我们将定义3个隐藏层和1个全连接层。每一层都有一个漏重激活功能。泄漏的ReLU类似于普通的ReLU，只是对于负输入值有一个小的非零输出，它是通过乘以一个小常数得到的。</p><p id="ad42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还将采用在输出端使用数值上更稳定的损失函数的方法。回想一下，我们希望鉴别器输出一个0–1的值，表示一幅图像是<em class="ld">真的还是假的</em>。因此，我们的最终输出层不应该有任何激活功能应用于它。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="a691" class="lu lv it mt b gy mx my l mz na">class Discriminator(nn.Module):<br/> def __init__(self, input_size, hidden_dim, output_size):<br/>  super(Discriminator, self).__init__()<br/> <br/>    # define all layers<br/> <br/>    #There are three hidden layers<br/>    self.layer1=nn.Linear(input_size,hidden_dim*4)<br/>    self.layer2=nn.Linear(hidden_dim*4,hidden_dim*2)<br/>    self.layer3=nn.Linear(hidden_dim*2,hidden_dim)<br/> <br/>    #This is the fully connected layer<br/>    self.layer4=nn.Linear(hidden_dim,output_size)<br/> <br/>    #A dropout with value 0.2 is added<br/>    self.dropout=nn.Dropout(0.2)<br/> <br/> def forward(self, x):<br/>    # flatten image<br/>    x=x.view(-1,28*28)<br/>    # pass x through all layers<br/>    # apply leaky relu activation to all hidden layers<br/>    x=F.leaky_relu(self.layer1(x),0.2)<br/>    x=self.dropout(x)<br/>    x=F.leaky_relu(self.layer2(x),0.2)<br/>    x=self.dropout(x)<br/>    x=F.leaky_relu(self.layer3(x),0.2)<br/>    x=self.dropout(x)<br/> <br/>    output=self.layer4(x)<br/>    return output</span></pre><h2 id="9c71" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">发电机</h2><p id="f09f" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">发生器网络将与鉴别器网络几乎完全相同，除了我们将一个<a class="ae ko" href="https://pytorch.org/docs/stable/nn.html#tanh" rel="noopener ugc nofollow" target="_blank">双曲正切激活函数</a>应用到我们的输出层。已经发现，对于发电机输出来说，具有<em class="ld"> 𝑡𝑎𝑛ℎ </em>的发电机表现最佳，其将输出缩放到-1和1之间，而不是0和1。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="7762" class="lu lv it mt b gy mx my l mz na">class Generator(nn.Module):</span><span id="2b8f" class="lu lv it mt b gy nf my l mz na">  def __init__(self, input_size, hidden_dim, output_size):<br/>   super(Generator, self).__init__()<br/> <br/>     # define all layers<br/> <br/>     #There are three hidden layers<br/>     self.layer1=nn.Linear(input_size,hidden_dim)<br/>     self.layer2=nn.Linear(hidden_dim,hidden_dim*2)<br/>     self.layer3=nn.Linear(hidden_dim*2,hidden_dim*4)<br/> <br/>     #This is the fully connected layer<br/>     self.layer4=nn.Linear(hidden_dim*4,output_size)<br/> <br/>     #A dropout with value 0.2 is added<br/>     self.dropout=nn.Dropout(0.2)</span><span id="e8e2" class="lu lv it mt b gy nf my l mz na"> def forward(self, x):<br/>     # pass x through all layers<br/> <br/>     # final layer should have tanh applied<br/>     x=F.leaky_relu(self.layer1(x),0.2)<br/>     x=self.dropout(x)<br/>     x=F.leaky_relu(self.layer2(x),0.2)<br/>     x=self.dropout(x)<br/>     x=F.leaky_relu(self.layer3(x),0.2)<br/>     x=self.dropout(x)<br/>     output=F.tanh(self.layer4(x))<br/>     return output</span></pre><p id="20ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是为我们的模型设置超参数</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="c6a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们将建立完整的模型。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ba11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出将显示我们完整的模型架构，</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="b953" class="lu lv it mt b gy mx my l mz na">Discriminator(<br/>  (layer1): Linear(in_features=784, out_features=128, bias=True)<br/>  (layer2): Linear(in_features=128, out_features=64, bias=True)<br/>  (layer3): Linear(in_features=64, out_features=32, bias=True)<br/>  (layer4): Linear(in_features=32, out_features=1, bias=True)<br/>  (dropout): Dropout(p=0.2)<br/>)<br/><br/>Generator(<br/>  (layer1): Linear(in_features=100, out_features=32, bias=True)<br/>  (layer2): Linear(in_features=32, out_features=64, bias=True)<br/>  (layer3): Linear(in_features=64, out_features=128, bias=True)<br/>  (layer4): Linear(in_features=128, out_features=784, bias=True)<br/>  (dropout): Dropout(p=0.2)<br/>)</span></pre><h2 id="b9bb" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">鉴频器损耗</h2><p id="6211" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">对于鉴别器，总损失是真实和伪造图像的损失之和，<code class="fe ng nh ni mt b">d_loss = d_real_loss + d_fake_loss</code>。请记住，我们希望鉴频器为真实图像输出1，为虚假图像输出0，因此我们需要设置损耗来反映这一点。</p><p id="9ed5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">损失将由二元交叉熵损失与logits，我们可以得到与<a class="ae ko" href="https://pytorch.org/docs/stable/nn.html#bcewithlogitsloss" rel="noopener ugc nofollow" target="_blank"> BCEWithLogitsLoss </a>。这将<code class="fe ng nh ni mt b">sigmoid</code>激活函数<strong class="js iu">和</strong>二元交叉熵损失结合在一个函数中。</p><h2 id="cb72" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">发电机损耗</h2><p id="94ed" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">只有在标签翻转的情况下，发电机损耗才会看起来相似。生成器的目标是得到<code class="fe ng nh ni mt b">D(fake_images) = 1</code>。在这种情况下，标签被<strong class="js iu">翻转</strong>以表示生成器试图欺骗鉴别器，使其认为生成的图像(赝品)是真实的！</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="f449" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们希望分别更新生成器和鉴别器变量。因此，我们将定义两个独立的Adam优化器。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="c7fe" class="nj lv it bd lw nk nl nm lz nn no np mc nq nr ns mf nt nu nv mi nw nx ny ml nz bi translated">培养</h1><p id="9c77" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">训练将包括交替训练鉴别器和发生器。我们将使用函数<code class="fe ng nh ni mt b">real_loss</code>和<code class="fe ng nh ni mt b">fake_loss</code>来帮助我们计算以下所有情况下的鉴频器损耗。</p><h2 id="b6ec" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">甄别训练</h2><p id="c38d" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">在真实的训练图像上计算鉴别器损失，然后生成假图像。最后，执行反向传播+优化来更新鉴别器的权重。</p><h2 id="949b" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">发电机培训</h2><p id="626f" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">使用<strong class="js iu">翻转的</strong>标签生成假图像并计算假图像的鉴别器损耗。执行反向传播+优化来更新生成器的权重。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="ddb6" class="lu lv it mt b gy mx my l mz na">num_epochs = 100<br/>samples = []<br/>losses = []<br/>print_every = 400</span><span id="5443" class="lu lv it mt b gy nf my l mz na">sample_size=16<br/>fixed_z = np.random.uniform(-1, 1, size=(sample_size, z_size))<br/>fixed_z = torch.from_numpy(fixed_z).float()</span><span id="0223" class="lu lv it mt b gy nf my l mz na">D.train()<br/>G.train()<br/>for epoch in range(num_epochs):<br/>   for batch_i, (real_images, _) in enumerate(train_loader):<br/>        batch_size = real_images.size(0)<br/>        real_images = real_images*2–1 <br/>        d_optimizer.zero_grad()<br/>        D_real = D(real_images)<br/>        d_real_loss = real_loss(D_real, smooth=True)<br/> <br/>        z = np.random.uniform(-1, 1, size=(batch_size, z_size))<br/>        z = torch.from_numpy(z).float()<br/>        fake_images = G(z)<br/> <br/>        D_fake = D(fake_images)<br/>        d_fake_loss = fake_loss(D_fake)<br/> <br/>        d_loss = d_real_loss + d_fake_loss<br/>        d_loss.backward()<br/>        d_optimizer.step()<br/> <br/>        g_optimizer.zero_grad()<br/> <br/>        z = np.random.uniform(-1, 1, size=(batch_size, z_size))<br/>        z = torch.from_numpy(z).float()<br/>        fake_images = G(z)<br/>        D_fake = D(fake_images)<br/>        g_loss = real_loss(D_fake) <br/>        g_loss.backward()<br/>        g_optimizer.step()<br/>        if batch_i % print_every == 0:<br/>             print(‘Epoch [{:5d}/{:5d}] | d_loss: {:6.4f} | g_loss:  <br/>                   {:6.4f}’.format(epoch+1, num_epochs,  <br/>                    d_loss.item(), g_loss.item()))</span><span id="e1ad" class="lu lv it mt b gy nf my l mz na">## AFTER EACH EPOCH##<br/>   losses.append((d_loss.item(), g_loss.item()))<br/>   G.eval() <br/>   samples_z = G(fixed_z)<br/>   samples.append(samples_z)<br/>   G.train()</span><span id="a62e" class="lu lv it mt b gy nf my l mz na">with open(‘train_samples.pkl’, ‘wb’) as f:<br/>   pkl.dump(samples, f)</span></pre><h2 id="72f7" class="lu lv it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">培训损失</h2><p id="a5bc" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">这里我们将绘制发生器和鉴别器的训练损耗，在每个时期后记录。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/fedc52ee45d50603c3309a0087754d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*ZbU-gpL9-yWZTaS_SJezNg.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">培训损失</figcaption></figure><p id="b34f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，让我们测试生成的新图像。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/f5705cc05e769b1e580f9d448d2d5b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*Avp1YwUMel8xwzn8k2VlTQ.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">新MNIST形象！！</figcaption></figure><p id="748c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Tada！这里使用GAN，生成了新的手写图像。类似地，GANs可用于从现有图像生成新图像。享受探索甘斯的乐趣。</p><p id="bd12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编码快乐！</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><div class="lf lg lh li gt oj"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">编写面试问题</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">技术开发</p></div></div><div class="os l"><div class="ot l ou ov ow os ox lo oj"/></div></div></a></div></div></div>    
</body>
</html>