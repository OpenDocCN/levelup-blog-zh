<html>
<head>
<title>Java Native Access: A Cleaner Alternative to JNI?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java本地访问:JNI的更干净的替代方案？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-native-access-a-cleaner-alternative-to-jni-954b53b77398?source=collection_archive---------3-----------------------#2020-03-18">https://levelup.gitconnected.com/java-native-access-a-cleaner-alternative-to-jni-954b53b77398?source=collection_archive---------3-----------------------#2020-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/b63ec31d74827dfb24d7a78b5f887486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1G07pI_tTKo4OKsymrVazg.jpeg"/></div></figure><p id="68a6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最近，我写了一篇关于<a class="ae ks" href="https://medium.com/swlh/introduction-to-java-native-interface-establishing-a-bridge-between-java-and-c-c-1cc16d95426a" rel="noopener"><strong class="jw ir">【JNI】(Java本地接口)</strong> </a>的文章，演示了如何使用它从Java中调用本地代码。虽然JNI是一种流行的选择，但它有点难以使用，并且每次对本机代码稍作改动时都需要生成它的存根(绑定所需的JNI头文件)。更重要的是，您可能无法访问想要使用的共享库的源代码。在这种情况下，除非该库是为了支持JNI而编写的，否则您无法让它工作。假设您可以访问本机方法签名，JNA实际上可以让您做到这一点。</p><p id="ff80" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">JNA是一个开源项目，它让你只使用Java代码就能使用本地库，几乎没有C编程经验。你可以在这里  <strong class="jw ir">找到它的源代码<a class="ae ks" href="https://github.com/java-native-access/jna" rel="noopener ugc nofollow" target="_blank">。</a></strong></p><p id="f267" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我在JNI的文章中创建了一个示例应用程序，名为<strong class="jw ir"> TemperatureSampler。在本文的第一部分，我将用一个简单的例子来演示JNA。之后，我们将尝试编写一个相当于JNA温度采样器的演示应用程序。最后，我将谈谈使用JNA而不是JNI的优势和劣势。当然，你可以在这里</strong>  <strong class="jw ir">找到完整的源代码<a class="ae ks" href="https://github.com/yigitpirildak/SimpleJNADemo" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">。让我们开始吧！</strong></a></strong></p><h1 id="fe57" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">使用JNA标准库访问C函数</strong></h1><p id="ea5c" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">为了测试JNA，我们实际上不需要任何外部共享库。JNA自己提供了一个名为“C”的库，可以访问很多C语言的功能。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="636e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如你所见，我们创建了一个接口并扩展了属于JNA的<strong class="jw ir">库</strong>类。然后，我们可以将需要使用的本地方法的签名映射到Java方法，以便访问它们。以下是类型映射列表:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/f4374f58b962ac652aefb917884d57a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*L-8jM5093cAETC9-oO9NQw.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">src—<a class="ae ks" href="https://github.com/java-native-access/jna/blob/master/www/Mappings.md" rel="noopener ugc nofollow" target="_blank">https://github . com/Java-native-access/jna/blob/master/www/mappings . MD</a></figcaption></figure><p id="3f89" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Native.load()用于加载一个本地库，但是因为我们使用的是默认库，所以只需传递“c”就可以了(在其他平台中命名可能会有所不同)。</p><p id="946f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">加载本机库后，我们可以访问printf和scanf方法。当然，上面的程序输出:</p><blockquote class="mh mi mj"><p id="a80b" class="ju jv mk jw b jx jy jz ka kb kc kd ke ml kg kh ki mm kk kl km mn ko kp kq kr ij bi translated">请工作？你的留言[PleaseWork？]是印刷感谢JNA图书馆5.5.0版！</p></blockquote><h1 id="4449" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">装载/使用你自己的东西</h1><p id="a3bd" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">JNA提供的例子很好，但这几乎不是我们想要的。现在我们将看看如何加载自己的本地库并映射它的方法。正如我之前提到的，我们将重新实现TemperatureSampler以使用JNA。</p><p id="ec3f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们从创建我们需要的界面开始。如果你还记得温度采样器，它有两个方法，<strong class="jw ir"> getTemperature() </strong>和<strong class="jw ir"> getDetailedTemperature() </strong>。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="2311" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们使用相同的方法加载共享对象，但是现在我们将提供本地库的完整路径。我的存储在项目根目录下的<strong class="jw ir">本地/输出</strong>文件夹中。如果您想下载示例代码并测试应用程序，我在<strong class="jw ir"> native </strong>文件夹下提供了一个Makefile来构建共享库，因为它是特定于平台的。</p><p id="47f9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> getTemperature() </strong>方法返回一个简单的原始类型，所以我们不需要做其他任何事情。然而，getDetailedTemperature 需要一些额外的东西来使它工作。</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="43a0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，我们需要扩展Structure class，它将本机c结构映射到Java类。我们将通过它的值返回struct，struct假定它是通过引用返回的，所以我们也将实现struct。通过值接口来解决这个问题。</p><p id="6808" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与JNI示例相比，我们的字段声明略有变化。我们将使用字节数组，并使用Native.toString()方法将它们转换为字符串，而不是使用字符串。据我所知，使用String来映射<strong class="jw ir"> const char数组</strong>可能没问题，但是建议使用byte数组来避免字符串编码错误。</p><p id="9b87" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们定义我们的字段顺序来匹配本机结构字段声明顺序。覆盖getFieldOrder来返回我们的字段顺序就可以了。这个方法是必要的，因为使用反射API获取这些字段并不能保证任何排序。</p><p id="5e31" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在前面的例子中，我们为<strong class="jw ir">刻度</strong>字段使用了TemperatureScale枚举。据我所知，不像JNI，没有办法自动将返回值映射到枚举。如果需要，您需要做额外的工作来获取值并将其转换为Java枚举。为了方便起见，我简单地将scale声明为一个字节数组，如果您愿意，可以在读取其值后将其映射为一个枚举。</p><p id="531c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们执行我们的主要方法，看看它是如何工作的！</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="82c7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">瞧啊。我们得到了与JNI示例相同的输出！</p><blockquote class="mh mi mj"><p id="cb00" class="ju jv mk jw b jx jy jz ka kb kc kd ke ml kg kh ki mm kk kl km mn ko kp kq kr ij bi translated">返回简单温度… <br/>采样温度= 27.8 <br/>返回详细温度… <br/>时间戳= 02–03–2020 17:30:48<br/>温度= 27.799999 <br/>刻度=摄氏度</p></blockquote><p id="4da4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们看一看我们正在调用的本地库，你会意识到它没有嵌入JNI的东西要简单得多。它基本上是普通的C语言，代码不知道某一天某个Java开发人员可能会调用它！</p><figure class="lw lx ly lz gt jr"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="3e98" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我在打印前禁用了输出缓冲，否则您可能会得到不正确的打印顺序。您也可以在Windows平台上使用fflush来清除输出缓冲区。</p><h1 id="36f4" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">JNI对JNA</h1><p id="67b5" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">现在是关键时刻了！你应该用JNA而不是JNI吗？嗯，看情况。我会通过分解它们来帮你决定哪一个更适合你的需求。</p><h2 id="ad96" class="mo ku iq bd kv mp mq dn kz mr ms dp ld kf mt mu lh kj mv mw ll kn mx my lp mz bi translated">JNI相对于JNA的优势</h2><ul class=""><li id="1c78" class="na nb iq jw b jx lr kb ls kf nc kj nd kn ne kr nf ng nh ni bi translated">允许您通过其丰富的API访问Java内容，使您能够创建Java类和调用方法。</li><li id="5008" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nf ng nh ni bi translated">在Java端，除了从源代码生成JNI头文件之外，不需要做任何额外的事情，这可以在编译时完成，而且(希望)很少发生。大部分工作是在本地完成的。另外值得一提的是，如果您已经知道如何定义JNI本地方法(或者生成它，然后将其转换为C/C++文件并填充方法，但这是额外的工作)，那么可以跳过存根生成。在AOSP通常是这样做的。</li><li id="3802" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nf ng nh ni bi translated">JNI要快得多，因为JNA需要在运行时进行一些动态生成(不需要提供预先生成的存根在这里成为一个缺点)。</li><li id="539c" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nf ng nh ni bi translated">可以与C++一起使用，而不需要做任何额外的工作(JNI通过在自动生成的头文件中使用<strong class="jw ir">Extern“C”</strong>来告诉编译器使用C的命名和调用约定)。默认情况下，JNA不会处理这个问题，所以要让它工作就要靠你了。</li><li id="83be" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nf ng nh ni bi translated">调用本机函数的最常用方法，所以它是更安全的选择(毕竟是标准的Java特性)。</li></ul><h2 id="bd35" class="mo ku iq bd kv mp mq dn kz mr ms dp ld kf mt mu lh kj mv mw ll kn mx my lp mz bi translated"><strong class="ak">JNA对JNI的优势</strong></h2><ul class=""><li id="692b" class="na nb iq jw b jx lr kb ls kf nc kj nd kn ne kr nf ng nh ni bi translated">编译后不需要接触本机代码。您所需要做的就是在Java代码上修改您的JNA访问接口，以便访问您需要的任何内容。</li><li id="9d25" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nf ng nh ni bi translated">本地代码不需要被Java调用。因此，您可以使用JNA轻松导入标准的C库。</li><li id="afa5" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nf ng nh ni bi translated">不需要你了解C语言和编译过程(也可能是交叉编译)。你是一个Java开发者，你想写Java代码，这就是适合你的方法。</li><li id="1924" class="na nb iq jw b jx nj kb nk kf nl kj nm kn nn kr nf ng nh ni bi translated">更容易习惯，需要更少的麻烦使其工作。您只需获取所需的原生库，将JNA依赖项添加到您的Maven/Gradle项目中，就万事大吉了。</li></ul><h1 id="556a" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">包裹</h1><p id="adeb" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">这两者之间的主要区别在于，JNI的实现大部分是在本机端完成的，而JNA是在Java层自动为您处理本机的事情。</p><p id="bc36" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">总的来说，JNI提供了一些你在JNA可能做不到的事情。如果你在<strong class="jw ir"> AOSP (Android开源项目)</strong>处理Android Framework/SystemServer绑定层，在那里用JNA就没道理了(我自己没见过有人用，谷歌更喜欢JNI，其他人也是)。AOSP用例通常需要一些从本机到框架的反向函数调用，这是使用JNA无法完成的。如果我们认为AOSP是一个利基市场，那么JNA对你来说是完美的，尤其是如果你需要做的只是使用一个已经为你编写的本地库。最终，您需要权衡每种技术的利弊，选择最适合您需求的技术。记住，保持技术不可知论的心态很重要。</p><p id="0c07" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">参考文献:</strong></p><div class="no np gp gr nq nr"><a href="https://github.com/java-native-access" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">Java本地访问</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of js nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://imagej.net/Developing_using_native_libraries" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">使用本地库开发</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">有时，您可能希望使用不作为Java组件提供的第三方库，而只是作为本机…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">imagej.net</p></div></div></div></a></div><div class="no np gp gr nq nr"><a href="https://en.wikipedia.org/wiki/Java_Native_Access" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">Java本地访问</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">原作者托德·法斯特、蒂莫西·沃尔、梁晨初版2007年5月9日稳定版5 . 5 . 0/2019年7月…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div></div></div>    
</body>
</html>