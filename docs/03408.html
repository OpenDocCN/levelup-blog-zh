<html>
<head>
<title>More Javascript Functional Programming Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更多Javascript函数式编程特性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/more-javascript-functional-programming-features-970b129d31dd?source=collection_archive---------14-----------------------#2020-05-06">https://levelup.gitconnected.com/more-javascript-functional-programming-features-970b129d31dd?source=collection_archive---------14-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3b22be4521d55575a2c158a35dc9f4cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tSYfCREUHuiKux7E"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk">Photo by <a class="ae kf" href="https://unsplash.com/@awmleer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡晨</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="adaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种简单易学的编程语言。它还使用了许多函数式编程特性，使我们的生活更加轻松。</p><p id="9864" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究JavaScript的一些函数式编程特性，包括函子和纯函数。</p><h1 id="1baa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">函子</h1><p id="67d5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函子是可以被映射的东西。如果一个实体的条目可以映射到新的值，那么它就是一个函子。</p><p id="a15f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，任何我们可以调用<code class="fe mh mi mj mk b">map</code>方法的东西都是函子。这是JavaScript中的一个数组。</p><p id="06c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，对于一个数组，我们可以如下调用<code class="fe mh mi mj mk b">map</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9cae" class="mt lf it mk b gy mu mv l mw mx">const arr = [1, 2, 3].map(a =&gt; a * 2);</span></pre><p id="8c61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们传入了一个回调函数，该函数返回一个数组，该数组的每个值都是原始数组的两倍。因此，数组是一个函子。</p><p id="c0e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了数组，我们还可以通过使用spread操作符将类似数组的可迭代对象转换为数组来创建数组。</p><p id="673e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个生成器函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c0f4" class="mt lf it mk b gy mu mv l mw mx">const generator = function*() {<br/>  yield 1;<br/>  yield 2;<br/>  yield 3;<br/>}</span></pre><p id="9e44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以将它转换成一个数组，并对转换后的数组调用<code class="fe mh mi mj mk b">map</code>，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e0b1" class="mt lf it mk b gy mu mv l mw mx">const arr = [...generator()].map(a =&gt; a * 2);</span></pre><p id="da84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用了spread操作符将<code class="fe mh mi mj mk b">generator</code>返回的迭代器转换成一个数组。</p><p id="a57d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到和第一个例子一样的结果。</p><p id="1eb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似数组的可迭代对象的其他例子包括<code class="fe mh mi mj mk b">arguments</code>对象、DOM节点列表、集合、映射和<code class="fe mh mi mj mk b">Files</code>对象。</p><p id="2847" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于不可迭代的类似数组的对象。也就是说，拥有数字键和<code class="fe mh mi mj mk b">length</code>属性的对象，我们可以使用<code class="fe mh mi mj mk b">Array.from</code>将其转换为数组。</p><p id="678f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下调用<code class="fe mh mi mj mk b">Array.from</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="19d8" class="mt lf it mk b gy mu mv l mw mx">const obj = {<br/>  0: 1,<br/>  1: 2,<br/>  2: 3,<br/>  length: 3<br/>}<br/>const arr = Array.from(obj).map(a =&gt; a * 2);</span></pre><p id="2bc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们将<code class="fe mh mi mj mk b">obj</code>传递给<code class="fe mh mi mj mk b">Array.from</code>以将其转换为数组，然后像在前面的示例中一样对其调用<code class="fe mh mi mj mk b">map</code>。</p><h1 id="9b4b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">纯函数</h1><p id="b970" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">纯函数是对于给定的一组输入，总是返回相同输出的函数。</p><p id="5615" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而且，它们不会产生任何副作用。它们很有用，因为它们易于理解和测试，因为它们只是处理输入并返回输出。</p><p id="1bd2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们也不会产生任何副作用，所以我们不会有函数本身以外的事情发生，这些事情是由函数引起的。</p><p id="4a62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">纯函数的一个例子包括:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5dbb" class="mt lf it mk b gy mu mv l mw mx">const add = (x, y) =&gt; x + y;</span></pre><p id="dd9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">add</code>函数只取2个数并返回相加的结果，所以它是一个纯函数。它不修改函数之外的任何东西，所以不会产生副作用。</p><p id="770a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非纯函数的一个例子是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e9a4" class="mt lf it mk b gy mu mv l mw mx">let foo = 1;<br/>const impureAdd = (a, b) =&gt; {<br/>  foo = 3;<br/>  return a + b;<br/>};</span></pre><p id="dacf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">impureAdd</code>函数通过将函数外的<code class="fe mh mi mj mk b">foo</code>变量重新赋值为不同的值而产生副作用。</p><p id="6568" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，<code class="fe mh mi mj mk b">impureAdd</code>不是一个纯函数。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/f1c65ca8a284e1cd6fd3f99ce6e5b00e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8xFQepPLQxzoPw-M"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@hoangx?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">黄阮</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="d0b9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">副作用</h1><p id="9ced" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">副作用是除了返回值之外，在被调用函数之外可以观察到的任何操作。</p><p id="88d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，它们包括如下操作:</p><ul class=""><li id="8456" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated">在函数外改变变量值</li><li id="ed3e" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">记录到控制台</li><li id="f826" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">在屏幕上画画</li><li id="c8a6" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">将文件写入磁盘</li><li id="5a83" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">运行外部流程</li><li id="174e" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">调用其他产生副作用的函数</li><li id="a019" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated">…以及任何在函数之外做事情的东西</li></ul><p id="7576" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用函数式编程，副作用被最小化，因此函数更容易阅读和测试，因为我们不必检查它们的副作用结果。</p><h1 id="aa4e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对透明性有关的</h1><p id="2f5d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">引用透明性是这样一个事实，一个表达式可以被它的值或任何具有相同值的东西代替，而不会改变程序的结果。</p><p id="a11a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于给定的参数，函数应该总是返回相同的值，而不会产生任何其他影响。</p><p id="49c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，这意味着我们的功能没有副作用。</p><p id="0184" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们上面的<code class="fe mh mi mj mk b">add</code>函数具有引用透明性，因为对于传入的同一组参数，我们总是得到相同的输出。</p><h1 id="914e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="5928" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了使我们的代码易于阅读和测试，我们尽可能坚持使用纯函数。</p><p id="2f63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">副作用是尽可能避免的，这样我们就不用去检查它们了。</p><p id="99d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函子是我们可以映射它们的值的任何东西。在JavaScript中，数组有<code class="fe mh mi mj mk b">map</code>方法，所以JavaScript数组是函子。我们还可以将多种对象转换成数组，包括可迭代和不可迭代的类似数组的对象。</p></div></div>    
</body>
</html>