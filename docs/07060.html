<html>
<head>
<title>gRPC: How to Make Client Streaming Calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gRPC:如何进行客户端流调用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/grpc-how-to-make-client-streaming-calls-5c731197585?source=collection_archive---------3-----------------------#2021-01-21">https://levelup.gitconnected.com/grpc-how-to-make-client-streaming-calls-5c731197585?source=collection_archive---------3-----------------------#2021-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6709494ce40e411bd799b4b13eabb48f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dAr2veAN9aj5qSJa8aN1BA.png"/></div></div></figure><p id="5432" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将介绍客户机流gRPC调用——实现客户机和服务器Go应用程序。</p><p id="69b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是该系列的第二篇文章:</p><ol class=""><li id="adad" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/grpc-how-to-make-effective-unary-calls-4c9fa68cd9d5">如何进行有效的一元调用</a></li><li id="b71f" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">如何进行客户端流呼叫</li><li id="07d9" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/grpc-how-to-make-server-streaming-calls-763b42895481">如何进行服务器流调用</a></li><li id="233c" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/grpc-how-to-make-bi-directional-streaming-calls-70b4a0569b5b">如何进行双向流媒体通话</a></li></ol><p id="dd6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在客户端流rpc调用中，客户端发送一堆请求，一旦完成流，服务器将返回一条消息。</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lo"><img src="../Images/eb942755acf22241e5a11a8e2c745dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l-gSz3cxkutbc5nq8HZKmQ.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">客户端流请求</figcaption></figure><h2 id="59f5" class="lx ly it bd lz ma mb dn mc md me dp mf km mg mh mi kq mj mk ml ku mm mn mo mp bi translated">项目描述</h2><p id="f982" class="pw-post-body-paragraph kb kc it kd b ke mq kg kh ki mr kk kl km ms ko kp kq mt ks kt ku mu kw kx ky im bi translated">对于这个项目，我们将创建一个带有一个gRPC端点的Books服务，它将允许客户端发送一个流请求。</p><p id="79b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">端点将接收一个Book对象，它将在其上运行一些验证，并返回一组验证错误作为响应。</p><p id="1478" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于这是一个客户端流调用，服务器将首先从客户端接收流，一旦客户端完成流，服务器将返回响应。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="c89d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，我们可以开始在grpc_calls中创建另一个文件夹，并将其命名为client_stream。</p><p id="ebe5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个文件夹中创建以下结构。</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/55f64e6193eac7d43af485597d5ef55a.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*Esgv8iYDZMuC3zjVfWpJ1w.png"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">gRPC客户端流文件夹结构</figcaption></figure><p id="1b8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">books.proto文件的定义如下:</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="56f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于这个原型文件，我为这个请求定义了books服务、端点和相应的消息。</p><h2 id="d4ce" class="lx ly it bd lz ma mb dn mc md me dp mf km mg mh mi kq mj mk ml ku mm mn mo mp bi translated">原型文件定义:</h2><ol class=""><li id="21d2" class="kz la it kd b ke mq ki mr km nf kq ng ku nh ky le lf lg lh bi translated"><strong class="kd iu"> ValidateBooks: </strong>这是rpc端点定义，它接受流ValidationReq消息并返回ValidationRes消息。</li><li id="4944" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><strong class="kd iu"> ValidationReq: </strong>这是rpc端点的请求消息，它有一个名为book的字段，类型为Book(它反过来表示另一个消息)。</li><li id="a7a7" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><strong class="kd iu"> Book: </strong>该消息表示并包含Book对象的公共字段。</li><li id="4b4d" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><strong class="kd iu"> ValidationRes: </strong>这是rpc端点的响应消息，它有一个名为errors的重复字段，类型为ValidationError(它反过来表示另一个消息)。</li><li id="c123" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><strong class="kd iu"> ValidationError: </strong>该消息表示一个错误，包含两个字段，book_id和一个字符串类型的错误数组。</li></ol><p id="c873" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我前面提到的，这个端点允许客户机发送一个流请求，然后服务器在其上运行一些验证，最后向客户机返回验证错误消息。</p><p id="fb78" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当客户端需要将资源一个接一个地发送到服务器时，发出客户端流请求非常有用，这样就可以立即处理这些资源，一旦流调用完成，客户端就会得到响应。</p><p id="377f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以为这个原型文件生成go代码了。</p><p id="ee61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在proto文件夹中运行以下命令:</p><pre class="lp lq lr ls gt ni nj nk nl aw nm bi"><span id="b4f3" class="lx ly it nj b gy nn no l np nq">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative books.proto</span></pre><p id="1685" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很好，现在我们已经为这个原型文件生成了go代码，我们可以继续实现服务器了。</p><p id="8650" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是server go应用程序的代码:</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d73f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">和前一篇文章一样，我们首先创建一个新的grpc服务器，它将监听端口3000，然后我们注册图书的服务，并开始监听连接。</p><p id="f5bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如你所见，我正在导入proto_client_stream包。因为有本地进口的Go会投诉。</p><p id="c75e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">要解决这个问题，您可以执行以下操作:</strong></p><ol class=""><li id="cd45" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">将proto文件夹的内容推送到Github，然后从那里导入。</li><li id="653d" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">将proto文件夹的内容放在<strong class="kd iu">包/src </strong>文件夹中，作为go版本路径。在我的情况下，这是路径:</li></ol><pre class="lp lq lr ls gt ni nj nk nl aw nm bi"><span id="696f" class="lx ly it nj b gy nn no l np nq">golang/1.15.5/packages/src</span></pre><p id="2d20" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个文件夹中，我创建了一个proto_client_stream文件夹，并粘贴了包含生成的代码和users.proto文件的proto文件夹中的文件。</p><p id="d332" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样我就可以导入这个包，而不用把它推到Github。采取你认为更方便的方法。</p><p id="4125" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<strong class="kd iu"> ValidateBooks </strong>函数中，我们接收流对象作为函数参数，然后在函数体中，我们初始化一个新的<strong class="kd iu"> ValidationError </strong>消息，我们将使用它来捕获错误。然后在for循环中，我们通过调用<strong class="kd iu"> Recv </strong>函数开始从客户端接收流消息，然后我们检查客户端是否已经完成流，我们这样做的方法是调用<a class="ae li" href="https://golang.org/pkg/io/#pkg-index" rel="noopener ugc nofollow" target="_blank"> io。EOF </a>函数，它允许我们知道流何时结束，并且没有更多输入可供处理。就在我们将错误消息返回给客户端之后。</p><p id="023a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果流还没有完成，我们获取书的标题、页数和年份，并运行一些验证，如果验证失败，我们创建一个新的ValidationError消息，并将其附加到错误数组中。</p><p id="7a51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">服务器现在准备好接受来自客户端的流请求。让我们实现客户端代码。</p><figure class="lp lq lr ls gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1b53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于客户机代码，我们在端口3000上创建一个新的客户机-服务器，使用该书的包提供的<strong class="kd iu"> NewBooksClient </strong>方法。</p><p id="1e29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，validateBooks函数处理流请求。它首先通过初始化一个容器结构并在其上调用initBooks函数来构建请求消息，以获得一些虚拟的book对象。然后，它从ValidateBooks函数获取流对象和一个错误，如果没有错误，它将迭代请求消息，并开始对每个book对象进行流调用。</p><p id="654c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在for循环完成后，我们关闭了流，并打印来自服务器的响应。</p><p id="6c6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，这就是客户端和服务器端go应用程序的所有代码，这次代码稍微复杂一点，因为我们必须从客户端代码发出流请求，从服务器端我们必须允许函数接收流对象。</p><p id="3aba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在准备尝试一下。如果我们转到控制台，在服务器文件夹中，我们可以用下面的命令启动服务器。</p><pre class="lp lq lr ls gt ni nj nk nl aw nm bi"><span id="ff5d" class="lx ly it nj b gy nn no l np nq">go run .</span></pre><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/9c40d01e0668dbfe875dc99756185598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRa7mX7bqbI00eV1scE66A.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">服务器Go应用程序日志</figcaption></figure><p id="5e63" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后使用相同的命令启动客户端，但是在客户端文件夹下，如果一切都正确，您应该会看到预期的结果。</p><figure class="lp lq lr ls gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/f5a8d5a61058a3797bf904caf5f608cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJI5sp1TNUMjd6tYiiyyIg.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">客户端Go应用程序日志</figcaption></figure><p id="28d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">太好了，我们已经实现了一个客户端流rpc调用。</p><p id="2429" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望你觉得有用，学到新东西。在下一篇文章中，我们将使用服务器流响应来处理gRPC调用。</p><p id="701e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您花时间阅读该系列！！</p></div></div>    
</body>
</html>