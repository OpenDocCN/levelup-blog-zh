# JavaScript 中的 OLOO 简介

> 原文：<https://levelup.gitconnected.com/an-introduction-to-oloo-in-javascript-f2ba3445896a>

## 使用 Kyle Simpson 的 OLOO 设计模式的简单解释，用 JavaScript 设计漂亮的对象。

每个 JavaScript 开发者都知道对象是强大的；然而，JavaScript 的对象也有一种独特的继承类型，这赋予了它们新颖的节省空间的能力。

这种类型的继承被称为**原型继承**，这种类型的继承使得 **OLOO** 成为可能。

OLOO 代表**对象链接到其他对象**，是一种对象设计模式。

在能够有效地使用 OLOO 之前，必须理解原型继承的绝对基础。

![](img/2eb1ab5001659bcb92ff615d2ab4f3dd.png)

这不是 JavaScript！

# 原型继承变得简单

不像基于类的语言，比如`Java`和`C#`，JavaScript 只有一个使用继承的构造:对象**。**

**每个对象都有一个私有属性，该属性包含一个到另一个对象的链接，该对象被称为它的**原型**。**

**由 **prototype** 属性指向的对象有自己的 prototype 属性，它指向另一个对象。对象之间的链接形成了一个**原型链**，链的终点是`null`。**

> **因为`prototype`属性是私有的，所以不能通过简单地在对象上调用它来访问它。人们可以调用`Object`上的某些方法来检查对象的原型。**

# **原型链是做什么的？**

**对象是属性的动态集合。**

**当试图访问一个对象的属性时，调用对象将是第一个被检查的对象。**

**然而，如果在被调用的对象上缺少一个属性，该请求将被委托给原型链的上一级**。原型链中的下一个链接，一个对象或`null`，由当前对象的**原型**属性指向。****

****![](img/3cdc307989155e1fbf63fe33f301dbbc.png)****

****每个物体都是链条上的一环。****

****通过跟踪每个链接对象上的`prototype`属性，跟踪这个链，直到找到该属性或者到达`null`。****

****这意味着对象可以访问其原型链中任何对象上的任何属性。****

# ****OLOO 拥抱原型遗传****

****OLOO(原型和构造器设计模式)和`class`语法糖之间的区别在于 OLOO 包含原型继承。另外两个只是简单地模仿经典继承，同时仍然使用原型继承。****

****因为 JavaScript 只使用对象进行继承，而对象只通过原型链进行委托，所以 JavaScript 中唯一可能的继承类型本质上是严格的原型。****

****原型继承和经典继承的主要区别如下:在经典继承中，父对象的属性和方法的完整副本是在子对象中创建的。****

****另一方面，在原型继承中，从一个**原型**创建的每个对象在其自身和原型对象之间形成一个链接。通过此链接，对象可以访问原型对象的属性。****

****通过原型链访问属性被称为**行为委托**。****

****通过使用行为委托，可以节省大量的程序空间。我们不需要从一个原型到链接到它的所有对象上定义属性的完整副本，我们可以简单地从对象到原型委托那些丢失的属性。****

****此外，如果需要更改原型的所有实例共享的属性，只需更改原型的属性。该更改将反映在委托给原型的所有对象中。****

****通过使用 OLOO，人们可以更清楚地使用行为委托和原型继承。****

> ****名称**链接到其他对象**的对象现在有意义了吗？****

# ****用 OLOO 建模对象****

****原型对象是为特定对象组定义一组共享属性的对象。****

****例如，看看下面的仪器。****

****仪器将是原型。****

****可以有把握地假设`Instrument`的所有实例都将被用于`practice`或`perform`。尽管有许多不同类型的工具。如何用 OLOO 模拟特定乐器的独特状态？****

****大多数 OLOO 设计使用`init`方法来定义一个对象的状态。****

****初始化对象的状态。****

****现在，我们可以用状态初始化一个对象，同时仍然将原型链上的行为委托给`Instrument`。****

****谁不爱吉他？****

****`Object.create(prototype)`创建一个新对象，将传递的`prototype`设置为新对象的`prototype`属性。要了解更多关于此方法的信息，请点击[此处](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)。****

****为了确保从原型创建的对象实际上没有原型的属性，可以使用`Object.prototype.hasOwnProperty(propertyName)`方法。该方法根据对象是否具有作为`propertyName`传递的属性来返回`true || false`。****

****检查自持房产。****

****最后，要检查某个对象是否是另一个对象的原型，可以使用`Object.prototype.isPrototypeOf(object)`方法。****

****原型检查成功。****

# ****结论****

****OLOO 可以变得比本文给出的简单解释和示例复杂得多。这篇文章仅仅是对这个微妙话题的简单介绍。****

****想了解更多关于 OLOO 的信息，可以看看凯尔·辛普森的书， [*你不知道的 JS*](https://github.com/petyakostova/IT-Books/blob/master/JavaScript/You%20Don't%20Know%20JS%20-%20Kyle%20Simpson/You%20Don't%20Know%20JS%20(book%20series)%20-%20Kyle%20Simpson.pdf) 。****

****编码快乐！****