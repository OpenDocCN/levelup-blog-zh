<html>
<head>
<title>The Gems of Python — 7 Features You Should Know (and you better know it well)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的瑰宝——您应该知道的7个特性(并且您最好非常了解)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-gems-of-python-7-features-you-should-know-and-you-better-know-it-well-cffa4141d7fa?source=collection_archive---------8-----------------------#2020-07-20">https://levelup.gitconnected.com/the-gems-of-python-7-features-you-should-know-and-you-better-know-it-well-cffa4141d7fa?source=collection_archive---------8-----------------------#2020-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b1a8ba6dd06af9839304e3040e64a6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6kBm-OaLUveOlcK2"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@nosoylasonia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">胡安·戈麦斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="bce7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您很可能听说过Python编程语言的优点——类似英语的语法、简单易学、高度通用，以及编程的瑞士军刀。Python很容易学习，而且这种语言结合了函数式、结构化和OOP范例的思想，使它成为一种极其强大和动态的语言。当其他语言需要许多行代码来完成一项任务时，Python通常可以使用一行代码来完成同样的任务。这就是用Python编程的乐趣。初学者和专家每天都在学习新的技巧。</p><p id="8894" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文讨论了Python语言的几个重要特性，这些特性经常被忽略或者没有被很好地理解，同时还讨论了几个要点，即使是最有经验的开发人员也会被这些要点所困扰。</p><p id="6b87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">具体来说，本文将讨论:</p><ul class=""><li id="2dd4" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">迭代器和生成器</li><li id="51cb" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">列表理解</li><li id="c865" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">使用any()和all()函数</li><li id="fe31" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">使用zip()函数</li><li id="b9c3" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">比较运算符链接</li><li id="a2ba" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">使用可变对象作为默认参数</li><li id="68ca" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">λ函数</li></ul><h1 id="5fd5" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">迭代器和生成器</h1><p id="1480" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">迭代器是Python中一个不容易理解的主题。因此，我将在本文中尝试将其合理化。</p><p id="d469" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，<em class="mv"> iterate </em>这个词的意思是从某物中获得一个物品，一次一个物品。在Python中，许多内置类型支持迭代(我们说它们是一个<em class="mv">可迭代</em>对象)。如<code class="fe mw mx my mz b"><strong class="ki iu">list</strong></code>、<code class="fe mw mx my mz b"><strong class="ki iu">str</strong></code>、<code class="fe mw mx my mz b"><strong class="ki iu">tuple</strong></code>等。这是什么意思？这意味着您可以遍历变量中的每一项，比如说一个<code class="fe mw mx my mz b"><strong class="ki iu">list</strong></code>:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="4683" class="ni lt it mz b gy nj nk l nl nm">nums = [3,4,1,7,9,5]<br/>for n in nums:<br/>    print(n, end=' ')<br/># 3 4 1 7 9 5</span></pre><p id="4ff8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，一个<code class="fe mw mx my mz b"><strong class="ki iu">str</strong></code>:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="ce52" class="ni lt it mz b gy nj nk l nl nm">s = 'Hello'<br/>for c in s:<br/>    print(c, end=' ')<br/># H e l l o</span></pre><p id="7b14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似地，<code class="fe mw mx my mz b"><strong class="ki iu">range()</strong></code>函数返回一个<code class="fe mw mx my mz b"><strong class="ki iu">range</strong></code>对象，它是一个<code class="fe mw mx my mz b"><strong class="ki iu">iterable</strong></code>。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="9526" class="ni lt it mz b gy nj nk l nl nm">r = range(5)<br/>for i in r:<br/>    print(i, end=' ')<br/># 0 1 2 3 4</span></pre><h2 id="5fc8" class="ni lt it bd lu nn no dn ly np nq dp mc kr nr ns mg kv nt nu mk kz nv nw mo nx bi translated">迭代器与可迭代</h2><p id="707e" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">在Python中，当我们谈论迭代时，总会出现两个术语— <em class="mv"> iterable </em>和<em class="mv"> iterator </em>。</p><p id="d617" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<code class="fe mw mx my mz b"><strong class="ki iu">iterable</strong></code>是一个你可以迭代的对象(比如一个<code class="fe mw mx my mz b"><strong class="ki iu">list</strong></code>、<code class="fe mw mx my mz b"><strong class="ki iu">str</strong></code>等等)，而一个<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>是一个你可以使用<code class="fe mw mx my mz b"><strong class="ki iu">next()</strong></code>函数迭代的对象。当您在一个<code class="fe mw mx my mz b"><strong class="ki iu">iterable</strong></code>对象上调用<code class="fe mw mx my mz b"><strong class="ki iu">iter()</strong></code>函数时，就会创建一个<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>。</p><p id="2e96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>都是一个<code class="fe mw mx my mz b"><strong class="ki iu">iterable</strong></code>，而不是每个<code class="fe mw mx my mz b"><strong class="ki iu">iterable</strong></code>都是一个<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>。例如，<code class="fe mw mx my mz b"><strong class="ki iu">list</strong></code>对象是一个<code class="fe mw mx my mz b"><strong class="ki iu">iterable</strong></code>，但它不是一个<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>。</p><p id="10c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">迷茫？考虑下面的例子:</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/663f1a4befd25eae9e924151bbf7b8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RWoGU468JTjFVrjo-YFh5Q.png"/></div></div></figure><p id="6b5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mz b"><strong class="ki iu">nums</strong></code>是一个<code class="fe mw mx my mz b"><strong class="ki iu">list</strong></code>，是一个<code class="fe mw mx my mz b"><strong class="ki iu">iterable</strong></code>。当您使用一个<code class="fe mw mx my mz b"><strong class="ki iu">for</strong></code>循环来遍历它的内容时，它会自动将<code class="fe mw mx my mz b"><strong class="ki iu">nums</strong></code>转换为<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>。当你打印出<code class="fe mw mx my mz b"><strong class="ki iu">n</strong></code>的值时，它调用<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>上的<code class="fe mw mx my mz b"><strong class="ki iu">next()</strong></code>函数来获得下一个值。当没有更多的元素从<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>中获取时，<code class="fe mw mx my mz b"><strong class="ki iu">next()</strong></code>函数将引发<code class="fe mw mx my mz b"><strong class="ki iu">StopIteration</strong></code>异常，一旦捕获到该异常，<code class="fe mw mx my mz b"><strong class="ki iu">for</strong></code>循环将终止。</p><h2 id="2cb4" class="ni lt it bd lu nn no dn ly np nq dp mc kr nr ns mg kv nt nu mk kz nv nw mo nx bi translated">创建迭代器对象</h2><p id="511c" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">您可以使用<code class="fe mw mx my mz b"><strong class="ki iu">iter()</strong></code>函数手动将<code class="fe mw mx my mz b"><strong class="ki iu">iterable</strong></code>转换为迭代器对象:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="8fe0" class="ni lt it mz b gy nj nk l nl nm">nums = [3,4,1,7,9,5]<br/><strong class="mz iu">i = iter(nums)</strong></span></pre><p id="4139" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mz b"><strong class="ki iu">iter()</strong></code>函数的结果是一个<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>对象。要获得<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>对象中的每一项，您需要调用<code class="fe mw mx my mz b"><strong class="ki iu">next()</strong></code>函数:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="4952" class="ni lt it mz b gy nj nk l nl nm">print(next(i))    # 3<br/>print(next(i))    # 4<br/>print(next(i))    # 1<br/>print(next(i))    # 7<br/>print(next(i))    # 9 <br/>print(next(i))    # 5</span></pre><p id="ee53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每次在迭代器上调用<code class="fe mw mx my mz b"><strong class="ki iu">next()</strong></code>函数时，都会返回iterable中的下一个值。当到达最后一项时，您调用<code class="fe mw mx my mz b"><strong class="ki iu">next()</strong></code>函数，将引发<code class="fe mw mx my mz b"><strong class="ki iu">StopIteration</strong></code>异常:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="c1ae" class="ni lt it mz b gy nj nk l nl nm">print(next(i))<br/>'''<br/>---------------------------------------------------------------------------<br/>StopIteration                             Traceback (most recent call last)<br/>&lt;ipython-input-27-58c5a451ce44&gt; in &lt;module&gt;<br/>----&gt; 1 print(next(i))</span><span id="b964" class="ni lt it mz b gy nz nk l nl nm">StopIteration: <br/>'''</span></pre><p id="4bba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用下面的代码片段复制<code class="fe mw mx my mz b"><strong class="ki iu">for</strong></code>循环的功能:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="d650" class="ni lt it mz b gy nj nk l nl nm">nums = [3,4,1,7,9,5]<br/>i = iter(nums)<br/>while True:<br/>    try:<br/>        print(next(i), end=' ')<br/>    except StopIteration:<br/>        break<br/><br/># 3 4 1 7 9 5</span></pre><h2 id="d582" class="ni lt it bd lu nn no dn ly np nq dp mc kr nr ns mg kv nt nu mk kz nv nw mo nx bi translated">实现迭代器对象</h2><p id="e12e" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">有些情况下，您可能想要创建自己的<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>对象。考虑以下场景—您希望生成最大值为1000的斐波纳契数列，但您不需要一次生成所有的数字。你只知道你需要按需生成数字。这是迭代器的完美用例。下面是如何通过创建自己的<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>对象来实现这一点:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="9e4e" class="ni lt it mz b gy nj nk l nl nm">class Fib:                                        <br/>    def __init__(self, max):                      <br/>        self.max = max<br/>        self.a = 0<br/>        self.b = 1</span><span id="19ad" class="ni lt it mz b gy nz nk l nl nm">    def __iter__(self):                          <br/>        return self</span><span id="a773" class="ni lt it mz b gy nz nk l nl nm">    def __next__(self):                          <br/>        fib = self.a<br/>        if fib &gt; self.max:<br/>            raise StopIteration                  <br/>        self.a, self.b = self.b, self.a + self.b<br/>        return fib</span></pre><p id="36c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> Fib </strong>类包含以下内容:</p><ul class=""><li id="1986" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><code class="fe mw mx my mz b"><strong class="ki iu">__init__()</strong></code>初始化器——接受为斐波纳契数列生成的最大值</li><li id="5495" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe mw mx my mz b"><strong class="ki iu">__iter__()</strong></code>函数—返回给定对象的<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code></li><li id="986d" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe mw mx my mz b"><strong class="ki iu">__next__()</strong></code>函数—返回<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>对象中的下一个值。当在最后一个元素被迭代后调用该函数时，会引发<code class="fe mw mx my mz b"><strong class="ki iu">StopIteration</strong></code>异常。</li></ul><p id="ee12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了生成最大值为1000的所有斐波纳契数，您创建了一个<code class="fe mw mx my mz b"><strong class="ki iu">Fib</strong></code>对象(它是一个迭代器):</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="9d46" class="ni lt it mz b gy nj nk l nl nm">fib = Fib(1000)</span></pre><p id="ac23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最好的事情是<code class="fe mw mx my mz b"><strong class="ki iu">Fib</strong></code>类不需要一次生成并存储所有的斐波那契数。事实上，所有的数字都还没有生成。只有当用<code class="fe mw mx my mz b"><strong class="ki iu">next()</strong></code>函数调用<code class="fe mw mx my mz b"><strong class="ki iu">iterator</strong></code>对象时，序列中才会生成一个数字:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="be03" class="ni lt it mz b gy nj nk l nl nm">print(next(fib))  # 0<br/>print(next(fib))  # 1<br/>print(next(fib))  # 1<br/>print(next(fib))  # 2<br/>print(next(fib))  # 3</span></pre><p id="6af2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在内部，<strong class="ki iu"> Fib </strong>类只需要存储三个变量——<code class="fe mw mx my mz b"><strong class="ki iu">a</strong></code>、<code class="fe mw mx my mz b"><strong class="ki iu">b</strong></code>和<code class="fe mw mx my mz b"><strong class="ki iu">max</strong></code>。</p><p id="1d39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想得到序列中的所有数字，你可以使用一个<code class="fe mw mx my mz b"><strong class="ki iu">for</strong></code>循环:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="69ff" class="ni lt it mz b gy nj nk l nl nm">for i in fib:<br/>    print(i, end=' ')<br/>#  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</span></pre><p id="eb96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，要强制<strong class="ki iu"> Fib </strong>类一次返回所有数字，使用<strong class="ki iu"> list() </strong>函数调用它:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="761f" class="ni lt it mz b gy nj nk l nl nm">fib = Fib(1000)<br/>list(fib)<br/># [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]</span></pre><h2 id="6224" class="ni lt it bd lu nn no dn ly np nq dp mc kr nr ns mg kv nt nu mk kz nv nw mo nx bi translated">使用生成器实现迭代器</h2><p id="d2e3" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">虽然您可以使用带有<code class="fe mw mx my mz b"><strong class="ki iu">__iter__()</strong></code>和<code class="fe mw mx my mz b"><strong class="ki iu">__next__()</strong></code>函数的<code class="fe mw mx my mz b"><strong class="ki iu">Class</strong></code>来实现<code class="fe mw mx my mz b"><strong class="ki iu">iterators</strong></code>，但有时这太麻烦了。更简单的方法是使用<em class="mv">发电机</em>。生成器允许你从函数中创建迭代器。像往常一样，举个例子就能消除误会。</p><blockquote class="oa ob oc"><p id="ef15" class="kg kh mv ki b kj kk kl km kn ko kp kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated">生成器允许你从函数中创建迭代器。</p></blockquote><p id="4d81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再次考虑斐波那契的例子。想象一下现在需求有了一点变化。您现在想要生成一个无限的斐波那契数列，而不是生成一个特定最大数目的数列。您可以使用带有生成器的函数来实现这一点:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="8165" class="ni lt it mz b gy nj nk l nl nm">def fib():<br/>    a, b = 0, 1<br/>    while True:<br/>        yield a<br/>        a, b = b, a + b</span></pre><p id="87b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这看起来像一个常规函数，除了<code class="fe mw mx my mz b"><strong class="ki iu">yield</strong></code>语句。具体来说，上面的<code class="fe mw mx my mz b"><strong class="ki iu">fib()</strong></code>函数返回一个<code class="fe mw mx my mz b"><strong class="ki iu">generator</strong></code> <strong class="ki iu"> </strong>对象。</p><blockquote class="oa ob oc"><p id="968f" class="kg kh mv ki b kj kk kl km kn ko kp kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated">生成器是产生一系列值而不是单个值的函数。</p></blockquote><p id="7979" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mz b"><strong class="ki iu">yield</strong></code>语句和<code class="fe mw mx my mz b"><strong class="ki iu">return</strong></code>语句一样，只有一个例外——当执行<code class="fe mw mx my mz b"><strong class="ki iu">yield</strong></code>语句时，程序暂停函数的执行，保留函数的状态，并返回值；下一次调用者调用<code class="fe mw mx my mz b"><strong class="ki iu">generator</strong></code>对象上的<strong class="ki iu"> next() </strong>函数时，函数的执行将从先前停止的地方继续。</p><blockquote class="oa ob oc"><p id="1ca9" class="kg kh mv ki b kj kk kl km kn ko kp kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated">生成器基本上是一个迭代器。</p></blockquote><p id="57ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要查看它是如何工作的，调用<code class="fe mw mx my mz b"><strong class="ki iu">fib()</strong></code>函数并在<code class="fe mw mx my mz b"><strong class="ki iu">generator</strong></code>对象上调用<code class="fe mw mx my mz b"><strong class="ki iu">next()</strong></code>函数:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="754c" class="ni lt it mz b gy nj nk l nl nm">i = fib()<br/>print(next(i)) # 0<br/>print(next(i)) # 1<br/>print(next(i)) # 1<br/>print(next(i)) # 2<br/>print(next(i)) # 3</span></pre><blockquote class="og"><p id="b4b3" class="oh oi it bd oj ok ol om on oo op ld dk translated">从这个例子中得到的关键是，迭代器(和生成器)适用于计算大型结果集，在这种情况下，您不知道何时需要所有结果，或者您不想同时为所有结果分配内存。</p></blockquote><h1 id="50af" class="ls lt it bd lu lv lw lx ly lz ma mb mc md oq mf mg mh or mj mk ml os mn mo mp bi translated">列表理解</h1><p id="824c" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">Python的标志性特性之一是<em class="mv">列表理解</em>。列表理解完美地展示了Python的优雅——易读、易懂、单行且功能强大。</p><p id="f394" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">列表理解允许您使用以下语法创建列表:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="bafa" class="ni lt it mz b gy nj nk l nl nm">new_list = <strong class="mz iu">[</strong><em class="mv">expression</em> <strong class="mz iu">for</strong> <em class="mv">item</em> <strong class="mz iu">in</strong> <em class="mv">iterable optional_expression</em><strong class="mz iu">]</strong></span></pre><p id="ea28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，要创建一个从0到10的偶数列表，可以使用以下语句:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="e081" class="ni lt it mz b gy nj nk l nl nm">evens = <strong class="mz iu">[n for n in range(0,11,2)]</strong><br/># [0, 2, 4, 6, 8, 10]</span></pre><p id="718f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，您生成一个范围从0到11(不含)的值，步长为2。也就是0，2，4，6，8，10。然后使用变量<code class="fe mw mx my mz b"><strong class="ki iu">n</strong></code>使用<strong class="ki iu"> for </strong>循环遍历这组数字。然后将<strong class="ki iu"> n </strong>的每个值添加到列表中。最终结果是:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="3127" class="ni lt it mz b gy nj nk l nl nm">[0, 2, 4, 6, 8, 10]</span></pre><p id="aaa4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还可以在iterable后面添加一个可选表达式，如下所示:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="a013" class="ni lt it mz b gy nj nk l nl nm">evens = [n for n in range(0,11) <strong class="mz iu">if n % 2 == 0</strong>]<br/>evens</span></pre><p id="50f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的语句将产生相同的结果。在这种情况下，<strong class="ki iu"> n </strong>将只取0到11(不含)的所有能被2整除的数。注意，这里不允许有<code class="fe mw mx my mz b"><strong class="ki iu">else</strong></code>条件:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="71f2" class="ni lt it mz b gy nj nk l nl nm">evens = [n for n in range(0,11) if n % 2 == 0 <strong class="mz iu">else ...</strong>]   <strong class="mz iu"># error</strong></span></pre><p id="d411" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，你也可以把你的表达式放在<code class="fe mw mx my mz b"><strong class="ki iu">for</strong></code>循环之前，就像这样:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="5092" class="ni lt it mz b gy nj nk l nl nm">evens = [<strong class="mz iu">n if n % 2 == 0 else “-”</strong> for n in range(0,11)]<br/># [0, '-', 2, '-', 4, '-', 6, '-', 8, '-', 10]</span></pre><p id="0897" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的语句中，您正在检查<strong class="ki iu"> n </strong>是否能被2整除。如果是，结果将包括<strong class="ki iu"> n </strong>，否则将包括<code class="fe mw mx my mz b"><strong class="ki iu">-</strong></code>。请注意，在这种情况下，<code class="fe mw mx my mz b"><strong class="ki iu">else</strong></code>语句是强制的。</p><h2 id="80fa" class="ni lt it bd lu nn no dn ly np nq dp mc kr nr ns mg kv nt nu mk kz nv nw mo nx bi translated">何时不使用列表理解</h2><p id="2671" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">虽然列表理解是优雅的，但有些时候你不应该使用它。因为列表理解需要生成列表中的所有项目并存储在内存中，所以在处理大量项目时效率非常低。</p><p id="8c4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑这样一种情况，您想要对从1到1000000000的所有数字求和。使用列表理解，您的代码将类似于:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="a2a1" class="ni lt it mz b gy nj nk l nl nm">sum([n for n in range(1,1000000001)])</span></pre><p id="3638" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">问题是，在使用<strong class="ki iu"> sum() </strong>函数对列表中的10亿个数字求和之前，您首先需要生成它们。上面的语句使用了大量内存。在这种情况下，最好使用生成器，如下所示:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="8680" class="ni lt it mz b gy nj nk l nl nm">sum(n for n in range(1,1000000001))</span></pre><blockquote class="oa ob oc"><p id="354c" class="kg kh mv ki b kj kk kl km kn ko kp kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated">注意:生成器用括号括起来。</p></blockquote><p id="d664" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用生成器，每次生成一个数时，它都被添加到当前和中，然后被丢弃。因此，没有必要在内存中存储10亿个数字。</p><h1 id="ab4f" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用any()和all()函数</h1><p id="7c7c" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated"><code class="fe mw mx my mz b"><strong class="ki iu">any()</strong></code>函数检查一个iterable(列表、元组、集合、生成器等)以查看<em class="mv">是否有任何</em>项是<code class="fe mw mx my mz b"><strong class="ki iu">True</strong></code>。另一方面，<code class="fe mw mx my mz b"><strong class="ki iu">all()</strong></code>函数检查一个iterable来查看<em class="mv">是否所有的</em>项都是<code class="fe mw mx my mz b"><strong class="ki iu">True</strong></code>。</p><p id="2aaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面检查一个列表，看看<code class="fe mw mx my mz b"><strong class="ki iu">nums</strong></code>中的<em class="mv">项是否有</em>项是<em class="mv">偶数</em>项:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="888d" class="ni lt it mz b gy nj nk l nl nm">nums = [12,44,56,24,13,78,32,123,3]<br/><strong class="mz iu">any</strong>([n % 2 == 0 for n in nums])              # True</span></pre><p id="f2b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想查看nums中的所有数字是否都是偶数，则使用<code class="fe mw mx my mz b"><strong class="ki iu">all()</strong></code>功能:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="3a9c" class="ni lt it mz b gy nj nk l nl nm"><strong class="mz iu">all</strong>([n % 2 == 0 for n in nums])              # False</span></pre><p id="6d73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以这里有一个测验来测试你自己。给定一个单词列表，你能写代码来检查列表中的任何单词是否包含元音(例如' aeoiu ')？</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="b673" class="ni lt it mz b gy nj nk l nl nm">words = ['The','quick','brown','sly','fox',<br/>         'jumps','over','the','lazy','dog']</span></pre><p id="ebf6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在你回来寻找答案之前，你可以自己尝试一下。</p><p id="e310" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">准备好了吗？完成了吗？</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="b92f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是我使用<code class="fe mw mx my mz b"><strong class="ki iu">any()</strong></code>函数和列表理解的答案:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="e3e3" class="ni lt it mz b gy nj nk l nl nm"><strong class="mz iu">any(any(c.lower() in 'aeiou' for c in word) for word in words)</strong></span></pre><p id="ed23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了理解上面的陈述，您从最右边的表达式开始:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="7737" class="ni lt it mz b gy nj nk l nl nm">(word for word in words)</span></pre><p id="216f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将返回一个<em class="mv">生成器</em>。然后，对于每个单词，检查每个字符，看它是否包含'<em class="mv"> aeiou </em>'中的任何字符:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="d0c9" class="ni lt it mz b gy nj nk l nl nm"><strong class="mz iu">any</strong>(c.lower() in 'aeiou' for c in word)</span></pre><p id="64a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mz b"><strong class="ki iu">any()</strong></code>函数执行<em class="mv">短路</em>——只要一个字符在<em class="mv"> aeiou </em>中，就不需要进一步检查。并且这种短路扩展到列表中的所有单词:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="9adb" class="ni lt it mz b gy nj nk l nl nm"><strong class="mz iu">any</strong>(any(c.lower() in 'aeiou' for c in word) for word in words)</span></pre><p id="6941" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果列表中的任何单词有一个字符在'<em class="mv"> aeiou </em>中，则操作停止并返回<code class="fe mw mx my mz b"><strong class="ki iu">True</strong></code>。</p><h1 id="9353" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用zip()函数</h1><p id="f95a" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated"><code class="fe mw mx my mz b"><strong class="ki iu">zip()</strong></code>函数将两个以上的可重复项连接在一起。考虑以下代码片段:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="56ac" class="ni lt it mz b gy nj nk l nl nm">days = [1,5,9]<br/>months = ['Feb','Apr','Dec']<br/>years = [2019,2020,2021]</span></pre><p id="f99d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您有三组日期，每一组都存储在三个单独的列表中。如果您想提取所有日期，您可以使用<code class="fe mw mx my mz b"><strong class="ki iu">zip()</strong></code>功能将它们组合起来:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="43c1" class="ni lt it mz b gy nj nk l nl nm">zip(days, months, years)</span></pre><p id="e984" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是<strong class="ki iu"> </strong> <code class="fe mw mx my mz b"><strong class="ki iu">zip()</strong></code>函数返回一个<code class="fe mw mx my mz b"><strong class="ki iu">zip</strong></code>对象，您必须对其进行迭代以获取其内容。最简单的方法是用<em class="mv">列表领悟</em>，就像这样:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="d904" class="ni lt it mz b gy nj nk l nl nm">[date for date in zip(days, months, years)]<br/># [(1, 'Feb', 2019), (5, 'Apr', 2020), (9, 'Dec', 2021)]</span></pre><p id="9961" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后可以将列表中的每个元组转换成一个<code class="fe mw mx my mz b"><strong class="ki iu">Date</strong></code>对象:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="23af" class="ni lt it mz b gy nj nk l nl nm">from datetime import datetime</span><span id="5de3" class="ni lt it mz b gy nz nk l nl nm">for d in [date for date in zip(days, months, years)]:<br/>    date_string = f'{d[0]} {d[1]}, {d[2]}'<br/>    date_object = datetime.strptime(date_string, "%d %b, %Y")<br/>    print(date_object.date())<br/>'''<br/>2019-02-01<br/>2020-04-05<br/>2021-12-09<br/>'''</span></pre><h1 id="e674" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">比较运算符链接</strong></h1><p id="eb28" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">执行比较时，通常会检查某个值是否在特定范围内。例如，您想检查一个变量是否大于2且小于6，因此通常的代码如下所示:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="499a" class="ni lt it mz b gy nj nk l nl nm">num = 5<br/>if num&lt;6 and num&gt;2:<br/>    print(True)<br/>else:<br/>    print(False)</span></pre><p id="5ca9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，Python支持比较运算符链，因此您可以像这样重写上面的比较表达式:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="b1c3" class="ni lt it mz b gy nj nk l nl nm">print(2&lt;num&lt;6)   # True<br/>print(6&gt;num&gt;2)   # True<br/>print(2&lt;num&lt;5)   # False</span></pre><p id="e2f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然看起来更整洁，更容易理解！</p><h1 id="fdc6" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">不要使用可变对象作为默认参数</h1><p id="daad" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">Python支持可选参数-如果未提供参数，将为其提供默认值。如果不小心的话，这个看似简单直接的特性会有一些意想不到的行为。考虑以下情况</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="6589" class="ni lt it mz b gy nj nk l nl nm">def do_something(arg1, arg2=[]):<br/>    arg2.append(arg1)<br/>    print(arg2)</span></pre><p id="659e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数<code class="fe mw mx my mz b"><strong class="ki iu">arg2</strong></code>是可选的。如果没有提供值<code class="fe mw mx my mz b"><strong class="ki iu">arg2</strong></code>将假定一个空列表。在该功能中，<code class="fe mw mx my mz b"><strong class="ki iu">arg1</strong></code>将被追加到<code class="fe mw mx my mz b"><strong class="ki iu">arg2</strong></code>。为了便于查看<code class="fe mw mx my mz b"><strong class="ki iu">arg2</strong></code>的值，我在函数中将其打印出来。</p><p id="ce8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在提供两个参数的情况下测试调用该函数:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="55da" class="ni lt it mz b gy nj nk l nl nm">do_something(2, [1])    <br/>do_something(3, [2])    <br/>do_something(4, [3])    <br/>'''<br/>[1, 2]<br/>[2, 3]<br/>[3, 4]<br/>'''</span></pre><p id="bcb0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的结果似乎合乎逻辑，也符合我们的理解。现在让我们省略第二个参数，用<code class="fe mw mx my mz b"><strong class="ki iu">1</strong></code>调用函数。既然现在省略了第二个参数，<code class="fe mw mx my mz b"><strong class="ki iu">arg2</strong></code>应该假设为<code class="fe mw mx my mz b"><strong class="ki iu">[]</strong></code>。如预期的那样，在<code class="fe mw mx my mz b"><strong class="ki iu">[]</strong></code>后添加一个<code class="fe mw mx my mz b"><strong class="ki iu">1</strong></code>应该会产生一个<code class="fe mw mx my mz b"><strong class="ki iu">[1]</strong></code>:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="e8c8" class="ni lt it mz b gy nj nk l nl nm">do_something(1)<br/>'''<br/>[1]<br/>'''</span></pre><p id="0d92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果您使用相同的参数再次调用该函数，您现在会得到一个<code class="fe mw mx my mz b"><strong class="ki iu">[1,1]</strong></code>:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="4136" class="ni lt it mz b gy nj nk l nl nm">do_something(1) <br/>'''<br/>[1, 1]<br/>'''</span></pre><p id="731c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再次调用该函数会产生<code class="fe mw mx my mz b"><strong class="ki iu">[1,1,1]</strong></code>:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="d2c6" class="ni lt it mz b gy nj nk l nl nm">do_something(1) <br/>'''<br/>[1, 1, 1]<br/>'''</span></pre><p id="eda7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能希望每次调用该函数时，<code class="fe mw mx my mz b"><strong class="ki iu">arg2</strong></code>都会被初始化为<code class="fe mw mx my mz b"><strong class="ki iu">[]</strong></code>。然而，事实显然并非如此。事实证明，对于可选参数，如果默认值是一个<em class="mv">可变</em>类型(list是一个可变类型)，默认值将只初始化<em class="mv">一次</em>。当随后调用该函数时，<code class="fe mw mx my mz b"><strong class="ki iu">arg2</strong></code>将恢复其现有值。这让相当多的人大吃一惊。</p><blockquote class="oa ob oc"><p id="39c5" class="kg kh mv ki b kj kk kl km kn ko kp kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated">通常，不要使用可变对象作为可选参数的值。</p></blockquote><p id="eea8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，如何按照您的预期解决这个问题呢？最简单的方法是在函数内部对<code class="fe mw mx my mz b"><strong class="ki iu">arg2</strong></code>进行初始化，并在函数声明中将其设置为<code class="fe mw mx my mz b"><strong class="ki iu">None</strong></code>:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="91d1" class="ni lt it mz b gy nj nk l nl nm">def do_something(arg1, <strong class="mz iu">arg2=None</strong>):<br/><strong class="mz iu">    if arg2 is None:<br/>        arg2 = []<br/></strong>    arg2.append(arg1)<br/>    print(arg2)</span></pre><p id="05f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您的功能现在将按预期工作:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="78f0" class="ni lt it mz b gy nj nk l nl nm">do_something(1)  #  [1]<br/>do_something(1)  #  [1]<br/>do_something(1)  #  [1]</span></pre><h1 id="0200" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">λ函数</h1><p id="16da" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">Python支持使用lambda函数。Lambda函数是没有名字的匿名函数。本质上，lambda函数是单表达式函数。恰当地使用lambda函数可以让你的代码更具可读性和可维护性。让我们试着去理解lambda函数是如何工作的。</p><p id="4500" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑下面的数字列表，<code class="fe mw mx my mz b"><strong class="ki iu">nums</strong></code>:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="590e" class="ni lt it mz b gy nj nk l nl nm">nums = [3,4,1,7,9,5]</span></pre><p id="0eeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您想将每个数字乘以一个常数，比如2。这可以通过多种方法轻松实现。一是通过<em class="mv">列表理解</em>:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="9230" class="ni lt it mz b gy nj nk l nl nm">[n * 2 for n in nums]</span></pre><p id="d4ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种方法是使用<code class="fe mw mx my mz b"><strong class="ki iu">map()</strong></code>函数。<code class="fe mw mx my mz b"><strong class="ki iu">map()</strong></code>函数允许你在<em class="mv"> iterable </em>(比如一个列表)的所有元素上应用一个函数，从而将它从一个值映射到另一个值(因此得名)。为了理解<code class="fe mw mx my mz b"><strong class="ki iu">map()</strong></code>函数是如何工作的，让我们一步一步来研究它。</p><p id="3f84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mz b"><strong class="ki iu">map()</strong></code>函数接受两个参数——一个iterable和一个函数。对于函数，让我们定义一个名为<code class="fe mw mx my mz b"><strong class="ki iu">change()</strong></code>的函数，带有一个输入参数，并将其传递给<code class="fe mw mx my mz b"><strong class="ki iu">map()</strong></code>函数:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="2d9f" class="ni lt it mz b gy nj nk l nl nm"><strong class="mz iu">def change(n):<br/>    print(n)<br/>    return n </strong>   </span><span id="514f" class="ni lt it mz b gy nz nk l nl nm">nums_modified = map(<strong class="mz iu">change</strong>, nums)</span></pre><p id="ef8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当处理接受另一个函数的函数时(比如<code class="fe mw mx my mz b"><strong class="ki iu">map()</strong></code>函数)，我总是喜欢先定义一个函数并打印出参数，这样我就可以检查传递给函数的是什么。当您运行上面的代码片段时，不会打印出任何内容。这是因为<code class="fe mw mx my mz b"><strong class="ki iu">map()</strong></code>函数返回一个<code class="fe mw mx my mz b"><strong class="ki iu">map</strong></code>对象，该对象本身是一个迭代器(因此是可迭代的)。您可以使用以下语句来确认对象是否是可迭代的:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="a4b3" class="ni lt it mz b gy nj nk l nl nm">import collections.abc<br/>isinstance(nums_modified, collections.abc.Iterable)  # True</span></pre><p id="5edb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<code class="fe mw mx my mz b"><strong class="ki iu">nums_modified</strong></code>是一个迭代器，为了让您看到<strong class="ki iu"> change() </strong>函数的输出，您可以使用<code class="fe mw mx my mz b"><strong class="ki iu">list()</strong></code>函数将其转换为<code class="fe mw mx my mz b"><strong class="ki iu">list</strong></code>:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="3a0a" class="ni lt it mz b gy nj nk l nl nm">list(nums_modified)</span></pre><p id="e3a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您现在可以看到以下输出:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="8576" class="ni lt it mz b gy nj nk l nl nm">3<br/>4<br/>1<br/>7<br/>9<br/>5</span><span id="814e" class="ni lt it mz b gy nz nk l nl nm">[3, 4, 1, 7, 9, 5]</span></pre><p id="bc21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以现在很清楚<code class="fe mw mx my mz b"><strong class="ki iu">change()</strong></code>函数在做什么——它基本上是一个接一个地获取<code class="fe mw mx my mz b"><strong class="ki iu">nums</strong></code>列表中的所有数字，然后返回数字。</p><p id="c706" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们返回每个乘以2的数字:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="6664" class="ni lt it mz b gy nj nk l nl nm">def change(n):<br/><strong class="mz iu">    return n*2</strong></span></pre><p id="fff0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出将是:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="82d9" class="ni lt it mz b gy nj nk l nl nm">nums_modified = map(change, nums)<br/>list(nums_modified)<br/><strong class="mz iu"># [6, 8, 2, 14, 18, 10]</strong></span></pre><p id="9494" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了对<code class="fe mw mx my mz b"><strong class="ki iu">change()</strong></code>函数所做的事情的更清晰的了解，您就可以专注于将它转换成lambda函数了。</p><blockquote class="oa ob oc"><p id="905a" class="kg kh mv ki b kj kk kl km kn ko kp kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated">记住，lambda函数没有名字，它只能包含一个表达式。</p></blockquote><p id="823f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此<code class="fe mw mx my mz b"><strong class="ki iu">change()</strong></code>函数现在可以重写如下:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="2a04" class="ni lt it mz b gy nj nk l nl nm">nums_modified = map(<strong class="mz iu">lambda n:n*2</strong>, nums)</span></pre><p id="0e5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想将数字转换成字符串，并在每个字符串前面加上“<code class="fe mw mx my mz b"><strong class="ki iu">$</strong></code>”符号，该怎么办？你可以用<em class="mv"> f弦</em>来做:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="f32f" class="ni lt it mz b gy nj nk l nl nm">nums_modified = map(lambda n:<strong class="mz iu">f'${n}'</strong>, nums)<br/>list(nums_modified)<br/>#['$3', '$4', '$1', '$7', '$9', '$5']</span></pre><blockquote class="oa ob oc"><p id="bf3c" class="kg kh mv ki b kj kk kl km kn ko kp kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated">f字符串是Python 3.6及更高版本中提供的一项功能</p></blockquote><p id="60c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对每件商品征收7%的销售税怎么样？f字符串变量支持Python表达式:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="99a1" class="ni lt it mz b gy nj nk l nl nm">nums_modified = map(lambda n:<strong class="mz iu">f'${n*1.07:.2f}</strong>', nums)<br/>list(nums_modified)<br/># ['$3.21', '$4.28', '$1.07', '$7.49', '$9.63', '$5.35']</span></pre><p id="d62f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果销售税只适用于5美元及以上的商品怎么办？您可以使用Python <em class="mv">三元运算符</em>来实现:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="b19b" class="ni lt it mz b gy nj nk l nl nm">nums_modified = map(lambda n:<strong class="mz iu">f'${(n*1.07 if n&gt;=5 else n):.2f}'</strong>, <br/>                    nums)<br/>list(nums_modified)<br/>#['$3.00', '$4.00', '$1.00', '$7.49', '$9.63', '$5.35']</span></pre><p id="ce3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只要函数的内容可以在一个表达式中完成，就可以用lambda函数代替常规函数。</p><p id="e58b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Lambda函数非常有用，尤其是在处理熊猫数据帧时。</p><h1 id="fd26" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">摘要</h1><p id="bdbd" class="pw-post-body-paragraph kg kh it ki b kj mq kl km kn mr kp kq kr ms kt ku kv mt kx ky kz mu lb lc ld im bi translated">我希望您现在对Python中的一些优秀特性有了更好的理解。如果您认为我遗漏了任何值得一提的特性，请告诉我！</p><div class="pa pb gp gr pc pd"><a href="https://weimenglee.medium.com/membership" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd iu gy z fp pi fr fs pj fu fw is bi translated">加入媒介与我的介绍链接-李伟孟</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">weimenglee.medium.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr jz pd"/></div></div></a></div></div></div>    
</body>
</html>