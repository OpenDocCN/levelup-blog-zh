<html>
<head>
<title>An Introduction to OLOO in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的OLOO简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-introduction-to-oloo-in-javascript-f2ba3445896a?source=collection_archive---------3-----------------------#2020-04-10">https://levelup.gitconnected.com/an-introduction-to-oloo-in-javascript-f2ba3445896a?source=collection_archive---------3-----------------------#2020-04-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6837" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Kyle Simpson的OLOO设计模式的简单解释，用JavaScript设计漂亮的对象。</h2></div><p id="f534" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个JavaScript开发者都知道对象是强大的；然而，JavaScript的对象也有一种独特的继承类型，这赋予了它们新颖的节省空间的能力。</p><p id="1d4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种类型的继承被称为<strong class="kk iu">原型继承</strong>，这种类型的继承使得<strong class="kk iu"> OLOO </strong>成为可能。</p><p id="4e81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OLOO代表<strong class="kk iu">对象链接到其他对象</strong>，是一种对象设计模式。</p><p id="0d36" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在能够有效地使用OLOO之前，必须理解原型继承的绝对基础。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/2eb1ab5001659bcb92ff615d2ab4f3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YaueU4meqq-bCM8y3OlkQ.jpeg"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">这不是JavaScript！</figcaption></figure><h1 id="289d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">原型继承变得简单</h1><p id="2a7f" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">不像基于类的语言，比如<code class="fe mr ms mt mu b">Java</code>和<code class="fe mr ms mt mu b">C#</code>，JavaScript只有一个使用继承的构造:对象<strong class="kk iu"/>。</p><p id="d2f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个对象都有一个私有属性，该属性包含一个到另一个对象的链接，该对象被称为它的<strong class="kk iu">原型</strong>。</p><p id="5102" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由<strong class="kk iu"> prototype </strong>属性指向的对象有自己的prototype属性，它指向另一个对象。对象之间的链接形成了一个<strong class="kk iu">原型链</strong>，链的终点是<code class="fe mr ms mt mu b">null</code>。</p><blockquote class="mv mw mx"><p id="0823" class="ki kj my kk b kl km ju kn ko kp jx kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">因为<code class="fe mr ms mt mu b">prototype</code>属性是私有的，所以不能通过简单地在对象上调用它来访问它。人们可以调用<code class="fe mr ms mt mu b">Object</code>上的某些方法来检查对象的原型。</p></blockquote><h1 id="f08a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">原型链是做什么的？</h1><p id="2450" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">对象是属性的动态集合。</p><p id="5a1e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当试图访问一个对象的属性时，调用对象将是第一个被检查的对象。</p><p id="c0f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果在被调用的对象上缺少一个属性，该请求将被委托给原型链的上一级<strong class="kk iu"/>。原型链中的下一个链接，一个对象或<code class="fe mr ms mt mu b">null</code>，由当前对象的<strong class="kk iu">原型</strong>属性指向。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nc"><img src="../Images/3cdc307989155e1fbf63fe33f301dbbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88iSfebNuHbUOqoRNKRwZg.jpeg"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">每个物体都是链条上的一环。</figcaption></figure><p id="68d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过跟踪每个链接对象上的<code class="fe mr ms mt mu b">prototype</code>属性，跟踪这个链，直到找到该属性或者到达<code class="fe mr ms mt mu b">null</code>。</p><p id="17e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着对象可以访问其原型链中任何对象上的任何属性。</p><h1 id="cc11" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">OLOO拥抱原型遗传</h1><p id="e7bd" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">OLOO(原型和构造器设计模式)和<code class="fe mr ms mt mu b">class</code>语法糖之间的区别在于OLOO包含原型继承。另外两个只是简单地模仿经典继承，同时仍然使用原型继承。</p><p id="1d80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为JavaScript只使用对象进行继承，而对象只通过原型链进行委托，所以JavaScript中唯一可能的继承类型本质上是严格的原型。</p><p id="57b9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原型继承和经典继承的主要区别如下:在经典继承中，父对象的属性和方法的完整副本是在子对象中创建的。</p><p id="a5c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，在原型继承中，从一个<strong class="kk iu">原型</strong>创建的每个对象在其自身和原型对象之间形成一个链接。通过此链接，对象可以访问原型对象的属性。</p><p id="e7e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过原型链访问属性被称为<strong class="kk iu">行为委托</strong>。</p><p id="44cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用行为委托，可以节省大量的程序空间。我们不需要从一个原型到链接到它的所有对象上定义属性的完整副本，我们可以简单地从对象到原型委托那些丢失的属性。</p><p id="7888" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，如果需要更改原型的所有实例共享的属性，只需更改原型的属性。该更改将反映在委托给原型的所有对象中。</p><p id="c832" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用OLOO，人们可以更清楚地使用行为委托和原型继承。</p><blockquote class="mv mw mx"><p id="a534" class="ki kj my kk b kl km ju kn ko kp jx kq mz ks kt ku na kw kx ky nb la lb lc ld im bi translated">名称<strong class="kk iu">链接到其他对象</strong>的对象现在有意义了吗？</p></blockquote><h1 id="108e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">用OLOO建模对象</h1><p id="75fa" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">原型对象是为特定对象组定义一组共享属性的对象。</p><p id="b87f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，看看下面的仪器。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">仪器将是原型。</figcaption></figure><p id="1cc4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以有把握地假设<code class="fe mr ms mt mu b">Instrument</code>的所有实例都将被用于<code class="fe mr ms mt mu b">practice</code>或<code class="fe mr ms mt mu b">perform</code>。尽管有许多不同类型的工具。如何用OLOO模拟特定乐器的独特状态？</p><p id="5112" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数OLOO设计使用<code class="fe mr ms mt mu b">init</code>方法来定义一个对象的状态。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">初始化对象的状态。</figcaption></figure><p id="ddd1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以用状态初始化一个对象，同时仍然将原型链上的行为委托给<code class="fe mr ms mt mu b">Instrument</code>。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">谁不爱吉他？</figcaption></figure><p id="abb7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mr ms mt mu b">Object.create(prototype)</code>创建一个新对象，将传递的<code class="fe mr ms mt mu b">prototype</code>设置为新对象的<code class="fe mr ms mt mu b">prototype</code>属性。要了解更多关于此方法的信息，请点击<a class="ae nf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="67dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了确保从原型创建的对象实际上没有原型的属性，可以使用<code class="fe mr ms mt mu b">Object.prototype.hasOwnProperty(propertyName)</code>方法。该方法根据对象是否具有作为<code class="fe mr ms mt mu b">propertyName</code>传递的属性来返回<code class="fe mr ms mt mu b">true || false</code>。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">检查自持房产。</figcaption></figure><p id="be76" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，要检查某个对象是否是另一个对象的原型，可以使用<code class="fe mr ms mt mu b">Object.prototype.isPrototypeOf(object)</code>方法。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">原型检查成功。</figcaption></figure><h1 id="3cd7" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="e2c2" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">OLOO可以变得比本文给出的简单解释和示例复杂得多。这篇文章仅仅是对这个微妙话题的简单介绍。</p><p id="60e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想了解更多关于OLOO的信息，可以看看凯尔·辛普森的书，<a class="ae nf" href="https://github.com/petyakostova/IT-Books/blob/master/JavaScript/You%20Don't%20Know%20JS%20-%20Kyle%20Simpson/You%20Don't%20Know%20JS%20(book%20series)%20-%20Kyle%20Simpson.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="my">你不知道的JS </em> </a>。</p><p id="5122" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码快乐！</p></div></div>    
</body>
</html>