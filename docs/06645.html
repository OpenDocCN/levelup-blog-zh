<html>
<head>
<title>How to Handle Advanced Requests on Android with GraphQL &amp;RxJava</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用GraphQL &amp;RxJava处理Android上的高级请求</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/easily-handle-advanced-requests-on-android-with-graphql-and-rxjava-dca2cc0cecee?source=collection_archive---------14-----------------------#2020-12-15">https://levelup.gitconnected.com/easily-handle-advanced-requests-on-android-with-graphql-and-rxjava-dca2cc0cecee?source=collection_archive---------14-----------------------#2020-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/adceec767bb9c88440a952005d5dff1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XGRUpjhpnGtdmN3C"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="1f81" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="5aad" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">欢迎阅读我的GraphQL、Android和RxJava系列的第二部分！如果你还没有看过，一定要看看我的文章<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/apollo-rxjava-android-graphql-the-right-way-a1f2b10a9ac8">第一部分</a>，在那里我回顾了在Android上使用RxJava和GraphQL的基础知识。在本文中，我们将讨论一些更高级的主题，比如处理并行和依赖请求。我们开始吧！</p><h1 id="1341" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">设置</h1><p id="c2bb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">对于这里的例子，我们将继续使用我在上一篇文章中设置的Android应用程序。在本文中，我们也将继续使用SpaceX GraphQL API。特别是<code class="fe lz ma mb mc b">rocket</code>和<code class="fe lz ma mb mc b">launchpads</code>查询。让我们从为这些端点编写GraphQL查询开始。</p><p id="3192" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">首先，<code class="fe lz ma mb mc b">rocket</code>查询:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7d1c" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">如果你读过我的前一篇文章，这应该很熟悉，唯一的不同是我们添加的<code class="fe lz ma mb mc b">$id</code>参数。这用于指定我们想要获取哪个火箭，稍后我们将在Java代码中使用它。</p><p id="aecc" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">现在<code class="fe lz ma mb mc b">launchpads</code>查询:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4542" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">这里没什么特别的，只是一些好的图表。</p><p id="3469" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">随着我们的GraphQL查询的编写，剩下的就是在我们的服务器类中为它们创建方法。</p><p id="a7fb" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">第一，<code class="fe lz ma mb mc b">rocket</code>:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9710" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">同样，这与我们之前的设置非常相似。但是，请注意方法定义中的id参数。我们用它来设置前面在GraphQL查询文件中定义的<code class="fe lz ma mb mc b">$id</code>参数。</p><p id="5ce0" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">接下来，<code class="fe lz ma mb mc b">launchpads</code>:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e158" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">这个就像我们其他的服务器方法一样。我们创建一个<code class="fe lz ma mb mc b">ApolloQueryCall</code>，用它创建一个查询对象，然后将它转换成一个<code class="fe lz ma mb mc b">Observable</code>，这样我们就可以施展我们的Rx魔力了。</p><p id="fe44" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">这就是我们的服务器类。你可以参考<a class="ae kc" href="https://github.com/Ninjaman494/Android-GraphQL-Example/blob/main/app/src/main/java/com/n494/spacex/Server.java" rel="noopener ugc nofollow" target="_blank">回购版本</a>来确保你的设置正确。完成这些后，我们应该可以开始一些高级的请求场景了。</p><h1 id="6016" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">场景1:并行请求</h1><p id="cd66" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们的第一个场景非常常见，并行请求。很多时候，我们需要发出多个请求来获取我们需要的数据。在我们的例子中，我们将创建一个页面，列出关于火箭的信息以及它所使用的发射台的列表。因为这些请求是相互独立的，所以我们应该并行执行它们。处理这种情况的最好方法是在开始时执行两个请求，在等待响应时显示一个加载指示器，然后在两个请求完成后显示页面。使用GraphQL和RxJava的组合，在Android上做到这一点变得非常容易。</p><p id="3bd0" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">首先，让我们为我们的<code class="fe lz ma mb mc b">rocket</code>查询创建一个<code class="fe lz ma mb mc b">Observable</code>:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="65be" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">请注意，我们保存了这个可观察值，而不是立即对其进行操作。这是因为我们要将它与我们的第二个请求结合起来，这样我们就可以对结合的结果采取行动。不过不要担心，只要我们调用我们的<code class="fe lz ma mb mc b">fetchRocket</code>方法，请求就会被发出。</p><p id="4827" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">然后我们进行我们的<code class="fe lz ma mb mc b">launchpads</code>查询，并用<code class="fe lz ma mb mc b">zipWith</code>将两个请求组合起来:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="994e" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">在这里，我们执行我们的<code class="fe lz ma mb mc b">launchpads</code>查询，并用我们之前查询的<code class="fe lz ma mb mc b">observable</code>压缩它。第二个参数是描述如何组合两个请求响应的函数。在我们的例子中，我们将首先对发射台进行排序，只保存我们想要显示的火箭使用过的发射台。然后，我们将来自两个请求的数据组合成一个<code class="fe lz ma mb mc b">Pair</code>。</p><p id="2156" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">在管道的这一步中，我们已经将来自请求的响应合并到一个新对象中。我们的<code class="fe lz ma mb mc b">zipWith</code>函数直到两个响应都解析后才会被调用，所以我们现在所要担心的就是处理合并后的结果。此时，它就像处理一个常规请求一样。我们可以只使用<code class="fe lz ma mb mc b">subscribeWith</code>:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7385" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">请注意，类定义使用了<code class="fe lz ma mb mc b">Pair&lt;RocketQuery.Rocket,List&lt;String&gt;&gt;</code>，这是来自我们的<code class="fe lz ma mb mc b">zipWith</code>函数的返回类型，这些类型需要匹配才能使我们的管道工作。在<code class="fe lz ma mb mc b">onNext</code>中，我们使用在<code class="fe lz ma mb mc b">zipWith</code>中创建的<code class="fe lz ma mb mc b">Pair</code>来用响应数据填充我们的视图。然后，我们在<code class="fe lz ma mb mc b">onComplete</code>中关闭加载状态。为了简单起见，我没有处理错误状态，但这可以在<code class="fe lz ma mb mc b">onError</code>事件处理程序中轻松完成。这一步我们的管道应该完成了，你可以通过检查<a class="ae kc" href="https://github.com/Ninjaman494/Android-GraphQL-Example/blob/main/app/src/main/java/com/n494/spacex/RocketDetailsActivity.java" rel="noopener ugc nofollow" target="_blank">这个代码文件</a>来仔细检查你的管道。</p><p id="e956" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">使用Apollo Android和RxJava，我们能够轻松处理并行请求。这可以很容易地扩展到处理更多的并行请求，只需为每个新请求添加另一个<code class="fe lz ma mb mc b">zipWith</code>并相应地更新您的<code class="fe lz ma mb mc b">subscribeWith</code>。</p><h1 id="573e" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">场景2:从属请求</h1><p id="0d8a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在我们最后的场景中，两个请求是相互独立的，但是如果它们不是呢？有时我们需要发出多个请求，但是第二个请求需要来自第一个请求的数据。在这种情况下，我们不能并行运行请求，而是必须顺序运行它们。</p><p id="5559" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">这一次我们仍然要显示关于火箭的信息，但是我们只有火箭的名称，没有它的id。这意味着我们首先必须向<code class="fe lz ma mb mc b">rockets</code>端点发出请求(参见<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/apollo-rxjava-android-graphql-the-right-way-a1f2b10a9ac8">我的上一篇文章</a>),从响应中获取id，然后使用该id调用<code class="fe lz ma mb mc b">rocket</code>。使用GraphQL和RxJava在Android上处理这种情况轻而易举。</p><p id="9390" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">首先，我们将查询<code class="fe lz ma mb mc b">rockets</code>端点，然后使用<code class="fe lz ma mb mc b">concatMap</code>来处理结果:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4ec3" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">这里，我们使用我在上一篇文章中创建的<code class="fe lz ma mb mc b">fetchRockets</code>方法，但是用<code class="fe lz ma mb mc b">concatMap</code>来处理它。使用<code class="fe lz ma mb mc b">concatMap</code>，我们可以处理响应，然后将信息传递到RxJava管道的下一步。首先，我们对列表进行排序，找到我们要找的火箭。一旦我们找到正确的火箭，我们使用它的id向我们的<code class="fe lz ma mb mc b">rocket</code>端点发出请求。</p><p id="aaf2" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">注意，我们正在返回由<code class="fe lz ma mb mc b">fetchRocket</code>创建的<code class="fe lz ma mb mc b">Observable</code>，这是因为我们将在下一个管道步骤中使用它，如下所示:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e42c" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">这段代码现在应该再熟悉不过了。就像我们的其他例子一样，我们使用<code class="fe lz ma mb mc b">subscribeWith</code>来处理响应。你可以在这里查看已完成的<a class="ae kc" href="https://github.com/Ninjaman494/Android-GraphQL-Example/blob/main/app/src/main/java/com/n494/spacex/RocketDetailsByNameActivity.java" rel="noopener ugc nofollow" target="_blank">管道。有了RxJava，我们可以轻松处理Android上复杂的GraphQL请求。</a></p><h1 id="d550" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="8d1d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">通过利用Apollo Android和RxJava库，我们可以毫无困难地处理一些非常复杂的请求场景。请务必查看本文的<a class="ae kc" href="https://github.com/Ninjaman494/Android-GraphQL-Example" rel="noopener ugc nofollow" target="_blank">配套回购</a>以更深入地了解代码。在我的下一篇文章中，我将讨论如何为我们提出的GraphQL请求编写Android测试。一定要跟着我，这样才不会错过！</p><p id="2586" class="pw-post-body-paragraph lb lc iq ld b le md lg lh li me lk ll lm mf lo lp lq mg ls lt lu mh lw lx ly ij bi translated">一如既往，感谢阅读并给我一个👏如果你喜欢这篇文章！我喜欢看到我的读者如何使用他们所学的知识，所以请在下面的评论中分享你如何在你自己的Android应用程序中使用这些策略。</p></div></div>    
</body>
</html>