<html>
<head>
<title>Practical approach to Microservices Architecture — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务架构的实用方法—第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-approach-to-microservices-architecture-part-1-52488c32df58?source=collection_archive---------8-----------------------#2021-01-07">https://levelup.gitconnected.com/practical-approach-to-microservices-architecture-part-1-52488c32df58?source=collection_archive---------8-----------------------#2021-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="df2c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解基本微服务模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/87d03209e7d156c82e990b4195f818f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OjlroL17sCIjBsQQBQO5pw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由Unsplash上的Clay Banks拍摄</figcaption></figure><p id="ccf8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">考虑采用微服务架构的复杂大规模应用程序应该遵循一套模式来实现其全部优势。我将分享这些最佳实践，以及它们如何提高应用程序的效率，这是一个由两部分组成的系列。</p><p id="f113" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你的团队仍在决定微服务是否是你的应用的正确架构，我强烈推荐你阅读我之前的文章。</p><p id="ddfe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看每个采用微服务的团队都必须解决的一般问题列表:</p><ol class=""><li id="7327" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">客户端应用程序的开销增加，因为它们必须了解多个频繁更新的微服务。</li><li id="d9ac" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">对团队生产力的影响，因为他们必须解决交叉问题(如授权、缓存、日志记录等。)在每个微服务中保持一致。</li><li id="9345" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">对应用可靠性的影响，因为每个客户端请求都必须经过多个微服务才能得到处理。</li><li id="eb8d" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">由于无法跟踪和观察请求流，增加了调试和故障排除问题的复杂性。</li><li id="faea" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">对开发运维工作效率的影响，因为他们必须部署多个微服务，监控每个微服务的运行状况，并解决停机时间、流量突发和规模问题。</li><li id="53f3" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">随着配置更改和秘密轮换需要在每个微服务中一致处理，开发运维工作量增加。</li></ol><p id="21bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了保持这篇文章的简洁，我将在这里解决前3个问题，剩下的3个将在后续文章中解决。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/bf064405d8d28b000a42e9f364b91bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANGUhOLhFUcQTFsI9eM9AQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">微服务应用的高级架构</figcaption></figure><p id="0ad9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个高级应用程序架构，我看到大多数团队都采用它来解决这些问题，下面让我们深入了解每个关键领域</p><h2 id="7be1" class="mh mi iq bd mj mk ml dn mm mn mo dp mp le mq mr ms li mt mu mv lm mw mx my mz bi translated">抽象内部集群复杂性</h2><p id="2544" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">在大多数应用程序中，单个UX页面从多个微服务获取数据是非常常见的。为了建立与这些服务的通信，客户端需要了解所有细节，如端口、协议以及资源是如何划分的。除此之外，对这些服务的任何更新都可能需要更改客户端。此外，还需要支持给定API的多个版本。例如，一个用于web \桌面版本的API和一个用于移动版本的轻量级API。所有这些变动的结果是，应用程序最终形成了类似这样的架构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/9343064a2377bbd0cd89c2d2d5183330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*tpJ8VtolRjLrFLS7enT2lA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">没有API网关的微服务应用</figcaption></figure><p id="3f1b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这给我们带来了一个问题，基于微服务的客户端如何在满足所有这些需求的同时访问单独的服务(API)。</p><p id="8e70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">客户端应该从这些内部复杂性中抽象出来，这就是API网关发挥重要作用的地方。API网关是所有客户端请求的单一入口点。它就像一个反向代理，为集群中的微服务提供所有客户端流量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/f04fcf924c3bf518dc65027ea4cacf3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bkH0C_mpReqbyf7HDRLCEA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">具有API网关的微服务应用</figcaption></figure><p id="7a0e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是使用API Gateway修改架构的优势</p><ol class=""><li id="20ed" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">每个客户端不需要知道所有的微服务和它需要与之对话的端点。这使得应用团队能够灵活地最终迁移出微服务、修改现有服务或创建新的微服务。</li><li id="de71" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">我们可以将认证、日志记录和缓存等任何交叉问题卸载到该网关层。例如，只允许经过认证和信任的客户端流量通过网关流向微服务。此外，服务之间的内部通信可以在可信的专用网络上进行，而不必担心处理额外的开销，如验证请求和保护SSL上的通信。</li><li id="1714" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">它还可以通过查询多个微服务并结合结果来生成最终的聚合响应，从而有助于API合成。</li><li id="afa0" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">它还可以充当速率限制器，对来自进入不良状态的客户端的请求进行节流，这有助于提高集群的容错能力。</li></ol><h2 id="b06b" class="mh mi iq bd mj mk ml dn mm mn mo dp mp le mq mr ms li mt mu mv lm mw mx my mz bi translated">处理微服务之间的内部通信</h2><p id="3a03" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">微服务必须处理来自应用程序客户端的请求，同时相互协作来处理它们。同步通信期望客户端和相关服务在整个请求期间都是可用的。如果可能的话，通常最好避免服务之间的同步通信，因为这样可以减少请求发送者和请求消费者同时进行处理的依赖性。它还避免了一些常见的陷阱，如您在下面的场景中看到的级联故障。</p><p id="a0e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个场景中，微服务1依赖于微服务2、微服务3和微服务4(通过微服务2和微服务3)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/4586d67fef872c88123bda1bee800c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*Ixfgq2eHYSgUrXxljmDxkA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">具有同步通信的级联故障</figcaption></figure><p id="2c58" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果微服务4在客户端请求时关闭，将导致整个请求失败。如果处理不当，微服务4的这些通信故障将逐渐使微服务2和微服务3过载，使它们停机，进而使微服务1停机，从而使整个系统停机。</p><p id="7652" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">消息总线</strong></p><p id="7992" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只要有可能，我们应该确保微服务之间的通信使用消息服务(在架构中我称之为消息总线)以异步方式进行。市场上有许多异步消息传递技术，如Azure service bus、Apache Kafka、RabbitMQ。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/177fce70526ec9c295830cc130b6125d.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*tE5ew5534NK8rXGVZl3jog.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用消息总线的异步通信</figcaption></figure><p id="4f0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这比直接的服务对服务通信更复杂，但是使用消息总线进行微服务之间的通信具有以下优点:</p><ol class=""><li id="541d" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">实现请求生产者与请求消费者的分离，使他们能够灵活地按照自己的规模处理请求。</li><li id="9b57" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">为每个微服务提供了灵活性，可根据流量突发情况进行扩展和缩减。生产者和消费者都不需要担心请求节流。</li><li id="b944" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">提高系统的整体可用性和容错能力，因为生产者不太关心如何处理消费者的故障。消费者可以放心，只要适当的消息有效负载被发布到消息总线，它最终会被处理。</li></ol><p id="2dc9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在异步通信不可能且服务必须依赖直接通信的情况下，通常最佳做法是结合使用断路器模式和指数回退重试来应对级联故障。</p><p id="024e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">断路器</strong></p><p id="195f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这类似于电路断路器。按照这种模式，当服务4的故障率在给定的时间窗口内超过阈值时，服务2和3将断开电路(连接)并返回默认的预定义响应，而不是调用服务4。在此期间，除了一小部分请求之外，不调用有故障的服务。如果这些呼叫成功，则连接将为其余流量恢复，从而为服务4提供充足的恢复时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/c49cf88c4ee1af7b09e55a524ef4df5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*41Zjph2jO4tr_SwGipJwKw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">用于弹性通信的断路器</figcaption></figure><p id="c988" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> CQRS(命令查询响应分离)</strong></p><p id="77fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大多数致力于最终一致的系统的团队，用一种叫做CQRS的模式来分离读和写。在这种模式中，读取(或获取)请求通过直接的服务到服务通信来实现，而写入(POST、PUT、PATCH或DELETE)请求通过异步通信来实现。在响应读取请求时，服务主要从数据源的缓存或只读副本中读取。这有助于将查询从命令中分离出来，并提供独立扩展、缓存和发展的灵活性。</p><p id="22ce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我的下一篇<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/practical-approach-to-microservices-architecture-part-2-7337c0444086">文章</a>中，我将介绍集群编排、集中式遥测和配置管理等模式，这些模式将有助于解决开头讨论的其他问题</p></div></div>    
</body>
</html>