<html>
<head>
<title>Animating Brightness Adjustment in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中的亮度调整动画</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/animating-brightness-adjustment-in-ios-e56d1bff5a9f?source=collection_archive---------20-----------------------#2022-11-28">https://levelup.gitconnected.com/animating-brightness-adjustment-in-ios-e56d1bff5a9f?source=collection_archive---------20-----------------------#2022-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9b14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在iOS应用程序开发中，通过过渡动画以编程方式将屏幕亮度调整到特定值从来都不容易实现，因为苹果没有提供直观的API。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><blockquote class="ks kt ku"><p id="f9c2" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">开发者</em> </strong> <em class="iq">:我想用过渡效果调整屏幕亮度。你能告诉我怎么做吗？🧐 </em></p><p id="c9fb" class="jn jo kv jp b jq jr js jt ju jv jw jx kw jz ka kb kx kd ke kf ky kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">苹果</em> </strong> <em class="iq">:好吧，好吧！代码已经在那里了。给你。我相信这就是你想要的。😀</em></p></blockquote><pre class="kz la lb lc gt ld le lf bn lg lh bi"><span id="56dd" class="li lj iq le b be lk ll l lm ln">// From 10% <br/>UIScreen.main.brightness = 0.1<br/><br/>// To 100% <br/>UIScreen.main.brightness = 1</span></pre><figure class="kz la lb lc gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lo"><img src="../Images/22eba2be32dcd6b21af16bf7fd933c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*e8sA_ILtyCz0oIQCbHuPCA.gif"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">无过渡效果的亮度调节</figcaption></figure></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="714a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将向您展示如何实现带有过渡效果的亮度调整，以及<strong class="jp ir"> <em class="kv">代码片段、解释和结果</em> </strong>。</p><h1 id="361d" class="ma lj iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">🧑‍💻代码片段:</h1><pre class="kz la lb lc gt ld le lf bn lg lh bi"><span id="4dcf" class="li lj iq le b be lk ll l lm ln">func adjustScreenBrightness(to value: CGFloat, animationDuration: CGFloat = 1) {<br/>    var currentBrightness: CGFloat = UIScreen.main.brightness<br/>        <br/>    // MARK: 1) Determine the direction of the adjustment; Increase / Decrease<br/>    let isIncreasing: Bool = currentBrightness &lt; value<br/>        <br/>    // MARK: 2) Determine the animation speed<br/>    let incrementalStep: CGFloat = 1 / (animationDuration * 1000)<br/>        <br/>    // MARK: 3) Execute the iteration operation in a separate thread<br/>    DispatchQueue.global(qos: .userInteractive).async {<br/>        while (isIncreasing &amp;&amp; currentBrightness &lt;= value) || (!isIncreasing &amp;&amp; currentBrightness &gt;= value) {<br/>            DispatchQueue.main.async {<br/>                currentBrightness += isIncreasing ? incrementalStep : -incrementalStep<br/>                UIScreen.main.brightness = currentBrightness<br/>            }<br/>                <br/>            // MARK: 4) Set 1 milisecond interval to the while-loop<br/>            Thread.sleep(forTimeInterval: 1 / 1000)<br/>        }<br/>    }<br/>}</span></pre><h1 id="507f" class="ma lj iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated"><strong class="ak">📝解释:</strong></h1><h2 id="38b5" class="mx lj iq bd mb my mz dn mf na nb dp mj jy nc nd mn kc ne nf mr kg ng nh mv ni bi translated">1.确定调整的方向；增加/减少</h2><p id="e8b5" class="pw-post-body-paragraph jn jo iq jp b jq nj js jt ju nk jw jx jy nl ka kb kc nm ke kf kg nn ki kj kk ij bi translated">这非常简单。通过比较屏幕亮度的当前值和我们想要将亮度调到的值，我们可以考虑动画操作是应该<strong class="jp ir"> <em class="kv">增加</em> </strong>还是<strong class="jp ir"> <em class="kv">降低</em> </strong>屏幕的亮度。</p><h2 id="93db" class="mx lj iq bd mb my mz dn mf na nb dp mj jy nc nd mn kc ne nf mr kg ng nh mv ni bi translated">2.确定动画速度</h2><p id="34cf" class="pw-post-body-paragraph jn jo iq jp b jq nj js jt ju nk jw jx jy nl ka kb kc nm ke kf kg nn ki kj kk ij bi translated">该函数期望<strong class="jp ir"> <em class="kv">持续时间</em> </strong>参数确定增量值，以增加或减少屏幕亮度。</p><h2 id="abb2" class="mx lj iq bd mb my mz dn mf na nb dp mj jy nc nd mn kc ne nf mr kg ng nh mv ni bi translated">3.在单独的线程中执行迭代操作</h2><p id="36cc" class="pw-post-body-paragraph jn jo iq jp b jq nj js jt ju nk jw jx jy nl ka kb kc nm ke kf kg nn ki kj kk ij bi translated">为了使亮度调整看起来具有稳定和舒缓的过渡动画，我们可以利用一个名为<strong class="jp ir"> <em class="kv">的迭代操作，同时循环</em> </strong>来执行屏幕亮度值的连续增加或减少。</p><p id="6b66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还要强调使用<a class="ae no" href="http://shorturl.at/HIJXZ" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="kv"/></strong></a><strong class="jp ir"><em class="kv"/></strong>来执行循环。</p><blockquote class="np"><p id="32b0" class="nq nr iq bd ns nt nu nv nw nx ny kk dk translated"><strong class="ak"> <em class="nz">用户交互</em> </strong> <em class="nz">服务质量:</em></p><p id="ac9d" class="nq nr iq bd ns nt nu nv nw nx ny kk dk translated">用户交互任务的服务质量类别，如动画、事件处理或应用程序用户界面的更新—苹果开发者文档</p></blockquote></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="4786" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据定义，用户交互QoS是用于对界面或动画执行交互更新的最合适的队列。更重要的是，将执行设置到单独的操作队列，而不是<strong class="jp ir">主</strong>队列，可以防止与应用程序滞后或冻结相关的常见用户界面问题，因为如果动画速度较慢或者<strong class="jp ir"><em class="kv">animation duration</em></strong>参数(在我们的例子中)设置为较高的值，循环操作的执行时间将需要较长的时间才能完成。</p><h2 id="fcd3" class="mx lj iq bd mb my mz dn mf na nb dp mj jy nc nd mn kc ne nf mr kg ng nh mv ni bi translated">4.为执行创建一个动画效果</h2><p id="94f1" class="pw-post-body-paragraph jn jo iq jp b jq nj js jt ju nk jw jx jy nl ka kb kc nm ke kf kg nn ki kj kk ij bi translated">迭代操作<strong class="jp ir"> <em class="kv"> while-loop </em> </strong>，从其鲜明的性质来看，根本没有耐心。我们无法控制它的速度。CPU性能越高，执行速度越快。因此，我们需要在每次增量迭代中引入一毫秒(1ms)的时间间隔，以产生动画效果。</p><h1 id="ca98" class="ma lj iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">🏆结果:</h1><figure class="kz la lb lc gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lo"><img src="../Images/9fa73d2e6da85b4127205d5e2dc4e33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6R3hF_vOWnKHb5vXmpLFwQ.gif"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">具有过渡效果的亮度调节</figcaption></figure><h1 id="28a6" class="ma lj iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">🎁奖金:</h1><p id="ca1c" class="pw-post-body-paragraph jn jo iq jp b jq nj js jt ju nk jw jx jy nl ka kb kc nm ke kf kg nn ki kj kk ij bi translated">为了使上面代码片段中的函数可以从任何地方访问，我们可以在UIScreen类上创建一个扩展，并将该函数放在那里。</p><pre class="kz la lb lc gt ld le lf bn lg lh bi"><span id="05e6" class="li lj iq le b be lk ll l lm ln">extension UIScreen {<br/><br/>  func adjustScreenBrightness(to value: CGFloat, animationDuration: CGFloat = 1) {<br/>      var currentBrightness: CGFloat = UIScreen.main.brightness<br/>        <br/>      // MARK: 1) Determine the direction of the adjustment; Increase / Decrease<br/>      let isIncreasing: Bool = currentBrightness &lt; value<br/>        <br/>      // MARK: 2) Determine the animation speed<br/>      let incrementalStep: CGFloat = 1 / (animationDuration * 1000)<br/>        <br/>      // MARK: 3) Execute the iteration operation in a separate thread<br/>      DispatchQueue.global(qos: .userInteractive).async {<br/>          while (isIncreasing &amp;&amp; currentBrightness &lt;= value) || (!isIncreasing &amp;&amp; currentBrightness &gt;= value) {<br/>              DispatchQueue.main.async {<br/>                  currentBrightness += isIncreasing ? incrementalStep : -incrementalStep<br/>                  UIScreen.main.brightness = currentBrightness<br/>              }<br/>                <br/>              // MARK: 4) Set 1 milisecond interval to the while-loop<br/>              Thread.sleep(forTimeInterval: 1 / 1000)<br/>          }<br/>      }<br/>  }<br/><br/>}</span></pre><p id="a87d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🇰🇭就是这样。如果你有更好的解决方案、编码风格甚至建议，请随意发表你的想法。</p></div></div>    
</body>
</html>