<html>
<head>
<title>StateFlow, SharedFlow, and the secret bus 🚌</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">状态流、共享流和秘密总线🚌</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/stateflow-sharedflow-and-the-secret-bus-ba9978ad8453?source=collection_archive---------3-----------------------#2020-11-08">https://levelup.gitconnected.com/stateflow-sharedflow-and-the-secret-bus-ba9978ad8453?source=collection_archive---------3-----------------------#2020-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4816" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kotlin Coroutines 1.4 来了，这是另一个打发无聊的机会。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/8214e91cde20341f1574a8a154d848c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*UBDJjg6BJBrK6g0ytOwzgg.jpeg"/></div></figure><h2 id="1573" class="kx ky it bd kz la lb dn lc ld le dp lf kb lg lh li kf lj lk ll kj lm ln lo lp bi translated">状态流</h2><p id="c8d2" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">假设我们有一个片段对经典的<a class="ae ko" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JsonPlaceHolder </a> API中的<em class="lv"> todo </em>任务感兴趣。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="b353" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于我们正在使用<a class="ae ko" href="https://kotlinlang.org/docs/reference/coroutines/flow.html" rel="noopener ugc nofollow" target="_blank">流</a>，我们需要启动一个协程来收集它。</p><p id="404e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个小按钮将告诉<em class="lv"> viewmodel </em>获取一个<em class="lv"> todo，</em>更新流并让我们收集更新，以便它可以显示在屏幕上。</p><p id="878c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">viewmodel本身将归活动所有，而不是片段，以便稍后运行实验。</p><p id="bfb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">视图模型:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lw lx l"/></div></figure><ul class=""><li id="0372" class="ly lz it js b jt ju jx jy kb ma kf mb kj mc kn md me mf mg bi translated">通知<code class="fe mh mi mj mk b">value = null</code>。这是最初的更新，将给予第一次收集这个流量的人。</li><li id="1dd3" class="ly lz it js b jt ml jx mm kb mn kf mo kj mp kn md me mf mg bi translated">其余的都是相当标准的东西。去存储库请求一个<em class="lv"> todo </em>，然后用最新的值更新<em class="lv"> </em> <code class="fe mh mi mj mk b"><em class="lv">todoStateFlow</em></code> <em class="lv"> </em>。</li><li id="1aff" class="ly lz it js b jt ml jx mm kb mn kf mo kj mp kn md me mf mg bi translated">收集流的片段将获得更新并显示在屏幕上。</li><li id="37ca" class="ly lz it js b jt ml jx mm kb mn kf mo kj mp kn md me mf mg bi translated">旋转将再次运行<code class="fe mh mi mj mk b">collect</code>方法，并接收最后一个已知值。(或者你可以说，最后一个已知的状态😅)</li></ul><p id="9455" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有人可能会说，有了StateFlow，LiveData就没什么用了。但话说回来，这种类型的短语每隔一个周末就能听到，所以谁知道呢。</p><p id="b3ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到手头的任务:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/189a2472a5b958367ee78243ba5b1be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/1*N2QR6kKPJ4wVNymZiIQQ8w.gif"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">delectus aut em？💭</figcaption></figure><h2 id="7936" class="kx ky it bd kz la lb dn lc ld le dp lf kb lg lh li kf lj lk ll kj lm ln lo lp bi translated">共享流</h2><p id="affd" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">片段(几乎)保持不变，但是视图模型现在已经改变:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lw lx l"/></div></figure><ul class=""><li id="8a92" class="ly lz it js b jt ju jx jy kb ma kf mb kj mc kn md me mf mg bi translated"><code class="fe mh mi mj mk b">replay = 0</code>表示一旦从流中收集到更新，就再也看不到了(例如旋转设备时)。</li><li id="5bba" class="ly lz it js b jt ml jx mm kb mn kf mo kj mp kn md me mf mg bi translated">将<code class="fe mh mi mj mk b">replay</code>更改为1会将它转换为StateFlow，因为最后一个已知的值将被发送给任何开始收集的人。进一步增加这个数字也将增加任何“新”集合分别获得的更新的数量。</li></ul><p id="e62c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">任何使用MVVM超过5分钟的人都需要发出一个动作，这个动作不会在旋转中重复。于是<a class="ae ko" href="https://github.com/android/architecture-samples/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java" rel="noopener ugc nofollow" target="_blank">single live data</a>/<a class="ae ko" href="https://proandroiddev.com/singleliveevent-to-help-you-work-with-livedata-and-events-5ac519989c70" rel="noopener ugc nofollow" target="_blank">single live event</a>的“黑客”就诞生了。</p><p id="eaa6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">带有0 replay的shared flow似乎可以解决这个问题，但也带来了一个问题:</p><p id="38e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果集合在将值发布到共享流时不是活动的，该值将永远不会被片段收集。看来我们将不得不满足于再等一会儿。</p><h2 id="05d4" class="kx ky it bd kz la lb dn lc ld le dp lf kb lg lh li kf lj lk ll kj lm ln lo lp bi translated">同一共享流上的多个集合</h2><p id="3c6e" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">当两个独立的片段在同一个SharedFlow变量上运行一个集合时会发生什么？</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/b90e40350815d75aaaf9cf03404d4bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/1*X6FNqY6RnYQ0ACexcWfTcQ.gif"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated"><code class="fe mh mi mj mk b">replay = 0</code></figcaption></figure><p id="de3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我从来没有在尝试之前阅读过文档(就像任何专业键盘用户一样)，所以我不知道会发生什么，但这是一个很好的惊喜！两个片段都获得更新，如果它们旋转，将永远不会再次获得更新。</p><p id="7172" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">老校车鉴赏家会注意到这看起来像是经典<a class="ae ko" href="https://github.com/greenrobot/EventBus" rel="noopener ugc nofollow" target="_blank"> EventBus </a> / <a class="ae ko" href="https://square.github.io/otto/" rel="noopener ugc nofollow" target="_blank"> Otto </a>的Kotlin-y替代品，如果你觉得你已经受够了它们的话。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/841bcb67d3d961154c07505d237d11cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*ALW9naAEIjOhPyHh7_tTrw.jpeg"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">在r/mAndroidDev上花太多时间会对人产生奇怪的影响</figcaption></figure><h2 id="590f" class="kx ky it bd kz la lb dn lc ld le dp lf kb lg lh li kf lj lk ll kj lm ln lo lp bi translated">好了</h2><p id="ca61" class="pw-post-body-paragraph jq jr it js b jt lq jv jw jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn im bi translated">虽然这个简单的测试很有趣，但我还没有在同一时间用更多的收集器测试过。</p><p id="d158" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你<strong class="js iu">做了</strong>尝试，然后给我发消息/发表评论，告诉我你的发现。另外，如果你喜欢这些迷因，为什么不用这个小按钮呢？</p><p id="e183" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该项目的完整源代码可以在<a class="ae ko" href="https://github.com/CostaFot/flow" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="e4ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以后再说。</p></div></div>    
</body>
</html>