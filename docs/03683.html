<html>
<head>
<title>Make Loading Placeholder Work with Content Pre-Fetching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使加载占位符与内容预取一起工作</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/make-loading-placeholder-work-with-content-pre-fetching-d70385f4aaeb?source=collection_archive---------11-----------------------#2020-05-22">https://levelup.gitconnected.com/make-loading-placeholder-work-with-content-pre-fetching-d70385f4aaeb?source=collection_archive---------11-----------------------#2020-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a74e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">TL；【T2博士】在一个单页面的web应用程序中，我们使用以下技术来使布局稳定:</strong></p><ol class=""><li id="b4e4" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">如果有上一页，在重定向之前使用“预取”技术加载数据。加载数据后，重定向到下一个完全呈现内容的页面。</li><li id="e5a7" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">如果页面是第一个登录页面，不要预取数据。请改为显示加载占位符。</li></ol><p id="0bf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我的工作实例:<a class="ae kz" href="https://8maple.us/category/movies" rel="noopener ugc nofollow" target="_blank">https://8maple.us/category/movies</a></p><p id="84b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文将向您展示如何在Angular中做到这一点。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="c2bb" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">加载占位符</h1><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/5f6c9cef98caceb993bfd736e5b8faa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AQNAGRIwEIYD1UGp.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">典型的装载占位符</figcaption></figure><p id="ad05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“加载占位符”是许多SPA网站使用的一种常用技术，通过在将要显示内容的地方显示占位符，使页面加载看起来一致且更快。它减少了使用户不舒服的布局不稳定性。</p><blockquote class="mv mw mx"><p id="32e6" class="jn jo my jp b jq jr js jt ju jv jw jx mz jz ka kb na kd ke kf nb kh ki kj kk ij bi translated">谷歌最近提供了一个名为CLS ( <a class="ae kz" href="https://web.dev/cls/" rel="noopener ugc nofollow" target="_blank">累积布局移动</a>)分数的指标，这使得这个想法量化了。</p></blockquote></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="ba1f" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">内容预取</h1><p id="80eb" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">许多其他SPA网站(例如<a class="ae kz" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> angular.io </a>)使用内容预取技术来制作好的UX。当用户点击一个链接时，它会在页面上显示加载进度条，并在后台加载数据。加载数据后，它将显示下一个页面，其中包含完整的呈现内容。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nh"><img src="../Images/64661bd27ac3b68b03c74d4090f72d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3he5rhW9NWy3Jacu.jpg"/></div></div></figure><p id="9704" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以用<a class="ae kz" href="https://angular.io/api/router/Resolve" rel="noopener ugc nofollow" target="_blank">路线解析器</a>在角度上完成。在路由器设置中:</p><pre class="mg mh mi mj gt ni nj nk nl aw nm bi"><span id="fe1c" class="nn li iq nj b gy no np l nq nr">[<br/>  { path: 'mypath', component: MyPageComponent, resolve: { <strong class="nj ir">myData</strong>: MyResolverService}},<br/>...<br/>]</span></pre><p id="8d52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在解析器中:</p><pre class="mg mh mi mj gt ni nj nk nl aw nm bi"><span id="7286" class="nn li iq nj b gy no np l nq nr">export class MyResolverService implements Resolve&lt;any&gt; {</span><span id="d0ba" class="nn li iq nj b gy ns np l nq nr"><strong class="nj ir">  resolve(route: ActivatedRouteSnapshot): Observable&lt;any&gt; {<br/>    return this.myService.getData();<br/>  }</strong></span><span id="5573" class="nn li iq nj b gy ns np l nq nr">  constructor(private myService: MyService) { }</span><span id="ef8d" class="nn li iq nj b gy ns np l nq nr">}</span></pre><p id="9a0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在页面组件中，我们可以获取数据并直接写入<code class="fe nt nu nv nj b">this.items$</code>:</p><pre class="mg mh mi mj gt ni nj nk nl aw nm bi"><span id="8cf4" class="nn li iq nj b gy no np l nq nr">ngOnInit(): void {</span><span id="9dd7" class="nn li iq nj b gy ns np l nq nr">  this.items$ = this.route.data.pipe(map( data =&gt; data.<strong class="nj ir">myData </strong>);</span><span id="b44a" class="nn li iq nj b gy ns np l nq nr">}</span></pre></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="a87a" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">让他们一起工作</h1><p id="9e0a" class="pw-post-body-paragraph jn jo iq jp b jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">您可能认为内容预取已经消除了对加载占位符的需要，因为数据在出现的那一刻就被完全呈现了。</p><p id="7774" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果用户直接登陆页面，除了进度条什么也不显示。我们仍然需要显示一个占位符来减少CLS。我们要做的是:</p><ol class=""><li id="15ba" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">如果有上一页，请在传送前加载数据。</li><li id="58c7" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">如果页面是第一个登陆的，就不要取数据。请改为显示加载占位符。</li></ol><p id="184d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我的工作实例:<a class="ae kz" href="https://8maple.us/category/movies" rel="noopener ugc nofollow" target="_blank">https://8maple.us/category/movies</a><br/>点击顶部菜单中的左右，你会看到预取技术；刷新页面，您将看到第一个平台的装载占位符。</p><p id="4230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，让我们在路由解析器中做一些修改。</p><pre class="mg mh mi mj gt ni nj nk nl aw nm bi"><span id="43d9" class="nn li iq nj b gy no np l nq nr">export class MyResolverService implements Resolve&lt;any&gt; {</span><span id="508a" class="nn li iq nj b gy ns np l nq nr">resolve(route: ActivatedRouteSnapshot): Observable&lt;any&gt; {<br/>  if(<strong class="nj ir">this.router.getCurrentNavigation().previousNavigation</strong>) {<br/>    // there was a previous route, load data before routing<br/>    <strong class="nj ir">return this.myService.getData();<br/>  </strong>} else {<br/>    // the page is the first landing one, resolve directly <br/>    <strong class="nj ir">return of({isNeedLoad: true});</strong><br/>  }<br/>}</span><span id="ecc8" class="nn li iq nj b gy ns np l nq nr">constructor(<br/>  private router: Router,<br/>  private myService: MyService,<br/>) { }</span><span id="e2e6" class="nn li iq nj b gy ns np l nq nr">}</span></pre><p id="e9a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过获取<code class="fe nt nu nv nj b">router.getCurrentNavigation().previousNavigation</code>来判断它是否是登录页面，如果是，我们只返回一个带有<code class="fe nt nu nv nj b">{isNeedLoad: true}</code>的解析后的可观察值。它使路由解析并重定向到下一页。</p><p id="1a4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以在下一页，我们改变<code class="fe nt nu nv nj b">this.items$</code>是如何衍生的。</p><pre class="mg mh mi mj gt ni nj nk nl aw nm bi"><span id="71e8" class="nn li iq nj b gy no np l nq nr">this.items$ = this.route.data.pipe(switchMap( data =&gt;<br/>  iif( () =&gt; data.myData.isNeedLoad === true,<br/>    this.route.paramMap.pipe(switchMap(params =&gt;<br/>      <strong class="nj ir">this.myService.getData()</strong>)),<br/>    of(data.myData)<br/>)), startWith([{isLoading: true}]));</span></pre><p id="5964" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用条件操作符<code class="fe nt nu nv nj b">iff</code>来检查<code class="fe nt nu nv nj b">isNeedLoad</code>。如果是真的，我们调用服务来加载数据。否则，我们就使用路由器解析器中预取的<code class="fe nt nu nv nj b">myData</code>。</p></div></div>    
</body>
</html>