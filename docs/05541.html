<html>
<head>
<title>Scala Journals — The mystery of Implicits debunked</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala Journals——揭开隐含的神秘面纱</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-journals-the-mystery-of-implicits-debunked-a38def8959b?source=collection_archive---------18-----------------------#2020-09-07">https://levelup.gitconnected.com/scala-journals-the-mystery-of-implicits-debunked-a38def8959b?source=collection_archive---------18-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e3045f92504687ae36957d8b66bd57af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*egVbEZgxTDM9xbFp"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="https://unsplash.com/photos/EUqatWCcX-s" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="783c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天我将讲述一个非常有趣的话题——隐含。它们几乎和它们因增加代码库复杂性和调试地狱故事而臭名昭著一样有趣(剧透:你很快就会发现——除非它们被错误地使用)。</p><p id="6a53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以让我们试着找出<strong class="ki iu">它们是什么</strong><strong class="ki iu">，为什么需要它们</strong>，最重要的是——我们应该在现实生活中什么时候使用它们？事实再次证明，一旦你掌握了基本知识，它们就不像想象中那么可怕了。</p><h1 id="28d2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是隐含</h1><p id="7c2d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">随着时间的推移，当您习惯使用Scala时，您最终会遇到类似的编译器错误消息:</p><blockquote class="mh mi mj"><p id="2668" class="kg kh mk ki b kj kk kl km kn ko kp kq ml ks kt ku mm kw kx ky mn la lb lc ld im bi translated"><strong class="ki iu">错误</strong>:找不到参数reads的隐式值:JsonReads[Order]</p></blockquote><p id="831d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我喜欢在英语词典中检查编程术语的意思，以真正尝试并理解为什么某样东西被称为它的样子。所以让我们仔细检查一下<strong class="ki iu">隐含的</strong>在人类语言中是什么意思。<a class="ae kf" href="https://www.collinsdictionary.com/dictionary/english/implicit" rel="noopener ugc nofollow" target="_blank"> <em class="mk">柯林斯字典</em> </a>说:</p><blockquote class="mo"><p id="7ded" class="mp mq it bd mr ms mt mu mv mw mx ld dk translated">"含蓄的东西用间接的方式表达出来."</p></blockquote><p id="090d" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">因此，我们可以对其进行调整，以匹配Scala领域:</p><blockquote class="mo"><p id="b5de" class="mp mq it bd mr ms mt mu mv mw mx ld dk translated">隐含的东西意味着它以间接的方式“在幕后”被传递和使用。</p></blockquote><p id="8620" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">下面是一个隐式值用法的例子。(免责声明:这是一种可怕的做法，但它仅用几行代码就阐明了隐含背后的思想。请不要对这样的事情使用暗示)。密切关注<strong class="ki iu">包</strong>中<strong class="ki iu">位置</strong>的代码片段:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="da77" class="nm lf it ni b gy nn no l np nq">// inside com.taxwebsite.StaticValues<strong class="ni iu"><br/></strong>...<br/>implicit val vat: Double = 0.19<br/>...</span><span id="ae4b" class="nm lf it ni b gy nr no l np nq">// inside com.taxwebsite.TaxCalulator<br/>...<br/>def getPriceWithTax(amount: Int)(implicit vat: Double) = amount + amount * vat<br/>...</span><span id="98b6" class="nm lf it ni b gy nr no l np nq">// inside com.taxwebsite.PriceService<br/><strong class="ni iu">import com.taxwebsite.StaticValues.vat &lt;- important chunk here!</strong><br/>...<br/>def getFinalPrice(amount: Int) = getPriceWithTax(amount)<br/>...</span></pre><p id="c18f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码示例中，我们有一个隐式值<code class="fe ns nt nu ni b">vat</code>，它被导入到<code class="fe ns nt nu ni b">PriceService</code>的范围内。因为<code class="fe ns nt nu ni b">vat</code>值被标记为<strong class="ki iu">隐式</strong>，那么就不需要<strong class="ki iu">显式</strong>说<code class="fe ns nt nu ni b">getPriceWithTax(amount)<strong class="ki iu">(vat)</strong></code>来满足<code class="fe ns nt nu ni b">getPriceWithTax</code>签名——<code class="fe ns nt nu ni b">vat</code>是在幕后通过<strong class="ki iu"><em class="mk"/></strong>。</p><p id="4c61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有几种方法可以重现我在开头提到的错误:</p><ul class=""><li id="5f89" class="nv nw it ki b kj kk kn ko kr nx kv ny kz nz ld oa ob oc od bi translated">如果我们从<code class="fe ns nt nu ni b">PriceService</code>移除导入</li><li id="ca08" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld oa ob oc od bi translated">…或者如果我们没有将<code class="fe ns nt nu ni b">val vat</code>标记为隐式</li><li id="7f9e" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld oa ob oc od bi translated">…或者如果<code class="fe ns nt nu ni b">val vat</code>不是一个<code class="fe ns nt nu ni b">Double</code></li><li id="4f55" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld oa ob oc od bi translated">…或者如果<code class="fe ns nt nu ni b">getPriceWithTax</code>不是一个<code class="fe ns nt nu ni b">Double</code></li></ul><p id="a529" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">重要提示！希望以上分解这种琐碎代码的方法说明了移动部件的数量，以及如果你追求简单的东西的类似实现而不必要地添加了隐含，你会给你未来的同事带来什么样的麻烦。</strong></p><h2 id="e1c0" class="nm lf it bd lg oj ok dn lk ol om dp lo kr on oo ls kv op oq lw kz or os ma ot bi translated">编译器如何知道将哪个隐式“注入”到哪里？</h2><p id="454e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">没有“艺术”你无法拼出“地球”，但是没有“<strong class="ki iu">魔法</strong>”你绝对可以拼出“<strong class="ki iu">编译器</strong>”。</p><p id="c79e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">隐式解析</strong></p><p id="310c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们讨论一下编译器在哪里寻找隐含，以及它在看什么。让我们以上面的例子为基础，像编译器一样思考。(*)</p><ol class=""><li id="c805" class="nv nw it ki b kj kk kn ko kr nx kv ny kz nz ld ou ob oc od bi translated">我打电话给<code class="fe ns nt nu ni b">getFinalPrice</code></li><li id="1952" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld ou ob oc od bi translated">我看到<code class="fe ns nt nu ni b">getFinalPrice</code>调用了<code class="fe ns nt nu ni b">getPriceWithTax</code>，它需要一个类型为Double 的<strong class="ki iu">隐式值(注意编译器并不关心值的名称。只是它的<strong class="ki iu">型</strong></strong></li><li id="4241" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld ou ob oc od bi translated"><code class="fe ns nt nu ni b">getFinalPrice</code>内部有没有<strong class="ki iu">隐式双精度</strong>值？号码</li><li id="e150" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld ou ob oc od bi translated"><code class="fe ns nt nu ni b">PriceService</code>中有没有<strong class="ki iu">隐式双</strong>值？号码</li><li id="f544" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld ou ob oc od bi translated"><code class="fe ns nt nu ni b">PriceService</code>有伴对象吗？号码</li><li id="0350" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld ou ob oc od bi translated">在<code class="fe ns nt nu ni b">PriceService</code>中有包含一个<strong class="ki iu">隐式Double </strong>值的导入吗？是的。</li><li id="390e" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld ou ob oc od bi translated">好的，那么我假设这个值是<code class="fe ns nt nu ni b">getPriceWithTax</code>需要的<strong class="ki iu">隐式Double </strong>值。我会在“幕后”隐晦地传递。</li></ol><h2 id="7405" class="nm lf it bd lg oj ok dn lk ol om dp lo kr on oo ls kv op oq lw kz or os ma ot bi translated">有什么可以含蓄的？</h2><p id="8d4b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">不仅仅是<code class="fe ns nt nu ni b">val</code>或者<code class="fe ns nt nu ni b">var</code>。也可以是<code class="fe ns nt nu ni b">implicit def</code>、<code class="fe ns nt nu ni b">implicit class</code>、<code class="fe ns nt nu ni b">implicit object</code>。</p><h1 id="be3e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么要使用暗示</h1><p id="d06a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我故意在<strong class="ki iu">结尾跳过所有细节，可以隐含什么？</strong>一节。我觉得在网上的大部分资料中，例子太多了，但是有两个<strong class="ki iu"/><strong class="ki iu">最重要的要点</strong>总是被遗漏，这是高级初学者经常遇到的问题。他们在这里:</p><ol class=""><li id="d716" class="nv nw it ki b kj kk kn ko kr nx kv ny kz nz ld ou ob oc od bi translated">隐式对象(val、类、定义、对象)本身在日常编程中很少使用。有一组非常严格的用例，你可以将它们添加到你的代码中。在现实世界中，你不会像网上所有资料显示的那样，只写一个隐式对象并四处传递它(包括我上面的税务服务的例子！)</li><li id="7065" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld ou ob oc od bi translated">隐含在<strong class="ki iu">更大的画面中发挥作用，</strong>在<strong class="ki iu">设计模式抽象层次上</strong>。我想到的两个例子是实现<strong class="ki iu">类型类</strong>或<strong class="ki iu">隐式转换</strong>。<strong class="ki iu"> </strong>现在我们来看两者。</li></ol><h2 id="0b9f" class="nm lf it bd lg oj ok dn lk ol om dp lo kr on oo ls kv op oq lw kz or os ma ot bi translated">类型类别</h2><p id="68f8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这里我将跳过实现细节。这是一个有点挑战性的设计概念，其中隐含着一些含义。我没有链接到任何资料，只是因为类型类太难了，仅仅通过阅读它们是难以理解的，我不想让你气馁。有一天我会在一篇文章中介绍它们。长话短说，类型类模式允许你(除了别的以外)在一个现有的类型中添加一个新的方法，而不改变这个类型的源代码。</p><p id="6b73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以使用一个类型类，你可以扩展类型<code class="fe ns nt nu ni b">String</code>来调用一些有趣的东西:</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="900e" class="nm lf it ni b gy nn no l np nq">"Berlin".getCountry</span></pre><p id="22c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是所谓的<strong class="ki iu">特定多态性</strong>。类型类在一些函数式Scala库中被广泛使用，最著名的可能是<a class="ae kf" href="https://typelevel.org/cats/" rel="noopener ugc nofollow" target="_blank"> cats </a>。</p><p id="99d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">有趣的事实:</strong>在Scala的最新版本Scala 3中，类型类和扩展方法应该更容易使用。我承认我还没试过。</p><h2 id="383d" class="nm lf it bd lg oj ok dn lk ol om dp lo kr on oo ls kv op oq lw kz or os ma ot bi translated">隐式转换</h2><p id="a2d9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">另一个设计模式级别的概念，通常用于实现<strong class="ki iu">磁铁模式</strong>。你可以把它看作是当一个不正确的参数类型被传递给一个现有的函数或类时，编译器试图应用的一些方法。他们<strong class="ki iu">隐式地</strong>转换类型，“在幕后”匹配被调用函数的签名。隐式转换的一个有趣例子是如何将Scala Int传递给期望Java的Integer的Java方法。</p><h1 id="900a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">何时使用暗示</h1><p id="41ab" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">因此，我们终于谈到了可能大多数读者都在等待的话题。</p><p id="88b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">现实生活。</strong></p><p id="bad0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我有一种感觉，你们中的大多数人在这个阶段理解隐含背后的思想，但是想不出一个可以使用它们的用例。</p><p id="ae1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很好。<strong class="ki iu">正是如此</strong>。正如我上面已经提到的，你不能像大多数介绍隐式的材料所建议的那样，只写一个隐式对象，然后把它传递出去。</p><blockquote class="mo"><p id="9573" class="mp mq it bd mr ms mt mu mv mw mx ld dk translated">被不正确的隐含用法污染的新代码库注定会很快变成遗留代码库。</p></blockquote><p id="21c7" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">除非在一个标准的众所周知的设计模式的框架内使用，或者用于一个众所周知的用例，否则隐式会让你的代码变得非常难以阅读，并且会很快积累大量的技术债务。</p><p id="dcd7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在现实生活中，你会在以下情况下遇到暗示:</p><h2 id="15d6" class="nm lf it bd lg oj ok dn lk ol om dp lo kr on oo ls kv op oq lw kz or os ma ot bi translated"><strong class="ak">你需要满足一个库依赖</strong></h2><p id="e674" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有大量的库，因为它们的内部设计(通常是类型类)会要求你在作用域中有一些隐含的值。举三个例子:</p><ul class=""><li id="f48e" class="nv nw it ki b kj kk kn ko kr nx kv ny kz nz ld oa ob oc od bi translated">要使用大多数带有<strong class="ki iu">自定义</strong>类型的JSON serialiser库，您需要创建一个<strong class="ki iu">隐式读/写对象</strong>，该对象将在您的自定义类型上公开一个类似于<code class="fe ns nt nu ni b">.toJson</code>的扩展方法，然后导入它。然后可以调用:<code class="fe ns nt nu ni b">Person("Andrew").toJson</code></li><li id="fe30" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld oa ob oc od bi translated">要使用Scala Future，你需要一个<strong class="ki iu">隐式执行上下文</strong>。</li><li id="82bc" class="nv nw it ki b kj oe kn of kr og kv oh kz oi ld oa ob oc od bi translated">Scala的Duration看起来<strong class="ki iu"> type class </strong> -y吧？</li></ul><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="2c9f" class="nm lf it ni b gy nn no l np nq">// extension methods for Int imported here, you will find a lot of implicits in this package<br/>import scala.concurrent.Duration._</span><span id="9524" class="nm lf it ni b gy nr no l np nq">1.second // "second" is an extension method on Int<br/>10.millis // ...so is "millis"</span></pre><h2 id="671e" class="nm lf it bd lg oj ok dn lk ol om dp lo kr on oo ls kv op oq lw kz or os ma ot bi translated"><strong class="ak">您使用分布式跟踪</strong></h2><p id="acad" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我看到了隐式的一个有趣用法，那就是在系统中隐式地传递一个分布式跟踪ID和每个请求。结果，业务逻辑没有被分布式跟踪ID引用污染——毕竟它们与业务逻辑无关。</p><h2 id="60d1" class="nm lf it bd lg oj ok dn lk ol om dp lo kr on oo ls kv op oq lw kz or os ma ot bi translated"><strong class="ak">你实现一个类型类模式或者隐式转换</strong></h2><p id="84f1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果你不知道怎么做或者不确定什么时候用，完全没问题。在工作中，到目前为止，我还没有从零开始实现这两个中的任何一个。在大多数情况下，您不会自己编写它们，而可能会使用库中已经存在的东西。</p><figure class="nd ne nf ng gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/55e35af0e6850955592dacad8d8036b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6cvNMTVpe4NiD14w"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="https://unsplash.com/photos/qDY9ahp0Mto" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="a651" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="9d83" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们总结一下。</p><p id="75de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">什么是暗示？ <br/>标有关键字“隐含”的对象。可以是值、变量、对象、类、定义。如果它们被列为另一个对象的依赖项，编译器会在“幕后”拾取它们。编译器只查看隐式值的类型，不查看名称。</p><p id="0a87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">它们用在哪里？<br/> </strong>主要在函数库或众所周知的设计模式中，如<strong class="ki iu">类型类</strong>或<strong class="ki iu">隐式转换</strong>。</p><p id="f234" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我应该什么时候在代码中使用它们？ <br/>不惜一切代价避免，除非你正在实现一个众所周知的设计模式，其他Scala工程师可以理解<strong class="ki iu">或</strong>满足一个库依赖。如果使用不当，隐含将使代码难以阅读、测试和维护。<br/>长话短说:<br/>如果其他事情需要暗示——完全没问题，那就提供吧。如果你认为你正在编写的代码中的某些东西需要被隐式化:100个案例中有99个都不需要。</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="c982" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(*)当然还有更多——为了简单起见，我跳过了本解释中的大部分细节。</p></div></div>    
</body>
</html>