<html>
<head>
<title>How to Fix Vulnerable NPM Dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何修复易受攻击的NPM依赖</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-fix-vulnerable-npm-dependencies-6882ae9a82fd?source=collection_archive---------3-----------------------#2021-04-26">https://levelup.gitconnected.com/how-to-fix-vulnerable-npm-dependencies-6882ae9a82fd?source=collection_archive---------3-----------------------#2021-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7628" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用自动化工具修复易受攻击的依赖关系</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d725d10800aa1f8546b5ad0fe3d06c97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wVpuItfOfIS3Nt5H"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">图片由</em><a class="ae kz" href="https://unsplash.com/photos/ahi73ZN5P0Y" rel="noopener ugc nofollow" target="_blank">T3】费德里科·贝卡里T5】</a></figcaption></figure><p id="8ce2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">像几乎所有的编程语言一样，Javascript并不是没有易受攻击的包，这些包可能作为依赖项包含在使用npm的开发团队的项目中。针对JavaScript中易受攻击的依赖项的最佳防御是跟踪它们并实施适当的控制以减少暴露。</p><p id="a3e0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">每一个团队都面临着保持所有依赖关系最新且没有漏洞的挑战。随着单个存储库中的依赖项数量或存储库数量的增长，这一挑战变得更大、更难管理。如果一个团队需要手动管理所有的包依赖关系，它将花费大量的精力和时间来不断地确保依赖关系是最新的，并且不会使项目变得脆弱。</p><p id="c1ee" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了避免将开发人员的注意力和时间转移到不需要手动完成的任务上，您可以采用自动化工具来扫描所有的依赖项并提出修复建议，无论您的团队使用什么平台或语言。</p><p id="1716" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本文中，我们将研究一些JavaScript漏洞，以及如何使用扫描依赖关系的自动化工具来修复它们。</p><h1 id="c8c3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">JavaScript漏洞</h1><p id="07fe" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">所有软件在某个时间点都会有漏洞，JavaScript也不例外。让我们看看一些类型的漏洞，并浏览一些在以前版本的电子库中发现的实际漏洞的例子。</p><blockquote class="mt mu mv"><p id="6080" class="la lb mw lc b ld le ju lf lg lh jx li mx lk ll lm my lo lp lq mz ls lt lu lv im bi translated">电子框架让你可以使用JavaScript、HTML和CSS编写跨平台的桌面应用。它基于Node.js和Chromium，由Atom编辑器和许多其他应用程序使用。</p><p id="e274" class="la lb mw lc b ld le ju lf lg lh jx li mx lk ll lm my lo lp lq mz ls lt lu lv im bi translated">资料来源:npmjs.com</p></blockquote><p id="0577" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">📝<em class="mw">以下漏洞目前已修复，仅用作示例，无意以任何方式促进漏洞利用。</em></p><h1 id="d3b7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">越界写入</h1><p id="f11d" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">越界写入允许将数据写入已分配缓冲区的边界之外。如果出现此漏洞，可能会导致正在处理的数据损坏、系统崩溃或执行恶意代码。</p><p id="c537" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这个<a class="ae kz" href="https://github.com/electron/electron/pull/28132" rel="noopener ugc nofollow" target="_blank">拉请求</a>中已经报告了这种漏洞的一个例子，它与音频组件中的数据竞争有关。通过此漏洞，远程攻击者可能已经使用精心编制的HTML页面创建了堆溢出。</p><p id="2634" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">该漏洞已在Electron的版本<a class="ae kz" href="https://github.com/electron/electron/releases/tag/v11.4.1" rel="noopener ugc nofollow" target="_blank"> v11.4.1 </a>中修复。</p><h1 id="9636" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">输入验证不正确</h1><p id="b7ef" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">不正确的输入验证允许接收输入，但不验证或不正确地验证它。如果出现此漏洞，系统可能会处理不正确/不安全的数据。</p><p id="3c0b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种漏洞的一个例子是在这个<a class="ae kz" href="https://github.com/electron/electron/pull/28247" rel="noopener ugc nofollow" target="_blank"> pull request </a>中报告的，攻击者使用专门准备的HTML页面来暴露跨来源的数据。</p><p id="73e2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">电子版<a class="ae kz" href="https://github.com/electron/electron/releases/tag/v11.4.1" rel="noopener ugc nofollow" target="_blank"> v11.4.1 </a>修复了该漏洞。</p><h1 id="0213" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">不适当的访问控制</h1><p id="19ba" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">不适当的访问控制使得未经授权的参与者能够以不受限制或不正确的权限访问系统。</p><p id="1337" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这个<a class="ae kz" href="https://github.com/electron/electron/pull/26860" rel="noopener ugc nofollow" target="_blank">拉请求</a>中已经报告了这种漏洞的一个例子。该漏洞基于Chromium网络组件中发现的策略执行不充分的缺陷。</p><p id="8862" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">该漏洞已在Electron的版本<a class="ae kz" href="https://github.com/electron/electron/releases/tag/v9.4.0" rel="noopener ugc nofollow" target="_blank"> v9.4.0 </a>中修复。</p><p id="cf88" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在我们已经了解了一些漏洞，让我们创建一个简单的依赖于8.4.0版本的电子仓库，其中包含前面提到的漏洞。</p><h1 id="80e8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">项目和存储库设置</h1><p id="d91e" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">让我们从初始化项目开始，从命令行终端运行下面的命令。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="757e" class="nf lx it nb b gy ng nh l ni nj">npm init</span></pre><p id="118d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">命令行终端将提示几个问题，最后，您应该有一个名为package.json的文件。</p><p id="5327" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">项目准备就绪后，我们需要做的第一件事是添加一个易受攻击的依赖项。为此，我们将使用8.4.0版本的Electron。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a122" class="nf lx it nb b gy ng nh l ni nj">npm install electron@8.4.0</span></pre><p id="72fe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，package.json文件应该如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0f33" class="nf lx it nb b gy ng nh l ni nj">{<br/>  “name”: “npm-vulnerable-dependencies”,<br/>  “version”: “1.0.0”,<br/>  “description”: “Update npm vulnerable dependencies with renovate”,<br/>  “scripts”: {},<br/>  “dependencies”: {<br/>    “electron”: “8.4.0”<br/>  }<br/>}</span></pre><p id="a796" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">只需将这些文件放入存储库，就大功告成了。</p><p id="cd79" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有了存储库，让我们用WhiteSource的免费工具<a class="ae kz" href="https://www.whitesourcesoftware.com/free-developer-tools/renovate" rel="noopener ugc nofollow" target="_blank">来扫描依赖关系。它将自动更新项目依赖关系，这样我们可以检测旧的依赖关系版本，并将它们更新到最新版本。</a></p><p id="ee41" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">随着我们不断开发和发展我们的项目，keep将为我们提供一些有用的功能:</p><ul class=""><li id="a8c8" class="nk nl it lc b ld le lg lh lj nm ln nn lr no lv np nq nr ns bi translated">持续运行并检测最新的可用版本。</li><li id="f3da" class="nk nl it lc b ld nt lg nu lj nv ln nw lr nx lv np nq nr ns bi translated">每次更新时，我们都会提取并包含变更日志和提交历史，这样我们就不会忘记发生了什么变化以及原因。</li><li id="8c20" class="nk nl it lc b ld nt lg nu lj nv ln nw lr nx lv np nq nr ns bi translated">如果我们有一个测试套件，它将在每次更新时运行测试，以避免回归错误。</li></ul><p id="3a4f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在我们对这个工具有了更好的了解，让我们继续安装它。</p><h1 id="c5e8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">安装和配置翻新</h1><p id="9d6d" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">下一步是在版本控制平台中安装Renovate的bot。这种情况下，我用过GitHub。安装过程非常简单。只需按照GitHub <a class="ae kz" href="https://github.com/apps/renovate" rel="noopener ugc nofollow" target="_blank">网站</a>上的说明操作即可。</p><p id="bace" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">安装之后，将自动创建一个标题为“配置更新”的请求，这将帮助您配置它到存储库中的集成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7a17ea45f26a60a8beb2d8b9884a9078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fj_NObUhmUhXxuNN"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">配置拉取请求</em></figcaption></figure><p id="d751" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个pull请求将包含一个“配置概要”,描述Renovate的默认行为，以及一个“预期”部分，显示将要创建的分支的计划。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cbaf786cc6ee6c96fa1a6a745c4e595c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9DFg1_A_qsBgNht9"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">“预期”部分显示了未来的拉动式需求</em></figcaption></figure><p id="2be3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要启用renew，只需浏览初始的pull请求并将其合并。</p><p id="a716" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们来看看启用后是如何工作的。</p><h1 id="7658" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">翻新是如何工作的？</h1><p id="b670" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">在您合并初始的pull请求之后，renewal被启用，并准备好扫描项目依赖项。当需要更新依赖项时，renew将执行以下操作:</p><ul class=""><li id="7867" class="nk nl it lc b ld le lg lh lj nm ln nn lr no lv np nq nr ns bi translated">创建一个单独的分支(为每个需要更新的依赖项创建一个不同的分支)</li><li id="b77d" class="nk nl it lc b ld nt lg nu lj nv ln nw lr nx lv np nq nr ns bi translated">为新创建的分支创建一个拉请求</li></ul><p id="1cfb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">此时，它会通知您有一个新的“拉”请求打开。您可以决定是通过合并拉请求来处理依赖项更新，还是将更新推迟到以后的阶段。独立于您的决定，依赖性更新的意识已经以拉请求的形式被注册。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/00670af806e32608ba7a51016e5b5d50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1O20KBCmsiBUuoeV"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">将拉请求与建议的更新合并</em></figcaption></figure><p id="4f5a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在合并建议的拉请求之后，依赖关系将被更新，存储库将在“拉请求”部分记录应用的修复。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/051ce3c3ef548f4ced8ffd173ddff999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZaWLrMV6g9PSJ0Vl"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">更新作业日志</figcaption></figure><p id="3cd6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在renew app<a class="ae kz" href="https://app.renovatebot.com/dashboard" rel="noopener ugc nofollow" target="_blank">仪表盘</a>上，您将找到已经运行并产生我们之前看到的分支/PRs的相应作业。</p><h2 id="66f9" class="nf lx it bd ly nz oa dn mc ob oc dp mg lj od oe mi ln of og mk lr oh oi mm oj bi translated">包扎</h2><p id="f190" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">依赖性管理是确保避免或减少易受攻击的依赖性的重要部分。</p><p id="7f0c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">第一步是建立对漏洞的认识，并提供解决它们的计划。一旦计划就绪，就只需要根据漏洞的严重性进行修复了。</p><p id="ef9c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您目前没有关注您正在处理的项目的相关性，请花一些时间浏览它们，以获得项目状态的概览。</p><p id="f64a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">编码快乐！</p></div></div>    
</body>
</html>