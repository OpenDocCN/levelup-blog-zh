<html>
<head>
<title>My Favorite Libraries for Embedded Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我最喜欢的嵌入式系统库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/my-favorite-libraries-for-embedded-systems-a65ff0afc3dc?source=collection_archive---------1-----------------------#2022-04-04">https://levelup.gitconnected.com/my-favorite-libraries-for-embedded-systems-a65ff0afc3dc?source=collection_archive---------1-----------------------#2022-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5942" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">推荐四个牛逼的图书馆。</h2></div><p id="d53a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">作为一名充满激情的嵌入式系统开发人员，我面临过很多不得不重新发明轮子的情况。<br/>在这种情况下，我只是告诉自己，对于我正在使用的平台，没有这样的库可用，或者，如果有什么有用的东西，不幸的是，它充斥着大量Arduino delay()函数调用…即使它是一个用于二叉树处理的库。</p><p id="60ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我承认有独角兽存在:跨平台的、文档完善的、(几乎)无bug的库，它们不依赖于特定于架构的代码，因此可以原样放入您的嵌入式项目中！</p><h2 id="da0c" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated"><em class="me">今天，我将与您分享4个最好的C/C++库，它们非常非常可能与您正在使用的微控制器兼容！</em></h2><h2 id="5b42" class="ll lm iq bd ln lo lp dn lq lr ls dp lt ko lu lv lw ks lx ly lz kw ma mb mc md bi translated">好吧，我们继续。</h2></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="aabb" class="mm lm iq bd ln mn mo mp lq mq mr ms lt jw mt jx lw jz mu ka lz kc mv kd mc mw bi translated">1.一致</h1><p id="6b9b" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> H </span>你曾经在Arduino上体验过<a class="ae nc" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发(TDD) </a>吗？<br/>如果是这样，我相信你已经使用过<a class="ae nc" href="https://github.com/ThrowTheSwitch/Unity" rel="noopener ugc nofollow" target="_blank"> Unity </a>测试库了。</p><p id="fa8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管TDD的其他替代方案确实存在(例如<a class="ae nc" href="https://cpputest.github.io/" rel="noopener ugc nofollow" target="_blank"><em class="lk">cputest</em></a>)，但它的一个主要优势来自于Unity是一个普通的老式C库:如果运气好的话，它可以很容易地集成到你的项目中。</p><p id="6c87" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是它是如何工作的呢？首先，您定义自己的函数来访问标准输出:这些函数将用于打印测试结果。</p><p id="9438" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，你写一堆单元测试，除了void函数什么都不是，用一个实用方法把它们添加到Unity测试列表中。例如，看一下这段代码:</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/fde98d9ce1bd8db0705356263f7acae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*pT-2GKjoCywCZ68CgE36bw.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">Unity测试示例— test_fail()和test_shouldPass()在Arduino setup()函数中运行</figcaption></figure><p id="f9fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我在微控制器上刷新并运行程序时，它会打印出这样的信息:</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/fe93206179f9632691701f266abdd873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynrgcTQ1jpLv-LgnNzdxUw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">通过PlatformIO内核运行Unity测试(在STM32F401RE上)</figcaption></figure></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="b739" class="mm lm iq bd ln mn mo mp lq mq mr ms lt jw mt jx lw jz mu ka lz kc mv kd mc mw bi translated">2.CMSIS</h1><p id="47a8" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi lb translated">好吧，这可能是基于ARM的微控制器最广泛的一段代码，我们中的一些人已经利用了很长时间，甚至不知道它的存在。</p><p id="37e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae nc" href="https://www.arm.com/why-arm/technologies/cmsis" rel="noopener ugc nofollow" target="_blank">通用微控制器系统接口标准</a> (CMSIS)是由ARM定义的一套接口，旨在提高不同厂商生产的微控制器之间的互操作性。</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi nu"><img src="../Images/3cab57b8e9299dfe024a44e60b78895a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y236DgX5L-WHZFbo-nMobA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">CMSIS概述。来源:ARM网站</figcaption></figure><p id="1bf3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用CMSIS，您可以访问标准化的RTOS、HAL甚至神经网络包，这些包可以在完全不同的设备之间完全移植。有兴趣的话，也有简化“裸机”C编程的仅头文件、特定于供应商的包(看看<a class="ae nc" href="https://www.keil.com/pack/doc/CMSIS/Core/html/device_h_pg.html" rel="noopener ugc nofollow" target="_blank">设备</a>)。</p><p id="b49a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想值得指出的是，ARM并不负责实现过程。因此，这是很常见的，例如，提供了RTOS的实现，但没有一个哈尔。</p><p id="c48d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，你必须看看是否有人实现了你要找的模块。引用我最喜欢的电影之一:</p><blockquote class="nv nw nx"><p id="1a14" class="kf kg lk kh b ki kj jr kk kl km ju kn ny kp kq kr nz kt ku kv oa kx ky kz la ij bi translated">这是一个英雄，不是我们应得的英雄，而是我们需要的英雄。</p></blockquote><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi ob"><img src="../Images/c8c7177401a398472cbcd22af169c936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YcZ4SZ6Tex3LU7ZG80Bgg.jpeg"/></div></div></figure></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="1de0" class="mm lm iq bd ln mn mo mp lq mq mr ms lt jw mt jx lw jz mu ka lz kc mv kd mc mw bi translated">3.弗里托斯</h1><p id="2638" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">F</span>T5】re ertos是一个开源的实时操作系统，已经移植到大量的微控制器上。它为并发编程和访问共享资源提供了各种实用工具，例如任务、队列、互斥和非阻塞延迟！</p><p id="fe4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，它的杀手锏之一是其庞大的社区:无论你有什么问题，只要在谷歌搜索栏中键入一串单词，你很可能会找到一个现成的解决方案。</p><figure class="ne nf ng nh gt ni gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi oc"><img src="../Images/c6a0c661e822d7248b2c6f858795e3de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e7YbCltazH_zQVYIWyPPrw.png"/></div></div></figure><p id="5150" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果你愿意接受嵌入式操作系统的强大功能，而不必绑定到任何封闭的专有解决方案，那么可以考虑尝试一下FreeRTOS。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="2bc5" class="mm lm iq bd ln mn mo mp lq mq mr ms lt jw mt jx lw jz mu ka lz kc mv kd mc mw bi translated">4.嵌入式模板库</h1><p id="1ab8" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">作为一个C++爱好者，我一直梦想有一种方法可以在我的嵌入式代码中去掉普通的C数组… <br/>你知道，也许可以使用类似于<a class="ae nc" href="https://en.wikipedia.org/wiki/Standard_Template_Library" rel="noopener ugc nofollow" target="_blank"> STL </a>的东西！</span></p><p id="b21a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我很自豪地宣布，解决方案终于出来了。<br/>由John Wellbelove开发的<a class="ae nc" href="https://www.etlcpp.com/home.html" rel="noopener ugc nofollow" target="_blank">嵌入式模板库(ETL) </a>是易用性和效率之间的折衷，同时保持代码一如既往的确定性。事实上，每个ETL容器都有在编译时确定的固定容量:根本没有malloc/free！</p><p id="d1b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个包还包括一些标准设计模式的参考实现，比如GoF Visitor和Observer。</p><p id="cf28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它绝对配得上GitHub 上的一颗星！</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="736b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您阅读至此。如果你有任何关于适合嵌入式系统的花哨的C/C++库的额外推荐，请在评论区发表！</p></div></div>    
</body>
</html>