<html>
<head>
<title>Passing smart pointers in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C++中传递智能指针</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/passing-smart-pointers-in-c-479775632443?source=collection_archive---------1-----------------------#2021-03-21">https://levelup.gitconnected.com/passing-smart-pointers-in-c-479775632443?source=collection_archive---------1-----------------------#2021-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e7d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理智能指针是任何C++程序员的日常任务，当您希望获得最佳性能时，如何传递它们会变得很棘手。这里有一些提示和一般准则，可以在返回时将shared_ptr和unique_ptr作为函数参数传递。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c0910ad71ec8647721a3859addef61f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MKKxnMeiF8CTX0zm"/></div></div></figure><blockquote class="kx ky kz"><p id="fd0d" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">和往常一样，除非你打算共享所有权，否则最好选择unique_ptr而不是shared_ptr。</p></blockquote><h1 id="aa24" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">介绍</h1><ol class=""><li id="7687" class="mc md iq jp b jq me ju mf jy mg kc mh kg mi kk mj mk ml mm bi translated">总是问自己“我真的需要传递一个智能指针吗？”</li><li id="872c" class="mc md iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">std::unique_ptr用法</li><li id="31e3" class="mc md iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">std::shared_ptr用法</li><li id="76ea" class="mc md iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">如何正确传递原始指针/引用？</li><li id="8fc7" class="mc md iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">对于返回智能指针，规范是什么？</li></ol></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="fc67" class="le lf iq bd lg lh mz lj lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb bi translated">总是问自己“我真的需要传递一个智能指针吗？”</h1><p id="20e4" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">您应该始终评估将智能指针作为函数参数传递是否是您真正需要的。在大多数情况下，你只需要使用它并完成它。在这些情况下，获得一个原始指针并传递它总是好的。</p><p id="9adc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在我们继续之前，我必须告诉你<strong class="jp ir">原始指针并不总是坏的</strong>。正如我们将在本帖中读到的，它们在许多情况下非常有用。</p><h2 id="4177" class="nh lf iq bd lg ni nj dn lk nk nl dp lo jy nm nn ls kc no np lw kg nq nr ma ns bi translated">指导方针</h2><blockquote class="kx ky kz"><p id="2854" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">不要将智能指针作为函数参数传递，除非您想要使用或操作它，例如共享或转移所有权。</p><p id="91f6" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated"><strong class="jp ir">更喜欢</strong>通过不拥有的原始指针(<strong class="jp ir"> * </strong>)或引用(<strong class="jp ir"> &amp; </strong>)传递对象。</p></blockquote><h2 id="aa42" class="nh lf iq bd lg ni nj dn lk nk nl dp lo jy nm nn ls kc no np lw kg nq nr ma ns bi translated">理由和例子</h2><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="0a77" class="nh lf iq nu b gy ny nz l oa ob">void f( widget* );              <br/>void f( widget&amp; );</span></pre><p id="0a7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它们不知道调用者使用什么样的生存期策略，并且很好地观察了一个我们知道其生存期超过指针或引用生存期的对象。</p><p id="f90e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是限制性的，不容易提交。然后我们会看到并评估传递智能指针的最佳方式。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oc"><img src="../Images/1b2bc2600fb077e57fb580ea092f0b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CiD2BpQ9eDI1PX9OYMMLAQ.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated"><strong class="bd lg">第一步:了解你的一生</strong> …全貌会越来越清晰:)</figcaption></figure><p id="af98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果我们对寿命有把握，应该遵循以下原则</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oh"><img src="../Images/7cc3c17787687ad4fe7748deaf93d584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tuRoK1HFOMg2xkZcSGyTIw.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated"><strong class="bd lg">无股份或所有权转让时应遵循的指导方针和有效寿命</strong></figcaption></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="18b4" class="le lf iq bd lg lh mz lj lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb bi translated">std::unique_ptr用法</h1><h2 id="c9e4" class="nh lf iq bd lg ni nj dn lk nk nl dp lo jy nm nn ls kc no np lw kg nq nr ma ns bi translated"><code class="fe oi oj ok nu b">By value unique_ptr&lt;type&gt;</code>假设拥有一个<code class="fe oi oj ok nu b">widget</code></h2><p id="1d8e" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated"><strong class="jp ir">理由:</strong>这是表达消费功能的首选方式，也称为<strong class="jp ir">“汇”</strong>。</p><p id="0feb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在文档和代码中以这种方式使用<code class="fe oi oj ok nu b">unique_ptr</code>，很好地实施了函数调用的所有权转移(<em class="la">表示一个“接收器”函数)</em></p><p id="833d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比如——</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="5988" class="nh lf iq nu b gy ny nz l oa ob">void sink(unique_ptr&lt;widget&gt;); // takes ownership of the widget</span><span id="fe0f" class="nh lf iq nu b gy ol nz l oa ob">// whereas</span><span id="ec62" class="nh lf iq nu b gy ol nz l oa ob">void uses(widget*);            // just uses the pointed object</span></pre><p id="b588" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个不好的例子—</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="af1f" class="nh lf iq nu b gy ny nz l oa ob">void thinko(const unique_ptr&lt;widget&gt;&amp;); // usually not what you want</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi om"><img src="../Images/10efcc7ac1a12e8c87161ec4b1b57235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hsARhJ6S3gqAHfiNkdIlGQ.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated"><strong class="bd lg">独特_ptr通过指引</strong></figcaption></figure><p id="a190" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在的指导方针是—</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi on"><img src="../Images/26e23bcb101efcd4f0932bc29e6921d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cp9haQg73JXSEN-xfrJB-g.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated"><strong class="bd lg">第二步:了解您的转账情况</strong> …更清晰的图片:)</figcaption></figure><h2 id="992d" class="nh lf iq bd lg ni nj dn lk nk nl dp lo jy nm nn ls kc no np lw kg nq nr ma ns bi translated">指南:</h2><blockquote class="kx ky kz"><p id="a97a" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">使用by-value <strong class="jp ir"> unique_ptr </strong>参数表示“sink”函数。<em class="iq">使用非常数</em><strong class="jp ir"><em class="iq">unique _ ptr&amp;</em></strong><em class="iq">参数只修改</em><strong class="jp ir"><em class="iq">unique _ ptr</em></strong><em class="iq">。</em></p></blockquote></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="0bc5" class="le lf iq bd lg lh mz lj lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb bi translated">std::shared_ptr用法</h1><h2 id="a779" class="nh lf iq bd lg ni nj dn lk nk nl dp lo jy nm nn ls kc no np lw kg nq nr ma ns bi translated">仅当您共享所有权时，才通过值传递shared_ptr</h2><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="4df7" class="nh lf iq nu b gy ny nz l oa ob">void f( shared_ptr&lt;widget&gt; );  // only when you want to retain<br/>                               // object and share ownership</span></pre><blockquote class="oo"><p id="f4ac" class="op oq iq bd or os ot ou ov ow ox kk dk translated">分享所有权是有代价的，所以要确保你真的打算付出这个代价。</p></blockquote><p id="5174" class="pw-post-body-paragraph jn jo iq jp b jq oy js jt ju oz jw jx jy pa ka kb kc pb ke kf kg pc ki kj kk ij bi translated">在按值传递中，参数在进入函数时被复制(通常除非是临时的)，然后在函数退出时被销毁(总是)。</p><p id="599a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过值传递<em class="la"> shared_ptr </em>意味着——<br/>1)一个新的<strong class="jp ir"> <em class="la"> shared_ptr </em> </strong>将被<strong class="jp ir">复制构造。2)作为原子共享变量的引用计数增加。<br/>3)<strong class="jp ir"><em class="la">shared _ ptr</em></strong>copy在函数结束时被销毁。作为原子共享变量的引用计数减少。</strong></p><p id="f53a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">【相关帖子:<a class="ae pd" href="https://medium.com/pranayaggarwal25/a-tale-of-two-allocations-f61aa0bf71fc" rel="noopener">https://medium . com/pranayaggarwal 25/a-tale-of two-allocations-f 61 aa 0f 71 fc</a>]</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="34a3" class="nh lf iq nu b gy ny nz l oa ob">void f( const shared_ptr&amp;&lt;widget&gt; );   // may share ownership<br/>void f( shared_ptr&amp;&lt;widget&gt; );         // may reset pointer</span></pre><p id="a5f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在特殊情况下，函数<em class="la">可能</em>共享所有权，但不一定在给定的调用中复制其参数，然后传递一个const-ref以避免在不需要它的调用中复制。所以对于<strong class="jp ir"> <em class="la"> shared_ptr </em> </strong>遵循这个——</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pe"><img src="../Images/fe6ab7a8163413a62c008b4ed5efba3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1VklHsi0KmZw17S5o0VW8Q.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated"><strong class="bd lg">共享_ptr通过指引</strong></figcaption></figure><p id="3d6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们在这里有完整的指导方针——</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pf"><img src="../Images/0d325e7459b83a46932139b6f46e72ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZhPV6_u-926_gDzo-_RHg.png"/></div></div><figcaption class="od oe gj gh gi of og bd b be z dk translated"><strong class="bd lg">第三步:最终指南图片</strong></figcaption></figure></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="79f9" class="le lf iq bd lg lh mz lj lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb bi translated">如何正确传递原始指针/引用？</h1><p id="489f" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">正如我们在上面所看到的，函数应该尽可能地向下传递原始指针和引用。</p><p id="b7fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在调用树的顶部，从保持对象活动的智能指针获取原始指针或引用。您需要确保智能指针不会被无意中从下面的调用树中重置或重新分配。</p><p id="d8ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">为了做到这一点，有时你需要获取一个智能指针的本地副本，它在函数和调用树的持续时间内牢牢地保持对象活动。</strong></p><p id="e244" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑一下这段代码，以下内容应该不会通过代码审查:</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="3fed" class="nh lf iq nu b gy ny nz l oa ob">// global (static or heap), or aliased local ...<br/>shared_ptr&lt;widget&gt; g_p = ...;</span><span id="8849" class="nh lf iq nu b gy ol nz l oa ob">void my_code()<br/>{<br/>    // <strong class="nu ir">BAD:</strong> passing pointer or reference obtained from a non-local<br/>    // smart pointer that could be inadvertently reset somewhere <br/>    // inside f or its callees<br/>    f(*g_p);</span><span id="7db6" class="nh lf iq nu b gy ol nz l oa ob">// <strong class="nu ir">BAD:</strong> same reason, just passing it as a "this" pointer<br/>    g_p-&gt;func();<br/>}</span></pre><p id="481d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">修复方法很简单——获取指针的本地副本来保存调用树的引用计数:</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="36bd" class="nh lf iq nu b gy ny nz l oa ob">// global (static or heap), or aliased local ...<br/>shared_ptr&lt;widget&gt; g_p = ...;</span><span id="116c" class="nh lf iq nu b gy ol nz l oa ob">void my_code()<br/>{<br/>    // <strong class="nu ir">cheap:</strong> 1 increment covers this entire function and call trees <br/>    auto pin = g_p;</span><span id="e184" class="nh lf iq nu b gy ol nz l oa ob">// <strong class="nu ir">GOOD:</strong> passing pointer or reference obtained from a local <br/>    // unaliased smart pointer<br/>    f(*pin);</span><span id="3146" class="nh lf iq nu b gy ol nz l oa ob">// <strong class="nu ir">GOOD:</strong> same reason<br/>    pin-&gt;func();<br/>}</span></pre></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="df03" class="le lf iq bd lg lh mz lj lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb bi translated">对于返回智能指针，规范是什么？</h1><p id="5289" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk ij bi translated">您应该遵循上面的相同逻辑:</p><blockquote class="kx ky kz"><p id="c8dd" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">如果调用者想要操作智能指针本身，则返回智能指针；如果调用者只需要底层对象的句柄，则返回原始指针/引用。</p></blockquote><p id="58e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你真的需要从一个函数返回智能指针，放轻松，总是通过值返回<em class="la">。那就是:</em></p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="d383" class="nh lf iq nu b gy ny nz l oa ob">std::unique_ptr&lt;Object&gt; getUnique();<br/>std::shared_ptr&lt;Object&gt; getShared();<br/>std::weak_ptr&lt;Object&gt;   getWeak();</span></pre><p id="a4bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这至少有三个很好的理由:</p><ol class=""><li id="2d2e" class="mc md iq jp b jq jr ju jv jy pg kc ph kg pi kk mj mk ml mm bi translated"><strong class="jp ir">移动语义</strong><strong class="jp ir">——</strong>智能指针由移动语义驱动:它们持有的动态分配的资源被四处移动，而不是被浪费地复制。</li><li id="643b" class="mc md iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated"><strong class="jp ir">返回值优化(RVO) </strong>从C++17开始，标准保证了这一点。通过引用返回会禁止该快捷方式。</li><li id="aff8" class="mc md iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated"><strong class="jp ir">对象删除概率— </strong>通过引用返回<code class="fe oi oj ok nu b">std::shared_ptr</code>不会正确地增加引用计数，这就带来了在错误的时间删除某些内容的风险，因为当对象超出另一个上下文的范围时，会导致对象被删除(可能是本地的)的风险。</li></ol><p id="883d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">多亏了RVO。当返回一个<code class="fe oi oj ok nu b">std::unique_ptr</code>时，你也不需要移动任何东西。</p><pre class="km kn ko kp gt nt nu nv nw aw nx bi"><span id="9178" class="nh lf iq nu b gy ny nz l oa ob">std::unique_ptr&lt;Object&gt; getUnique()<br/>{<br/>    std::unique_ptr&lt;Object&gt; p = std::make_unique&lt;Object&gt;();<br/>    return p; <br/>    // also return std::make_unique&lt;Object&gt;();<br/>}</span></pre></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><h1 id="20a3" class="le lf iq bd lg lh mz lj lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb bi translated">参考</h1><ol class=""><li id="07da" class="mc md iq jp b jq me ju mf jy mg kc mh kg mi kk mj mk ml mm bi translated"><a class="ae pd" href="https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/" rel="noopener ugc nofollow" target="_blank">https://herbsutter . com/2013/06/05/gotw-91-solution-smart-pointer-parameters/</a></li><li id="9aa4" class="mc md iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated"><a class="ae pd" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-uniqueptrparam" rel="noopener ugc nofollow" target="_blank">http://isocpp . github . io/cppcore guidelines/cppcore guidelines # Rr-uniqueptrparam</a></li><li id="c0e8" class="mc md iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated"><a class="ae pd" href="https://www.internalpointers.com/post/move-smart-pointers-and-out-functions-modern-c" rel="noopener ugc nofollow" target="_blank">https://www . internal pointers . com/post/move-smart-pointers-and-out-functions-modern-c</a></li></ol></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="5f4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读这篇文章！欢迎留下你的评论，分享你的想法。请不吝赐教，改进这篇文章。<br/>祝您愉快！</p><p id="e6cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请随意给我买杯咖啡☕ =&gt; <a class="ae pd" href="https://www.buymeacoffee.com/pranayagrawal" rel="noopener ugc nofollow" target="_blank">这里</a>😊</p></div></div>    
</body>
</html>