<html>
<head>
<title>Evaluating Performance on Search Algorithms in Python and Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">评估Python和Rust中搜索算法的性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/evaluating-performance-on-search-algorithms-in-python-and-rust-c86fa07678e1?source=collection_archive---------17-----------------------#2020-05-25">https://levelup.gitconnected.com/evaluating-performance-on-search-algorithms-in-python-and-rust-c86fa07678e1?source=collection_archive---------17-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/93e91c3644af220f02c53ab52ab8efd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EdrFU-V7xcJ8EGZh"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kf" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>拍摄</figcaption></figure><h1 id="b4af" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">背景</h1><p id="4f65" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">有没有想过，你在高中或大学学习的搜索算法，在不同的编程语言中会有不同的表现？</p><p id="17ea" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在本文中，我将向您展示如何用两种编程语言实现线性和二分搜索法算法，即Python和Rust语言。此外，还比较了这两种算法在这两种语言中的性能。</p><p id="21f7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在我们开始这篇文章之前，我想对我的上一篇文章，<a class="ae kf" href="https://medium.com/@leonardyeo_xl/evaluating-performance-on-classic-sorting-algorithms-in-python-and-rust-76f981dfc0c" rel="noopener">https://medium . com/@ Leonard Yeo _ XL/evaluating-performance-on-classic-sorting-algorithms-in-python-and-rust-76f 981 DFC，</a>进行一个简短的介绍，如果你对性能评估这类事情感兴趣的话。</p><p id="3e87" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">好吧，让我们开始吧！</p><div class="mh mi gp gr mj mk"><a href="https://www.eduelk.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">教育</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">通过我们的练习题为您的下一次技术认证考试树立信心。我们提供课程来加速…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.eduelk.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my jz mk"/></div></div></a></div><div class="mh mi gp gr mj mk"><a href="https://www.eduelk.com/about-us" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">关于我们——教育</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">在爱德克教育，我们相信熟能生巧。我们知道准备参加技术认证是…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.eduelk.com</p></div></div><div class="mt l"><div class="mz l mv mw mx mt my jz mk"/></div></div></a></div><div class="mh mi gp gr mj mk"><a href="https://www.eduelk.com/shop-for-practice-questions" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">通过我们负担得起的练习题获得自信——教育</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">编辑描述</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.eduelk.com</p></div></div><div class="mt l"><div class="na l mv mw mx mt my jz mk"/></div></div></a></div><div class="mh mi gp gr mj mk"><a href="https://www.eduelk.com/book-a-lesson" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">联系方式1——教育</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">编辑描述</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.eduelk.com</p></div></div><div class="mt l"><div class="nb l mv mw mx mt my jz mk"/></div></div></a></div><h1 id="4618" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">先决条件</h1><p id="3205" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在继续本文之前，您应该已经，</p><ul class=""><li id="9584" class="nc nd it lg b lh mc ll md lp ne lt nf lx ng mb nh ni nj nk bi translated">Python和Rust的基本编程经验</li><li id="eb69" class="nc nd it lg b lh nl ll nm lp nn lt no lx np mb nh ni nj nk bi translated">对一些经典搜索算法的基本理解</li></ul><h1 id="f946" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">环境</h1><p id="6bb4" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">以下是我在评估中使用的环境:</p><ul class=""><li id="df21" class="nc nd it lg b lh mc ll md lp ne lt nf lx ng mb nh ni nj nk bi translated">Docker版本19.03.6</li><li id="57c7" class="nc nd it lg b lh nl ll nm lp nn lt no lx np mb nh ni nj nk bi translated">Python 3.7.3</li><li id="d8a1" class="nc nd it lg b lh nl ll nm lp nn lt no lx np mb nh ni nj nk bi translated">铁锈1.43.1</li><li id="23db" class="nc nd it lg b lh nl ll nm lp nn lt no lx np mb nh ni nj nk bi translated">Rust dependencies rand = "0.7.3 "</li><li id="9e59" class="nc nd it lg b lh nl ll nm lp nn lt no lx np mb nh ni nj nk bi translated">Rust依赖浮动-duration = "0.1.2 "</li></ul><p id="1128" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">注意，算法运行在数据大小为<strong class="lg iu"> 900 </strong>个元素的<strong class="lg iu">上。</strong></p><p id="2cf7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">开始编码吧！</p><h1 id="9405" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">线性搜索</h1><p id="2a8e" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">简单回顾一下，线性搜索既可以迭代实现，也可以递归实现。执行搜索时，不必对数据进行排序。</p><h2 id="f998" class="nq kh it bd ki nr ns dn km nt nu dp kq lp nv nw ku lt nx ny ky lx nz oa lc ob bi translated">计算机编程语言</h2><p id="1844" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu">源代码迭代</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="7063" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">import </strong>random<br/><strong class="oh iu">import </strong>datetime</span><span id="9586" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">def </strong>sorted_linear_search(search_key, arr):<br/> for i in range(0, len(arr)-1):<br/>  if arr[i] == search_key:<br/>   return True<br/> return False</span></pre><p id="755f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">运行迭代</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="75cf" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">if </strong>__name__ == "__main__":<br/> array = [index for index in range(1, 901)]<br/> random.shuffle(array)</span><span id="b8cf" class="nq kh it oh b gy op om l on oo"> start = datetime.datetime.now()<br/> result = sorted_linear_search(789, array)<br/> end = datetime.datetime.now()<br/> print("It took: ",(end-start).total_seconds()*1000," ms to search")</span></pre><p id="5d43" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">性能迭代</strong></p><p id="423e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在900的数据量中搜索数字789估计花费了<strong class="lg iu"> 0.024毫秒</strong>。</p><p id="6316" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">源代码递归</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="ea43" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">import </strong>random<br/><strong class="oh iu">import </strong>datetime</span><span id="65d7" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">def </strong>sorted_linear_search_recursion(search_key, arr, tail):<br/> if tail &lt; 0:<br/>  return False<br/> elif search_key == arr[tail]:<br/>  return True<br/> else:<br/>  return sorted_linear_search_recursion(search_key, arr, tail-1)</span></pre><p id="efe1" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">运行递归</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="bceb" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">if </strong>__name__ == "__main__":<br/> array = [index for index in range(1, 901)]<br/> random.shuffle(array)</span><span id="2744" class="nq kh it oh b gy op om l on oo"> start = datetime.datetime.now()<br/> result = sorted_linear_search_recursion(789, array, len(array)-1)<br/> end = datetime.datetime.now()<br/> print("It took: ",(end-start).total_seconds()*1000," ms to search")</span></pre><p id="8251" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">性能递归</strong></p><p id="da60" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在900的数据量中搜索数字789估计花费了<strong class="lg iu"> 0.187毫秒</strong>。</p><h2 id="2aa1" class="nq kh it bd ki nr ns dn km nt nu dp kq lp nv nw ku lt nx ny ky lx nz oa lc ob bi translated">锈</h2><p id="a96a" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu">源代码迭代</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="3768" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">use </strong>rand::seq::SliceRandom;<br/><strong class="oh iu">use </strong>rand::thread_rng;<br/><strong class="oh iu">use </strong>std::time::Instant;<br/><strong class="oh iu">use </strong>floating_duration::TimeFormat;</span><span id="f8b6" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">fn </strong>linear_search_iteration(search_key: i32, vec: &amp;mut Vec&lt;i32&gt;) -&gt; bool {<br/> for index in 0..vec.len()-1 {<br/>  if vec[index] == search_key {<br/>   return true;<br/>  }<br/> }<br/> return false;<br/>}</span></pre><p id="e5ec" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">运行迭代</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="4766" class="nq kh it oh b gy ol om l on oo">fn main() {<br/> let mut rng = thread_rng();<br/> let mut int_vec = Vec::new();<br/> let max_num = 901;</span><span id="c334" class="nq kh it oh b gy op om l on oo"> for num in 1..max_num {<br/>  int_vec.push(num as i32);<br/> }</span><span id="1b1a" class="nq kh it oh b gy op om l on oo"> println!("Unshuffled: {:?}", int_vec);<br/> int_vec.shuffle(&amp;mut rng);<br/> println!("Shuffled: {:?}", int_vec);</span><span id="beaa" class="nq kh it oh b gy op om l on oo"> int_vec.shuffle(&amp;mut rng);<br/> let mut start = Instant::now();<br/> let result = linear_search_iteration(789, &amp;mut int_vec);<br/> println!("It took: {} to search", TimeFormat(start.elapsed()));<br/>}</span></pre><p id="46f4" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">性能迭代</strong></p><ul class=""><li id="f8d0" class="nc nd it lg b lh mc ll md lp ne lt nf lx ng mb nh ni nj nk bi translated">在数据量为900的情况下，搜索数字789估计花费了<strong class="lg iu"> 42.550秒</strong>(微秒)或<strong class="lg iu"> 0.04255毫秒</strong>。</li></ul><p id="6dfe" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">源代码递归</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="4061" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">use </strong>rand::seq::SliceRandom;<br/><strong class="oh iu">use </strong>rand::thread_rng;<br/><strong class="oh iu">use </strong>std::time::Instant;<br/><strong class="oh iu">use </strong>floating_duration::TimeFormat;</span><span id="5e0e" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">fn </strong>linear_search_recursion(search_key: i32, vec: &amp;mut Vec&lt;i32&gt;, tail: usize) -&gt; bool {<br/> if tail &gt; 0 {<br/>  if search_key == vec[tail] {<br/>   return true;<br/>  }<br/>  else {<br/>   return sorted_search_iteration(search_key, vec, tail-1);<br/>  }<br/> }<br/> else if tail == 0 {<br/>  if search_key == vec[tail] {<br/>   return true;<br/>  } <br/>  return false;<br/> }<br/> else {<br/>  return false;<br/> }<br/>}</span></pre><p id="3a22" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">运行递归</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="1078" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">fn </strong>main() {<br/> let mut rng = thread_rng();<br/> let mut int_vec = Vec::new();<br/> let max_num = 901;</span><span id="7310" class="nq kh it oh b gy op om l on oo"> for num in 1..max_num {<br/>  int_vec.push(num as i32);<br/> }</span><span id="0eb4" class="nq kh it oh b gy op om l on oo"> println!(“Unshuffled: {:?}”, int_vec);<br/> int_vec.shuffle(&amp;mut rng);<br/> println!(“Shuffled: {:?}”, int_vec);</span><span id="a769" class="nq kh it oh b gy op om l on oo"> let vec_length: usize = int_vec.len()-1;<br/> start = Instant::now();<br/> let result = linear_search_recursion(789,&amp;mut int_vec,vec_length);<br/> println!("It took: {} to search", TimeFormat(start.elapsed()));<br/>}</span></pre><p id="dacd" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">性能递归</strong></p><p id="b49e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在900的数据大小中搜索数字789估计花费了<strong class="lg iu"> 15.390 s(微秒)</strong>或<strong class="lg iu"> 0.01539毫秒</strong>。</p></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><h1 id="788d" class="kg kh it bd ki kj ox kl km kn oy kp kq kr oz kt ku kv pa kx ky kz pb lb lc ld bi translated">二进位检索</h1><p id="4495" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">简单回顾一下，二分搜索法可以迭代递归地实现。然而，数据必须按降序或升序进行排序。</p><h2 id="84dc" class="nq kh it bd ki nr ns dn km nt nu dp kq lp nv nw ku lt nx ny ky lx nz oa lc ob bi translated">计算机编程语言</h2><p id="f287" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu">源代码迭代</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="0079" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">import </strong>random<br/><strong class="oh iu">import </strong>datetime</span><span id="8daf" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">def </strong>binSearch_ite(search_key, arr):<br/> low = 0<br/> high = len(arr)-1</span><span id="fd92" class="nq kh it oh b gy op om l on oo"> while low &lt;= high:<br/>  mid = int(low + (high-low)//2)<br/>  if search_key == arr[mid]:<br/>   return True<br/>  if search_key &lt; arr[mid]:<br/>   high = mid-1<br/>  elif search_key &gt; arr[mid]:<br/>   low = mid+1</span><span id="a30f" class="nq kh it oh b gy op om l on oo"> return False</span></pre><p id="1167" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">运行迭代</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="434f" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">if </strong>__name__ == "__main__":<br/> array = [index for index in range(1, 901)]<br/> start = datetime.datetime.now()<br/> result = binSearch_ite(789, array)<br/> end = datetime.datetime.now()<br/> print("It took: ",(end-start).total_seconds()*1000," ms to search")</span></pre><p id="7b8b" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">性能迭代</strong></p><p id="60a8" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在900的数据量中搜索数字789估计花费了<strong class="lg iu"> 0.007毫秒</strong>。</p><p id="5e44" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">源代码递归</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="cada" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">import </strong>random<br/><strong class="oh iu">import </strong>datetime</span><span id="5777" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">def</strong> binSearch_re(low, high, search_key, arr):<br/> if low &gt; high:<br/>  return False<br/> else:<br/>  mid = int(low + (high-low)//2)<br/>  if search_key == arr[mid]:<br/>   return True<br/>  if search_key &lt; arr[mid]:<br/>   return binSearch_re(low, mid-1, search_key, arr)<br/>  elif search_key &gt; arr[mid]:<br/>   return binSearch_re(mid+1, high, search_key, arr)</span></pre><p id="c5b6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">运行递归</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="e7a3" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">if </strong>__name__ == "__main__":<br/> array = [index for index in range(1, 901)]<br/> start = datetime.datetime.now()<br/> result = binSearch_re(0, len(array)-1, 789, array)<br/> end = datetime.datetime.now()<br/> print("It took: ",(end-start).total_seconds()*1000," ms to search")</span></pre><p id="6303" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">性能递归</strong></p><p id="400c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在900的数据中搜索数字789估计花费了<strong class="lg iu"> 0.01毫秒</strong>。</p><h2 id="e408" class="nq kh it bd ki nr ns dn km nt nu dp kq lp nv nw ku lt nx ny ky lx nz oa lc ob bi translated">锈</h2><p id="be02" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu">源代码迭代</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="8dd3" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">use </strong>rand::seq::SliceRandom;<br/><strong class="oh iu">use </strong>rand::thread_rng;<br/><strong class="oh iu">use </strong>std::time::Instant;<br/><strong class="oh iu">use </strong>floating_duration::TimeFormat;</span><span id="347f" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">fn </strong>binary_search_iteration(search_key: i32, vec: &amp;mut Vec&lt;i32&gt;) -&gt; bool {<br/> let mut low: usize = 0;<br/> let mut high: usize = vec.len()-1;<br/> let mut mid: usize = 0;</span><span id="7ecf" class="nq kh it oh b gy op om l on oo"> while low &lt;= high {<br/>  mid = low + (high-low)/2;<br/>  if search_key == vec[mid] {<br/>   return true;<br/>  }</span><span id="b83a" class="nq kh it oh b gy op om l on oo">  if search_key &lt; vec[mid] {<br/>   high = mid — 1;<br/>  } else if search_key &gt; vec[mid] {<br/>   low = mid + 1;<br/>  }<br/> }</span><span id="0b08" class="nq kh it oh b gy op om l on oo"> return false;<br/>}</span></pre><p id="aa3f" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">运行迭代</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="c508" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">fn </strong>main() {<br/> let mut rng = thread_rng();<br/> let mut int_vec = Vec::new();<br/> let max_num = 901;</span><span id="9f5e" class="nq kh it oh b gy op om l on oo"> for num in 1..max_num {<br/> int_vec.push(num as i32);<br/> }</span><span id="ef0c" class="nq kh it oh b gy op om l on oo"> let mut start = Instant::now();<br/> let result = binary_search_iteration(789, &amp;mut int_vec);<br/> println!("It took: {} to search", TimeFormat(start.elapsed()));<br/>}</span></pre><p id="7534" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">性能迭代</strong></p><p id="e278" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在数据量为900的情况下，搜索数字789估计需要<strong class="lg iu">680纳秒</strong>或<strong class="lg iu"> 0.00068毫秒</strong>。</p><p id="3abd" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">源代码递归</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="fefa" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">use </strong>rand::seq::SliceRandom;<br/><strong class="oh iu">use </strong>rand::thread_rng;<br/><strong class="oh iu">use </strong>std::time::Instant;<br/><strong class="oh iu">use </strong>floating_duration::TimeFormat;</span><span id="7547" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">fn </strong>binary_search_rec(low: usize, high: usize, search_key: i32, vec: &amp;mut Vec&lt;i32&gt;) -&gt; bool {<br/> if low &gt; high {<br/>  return false;<br/> } else {<br/>  let mut mid = low + (high-low)/2;<br/>  if search_key == vec[mid] {<br/>   return true;<br/>  }</span><span id="15bf" class="nq kh it oh b gy op om l on oo">  if search_key &lt; vec[mid] {<br/>   return binary_search_rec(low, mid-1, search_key, vec);<br/>  } else {<br/>   return binary_search_rec(mid+1, high, search_key, vec);<br/>  }<br/> }<br/>}</span></pre><p id="7f90" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">运行递归</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="51ce" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">fn </strong>main() {<br/> let mut rng = thread_rng();<br/> let mut int_vec = Vec::new();<br/> let max_num = 901;</span><span id="b06f" class="nq kh it oh b gy op om l on oo"> for num in 1..max_num {<br/>  int_vec.push(num as i32);<br/> }</span><span id="f7ad" class="nq kh it oh b gy op om l on oo"> start = Instant::now();<br/> let result = binary_search_rec(0,int_vec.len()-1,789,&amp;mut int_vec);<br/> println!(“It took: {} to search”, TimeFormat(start.elapsed()));<br/>}</span></pre><p id="b98c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated"><strong class="lg iu">性能递归</strong></p><p id="3f2c" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在900的数据大小中搜索数字789估计花费了<strong class="lg iu">620纳秒</strong>或<strong class="lg iu"> 0.00062毫秒</strong>。</p><h1 id="a59c" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">思想</h1><p id="ae32" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">总而言之，</p><ul class=""><li id="f23d" class="nc nd it lg b lh mc ll md lp ne lt nf lx ng mb nh ni nj nk bi translated">线性迭代搜索(Python)估计花费了<strong class="lg iu"> 0.024毫秒</strong></li><li id="c24c" class="nc nd it lg b lh nl ll nm lp nn lt no lx np mb nh ni nj nk bi translated">线性递归搜索(Python)估计花费了<strong class="lg iu"> 0.187毫秒</strong></li><li id="2684" class="nc nd it lg b lh nl ll nm lp nn lt no lx np mb nh ni nj nk bi translated">线性迭代搜索(Rust)估计花费了<strong class="lg iu"> 0.04255毫秒</strong></li><li id="96c6" class="nc nd it lg b lh nl ll nm lp nn lt no lx np mb nh ni nj nk bi translated">递归线性搜索(Rust)估计花费了<strong class="lg iu"> 0.01539毫秒</strong></li><li id="c9ed" class="nc nd it lg b lh nl ll nm lp nn lt no lx np mb nh ni nj nk bi translated">二分搜索法迭代(Python)耗时估计<strong class="lg iu"> 0.007毫秒</strong></li><li id="5348" class="nc nd it lg b lh nl ll nm lp nn lt no lx np mb nh ni nj nk bi translated">二分搜索法递归(Python)耗时估计<strong class="lg iu"> 0.01毫秒</strong></li><li id="d55b" class="nc nd it lg b lh nl ll nm lp nn lt no lx np mb nh ni nj nk bi translated">二分搜索法迭代(Rust)花费了估计的<strong class="lg iu"> 0.00068毫秒</strong></li><li id="9c72" class="nc nd it lg b lh nl ll nm lp nn lt no lx np mb nh ni nj nk bi translated">二分搜索法递归(Rust)耗时估计<strong class="lg iu"> 0.00062毫秒</strong></li></ul><p id="83d7" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">以下是我从这个实验中得出的想法，二分搜索法无疑比线性搜索快得多。此外，用Rust写二分搜索法，执行速度更快。迭代或递归编写对速度没有太大影响。</p><p id="9df6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在结束之前，我想对我的上一篇文章，<a class="ae kf" href="https://medium.com/@leonardyeo_xl/evaluating-performance-on-classic-sorting-algorithms-in-python-and-rust-76f981dfc0c" rel="noopener">https://medium . com/@ leonardyeo _ XL/evaluating-performance-on-classic-sorting-algorithms-in-python-and-rust-76f 981 DFC 0 c，</a>进行一个简短的介绍，如果你对性能评估之类的东西感兴趣的话。</p><div class="mh mi gp gr mj mk"><a href="https://www.eduelk.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">教育</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">通过我们的练习题为您的下一次技术认证考试树立信心。我们提供课程来加速…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.eduelk.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my jz mk"/></div></div></a></div><div class="mh mi gp gr mj mk"><a href="https://www.eduelk.com/about-us" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">关于我们——教育</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">在爱德克教育，我们相信熟能生巧。我们知道准备参加技术认证是…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.eduelk.com</p></div></div><div class="mt l"><div class="mz l mv mw mx mt my jz mk"/></div></div></a></div><div class="mh mi gp gr mj mk"><a href="https://www.eduelk.com/shop-for-practice-questions" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">通过我们负担得起的练习题获得自信——教育</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">编辑描述</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.eduelk.com</p></div></div><div class="mt l"><div class="na l mv mw mx mt my jz mk"/></div></div></a></div><div class="mh mi gp gr mj mk"><a href="https://www.eduelk.com/book-a-lesson" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd iu gy z fp mp fr fs mq fu fw is bi translated">联系方式1——教育</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">编辑描述</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">www.eduelk.com</p></div></div><div class="mt l"><div class="nb l mv mw mx mt my jz mk"/></div></div></a></div></div></div>    
</body>
</html>