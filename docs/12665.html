<html>
<head>
<title>Go Project Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">转到项目结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-project-structure-5157f458c520?source=collection_archive---------2-----------------------#2022-06-28">https://levelup.gitconnected.com/go-project-structure-5157f458c520?source=collection_archive---------2-----------------------#2022-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ddd18a44e2542ad0ce7308cc5b02c3ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fVWC6_ULfLU3TIYi"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Maksym Kaharlytskyi 在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="2d5d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一个大项目中组织go代码可能很难。<a class="ae jd" href="https://go.dev/blog/package-names" rel="noopener ugc nofollow" target="_blank"> Go的标准包命名约定</a>很棒，但是例子过于简单，更多的是与库代码相关。有这么多公司使用Go作为他们的后端，我很惊讶在一个大的服务器项目中，包/文件夹组织的例子如此之少。在<a class="ae jd" href="https://www.tonal.com/" rel="noopener ugc nofollow" target="_blank"> Tonal </a>，我们有一个支持许多微服务的monorepo，经过过去四年的多次迭代，我认为我们终于有了一个良好的基本结构，它将很好地服务于我们的未来。Tonal生产一种连接的力量训练设备，所以我的业务逻辑示例将与锻炼相关。</p><p id="160b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有大约40个微服务，每个微服务都有特定于它们支持的API的相关业务逻辑。为了将这些组织在一起，服务编译单元被放在我们根目录下的一个<code class="fe lb lc ld le b">cmd</code>子目录中。每个服务目录遵循模式<code class="fe lb lc ld le b">{serviceName}-service</code>。这不是一个有效的包名，因为这个文件夹只包含使用主包的<code class="fe lb lc ld le b">main.go</code>。我们有一个约定，所有服务都应该从这里开始本地开发，只有<code class="fe lb lc ld le b">go run main.go</code>。这个目录也有非go服务特定的设置，比如用于Kubernetes配置的<code class="fe lb lc ld le b">Dockerfile</code>和<code class="fe lb lc ld le b">k8s</code>目录。<br/> <br/>服务目录还有一个<code class="fe lb lc ld le b">app</code>包，负责服务配置和启动。这个包在所有的微服务中都有一个通用的名称，为初始化依赖关系和注册服务支持的路由提供一个通用的起点。它还保持了<code class="fe lb lc ld le b">main.go</code>的紧凑性，因为大多数初始化都在服务应用包中。拥有这些的静态命名约定允许使用我们的标准引导和CI/CD配置生成新服务的代码。</p><p id="a12f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初，在每个服务目录中，我们有一个包含API处理程序的<code class="fe lb lc ld le b">controllers</code>目录，通常还有一个包含数据库访问代码的<code class="fe lb lc ld le b">repos</code>目录。我现在认为这个会议是个错误。随着代码的增长，这些目录变得越来越大，我觉得它们现在太通用了，就像通用的<code class="fe lb lc ld le b">utils</code>包一样，严重混淆了关注点。我的一个同事提出了一个更好的解决方案。他创建了基于功能而不是通用角色的包。</p><p id="b909" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="d28b" class="ln lo jg le b gy lp lq l lr ls">controllers/<br/>    workouts.go<br/>repos/<br/>     workouts.go</span></pre><p id="91d5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">执行以下操作:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a2c6" class="ln lo jg le b gy lp lq l lr ls">workouts/ <br/>    controllers.go<br/>    repos.go</span></pre><p id="8ebe" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一更改在文件浏览级别给出了完全相同的信息，但它使代码更简单，因为没有通用的包前缀。例如，从控制器包中调用的回购方法<code class="fe lb lc ld le b">FetchWorkout</code>可能是<code class="fe lb lc ld le b">repos.FetchWorkout</code>，但当代码在同一个包中时，它只是<code class="fe lb lc ld le b">FetchWorkout</code>。这更符合围棋的习惯。通常，以这种方式组织的代码只在包内使用，不需要导出，这使得修改更容易。</p><p id="7f40" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何跨服务共享的代码都会根据功能放入根的顶层包中。这些包中的大多数都有特定于我们公司的业务逻辑或特性的名称，例如:<code class="fe lb lc ld le b">workouts</code>、<code class="fe lb lc ld le b">weights</code>和<code class="fe lb lc ld le b">leaderboard</code>。其他的是特定的实用程序包，如<code class="fe lb lc ld le b">service</code>，它提供了用于启动微服务和向标准监控和中间件注册API端点的通用实用程序。其他例子有<code class="fe lb lc ld le b">response</code>，它包含标准API响应的帮助器，以及<code class="fe lb lc ld le b">pg</code>，它允许我们的postgresql DB连接的通用配置。</p><p id="3429" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于微服务，我们需要共享客户端来调用其他服务。这意味着我们通常在顶层有与包含客户端代码的服务名称相匹配的包。这是将服务目录下推到<code class="fe lb lc ld le b">cmd</code>目录以最小化导航混乱的一个重要原因。我们有一个政策，任何服务都不能从另一个服务导入包，所以如果任何代码需要共享，它必须被提升到顶级目录中。</p><p id="602d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是我们顶级git回购的完整示例:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="fcc4" class="ln lo jg le b gy lp lq l lr ls">cmd/<br/>    workouts-service/<br/>        main.go<br/>        app/         // service setup<br/>            setup.go<br/>        workouts/    // business logic<br/>            controller.go<br/>            repo.go<br/>            <br/>        k8s/         // kubernetes config<br/>        Dockerfile    // deployment packaging<br/>    media-service/<br/>        ...          // same layout as workouts-service<br/>workouts/            // business logic shared lib<br/>    client.go<br/>    models.go<br/>response/           // generic shared lib<br/>    errors.go<br/>pg/                 // generic shared lib<br/>    connection.go</span></pre><p id="659a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种组织是简单的，并且是有意扁平的，以去除不必要的目录分类(no <code class="fe lb lc ld le b">pkg</code> dir)。我认为许多公司可能会使用类似的结构，但我认为每个公司的项目看起来会非常不同。层次结构中很少有静态名称，遵循这种方法需要根据您的业务逻辑选择好的名称。</p><p id="b5c8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">交流可以跨问题域使用的静态名称要比交流特定于应用程序的好名称容易得多。Ruby on Rails使用类似于<code class="fe lb lc ld le b">models</code>或<code class="fe lb lc ld le b">controllers</code>的文件夹名。我们在早期使用了这种方法，但是由于代码中使用包名的方式，它很快变得非常混乱。它还将域与代码混合在一起，将不同的特性混合在一起。使用通用的包名最终会变成样板文件，传达的信息很少。这里使用的唯一通用包是<code class="fe lb lc ld le b">app</code>包，它只在<code class="fe lb lc ld le b">main.go</code>中使用，所以不会浪费业务逻辑代码。</p><p id="888e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">甚至我在这篇文章中使用的例子也不是真实的，因为实际的名字是如此的领域特定，以至于不被广大读者所理解。我很幸运，我开发的产品大多数人都不知道什么是锻炼。每个开发人员最了解他们公司的领域，应该在结构中选择反映这些问题的名称。</p><p id="e095" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果其他人已经找到了组织他们的服务器Go代码的好方法，我很乐意在评论中听到。</p></div></div>    
</body>
</html>