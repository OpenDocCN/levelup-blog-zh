<html>
<head>
<title>Go faster than navigation with Angular resolvers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用角度解算器比导航更快</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-faster-than-navigation-with-angular-resolvers-1ab77de8f834?source=collection_archive---------8-----------------------#2020-07-02">https://levelup.gitconnected.com/go-faster-than-navigation-with-angular-resolvers-1ab77de8f834?source=collection_archive---------8-----------------------#2020-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/45fcb435c05c99f082b2bc7900c1d8e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*6AM2ggJ-9ycAcNKv.jpg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图片来源:Freepik</figcaption></figure><p id="b853" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我记得第一次读到角旋变器时，它们听起来很酷。让路由器预取数据？是的，请！但是当我试图跟随Angular网站上的<a class="ae kz" href="https://angular.io/guide/router#resolve-pre-fetching-component-data" rel="noopener ugc nofollow" target="_blank">教程时，我有点迷路了。</a></p><p id="da30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然作者在分解所有内容方面做得非常出色，但我还是不断遇到null injector错误，因为当你从一个延迟加载的库到另一个库，而不是直接从一个模块到你的应用程序时，情况会有所不同。你真的需要了解路由器<a class="ae kz" href="https://www.smashingmagazine.com/2018/11/a-complete-guide-to-routing-in-angular/" rel="noopener ugc nofollow" target="_blank">、激活路由和路由器状态</a>之间的区别，才能真正体会角度解析器有多酷。</p><h1 id="ff8c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是角分解器？</h1><p id="be3b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">想象一个有角度的管道，但是你在页面加载之前就使用它了！这意味着您可以转换或获取数据，而不必订阅激活的路由！换句话说，不用再等了！</p><p id="239b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解析器可以极大地增强你的应用或网站体验，因为它们在用户决定导航到某个地方的那一刻就开始了。事实上，在解析器完成之前，页面甚至不会加载。因此，你不必与比赛条件争夺，可以为他们到来时做好准备。</p><p id="16da" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请记住，我们谈论的是毫秒，所以不要太疯狂。以下是我开始着手的一些用例:</p><ol class=""><li id="7620" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">生成和更新元标签</li><li id="8076" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">获取博客文章</li><li id="15cc" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">抓取动态参数进行搜索查询</li><li id="92b1" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">基于您的路由模块创建导航菜单</li></ol><h1 id="c08d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">它们是如何工作的？</h1><p id="6e56" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">想象一下，让一个完全独立的服务存在于你的模块之外，就好像它实际上在你的模块之内一样。它使用ActivatedRouteSnapshot和RouterStateSnapshot作为其resolve方法的参数，这样它就可以使用您通过ActivatedRoute和RouterState获得的完全相同的路由数据来向您发送数据。</p><p id="e207" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，它已经为您准备好了数据，而不是订阅路由事件！您所要做的就是向路由模块添加额外的参数，就像处理路径、组件和数据一样。因此，在同一级别上，只需添加一个resolve参数，说明使用什么键以及哪个解析器应该提供数据。然后，获取激活路线的快照以检索数据。</p><h1 id="b1e3" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">能给我举个端到端的例子吗？</h1><p id="1fc5" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">当然可以！不久前，我给<a class="ae kz" href="https://medium.com/swlh/how-to-create-a-self-updating-navigation-menu-in-angular-d90ef1b7acf5" rel="noopener">写了一篇关于创建自我更新导航菜单</a>的文章。虽然我很喜欢在一个地方更新路线和元信息，但我不喜欢创建多个菜单，即使这样做非常简单快捷。</p><p id="b51f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，为了创建导航菜单，我可以将以下内容添加到我的路由模块中:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e7c6" class="na lb it mw b gy nb nc l nd ne">resolve: { <br/>    displayTitle: MetaTagsResolverRouteDataService, <br/>    menu: ResolveMenuService <br/>},</span></pre><p id="fb2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意:“显示标题”和“菜单”是任意值，仅在此处声明。当需要查找您的路线数据时，它们将被用作密钥。</strong></p><p id="28fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以选择在模块、路由或组件级别使用解析器。请记住，如果您将它提供给父路由，它的所有子路由都可以轻松访问它。但是，您可能需要记住，每当用户导航到该路线时，它都会触发。</p><p id="1b8a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> demos-routing.module.ts </strong></p><p id="c085" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我将数据添加到路由模块，以指定使用什么值。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="03f4" class="na lb it mw b gy nb nc l nd ne"> { <br/>   path: 'select-menus', <br/>   component: DemoSelectMenusComponent, <br/>   data: { <br/>      title: 'Select Menus', <br/>      description: "Cloud engineering demo of customizable select menus", <br/>      menu: { icon: 'dropdown', label: 'Select Menus', show: true, activeSelfOnly: true, <br/>            }, <br/>        }, <br/> },</span></pre><p id="146c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> resolve-menu.service.ts </strong></p><p id="3039" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我的解析器超级简单。它只是解析出构建导航菜单所需的数据并将其返回。</p><p id="8954" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">需要注意的一点是，根据您设置路线的方式，可能存在父/子层级。我的菜单几乎总是在父级，因为我希望它们出现在属于它们库的每个页面上。您可以使用Angular的路由器插座创建布局一致的特定于库的模板。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="41fa" class="na lb it mw b gy nb nc l nd ne">import { Injectable } from '@angular/core';<br/>import { Resolve, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';<br/>import { ResolveMenu } from './menus';<br/>import { Observable } from 'rxjs';</span><span id="05dd" class="na lb it mw b gy nf nc l nd ne">@Injectable({<br/>   providedIn: 'root'<br/>})</span><span id="165b" class="na lb it mw b gy nf nc l nd ne">export class ResolveMenuService implements Resolve&lt;ResolveMenu[]&gt; {</span><span id="781d" class="na lb it mw b gy nf nc l nd ne">    constructor() { }</span><span id="a074" class="na lb it mw b gy nf nc l nd ne">    resolve(<br/>         route: ActivatedRouteSnapshot,<br/>         state: RouterStateSnapshot<br/>         ): ResolveMenu[] | Observable&lt;ResolveMenu[]&gt; {</span><span id="35a3" class="na lb it mw b gy nf nc l nd ne">                 let menu: ResolveMenu[] = [];<br/>                 <br/>                 route.routeConfig.children.map(child =&gt; {<br/>                        if (child.data.menu)<br/>                            menu.push({<br/>                                 path: child.path,<br/>                                 show: child.data.menu.show,<br/>                                 activeSelfOnly: child.data.menu.activeSelfOnly,<br/>                                 title: child.data.title,<br/>                                 label: child.data.menu.label,<br/>                                 icon: child.data.menu.icon<br/>                            })<br/>                  })</span><span id="ceed" class="na lb it mw b gy nf nc l nd ne">                 return menu;</span><span id="f252" class="na lb it mw b gy nf nc l nd ne">           }</span><span id="e1d6" class="na lb it mw b gy nf nc l nd ne">}</span></pre><p id="54ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> menus.demo.component.ts </strong></p><p id="cf39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，为了查看解析后的数据，我可以这样调用它:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="0e8d" class="na lb it mw b gy nb nc l nd ne">import { Component, OnInit } from '@angular/core'; <br/>import { ActivatedRoute } from '@angular/router'; <br/>import { ButtonRoute } from 'projects/buttons/src/public-api'; </span><span id="44ac" class="na lb it mw b gy nf nc l nd ne">@Component({ <br/>    selector: 'ces-demos-menu', <br/>    templateUrl: './demos-menu.component.html', <br/>    styleUrls: ['./demos-menu.component.scss'] <br/>}) </span><span id="c109" class="na lb it mw b gy nf nc l nd ne">export class DemosMenuComponent implements OnInit { </span><span id="ceb7" class="na lb it mw b gy nf nc l nd ne">     buttons: ButtonRoute[] = []; </span><span id="f059" class="na lb it mw b gy nf nc l nd ne">     constructor( private route: ActivatedRoute, ) {} </span><span id="875c" class="na lb it mw b gy nf nc l nd ne">     ngOnInit(): void { this.buttons = this.route.snapshot.data.menu; </span><span id="00c5" class="na lb it mw b gy nf nc l nd ne">     } <br/>}</span></pre><p id="24bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解析的数据存储在ActivatedRouteSnapshot和RouterStateSnapshot中。只需查找您在指定路线时添加的任何键，它将以JSON格式提供。</p><p id="7461" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">demos-menu.component.html</strong></p><p id="eb10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了呈现菜单，我只需将this.buttons值传递给我为处理路由而创建的按钮路由组件:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4c07" class="na lb it mw b gy nb nc l nd ne">&lt;nav&gt;<br/>  &lt;ces-button-route *ngFor="let button of buttons" [link]="button.path" [title]="button.title" [label]="button.label" [icon]="button.icon" [activeSelfOnly]="button.activeSelfOnly" class="nav-button"&gt;<br/>  &lt;/ces-button-route&gt;<br/>&lt;/nav&gt;</span></pre><p id="8637" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">瞧，这是<a class="ae kz" href="https://cloudengineering.studio/demos" rel="noopener ugc nofollow" target="_blank">导航菜单在起作用</a>。我通常会把它隐藏起来，因为一个项目有一个导航菜单看起来很傻，但现在我会把它保留下来，以防你想看一眼。这样，将来每当我在这个部分添加另一个演示时，菜单就会自动创建。</p><p id="c714" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想一起看所有的文件，这里有Github列表。</p><h1 id="4a54" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">需要注意的事项</h1><h1 id="9d48" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">循环引用</h1><p id="e903" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">不能在将使用解析器的同一个库/模块中构建解析器。同样，不能使用库/模块内部的服务，也不能将解析器放在目标库使用的同一个库中。这将创建一个循环参考和Angular是足够聪明的让你知道。</p><p id="2c80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我为我的博客服务创建了一个数据库来获取文章。我无法将解析器放入这两个库中，也无法使用博客服务来获取文章。因此，我将我的解析器放在一个路由库中，该库使用数据服务来获取文章。</p><p id="56d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">无论如何，最好的做法是让所有事情都朝着一个方向进行，以免导致不必要的依赖。</p><h1 id="7e73" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">没有提供程序错误</h1><p id="bf93" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">记住，解析器就像一条浮动的路线。因此，如果您希望在用户导航到某个路线之外使用解析器，请传入ActivatedRoute和RouterState，而不是ActivatedRouteSnapshot和RouterStateSnapshot。</p><p id="8204" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望你喜欢这篇文章。感谢阅读！</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="a17f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nn">最初发布于</em><a class="ae kz" href="https://cloudengineering.studio/articles/go-faster-than-navigation-with-angular-resolvers" rel="noopener ugc nofollow" target="_blank"><em class="nn">https://cloud engineering . studio</em></a><em class="nn">。</em></p></div></div>    
</body>
</html>