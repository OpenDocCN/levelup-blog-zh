<html>
<head>
<title>How to build a (simple) blog using Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Rust建立一个(简单的)博客</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-simple-blog-using-rust-54cdee8541c0?source=collection_archive---------0-----------------------#2022-08-30">https://levelup.gitconnected.com/how-to-build-a-simple-blog-using-rust-54cdee8541c0?source=collection_archive---------0-----------------------#2022-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2c602e77e3653d6f57665392c0c2865b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3GP8bJqCqRANlIPZrs6OlA.png"/></div></div></figure><p id="0385" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，你已经阅读了rust很长一段时间，在Stack Overflow的年度调查中了解到它连续多年是最受欢迎的编程语言，你想加入。但是，你不是系统级的程序员，Reddit一直告诉你“使用正确的工具来完成工作”，“rust旨在编写数据库和编写无人机之类的低级东西”(第一条实际上是个好建议，我只是需要它来创建一个戏剧性的设置)。所以你心灰意冷，选择用你一直用的。我认为这是一个错误，因为无论是从执行速度还是开发者体验来看，rust都是一种令人惊叹的语言。没有多少语言能给你一个方便的配对程序员，即编译器，它只会给出好的建议，并在此期间闭嘴(rust的编译器太棒了)。</p><p id="3f73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重写的目标是把<em class="kw">的一些东西</em>拿出来，作为学习的例子，并在此基础上进一步加深我对语言的理解。我希望这篇文章对你也一样。</p><p id="26cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">旁注</em>:我以写Go为生，过去5年来一直从事专业编码工作，所以尽管我对自己的整体技能很有信心，但本教程可能并不总是展示惯用的Rust和最佳实践。有一群比我更容易生锈的开发人员已经写了一些很棒的材料，其中大部分为我将要向您展示的内容奠定了基础。在本文的最后，您将找到一个资源列表，在阅读完本文(希望能够一起编码)后，您可以查看该列表。</p><p id="6df0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有任何问题或意见，请随时在Twitter上联系我。</p><h1 id="066d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">开始做事</h1><p id="72a3" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">因此，要使用Rust创建你的新博客，你需要在你的系统上安装Rust，然后运行<code class="fe mb mc md me b">cargo new awesome-blog</code>。然后运行<code class="fe mb mc md me b">cd awesome-blog</code>进入目录，打开<code class="fe mb mc md me b">Cargo.toml</code>，在<code class="fe mb mc md me b">[dependencies]</code>下添加以下内容:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="c742" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请随意使用上述版本之外的其他版本；这是我写这篇文章时用的。</p><p id="397f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我简单介绍一下其中的一些库。这里最主要的是actix-web，它是Rust web框架中最大的玩家之一。还有其他多种选择(例如参见<a class="ae kx" href="http://localhost:8191/page/insert-warp-link" rel="noopener ugc nofollow" target="_blank"> warp </a>、<a class="ae kx" href="http://localhost:8191/page/insert-rocket-link" rel="noopener ugc nofollow" target="_blank"> rocket </a>、<a class="ae kx" href="http://localhost:8191/page/insert-link-here" rel="noopener ugc nofollow" target="_blank"> axum </a>)，但是我非常喜欢Actix的API，并且已经使用它构建了多个项目。此外，它的性能非常好，可以处理很多请求。</p><p id="a803" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来是<code class="fe mb mc md me b">serde</code>,如果你做过Rust编程，你很可能对这个库很熟悉。如果没有，它基本上是一组有效和通用地序列化和反序列化数据结构的方法。如果你找不到你想要的数据结构的实现，你只需要为你的数据结构实现<a class="ae kx" href="https://serde.rs/custom-serialization.html" rel="noopener ugc nofollow" target="_blank">方法</a>，你就可以开始比赛了。对于这个项目来说，<code class="fe mb mc md me b">serde</code>将被用来把一篇博客文章的元数据从一个<code class="fe mb mc md me b">.toml</code>文件序列化为一个Rust结构。</p><p id="58e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我想提一下<code class="fe mb mc md me b">tera</code>，它是我在这个博客中使用的模板引擎。它的灵感来自Jinja2，如果你曾经用<code class="fe mb mc md me b">Django</code>做过网络开发，你可能会很熟悉它。过去，我开始使用<code class="fe mb mc md me b">Django</code>构建web应用程序，非常喜欢它的模板化方式，所以想在我的个人项目中复制这种体验。在这个世界上，一切都是组件，最轻微的重复都是死罪，使用“老派”模板的经历是一种解脱。</p><h1 id="20de" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">简单的服务器</h1><p id="84bb" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">开箱后，在运行<code class="fe mb mc md me b">cargo new awesome-blog</code>之后，您应该能够打开<code class="fe mb mc md me b">src/main.rs</code>并看到如下内容:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0e19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行命令:<code class="fe mb mc md me b">cargo run</code>将在你的终端中输出经典的<code class="fe mb mc md me b">Hello, world!</code>。我们将把<code class="fe mb mc md me b">main.rs</code>作为我们应用程序的瘦入口点，这基本上意味着它应该做一些高级配置和调用启动功能。根据这一要求，我们最终会得到这样的结果:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7b15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了一堆错误之外，这里没发生什么，所以让我们快速分解一下:</p><ul class=""><li id="6dc9" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">我们设置了一个env变量<code class="fe mb mc md me b">RUST_LOG</code>,它决定了我们要输出哪种日志语句</li><li id="12a0" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">我们初始化一个使用env变量配置的简单记录器</li><li id="2055" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">我们创建一个监听端口<code class="fe mb mc md me b">8080</code>的监听器</li><li id="8b07" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">我们将监听器传递给<code class="fe mb mc md me b">start_blog</code>，然后我们开始比赛</li></ul><p id="f8f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们稍后将处理<code class="fe mb mc md me b">start_blog</code>，这意味着唯一没有处理的是<code class="fe mb mc md me b">#[axtic_web::main]</code>。这是一个宏，或者更准确地说，是一个为我们生成一些代码的<code class="fe mb mc md me b">proc_macro</code>，让我们的<code class="fe mb mc md me b">awesome_blog</code>异步运行。团队做出了一个明智的决定，不在标准库中提供异步运行时，而是选择提供essentials，让社区来完成剩下的工作。原因是多方面的，但其中一个原因可能是对于这样的运行时应该是什么样子还没有达成共识。该主题也超出了本文的范围；你只需要知道它为我们生成代码，这使得异步运行时成为可能。</p><h1 id="ebea" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">剥离这些层</h1><p id="a5a2" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们需要处理<code class="fe mb mc md me b">start_blog</code>函数，所以在<code class="fe mb mc md me b">src</code>下创建一个名为<code class="fe mb mc md me b">lib.rs</code>的新文件并打开它。我们将逐步构建它，从添加运行<code class="fe mb mc md me b">HttpServer</code>所需的代码开始:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a1e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我们做的不仅仅是创建一个<code class="fe mb mc md me b">HttpServer</code>。我们还添加了在<code class="fe mb mc md me b">main.rs</code>中定义的记录器，并创建了一个路由，基本上是pings回一个<code class="fe mb mc md me b">200 Ok</code>响应。</p><p id="a165" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的大部分代码对你来说应该是有意义的(假设你熟悉<code class="fe mb mc md me b">rust</code>)，但是让我们快速接触一下<code class="fe mb mc md me b">move</code>关键字。根据文档:<code class="fe mb mc md me b">move</code>将通过引用或可变引用捕获的任何变量转换为通过值捕获的变量。如果你对上面的陈述有点困惑，加入这个俱乐部吧。但是，它可以被分解成一个更容易理解的句子(至少对我来说)。归结起来就是<code class="fe mb mc md me b">rust</code>的所有权模型以及它如何处理内存分配和引用。我们在这条线<code class="fe mb mc md me b">HttpServer::new( move || { App::new() })</code>中看到的是一个闭包，闭包可能会<a class="ae kx" href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/" rel="noopener ugc nofollow" target="_blank">转义</a>。简而言之，<code class="fe mb mc md me b">actix_web</code>将加速你的应用程序的多个实例，假设是多线程环境，所以传递给<code class="fe mb mc md me b">App::new()</code>的变量/值可能比<code class="fe mb mc md me b">App</code>活得长，也就是说闭包可能会逃逸。这将留下悬而未决的引用，而这些引用并没有被考虑太多，这在<code class="fe mb mc md me b">rust</code>中是不好的。因此，为了解决这个问题，我们告诉<code class="fe mb mc md me b">App</code>获取传递给它的值的所有权，这样每个实例拥有传递给它的值。</p><p id="6590" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管我们在这里有点“老派”，使用纯简单的html，我们仍然希望有一些可重用性。这正是<code class="fe mb mc md me b">tera</code>的用武之地。然而，因为一旦我们将模板放入prod，它们将保持不变，所以只加载一次然后传递一个引用可能是个好主意。为此，我们将使用<code class="fe mb mc md me b">lazy_static!</code>，继续将以下内容添加到您的<code class="fe mb mc md me b">lib.rs</code>:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5168" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一切都好，但缺少一件事。我们需要在根目录中添加一个模板目录，所以继续操作<code class="fe mb mc md me b">mkdir templates</code>。我们将很快回到<code class="fe mb mc md me b">main.rs</code>、<code class="fe mb mc md me b">lib.rs</code>等，但是现在，让我们快速地接触一下模板，这样我们就有东西可以展示了。</p><h1 id="9ea0" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">伙计，部件在哪里？</h1><p id="1c39" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我的第一份工作是前端开发人员，我从<code class="fe mb mc md me b">react</code>开始做起。当时组件风靡一时(现在仍然如此，但这让我听起来更老更明智了)，这也是我开始考虑UI元素的原因。在这一点上，我已经改变了我的想法，但那将是另一篇文章。如你所知，我们在这里不做组件，而是做<code class="fe mb mc md me b">partials</code>和<code class="fe mb mc md me b">blocks</code>，所以在你的<code class="fe mb mc md me b">templates</code>目录中，创建一个名为<code class="fe mb mc md me b">base.html</code>的文件:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ed49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以上是我们做其他事情的基础。</p><p id="d080" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要让我们扩展<code class="fe mb mc md me b">base.html</code>(或者说，继承……)的部分就是这个<code class="fe mb mc md me b">{% block content %}{% endblock content %}</code>。让我们看看这是如何做到的，所以继续在<code class="fe mb mc md me b">templates</code>下创建一个名为<code class="fe mb mc md me b">home.html</code>的新文件:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="1910" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，注意顶部的<code class="fe mb mc md me b">{% extends "base.html" %}</code>。这让我们可以与在<code class="fe mb mc md me b">base.html</code>模板中创建的所有<code class="fe mb mc md me b">blocks</code>进行交互。此外，我们在标记中有一个for循环:<code class="fe mb mc md me b">{% for frontmatter in posts %}</code>。我们可以在将html作为对<code class="fe mb mc md me b">http://awesomeblog.com/</code>的响应的一部分时将数据作为变量传递，在上面的例子中，它将返回一个名为<code class="fe mb mc md me b">posts</code>的变量，这是一个posts数组。</p><p id="c0a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您现在尝试运行应用程序，不会有太大的不同，所以让我们实现一些处理程序/控制器/等等来实际服务一些html！</p><h1 id="07a5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">控制器/处理器层</h1><p id="5ed4" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">现在我们进入了这个东西的实际内容，并开始编写一些实际的<code class="fe mb mc md me b">Rust</code>代码！</p><p id="bb3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要一些东西来开始，所以继续在<code class="fe mb mc md me b">src</code>下创建一个名为<code class="fe mb mc md me b">handlers</code>的新文件夹。在这个容器中，创建一个名为<code class="fe mb mc md me b">mod.rs</code>和<code class="fe mb mc md me b">home_handler.rs</code>的文件。让我们从一些简单的测试数据开始，在加载主页时展示一些东西。打开<code class="fe mb mc md me b">home_handler.rs</code>并添加以下内容:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4bb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你读过《T21》这本书，大部分内容对你来说应该是有意义的。</p><p id="7261" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果没有，让我们快速浏览一下。我们创建一个结构，并从标准库<code class="fe mb mc md me b">serde</code>中派生出一些方法(在<code class="fe mb mc md me b">Frontmatter</code>之上的<code class="fe mb mc md me b">#[derive()]</code>)。接下来，我们通过<code class="fe mb mc md me b">tera</code>创建一个上下文。还记得我们讨论过如何通过我们的处理程序向模板提供数据吗？我们就是这么做的。然后我们简单地在上下文中调用<code class="fe mb mc md me b">.insert()</code>，提供变量名和数据，我们就可以开始了。在函数的返回部分，我们放入了<code class="fe mb mc md me b">impl Responder</code>，所以我们只需要返回<em class="kw">一些实现<code class="fe mb mc md me b">Responder</code>的东西</em>。恰好<code class="fe mb mc md me b">HttpResponse</code>实现了<code class="fe mb mc md me b">Responder</code>，所以剩下要做的就是从<code class="fe mb mc md me b">tera</code>中取出正确的模板。由于<code class="fe mb mc md me b">template.render()</code>可能会失败，我们提供了一个备份，不可否认，现在有点懒，但我们总是可以回来改进这一点。最后，您可能想知道我们实际上如何访问我们在处理程序中引用的模板<code class="fe mb mc md me b">templates: web::Data&lt;tera::TerA&gt;</code>。</p><p id="51c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Actix有一种通过<code class="fe mb mc md me b">App::app_data</code>和<code class="fe mb mc md me b">struct Data&lt;T: ?Sized&gt;(_)</code>类型共享数据的简洁方式。通过将包装在<code class="fe mb mc md me b">web::Data::new</code>中的传递给<code class="fe mb mc md me b">App.app_data</code>(附注:我们可以通过将<code class="fe mb mc md me b">web::Data::clone</code>传递给<code class="fe mb mc md me b">app_data</code>而不是<code class="fe mb mc md me b">web::Data::new</code>来改进这一点，只需在<code class="fe mb mc md me b">web::Data::new</code>中包装一次我们的数据，并简单地传递对<code class="fe mb mc md me b">web::Data::copy</code>中数据的引用。这是因为<code class="fe mb mc md me b">Data</code>在内部使用<code class="fe mb mc md me b">Arc</code>，这使得克隆它非常便宜)我们现在可以在你的处理程序中提取它！</p><p id="c3ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在我们可以访问我们新的闪亮处理程序之前，我们需要使它可访问，因此打开<code class="fe mb mc md me b">src/handlers</code>下的<code class="fe mb mc md me b">mod.rs</code>:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="70c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只需要添加一个路由，这样我们就可以为用户提供内容。打开<code class="fe mb mc md me b">main.rs</code>并添加以下内容:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0639" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">旋转一下，你应该会看到(一个相当难看的)有你的博客文章的网页！</p><h1 id="8d42" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">静态资产和阻力最小的路径</h1><p id="f5df" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">当我们设置html模板的时候，你可能已经注意到了看起来像是<code class="fe mb mc md me b">tailwindcss</code>类的东西，然后很快就想知道它在主页上有什么样的最终结果。首先，很高兴你选择了优秀的前端工具。其次，我们还没有包含样式实际执行某些操作所需的css。</p><p id="b200" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你检查<code class="fe mb mc md me b">base.html</code>，你会看到这一行:<code class="fe mb mc md me b">&lt;link rel="stylesheet" type="text/css" href="/static/css/index.css"&gt;</code>，它暗示我们需要在<code class="fe mb mc md me b">static</code>中有一个<code class="fe mb mc md me b">css</code>文件夹。现在，我们可以通过多种方式来实现这一点，这取决于我们期望获得什么样的流量，以及我们计划如何(过度)实现这一点。</p><p id="57bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一种选择是通过S3桶提供<code class="fe mb mc md me b">index.css</code>的内容，然后直接指向一个URL，这个URL在这里被引用。这肯定会使生成的二进制文件更小，但它确实会增加一些现在并不真正需要的开销(更复杂的CI/CD流，处理开发和生产中的各种路径等)。另一个选择(我们正在做的)是把它作为整个二进制文件的一部分添加进去。</p><p id="59cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在它让事情变得简单，如果我们的博客取得巨大成功，我们很可能会担心这一点。所以，在根目录下创建两个新文件夹，即<code class="fe mb mc md me b">static</code>和其下的<code class="fe mb mc md me b">css</code>。接下来，我们需要做一些顺风设置，你可以在他们自己的网站上找到，为了方便起见，这里是你可以在你的终端上运行的<code class="fe mb mc md me b">cmd</code>:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="92fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">差不多了，只需再走几步，打开<code class="fe mb mc md me b">tailwind.config.js</code>，复制粘贴以下内容:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="1b3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有两件事，打开<code class="fe mb mc md me b">base.css</code>，复制粘贴以下内容:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="270f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，打开<code class="fe mb mc md me b">package.json</code>并在脚本下添加以下内容:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="dcd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两个脚本基本上给了你一个<code class="fe mb mc md me b">cmd</code>来观察开发中的任何变化，然后在我们合并时为生产而构建。这也意味着您必须记住在合并到<code class="fe mb mc md me b">master</code>之前运行<code class="fe mb mc md me b">build-css-prod</code>。这肯定可以改进，但由于你是这个项目的主要(也是唯一的)开发者，它将很好地满足我们的需求。</p><p id="fc08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步，我们需要让<code class="fe mb mc md me b">actix_web</code>知道我们的静态文件。所以打开<code class="fe mb mc md me b">lib.rs</code>并更新如下:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2219" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只需要构建<code class="fe mb mc md me b">css</code>，因此从根目录运行:<code class="fe mb mc md me b">cd tailwind &amp;&amp; npm run build-css-prod &amp;&amp; cd ..</code>。</p><p id="c6e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，旋转一下<code class="fe mb mc md me b">cargo run</code>,你会看到一个更好看的网站。</p><h1 id="1f79" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">短暂的插曲</h1><p id="78bd" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">目前缺少两样东西:1。一个存储<em class="kw">实际</em>博客文章和2。一个展示帖子所有优点的页面。</p><p id="f68b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从清单上的第二项开始，因为我们已经做了很多。为了不让你对同样的事情厌烦两次，继续打开这个<a class="ae kx" href="https://github.com/MBvisti/awesome-blog/blob/master/templates/post.html" rel="noopener ugc nofollow" target="_blank">链接</a>(链接到带有完整代码的回购协议)，复制内容并在<code class="fe mb mc md me b">templates</code>下创建一个名为<code class="fe mb mc md me b">post.html</code>的新文件。</p><p id="a59c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，转到<a class="ae kx" href="https://github.com/MBvisti/awesome-blog/blob/master/tailwind/base.css" rel="noopener ugc nofollow" target="_blank">这里</a>复制内容并粘贴到您的<code class="fe mb mc md me b">base.css</code>中。如果你做过任何<code class="fe mb mc md me b">css</code>，并且只是在文章页面上应用了一些简单的样式，你应该对这些很熟悉。</p><h1 id="60da" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">像艺术家一样偷窃(或者，模仿比你更聪明的人)</h1><p id="4549" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">一切都已基本完成<em class="kw"/>,我们只需要一种方法来存储我们精彩的博客文章，以及一种方法来检索它们，这样我们就可以删除我们之前做的硬编码。这样做的方法很大程度上受到了另一个比我聪明得多的人写的博客的启发:<a class="ae kx" href="https://fasterthanli.me/" rel="noopener ugc nofollow" target="_blank">faster shanlime</a>如果你还没有看，你绝对应该看看。这家伙很认真地做一些深潜，而且非常了解他的技术。</p><p id="70e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">继续创建一个名为<code class="fe mb mc md me b">posts</code>的新文件夹，与<code class="fe mb mc md me b">static</code>文件夹在同一层。在这个里面，创建另一个文件夹，给它一个像<code class="fe mb mc md me b">my-first-article</code>和<code class="fe mb mc md me b">cd</code>的名字。我用<code class="fe mb mc md me b">markdown</code>写我所有的东西，所以这也是我们在这里要做的。</p><p id="be41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个名为<code class="fe mb mc md me b">post.md</code>的文件，复制粘贴一些lorem ipsum文本(或者你准备的一篇文章)。接下来，创建一个名为<code class="fe mb mc md me b">post_frontmatter.toml</code>的文件，打开它并添加以下内容:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="58d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这看起来可疑地像我们的<code class="fe mb mc md me b">struct Frontmatter {....}</code>，那么是因为它是。</p><p id="abd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个订单业务，添加一些逻辑来提取我们可能有的所有前沿问题，并将其显示在我们的主页上。让我们从获取我们令人敬畏的博客的所有前沿问题的逻辑开始，所以打开<code class="fe mb mc md me b">home_handler.rs</code>并添加以下内容:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="6c58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们将帖子存储为二进制文件的一部分，我们需要一种方法来定位所有帖子的主要内容，为此，我们将使用<code class="fe mb mc md me b">ignore::WalkBuilder</code>。这给了我们一个递归目录迭代器，它有大量的配置，我们可以根据我们想要做的动作类型来设置。在这种情况下，我们希望它在<code class="fe mb mc md me b">posts</code>目录中查找所有带有<code class="fe mb mc md me b">.toml</code>扩展名的文件，它很快就做到了。</p><p id="5508" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里需要注意的一点是，<code class="fe mb mc md me b">find_all_frontmatters</code>返回一个<code class="fe mb mc md me b">Result</code>，因为有些动作可能会失败，这意味着我们也必须处理一些错误。正如你可能知道的，我没有在这个函数的错误上花太多时间，基本上，只是记录来自<code class="fe mb mc md me b">ignore</code>的任何错误，然后从<code class="fe mb mc md me b">std::io::ErrorKind</code>返回最相似的错误。使用像<code class="fe mb mc md me b">anyerror</code>或<code class="fe mb mc md me b">thiserror</code>这样的库肯定可以做得更好。我鼓励你自己尝试一下，或者如果你在这里有所改进<a class="ae kx" href="https://github.com/mbvisti/awesome-blog" rel="noopener ugc nofollow" target="_blank"/>就提出一个拉动请求。</p><p id="b20f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了在主页上实际显示一些动态数据，我们需要在我们的<code class="fe mb mc md me b">index</code>处理程序中使用上述函数，因此打开<code class="fe mb mc md me b">home_handler.rs</code>并进行以下调整:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a64d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">旋转<code class="fe mb mc md me b">cargo run</code>看看结果吧！</p><p id="5d09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后需要做的是为<code class="fe mb mc md me b">post.html</code>页面添加处理程序，提取文章的markdown，将其转换为<code class="fe mb mc md me b">html</code>并提供服务。既然我们已经准备好了<code class="fe mb mc md me b">post.html</code>，继续在<code class="fe mb mc md me b">src/handlers</code>下创建<code class="fe mb mc md me b">post_handler.rs</code>并打开它。我们需要增加两个功能:1 .从一个特定的职位和2。提取帖子的降价信息。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="b146" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里没有太多新东西，只是使用了<code class="fe mb mc md me b">toml::from_str</code>将一个字符串反序列化为一个特定的类型，在这里是:<code class="fe mb mc md me b">Frontmatter</code>。</p><p id="cc45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要做的最后一件事是创建处理程序，并将其作为<code class="fe mb mc md me b">service</code>添加到我们在<code class="fe mb mc md me b">lib.rs</code>中的<code class="fe mb mc md me b">App</code>中，因此将以下内容添加到<code class="fe mb mc md me b">post_handler.rs</code>:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="17b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中大部分都很熟悉，不同之处在于我们为模板提供了两个变量:<code class="fe mb mc md me b">post</code>和<code class="fe mb mc md me b">meta_data</code>。</p><p id="d557" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们需要在<code class="fe mb mc md me b">lib.rs</code>和我们的<code class="fe mb mc md me b">handlers/mod.rs</code>中包含新的处理程序。我会让你决定的！</p><p id="79fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加之后，再旋转一下<code class="fe mb mc md me b">cargo run</code>，你应该可以从主页点击文章，被重定向到文章页面，看到你的文章！</p><h1 id="6dfa" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结束语</h1><p id="5fee" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我希望你喜欢这个演示，并有兴趣用<code class="fe mb mc md me b">rust</code>做更多的web开发，它现在的状态非常好，有一个令人兴奋的未来。是的，开始可能会有点令人沮丧，让你的头脑围绕所有权，借用和参考可能需要一些时间。但我向你保证，这是非常值得的！</p><p id="743d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您得到的编译器错误可能很烦人，但也会引导您走向正确的道路，与类似<code class="fe mb mc md me b">Typescript</code>的东西相比，这是天赐之物。你写得越多，它就变得越容易。</p><p id="df92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它很快成为我编写小服务的首选语言，因为它与<code class="fe mb mc md me b">aws lambda</code>配合得非常好，而且由于它的速度非常快，冷启动甚至不再是一个问题。所以，请拿走你这里有的，想怎么延长就怎么延长。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="5233" class="ky kz iq bd la lb ng ld le lf nh lh li lj ni ll lm ln nj lp lq lr nk lt lu lv bi translated">资源</h1><p id="5dad" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">这里收集了我开始使用<code class="fe mb mc md me b">rust</code>的所有资料。有些是免费的，有些是付费的，但所有这些都是非常值得推荐的，所以我希望你能找到一些进一步的学习！</p><ul class=""><li id="98fb" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated"><a class="ae kx" href="https://www.zero2prod.com/" rel="noopener ugc nofollow" target="_blank">零2产量</a></li><li id="8e1d" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><a class="ae kx" href="https://doc.rust-lang.org/book/title-page.html" rel="noopener ugc nofollow" target="_blank">锈书</a></li><li id="8478" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><a class="ae kx" href="https://fasterthanli.me/articles/a-new-website-for-2020" rel="noopener ugc nofollow" target="_blank">2020年的新网站</a></li><li id="44e9" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><a class="ae kx" href="https://doc.rust-lang.org/stable/rust-by-example/" rel="noopener ugc nofollow" target="_blank">铁锈示例</a></li></ul><p id="db2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原贴于</em><a class="ae kx" href="https://mortenvistisen.com" rel="noopener ugc nofollow" target="_blank">mortenvistisen.com</a></p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="f121" class="ky kz iq bd la lb ng ld le lf nh lh li lj ni ll lm ln nj lp lq lr nk lt lu lv bi translated">分级编码</h1><p id="2306" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="db89" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="3a85" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">📰查看更多内容请参见<a class="ae kx" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="8615" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">🔔关注我们:<a class="ae kx" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kx" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kx" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="c819" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">🚀👉<a class="ae kx" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">加入升级达人集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>