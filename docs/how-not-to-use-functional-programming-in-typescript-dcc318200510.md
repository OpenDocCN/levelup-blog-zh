# 如何在 TypeScript 中不使用函数式编程

> 原文：<https://levelup.gitconnected.com/how-not-to-use-functional-programming-in-typescript-dcc318200510>

在过去的几年里，我深入研究了函数式编程。尽管我在这次旅程中毫发无损，但我一路上学到了很多东西，尤其是当我将它应用到我的 TypeScript 项目中时。今天，我与你分享我的知识；我希望你能从我的成功和失败中吸取教训。

我是从一个 JavaScript/TypeScript 开发人员的角度写这篇文章的。如果您不是这样的人，您可能仍然会发现许多与不同主流编程语言相关的问题。

![](img/850d01775b29b64b265004ed8293739a.png)

安托万·道特里在 Unsplash[拍摄的照片](https://unsplash.com?utm_source=medium&utm_medium=referral)

# 到处应用 FP

函数式编程的范例已经在主流中获得了很大的吸引力，同时，可以说，其他范例由于其明显的弱点而受到了很大的反对。这自然引起了我的注意，因为我努力根据技术在商业产品中的实用性来做出判断。

函数式编程可能会吸引一些软件开发人员，因为它与数学，尤其是代数有着密切的联系。大多数编码人员可能会同意不变性、函数纯度或可组合性等原则。对于一些人来说，使用正式验证的可能性听起来也很令人兴奋。

是否意味着函数式编程更好？

不一定。

主流编程语言支持多种范例，有些人甚至将它们的成功归功于此。如果我们可以在一个项目中利用许多范例，我们应该约束自己只支持一个范例吗？

在大多数情况下，我们可以结合其他模式使用函数式编程，例如，面向对象编程。毕竟，我们可以对类实例应用不变性，不是吗？

另一方面，国家并不总是对手；我们可以使用有状态对象更好地表达一些想法——例如，web 套接字有一个称为连接状态的自然状态属性。

投掷失误怎么办？我发现可抛出代码可读性更好，即使我的想法违背了函数式编程的原则。更不用说我们可能仍然希望使用原生的`Error`类型来标记堆栈跟踪。

错误管理看起来不同，但看起来相似(这个片段使用 fp-ts)。

最后，我相信有经验的开发人员知道在函数式编程中处理横切关注点(比如日志)有多难。

# **关闭偏好**

当我第一次了解到*curry*和*局部应用*时，它永远地改变了我使用函数的方式。由于这两个概念是不同的，从现在开始，我将使用更宽泛的术语*闭包*来表示它们在代码中的用法。

闭包是 JavaScript 的基础，就像情态动词对于英语一样重要。我相信大多数软件开发人员基于他们的编码本能使用它们，甚至不知道闭包的概念。既然每个人都应该理解他们代码的影响，我们应该更仔细地研究一下闭包(双关语！).

闭包不一定比将参数显式传递给函数更高效。由于闭包的广泛使用，您选择的 TypeScript 编译器可能无法应用某些优化(读取:重写)。同样，由于闭包，JavaScript 引擎可能不会在运行时优化代码。闭包需要足够快地释放捕获的变量——否则内存消耗会增加。

你在这里看到了多少个闭包？(这个代码片段使用 fp-ts)

在一些语言中(例如 Java)，闭包只接受外部作用域的不可变变量。如果你知道为什么会这样，你可能想在评论区留下评论！

根据定义，闭包会破坏功能和数据。当我们调用一个 curried 或部分应用的函数时，它的调用者不知道闭包内捕获的变量。由于 TypeScript 类型系统的性质，调用方永远不会知道传递给它的函数的来源。

一些函数式编程的鼓吹者声称混合功能和数据是一种反模式。通常，他们会谈到使用面向对象模式的项目中的过度继承，导致即使是经验丰富的开发人员也难以理解的代码。我完全同意。不过，在我的例子中，我可以对过度使用闭包提出类似的观点。

# **依靠代码覆盖率**

代码覆盖率是我用来确定项目质量的众多指标之一。我的经验是，被覆盖分支的百分比既不能太低，也不能太高。对于我遇到的大多数项目来说，这条规则相当有效。

你可能会问为什么以实现 100%的覆盖率为目标是错误的？根据我的经验，这不一定是坏事，但你可以更明智地投资你的时间。毕竟，商业项目的资金和时间预算有限。

然而，如果您在代码库中无处不在地应用函数式编程，您可能会观察到代码覆盖率变得异常高。是因为这种范式帮助开发人员编写更好的测试吗？

*号*

命令式编程迫使编码人员使用条件语句来控制代码流。每个条件都会添加两个或更多对代码覆盖工具可见的分支。在函数式编程中也会发生同样的情况吗？

一元运算封装了条件语句，隐藏了分支的存在。开发人员将复合操作表示为函数的组合，称为管道。函数式编程将显式分支减少到了最低限度。

代码覆盖率来自我的开源项目“fp-backend”。注意分支百分比。

上述事实表明，我们不能依赖代码覆盖工具，至少在使用分支作为一般报告方法时不能。我们仍然可以看到我们是否忘记了导入特定的文件或函数——但是我们也可以从我们的 ide 接收到这些信息。

# **克服语言限制**

![](img/ac5405a702877d705be386b7ab1303db.png)

安迪·比尔斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

现有的每一种编程语言都有其局限性。有些限制是故意的。有些是因为最初的语言设计而出现的。重要的是，我们，软件工匠，在某种程度上依赖于我们使用的工具。

例如，TypeScript 不支持*高阶类型*。对于想要使用这种功能的开发人员来说，这意味着什么？

他们需要找到另一种方式来实现他们的目标。坦率地说，目标是交付他们的产品，而不是编写使用*高阶类型*的代码。我不会尝试编写接受任何单子作为参数的函数，除非我不想失去拥有类型系统的好处。

这些年来，我学会了不要在没人能解决的问题上投入太多时间。有时候我们需要接受他们的现状，继续前进。

顺便说一句，如果你总是得到类型错误，这可能意味着你的代码太复杂了。也许你引入了太多的成分，或者你使用了太多不同的*单子*？

# **偏爱单子**

单子可能是函数式编程中新手在学习基础知识后偶然发现的第一个高级概念。一些开发人员可能会发现具有普遍适用功能的容器的想法是革命性的。在学习了所有主要的一元类型之后，很难回到其他范式。

实际上，在处理单子时了解一些注意事项是有好处的。

由于 TypeScript 允许开发人员管理可空性，我相信我们不需要依赖于`Option` ( `Maybe`，`Nullable`)单子。我们仍然可以编写返回可空值的简单函数；当我们需要一个单子时，我们可以根据需要从一个特定的变量创建一个`Option`单子。

函数式编程促进了函数组合，尤其是构建一元函数的流水线。在这里，这样的构造要么接受一元参数，要么返回一元参数。

如果一个函数中返回的一元类型与第二个函数中接受的参数类型不同怎么办？

我们需要依赖单子转换器——接受一种类型的单子并返回另一种类型的单子的构造函数。这样，我们可以瞬间将一个`Option`转换成一个`Either` ( `Result`)。

我花了大量的编码时间试图简化项目中的管道。我建议在一个项目中只坚持少数单子，以避免大量处理单子变压器。你还可以因为不必向同事解释新概念而获得加分。

# **总结**

正如我之前提到的，我认为每个开发人员都应该了解他们的代码是如何工作的，以及它对整体性能的影响。毕竟，编码人员使用所有可用的工具来构建产品。如果使用一个特定的模式或范例使你偏离了成功，你可以考虑放弃它。

我发现函数式编程非常有用，尤其是从它引发的思维转变来看。像不变性、函数纯度或单子这样的想法有助于将代码组织成独立的块。只要我们不试图取代其他范例，我们就只会从函数式编程中受益。

本文中的所有代码片段都来自我的开源项目“fp-backend”，可在这里[获得](https://github.com/grzpab/fp-backend)。请注意，这是一个实验项目，是我各种想法的游乐场。