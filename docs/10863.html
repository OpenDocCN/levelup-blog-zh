<html>
<head>
<title>How To Render Your Lists Faster With React Virtualization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用React虚拟化更快地呈现您的列表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-render-your-lists-faster-with-react-virtualization-5e327588c910?source=collection_archive---------4-----------------------#2022-01-18">https://levelup.gitconnected.com/how-to-render-your-lists-faster-with-react-virtualization-5e327588c910?source=collection_archive---------4-----------------------#2022-01-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fdae16c70760233cb6140340eae727f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kx43fZIlnZmLZORblDrGdg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">React中的虚拟化。作者插图。</figcaption></figure><h2 id="2c48" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是虚拟化？</h2><p id="b94b" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">假设您想要呈现每分钟生成的大量tweets列表。你获取大量的数据(可能是JSON格式的),并使用HTML、CSS和JavaScript将其添加到DOM中。</p><p id="7e24" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">在数据发生变化之前，我们可能无法在一分钟内看到所有推文。不仅如此，由于渲染DOM元素会占用浏览器内存，我们的浏览器有可能会受到性能影响，速度会变慢。</p><p id="6a53" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">这里有一个快速的可视化:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/73d073c2c12481b846506b6842d35f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fXRvQnxIJteuiHgFfknH2w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">呈现大型列表。作者插图。</figcaption></figure><p id="df39" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">那么，我们能做些什么来确保我们的浏览器快如闪电，即使我们显示巨大的数据列表？</p><p id="11a3" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">进入UI虚拟化。</p><p id="7176" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">UI虚拟化是一个前端概念，它要求我们只渲染用户视口中可见的数据量，而不是一次性添加所有DOM元素。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/d70c768ffd38e276d3c6f33b00640a0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pZEf0q8mK1eLNgkh3LhnJA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">UI虚拟化。作者插图。</figcaption></figure><p id="9e58" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">如果我们在用户的视口中呈现精确的可见数据量，用户可能需要等待几秒钟才能在DOM中滚动到下面的数据集。</p><p id="b56f" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">为了避免这样的用户体验，我们可以获取额外的缓冲数据来解释用户的滚动行为。</p><p id="0321" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">下面是它的样子:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/ef34b4e1c26e8ecc355bdc06cfa6cbad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xlSpFCP1gbQDc-Hb3zO_2Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用缓冲数据的UI虚拟化。作者插图。</figcaption></figure><p id="a838" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">这个公式确保我们的浏览器和用户在呈现和查看大型数据列表时感到满意。</p><p id="c0fe" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">现在我们对UI虚拟化有了一些了解，我们可以看看如何在React中实现它。</p><h2 id="f051" class="kc kd iq bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">React中的虚拟化</h2><p id="c7f3" class="pw-post-body-paragraph ky kz iq la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ij bi translated">我们将使用react-virtualized包来实现虚拟化。</p><p id="9dab" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">在最基本的层面上，react-virtualized包的列表组件负责呈现整个元素列表。</p><p id="764c" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">它需要以下道具:</p><ul class=""><li id="6b76" class="mf mg iq la b lb lt lf lu kl mh kp mi kt mj ls mk ml mm mn bi translated">列表的高度和宽度。</li><li id="59a2" class="mf mg iq la b lb mo lf mp kl mq kp mr kt ms ls mk ml mm mn bi translated">元素每行的大小。</li><li id="a93b" class="mf mg iq la b lb mo lf mp kl mq kp mr kt ms ls mk ml mm mn bi translated">列表中的项目数。</li><li id="59d1" class="mf mg iq la b lb mo lf mp kl mq kp mr kt ms ls mk ml mm mn bi translated">负责呈现列表的函数。</li></ul><p id="570e" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">相当多。我知道。</p><p id="3bac" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">为了更好地理解，让我们看看在下面的代码沙箱中实现时的情况。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2b97" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">如您所见，我们已经对列表的宽度和高度以及元素的行高进行了硬编码。我保证会在接下来的代码示例中告诉你如何让这个列表具有响应性。</p><p id="3650" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">您可能还注意到rowRenderer属性接受一个函数作为值。该函数可以访问参数，如key、index和style元素。</p><p id="c69d" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">让我告诉你它们的意思。</p><ul class=""><li id="42a3" class="mf mg iq la b lb lt lf lu kl mh kp mi kt mj ls mk ml mm mn bi translated">键—分配给列表中项目的唯一键。</li><li id="5d36" class="mf mg iq la b lb mo lf mp kl mq kp mr kt ms ls mk ml mm mn bi translated">索引—列表中每个元素的索引。</li><li id="b998" class="mf mg iq la b lb mo lf mp kl mq kp mr kt ms ls mk ml mm mn bi translated">Style —动态添加的样式属性，用于在用户滚动时将DOM元素放在列表的正确位置。</li></ul><p id="ac2c" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">现在我们知道了如何呈现虚拟化列表，是时候兑现我的承诺，继续关注它的响应能力了。</p><p id="ef65" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">为此，让我们看看下面的代码沙箱。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="11d6" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">扩展我们之前的示例，您可以看到添加了一个名为AutoSizer的新组件。</p><p id="d7ac" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">react-virtualized的AutoSizer组件为您提供了要传递给List组件的宽度和高度属性。</p><p id="731e" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">AutoSizer接受一个函数，该函数获取宽度和高度作为道具，并返回要呈现的元素。在我们的例子中，这将是列表组件。</p><p id="194b" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">AutoSizer可以有一个父div来决定它的高度和宽度，从而使您可以完全控制所呈现列表的尺寸。</p><p id="cce8" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">好吧。听起来不错。</p><p id="b786" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">但还是少了一块。</p><p id="1d6c" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">我们确实有行高硬编码。</p><p id="26f2" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">如果列表中有多个元素，每个元素都有不同的高度，该怎么办？</p><p id="0c88" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">我们如何解决这个问题？</p><p id="2cbf" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">react-virtualized的CellMeasurer组件可以解决这个问题。</p><p id="911f" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">让我们看一看。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2884" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">CellMeasurer和CellMeasurerCache是react-virtualized提供的两个组件，可以帮助您动态地测量元素大小。</p><p id="9d19" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">我来详细说明一下。</p><p id="49ff" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">CellMeasurer将测量元素的大小。CellMeasurerCache将存储CellMeasurer测量值，以便与父组件共享。</p><p id="4a0c" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">CellMeasurerCache接受一个对象，您可以在其中配置所需的度量。在上面的代码示例中，fixedWidth意味着项目将具有固定的宽度和动态的高度。</p><p id="4074" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">更进一步，List组件的rowHeight使用CellMeasurerCache中的值。这是因为缓存存储了来自CellMeasurer的测量值。deferredMeasurementCache允许在List和CellMeasurer组件之间共享度量数据。</p><p id="171a" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">CellMeasurer的columnIndex为0，因为List组件只有一列。rowIndex是要测量的行的索引。parent是对用于呈现项目的父列表的引用。</p><p id="2d76" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">这就是了。React中使用react-virtualized动态配置的虚拟化列表。</p><p id="aee5" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">我希望这篇文章为您更详细地探索虚拟化和react-virtualized包提供了一个良好的起点。</p><p id="44b4" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">如果你有任何问题，建议，评论，欢迎在下面的评论区分享。</p><p id="faf5" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated">到那时，快乐的编码！</p><p id="e05f" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated"><strong class="la ir"> <em class="mv">参考文献:</em> </strong></p><p id="912b" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated"><a class="ae mw" href="https://www.kirupa.com/hodgepodge/ui_virtualization.htm" rel="noopener ugc nofollow" target="_blank">什么是UI虚拟化？</a></p><p id="d633" class="pw-post-body-paragraph ky kz iq la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ij bi translated"><a class="ae mw" href="https://www.youtube.com/watch?v=UrgfPjX97Yg" rel="noopener ugc nofollow" target="_blank">使用react-virtualized渲染大型列表</a></p></div></div>    
</body>
</html>