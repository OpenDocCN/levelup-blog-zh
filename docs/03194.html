<html>
<head>
<title>Creating Our Own Redux Middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建我们自己的Redux中间件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-our-own-redux-middleware-4b0aaed8a527?source=collection_archive---------12-----------------------#2020-04-24">https://levelup.gitconnected.com/creating-our-own-redux-middleware-4b0aaed8a527?source=collection_archive---------12-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/37e5d0ba5294b446549f1ce6ee5a24b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8yXXX2s9E9Skn84t"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@willie_f?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威利·芬伯格</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="45ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了Redux，我们可以用它在JavaScript应用程序的中央位置存储数据。它可以单独工作，当与React-Redux结合使用时，它也可以作为React应用程序的一个流行的状态管理解决方案。</p><p id="4eba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何创建我们自己的Redux中间件。</p><h1 id="3998" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">中间件</h1><p id="90ac" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">中间件是一些代码，我们可以把它放在分派动作和动作到达缩减器之间。</p><p id="bf21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了简洁地做到这一点，我们定义了一个函数，该函数以<code class="fe mh mi mj mk b">store</code>为参数，返回一个以<code class="fe mh mi mj mk b">next</code>为参数的函数，该函数与<code class="fe mh mi mj mk b">dispatch</code>函数相同，然后返回一个以<code class="fe mh mi mj mk b">action</code>为参数的函数，并返回<code class="fe mh mi mj mk b">next(action)</code>。</p><p id="aaa0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以这样做:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0a2f" class="mt lf it mk b gy mu mv l mw mx">import { createStore, applyMiddleware } from "redux";</span><span id="898a" class="mt lf it mk b gy my mv l mw mx">function countReducer(state = 0, action) {<br/>  switch (action.type) {<br/>    case "INCREMENT":<br/>      return state + 1;<br/>    case "DECREMENT":<br/>      return state - 1;<br/>    default:<br/>      return state;<br/>  }<br/>}</span><span id="bb92" class="mt lf it mk b gy my mv l mw mx">const logger = store =&gt; next =&gt; action =&gt; {<br/>  console.log("dispatching", action);<br/>  let result = next(action);<br/>  console.log("next state", store.getState());<br/>  return result;<br/>};</span><span id="b778" class="mt lf it mk b gy my mv l mw mx">let store = createStore(countReducer, applyMiddleware(logger));<br/>store.subscribe(() =&gt; store.getState());<br/>store.dispatch({ type: "INCREMENT" });<br/>store.dispatch({ type: "DECREMENT" });</span></pre><p id="47e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个<code class="fe mh mi mj mk b">logger</code>中间件，它是一个接受<code class="fe mh mi mj mk b">store</code>参数的函数，该参数保存Redux存储本身，然后返回一个接受<code class="fe mh mi mj mk b">next</code>函数的函数，与<code class="fe mh mi mj mk b">store.dispatch</code>相同。这个函数然后返回一个带有<code class="fe mh mi mj mk b">action</code>参数的函数，这个参数是我们调用<code class="fe mh mi mj mk b">dispatch</code>的动作对象。</p><p id="5101" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在取<code class="fe mh mi mj mk b">action</code>的函数中，首先我们记录<code class="fe mh mi mj mk b">action</code>，然后我们用<code class="fe mh mi mj mk b">action</code>调用<code class="fe mh mi mj mk b">next</code>，然后我们取返回的结果并赋给<code class="fe mh mi mj mk b">result</code>。</p><p id="faeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们记录<code class="fe mh mi mj mk b">store.getState()</code>，并返回<code class="fe mh mi mj mk b">result</code>。</p><p id="95f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使用我们刚刚定义的<code class="fe mh mi mj mk b">logger</code>中间件，我们编写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="01ed" class="mt lf it mk b gy mu mv l mw mx">let store = createStore(countReducer, applyMiddleware(logger));</span></pre><p id="5002" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们运行<code class="fe mh mi mj mk b">dispatch</code>时，我们将看到记录器的<code class="fe mh mi mj mk b">console.log</code>输出。</p><h1 id="ade9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用中间件返回非简单对象</h1><p id="002b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不必用中间件返回普通对象。</p><p id="86f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们也可以如下返回一个承诺:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bc4e" class="mt lf it mk b gy mu mv l mw mx">const promiseMiddleware = store =&gt; next =&gt; action =&gt; {<br/>  if (!(action instanceof Promise)) {<br/>    return next(action);<br/>  }<br/>  return (async () =&gt; {<br/>    const resolvedAction = await Promise.resolve(action);<br/>    store.dispatch(resolvedAction);<br/>  })();<br/>};</span></pre><p id="c7a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们返回了一个承诺，它不是一个简单的对象。</p><p id="8280" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它所做的就是，如果我们向<code class="fe mh mi mj mk b">dispatch</code>传递一个承诺，它将解析这个承诺，然后调用<code class="fe mh mi mj mk b">store.dispatch</code>并执行解析后的动作。</p><p id="3963" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当调用<code class="fe mh mi mj mk b">createStore</code>函数时，我们可以调用<code class="fe mh mi mj mk b">applyMiddleware</code>函数。</p><p id="72b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们调用了我们的异步函数，我们不只是返回它。我们必须给<code class="fe mh mi mj mk b">store.dispatch</code>打电话，这样我们行动的价值就会在商店里被设定。</p><h1 id="1016" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">定义和使用多个中间件</h1><p id="8eec" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们调用<code class="fe mh mi mj mk b">applyMiddleware</code>时，我们可以创建和应用多个中间件。为此，我们只需为<code class="fe mh mi mj mk b">applyMiddleware</code>传递所有的中间件。</p><p id="2cc3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想应用上面例子中的所有中间件，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b8a0" class="mt lf it mk b gy mu mv l mw mx">import { createStore, applyMiddleware } from "redux";</span><span id="a2bf" class="mt lf it mk b gy my mv l mw mx">function countReducer(state = 0, action) {<br/>  switch (action.type) {<br/>    case "INCREMENT":<br/>      return state + 1;<br/>    case "DECREMENT":<br/>      return state - 1;<br/>    default:<br/>      return state;<br/>  }<br/>}</span><span id="716a" class="mt lf it mk b gy my mv l mw mx">const logger = store =&gt; next =&gt; action =&gt; {<br/>  console.log("dispatching", action);<br/>  let result = next(action);<br/>  console.log("next state", store.getState());<br/>  return result;<br/>};</span><span id="ecfa" class="mt lf it mk b gy my mv l mw mx">const promiseMiddleware = store =&gt; next =&gt; action =&gt; {<br/>  if (!(action instanceof Promise)) {<br/>    return next(action);<br/>  }<br/>  return (async () =&gt; {<br/>    const resolvedAction = await Promise.resolve(action);<br/>    store.dispatch(resolvedAction);<br/>  })();<br/>};</span><span id="5bea" class="mt lf it mk b gy my mv l mw mx">let store = createStore(<br/>  countReducer,<br/>  applyMiddleware(promiseMiddleware, logger)<br/>);<br/>store.subscribe(() =&gt; store.getState());<br/>store.dispatch(Promise.resolve({ type: "INCREMENT" }));<br/>store.dispatch({ type: "DECREMENT" });</span></pre><p id="a173" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们有了<code class="fe mh mi mj mk b">promiseMiddleware</code>，我们现在可以将承诺传递给<code class="fe mh mi mj mk b">dispatch</code>并在商店中设置值。</p><p id="4476" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可以这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ba24" class="mt lf it mk b gy mu mv l mw mx">store.dispatch(Promise.resolve({ type: "INCREMENT" }));<br/>store.dispatch({ type: "DECREMENT" });</span></pre><p id="972e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不会得到一个错误。</p><p id="1624" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mh mi mj mk b">logger</code>中间件，我们得到<code class="fe mh mi mj mk b">console.log</code>输出。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/1fa542f22f6f2b0282431db0b2bc2d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hVvAW-GnEsTlJejX"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Mitch Lensink 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="f71c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="bcd3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以定义中间件来做比Redux本身更多的事情。</p><p id="6784" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们定义了一个以<code class="fe mh mi mj mk b">store</code>为参数的函数，该函数返回一个以<code class="fe mh mi mj mk b">next</code>为参数的函数，该函数与<code class="fe mh mi mj mk b">dispatch</code>函数相同，后者返回一个以<code class="fe mh mi mj mk b">action</code>为参数的函数，并返回<code class="fe mh mi mj mk b">next(action)</code>。</p><p id="217f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数必须调用<code class="fe mh mi mj mk b">dispatch</code>，以便将动作对象传播到缩减器。</p><p id="46f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">applyMiddleware</code>函数链接中间件，该函数接受一个或多个中间件。</p></div></div>    
</body>
</html>