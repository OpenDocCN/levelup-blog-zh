<html>
<head>
<title>Practical SOLID in Golang: Single Responsibility Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗的实践基础:单一责任原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-solid-in-golang-single-responsibility-principle-20afb8643483?source=collection_archive---------2-----------------------#2021-10-24">https://levelup.gitconnected.com/practical-solid-in-golang-single-responsibility-principle-20afb8643483?source=collection_archive---------2-----------------------#2021-10-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="020e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">坚实的原则</h2><div class=""/><div class=""><h2 id="7dab" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我们通过介绍最广为人知的原则——单一责任原则，开始了软件开发的基本原则之旅。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/76dfad4fd72bd6e334fdcf39236d9602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uefvIhFklXKblURh"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae lh" href="https://unsplash.com/@hnhmarketing?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">猎人哈利</a>拍摄的照片</figcaption></figure><p id="8edb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">软件开发突破的可能性不太多。它们大多是在错误的初始学习后重新连接逻辑，或者填补我们知识中缺失的一块。</p><p id="1da8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我喜欢那种更深刻的领悟的感觉。有时是在编码过程中，有时是在网上阅读书籍或文章时，有时是坐在公交车上。</p><p id="91ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">内在的声音总是跟着它。<em class="me">啊，是啊，就是这么回事</em>。突然间，所有过去的错误都有了逻辑上的原因。所有未来的需求都有一个形状。</p><p id="2a4d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我有这样一个坚实的原则突破。这些原则第一次出现在鲍勃叔叔的文件中。后来他在他的书《干净的建筑》中塑造了他们。</p><p id="8d4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，我计划通过提供Go中的例子来开始我的旅程。列表中的第一个，代表单词<em class="me"> SOLID </em>中的字母<em class="me"> S </em>，是单一责任原则。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="df65" class="mk ml it mg b gy mm mn l mo mp">Are you interested in Domain-Driven Desing? Check these articles from DDD series:</span><span id="7c8e" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mg jd">Practical DDD in Golang: Value Object</strong></a></span><span id="fec8" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mg jd">Practical DDD in Golang: Entity</strong></a></span><span id="b22c" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-service-4418a1650274"><strong class="mg jd">Practical DDD in Golang: Domain Service</strong></a></span><span id="8a5c" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-event-de02ad492989"><strong class="mg jd">Practical DDD in Golang: Domain Event</strong></a></span><span id="7e0b" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">5. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-module-51edf4c319ec"><strong class="mg jd">Practical DDD in Golang: Module</strong></a></span><span id="2310" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">6. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-aggregate-de13f561e629"><strong class="mg jd">Practical DDD in Golang: Aggregate</strong></a></span><span id="0512" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">7. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-factory-5ba135df6362"><strong class="mg jd">Practical DDD in Golang: Factory</strong></a></span><span id="fc90" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">8. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-repository-d308c9d79ba7"><strong class="mg jd">Practical DDD in Golang: Repository</strong></a></span><span id="6f73" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">9. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-specification-6523d14438e6"><strong class="mg jd">Practical DDD in Golang: Specification</strong></a></span></pre><div class="mr ms gp gr mt mu"><a href="https://blog.ompluscator.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd jd gy z fp mz fr fs na fu fw jc bi translated">通过我的推荐链接加入媒体——马尔科·米洛耶维奇</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">blog.ompluscator.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni lb mu"/></div></div></a></div><h1 id="1424" class="nj ml it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">当我们不尊重单一责任时</h1><blockquote class="oa ob oc"><p id="2149" class="li lj me lk b ll lm kd ln lo lp kg lq od ls lt lu oe lw lx ly of ma mb mc md im bi translated">单一责任原则(SRP)规定每个软件模块应该有且只有一个变更的理由。</p></blockquote><p id="9ccd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的句子是鲍勃叔叔自己写的。它的意义最初是绑定到一个模块，并通过将责任映射到组织的日常工作来划分责任。</p><p id="7ebe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">今天，SRP的范围很广，它涉及软件的不同方面。我们可以在类、函数、模块中使用它的用途。当然，在Go中，我们可以在结构中使用它。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="1fbf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们从上面检查代码块。这里我们有一个结构<code class="fe oi oj ok mg b">EmailService</code>，只有一个方法<code class="fe oi oj ok mg b">Send</code>。我们使用这项服务发送电子邮件。即使它看起来很好，当我们触及表面时，我们意识到这段代码破坏了SRP的每个方面。</p><p id="ebdb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe oi oj ok mg b">EmailService</code>的职责不仅仅是发送电子邮件，而是将电子邮件信息存储到数据库<strong class="lk jd">中，然后</strong>通过SMTP协议发送出去。</p><p id="6d74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">仔细看看上面的句子。“和”这个词是有目的的加粗。使用这样的表述看起来不像我们描述单一责任的情况。</p><blockquote class="oa ob oc"><p id="660f" class="li lj me lk b ll lm kd ln lo lp kg lq od ls lt lu oe lw lx ly of ma mb mc md im bi translated">一旦描述某个代码结构的责任需要使用“和”这个词，它就已经打破了单一责任原则。</p></blockquote><p id="84f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们的例子中，我们在许多代码级别上违反了SRP。第一个是功能层面的。函数<code class="fe oi oj ok mg b">Send</code>既负责在数据库中存储消息，也负责通过SMTP协议发送电子邮件。</p><p id="d308" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第二层是一个结构<code class="fe oi oj ok mg b">EmailService</code>。正如我们已经得出的结论，它也有两个责任，存储在数据库和发送电子邮件。</p><p id="c954" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样的守则会有什么后果？</p><ol class=""><li id="0024" class="ol om it lk b ll lm lo lp lr on lv oo lz op md oq or os ot bi translated">当我们改变表结构或存储类型时，我们需要改变通过SMTP发送电子邮件的代码。</li><li id="f515" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated">当我们想要集成<a class="ae lh" href="https://www.mailgun.com/" rel="noopener ugc nofollow" target="_blank"> Mailgun </a>或<a class="ae lh" href="https://www.mailjet.de/" rel="noopener ugc nofollow" target="_blank"> Mailjet </a>时，我们需要更改一段代码，用于在MySQL数据库中存储数据。</li><li id="f3a9" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated">如果我们在应用程序中选择发送电子邮件的不同集成，每个集成都需要有一个逻辑来存储数据库中的数据。</li><li id="f2ce" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated">假设我们决定将应用程序的职责分成两个团队，一个团队负责维护数据库，另一个团队负责集成电子邮件提供商。在这种情况下，他们将使用相同的代码。</li><li id="b3bb" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated">这个服务实际上无法通过单元测试来测试。</li><li id="d45d" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi">…</li></ol><p id="6436" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，让我们重构这段代码。</p><h1 id="aaea" class="nj ml it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">我们如何尊重单一责任</h1><p id="3dea" class="pw-post-body-paragraph li lj it lk b ll oz kd ln lo pa kg lq lr pb lt lu lv pc lx ly lz pd mb mc md im bi translated">为了在这种情况下划分职责，并使代码块只有一个存在的理由，我们应该为每个代码块定义一个结构。</p><p id="9712" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它实际上意味着在一些存储器中有一个单独的结构用于存储数据，并且通过使用与电子邮件提供商的一些集成有一个不同的结构用于发送电子邮件。下面的代码块中有更多信息:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="0bcd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们提供了两个新的结构。第一个是作为<code class="fe oi oj ok mg b">EmailRepository</code>接口实现的<code class="fe oi oj ok mg b">EmailDBRepository</code>。它支持在底层数据库中持久化数据。</p><p id="d7b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第二个结构是<code class="fe oi oj ok mg b">EmailSMTPSender</code>，它实现了<code class="fe oi oj ok mg b">EmailSender</code>接口。这个结构只负责通过SMPT协议发送电子邮件。</p><p id="c560" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，新的<code class="fe oi oj ok mg b">EmailService</code>包含来自上面的接口，并委托发送电子邮件的请求。</p><p id="7d9e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可能会出现一个问题:<code class="fe oi oj ok mg b">EmailService</code>是否仍然有多重职责，因为它仍然拥有存储和发送电子邮件的逻辑？看起来像是我们只是做了一个抽象，但职责仍然在那里吗？</p><p id="55d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，情况并非如此。<code class="fe oi oj ok mg b">EmailService</code>不负责储存和发送电子邮件。它将它们委托给下面的结构。它的职责是将处理电子邮件的请求委托给底层服务。</p><blockquote class="oa ob oc"><p id="12e3" class="li lj me lk b ll lm kd ln lo lp kg lq od ls lt lu oe lw lx ly of ma mb mc md im bi translated">承担责任和委派责任是有区别的。如果一个特定代码的改编可以消除责任的整个目的，我们就说持有。如果这种责任在删除特定代码后仍然存在，那么我们就谈到了委托。</p></blockquote><p id="d35f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们去掉complete <code class="fe oi oj ok mg b">EmailService</code>，我们仍然需要一个负责在数据库中存储数据和通过SMTP发送电子邮件的代码。这意味着我们可以肯定地说，电子邮件服务不承担这两项责任。</p><h1 id="4f14" class="nj ml it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">更多的例子</h1><p id="c321" class="pw-post-body-paragraph li lj it lk b ll oz kd ln lo pa kg lq lr pb lt lu lv pc lx ly lz pd mb mc md im bi translated">正如我们之前看到的，SRP适用于编码的许多不同方面，而不仅仅是结构。我们可以看到，我们可以为了函数而破坏它，但是这个例子已经在一个struct中破坏SRP的阴影下了。</p><p id="280d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了更好地了解SRP原理在函数中的应用，让我们看下面的一个例子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="ea19" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">函数<code class="fe oi oj ok mg b">extractUsername</code>没有太多行。它支持从HTTP头<strong class="lk jd">中提取原始的<a class="ae lh" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JWT </a>令牌，并且</strong>返回用户名的值(如果它存在于其中的话)。</p><p id="a43a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可能会再次注意到粗体字“和”。这个方法有多重责任。我们如何重构它的描述并不重要。我们不能避免使用“和”这个词来描述这个方法的作用。</p><p id="00e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们应该更多地参与方法本身的重构，而不是重构一种描述函数目的的方式。下面你可以找到一个新代码的建议:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="5799" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们有两个新功能。第一个是<code class="fe oi oj ok mg b">extractRawToken</code>，包含从HTTP头中提取原始JWT令牌的责任。如果我们改变了头中保存令牌的键，我们应该只接触一个方法。</p><p id="6dc7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第二个是<code class="fe oi oj ok mg b">extractClaims</code>。该方法负责从原始JWT令牌中提取声明。最后，在将令牌提取请求委托给底层方法之后，我们的旧函数<code class="fe oi oj ok mg b">extractUsername</code>从声明中获取特定值。</p><p id="db42" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有更多例子。其中许多是我们日常使用的。我们使用其中一些是因为一些框架规定了错误的方法，或者我们懒得提供正确的实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="2246" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的例子显示了模式<a class="ae lh" href="https://en.wikipedia.org/wiki/Active_record_pattern" rel="noopener ugc nofollow" target="_blank">活动记录</a>的典型实现。在这种情况下，我们还在<code class="fe oi oj ok mg b">User</code>结构中添加了一个业务逻辑，而不仅仅是将数据存储到数据库中。</p><p id="2b00" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们混合了活动记录的目的和来自领域驱动设计的<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3">实体</a>模式。为了正确地交付代码，我们需要提供单独的结构:一个用于在数据库中持久存储数据，另一个充当实体的角色。下面的例子也犯了同样的错误:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="2629" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们又有了两个职责，但是现在，第二个职责(数据库中一个表的映射，通过<a class="ae lh" href="https://gorm.io/index.html" rel="noopener ugc nofollow" target="_blank"> Gorm </a>包)没有直接表示为算法，而是表示为Go标签。</p><p id="ec3a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">即使是现在，钱包结构也违反了SRP原则，因为它扮演着多重角色。如果我们改变一个数据库模式，我们需要调整这个结构。如果我们改变取款的业务规则，我们需要调整这个类。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="2a15" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的代码片段是破坏SRP的另一个例子。而且，在我看来，这是最悲剧的一个！我们不能提供一个更小的结构来承担更多的责任。</p><p id="416e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过查看<code class="fe oi oj ok mg b">Transaction</code>结构，我们意识到它描述了到数据库中表的映射，并且是REST API中JSON响应的持有者，但是由于验证部分，它也可以是API请求的JSON主体。<em class="me">一个结构统治所有的</em>。</p><p id="1b2c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有这些例子迟早都需要调整。只要我们把它们保留在代码中，它们就是无声的问题，很快就会打破我们的逻辑。</p><h1 id="60d3" class="nj ml it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">结论</h1><p id="a1bf" class="pw-post-body-paragraph li lj it lk b ll oz kd ln lo pa kg lq lr pb lt lu lv pc lx ly lz pd mb mc md im bi translated">单一责任原则是坚实原则中的第一个原则。它代表单词SOLID中的一个字母S。它声称一个代码结构必须只有一个存在的理由。</p><p id="b08e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将这些原因视为责任。一个结构可以承担责任或委托责任。每当我们的结构包含多个职责时，我们应该重构这段代码。</p></div></div>    
</body>
</html>