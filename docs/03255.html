<html>
<head>
<title>Five Things To Try as a Java Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为Java开发人员要尝试的五件事</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/five-things-to-try-as-a-java-developer-32d13a9745d9?source=collection_archive---------2-----------------------#2020-04-28">https://levelup.gitconnected.com/five-things-to-try-as-a-java-developer-32d13a9745d9?source=collection_archive---------2-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6041" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你不需要放弃Java生态系统来扩展你的技能和学习新的东西。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/df5024b2265cc54f53b874b11b70d57b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tMqo8FxEsnkkWKDO"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">凯利·西克玛在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名Java开发人员，专攻一种平台或编程语言并不罕见。我们专注于我们擅长的事情，并继续做得更好。不久之后，我们把自己局限在一个狭窄的技能范围内，而牺牲了其他所有的技能。</p><p id="1f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经到了这一步，是时候扩展一下，学习一些新的东西了。首先，对你的事业有好处。当然，Java本身——尽管它已经存在了一段时间——可能在未来一段时间内仍将是一种占主导地位的语言和平台。编写相同类型的企业Java应用程序很容易陷入困境。但是Java平台提供的东西将会不断发展。有一些有用的、革命性的创新正在你身边进行:反应式编程和函数式编程；更新、更小、更快的框架；大数据处理；备选JVM语言。冒着你自己职业生涯的风险，保持对它们的忽视！</p><p id="3bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二，对大脑有好处。科学清楚地表明，学习新事物有助于你的大脑成长并保持健康。当然，你可以学习弹吉他、攀岩、变戏法或表演即兴喜剧(所有这些都是需要掌握的技能)。但是如果你是一名程序员，为什么不学习与你的工作相关的新技能呢？</p><p id="a7d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我认为这将有助于避免职业倦怠。只坚持你所知道的，很容易对你的软件工程生涯感到厌倦和不满。但事实上，这个行业有很多令人兴奋的事情在发生！</p><p id="595a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，作为Java程序员，我们并不总是想偏离自己的领域太远。因此，下面是一些需要学习的东西，它们仍然与Java有一些联系。</p><h1 id="5bba" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">RxJava</h1><p id="b39c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">反应式编程最近越来越受欢迎。这是至少两个其他行业趋势同时出现的结果:</p><ul class=""><li id="d50a" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">基于事件循环的web服务器框架，如Node.js，以及本文后面提到的一些基于Netty的Java框架</li><li id="5490" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">大数据:大数据流的批处理</li></ul><p id="9b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RxJava(代表Java 的<em class="ng">反应式扩展)已经成为第一个，也是最流行的，进行反应式编程的Java工具包之一。值得一提的是，自从RxJava兴起后，<a class="ae ky" href="https://www.reactive-streams.org/" rel="noopener ugc nofollow" target="_blank"> Reactive Streams </a> Java规范作为一种标准化Java中异步流处理的尝试。Reactive Streams API与RxJava的原始API有些不同；然而，RxJava的最新版本符合新的规范。</em></p><p id="7052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是首先，对于那些不知道什么是反应式编程，或者为什么我们想要一个反应式编程的特殊工具包的人来说，这是一本入门书。</p><p id="1625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，反应式编程涉及到对异步流的编程，每次数据到达流时都有效地“反应”。所以我可能会写一个程序，说:“监听这个套接字，任何时候有新的连接进来，就执行这个工作。”我们如何指定这个作品是什么？通过提供回调。</p><p id="baff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，上述示例的伪Java代码可能如下所示:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="d172" class="nm lw it ni b gy nn no l np nq">Socket s = getSocket();<br/>s.connect(new SocketCallback(SocketData d) {<br/> log.info(d.message);<br/>});</span></pre><p id="a89e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面编造的API中，我们可以连接到一个<code class="fe nr ns nt ni b">Socket</code>的实例，并连接到它，提供一个<code class="fe nr ns nt ni b">SocketCallback</code>的匿名实例来处理作为新连接的结果而进入的数据。一旦进行了<code class="fe nr ns nt ni b">s.connect(…)</code>调用，我们的代码将继续执行，稍后当连接进来时，我们的<code class="fe nr ns nt ni b">SocketCallback</code>将执行。</p><p id="c991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是反应式编程的一个简单例子。这就是问题所在:当我们开始超越琐碎的例子时，我们的代码会变得相当难看和难以阅读。好的，当然，在Java 8中，我们可以用一个lambda:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4068" class="nm lw it ni b gy nn no l np nq">getSocket().connect(d -&gt; log.info(d.message);</span></pre><p id="43f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们需要链接额外的反应调用来处理套接字数据呢？</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="87eb" class="nm lw it ni b gy nn no l np nq">getSocket().connect(d -&gt; {<br/>  httpClient.sendAsyncRequest(d.message, resp -&gt; {<br/>    dbClient.save(resp.body, result -&gt; {<br/>      log.info("data saved");<br/>    }<br/>  }<br/>});</span></pre><p id="f15e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须开始嵌套我们的回调，我们进入“回调地狱”。上面描述的三个回调可能看起来仍然是可管理的，但是在现实世界中，我们经常会发现自己将更多的被动调用链接在一起。</p><p id="5052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是RxJava的用武之地。简而言之，它允许我们以一种看起来更像过程化编程的方式将调用链接在一起:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="e2fa" class="nm lw it ni b gy nn no l np nq">getSocket.connect()<br/>.map(d -&gt; httpClient.sendAsyncRequest(d.message)<br/>.map(result -&gt; log.info("data saved"));</span></pre><p id="af08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用过Java Streams API，这可能看起来有点熟悉。但是这两种API之间有一些重要的区别。值得注意的是，Streams API给了我们足够的能力在本地转换数据集；例如，在单个方法的上下文中。使用RxJava，我们可以构建完整的应用程序，而无需离开反应式上下文。例如，当我们想要利用高度可伸缩的、基于事件循环的web应用程序框架时，这是很重要的。</p><h2 id="8e78" class="nm lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">如何学习RxJava</h2><p id="f098" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">学习RxJava有几种方法。首先，您可以创建一个简单的Java项目，添加最新的RxJava依赖项，此时看起来如下所示:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="27e6" class="nm lw it ni b gy nn no l np nq">&lt;dependency&gt;<br/> &lt;groupId&gt;io.reactivex.rxjava2&lt;/groupId&gt;<br/> &lt;artifactId&gt;rxjava&lt;/artifactId&gt;<br/> &lt;version&gt;2.2.19&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="186a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始时，请记住RxJava API实际上只有几个基本部分:</p><ul class=""><li id="7dd3" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><strong class="lb iu"> <em class="ng">可观测量</em> </strong>。它们代表了良好的、被观察的和被处理的数据。有几种不同的类型:<code class="fe nr ns nt ni b">Observable&lt;T&gt;</code>:基本类型，代表0..n项；<code class="fe nr ns nt ni b">Single&lt;T&gt;</code>:发出一个单项(或一个错误)；<code class="fe nr ns nt ni b">Maybe&lt;T&gt;</code>:发出一个项目，不发出任何项目，或者发出一个错误；而<code class="fe nr ns nt ni b">Completable</code>:要么完成而不发出任何东西，要么返回一个错误(类似于<code class="fe nr ns nt ni b">Runnable</code>)。</li><li id="ae36" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu"> <em class="ng">订户</em> </strong>。它们订阅上面提到的可观察类型之一，并处理发出的项目(或错误)。</li><li id="f225" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu"> <em class="ng">加工功能</em> </strong>。通过<code class="fe nr ns nt ni b">filter()</code>和<code class="fe nr ns nt ni b">map()</code>等方法，转换由可观察类型发出的数据。他们这样做并没有改变任何数据，而是通过返回修改后的副本。在下面的例子中，我们从<code class="fe nr ns nt ni b">String</code> s的<code class="fe nr ns nt ni b">Observable</code>开始，将其转换为<code class="fe nr ns nt ni b">Integer</code> s的新<code class="fe nr ns nt ni b">Observable</code>(通过<code class="fe nr ns nt ni b">map()</code>方法)，然后再次将其转换为<code class="fe nr ns nt ni b">Integer</code> s的新<code class="fe nr ns nt ni b">Observable</code>(通过<code class="fe nr ns nt ni b">filter()</code>方法)。</li></ul><p id="8825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，您就可以编写并运行您的第一段RxJava代码，如下所示:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="631e" class="nm lw it ni b gy nn no l np nq">package rxdemo;</span><span id="adb2" class="nm lw it ni b gy of no l np nq">import io.reactivex.Observable;</span><span id="74e6" class="nm lw it ni b gy of no l np nq">public class RxDemo {</span><span id="9806" class="nm lw it ni b gy of no l np nq">public static void main(String[] args) {<br/>    Observable&lt;String&gt; obs = Observable.<em class="ng">just</em>(<br/>          "foo", "bar", "baz", "monkey", "gamma", "onomatopoeia");<br/>    obs.map(s -&gt; new Integer(s.length()))<br/>    .filter(i -&gt; i &gt; 3)<br/>    .subscribe(len -&gt; {<br/>      System.<em class="ng">out</em>.println("Found a large string of length: "+ len);<br/>    }, e -&gt; {<br/>      e.printStackTrace();<br/>    });<br/>  }<br/>}</span></pre><p id="f6ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从那里找一个好的教程开始。ReactiveX网站有一个<a class="ae ky" href="http://reactivex.io/tutorials.html" rel="noopener ugc nofollow" target="_blank">页面，列出了许多教程和入门指南</a>。请记住，ReactiveX是独立于语言的反应式扩展伞。虽然不同语言实现的概念非常相似，但在开始学习时，您会希望选择一个特定于RxJava的教程。</p><p id="c11b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你掌握了一些编码，你就可以在你选择的框架中使用RxJava了。比如Android应用中常用的RxJava。你也可以<a class="ae ky" href="https://medium.com/@axella.gerald/reactive-rest-api-using-spring-boot-rxjava-4efb620c69ac" rel="noopener">轻松地把它添加到Spring </a>这样的框架中，并且它在Vert.x 这样的<a class="ae ky" href="https://vertx.io/docs/vertx-rx/java2/" rel="noopener ugc nofollow" target="_blank">其他框架中也是原生支持的。</a></p><h2 id="40b1" class="nm lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">学习RxJava的收获</h2><p id="5d97" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">通过学习RxJava，您将能够理解反应式编程。如果你没有做过很多，你可能会发现一开始会有一点挑战性(好的方面)。但是你可能也会觉得有趣和好玩。随着许多web应用程序转向事件循环、反应式API模型，您将获得越来越受欢迎的技能。</p><p id="a981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还将获得对函数式编程的一些核心概念的相对温和的介绍(尽管您可能听说过函数式编程——虽然与反应式编程相关——但不是一回事)。值得注意的是，RxJava是围绕<a class="ae ky" href="https://www.nurkiewicz.com/2016/06/functor-and-monad-examples-in-plain-java.html" rel="noopener ugc nofollow" target="_blank">函子和单子</a>构建的。尤其是单子，众所周知很难解释，然而一旦你理解了它们，它却出奇的简单。使用RxJava的可观察类型将帮助您在意识到之前理解单子。这将使你处于一个很好的位置——如果你决定尝试纯函数式编程的话(这是另一种需求越来越大的技能)。</p><h1 id="5f67" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">斯卡拉</h1><p id="de36" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Scala是JVM的替代编程语言。它经常被描述为一种混合的函数式面向对象语言。换句话说，它提供了函数式编程所需的所有功能，但也支持面向对象编程。这使得Java OO程序员学习Scala比学习纯函数式JVM语言<a class="ae ky" href="https://clojure.org/" rel="noopener ugc nofollow" target="_blank"> Clojure </a>更容易。</p><p id="552c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，学习和理解Scala可能会很困难，需要付出一些努力。首先，虽然面向对象和函数式编程的结合可以让Scala更容易学习，但也增加了语言的复杂性。此外，Scala倾向于提供许多不同的方式来做任何事情。Scala还引入了许多强大的构造(例如，<a class="ae ky" href="https://docs.scala-lang.org/tour/implicit-parameters.html" rel="noopener ugc nofollow" target="_blank">隐式</a>)，这些构造虽然非常有用，但可能会让新手感到困惑。最后，即使是<a class="ae ky" href="https://www.cis.upenn.edu/~matuszek/cis554-2011/Pages/scala-api.html" rel="noopener ugc nofollow" target="_blank"> Scala的文档也很难读懂</a>，直到你习惯了它。</p><p id="a012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是Scala的强大和灵活性让它在许多行业得到了越来越广泛的使用。如果您是一名Java开发人员，您可能会遇到已经迁移到Scala的Java商店，至少对于他们的一些系统来说是这样。即使您没有也不打算这样做，熟悉Scala也可以帮助您完成Java日常工作。</p><p id="3d84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，Scala从一开始就被设计为在JVM上运行，这也很有帮助。这意味着在幕后，您不会偏离Java生态系统。此外，Scala可以与Java互操作。这意味着您可以从Java代码中调用Scala代码，反之亦然(事实上，当我以开发Scala为生时，我经常这么做。)</p><p id="985d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，Scala无可否认的强大。你可以用这门语言做很多事情。学习Scala可能需要一段时间，但是在学习的过程中，您将会学到一些有趣且有用的构造，甚至可能会想知道Java何时会开始实现它们。</p><h2 id="5967" class="nm lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">如何学习Scala</h2><p id="f63a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，不要从学习Scala框架开始学习Scala。这主要是因为借助Scala强大的构造和灵活的语法，它的许多流行框架(例如，Play！框架)实际上是领域特定语言(DSL)。它们中的许多都需要你学习它们自己的语法，这对学习Scala可能有帮助，也可能没有帮助。</p><p id="7e27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，从简单地学习语言本身开始。有一些不错的教程，但是我建议从一本书开始。<a class="ae ky" href="https://www.amazon.com/Scala-Impatient-Cay-S-Horstmann/dp/0321774094" rel="noopener ugc nofollow" target="_blank">Scala for the immune</a>是快速学习Scala的最佳书籍之一。这将很好地向您介绍Scala最常见的特性，并将涵盖面向对象和函数式方法。</p><p id="faa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你掌握了基本的语言语法和结构，我建议你把重点放在Scala的纯函数方面。毕竟，作为一名Java开发人员，OO编程对你来说应该不是什么新鲜事。我推荐阿尔文·亚历山大的<a class="ae ky" href="https://www.amazon.com/Functional-Programming-Simplified-Alvin-Alexander/dp/1979788782/ref=sr_1_1_sspa?crid=61KPOG46HK39&amp;dchild=1&amp;keywords=functional+programming+in+scala&amp;qid=1587355013&amp;s=books&amp;sprefix=functional+p%2Cstripbooks%2C215&amp;sr=1-1-spons&amp;psc=1&amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEyWjhMOUtNQllRTVJYJmVuY3J5cHRlZElkPUEwMzE3ODI1NDRDUlQwN09XNFJRJmVuY3J5cHRlZEFkSWQ9QTA1OTg4MDczMFQwNURSTVZMT1U4JndpZGdldE5hbWU9c3BfYXRmJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ==" rel="noopener ugc nofollow" target="_blank">函数式编程，简化版:(Scala版)</a>。</p><h2 id="aff9" class="nm lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">学习Scala你会得到什么</h2><p id="ee9b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">即使你在日常工作中从未使用过Scala，学习它仍然会让你成为一名更好的程序员。</p><p id="a1a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，您将获得函数式编程的基础经验。除了别的以外，这将帮助您更好地理解像Java Streams API这样的东西，包括它为什么存在，如何更好地使用它，以及它目前缺少什么。</p><p id="b0e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还将学习一些强大的构造，例如:</p><ul class=""><li id="f6e3" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><a class="ae ky" href="https://docs.scala-lang.org/tour/pattern-matching.html" rel="noopener ugc nofollow" target="_blank">模式匹配</a>，这将让你体会到Java非常缺乏的功能，但这些功能将在<a class="ae ky" href="https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html" rel="noopener ugc nofollow" target="_blank">的</a>和<a class="ae ky" href="https://dzone.com/articles/a-first-look-at-records-in-java-14" rel="noopener ugc nofollow" target="_blank">的</a>中逐渐增加。</li><li id="2da7" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/scala-for-comprehensions/" rel="noopener ugc nofollow" target="_blank"><em class="ng">for</em>comprehensions</a>，这是一个使链式函数调用更容易理解的特性。</li><li id="49bc" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/currying-functions-in-java-with-examples/" rel="noopener ugc nofollow" target="_blank"> currying </a>，Scala和其他函数式语言中常见的、有用的功能，在Java中也可以实现</li><li id="d186" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://docs.scala-lang.org/tour/case-classes.html" rel="noopener ugc nofollow" target="_blank"> case类</a>，它们不仅不需要显式的getters和setters(以及显式的<code class="fe nr ns nt ni b">.equals()</code>和<code class="fe nr ns nt ni b">.toString()</code>方法和构造函数)，还支持模式匹配等特性</li></ul><p id="4f05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦，也许你会意识到关于Java 10 中<em class="ng">局部变量</em>的争论是多么的愚蠢。</p><h1 id="9be5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">春天…或者，不是春天的东西</h1><p id="2074" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在服务器端Java的世界里，似乎有两种类型的程序员:</p><ul class=""><li id="19b0" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">那些使用Spring(或类似的依赖注入框架)的</li><li id="4429" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">他人</li></ul><p id="29d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Spring可以说是最流行的服务器端Java框架。作为依赖注入框架的核心，Spring已经发展成为几乎所有企业Java工作的事实上的Java框架。</p><p id="b9cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是在近二十年前发布的，表面上是对更“重量级”的Java企业版(<em class="ng"> J2EE </em>或者后来的<em class="ng"> Jave EE </em>)的回应。但是即使在早期，Spring也利用了部分Enterprise Java，最著名的是servlet模型。</p><p id="f144" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，Spring仍然被认为是两者中更轻量级(和开放)的，所以它赢得了市场的最大份额。的确，春天的流行是当之无愧的。它功能强大，具有一致的编程模型，简单明了，并且被证明可以适应行业变化。事实上，以至于许多Spring程序员已经沉浸在框架中，再也不想学习其他任何东西。</p><p id="03da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但问题是，这里的<strong class="lb iu"> <em class="ng">是</em> </strong>还有很多其他的。无数其他的Java框架涌现出来，并且越来越受欢迎。虽然其中一些框架遵循Spring的基本模式(依赖注入、分层架构、每请求线程编程模型*)，但它们中的许多提供了完全不同的范例。</p><p id="3b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，也许你是<strong class="lb iu"> <em class="ng">不使用</em></strong>Spring的后端Java开发者之一。鉴于Spring仍然是最流行的Java框架，为什么不花点时间熟悉一下呢？您可能不会最终切换到Spring作为您的 事实上的框架，但是它将帮助您理解它为什么如此受欢迎，以及它的缺点导致了其他框架的出现。</p><p id="f45d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ng"> *历史上。Spring 5引入了反应式Webflux模型，尽管今天许多Spring应用程序仍然遵循每请求线程模型。</em></p><h2 id="27ba" class="nm lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">从学习非Spring框架中你会得到什么</h2><p id="96f5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果您认为自己是Spring开发人员，那么您可能已经习惯了这样的想法，即基于配置或基于注释的依赖注入对于严肃的应用程序开发是绝对必要的。您的应用程序设计应该看起来像一个生日蛋糕(底部是美味的巧克力DAO层，中间是美味的香草业务/域层，顶部是美味的草莓UI层)。每个请求应该在自己的线程上运行。此外，您的应用程序需要几秒钟甚至几分钟才能启动，这没什么大不了的。</p><p id="f921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，挑战这些假设是值得的。例如，有许多较新的应用程序避免了依赖注入——至少Spring提供了重量级的内置依赖注入——并且比Spring更高效。</p><p id="133d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些框架的核心是基于非阻塞的、反应式的模型。这通常允许单个服务器处理高得多的负载。这也是一个有趣的编程模型，需要熟悉。</p><p id="e2ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且许多这样的框架——因为它们在启动时缺少Spring的依赖注入连线——会在眨眼之间启动。事实上，有些甚至本身就支持热重载，避免了重新编译/重启来测试更改的需要。</p><p id="dc0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您很可能会决定坚持使用Spring作为您事实上的框架。但是探索其他框架将会让您体验到现有的替代方案。</p><p id="9fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就其本身而言，这会拓宽你的技能。此外，如果您遇到Spring不是理想解决方案的用例，并且面临队友怀疑您应该使用完全不同的语言时，它可以成为救命稻草。我不止一次遇到过这样的情况，大量的预期并发请求促使我们考虑使用Node.js。我对Vert.x框架的熟悉——它本身源于Node.js模型，提供了超越Node的优势——为我们提供了一个很好的选择，让我们留在了Java世界中。</p><h2 id="ac38" class="nm lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">学习非Spring框架</h2><p id="7057" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">学习替代框架首先要做的是选择要学习的框架。外面有许多选择；我会推荐三个好的候选人。</p><p id="7e42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">垂直x轴</strong></p><p id="c42f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://vertx.io/" rel="noopener ugc nofollow" target="_blank"> Vert.x </a>是我用过的所有框架中最喜欢的一个。像许多新的Java框架一样，它是建立在Netty之上的；它提供了基于事件循环的编程范式和反应式API，使它能够处理大量的请求。它还提供了许多有用的创新功能，包括:</p><ul class=""><li id="dffc" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><em class="ng">多语言编程</em>。编写Vert.x应用时，可以从众多语言中选择，比如Python、Scala、Kotlin、Javascript，当然还有Java。您甚至可以在同一个应用程序中混合使用多种语言。因此，即使您可能坚持使用Java，您也可以涉猎其他语言……或者让您热爱Python的队友相信Vert.x是您下一个项目的正确选择。</li><li id="3c30" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><em class="ng">垂直</em>。Vert.x应用可以通过使用<em class="ng">vertices</em>来组成，vertices是独立部署的组件。垂直设备通过事件总线(接下来讨论)传递消息来相互通信。这使得垂直元素彼此分离。它还提供了一个灵活的部署模型，其中相同的垂直集可以在相同的应用程序中运行，也可以跨不同的应用程序运行。</li><li id="48b0" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><em class="ng">事件总线</em>。顾名思义，Vert.x事件总线是一个发布和使用消息的通道。这是不同垂直领域进行沟通的主要机制。</li><li id="6e8c" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><em class="ng">热重装</em>。特别是当采用垂直模型时，更改会自动重新加载。无需退出，重新编译，并重新启动您的应用程序。</li></ul><p id="294f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">学习Vert.x有很多方法。你会在网上找到很多教程(<a class="ae ky" href="https://medium.com/better-programming/build-a-movie-tracking-system-using-react-and-java-522388965c55" rel="noopener">包括我自己的一个</a>)，但是你也可以直接从<a class="ae ky" href="https://vertx.io/" rel="noopener ugc nofollow" target="_blank"> vertx.io </a>开始。该文档是一流的，并且该网站提供了许多操作方法和教程的链接。</p><p id="61fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">玩！</strong></p><p id="de80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.playframework.com/" rel="noopener ugc nofollow" target="_blank">上场了！十年前，Typesafe(现在莫名其妙地被称为<a class="ae ky" href="https://www.lightbend.com" rel="noopener ugc nofollow" target="_blank"> Lightbend </a>)创建了框架</a>。它用Scala编写，很快成为最流行的Scala web框架之一。然而，它也提供了一流的Java API，因此您可以继续使用您的语言。</p><p id="2ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Play也是建立在Netty之上的，并具有一个反应式API。因此，它为开发基于事件循环的web应用程序提供了很好的介绍。它还具有快速启动时间和热代码重载功能，允许开发人员避免重新编译-重新启动循环来测试更改。</p><p id="a6e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这出戏！网站为<a class="ae ky" href="https://www.playframework.com/documentation/2.8.x/Tutorials" rel="noopener ugc nofollow" target="_blank">提供了大量的教程</a>，其中大部分专注于某个特定的功能。它还链接到各种第三方教程，其中许多是新手的良好起点。</p><p id="75b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">夸尔库斯</strong></p><p id="39a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为最新的Java框架之一(至少在撰写本文的时候)，<a class="ae ky" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>是一个有前途的框架，具有近乎革命性的特性。像大多数新的Java框架一样，Quarkus是建立在Netty之上的。事实上，它实际上是建立在Vert.x(如上所述)之上的，而vert . x本身是建立在Netty之上的。它还增加了自己的反应库，大大简化了反应代码的编写。</p><p id="163d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但不仅如此，Quarkus是从零开始建造的，考虑到了Kubernetes和容器。快速启动、低内存开销和更小的应用程序从一开始就是目标。Quarkus也被设计成可以在GraalVM上运行，并且可以很容易地编译成本地可执行文件。</p><p id="6a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Quarkus还宣传它的命令式和反应式编程的融合。事实上，我不推荐Quarkus作为Spring开发者尝试的另一个框架的唯一原因是Quarkus可能有点太熟悉了。也就是说，对于那些想尝试新东西但又不想偏离舒适区太远的Spring开发者来说，Quarkus可能正是他们想要的。</p><p id="4c3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始使用Quarkus，可能没有比前往Quarkus的<a class="ae ky" href="https://quarkus.io/guides/getting-started-reactive" rel="noopener ugc nofollow" target="_blank">入门</a>页面更好的方法了。</p><h2 id="6a02" class="nm lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">你将从学习Spring中得到什么</h2><p id="6559" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你是少数几个不知道或不使用Spring的Java程序员之一，那么你真的应该熟悉它。Spring是事实上的依赖注入框架(在Java生态系统以及其他软件行业中)。理解Spring将有助于您理解依赖注入到底有多强大。</p><h2 id="0574" class="nm lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">学习Spring框架</h2><p id="76ea" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">到目前为止，有无数的资源可以用来学习Spring。此外，Spring生态系统已经变得足够庞大，以至于您需要决定想要尝试哪种风格的Spring应用程序。我建议切入正题，用<a class="ae ky" href="https://github.com/spring-projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>构建一个<a class="ae ky" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" rel="noopener ugc nofollow" target="_blank"> SpringMVC </a>应用程序(这是Spring的微服务快速开发环境)。只需前往<a class="ae ky" href="https://spring.io/guides/gs/spring-boot/" rel="noopener ugc nofollow" target="_blank"> Spring Boot入门页面</a>。</p><h1 id="4125" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">阿帕奇波束</h1><p id="25ff" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如今，大数据是大新闻。多年来，出现了许多用于处理大量数据的框架——Hadoop、Flink、Spark、Storm。对于普通程序员来说，没有一个是超级直观的。作为一名通才软件开发人员，他们总是不敢坐下来学习。</p><p id="68ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阿帕奇光束不一样。首先，Beam是一个更高级的数据处理框架，它独立于运行程序。这意味着您可以编写自己的代码(Java是Beam的一等公民，Python也是)，并使用各种不同的运行程序运行它。从某种意义上说，Beam就像Java一样，只需编写一次就可以在任何地方运行。例如，你可以编写你的数据处理代码，并轻松地在本地运行它，然后在不更改一行代码的情况下，在<a class="ae ky" href="https://cloud.google.com/dataflow" rel="noopener ugc nofollow" target="_blank"> Google Cloud Dataflow </a>上运行它。</p><p id="0866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且入门极其容易。一旦您创建了一个Maven项目并导入了Bean依赖项，那么在本地创建并运行一个Beam作业所需要的就是一个像下面这样简单的类:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4efd" class="nm lw it ni b gy nn no l np nq">public class WordCounter {</span><span id="b855" class="nm lw it ni b gy of no l np nq">public static void main(String[] args) {<br/>    PipelineOptions options = PipelineOptionsFactory.create();<br/>    Pipeline p = Pipeline.create(options);<br/>    p.apply(TextIO.read().from("gs://apache-beam-samples/shakespeare/*"))<br/>        .apply(<br/>            FlatMapElements.into(TypeDescriptors.strings())<br/>                .via((String line) -&gt; Arrays.asList(line.split("[^\\p{L}]+"))))<br/>        .apply(Filter.by((String word) -&gt; !word.isEmpty()))<br/>        .apply(Count.perElement())<br/>        .apply(<br/>            MapElements.into(TypeDescriptors.strings())<br/>                .via(<br/>                    (KV&lt;String, Long&gt; wc) -&gt;<br/>                        wc.getKey() + ": " + wc.getValue()))<br/>        .apply(TextIO.write().to("wordcounts"));<br/>    p.run().waitUntilFinish();<br/>  }<br/>}</span></pre><p id="49c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并通过如下方式运行它:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="6e79" class="nm lw it ni b gy nn no l np nq">mvn compile exec:java -Dexec.mainClass=com.me.example.WordCounter -Dexec.args=<strong class="ni iu">"--output=./output/"</strong></span></pre><p id="613f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，这是一个基本的例子，所有的东西都被塞进了一个main方法中——很难像你写一个真正的程序那样。但是它显示了从一个简单的Beam示例开始，然后随着您了解的越来越多，构建它是多么容易。</p><h2 id="08ea" class="nm lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">学习平衡木的收获</h2><p id="2072" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">通过学习Apache Beam，您将体会到如何处理大型数据集。当然，你可能不希望自己成为一名数据工程师。但是工程界正在向大数据处理发展。因此，了解如何编写数据处理代码对后端软件工程师来说变得越来越重要。</p><p id="3d26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，通过学习Beam，您将了解一个可以在多种环境中运行的框架。正如我们提到的，Beam是跑步者不可知的。所以你可以轻松地在本地运行你的Beam应用，也可以在Google Cloud数据流上运行。你也可以在Spark上运行它们，这意味着(多亏了<a class="ae ky" href="https://aws.amazon.com/emr/" rel="noopener ugc nofollow" target="_blank"> AWS EMR </a>)你可以在AWS上运行它们(尽管需要更多的努力)。</p><h2 id="f896" class="nm lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">学习阿帕奇光束</h2><p id="9544" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">“字数统计”的例子似乎是阿帕奇梁的<em class="ng"> hello world </em>。所以我推荐阅读Beam的<a class="ae ky" href="https://beam.apache.org/get-started/wordcount-example/" rel="noopener ugc nofollow" target="_blank">入门教程，开始在本地开发和运行Beam。此外，在谷歌云平台(GCP)上运行同样的例子非常容易。事实上，GCP基于同样的WordCount应用程序提供了自己的</a><a class="ae ky" href="https://cloud.google.com/dataflow/docs/quickstarts/quickstart-java-maven" rel="noopener ugc nofollow" target="_blank">简单易懂的教程</a>。因此，要么尝试其中之一，要么两者都尝试。</p><h1 id="48de" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">React.js</h1><p id="3a66" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">作为Java开发人员，我们热爱面向对象、强类型和编译代码，这是有充分理由的。因此，很难采用一种既不提供编译、不提供强类型、也不提供(直到不久前)对象的编程语言。</p><p id="302b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而JavaScript和Java是最流行的编程语言之一。你可能会说它的流行仅仅是因为它是唯一一种可以在所有主流浏览器上运行的语言。你可能是对的。但是这并不能改变JavaScript在这个行业中是一种非常重要的语言的事实。</p><p id="19e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是作为一名Java开发人员，您如何调和您对这种语言的厌恶和学习它的需要呢？有答案，那个答案就是<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> <em class="ng"> React.js </em> </a>。</p><p id="0742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，你可能听说过React。但是从外部来看，它似乎是前端世界正在谈论的一长串JavaScript框架中的最新一个。不是的。信不信由你，作为一名Java开发人员，<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/even-if-you-hate-javascript-you-might-love-react-9e4134787d87">你可能真的喜欢React </a>。</p><p id="f757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有许多原因，例如:</p><ul class=""><li id="0606" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">这是一个易于理解的范例。React的核心是构建组件。然后，这些组件被组合成UI应用程序。当然，你需要使用一些JavaScript，但是学习React并不是学习JavaScript；是关于学习一个Web UI框架。</li><li id="2558" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">JavaScript只是等式的一部分。使用React时，您将开发由三部分组成的组件:<strong class="lb iu"> <em class="ng">表示样式</em> </strong>以<strong class="lb iu"> <em class="ng">级联样式表</em> </strong>或CSS的形式；<strong class="lb iu"><em class="ng"/></strong>形式的<a class="ae ky" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="ng">JSX</em></strong></a>(这点和HTML很像)，以及<strong class="lb iu"> <em class="ng">形式的</em> </strong>形式的<strong class="lb iu"> <em class="ng"> JavaScript </em> </strong>。</li><li id="6e6e" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><strong class="lb iu"> JavaScript更像胶水</strong>。正如刚才提到的，您将不会纯粹使用JavaScript。此外，当您编写JavaScript时，您通常会将它作为真正的脚本语言来使用，本质上是将应用程序的各个部分粘合在一起。基本上，这是几十年前它第一次被编写时的使用方式。</li><li id="0db3" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">它有一个很好的编译系统，可以捕捉错误。还记得我们说过作为Java开发人员，我们喜欢编译器吗？React提供了一个(实际上，更像是一个transpiler)，而且是一个很好的工具。除了构建紧凑的生产就绪代码之外，它还会捕捉某些类型的错误。虽然不像Java编译器那样健壮，但它提供了良好的防护，防止运行时出现错误。</li><li id="6b48" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">在Java应用程序上构建React UIs很容易。仅仅因为你正在使用React、JavaScript和node . js(React的构建系统运行于其上),并不意味着你不能愉快地继续用Java构建你所有的服务器端应用程序。事实上，构建与Java后端交互的React UIs非常容易。此外，通过将所有内容打包到一个可执行的超级JAR中，可以很容易地发布一个由React提供前端并由Java提供支持的自包含web应用程序。</li><li id="525f" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">如果你愿意，可以使用TypeScript。在React中，JavaScript以易于管理的小块形式出现。但是如果你真的反对JavaScript，你总是可以使用<a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript、</a>和强静态类型语言，它们可以向下转换成JavaScript。老实说，TypeScript是一种非常有趣的语言，有很多Java开发人员熟悉的特性(强类型、丰富的对象层次结构)，也有一些Java开发人员可能会有点嫉妒的特性(例如联合类型、内置元组)。</li></ul><h2 id="5378" class="nm lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">如何学习React.js</h2><p id="0762" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">外面有很多好的React.js教程，<a class="ae ky" href="https://reactjs.org/tutorial/tutorial.html" rel="noopener ugc nofollow" target="_blank">比如这个</a>。大多数教程都假设您对JavaScript有所了解。但是，即使您从未使用JavaScript开发过，您也几乎可以肯定地理解它，不会有什么问题。</p><p id="4ab7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，我在学习React时经常遇到的一个问题是JavaScript的<a class="ae ky" href="https://scotch.io/tutorials/understanding-scope-in-javascript" rel="noopener ugc nofollow" target="_blank">上下文</a>。您将在React中编写的大部分JavaScript都是回调方法的形式。换句话说，您将编写一个能够响应某些事件(HTTP请求返回、用户点击按钮等)的组件。您将在该组件中编写一个回调方法，并注册该回调来处理该事件。任何Java开发人员都希望能够使用<code class="fe nr ns nt ni b">this</code>关键字来引用组件……毕竟，这是定义方法的地方。但是你不能…除非你在组件的构造函数中做了一件奇怪的事情:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="cea8" class="nm lw it ni b gy nn no l np nq">this.myCallback = this.myCallback.bind(this);</span></pre><p id="4012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要问我为什么。这只是一件事。大多数JavaScript教程都会简要涉及到这一点；一定要记住，尤其是当你的React错误消息试图告诉你你的<code class="fe nr ns nt ni b">myCallback()</code>方法试图调用另一个不存在的方法时。</p><h2 id="3189" class="nm lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">您将从React.js获得什么</h2><p id="62dd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">通过学习React.js，您将了解最流行的UI框架之一。你也将获得学习JavaScript的立足点。此外，您将学习一个直观的Web UI范例，它可以很好地与Java集成。</p><h1 id="777d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">是时候成长了</h1><p id="7d25" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我明白了。你喜欢Java，你对自己的职业生涯感到满意。但是过于舒适会对你的职业生涯、精神敏锐度以及(也许具有讽刺意味的)职业满足感造成损害。即使不离开Java生态系统，也有足够多的创新性东西可供尝试和学习。</p><h1 id="eca9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ul class=""><li id="87b6" class="ms mt it lb b lc mn lf mo li og lm oh lq oi lu mx my mz na bi translated"><a class="ae ky" href="https://stackify.com/10-of-the-most-popular-java-frameworks-of-2020/" rel="noopener ugc nofollow" target="_blank">https://stack ify . com/10-of-the-most-popular-Java-frameworks-of-2020/</a></li><li id="a48f" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://developers.redhat.com/blog/2019/03/07/quarkus-next-generation-kubernetes-native-java-framework/" rel="noopener ugc nofollow" target="_blank">https://developers . red hat . com/blog/2019/03/07/quar kus-next-generation-kubernetes-native-Java-framework/</a></li><li id="9a34" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://www.reactiveworld.net/2018/04/29/RxJava-vs-Java-Stream.html" rel="noopener ugc nofollow" target="_blank">https://www . react ive world . net/2018/04/29/rx Java-vs-Java-stream . html</a></li><li id="1b15" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://dzone.com/articles/functor-and-monad-examples-in-plain-java" rel="noopener ugc nofollow" target="_blank">https://dzone . com/articles/functor-and-monad-examples-in-plain-Java</a></li><li id="828d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://medium.com/@luijar/the-observable-disguised-as-an-io-monad-c89042aa8f31" rel="noopener">https://medium . com/@ lui jar/the-observable-伪装成一个io-monad-c89042aa8f31 </a></li><li id="d0c1" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://www.inc.com/brian-wong/how-learning-a-new-skill-helps-your-mind-grow-stronger.html" rel="noopener ugc nofollow" target="_blank">https://www . Inc . com/Brian-wong/how-learning-a-new-skill-helps-your-mind-grow-strong . html</a></li></ul></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="e42b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">觉得这个故事有用？想多读点？只需<a class="ae ky" href="https://dt-23597.medium.com/subscribe" rel="noopener">在这里订阅</a>就可以将我的最新故事直接发送到你的收件箱。</p><p id="ab17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天<a class="ae ky" href="https://dt-23597.medium.com/membership" rel="noopener">成为媒体会员</a>，你也可以支持我和我的写作，并获得无限数量的故事。</p></div></div>    
</body>
</html>