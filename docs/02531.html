<html>
<head>
<title>Learning Go: Slicing Slices and Other Tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习围棋:切片和其他任务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-go-slicing-slices-and-other-tasks-cdd3a089860f?source=collection_archive---------17-----------------------#2020-03-19">https://levelup.gitconnected.com/learning-go-slicing-slices-and-other-tasks-cdd3a089860f?source=collection_archive---------17-----------------------#2020-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/aed32e7fb334e0af66dd75c7fbf4ccea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KkkUT1FL1T2w7uNV"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">比安卡·阿克曼在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="166e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上一篇文章中，我向您介绍了切片数据结构，这是一种相同类型的未绑定数据序列。在本文中，我将向您展示如何从切片创建数据切片。</p><h1 id="9227" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">切片运算符</h1><p id="5171" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">slice运算符用于返回切片的子集。给定切片s，切片运算符为:</p><p id="72d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mh"> s【开始:停止】</em></p><p id="b228" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中<em class="mh"> start </em>是您想要用于子集的底层数组的第一个位置，而<em class="mh"> stop </em>标记您想要停止子集的位置之后的一个元素。</p><p id="4a15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一些切片操作符如何工作的例子:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a1b7" class="mr lf it mn b gy ms mt l mu mv">func main() {<br/>  letters := []string{"a","b","c","d","e"}<br/>  firstThree := letters[0:3]<br/>  fmt.Println(firstThree) // displays [a b c]<br/>  twoThree := letters[1:3]<br/>  fmt.Println(twoThree) // displays [b c]<br/>  firstOne := letters[:1]<br/>  fmt.Println(firstOne) // displays [a]<br/>  lastOne := letters[len(letters)-1 :]<br/>  fmt.Println(lastOne) // displays [e]<br/>  all := letters[:]<br/>  fmt.Println(all) // displays [a b c d e]<br/>}</span></pre><h1 id="6f2a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用切片运算符</h1><p id="8fe1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在这一节中，我将演示如何使用slice操作符编写一些有用的函数。</p><p id="f4d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将创建的第一个函数是<code class="fe mw mx my mn b">middle</code>。此函数将切片作为参数，并返回切片的中间元素，删除第一个和最后一个元素。下面是函数定义和一个测试程序:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="92b1" class="mr lf it mn b gy ms mt l mu mv">func middle(s []string) []string {<br/>  return s[1:len(s)-1]<br/>}</span><span id="8f77" class="mr lf it mn b gy mz mt l mu mv">func main() {<br/>  letters := []string{"a","b","c"}<br/>  fmt.Println(middle(letters))<br/>  words := []string{"now","is","the","time","for","all","good"}<br/>  fmt.Println(middle(words))<br/>}</span></pre><p id="2dfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来我要写的两个函数是<code class="fe mw mx my mn b">chopFront</code>和<code class="fe mw mx my mn b">chopBack</code>，它们分别取出切片的第一个元素和最后一个元素。下面是函数定义和一个测试程序:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f76c" class="mr lf it mn b gy ms mt l mu mv">func chopFront(s []string) []string {<br/>  return s[1:]<br/>}</span><span id="fd85" class="mr lf it mn b gy mz mt l mu mv">func chopBack(s []string) []string {<br/>  return s[0:len(s)-1]<br/>}</span><span id="02ae" class="mr lf it mn b gy mz mt l mu mv">func main() {<br/>  letters := []string{"a","b","c"}<br/>  fmt.Println(chopFront(letters))<br/>  fmt.Println(chopBack(letters))<br/>}</span></pre><p id="2554" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，下面是一个函数，它根据作为参数提供给该函数的开始和停止参数返回一个自定义切片:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a4da" class="mr lf it mn b gy ms mt l mu mv">func mySlice(s []string, start int, stop int) []string {<br/>  return s[start:stop]<br/>}</span><span id="2f20" class="mr lf it mn b gy mz mt l mu mv">func main() {<br/>  letters := []string{"a","b","c","d","e","f"}<br/>  fmt.Println(mySlice(letters, 2, 4))<br/>}</span></pre><h1 id="6ca2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从切片中移除元素</h1><p id="49b6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">没有用于从切片中移除元素的内置函数。我们将不得不自己编写这个函数。您不能就地从切片中移除项目，因此您必须通过将切片的两个部分(移除项目之前的部分和移除项目之后的部分)附加在一起并返回附加的切片来完成。</p><p id="1805" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个定义和一个测试程序:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4fae" class="mr lf it mn b gy ms mt l mu mv">func removeItem(s []string, index int) []string {<br/>  return append(s[:index], s[index+1:]...)<br/>}</span><span id="999c" class="mr lf it mn b gy mz mt l mu mv">func main() {<br/>  letters := []string{"a","b","c","d","e","f"}<br/>  letters = removeItem(letters, 2)<br/>  fmt.Println(letters)<br/>}</span></pre><p id="efbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">return语句末尾的省略号表示将返回切片中剩余的内容。</p><h1 id="103e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">零切片</h1><p id="ea68" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">没有任何数据的切片是一个<em class="mh">零</em>切片:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="b638" class="mr lf it mn b gy ms mt l mu mv">func main() {<br/>  var numbers []int<br/>  fmt.Println(numbers == nil) // displays true<br/>}</span></pre><p id="92cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">试图拿走一部分会导致恐慌:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="670a" class="mr lf it mn b gy ms mt l mu mv">func main() {<br/>  var numbers []int<br/>  fmt.Print(numbers[0:1]) // causes panic<br/>}</span></pre><p id="90aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此死机的输出如下所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e48f" class="mr lf it mn b gy ms mt l mu mv">panic: runtime error: slice bounds out of range [:1] with capacity 0</span><span id="0061" class="mr lf it mn b gy mz mt l mu mv">goroutine 1 [running]:<br/>main.main()<br/>c:/go/bin/test.go:8 +0x93<br/>exit status 2</span></pre><p id="a7bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果有可能出现零切片，您应该在对其执行操作之前测试该切片。</p><h1 id="f633" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">切片然后走</h1><p id="00fd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">切片是一种非常强大的数据结构，也是在Go中存储顺序数据的首选方式。对于大多数应用程序，您应该更喜欢使用切片而不是数组。切片的大小不固定，比数组更灵活。您始终可以从数组创建切片，或者如果数据尚未存储在数组中，也可以从一个新的数组开始。编程专家多年来一直建议使用动态数据结构，比如slice，而不是使用数组，你应该听从他们的建议。</p><p id="1a59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请将您的意见和建议通过电子邮件发送给我。</p></div></div>    
</body>
</html>