<html>
<head>
<title>Extensive introduction to why and how you might want to use and test redux-observable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广泛介绍为什么以及如何使用和测试redux-observable</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/extensive-introduction-to-why-and-how-you-might-want-to-use-and-test-redux-observable-1f2987407166?source=collection_archive---------12-----------------------#2020-01-27">https://levelup.gitconnected.com/extensive-introduction-to-why-and-how-you-might-want-to-use-and-test-redux-observable-1f2987407166?source=collection_archive---------12-----------------------#2020-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ba43b3311eb2df0c146d346d158474f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYI_gEiH-hbCXA6z0kkQHQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">和其他人一样，只是一张随机的图片(鸣谢:<a class="ae kc" href="https://unsplash.com/@genessapana" rel="noopener ugc nofollow" target="_blank">来自unsplash的Genessa Panainte </a></figcaption></figure><p id="e212" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated">我在我的公司努力为可重复观测的操作编写一些测试。大多数网络请求由RxJS管理，没有一个被测试覆盖。我想写测试，但是不知道怎么写。</p><p id="4993" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我真的只想从基础开始——我的意思是，非常基础的，包括为什么，以及我们可能想要如何使用<code class="fe lk ll lm ln b">redux-observable</code>。</p><h1 id="b399" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">TL；博士；医生</h1><p id="e630" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">如果你想直接进入源代码，这里有<a class="ae kc" href="https://github.com/9oelM/redux-observable" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="9238" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">什么是反应式编程？</h1><p id="c714" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated"><a class="ae kc" href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754#reactive-programming-is-programming-with-asynchronous-data-streams" rel="noopener ugc nofollow" target="_blank">反应式编程</a>是用异步数据流编程。</p><ul class=""><li id="a784" class="mr ms iq kf b kg kh kk kl ko mt ks mu kw mv la mw mx my mz bi translated">典型的事件是异步事件流，您希望观察它们</li><li id="449a" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated">您有一些有用的函数来组合/创建/过滤这些流</li></ul><p id="b187" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">流</strong>是按时间顺序排列的一系列正在进行的事件。它可以发出三种不同的东西:一个值(某种类型)、一个错误或一个“完成”信号。</p><p id="80a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只异步地捕获这些发出的事件，通过<strong class="kf ir">定义一个在发出一个值时执行的函数，</strong>定义另一个在发出一个错误时执行的函数，以及定义另一个在“完成”时执行的函数。</p><p id="1506" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以这实质上是回到了观察者设计模式。</p><h1 id="9dfb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">何必用RxJS？</h1><h2 id="e86e" class="nf lp iq bd lq ng nh dn lu ni nj dp ly ko nk nl mc ks nm nn mg kw no np mk nq bi translated">抽象</h2><p id="bfb9" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">如果你使用RP，你不必真的担心实现细节，因为它给你一个高层次的抽象层。所以你再也不用担心javascript中的<code class="fe lk ll lm ln b">Promise</code>和<code class="fe lk ll lm ln b">await</code>了。只需要声明性地实现你想做的事情，就可以了。</p><h2 id="2e42" class="nf lp iq bd lq ng nh dn lu ni nj dp ly ko nk nl mc ks nm nn mg kw no np mk nq bi translated">异步工作变得更加简单</h2><p id="c6d9" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">如今，异步操作已经变得很常见，因为你可能需要处理UI交互&amp;大量的网络请求。</p><p id="95dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以它很有可能非常适合基于网络的应用程序(包括前端和后端)。</p><h2 id="cd7e" class="nf lp iq bd lq ng nh dn lu ni nj dp ly ko nk nl mc ks nm nn mg kw no np mk nq bi translated">大量的助手函数以声明的方式简化工作</h2><p id="2433" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">你有专门的助手函数来实现你想要做的事情，否则你可能会以一种非常复杂的方式来完成。即使你现在还没有完全意识到这一点，当你阅读这篇文章时，你会注意到这一点。</p><h1 id="9da4" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">何必和Redux一起用呢？</h1><p id="6eed" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">现在我们对使用RxJS的优势有了一个简单的了解。现在，我们想在Redux中处理动作，但并不是所有的动作都是同步的。</p><p id="7d7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">举个简单的例子，我编写了一个应用程序，它从服务器获取文本并显示出来，如下所示:</p><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/975299c36605690c9cc3b27e39dbdf51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Qh_A8y_VSV7iUuiUbIhEtg.gif"/></div></div></figure><blockquote class="nw nx ny"><p id="e435" class="kd ke nz kf b kg kh ki kj kk kl km kn oa kp kq kr ob kt ku kv oc kx ky kz la ij bi translated"><em class="iq">我假设你事先了解一些Typescript和React基础知识，包括钩子。</em></p></blockquote><p id="8c38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是项目结构(省略不重要的):</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="3df6" class="nf lp iq bd lq ng nh dn lu ni nj dp ly ko nk nl mc ks nm nn mg kw no np mk nq bi translated">先还原相关的东西</h2><p id="a6f0" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">为了能够理解使用redux-observable的真正好处，我们需要首先了解redux是如何工作的，这样我们就可以进行比较(如果您已经知道如何使用bare redux处理异步操作，可以跳过这一部分)</p><p id="816b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在redux中，如你所知，我们主要有actions和reducers。我创建了三种类型的操作:</p><ol class=""><li id="5739" class="mr ms iq kf b kg kh kk kl ko mt ks mu kw mv la of mx my mz bi translated"><code class="fe lk ll lm ln b">StartRequestText</code>:我将在从虚拟文本API中<code class="fe lk ll lm ln b">fetch</code>出来之前<code class="fe lk ll lm ln b">dispatch</code>这个。</li><li id="0281" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la of mx my mz bi translated"><code class="fe lk ll lm ln b">FinishRequestText</code>:收到短信后我会马上<code class="fe lk ll lm ln b">dispatch</code>。</li><li id="26e5" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la of mx my mz bi translated"><code class="fe lk ll lm ln b">ErrorRequestText</code>:我会在上述过程中一遇到错误就<code class="fe lk ll lm ln b">dispatch</code>这样做。</li></ol><p id="b210" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上动作在<code class="fe lk ll lm ln b">actions.ts</code>中是这样实现的:</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="df4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在<code class="fe lk ll lm ln b">constants.ts</code>中简单定义了一些动作类型:</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="3544" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">把它们放进<code class="fe lk ll lm ln b">reducer.ts</code>一点都不难。我们只需要更新每个不同动作的状态。你可以看到我正在根据一个<code class="fe lk ll lm ln b">action</code>的每个<code class="fe lk ll lm ln b">type</code>分别更新<code class="fe lk ll lm ln b">isLoading</code>、<code class="fe lk ll lm ln b">text</code>和<code class="fe lk ll lm ln b">errorMsg</code>:</p><p id="f3ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">reducer.ts</code></p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1612" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，在<code class="fe lk ll lm ln b">store.ts</code>中没有那么多。只需组合减速器(尽管我们只有一个，这在生产环境中并不常见)并配置redux devtools扩展，然后创建存储。</p><p id="5bcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">store.ts</code></p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="cefd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在<code class="fe lk ll lm ln b">types.ts</code>中定义了我们需要的类型:</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="ae70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">App.tsx</code>在父组件中，我们只想显示两样东西:按钮和文本。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="2080" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">DummyTextRequestButton.tsx</code></p><p id="f0d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个组件中，我们有调度我们前面定义的所有动作的逻辑。你必须认识到，我们希望将<code class="fe lk ll lm ln b">handleClick</code>中的逻辑移植到以后的<code class="fe lk ll lm ln b">redux-observable</code>中，因为现在它根本没有反应。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="7403" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">DummyTextViewer.tsx</code></p><p id="9061" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该组件消耗redux状态。基于状态显示错误、文本或加载。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><h1 id="9062" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">用RxJS和redux-observable？</h1><p id="d217" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">首先，我们将向我们的项目介绍相关模块:</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e7c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们想去掉<code class="fe lk ll lm ln b">DummyTextRequestButton.tsx</code>内部有些复杂的逻辑:</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="035f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以像上面这样做，因为我们要将我们的逻辑移植到<code class="fe lk ll lm ln b">redux-observable</code>。</p><p id="444a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将在<code class="fe lk ll lm ln b">redux</code>文件夹中创建一个名为<code class="fe lk ll lm ln b">epics.ts</code>的东西:</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><blockquote class="nw nx ny"><p id="5f3a" class="kd ke nz kf b kg kh ki kj kk kl km kn oa kp kq kr ob kt ku kv oc kx ky kz la ij bi translated"><em class="iq">一个</em> <strong class="kf ir"> <em class="iq">史诗</em> </strong> <em class="iq">其实就是监听一个redux动作，并相应输出其他动作的东西。</em></p></blockquote><p id="a688" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么上面的代码是如何做到的呢？我们可以看到<code class="fe lk ll lm ln b">startRequestTextEpic</code>正在监听一个名为<code class="fe lk ll lm ln b">C.START_REQUEST_TEXT</code>的动作。所以这段代码不会被执行，如果redux分派了其他动作。</p><p id="a30d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，暂时忘掉<code class="fe lk ll lm ln b">mergeMap</code>，然后我们继续。我们可以看到，我们正在使用RxJS自己的名为<code class="fe lk ll lm ln b">fromFetch</code>的<code class="fe lk ll lm ln b">fetch</code>方法，本质上只是将<code class="fe lk ll lm ln b">fetch</code>变成一个可观察的。</p><p id="e364" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您处理来自<code class="fe lk ll lm ln b">fetch</code>的响应，响应中的<code class="fe lk ll lm ln b">text</code>将成为<code class="fe lk ll lm ln b">finishRequestText</code>动作的有效负载。</p><p id="7c66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，如果您在<code class="fe lk ll lm ln b">fetch</code>运行时出错，该错误将被捕获，并会调度<code class="fe lk ll lm ln b">errorRequestText</code>操作。</p><p id="45ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种方式，我们已经成功地将我们在<code class="fe lk ll lm ln b">handleClick</code>中的实现移植到epic内部，剩下我们要做的就是实际配置<code class="fe lk ll lm ln b">store.ts</code>中的一些东西，以便能够在我们的项目中使用<code class="fe lk ll lm ln b">redux-observable</code>:</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="401e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，加上<code class="fe lk ll lm ln b">redux-observable</code>之后，现在我们有了一些好处:</p><ol class=""><li id="79ec" class="mr ms iq kf b kg kh kk kl ko mt ks mu kw mv la of mx my mz bi translated">反应性。在redux中，通过对被调度的动作做出反应，可以很容易地处理异步动作和状态更新。</li><li id="f368" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la of mx my mz bi translated">关注点分离。现在你不必关心<code class="fe lk ll lm ln b">DummyTextButton</code>中的<code class="fe lk ll lm ln b">startRequestText</code>之后做什么，因为所有的逻辑都已经移植到<code class="fe lk ll lm ln b">startRequestTextEpic</code>了。</li><li id="5a24" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la of mx my mz bi translated">伟大的工具链。现在我们只使用了RxJS中的几个函数，但是许多函数的组合将使处理数据流变得更加容易。</li></ol><h1 id="9914" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">通过利用RxJS所拥有的进一步扩展</h1><p id="3c7a" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">现在我们有一个小问题:当用户在如此短的时间内多次点击按钮时，请求将被发送多次，这可能是无用的，如下图所示:</p><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/0ae32d83d42433d8dfa55b7a919c4ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8jN3kpzDFSalsJ2-igqEFA.gif"/></div></div></figure><p id="ca48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我点击了三次按钮，但实际上你们所需要的只是一个请求。所以你可以这么做:</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1160" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们刚刚添加了<code class="fe lk ll lm ln b">debounce</code>，它将在一秒钟内只过滤掉一个类型为<code class="fe lk ll lm ln b">START_REQUEST_TEXT</code>的动作，这意味着即使你在一秒钟内点击按钮三次，请求也只会被发送一次，如下图所示:</p><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/43cd5856905e7a94b5c174becee7dbec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vJIKHyD8eD4md9T9wxN0Ig.gif"/></div></div></figure><p id="1b4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，你更想要的其实是<code class="fe lk ll lm ln b">switchMap</code>；它将取消任何未决请求，并切换到最后一个请求:</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/f9d312d4c8ef279a943d2cf92031ca16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GGEdTm_0eA4NBD18Dd43Hg.gif"/></div></div></figure><p id="588f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，假设您有另一个按钮来显示其他文本，如下所示:</p><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/a6ce83e5a5d27c9acfa67f5ce71c06a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7EPpMVogNObk75_SeEFU5Q.gif"/></div></div></figure><p id="f2f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们现在有了一个额外的UI，所以我们需要处理一个特殊情况(我们不打算讨论其他情况，尽管有很多):<strong class="kf ir">您单击了请求虚拟文本按钮，但是您改变主意看到hi而不是</strong>。然后，您需要<strong class="kf ir">取消并完成</strong>您的操作。</p><p id="3c5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简单起见，我不打算展示整个代码，而是用<code class="fe lk ll lm ln b">epics.ts</code>来演示(您仍然可以从Github库查看<a class="ae kc" href="https://github.com/9oelM/redux-observable/tree/master/redux-observable" rel="noopener ugc nofollow" target="_blank">整个代码库):</a></p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="9af5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有两个主要部分:<code class="fe lk ll lm ln b">sendRequest$</code>和<code class="fe lk ll lm ln b">cancelRequest$</code>。在<code class="fe lk ll lm ln b">cancelRequest$</code> ovservable中，我们将强制完成请求文本，因为如果您已经切换到查看<code class="fe lk ll lm ln b">hi</code>文本，就不再需要请求文本了。</p><p id="aefb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lk ll lm ln b">race</code>如果其他行动结束，将取消任何其他正在进行的行动。就像javascript里的<code class="fe lk ll lm ln b">Promise.race</code>一样！所以，我们用gif来看看这个:</p><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/72af6b44a0138d0ce1211a41d1ee42c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-W6L7V0X0VHTc7X86z_kcQ.gif"/></div></div></figure><h2 id="0864" class="nf lp iq bd lq ng nh dn lu ni nj dp ly ko nk nl mc ks nm nn mg kw no np mk nq bi translated">检查站</h2><p id="18db" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">你现在明白为什么要使用redux-observable了吗？它为您提供了一套很好的工具，用于在redux中调度操作后执行副作用。否则，用普通的javascript手动管理像取消这样的事件将会非常痛苦。</p><p id="f5fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，嘿，我们还没完呢。让我们以如何测试这些史诗的指南来结束它。</p><h1 id="e60c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">测试你的史诗</h1><h2 id="5531" class="nf lp iq bd lq ng nh dn lu ni nj dp ly ko nk nl mc ks nm nn mg kw no np mk nq bi translated">方法1:基于输入动作测试输出动作。</h2><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="5089" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喔，有很多事情要经历，对吧？但基本上，我们所做的只是:</p><ol class=""><li id="c915" class="mr ms iq kf b kg kh kk kl ko mt ks mu kw mv la of mx my mz bi translated"><strong class="kf ir">模仿某些模块的功能，使它们按照我们的目的工作</strong>。我们嘲笑<code class="fe lk ll lm ln b">rxjs.race</code>和<code class="fe lk ll lm ln b">FF.fromFetch</code>,因为对于<code class="fe lk ll lm ln b">race</code>,我们不希望race在测试环境中不能很好地工作，我们可以决定发出哪个可观测值，而不是依赖于代码本身，对于<code class="fe lk ll lm ln b">fromFetch</code>,我们不希望使用真正的<code class="fe lk ll lm ln b">fetch</code>,因为这将毫无意义地花费更多时间。</li><li id="6ec7" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la of mx my mz bi translated"><strong class="kf ir">运行带有初始动作和状态的epic</strong>。史诗会运行，结果会吐出另一组动作。</li><li id="ba2d" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la of mx my mz bi translated"><strong class="kf ir">测试输出动作与预期的</strong>是否相等。我们只需要测试epic是否给出了预期的动作集。</li></ol><p id="f306" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">差不多就是这样！但是我们需要测试更多，那么为什么不用一个简单的函数来简化这个过程呢？：</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="9cea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以把测试变成:</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="3bb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更少的样板，对不对？</p><p id="56bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们也可以写出其他东西的测试，就像这样:</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="a348" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你必须看到你所有的测试都通过了:</p><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/109f8d22d92fea4b3e85af53109643e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZMqpDe30Ngd0AdwPmqH9g.png"/></div></div></figure><h2 id="fe39" class="nf lp iq bd lq ng nh dn lu ni nj dp ly ko nk nl mc ks nm nn mg kw no np mk nq bi translated">方法2:使用大理石测试</h2><p id="becc" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">以前，我们只使用了一些基本的方法来测试史诗。使用marble测试可以让你在和<em class="nz">发生什么事情的时候更加关注<em class="nz">。</em></em></p><p id="20c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不熟悉大理石图，请参考<a class="ae kc" href="http://reactivex.io/documentation/observable.html" rel="noopener ugc nofollow" target="_blank">react vex对大理石图的解释</a>。或者，网上还有许多其他好的资源。</p><p id="ce46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于大理石语法，请参考<a class="ae kc" href="https://rxjs-dev.firebaseapp.com/guide/testing/marble-testing#marble-syntax" rel="noopener ugc nofollow" target="_blank"> rxjs API文档</a>。</p><h2 id="6ed8" class="nf lp iq bd lq ng nh dn lu ni nj dp ly ko nk nl mc ks nm nn mg kw no np mk nq bi translated">热对比冷观察</h2><p id="fd37" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">有一篇关于媒介的很棒的文章简化了冷热可观测量的定义<a class="ae kc" href="https://medium.com/@bencabanes/marble-testing-observable-introduction-1f5ad39231c#f123" rel="noopener">，所以我摘录了其中的定义</a>。(或者看<a class="ae kc" href="https://rxjs-dev.firebaseapp.com/guide/testing/marble-testing" rel="noopener ugc nofollow" target="_blank"> rxjs API文档</a>)</p><p id="9f3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">cold:测试开始时开始订阅。</p><blockquote class="nw nx ny"><p id="7943" class="kd ke nz kf b kg kh ki kj kk kl km kn oa kp kq kr ob kt ku kv oc kx ky kz la ij bi translated"><code class="fe lk ll lm ln b"><em class="iq">cold(--a--b--|, { a: 'Hello', b: 'World' })</em></code><em class="iq">→30毫秒发出“Hello”，60毫秒发出“World”，90毫秒完成。</em></p></blockquote><p id="9fc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">hot:从插入符号处开始订阅。</p><blockquote class="nw nx ny"><p id="27a0" class="kd ke nz kf b kg kh ki kj kk kl km kn oa kp kq kr ob kt ku kv oc kx ky kz la ij bi translated"><code class="fe lk ll lm ln b"><em class="iq">hot(--^--a--b--|, { a: 'Hello', b: 'World' })</em></code> <em class="iq"> →订阅从插入符号开始，然后在30毫秒时发出“Hello ”,在60毫秒时发出“World ”,在90毫秒时完成。</em></p></blockquote><h2 id="fd35" class="nf lp iq bd lq ng nh dn lu ni nj dp ly ko nk nl mc ks nm nn mg kw no np mk nq bi translated">测试与时间相关的事件</h2><p id="ed03" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">使用方法1我们无法真正回答的是类似“如果有多个动作输入，动作真的可以被取消吗，因为我们使用了<code class="fe lk ll lm ln b">switchMap</code>？”</p><p id="43f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们可以控制时间，这是完全可能的。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="756a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个真的很基础；我们请求文本，为了测试，我们通过<code class="fe lk ll lm ln b">1</code> ms延迟了来自<code class="fe lk ll lm ln b">fromFetch</code>的响应。然后我们运行<code class="fe lk ll lm ln b">START_REQUEST_TEXT</code>，并期望在另一个<code class="fe lk ll lm ln b">1</code> ms过去后输出动作为<code class="fe lk ll lm ln b">FINISH_REQUEST_TEXT</code>。简单。对吗？</p><p id="860b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是对于一些更复杂的测试呢，比如因为<code class="fe lk ll lm ln b">switchMap</code>而取消的动作？：</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="1a80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们再次伪造<code class="fe lk ll lm ln b">fromFetch</code>，这一次它将在<code class="fe lk ll lm ln b">5</code> ms之后得到您的响应。现在您决定在<code class="fe lk ll lm ln b">4ms</code>中连续四次使用<code class="fe lk ll lm ln b">START_REQUEST_TEXT</code>，每次使用<code class="fe lk ll lm ln b">1ms</code>。</p><p id="b8dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么应该发生的是所有的<code class="fe lk ll lm ln b">a</code>、<code class="fe lk ll lm ln b">b</code>、<code class="fe lk ll lm ln b">c</code>都被取消，因为它们被紧随其后的动作取消，而此时<code class="fe lk ll lm ln b">fromFetch</code>还没有返回响应。这正是<code class="fe lk ll lm ln b">switchMap</code>所要做的。它会取消其他的可观测，只发射最体面的投射可观测，也就是<code class="fe lk ll lm ln b">d</code>(在<code class="fe lk ll lm ln b">5ms</code>之后)。</p><p id="aa31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以基本就是这样！当然，我们可以再次对这个测试逻辑进行抽象，就像我们对<code class="fe lk ll lm ln b">runEpicTest</code>所做的那样，但是太糟糕了——我现在太累了，所以我将把这项工作留给你。:)</p><h1 id="9a5d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="c9f8" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">到目前为止，我们已经介绍了:</p><ol class=""><li id="4964" class="mr ms iq kf b kg kh kk kl ko mt ks mu kw mv la of mx my mz bi translated">为什么你可能想要使用<code class="fe lk ll lm ln b">rxjs</code>和<code class="fe lk ll lm ln b">redux-observable</code>(也许你可以在评论区提出更多的理由)</li><li id="f56b" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la of mx my mz bi translated">如何将基于<code class="fe lk ll lm ln b">redux</code>的代码替换成基于<code class="fe lk ll lm ln b">redux-observable</code>的代码</li><li id="dae0" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la of mx my mz bi translated">使用<code class="fe lk ll lm ln b">redux-observable</code>的可扩展性(好处)，特别是对于复杂的逻辑</li><li id="6c13" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la of mx my mz bi translated">测试你的<code class="fe lk ll lm ln b">epic</code>的两种方法</li></ol><h1 id="9e9c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">附录</h1><p id="36e8" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">只是给你一些遗言。</p><h2 id="04c6" class="nf lp iq bd lq ng nh dn lu ni nj dp ly ko nk nl mc ks nm nn mg kw no np mk nq bi translated">对“永远是通行证”的怀疑</h2><p id="8230" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">有时，很难知道您的测试是否真的有效，或者只是通过了测试，因为jest比您想要的时间更早地完成了测试。<a class="ae kc" href="https://jestjs.io/docs/en/asynchronous" rel="noopener ugc nofollow" target="_blank">确保你使用了</a> <code class="fe lk ll lm ln b"><a class="ae kc" href="https://jestjs.io/docs/en/asynchronous" rel="noopener ugc nofollow" target="_blank">done</a></code>，如果你仍然不确定，试着通过把<code class="fe lk ll lm ln b">expect(...).toEqual(...)</code>改成<code class="fe lk ll lm ln b">expect(...).not.toEqual(...)</code>来打破测试。那么您应该会看到这样的内容:</p><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/8bcae4620b1641d1fe8786256082310f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDyC3hzV-6wP9myFegLi7w.png"/></div></div></figure><p id="7bcd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你的测试仍然通过，那就有问题了。</p><h2 id="b2f1" class="nf lp iq bd lq ng nh dn lu ni nj dp ly ko nk nl mc ks nm nn mg kw no np mk nq bi translated">我不应该测试epic如何改变状态吗？</h2><p id="b845" class="pw-post-body-paragraph kd ke iq kf b kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">不。因为你应该在<em class="nz">上测试一个动作集如何输出另一个动作集。</em></p><p id="71ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您将在reducer的测试中测试这一点，因为reducer实际上是操作将改变状态的地方。</p><p id="8301" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">epic真正做的只是直到调度动作。当然，它与状态有关，因为它使用它，但它不直接修改状态。那就要留给减速器的角色了。</p><h2 id="38f8" class="nf lp iq bd lq ng nh dn lu ni nj dp ly ko nk nl mc ks nm nn mg kw no np mk nq bi translated">源代码库</h2><ul class=""><li id="7f0b" class="mr ms iq kf b kg mm kk mn ko oi ks oj kw ok la mw mx my mz bi translated"><a class="ae kc" href="https://github.com/9oelM/redux-observable/tree/master/redux-only" rel="noopener ugc nofollow" target="_blank"> redux实现</a></li><li id="1b3f" class="mr ms iq kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated"><a class="ae kc" href="https://github.com/9oelM/redux-observable/tree/master/redux-observable" rel="noopener ugc nofollow" target="_blank"> redux-observable实现和测试</a></li></ul><p id="dfb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有…谢谢你的阅读！</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="5ae4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nz">最初发表于</em><a class="ae kc" href="https://9oelm.github.io/2020-01-24--Fundamental-yet-extensive-introduction-to-why-and-how-you-might-want-to-use-redux-observable-for-async-actions/" rel="noopener ugc nofollow" target="_blank"><em class="nz">https://9oelm.github.io/2020-01-24-基本但广泛-介绍-为什么和如何你可能想要使用-redux-observable-for-async-actions/</em></a><em class="nz">。</em></p></div></div>    
</body>
</html>