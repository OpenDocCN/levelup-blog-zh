# Laravel:用 Stripe 对订阅付费进行闪电般的快速测试

> 原文：<https://levelup.gitconnected.com/laravel-lightning-fast-testing-for-subscription-payments-with-stripe-167cfb43280a>

## 我应该有一个基本的测试套件，可以在没有互联网连接的情况下运行，而且应该非常快。他们两个，同时。

![](img/67278a95e7a63fea5fd06de2b26b0da9.png)

在 [Unsplash](/s/photos/speed?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上由 [Veri Ivanova](https://unsplash.com/@veri_ivanova?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄的照片

由于其易用性，Laravel 一直是我所有辅助项目的首选框架，但最近在将[收银员](https://laravel.com/docs/7.x/billing)集成到[娜娜](https://nana-landing.netlify.app/)时，我发现在使用收银员时没有简单的方法来测试订阅创建流程。文档建议您对 Stripe 的测试 API 进行真正的调用:

> 当测试一个使用 Cashier 的应用程序时，您可以模拟对 Stripe API 的实际 HTTP 请求；但是，这需要您部分地重新实现出纳自己的行为。因此，我们建议允许您的测试触及实际的条带 API。

对于某些情况来说，这可能是一个好建议，并且肯定会提供一个端到端测试流的好方法，并且它有一些优点:

*   可以端到端地测试流程，以及应用程序中的 API 契约和端点。
*   由于能够在一个测试用例中测试多个单元，比如身份验证、数据库交互、收银员、支付流程等等，所以测试总体上更有信心。

但它也有自己的问题:

*   在条带测试仪表板中需要有测试数据设置，这使得在新项目中复制变得棘手。
*   添加到条带的测试数据必须保持最新，并且必须根据需要随测试一起单独更新。
*   如果测试数据不一定要在 Stripe 仪表板上，测试将需要构建测试数据，并在每次测试后进行清理，这意味着即使对于简单的测试来说，也有相当多的样板代码。
*   根据 Stripe 文档，如果您有许多测试，在测试模式[下每秒 25 个请求，您可以达到 Stripe APIs 速率限制。](https://stripe.com/docs/rate-limits)
*   测试将会变得更慢，使你的整体反馈循环更慢。

虽然这些缺点中的一些可以通过一些巧妙的技巧来解决，但它仍然不是最好的方法。对于我的用例来说，我更愿意采用这样的流程，即只需要设置一次条带测试数据，并使测试依赖于它们；然而，Nana 应该是 Laravel 的一个非常简单的入门套件，因此让用户在 Stripe dashboard 上一个接一个地进行设置不是一个选项。另一个选择是包含一个一次性脚本来在 Stripe 上进行设置，但这也不是最理想的，因为该文件一旦执行就会变成死代码，我不想让用户感到困惑。我必须找到一个替代方案。

# 输入预言

对于那些不知道[预言](https://github.com/phpspec/prophecy)的人来说，这是一个非常简单的嘲笑 PHP 的库。预言允许您轻松地为模拟对象定义行为和返回值:

```
// Create your mock
$mockUser = $this->prophesize(\App\User::class);// Define the behavior and return value
$mockUser->doSomething()
    ->shouldBeCalled()
    ->willReturn('something done');
```

预言与我将在本文后面展示的技巧并不十分相关，它只是为下面的例子奠定了基础。实际上，任何模拟库都应该可以工作。

# 处理订阅创建

假设您有一个简单的定价结构，用户选择了其中一个选项并结帐。此时，您必须用给定的信息为用户创建一个订阅。

一个假想的控制器来演示测试。

我们只是从请求中接收了与支付相关的信息，附加了优惠券(如果存在的话)，并创建了订阅。为了简单起见，这里没有显示请求的验证，**请不要在生产中使用这个控制器。**我们不打算处理接口，因为这一点无关紧要。

# 测试控制器

现在你已经准备好了你的控制器，我们要测试它。一种简单的方法是构建一个常规的功能测试，让用户调用端点，并观察在 Stripe 上创建的订阅，但正如我们之前提到的，我们不想进行互联网调用，因为我们希望我们的测试简单而快速，而不仅仅是简单或快速。

下面是我们控制器的测试函数:

假设终点的示例测试。

正如您所看到的，测试从定义公共请求变量开始，然后继续定义订阅模拟的行为。`SubscriptionBuilder`类是我们控制器类中`$user->subscription()`的返回值；所以，我们首先需要做好准备。

*   控制器应该附加优惠券，所以定义`withCoupon`方法行为。
*   控制器应该尝试创建订阅，所以用参数`$paymentMethodId`定义`create`方法。

一旦我们准备好了 subscription builder，我们需要将它附加到我们的用户对象:

*   当用这些字符串参数调用`$user`对象的`newSubscription()`方法时，mock 将返回我们刚刚准备好的订阅构建器。

至此，我们完成了模拟，可以执行实际的请求了。它只是对订阅创建端点的一个`POST`请求，它包括我们在函数开始时定义的请求参数。

这里的技巧是在执行`POST`请求之前调用方法`actingAs`。该值将自动与控制器使用的`$request->user()`方法相关联，并允许我们完全按照自己的意愿定义用户的行为，而无需在数据库上设置任何东西，无需工厂，也绝对无需互联网调用。

就是这样。现在，您可以使用这种方法来模拟您的收银员依赖性，而无需进行任何外部调用，并确保您的测试保持超快的速度。

# 我为什么要用这种方法？

就像任何其他技术决策一样，这种方法也有其优点和缺点。

## 不足之处

这种方法的缺点是:

*   它需要模仿一些应用程序内部的行为，比如用户对象上的`subscription()`方法。如果您没有在用户模型上正确设置 Cashier，这些测试仍然会通过。
*   它没有端到端地测试流，这意味着如果您的管道中有其他问题，比如发送无效的令牌或优惠券，这些测试仍然会通过。
*   它要求您正确定义控制器中使用的方法的返回值。

## 优势

尽管这种方法有一些缺点，但它仍然有很多价值:

*   没有必要测试出纳的内部，就像[出纳文档](https://laravel.com/docs/7.x/billing#testing)中建议的那样。

> 在测试时，请记住收银台本身已经有了一个很好的测试套件，所以您应该只关注于测试您自己的应用程序的订阅和支付流程，而不是每一个底层的收银台行为。

*   测试仍然覆盖控制器的外围设备，比如路由和请求变量传递，这比仅仅构建一个控制器实例并直接调用其`save`方法要好。
*   它不需要任何互联网或数据库连接，而且**超级快。**
*   由于它不依赖于 Stripe 的 API，因此不存在速率限制或网络调用失败的风险。

# 结论

总的来说，这种方法似乎满足了我的需求。它涵盖了足够多的应用程序，并为这样一项小小的工作提供了足够的价值。接下来，让测试也调用 Stripe API 将是有益的，这可能被分组并仅在主构建上或仅在需要时执行，这两种方法可以很容易地一起工作，并且还允许您在出现 bug 时隔离您的问题。对于 Nana 来说，这种方法肯定允许我用测试覆盖所有与支付/订阅相关的端点，这样用户就可以在这些特性的基础上进行构建，而无需关心在 Stripe 上设置任何东西。

既然你已经设法读到这里，这里有一张可爱鹦鹉的照片作为感谢:

![](img/b05e88d9af5de68a78e91f60c23be9af.png)

凯文·穆勒在 [Unsplash](/s/photos/animal?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片