<html>
<head>
<title>Everything you need to know about the `passport-local` Passport JS Strategy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于“护照-当地”护照JS策略，您需要了解的一切</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/everything-you-need-to-know-about-the-passport-local-passport-js-strategy-633bbab6195?source=collection_archive---------0-----------------------#2020-01-11">https://levelup.gitconnected.com/everything-you-need-to-know-about-the-passport-local-passport-js-strategy-633bbab6195?source=collection_archive---------0-----------------------#2020-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c91b99bd032db86f60d9e3dc4936211a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1h_F5eoAroDD0-HjgKWVbA.png"/></div></div></figure><p id="279f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将介绍为什么对于实施Node/Express web应用程序的小型团队和初创公司来说,<code class="fe kz la lb lc b">passport-local</code>身份验证策略是一个简单、安全的解决方案。</p><p id="1c5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章与我关于<code class="fe kz la lb lc b">passport-jwt</code>策略和<a class="ae ld" href="https://medium.com/@zach.gollwitzer/everything-you-need-to-know-about-the-passport-jwt-passport-js-strategy-8b69f39014b0" rel="noopener">的文章紧密相关，你可以在这里找到。</a></p><p id="1939" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了帮助你完成这篇文章，我用这里的所有代码创建了一个Github Repo:<a class="ae ld" href="https://github.com/zachgoll/express-session-authentication-starter" rel="noopener ugc nofollow" target="_blank">基于会话的授权报告</a></p><h1 id="c030" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">目录</h1><ul class=""><li id="4eda" class="mc md it kd b ke me ki mf km mg kq mh ku mi ky mj mk ml mm bi translated"><a class="ae ld" href="#4e42" rel="noopener ugc nofollow">认证选择</a></li><li id="5027" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae ld" href="#9732" rel="noopener ugc nofollow">什么是基于会话的认证？</a></li><li id="5ab7" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae ld" href="#7948" rel="noopener ugc nofollow"> HTTP头</a></li><li id="68af" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae ld" href="#76f6" rel="noopener ugc nofollow">cookie的工作原理</a></li><li id="1df5" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae ld" href="#0558" rel="noopener ugc nofollow">现实中的这种情况</a></li><li id="60f3" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae ld" href="#bfbd" rel="noopener ugc nofollow">会话如何工作</a></li><li id="d40d" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae ld" href="#9406" rel="noopener ugc nofollow">快速复习快速中间件</a></li><li id="66a1" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae ld" href="#1334" rel="noopener ugc nofollow">快速会话中间件如何工作</a></li><li id="7080" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae ld" href="#ded8" rel="noopener ugc nofollow">Passport JS本地策略如何工作</a></li><li id="52c3" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae ld" href="#d9fe" rel="noopener ugc nofollow">基于会话的认证的概念概述</a></li><li id="9b14" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae ld" href="#aff2" rel="noopener ugc nofollow">基于会话的认证实现</a></li><li id="6a63" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated"><a class="ae ld" href="#c0b8" rel="noopener ugc nofollow">回顾和预览</a></li></ul><h1 id="4e42" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">认证选择</h1><figure class="mt mu mv mw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/a3069e4e31d0e3ce253504eb1be86278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NWrZ6GbApzspYAzsqdtghQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">您的身份验证选择</figcaption></figure><p id="101d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以上是对当今开发人员可用的主要身份验证选择的高级概述。以下是对每一项的快速概述:</p><ul class=""><li id="3aab" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky mj mk ml mm bi translated">基于会话的身份验证—利用浏览器Cookies和后端“会话”来管理登录和注销的用户。</li><li id="ae57" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">JWT认证——一种无状态认证方法，其中JSON Web令牌(JWT)存储在浏览器中(通常是<code class="fe kz la lb lc b">localStorage</code>)。该JWT具有关于用户的断言，并且只能使用存储在服务器上的秘密来解码。</li><li id="b394" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">OAuth和OpenID连接身份验证—一种现代身份验证方法，其中应用程序使用其他应用程序生成的“声明”来验证自己的用户。换句话说，这是联合身份验证，其中现有的服务(如Google)处理用户的身份验证和存储，而您的应用程序利用这个流程来验证用户。</li></ul><p id="8fb5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我要注意的一点是——Oauth很快就会变得令人困惑，因此在这篇文章中没有对它进行全面的探讨。对于一个小团队/初创公司来说，不仅没有必要开发一个应用程序，而且根据你使用的服务(如谷歌、脸书、Github等)的不同，它也会略有不同。).</p><p id="e8f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，您可能会注意到OAuth被列为“作为服务”和“内部”。这是一个特别的注释，用来强调这样一个事实:实际上有一家名为“OAuth”的公司将OAuth协议实现为一项服务。不使用OAuth公司的服务也可以实现OAuth协议！</p><h1 id="9732" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是基于会话的身份验证？</h1><p id="6b98" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">如果我们要为这些身份验证方法创建一个谱系，基于会话的身份验证将是其中最古老的，但肯定不会过时。基于会话的身份验证是<code class="fe kz la lb lc b">passport-local</code>策略的基础。这种身份验证方法是“服务器端的”，这意味着我们的Express应用程序和数据库协同工作，以保持访问我们应用程序的每个用户的当前身份验证状态。</p><p id="ee0b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要理解基于会话的身份验证的基本原则，您需要理解几个概念:</p><ul class=""><li id="a85b" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky mj mk ml mm bi translated">基本HTTP报头协议</li><li id="6c47" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">什么是饼干</li><li id="bbe7" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">什么是会话</li><li id="8557" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">会话(服务器)和cookie(浏览器)如何交互来验证用户</li></ul><h1 id="7948" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">HTTP标题</h1><p id="370d" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">有许多方法可以在浏览器中发出HTTP请求。HTTP客户端可以是web应用程序、物联网设备、命令行(curl)或许多其他东西。每个客户端都连接到互联网并发出HTTP请求，这些请求要么获取数据(GET)，要么修改数据(POST、PUT、DELETE等)。).</p><p id="9ac6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">出于解释的目的，我们假设:</p><p id="9cac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">服务器=<a class="ae ld" href="http://www.google.com/" rel="noopener ugc nofollow" target="_blank">www.google.com</a></p><p id="d495" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当咖啡店里的那个随机的人在他们的Google Chrome浏览器中输入<code class="fe kz la lb lc b">www.google.com</code>时，这个请求将会以“HTTP头”的形式发送。这些HTTP头是键:值对，为浏览器提供额外的数据来帮助完成请求。该请求将有两种类型的报头:</p><ol class=""><li id="faea" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky nh mk ml mm bi translated">常规标题</li><li id="114f" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">请求标题</li></ol><p id="5dfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了让这个互动，打开谷歌浏览器，打开你的开发者工具(右击“Inspect”)，点击“网络”标签。现在，在地址栏中输入<code class="fe kz la lb lc b">www.google.com</code>,观察网络选项卡从服务器加载几个资源。您应该会看到几列，如名称、状态、类型、启动器、大小、时间和瀑布。找到“文档”作为“类型”值的请求，并单击它。您应该会看到这个请求和响应交互的所有头。</p><p id="1732" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您(作为客户端)发出的请求将具有类似于(但不完全是)以下内容的一般和请求标头:</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="fe14" class="nm lf it lc b gy nn no l np nq">General Headers<br/>  Request URL: https://www.google.com/<br/>  Request Method: GET<br/>  Status Code: 200</span><span id="4007" class="nm lf it lc b gy nr no l np nq">Request Headers<br/>  Accept: text/html<br/>  Accept-Language: en-US<br/>  Connection: keep-alive</span></pre><p id="d33d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您在地址栏中键入<code class="fe kz la lb lc b">www.google.com</code>并按回车键时，您的HTTP请求就与这些头(可能还有其他几个)一起发送了。虽然这些头相对来说是不言自明的，但是我想通过几个来更好地了解HTTP头的用途。在MDN 上随意查找任何你不知道的。</p><p id="a27b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">General</code>头可以是请求和响应数据的混合。显然，<code class="fe kz la lb lc b">Request URL</code>和<code class="fe kz la lb lc b">Request Method</code>是请求对象的一部分，它们告诉Google Chrome浏览器将你的请求路由到哪里。<code class="fe kz la lb lc b">Status Code</code>显然是响应的一部分，因为它表明您的GET请求是成功的，并且在<code class="fe kz la lb lc b">www.google.com</code>的网页加载正常。</p><p id="c4b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">Request Headers</code>只包含请求对象本身包含的头。您可以将请求头视为“服务器的指令”。在这种情况下，我的请求告诉Google服务器以下内容:</p><ul class=""><li id="f123" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky mj mk ml mm bi translated">嘿谷歌服务器，请给我发送HTML或文本数据。我现在要么没有能力，要么没有兴趣阅读其他任何东西！</li><li id="01b6" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">嘿谷歌服务器，请只给我发英文单词</li><li id="bd4b" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">嘿谷歌服务器，请不要在请求结束后关闭我与你的连接</li></ul><p id="14ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以设置更多的请求头，但这些只是您可能会在所有HTTP请求中看到的一些常见的请求头。</p><p id="d098" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，当您搜索<code class="fe kz la lb lc b">www.google.com</code>时，您将您的请求和标题发送到Google服务器(为了简单起见，我们假设它是一个大型服务器)。Google服务器接受您的请求，通读“指令”(标题)，并创建一个<em class="ns">响应</em>。回应包括:</p><ul class=""><li id="f1aa" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky mj mk ml mm bi translated">HTML数据(您在浏览器中看到的内容)</li><li id="ddce" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">HTTP标题</li></ul><p id="2de7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你可能已经猜到的，“响应头”是由谷歌服务器设置的。这里有一些你可能会看到的:</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="14f8" class="nm lf it lc b gy nn no l np nq">Response Headers<br/>  Content-Length: 41485<br/>  Content-Type: text/html; charset=UTF-8<br/>  Set-Cookie: made_up_cookie_name=some value; expires=Thu, 28-Dec-2020 20:44:50 GMT;</span></pre><p id="c654" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了<code class="fe kz la lb lc b">Set-Cookie</code>头之外，这些响应头相当简单。</p><p id="b0a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我包含了<code class="fe kz la lb lc b">Set-Cookie</code>头，因为这正是我们为了学习基于会话的认证所需要理解的(并且将帮助我们理解本文后面的其他认证方法)。</p><h1 id="76f6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Cookies的工作原理</h1><p id="c17f" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">浏览器中没有Cookies，我们就有问题了。</p><p id="b83b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们有一个受保护的网页，我们希望我们的用户登录访问，没有cookies，这些用户将不得不登录每次他们刷新页面！这是因为HTTP协议默认是“无状态”的。</p><p id="24e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Cookies引入了“持久状态”的概念，并允许浏览器“记住”服务器先前告诉它的一些东西。</p><p id="90bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">谷歌服务器可以告诉我的谷歌Chrome浏览器让我访问受保护的页面，但当我刷新页面时，我的浏览器会“忘记”这一点，并让我再次验证。</p><p id="33ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是Cookies的用武之地，它解释了<code class="fe kz la lb lc b">Set-Cookie</code>头的目的是什么。在上面的请求中，我们在浏览器中键入<code class="fe kz la lb lc b">www.google.com</code>并按下enter，我们的客户端发送了一个带有一些头的请求，Google服务器用一个响应和一些头来响应。其中一个回复标题是<code class="fe kz la lb lc b">Set-Cookie: made_up_cookie_name=some value; expires=Thu, 28-Dec-2020 20:44:50 GMT;</code>。这种互动是这样进行的:</p><p id="267a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">服务器:“嗨客户端！我希望您设置一个名为<code class="fe kz la lb lc b">made_up_cookie_name</code>的cookie，并将其设置为等于<code class="fe kz la lb lc b">some value</code>。</p><p id="7a19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">客户:“嘿，服务器，我会把这个设置在我对这个域的所有请求的<code class="fe kz la lb lc b">Cookie</code>头上，直到2020年12月28日！”</p><p id="36f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以验证这确实发生在谷歌Chrome开发者工具中。进入“应用”-&gt;“存储”，点击“Cookies”。现在点击你正在访问的网站，你会看到所有为这个网站设置的cookies。在我们虚构的示例中，您可能会看到如下内容:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">示例cookie</figcaption></figure><p id="f2e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在cookie上设置的到期日之前，该cookie将被设置为对<code class="fe kz la lb lc b">www.google.com</code>发出的所有请求的<code class="fe kz la lb lc b">Cookie</code> <strong class="kd iu">请求头</strong>。</p><p id="1aca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您可能得出的结论，如果我们设置某种“auth”cookie，这对于身份验证非常有用。这种工作方式的一个过于简化的过程是:</p><ol class=""><li id="788c" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky nh mk ml mm bi translated">从咖啡店随机抽取一个人在浏览器中输入<code class="fe kz la lb lc b">www.example-site.com/login/</code></li><li id="cdca" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">咖啡店里的一个随机的人在这个页面上填写一个用户名和密码</li><li id="ce76" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">随机人的Google Chrome浏览器向运行<code class="fe kz la lb lc b"><a class="ae ld" href="http://www.example-site.com." rel="noopener ugc nofollow" target="_blank">www.example-site.com</a></code> <a class="ae ld" href="http://www.example-site.com." rel="noopener ugc nofollow" target="_blank">的服务器提交一个POST请求，请求中包含登录数据(用户名，密码)。</a></li><li id="6e09" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">运行<code class="fe kz la lb lc b">www.example-site.com</code>的服务器接收登录信息，检查数据库中的登录信息，验证登录信息，如果成功，就创建一个带有标题<code class="fe kz la lb lc b">Set-Cookie: user_is_authenticated=true; expires=Thu, 1-Jan-2020 20:00:00 GMT</code>的响应。</li><li id="5752" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">这个随机的人的Google Chrome浏览器接收到这个响应并设置一个浏览器cookie:</li></ol><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">示例cookie</figcaption></figure><p id="74b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">6.随机的人现在访问<code class="fe kz la lb lc b"><a class="ae ld" href="http://www.example-site.com/protected-route/" rel="noopener ugc nofollow" target="_blank">www.example-site.com/protected-route/</a></code></p><p id="e003" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">7.这个随机的人的浏览器创建了一个HTTP请求，并在请求中附加了标题<code class="fe kz la lb lc b">Cookie: user_is_authenticated=true; expires=Thu, 1-Jan-2020 20:00:00 GMT</code>。</p><p id="f18e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">8.服务器收到这个请求，看到请求中有一个cookie，“记得”几秒钟前它已经验证了这个用户，并允许用户访问这个页面。</p><h1 id="0558" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">这种情况的现实</h1><p id="a991" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">显然，我刚才描述的是一种非常不安全的用户认证方式。实际上，服务器会根据用户提供的密码创建某种散列，并使用服务器上的某个加密库来验证该散列。</p><p id="c693" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也就是说，这个高级概念是有效的，它允许我们在讨论身份验证时理解cookies的价值。</p><p id="4054" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们阅读这篇文章的剩余部分时，请记住这个例子。</p><h1 id="bfbd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">会议</h1><p id="a47c" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">会话和cookies实际上非常相似，可能会混淆，因为它们实际上可以无缝地一起使用。两者的<em class="ns">主要区别</em>是它们存放的<strong class="kd iu">位置</strong>。</p><p id="6a8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">换句话说，Cookie是由服务器设置的，但是存储在浏览器中。如果服务器想用这个cookie来存储关于用户“状态”的数据，它必须想出一个精心设计的方案来持续跟踪浏览器中Cookie的样子。它可能是这样的:</p><ul class=""><li id="5b5f" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky mj mk ml mm bi translated">服务器:嘿，浏览器，我刚刚验证了这个用户，所以你应该存储一个cookie来提醒我(<code class="fe kz la lb lc b">Set-Cookie: user_auth=true; expires=Thu, 1-Jan-2020 20:00:00 GMT</code>)下次你向我请求什么的时候</li><li id="e915" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">浏览器:谢谢，服务器！我将把这个cookie附加到我的<code class="fe kz la lb lc b">Cookie</code>请求头中</li><li id="71fd" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">浏览器:嘿，服务器，我能在<code class="fe kz la lb lc b">www.domain.com/protected</code>看到内容吗？这是你上次请求时发给我的饼干。</li><li id="bc28" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">服务员:当然，我可以做到。这里是页面数据。我还包含了另一个<code class="fe kz la lb lc b">Set-Cookie</code>标题(<code class="fe kz la lb lc b">Set-Cookie: marketing_page_visit_count=1; user_ip=192.1.234.21</code>)，因为拥有我的公司喜欢跟踪有多少人访问了这个特定的页面，以及出于营销目的从哪台计算机访问的。</li><li id="cbc2" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">浏览器:好的，我会把这个cookie添加到我的<code class="fe kz la lb lc b">Cookie</code>请求头中</li><li id="d60e" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky mj mk ml mm bi translated">浏览器:嘿服务器，你能把<code class="fe kz la lb lc b">www.domain.com/protected/special-offer</code>的内容发给我吗？这是到目前为止你给我做的所有饼干。(<code class="fe kz la lb lc b">Cookie: user_auth=true; expires=Thu, 1-Jan-2020 20:00:00 GMT; marketing_page_visit_count=1; user_ip=192.1.234.21</code>)</li></ul><p id="34cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，浏览器访问的页面越多，服务器设置的cookie就越多，浏览器必须在每个请求头中附加的cookie也就越多。</p><p id="f51f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">服务器可能有某种功能来解析附加到请求的所有cookie，并根据特定cookie的存在与否来执行某些操作。对我来说，这自然引出了一个问题…为什么服务器不在数据库中保存这些信息的记录，并使用单一的“会话ID”来识别用户正在进行的事件？</p><p id="ffa9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这正是会议的目的。正如我提到的，cookie和会话之间的主要区别在于它们存储在哪里。会话存储在某个数据存储区(数据库的一个时髦术语)，而Cookie存储在浏览器中。由于会话存储在服务器上，它可能存储敏感信息。将敏感信息存储在cookie中是非常不安全的。</p><p id="6352" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当我们谈到一起使用cookies和会话<em class="ns">时，这一切变得有点混乱。</em></p><p id="48ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于cookie是客户端和服务器传递元数据(以及其他HTTP头)的方法，会话仍然必须利用cookie。观察这种交互的最简单方法是在Node + Express + MongoDB中实际构建一个简单的身份验证应用程序。我假设你对在Express中构建应用程序有一个基本的了解，但是我会在我们进行的过程中尝试解释每一部分。</p><p id="507b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">设置基本应用程序:</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="adf6" class="nm lf it lc b gy nn no l np nq">mkdir session-auth-app<br/>cd session-auth-app<br/>npm init -y<br/>npm install --save express mongoose dotenv connect-mongo express-session passport passport-local</span></pre><p id="3e34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里是<code class="fe kz la lb lc b">app.js</code>。在继续之前，通读评论以了解更多关于正在发生的事情。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">app.js</figcaption></figure><p id="11ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要做的第一件事是理解<code class="fe kz la lb lc b">express-session</code>模块在这个应用程序中是如何工作的。这是一个“中间件”，这是一种奇特的说法，它是一个在我们的应用程序中修改某些东西的功能。</p><h1 id="9406" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">快速复习快速中间件</h1><p id="a200" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">假设我们有以下代码:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">中间件. js</figcaption></figure><p id="8af7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你所看到的，这是一个非常简单的Express应用程序，它定义了两个中间件，并且只有一条路线，你可以在<code class="fe kz la lb lc b">http://localhost:3000</code>的浏览器中访问。如果您启动该应用程序并访问该路径，它会显示“自定义属性值:未定义”,因为仅仅定义中间件功能是不够的。</p><p id="b225" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们需要告诉Express应用程序实际使用这些中间件。我们可以用几种方法做到这一点。首先，我们可以在一条路线内完成。</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="1655" class="nm lf it lc b gy nn no l np nq">app.get('/', myMiddleware1, (req, res, next) =&gt; {<br/>    res.send(`&lt;h1&gt;Custom Property Value: ${req.newProperty}`);<br/>});</span></pre><p id="cd75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您将第一个中间件函数作为参数添加到路由中，您现在将会看到“Custom Property Value:my Custom Property”出现在浏览器中。这里到底发生了什么:</p><ol class=""><li id="1fe4" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky nh mk ml mm bi translated">应用程序已初始化</li><li id="63b0" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">一个用户在浏览器中访问了<code class="fe kz la lb lc b">http://localhost:3000/</code>，触发了<code class="fe kz la lb lc b">app.get()</code>功能。</li><li id="f94f" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">Express应用程序首先检查路由器上是否安装了任何“全局”中间件，但是没有找到。</li><li id="80c0" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">快速应用程序查看了<code class="fe kz la lb lc b">app.get()</code>函数，注意到在回调之前安装了一个中间件函数。应用程序运行中间件，并将<code class="fe kz la lb lc b">req</code>对象、<code class="fe kz la lb lc b">res</code>对象和<code class="fe kz la lb lc b">next()</code>回调传递给中间件。</li><li id="19a2" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated"><code class="fe kz la lb lc b">myMiddleware1</code>中间件先设置<code class="fe kz la lb lc b">req.newProperty</code>，然后调用<code class="fe kz la lb lc b">next()</code>，告知Express应用“转到下一个中间件”。如果中间件没有调用<code class="fe kz la lb lc b">next()</code>，浏览器将被“卡住”并且不返回任何东西。</li><li id="7e20" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">Express应用程序没有看到更多的中间件，所以它继续请求并发送结果。</li></ol><p id="3454" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这只是使用中间件的一种方式，也正是<code class="fe kz la lb lc b">passport.authenticate()</code>功能的工作方式(稍后会有更多介绍，请记住)。</p><p id="ab22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用中间件的另一种方式是“全局”设置它。看一看我们的应用程序在此之后的变化:</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">中间件. js</figcaption></figure><p id="9c5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这个app结构，你会注意到在浏览器<em class="ns">中访问<code class="fe kz la lb lc b">http://localhost:3000/</code>仍然</em>返回和以前一样的值。这是因为中间件<code class="fe kz la lb lc b">app.use(myMiddleware2)</code>发生在和<code class="fe kz la lb lc b">app.get('/', myMiddleware1)</code>之前<em class="ns">。如果我们从路由中删除了中间件，您将在浏览器中看到更新后的值。</em></p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="3b3d" class="nm lf it lc b gy nn no l np nq">app.use(myMiddleware2);</span><span id="7c2d" class="nm lf it lc b gy nr no l np nq">app.get('/', (req, res, next) =&gt; {<br/>    // Sends "Custom Property Value: updated value<br/>    res.send(`&lt;h1&gt;Custom Property Value: ${req.newProperty}`);<br/>});</span></pre><p id="aa64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以通过将第二个中间件放在路由中的第一个中间件之后来获得这个结果。</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="2b37" class="nm lf it lc b gy nn no l np nq">app.get('/', myMiddleware1, myMiddleware2, (req, res, next) =&gt; {<br/>    // Sends "Custom Property Value: updated value<br/>    res.send(`&lt;h1&gt;Custom Property Value: ${req.newProperty}`);<br/>});</span></pre><p id="5644" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管这是对Express中中间件的快速和高层次的概述，但它将帮助我们理解<code class="fe kz la lb lc b">express-session</code>中间件是怎么回事。</p><h1 id="1334" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">快速会话中间件如何工作</h1><p id="bb14" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">正如我之前提到的，<code class="fe kz la lb lc b">express-session</code>模块为我们提供了可以在应用程序中使用的中间件。中间件的定义如下:</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="1083" class="nm lf it lc b gy nn no l np nq">// Again, here is the documentation for this - <a class="ae ld" href="https://www.npmjs.com/package/express-session" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/express-session</a></span><span id="1487" class="nm lf it lc b gy nr no l np nq">app.use(session({<br/>    secret: process.env.SECRET,<br/>    resave: false,<br/>    saveUninitialized: true,<br/>    store: sessionStore <br/>}));</span></pre><p id="611c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是快速会话中间件功能的简要概述:</p><ol class=""><li id="bdf1" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky nh mk ml mm bi translated">当加载一个路由时，中间件检查是否在会话存储中建立了一个会话(在我们的例子中是MongoDB数据库，因为我们使用的是<code class="fe kz la lb lc b">connect-mongo</code>自定义会话存储)。</li><li id="3e75" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">如果有会话，中间件会用密码验证它，然后告诉浏览器会话是否有效。如果有效，浏览器会自动将<code class="fe kz la lb lc b">connect.sid</code> Cookie附加到HTTP请求上。</li><li id="e5ac" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">如果没有会话，中间件会创建一个新的会话，获取该会话的加密哈希，并将该值存储在一个名为<code class="fe kz la lb lc b">connect.sid</code>的Cookie中。然后，它用散列值(<code class="fe kz la lb lc b">Set-Cookie: connect.sid=hashed value</code>)将<code class="fe kz la lb lc b">Set-Cookie</code> HTTP头附加到<code class="fe kz la lb lc b">res</code>对象上。</li></ol><p id="b335" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能想知道这到底为什么有用，以及所有这些实际上是如何工作的。</p><p id="a268" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您还记得快速中间件的快速复习，我说过中间件有能力改变从一个中间件传递到下一个中间件的<code class="fe kz la lb lc b">req</code>和<code class="fe kz la lb lc b">res</code>对象，直到它到达HTTP请求的末尾。就像我们在<code class="fe kz la lb lc b">req</code>对象上设置自定义属性一样，我们也可以设置更复杂的东西，比如具有属性、方法等的<code class="fe kz la lb lc b">session</code>对象。</p><p id="2ed8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这正是<code class="fe kz la lb lc b">express-session</code>中间件所做的。创建新会话时，以下属性会添加到<code class="fe kz la lb lc b">req</code>对象中:</p><ul class=""><li id="b761" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky mj mk ml mm bi translated"><code class="fe kz la lb lc b">req.sessionID</code> -随机生成的UUID。通过设置<code class="fe kz la lb lc b">genid</code>选项，您可以定义一个自定义函数来生成该ID。如果不设置此选项，默认是使用<code class="fe kz la lb lc b">uid-safe</code> <a class="ae ld" href="https://www.npmjs.com/package/uid-safe" rel="noopener ugc nofollow" target="_blank">模块</a>。</li></ul><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="6845" class="nm lf it lc b gy nn no l np nq">app.use(session({<br/>  genid: function (req) {<br/>    // Put your UUID implementation here<br/>  }<br/>}));</span></pre><ul class=""><li id="3b71" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky mj mk ml mm bi translated"><code class="fe kz la lb lc b">req.session</code> -会话对象。这包含有关会话的信息，可用于设置要使用的自定义属性。例如，您可能想要跟踪特定页面在单个会话中被加载的次数:</li></ul><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="4b34" class="nm lf it lc b gy nn no l np nq">app.get('/tracking-route', (req, res, next) =&gt; {<br/>  <br/>  if (req.session.viewCount) {<br/>    req.session.viewCount = req.session.viewCount + 1;<br/>  } else {<br/>    req.session.viewCount = 1;<br/>  }</span><span id="0fcb" class="nm lf it lc b gy nr no l np nq">  res.send("&lt;p&gt;View count is: " + req.session.viewCount + "&lt;/p&gt;");<br/>  <br/>});</span></pre><ul class=""><li id="6473" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky mj mk ml mm bi translated"><code class="fe kz la lb lc b">req.session.cookie</code>-Cookie对象。这定义了在浏览器中存储哈希会话ID的cookie的行为。记住，一旦设置了cookie，浏览器会自动将它附加到每个HTTP请求上，直到它过期。</li></ul><h1 id="ded8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Passport JS本地策略如何工作</h1><p id="0a90" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">为了完全理解基于会话的身份验证，我们还需要学习最后一件事——Passport JS。</p><p id="0706" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Passport JS拥有500多种可在Node/Express应用程序中使用的身份验证“策略”。这些策略中的许多都非常具体(例如，<code class="fe kz la lb lc b">passport-amazon</code>允许您通过Amazon凭证认证进入您的应用程序)，但它们在您的Express应用程序中的工作方式都是相似的。</p><p id="d309" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我看来，护照模块可以使用文档部门的一些工作。Passport不仅由两个模块组成(Passport base + Specific Strategy)，而且它还是一个中间件，正如我们所看到的，这本身就有点令人困惑。更令人困惑的是，我们将要经历的策略(<code class="fe kz la lb lc b">passport-local</code>)是一个修改由另一个中间件(<code class="fe kz la lb lc b">express-session</code>)创建的对象的中间件。由于护照文档对这一切是如何工作的几乎没有说明，我将在这篇文章中尽我所能解释它。</p><p id="09b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们首先浏览一下模块的设置。</p><p id="e138" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您一直在学习本教程，那么您已经拥有了所需的模块。如果没有，您将需要安装Passport和一个策略到您的项目。</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="c3f7" class="nm lf it lc b gy nn no l np nq">npm install --save passport passport-local</span></pre><p id="b81d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦您完成了这些，您将需要在您的应用程序中实现Passport。下面，我已经添加了所有你需要的<code class="fe kz la lb lc b">passport-local</code>策略。为了简化，我删除了注释。快速浏览代码，然后我们将浏览所有的<code class="fe kz la lb lc b">// NEW</code>代码。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">app.js</figcaption></figure><p id="f348" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">是的，我知道这里有很多东西要接受。让我们从简单的部分开始——助手函数。在上面的代码中，我有两个助手函数，它们将帮助创建和验证密码。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">passwordUtils.js</figcaption></figure><p id="b520" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了注释之外，我会注意到这些函数需要NodeJS内置的<code class="fe kz la lb lc b">crypto</code>库。有些人会争论一个更好的加密库，但是除非你的应用程序需要高度的安全性，否则这个库已经足够了！</p><p id="65ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来看看<code class="fe kz la lb lc b">passport.use()</code>法。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">Passport JS配置</figcaption></figure><p id="0a49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我知道上面的函数有很多要看，所以让我们来探究它的一些关键组件。首先，我要提到的是，对于所有的<strong class="kd iu">Passport JS认证策略(不仅仅是我们使用的本地策略)，您需要为它提供一个回调，当您调用<code class="fe kz la lb lc b">passport.authenticate()</code>方法时，这个回调将被执行。例如，您的应用程序中可能有一个登录路径:</strong></p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="0589" class="nm lf it lc b gy nn no l np nq">app.post('/login', passport.authenticate('local', { failureRedirect: '/login' }), (err, req, res, next) =&gt; {<br/>    if (err) next(err);<br/>    console.log('You are logged in!');<br/>});</span></pre><p id="4fc0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您的用户将通过登录表单输入他们的用户名和密码，这将创建一个到<code class="fe kz la lb lc b">/login</code>路由的HTTP POST请求。假设您的发布请求包含以下数据:</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="3e56" class="nm lf it lc b gy nn no l np nq">{<br/>  "email": "sample@email.com",<br/>  "pw": "sample password"<br/>}</span></pre><p id="d14a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样不行。原因？因为<code class="fe kz la lb lc b">passport.use()</code>方法<em class="ns">期望</em>您的POST请求具有以下字段:</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="ed9c" class="nm lf it lc b gy nn no l np nq">{<br/>  "username": "sample@email.com",<br/>  "password": "sample password"<br/>}</span></pre><p id="6f94" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它寻找<code class="fe kz la lb lc b">username</code>和<code class="fe kz la lb lc b">password</code>字段。如果您想让第一个json请求体工作，您需要为<code class="fe kz la lb lc b">passport.use()</code>函数提供字段定义:</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="f779" class="nm lf it lc b gy nn no l np nq">passport.use(</span><span id="98cb" class="nm lf it lc b gy nr no l np nq">  {<br/>    usernameField: 'email',<br/>    passwordField: 'pw'<br/>  },<br/>  function (email, password, callback) {</span><span id="9976" class="nm lf it lc b gy nr no l np nq">    // Implement your callback function here</span><span id="63a6" class="nm lf it lc b gy nr no l np nq">  }</span><span id="dddb" class="nm lf it lc b gy nr no l np nq">);</span></pre><p id="5ef2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过定义<code class="fe kz la lb lc b">usernameField</code>和<code class="fe kz la lb lc b">passwordField</code>，您可以指定一个定制的POST请求主体对象。</p><p id="afc5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">撇开这个不谈，让我们回到帖子要求的<code class="fe kz la lb lc b">/login</code>路线:</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="67ca" class="nm lf it lc b gy nn no l np nq">app.post('/login', passport.authenticate('local', { failureRedirect: '/login' }), (err, req, res, next) =&gt; {<br/>    if (err) next(err);<br/>    console.log('You are logged in!');<br/>});</span></pre><p id="99c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当用户提交他/她的登录凭证时，<code class="fe kz la lb lc b">passport.authenticate()</code>方法(这里用作中间件)将执行您已经定义的回调，并从POST请求体向它提供<code class="fe kz la lb lc b">username</code>和<code class="fe kz la lb lc b">password</code>。<code class="fe kz la lb lc b">passport.authenticate()</code>方法有两个参数——策略的名称和选项。这里默认的策略名称是<code class="fe kz la lb lc b">local</code>，但是您可以这样修改它:</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="d63d" class="nm lf it lc b gy nn no l np nq">// Supply a name string as the first argument to the passport.use() function</span><span id="c62e" class="nm lf it lc b gy nr no l np nq">passport.use('custom-name', new Strategy());</span><span id="8c9e" class="nm lf it lc b gy nr no l np nq">// Use the same name as above<br/>app.post('/login', passport.authenticate('custom-name', { failureRedirect: '/login' }), (err, req, res, next) =&gt; {<br/>    if (err) next(err);<br/>    console.log('You are logged in!');<br/>});</span></pre><p id="20ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我用过的方式<code class="fe kz la lb lc b">passport.authenticate()</code>策略会先执行我们在<code class="fe kz la lb lc b">new LocalStrategy()</code>里面定义的回调函数，如果认证成功，它会调用<code class="fe kz la lb lc b">next()</code>函数，我们就进入路由。如果认证不成功(用户名或密码无效)，应用程序将再次重定向到<code class="fe kz la lb lc b">/login</code>路线。</p><p id="5b02" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经了解了它的用法，让我们回到我们之前定义的回调函数，也就是<code class="fe kz la lb lc b">passport.authenticate()</code>正在使用的函数。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">Passport配置</figcaption></figure><p id="0a14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经非常详细地评论了上面的内容，所以请务必在继续之前通读一遍。</p><p id="0869" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您可能注意到的，回调函数与数据库和验证无关。换句话说，我们不需要使用MongoDB，也不需要以同样的方式验证我们的密码。PassportJS把这个交给我们了！这可能会令人困惑，但也非常强大，这也是PassportJS被广泛采用的原因。</p><p id="4558" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，您将看到两个相关的函数:</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="4c25" class="nm lf it lc b gy nn no l np nq">passport.serializeUser(function(user, cb) {<br/>    cb(null, user.id);<br/>});</span><span id="eb14" class="nm lf it lc b gy nr no l np nq">passport.deserializeUser(function(id, cb) {<br/>    User.findById(id, function (err, user) {<br/>        if (err) { return cb(err); }<br/>        cb(null, user);<br/>    });<br/>});</span></pre><p id="9af3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就我个人而言，我发现这两个函数是最令人困惑的，因为没有很多关于它们的文档。当我们谈到PassportJS和Express Session中间件如何交互时，我们将进一步探讨这些函数在做什么，但简而言之，这两个函数负责将用户“序列化”到当前会话对象和从当前会话对象“反序列化”用户。</p><p id="6b07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们不需要在会话中存储整个<code class="fe kz la lb lc b">user</code>对象，只需要存储用户的数据库ID。当我们需要在当前会话中获得关于用户的更多信息时，我们可以使用反序列化函数，使用存储在会话中的ID在数据库中查找用户。同样，我们很快会对此有更多的理解。</p><p id="7d54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，对于Passport实现，您将看到两行代码:</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="ba0a" class="nm lf it lc b gy nn no l np nq">app.use(passport.initialize());<br/>app.use(passport.session());</span></pre><p id="0228" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你还记得早先关于中间件如何工作的文章，通过调用<code class="fe kz la lb lc b">app.use()</code>，我们告诉Express在括号<strong class="kd iu">内执行函数，以便</strong>对<strong class="kd iu">的每个请求</strong>。</p><p id="7c32" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">换句话说，对于我们的Express应用程序发出的每个HTTP请求，它将执行<code class="fe kz la lb lc b">passport.initialize()</code>和<code class="fe kz la lb lc b">passport.session()</code>。</p><p id="7043" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有什么奇怪的吗？？</p><p id="d97c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果<code class="fe kz la lb lc b">app.use()</code> <strong class="kd iu">执行</strong>内包含的函数，那么上面的语法就像是在说:</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="9657" class="nm lf it lc b gy nn no l np nq">passport.initialize()();<br/>passport.session()();</span></pre><p id="d1a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样做的原因是因为这两个函数实际上会返回另一个函数！有点像这样:</p><pre class="mt mu mv mw gt ni lc nj nk aw nl bi"><span id="dd4d" class="nm lf it lc b gy nn no l np nq">Passport.prototype.initialize = function () {<br/>  // Does something </span><span id="8ded" class="nm lf it lc b gy nr no l np nq">  return function () {<br/>    // This is what is called by `app.use()`<br/>  }<br/>}</span></pre><p id="2862" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用Passport不需要知道这一点，但是如果您对语法有疑问，这肯定会消除一些困惑。</p><p id="08aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不管怎样…</p><p id="1c27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个中间件功能是将PassportJS与<code class="fe kz la lb lc b">express-session</code>中间件集成所必需的。这就是为什么这两个功能<strong class="kd iu">必须在<code class="fe kz la lb lc b">app.use(session({}))</code>中间件</strong>之后！就像<code class="fe kz la lb lc b">passport.serializeUser()</code>和<code class="fe kz la lb lc b">passport.deserializeUser()</code>一样，这些中间件很快就会变得更有意义。</p><h1 id="d9fe" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">基于会话的身份验证的概念概述</h1><p id="5e24" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">既然我们已经了解了HTTP头、Cookies、中间件、Express Session中间件和Passport JS中间件，现在终于到了学习如何使用它们来验证用户进入我们的应用程序的时候了。我想先用这一节来回顾和解释概念流程，然后在下一节深入研究实现。</p><p id="222c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们应用程序的基本流程:</p><ol class=""><li id="95c8" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky nh mk ml mm bi translated">Express app在<code class="fe kz la lb lc b">http://www.expressapp.com</code>启动并监听(为了示例起见，假设这是真的)。</li><li id="6b00" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">用户在浏览器中访问<code class="fe kz la lb lc b">http://www.expressapp.com/login</code></li><li id="d5bc" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated"><code class="fe kz la lb lc b">express-session</code>中间件意识到有一个用户连接到Express服务器。它检查<code class="fe kz la lb lc b">req</code>对象上的<code class="fe kz la lb lc b">Cookie</code> HTTP头。由于该用户是第一次访问，<code class="fe kz la lb lc b">Cookie</code>头中没有值。因为没有<code class="fe kz la lb lc b">Cookie</code>值，所以Express服务器返回<code class="fe kz la lb lc b">/login</code> HTML并调用<code class="fe kz la lb lc b">Set-Cookie</code> HTTP头。<code class="fe kz la lb lc b">Set-Cookie</code>值是由<code class="fe kz la lb lc b">express-session</code>中间件根据开发人员设置的选项生成的cookie字符串(在本例中假设maxAge值为10天)。</li><li id="ca52" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">用户意识到他现在不想登录，而是想出去走走。他关闭了浏览器。</li><li id="251f" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">用户散步回来，打开浏览器，再次返回到<code class="fe kz la lb lc b">http://www.expressapp.com/login</code>。</li><li id="7556" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">再次，<code class="fe kz la lb lc b">express-session</code>中间件运行GET请求，检查<code class="fe kz la lb lc b">Cookie</code> HTTP头，但是这一次，发现一个值！这是因为用户在当天早些时候已经创建了一个会话。由于在<code class="fe kz la lb lc b">express-session</code>中间件上<code class="fe kz la lb lc b">maxAge</code>选项被设置为10天，关闭浏览器不会破坏cookie。</li><li id="3766" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated"><code class="fe kz la lb lc b">express-session</code>中间件现在从<code class="fe kz la lb lc b">Cookie</code> HTTP头中获取<code class="fe kz la lb lc b">connect.sid</code>值，在<code class="fe kz la lb lc b">MongoStore</code>中查找它(有趣的说法是，它在数据库中的<code class="fe kz la lb lc b">sessions</code>集合中查找id)，并找到它。由于会话存在，<code class="fe kz la lb lc b">express-session</code>中间件不做任何事情，并且<code class="fe kz la lb lc b">Cookie</code> HTTP头值和<code class="fe kz la lb lc b">sessions</code>集合中的<code class="fe kz la lb lc b">MongoStore</code>数据库条目保持不变。</li><li id="b812" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">现在，用户输入他的用户名和密码，然后点击“登录”按钮。</li><li id="5fe4" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">通过按“登录”按钮，用户向使用<code class="fe kz la lb lc b">passport.authenticate()</code>中间件的<code class="fe kz la lb lc b">/login</code>路由发送POST请求。</li><li id="5488" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">到目前为止，对于每个请求，<code class="fe kz la lb lc b">passport.initialize()</code>和<code class="fe kz la lb lc b">passport.session()</code>中间件一直在运行。对于每个请求，这些中间件检查<code class="fe kz la lb lc b">req.session</code>对象(由<code class="fe kz la lb lc b">express-session</code>中间件创建)是否有一个名为<code class="fe kz la lb lc b">passport.user</code>(即<code class="fe kz la lb lc b">req.session.passport.user</code>)的属性。因为还没有调用<code class="fe kz la lb lc b">passport.authenticate()</code>方法，所以<code class="fe kz la lb lc b">req.session</code>对象没有<code class="fe kz la lb lc b">passport</code>属性。现在已经通过对<code class="fe kz la lb lc b">/login</code>的POST请求调用了<code class="fe kz la lb lc b">passport.authenticate()</code>方法，Passport将使用用户输入并提交的用户名和密码执行用户定义的身份验证回调。</li><li id="3361" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">我们假设用户已经在数据库中注册并输入了正确的凭证。Passport回调成功验证了用户。</li><li id="287d" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated"><code class="fe kz la lb lc b">passport.authenticate()</code>方法现在返回经过验证的<code class="fe kz la lb lc b">user</code>对象。此外，它将<code class="fe kz la lb lc b">req.session.passport</code>属性附加到<code class="fe kz la lb lc b">req.session</code>对象，通过<code class="fe kz la lb lc b">passport.serializeUser()</code>序列化用户，并将序列化的用户(即用户的ID)附加到<code class="fe kz la lb lc b">req.session.passport.user</code>属性。最后，它将完整的用户对象附加到<code class="fe kz la lb lc b">req.user</code>。</li><li id="d01d" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">用户关掉他的电脑，去散步，因为我们的应用程序很无聊。</li><li id="57f7" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">用户第二天打开他的计算机，在我们的应用程序上访问一条<strong class="kd iu">受保护的路线</strong>。</li><li id="20f2" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated"><code class="fe kz la lb lc b">express-session</code>中间件检查<code class="fe kz la lb lc b">req</code>上的<code class="fe kz la lb lc b">Cookie</code> HTTP头，找到昨天的会话(仍然有效，因为我们的<code class="fe kz la lb lc b">maxAge</code>被设置为10天)，在<code class="fe kz la lb lc b">MongoStore</code>中查找，找到它，并且对<code class="fe kz la lb lc b">Cookie</code>不做任何事情，因为会话仍然有效。中间件重新初始化<code class="fe kz la lb lc b">req.session</code>对象，并设置为从<code class="fe kz la lb lc b">MongoStore</code>返回的值。</li><li id="7fe3" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated"><code class="fe kz la lb lc b">passport.initialize()</code>中间件检查<code class="fe kz la lb lc b">req.session.passport</code>属性，发现那里仍然有一个<code class="fe kz la lb lc b">user</code>值。<code class="fe kz la lb lc b">passport.session()</code>中间件使用在<code class="fe kz la lb lc b">req.session.passport.user</code>上找到的<code class="fe kz la lb lc b">user</code>属性来重新初始化<code class="fe kz la lb lc b">req.user</code>对象，以等同于通过<code class="fe kz la lb lc b">passport.deserializeUser()</code>函数连接到会话的用户。</li><li id="75f2" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">受保护的路线查看<code class="fe kz la lb lc b">req.session.passport.user</code>是否存在。因为Passport中间件刚刚重新初始化了它，所以它确实初始化了，并且受保护的路由允许用户访问。</li><li id="3123" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">用户离开他的计算机2个月。</li><li id="86f2" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">用户返回并访问相同的受保护路由(提示:会话已过期！)</li><li id="7c23" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated"><code class="fe kz la lb lc b">express-session</code>中间件运行，意识到<code class="fe kz la lb lc b">Cookie</code> HTTP头的值有一个<strong class="kd iu">过期的</strong> cookie值，并通过附加到<code class="fe kz la lb lc b">res</code>对象的<code class="fe kz la lb lc b">Set-Cookie</code> HTTP头用一个新的会话替换<code class="fe kz la lb lc b">Cookie</code>值。</li><li id="24c3" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated"><code class="fe kz la lb lc b">passport.initialize()</code>和<code class="fe kz la lb lc b">passport.session()</code>中间件运行，但是这一次，因为<code class="fe kz la lb lc b">express-session</code>中间件必须创建一个新的会话，所以不再有<code class="fe kz la lb lc b">req.session.passport</code>对象！</li><li id="2997" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">由于用户没有登录并试图访问受保护的路由，该路由将检查<code class="fe kz la lb lc b">req.session.passport.user</code>是否存在。因为它不存在，所以拒绝访问！</li><li id="c1cc" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">一旦用户再次登录并触发<code class="fe kz la lb lc b">passport.authenticate()</code>中间件，将重新建立<code class="fe kz la lb lc b">req.session.passport</code>对象，用户将再次能够访问受保护的路线。</li></ol><p id="77b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">呜呜呜…</p><p id="1b1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">明白了吗？</p><h1 id="aff2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">基于会话的认证实现</h1><p id="ee43" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">最困难的部分已经过去了。</p><p id="72c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将所有东西放在一起，下面是您的全功能基于会话的认证快速应用程序。下面是包含在单个文件中的应用程序，但我也重构了这个应用程序，使其更接近您在真实世界中使用的<a class="ae ld" href="https://github.com/zachgoll/express-session-authentication-starter" rel="noopener ugc nofollow" target="_blank">这个库</a>中的应用程序。</p><figure class="mt mu mv mw gt ju"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">app.js</figcaption></figure><h1 id="c0b8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">回顾和预览</h1><p id="6613" class="pw-post-body-paragraph kb kc it kd b ke me kg kh ki mf kk kl km ne ko kp kq nf ks kt ku ng kw kx ky im bi translated">我们的<code class="fe kz la lb lc b">passport-local</code>认证教程到此结束，但是我有一个与<code class="fe kz la lb lc b">passport-jwt</code>策略密切相关的教程，它将帮助您获得对不同用户认证流程的广泛理解。</p><p id="cb4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们从基于会话的身份验证过渡到基于JWT的身份验证时，保持身份验证流程清晰非常重要。快速回顾一下，基于会话的身份验证应用程序的基本身份验证流程如下:</p><ol class=""><li id="94c4" class="mc md it kd b ke kf ki kj km nb kq nc ku nd ky nh mk ml mm bi translated">用户访问您的Express应用程序，并使用其用户名和密码登录</li><li id="bab7" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">用户名和密码通过POST请求发送到Express应用服务器上的<code class="fe kz la lb lc b">/login</code>路由</li><li id="95f5" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">Express application server将从数据库中检索用户(哈希和salt存储在用户配置文件中)，使用附加到数据库用户对象的salt获取用户几秒钟前提供的密码的哈希，并验证获取的哈希与存储在数据库用户对象上的哈希相匹配。</li><li id="d51b" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">如果散列匹配，我们得出结论，用户提供了正确的凭证，我们的<code class="fe kz la lb lc b">passport-local</code>中间件将把用户附加到当前会话。</li><li id="9a48" class="mc md it kd b ke mn ki mo km mp kq mq ku mr ky nh mk ml mm bi translated">对于用户在前端发出的每个新请求，他们的会话Cookie将被附加到请求上，随后将由Passport中间件进行验证。如果Passport中间件成功验证了会话cookie，服务器将返回请求的路由数据，我们的认证流程就完成了。</li></ol><p id="adbb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">关于这个流程，我想让你注意的是，用户只需要输入他的用户名和密码<strong class="kd iu">一次</strong>，在接下来的会话中，他可以访问受保护的路由。会话cookie<strong class="kd iu">会自动</strong>附加到他的所有请求上，因为这是web浏览器的默认行为，也是cookie的工作方式！此外，每次发出请求时，Passport中间件和Express会话中间件都会查询我们的数据库，以检索会话信息。换句话说，<strong class="kd iu">要认证一个用户，需要一个数据库</strong>。</p><p id="a37c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在向前跳，您将开始注意到，使用JWTs，在每个请求上绝对不需要数据库来验证用户。是的，我们将需要发出一个数据库请求来最初验证一个用户并生成一个JWT，但是在那之后，JWT将被附加在<code class="fe kz la lb lc b">Authorization</code> HTTP头中(与<code class="fe kz la lb lc b">Cookie</code>头相反)，并且不需要数据库。</p><p id="92a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果这没有意义，那也没关系。点击此链接，通过<a class="ae ld" href="https://medium.com/@zach.gollwitzer/everything-you-need-to-know-about-the-passport-jwt-passport-js-strategy-8b69f39014b0" rel="noopener">进入我关于<code class="fe kz la lb lc b">passport-jwt</code>战略的帖子。</a></p></div></div>    
</body>
</html>