<html>
<head>
<title>Always pass one argument to your JavaScript function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">始终向JavaScript函数传递一个参数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/always-pass-one-argument-to-your-javascript-function-4140d909937e?source=collection_archive---------0-----------------------#2019-01-16">https://levelup.gitconnected.com/always-pass-one-argument-to-your-javascript-function-4140d909937e?source=collection_archive---------0-----------------------#2019-01-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a3d5efdd5f11f26f8ac2cbcdcae7c9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MxovkfggAJv4HuEzDAWs4A.jpeg"/></div></div></figure><p id="86a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript没有真正的关键字参数概念，同时对于传递给函数的内容非常灵活。因此，对于以什么样的顺序将什么传递给一个函数，人们很容易感到困惑或不知所措。我发现，无论是对我自己还是对使用我的代码的其他人来说，总是只将一个名为<code class="fe kw kx ky kz b">params</code>的参数传递给我的函数，并将所有内容嵌入其中，这样更好。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="14e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我试图说服您这是一个好主意之前，让我们来看看JavaScript中的参数处理是如何工作的。</p><p id="5bef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数可以在其声明中指定任意数量的参数:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="f95f" class="lp lq iq kz b gy lr ls l lt lu">function callMe(a, b, c) {}</span></pre><p id="84bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您使用正确数量的位置参数调用该函数时，一切都有意义:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="91ba" class="lp lq iq kz b gy lr ls l lt lu">function callMe(a, b, c) {<br/>    return a + b + c<br/>}<br/>callMe(1, 2, 3)</span><span id="cc41" class="lp lq iq kz b gy lv ls l lt lu">&gt;&gt;&gt; 6</span></pre><p id="f17e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在许多其他语言中，做任何不同的事情都会导致异常。没有提供足够的论据？例外。提供太多参数？例外。在JavaScript中并非如此。</p><p id="d4bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尝试用很少的参数调用上面的函数:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="ce5e" class="lp lq iq kz b gy lr ls l lt lu">callMe(1,2)</span><span id="3c9a" class="lp lq iq kz b gy lv ls l lt lu">&gt;&gt;&gt; NaN</span></pre><p id="bc3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者太多了:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="429e" class="lp lq iq kz b gy lr ls l lt lu">callMe(1,2,3,4)</span><span id="e8f2" class="lp lq iq kz b gy lv ls l lt lu">&gt;&gt;&gt; 6</span></pre><p id="9b7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在的情况是，JavaScript并没有真正的方法“签名”的概念，比如说，你可以在OO语言中找到。当你在函数声明中声明一个参数名时，你所做的只是在函数内部使用时给这个位置参数附加一个标签。如果那个参数没有被传入，标签就是<code class="fe kw kx ky kz b">undefined</code>。如果你传入一个没有位置标签的参数，那么它仍然在函数范围内，你只是没有它的名字。</p><p id="6887" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这解释了我们上面的函数调用的输出。当我们为<code class="fe kw kx ky kz b">c</code>省略一个值时，那么<code class="fe kw kx ky kz b">c</code>就是<code class="fe kw kx ky kz b">undefined</code>，而<code class="fe kw kx ky kz b">a + b + c</code>就是<code class="fe kw kx ky kz b">NaN</code>。当我们传入第四个参数时，函数继续运行，就好像它不存在一样。</p><p id="ed62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，能够传入没有标签的值，从而无法在函数内部访问这些值，这有什么意义呢？嗯，这句话的后半部分不是真的。我们<em class="lw">可以</em>访问该值，如果你知道去哪里找的话，那就是在所有声明的函数中存在的特殊的<code class="fe kw kx ky kz b">arguments</code>局部变量中。它是一种特殊的动物，有自己的类型，如果我们愿意，我们可以将它转换为数组:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="4096" class="lp lq iq kz b gy lr ls l lt lu">function callMe() {<br/>    return Array.prototype.slice.call(arguments)<br/>}</span></pre><p id="893a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(注意我这里用的是ES5，它肯定能在你选择的浏览器中工作。在ES6中使用<code class="fe kw kx ky kz b">Array.from(arguments)</code>有一个稍微快一点的方法。</p><p id="b2d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们声明这个函数没有位置参数，只是为了让这一点非常清楚。我们现在可以用任意数量的参数来调用它，它会把它们反映给我们:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="28c5" class="lp lq iq kz b gy lr ls l lt lu">callMe(1, 2, 3, 4)</span><span id="a243" class="lp lq iq kz b gy lv ls l lt lu">&gt;&gt;&gt; [1, 2, 3, 4]</span></pre><p id="6ea9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于参数，你需要知道的另一件事是，从ES6开始，你<em class="lw">可以</em>像这样给它们设置默认值:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="74df" class="lp lq iq kz b gy lr ls l lt lu">function callMe(a, b=2, c=4) { return a + b + c }</span><span id="6b8c" class="lp lq iq kz b gy lv ls l lt lu">callMe(1)<br/>&gt;&gt;&gt; 7</span><span id="42ef" class="lp lq iq kz b gy lv ls l lt lu">callMe(2, 3)<br/>&gt;&gt;&gt; 9</span></pre><p id="a2d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是不能将参数作为关键字传递。我的意思是，下面的工作不像你预期的那样；试试看:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="ee00" class="lp lq iq kz b gy lr ls l lt lu">callMe(a=3, c=5);</span></pre></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="f046" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终，这意味着函数声明的参数只不过是函数能力的指南。再加上缺乏真正的关键字参数，因此很难理解函数声明及其文档，也很难确保您传入的是正确的内容。</p><p id="e755" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经常会看到JavaScript文档这样写道:</p><p id="bd52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lw">函数doIt(oneThingOrAnother，[someOption。[其他选项]]) </em></p><p id="ebe9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lw">调用这个函数，用一个东西或另一个东西作为第一个参数，然后你的选项是… </em></p><p id="6b28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我来说，这种函数声明是笨拙的，在我看到它如何工作之前，几乎总是会导致一点尝试性的错误。</p><p id="2bf9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，我更喜欢使用单个函数参数<code class="fe kw kx ky kz b">params</code>，记录它的结构，并且永远不用担心变量参数列表。我们可以像这样快速重写上面的函数:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="3ebc" class="lp lq iq kz b gy lr ls l lt lu">function doIt(params) {<br/>    var oneThing = params.oneThing;<br/>    var anotherThing = params.anotherThing;<br/>    var someOption = params.someOption;<br/>    var someOtherOption = params.someOtherOption;<br/>    // ....<br/>}</span></pre><p id="2f73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这还不完美，我们会在进行过程中清理它…</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="ccb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们深入了解为什么这种方法是一个好主意:</p><p id="a0c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它<strong class="ka ir">消除了参数的位置排序</strong>——你的用户不再需要反复提醒自己参数的传递顺序。当我调用这个函数时，我可以用任何方式:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="21b9" class="lp lq iq kz b gy lr ls l lt lu">doIt({<br/>    oneThing: "one", anotherThing: "another", <br/>    someOption: "a", someOtherOption: "b"<br/>});</span><span id="5daa" class="lp lq iq kz b gy lv ls l lt lu">doIt({<br/>    someOption: "a", someOtherOption: "b",<br/>    oneThing: "one", anotherThing: "another"<br/>});</span></pre><p id="4365" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它允许我连贯地传递可变数量的参数(T12)——我可以省略一个参数，而不会打乱顺序或行为。比如如果我只想通过<code class="fe kw kx ky kz b">oneThing</code>或<code class="fe kw kx ky kz b">anotherThing</code>:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="af5b" class="lp lq iq kz b gy lr ls l lt lu">doIt({<br/>    oneThing: "one", someOption: "a", someOtherOption: "b"<br/>});</span><span id="22ef" class="lp lq iq kz b gy lv ls l lt lu">doIt({<br/>    anotherThing: "another", someOption: "a", someOtherOption: "b"<br/>});</span></pre><p id="3e7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一个函数作者，如果调用者没有指定默认参数<strong class="ka ir">和</strong>，我可以很容易地做到:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="0cdd" class="lp lq iq kz b gy lr ls l lt lu">function doIt(params) {<br/>    var oneThing = params.hasOwnProperty("oneThing") ? <br/>                      params.oneThing : "defaultOneThing";</span><span id="f604" class="lp lq iq kz b gy lv ls l lt lu">    var anotherThing = params.hasOwnProperty("anotherThing") ? <br/>                      params.anotherThing : "defaultAnotherThing";</span><span id="cdfc" class="lp lq iq kz b gy lv ls l lt lu">    var someOption = params.hasOwnProperty("someOption") ? <br/>                      params.someOption : "defaultSomeOption";</span><span id="b3ce" class="lp lq iq kz b gy lv ls l lt lu">    var someOtherOption = params.hasOwnProperty("someOther") ? <br/>                      params.someOther : "defaultSomeOther";<br/>    // ....<br/>}</span></pre><p id="19e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(注意我们不使用老式的<code class="fe kw kx ky kz b">var oneThing = params.oneThing || "defaultOneThing"</code>方法，因为这个<em class="lw">最终会</em>破坏你的函数，你可以在这里读到我对那个<a class="ae lx" href="https://itnext.io/you-shouldnt-use-truthy-tests-753b39ef8893" rel="noopener ugc nofollow" target="_blank">的咆哮。)</a></p><p id="b055" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这也意味着我可以用命名良好的参数来宣传我的函数的特性，而不必在函数中坚持那些参数名称。这可能是一个非常方便的区别。例如:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="d6d1" class="lp lq iq kz b gy lr ls l lt lu">function doIt(params) {<br/>    var one = params.hasOwnProperty("oneThing") ? <br/>                      params.oneThing : "defaultOneThing";</span><span id="58af" class="lp lq iq kz b gy lv ls l lt lu">    var another = params.hasOwnProperty("anotherThing") ? <br/>                      params.anotherThing : "defaultAnotherThing";</span><span id="df2a" class="lp lq iq kz b gy lv ls l lt lu">    var opt1 = params.hasOwnProperty("someOption") ? <br/>                      params.someOption : "defaultSomeOption";</span><span id="c1e9" class="lp lq iq kz b gy lv ls l lt lu">    var opt2 = params.hasOwnProperty("someOther") ? <br/>                      params.someOther : "defaultSomeOther";<br/>    // ....<br/>}</span></pre><p id="99cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在文档方面，<strong class="ka ir">函数调用本身变得相当自文档化</strong>，或者至少更容易理解:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="a806" class="lp lq iq kz b gy lr ls l lt lu">doIt({<br/>    oneThing: "one", someOption: "a", someOtherOption: "b"<br/>});</span></pre><p id="8981" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对抗</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="e0df" class="lp lq iq kz b gy lr ls l lt lu">doIt("one", "a", "b")</span></pre><p id="00ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在函数声明方面，<strong class="ka ir">记录<code class="fe kw kx ky kz b">params</code>对象的内部结构</strong>很容易，而<a class="ae lx" href="http://usejsdoc.org/" rel="noopener ugc nofollow" target="_blank"> JSDoc </a>会很好地为您将文档列表。这是最近一个项目的文档片段，以及它产生的JSDoc输出:</p><pre class="lh li lj lk gt ll kz lm ln aw lo bi"><span id="9da6" class="lp lq iq kz b gy lr ls l lt lu"><em class="lw">/**<br/> * </em><strong class="kz ir"><em class="lw">@param </em></strong><em class="lw">{Object} params<br/> * </em><strong class="kz ir"><em class="lw">@param </em></strong><em class="lw">{string} params.selector - the jQuery selector for the page element into which to render the Edge<br/> * </em><strong class="kz ir"><em class="lw">@param </em></strong><em class="lw">{number} params.top_donor_limit - the number of Donors/Members to include in the Top X Donor/Member chart<br/> * </em><strong class="kz ir"><em class="lw">@param </em></strong><em class="lw">{String} params.funding_progress_header - header text<br/> * </em><strong class="kz ir"><em class="lw">@param </em></strong><em class="lw">{String} params.funding_progress_intro - section intro text<br/> * </em><strong class="kz ir"><em class="lw">@param </em></strong><em class="lw">{String} params.funding_by_country_header - header text<br/> * </em><strong class="kz ir"><em class="lw">@param </em></strong><em class="lw">{String} params.funding_by_country_intro - section intro text<br/> * </em><strong class="kz ir"><em class="lw">@param </em></strong><em class="lw">{String} params.funding_by_continent_header - header text<br/> * </em><strong class="kz ir"><em class="lw">@param </em></strong><em class="lw">{String} params.funding_by_continent_intro - section intro text<br/> * ...<br/> */</em></span></pre><figure class="lh li lj lk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/8fa5cfc0a63ede73322953458eeddbed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84thwwsHw-Sf9PxKoktDEQ.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">params对象的JSDoc输出</figcaption></figure></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="2c36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有很多很好的理由这样声明你的函数。当然，和JavaScript一样，这是一个惯例，你可能会发现你想违反它的情况。你肯定会使用其他人的代码，而这些代码不会以这种方式运行。不过，我向您保证，从长远来看，像这样编写您自己的代码将使您免于处理声明不当的函数这种低级的后台问题。</p><p id="3ce7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lw"> Richard是软件开发咨询公司</em><a class="ae lx" href="https://cottagelabs.com" rel="noopener ugc nofollow" target="_blank"><em class="lw">Cottage Labs</em></a><em class="lw">的创始人，该公司专注于数据生命周期的各个方面。他偶尔会在推特上发</em><a class="ae lx" href="https://twitter.com/richard_d_jones" rel="noopener ugc nofollow" target="_blank"><em class="lw">@ Richard _ d _ Jones</em></a></p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><figure class="lh li lj lk gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi md"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="me mf gp gr mg mh"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd ir gy z fp mm fr fs mn fu fw ip bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">排名前65的JavaScript教程。课程由开发者提交并投票，使您能够找到最好的…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">gitconnected.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv jw mh"/></div></div></a></div></div></div>    
</body>
</html>