<html>
<head>
<title>JavaScript Design Patterns: Decorator Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript设计模式:装饰模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-design-patterns-decorator-pattern-fc278652bd03?source=collection_archive---------8-----------------------#2022-10-30">https://levelup.gitconnected.com/javascript-design-patterns-decorator-pattern-fc278652bd03?source=collection_archive---------8-----------------------#2022-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="96f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从ES6: Decorator模式重新连接JavaScript设计模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b45f8e15df77a3cf13dd1c158b099155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7w8gIAirSwm2Ja3Dq3EQ2Q.png"/></div></div></figure><h2 id="8b03" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">1.什么是装饰者模式</h2><p id="aa47" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">向现有对象添加新功能而不改变其结构的设计模式称为装饰模式，它充当现有类的包装器。</p><p id="4282" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">装饰者可以理解为游戏角色购买的装备。比如LOL中的英雄，刚开始游戏的时候只有基础攻击力和魔法力。但购买装备后，触发攻击和技能时，可以享受装备带来的输出加成。我们可以理解为购买的装备装饰了英雄的攻击和技能的相关方法。</p><h2 id="a48e" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">2.ESnext中的装饰模式</h2><p id="a9ce" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">ESnext中有一个Decorator建议，它使用一个以@开头的函数来修饰ES6中的类及其属性和方法。</p><p id="ca96" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">目前，Decorator的语法只是一个建议。如果现在想使用装饰器模式，需要安装并配合<code class="fe mo mp mq mr b">babel</code> + <code class="fe mo mp mq mr b">webpack </code>并结合插件实现。</p><p id="283b" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated"><em class="ms"> npm安装依赖关系</em></p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="9d91" class="ku kv it mr b gy mx my l mz na">npm install babel-core babel-loader babel-plugin-transform-decorators babel-plugin-transform-decorators-legacy babel-preset-env</span></pre><p id="c295" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated"><em class="ms">配置</em> <code class="fe mo mp mq mr b"><em class="ms">.babelrc</em></code>文件<em class="ms">文件</em></p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="173f" class="ku kv it mr b gy mx my l mz na">{<br/>  "presets": ["env"],<br/>  "plugins": ["transform-decorators-legacy"]<br/>}</span></pre><p id="a3c3" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">在<code class="fe mo mp mq mr b">webpack.config.js</code>中增加<code class="fe mo mp mq mr b">babel-loader</code></p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="078b" class="ku kv it mr b gy mx my l mz na">module: {<br/>    rules: [<br/>      { test: /\.js$/, exclude: /node_modules/, loader: "babel-loader" }<br/>    ],<br/>  }</span></pre><p id="bc95" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">如果您的IDE是Visual Studio代码，您可能还需要在项目根目录中添加下面的<code class="fe mo mp mq mr b">tsconfig.json</code>文件来组织ts检查错误。</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="2bf2" class="ku kv it mr b gy mx my l mz na">{<br/>  "compilerOptions": {<br/>    "experimentalDecorators": true,<br/>    "allowJs": true,<br/>    "lib": [<br/>      "es6"<br/>    ],<br/>  }<br/>}</span></pre><p id="cb91" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">下面我将实现3个装饰者，<code class="fe mo mp mq mr b">@autobind, @debounce,<strong class="ls iu"> @</strong>deprecate<strong class="ls iu">.</strong></code></p><p id="67d4" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated"><strong class="ls iu"> 2.1 </strong> <code class="fe mo mp mq mr b"><strong class="ls iu">@autobind</strong></code> <strong class="ls iu">实现</strong> <code class="fe mo mp mq mr b"><strong class="ls iu">this </strong></code> <strong class="ls iu">指向原对象</strong></p><p id="b757" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">在JavaScript中，<code class="fe mo mp mq mr b">this </code>指向的问题一直是一个常见的话题。新手在使用<code class="fe mo mp mq mr b">Vue </code>或<code class="fe mo mp mq mr b">React</code>等框架的过程中，很可能会不小心失去<code class="fe mo mp mq mr b">this </code>的指向，导致方法调用错误。例如下面的代码:</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="b0cb" class="ku kv it mr b gy mx my l mz na">class Person {<br/>  getPerson() {<br/>    return this;<br/>  }<br/>}<br/><br/>let person = new Person();<br/>let { getPerson } = person;<br/><br/>console.log(getPerson() === person); // false</span></pre><p id="013c" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">在上面的代码中，<code class="fe mo mp mq mr b">getPerson </code>方法中的<code class="fe mo mp mq mr b">this </code>默认指向<code class="fe mo mp mq mr b">Person </code>类的一个实例，但是如果<code class="fe mo mp mq mr b">Person</code>是通过析构赋值提取的，那么<code class="fe mo mp mq mr b">this </code>指向<code class="fe mo mp mq mr b">undefined</code>。所以最终打印结果是假的。</p><p id="1113" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">此时，我们可以实现一个<code class="fe mo mp mq mr b">autobind </code>函数来修饰<code class="fe mo mp mq mr b">getPerson </code>方法，使<code class="fe mo mp mq mr b">this</code>始终指向<code class="fe mo mp mq mr b">Person</code>的一个实例。</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="e67f" class="ku kv it mr b gy mx my l mz na">function autobind(target, key, descriptor) {<br/>  var fn = descriptor.value;<br/>  var configurable = descriptor.configurable;<br/>  var enumerable = descriptor.enumerable;<br/><br/>  // return descriptor<br/>  return {<br/>    configurable: configurable,<br/>    enumerable: enumerable,<br/>    get: function get() {<br/>      // bind this<br/>      var boundFn = fn.bind(this);<br/>      // Use Object.defineProperty to redefine the method<br/>      Object.defineProperty(this, key, {<br/>        configurable: true,<br/>        writable: true,<br/>        enumerable: false,<br/>        value: boundFn<br/>      })<br/><br/>      return boundFn;<br/>    }<br/>  }<br/>}</span></pre><p id="463c" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">我们通过<code class="fe mo mp mq mr b">bind</code>实现<code class="fe mo mp mq mr b">this </code>的绑定，用<code class="fe mo mp mq mr b">Object.defineProperty</code>重写<code class="fe mo mp mq mr b">get</code>中的方法，将值定义为bind绑定的<code class="fe mo mp mq mr b">boundFn </code>函数，这样这个就一直指向实例。接下来我们装饰并调用<code class="fe mo mp mq mr b">getPerson</code>方法。</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="9b25" class="ku kv it mr b gy mx my l mz na">class Person {<br/>  @autobind<br/>  getPerson() {<br/>    return this;<br/>  }<br/>}<br/><br/>let person = new Person();<br/>let { getPerson } = person;<br/><br/>console.log(getPerson() === person); // true</span></pre><p id="bb04" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated"><strong class="ls iu">2.2 @去抖实现</strong>去抖<strong class="ls iu">功能</strong></p><p id="1e56" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">去抖功能在前端项目中有很多应用，比如在resize或scroll等事件中操纵DOM，或者实现用户输入的实时ajax搜索，这些都会被频繁触发。前者会对浏览器性能产生直观的影响。后者会给服务器造成很大压力。我们期待这样高频率的连续触发事件在触发结束后有所反应。这就是函数防抖的应用。</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="12aa" class="ku kv it mr b gy mx my l mz na">class Editor {<br/>  constructor() {<br/>    this.content = '';<br/>  }<br/><br/>  updateContent(content) {<br/>    console.log(content);<br/>    this.content = content;<br/>    // There are some performance-consuming operations behind<br/>  }<br/>}<br/><br/>const editor1 = new Editor();<br/>editor1.updateContent(1);<br/>setTimeout(() =&gt; { editor1.updateContent(2); }, 400);<br/><br/><br/>const editor2= new Editor();<br/>editor2.updateContent(3);<br/>setTimeout(() =&gt; { editor2.updateContent(4); }, 600);<br/><br/>// result: 1 3 2 4</span></pre><p id="91a4" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">在上面的代码中，我们定义了<code class="fe mo mp mq mr b">Editor </code>类，其中<code class="fe mo mp mq mr b">updateContent </code>方法将在用户输入时执行，并且可能有一些消耗性能的DOM操作。这里我们打印方法内部的传入参数来验证调用过程。可以看到4次调用的结果分别是1 3 2 4。</p><p id="83f8" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">下面我们实现一个<code class="fe mo mp mq mr b">debounce </code>函数，它传入一个数值超时参数。</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="3735" class="ku kv it mr b gy mx my l mz na">function debounce(timeout) {<br/>  const instanceMap = new Map(); <br/>// Create a Map data structure with the instantiated object as the key<br/><br/>  return function (target, key, descriptor) {<br/><br/>    return Object.assign({}, descriptor, {<br/>      value: function value() {<br/><br/>        clearTimeout(instanceMap.get(this));<br/>        instanceMap.set(this, setTimeout(() =&gt; {<br/>          descriptor.value.apply(this, arguments);<br/>          instanceMap.set(this, null);<br/>        }, timeout));<br/>      }<br/>    })<br/>  }<br/>}</span></pre><p id="a5df" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">在上述方法中，我们使用ES6提供的<code class="fe mo mp mq mr b">Map </code>数据结构来实现实例化对象和延迟层之间的映射。在函数内部，首先清除delayer，然后设置延迟执行函数。这是实现去抖的常用方法。让我们测试一下<code class="fe mo mp mq mr b">debounce </code>装饰器。</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="7656" class="ku kv it mr b gy mx my l mz na">class Editor {<br/>  constructor() {<br/>    this.content = '';<br/>  }<br/><br/>  @debounce(500)  <br/>  updateContent(content) {<br/>    console.log(content);<br/>    this.content = content;<br/>  }<br/>}<br/><br/>const editor1 = new Editor();<br/>editor1.updateContent(1);<br/>setTimeout(() =&gt; { editor1.updateContent(2); }, 400);<br/><br/><br/>const editor2= new Editor();<br/>editor2.updateContent(3);<br/>setTimeout(() =&gt; { editor2.updateContent(4); }, 600);<br/><br/>//result： 3 2 4</span></pre><p id="90e2" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">上面调用了4次<code class="fe mo mp mq mr b">updateContent </code>方法，打印结果为<code class="fe mo mp mq mr b">3 2 4</code>。<code class="fe mo mp mq mr b">1</code>不打印是因为它在400ms内被反复调用，这符合我们对参数500的预期。</p><p id="cbb8" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated"><strong class="ls iu"> 2.3 @deprecate实现警告提示</strong></p><p id="8f11" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">在使用第三方库的过程中，我们时不时会遇到一些控制台的警告。这些警告用于提醒开发人员所调用的方法将在下一版本中被弃用。这样的一行打印信息可能是我们通常的做法，在方法内部加一行代码，实际上对源代码阅读并不友好，也不符合单一责任原则。在需要抛出警告来实现警告的方法前面添加一个@deprecate装饰器会友好得多。</p><p id="0eec" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">让我们实现一个@deprecate装饰器。其实这种类型的decorator还可以扩展到打印日志decorator @log，报表信息decorator @fetchInfo等。</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="d131" class="ku kv it mr b gy mx my l mz na">function deprecate(deprecatedObj) {</span><span id="912a" class="ku kv it mr b gy nb my l mz na">return function(target, key, descriptor) {<br/>    const deprecatedInfo = deprecatedObj.info;<br/>    const deprecatedUrl = deprecatedObj.url;<br/>    // Warning message<br/>    const txt = `DEPRECATION ${target.constructor.name}#${key}: ${deprecatedInfo}. ${deprecatedUrl ? 'See '+ deprecatedUrl + ' for more detail' : ''}`;<br/>    <br/>    return Object.assign({}, descriptor, {<br/>      value: function value() {<br/>        // print warning message<br/>        console.warn(txt);<br/>        descriptor.value.apply(this, arguments);<br/>      }<br/>    })<br/>  }<br/>}</span></pre><p id="5a7d" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">上面的deprecate函数接受一个object参数，该参数有两个键值:<code class="fe mo mp mq mr b">info </code>和<code class="fe mo mp mq mr b">url</code>，其中<code class="fe mo mp mq mr b">info </code>填充了警告信息，<code class="fe mo mp mq mr b">url</code>是可选的详细信息网页地址。让我们将这个装饰器添加到名为<code class="fe mo mp mq mr b">MyLib</code>的库的<code class="fe mo mp mq mr b">deprecatedMethod </code>方法中！</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="2fe7" class="ku kv it mr b gy mx my l mz na">class MyLib {<br/>  @deprecate({<br/>    info: 'The methods will be deprecated in next version', <br/>    url: 'https://www.medium.com'<br/>  })<br/>  deprecatedMethod(txt) {<br/>    console.log(txt)<br/>  }<br/>}</span><span id="088d" class="ku kv it mr b gy nb my l mz na">const lib = new MyLib();<br/>lib.deprecatedMethod('Called a method that will be removed in the next version');<br/></span></pre><h2 id="d247" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">3.摘要</h2><p id="0a5e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly ld lz ma mb lh mc md me ll mf mg mh mi im bi translated">通过<code class="fe mo mp mq mr b">ESnext </code>中的decorator实现decorator模式，不仅具有扩展类的功能的功能，还在读取源代码的过程中起到了提示的作用。上面提到的例子只是一个简单的封装，结合了装饰器和装饰器模式的新语法，不应该在生产环境中使用。如果您现在已经意识到了decorator模式的好处，并且希望在您的项目中大量使用它，那么请看一下<code class="fe mo mp mq mr b">core-decorators</code>库，它封装了许多常用的decorator。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="e062" class="pw-post-body-paragraph lq lr it ls b lt mj ju lv lw mk jx ly ld ml ma mb lh mm md me ll mn mg mh mi im bi translated">关于设计模式的其他文章，看下面的文章，如果你对我的文章感兴趣，可以在<a class="ae nj" href="https://hyhwell.medium.com/" rel="noopener"> Medium </a>或者<a class="ae nj" href="https://twitter.com/Maxwell_hyh" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p><div class="nk nl gp gr nm nn"><a href="https://javascript.plainenglish.io/javascript-design-patterns-factory-pattern-4fa7914f7ff6" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">JavaScript设计模式:工厂模式</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">工厂模式是什么？工厂模式是用于创建对象的最常见的设计模式之一。</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ks nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-design-patterns-observer-pattern-1cf90cffb1e2"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">JavaScript设计模式:观察者模式</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">观察者</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">图案Observerlevelup.gitconnected.com</p></div></div><div class="nw l"><div class="oc l ny nz oa nw ob ks nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-design-patterns-strategy-pattern-c013d3dbc059"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">JavaScript设计模式:策略模式</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">学习设计模式的目的是代码的可重用性，使代码更容易被其他人理解，并且…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nw l"><div class="od l ny nz oa nw ob ks nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-design-patterns-singleton-pattern-7ada98be9a10"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">JavaScript设计模式:单例模式</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">Singleton模式:将类实例化的次数限制为一次，一个类只有一个实例，并且…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nw l"><div class="oe l ny nz oa nw ob ks nn"/></div></div></a></div></div></div>    
</body>
</html>