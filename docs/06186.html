<html>
<head>
<title>.Net core Dependency Injection: Lifetimes and few best practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。Net核心依赖注入:生存期和一些最佳实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/net-core-dependency-injection-lifetimes-and-few-best-practices-e194d2a39eff?source=collection_archive---------3-----------------------#2020-11-02">https://levelup.gitconnected.com/net-core-dependency-injection-lifetimes-and-few-best-practices-e194d2a39eff?source=collection_archive---------3-----------------------#2020-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6bbf1ad6483612b6592456c41847d434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ftkCv0zF9KmQvSM7.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">礼貌:google.com</figcaption></figure><p id="e1fc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们深入研究<strong class="ke ir"> <em class="la">依赖注入(DI) </em> </strong>之前。理解我们为什么需要魔法是很重要的。</p><p id="c25b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们先来探讨一下什么是<strong class="ke ir"> <em class="la">依存倒置原理(DIP) </em> </strong>是什么。DIP允许您解耦两个类，否则这两个类会非常紧密地耦合在一起，这有助于提高可重用性和可维护性。</p><blockquote class="lb lc ld"><p id="cbd4" class="kc kd la ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">倾斜状态，</p><p id="2c4c" class="kc kd la ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">1.高层模块不应该依赖低层模块。两者都应该依赖于抽象。</p><p id="1aad" class="kc kd la ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">2.抽象不应该依赖于细节。细节应该依赖于抽象。</p></blockquote><p id="db4f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了便于讨论，让我们忽略后者，用一个例子更深入地研究前者</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="9568" class="lq lr iq lm b gy ls lt l lu lv">class Foo {<br/>  Foo(Car _car){<br/>    // something<br/>  }<br/>}</span></pre><p id="d8aa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的代码片段中，类<code class="fe lw lx ly lm b">Foo</code>直接依赖于类<code class="fe lw lx ly lm b">car</code>。这些类之间的紧密耦合会带来两个主要问题</p><ol class=""><li id="adc9" class="lz ma iq ke b kf kg kj kk kn mb kr mc kv md kz me mf mg mh bi translated"><code class="fe lw lx ly lm b">Foo</code>不能用不同风格的<code class="fe lw lx ly lm b">car</code>来实例化，也就是说，如果有一个新的汽车类，比如:<code class="fe lw lx ly lm b">Sedan</code>来了，<code class="fe lw lx ly lm b">Foo</code>不能被重用</li><li id="a6bd" class="lz ma iq ke b kf mi kj mj kn mk kr ml kv mm kz me mf mg mh bi translated"><code class="fe lw lx ly lm b">car</code>合同的任何变化现在都会影响<code class="fe lw lx ly lm b">Foo</code>，直接增加维护费用。</li></ol><p id="f79b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了避免这两个问题，DIP建议高层模块<code class="fe lw lx ly lm b">Foo</code>不应该直接依赖于低层模块<code class="fe lw lx ly lm b">Car</code>，而是应该依赖于一个抽象，例如:接口。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="ff3e" class="lq lr iq lm b gy ls lt l lu lv">class Foo {<br/>  Foo(ICar _car){<br/>    // something<br/>  }<br/>}</span><span id="d44b" class="lq lr iq lm b gy mn lt l lu lv">class Car : ICar {<br/>  <br/>}</span><span id="8c20" class="lq lr iq lm b gy mn lt l lu lv">class Sedan : ICar{</span><span id="06b0" class="lq lr iq lm b gy mn lt l lu lv">}</span></pre><p id="156f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">仅仅通过引入一个简单的抽象<code class="fe lw lx ly lm b">ICar</code>,<code class="fe lw lx ly lm b">Foo</code>变得兼容于任何遵循契约或抽象<code class="fe lw lx ly lm b">ICar</code>的类。</p><p id="8544" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那么现在这如何链接到依赖注入呢？</p><p id="0f99" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">DIP提高了代码的可重用性，并在需要更改较低级别的类时限制了波动效应。即使当DIP被完美地实现时，该接口也只是在高级类中解耦了低级类的使用，而不是它的实例化。在代码的某个地方，您需要实例化接口的一个实现。这可以防止您动态地用不同的接口替换该接口的实现。</p><p id="0d9d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">依赖注入在这里发挥作用，帮助将使用从创建中分离出来。简单地说，每当DI框架发现一个类中任何注册服务的依赖时，它将提供一个具体的实例化。</p><p id="f322" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设<code class="fe lw lx ly lm b">ICar</code>在DI框架中注册提供了一个<code class="fe lw lx ly lm b">Car</code>的实例，那么对于每个<code class="fe lw lx ly lm b">Foo</code>对象的实例化，<code class="fe lw lx ly lm b">Foo</code>的构造器总是接收到一个<code class="fe lw lx ly lm b">car</code>的具体实例。</p><h2 id="0d7a" class="lq lr iq bd mo mp mq dn mr ms mt dp mu kn mv mw mx kr my mz na kv nb nc nd ne bi translated">迪在。网络核心:</h2><p id="a033" class="pw-post-body-paragraph kc kd iq ke b kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz ij bi translated">在……Net核心框架来了，我们应该配置一个第三方的DI框架，像<a class="ae nk" href="https://github.com/castleproject/Windsor" rel="noopener ugc nofollow" target="_blank">温莎城堡</a>，<a class="ae nk" href="https://github.com/autofac/Autofac" rel="noopener ugc nofollow" target="_blank"> Autofac </a>和许多其他的。然而，在。Net core DI开箱即用。“Startup”类提供了一个名为<code class="fe lw lx ly lm b">configureServices</code>的方法，这是开发人员向容器注册服务和类的地方。</p><pre class="lh li lj lk gt ll lm ln lo aw lp bi"><span id="5ada" class="lq lr iq lm b gy ls lt l lu lv">public class Startup {</span><span id="5ff7" class="lq lr iq lm b gy mn lt l lu lv">  // ...</span><span id="6819" class="lq lr iq lm b gy mn lt l lu lv">  public void ConfigureServices(IServiceCollection services) {<br/>    services.AddTransient&lt;ICar, Car&gt;();<br/>  }<br/>  // ...<br/>}</span></pre><p id="be62" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，对于每个请求，控制器被调用，所有依赖项都从容器中解析出来。所有这些都可以在。没有复杂配置的Net core。。Net也没有在创建实例的生命周期中提供一些在特定动机下可能会派上用场的味道。让我们来看看这些。</p><h2 id="63cc" class="lq lr iq bd mo mp mq dn mr ms mt dp mu kn mv mw mx kr my mz na kv nb nc nd ne bi translated">依赖项生存期:</h2><p id="99f6" class="pw-post-body-paragraph kc kd iq ke b kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz ij bi translated">在注册时，需要指定服务的生命周期。这个生存期定义给出了一个新实例何时创建的概念。有三种不同的味道。</p><ol class=""><li id="919d" class="lz ma iq ke b kf kg kj kk kn mb kr mc kv md kz me mf mg mh bi translated">短暂的</li><li id="e975" class="lz ma iq ke b kf mi kj mj kn mk kr ml kv mm kz me mf mg mh bi translated">审视</li><li id="ec76" class="lz ma iq ke b kf mi kj mj kn mk kr ml kv mm kz me mf mg mh bi translated">一个</li></ol><p id="e4c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> Transient: </strong>这个生存期定义使得DI可以在任何需要的时候创建一个新的实例</p><p id="3052" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> Scoped: </strong>这使得DI为每个新作用域创建一个新实例。这里的范围通常是指一个新的web请求。</p><p id="2d41" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> Singleton: </strong>这只会在第一次请求时创建一个新的实例，在应用程序的剩余生命周期中，同一个实例会提供给所有的消费者类。</p><h2 id="fe57" class="lq lr iq bd mo mp mq dn mr ms mt dp mu kn mv mw mx kr my mz na kv nb nc nd ne bi translated">良好做法</h2><ol class=""><li id="76ed" class="lz ma iq ke b kf nf kj ng kn nl kr nm kv nn kz me mf mg mh bi translated">作用域服务通常应该由单个web请求/线程使用。因此，您不应该跨线程共享服务范围。</li><li id="d021" class="lz ma iq ke b kf mi kj mj kn mk kr ml kv mm kz me mf mg mh bi translated">配置为单例的服务可能会导致应用程序中的内存泄漏。</li><li id="ed89" class="lz ma iq ke b kf mi kj mj kn mk kr ml kv mm kz me mf mg mh bi translated"><strong class="ke ir">内存泄漏</strong>一般是由单体服务引起的。这是因为创建的实例没有被释放，它将一直留在内存中，直到应用程序结束。所以一旦不用了就释放它们是好的。</li><li id="c2d9" class="lz ma iq ke b kf mi kj mj kn mk kr ml kv mm kz me mf mg mh bi translated">注册为transient的服务寿命较短，所以你可能不太关心<strong class="ke ir">多线程</strong>和<strong class="ke ir">内存泄漏。</strong></li><li id="b79d" class="lz ma iq ke b kf mi kj mj kn mk kr ml kv mm kz me mf mg mh bi translated"><strong class="ke ir">不要依赖</strong>单例服务中的瞬态服务或作用域服务。因为当单例服务注入瞬态服务时，瞬态服务变成了单例实例，如果瞬态服务没有被设计成支持这样的场景，这可能会导致问题。ASP.NET核心的默认DI容器已经在这种情况下抛出了<strong class="ke ir">异常</strong>。</li></ol><h2 id="1054" class="lq lr iq bd mo mp mq dn mr ms mt dp mu kn mv mw mx kr my mz na kv nb nc nd ne bi translated">摘要</h2><p id="0093" class="pw-post-body-paragraph kc kd iq ke b kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz ij bi translated">DIP坚持在一个更高级别的类和它的依赖之间创建一个抽象(接口)。这有助于将较高级别的类从其依赖项中分离出来，这样对较低级别的类的任何更改都不会影响较高级别的类。唯一直接使用依赖项的代码是负责实例化实现接口的类的对象的代码。</p><p id="fe9e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">依赖注入技术使您能够进一步改进这一点。它提供了一种将对象的创建和使用分开的方法。通过这样做，您可以在不更改任何代码的情况下替换依赖项，并且还可以减少业务逻辑中的样板代码。</p></div></div>    
</body>
</html>