<html>
<head>
<title>A Realtime Chart with Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带抖动的实时图表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-realtime-chart-with-flutter-75d1840b7789?source=collection_archive---------4-----------------------#2020-03-30">https://levelup.gitconnected.com/a-realtime-chart-with-flutter-75d1840b7789?source=collection_archive---------4-----------------------#2020-03-30</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a1da" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">pub.dev中有几个图表包可用，我选择了mp_chart，因为它类似于久经考验的MPAndroidChart。</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj kj"><img src="../Images/4d778c073135754eb56d20f81f3de13c.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/1*ct5CJblPsaVLmWMO3mTshw.gif"/></div><figcaption class="kr ks gk gi gj kt ku bd b be z dk translated">运行中的实时图表</figcaption></figure><p id="0525" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">您将学到的内容:</p><ul class=""><li id="bbb8" class="lr ls iu kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">如何从mp_chart包示例中剪切出一个图表，并集成到你的app中。</li><li id="ebde" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">如何使用Dart DevTools保证没有内存泄漏？</li></ul><p id="76b4" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">从一月份开始，我就在尝试一些私人的Flutter应用。特别是我正在研究如何使用Flutter来控制蓝牙设备，开发桌面应用程序、Web应用程序等等。</p><p id="c6ec" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">对于一个蓝牙项目，我需要像在示波器上一样实时显示两个值。我检查了pub.dev上的包，选择了mp_chart包。该软件包在README页面上有一个漂亮的实时动画图表。</p><p id="0212" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">Flutter使得孤立地开发一个应用程序的独立部件，然后将它们粘在一起变得很容易。所有语言都可以做到这一点，但是<em class="mf">‘一切都是小部件’</em>原则让它变得非常简单，没有任何麻烦。</p><p id="e4b4" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">另一方面，从一个应用程序中剪切出有趣的部分(小部件)并对其进行进一步处理是很容易的。这是我开始使用新包装时的程序。我在github上查看它是否有一个示例应用程序，并剪切出我需要的内容。</p><p id="d7fe" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">mp_charts包展示了所有支持的图表类型。有这么多不同的小工具，我必须找到合适的:</p><ul class=""><li id="06f0" class="lr ls iu kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">条形图基础</li><li id="2239" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">条形图基础2</li><li id="99c2" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">条形图水平</li><li id="834c" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">条形图倍数</li><li id="ba35" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">条形图负片</li><li id="4f95" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">巴恰特辛</li><li id="d710" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">条形图堆叠</li><li id="7664" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">条形图堆叠2</li><li id="93ac" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">更动态</li><li id="354b" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">甚至每小时</li><li id="f457" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated"><strong class="kx iv"> EvenMoreRealtime </strong></li><li id="dc07" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">LineChartBasic</li><li id="96e1" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">彩色折线图</li><li id="99ab" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">线图立方</li><li id="731f" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">线图双轴</li><li id="509a" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">填充线图</li><li id="fb7b" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">线图反转轴</li><li id="56db" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">折线图倍数</li><li id="d725" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">折线图性能</li><li id="c64f" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">其他图表气泡</li><li id="e9da" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">其他图表烛台</li><li id="2836" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">其他图表合并</li><li id="b106" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">其他图表雷达</li><li id="c543" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">其他图表</li><li id="a2f8" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">PieChartBasic</li><li id="a8d1" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">馅饼</li><li id="0936" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">PieChartValueLines</li><li id="ae8a" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">ScrollingChartManyBar</li><li id="c3c3" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">ScrollingChartMultiple</li><li id="13ba" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">ScrollingChartTallBar</li><li id="f413" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">scrollingchartviewparager</li></ul><p id="3b1f" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我在源文件<code class="fe mg mh mi mj b">mp_chart/example/lib/demo/even_more/realtime.dart</code>中找到了小部件<code class="fe mg mh mi mj b">EvenMoreRealtime</code>。<strong class="kx iv">但是</strong>:这个小部件对演示应用有几个依赖。为了使它独立于陈列柜框架，我必须做以下改动:</p><ol class=""><li id="0cb2" class="lr ls iu kx b ky kz lb lc le lt li lu lm lv lq mk lx ly lz bi translated">我的版本不再扩展ActionState，只是扩展了一个标准状态&lt;&gt;。</li><li id="9a3f" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq mk lx ly lz bi translated">我移除了ActionState类中定义的所有被覆盖的方法。</li><li id="45f9" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq mk lx ly lz bi translated">被覆盖的getBody()方法中的代码被移到标准的被覆盖的build()方法中。</li><li id="3c58" class="lr ls iu kx b ky ma lb mb le mc li md lm me lq mk lx ly lz bi translated">不再需要的导入被删除</li></ol><p id="af1a" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">在做了这些更改并将小部件重命名为RealTimeChart之后，我可以在一个名为PulsarScreen的屏幕中使用它，这是我的测试应用程序框架的主体。下面的代码在列的顶部构建RealTimeChart。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ml mm l"/></div></figure><p id="7332" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">图表下方的配置小部件包含一个范围滑块，用于设置生成值的上限和下限，以及一个滑块，用于显示生成的正弦值的频率。这些设置存储在类RealtimeDataServiceImpl中。</p><p id="308d" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">以下代码片段显示了演示示例的原始代码:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ml mm l"/></div></figure><p id="fa71" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">这是我的裁剪部件的相应部分，它可以在没有演示框架的情况下运行:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ml mm l"/></div></figure><p id="ecaf" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我又做了一些修改，让这个小部件适应我的需求:</p><p id="f8da" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe mg mh mi mj b">_initController</code>方法配置所有的颜色、文本样式、轴的限制等等。总而言之，你可以根据自己的需求调整x属性。</p><p id="5672" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">演示小部件只是在_updateEntry()中定期调用1000次_addEntry()。我用一个——也许是无止境的——数据流上的监听代替了它。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ml mm l"/></div></figure><p id="04e5" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">This _dataStream由<code class="fe mg mh mi mj b">RealtimeDataService</code>的一个实例提供，它是使用<code class="fe mg mh mi mj b">get_it</code>包的定位器注入的。该服务由两个滑块构成，它向水流提供两个正弦波。</p><p id="60f3" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe mg mh mi mj b">Stream&lt;DataSet&gt; _dataStream = locator&lt;RealtimeDataService&gt;().dataStream;</code></p><p id="fdbe" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">对于这个简单的测试应用程序来说，这有点过了，但是我在一个应用程序中使用了相同的架构，它也将使用这个RealtimeChart小部件。</p><p id="49ca" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">最初的演示示例通过每次调用内存中的<code class="fe mg mh mi mj b">_addMultiple()</code>来创建有限数量的新条目。对于运行时间更长的“真正的”实时应用程序，这将是一个显著的内存泄漏。在谷歌搜索<code class="fe mg mh mi mj b">mpandroidchart realtime chart remove</code>我在stackoverflow找到了一个解决方案。我搜索了<code class="fe mg mh mi mj b">mpandroidchart</code>,因为软件包的自述文件指出:</p><p id="a5e1" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><code class="fe mg mh mi mj b">flutter charts just like MPAndroidChart</code></p><p id="39ac" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">mp_charts包的一个很大的优点是，任何问题都可以用与<code class="fe mg mh mi mj b">MPAndroidChart.</code>相同的方式来解决。这有助于了解是否发生了任何问题或需要配置任何特殊情况。</p><p id="6234" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我发现的解决方案是在方法<code class="fe mg mh mi mj b">addWithRemove().</code>中实现的，只要条目不再可见，它就会删除它们。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ml mm l"/></div></figure><p id="8108" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">可以在Dart DevTools的内存视图中检查差异。下面的屏幕截图显示了在addWithRemove()中注释掉对<code class="fe mg mh mi mj b">removeEntry2</code>的调用时的内存:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gi gj mn"><img src="../Images/a8ee7afaeeab67655cab47fc336fc102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ngR70_JyNcagcJ82AJc1SA.png"/></div></div><figcaption class="kr ks gk gi gj kt ku bd b be z dk translated">一分钟消耗3290个对象和154 kB内存</figcaption></figure><p id="c3cf" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated"><strong class="kx iv">注意</strong>:要获得可行的结果，您必须点击<code class="fe mg mh mi mj b">gc</code>图标来执行垃圾收集器。之后，单击快照会显示所有对象的数量。特别感兴趣的是类<code class="fe mg mh mi mj b">Entry</code>的对象计数。</p><p id="8027" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">下面是调用<code class="fe mg mh mi mj b">removeEntry2</code>时的计数:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gi gj ms"><img src="../Images/def70c379ddf9f3115afdec57e81ebd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TrRjm746CZEturZQranjlA.png"/></div></div><figcaption class="kr ks gk gi gj kt ku bd b be z dk translated">无论应用程序运行多长时间，只消耗120个对象和15 kB</figcaption></figure><h2 id="1712" class="mt mu iu bd mv mw mx dn my mz na dp nb le nc nd ne li nf ng nh lm ni nj nk nl bi translated">结论</h2><p id="2500" class="pw-post-body-paragraph kv kw iu kx b ky nm jv la lb nn jy ld le no lg lh li np lk ll lm nq lo lp lq in bi translated">mp_chart包对于实时图表和许多其他图表类型非常有用。有许多可配置的属性。只需很少的努力，mp_charts包中的其他小部件就可以从示例中裁剪出来，并在自己的应用程序中使用。我还使用了小部件OtherChartRadar，如下图所示。切割过程与上述步骤非常相似。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nr"><img src="../Images/2937776472f643e948d6f4aca5384a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/1*KCZnRonljCuDJqVgitxKfg.gif"/></div><figcaption class="kr ks gk gi gj kt ku bd b be z dk translated">mp_chart包的雷达图</figcaption></figure><p id="b8eb" class="pw-post-body-paragraph kv kw iu kx b ky kz jv la lb lc jy ld le lf lg lh li lj lk ll lm ln lo lp lq in bi translated">我的测试应用的完整源代码在<a class="ae ns" href="https://github.com/schilken/flutter_realtime_chart_example" rel="noopener ugc nofollow" target="_blank"> Github </a>上。</p></div></div>    
</body>
</html>