<html>
<head>
<title>Compilation time that mixing Objective-C with Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">混合Objective-C和Swift的编译时间</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/compilation-time-that-mixing-objective-c-with-swift-d5adab04c5d?source=collection_archive---------5-----------------------#2020-07-13">https://levelup.gitconnected.com/compilation-time-that-mixing-objective-c-with-swift-d5adab04c5d?source=collection_archive---------5-----------------------#2020-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5db2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我之前的<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/dependency-injection-in-swift-bc16d66b038b">文章</a>描述了如何在一个纯粹的Swift项目中使用阿迪模式来减少编译时间并使您的代码松散耦合。今天我们就来深挖一下build系统是如何决定哪些文件应该重新编译，找出减少编译时间的最佳方法在混合Objective-C和Swift的时候，你的体验和我的不一样，但是一些有用的小技巧可能对你有用。如果我做错了什么，请纠正我。</p><h1 id="4881" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">摘要</h1><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="9964" class="lw kq it ls b gy lx ly l lz ma"><strong class="ls iu">1. The Context Of Swift Compiler<br/></strong>  1.1. Swift Driver, Frontend jobs<br/>  1.2. Demo profiling of dependency analysis</span><span id="ea4b" class="lw kq it ls b gy mb ly l lz ma">2. Compilation time<br/>  2.1. The bad cases of compilation time<br/>  2.2. The ways to fix compilation time issue</span></pre><h1 id="e437" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Swift编译器的背景</h1><p id="bd3f" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我只挑选Swift编译器的相关上下文作为您阅读本文之前的基本必备知识。</p><h2 id="6479" class="lw kq it bd kr mh mi dn kv mj mk dp kz kb ml mm ld kf mn mo lh kj mp mq ll mr bi translated"><a class="ae ko" href="https://github.com/apple/swift-driver" rel="noopener ugc nofollow" target="_blank"> Swift驱动</a>，前端作业</h2><p id="505b" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">Swift的编译器驱动程序是一个协调将Swift源代码编译成各种编译结果的程序:可执行文件、库、目标文件、Swift模块和接口等。<em class="ms">驱动程序</em>是当你调用<code class="fe mt mu mv ls b">swift</code>或<code class="fe mt mu mv ls b">swiftc</code>时运行的程序。这实际上本身并没有编译任何东西；相反，它调用其他工具来产生期望的输出。例如<strong class="js iu"> <em class="ms">前端。</em>T13】</strong></p><p id="4505" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ms">前端</em>是实际编译代码的程序(在解释器模式下，通过JIT执行代码)<code class="fe mt mu mv ls b">.</code>Xcode构建系统在你点击command+B后会做很多工作，你可以在Xcode报告导航器(Command + 9)上查看。第一个命令是<code class="fe mt mu mv ls b"><strong class="js iu">swift -frontend.</strong></code></p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mw"><img src="../Images/00f6e5b49b02bf71c2158321f8167054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DvNW3vSaeWbt7C-EfdlEg.png"/></div></div></figure><p id="b15c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正常的Swift编译从与输入文件一样多的<em class="ms">前端作业</em>开始。Swift前端的每次调用都会解析模块中的每个文件，但也会有一个特定文件被标记为<em class="ms">主文件。</em>一个作业只负责编译它的主文件，并且只做编译该文件所需的工作，对模块中其他文件的声明进行惰性类型检查。例如，下面的图片描述了由编译Feature3.swift和PrivateModel.swift组成的前端作业。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ne"><img src="../Images/2c370fa60677888a5c05e277dd6a7731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZJM33p1q5uNt9Si2PGClw.png"/></div></div></figure><p id="2617" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这两个文件也被视为主要文件。(<strong class="js iu">swift-frontend-c-primary-file feature 3 . swift</strong>)前端作业发出诊断、目标文件、依赖信息和<em class="ms">部分模块文件。</em>构建系统负责生成Feature3-OutputFileMap.json文件指定的这些文件，这些文件放置在<strong class="js iu">/Users/vedon/Library/Developer/Xcode/derived data/DI-bgjyihycmgnhgmehddbteazwwqm/Build/intermediates . no index/pods . Build/Debug-iphone simulator/feature 3 . Build/Objects-normal/x86 _ 64</strong>文件夹中。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nf"><img src="../Images/d29e30a5bdf79c90bc2cff6070aedc9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2vzKHLlT_SNhucwBFWJ_UA.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">功能3-输出文件映射</figcaption></figure><p id="2363" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">特殊的<code class="fe mt mu mv ls b">""</code>条目用于应用于整个构建的输出。下图是Feature3-master.swiftdeps的内容。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nk"><img src="../Images/01e4ca974eb6a0ea621699ec55b91b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R1IFbW0a4icSx3-rYWJTJQ.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">功能3-master.swiftdeps</figcaption></figure><p id="078f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以查看PrivateModule.swift的Xcode build命令，看看Xcode是如何生成这些文件的。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nl"><img src="../Images/103b386311c55efcf82159e29fadefc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLN7BvFCpxxmY7_j_ytBkA.png"/></div></div></figure><figure class="ln lo lp lq gt mx"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">移除不必要的构建信息</figcaption></figure><p id="dcdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些文件位于路径/Library/Developer/Xcode/derived data/DI-bgjyihycmgnhgmehddbteazwwqm/Build/intermediates . no index/pods . Build/Debug-iphone simulator/feature 3 . Build/Objects-normal/x86 _ 64</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi no"><img src="../Images/d56c9efef6d17a2fda092d2778b65764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LmyrtXKBVUVjd40yuEA5Xg.png"/></div></div></figure><p id="ecc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我找到了一些文件扩展名的解释。</p><h2 id="7691" class="lw kq it bd kr mh mi dn kv mj mk dp kz kb ml mm ld kf mn mo lh kj mp mq ll mr bi translated">*.d</h2><p id="2c19" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">按照命令(emit-dependencies-path)的意思记录源文件的依赖文件路径。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi np"><img src="../Images/a71484abc8596ef0ee27ef57728dfec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5owZH1w0w9sxlW6X5zQIw.png"/></div></div></figure><h2 id="8493" class="lw kq it bd kr mh mi dn kv mj mk dp kz kb ml mm ld kf mn mo lh kj mp mq ll mr bi translated">*.swiftdeps</h2><p id="6a6e" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">Swift编译器使用扩展名为"的文件。swiftdeps”在单个模块中存储关于跨文件依赖关系的信息。这些文件在编译开始时被读入，以计算依赖图，并随着编译的进行而更新(和重新读取)。但是，因为这些文件在每次构建时都会更新，所以依赖关系分析的问题很难重现——输入已经丢失。</p><h2 id="fc65" class="lw kq it bd kr mh mi dn kv mj mk dp kz kb ml mm ld kf mn mo lh kj mp mq ll mr bi translated">*.swift模块</h2><p id="bfd2" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">Swift没有头文件；相反，它使用一种生成的二进制格式，称为<em class="ms"> Swift模块文件，相当于头文件</em>。前端为项目中的每个源文件生成一个“部分”模块，就像为每个源文件生成一个. o文件一样。对于N个前端作业，有必要将所有部分模块文件缝合在一起。这项工作也由前端在一个称为“模块合并”的步骤中执行。模块合并只会生成一个合并的模块文件(以及带有扩展名的文档文件)。swiftdoc)，然后可以在以后的构建中导入它。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nq"><img src="../Images/0a80afd7a0044d6ca9845b456140aa09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LspTap0dXkEny7MBkO2NVA.png"/></div></div></figure><h2 id="dba1" class="lw kq it bd kr mh mi dn kv mj mk dp kz kb ml mm ld kf mn mo lh kj mp mq ll mr bi translated"><strong class="ak"> *。swiftsoureinfo </strong></h2><p id="ebcd" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我找不到这个文件的规范声明，但我认为这个文件用来记录编译文件信息，除了标记为private。文件内容可能包括文件的修改时间、文件路径、Swift编译器版本等。</p><p id="5be1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您在已编译文件的类中添加一些新的空行，您的swiftsourceinfo数据存储在CodeResource文件(*。framework/_ code signature/code resource)将被更改。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nr"><img src="../Images/701f8fa9087c4ffe8c7f4bd43c47be2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dThdXbbfa-g-_oU3HTV4AQ.png"/></div></div></figure><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ns"><img src="../Images/743a8f41b39820573d4e91a3ea50d666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dAhtxgJABpjcXiUXJhuYEg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">代码资源</figcaption></figure><h2 id="8915" class="lw kq it bd kr mh mi dn kv mj mk dp kz kb ml mm ld kf mn mo lh kj mp mq ll mr bi translated">依赖性分析的演示分析</h2><p id="e614" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我的<a class="ae ko" href="https://github.com/vedon/DI" rel="noopener ugc nofollow" target="_blank">演示</a>的依赖图如下所示。feature2有Feature3的一些依赖项，因此由于这些依赖项的修改，一些文件将被重新编译。但是Xcode是如何决定哪些文件应该重新编译的呢？</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nt"><img src="../Images/c20e03935c40ea99c85e38e8366f0438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NcAvw8ogpToZHuBL.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated"><a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/dependency-injection-in-swift-bc16d66b038b">https://level up . git connected . com/dependency-injection-in-swift-BC 16d 66 b 038 b</a></figcaption></figure><p id="fb74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Swift的模块内依赖性分析基于“提供”/“依赖”系统，该系统最终试图证明哪些文件不需要重建。如上所述，文件扩展名为。存储跨文件依赖关系。让我们看看Feature2.swiftdeps和Feature2.swift的源代码。</p><figure class="ln lo lp lq gt mx"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nu"><img src="../Images/35fe9cd85477faf5a856ff76338c718e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y4Z_fEGAMfp9GkDTUhazlA.png"/></div></div></figure><p id="2601" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你没有读过<a class="ae ko" href="https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.md" rel="noopener ugc nofollow" target="_blank">依赖分析</a>，我强烈推荐你读一读。到目前为止，我只关注<strong class="js iu">外部依赖</strong>，它们是使用一个特殊的<code class="fe mt mu mv ls b">depends-external</code>集合来跟踪的。这些依赖关系引用模块外部的文件。Swift驱动程序专门解释这个集合，并决定跨模块的依赖性是否已经改变。出于好奇，我修改了内容，在/opengles . framework/Headers/opengles . API notes文件中添加了空行，这将导致整个项目重新构建。为什么？</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nv"><img src="../Images/41b27a4b9134e8cd234ac0e043b07da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LuEtBLclszoIxMM2.png"/></div></div></figure><p id="926f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我检查了我所有的swiftdeps文件，发现它们都依赖于OpenGLES.apinotes，最后要提到的是interface-hash注释，顾名思义，就是为Feature2.swift文件生成的哈希值。根据我的分析，如果您添加新属性、新函数、添加扩展或修改现有的方法签名等，哈希值将会改变，但不包括修改函数体。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nw"><img src="../Images/bc899caab41b36f1ce461e3d468320f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71CjXooLoK_UXsel-N-Z8Q.png"/></div></div></figure><p id="74fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个文件都有一个它“提供”什么和“依赖”什么的列表，当一个文件被触动时，每个“依赖”第一个文件“提供”什么的文件都需要重建。从演示的角度来看，Feature2依赖于Feature3提供的，所以如果Feature3提供了更改，Feature2将重新构建，也就是说，接口散列被更改了。</p><h2 id="18a5" class="lw kq it bd kr mh mi dn kv mj mk dp kz kb ml mm ld kf mn mo lh kj mp mq ll mr bi translated">结论</h2><p id="7a92" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">添加属性、函数、扩展或修改现有方法签名所有会改变接口哈希值的内容都将导致相应的swift模块文件改变，依赖于此修改模块的模块将重新构建。</p><h1 id="caf5" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">编译时间</h1><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div class="ab gu cl nx"><img src="../Images/25c539fe65eb4d0a96a2e2ac985838a6.png" data-original-src="https://miro.medium.com/v2/format:webp/0*lvDQDqiwnEMQqZO6.jpeg"/></div></figure><h2 id="f0f2" class="lw kq it bd kr mh mi dn kv mj mk dp kz kb ml mm ld kf mn mo lh kj mp mq ll mr bi translated">编译时间的坏例子</h2><p id="6571" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我想把编译时间的糟糕情况分成两种类型，跨模块(粗粒度)和模块内(细粒度)。</p><h2 id="cfe8" class="lw kq it bd kr mh mi dn kv mj mk dp kz kb ml mm ld kf mn mo lh kj mp mq ll mr bi translated"><strong class="ak">跨模块</strong></h2><p id="ae99" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">模块A依赖于模块B，如果模块B指定的接口之一发生变化，模块A将重建所有文件。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ny"><img src="../Images/b791154eba24ec32dc2ee4cfe247beda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4HIlt0FOxGme55ogq2vptw.png"/></div></div></figure><p id="ea72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的图片显示了两个模块之间的编译信息。你可能会说，将B.swift标记为private will会破坏编译链。对不起，它不起作用。私有的B.swift文件仍然被视为由<a class="ae ko" href="https://github.com/apple/swift/blob/master/docs/Driver.md" rel="noopener ugc nofollow" target="_blank">输出文件映射</a>指定的前端作业之一。您也可以打开相应的*-master.swiftdeps文件以获得更多详细信息。例如构建时间。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nz"><img src="../Images/64aa2fce2b6210a9ebe360417e3294a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sj1oaiKu-obeniDAFGG8fA.png"/></div></div></figure><p id="0c62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你有很多模块，并且没有很好地处理它们之间的依赖关系，那么在你修改了一行代码之后，你会毁了你的一天。</p><h2 id="020b" class="lw kq it bd kr mh mi dn kv mj mk dp kz kb ml mm ld kf mn mo lh kj mp mq ll mr bi translated">模块内</h2><p id="f6d5" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">如果文件的引用接口被更改，文件将被重新编译。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oa"><img src="../Images/6f6641d9d1888cea39b3063c1d38b9f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s1LHLVsYR1RA3K8N7kbT8Q.png"/></div></div></figure><ul class=""><li id="fd6a" class="ob oc it js b jt ju jx jy kb od kf oe kj of kn og oh oi oj bi translated">如果B.swift或C.swift接口被更改，A.swift将被重新编译。</li><li id="2bfb" class="ob oc it js b jt ok jx ol kb om kf on kj oo kn og oh oi oj bi translated">如果E.swift接口被更改或影响E.swift接口的C.swift接口被更改，D.swift将被重新编译。</li></ul><p id="5b65" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您有许多swift文件依赖于C.swift文件，并且C.swift文件经常被修改，那么在您修改C.swift文件上的一行代码后，您将毁了您的一天。所以，你应该注意像Util.swift这样的东西，它允许你在里面放任何东西。</p><p id="09e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更多信息，请访问<a class="ae ko" href="https://github.com/apple/swift/blob/master/docs/DependencyAnalysis.md" rel="noopener ugc nofollow" target="_blank">级联与非级联依赖关系</a>。</p><h2 id="2a9e" class="lw kq it bd kr mh mi dn kv mj mk dp kz kb ml mm ld kf mn mo lh kj mp mq ll mr bi translated">解决编译时间问题的方法</h2><p id="c612" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">如果编译时间问题发生在跨模块中，我使用的解决方法是使用依赖注入和DIP设计模式。更多信息请访问我的<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/dependency-injection-in-swift-bc16d66b038b">以前的文章</a>。如果编译时间问题发生在模块内，问题会变得复杂。我对纯Swift模块有一些建议。</p><ul class=""><li id="bbdb" class="ob oc it js b jt ju jx jy kb od kf oe kj of kn og oh oi oj bi translated">遵循<a class="ae ko" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank">界面分离原则</a>。不要把所有东西都放在一个swift文件中。例如Util.swift</li><li id="a20a" class="ob oc it js b jt ok jx ol kb om kf on kj oo kn og oh oi oj bi translated">你的源文件的接口应该设计成通用的，以减少接口的数量并保持稳定性。</li></ul><p id="5747" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">许多模块将Objective-C与Swift混合使用。苹果公司的建议如下。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi op"><img src="../Images/e06a6bd1ae9736667c096b9d47ba5911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJI0ZUQNJ2bFuOBPV23KFw.png"/></div></div></figure><p id="9f0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Swift调用Objective-C使用桥接头和Objective-C调用Swift使用生成头是减少编译时间的关键。通过Objective-C私有所有不需要的东西，以减少通过生成的头文件暴露的接口。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi oq"><img src="../Images/ba36431738fe7f1e19aabe23bfb84661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXsgJtbQifLOmV7H8vQLCg.png"/></div></div></figure><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi or"><img src="../Images/a91dda53e34e2b1a9fe68ef197b081ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1te6i4_pHVmDnBnWzi8uCQ.png"/></div></div></figure><p id="cada" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">私有所有不需要的东西。您可以添加一些像MyViewController+internal.h这样的私有头来隐藏其他类不使用的MyNetworkManager属性。</p><figure class="ln lo lp lq gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi os"><img src="../Images/22c39735863db3beda0634e446200773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WaSTCa74JOhaczaaV2nLVw.png"/></div></div></figure><p id="062a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读，任何建议都会有帮助。</p><h1 id="383b" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">参考</h1><p id="cfc1" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated"><a class="ae ko" href="https://swift.org/swift-compiler/#compiler-architecture" rel="noopener ugc nofollow" target="_blank"> Swift编译器</a></p><p id="4103" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://developer.apple.com/videos/play/wwdc2018/408/" rel="noopener ugc nofollow" target="_blank">Xcode中的WWDC 2018建设更快</a></p><p id="3194" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://bytes.swiggy.com/advanced-techniques-to-speed-up-the-compile-time-in-xcode-27819cb3be59" rel="noopener ugc nofollow" target="_blank">加速Xcode编译时间的高级技术</a></p></div></div>    
</body>
</html>