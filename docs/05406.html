<html>
<head>
<title>Theming styled-components with CSS custom properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有CSS自定义属性的主题化样式组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/theming-styled-components-with-css-custom-properties-e60050237741?source=collection_archive---------8-----------------------#2020-08-25">https://levelup.gitconnected.com/theming-styled-components-with-css-custom-properties-e60050237741?source=collection_archive---------8-----------------------#2020-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d3aa2855f8919c4c1fddeef747d19c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sMfmZnT6hwS6FjynVahbjw.jpeg"/></div></div></figure><div class=""/><p id="b821" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我从Vue过渡到React(这里有更多关于它的信息<a class="ae kw" href="https://daily.dev/posts/ive-made-up-my-mind-i-know-how-to-choose-my-next-tech-stack" rel="noopener ugc nofollow" target="_blank"/>)。有了Vue，我习惯用老派风格的标签写纯CSS。现在随着过渡反应，我想体验一些不同的东西，所以我决定给<a class="ae kw" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank">样式组件</a>一个尝试。老实说，到目前为止我喜欢它。它有助于保持易于重构和扩展的可维护风格。唯一的缺点是，如果你过度使用他们的道具系统，你的造型会变得不那么可读和凌乱。这正是我喜欢CSS自定义属性(变量)的原因，它们可以帮助你保持CSS的整洁，尤其是在主题化的时候！</p><h1 id="e508" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">CSS自定义属性</h1><blockquote class="lv lw lx"><p id="5160" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><em class="jb">就像你知道的任何其他可变系统一样</em></p></blockquote><p id="9ac2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">CSS自定义属性通常称为CSS变量，包含可以在整个应用程序中重用的值。就像你知道的任何其他可变系统一样。它们在94.75%的浏览器市场份额上受到支持，因此它甚至可以投入生产。</p><p id="409e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">定义一个自定义属性就像设置一个CSS属性，唯一的区别是你需要加上前缀<code class="fe mc md me mf b">--</code>。</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="ffbd" class="mo ky jb mf b gy mp mq l mr ms">:root {<br/>  --theme-primary: #F5005E;<br/>}</span></pre><p id="23f3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我初始化了一个名为<code class="fe mc md me mf b">theme-primary</code>的新自定义属性，并将其值设置为<code class="fe mc md me mf b">#151618</code>。<code class="fe mc md me mf b">:root</code>伪类用于确保新的定制属性在整个文档中都可用，而不仅仅是在特定的范围内。<br/>现在要使用<code class="fe mc md me mf b">theme-primary</code>，我们可以使用CSS函数<code class="fe mc md me mf b">var</code>。让我们看看实际情况:</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="af5f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要了解更多信息，<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties" rel="noopener ugc nofollow" target="_blank">查看MDN文档</a>。</p><h1 id="eef7" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">CSS自定义属性与样式化组件属性</h1><blockquote class="lv lw lx"><p id="9d30" class="jy jz ly ka b kb kc kd ke kf kg kh ki lz kk kl km ma ko kp kq mb ks kt ku kv ij bi translated"><em class="jb"> CSS自定义属性将保持你的代码整洁易读，而样式化组件属性更加灵活</em></p></blockquote><p id="cd31" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您已经掌握了什么是CSS自定义属性。但是样式组件也有一个道具系统。那么我们如何决定哪一个对我们更好呢？简而言之:CSS自定义属性将保持代码的整洁和可读性，而样式化组件属性则更加灵活。让我们深入研究一下。</p><p id="66e0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一方面，我们有CSS自定义属性，为您提供所有现成的CSS功能。变量自动向下游传递给子元素，您可以用更具体的规则覆盖它们，并像任何其他CSS属性一样动态地更改它们。样式也保持整洁和优雅(稍后将详细介绍)。但是说到底，它们只是线，你不能用它们做任何花哨的事情。</p><p id="a7ce" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，样式化组件道具拥有JavaScript的力量。您可以像使用任何其他JavaScript变量一样使用它们，并相应地更改样式。您可以对用户事件做出反应，根据react组件属性设置值，验证，设置类型，以及基本上所有的事情。问题是，使用道具的样式更难阅读，最终的捆绑会更大。</p><p id="8659" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主题属性通常是静态设置的，几乎可以被应用程序中的任何组件访问。它为CSS自定义属性提供了一个完美的用例。传递主题是我们免费获得的，我们不需要验证或应用任何复杂的规则。</p><h1 id="d079" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">样式-组件全局样式</h1><p id="4e21" class="pw-post-body-paragraph jy jz jb ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">styled-components专注于创建具有范围样式的组件。但有时，我们需要对所有组件应用全局样式。例如，如果我们想重置浏览器的默认样式，或者在我们的情况下，如果我们需要应用一个全局主题。<br/>由于这个具体原因，我们可以使用助手函数<code class="fe mc md me mf b">createGlobalStyle</code>。让我们更新之前的例子，使用样式化组件和<code class="fe mc md me mf b">createGlobalStyle</code>。</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="3ba9" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">主题</h1><p id="9863" class="pw-post-body-paragraph jy jz jb ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">我们差不多完成了，这是过程的最后一步。在这里，我们将整合我们所学的一切，为我们的React应用程序创建一个可维护的主题系统。为了创建主题，我们需要用不同的值多次设置相同的CSS自定义属性。例如，假设我们有一个深色主题(默认)和一个浅色主题。默认情况下，暗值将在<code class="fe mc md me mf b">:root</code>伪元素中设置，亮值可在<code class="fe mc md me mf b">html.light</code>中设置。如果html元素打开了light类，它将覆盖默认值。</p><p id="6fb5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看它的实际效果吧！</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5eb9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看多简单啊！一旦自定义属性被更改，它会自动传播到每个组件。</p><p id="6c7b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了便于比较，我用样式化组件内置解决方案创建了相同的演示。(更多信息<a class="ae kw" href="https://styled-components.com/docs/advanced#theming" rel="noopener ugc nofollow" target="_blank">点击此处</a>)</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="465c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我看来，这种实现有两个缺点。首先，我发现它可读性较差，解决方案也不够优雅，因为它包含了太多的字符串插值。第二，输出包更大，因为样式化组件为道具的每个值创建一个类。如果您在切换主题时打开DevTools，您将看到button类发生了变化。</p><p id="2b52" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终，由您决定您更喜欢哪个解决方案。没有对错之分。</p><h1 id="63cd" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">奖励:转换主题变化</h1><p id="1ac4" class="pw-post-body-paragraph jy jz jb ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">你已经成功了，这是个不错的奖励。平滑地过渡UI变化总是更好的，对主题也是如此。我们所要做的就是切换主题，添加一个过渡。这将确保每个属性都平稳过渡。请小心使用，因为在某些情况下它可能会导致性能问题。</p><figure class="mg mh mi mj gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="dc63" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅此而已！我很高兴你通过了。请在下面的评论中告诉我你的想法👇</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><p id="a4d7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ly">这篇客座博文是❤️与</em><a class="ae kw" href="https://r.daily.dev/gitconnected" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc"><em class="ly">daily . dev</em></strong></a><em class="ly">合作向</em><a class="ae kw" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank"><em class="ly">git connected</em></a><em class="ly">社区发布的。daily.dev在每个新标签页提供最好的节目新闻。它将为您排列数百个合格的来源，以便您可以侵入未来。</em></p><figure class="mg mh mi mj gt is gh gi paragraph-image"><a href="https://r.daily.dev/gitconnected"><div class="gh gi nh"><img src="../Images/51b45a5053d4bd2cb9a7399fe2288716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lw6kGC2y_FFtRUmn.png"/></div></a></figure></div></div>    
</body>
</html>