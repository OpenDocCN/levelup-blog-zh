<html>
<head>
<title>Control rendering with React Memo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React备忘录控制渲染</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/control-rendering-with-react-memo-39ef36486588?source=collection_archive---------5-----------------------#2020-08-02">https://levelup.gitconnected.com/control-rendering-with-react-memo-39ef36486588?source=collection_archive---------5-----------------------#2020-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div></figure><p id="74d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在React 16.8引入React钩子之前，我们在类和函数组件之间切换。所有的类组件包含状态，而函数组件包含所有的JSX，并管理UI的呈现。</p><p id="6be2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类组件的一个主要好处是它包含了生命周期挂钩，可以用来控制组件，如ComponentDidMount、ComponentDidUnmount、componentDidCatch。类Components还包含shouldComponentUpdate生命周期挂钩，当您想要控制组件的呈现时，这非常有用。</p><p id="dad6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React背后的虚拟DOM比较节点树中的状态，当一个JSX元素被更新时，每个子元素也被更新。虚拟DOM速度很快，性能也很好，所以我们通常不需要为了性能而优化代码。</p><p id="6d94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您很可能会有一些组件不必要地重新呈现，但是性能下降可能不会影响您的代码或用户体验，因此您完全不必担心。不然React也不会很流行:-)。</p><p id="fec3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最终，您会发现自己实现了一个包含许多子组件的组件，您需要这些特性或功能来控制重新呈现。</p><p id="87f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">shouldcomponentdupdate()</em>用于控制组件何时应该更新。在下面的例子中，我们检查是否不等于“绿色”，并返回结果，这将决定我们是否可以更新组件。如果颜色是绿色，我们将返回false，这将导致<em class="kw"> render() </em>没有被调用，因此不会更新组件。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="d700" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在父组件中实现Collection.js组件，并添加一些简单的按钮来演示行为。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="26a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，这种使用<em class="kw"> shouldComponentUpdate </em>的方式仅用于演示目的，而不是您应该如何处理条件渲染。</p><p id="0bac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着React 16.8引入钩子，你将会看到多个曾经是类组件的组件被写成一个带有<em class="kw"> useState </em>钩子的函数组件。</p><p id="255c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw"> useEffect </em>用于控制常见的生命周期挂钩，如componentDidMount、componentWillUnmount和componentDidUpdate，但它不包含<em class="kw">shouldcomponentdupdate</em>挂钩功能，如类组件。</p><p id="035e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> React.memo来救援！</strong></p><p id="8cf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React.memo是memoization的缩写，是一个高阶组件，只有在属性发生变化时才会更新。在维基百科上，记忆被描述为</p><p id="e66a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">中的</em> <a class="ae ld" href="https://en.wikipedia.org/wiki/Computing" rel="noopener ugc nofollow" target="_blank"> <em class="kw">计算</em> </a> <em class="kw">、</em> <strong class="ka ir"> <em class="kw">记忆化</em> </strong> <em class="kw">或</em> <strong class="ka ir"> <em class="kw">记忆化</em> </strong> <em class="kw">是一种</em> <a class="ae ld" href="https://en.wikipedia.org/wiki/Optimization_(computer_science)" rel="noopener ugc nofollow" target="_blank"> <em class="kw">优化</em> </a> <em class="kw">技术主要用于加速</em> <a class="ae ld" href="https://en.wikipedia.org/wiki/Computer_programs" rel="noopener ugc nofollow" target="_blank"> <em class="kw">计算机程序</em> </a> <em class="kw">通过存储昂贵的</em>结果</p><p id="67d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在代码看起来像这样</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="4ef1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用React memo进行组合，Collection现在已成为CollectionMemo。现在CollectionMemo只会在道具变化的时候更新。</p><p id="d01f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">我如何根据特定的传递属性来控制组件的更新？</strong></p><p id="25c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很高兴你问了:-)</p><p id="3989" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用React.memo，您可以传递一个回调作为第二个参数，在这里您将接收前一个属性和下一个属性，并可以根据这些信息确定组件是否应该更新。您可以在这里添加逻辑来确定这一点。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="c139" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在areEqual函数中，如果道具相等，我们返回true，说明道具是相同的，不应该更新。否则我们更新组件来反映道具。如果通过设置useState来更新组件，那么不管React.memo条件如何，组件都会更新。</p><p id="ed1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望对你有帮助！</p></div></div>    
</body>
</html>