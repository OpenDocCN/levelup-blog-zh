<html>
<head>
<title>The Magician’s Guide to Algorithms, part 2: The Merge Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">魔术师算法指南，第2部分:合并排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-magicians-guide-to-algorithms-part-2-the-merge-sort-84e3cbdd1cd2?source=collection_archive---------0-----------------------#2017-10-15">https://levelup.gitconnected.com/the-magicians-guide-to-algorithms-part-2-the-merge-sort-84e3cbdd1cd2?source=collection_archive---------0-----------------------#2017-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/85a83f3f613da22e7f81b6f712a1f640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/1*mg6mFUVcOqfflDxiMC2m8A.gif"/></div></div></figure><p id="7599" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上周，我们在帮助斯内普收集坩埚时，讨论了气泡分类。本周我们将跳到布莱克比尔，帮助昆汀·科尔德沃特整理他的扑克牌。这不会是完美的，昆汀知道这一点。你看，魔术是一件棘手的事情，不会总是给我们想要的结果。但是合并排序将使我们更接近于整理昆廷的混乱，所以我们将尝试一下。</p><p id="44c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">合并排序</strong></p><p id="9d5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">咒语是这样的:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="dfef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者说，这是咒语。合并排序(据我的研究显示)将总是需要两个函数来成功地排序Quentin的卡片组。原因是:您需要一个函数来递归地将列表分割成越来越小的列表，直到每个列表只包含一个条目，并且您需要另一个合并函数来将排序后的列表重新组合在一起。</p><p id="0352" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ld le lf lg b">mergeSort</code>函数很容易解释。因为我们是优秀的魔术师(而且懒于此),如果列表只有一个项目，我们不希望函数过早返回，因为一个项目的列表总是排序的。</p><p id="17b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，长度超过一个条目的列表必须一分为二，首先找到中点，然后将列表分割成两个不同的变量。</p><p id="28ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们在另一个带两个参数的<code class="fe ld le lf lg b">merge</code>函数中递归调用<code class="fe ld le lf lg b">mergeSort</code>函数，这两个参数位于列表的左侧和右侧。</p><p id="9f80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">合并功能</strong></p><p id="2ac2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">merge函数稍微复杂一点，但只是一点点。</p><p id="c5ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ld le lf lg b">merge</code>函数的作用是将分离的列表按照从少到多的顺序合并在一起。这需要一个<code class="fe ld le lf lg b">while</code>循环，首先检查左侧和右侧列表的长度。如果一方没有，就没有必要排序。我们还可以假设剩余的边已经被排序了，因为mergeSort被递归地调用了。</p><p id="2f31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当两个列表都有长度时，我们检查左边的第一项是否小于右边的。如果是这样，我们<code class="fe ld le lf lg b">shift</code>从左边的列表中取出第一个项目，并将其压入结果数组。我们可以这样做，因为<code class="fe ld le lf lg b">list.shift()</code>返回从数组开始移除的项目。</p><p id="a52b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果左边的元素比右边的大，我们做相反的事情。</p><p id="434d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，两个列表的剩余部分连接在一起。这样做的原因很简单，因为我们知道如果一个列表已经被清空，并且两个列表都已经被排序，那么剩余的元素就比结果数组中已经存在的元素要多。</p><p id="cafe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">结论</strong></p><p id="9f3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样，我们学会了如何给昆汀的卡片分类。</p><p id="09b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不相信我？取上面的代码，插入下面的代码:</p><p id="ed5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ld le lf lg b">mergeSort([4, 2, 3, 5, 1, 7, 8, 10, 9, 6])</code></p><p id="3908" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">分类了吗？我想是的。昆廷想学习更好、更强大的法术，以帮助他解决排序问题。下一次我们将报道<a class="ae kw" href="https://medium.com/gitconnected/the-magicians-guide-to-algorithms-part-3-the-binary-search-20ced57ba929" rel="noopener">二分搜索法</a>，现在我们已经把昆汀的卡片整理好了。</p></div></div>    
</body>
</html>