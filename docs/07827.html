<html>
<head>
<title>4 Git Commands for Productive Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向高效开发人员的4个Git命令</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/4-git-commands-for-productive-developers-eda9da16004?source=collection_archive---------7-----------------------#2021-03-14">https://levelup.gitconnected.com/4-git-commands-for-productive-developers-eda9da16004?source=collection_archive---------7-----------------------#2021-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4d52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Git是大多数开发人员日常生活的一部分。许多人没有充分利用git的特性。下面是我经常使用的一些有用的命令，它们有助于保持我的工作效率和交付代码。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/aa59a76f3e1ea5c0e93e77f81e14221b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6o_qgQmjxuUNESxm"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae lb" href="https://unsplash.com/@matteocatanese?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Matteo Catanese </a>拍摄的照片</figcaption></figure><h1 id="c4d5" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">1.git还原</h1><p id="c3e0" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><a class="ae lb" href="https://git-scm.com/docs/git-restore" rel="noopener ugc nofollow" target="_blank">恢复</a>命令可用于删除您对暂存和未暂存文件所做的更改。下面是使用restore命令的两个用例。</p><h2 id="3524" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">未分级文件</h2><p id="2907" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">假设您正在处理您的分支。您已经对一些文件进行了更改，并意识到您实际上并不需要这些更改。您可以对工作目录中的所有文件使用restore命令，而不是转到编辑器中的文件并尝试按Ctrl+Z键(或计算机上的任何快捷键来撤消)将文件恢复到原始状态。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mr"><img src="../Images/a3445a507f48d5e71fa6f0f1e651756f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nAJkbpwnuv1upVAIFtpDbQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">对未转移的文件使用restore命令。</figcaption></figure><p id="6a14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面可以看到，当我们第一次检查状态时，有三个未分级的变更，两个在工作目录中，一个在子目录中。下一个命令是“git restore”，在工作目录上运行restore。当运行下一个status命令时，您可以看到所有的更改都已从文件中删除。</p><h2 id="f298" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">暂存文件</h2><p id="d1c1" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">现在，假设您已经对您的分支进行了更改，并且已经暂存了一些文件，并且意识到您意外地暂存了一个不需要的更改。为了撤消暂存的更改，请使用“- staged”标志，并添加从工作目录到需要撤消更改的文件的路径。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mr"><img src="../Images/d7fbc39872e99af7c86ee48a7b7610f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5MapwfZUhEyE2bKL-bgDQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">对暂存文件使用还原。</figcaption></figure><p id="55d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在上面的初始状态命令中看到，有两个暂存文件。然后，使用分段选项对特定文件运行还原。文件中的更改会被保留，但在第二个状态命令中不会被转移。</p><h1 id="2626" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">2.git贮藏</h1><p id="6e90" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Git有分支和标签来帮助团队跟踪远程存储库中的代码。在本地存储库中，也有一个<a class="ae lb" href="https://git-scm.com/docs/git-stash" rel="noopener ugc nofollow" target="_blank">存储库</a>开发者可以用来存储代码。有几个使用存储的用例。</p><h2 id="d864" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">快速换挡</h2><p id="089b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">有时候，当您正在编写一个特性时，有人拍了拍您的肩膀，或者ping偷偷溜到您的屏幕上，您正因为一个需要立即优先处理的生产bug而离开当前的工作。您检查您的git状态，并且您有阶段化的变更、新文件、未阶段化的变更，所有这些都在您的工作分支上。所有这些都需要消失，这样您就可以开始工作在最新的生产发布标签。这是可以利用的地方。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="1015" class="mf ld iq mt b gy mx my l mz na">$ git stash save --no-keep-index --include-untracked</span></pre><p id="8f01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此命令将获取工作分支中的所有更改；新文件，分阶段的和未分阶段的，并把它们放在你的存储库的顶部，它本质上是一个代码变更引用的堆栈。您将引用放入存储库，然后在需要时按照后进先出的顺序将它们取出。当您处理完生产bug并返回到您的功能工作时，您可以运行以下命令来获取您隐藏的更改。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="7c92" class="mf ld iq mt b gy mx my l mz na">$ git stash pop</span></pre><p id="3dab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，当您弹出您隐藏的变更时，被暂存的变更现在未被暂存，但是仍然在文件中。您所做的更改将被恢复，您可以继续处理该特征。</p><h2 id="bbe8" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">快速抛出变化</h2><p id="aa74" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">使用git stash的另一个例子是，当你正在处理一个特性时，你对解决方案进行了一些提交。现在，您已经做了一些未分级的更改，添加了一些文件，并意识到您所做的更改和创建的文件是解决方案的错误方向。在这种情况下，您可以将所有未暂存的更改和新文件放入您的存储中，然后删除存储中的最后一个项目。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="1dbc" class="mf ld iq mt b gy mx my l mz na">$ git stash save --keep-index --include-untracked<br/>$ git stash drop</span></pre><p id="8632" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">keep-index选项用于不隐藏任何分段更改。stash drop命令用于删除stash顶部的最后一条记录。</p><h1 id="af76" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">3.git重置</h1><p id="3d06" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><a class="ae lb" href="https://git-scm.com/docs/git-reset" rel="noopener ugc nofollow" target="_blank"> reset </a>命令可用于撤回已提交的代码更改。当您偶然提交到一个分支时，这可能是有用的。</p><p id="d58a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我所在团队的一个常见做法是锁定主分支和开发分支，并且只允许通过拉请求将代码更改移入分支。当您尝试将提交推送到这些分支时，您会看到类似下面的消息。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nb"><img src="../Images/37487a20145ed0fc39b438a4b26cb197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bkUuW-UJqcBE2DUJHLNSCA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">GitHub拒绝对受保护分支的推送。</figcaption></figure><p id="8e0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您意外地将更改提交到远程服务器上受保护的本地分支，您可以使用以下命令将这些更改回滚到未转移状态。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="8b91" class="mf ld iq mt b gy mx my l mz na">$ git reset HEAD~<br/>$ git checkout -b new-feature-branch<br/>$ git commit -am "commit changes to correct branch"</span></pre><p id="be65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">reset HEAD~命令将上次提交的更改拉回到未转移状态。所有的更改都是未分级的，您可以创建并检出一个新的特征分支，这是通过checkout -b命令完成的。一旦在那个分支上，您就能够将变更提交到正确的分支。</p><h1 id="2018" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">4.git合并-挤压</h1><p id="6b33" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><a class="ae lb" href="https://git-scm.com/docs/git-merge" rel="noopener ugc nofollow" target="_blank"> merge </a>命令很常见，无论开发人员是在积极使用git GUI、Git Bash，还是让IDE来处理它，他们都很可能每天使用它。</p><p id="d059" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">合并时可以使用挤压选项来清理提交历史。有些提交可能是无用的，比如当您修改代码样式以匹配其他文件中的标准时。其他提交可能不适合出现在远程服务器的日志历史或公司标准中。无论哪种方式，如果您想清理您的日志历史，您可以在合并时使用挤压选项。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/1c7c91c9e5e2f82ec71c174dc4aac244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R3QVyS0i5Uww_XND-NDZNA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">提交要清理的历史日志。</figcaption></figure><p id="4ea7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看上面的日志，有四个提交；三个来自开发分支，最后一个来自主分支，这是创建开发分支之前的最后一次提交。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/18d66480f7f4566a96cc6c250aabe254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ARsE4YHiOQX00YYpXCePpA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">挤压提交开发分支变成主</figcaption></figure><p id="366a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在,“开发”分支合并到“带有挤压选项的母版”中。当运行status命令时，您会看到有已暂存但未提交的更改。这是因为develop中的所有提交都被删除了，只保留了更改。下一个命令是在执行挤压合并时需要提交新的更改。最后，当我们检查最后两次提交的日志时，您会看到来自开发分支的提交都不见了，取而代之的是单个压缩的合并提交，然后是在创建开发分支之前来自主分支的单个原始提交。</p><p id="181e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当多人在一个分支上工作时，压制合并是一个不好的做法。提交应该归功于开发人员。这也会引起问题，因为历史实际上已经被删除了。只有当您是唯一一个在被合并的分支中进行更改的开发人员时，才使用git squash是一个好的实践。</p><h1 id="1105" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="d4a5" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Git是许多开发人员日常生活的一部分。许多允许ide处理git交互。花时间学习命令行，并使用不常用的命令将有助于您成为更高效的开发人员，并帮助您成为团队中有价值的一员。</p><p id="fc24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编码快乐！</p></div></div>    
</body>
</html>