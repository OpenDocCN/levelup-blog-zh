<html>
<head>
<title>Apollo Client + Typescript Hook Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apollo客户端+ Typescript钩子模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/apollo-client-typescript-hook-patterns-33353b6315a1?source=collection_archive---------7-----------------------#2020-04-21">https://levelup.gitconnected.com/apollo-client-typescript-hook-patterns-33353b6315a1?source=collection_archive---------7-----------------------#2020-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/185a0ee19821594d0a5b8202f749e22e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mvQY8-kaB3AbSTNC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@steve_j?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯蒂夫·约翰森</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e58a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在过去的18个月里，我们已经看到React和Apollo带来了许多伟大的新东西。可以说，钩子是最重要的变化之一。在我看来，它们对我们代码库的结构、外观和感觉产生了最大的影响。我花了一些时间和另一个开发人员Ben Lacy讨论我们希望我们的钩子结构是什么样子，这是我们发现最有用的。这是第1/3部分，包括文件夹结构和使用查询。寻找useMutation和useLazyQuery文章。</p><h1 id="0203" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">文件夹结构</h1><h2 id="b435" class="lz lc iq bd ld ma mb dn lh mc md dp ll ko me mf lp ks mg mh lt kw mi mj lx mk bi translated">以前</h2><p id="6ab6" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">在之前一个基于GraphQL的项目中，我们使用了一个类似这样的文件夹结构。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="298b" class="lz lc iq mv b gy mz na l nb nc">app<br/> - graphql<br/>    * query_name.gql<br/> - hoc<br/>    * ApolloQueryHelper.js<br/> - pages<br/>    * dashboard.js<br/> - components<br/>    * ListItem.js<br/> - types<br/>    * User.ts</span></pre><p id="5cde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种结构有一个优点，你可以很容易地重用查询和片段。查询应该有唯一的名称。这种结构减少了具有相同签名但使用唯一名称的gql查询的重复。<code class="fe nd ne nf mv b">RefetchQueries</code>使用查询名称，因此如果您的应用程序需要使用<code class="fe nd ne nf mv b">RefetchQueries</code>函数，使用单个查询名称更容易跟踪。</p><h2 id="638e" class="lz lc iq bd ld ma mb dn lh mc md dp ll ko me mf lp ks mg mh lt kw mi mj lx mk bi translated">更好的方法</h2><p id="adaa" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">如果我们开始更多地考虑模块，我们可以创建与应用程序其他部分耦合较少的组件。目标是只需要传入一个id来生成一个组件。这将创建具有本地化显示/逻辑的组件，并且更容易在整个项目中跟踪。这也将允许您更容易地将组件移植到新项目中。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="c046" class="lz lc iq mv b gy mz na l nb nc">app<br/> - components<br/>   - UserName<br/>     - graphql<br/>       - __generated__.  &lt;-- created by Apollo codegen <br/>         * generatedQueryType.ts  &lt;-- created by Apollo codegen<br/>       * useUserNameQuery.ts<br/>       * useUserNameMutation.ts<br/>     * UserName.tsx</span></pre><p id="25d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意到生成的文件了吗？我一般用打字稿工作，这些是由阿波罗Codegen(<a class="ae kc" href="https://github.com/apollographql/apollo-tooling" rel="noopener ugc nofollow" target="_blank">https://github.com/apollographql/apollo-tooling</a>)创建的，我强烈推荐看看。这里的动机是将您的显示逻辑包含在<code class="fe nd ne nf mv b">UserName.tsx</code>中，并将您的大部分业务/控制器逻辑移到<code class="fe nd ne nf mv b">useUserNameQuery</code>或<code class="fe nd ne nf mv b">useUserNameMutation</code></p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="3168" class="lb lc iq bd ld le nn lg lh li no lk ll lm np lo lp lq nq ls lt lu nr lw lx ly bi translated">使用查询</h1><p id="69b1" class="pw-post-body-paragraph kd ke iq kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">UseQuery是一个用于控制graphql查询的钩子。在阿波罗客户端3中，它被放入了<code class="fe nd ne nf mv b">@apollo/client</code>包中。查询挂钩通常非常简单。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="fd4a" class="lz lc iq mv b gy mz na l nb nc">import { useQuery } from "@apollo/client";<br/>import gql from "graphql-tag";<br/>import { ActivityTableQuery, ActivityTableQueryVariables } from "./__generated__/ActivityTableQuery";</span><span id="d317" class="lz lc iq mv b gy ns na l nb nc">export default () =&gt;<br/> useQuery&lt;ActivityTableQuery, ActivityTableQueryVariables&gt;(gql`<br/>   query ActivityTableQuery {<br/>    activity(order_by: { created_at: desc }) { <br/>     id<br/>     title<br/>   }<br/> }<br/>`);</span></pre><p id="c569" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">稍微剖析一下，我们的<code class="fe nd ne nf mv b">useQuery</code>和<code class="fe nd ne nf mv b">gql</code>的导入是标准的。下一行<code class="fe nd ne nf mv b">import { ActivityTableQuery } from "./__generated__/ActivityTableQuery"</code>是导入生成的类型，我们将它传递给<code class="fe nd ne nf mv b">useQuery</code>钩子。这个查询没有变量，但是如果有，我们会将它们作为第二个类型参数传入。之后，我们传递包装在<code class="fe nd ne nf mv b">gql </code>标签中的gql查询。需要注意的一点是，您的查询应该使用唯一的名称，匿名查询是禁止的。匿名查询是那些用花括号打开而不是使用<code class="fe nd ne nf mv b">query MyQueryName.</code>的查询。查询名称将用于生成您的类型，我更喜欢大写类型名称，因此我的查询使用大写名称。</p><p id="e976" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">消费</strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="2f09" class="lz lc iq mv b gy mz na l nb nc">import React from "react";</span><span id="6920" class="lz lc iq mv b gy ns na l nb nc">import useActivityQuery from "./graphql/useActivityQuery";</span><span id="f8b3" class="lz lc iq mv b gy ns na l nb nc">...</span><span id="24b2" class="lz lc iq mv b gy ns na l nb nc">interface ActivityTableProps {...}</span><span id="c53f" class="lz lc iq mv b gy ns na l nb nc">const ActivityTable = (props: ActivityTableProps) =&gt; {<br/> const { data, loading } = useActivityQuery();<br/> return (<br/>   &lt;ul&gt;<br/>    {data?.activity?.map(act=&gt; &lt;li key={act.id}&gt;{act.title}&lt;/li&gt;)<br/>   &lt;/ul&gt;<br/>  )<br/>}</span></pre><p id="49ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GraphQL的好处之一是您可以按照自己的方式设计数据。在我们的例子中，我们只需要活动的<code class="fe nd ne nf mv b">title</code>和<code class="fe nd ne nf mv b">id </code>，所以这就是我们所要求的。</p><p id="c182" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你能控制你的模式，我建议用BFF(后端对前端)的风格来构建它。构建更能代表数据显示方式的类型，而不是看起来像RDB结构的类型，这将使每个人的生活更轻松，开发速度更快。</p><p id="5f25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">如果我无法控制API/图形怎么办？</strong></p><p id="5339" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是使用第三方API时的常见问题。我们如何修改钩子来使用数据，并以一种易于使用的方式将数据传递给显示组件？</p><p id="8ffa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个联合类型:<code class="fe nd ne nf mv b">union Activity = SummerActivity | WinterActivity</code>使用不同的主键，<code class="fe nd ne nf mv b">summerId</code>和<code class="fe nd ne nf mv b">winterId.</code>我们的组件只想显示一个值<code class="fe nd ne nf mv b">id</code>，所以这就是我们如何修改我们的钩子。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="fb02" class="lz lc iq mv b gy mz na l nb nc">import { useQuery } from "@apollo/client";<br/>import gql from "graphql-tag";<br/>import { ActivityTableQuery, ActivityTableQueryVariables } from "./__generated__/ActivityTableQuery";</span><span id="b279" class="lz lc iq mv b gy ns na l nb nc">export default () =&gt; {<br/>const {data} =  useQuery&lt;ActivityTableQuery, ActivityTableQueryVariables&gt;(gql`<br/>   query ActivityTableQuery {<br/>    activity(order_by: { created_at: desc }) { <br/>     ... on WinterActivity{<br/>       winterId<br/>      }<br/>     ... on SummerActivity{<br/>       summerId<br/>      }<br/>   }<br/> }<br/>`)</span><span id="3f8d" class="lz lc iq mv b gy ns na l nb nc">const id = activity.__typename === 'SummerActivity' ? <br/>         activity.summerId<br/>         : activity.__typename === 'WinterActivity' ?<br/>         activity.winterId <br/>         : null</span><span id="88b6" class="lz lc iq mv b gy ns na l nb nc">return { id }<br/>};</span></pre><p id="425f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们使用数据时，我们将只看到一个id，而不管它是什么类型。</p><p id="7be6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是第1部分，在我的下一篇文章中，我们将探索useMutation和用于包含变异数据的有趣模式。</p></div></div>    
</body>
</html>