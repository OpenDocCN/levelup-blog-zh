# 创建迷幻的 WebAssembly Chrome 扩展

> 原文：<https://levelup.gitconnected.com/creating-a-psychedelic-webassembly-chrome-extension-9c3a5d806e4a>

## 如何将网站上的所有图片变成色彩万花筒

![](img/cb412b614e59da5203d39dc851f49413.png)

CNN 体育版的图像处理

## 它的作用

我创建了一个 chrome 扩展，它将:

1.  扫描网站上的所有图像
2.  用 iframes 替换那些图像
3.  为用 C 编写的每个 iframe 加载一个 WebAssembly (Wasm)模块
4.  将原始网站的图像加载到模块的内存中进行操作，并写回到 HTML canvas 元素中

**为什么？这让我们能够随心所欲地操纵网站上的每一张图片。**

有了这个，我需要决定我想做什么样的操作。我知道我想创造一些奇怪的和视觉上吸引人的东西，但心里没有确切的方向。

玩了一会儿后，我想出了 **tripster** 回到伍德斯托克的迷幻之旅。😃

理解这一点的最好方法是通过演示，首先让我们看看扩展如何改变 google 主页。

*这是我的最爱之一。我没想到谷歌标题会这样，因为我只是玩了玩算法，然后重新加载看看我得到了什么结果。*

在这个结果之后，我决定看看它是如何改变 BBC 主页的。

得到这个结果后，我知道我得到了我想要的效果。 ***一个神魂颠倒的图像操纵者！😈***

如果您想亲自体验一下，可以访问以下网址找到 web 扩展:

[](https://chrome.google.com/webstore/detail/tripster/joonbncncgdeedndimiojcilgecadckc) [## Tripster

### 这是一个操作网站图片的 chrome 扩展。

chrome.google.com](https://chrome.google.com/webstore/detail/tripster/joonbncncgdeedndimiojcilgecadckc) 

## 我为什么建造它

*这首先是一个概念证明(POC)。这只是对我自己的一个学习练习，将来可能对其他人有用。我不会将它用于生产中任何重要的东西。*

我想学习的两个主要话题是

1.  Wasm
2.  Chrome 扩展

我读过很多关于 Wasm 的东西，但从来没有机会使用它。

我喜欢 Wasm 的一点是，你可以用不同的语言为其他平台编写包，并在浏览器中使用它们。这迎合了我懒惰的一面。我喜欢的另一个方面是，由于它的性能增强，它扩展了您在浏览器中可以做的事情。

*关于 Wasm 的性能，需要注意的一点是，即使性能提升往往会成为卖点，但您并不总能获得提升。这真的取决于你写的底层代码和它的作用。*

图像处理的想法部分源于我用 HTML 画布做的另一个项目。chrome 扩展部分排在最后，因为这是我创建类似东西的唯一方法，但也很有趣，因为我以前从未创建过。

## 它是如何工作的

该扩展正在使用版本 3 清单，因为您无法再创建新的版本 2 扩展。

不能使用版本 2 意味着 iframe 需要在沙箱中，因为这是唯一可以设置正确内容安全策略的地方:

```
sandbox allow-scripts script-src 'self' 'unsafe-eval'; img-src data:
```

这是必需的，这样您就可以加载图像数据 blob 并运行 Wasm 模块。如果没有**不安全评估**，Wasm 模块将失效，如这里提到的。

*你可以使用 wasm-unsafe-eval。然而，一旦我得到了它的工作，我不敢改变它，因为这是一个噩梦得到这个权利，它是在沙盒中运行，所以不能造成任何伤害。*

您可以看到，在每个页面加载中，内容脚本将执行以下操作:

您可以看到，我们对每种旅行类型**、**做了几乎相同的事情，唯一的区别是我们将不同的类型设置为全局变量，供其他函数使用。

触发此事件的事件来自服务人员。这个事件在这里被触发，因为我们希望所有的选项卡都有一个全局类型。所以当我们改变一个选项时

1.  获取弹出 JavaScript (JS)以将类型保存到本地存储
2.  在本地存储更改的服务工作器中触发事件处理程序，以将其发送到每个浏览器选项卡
3.  触发设置类型的所有浏览器选项卡事件

**如果你感兴趣，这方面的代码都在完整的回购协议中，这里没有显示。**

*上面的代码显然可以重构，因为唯一的区别是 NONE 开关。此外，我们在第一次加载时运行 scroll，这样我们马上就能得到效果。如果我们确保服务人员在内容脚本加载后触发一个事件，就不需要这样做。因为这是一个概念验证，所以我没有打扰。*

上面使用的实现函数如下所示。

现在我们有了一个[去抖](https://www.freecodecamp.org/news/javascript-debounce-example/)滚动事件的类型和处理程序，我们需要理解滚动函数是做什么的。这里有许多可移动的部分，所以让我们按时间顺序来看一下:

1.  收集所有可见图像
2.  为每个图像创建一个 iframe，根据要替换的图像传递类型和唯一的 ID
3.  使用 **getComputedStyle** 函数将 iframe 放在与图像完全相同的位置
4.  为每个图像创建一个 base64 编码的数据 blob，并在完全加载后将该数据发送到 iframe

为了达到同样的效果，我们尝试了一些其他的设置，但是由于一些原因失败了:

*   由于清单版本 3 的限制，您无法在内容脚本中运行 Wasm 它一定在沙盒里
*   您也不能将这些数据发送到 URL 中的 iframe，因为 URL 的大小有限。

因此，您必须将这些数据作为发布的消息发送给 iframe，因为 iframe 没有数据传输限制。该数据需要在 iframe 加载了**之后发送，而不是在**之前。因此，我们需要 iframe 发送一个包含唯一 ID 的“hello”事件。这个 ID 是必需的，因为内容页面不知道什么 iframe 准备好了，需要知道发送什么图像。

您可以在上面看到，我们正在为 ID 为的 iframe“hello”消息创建多个处理程序。每个函数将只响应正确的 iframe，因为它通过 if 语句中的闭包检查 iframe 的 ID:

```
if ( e.data === iframe.id.substring(0,1000) && e.origin === "null") {
```

当你做一些研究时，有另一个推荐的方法来检查这一点:

```
if ( e.data === "loaded" && e.origin === "null" && e.source === iframe.contentWindow) {
```

这在原理上应该是可行的，因为它检查了 **e.source** 和 **iframe.contentWindow** 是同一个底层对象。然而，这在开发中有效，但在部署的扩展中无效！因此，我使用上面的 ID 方法。

此时，我们已经将 iframe 放在了正确的位置，并将图像数据放在了沙箱中。现在我们需要 iframe 来接管。下面你可以看到运行在 iframe 中的 JS。

假设我们已经成功地将图像 blob 放到了 iframe 沙箱中，我们来分解一下:

1.  blob 被加载到一个 HTML 图像标签中，然后我们可以将它加载到一个 HTML 画布中
2.  然后画布数据被加载到 Wasm 内存中，这样我们就可以在 C 函数中访问它
3.  然后，当 C 函数改变底层像素时，我们在一个循环中渲染画布

我们正在使用的 C 函数如下所示。

**完整披露，以上代码摘自** [**本例**](https://compile.fi/canvas-filled-three-ways-js-webassembly-and-webgl/) **。我无法感谢他们，因为我在这一点上失去了！我所做的只是稍微修改了一下自己函数的代码，以获得我需要的效果。**

上面你可以看到我们在堆栈中创建了一个巨大的数组，然后我们将它作为指针返回给运行在 iframe 中的 JS。

*这种方法不应该这样做。我们应该已经在堆中为要放置的图像创建了内存。*

现在我们有了我们需要的 JS 和 C 代码

1.  用我们的 C 代码创建编译好的 Wasm 模块
2.  创建 JS 样板文件，它将把我们的模块加载到浏览器中

这可以通过使用 [Emscripten](https://emscripten.org/) 来完成，在主页上描述为:

> Emscripten 是一个完整的 WebAssembly 编译器工具链，使用 LLVM，特别关注速度、大小和 Web 平台。

基本上，这就像使用带有一些工具的标准 GCC 编译器一样。下面你可以看到这一点。

```
emcc --post-js src/post.js -o static/iframe.js src/image/main.c -s WASM=1 -s EXPORTED_FUNCTIONS='["_render", "_init", "_psyrender"]' -s EXPORTED_RUNTIME_METHODS='["cwrap"]' -s ALLOW_MEMORY_GROWTH
```

该命令将获取上面的 JS，然后将其放在样板 JS 的底部，样板 JS 将加载 Wasm 模块。它还导出内置的 Emscripten 函数，如 **cwrap** ，我们用它来调用 JS 中的 C 函数。这将输出一个 JS 文件和一个 Wasm 文件，您可以像往常一样将它们加载到网页中。

*上面的命令没有经过任何优化，因为这只是一个概念验证。所有可用标志的描述都非常好，如果你使用这个工具，我推荐你看一看。*

这样我们就有了想要部署到 chrome 网络商店的扩展。

## 部署 Chrome 扩展

部署 chrome 扩展相对容易。运行上面的命令创建 Wasm 文件后，您可以运行

```
npm run build
cd dist
 zip -r ../extension.zip *
```

npm 命令使用 webpack 将文件打包成一个发行版，我们可以压缩并上传到 chrome 网络商店。

*我把生产版本留为开发版本，因为 chrome 网上商店要求你不要最小化代码，这样他们就可以审查了。我没有包括 C 源代码，只有 Wasm 输出。我预计这可能是一个问题，但令人惊讶的是它通过了审查过程；所以结局好就一切都好😃。*

我用 zip 创建了一个开发者账户，并按照他们的要求发了一封新邮件，并支付了我 5 美元。然后我上传了压缩文件和图片，你可以在扩展主页上看到。

此外，我必须解释为什么我需要在清单中请求的扩展权限。这很简单，因为我需要访问所有网页以使其正常运行，我还需要访问存储器以保存用户选择的最新类型选项。

这是容易的部分。噩梦的一部分是几天后我的扩展被审查，然后我把它安装在我的浏览器上…**没有效果！**

这个问题是我自己的错，因为我有一个竞争条件，图像数据 blob 是在模块加载后发送的，所以事件处理程序没有被触发。这完全可以理解。

我不明白的是，是什么造成了开发扩展和部署扩展的差异。这非常令人沮丧，因为我必须推测它可能是什么，部署，然后测试，如果需要的话再重复一次。这花了大约一周的时间，因为每次审查需要几天时间。

最后，如你所见，它适用于 0.0.3 版本。

## 结论

前面提到的这个示例只是一个概念验证，如果您有兴趣，可以在这里找到:

[](https://github.com/mortonprod/tripster) [## GitHub - mortonprod/tripster:一个概念验证，使用 WebAssembly 在

### 在 chrome 扩展中使用 WebAssembly 操作网站图像的概念验证

github.com](https://github.com/mortonprod/tripster) 

然而，我确实觉得它对其他人有用，因为我一直在努力寻找使用 Wasm 的平易近人的例子。您可以找到一些例子，但是很多例子有时太基础了，不足以解释像内存管理这样的事情是如何工作的。特别是像图像处理这样复杂的事情，JS 和 WASM 模块之间是如何共享内存的。这甚至没有触及如何让 WASM 在不同的 chrome 扩展版本中工作的信息的缺乏。这是完全可以理解的，因为 Wasm 没有被广泛使用。

这并不是说我会在这里详细介绍。像我这样的新手不会这么大胆😄。我只是希望足够多的人埋头苦干，将产生越来越多的例子，使这个过程更容易。

展望未来，我想看看除了制作奇怪但漂亮的图像之外，我还能用这个装置做些什么。