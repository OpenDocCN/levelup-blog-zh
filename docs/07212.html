<html>
<head>
<title>Building a synonym searcher 🔍 in Rust with tokio, select, and reqwest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建同义词搜索器🔍在Rust with tokio中，选择并请求west</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-synonym-searcher-in-rust-with-tokio-select-reqwest-3dca2b00d869?source=collection_archive---------14-----------------------#2021-02-01">https://levelup.gitconnected.com/building-a-synonym-searcher-in-rust-with-tokio-select-reqwest-3dca2b00d869?source=collection_archive---------14-----------------------#2021-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7cc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为开发人员，给事物命名是一项众所周知的任务，这是一项持续的斗争。我经常打开两个或更多的浏览器标签，以便找到我要找的单词。然后有一天我突然想到。</p><blockquote class="kl km kn"><p id="a78f" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">终端里有个同义词搜索器不是很好吗？。</p></blockquote><p id="5f0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有时间可以浪费，所有其他的副业都在瞬间被放弃，我通往一个更好命名的世界的道路开始了。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/007f4fca5a3b93ac41259352f313baf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z2LxUHuLGrbOd2dB"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@tolga__?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托尔加·乌尔坎</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h2 id="b4f8" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">目标🥅</h2><p id="05f9" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">从弄清楚我们想要实现什么开始总是好的。本着努力完成这一点的精神，让我们尽量保持范围相对较小。<br/>命令行工具不必比这更复杂:</p><pre class="kt ku kv kw gt mh mi mj mk aw ml bi"><span id="1af8" class="lj lk iq mi b gy mm mn l mo mp">$ cargo run &lt;SOME-WORD&gt;</span><span id="d609" class="lj lk iq mi b gy mq mn l mo mp">suggestion 1<br/>suggestion 2<br/>suggestion 3<br/>...<br/>suggestion 10</span></pre><h2 id="1dfd" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">寻找合适的词语💬</h2><p id="9777" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">那么我们在哪里可以找到同义词呢？</p><p id="2da3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我通常用谷歌搜索我想找的同义词，然后点击进入一些网站。我意识到我通常会上这三个网站:<a class="ae li" href="https://www.thesaurus.com/" rel="noopener ugc nofollow" target="_blank">thesaurus.com</a>、<a class="ae li" href="https://www.yourdictionary.com/" rel="noopener ugc nofollow" target="_blank">yourdictionary.com</a>和<a class="ae li" href="https://www.merriam-webster.com" rel="noopener ugc nofollow" target="_blank">merriam-webster.com</a>。</p><p id="ba59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个简单的解决方案是抓取这些站点，然后合并结果。但是为了找到我们想要抓取的页面，我们需要一种可靠的方法来查询每个站点。</p><p id="fc78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过一番调查，发现每个网站都使用URL中搜索到的单词作为路径参数。太完美了:)</p><p id="9182" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查找单词“汽车”的同义词，每个站点的URL应该是:<br/> <code class="fe mr ms mt mi b"><a class="ae li" href="https://thesaurus.yourdictionary.com/car" rel="noopener ugc nofollow" target="_blank">https://thesaurus.yourdictionary.com/car</a></code> <br/> <code class="fe mr ms mt mi b"><a class="ae li" href="https://www.thesaurus.com/browse/car" rel="noopener ugc nofollow" target="_blank">https://www.thesaurus.com/browse/car</a></code> <br/> <code class="fe mr ms mt mi b"><a class="ae li" href="https://www.merriam-webster.com/thesaurus/car" rel="noopener ugc nofollow" target="_blank">https://www.merriam-webster.com/thesaurus/car</a></code></p><h2 id="c1e6" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">刮掉🛣️的路</h2><p id="2182" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">为了从每个网页中提取数据，我们首先需要一种方法来发出获取网页的HTTP请求。为此，我将使用HTTP-crate:<a class="ae li" href="https://docs.rs/reqwest/0.11.0/reqwest/" rel="noopener ugc nofollow" target="_blank"><em class="ko">req west</em></a>。</p><p id="f44d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获取网页后，我们需要某种方法来解析和选择HTML中的数据。这可以用<a class="ae li" href="https://docs.rs/select/0.5.0/select/" rel="noopener ugc nofollow" target="_blank"> <em class="ko">选择</em> </a>板条箱来完成。</p><p id="21ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我就不赘述<a class="ae li" href="https://docs.rs/select/0.5.0/select/" rel="noopener ugc nofollow" target="_blank"> <em class="ko">选择</em> </a>板条箱是如何工作的了，不过我以前写过关于这个库的文章，所以如果你想要的话，可以在这里<a class="ae li" href="https://medium.com/swlh/digging-out-the-news-with-rust-b4975c91be74" rel="noopener">阅读一下。</a></p><h2 id="1c91" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">寻找关键的🗝️</h2><p id="f375" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">下一步是找出如何在每个网站中找到重要的数据。这意味着弄清楚HTML的结构，这样我们就可以可靠地遍历它，每次都能找到相同的元素和数据。</p><p id="9330" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一些选择器语法，显示了每个网页的一种可能的解决方案。</p><p id="785e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">韦氏词典</strong> : <code class="fe mr ms mt mi b">.syn-list .mw-list &gt; li &gt; a</code> <br/> <strong class="jp ir">词库</strong> : <code class="fe mr ms mt mi b">[id="meanings"] li</code> <br/> <strong class="jp ir">你的词典</strong> : <code class="fe mr ms mt mi b">.synonym-link</code></p><h2 id="e9be" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">去拿🐶</h2><p id="de38" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">好了，让我们开始这个敲打键盘的旅程吧！</p><p id="32ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要克服的第一个障碍是从每个网站获取内容。我们如何用<em class="ko"> reqwest </em>来做这件事？</p><p id="b2dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">机箱分为两部分:异步和阻塞。尽管我们已经承诺在<em class="ko"> Tokio </em>中用async来做这件事，我们将从阻塞客户端开始，稍后再引入async。</p><p id="a1ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获取网站并提取其主体的代码非常简单。<br/> <code class="fe mr ms mt mi b">let body = reqwest::blocking::get("http://some.url")?.text()?;</code></p><p id="1a37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里阅读更多关于<code class="fe mr ms mt mi b">get</code>功能<a class="ae li" href="https://docs.rs/reqwest/0.11.0/reqwest/blocking/fn.get.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="cf16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<em class="ko">中选择</em> crate-world，你创建一个<code class="fe mr ms mt mi b"><a class="ae li" href="https://docs.rs/select/0.5.0/select/document/struct.Document.html" rel="noopener ugc nofollow" target="_blank">Document</a></code>，它代表你想要搜索和提取的HTML。这是真的，与我们将要合作的网站无关。所以我们可以从创建一个获取网站的函数并将其转换成一个<code class="fe mr ms mt mi b"><a class="ae li" href="https://docs.rs/select/0.5.0/select/document/struct.Document.html" rel="noopener ugc nofollow" target="_blank">Document</a></code>开始。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="8c93" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">挑剔的⛏️</h2><p id="8069" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们已经知道在每个网页的哪里寻找我们的数据，现在我们只需要记下适当的<em class="ko">选择</em>代码。让我们为每个网站创建一个单独的功能。</p><p id="ffb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该函数将接受一个<code class="fe mr ms mt mi b">&amp;str</code>并返回一个<code class="fe mr ms mt mi b">Vec&lt;String&gt;</code>。</p><p id="cd7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是三种实现方式:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6c90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这三个函数都使用这个小助手函数从一个<em class="ko">选择</em> <code class="fe mr ms mt mi b"><a class="ae li" href="https://docs.rs/select/0.5.0/select/node/struct.Node.html" rel="noopener ugc nofollow" target="_blank">Node</a></code>对象中提取文本。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="0e6a" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">链条链条⛓️</h2><p id="890b" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">有了这三个独立的网页抓取功能，我们最终得到了三个填充了<code class="fe mr ms mt mi b">Strings</code>的列表。第一步是尝试将所有列表合并成一个大列表。</p><p id="6f3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过将我们的<code class="fe mr ms mt mi b">Vec&lt;String&gt;</code>值转换成<code class="fe mr ms mt mi b"><a class="ae li" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html" rel="noopener ugc nofollow" target="_blank">Iterator</a></code>实例，这使我们能够使用<code class="fe mr ms mt mi b"><a class="ae li" href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain" rel="noopener ugc nofollow" target="_blank">.chain </a></code>方法。就这么简单:)</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="54d0" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">🎖️新秩序</h2><p id="d886" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">如果我们使用我们的合并结果，我们会注意到同义词的排序会有点混乱。</p><p id="29dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们正在使用的网站似乎会在列表顶部显示最相关的同义词。同样，更牵强的单词会出现在列表的底部。</p><p id="f74c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们当前的解决方案将显示从<code class="fe mr ms mt mi b">res_1</code>开始的所有单词，从最相关到最不相关排序，然后<em class="ko">显示<code class="fe mr ms mt mi b">res_2</code>的排序结果，依此类推。</em></p><p id="41b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要一种跟踪同义词出现顺序的方法。</p><p id="b751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们在获取函数中使用迭代器，所以我们可以使用<code class="fe mr ms mt mi b">.enumeration</code>方法。这将是一个小切口，并给出什么后。该方法会将我们的最终结果从<code class="fe mr ms mt mi b">Vec&lt;String&gt;</code>更改为<code class="fe mr ms mt mi b">Vec&lt;(usize, String)&gt;</code>。</p><p id="8ddb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个例子:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="add6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于单词“hello ”,我们现在得到这样的结果:</p><pre class="kt ku kv kw gt mh mi mj mk aw ml bi"><span id="82c2" class="lj lk iq mi b gy mm mn l mo mp">(0, greetings)<br/>(1, hi)<br/>(2, howdy)<br/>(3, ...)<br/>...</span></pre><p id="bc8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以对枚举值进行排序，其中最小值等于最佳匹配:<code class="fe mr ms mt mi b">result.sort_by(|(a, _), (b, _)| a.cmp(b));</code></p><h2 id="a718" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">复视觉🐫</h2><p id="ffb1" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们现在可以组合我们的结果<em class="ko">和</em>排序我们的组合列表，但是另一个问题出现了…</p><p id="e2a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重复的呢？最有可能发生的情况是三个不同的提取结果可能包括相同的单词。有时单词在相同的枚举位置，有时不在。</p><pre class="kt ku kv kw gt mh mi mj mk aw ml bi"><span id="8732" class="lj lk iq mi b gy mm mn l mo mp">Source 1<br/> (0, Wonderful)<br/> (1, Perfect)</span><span id="928d" class="lj lk iq mi b gy mq mn l mo mp">Source 2<br/> (0, Brilliant)<br/> (1, Wonderful)</span><span id="4d91" class="lj lk iq mi b gy mq mn l mo mp">Source 3<br/> (0, Wonderful)<br/> (1, Nice)</span></pre><p id="a796" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，单词“精彩”根据来源1和3排在第一位，但根据来源2排在第二位。</p><p id="abb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可能有一些聪明的解决方案来解决这个问题，但让我们保持简单:)</p><p id="5ec9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想到的第一个解决方案是将每个单词分组，并对它们的枚举值求和。在本例中，“精彩”的得分为<code class="fe mr ms mt mi b">1=(0+1+0)</code>。</p><p id="a785" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用一个<code class="fe mr ms mt mi b">HashMap&lt;String, usize&gt; </code>来分组计算。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="b1f2" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">多任务⚙️</h2><p id="dcb5" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们差不多完成了。是时候加入期待已久的超级英雄Tokio了。Tokio是一个异步运行时，它允许我们轻松地同时表达和运行事物。</p><p id="a27d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的代码现在的一个问题是我们一个接一个地发出HTTP请求。在<em class="ko"> Tokio </em>和来自<em class="ko"> reqwest </em>的异步<a class="ae li" href="https://docs.rs/reqwest/0.11.0/reqwest/fn.get.html" rel="noopener ugc nofollow" target="_blank"> get </a>函数的帮助下，这些请求可以同时运行。</p><p id="0d30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的方面是它不需要我们做太多的工作来改变它。下面是将要发生的事情的清单:</p><ul class=""><li id="3ec9" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">让我们的<code class="fe mr ms mt mi b">main</code>函数与<code class="fe mr ms mt mi b">#[tokio::main]</code>宏异步。</li><li id="299d" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">将我们的三个<code class="fe mr ms mt mi b">fetch_*</code>函数转换为异步</li><li id="066d" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">将我们的<code class="fe mr ms mt mi b">fetch_website</code>转换为异步，并使用来自<em class="ko"> reqwest </em>的异步<code class="fe mr ms mt mi b">get</code></li><li id="c7c0" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated">使用<em class="ko"> Tokio的</em> <code class="fe mr ms mt mi b">join!</code>宏调用每个<code class="fe mr ms mt mi b">fetch_*</code>并等待全部完成</li></ul><p id="cc92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">…下面是一些代码示例:</p><p id="e86d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ko">主要功能签名:</em></p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="3194" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ko">取文件功能:</em></p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7c88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ko">获取其中一个同义词站点:</em></p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2138" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ko">使用Tokio的</em> <code class="fe mr ms mt mi b"><em class="ko">join!</em></code> <em class="ko">宏等待所有异步功能完成:</em></p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="436e" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">波兰✨</h2><p id="163b" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">组合结果的列表可能会很长，所以让我们通过选择前10个同义词来限制输出。最后，输出结果。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="27c9" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">这是一个总结🌯</h2><p id="2aba" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">运行<code class="fe mr ms mt mi b">cargo run improve</code>会给你一个同义词列表:)</p><p id="3e24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在测试的时候，我意识到结果有时会让人感觉有点偏差。因此，一些改进肯定是可以实现的，但是，如果一切都这么简单，那就有点无聊了！</p><p id="b102" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有很多未处理的错误，但是为了这篇文章不至于没完没了，我将把它留给你或以后的文章去深入研究。</p><p id="2965" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是同步和异步示例版本的链接:</p><ul class=""><li id="370d" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated"><a class="ae li" href="https://github.com/fabrlyn/sandbox__syno/blob/sync-version/src/main.rs" rel="noopener ugc nofollow" target="_blank">同步版本</a></li><li id="cd9c" class="mw mx iq jp b jq nf ju ng jy nh kc ni kg nj kk nb nc nd ne bi translated"><a class="ae li" href="https://github.com/fabrlyn/sandbox__syno/blob/async-version/src/main.rs" rel="noopener ugc nofollow" target="_blank">异步版本</a></li></ul><p id="b07f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢你在我晚上闲逛的时候跟着我。</p><p id="a7e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ko">/罗伯特</em></p></div></div>    
</body>
</html>