<html>
<head>
<title>How to Implement the Binary Search Tree(BST) Data Structure in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Golang中实现二叉查找树(BST)数据结构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-implement-the-binary-search-tree-bst-data-structure-in-golang-c4f2b598f752?source=collection_archive---------5-----------------------#2022-04-11">https://levelup.gitconnected.com/how-to-implement-the-binary-search-tree-bst-data-structure-in-golang-c4f2b598f752?source=collection_archive---------5-----------------------#2022-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b1b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">二叉查找树(BST)是一种数据结构，其内部节点存储的键大于该节点左子树中的所有键，小于其右子树中的所有键。</p><p id="c06c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本教程中，我们将看到如何使用Golang实现BST。如果你不熟悉它的概念，请在开始本教程之前阅读下面的帖子。</p><div class="ko kp gp gr kq kr"><a href="https://jerryan.medium.com/binary-tree-cheat-sheet-for-next-interview-7b442a84d70" rel="noopener follow" target="_blank"><div class="ks ab fo"><div class="kt ab ku cl cj kv"><h2 class="bd iu gy z fp kw fr fs kx fu fw is bi translated">以下面试的二叉树备忘单</h2><div class="ky l"><h3 class="bd b gy z fp kw fr fs kx fu fw dk translated">二叉树是一种树状数据结构，其中每个节点最多有…</h3></div><div class="kz l"><p class="bd b dl z fp kw fr fs kx fu fw dk translated">jerryan.medium.com。</p></div></div><div class="la l"><div class="lb l lc ld le la lf lg kr"/></div></div></a></div><p id="7aa6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我们将看到以下内容</p><ul class=""><li id="434a" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated">TreeNode和Tree</li><li id="d8c8" class="lh li it js b jt lq jx lr kb ls kf lt kj lu kn lm ln lo lp bi translated">插入元素&amp;插入树节点</li><li id="15ef" class="lh li it js b jt lq jx lr kb ls kf lt kj lu kn lm ln lo lp bi translated">有序遍历/前序遍历/后序遍历</li><li id="19c4" class="lh li it js b jt lq jx lr kb ls kf lt kj lu kn lm ln lo lp bi translated">最小/最大</li><li id="a9b5" class="lh li it js b jt lq jx lr kb ls kf lt kj lu kn lm ln lo lp bi translated">二进位检索</li><li id="f052" class="lh li it js b jt lq jx lr kb ls kf lt kj lu kn lm ln lo lp bi translated">移除节点</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="0246" class="mc md it bd me mf mg dn mh mi mj dp mk kb ml mm mn kf mo mp mq kj mr ms mt mu bi translated"><em class="mv"> TreeNode &amp; Tree </em></h2><p id="fb0d" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">我们首先定义两个结构，一个用于<em class="nb"> TreeNode </em>，一个用于<em class="nb"> Tree </em>。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/08845e7be0ea919a034363eb939af793.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*bu1Hyp8N9YK38UKxd0OyQA.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk translated">示例二叉树和树节点</figcaption></figure><ul class=""><li id="2c6a" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated"><em class="nb"> TreeNode </em>结构包含键、值和指向其左右<em class="nb"> TreeNode </em>的指针。</li><li id="15a0" class="lh li it js b jt lq jx lr kb ls kf lt kj lu kn lm ln lo lp bi translated"><em class="nb">树</em>结构包含<em class="nb">根节点</em>和一个<em class="nb">互斥锁</em>来锁定树。</li></ul><figure class="nd ne nf ng gt nh"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="bc2d" class="mc md it bd me mf mg dn mh mi mj dp mk kb ml mm mn kf mo mp mq kj mr ms mt mu bi translated">插入元素&amp;插入树节点</h2><p id="3283" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">方法<code class="fe np nq nr ns b">InsertElement</code>获取一个键和值，然后构造一个新的树节点，然后调用<code class="fe np nq nr ns b">InsertNode</code>函数将节点插入到树中。</p><p id="760c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数<code class="fe np nq nr ns b">InsertNode</code>不是一个树方法，因为它的实现不是特定于树的。</p><figure class="nd ne nf ng gt nh"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="1e2b" class="mc md it bd me mf mg dn mh mi mj dp mk kb ml mm mn kf mo mp mq kj mr ms mt mu bi translated">有序遍历</h2><p id="e389" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">方法<code class="fe np nq nr ns b">InOrderTraverseTree</code>将一个函数作为参数，并以该函数作为参数调用<code class="fe np nq nr ns b">inOrderTraverseTree</code>函数。</p><figure class="nd ne nf ng gt nh"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="277e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例二叉查找树的导线测量结果如下。</p><p id="9964" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe np nq nr ns b">Value 1 -&gt; Value 3 &gt; Value 6 -&gt; Value 8 -&gt; Value 10</code></p><h2 id="d2f4" class="mc md it bd me mf mg dn mh mi mj dp mk kb ml mm mn kf mo mp mq kj mr ms mt mu bi translated">前序遍历</h2><figure class="nd ne nf ng gt nh"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="cbed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例二叉查找树的导线测量结果如下。</p><p id="8c64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe np nq nr ns b">Value 8 -&gt; Value 3 &gt; Value 1-&gt; Value 6-&gt; Value 10</code></p><h2 id="9973" class="mc md it bd me mf mg dn mh mi mj dp mk kb ml mm mn kf mo mp mq kj mr ms mt mu bi translated">后置导线</h2><figure class="nd ne nf ng gt nh"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f3de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例二叉查找树的导线测量结果如下。</p><p id="6789" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe np nq nr ns b">Value 1 -&gt; Value 6 &gt; Value 3 -&gt; Value 10-&gt; Value 8</code></p><h2 id="de61" class="mc md it bd me mf mg dn mh mi mj dp mk kb ml mm mn kf mo mp mq kj mr ms mt mu bi translated">最小和最大</h2><p id="ed18" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">方法<code class="fe np nq nr ns b">MinNode/MaxNode</code>用于查找键(<strong class="js iu">非值</strong>)为最小值/最大值的节点。</p><p id="4912" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记住，没有必要遍历整个树来寻找最小值/最大值。</p><p id="71b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为BST的属性确保最小值/最大值总是最左边/最右边的节点。</p><figure class="nd ne nf ng gt nh"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="a404" class="mc md it bd me mf mg dn mh mi mj dp mk kb ml mm mn kf mo mp mq kj mr ms mt mu bi translated">二进位检索</h2><p id="993f" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">方法<code class="fe np nq nr ns b">SearchNode</code>用于搜索树中的一个节点。如果找到了，它将返回节点。如果没有，则返回零。</p><figure class="nd ne nf ng gt nh"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="4fae" class="mc md it bd me mf mg dn mh mi mj dp mk kb ml mm mn kf mo mp mq kj mr ms mt mu bi translated">移除节点</h2><p id="180b" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">方法<code class="fe np nq nr ns b">RemoveNode</code>用于根据键从树中删除一个节点。</p><figure class="nd ne nf ng gt nh"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="2380" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你喜欢读这篇文章。如果你愿意支持我成为一名作家，考虑成为<a class="ae nt" href="https://jerryan.medium.com/membership" rel="noopener">一名媒体成员</a>。你还可以无限制地访问媒体上的每个故事。</p></div></div>    
</body>
</html>