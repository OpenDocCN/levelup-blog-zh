<html>
<head>
<title>How To Write A Simple Postgres JSON Wrapper With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python写一个简单的Postgres JSON包装器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-a-simple-postgres-json-wrapper-with-python-ef09572daa66?source=collection_archive---------1-----------------------#2020-09-03">https://levelup.gitconnected.com/how-to-write-a-simple-postgres-json-wrapper-with-python-ef09572daa66?source=collection_archive---------1-----------------------#2020-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/43540378f665d7321e0e8e9548a18f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E71VWSVOUplfC6juanF3tA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">琼·加梅尔在<a class="ae kf" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="aaf1" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">Postgres是一个<em class="ll">传奇</em>数据库。它已经存在了一段时间，并且得到了广泛的支持。这个数据库快速、高效，被从初创公司到国际企业集团的各种公司广泛使用。Postgres如此受欢迎的一个原因是它有大量的扩展、插件和连接器。你可以通过许多不同的编程语言进行连接，也有许多顶级的ORM<a class="ae kf" href="https://en.wikipedia.org/wiki/Object-relational_mapping" rel="noopener ugc nofollow" target="_blank">or</a>可用。</p><p id="5848" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">根据您的特定需求和项目规模，您可能不需要设置大量额外的抽象层或框架来处理对Postgres的查询。在Python这样的语言中，为不同的查询和常用函数制作一个简单的包装器既简单又有效。</p><p id="b25d" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果您正在构建一个小型应用程序的原型，或者使用一个高度受限的嵌入式系统，那么编写一个轻量级的包装器会有很大的好处。使用非常流行的<a class="ae kf" href="https://pypi.org/project/psycopg2/" rel="noopener ugc nofollow" target="_blank"> psycopg2 </a>模块，从PG中获取JSON结果非常容易。这个用于Python的低级数据库连接模块允许您连接到Postgres、执行SQL和执行其他数据库功能。让我们探索如何使用这个模块在Python中设置一个数据库包装器，以使执行查询变得快速而简单。</p><h2 id="48bb" class="lm ln it bd lo lp lq dn lr ls lt dp lu ky lv lw lx lc ly lz ma lg mb mc md me bi translated">数据库</h2><p id="2334" class="pw-post-body-paragraph kn ko it kp b kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">对于我们的示例Postgres服务器，我们将使用一个充满测试数据的预填充数据库。这给了我们一堆样本数据来查询。毕竟一个空的数据库有什么意思。</p><p id="9e4f" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们将使用Docker来设置数据库容器，这样我们就不会用测试安装来污染我们的主机操作系统。如果你以前从未使用过Docker，或者需要快速复习一下,<a class="ae kf" href="https://medium.com/codingthesmartway-com-blog/docker-beginners-guide-part-1-images-containers-6f3507fffc98" rel="noopener"><em class="ll">Docker——初学者指南——第1部分:图片&amp;容器</em> </a> <em class="ll"> </em>是由<a class="mk ml ep" href="https://medium.com/u/c840719f0a3e?source=post_page-----ef09572daa66--------------------------------" rel="noopener" target="_blank">塞巴斯蒂安·埃施韦勒</a>编写的一个非常棒的指南，可以帮助你开始使用。</p><p id="4dc1" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">查看Docker Hub上的<a class="ae kf" href="https://hub.docker.com/r/aa8y/postgres-dataset/" rel="noopener ugc nofollow" target="_blank"> postgres-dataset </a>(大声喊出来<a class="ae kf" href="https://github.com/aa8y" rel="noopener ugc nofollow" target="_blank"> aa8y </a>创建了这个非常方便的工具)来获取最新的映像并使用下面的命令部署它。如果您已经在您的机器上运行了Postgres实例，您将希望将第一个端口从<code class="fe mm mn mo mp b">5432</code>更改为其他端口。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="fbf2" class="lm ln it mp b gy my mz l na nb">docker pull aa8y/postgres-dataset<br/>docker run -d -p 5432:5432 --name pg-ds-fake aa8y/postgres-dataset:latest</span></pre><p id="2987" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">给数据库几分钟时间来填充测试数据，然后使用以下命令连接到容器:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="23e7" class="lm ln it mp b gy my mz l na nb">docker exec -it pg-ds-fake /bin/bash</span></pre><p id="f928" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们需要做一点调整，允许从主机访问容器的PG实例。连接到容器时，运行以下命令:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="f7db" class="lm ln it mp b gy my mz l na nb">echo "host all all 0.0.0.0/0 trust" &gt; /var/lib/postgresql/data/pg_hba.conf</span><span id="3023" class="lm ln it mp b gy nc mz l na nb">pg_ctl reload</span></pre><p id="a63a" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">第一行将允许所有到Postgres的TCP/IP连接，并删除所有其他身份验证。这是<em class="ll">严格测试</em>以使事情变得更简单，而不是处理来自主机的密码和认证。在任何情况下，都不应该将此配置添加到Postgres的生产实例中。最后一个命令重新加载Postgres，以便它选择新的配置。</p><p id="522e" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在，您应该能够通过运行以下命令使用<code class="fe mm mn mo mp b">psql</code>从主机连接到Postgres(确保您首先退出容器):</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="4252" class="lm ln it mp b gy my mz l na nb">psql -U postgres -h localhost</span></pre><p id="933b" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果你没有安装<code class="fe mm mn mo mp b">psql</code>你可以参考指南<a class="ae kf" href="https://blog.timescale.com/tutorials/how-to-install-psql-on-mac-ubuntu-debian-windows/" rel="noopener ugc nofollow" target="_blank">在这里</a>安装。在<code class="fe mm mn mo mp b">world</code>数据库上尝试一个测试查询:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="d7e6" class="lm ln it mp b gy my mz l na nb">\c world<br/>SELECT * FROM country LIMIT 5;</span></pre><h2 id="79dd" class="lm ln it bd lo lp lq dn lr ls lt dp lu ky lv lw lx lc ly lz ma lg mb mc md me bi translated">包装纸</h2><p id="edf7" class="pw-post-body-paragraph kn ko it kp b kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">既然我们已经建立了数据库并运行了一些测试数据，我们可以开始用Python设置我们的包装器了。让我们打开一个新的Python文件并开始编辑。我们现在可以称之为<code class="fe mm mn mo mp b">wrapper.py</code>,并添加以下内容:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="b05a" class="lm ln it mp b gy my mz l na nb">#!/usr/bin/env python3</span><span id="9095" class="lm ln it mp b gy nc mz l na nb">import simplejson as json<br/>import psycopg2<br/>from psycopg2.extras import RealDictCursor</span><span id="313f" class="lm ln it mp b gy nc mz l na nb">class PostgresWrapper:<br/>    def __init__(self, **args):<br/>        self.user = args.get('user', 'postgres')<br/>        self.port = args.get('port', 5432)<br/>        self.dbname = args.get('dbname', 'world')<br/>        self.host = args.get('host', 'localhost')<br/>        self.connection = None</span></pre><p id="bbc4" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">首先，我们引入了<code class="fe mm mn mo mp b">simplejson</code>而不是标准的<code class="fe mm mn mo mp b">json</code>库，因为当我们查询<code class="fe mm mn mo mp b">Decimal</code>值时，只有使用支持转储该数据类型的更新库才能正确序列化它们。</p><p id="4ce0" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">接下来，我们引入<code class="fe mm mn mo mp b">psycopg2</code>库和<code class="fe mm mn mo mp b">RealDictCursor</code>工厂。这个工厂将让我们轻松地将查询结果直接序列化为一个<code class="fe mm mn mo mp b">Dict</code>类型，然后将它转储到JSON。我们还将定义一个基本的<code class="fe mm mn mo mp b">PostgresWrapper</code>类来保存我们所有的特性并提供一些默认的初始化值。现在让我们添加一些简单的连接函数:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="72c0" class="lm ln it mp b gy my mz l na nb">    def connect(self):<br/>        pg_conn = psycopg2.connect(<br/>            user=self.user,<br/>            port=self.port,<br/>            dbname=self.dbname,<br/>            host=self.host<br/>        )<br/>        self.connection = pg_conn</span><span id="8d12" class="lm ln it mp b gy nc mz l na nb">    def get_json_cursor(self):<br/>        return self.connection.cursor(cursor_factory=RealDictCursor)</span></pre><p id="f92b" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在<code class="fe mm mn mo mp b">connect()</code>函数中，我们使用<code class="fe mm mn mo mp b">psycopg2</code>直接连接到我们之前设置的Postgres数据库。这个连接还指定了在Postgres内部连接到哪个数据库。对于这个例子，我们将使用包含城市和国家的<code class="fe mm mn mo mp b">world</code>数据。下一个函数使用先前的连接来设置新的游标。光标类似于您输入SQL语句的交互式<code class="fe mm mn mo mp b">psql</code>提示符，除了这个是非交互式的并且可以通过编程控制。这个游标还使用<code class="fe mm mn mo mp b">RealDictCursor</code>规范来返回<code class="fe mm mn mo mp b">Dict</code>类型，这些类型很容易在以后作为JSON字符串返回。</p><p id="710c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">最后，让我们设置函数来实际获取一些数据:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="a536" class="lm ln it mp b gy my mz l na nb">    @staticmethod<br/>    def execute_and_fetch(cursor, query):<br/>        cursor.execute(query)<br/>        res = cursor.fetchall()<br/>        cursor.close()<br/>        return res</span><span id="6a83" class="lm ln it mp b gy nc mz l na nb">    def get_json_response(self, query):<br/>        cursor = self.get_json_cursor()<br/>        response = self.execute_and_fetch(cursor, query)<br/>        return json.dumps(response)</span><span id="e717" class="lm ln it mp b gy nc mz l na nb">    def get_countries(self):<br/>        query = "SELECT * FROM country LIMIT 2;"<br/>        print(self.get_json_response(query))</span></pre><p id="05cc" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><code class="fe mm mn mo mp b">execute_and_fetch()</code>函数使用我们之前设置的游标来执行SQL查询，关闭游标连接，然后返回结果。当动作完成时关闭游标是很重要的，因为否则每次调用<code class="fe mm mn mo mp b">execute_and_fetch()</code>都会实例化多个游标并消耗数据库中更多的资源。<code class="fe mm mn mo mp b">get_json_response()</code>函数是一个助手函数，它处理光标的实例化，并将光标和查询传递给<code class="fe mm mn mo mp b">execute_and_fetch()</code>。然后，这个函数以JSON字符串的形式返回响应。</p><p id="c4bc" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><code class="fe mm mn mo mp b">get_countries()</code>函数将利用<code class="fe mm mn mo mp b">get_json_response()</code>并传入对国家的查询。当我们调用这个函数时，我们从数据库接收查询行的最终JSON blob。</p><h2 id="c7c8" class="lm ln it bd lo lp lq dn lr ls lt dp lu ky lv lw lx lc ly lz ma lg mb mc md me bi translated">把所有的放在一起</h2><p id="39f1" class="pw-post-body-paragraph kn ko it kp b kq mf ks kt ku mg kw kx ky mh la lb lc mi le lf lg mj li lj lk im bi translated">让我们回顾一下整个包装类应该是什么样子:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="1192" class="lm ln it mp b gy my mz l na nb">#!/usr/bin/env python3</span><span id="c920" class="lm ln it mp b gy nc mz l na nb">import simplejson as json<br/>import psycopg2<br/>from psycopg2.extras import RealDictCursor</span><span id="0123" class="lm ln it mp b gy nc mz l na nb">class PostgresWrapper:<br/>    def __init__(self, **args):<br/>        self.user = args.get('user', 'postgres')<br/>        self.port = args.get('port', 5432)<br/>        self.dbname = args.get('dbname', 'world')<br/>        self.host = args.get('host', 'localhost')<br/>        self.connection = None</span><span id="2503" class="lm ln it mp b gy nc mz l na nb">    def connect(self):<br/>        pg_conn = psycopg2.connect(<br/>            user=self.user,<br/>            port=self.port,<br/>            dbname=self.dbname,<br/>            host=self.host<br/>        )<br/>        self.connection = pg_conn</span><span id="2b36" class="lm ln it mp b gy nc mz l na nb">    def get_json_cursor(self):<br/>        return self.connection.cursor(cursor_factory=RealDictCursor)</span><span id="655d" class="lm ln it mp b gy nc mz l na nb">    @staticmethod<br/>    def execute_and_fetch(cursor, query):<br/>        cursor.execute(query)<br/>        res = cursor.fetchall()<br/>        cursor.close()<br/>        return res</span><span id="65d5" class="lm ln it mp b gy nc mz l na nb">    def get_json_response(self, query):<br/>        cursor = self.get_json_cursor()<br/>        response = self.execute_and_fetch(cursor, query)<br/>        return json.dumps(response)</span><span id="ad56" class="lm ln it mp b gy nc mz l na nb">    def get_countries(self):<br/>        query = "SELECT * FROM country LIMIT 2;"<br/>        print(self.get_json_response(query))</span><span id="d61f" class="lm ln it mp b gy nc mz l na nb">dbconn = PostgresWrapper()<br/>dbconn.connect()<br/>dbconn.get_countries()</span></pre><p id="18f4" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在文件的底部，我们处理实例化<code class="fe mm mn mo mp b">PostgresWrapper</code>，连接然后调用<code class="fe mm mn mo mp b">get_countries()</code>来打印一些样本JSON数据。</p><p id="ca1b" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">您应该能够简单地运行该文件并产生结果:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="1a63" class="lm ln it mp b gy my mz l na nb">./wrapper.py</span></pre><p id="5330" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在，您应该会看到类似如下的JSON输出:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="351b" class="lm ln it mp b gy my mz l na nb">[{"code": "AFG", "name": "Afghanistan", "continent": "Asia", "region": "Southern and Central Asia", ...}]</span></pre><p id="ae48" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果一切工作正常，您将得到一个非常简单的Postgres包装器类，可以调整它来输出不同查询的JSON blobs。这可以集成到现有的Python应用程序中，甚至可以用作API的基本后端。请记住，这是一个简单的示例类，您可以对该类进行一些扩展，使查询更加灵活。</p><p id="1a30" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">将Postgres与Python的强大功能和强大的模块结合起来，您可以简化和抽象连接到数据库和从数据库中获取数据的复杂性。对于一个更加优雅的方法，可以考虑探索一个叫做<a class="ae kf" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>的<a class="ae kf" href="https://en.wikipedia.org/wiki/Object-relational_mapping" rel="noopener ugc nofollow" target="_blank"> ORM </a>模块。这允许您将数据库结果作为实际的Python对象进行交互，并编写更少的特定于数据库的代码。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="0c92" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="ll">感谢阅读！Postgres和Python是天作之合。这个包装器是超级轻量级的，容易理解，但是可以扩展更多的功能。在</em> <a class="ae kf" href="https://twitter.com/Tate_Galbraith" rel="noopener ugc nofollow" target="_blank"> <em class="ll"> Twitter </em> </a> <em class="ll">上发布一些您自己的Python &amp; Postgres配对冒险。</em></p></div></div>    
</body>
</html>