<html>
<head>
<title>Introduction to micro frontends architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微前端架构介绍</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/brief-introduction-to-micro-frontends-architecture-ec928c587727?source=collection_archive---------0-----------------------#2019-10-16">https://levelup.gitconnected.com/brief-introduction-to-micro-frontends-architecture-ec928c587727?source=collection_archive---------0-----------------------#2019-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/35e710f7b2097191b810024c23ea9b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qWGEMPbQ5zJuLfeI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://github.com/mraible/history-of-web-frameworks-timeline" rel="noopener ugc nofollow" target="_blank">https://github . com/mraible/history-of-web-frameworks-timeline</a></figcaption></figure><p id="91ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着前端世界的发展，其架构解决方案也应该发展。微前端背后的主要思想是前端应用程序的独立部分可以由独立的团队来维护。</p><blockquote class="lb lc ld"><p id="e022" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">“一种架构风格，其中可独立交付的前端应用程序被组合成一个更大的整体”</p></blockquote><h1 id="4c45" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">传统建筑</h1><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/71f15aa9b0b5116db4d51627eff29a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FBJBa_8bFlMEN38HNNkP2g.png"/></div></div></figure><h1 id="acf6" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">微服务优势</h1><ul class=""><li id="dfc1" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ms mt mu mv bi translated">去耦代码库</li><li id="e106" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">自主团队</li><li id="324e" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">与技术和框架无关</li><li id="b3bb" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">独立部署</li><li id="689f" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">可量测性</li><li id="4b76" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">复用性</li></ul><h1 id="0c8e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">也在前端上尝试一下</h1><p id="7b67" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">与微服务具有相同的优势，但如果与后端微服务相结合，则是端到端团队。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/27eb0b625c3c55a2ab72e73fc55d0465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NXq8bhGDIqhAdpAccM1EQ.png"/></div></div></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><blockquote class="nm"><p id="4409" class="nn no iq bd np nq nr ns nt nu nv la dk translated"><strong class="ak"> <em class="nw">因为你可以使用不同的框架和技术，但这并不意味着你必须这样做。</em> </strong></p></blockquote></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="6934" class="li lj iq bd lk ll nx ln lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf bi translated">何时使用微前端</h1><ul class=""><li id="695a" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ms mt mu mv bi translated">巨大的代码库，不同的团队都参与其中</li><li id="cf92" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">代码所有权变得混乱</li><li id="0505" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">由于应用程序的其他部分，部署被延迟</li><li id="c820" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">你喜欢使用不同的有限元框架</li></ul><h1 id="5efe" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">管弦乐编曲</h1><p id="b82d" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">通过编排，应该可以将不同的微前端组合成一个功能应用程序。这既可以在服务器端完成，也可以在客户端完成。为了获得最佳性能，我们应该将这些方法结合起来。</p><p id="8cd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个解决方案叫做<strong class="kf ir">构建时集成</strong>。</p><h2 id="9318" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">构建时间集成</h2><ul class=""><li id="4499" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ms mt mu mv bi translated">每个微前端应用代表一个npm包</li><li id="89b1" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">主应用程序(orchestrator/container)将自己构建成一个包含所有依赖项(微前端)的最终包</li></ul><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="d916" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这似乎有道理，但不推荐<strong class="kf ir">使用</strong>，因为它有一个很大的缺点。每当一个微前端应用程序发生变化时，整个orchestrator及其所有依赖项都应该重新构建并创建一个新版本。这可能会导致每个微前端的延迟、回滚或错误，这是我们希望避免的。另外，每个团队都应该依赖于相同的包版本，这使得创建新版本变得更加困难。</p><h1 id="784a" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.客户端编排</h1><ul class=""><li id="1d6b" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ms mt mu mv bi translated">客户端路由</li><li id="296b" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">状态共享</li><li id="9ee6" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">注册所有应用程序</li><li id="3fb8" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">解决共享依赖关系(如果有)</li><li id="b386" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">初始化主应用程序</li><li id="ac85" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">从不同的微前端应用程序合成片段</li></ul><p id="1cb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以通过使用不同的库来完成此列表，例如:</p><ul class=""><li id="c8c8" class="ml mm iq kf b kg kh kk kl ko oq ks or kw os la ms mt mu mv bi translated">单spa<a class="ae kc" href="https://single-spa.js.org/" rel="noopener ugc nofollow" target="_blank">https://single-spa.js.org/</a>(顶级路由器)</li><li id="7d6d" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">http://mnot.github.io/hinclude/(包括HTML片段)</li><li id="2c39" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">h-include<a class="ae kc" href="https://github.com/gustafnk/h-include" rel="noopener ugc nofollow" target="_blank">https://github.com/gustafnk/h-include</a>(包括使用Web组件的HTML片段)</li></ul><p id="d738" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">片段组合可以通过对不同API的简单Ajax调用来完成，这些API可以返回预先呈现的HTML，这些HTML可以在前端进行水合，或者只返回所需的脚本标签和带有ID的特定HTML标签，其中加载的片段可以呈现自身。</p><p id="a2f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也有可能使用普通的JS或者一些框架来实现你自己的编排。</p><h1 id="d286" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.1.按指定路线发送</h1><ol class=""><li id="1a72" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ot mt mu mv bi translated">使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/history" rel="noopener ugc nofollow" target="_blank">历史API </a>在应用路由器中初始化</li><li id="1010" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ot mt mu mv bi translated"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent" rel="noopener ugc nofollow" target="_blank">自定义浏览器事件</a>或<a class="ae kc" href="https://github.com/mroderick/PubSubJS" rel="noopener ugc nofollow" target="_blank"> PubSub </a>库</li><li id="84c9" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ot mt mu mv bi translated">将路由留在Orchestrator应用程序上</li></ol><h1 id="3fc8" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.2.共享全局状态并在应用程序之间进行通信</h1><ol class=""><li id="9e24" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ot mt mu mv bi translated">在这种情况下，具有每个微前端的导出公共状态的可观察模式— <a class="ae kc" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>很有用</li><li id="af36" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ot mt mu mv bi translated"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent" rel="noopener ugc nofollow" target="_blank">自定义浏览器事件</a></li><li id="80a2" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ot mt mu mv bi translated">Cookies、会话或本地存储</li></ol><h1 id="4de5" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.3.共享代码——主要是UI库</h1><ol class=""><li id="6d32" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ot mt mu mv bi translated">在第三方库的情况下，你应该使用一个支持你的微前端中所有使用的框架的库</li><li id="70f5" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ot mt mu mv bi translated">如果你正在开发自己的库，你可以使用<a class="ae kc" href="https://www.webcomponents.org" rel="noopener ugc nofollow" target="_blank"> Web组件</a>使它们通用</li><li id="f57c" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ot mt mu mv bi translated">开发和维护这个库的责任应该由每个团队承担，不要为此创建一个特定的团队</li></ol><h1 id="b23b" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.4.风格冲突</h1><ol class=""><li id="16bf" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ot mt mu mv bi translated">为每个团队确定CSS类的特定前缀</li><li id="7175" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ot mt mu mv bi translated">使用<a class="ae kc" href="http://getbem.com/" rel="noopener ugc nofollow" target="_blank">边界元样式</a></li><li id="3981" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ot mt mu mv bi translated">在JS库中使用CSS可以帮助你避免冲突——JSS<a class="ae kc" href="https://cssinjs.org" rel="noopener ugc nofollow" target="_blank">、</a><a class="ae kc" href="https://www.styled-components.com/" rel="noopener ugc nofollow" target="_blank">风格化组件</a>等等。</li><li id="6b65" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ot mt mu mv bi translated"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank">阴影DOM </a>来自<a class="ae kc" href="https://www.webcomponents.org" rel="noopener ugc nofollow" target="_blank"> Web组件</a></li></ol><h1 id="8e6c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.5.徐和UX</h1><ol class=""><li id="3323" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ot mt mu mv bi translated"><a class="ae kc" href="https://uxdesign.cc/engaging-users-with-progressive-loading-in-skeleton-screen-335a4e287a55" rel="noopener" target="_blank">框架UI</a>——基本上是一个预定义的闪屏，用于显示尚未加载的内容</li><li id="37c9" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ot mt mu mv bi translated">借助ESI或SSI的服务器端呈现(在服务器端编排中描述)</li></ol><h1 id="1323" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">1.6.拯救世界的Web组件</h1><p id="a48b" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">它们由4个规范定义。</p><h2 id="5494" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">1.6.1.自定义元素</h2><ul class=""><li id="e15e" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ms mt mu mv bi translated"><a class="ae kc" href="https://w3c.github.io/webcomponents/spec/custom/" rel="noopener ugc nofollow" target="_blank">https://w3c.github.io/webcomponents/spec/custom/</a></li></ul><p id="538c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements" rel="noopener ugc nofollow" target="_blank">定制元素</a> API允许你用生命周期方法、属性改变处理程序、事件处理程序等创建全功能的定制HTML元素。</p><p id="a047" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建自定义元素的过程:</p><ul class=""><li id="4b96" class="ml mm iq kf b kg kh kk kl ko oq ks or kw os la ms mt mu mv bi translated">创建一个扩展HTMLElement类的类</li><li id="4cfe" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">定义您的生命周期方法、自定义属性等。</li><li id="e5f6" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">将新元素与HTML模板相关联(在<em class="le"> connectedCallback() </em>生命周期方法中)</li><li id="079c" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements" rel="noopener ugc nofollow" target="_blank">自定义元素API </a>注册该元素</li><li id="32e2" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">在你的HTML中使用这个元素</li></ul><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="10eb" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">1.6.2.阴影DOM</h2><ul class=""><li id="a66a" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ms mt mu mv bi translated"><a class="ae kc" href="https://w3c.github.io/webcomponents/spec/shadow/" rel="noopener ugc nofollow" target="_blank">https://w3c.github.io/webcomponents/spec/shadow/</a></li><li id="3a13" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/Web _ Components/Using _ shadow _ DOM</a></li></ul><pre class="mh mi mj mk gt ou ov ow ox aw oy bi"><span id="aad7" class="oc lj iq ov b gy oz pa l pb pc">Element.attachShadow();</span></pre><p id="1509" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe pd pe pf ov b">attachShadow</code>方法只接受一个参数，该参数是具有一个属性<em class="le">模式</em>的对象。它允许你用两种模式创建隔离的DOM树(作用域样式，自包含组件)，<em class="le">打开</em>和<em class="le">关闭</em>。</p><p id="4efd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="le"> Open </em>意味着您可以使用在主页面上下文中编写的JavaScript访问影子DOM。另一方面，<em class="le"> closed </em>意味着只能通过自定义元素上下文中的Javascript访问影子DOM。当你必须隔离你的CSS时，这真的很有用。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="cc27" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">1.6.3.ES模块</h2><ul class=""><li id="d656" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ms mt mu mv bi translated"><a class="ae kc" href="https://html.spec.whatwg.org/multipage/webappapis.html#integration-with-the-javascript-module-system" rel="noopener ugc nofollow" target="_blank">https://html . spec . whatwg . org/multipage/web app APIs . html # integration-with-the-JavaScript-module-system</a></li></ul><p id="7c01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导入/导出JS模块，仅此而已。</p><h2 id="dba3" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">1.6.4.HTML模板</h2><ul class=""><li id="960e" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ms mt mu mv bi translated"><a class="ae kc" href="https://html.spec.whatwg.org/multipage/scripting.html#the-template-element/" rel="noopener ugc nofollow" target="_blank">https://html . spec . whatwg . org/multipage/scripting . html # the-template-element/</a></li><li id="d5e2" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated"><a class="ae kc" href="https://html.spec.whatwg.org/multipage/scripting.html#the-slot-element" rel="noopener ugc nofollow" target="_blank">https://html . spec . whatwg . org/multipage/scripting . html # the-slot-element</a></li></ul><p id="cecd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用HTML模板(<code class="fe pd pe pf ov b">&lt;template&gt;</code>)，你可以创建不在加载时呈现的HTML片段，但是你可以在运行时通过JavaScript初始化它们。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="8712" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个有用的元素是<code class="fe pd pe pf ov b">&lt;slot&gt;</code>。它是web组件技术的一部分，用作Web组件中的占位符，您可以用自己的标记填充它。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="b9f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果是:</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pg"><img src="../Images/4a55fa7d6cdd89df1263b6facf7c3f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ifudm2FcMu7Af8zBnQ2VHQ.png"/></div></div></figure><p id="1fb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，定义的具有属性<em class="le"> slot </em>的<strong class="kf ir"> <em class="le"> span </em> </strong>元素在具有属性<em class="le"> name </em>的<em class="le"> slot </em> 元素中得到呈现，其值与我们的<strong class="kf ir"> <em class="le"> span </em> </strong>元素上的<em class="le"> slot </em>属性值相匹配。</p><h1 id="c91b" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">2.服务器端编排</h1><ul class=""><li id="a177" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ms mt mu mv bi translated">具有代理请求的服务器路由</li><li id="fb8a" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">注册所有应用程序</li><li id="2541" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">解决共享依赖关系(如果有)</li><li id="ac7b" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">从不同的微前端应用程序提供和编写片段</li></ul><h1 id="6a44" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">2.2.引导应用程序</h1><p id="9f3b" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">我们可以将服务器端编排的解决方案称为引导应用程序。它可以用不同的方法来完成，通常它更复杂，包含不止一个解决方案。我将描述大公司是如何做到这一点的。</p><h2 id="9da1" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">2.2.1.扎兰多斯溶液</h2><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ph"><img src="../Images/b048df4fc7ffbdc70c121f7a493ecce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9WlTRF9h8KhU6E3G"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.zalando.com" rel="noopener ugc nofollow" target="_blank">https://www.zalando.com</a></figcaption></figure><p id="35c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它被称为https://www.mosaic9.org/马赛克项目。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pi"><img src="../Images/88e85808e815e0d794ac62cfe7397610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HZ-XtiVTNAE0DGzV"/></div></div></figure><p id="598b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用例就像你在图片上看到的一样简单。用户来到页面，浏览器点击路由器，路由器决定它是API调用还是布局调用。在API调用的情况下，路由器将请求代理给所需的API。在层调用的情况下，路由器调用知道所有可能布局的布局服务，并从不同的端点加载它们。</p><p id="0c16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您在下图中看到的，他们已经创建了开源项目来完成所有描述的步骤。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pj"><img src="../Images/d152430ed809b3de705853efa2343522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uUtTTOkWAUBno0Sb"/></div></div></figure><h2 id="2533" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">2.2.2.OpenTables解决方案</h2><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pk"><img src="../Images/5b2cdecf91f9017634ac153f02e0e64d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dt280an1cMSaJRMh"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.opentable.com/" rel="noopener ugc nofollow" target="_blank">https://www.opentable.com/</a></figcaption></figure><p id="d19e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们称之为开放组件<a class="ae kc" href="https://opencomponents.github.io/" rel="noopener ugc nofollow" target="_blank">https://opencomponents.github.io/</a>。这个项目背后的想法是有一个组件注册表，其中包含公司中的所有组件，这些组件应该可用于Node.js呈现的服务器端。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pl"><img src="../Images/800392aa4a9fcf1323a8415d11dcade9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IhWZ4jXVQmrmPDx9"/></div></div></figure><h2 id="6c09" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">2.2.3.Spotify的解决方案</h2><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pm"><img src="../Images/efab0693b78e905211a840d003a4be01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0upT0VGw2XI875Re"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.spotify.com/" rel="noopener ugc nofollow" target="_blank">https://www.spotify.com/</a></figcaption></figure><p id="540c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们在一个单独的iframe中加载每个片段。为了通信和协调不同iframes之间的事件，他们使用事件总线。每个片段都有自己的依赖项和数据。这种解决方案的缺点是一些依赖项会被加载更多次。</p><h2 id="0b32" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">2.2.4.达赞溶液</h2><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/bc8d68842145ff6a54e2641f2f29e328.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/0*xyjUK4gmrIXHLrlv"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://dazn.com/" rel="noopener ugc nofollow" target="_blank">https://dazn.com/</a></figcaption></figure><p id="dd1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在前端，他们有自己的解决方案，非常类似于https://single-spa.js.org/的单spa <a class="ae kc" href="https://single-spa.js.org/" rel="noopener ugc nofollow" target="_blank">，在服务器端有一个引导层，它组成片段并处理不同路由的请求。</a></p><h2 id="d17e" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">2.2.5.脸书溶液</h2><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi po"><img src="../Images/b3e757683d6e25940d2dac55f1a16e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*92FDEd--Yr5M6gOB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">【https://www.facebook.com/ T4】</figcaption></figure><p id="d9b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们称之为<strong class="kf ir"> BigPipe。</strong>类似于Zalandos solution的Tailor.js。实际上Tailor.js的灵感来自facebook的BigPipe。你可以在这里阅读关于它如何工作的原始帖子<a class="ae kc" href="https://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919/" rel="noopener ugc nofollow" target="_blank">https://www . Facebook . com/notes/Facebook-engineering/big pipe-piping-web-pages-for-high-performance/389414033919/</a>。</p><h1 id="d9ff" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">2.3.碎片组合的可能性</h1><p id="adbc" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">现在谈谈服务器端片段组合的技术方面。有两种更老的技术，通过它们我们可以很容易地完成组合，<strong class="kf ir">服务器端包括(SSI) </strong>和<strong class="kf ir">边缘端包括</strong> ( <strong class="kf ir"> ESI)。</strong>它们用于将不同的HTML标记合并成一个。在这两种情况下，我们都需要维护一个对应于静态HTML文件的URL映射。</p><h2 id="d0bf" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">2.3.1.服务器端包含(SSI)</h2><ul class=""><li id="67f7" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ms mt mu mv bi translated"><a class="ae kc" href="http://www.alticore.eu/wasd_root/doc/env/env_0400.html" rel="noopener ugc nofollow" target="_blank">http://www.alticore.eu/wasd_root/doc/env/env_0400.html</a></li><li id="740a" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated"><a class="ae kc" href="https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection" rel="noopener ugc nofollow" target="_blank">https://www . owasp . org/index . PHP/Server-Side _ Includes _(SSI)_ Injection</a></li><li id="cbb4" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated"><a class="ae kc" href="https://www.w3.org/Jigsaw/Doc/User/SSI.html" rel="noopener ugc nofollow" target="_blank">https://www.w3.org/Jigsaw/Doc/User/SSI.html</a></li><li id="07fc" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated"><a class="ae kc" href="http://httpd.apache.org/docs/current/howto/ssi.html#basic" rel="noopener ugc nofollow" target="_blank">http://httpd.apache.org/docs/current/howto/ssi.html#basic</a></li><li id="3b04" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">简单的解释型服务器端脚本语言</li><li id="1c1e" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">受Apache、Nginx等支持。</li></ul><p id="be81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在主html文件中:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="3462" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Nginx配置中:</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="e9a4" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">2.3.2.边缘侧包括(ESI)</h2><ul class=""><li id="8308" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ms mt mu mv bi translated"><a class="ae kc" href="https://www.w3.org/TR/esi-lang" rel="noopener ugc nofollow" target="_blank">https://www.w3.org/TR/esi-lang</a></li><li id="9b70" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">小型标记语言</li><li id="0580" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">这只是一个从未成为标准的建议</li><li id="bc02" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">由不同的技术或库支持(Nginx、Varnish等。)</li><li id="6a87" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">对于NodeJS，有<a class="ae kc" href="https://www.npmjs.com/package/nodesi" rel="noopener ugc nofollow" target="_blank"> nodesi </a> npm包</li></ul><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="oo op l"/></div></figure><h2 id="cc84" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated">2.3.3.自己的实现</h2><p id="2f25" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">您可以在服务器端实现自己的解析器或某种标记助手。几乎每个模板库都有一些实现自定义标签解析的可能性。</p><h1 id="1c66" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">3.微前端架构的缺点</h1><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/8282d0584649d6c554bc4cd485f69fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/0*8srxNXy8zuvoMK2F"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">https://twitter.com/TheLarkInn/status/1139281821810618369<a class="ae kc" href="https://twitter.com/TheLarkInn/status/1139281821810618369" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><ul class=""><li id="4143" class="ml mm iq kf b kg kh kk kl ko oq ks or kw os la ms mt mu mv bi translated">更大的捆尺寸</li><li id="dd14" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">较慢的加载时间</li><li id="b01f" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">现有团队的团队组织变更</li><li id="123c" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">对小公司来说不必要的复杂</li></ul><h1 id="cad0" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="80a6" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">通过分析问题来选择工具。不要试图用你最喜欢的工具来解决每个问题。</p><p id="b233" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您选择微前端架构，您可以面向两个群体:</p><h2 id="510a" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated"><strong class="ak">完全独立</strong></h2><ul class=""><li id="b8c2" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ms mt mu mv bi translated">每个团队选择他们的<strong class="kf ir">技术栈</strong>——没有代码共享</li><li id="7e50" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">每个片段都有自己的API调用</li><li id="2bd9" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">每个视图由<strong class="kf ir">全功能片段</strong>组成</li><li id="6f14" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">每个微前端应用都有自己的<strong class="kf ir"> CI/CD </strong></li></ul><h2 id="6b08" class="oc lj iq bd lk od oe dn lo of og dp ls ko oh oi lw ks oj ok ma kw ol om me on bi translated"><strong class="ak">战略合作</strong></h2><ul class=""><li id="cdb3" class="ml mm iq kf b kg mn kk mo ko mp ks mq kw mr la ms mt mu mv bi translated">就技术堆栈达成一致，并且<strong class="kf ir">共享公共</strong>库</li><li id="0799" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">API调用流经<strong class="kf ir"> bootstrap </strong> <strong class="kf ir"> app </strong></li><li id="2af3" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">共享的<strong class="kf ir"> UI库</strong></li><li id="b88f" class="ml mm iq kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">共享的<strong class="kf ir"> CI/CD </strong></li></ul></div></div>    
</body>
</html>