<html>
<head>
<title>How to Release Your Code Into the Wild</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将你的代码释放到野外</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-release-your-code-into-the-wild-dd144218cb9b?source=collection_archive---------12-----------------------#2022-08-07">https://levelup.gitconnected.com/how-to-release-your-code-into-the-wild-dd144218cb9b?source=collection_archive---------12-----------------------#2022-08-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7f3d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">…在这个过程中不会发疯</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7f08028b18117c4379dfbdf85ab220df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n293EZ52Hq0zI_yaOIUyHA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">中途，莫比乌斯和恩基·比拉风格的鸟笼</figcaption></figure><p id="f8d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编码很好。但不可避免的是，总有一天我们需要编译我们生成的代码，并将最终结果发布出去。无论是以应用程序、网站、程序、共享库还是NPM模块的形式…</p><p id="2c96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可能一开始很容易管理。</p><p id="fd36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是随着项目的增长，<strong class="la iu">推出代码的复杂性也在增加。活动部件越多，损坏的机会就越多。</strong></p><p id="1066" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，在工作中，我们使用集成了React应用程序的PHP后端堆栈。因此，将新版本投入生产包括:</p><ul class=""><li id="a5ee" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">从我们使用的翻译工具下载任何<strong class="la iu">翻译</strong></li><li id="f5b6" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">运行<strong class="la iu">棉绒</strong>检查代码质量，</li><li id="8082" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">运行<strong class="la iu">单元测试</strong>，</li><li id="4009" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">缩小javascript代码</li><li id="2d84" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">更新版本号</strong></li><li id="67d8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">将各种React组件</strong>构建成产品包，</li><li id="d21d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">将编译好的javascript推送到<strong class="la iu"> CDN </strong></li><li id="8454" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在<strong class="la iu"> AWS </strong>上将PHP代码推送到服务器。</li></ul><p id="0da3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">忘记这些步骤中的任何一个都会带来麻烦。我浪费了几个小时试图记住该做什么，以及如何解决困扰部署过程的问题。当你试图记住如何更新一个你已经三个月没做的项目时，情况会更糟。</p><p id="3e55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么答案是什么呢？</p><p id="77fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原则上，解决方案很简单:自动化一切可以自动化的东西。</p><p id="b236" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我有好消息告诉你:有一个强大的工具可以让你自动化很多T21的事情。它叫做GitHub Actions。但这令人望而生畏，所以今天我们要看看:</p><ul class=""><li id="7f7e" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">如何使用<code class="fe mj mk ml mm b">release-it</code>和<code class="fe mj mk ml mm b">auto-changelog</code>来编写你的发布过程</li><li id="5fbc" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如何设置GitHub动作来自动化发布过程</li></ul><h1 id="497b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用release-it释放NPM模块</h1><p id="21fb" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">首先，让我们看看如何部署我们的代码。我将使用我创建的<a class="ae nk" href="https://github.com/Kodaps/faker" rel="noopener ugc nofollow" target="_blank"> NPM模块</a>来开发一个简化版本。</p><p id="5092" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在继续下去之前，这里有一句忠告。如果使用yarn而不是npm，用GitHub动作发布NPM模块会复杂得多。我的建议是在你可能有的任何<code class="fe mj mk ml mm b">yarn.lock</code>文件上运行<code class="fe mj mk ml mm b">git rm</code>，并且只使用npm。(使用纱线是可行的，但是有点复杂)。</p><p id="7dc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我每次更新我的npm包时都使用五个步骤。</p><ol class=""><li id="91d7" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt nl ma mb mc bi translated">我确保我的代码是最新的(通过git pull)。</li><li id="e047" class="lu lv it la b lb md le me lh mf ll mg lp mh lt nl ma mb mc bi translated">我通过运行单元测试(用Jest)和林挺(用ESLint)来确保代码是干净的。</li><li id="c173" class="lu lv it la b lb md le me lh mf ll mg lp mh lt nl ma mb mc bi translated">我准备了一个变更日志，列出了自上一版本以来的所有变更。</li><li id="cb75" class="lu lv it la b lb md le me lh mf ll mg lp mh lt nl ma mb mc bi translated">然后，我设置了新的版本号。</li><li id="7377" class="lu lv it la b lb md le me lh mf ll mg lp mh lt nl ma mb mc bi translated">最后，我提交并发布了全部内容，既发布给GitHub，也发布给NPM。</li></ol><p id="58a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">这里有一个快速提示</strong>:每当我自动化任何事情时，我都是从创建一个本地脚本文件开始的，该文件按顺序运行所有的步骤。例如，为了推出代码，我倾向于创建一个名为“up.sh”的批处理文件，它位于我的项目的根目录下，运行所有的任务。</p><p id="c30c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是我遇到了一个工具，它可以满足我所有的出版需求，甚至更多。这是一个名为<a class="ae nk" href="https://github.com/release-it/release-it" rel="noopener ugc nofollow" target="_blank"> release-it </a>的NPM模块，我现在在几乎所有的项目中都使用它。请允许我向你展示它是如何工作的。</p><p id="9bc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，为了设置它，我们运行:</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="2140" class="nq mo it mm b gy nr ns l nt nu">npm init release-it</span></pre><p id="fea0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该工具会询问几个问题。它要么将其配置存储在<code class="fe mj mk ml mm b">package.json</code>中，要么存储在一个名为<code class="fe mj mk ml mm b">.release-it.json</code>的单独文件中。我个人更喜欢第二种方式，因为我的package.json文件通常已经包含了相当多的内容。</p><p id="e59b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，在我提到的五个步骤中，一个是跟踪和更新版本号。这已经包含在发布工具中了。一步完成了，还有四步。</p><p id="64c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，如果git存储库不处于干净状态，release-它还会拒绝<em class="mi">做任何事情。例如，如果有未提交的工作正在进行。默认情况下，这已经解决了。</em></p><p id="bf95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一件事是确保我们只从实际上应该被发布的git分支中发布。为此，我们在配置文件(<code class="fe mj mk ml mm b">.release-it.json</code>)中添加一个约束，如下所示:</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="1d2f" class="nq mo it mm b gy nr ns l nt nu">{<br/>  "git": {<br/>    "requireBranch": "main",<br/>  }<br/>}</span></pre><p id="63ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是不言自明的:只有在“主”分支上才运行。在工作中，我们使用一个叫做“预生产”的分支来准备和测试我们的代码，所以我用它来代替。</p><p id="71d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们还可以指定发布包时将创建的提交消息:</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="7cef" class="nq mo it mm b gy nr ns l nt nu">{<br/>  "git": {<br/>    "requireBranch": "main",<br/>    "commitMessage": "chore: release v${version}",<br/>  }<br/>}</span></pre><p id="d08c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，接下来的步骤是确保我的代码是最新的，并测试它。我已经使用Jest和EsLint在我的项目中设置了测试，并使用“npm run test”和“npm run lint”运行它们。</p><p id="1843" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这些在任何事情发生之前就开始运行，所以我使用了一个release-it生命周期挂钩，而且有很多这样的挂钩。所以在我的配置文件中，我现在在<code class="fe mj mk ml mm b">before:init</code>钩子中有一个包含三个项目的列表:</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="22fe" class="nq mo it mm b gy nr ns l nt nu">{<br/>  "git": {<br/>    "requireBranch": "main",<!-- -->   <br/>    <!-- -->"commitMessage": "chore: release v${version}",<br/>  },<br/>  "hooks": {<br/>    "before:init": ["git pull", "npm run lint", "npm run test"],<br/>  }<br/>}</span></pre><p id="12ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这也是不言自明的。我们为release-it定义了一个钩子，它在开始工作之前运行，并且用<code class="fe mj mk ml mm b">git pull</code>更新代码。然后用<code class="fe mj mk ml mm b">npm run lint</code>检查林挺错误，用<code class="fe mj mk ml mm b">npm run test</code>运行单元测试。</p><p id="1726" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想做的最后一件事是添加一个变更日志；列出我们在发布之间所做的一切。但是我们写的提交已经陈述了我们做了什么，所以我们也可以自动化这个。</p><p id="aaee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们将使用一个叫做<a class="ae nk" href="https://github.com/cookpete/auto-changelog" rel="noopener ugc nofollow" target="_blank"> auto-changelog </a>的工具。</p><p id="b225" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了触发它，我们将使用另一个名为<code class="fe mj mk ml mm b">after:bump</code>的钩子。顾名思义，一旦版本号被“升级”,它就会运行。</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="8db5" class="nq mo it mm b gy nr ns l nt nu">{<br/>  "git": {<br/>    "requireBranch": "main",<br/>  },<br/>  "hooks": {<br/>    "before:init": ["git pull", "npm run lint", "npm run test"],<br/>    "after:bump": "npx auto-changelog -p",<br/>  }<br/>}</span></pre><p id="714d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们添加了一个-p标志，告诉工具版本号存储在package.json文件中。</p><p id="e008" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将使用提交数据创建一个changelog文件，并创建发布信息。</p><p id="eae2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们指定要将代码发布到GitHub，并发布到NPM。</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="3408" class="nq mo it mm b gy nr ns l nt nu">{<br/>  "git": {<br/>    "requireBranch": "main",<br/>  },<br/>  "hooks": {<br/>    "before:init": ["git pull", "npm run lint", "npm run test"],<br/>	"after:bump": "npx auto-changelog -p",<br/>  },<br/>  "github": {<br/>    "release": true<br/>  },<br/>  "npm": {<br/>    "publish": true<br/>  }<br/>}</span></pre><p id="e275" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在是检验它的时候了。如果您查看package.json文件，init应该已经在脚本部分添加了一个release条目:</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="2757" class="nq mo it mm b gy nr ns l nt nu">{<br/>  [...]<br/>  "scripts": {<br/>    "release": "release-it",<br/>    [...]<br/>  },<br/>}</span></pre><p id="aaa9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这允许我们运行<code class="fe mj mk ml mm b">npm run release</code>来触发释放过程。当我们这样做的时候，我们会被问到一系列的问题:我们是想把它定义为一个小的升级，一个大的升级，还是一个突破性的改变？我们要出版吗？诸如此类。这允许我们运行整个过程并检查正在发生的事情。</p><p id="1df6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦它以您想要的方式工作，现在就是时候…进一步自动化它了！</p><h1 id="91ca" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用GitHub动作使事情更加自动化</h1><h2 id="11e0" class="nq mo it bd mp nv nw dn mt nx ny dp mx lh nz oa mz ll ob oc nb lp od oe nd of bi translated">了解工作流文件</h2><p id="7110" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">为此，我们将使用GitHub操作。现在，什么是GitHub动作，它们是如何工作的？</p><p id="8844" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设你在一家公司，一个新的开发人员加入了你的团队。你是做什么的？</p><p id="e3ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，首先你给他买一台新电脑，然后你帮他下载代码，安装好所有东西，然后开始工作。</p><p id="de21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从某种意义上说，GitHub Actions做的也是同样的事情。它设置了一个带有操作系统的容器。然后它下载软件和我们代码的当前版本。最后，它执行一组任务…</p><p id="dfe0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们创建了一个名为<code class="fe mj mk ml mm b">.github</code>的文件夹。在该文件夹中，我们创建另一个名为<code class="fe mj mk ml mm b">workflows</code>的文件夹。在这个文件夹中，我们创建了一个名为<code class="fe mj mk ml mm b">release.yml</code>的文件。</p><p id="3013" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有三个必填字段:<code class="fe mj mk ml mm b">name</code>、<code class="fe mj mk ml mm b">on</code>和<code class="fe mj mk ml mm b">jobs</code>。它们定义了工作流的名称、触发时间以及采取的操作。</p><p id="1384" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的例子中，工作流将被称为“发布&amp;发布到NPM ”,所以我们相应地填写名称。</p><p id="2b6c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而且会手动触发，所以我们把“开”字段设置为:<code class="fe mj mk ml mm b">“workflow_dispatch”</code>。(我们可以在这里添加几个不同的触发器，并配置它们，但在我们的例子中，我们不需要这样做)。</p><p id="18cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的发布配置文件现在看起来像这样:</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="195e" class="nq mo it mm b gy nr ns l nt nu">name: Release &amp; Publish to NPM<br/>on: workflow_dispatch</span></pre><p id="7880" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在到了有趣的部分，即<code class="fe mj mk ml mm b">jobs</code>字段！这定义了可以运行的作业列表，每个作业都是步骤列表。我们的第一个(也是唯一的)任务将被称为<code class="fe mj mk ml mm b">release</code>，现在我们开始配置它！</p><p id="5cb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们首先使用“runs-on”参数指定我们想要运行的操作系统。这里我指定了ubuntu。现在我们定义步骤列表。我们从简单的开始，只是为了测试一下</p><p id="4d60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们做的第一件事是检索代码，为此，我们将使用一个名为“actions/checkout@v2”的预打包动作。这个是由GitHub创建的，有许多不同用例的可用操作。</p><p id="9ce6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第二步中，我们安装依赖项，为此，我们只需在步骤中指定我们想要运行的命令。所以这里我们有执行动作<code class="fe mj mk ml mm b">npm ci</code>(它运行一个干净的安装)。</p><p id="2ef8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们记录工作已经完成，同样，我们只需运行一个“echo”命令。</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="1cec" class="nq mo it mm b gy nr ns l nt nu">jobs:<br/>  release:<br/>    runs-on: ubuntu-20.04<br/>    steps:<br/>      - name: Checkout source code<br/>        uses: actions/checkout@v2<br/>      - name: Install the dependancies<br/>        run: npm ci<br/>      - name: End message<br/>        run: echo 'All done!'</span></pre><p id="c684" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从测试这个开始。为此，我们提交工作流文件并将其推送到主分支。</p><p id="e22a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您在访问存储库时看到的，有一个“Actions”选项卡。我们的工作流程现在就列在那里。在这里，我们可以手动触发工作流。为此，我们单击用户界面中的“运行工作流”按钮。</p><p id="bced" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当它完成运行时(或者甚至当它还在运行时！)，我们可以打开日志。我们可以看到不同的步骤在哪里，以及是否有任何错误。</p><h2 id="75b6" class="nq mo it bd mp nv nw dn mt nx ny dp mx lh nz oa mz ll ob oc nb lp od oe nd of bi translated">配置git和NPM</h2><p id="967a" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">下一步是完成工作流中git和npm的设置。为此，我们在列表中添加了另一个步骤，在checkout动作之后，我们声明了我们想要使用的git用户和电子邮件</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="65e7" class="nq mo it mm b gy nr ns l nt nu">- name: Initialize Git user<br/>        run: |<br/>            git config --global user.email "david@kodaps.com"<br/>            git config --global user.name "Release Workflow"</span></pre><p id="0a7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们需要能够在不登录的情况下发布到NPM，为此，我们需要一个“发布”令牌。</p><p id="8969" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了检索这个，我们需要前往NPM网站。登录后，我们需要选择访问令牌。然后回到GitHub，在存储库页面，我们点击设置，然后秘密&gt;行动。在这里，我们单击“New repository secret”并输入<code class="fe mj mk ml mm b">NPM_TOKEN</code>作为机密名称，然后粘贴令牌的值。</p><p id="bbb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们需要配置npm在与NPM注册中心对话时使用令牌。我们使用<code class="fe mj mk ml mm b">npm config set</code>命令，并传递刚刚生成的秘密<code class="fe mj mk ml mm b">NPM_TOKEN</code>/</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="df4a" class="nq mo it mm b gy nr ns l nt nu">- name: Initialise the NPM config<br/>        run: npm config set //registry.npmjs.org/:_authToken $NPM_TOKEN<br/>        env:<br/>          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}</span></pre><p id="ae54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，有一个问题。该命令在容器上创建一个<code class="fe mj mk ml mm b">.npmrc</code>文件。该文件将阻止发布，因为git目录将不再干净。</p><p id="ff5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，让我们将该文件添加到<code class="fe mj mk ml mm b">.gitignore</code>文件中:</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="71f9" class="nq mo it mm b gy nr ns l nt nu">#.gitignore<br/>node_modules/<br/>.env<br/>.npmrc</span></pre><h2 id="de89" class="nq mo it bd mp nv nw dn mt nx ny dp mx lh nz oa mz ll ob oc nb lp od oe nd of bi translated">现在发布</h2><p id="84da" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">现在，让我们使用release命令和<code class="fe mj mk ml mm b">--ci</code>标志(代表持续集成)，用发布包的命令替换最后的日志。</p><p id="e17a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还需要为动作提供两个令牌。第一个是GitHub令牌，默认情况下由操作提供。</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="4a7e" class="nq mo it mm b gy nr ns l nt nu">- name: Run release<br/>        run: npm run release --ci<br/>        env:<br/>          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}<br/>          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}</span></pre><p id="4544" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们最终的工作流现在看起来像这样</p><pre class="kj kk kl km gt nm mm nn no aw np bi"><span id="7b3b" class="nq mo it mm b gy nr ns l nt nu"><em class="mi"># .github/workflows/release.yml<br/></em>name: Release &amp; Publish to NPM<br/>on: workflow_dispatch<br/>jobs:<br/>  release:<br/>    runs-on: ubuntu-20.04<br/>    steps:<br/>    - name: Checkout source code<br/>      uses: actions/checkout@v2<br/>    - name: Install the dependancies<br/>      run: npm ci<br/>    - name: Initialise the NPM config<br/>      run: npm config set //registry.npmjs.org/:_authToken $NPM_TOKEN<br/>      env:<br/>        NPM_TOKEN: ${{ secrets.NPM_TOKEN }}<br/>    - name: Initialize Git user<br/>      run: |<br/>        git config --global user.email "david@kodaps.com"<br/>        git config --global user.name "Release Workflow"<br/>    - name: Log git status<br/>      run: git status<br/>    - name: Run release<br/>      run: npm run release --ci<br/>      env:<br/>        NPM_TOKEN: ${{ secrets.NPM_TOKEN }}<br/>        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</span></pre><h1 id="1663" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">最后</h1><p id="6c9f" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我发现<code class="fe mj mk ml mm b">release-it</code>和GitHub动作的结合非常强大。无论是在个人项目中还是在工作中，它们一起缓解了我反复出现的痛点。</p><p id="f7cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，我只将它应用于NPM模块和NextJS网站(虽然我也使用GitHub动作来自动更新我的个人资料)，但我期待着也使用它们来构建和发布移动应用程序。当然，您可以做很多有趣的事情，比如发送Slack或Discord通知，设置cron来触发API调用，等等。如果你想让我解释怎么做，请告诉我！</p><h1 id="4efb" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">更多资源:</h1><ul class=""><li id="8207" class="lu lv it la b lb nf le ng lh og ll oh lp oi lt lz ma mb mc bi translated"><a class="ae nk" href="https://docs.github.com/en/actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作文档</a></li><li id="b707" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><a class="ae nk" href="https://github.com/release-it/release-it" rel="noopener ugc nofollow" target="_blank">松开它</a></li></ul></div></div>    
</body>
</html>