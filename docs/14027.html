<html>
<head>
<title>Consistent Hashing Simply Explained — Problems solved in a distributed system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单解释了一致散列法——分布式系统中解决的问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/consistent-hashing-simply-explained-problems-solved-in-a-distributed-system-f20cdaa5befc?source=collection_archive---------15-----------------------#2022-10-25">https://levelup.gitconnected.com/consistent-hashing-simply-explained-problems-solved-in-a-distributed-system-f20cdaa5befc?source=collection_archive---------15-----------------------#2022-10-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e9d8c00e3b151103d6c3bf496c4e8ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0ZRnsOl5l0pBOv-Q.jpg"/></div></div></figure><p id="0b95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一致散列构成了许多分布式系统的核心。这是一种哈希技术，可以解决数据分布和位置问题，同时对系统的影响最小。在本文中，我将带您了解一致散列是如何工作的，以及我们如何在一致散列的帮助下构建一个分布式系统。</p><p id="818d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">出于本教程的目的，我们正在构建一个系统，其中每个用户的数据必须一起存储在一个分布式环境中。我们将使用用户名作为散列的密钥。</p><h1 id="b927" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">用于拆分数据的散列法</h1><p id="3c13" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">通常，在分布式系统中，数据分散在多个节点/服务器上。在上面的示例中，如果我们有两台服务器，我们希望50%的用户存储在第一个节点上，剩下的50%存储在另一个节点上。</p><h1 id="612a" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">我们如何实现这种分割？</h1><p id="c8be" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">一个非常简单的逻辑是使用用户名进行分割。A-M之间的所有用户名<strong class="kd iu">可以进入节点1，所有其他的可以进入节点2。类似地，如果我们有3个节点，那么我们的数据将使用用户名的第一个字符拆分到3个节点上。</strong></p><p id="8c91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能已经猜到了，这种方法存在一个问题。实际上，许多用户名可能以A、E、R开头，但没有一个以X、U等开头。在这种情况下，我们的数据可能不会均匀地分布在两台服务器上。所以，我们<strong class="kd iu">必须选择一种策略来帮助我们统一分配数据。</strong></p><p id="2467" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为上述挑战的解决方案，我们可以使用哈希算法，该算法通常对均匀随机分布进行哈希运算。我们首先将用户名映射到一个数字，然后使用这个数字作为哈希桶。这个数字一直保持不变。我们可以决定将数百万用户统一存储在任意大小的存储桶中。可以是100，1000，1M。那不重要。在特定桶中被散列的用户将总是被分配相同的桶号。因此，我们将数据存储在单一位置的要求得到了满足。下图显示了所有用户如何通过使用一个好的哈希函数，来确保分布是均匀的。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/f52d9c8b87f00390bc1d8d0ff236995e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WTFVLaiDVoBiHsna.jpg"/></div></div></figure><p id="7285" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们只有2台服务器，我们可以将散列从<code class="fe mh mi mj mk b">0-49</code>分配给服务器1，将<code class="fe mh mi mj mk b">50-99</code>分配给服务器2。通过这样做，我们可以确保我们的键均匀地分布在集群中的节点上。</p><h1 id="5e98" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">另一个问题</h1><p id="b2d7" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">尽管这种解决方案更好地解决了分发问题，但是这种方法还有另一个问题。</p><p id="0cfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们向双服务器集群添加新节点时，会发生什么情况。根据我们的散列策略，我们现在可以说服务器1保存散列值为0–33的密钥，服务器2保存散列值为34–67的节点，第三个服务器可以保存散列值为68–99的数据。请参考下图。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/e291a2403f671040eef157a4f7a165ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cAYZI71b7nmYNQB5.jpg"/></div></div></figure><p id="28c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种方法的问题是，每次在集群中添加或删除一个新节点时，散列必须在机器之间重新分布。想象一下，如果我们有20个节点，那么到处都会有数据的重新分布。</p><p id="1892" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当数据量巨大时，数据的网络和重新分发是一项昂贵的操作。如果我们能够以某种方式最小化节点间的哈希重分发，这个问题是可以避免的。这就是一致性哈希的用武之地。</p><h1 id="7ff2" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">一致散列法</h1><p id="435d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">一致散列是对我们以前的散列技术的改进。我们的目标是在服务器负载增加时减少数据的分发。同时为键提供散列，这样我们就能准确地知道从哪个节点查询数据。</p><p id="34e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一致散列的思想是，我们假设有一个虚拟的<code class="fe mh mi mj mk b">Space</code>，所有的键都映射到这个虚拟的<code class="fe mh mi mj mk b">Space</code>。想象我们有一个环状结构，它可以从<code class="fe mh mi mj mk b">0 to n-1</code>开始给<code class="fe mh mi mj mk b">hashing slots</code>编号。n是散列桶的数量。当我们用我们的散列算法散列密钥时，所有的密钥(在我们的例子中是用户id)将被放置在环上的某个点上。(如下图)</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/a6e8b88ec67ecd73dfec96c638a0642a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ilcj7jE_V18PizNz.jpg"/></div></div></figure><p id="f40b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上图中，我们决定拥有1024个存储桶。实际上，这可能是任何数字。因此，即使我们有数百万个键，它们也会均匀地分布在这1024个桶中。</p><p id="ef84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们希望确保在集群中的各种机器上分发数据，所以我们可以获取所有机器id，并在同一个环上对它们进行散列。让我们看看如果我们的集群中有四台机器会发生什么。我们将机器id /节点id视为同一个散列空间中的另一个id。这将确保机器id与目标密钥/用户id分布在同一个环上。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/f5353a9119649cc3d7eeb7ffaefcdb7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FKXMmmxWHtuWcULa.jpg"/></div></div></figure><p id="c94f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您注意到机器在环中的位置，您可以看到机器也获得了一个bucket，并且根据它们的机器id散列被放置在相同的环位置上。</p><p id="571e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一致散列的最后一部分是给机器分配密钥。请参考下图。为了简单起见，我们给我们的机器散列范围编号。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/015636efc0ebc4289d9b309cfd87d523.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q44QxlVn3Gro1CX3.jpg"/></div></div></figure><p id="d736" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如上图所示，我们将两个节点之间的所有存储桶分配给了下一个节点。因此，散列到桶的密钥将总是被放置到环上的下一台机器。在我们的例子中，我们看到M2处理在<code class="fe mh mi mj mk b">901-1023</code>和<code class="fe mh mi mj mk b">0-200</code>之间散列的请求，M3处理在<code class="fe mh mi mj mk b">201-500</code>之间散列的键，等等。</p><h1 id="3f1f" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">添加或删除节点。</h1><p id="a9ea" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">因为机器和密钥共享相同的散列空间，所以我们可以很容易地在我们的环中添加或删除一个节点。让我们向我们的节点添加一台新机器m5，并将其放在m1和m2之间。注意当我们执行这个操作时，我们的数据分布发生了什么变化。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mp"><img src="../Images/27da93000701a98107c9d7f4d45f0e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wsZ_W1LBO8UNGGv_.jpg"/></div></div></figure><p id="edb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以前，M2处理的是<code class="fe mh mi mj mk b">901-1023</code>和<code class="fe mh mi mj mk b">0-200</code>之间的散列。这是因为在我们的算法中，所有散列都由下一个可用节点提供服务。现在，当我们向集群添加另一个节点时，我们将它放在hash 0处。在这种情况下，会发生两种变化。</p><ol class=""><li id="ee2e" class="mq mr it kd b ke kf ki kj km ms kq mt ku mu ky mv mw mx my bi translated">M2现在将提供0-200之间的范围。</li><li id="e937" class="mq mr it kd b ke mz ki na km nb kq nc ku nd ky mv mw mx my bi translated">M5将负责900-1023之间的服务范围。</li></ol><p id="2ab7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，其他机器都不会因此受到影响。任何其他节点之间没有数据移动。这就是一致性散列的美妙之处。该算法确保数据移动和数据分发最小化。</p><p id="96b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当机器5负责901–1023时，它可以查询M2，请求从M2转移这些散列。在这种情况下，这是唯一可能发生的数据移动。</p><p id="33a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一致散列是一种很好的技术，可以在系统中添加或删除节点时分发数据并最小化数据移动。还有一个问题我们在这篇文章中没有提到，但是我们目前的设计可能会导致一些机器比另一些机器负载更大。我们将在另一篇文章中讨论这个问题。</p><p id="4f6f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了理解分布式系统，一致散列是理解如何均匀分布数据的一种非常好的方式。从概念上理解有多少系统可能在做这件事。</p><p id="1bf7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章能帮助你理解这项技术的一些基础知识，并让你了解现实世界的系统是如何实现它的。</p><blockquote class="ne nf ng"><p id="8244" class="kb kc nh kd b ke kf kg kh ki kj kk kl ni kn ko kp nj kr ks kt nk kv kw kx ky im bi translated"><strong class="kd iu">敬请关注，更多内容请关注我！</strong></p></blockquote></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="126c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nh">原载于2022年10月25日</em><a class="ae ns" href="https://shanmukhsista.com/posts/technology/system-design/consistent-hashing-explained-problems-solved-in-a-distributed-system-network/" rel="noopener ugc nofollow" target="_blank"><em class="nh">https://shanmukhsista.com</em></a><em class="nh">。</em></p></div></div>    
</body>
</html>