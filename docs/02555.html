<html>
<head>
<title>Using the jsonwebtoken Node Package to Create JSON Web Tokens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用jsonwebtoken节点包创建JSON Web令牌</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-the-jsonwebtoken-node-package-to-create-json-web-tokens-e7941ff66e4e?source=collection_archive---------9-----------------------#2020-03-21">https://levelup.gitconnected.com/using-the-jsonwebtoken-node-package-to-create-json-web-tokens-e7941ff66e4e?source=collection_archive---------9-----------------------#2020-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d92e898195672232e25555d437cebe40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hcfVv1UvoofAS4Cf"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@eprouzet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Eric Prouzet </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c7e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着单页面应用程序和纯API后端的使用，JSON web token(jwt)已经成为向我们的应用程序添加身份验证功能的一种流行方式。</p><p id="20e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何使用<code class="fe le lf lg lh b">jsonwebtoken</code>包来创建JSON web令牌。</p><h1 id="cbc9" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">装置</h1><p id="b643" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">jsonwebtoken</code>是节点包。我们可以通过运行以下命令来安装它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="657b" class="mt lj it lh b gy mu mv l mw mx">npm install jsonwebtoken</span></pre><h1 id="1cf9" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用</h1><p id="c35c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">sign</code>方法创建一个新的JSON web令牌。可以按以下格式调用:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="44d8" class="mt lj it lh b gy mu mv l mw mx">jwt.sign(payload, secretOrPrivateKey, [options, callback])</span></pre><p id="01f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">payload</code>是我们希望在令牌中保存的任何数据。</p><p id="df68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">secretOrPrivateKey</code>是我们用来签署令牌的秘密密钥。它是一个字符串、bugger或对象，包含HMAC算法的秘密或ESA和ECDSA的PEM编码私钥。</p><p id="e756" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果是带有密码短语的私钥，则可以使用对象。在这种情况下，我们必须在<code class="fe le lf lg lh b">options</code>对象中设置<code class="fe le lf lg lh b">algorithm</code>属性。</p><p id="5c4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">options</code>是一个接受多种选项的对象。可以设置以下选项:</p><ul class=""><li id="eeb9" class="my mz it ki b kj kk kn ko kr na kv nb kz nc ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">algorithm</code> —默认为<code class="fe le lf lg lh b">HS256</code></li><li id="a781" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">expiresIn</code> —到期前的秒数或时间跨度类似<code class="fe le lf lg lh b">'2 days'</code>的字符串或任何可被<a class="ae kf" href="https://github.com/zeit/ms" rel="noopener ugc nofollow" target="_blank"> zeit/ms </a>接受的内容。</li><li id="0f61" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">notBefore</code> —用<a class="ae kf" href="https://github.com/zeit/ms" rel="noopener ugc nofollow" target="_blank"> zeit/ms </a>描述可接受的时间跨度的秒数或字符串。确定开始接受JWT进行处理的时间</li><li id="f77c" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">audience</code> —标识JWT的目标收件人</li><li id="0e09" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">issuer</code> —标识发布JWT的主体</li><li id="7c43" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">jwtid</code> —令牌区分大小写的唯一标识符，即使在不同的发行者之间也是如此</li><li id="0b21" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">subject</code>—JWT的主题</li><li id="5fc5" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">noTimestamp</code> —如果是<code class="fe le lf lg lh b">true</code>，则<code class="fe le lf lg lh b">iat</code>字段不会包含在JWT中</li><li id="172a" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">header</code> —用对象设置JWT的页眉</li><li id="b19f" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">mutatePayload</code>—<code class="fe le lf lg lh b">sign</code>函数将直接修改有效载荷对象，如果<code class="fe le lf lg lh b">true</code>。</li></ul><p id="bc3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">callback</code>是一个可选的回调函数，当这个方法被异步调用时，它会获取令牌或任何错误。</p><h1 id="a59b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">例子</h1><p id="f530" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以如下使用它来与默认的HMAC SHA256算法同步签发令牌:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="26fe" class="mt lj it lh b gy mu mv l mw mx">const express = require('express');<br/>const jwt = require('jsonwebtoken');<br/>const app = express();</span><span id="426d" class="mt lj it lh b gy nm mv l mw mx">app.post('/auth', (req, res) =&gt; {<br/>  const token = jwt.sign({ foo: 'bar' }, 'secret');<br/>  res.send(token);<br/>})</span><span id="2e2d" class="mt lj it lh b gy nm mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="d34e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们创建了一个<code class="fe le lf lg lh b">auth</code>端点，它通过使用<code class="fe le lf lg lh b">sign</code>方法同步发布一个令牌，带有有效负载和秘密，但没有回调。</p><p id="1a68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了与RSA SHA256算法一起使用，我们从文件中读取私钥，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="298e" class="mt lj it lh b gy mu mv l mw mx">const express = require('express');<br/>const jwt = require('jsonwebtoken');<br/>const fs = require('fs');<br/>const app = express();</span><span id="4496" class="mt lj it lh b gy nm mv l mw mx">app.post('/auth', (req, res) =&gt; {<br/>  const privateKey = fs.readFileSync('private.key');<br/>  const token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' });<br/>  res.send(token);<br/>})</span><span id="6e65" class="mt lj it lh b gy nm mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="db8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用<code class="fe le lf lg lh b">readFileSync</code>读取私钥，然后将它传递给第二个参数，而不是秘密。</p><p id="13a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在线或使用OpenSSL程序生成一个RSA private。</p><p id="11ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要异步创建令牌，我们可以编写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="55bf" class="mt lj it lh b gy mu mv l mw mx">const express = require('express');<br/>const jwt = require('jsonwebtoken');<br/>const fs = require('fs');<br/>const app = express();</span><span id="0e03" class="mt lj it lh b gy nm mv l mw mx">app.post('/auth', (req, res) =&gt; {<br/>  const privateKey = fs.readFileSync('private.key');<br/>  jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' },  (err, token) =&gt; {<br/>    res.send(token);<br/>  });</span><span id="9093" class="mt lj it lh b gy nm mv l mw mx">})</span><span id="2e28" class="mt lj it lh b gy nm mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="69e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个例子和上一个例子的唯一区别是我们传入了一个回调函数，而不是直接获取返回的令牌。</p><p id="bdec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过更改<code class="fe le lf lg lh b">iat</code>时间戳来回溯，即发布日期:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="37ae" class="mt lj it lh b gy mu mv l mw mx">const express = require('express');<br/>const jwt = require('jsonwebtoken');<br/>const app = express();</span><span id="fe07" class="mt lj it lh b gy nm mv l mw mx">app.post('/auth', (req, res) =&gt; {<br/>  const token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'secret');<br/>  res.send(token);<br/>})</span><span id="e38f" class="mt lj it lh b gy nm mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="458b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们将令牌回溯30秒，因为我们将<code class="fe le lf lg lh b">iat</code>设置为<code class="fe le lf lg lh b">Math.floor(Date.now() / 1000) — 30</code>。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/528d31123ca4086aa9abe0415ea71f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y-9tEjfPcplHZigl"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="55db" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">令牌过期(过期声明)</h1><p id="4e2e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们还可以通过如下设置<code class="fe le lf lg lh b">exp</code>字段来更改令牌到期时间:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="db25" class="mt lj it lh b gy mu mv l mw mx">const express = require('express');<br/>const jwt = require('jsonwebtoken');<br/>const app = express();</span><span id="f29e" class="mt lj it lh b gy nm mv l mw mx">app.post('/auth', (req, res) =&gt; {<br/>  const token = jwt.sign({<br/>    exp: Math.floor(Date.now() / 1000) + (2 * 60 * 60),<br/>    data: 'foobar'<br/>  }, 'secret');<br/>  res.send(token);<br/>})</span><span id="3aa0" class="mt lj it lh b gy nm mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="89dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们得到一个令牌，它在发布后2小时过期，因为我们将<code class="fe le lf lg lh b">Math.floor(Date.now() / 1000) + (2 * 60 * 60)</code>作为<code class="fe le lf lg lh b">exp</code>值。</p><p id="40db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一种更简单的方法是这样写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2771" class="mt lj it lh b gy mu mv l mw mx">const express = require('express');<br/>const jwt = require('jsonwebtoken');<br/>const app = express();</span><span id="502d" class="mt lj it lh b gy nm mv l mw mx">app.post('/auth', (req, res) =&gt; {<br/>  const token = jwt.sign({<br/>    data: 'foobar'<br/>  }, 'secret', { expiresIn: 2 * 60 * 60 });<br/>  res.send(token);<br/>})</span><span id="ca88" class="mt lj it lh b gy nm mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="d4bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7a3b" class="mt lj it lh b gy mu mv l mw mx">const express = require('express');<br/>const jwt = require('jsonwebtoken');<br/>const app = express();</span><span id="7787" class="mt lj it lh b gy nm mv l mw mx">app.post('/auth', (req, res) =&gt; {<br/>  const token = jwt.sign({<br/>    data: 'foobar'<br/>  }, 'secret', { expiresIn: '2h' });<br/>  res.send(token);<br/>})</span><span id="11af" class="mt lj it lh b gy nm mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><h1 id="afef" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="6011" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">sign</code>方法创建一个JSON web令牌。它采用各种选项，如受众、发行者、到期日、ID、加密算法、使令牌仅在一段时间后可用等。</p><p id="7edc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它支持HMAC和RSA算法来存储秘密，或者我们可以创建自己的秘密字符串来签署我们的JWT。</p></div></div>    
</body>
</html>