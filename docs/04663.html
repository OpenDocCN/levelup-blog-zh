<html>
<head>
<title>Cheapskate’s Journey to On-Demand Load Tests with Locust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">小气鬼用Locust实现按需负载测试之旅</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cheapskates-journey-to-on-demand-load-tests-with-locust-ffe730426ad8?source=collection_archive---------12-----------------------#2020-07-08">https://levelup.gitconnected.com/cheapskates-journey-to-on-demand-load-tests-with-locust-ffe730426ad8?source=collection_archive---------12-----------------------#2020-07-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/80b7e1ab85936bfc6fc42cb74f34e7f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZbrRNf3ZUari_dZ5NuYctA.png"/></div></div></figure><div class=""/><p id="116e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想充分利用我花在云上的每一分钱。我在Heroku上运行了一些web应用程序，并且像其他人一样，在非生产环境中对每个版本增量运行了一套冒烟测试和负载测试。负载测试很重要:它们不仅帮助我们理解我们系统的局限性，而且还提出了由于并发性而产生的问题，这些问题通常会避开单元测试和集成测试的领域。但是因为我们经常运行测试，所以我们不想每次运行测试都要花很多钱。</p><p id="7e34" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将向您展示如何建立经济高效的负载测试。我们将使用Locust来增强测试的健壮性，并使用Heroku来简化测试的运行，并降低成本。我还将展示如何使用VS代码和Docker进行开发，而无需在系统上安装dev依赖项。</p><h1 id="bf96" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">蝗虫是什么？</h1><p id="d5f7" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><a class="ae kz" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank"> Locust </a>是用Python编写的开源负载测试工具。蝗虫测试可以分布在多台机器上，同时模拟数百万用户，帮助确定您的站点或系统可以处理多少用户。</p><p id="0542" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建Locust是为了解决其他两个领先解决方案存在的问题— <a class="ae kz" href="https://jmeter.apache.org/" rel="noopener ugc nofollow" target="_blank"> JMeter </a>和<a class="ae kz" href="http://tsung.erlang-projects.org/" rel="noopener ugc nofollow" target="_blank"> Tsung </a>。具体来说，它旨在解决以下限制:</p><ul class=""><li id="17e9" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">并发性:JMeter是线程绑定的，为每个用户创建一个新线程。这严重限制了每台机器可以模拟的用户数量。另一方面，Locust是基于事件的，可以在一个进程上模拟成千上万的用户。</li><li id="82fb" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">易于编码:JMeter需要复杂的回调。Tsung使用基于XML的DSL来定义用户行为。两者都很难编码。另一方面，蝗虫场景是用普通Python编写的，很容易编码。</li></ul><h1 id="3534" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">术语</h1><p id="0cab" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">首先，一点术语。使用Locust，您可以在一组Locust file中编写用户行为测试，然后在目标应用程序上并发执行Locust file。就蝗虫而言，一群蝗虫用户(统称为虫群，单独称为蝗虫)将攻击目标应用程序并记录结果。每个蝗虫在它的沙盒进程中执行，这个沙盒进程叫做Greenlet。</p><h1 id="b216" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">考虑</h1><p id="0512" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在继续之前，我建议您阅读Heroku 关于负载测试的<a class="ae kz" href="https://devcenter.heroku.com/articles/load-testing-guidelines" rel="noopener ugc nofollow" target="_blank">指南，其中列出了适用的限制和后果。本文中的指导仅限于执行低级到中级测试(每秒少于10，000个请求)。对于执行大规模测试，您应该首先联系Heroku支持人员，以确保您的系统已经预热并且可以适当扩展，或者使用私有空间来托管您的测试平台(测试中的应用程序和测试平台)。对于高容量负载测试，我建议在</a><a class="ae kz" href="https://github.com/sho7650/heroku-locust" rel="noopener ugc nofollow" target="_blank">这个样例应用程序存储库</a>上建模您的测试设置。要了解最新的定价细节和估算在Heroku上运行您的应用程序的成本，请访问<a class="ae kz" href="https://www.heroku.com/pricing" rel="noopener ugc nofollow" target="_blank"> Heroku网站</a>。</p><h1 id="7fef" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">先决条件</h1><p id="217b" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">下面是我用来构建示例应用程序的工具和云服务列表。我的开发机器运行的是Windows 10 Professional，不过，以下工具也可以在Mac上使用。</p><ul class=""><li id="7da7" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">带有<a class="ae kz" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack" rel="noopener ugc nofollow" target="_blank">远程开发</a>扩展的VS代码</li><li id="30ae" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><a class="ae kz" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank">Heroku帐户</a>，您可以在其中创建标准层的应用</li><li id="b669" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">免费的微软Azure订阅服务</li><li id="1b2a" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><a class="ae kz" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank">适用于Windows(或Mac)的Docker桌面</a></li><li id="9750" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">Heroku CLI </li><li id="e987" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><a class="ae kz" href="https://docs.microsoft.com/en-us/azure/storage/common/storage-use-azcopy-v10" rel="noopener ugc nofollow" target="_blank"> Azcopy </a></li></ul><h1 id="620b" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">应用程序</h1><p id="d708" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我为这个演示准备的示例应用程序，我们称之为<em class="mr">目标API应用程序</em>，是一个用Go编写的REST API。我们还有第二个应用程序，我们称之为<em class="mr">负载测试应用程序</em>，它包含使用<a class="ae kz" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank"> Locust </a>用Python编写的负载测试。</p><ul class=""><li id="5212" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">目标API应用程序是我们打算测试的REST API。因为需要API来处理HTTP请求，所以我们将它托管在web dynos上。</li><li id="c4e0" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><em class="mr">负载测试应用程序</em>包含我们的<em class="mr">蝗虫测试</em>。根据<em class="mr">目标API应用</em>支持的用户类型，这些被分为两类。您可以并行或顺序执行这两个测试套件，从而改变您在<em class="mr">目标API应用程序</em>上应用的负载的数量和性质。因为执行测试的dyno只在测试执行期间需要，所以我们在Heroku的<a class="ae kz" href="https://devcenter.heroku.com/articles/one-off-dynos" rel="noopener ugc nofollow" target="_blank">一次性dyno</a>中托管它们。一次性dynos只对它们消耗的时间和资源计费，管理员可以使用<a class="ae kz" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"> Heroku CLI </a>工具生成它们。</li></ul><p id="59e8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是应用程序及其组件的高级设计图。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/f317a7ffc59446d5c6c4a30d429b8b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XpVkjRw67deVLbxf.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">高层设计图</strong></figcaption></figure><p id="ccfb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Heroku为在dyno上执行的应用程序进程提供临时存储，它可能存在，也可能不存在。此外，由于存储是进程的本地存储，我们无法访问Heroku CLI生成的任何文件，因为它在dyno上创建了另一个具有自己存储的沙盒进程。由于访问限制，生成文件的过程会将它们导出到持久的云存储服务，或者在web dynos的情况下，通过HTTP端点使它们可用。通过使用标志(–csv)执行locust，您可以指示Locust将测试结果保存在本地的CSV文件中。我们使用<a class="ae kz" href="https://docs.microsoft.com/en-us/azure/storage/common/storage-use-azcopy-v10" rel="noopener ugc nofollow" target="_blank"> Azcopy </a>，这是一个CLI工具，用于将二进制数据复制到Azure存储中或从Azure存储中复制出来，以将蝗虫测试生成的结果导出到Azure blob存储中。</p><h1 id="eb26" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置应用程序</h1><p id="a388" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">应用程序的源代码可以在我的<a class="ae kz" href="https://github.com/rahulrai-in/locust-load-test-heroku" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p><h1 id="ac73" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">目标API应用程序</h1><p id="c082" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">让我们首先剖析目标API应用程序，我们希望用我们的负载测试套件来测试它。在VS代码中打开名为<em class="mr"> api </em>的文件夹。在文件<em class="mr"> main.go </em>中，我定义了三个API端点:</p><pre class="mt mu mv mw gt nb nc nd ne aw nf bi"><span id="728c" class="ng lb je nc b gy nh ni l nj nk">http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {<br/>     fmt.Println("Served home request")<br/>     fmt.Fprintf(w, "Server OK")<br/>})</span><span id="080a" class="ng lb je nc b gy nl ni l nj nk">http.HandleFunc("/volatile", func(w http.ResponseWriter, r *http.Request) {<br/>     // For every 10 requests, delay the response by 1 second, up to 5 seconds.<br/>     currentCount := atomic.LoadInt32(&amp;requestCount)<br/>     atomic.AddInt32(&amp;requestCount, 1)<br/>     delay := currentCount / 10<br/>     if delay &gt; 5 {<br/>         atomic.StoreInt32(&amp;requestCount, 0)<br/>         delay = 5<br/>     }</span><span id="5f16" class="ng lb je nc b gy nl ni l nj nk">     time.Sleep(time.Duration(delay) * time.Second)<br/>     fmt.Fprintf(w, "Produced response after %d second/s", delay)<br/>     fmt.Printf("Produced response after %d second/s \n", delay)<br/>})</span><span id="010c" class="ng lb je nc b gy nl ni l nj nk">http.HandleFunc("/buggy", func(w http.ResponseWriter, r *http.Request) {<br/>     // After every 5 requests, throw error<br/>     currentCount := atomic.LoadInt32(&amp;requestCount)<br/>     atomic.AddInt32(&amp;requestCount, 1)<br/>     if currentCount%5 == 0 {<br/>         fmt.Printf("Returning error at %d request \n", currentCount)<br/>         http.Error(w, http.StatusText(500), 500)<br/>         return<br/>     }</span><span id="25e4" class="ng lb je nc b gy nl ni l nj nk">     fmt.Fprintf(w, "Ok for request %d", currentCount)<br/>})</span></pre><p id="f4c4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">三个端点的行为如下:</p><ul class=""><li id="02ed" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">"/":返回带有文本OK的HTTP 200响应。</li><li id="5799" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">"/ <em class="mr"> volatile </em>":返回HTTP 200响应，但每10个请求就会延迟一秒钟。</li><li id="82f0" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">"/ <em class="mr"> buggy </em>":每五个请求返回一个HTTP 500错误消息。</li></ul><h1 id="ecb9" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">用于调试的远程开发扩展</h1><p id="8ee8" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">您可能已经注意到，我没有提到安装Golang或Python是这个应用程序的先决条件。我们将使用您安装到VS代码中的<em class="mr">远程开发</em>扩展来调试目标API应用程序。你可以在这里阅读<a class="ae kz" href="https://code.visualstudio.com/docs/remote/remote-overview" rel="noopener ugc nofollow" target="_blank">的细节。然而，简而言之，这个扩展允许您使用容器作为开发环境。该扩展搜索名为<em class="mr">的文件夹。并使用<em class="mr"> Dockerfile </em>(容器定义)和<em class="mr"> devcontainer.json </em>(用于容器设置)文件来创建一个新的容器，并将包含您的代码的文件夹作为一个卷挂载到容器中。对于调试，扩展将VS代码调试器附加到容器中运行的进程。我已经为你配置好了容器资源，你只需要按F1键调出命令窗口，选择命令:<em class="mr"> Remote-Containers:打开容器中的文件夹</em>。</em></a></p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/892c1da2cbaf8fbbe0bb73013ee265c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cgT1Z3yQkaZXQpXM.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">打开容器中的文件夹</strong></figcaption></figure><p id="a466" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当询问打开哪个文件夹时，选择“api”文件夹并继续。</p><p id="bd52" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者，您可以通过单击VS代码窗口左下角的绿色图标来生成命令对话框。</p><p id="8fde" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">容器准备就绪后，按F5开始调试应用程序。您会注意到VS代码窗口左下角的文本变成了<em class="mr"> Dev Container </em> : Go表示应用程序当前正在远程容器中执行。现在，您可以通过导航到<a class="ae kz" href="http://localhost:9000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:9000 </a>从浏览器访问应用程序端点。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/553b8851ce5873805c24b59fe1340b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U1bLF2GeVB7Lx2Eq.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">在远程容器中执行应用</strong></figcaption></figure><h1 id="402c" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">负载测试应用程序</h1><p id="8f70" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在，我们将使用VS代码在一个容器中构建测试套件，并创建一个shell脚本来自动化测试基础设施的设置和拆除过程。您可以使用这个脚本来自动启动和关闭测试网格，并将其添加到您的CI\CD管道中。</p><h2 id="daf1" class="ng lb je bd lc nm nn dn lg no np dp lk km nq nr lo kq ns nt ls ku nu nv lw nw bi translated">1.启动负载测试应用程序开发容器</h2><p id="5eeb" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在另一个VS代码实例中，打开文件夹loadtest并在dev容器中启动它。在这个应用程序中，您会注意到我创建了两组测试来模拟目标API应用程序的两种用户类型的行为。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/0424cd7709f9aef3a4fbff16f580ad99.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*7Q6LDIJMrEFWBKed.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">测试用locust files</strong></figcaption></figure><ul class=""><li id="2689" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">类型为<em class="mr"> ApiUser </em>的用户行为记录在locustfile_scene_1.py中，根据测试，ApiUser类型的用户在两次调用之间等待五到九秒后访问目标API应用程序的默认和易变端点。</li><li id="b34e" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">类型为<em class="mr"> AdminUser </em>的用户行为记录在locustfile_scene_2.py中。这类用户在两次调用之间等待5到15秒后访问目标API应用程序的默认端点和错误端点。</li></ul><h2 id="a92d" class="ng lb je bd lc nm nn dn lg no np dp lk km nq nr lo kq ns nt ls ku nu nv lw nw bi translated">2.验证测试</h2><p id="74db" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了验证测试脚本，在集成终端中执行以下命令(<em class="mr"> Ctrl + ~ </em>)。</p><p id="2c97" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ny nz oa nc b">$ locust -f locustfile_scene_1.py</code></p><p id="655f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">导航到<a class="ae kz" href="http://localhost:8089/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8089 </a>调出locust UI。在表单中，输入目标API应用程序的主机名和端口以及所需的蝗虫群配置，然后单击按钮<em class="mr">开始群集</em>以启动测试。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/12d69ab7f0832052cc0dfbe96ad08515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/0*LaVtYwN_qWMGNrTb.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">蝗虫UI </strong></figcaption></figure><h2 id="41bf" class="ng lb je bd lc nm nn dn lg no np dp lk km nq nr lo kq ns nt ls ku nu nv lw nw bi translated">3.运行Shell脚本</h2><p id="06d8" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了执行蝗虫测试，我们需要为每组测试定义一个小的工作流，如下所示。</p><ul class=""><li id="f207" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">在没有web UI的情况下，在单个worker节点上执行测试一段固定的时间，并生成测试结果的CSV报告。</li><li id="02ef" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">使用Azcopy将测试结果文件复制到Azure存储。(当然，您可以将这部分替换为您可能使用的任何云存储提供商。您只需要修改下面的脚本来使用不同的实用程序而不是azcopy，并且您将复制到不同的存储位置。)</li></ul><p id="e838" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">负载测试项目中的<em class="mr"> run.sh </em>脚本实现了如下工作流:</p><pre class="mt mu mv mw gt nb nc nd ne aw nf bi"><span id="7495" class="ng lb je nc b gy nh ni l nj nk">#!/bin/bash</span><span id="6db0" class="ng lb je nc b gy nl ni l nj nk">locust -f $1 --headless -u 200 -r 10 --host=$TARGET_HOST --csv="$2_$(date +%F_%T)" --run-time 1h -t 2s --stop-timeout 60</span><span id="dcfa" class="ng lb je nc b gy nl ni l nj nk">for filename in *.csv; do<br/>    [ -e "$filename" ] || continue<br/>    azcopy copy "$filename" "https://locustloadtest.blob.core.windows.net/testresult/$filename\$SAS_TOKEN"<br/>done</span><span id="cd35" class="ng lb je nc b gy nl ni l nj nk">exit 0</span></pre><p id="aa1e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在前面的代码清单中，在执行产生CSV结果的<em class="mr"> locust </em>命令后，我们遍历CSV文件并使用Azcopy实用程序将每个文件上传到Azure存储位置——在<em class="mr">locustloadtest.blob.core.windows.net</em>帐户中名为<em class="mr"> testresult </em>的容器。您必须使用您在Azure订阅中创建的存储帐户来更改这些值。您可以看到，这个命令依赖于一个共享访问秘密(SAS)令牌进行身份验证，我们通过一个名为SAS_TOKEN的环境变量应用了这个令牌。稍后我们将把这个环境变量添加到应用程序中。如果您不熟悉Azcopy实用程序，请在这里阅读更多关于使用带有SAS令牌的<a class="ae kz" href="https://docs.microsoft.com/en-us/azure/storage/common/storage-use-azcopy-blobs" rel="noopener ugc nofollow" target="_blank"> Azcopy的信息。</a></p><h1 id="084e" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">启动目标API应用程序并创建Web Dyno</h1><p id="22f3" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在每个项目、API和Loadtest的根目录中，您会发现一个名为<em class="mr"> Procfile </em>的文件。</p><p id="53ef" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在API Procfile中，以下命令将指示Heroku创建一个web dyno，并调用命令<em class="mr"> locust-loadtest </em>来启动应用程序。</p><p id="49be" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ny nz oa nc b">web: locust-loadtest</code></p><p id="fc43" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Loadtest项目中，Locust测试的Procfile指示Heroku创建两个worker dynos，并使用适当的参数调用Run.sh脚本，如下所示:</p><p id="7579" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ny nz oa nc b">worker_scene_1: bash ./run.sh locustfile_scene_1.py scene_1</code><br/>T1】</p><h1 id="a22b" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">在Heroku中创建应用程序</h1><p id="f9b1" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们现在将在Heroku中创建两个必需的应用程序。</p><p id="38e3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以通过两种方式与Heroku交互:用户界面和Heroku CLI。我将指导您混合使用这两种方法，以便您对这两种方法都有一些经验。</p><p id="c1f1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了创建应用程序，我们将使用Heroku用户界面。我们将首先创建目标API应用程序。</p><h2 id="d769" class="ng lb je bd lc nm nn dn lg no np dp lk km nq nr lo kq ns nt ls ku nu nv lw nw bi translated">创建目标API应用程序</h2><p id="0c63" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在浏览器中，导航至<a class="ae kz" href="https://dashboard.heroku.com/" rel="noopener ugc nofollow" target="_blank">https://dashboard.heroku.com/</a>，点击<em class="mr">新建/创建新应用</em>按钮。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/3004601ab8be318a6f20a22f40138cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/0*Xrm6fjHHuf2bPXiN.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">创建新的Heroku App </strong></figcaption></figure><p id="4bab" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在创建应用程序页面上，输入应用程序的名称(locust-heroku-target)，选择<em class="mr">公共运行时</em>选项，以及所需的区域。请注意，应用程序名称在所有Heroku应用程序中必须是唯一的，因此此名称<em class="mr">可能不可用。您可以为这个应用程序(以及下面的测试引擎应用程序)选择自己唯一的名称，确保在所有后续代码和命令中引用这些新名称。如果您的客户分布在多个地区，您可以在不同的位置创建一个额外的测试平台，并从该位置测试您的应用程序的性能。点击<em class="mr">创建应用</em>按钮创建应用。</em></p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/7d4c99a8c8a2b4cb368bd477574b7bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cwVU98Sgrm00G_3Q.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">创建蝗虫-英雄-目标</strong></figcaption></figure><p id="fdc5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一个屏幕要求您指定部署方法。因为我已经在使用GitHub进行源代码控制，所以我可以指示Heroku在我对<em class="mr">主</em>分支进行更改时自动部署。我建议您不要在实际应用中遵循相同的方案。您应该从<em class="mr">主</em>分支部署到生产，并使用另一个分支，例如发布分支，来部署到测试环境(Git流)，或者在批准后从主分支部署(GitHub流)。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/74bc694b8bc1ac7b761363e6d495d25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hpdnVeCk8pNpsnAW.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">将应用程序链接到GitHub-locust-heroku-target</strong></figcaption></figure><h1 id="1446" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建负载测试应用程序</h1><p id="8ef4" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在让我们为我们的蝗虫测试设置Loadtest应用程序。您可以为测试创建另一个应用程序(rocast-heroku-test engine ),如下所示:</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/02f975d13f9ea59ac8eaa0c5ba9b1c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FaXYytmO5J9QFeQb.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">创造蝗虫-heroku-testengine </strong></figcaption></figure><p id="63ea" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能已经注意到，我使用了<a class="ae kz" href="https://en.wikipedia.org/wiki/Monorepo" rel="noopener ugc nofollow" target="_blank"> monorepo </a>模型将目标API应用程序和测试放在同一个项目中。</p><p id="e567" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在下一个屏幕上，将您刚刚创建的应用程序的部署连接到同一个存储库。通过这种设置，每当您对Loadtest或目标API应用程序进行更改时，两者都将被部署到Heroku，这有助于避免Loadtest和目标API应用程序版本之间的任何冲突。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/9fe6acc3c468bc3dff6365001706c62a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UVTnCkchxQnALG5M.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">将App链接到GitHub—locust-heroku-test engine</strong></figcaption></figure><p id="1fd2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，这个应用程序的worker dynos将使用标准的-1x dynos，对于我们的场景来说，这是成本和性能的一个很好的平衡。但是，您可以使用Heroku CLI或通过UI根据您的需求更改dyno类型。请参考<a class="ae kz" href="https://devcenter.heroku.com/articles/dyno-types" rel="noopener ugc nofollow" target="_blank"> Heroku文档</a>了解CLI命令和您可以使用的dynos类型。</p><h1 id="8921" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">通过Heroku CLI添加构建包</h1><p id="5079" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在让我们切换到终端，并使用Heroku CLI准备环境。我们将检查我们的服务需要的构建包，并一次添加一个。</p><h2 id="2636" class="ng lb je bd lc nm nn dn lg no np dp lk km nq nr lo kq ns nt ls ku nu nv lw nw bi translated">构建包如何工作</h2><p id="fdab" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">heroku<a class="ae kz" href="https://devcenter.heroku.com/articles/buildpacks" rel="noopener ugc nofollow" target="_blank">build pack</a>负责将你的代码转换成“slug”用Heroku的话来说，slug是应用程序的可部署副本。不是每个构建包都必须从您的应用程序代码生成二进制文件——构建包可以链接在一起，这样每个构建包都以某种方式转换应用程序代码，并将其提供给链中的下一个构建包。然而，在处理之后，dyno管理器必须接收一个slug作为输出。</p><p id="a0af" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，由于我们的源代码被组织为由目标API应用程序和Loadtest应用程序组成的monorepo，因此buildpack链中的第一个buildpack，<a class="ae kz" href="https://thecloudblog.net/post/cheapskates-journey-to-on-demand-load-tests-on-heroku-with-locust/" rel="noopener ugc nofollow" target="_blank">heroku-build pack-monorepo</a>，从mono repo中提取应用程序。链中的第二个构建包构建适当的应用程序。</p><h2 id="2a08" class="ng lb je bd lc nm nn dn lg no np dp lk km nq nr lo kq ns nt ls ku nu nv lw nw bi translated">目标API构建包</h2><p id="0fdc" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">让我们首先考虑目标API应用程序。使用<a class="ae kz" href="https://github.com/lstoll/heroku-buildpack-monorepo" rel="noopener ugc nofollow" target="_blank">heroku-build pack-monorepo</a>从mono repo中提取locust-heroku-target应用程序。下一个构建包，<a class="ae kz" href="https://github.com/heroku/heroku-buildpack-go" rel="noopener ugc nofollow" target="_blank"> heroku-buildpack-go </a>，构建目标API项目。</p><p id="e9ca" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">按照正确的顺序执行以下命令，以保持它们的执行顺序，并记住将命令中的应用程序名称更改为您之前在Heroku用户界面中指定的名称。</p><pre class="mt mu mv mw gt nb nc nd ne aw nf bi"><span id="b9a9" class="ng lb je nc b gy nh ni l nj nk">$ heroku buildpacks:add -a locust-heroku-target https://github.com/lstoll/heroku-buildpack-monorepo</span><span id="3f0b" class="ng lb je nc b gy nl ni l nj nk">$ heroku buildpacks:add -a locust-heroku-target <a class="ae kz" href="https://github.com/heroku/heroku-buildpack-go" rel="noopener ugc nofollow" target="_blank">https://github.com/heroku/heroku-buildpack-go</a></span></pre><h2 id="369e" class="ng lb je bd lc nm nn dn lg no np dp lk km nq nr lo kq ns nt ls ku nu nv lw nw bi translated">负载测试构建包</h2><p id="34fc" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">对于locust-heroku-testengine项目，我们需要两个构建包。第一个构建包是我们之前用过的，<a class="ae kz" href="https://github.com/lstoll/heroku-buildpack-monorepo" rel="noopener ugc nofollow" target="_blank">heroku-build pack-monorepo</a>。我们将修改参数，因此它将从monorepo中提取蝗虫测试项目(<em class="mr"> locust-heroku-testengine </em>)。第二个buildpack，<a class="ae kz" href="https://github.com/heroku/heroku-buildpack-python" rel="noopener ugc nofollow" target="_blank"> heroku-buildpack-python </a>，支持在heroku上执行python脚本。</p><pre class="mt mu mv mw gt nb nc nd ne aw nf bi"><span id="a1d8" class="ng lb je nc b gy nh ni l nj nk">$ heroku buildpacks:add -a locust-heroku-testengine https://github.com/lstoll/heroku-buildpack-monorepo</span><span id="c71a" class="ng lb je nc b gy nl ni l nj nk">$ heroku buildpacks:add -a locust-heroku-testengine <a class="ae kz" href="https://github.com/heroku/heroku-buildpack-python" rel="noopener ugc nofollow" target="_blank">https://github.com/heroku/heroku-buildpack-python</a></span></pre><h1 id="9178" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">配置环境变量</h1><h2 id="1bbe" class="ng lb je bd lc nm nn dn lg no np dp lk km nq nr lo kq ns nt ls ku nu nv lw nw bi translated">Via Heroku CLI</h2><p id="5f00" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们的应用程序需要设置一些环境变量。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/b24d2b66d4089411fc38370c5bc63c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*47Oyyx16DY-snyep5YV0aw.png"/></div></div></figure><p id="3ddd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">执行以下命令，将环境变量添加到应用程序中。</p><pre class="mt mu mv mw gt nb nc nd ne aw nf bi"><span id="c990" class="ng lb je nc b gy nh ni l nj nk">$ heroku config:set -a locust-heroku-target APP_BASE=api</span><span id="e3b0" class="ng lb je nc b gy nl ni l nj nk">$ heroku config:set -a locust-heroku-target GOVERSION=go1.13</span><span id="97ac" class="ng lb je nc b gy nl ni l nj nk">$ heroku config:set -a locust-heroku-testengine APP_BASE=loadtest</span><span id="ad61" class="ng lb je nc b gy nl ni l nj nk">$ heroku config:set -a locust-heroku-testengine PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/app/bin</span><span id="ed99" class="ng lb je nc b gy nl ni l nj nk">$ heroku config:set -a locust-heroku-testengine SAS_TOKEN="?sv=2019-10-10&amp;ss=bfqt&amp;srt=sco&amp;sp=rwdlacupx&amp;se=2025-05-16T11:41:28Z&amp;st=2020-05-15T03:41:28Z&amp;spr=https&amp;sig=\&lt;secret&gt;"</span><span id="907d" class="ng lb je nc b gy nl ni l nj nk">$ heroku config:set -a locust-heroku-testengine TARGET_HOST=https://locust-heroku-target.herokuapp.com/</span></pre><h2 id="7947" class="ng lb je bd lc nm nn dn lg no np dp lk km nq nr lo kq ns nt ls ku nu nv lw nw bi translated">通过Heroku用户界面</h2><p id="d4d5" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">正如我在本文中提到的，您也可以通过用户界面配置应用程序。您可以在<em class="mr">设置</em>选项卡下找到我们应用的设置，如下面的<em class="mr"> locust-heroku-target </em>应用程序部分的截图所示。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/e96d8f788accc9aa4590fa7f22149c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cGj7Qh9aAyuQRrEH.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">设置—蝗虫-英雄-目标</strong></figcaption></figure><p id="dacb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，下面的屏幕截图展示了我们应用于locust-heroku-testengine应用程序的设置。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/9408fda048d371c4b0f38d5a4b293d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ws13jNrP60pR3W5A.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><em class="oe">设置— locust-heroku-testengine </em></figcaption></figure><h1 id="9120" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">部署应用程序</h1><p id="c46d" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">由于现有的GitHub集成，Heroku会在任何更改被推送到主分支时部署我们的应用程序。将您的应用程序或更改推送到GitHub，并等待构建完成。您可以在应用程序的<em class="mr"> Activity </em>选项卡下查看构建日志。</p><h2 id="69d8" class="ng lb je bd lc nm nn dn lg no np dp lk km nq nr lo kq ns nt ls ku nu nv lw nw bi translated">目标API应用程序</h2><p id="26a9" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">部署之后，您可以导航到<em class="mr"> Resources </em>选项卡并查看托管应用程序的dyno。您可以从这个UI向外扩展dyno。点击<em class="mr">打开应用</em>按钮启动应用。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/40227a02025b2a8fe0f553e68130045e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8FsqX08V81DmYJdL.gif"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">打开App——蝗虫英雄目标</strong></figcaption></figure><h2 id="2ba6" class="ng lb je bd lc nm nn dn lg no np dp lk km nq nr lo kq ns nt ls ku nu nv lw nw bi translated">负载测试应用程序</h2><p id="b4dc" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">如果你导航到locust-heroku-testengine应用程序，你会发现heroku通过读取Loadtest项目的Procfile中的指令创建了两个worker dynos。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/8096a0514f4507ecf7a8aeea1fdd0d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bLJlPId-rAy-5DeW.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">蝗虫的工人Dynos-heroku-test engine</strong></figcaption></figure><h1 id="8db7" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">执行测试</h1><p id="ccec" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了执行托管在dynos中的测试，我们使用Heroku CLI和以下命令启动它们。这些函数启动一次性的dynos，然后在它们完成执行后立即终止。</p><pre class="mt mu mv mw gt nb nc nd ne aw nf bi"><span id="6f31" class="ng lb je nc b gy nh ni l nj nk">$ heroku run worker_scene_1 --app locust-heroku-testengine</span><span id="5f13" class="ng lb je nc b gy nl ni l nj nk">$ heroku run worker_scene_2 --app locust-heroku-testengine</span></pre><p id="96db" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">执行后，Azcopy实用程序将包含测试结果的CSV文件复制到Azure存储，您可以使用<a class="ae kz" href="https://azure.microsoft.com/en-us/features/storage-explorer/" rel="noopener ugc nofollow" target="_blank"> Azure Storage Explorer </a>提取这些文件。下图说明了这一过程的实际操作。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/fa4ad6189030c8d559913c6e69f8d565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2sH4cTfxnYmW4yOD.gif"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">执行负载测试</strong></figcaption></figure><p id="ad4f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用自定义可视化工具或在Excel中打开CSV文件来读取测试结果。下图显示了我从worker_scene_2 dyno的执行中收到的部分结果，该结果执行locustfile_scene_2.py文件中的测试。</p><figure class="mt mu mv mw gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ms"><img src="../Images/3342ee9e00fce411bdd0c81a1cc4de4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NHZLOtSjaTY9R2Nh.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated"><strong class="bd lc">负载测试结果</strong></figcaption></figure><h1 id="c493" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结果呢</h1><p id="5d71" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">让我们分析结果，看看我们的应用程序运行得如何。每个测试运行都会生成三个文件:</p><ol class=""><li id="2e5f" class="md me je kd b ke kf ki kj km mf kq mg ku mh ky of mj mk ml bi translated"><em class="mr">失败. csv </em>文件列出了遇到的失败总数。在场景2的结果中，我的运行从<em class="mr"> GET /buggy </em>端点产生了28个错误，这是意料之中的，因为我们就是这样编程的。</li><li id="e942" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky of mj mk ml bi translated"><em class="mr"> stats.csv </em>文件列出了测试向其发送请求的端点以及以毫秒为单位的响应时间。我对场景2的运行显示，swarm分别向<em class="mr"> GET / </em>和<em class="mr"> GET /buggy </em>端点发送了29和28个请求。平均而言，蝗虫分别在149毫秒和78毫秒内收到来自两个端点的响应。平均响应时间的百分比分割是负载测试生成的最有价值的信息。从我的测试运行中，我可以看到我的API的99%的用户将分别在430毫秒和270毫秒内收到来自<em class="mr"> GET / </em>和<em class="mr"> GET /buggy </em>端点的响应。</li><li id="8809" class="md me je kd b ke mm ki mn km mo kq mp ku mq ky of mj mk ml bi translated">第三个文件，<em class="mr"> history.csv </em>，类似于<em class="mr"> stats.csv </em>文件，但是在测试运行的每10秒钟获得一个新行。通过检查该文件的结果，可以发现API响应时间是否降低了久而久之。</li></ol><p id="14f7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看执行这些测试需要多少成本。我在两台标准的1X dynos上进行测试，每月花费25美元。因此，如果我让测试连续执行一个月，成本是50美元。由于我的个人测试运行只持续了两分钟，Heroku按秒计算处理时间的费用，我产生的费用非常少，甚至没有显示在我的仪表盘上。</p><p id="81d4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这很好，但是让我们估算一下测试实际应用程序可能产生的费用。假设一个API平均需要大约10套测试，因此需要10个dynos。如果这些测试每天晚上运行，并且每次运行持续五分钟，则每个dyno将保持活动一个dyno x 300秒x 30天= 9，000秒；因此，每个dyno每月将花费0.086美元。整整一个月运行10个负载测试dynos(一次性dynos)的总成本大约是0.87美元。</p><h1 id="c6a6" class="la lb je bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="56cb" class="pw-post-body-paragraph kb kc je kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在，您可以使用Locust在Heroku上执行负载测试了。您将能够测试每个部署的稳定性和性能。因为一次性dynos只对它们消耗的时间和资源收费，所以你将从你花费的每一分钱中获得最大价值。</p><p id="6548" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mr">经</em> <a class="ae kz" href="https://thecloudblog.net/" rel="noopener ugc nofollow" target="_blank"> <em class="mr">鲁莱</em> </a>许可发表</p></div></div>    
</body>
</html>