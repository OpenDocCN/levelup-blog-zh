<html>
<head>
<title>How To Stack Views &amp; Use Modifiers Efficiently in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SwiftUI中有效地堆叠视图和使用修饰符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-stack-views-use-modifiers-efficiently-in-swiftui-e563c5e8989b?source=collection_archive---------4-----------------------#2020-09-06">https://levelup.gitconnected.com/how-to-stack-views-use-modifiers-efficiently-in-swiftui-e563c5e8989b?source=collection_archive---------4-----------------------#2020-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c3e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用ZStack、VStack和HStack。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/995171ad4fca34a1f0528560dfbae491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M78eGpv-h6SZUait"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@lastnameeaster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> La-Rel Easter </a>拍摄的照片</figcaption></figure><p id="d09f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI有三个内置的堆叠视图；VStack、HStack和ZStack。所有三个堆栈都是视图类型。堆栈有对齐和内容参数。VStack &amp; HStack也有一个间距参数。在SwiftUI中，最后一个参数可以省略，如果没有指定，默认的居中对齐和间距是动态的。<br/>不用编写如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="45cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以用如下的简化方式来写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="cad0" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">VStack</h1><p id="d051" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">VStack是一个视图，它将子视图排列成一条垂直线。下面的例子是垂直堆叠三个圆角矩形。圆形矩形是符合视图类型的形状。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/208fdc1f8df7a74f190ae32220c5aa59.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/0*O2oZOqn_BeEBgojh.png"/></div></figure><h1 id="6dc1" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">HStack</h1><p id="ff61" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">HStack是一个以水平线排列其子视图的视图。下面的例子是水平堆叠三个圆角矩形。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/3c372fd406dfc22cafd595001c793709.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/0*axqIN6EoTxeDyH5y.png"/></div></figure><p id="e872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ZStack</p><p id="c5b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ZStack是一个覆盖其子视图的视图，将它们在两个轴上对齐。下面的例子是堆叠圆角矩形形状和文本视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/b5bfd05628f9990b131e8b195b4e38df.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/0*kQoCHC9dDvWYgh3T.png"/></div></figure><p id="151c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">堆栈和修改器</p><p id="ab95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面解释的三个栈都是视图类型的。这允许我们使用视图的修改器。修饰符将应用于堆栈中的所有元素。在下面的例子中，所有的圆角矩形都应用了堆栈的前景色修改器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/fda7266526ec6bdd6c7d362d8217f031.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/0*_I9W3iDoyth5c7Pr.png"/></div></figure><p id="60d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">堆栈视图内部元素的修饰符将覆盖堆栈视图的修饰符。下面的示例显示了第一个和第二个圆角矩形的前景色修改器覆盖堆栈的修改器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/83b962006459591f312ebf2fab110b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/0*dm7j51q3RLapHLrx.png"/></div></figure><p id="631b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>