<html>
<head>
<title>Best way to read specific columns from CSV in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阅读熊猫CSV中特定栏目的最佳方式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/best-way-to-read-specific-columns-from-csv-in-pandas-7e58507171b3?source=collection_archive---------3-----------------------#2019-06-14">https://levelup.gitconnected.com/best-way-to-read-specific-columns-from-csv-in-pandas-7e58507171b3?source=collection_archive---------3-----------------------#2019-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7fe1966f52474addab4365fead48fbec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3PsTP1ibp4CTLJ3ofVlqg.jpeg"/></div></div></figure><p id="6690" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我和一个朋友聊天，他正在做有很多专栏的CSV，他问我最好的方法是只阅读他需要的专栏。在我看来，最好的方法是将数据存储在数据库中，这样你就可以只选择你需要的列，但不幸的是，这对他来说不是一个选择。我也想过在命令行上使用<code class="fe kw kx ky kz b">cut</code>或<code class="fe kw kx ky kz b">awk</code>来预过滤数据，但是为了简单起见，我认为Pandas是正确的工具。</p><p id="ea65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，就像熊猫的其他事情一样，仍然有多种方式来实现这一点。两种显而易见的方法是在用<code class="fe kw kx ky kz b">read_csv</code>读入数据时过滤数据，以及读取全部内容并只选择您需要的列。我的逻辑告诉我，用<code class="fe kw kx ky kz b">read_csv</code>过滤将是正确的方法，但我心中的数学家需要证明。这就是:</p><p id="dcdf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发现了一个很酷的库，叫做<a class="ae la" href="https://pypi.org/project/memory-profiler/" rel="noopener ugc nofollow" target="_blank"> memory-profiler </a>，它可以帮助我查看一个特定函数使用了多少内存，并使用good ol’<code class="fe kw kx ky kz b">timeit</code>来查看它运行了多长时间。</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="230d" class="lj lk iq kz b gy ll lm l ln lo">from timeit import timeit<br/>from memory_profiler import profile</span><span id="5cd6" class="lj lk iq kz b gy lp lm l ln lo">import numpy as np<br/>import pandas as pd</span></pre><p id="2bce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用了一个函数来获得类似电子表格的列名(' A '，' B'…'AA '，' AB'…):</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="fa46" class="lj lk iq kz b gy ll lm l ln lo">def colnum_string(n):<br/>    """Convert number to string like: 1-&gt;A, 2-&gt;AA"""<br/>    string = ""<br/>    while n &gt; 0:<br/>        n, remainder = divmod(n - 1, 26)<br/>        string = chr(65 + remainder) + string<br/>    return string</span></pre><p id="e2f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了设置我的测试，我创建了一个具有150列和100，000行的大型csv:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="783b" class="lj lk iq kz b gy ll lm l ln lo">df = pd.DataFrame(<br/>    np.random.randint(0, 100, size=(100000, 150)),<br/>    columns=[colnum_string(i) for i in range(1, 151)],<br/>)<br/>df.to_csv("test.csv")</span></pre><p id="62cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我的测试a，选择4个(不连续的)列:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="e040" class="lj lk iq kz b gy ll lm l ln lo">test_cols = [colnum_string(i) for i in [1, 50, 103, 150]]</span></pre><p id="488e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还想看看使用<code class="fe kw kx ky kz b">df[cols]</code>和更具体的<code class="fe kw kx ky kz b">df.loc[:, cols]</code>之间是否有明显的区别。下面是我如何设置和运行我的测试:</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="cae4" class="lj lk iq kz b gy ll lm l ln lo"><a class="ae la" href="http://twitter.com/profile" rel="noopener ugc nofollow" target="_blank">@profile</a><br/>def filter_during_read():<br/>    return pd.read_csv("test.csv", usecols=test_cols)</span><span id="e17e" class="lj lk iq kz b gy lp lm l ln lo"><a class="ae la" href="http://twitter.com/profile" rel="noopener ugc nofollow" target="_blank">@profile</a><br/>def filter_after_read():<br/>    df = pd.read_csv("test.csv")<br/>    return df[test_cols]</span><span id="78f7" class="lj lk iq kz b gy lp lm l ln lo"><a class="ae la" href="http://twitter.com/profile" rel="noopener ugc nofollow" target="_blank">@profile</a><br/>def filter_after_read_loc():<br/>    df = pd.read_csv("test.csv")<br/>    return df.loc[:, test_cols]</span><span id="89a2" class="lj lk iq kz b gy lp lm l ln lo">pad = "-------------------"<br/>for func in [<br/>    filter_during_read,<br/>    filter_after_read,<br/>    filter_after_read_loc,<br/>]:<br/>    print(pad + "Testing " + func.__name__ + pad)<br/>    print(<br/>        "Took {} seconds to run {}".format(<br/>            timeit(func, number=3), func.__name__<br/>        )<br/>    )</span></pre><p id="da9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果是(击鼓…):</p><pre class="lb lc ld le gt lf kz lg lh aw li bi"><span id="9937" class="lj lk iq kz b gy ll lm l ln lo">---------------------Testing filter_during_read---------------------<br/>Filename: read_csv_profiling.py</span><span id="5aeb" class="lj lk iq kz b gy lp lm l ln lo">Line #    Mem usage    Increment   Line Contents<br/>================================================<br/>    32    206.7 MiB    206.7 MiB   <a class="ae la" href="http://twitter.com/profile" rel="noopener ugc nofollow" target="_blank">@profile</a><br/>    33                             def filter_during_read():<br/>    34    206.7 MiB      0.0 MiB       return pd.read_csv(<br/>    35    226.0 MiB     19.3 MiB           "test.csv", usecols=test_cols<br/>    36                                 )</span><span id="cfad" class="lj lk iq kz b gy lp lm l ln lo">Filename: read_csv_profiling.py</span><span id="16a5" class="lj lk iq kz b gy lp lm l ln lo">Line #    Mem usage    Increment   Line Contents<br/>================================================<br/>    32    226.0 MiB    226.0 MiB   <a class="ae la" href="http://twitter.com/profile" rel="noopener ugc nofollow" target="_blank">@profile</a><br/>    33                             def filter_during_read():<br/>    34    226.0 MiB      0.0 MiB       return pd.read_csv(<br/>    35    230.2 MiB      4.2 MiB           "test.csv", usecols=test_cols<br/>    36                                 )</span><span id="1510" class="lj lk iq kz b gy lp lm l ln lo">Filename: read_csv_profiling.py</span><span id="e221" class="lj lk iq kz b gy lp lm l ln lo">Line #    Mem usage    Increment   Line Contents<br/>================================================<br/>    32    230.2 MiB    230.2 MiB   <a class="ae la" href="http://twitter.com/profile" rel="noopener ugc nofollow" target="_blank">@profile</a><br/>    33                             def filter_during_read():<br/>    34    230.2 MiB      0.0 MiB       return pd.read_csv(<br/>    35    233.3 MiB      3.1 MiB           "test.csv", usecols=test_cols<br/>    36                                 )</span><span id="d263" class="lj lk iq kz b gy lp lm l ln lo">Took 1.0760158769553527 seconds to run filter_during_read</span><span id="dd05" class="lj lk iq kz b gy lp lm l ln lo">---------------------Testing filter_after_read---------------------<br/>Filename: read_csv_profiling.py</span><span id="e1fe" class="lj lk iq kz b gy lp lm l ln lo">Line #    Mem usage    Increment   Line Contents<br/>================================================<br/>    33    229.3 MiB    229.3 MiB   <a class="ae la" href="http://twitter.com/profile" rel="noopener ugc nofollow" target="_blank">@profile</a><br/>    34                             def filter_after_read():<br/>    35    337.4 MiB    108.0 MiB       df = pd.read_csv("test.csv")<br/>    36    337.8 MiB      0.4 MiB       return df[test_cols]</span><span id="85ca" class="lj lk iq kz b gy lp lm l ln lo">Filename: read_csv_profiling.py</span><span id="e5d7" class="lj lk iq kz b gy lp lm l ln lo">Line #    Mem usage    Increment   Line Contents<br/>================================================<br/>    33    222.4 MiB    222.4 MiB   <a class="ae la" href="http://twitter.com/profile" rel="noopener ugc nofollow" target="_blank">@profile</a><br/>    34                             def filter_after_read():<br/>    35    448.5 MiB    226.1 MiB       df = pd.read_csv("test.csv")<br/>    36    448.5 MiB      0.0 MiB       return df[test_cols]</span><span id="702c" class="lj lk iq kz b gy lp lm l ln lo">Filename: read_csv_profiling.py</span><span id="03dc" class="lj lk iq kz b gy lp lm l ln lo">Line #    Mem usage    Increment   Line Contents<br/>================================================<br/>    33    333.2 MiB    333.2 MiB   <a class="ae la" href="http://twitter.com/profile" rel="noopener ugc nofollow" target="_blank">@profile</a><br/>    34                             def filter_after_read():<br/>    35    451.4 MiB    118.3 MiB       df = pd.read_csv("test.csv")<br/>    36    451.4 MiB      0.0 MiB       return df[test_cols]</span><span id="a8f2" class="lj lk iq kz b gy lp lm l ln lo">Took 4.564797632978298 seconds to run filter_after_read</span><span id="a76c" class="lj lk iq kz b gy lp lm l ln lo">-------------------Testing filter_after_read_loc-------------------<br/>Filename: read_csv_profiling.py</span><span id="cd73" class="lj lk iq kz b gy lp lm l ln lo">Line #    Mem usage    Increment   Line Contents<br/>================================================<br/>    39    336.2 MiB    336.2 MiB   <a class="ae la" href="http://twitter.com/profile" rel="noopener ugc nofollow" target="_blank">@profile</a><br/>    40                             def filter_after_read_loc():<br/>    41    448.4 MiB    112.2 MiB       df = pd.read_csv("test.csv")<br/>    42    448.4 MiB      0.0 MiB       return df.loc[:, test_cols]</span><span id="0088" class="lj lk iq kz b gy lp lm l ln lo">Filename: read_csv_profiling.py</span><span id="376e" class="lj lk iq kz b gy lp lm l ln lo">Line #    Mem usage    Increment   Line Contents<br/>================================================<br/>    39    333.2 MiB    333.2 MiB   <a class="ae la" href="http://twitter.com/profile" rel="noopener ugc nofollow" target="_blank">@profile</a><br/>    40                             def filter_after_read_loc():<br/>    41    448.4 MiB    115.2 MiB       df = pd.read_csv("test.csv")<br/>    42    448.4 MiB      0.0 MiB       return df.loc[:, test_cols]</span><span id="b63f" class="lj lk iq kz b gy lp lm l ln lo">Filename: read_csv_profiling.py</span><span id="0468" class="lj lk iq kz b gy lp lm l ln lo">Line #    Mem usage    Increment   Line Contents<br/>================================================<br/>    39    333.2 MiB    333.2 MiB   <a class="ae la" href="http://twitter.com/profile" rel="noopener ugc nofollow" target="_blank">@profile</a><br/>    40                             def filter_after_read_loc():<br/>    41    448.4 MiB    115.2 MiB       df = pd.read_csv("test.csv")<br/>    42    448.4 MiB      0.0 MiB       return df.loc[:, test_cols]</span><span id="1616" class="lj lk iq kz b gy lp lm l ln lo">Took 4.263103098026477 seconds to run filter_after_read_loc</span></pre><p id="7413" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，正如我们所看到的，在这个测试中，使用<code class="fe kw kx ky kz b">read_csv</code>中的<code class="fe kw kx ky kz b">usecols</code>参数过滤我们需要的列大约快了4倍，并且使用了几乎一半的内存。与使用<code class="fe kw kx ky kz b">df.loc[:, cols]</code>相比，使用<code class="fe kw kx ky kz b">df[cols]</code>选择器似乎不会有太大的性能损失。</p><p id="a258" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于未来的测试，选择随机数量的随机选择的列而不是set 4会很有趣。</p></div></div>    
</body>
</html>