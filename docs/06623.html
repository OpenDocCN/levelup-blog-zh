<html>
<head>
<title>What is the use of the Virtual DOM in React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的虚拟DOM有什么用？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-the-use-of-the-virtual-dom-in-react-62a2ad61bb88?source=collection_archive---------8-----------------------#2020-12-13">https://levelup.gitconnected.com/what-is-the-use-of-the-virtual-dom-in-react-62a2ad61bb88?source=collection_archive---------8-----------------------#2020-12-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8db6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">React的虚拟DOM哲学。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a08de4bd6a4bbf2b31c4607c4277253c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dU3z1SSEYkmbQM45eCL1fA.png"/></div></div></figure><p id="137b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过我学习和理解ReactJS哲学的旅程，我遇到了虚拟DOM，我发现它非常有趣。React应用又快又快。</p><p id="feaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如今，现代网站的挑战是关于用户体验和响应时间。没有用户愿意在浏览网页时等待，对吗？</p><p id="966d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React创造了自己的概念和<a class="ae lq" href="https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf" rel="noopener ugc nofollow" target="_blank">算法</a>来应对这一挑战。这个概念被命名为<strong class="kw iu"> <em class="lr">虚拟DOM </em> </strong>。这个概念是React JS出名的因素之一，也是开发人员和公司首选的UI库。</p><p id="92bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将分享我迄今为止对虚拟DOM概念的了解。像往常一样，每一个反馈都受到愉快的欢迎，所以请随意让这些内容因您而成长。</p><p id="653f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">准备好了，我们走！</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="19ea" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">什么反应？</h1><p id="0a43" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">React是一个前端库，一个特殊的库，我说到做到。如果您想知道React为什么如此特别，并且每个前端开发人员都应该学习它，我建议您看看这篇文章:</p><div class="mw mx gp gr my mz"><a href="https://medium.com/the-innovation/whats-so-special-about-react-js-7707f706e038" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">React JS有什么特别之处？</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">什么反应？为什么它如此受欢迎？</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ks mz"/></div></div></a></div></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="d85e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">React中的虚拟DOM (VDOM)是什么？</h1><blockquote class="no np nq"><p id="42e1" class="ku kv lr kw b kx ky ju kz la lb jx lc nr le lf lg ns li lj lk nt lm ln lo lp im bi translated">虚拟DOM只不过是内存中的一个JavaScript对象，表示页面的整个HTML文档。</p></blockquote><p id="0187" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我解释一下。要在你的浏览器中渲染东西，你使用<strong class="kw iu"> <em class="lr"> render() </em> </strong>函数。这个函数创建了一个React元素树。下面是一个带有生成树的渲染代码的示例。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="079f" class="nz ma it nv b gy oa ob l oc od">&lt;div&gt;<br/>  &lt;div class="container"&gt;<br/>    &lt;h1&gt;Hello world&lt;/h1&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="86a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">渲染时，虚拟DOM可以表示如下:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="1be6" class="nz ma it nv b gy oa ob l oc od">{<br/>  tag: 'div',<br/>  children: [<br/>    {<br/>      tag: 'div',<br/>      attributes: {<br/>        class: 'container'<br/>      },<br/>      children: [<br/>        {<br/>          tag: 'h1',<br/>          children: 'Hello World'<br/>        }<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre><p id="6bb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当状态或道具改变时，React需要更新DOM。React可以愚蠢地生成另一棵树，替换之前的DOM。那就太容易了，问题不在这里，但是对于大的app来说，从性能和用户体验上来说会很贵。</p><p id="c09e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您使用React时，在单个时间点，您可以将<code class="fe oe of og nv b">render()</code>函数视为创建React元素树。在下一次state或props更新时，<code class="fe oe of og nv b">render()</code>函数将返回一个不同的React元素树。React然后需要找出如何更新UI来有效地匹配最近的树。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="47b2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">虚拟世界背后的哲学</h1><p id="1cd2" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">更新DOM是一个应用程序的最大成本。想象一下，我们需要为每个新的状态变化更新DOM多少次，并且每次都要重新呈现UI。那将是无法忍受的。那么React是如何快速更新DOM的呢？引擎盖下发生了什么？</p><p id="a28e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好奇，不是吗？让我们开始吧。</p><p id="21a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果到目前为止，我们知道您看到的每个React web页面都有一个等价的DOM表示，即虚拟DOM。该对象保存页面所有UI组件的结构表示。</p><p id="ae8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React维护虚拟DOM的两个副本。每当UI组件中的状态发生变化时，React都会跟踪这些变化。这些更改不会应用于实际的DOM，而是应用于虚拟DOM。因此，不在每次更改时都更新实际的DOM可以提高性能。但是，真正显示的DOM是如何更新的呢？</p><p id="46e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React有自己的算法，在特定的时间，它执行显示的DOM和虚拟DOM之间的区分算法。该算法计算增量，并仅应用于相关区域，而不是重新呈现整个网页。这个过程称为协调，算法称为差异或协调算法。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="5f4f" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">【React和解是如何工作的？</h1><p id="4c19" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">到目前为止，我们知道协调是将虚拟DOM与真实DOM同步的过程。如前所述，react在每次渲染DOM时都会创建一棵树。当app的状态发生变化时，<strong class="kw iu"> <em class="lr"> diffing算法</em> </strong>来到现场，对比真实和虚拟DOM的根元素。然后，它将更改应用于状态已更改的节点。</p><p id="e4f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还没完呢！React使用<strong class="kw iu"> <em class="lr">键</em> </strong>来确定我们需要挂载列表中的哪些项目。这就是为什么每次你想显示一个列表时都需要一个键。这个唯一的标识符有助于识别元素。</p><p id="02e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示例:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="a0c5" class="nz ma it nv b gy oa ob l oc od">&lt;ul&gt;<br/>  &lt;li key="0"&gt;ELEMNT 1&lt;/li&gt;<br/>  &lt;li key="1"&gt;ELEMENT 2&lt;/li&gt;<br/>  &lt;li key="2"&gt;ELEMENT 3&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="ae4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，React使用了非常有效的too <strong class="kw iu"> <em class="lr">属性</em> </strong>，因为他需要做的只是改变DOM节点的属性。</p><h2 id="2320" class="nz ma it bd mb oh oi dn mf oj ok dp mj ld ol om ml lh on oo mn ll op oq mp or bi translated"><strong class="ak">重新渲染真实DOM子树的示例:</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb5822b269e13829e761dd9274680552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wHAx1KnP7obeybFXsL7-NA.png"/></div></div></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="aed4" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">外卖</h1><ul class=""><li id="3ff3" class="os ot it kw b kx mr la ms ld ou lh ov ll ow lp ox oy oz pa bi translated">每次调用render(à函数都会创建一个React元素树。</li><li id="10ac" class="os ot it kw b kx pb la pc ld pd lh pe ll pf lp ox oy oz pa bi translated">更新UI以匹配新树的复杂度与树中元素的数量大约为O(n3)。我会让你想象为什么高效地做这件事如此重要。</li><li id="e4d4" class="os ot it kw b kx pb la pc ld pd lh pe ll pf lp ox oy oz pa bi translated">React保持相同的DOM节点，改变已经改变的子树。仅应用增量，而不是重新绘制整个网页。</li><li id="e5ca" class="os ot it kw b kx pb la pc ld pd lh pe ll pf lp ox oy oz pa bi translated">React拥有强大高效的UI渲染系统。</li><li id="335e" class="os ot it kw b kx pb la pc ld pd lh pe ll pf lp ox oy oz pa bi translated">想了解更多详情，这里是<a class="ae lq" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> React对账单据</em> </a>。</li></ul></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="5c35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">亲爱的读者朋友们，感谢你们的支持和宝贵时间。我希望这对你有用和有帮助。</p><p id="fc8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">关注我上</strong> <a class="ae lq" href="https://medium.com/@famzil/" rel="noopener"> <strong class="kw iu">中</strong> </a> <strong class="kw iu">，</strong><a class="ae lq" href="https://www.linkedin.com/in/fatima-amzil-9031ba95/" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">Linkedin</strong></a><strong class="kw iu">，</strong> <a class="ae lq" href="https://www.facebook.com/The-Front-End-World" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">【脸书</strong> </a> <strong class="kw iu">，</strong><a class="ae lq" href="https://twitter.com/FatimaAMZIL9" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">Twitter</strong></a><strong class="kw iu">查看更多文章。</strong></p><p id="ed7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回头见(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧)</p><p id="1faa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> FAM </strong></p></div></div>    
</body>
</html>