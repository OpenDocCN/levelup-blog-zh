<html>
<head>
<title>C++ vs Zig Template Based Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于C++和Zig模板的编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/c-vs-zig-template-based-programming-d3e248885aa?source=collection_archive---------1-----------------------#2020-11-06">https://levelup.gitconnected.com/c-vs-zig-template-based-programming-d3e248885aa?source=collection_archive---------1-----------------------#2020-11-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="60a8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">C++和Zig中编译时duck类型的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8ebb3e88512ffe5a3dad8f63e9630269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*td1jfbHL9eQEgJN8"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ghazisaeedi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fereshteh ghazisaedi</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3bd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多语言都有某种在编译时运行代码的系统。Java和C#中的泛型是在编译时创建具体类型的一种方式，所以我们不必手动创建<code class="fe lv lw lx ly b">IntArray</code>、<code class="fe lv lw lx ly b">FloatArray</code>、<code class="fe lv lw lx ly b">StringArray</code>和类似的类型。</p><p id="d6a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也避免了例如为每个可能的数字类型编写<code class="fe lv lw lx ly b">max</code>函数的需要。我们不想重复写一个<code class="fe lv lw lx ly b">maxFloat32</code>、<code class="fe lv lw lx ly b">maxFloat64</code>、<code class="fe lv lw lx ly b">maxInt16</code>、<code class="fe lv lw lx ly b">maxInt32</code>以及类似的函数。我们想要一个能够处理多种数字类型的<code class="fe lv lw lx ly b">max</code>函数。</p><p id="5b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在像Julia这样的语言中，数字类型存在于一个复杂的类型层次结构中，定义这样一个<code class="fe lv lw lx ly b">max</code>函数是相当容易的。你可以这样写:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b8e4" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">function</strong> maximum(a::Number, b::Number)<br/>    <strong class="ly iu">if</strong> a &gt; b<br/>        a<br/>    <strong class="ly iu">else</strong><br/>        b<br/>    <strong class="ly iu">end</strong><br/><strong class="ly iu">end</strong></span></pre><p id="13a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在大多数静态类型语言中，如Java、C#、C++、Zig等，类型层次中不存在数字，max函数也不容易定义。但无论如何让我们试试。</p><h2 id="1edd" class="md me it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">C++模板错误</h2><p id="01bf" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">看看这个简单的C++程序演示了一个max函数。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f4d1" class="md me it ly b gy mf mg l mh mi">#include &lt;iostream&gt;<br/><br/><strong class="ly iu">using</strong> <strong class="ly iu">namespace</strong> std;<br/><br/><strong class="ly iu">template</strong>&lt;<strong class="ly iu">typename</strong> T, <strong class="ly iu">typename</strong> S&gt;<br/>T maximum(T a, S b) {<br/>    T result;<br/>    <strong class="ly iu">if</strong> (a &gt; b)<br/>        result = a;<br/>    <strong class="ly iu">else</strong><br/>        result = b;<br/>    <strong class="ly iu">return</strong> result;<br/>}<br/><br/><strong class="ly iu">int</strong> main (int argc, char const *argv[])<br/>{<br/>    int a = 12;<br/>    int b = 3;<br/>    int biggest = maximum("12", b);<br/>        <br/>    cout &lt;&lt; "Max of " &lt;&lt; a &lt;&lt; " and "<br/>                      &lt;&lt; b &lt;&lt; " is " <br/>                      &lt;&lt; biggest &lt;&lt; endl;<br/>    return 0;<br/>}</span></pre><p id="702b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切都运行得很好，直到我们使用<code class="fe lv lw lx ly b">maxiumum</code>函数对该行进行更改，改为编写:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="cd9c" class="md me it ly b gy mf mg l mh mi">int biggest = maximum("12", b);</span></pre><p id="5ca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们得到这个编译器错误:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a69e" class="md me it ly b gy mf mg l mh mi">main.cpp:19:9: error: cannot initialize a variable of type 'int' with an rvalue of type 'const char *'<br/>    int biggest = maximum("12", b);<br/>        ^         ~~~~~~~~~~~~~~~~<br/>main.cpp:8:11: error: comparison between pointer and integer ('const char *' and 'int')<br/>    if (a &gt; b)<br/>        ~ ^ ~<br/>main.cpp:19:19: note: in instantiation of function template specialization 'maximum&lt;const char *, int&gt;' requested here<br/>    int biggest = maximum("12", b);<br/>                  ^</span></pre><p id="5e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是C++中较好的模板错误信息之一，但也不容易理解。</p><h2 id="705b" class="md me it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">Zig编译时间错误</h2><p id="e73a" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">让我们与Zig版本进行比较:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4ae3" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">const</strong> std = @import("std");<br/><br/><strong class="ly iu">fn</strong> maximum(a: <strong class="ly iu">anytype</strong>, b: <strong class="ly iu">anytype</strong>) @TypeOf(a) {<br/>    <strong class="ly iu">var</strong> result: @TypeOf(a) = undefined;<br/>    <strong class="ly iu">if</strong> (a &gt; b) {<br/>        result = a;<br/>    } <strong class="ly iu">else</strong> {<br/>        result = b;<br/>    }<br/><br/>    return result;<br/>}<br/><br/><strong class="ly iu">pub</strong> <strong class="ly iu">fn</strong> main() !void {<br/>    <strong class="ly iu">const</strong> stdout = std.io.getStdOut().writer();<br/><br/>    <strong class="ly iu">const</strong> a = 12;<br/>    <strong class="ly iu">const</strong> b = 3;<br/><br/>    <strong class="ly iu">const</strong> biggest = maximum(a, b);<br/><br/>    <strong class="ly iu">try</strong> stdout.print("Max of {} and {} is {}\n", <br/>                     .{ a, b, biggest });<br/>}</span></pre><p id="6776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Zig中，这实际上并不是您通常编写这些函数的方式，但是出于演示的目的，这很有用。</p><p id="8384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数人可能从未见过Zig代码，所以我们需要在这里解释一些看起来很奇怪的概念。</p><p id="3056" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像Go、Rust、Swift、Julia和当今许多其他语言一样，类型信息出现在变量名之后，这与C/C++、Java、C#和更老的语言不同。这样做的一个好处是，一行中的前几个关键字可以很快告诉你你看到的是什么类型的语句。例如，如果一行以<code class="fe lv lw lx ly b">fn</code>开头，你知道它是一个函数，而如果它以<code class="fe lv lw lx ly b">const</code>开头，它将是某种类型的变量。</p><p id="2883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么以<code class="fe lv lw lx ly b">@</code>符号开头的函数呢，比如<code class="fe lv lw lx ly b">@import</code>和<code class="fe lv lw lx ly b">@TypeOf</code>？这些是编译器内部函数。它们不是语言中的关键字或库中的函数。相反，它们是由编译器本身提供的函数。通常这些函数在编译时执行代码。</p><p id="3229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如<code class="fe lv lw lx ly b">@TypeOf(a)</code>将在编译时运行，并返回函数参数<code class="fe lv lw lx ly b">a</code>的类型。</p><p id="cfa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经定义了我们的<code class="fe lv lw lx ly b">maxium</code>函数来使用类似C++的编译时鸭子类型，除了在Zig中它的工作方式有点不同。这里没有类型占位符变量<code class="fe lv lw lx ly b">T</code>。相反，我们使用了<code class="fe lv lw lx ly b">anytype</code>关键字，它告诉Zig<code class="fe lv lw lx ly b">a</code>和<code class="fe lv lw lx ly b">b</code>可以是任何类型。编译器将在编译时确定类型。</p><p id="52cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们像C++例子中那样提供一个非数字参数，会发生什么？</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4c4b" class="md me it ly b gy mf mg l mh mi">const biggest = maximum("12", b);</span></pre><p id="90a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将不起作用，因为您不能用数字和字符串执行<code class="fe lv lw lx ly b">a &gt; b</code>。我们得到以下编译错误:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ae2b" class="md me it ly b gy mf mg l mh mi">main.zig:5:13: error: integer value 3 cannot be coerced to type '*const [2:0]u8'<br/>    if (a &gt; b) {<br/>            ^<br/>main.zig:20:28: note: called from here<br/>    const biggest = maximum("12", b);<br/>                           ^<br/>main.zig:14:21: note: called from here<br/>pub fn main() !void {<br/>                    ^<br/>main.zig:5:11: note: referenced here<br/>    if (a &gt; b) {</span></pre><p id="7ee6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到错误消息彼此并没有太大的不同。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="6540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，Zig给了我们一个机会来创建我们自己定制的编译错误消息。</p><p id="e24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个在一些帮助下重写<code class="fe lv lw lx ly b">maximum</code>函数的例子:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="7fcc" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">fn</strong> assertInteger(<strong class="ly iu">comptime</strong> T: <strong class="ly iu">type</strong>) <strong class="ly iu">void</strong> {<br/>    <strong class="ly iu">const</strong> is_int = <strong class="ly iu">switch</strong> (T) {<br/>        i8, i16, i32, i64 =&gt; <strong class="ly iu">true</strong>,<br/>        u8, u16, u32, u64 =&gt; <strong class="ly iu">true</strong>,<br/>        comptime_int =&gt; true,<br/>        <strong class="ly iu">else</strong> =&gt; <strong class="ly iu">false</strong>,<br/>    };<br/><br/>    <strong class="ly iu">if</strong> (!is_int) {<br/>        @compileError("Function require inputs which are integers");<br/>    }<br/>}<br/><br/><strong class="ly iu">fn</strong> maximum(a: <strong class="ly iu">anytype</strong>, b: <strong class="ly iu">anytype</strong>) @TypeOf(a) {<br/>    <strong class="ly iu">const</strong> A = @TypeOf(a);<br/>    <strong class="ly iu">const</strong> B = @TypeOf(b);<br/><br/>    assertInteger(A);<br/>    assertInteger(B);<br/>    <strong class="ly iu">var</strong> result: @TypeOf(a) = <strong class="ly iu">undefined</strong>;<br/>    <strong class="ly iu">if</strong> (a &gt; b) {<br/>        result = a;<br/>    } <strong class="ly iu">else</strong> {<br/>        result = b;<br/>    }<br/><br/>    <strong class="ly iu">return</strong> result;<br/>}</span></pre><p id="6ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我定义了一个额外的函数<code class="fe lv lw lx ly b">assertInteger</code>，它是一个只能在编译时运行的函数，因为我已经用关键字<code class="fe lv lw lx ly b">comptime</code>标记了它的一个参数<code class="fe lv lw lx ly b">T</code>以便在编译时才知道。</p><p id="9fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我是一个Zig新手，这篇文章可能写得不够优雅和好。但是它在Zig中展示了一个简单的能力。我们能够在运行时运行<code class="fe lv lw lx ly b">assertInteger</code>函数，以确保<code class="fe lv lw lx ly b">a</code>和<code class="fe lv lw lx ly b">b</code>的参数都是整数值。如果不是，我们会在编译时打印一条错误消息。</p><p id="05aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Zig给了我们许多函数，我们可以在编译时与用户交流。例如<code class="fe lv lw lx ly b">@compileError</code>让我们在编译时写错误信息。当我们试图编译时，会出现以下错误消息:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c01e" class="md me it ly b gy mf mg l mh mi">main.zig:11:9: error: Function require inputs which are integers<br/>        @compileError("Function require inputs which are integers");<br/>        ^<br/>main.zig:19:18: note: called from here<br/>    assertInteger(A);<br/>                 ^<br/>main.zig:37:28: note: called from here<br/>    const biggest = maximum(a, b);<br/>                           ^<br/>main.zig:31:21: note: called from here<br/>pub fn main() !void {<br/>                    ^<br/>main.zig:19:18: note: referenced here<br/>    assertInteger(A);<br/>                 ^<br/>main.zig:37:28: note: referenced here<br/>    const biggest = maximum(a, b);</span></pre><h2 id="8f88" class="md me it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">C++ 20概念呢？</h2><p id="2a4b" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">这让我们能够在类型不匹配时向用户提供更好的错误消息，而无需添加更多的语言特性。例如，C++ 20正在添加概念来帮助指定类型参数的契约，例如<code class="fe lv lw lx ly b">T</code>。</p><p id="6fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift可能是C++ 20中引入的concepts思想的较好实现之一。蒂姆·比尔斯在这里举了一个<a class="ae ky" href="https://medium.com/swift2go/mastering-generics-with-protocols-the-specification-pattern-5e2e303af4ca" rel="noopener">的例子</a>，我将做一个简化的版本:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4761" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">protocol</strong> Colored {<br/>    var color: Color { get set }<br/>}<br/><br/><strong class="ly iu">struct</strong> SizeSpecification&lt;T: Sized&gt; {<br/><br/>    <strong class="ly iu">var</strong> size: Size<br/><br/>    <strong class="ly iu">func</strong> isSatisfied(item: T) -&gt; Bool {<br/>        <strong class="ly iu">return</strong> item.size == size<br/>    }<br/>}</span></pre><p id="5e8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift中的协议类似于Java中的接口，但是您可以使用它们作为运行时多态性的接口，也可以约束类型参数，例如<code class="fe lv lw lx ly b">T</code>。在这种情况下，我们说<code class="fe lv lw lx ly b">isSatisfied</code>函数适用于某种类型的项目<code class="fe lv lw lx ly b">T</code>。该类型必须实现<code class="fe lv lw lx ly b">Colored</code>协议，否则它不是<code class="fe lv lw lx ly b">T</code>占位符类型的有效类型。</p><p id="3076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以像这样的东西显然是有用的。但这可能与保持语言简约的愿望相冲突。Swift和C++都不是极简语言。</p><p id="f8dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用编译时函数的Zig模板/泛型方法的好处是，它可以被广泛使用，并且可以根据具体情况进行定制。这意味着我们不用添加更多的语言特性，而是可以通过创建像<code class="fe lv lw lx ly b">assertInteger</code>这样的函数来解决库的编译时鸭子类型的许多问题。</p><h2 id="98ae" class="md me it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">带有类型参数T的Zig</h2><p id="35c8" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在我们的第一个例子中，参数<code class="fe lv lw lx ly b">a</code>和<code class="fe lv lw lx ly b">b</code>没有约束。</p><p id="3378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如在C++中，我们可以声明两个参数应该是相同的类型<code class="fe lv lw lx ly b">T</code>。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ebea" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">template</strong>&lt;typename T&gt;<br/>T minimum(T a, T b) {<br/>    T result;<br/>    <strong class="ly iu">if</strong> (a &lt; b)<br/>        result = a;<br/>    <strong class="ly iu">else</strong><br/>        result = b;<br/>    <strong class="ly iu">return</strong> result;<br/>}</span></pre><p id="0af6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以像之前调用<code class="fe lv lw lx ly b">maximum</code>一样调用<code class="fe lv lw lx ly b">minimum</code>函数，并让<code class="fe lv lw lx ly b">T</code>直接推断或指定它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8350" class="md me it ly b gy mf mg l mh mi">int smallest = minimum&lt;long&gt;(a, b);</span></pre><p id="f89e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我们提供<code class="fe lv lw lx ly b">T</code>作为<code class="fe lv lw lx ly b">maximum</code>函数的特殊参数。在Zig案例中有趣的是，类型并没有作为任何一种特殊的参数而过时。它们与任何其他参数一样，只是在编译时必须用关键字<code class="fe lv lw lx ly b">comptime</code>标记为已存在:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0ac3" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">fn</strong> minimum(<strong class="ly iu">comptime</strong> T: <strong class="ly iu">type</strong>, a: T, b: T) T {<br/>    assertInteger(T);<br/><br/>    <strong class="ly iu">var</strong> result: T = <strong class="ly iu">undefined</strong>;<br/>    <strong class="ly iu">if</strong> (a &lt; b) {<br/>        result = a;<br/>    } <strong class="ly iu">else</strong> {<br/>        result = b;<br/>    }<br/><br/>    <strong class="ly iu">return</strong> result;<br/>}</span></pre><p id="0968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们这样呼吁:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0913" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">const</strong> smallest = minimum(u16, a, b);</span></pre><p id="1f92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里<code class="fe lv lw lx ly b">u16</code>表示16位无符号整数点值。Zig使用短类型名。</p><p id="34e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至少对我来说，这种语法的一个好处是没有什么新东西需要学习。不需要学习特殊的类型参数语法。类型就像任何其他参数一样。甚至一个none类型的参数也可以被指定为<code class="fe lv lw lx ly b">comptime</code>,例如</p><p id="629d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以提供一个浮点值作为参数，因为我知道我的断言不喜欢这样:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="53d9" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">const</strong> smallest = minimum(f16, a, b);</span></pre><p id="bf98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生以下编译错误:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ed53" class="md me it ly b gy mf mg l mh mi">main.zig:12:9: error: Function require inputs which are integers<br/>        @compileError("Function require inputs which are integers");<br/>        ^<br/>main.zig:33:18: note: called from here<br/>    assertInteger(T);<br/>                 ^<br/>main.zig:55:29: note: called from here<br/>    const smallest = minimum(f16, a, b);<br/>                            ^<br/>main.zig:45:21: note: called from here<br/>pub fn main() !void {</span></pre><p id="1299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到一个堆栈回溯，它告诉我们在堆栈帧中的每一点问题发生在哪里。例如，<code class="fe lv lw lx ly b">@compileError</code>是由<code class="fe lv lw lx ly b">assertInteger(T)</code>呼叫引起的，而<code class="fe lv lw lx ly b">assertInteger(T)</code>呼叫又是由<code class="fe lv lw lx ly b">const smallest = minimum(f16, a, b);</code>呼叫引起的。</p><h2 id="cf35" class="md me it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">Zig CompTime取代了预处理宏</h2><p id="bad0" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">当分析Zig <code class="fe lv lw lx ly b">comptime</code>时，重要的是不要忘乎所以，想象和精心设计复杂的系统，用于随时间演进的泛型编程。Zig并不是要成为Haskell、C++、Rust或任何类似的语言。</p><p id="a00c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">comptime</code>的存在主要是为了取代C预处理器。可怕的C预处理器宏是大多数C开发人员认为是一个错误。然而，这是一个难以避免的错误，因为它提供了C语言中不存在的灵活性和功能性。C语言中的许多常见任务都需要预处理器。Zig的创造者安德鲁·凯利不得不拿出一个最小的替代品。那就是<code class="fe lv lw lx ly b">comptime</code>是什么。</p><p id="41c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，一个原本被设计得很小的功能，最终却产生了更广泛的影响。据Andrew自己说，他无意为泛型编程创建一个系统。</p><p id="cd8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在研究Zig特性时，我们不应该以“我们需要在Zig中实现什么来尽可能地进行令人敬畏的通用编程”为出发点，而是应该考虑如何利用Zig中的最小特性来达到这个目的？</p></div></div>    
</body>
</html>