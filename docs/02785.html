<html>
<head>
<title>Asynchronous JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步JavaScript</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asynchronous-javascript-6d219b6eb8ff?source=collection_archive---------12-----------------------#2020-04-04">https://levelup.gitconnected.com/asynchronous-javascript-6d219b6eb8ff?source=collection_archive---------12-----------------------#2020-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="84e7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">不那么单线程。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/933aec5e745f9186cc5015b8a29f5dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qb42wZjU6ImP-xDBS8BfoQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">单线程？在<a class="ae kv" href="https://unsplash.com/s/photos/thread?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@amir_v_ali?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> amirali mirhashemian </a>拍摄的照片</figcaption></figure><h1 id="9e21" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="0e66" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">作为一名JavaScript开发人员，您可能已经读过或听说过JavaScript是一种单线程语言。此外，我很确定许多JavaScript开发人员只是“<em class="mk">相信</em>”，从不质疑这个术语或概念，并且已经编写了数千行<a class="ae kv" href="https://stackoverflow.com/questions/34680985/what-is-the-difference-between-asynchronous-programming-and-multithreading/34681101" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">异步(类似多线程)</em> </strong> </a>代码，甚至没有理解它是如何工作的(不要感到羞耻😅，你不是一个人)。</p><h2 id="44ac" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">什么是线程？</h2><p id="c950" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">根据<a class="ae kv" href="https://simple.wikipedia.org/wiki/Thread_(computer_science)" rel="noopener ugc nofollow" target="_blank">维基百科</a>，计算机科学<a class="ae kv" href="https://simple.wikipedia.org/wiki/Computer_science" rel="noopener ugc nofollow" target="_blank">中的<strong class="lq ir">线程</strong>是执行的<em class="mk">线程的简称。线程是一个<a class="ae kv" href="https://simple.wikipedia.org/wiki/Computer_program" rel="noopener ugc nofollow" target="_blank">程序</a>将自己分成(称为<em class="mk">“拆分”</em>)两个或更多同时(或伪同时)运行<a class="ae kv" href="https://simple.wikipedia.org/wiki/Task_(computers)" rel="noopener ugc nofollow" target="_blank">任务</a>的一种方式。</em></a></p><p id="0af1" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">根据上面的定义，我们只是说JavaScript一次只能运行一个任务，对吗？好吧，让我们再深入一点。</p><p id="286c" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">为了理解JavaScript如何处理任务，我们需要理解JavaScript调用栈。</p><p id="6bb9" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">JavaScript调用堆栈是一个字面量<a class="ae kv" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">堆栈数据类型</em></strong></a><strong class="lq ir"><em class="mk"/></strong>，它将每个连续的函数调用堆叠在另一个上，并在其执行完成时弹出函数。下面是一个直观的表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/178ea942c7b974d5dfc44074bbaaf754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wudWlmUNTEGOfmaYDUXSAA.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">JavaScript调用栈演示。<a class="ae kv" href="https://gist.github.com/chuxmykel/81e2c490b1346250a12d643175476c40" rel="noopener ugc nofollow" target="_blank">源文件</a></figcaption></figure><p id="5b1b" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">观察右侧的菜单，重点关注“Call Stack”菜单项。请注意每个函数调用是如何相互叠加，并在执行完成后弹出的。但是<strong class="lq ir"> <em class="mk"> foo </em> </strong>是第一个函数调用吧？那为什么我们下面会有<strong class="lq ir"> <em class="mk">(匿名)</em></strong>foo呢？这是我们调用脚本时运行的主函数，这个函数运行时在全局范围内遇到了三个函数声明和一个函数调用<strong class="lq ir"> <em class="mk"> (foo) </em> </strong>。这会立即将foo添加到堆栈的顶部。现在我们在<em class="mk"> foo </em>的块范围内，我们遇到了另一个函数调用<strong class="lq ir"> <em class="mk"> (console.log())。</em> </strong></p><blockquote class="nd ne nf"><p id="a7ba" class="lo lp mk lq b lr mx jr lt lu my ju lw ng mz lz ma nh na md me ni nb mh mi mj ij bi translated">如果你想知道为什么<strong class="lq ir"> console.log() </strong>没有出现在调用堆栈上，JavaScript引擎非常快，我只能通过<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="iq">调试器</em></strong></a><strong class="lq ir"><em class="iq"/></strong>语句来可视化这个。而且由于我不能在<strong class="lq ir"><em class="iq">console . log()</em></strong>函数中放一个，所以它一执行就弹出来了。</p></blockquote><p id="3033" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">在弹出<strong class="lq ir"><em class="mk">console . log()</em></strong>之后，我们遇到了另一个函数调用<strong class="lq ir"> <em class="mk"> (bar()) </em> </strong>，它将执行上下文带入新函数，并将新函数添加到调用堆栈的顶部。<strong class="lq ir"> <em class="mk"> foo() </em> </strong>函数还没有离开堆栈，因为它的执行还没有完成，所以现在我们在堆栈上有<strong class="lq ir"> <em class="mk"> anonymous()，foo() </em> </strong>和<strong class="lq ir"> <em class="mk"> bar() </em> </strong>。执行<strong class="lq ir"> <em class="mk"> bar() </em> </strong>函数的过程是相同的，它将<strong class="lq ir"><em class="mk">【baz()</em></strong>放在调用堆栈的顶部。<strong class="lq ir"> <em class="mk"> baz() </em> </strong>将<strong class="lq ir"><em class="mk">console . log()</em></strong>放入栈中，弹出它并再次将其与告别消息一起放入然后弹出它，弹出<strong class="lq ir"> baz() </strong>函数然后返回到<strong class="lq ir"><em class="mk">bar()</em></strong>执行上下文运行第二个<strong class="lq ir"> <em class="mk"> console.log</em></strong></p><p id="0c58" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">我几乎可以肯定我的话没有清楚地传达这个概念，所以我冒昧地创建了一个gif来帮助可视化整个过程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/1a6e496d43ec0cf8a40151c37b625b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VnPa2qxPZkEfQte5w0qUqQ.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">根据调用堆栈可视化我们的代码执行</figcaption></figure><p id="30b4" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">现在，您应该能够清楚地看到<em class="mk"> console.log() </em>是如何融入流程的，以及每一行代码是如何执行的。</p><p id="eea4" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">JavaScript就是这样运行<a class="ae kv" href="https://gist.github.com/chuxmykel/21c6e5044b0cfdc2c60fa1873a836dc4" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">同步</em> </strong> </a>代码的。所有的函数都运行到完成，当它们没有其他事情可做时，就从堆栈中弹出。</p><p id="bc9a" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">如果我们已经围绕JavaScript引擎使用<strong class="lq ir"> <em class="mk">调用栈</em> </strong>执行代码的方式建立了一个心智模型，我们已经可以开始质疑它如何能够用一个调用栈同时执行多个任务了。</p><h2 id="07dd" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">异步JavaScript</h2><p id="8161" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">与我们之前的例子相比，考虑下面的代码片段。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">演示异步JS</figcaption></figure><p id="9c2f" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">如果JavaScript引擎像处理前一行代码一样执行这几行代码，我们将得到以下序列:</p><ul class=""><li id="6820" class="nm nn iq lq b lr mx lu my lx no mb np mf nq mj nr ns nt nu bi translated">执行脚本的函数<strong class="lq ir"> <em class="mk">(匿名)</em> </strong>被调用并放置在堆栈顶部。</li><li id="899a" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">它从文件顶部开始，发现3个函数声明，<strong class="lq ir"> <em class="mk">第一个</em></strong><strong class="lq ir"><em class="mk">第二个</em> </strong>和<strong class="lq ir"> <em class="mk"> main </em> </strong>。</li><li id="5f20" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated">在第16行，它看到对<strong class="lq ir"><em class="mk">main()</em></strong><em class="mk"/>函数的调用，并将其添加到堆栈中。</li><li id="0e76" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated"><strong class="lq ir"> <em class="mk"> main() </em> </strong>调用<strong class="lq ir"><em class="mk">first()</em></strong><strong class="lq ir"><em class="mk">first()</em></strong>调用<strong class="lq ir"> <em class="mk"> setTimeout() </em> </strong>。按照我们的心理模型，<strong class="lq ir"> <em class="mk"> setTimeout() </em> </strong>在<strong class="lq ir"> <em class="mk"> main() </em> </strong>可以调用<strong class="lq ir"> <em class="mk"> second() </em> </strong>之前，必须弹出调用堆栈(完成执行)。这意味着我们的堆栈应该被阻塞<em class="mk">一秒</em>对吗？</li></ul><p id="6af8" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">事实并非如此。<strong class="lq ir"><em class="mk"/></strong>setTimeout()奇怪地从堆栈中消失，其他所有东西继续存在，就好像<strong class="lq ir"> setTimeout() </strong>从未在堆栈中存在过一样。并且在我们的代码执行完成后，<strong class="lq ir"> <em class="mk"> setTimeout() </em> </strong>中的回调函数不知从哪里冒出来并执行。下面的gif演示了这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/99728c0ed051aa0bf5ee5e62da7ff736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LZsd8SFNQmycmZtOCaOD8g.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">可视化异步代码执行</figcaption></figure><p id="d9fb" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">显然，这对我们来说是个好消息。我们不需要等待整整一秒钟来执行下一行代码。但是这怎么可能呢？<strong class="lq ir"> <em class="mk"> setTimeout() </em> </strong>调用去了哪里？</p><p id="cdc2" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">我们的思维模式不应该改变。JavaScript是一种单线程语言，使用调用堆栈执行代码，一次执行一个函数调用。运行JavaScript的环境(客户端的<strong class="lq ir"> <em class="mk">浏览器</em> </strong>和服务器端的<strong class="lq ir"> <em class="mk">节点</em> </strong>)提供了一组API，这些API从环境中公开数据，并使用这些数据执行一些非常有用的任务。这些API不是核心JavaScript语言本身的一部分。相反，它们是建立在核心语言之上的，它们给你一些真正有用的附加功能来增强你的JavaScript代码。想想用<strong class="lq ir"> <em class="mk"> nodejs、</em> </strong>访问你的文件系统，JavaScript引擎没有给你任何开箱即用访问文件系统的方法。相反，<strong class="lq ir"> <em class="mk"> nodejs </em> </strong>公开的<strong class="lq ir"> <em class="mk">本机API</em></strong>使我们能够访问文件系统。<strong class="lq ir"> <em class="mk"> setTimeout() </em> </strong>也是web<strong class="lq ir"><em class="mk">API</em></strong>的一部分，每个对<strong class="lq ir"> <em class="mk"> setTimeout() </em> </strong>的调用都是由<strong class="lq ir"> <em class="mk">浏览器的</em> </strong>(或<strong class="lq ir"><em class="mk">nodejs’</em></strong>)<strong class="lq ir">API</strong>处理的。</p><h2 id="0205" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">事件循环</h2><p id="f2c6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果你了解<a class="ae kv" href="https://stackoverflow.com/questions/34680985/what-is-the-difference-between-asynchronous-programming-and-multithreading/34681101" rel="noopener ugc nofollow" target="_blank"> <em class="mk">多线程</em> </a> <em class="mk"> </em>你会发现，除了将任务分配给其他线程，你还将负责协调所有线程的流程，以确保它们不会相互冲突。然而，JavaScript有一种漂亮的处理任务的方式，它从我们这里抽象出编排，并可预测地执行它们。</p><p id="86c5" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">每当我们遇到一个任务，它是我们之前谈过的<em class="mk"><strong class="lq ir"><em class="mk">API</em></strong>的一部分(</em><strong class="lq ir"><em class="mk">setTimeout()</em></strong><em class="mk">)</em>，它将这个任务委托给<strong class="lq ir"><em class="mk">API</em></strong>并且当这些任务完成时，传递给它们的回调是在<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">中排队的<a class="ae kv" href="https://www.geeksforgeeks.org/queue-data-structure/" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="mk"/></strong></a>下面的gif演示了这一点。</em></strong></a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/5f476ed0b1009f5746d1ea15c89153b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Cyh2ZyZwnY6PtnZE9VNL1Q.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">用回调队列和web APIs可视化异步代码编排。</figcaption></figure><p id="8d5f" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">希望这一点现在已经很清楚了。如果此时你感到迷茫，建议你看看<a class="ae kv" href="https://medium.com/front-end-weekly/javascript-event-loop-explained-4cd26af121d4" rel="noopener"> <em class="mk">这篇文章</em> </a> <em class="mk">。</em></p><p id="d587" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">现在，我们知道了同步和异步代码是如何执行的，但是这对我们意味着什么呢？</p><h2 id="f8c2" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">回调地狱</h2><p id="1bec" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">考虑下面的片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用用户名登录的异步代码。</figcaption></figure><p id="c0b0" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">第4–6行的注释解释了异步代码的问题。再看函数，取出数据的方法只有一个，我们要把它作为参数传递给另一个函数(<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Callback_function" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">一个回调函数</em> </strong> </a>)。下面演示了这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">回调函数正在运行。</figcaption></figure><p id="f03d" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">然而，这种方法有一个问题。想象一下，我们必须登录，获得我们所有的帖子，并获得对帖子的评论，然后获得对我们的帖子发表评论的用户。这不会是一个美丽的景象，我会告诉你:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">回调地狱！</figcaption></figure><p id="13f4" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">如果出于某种原因，我们仍然需要用我们得到的最后一个用户数据来执行这些指令，我们将最终在回调中嵌套回调，这变得非常难以管理。</p><h2 id="b4cf" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">承诺</h2><p id="2e24" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">根据<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="mk">MDN Web Docs</em></strong></a><strong class="lq ir"><em class="mk">，</em></strong>A<strong class="lq ir"><em class="mk">promise</em></strong>是在创建<strong class="lq ir"> <em class="mk"> promise </em> </strong>时不一定知道的值的代理。它允许您将处理程序与异步操作的最终成功值或失败原因相关联。这使得异步方法像同步方法一样返回值:异步方法不是立即返回最终值，而是返回一个<em class="mk">承诺</em>在将来的某个时间提供该值。</p><p id="13c2" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">一个<strong class="lq ir"> <em class="mk">的承诺</em> </strong>就是处于这些状态之一:</p><ul class=""><li id="95b0" class="nm nn iq lq b lr mx lu my lx no mb np mf nq mj nr ns nt nu bi translated"><strong class="lq ir"> <em class="mk">待定</em> </strong>:初始状态，既不履行也不拒绝。</li><li id="69fd" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated"><strong class="lq ir"> <em class="mk">完成</em> </strong>:表示操作成功完成。</li><li id="db90" class="nm nn iq lq b lr nv lu nw lx nx mb ny mf nz mj nr ns nt nu bi translated"><strong class="lq ir"> <em class="mk">拒绝</em> </strong>:表示操作失败。</li></ul><p id="3a16" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated"><strong class="lq ir"> <em class="mk">承诺</em> </strong>给了我们一种不同的(也更干净的)处理异步代码的方式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">承诺在行动</figcaption></figure><p id="517c" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">关于<strong class="lq ir"> <em class="mk">承诺</em> </strong> <em class="mk">的一个有趣的事情是</em> <strong class="lq ir"> <em class="mk">。然后是()</em> </strong> <em class="mk"> </em>的方法。因为它返回一个承诺，所以它是可链接的。因此，这意味着我们可以进行进一步的行动，承诺解决。</p><p id="4fd3" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">现在让我们看看是否可以从上一节中拯救(重构)我们的<em class="mk">回调绑定的</em> <strong class="lq ir"> <em class="mk"> </em> </strong>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们的异步调用被重构为使用承诺</figcaption></figure><p id="05aa" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">我试图向你证明，承诺提供了更好的语法，然后，“重构”的文件有更多的代码行🤦🏿‍♂️.实际上，我们模拟的流程将使用<a class="ae kv" href="https://scotch.io/tutorials/how-to-use-the-javascript-fetch-api-to-get-data" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir"><em class="mk">fetch API</em></strong></a><strong class="lq ir"><em class="mk"/></strong>以一种更简洁的方式进行处理，它向一个实际的API发送一个请求，并给我们一个承诺，该承诺用来自API的数据进行解析，或者用适当的错误消息<strong class="lq ir"> <em class="mk">拒绝。</em>T71】</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">回电vs承诺</figcaption></figure><p id="13aa" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">虽然我们对承诺带来的改进感到高兴，但如果我们能以更可读的同步方式编写代码，那不是很好吗？考虑下面的片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们都知道并喜爱的同步语法</figcaption></figure><p id="0248" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">想象一下，我们不需要嵌套回调，甚至不需要连锁承诺。这将极大地提高可读性，但是根据JavaScript调用堆栈的心理模型，这意味着<a class="ae kv" href="https://nodejs.org/uk/docs/guides/dont-block-the-event-loop/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">事件循环</em> </strong> </a>将被阻塞，直到登录解析，对吗？想象一下，获取用户登录数据需要10秒钟，这意味着我们的应用程序将在整个10秒钟内暂停。当我们收到帖子、评论，然后是创建评论的用户时，时间会很快累积起来，我们会让用户感到沮丧，再也不想使用我们的应用程序。但是如果我告诉你JavaScript给了我们某种形式的<a class="ae kv" href="https://en.wikipedia.org/wiki/Syntactic_sugar" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">语法糖</em></strong></a><strong class="lq ir"><em class="mk"/></strong>来同步编写异步代码呢？</p><h1 id="1ba9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">异步/等待</h1><p id="7780" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">JavaScript提供了一种特殊的语法，允许我们以一种不太复杂的方式处理承诺。</p><blockquote class="nd ne nf"><p id="c5ba" class="lo lp mk lq b lr mx jr lt lu my ju lw ng mz lz ma nh na md me ni nb mh mi mj ij bi translated">有一个不应该被忽略的警告，那就是我们只能对一个叫做异步函数的特殊类型的函数使用这个语法。</p></blockquote><h2 id="cf17" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">异步函数</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">异步函数。</figcaption></figure><p id="746e" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">使用如上所示的<strong class="lq ir"> <em class="mk"> async </em> </strong>关键字声明异步函数。关于异步函数的一个有趣的事情是，它们总是返回一个承诺。我们可以从一个异步函数中显式返回一个承诺，这将产生相同的效果。注意在上面的代码片段中，我们如何链接一个<strong class="lq ir"> <em class="mk"> then() </em> </strong>到<strong class="lq ir"> <em class="mk"> func() </em> </strong>函数调用。来自<strong class="lq ir"> <em class="mk"> func() </em> </strong>的返回值作为参数自动传递给<strong class="lq ir"><em class="mk">console . log()</em></strong>。</p><h2 id="ed6e" class="ml kx iq bd ky mm mn dn lc mo mp dp lg lx mq mr li mb ms mt lk mf mu mv lm mw bi translated">Await关键字</h2><p id="6bfb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">记住我们所说的常规同步JavaScript函数，它们总是在弹出调用栈之前运行完成。但是异步函数的行为完全不同。我们可以用<strong class="lq ir"> <em class="mk"> await </em> </strong>关键字暂停异步函数的执行。考虑下面的片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">演示JavaScript如何处理异步函数的代码片段</figcaption></figure><p id="7948" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">从这段代码的输出中，我们可以看到奇怪的行为。<strong class="lq ir"> <em class="mk"> first() </em> </strong>被调用，即使它还没有完成它的执行，程序继续执行<strong class="lq ir"> <em class="mk"> second()。</em>T47】</strong></p><p id="4ce0" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">为了理解这种行为，让我们来看看<strong class="lq ir"> <em class="mk">等待</em> </strong>关键字做什么。当遇到<strong class="lq ir"> <em class="mk"> await </em> </strong>关键字时，它会让解释器等待，直到承诺被解决(解决或拒绝)。这意味着在我们代码片段的第11  行<strong class="lq ir"> <em class="mk">上，函数执行暂停，直到它从<em class="mk"/><strong class="lq ir"><em class="mk">getCount()</em></strong><em class="mk"/>函数中获得一个值。显然，这模仿了我们都知道并且非常喜欢的同步代码风格。不同之处在于，我们不是阻塞调用堆栈，而是继续处理其他任务(<strong class="lq ir"> <em class="mk">)、第二个()</em> </strong>)，然后在完成所有其他未完成的任务后，返回完成第一个()</em> </strong>的执行。</p><p id="94cb" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">与<strong class="lq ir"> <em class="mk"> promise.then()相比，这只是一种更优雅的处理承诺的方式。</em> </strong>不仅读起来赏心悦目，写起来也轻松了很多。</p><p id="9e96" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">那么我们如何重构我们的代码库来使用<strong class="lq ir"> <em class="mk">异步/等待</em> </strong>语法呢？让我们再来看一个片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">我们的承诺被重构为使用异步/等待</figcaption></figure><p id="71ad" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">注意，我们必须将所有操作包装在一个异步函数<strong class="lq ir"><em class="mk">(async operations())</em></strong>中，我们所要做的就是调用<strong class="lq ir"> <em class="mk">异步函数</em> </strong>，我们所有的承诺将在函数中一个接一个地执行。</p><p id="0647" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">JavaScript语言现在的位置真的很有趣。过去完成起来像噩梦一样的任务现在已经被简化了，语法也不像以前那么可怕了。</p><p id="7d31" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">作为开发人员，在没有理解他们试图解决的问题的情况下就投入到我们工具的新特性中是不够的。我见过很多代码库，开发者在很多不需要的地方丢弃了<strong class="lq ir"> <em class="mk"> await </em> </strong>关键字。这可能会给我们的应用程序带来性能问题。</p><blockquote class="oc"><p id="7639" class="od oe iq bd of og oh oi oj ok ol mj dk translated">经验法则:如果脚本的执行不依赖于异步操作的结果，就不要等待。</p></blockquote><h1 id="46a8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw om jx li jz on ka lk kc oo kd lm ln bi translated">结论</h1><p id="71b0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文中，我们学习了JavaScript调用栈以及它如何执行任务。我们还了解到JavaScript引擎运行的环境(客户端的浏览器和服务器端的nodejs)为我们提供了<strong class="lq ir"><em class="mk">API</em></strong>，我们可以利用它们来编写更强大的代码。我们还了解到，回调只是噩梦般的处理，我们应该尽可能用承诺来代替。</p><p id="2961" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">需要注意的一件重要事情是，我们在示例中没有考虑可能的错误情况。这是不好的做法。异步流程不能保证成功。我们应该总是优雅地处理错误，而不是让它们爆发💣💥我们的准则。</p><p id="a4f0" class="pw-post-body-paragraph lo lp iq lq b lr mx jr lt lu my ju lw lx mz lz ma mb na md me mf nb mh mi mj ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>