<html>
<head>
<title>Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/recursion-3b3956eaffad?source=collection_archive---------6-----------------------#2020-09-22">https://levelup.gitconnected.com/recursion-3b3956eaffad?source=collection_archive---------6-----------------------#2020-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/65f48914006f25d1544025732d3ebe65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fl03sQq3uXrt7ruirEfBEg.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">超跳跃？或者只是堆栈内部溢出？</figcaption></figure><div class=""/><p id="c39f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">算法。一个听起来很美的词，立刻让你听起来好像你知道你在做什么。这个词过去常常让学生感到害怕(或高兴)。然而，算法只是程序员编写的一个函数。两行函数在技术上是一种算法。简单的求和函数就是一种算法。算法允许我们使用所有类型的数据结构来对数据执行操作。随着您的公司越来越大，您处理的数据也越来越多，在您的代码中有效地使用算法对于您公司的可伸缩性变得更加重要。算法允许你把你的大O复杂度变成更有效的复杂度。</p><blockquote class="la lb lc"><p id="f3ad" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><em class="jf">算法是描述如何执行任务的一套准则</em>。—加州大学洛杉矶分校的约翰·比利亚塞诺尔— <a class="ae lh" href="https://slate.com/technology/2016/02/whats-the-deal-with-algorithms.html" rel="noopener ugc nofollow" target="_blank">链接</a></p></blockquote></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="e79d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好吧，那么什么是递归？函数直接或间接调用自身的过程称为递归，相应的函数称为递归函数。<a class="ae lh" href="https://www.geeksforgeeks.org/recursion/" rel="noopener ugc nofollow" target="_blank">链接</a>。本质上，递归函数在函数内部调用自己。</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lp"><img src="../Images/7d3a4633ac4213392c66f4fbd510b4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bt4pCnQyoyPBLe81IadjRQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">这是一个递归函数</figcaption></figure><p id="9e21" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">递归是常用的，在Javascript中，当一个对象嵌套在另一个对象中时，就会用到递归。</p><p id="da8c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是上面的函数是做什么的呢？这个算法让我更多地了解了一个我并不太熟悉的问题。堆栈溢出。</p><p id="e7c0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">什么是堆栈溢出？</p><p id="8584" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当你第一次开始编码时，我敢肯定你以前在你的控制台中遇到过这个屏幕。</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lu"><img src="../Images/04c5f24c220942ea4806262f7eccdc49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qFsW4J_mmI0H83Pz6Jr1TA.png"/></div></div></figure><p id="bf49" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一种保障。它不是通过不断地一遍又一遍地调用这个函数来使浏览器崩溃，而是在到达一个极限时自动停止。</p><p id="91e4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们在内部recursiveFunction调用上面的行中添加一个调试器，它会将您带到我们的调试器控制台。如果我们使用从左到右的小箭头点击函数，我们的堆栈将会增加，每次增加一个新的递归函数。</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lv"><img src="../Images/ffd42f25cef77868e49e2f7aefa569f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPBLQZarlf-4sBmtiQ8zMA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">当我点击它时，我每次都添加到我们的调用堆栈中</figcaption></figure><p id="66a3" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本质上，我们耗尽了内存，堆栈溢出！所以递归的一个缺点是，我们可能会一遍又一遍地运行一些东西，当我们在堆栈中持有每个被调用的函数时，就会占用内存。</p><p id="cfa6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们知道了递归是如何工作的，它是将一个函数调用叠加到下一个函数调用上，你认为这个函数的结果会是什么？</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lp"><img src="../Images/f4a811ce3a69ab855b887c8b80b113f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HdHruyXyQQx9bGBRMiQ7A.png"/></div></div></figure><p id="cc8b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">等一下。我们的柜台变成了4…但是还没有完成吗？为什么？这就是我们之前在控制台中看到的筹码发挥作用的地方。</p><p id="989e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们在浏览器中再看一遍。你会看到，当我们计数到4时，我们的值确实表示“完成！”。然而，当我们继续播放递归函数时，它开始从栈顶弹出。</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lw"><img src="../Images/1491670816692f9873dd444cc90252ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u57EA05t2TNNtC19VJedUQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">这里我们的计数器是4，所以我们应该完成！</figcaption></figure><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lw"><img src="../Images/0d86e7986752f51bc3943551a28f436d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PqT7Bxy9fYxWfIhVrC1jAQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">完美！让我们继续点击我们的功能</figcaption></figure><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lw"><img src="../Images/49d402b48571dee3ca0369fc737eb188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqbQjwZzxYuYlt4OCJnUcg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">这里是堆栈中的最后一个函数调用！但是我们的返回函数在哪里呢？！</figcaption></figure><p id="0648" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是为什么呢？好吧，如果我们分解我们的堆栈，这就是它看起来的样子。</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lx"><img src="../Images/1ce397f363e4b844f99bc610351b0677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t-10i3FxX7yFuaXdsSpDbA.png"/></div></div></figure><p id="717f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，我们可以通过简单地添加一个额外的返回，使用冒泡技术简单地解决这个问题。</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lp"><img src="../Images/4712a2ac46c2df50a38acb6a866ab9d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MxJBOMAGKV8ecK7Cy0Y24g.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">这将显示“完成！”一旦你到了4。</figcaption></figure><p id="a344" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就把我们带到了由<a class="ae lh" href="https://runestone.academy/runestone/books/published/pythonds/Recursion/TheThreeLawsofRecursion.html" rel="noopener ugc nofollow" target="_blank"> Runestone </a>提出的递归的3个法则上:</p><ol class=""><li id="3ccd" class="ly lz jf ke b kf kg kj kk kn ma kr mb kv mc kz md me mf mg bi translated">递归算法必须有一个<strong class="ke jg">基案例。</strong>(我们的if语句)。</li><li id="8ee3" class="ly lz jf ke b kf mh kj mi kn mj kr mk kv ml kz md me mf mg bi translated">递归算法必须改变其状态，并向基本情况移动。(2返回朝向返回“完成！”)</li><li id="52f8" class="ly lz jf ke b kf mh kj mi kn mj kr mk kv ml kz md me mf mg bi translated">递归算法必须递归地调用自身。(调用自身内部的函数)。</li></ol></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="08b6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好了，我们把学习放到一个常见的问题里。这个词是回文吗？(从后到前读起来一样吗？例如赛车)。</p><figure class="lq lr ls lt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mm"><img src="../Images/3e2622b83a28df1416ec297ad844a13c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SyuvRyc2rs8z9nU0awcnZA.png"/></div></div></figure><p id="f599" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以，我们在这里做的是设置我们的基数，也就是如果我们的word.length等于0，或者1(因为这取决于单词的长度是奇数还是偶数)。如果是这样，这意味着我们已经到达了我们的基地，这个词必须是一个回文。</p><p id="b9b5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，如果我们的长度还不是0或1，我们就进入改变状态的第二定律。如果第一个元素等于最后一个元素，那么它们匹配！这意味着我们可以再次返回我们的函数，但是这次我们去掉了第一个和最后一个字母(因为我们刚刚确认它们是相同的)。然后返回到顶部，检查我们的基本if函数。</p><p id="73ac" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，如果我们输入ispalindome(' dog ')，函数会发现第一个和最后一个元素不匹配，因此返回false！</p><p id="a0b7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是递归函数的一个很好的用途！</p></div></div>    
</body>
</html>