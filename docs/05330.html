<html>
<head>
<title>How I Organize API Files in my Flutter Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在我的Flutter项目中组织API文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-organize-api-files-in-my-flutter-project-8f21c17050df?source=collection_archive---------0-----------------------#2020-08-20">https://levelup.gitconnected.com/how-i-organize-api-files-in-my-flutter-project-8f21c17050df?source=collection_archive---------0-----------------------#2020-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0a01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个解释会很长很复杂，所以如果你想直接看到代码库，你可以在这里看到它:</p><div class="ko kp gp gr kq kr"><a href="https://github.com/blackmenthor/flutter_project_boilerplate/tree/master/lib/core/api" rel="noopener  ugc nofollow" target="_blank"><div class="ks ab fo"><div class="kt ab ku cl cj kv"><h2 class="bd iu gy z fp kw fr fs kx fu fw is bi translated">black ment hor/flutter _ project _ boilerplate</h2><div class="ky l"><h3 class="bd b gy z fp kw fr fs kx fu fw dk translated">在GitHub上创建一个帐户，为black mentor/flutter _ project _ boilerplate开发做出贡献。</h3></div><div class="kz l"><p class="bd b dl z fp kw fr fs kx fu fw dk translated">github.com</p></div></div><div class="la l"><div class="lb l lc ld le la lf lg kr"/></div></div></a></div><p id="d532" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">市场上几乎所有的应用程序都使用外部数据源(也就是互联网)并向其发送数据。虽然有些应用程序依赖本地数据库来保存和获取数据以显示给用户。这在移动编程中是相当容易的，因为对于全球的移动程序员来说，这是一个非常基本的话题，通常我们在学习移动编程框架本身的时候就会学到这一点。</p><p id="7af5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于小项目来说，这可能没什么大不了的，因为应用程序中使用的API调用很少。但是，如果应用程序大量使用并发送来自互联网的数据，会怎么样呢？当然，这带来了一个问题，尤其是如果代码库是由多个程序员处理的话。随着越来越多的程序员处理代码并向代码库写入代码，我们必须有一个标准化来使事情变得清晰并以正确的顺序进行。</p><p id="ecc9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，在为Flutter app设计API层的时候，我们应该考虑到什么呢？我试图列出在为Flutter设计API层之前需要考虑的所有事情</p><ul class=""><li id="cad2" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated">API层必须给UI层适当的抽象。</li><li id="50f7" class="lh li it js b jt lq jx lr kb ls kf lt kj lu kn lm ln lo lp bi translated">API层必须将所有的API响应转换成一个普通的dart对象，这样UI就可以直接消费它。</li><li id="8c5d" class="lh li it js b jt lq jx lr kb ls kf lt kj lu kn lm ln lo lp bi translated">API层必须能够自己管理会话，因此UI部分不应该负责管理会话。</li></ul><p id="9e45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑到这些因素后，这就是我在专业项目中经常使用的API层的形状。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="87f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们从API层将使用的组件开始，我将用一个简单的图表来说明这一点</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/9b1ba9153ea93cf999d412f36c3f8dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:242/format:webp/1*aotM91SiDM8BUDyY3Ce2zw.png"/></div></figure><p id="ac77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么那些组件是什么意思呢？</p><ul class=""><li id="3423" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated">先说互联网。</li></ul><p id="8544" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我们需要从设备外部获取的“互联网”或外部数据。这可以是任何通信方式，REST API，Websockets，文件下载/上传，任何东西。</p><ul class=""><li id="37cd" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated">接下来，我们从AuthApiClient开始。这是什么？</li></ul><p id="af57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数现代应用程序都需要用户登录/注册到应用程序的系统(后端)，这意味着大多数API调用都需要由系统进行验证。一个简单的例子是这样的:假设你正在开发一个电子商务应用程序，你不希望看到用户A以其他人(用户B)的身份买卖东西，对吗？</p><p id="893a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，这个AuthApiClient将处理所有关于用户身份验证和对需要它的其他组件的授权的通信。例如，如果我们需要某个页面上的用户信息，这就是您正在寻找的组件。</p><p id="b41f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于后端认证的更多信息，你可以在这里阅读<a class="ae mj" href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2" rel="noopener ugc nofollow" target="_blank">https://www . digital ocean . com/community/tutorials/an-introduction-to-oauth-2</a></p><ul class=""><li id="90f8" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated">接下来，我们得到ApiClient。</li></ul><p id="43d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么ApiClient和AuthApiClient有什么区别呢？好的，所以基本上它们是“相同”的东西，可以用于几乎相同的东西。但是责任是ApiClient和AuthApiClient的主要区别。</p><p id="61d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ApiClient将从用户的角度负责更实际的用例，例如当我们必须调用一个API来创建一个新的电子商务交易时，这就是你所需要的。</p><p id="6a9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而AuthApiClient将只负责与认证相关的用例。大多数情况下，用户只会在登录和注册应用程序内部的流时与该组件“交互”。但是这个组件总是在幕后工作，为其他组件提供与身份验证相关的数据。</p><p id="9220" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ApiClient将从API获取原始信息，并将原始信息发送到API，并对其进行处理，直到准备好供UI使用(在普通的Dart对象表单上)。因此，这将包括您为应用程序选择的任何数据解析机制。或多或少，这是API层本身的核心。</p><p id="ec32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，值得一提的是，ApiClient需要一个AuthApiClient才能正常运行。因为出于安全原因，现代移动应用程序中的大多数操作都需要身份验证数据。这是我把这两个分成不同部分的另一个原因。</p><ul class=""><li id="00a5" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated">接下来是ApiController。</li></ul><p id="15e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然ApiClient将为用户界面提供现成的数据，但是用户界面层不应该直接与API层通信。主要是因为API层内部有很多逻辑，UI不应该知道太多。</p><p id="ad31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是为什么我在这里为UI创建了另一个抽象层，称为ApiController。因此，基本上ApiController将负责创建对ApiClient的请求，在最适合用例的客户端之间切换。</p><p id="259c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，UI层不应该知道API调用背后的太多逻辑，它需要做的只是告诉ApiController它需要什么(获取最新数据、发送登录信息等)，ApiController应该完成剩下的工作。</p><ul class=""><li id="1647" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated">最后，是用户界面层。</li></ul><p id="1a52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是用户在应用程序中直接交互的界面。例如(按钮被点击、拉至刷新窗口小部件被触发等)。这只与ApiController通信，不多也不少。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="870d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，文件夹看起来像这样:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/f9897e4cb66b6eb20557aa0e6dd24d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*YHXzCVvnMb_U6vr76wHsOQ.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">Api层文件夹</figcaption></figure><p id="2442" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们有两个顶层文件夹，它们是Api和控制器。除了ApiController类之外，大多数Api层文件都放在Api文件夹中。</p><p id="137a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们需要定义Api层的请求和响应基类。这是必要的，因为我们需要将来自互联网/外部来源的所有信息转换为一个Dart对象。</p><p id="1970" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，对于所有Api响应，不管它是否是一个错误，我们都将它们转换成一个Api response类。实现将如下所示</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/a2faa15078ba2ac32989eeec273f5bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQOQvjSriui57pcAeBSm1w.png"/></div></div></figure><p id="e06b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个类将包含我们从后端收到的响应的JSON表示，以及原始API响应的HTTP状态代码(如果不使用HTTP，可能不需要这个)。</p><p id="4542" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是RequestObject和ResponseObject类，它将是所有保存API响应结果的普通Dart对象的基类。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/635e6658e0f3648b489276a1c4a89e75.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*N2FpDK6RHuSOdPr9WGIx_g.png"/></div></figure><figure class="md me mf mg gt mh gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/34b17d5c63c38c548592bbe1c9888a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*caMpXahWWewQCSnBqU8l1g.png"/></div></figure><p id="0511" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个抽象类是一个非常简单的类，我们需要它，所以如果将来我们需要在响应/请求对象上添加新的功能，我们可以只在这个基类上添加抽象方法，所有的子类都需要跟随。</p><p id="4822" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，这是最重要的部分，ApiClient类。这个类包含了很多方法，因为我们需要在一个REST API中支持很多Api方法(GET、POST、PUT、PATCH等)。所以我只针对GET方法进行说明。</p><p id="bc1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们将对HTTP库使用Dio，因为它非常非常实用，而且几乎所有的REST API方法都是现成的。即使是下载和上传文件。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mw"><img src="../Images/7b6d05097586ae66bf11f1cf322ec9dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d4Jgr2w0CL7fc3IB3LZI5Q.png"/></div></div></figure><p id="4161" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，让我们从Dio声明开始，理想情况下，它应该被注入到ApiClient中，这样就可以很容易地对它进行模拟测试，但是我现在跳过了这一部分。</p><p id="daca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们声明ApiClient需要的所有参数，它们是:</p><ul class=""><li id="ace1" class="lh li it js b jt ju jx jy kb lj kf lk kj ll kn lm ln lo lp bi translated">ApiKey(您的后端需要Api Key来确保HTTP请求来自您的应用程序，而不是来自恶意来源)</li><li id="baf8" class="lh li it js b jt lq jx lr kb ls kf lt kj lu kn lm ln lo lp bi translated">BaseURL(后端系统的基本URL)</li><li id="4d39" class="lh li it js b jt lq jx lr kb ls kf lt kj lu kn lm ln lo lp bi translated">记录器(这是不需要的，但这将是方便的记录所有的请求和响应，我们得到了所有的记录器机制，在应用程序中使用)</li></ul><p id="03c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是buildUrl方法:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mx"><img src="../Images/fa170451321dde261a4004215f8dbf00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eL6Gckca1rsekL2W_Q4AVw.png"/></div></div></figure><p id="3e01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法基本上是将应用程序所需的每个端点附加到后端系统的基本URL上，并在需要时在请求上添加queryparams。</p><p id="4e80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后构建Headers方法。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi my"><img src="../Images/f5bfa3bb1e03135533f1a086a0598ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKNIiaBJ-Fm9FOB1e6seMQ.png"/></div></div></figure><p id="9e5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该函数将添加后端所需的任何HTTP请求头，通过添加授权令牌和API密钥来识别HTTP请求是否来自正确的来源。你也可以根据自己的需要在这里添加更多的基本标题。</p><p id="1c17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是handleResponse方法。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mz"><img src="../Images/1c390f42aa7e39bb30aa05854a65b415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mfSTZkNY3Sf0efd2Vl3sew.png"/></div></div></figure><p id="ee83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以这个方法将通过Dio(我使用的HTTP实现)解析原始的响应类，并将其转换为ApiResponse或ApiError(我们自己的保存API响应的Dart对象)。</p><p id="a3cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，序列化不是在这个函数中完成的，因为我们只将信息保存到ApiResponse中的映射<string dynamic="">中。</string></p><p id="43e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">序列化之后，我们将得到一个普通的Dart对象，它描绘了一个真实世界的域，类似于<code class="fe na nb nc nd b">Car</code>、<code class="fe na nb nc nd b">Person</code>等。</p><p id="6ee9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来是ApiClient的GET方法。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9eee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是神奇之处，因此这个方法将编译您对某个端点发出的请求，使用某些查询参数(如果需要)，并从Dio调用GET方法的实际实现，并将其转换为类似于<code class="fe na nb nc nd b">Car</code>或<code class="fe na nb nc nd b">Person</code>的实际Dart对象。</p><p id="fe39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是你可能在这里看到了一个遗漏的解释，get函数中的序列化参数是什么意思？</p><p id="783e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我创建了一个名为Serializer的简单函数定义，它将由每个Dart对象实现，这些对象将代表来自Api响应的实际对象，类似于<code class="fe na nb nc nd b">Car</code>或<code class="fe na nb nc nd b">Person</code>。</p><p id="70a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，参见下面的<code class="fe na nb nc nd b">SessionResponse</code>类:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="f4c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我用json_annotation包把json解析成一个Dart对象(这里可以用自己的选择进行json解析，没有对错)。</p><p id="1746" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我创建了一个名为<code class="fe na nb nc nd b">serializer</code>的简单getter，它将返回一个静态函数，该函数将解析Map &lt;字符串，在本例中是将动态&gt;解析为<code class="fe na nb nc nd b">SessionResponse</code>。</p><p id="8b85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此ApiClient将只接收如何将从Api接收的Json对象解析成普通dart对象的实现。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d604" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，如何用这个客户端实现一个实际的Api？</p><p id="7b45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这很简单，所以首先，对于AuthApiClient(我将这个Api组件从通用ApiClient中分离出来)，实现将如下所示:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ng"><img src="../Images/8ba767f5fb143407bf122010239edcad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-HRwe-42ufu8xZ4AshL0w.png"/></div></div></figure><p id="c698" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们将从ApiClient类扩展这个类，从ApiClient类扩展所有参数。为了创建请求(例如，登录请求)，我们只需要创建一个端点、一个请求对象(基于后端的需求)，并定义一个序列化程序来解析Json。</p><p id="d303" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，对于此AuthClient的ApiController，定义如下:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nh"><img src="../Images/99a3d9ed6b0b8b577d7da1b37ee3ce7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gYbIqaeQr-4_zzaCw4heeQ.png"/></div></div></figure><p id="f490" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将注入AuthClient、logger(不需要)，然后我们将创建一个登录函数，该函数将从AuthClient实际调用登录实现。这将由UI层直接调用。</p><p id="e92f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其他Api客户端呢？将用于一般用例的那个。它看起来会像这样:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c60a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，与AuthClient相比，这个GeneralClient将多一个参数，即SessionController。如果我们想要向请求添加授权令牌(例如<code class="fe na nb nc nd b">fetchDummy</code>请求)，这将是需要的。除此之外，与AuthClient相比，它的实现基本相同。</p><p id="24e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这个ApiController，它看起来像这样:</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3ca2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或多或少，auth controller/session controller实现也是如此。这将由UI层直接调用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f2a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，最后一件要做的事情是，我将把所有的ApiClients分组到一个Api类中。这是必需的，这样我们就可以在这里组织所有的客户端，我们只需要调用factory <code class="fe na nb nc nd b">Api.create</code>语法来基于某些参数(Api键、基本URL、日志程序和会话控制器)初始化所有的Api客户端</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8070" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">瞧啊。我们刚刚从头开始为我们的Flutter项目做了一个完整的Api层&amp;这将涵盖我们的应用程序与后端通信以获取和发送数据所需的几乎所有基本功能。</p><p id="934e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我知道这很难一下子完成，但是我希望如果你打算用Api调用之类的东西开始你的Flutter项目，这将会很有用。</p><p id="d93c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像往常一样，如果你有任何问题，你可以在anggadwiarifandi96@gmail.com问我</p><p id="66b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">谢谢你，祝你愉快。注意安全！</p></div></div>    
</body>
</html>