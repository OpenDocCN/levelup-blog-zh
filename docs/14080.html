<html>
<head>
<title>How to use Intersection Observer API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用交叉点观察器API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-intersection-observer-api-with-a-directive-e86f0253c207?source=collection_archive---------3-----------------------#2022-10-31">https://levelup.gitconnected.com/how-to-use-intersection-observer-api-with-a-directive-e86f0253c207?source=collection_archive---------3-----------------------#2022-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cc6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是什么，如何用实际例子来使用它，为什么它很棒！😎</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/b9d71edd8031a4f24cf03ab7cb24089e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omcyigOYKUeTSxxbtXDf9Q.png"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="9fd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我真的很兴奋告诉你这个！</p><p id="637c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">交集观察器API </a>提供了一种异步观察目标元素与祖先元素或顶层文档的<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Glossary/Viewport" rel="noopener ugc nofollow" target="_blank">视窗</a>交集变化的方法。</p><blockquote class="lf lg lh"><p id="30a9" class="jn jo li jp b jq jr js jt ju jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj kk ij bi translated">历史上，检测元素的可见性或两个元素相对于彼此的相对可见性一直是一项困难的任务，其解决方案不可靠，并且容易导致浏览器和用户正在访问的网站变得缓慢。随着网络的成熟，对这类信息的需求也在增长。</p></blockquote><p id="a5d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管这篇文章举例说明了如何在Angular框架中实现这一点，但是这些知识对于任何框架都是极好的。这是一个Web API，所以如果你的东西在浏览器中运行，你可以使用交叉点观察器API！还有很多更酷的API在外面<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API" rel="noopener ugc nofollow" target="_blank">【1】</a>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lm"><img src="../Images/48c7203881dfac58c5ad75156496d483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ax1jXhNu9rNMiZELZZ_xg.png"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="2f57" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">为什么这很酷？😎</h1><p id="6fa5" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">通常，当我们想要检测我们何时看到某物(或者我们看到了多少)——我们倾向于查询元素，然后询问它们的坐标。通过结合滚动事件从边界框中读取坐标，并通过一些计算，我们得出我们所看到的结论。类似这样的<a class="ae le" href="https://stackoverflow.com/questions/9607252/how-to-detect-when-an-element-over-another-element-in-javascript" rel="noopener ugc nofollow" target="_blank">【2】</a>或者那样的<a class="ae le" href="https://stackoverflow.com/questions/46822870/how-to-detect-if-one-div-touches-another-div" rel="noopener ugc nofollow" target="_blank">【3】</a>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mq"><img src="../Images/4ddb8b7e7f5ed3d043b7082c32046360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a9CLyDmGYItsRUwtxgUNXA.png"/></div></div></figure><p id="d04e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为JS是在单线程上运行的，所以代价可能会很高。随着元素数量的增加，花费在查询和计算上的资源也在增加。</p><p id="28a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用交叉点观察器API，相同的典型计算被抽象到API<a class="ae le" href="https://github.com/GoogleChromeLabs/intersection-observer/blob/main/intersection-observer.js#L542" rel="noopener ugc nofollow" target="_blank">【4】</a>中。您得到的是一个漂亮的JSON，其中包含有观察者观察的元素的位置和交叉点的数据。不需要询问数据，API可以通过Observables直接给你。</p><p id="d0bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我并不是说交叉点观察器API将会取代一切，但它更具性能<a class="ae le" href="https://css-tricks.com/an-explanation-of-how-the-intersection-observer-watches/#aa-performance-intersection-observer-versus-scroll-events" rel="noopener ugc nofollow" target="_blank">【5】</a>，也许只是你知识库中的又一个工具。</p><h2 id="3e38" class="mr lo iq bd lp ms mt dn lt mu mv dp lx jy mw mx mb kc my mz mf kg na nb mj nc bi translated"><strong class="ak">更少的开销，更高的性能。</strong></h2></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="91a7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">简而言之，它是如何工作的？🤔</h1><p id="9178" class="pw-post-body-paragraph jn jo iq jp b jq ml js jt ju mm jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">你用<code class="fe nd ne nf ng b">observe()</code>将元素传递给交集观察者API，用<code class="fe nd ne nf ng b">unobserve()</code>或者<code class="fe nd ne nf ng b">disconnect()</code>观察移除它们。</p><p id="2d4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">可以观察到两件事。</strong>目标元素与设备的视窗或指定元素相交。出于交叉点观察器API的目的，该指定元素被称为根元素。</p><p id="dced" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">API负责跟踪您传递给它的元素。交叉点观察器API进行回调，并为您提供大量关于交叉点的元数据(包括<code class="fe nd ne nf ng b">boundingClientRect</code>)。它相交了多长时间(<code class="fe nd ne nf ng b">time</code>)、相交了多少百分比(<code class="fe nd ne nf ng b">intersectionRatio</code>)等等...</p><h2 id="3ebd" class="mr lo iq bd lp ms mt dn lt mu mv dp lx jy mw mx mb kc my mz mf kg na nb mj nc bi translated">API跟踪元素并发出更新。</h2></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="88c7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">如何实施？</h1><h2 id="760b" class="mr lo iq bd lp ms mt dn lt mu mv dp lx jy mw mx mb kc my mz mf kg na nb mj nc bi translated">指示的</h2><blockquote class="lf lg lh"><p id="7903" class="jn jo li jp b jq jr js jt ju jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj kk ij bi translated">用属性指令改变DOM元素和角度组件的外观或行为。</p></blockquote><p id="2421" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，您可以构建自己的基于API返回数据发出值的方法。我们使用指令<a class="ae le" href="https://angular.io/guide/attribute-directives" rel="noopener ugc nofollow" target="_blank">【6】</a>将观察者附加到元素上。该指令然后发出信息。我们消费这些信息，并根据这些信息做出一些反应。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/a609f422590319c8dc2a0c9ab5705bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ShnamK-v7TB8V59MPTo0mg.png"/></div></div></figure><p id="5729" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以在服务中或通过Decorators使用交叉点观察器API。但是指令方法的美妙之处在于它被应用到你附加它的地方。此外，当元素被破坏时，交叉点观察器API也会被破坏——这意味着没有泄漏！</p><h2 id="a195" class="mr lo iq bd lp ms mt dn lt mu mv dp lx jy mw mx mb kc my mz mf kg na nb mj nc bi translated">可以以多种方式使用和实现。</h2></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="e203" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">可能性#1:目标元素与设备的视口相交。无限滚动和动画。</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/6ab67dc98925ec5332b37d6075a7e625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LED59Lec3GtkZ-6JLNZfmQ.png"/></div></div></figure><p id="df55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，使用交叉点观察器API，我们将:</p><ol class=""><li id="136a" class="nj nk iq jp b jq jr ju jv jy nl kc nm kg nn kk no np nq nr bi translated">根据用户是否会看到结果来执行任务或动画过程；</li><li id="52a7" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated">进入/退出动画；</li><li id="25da" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated">无限滚动——数据的惰性加载；</li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nx"><img src="../Images/c66edd7d55d07ac07c7cb885f21b4e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*X5NmnNXrmKrUs07t1wmexQ.gif"/></div></div></figure><p id="09a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可在<a class="ae le" href="https://stackblitz.com/github/Nurech/intersection-observer-example?file=src%2Fapp%2Fdirectives%2Fintersection-observer.directive.ts" rel="noopener ugc nofollow" target="_blank"> StackBlitz </a>上查看示例。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="bff2" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">可能性#2:一个目标元素与另一个元素相交。</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ny"><img src="../Images/075c165408565378ce7ad9f921156742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9dIsQKhPC4psYK53i3sYg.png"/></div></div></figure><p id="6843" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，使用交叉点观察器API，我们将:</p><ol class=""><li id="c671" class="nj nk iq jp b jq jr ju jv jy nl kc nm kg nn kk no np nq nr bi translated">高速率求交比(但只在1%的变化上)。</li><li id="026a" class="nj nk iq jp b jq ns ju nt jy nu kc nv kg nw kk no np nq nr bi translated">更改色调以反映相交率。</li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nz"><img src="../Images/a3ed8f06fe1c213113eb1e372ec25b14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2ePhCAtDQEjnkKCjZsc8bg.gif"/></div></div></figure><p id="5941" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">交叉点观察器API不能告诉你重叠的像素的确切数目或者具体是哪些像素；然而，它涵盖了更常见的用例“如果它们相交于大约<em class="li"> N </em> %,我需要做些什么。”</p><p id="3767" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是想象一些拖放动作。</p><p id="34f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可在<a class="ae le" href="https://stackblitz.com/github/Nurech/intersection-observer-example?file=src%2Fapp%2Fdirectives%2Fintersection-observer.directive.ts" rel="noopener ugc nofollow" target="_blank"> StackBlitz </a>上查看示例。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="e6dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该指令可以在下面的要点中看到，在<a class="ae le" href="https://github.com/Nurech/intersection-observer-example" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中，或者在<a class="ae le" href="https://stackblitz.com/github/Nurech/intersection-observer-example?file=src%2Fapp%2Fdirectives%2Fintersection-observer.directive.ts" rel="noopener ugc nofollow" target="_blank"> Stackblitz </a>上直播。</p><p id="132f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！👏👏👏</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div></div>    
</body>
</html>