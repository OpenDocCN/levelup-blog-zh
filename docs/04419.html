<html>
<head>
<title>What is “effect” or “effectful” mean in Functional Programming?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程中的“effect”或“effective”是什么意思？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-effect-or-effectful-mean-in-functional-programming-7fc7323b52b4?source=collection_archive---------11-----------------------#2020-06-25">https://levelup.gitconnected.com/what-is-effect-or-effectful-mean-in-functional-programming-7fc7323b52b4?source=collection_archive---------11-----------------------#2020-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2aa2cf0a1ae13b8d6e50ebcc40dc0c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vDDK0EQPc24TxL5I"/></div></div></figure><p id="12ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多时候，当我们讨论效果时，我们通常会谈到副作用。然而，随着我对函数式编程越来越深入的研究和阅读越来越多的函数式编程书籍，我注意到在描述抽象事物时,“Effect”或“effective”在FP社区中被广泛使用了很多次。</p><p id="9882" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我对“效果”或“有效果的”的含义做了更深入的挖掘，并把它写在这篇博文里，作为对未来自己的一个提示。</p><h1 id="915d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">这不是副作用</h1><p id="f2a6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">通常，他们所说的“效果”或“有效”是没有副作用的(有时会有副作用)。这是<em class="lz">的主要效果</em>。</p><h1 id="de41" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">这与类型类别有关</h1><p id="1f61" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">类型类别是一种数学结构，用于抽象出数学中所有不同领域的表示。在设计程序时，我们可以在编写代码之前考虑程序的属性，而不是反过来。比如一个函数<code class="fe ma mb mc md b">sum</code>可以为空(同一律)，具有组合运算的性质，需要结合律。(1+2等于2+1)。我们可以将它们刻画为并将输入函数限制为一个<em class="lz">幺半群</em>。这样，我们可以用系统化的方法创建一个解决方案，产生更少的错误。</p><p id="7df5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“在类型范畴内”是一个时髦的词，指的是对给定类型产生“效果”的包装器。我将引用Alvin Alexander在<a class="ae me" href="https://www.amazon.com/Functional-Reactive-Domain-Modeling-Debasish/dp/1617292249/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=sl1&amp;tag=devdaily-20&amp;linkId=031fc4db53f522208ba4bbea056be0f8&amp;language=en_US" rel="noopener ugc nofollow" target="_blank"> <em class="lz">功能和反应域建模</em> </a>中提到的陈述:</p><ol class=""><li id="a118" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated"><em class="lz">选项</em>模拟可选性的影响</li><li id="2ec9" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><em class="lz">未来</em>将延迟建模为一种效果</li><li id="5df9" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><em class="lz">尝试</em>抽象失败的后果</li></ol><p id="ba7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些语句可以重写为:</p><ol class=""><li id="72b7" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated"><em class="lz"> Option </em>是一个<em class="lz">单子</em>，它对可选性的效果进行建模</li><li id="3eac" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><em class="lz"> Future </em>是一个<em class="lz"> monad </em>来模拟延迟的影响</li><li id="49c6" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><em class="lz"> Try </em>是一个<em class="lz">单子</em>，它对失败的影响进行建模(将异常作为一种效果进行管理)</li></ol><p id="077b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类似地:</p><ol class=""><li id="ccb7" class="mf mg iq ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">Reader是一个<em class="lz">单子</em>，它基于一些输入来模拟堆肥操作的效果。</li><li id="dc9f" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">Writer是一个<em class="lz">单子</em>，它模拟日志记录的影响</li><li id="3170" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">状态是一个<em class="lz">单子</em>，对状态的影响进行建模</li><li id="ddb8" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">Cats中的sync-effect是一个<em class="lz">单子</em>，它模拟了同步延迟执行的效果。</li></ol><h1 id="5ee6" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">这是F[A]而不是A</h1><p id="d734" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">单子处理的东西可以说是有影响的。</p><p id="6923" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">引用Rob Norris在《带效果的函数式编程》中的话——一个有效的函数返回<code class="fe ma mb mc md b">F[A]</code>而不是<code class="fe ma mb mc md b">A</code>。</p><p id="1344" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如:</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c0b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过查看上面的代码，我们知道无需深入代码，该函数就可以根据输入类型返回一些异常或整数。通过显式声明你的函数可以返回什么效果，其他调用<code class="fe ma mb mc md b">division</code>的任务将需要提供一种机制来处理那些“效果”类型，使你的程序具有确定性。</p><blockquote class="mz"><p id="398a" class="na nb iq bd nc nd ne nf ng nh ni kv dk translated"><em class="nj">“我不记得在哪里读到的，但是有人说，如果你要从哲学上思考，当一个函数返回一个A的时候，那个A已经被充分求值了；但是如果这个函数返回F[A],那么这个结果还没有被完全计算，A仍然在F[A]里面等待计算。因此，有效函数不是编写一个返回原始类型的函数，而是在一个有用的包装器中返回一个原始类型——其中包装器是一个单子，允许结果以单子的形式使用(例如，在Scala for-expression中)。”</em></p><p id="0616" class="na nb iq bd nc nd ne nf ng nh ni kv dk translated"><em class="nj">——阿尔文·亚历山大</em></p></blockquote><h1 id="39ee" class="kw kx iq bd ky kz la lb lc ld le lf lg lh nk lj lk ll nl ln lo lp nm lr ls lt bi translated">摘要</h1><ul class=""><li id="7e26" class="mf mg iq ka b kb lu kf lv kj nn kn no kr np kv nq ml mm mn bi translated">Effect也可以指程序的“主要效果”。</li><li id="242b" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv nq ml mm mn bi translated">而不是考虑副作用，而副作用是单子处理的。</li><li id="0567" class="mf mg iq ka b kb mo kf mp kj mq kn mr kr ms kv nq ml mm mn bi translated">一个“有效的”函数返回一个<code class="fe ma mb mc md b">F[A]</code>而不是<code class="fe ma mb mc md b">A</code></li></ul><h1 id="7263" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">来源</h1><p id="c030" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae me" href="https://alvinalexander.com/scala/what-effects-effectful-mean-in-functional-programming/#:~:text=As%20mentioned%2C%20rather%20than%20thinking,monad%20that%20you're%20using%3A&amp;text=Reader%20is%20a%20monad%20that%20models%20the%20effect%20of%20composing,models%20logging%20as%20an%20effect" rel="noopener ugc nofollow" target="_blank">效果或“有效”类型</a></p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="a290" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lz">最初发表于</em><a class="ae me" href="https://edward-huang.com/functional-programming/scala/monad/2020/06/21/what-is-effect-or-effectful-mean-in-functional-programming/" rel="noopener ugc nofollow" target="_blank"><em class="lz">https://edward-huang.com</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>