<html>
<head>
<title>React Native Events in Gory Details: What Happens on the Way to Listeners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以血淋淋的细节反应本地事件:在听众面前发生了什么</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-native-events-in-gory-details-what-happens-on-the-way-to-listeners-2cee6c55940c?source=collection_archive---------1-----------------------#2017-12-19">https://levelup.gitconnected.com/react-native-events-in-gory-details-what-happens-on-the-way-to-listeners-2cee6c55940c?source=collection_archive---------1-----------------------#2017-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9813" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在那里我们了解了React本机桥，并意识到React的中央事件处理系统经常被绕过…</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d397df254567282634134e4086de40e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*50WdkvWV-nHh5l9bKtQIaA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">反应本土:都是桥的问题。</figcaption></figure><p id="9316" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">继<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/how-exactly-does-react-handles-events-71e8b5e359f2">我上一篇关于React和React Native中事件处理的文章</a>之后，我有一些关于如何在React Native中发出自定义事件的问题。在React Native中编程意味着你不再在DOM中，像<code class="fe ls lt lu lv b">document.createEvent('myCustomEvent')</code>这样的工具是不可用的。</p><p id="c58d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么，你如何设法达到类似的结果呢？</p><p id="0778" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来解决这个问题:-)</p><h1 id="7006" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">为什么事件在React native中很重要？</h1><p id="fa7b" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">从本质上讲，React Native只是一个Javascript-Java-Xcode翻译器。不多不少。这种关系允许我们在本机代码之上添加Javascript层——React——并随后(几乎)编写任何东西，而不用担心本机细节。</p><p id="755e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就像在现实生活中翻译语言一样——在我们的例子中，在运行时将指令从一种编程语言传递到另一种编程语言——可能具有挑战性。将指令从一种编程语言传递到另一种编程语言工具是事件。事件相当容易概括，并且与语言无关。这使我们能够在各种情况下进行交流:</p><ul class=""><li id="a71e" class="mt mu iq kx b ky kz lb lc le mv li mw lm mx lq my mz na nb bi translated">从本机到Javascript</li><li id="84db" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">从Javascript到原生*</li><li id="6b1d" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">从Javascript到Javascript(有何不可！)</li></ul><p id="2e3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">高级的<a class="ae lr" href="https://facebook.github.io/react-native/docs/native-modules-android.html#sending-events-to-javascript" rel="noopener ugc nofollow" target="_blank"> React原生文档</a>中描述了利用这一强大工具的方法……但是该文档没有告诉您幕后发生了什么。</p><p id="af56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nh">*通过生命周期事件，这将不在本文中讨论。更多关于他们的信息可以在</em> <a class="ae lr" href="https://facebook.github.io/react-native/docs/native-modules-android.html#listening-to-lifecycle-events" rel="noopener ugc nofollow" target="_blank"> <em class="nh">这里</em> </a> <em class="nh">找到。</em></p><h1 id="f7fa" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">全能设备事件发射器</h1><p id="dfb7" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">我们将从最常见的将事件从本机传递到Javascript的方式开始探索，即<code class="fe ls lt lu lv b">DeviceEventEmitter</code>。但是<em class="nh">那个<code class="fe ls lt lu lv b">DeviceEventEmitter</code>到底是什么</em>？</p><p id="09b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">顾名思义，<code class="fe ls lt lu lv b">DeviceEventEmitter</code>是一个简单、无聊的事件发射器。你可以用Javascript或者任何你喜欢的语言来实现它。对于那些不熟悉什么是事件发射器的人，你可以看看这篇博客文章或者官方文档中的标准实现。简而言之，事件发射器是一个实现以下功能的对象:</p><ul class=""><li id="86b7" class="mt mu iq kx b ky kz lb lc le mv li mw lm mx lq my mz na nb bi translated">一个包含监听器数组的<code class="fe ls lt lu lv b">listenerStore</code>对象，这些函数将在匹配的事件类型被调度时被调用。每个数组都与一个<code class="fe ls lt lu lv b">eventName</code>键名相关联，该键名表示要匹配的事件类型。</li><li id="52b4" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">将<code class="fe ls lt lu lv b">listener</code>推到<code class="fe ls lt lu lv b">listenerStore[eventName]</code>的<code class="fe ls lt lu lv b">addListener(eventName, listener)</code>方法。</li><li id="c990" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">一个<code class="fe ls lt lu lv b">emit(eventName[,data)</code>方法，它将遍历<code class="fe ls lt lu lv b">listenerStore[eventName]</code>数组，并使用<code class="fe ls lt lu lv b">data</code>参数调用每个<code class="fe ls lt lu lv b">listener</code>。</li></ul><p id="15cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通常<code class="fe ls lt lu lv b">listenerStore</code>是一个特定事件发射器的属性。这意味着如果您有两个事件发射器，<code class="fe ls lt lu lv b">emitterA</code>和<code class="fe ls lt lu lv b">emitterB</code>，那么在<code class="fe ls lt lu lv b">emitterA</code>上注册的<code class="fe ls lt lu lv b">myEvent</code>的监听器将不会在<code class="fe ls lt lu lv b">emitterB.emit('myEvent')</code>上被调用。这有点问题，因为React Native <em class="nh">需要</em>才能在全球共享<code class="fe ls lt lu lv b">listenerStore</code>。如果它不能全局共享存储，在应用程序中任意位置触发的事件将无法到达适当的侦听器。</p><p id="5274" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们花一分钟来考虑一个事件必须传播的典型路径，从它的起源开始，到它的最终收听者结束。应用程序生命周期中发生的大多数事件(如触摸或滚动事件)都是在设备本身的本机代码中产生的。然而，在Javascript空间中，事件处理程序分散在应用程序的React部分。一个事件首先需要离开它在“Javascript世界”中的发源地，并以某种方式在整个Javascript代码库中回响，以便侦听器能够捕捉到它，而不管侦听器在哪里。这在技术上怎么可能？</p><p id="862d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于下一步，想法相当简单:与您可以<code class="fe ls lt lu lv b">import from ‘react-native’</code>的大多数模块不同，<code class="fe ls lt lu lv b"><strong class="kx ir">DeviceEventEmitter</strong></code> <strong class="kx ir">不是一个类，而是一个实例</strong>(一个对象，如果您愿意的话)。因此，每次导入实际上都为您提供了一个指向同一个对象的指针，这就很容易理解为什么订阅会自然地在所有Javascript代码中共享。更难弄清楚的是<code class="fe ls lt lu lv b">DeviceEventEmitter</code>如何与代码的本机部分进行交互。</p><p id="2435" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经知道，一旦事件到达<code class="fe ls lt lu lv b">DeviceEventEmitter</code>，就可以很容易地将它们分派到Javascript代码中的任何地方。然而，首先事件仍然需要能够到达那个<code class="fe ls lt lu lv b">DeviceEventEmitter</code>——一个基本的<em class="nh"> Javascript对象，而不是一个类</em> —。这意味着本机代码也需要对它的引用。事实上,<code class="fe ls lt lu lv b">DeviceEventEmitter</code>是一个独特的冷冻物体，正是这一事实使得这一壮举成为可能。要理解为什么，我们需要仔细看看React Native的核心:<em class="nh">桥。</em></p><h1 id="2892" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">如果React Native是一个群岛…</h1><p id="5951" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">如果React native是一个地理区域，它可能是由两座桥连接的三个岛屿组成的一个小群岛。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/aaa3906868711277b44bea0aead486ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*McXaZcFs1KsO1h-ux2KdKg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">——作者克莱尔·库夫拉特，经许可使用</figcaption></figure><p id="ccd9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">中央(也是最大的)岛是<strong class="kx ir"> JS岛</strong>。JS岛有两座桥，连接着<strong class="kx ir">爪哇岛</strong>和<strong class="kx ir"> Xcode岛</strong>。根据日期(或运行React Native的设备)，在给定时间只能使用其中一个桥，即使两个桥都存在。</p><p id="b721" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所有的岛屿都有自己复杂的高速公路系统。更糟糕的是，这些岛屿的居民甚至不在路的同一边开车！在建桥之前，岛上的人们在三件事上达成了一致:</p><ul class=""><li id="0682" class="mt mu iq kx b ky kz lb lc le mv li mw lm mx lq my mz na nb bi translated">这两座桥将有数量有限的车道(平心而论，这与其说是政治协议，不如说是物理约束…)，</li><li id="dfa2" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">为了避免混乱，禁止在一座桥上变换车道。如果你从一个岛上的A道开始，你必须在另一个岛上的A道结束</li><li id="b869" class="mt mu iq kx b ky nc lb nd le ne li nf lm ng lq my mz na nb bi translated">为了让来自JS岛的游客更容易参观邻近的岛屿，<strong class="kx ir">两座桥将有完全相同数量的车道，这些车道将有相同的名字</strong>——至少在JS岛上是这样。</li></ul><p id="47c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">经过长时间的谈判，最终给每座桥的车道起了名字:<code class="fe ls lt lu lv b">RCTDeviceEventEmitter</code>、<code class="fe ls lt lu lv b">RCTEventEmitter</code>、<code class="fe ls lt lu lv b">RCTLog</code>、<code class="fe ls lt lu lv b">Systrace</code>，每座桥总共11条车道。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/a382d94e047bde7c4a627c71b604c1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfPMaHc4HBU4yPP0QBsM0A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">反应当地人的桥梁</figcaption></figure><p id="3a77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">事实上，React Native中的桥接稍微复杂一些，通道的数量并不总是固定的。然而，这种类比仍然适用，因为每当React Native编排本机代码和Javascript代码之间的通信时，这正是幕后发生的事情。对于一个给定的桥(比如在Android设备中的Java和Javascript之间)，<strong class="kx ir">一个通道从一个模块指向另一端的严格对等模块</strong>。相同的名字，相同的方法，这就是为什么我们的 <code class="fe ls lt lu lv b"><strong class="kx ir">DeviceEventEmitter</strong></code> <strong class="kx ir">必须是一个唯一的对象而不是一个类。</strong>这样就可以从<em class="nh">Javascript和native调用它，native发出的类型为<code class="fe ls lt lu lv b">myEvent</code>的事件将被正确转发给所有在Javascript端监听<code class="fe ls lt lu lv b">myEvent</code>的人。</em></p><h1 id="5c6b" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">代码示例</h1><p id="9926" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">为了保持这篇文章的合理长度，我将只列出亮点和主要步骤。工作示例可在<a class="ae lr" href="https://github.com/nicolascouvrat/EventExample" rel="noopener ugc nofollow" target="_blank">资源库</a>中找到。你也可以直接跳到<a class="ae lr" href="#aa38" rel="noopener ugc nofollow">结论</a>然后再回到这些。</p><h2 id="4b26" class="nk lx iq bd ly nl nm dn mc nn no dp mg le np nq mi li nr ns mk lm nt nu mm nv bi translated">从本机到Javascript</h2><p id="2618" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated"><strong class="kx ir"> <em class="nh">注</em> </strong> <em class="nh">:因此我将用Java给出例子，因为我用它的经验比用Xcode多，但更多可以在</em> <a class="ae lr" href="https://facebook.github.io/react-native/docs/native-modules-ios.html" rel="noopener ugc nofollow" target="_blank"> <em class="nh">官方Xcode网页</em> </a> <em class="nh">上找到。原则是一样的。</em></p><p id="8a33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您首先需要定义您的本机组件。因为我们的目的是展示一种简单的方式来发出事件，这将不是一个UI组件，而是一个本机模块(是的，它们是不同的)，因此将是一个扩展<code class="fe ls lt lu lv b">ReactContextBaseJavaModule</code>的类。这迫使您实现一个<code class="fe ls lt lu lv b">getName()</code>和一个构造函数方法。要向Javascript公开一个方法，需要用<code class="fe ls lt lu lv b">@ReactMethod</code>修饰它，它必须返回<code class="fe ls lt lu lv b">void</code>。<code class="fe ls lt lu lv b">@ReactMethod</code>装饰器基本上创建了另一个方法，返回描述函数签名(名称、参数和参数类型)的数组。该签名然后被传递到桥的另一端(在这种情况下是Javascript)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="a01f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了向Javascript发送事件，您需要引用<code class="fe ls lt lu lv b">DeviceEventEmitter</code>。这可以通过获取桥所链接的当前上下文，然后获得正确的Javascript模块来实现</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="8c95" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，为您的模块创建一个<code class="fe ls lt lu lv b">ReactPackage</code>，并在<code class="fe ls lt lu lv b">MainApplication.java</code>中引用它。这基本上是样板文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="ed18" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过上面的代码，我们已经将一个事件直接发送给了<code class="fe ls lt lu lv b">DeviceEventEmitter</code>。因此，Javascript组件中唯一需要做的事情就是导入它并添加正确的事件监听器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="15c9" class="nk lx iq bd ly nl nm dn mc nn no dp mg le np nq mi li nr ns mk lm nt nu mm nv bi translated">从Javascript到Javascript</h2><p id="510d" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">这里没有问题，唯一需要做的是导入<code class="fe ls lt lu lv b">DeviceEventEmitter</code>并相应地使用<code class="fe ls lt lu lv b">emit()</code>和<code class="fe ls lt lu lv b">addListener()</code>。</p><p id="25a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，尽管完全可以直接使用<code class="fe ls lt lu lv b">DeviceEventEmitter</code>，但在代码中它被声明为不推荐使用。相反，您应该使用<code class="fe ls lt lu lv b">NativeEventEmitter</code>类作为基本模式，并在需要时扩展它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="eb5a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">等等，我们不是说过只有一个对象——而不是一个类——才能让整个系统工作吗？不要担心:<em class="nh">每个<code class="fe ls lt lu lv b">NativeEventEmitter</code>的</em>实例都通过引用存储在<code class="fe ls lt lu lv b">DeviceEventEmitter</code>中的侦听器数组进行初始化，因此在<code class="fe ls lt lu lv b">NativeEventEmitter</code>的一个实例上发出的事件可以被任何其他实例的<em class="nh">捕获，并且一切都按照预期工作。</em></p><h1 id="aa38" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">等等，我的事件在哪里冒泡？</h1><p id="342f" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">到目前为止，我们发现所有的事件发射器——无论是唯一的<code class="fe ls lt lu lv b">DeviceEventEmitter</code>还是我们的多个<code class="fe ls lt lu lv b">NativeEventEmitter</code>实例——都共享同一个订户列表。虽然提供了难以置信的灵活性(您不需要显式引用目标)，但重要的是要记住，如果您决定在React native中使用events，那么在任何 <code class="fe ls lt lu lv b"><strong class="kx ir">NativeEventEmitter</strong></code> <strong class="kx ir">实例或</strong> <code class="fe ls lt lu lv b"><strong class="kx ir">DeviceEventEmitter</strong></code> <strong class="kx ir">上发出的<strong class="kx ir">事件</strong> <code class="fe ls lt lu lv b"><strong class="kx ir">someEvent</strong></code> <strong class="kx ir">将被转发给<em class="nh">所有</em></strong> <code class="fe ls lt lu lv b"><strong class="kx ir">someEvent</strong></code> <strong class="kx ir">的监听器，无论这些监听器被添加到哪里！</strong>考虑下面的例子，其中<code class="fe ls lt lu lv b">MyEmitter</code>和<code class="fe ls lt lu lv b">MyListener</code>分别发出和监听<code class="fe ls lt lu lv b">someEvent</code>，每个都有自己的<code class="fe ls lt lu lv b">NativeEventEmitter</code>实例:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="5a27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每次一个<code class="fe ls lt lu lv b">MyEmitter</code>发出一个事件，两个<code class="fe ls lt lu lv b">MyListener</code>都会捕捉到，即使他们之间没有父子关系！小心不必要的触发因素…</p><p id="3b54" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，你自己可能已经得出结论:<strong class="kx ir">与</strong> <code class="fe ls lt lu lv b"><strong class="kx ir">DeviceEventEmitter</strong></code> <strong class="kx ir">，不存在事件冒泡</strong>之类的事情。没错，在那篇关于React的统一事件系统的伟大之处的<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/how-exactly-does-react-handles-events-71e8b5e359f2">长篇文章</a>之后，我们今天发现的是，在native和Javascript之间，甚至从Javascript到Javascript之间转发事件的最主流方式……根本不使用冒泡。</p><p id="61ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nh">但是React的冒泡系统很棒！我不能找到使用它的方法吗？</em>可以，可以。有一种方法——尽管很不容易。如果你想了解它的全部，那么你必须等待这篇文章的第二部分，即将发布的<strong class="kx ir">！</strong></p><h1 id="4386" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">最后一件事——你可能根本不需要事件</h1><p id="6402" class="pw-post-body-paragraph kv kw iq kx b ky mo jr la lb mp ju ld le mq lg lh li mr lk ll lm ms lo lp lq ij bi translated">事件是React Native本身的重要组成部分。但是说实话，就标准应用程序而言，您要寻找的可能只是回调。React是围绕回调构建的——用<code class="fe ls lt lu lv b">props</code>从父节点传递给子节点，这是在Javascript端模仿类似事件行为的最简单、最安全的方式。使用事件的最大缺点之一是，一旦发出了事件，您就不知道谁在监听——这意味着您可能会触发不必要的操作，并且您的代码变得相当难以维护。然而，有了回调，这个问题就消失了，你可以完全控制正在发生的事情。</p><p id="bc88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也就是说，有些时候可以认为事件更好:当你有一个组件埋得很深，以至于一直连接回调会很麻烦，或者当你需要在子树b中调用子树A中的组件时。</p><p id="e638" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">无论如何，这篇文章的目的是向你展示<em class="nh">可以</em>在React Native中使用事件发射。我会让你决定什么时候去T4。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="2a30" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望你和我一起享受这次新的旅行，这次是在事物的反应方面！像往常一样，还可以添加更多的细节，尤其是大桥背后的技术细节，但我在这里避免了这些，以集中讨论事件的主题。</p><p id="6a81" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一次，我们将回到我们亲爱的事件系统，并编写我们自己的事件插件！敬请关注…</p></div></div>    
</body>
</html>