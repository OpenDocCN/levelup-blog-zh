<html>
<head>
<title>How web browsers use Processes and Threads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">web浏览器如何使用进程和线程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-web-browsers-use-processes-and-threads-9f8f8fa23371?source=collection_archive---------0-----------------------#2020-07-16">https://levelup.gitconnected.com/how-web-browsers-use-processes-and-threads-9f8f8fa23371?source=collection_archive---------0-----------------------#2020-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f21b85b0bbeb388fab5e869762d07a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l4NinpDecWyMUkY2qCJaxQ.png"/></div></div></figure><p id="f669" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi kz translated"><span class="l la lb lc bm ld le lf lg lh di"/>进程可以描述为一个应用程序的执行程序。线程存在于进程中，执行进程程序的任何部分。启动应用程序时，会创建一个进程。程序可能会创建线程来帮助它工作，但这是可选的。</p><p id="1401" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个进程可以要求操作系统启动另一个进程来运行不同的任务。当这种情况发生时，内存的不同部分被分配给新的进程。如果两个进程需要对话，它们可以通过使用<strong class="kd iu">I</strong>enter<strong class="kd iu">P</strong>process<strong class="kd iu">C</strong>communication(<strong class="kd iu">IPC</strong>)来进行。许多应用程序都是以这种方式工作的，这样，如果一个工作进程没有响应，它可以在不停止运行应用程序不同部分的其他进程的情况下重新启动。</p><h2 id="e118" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">哪个过程控制什么？</h2><p id="2619" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated"><strong class="kd iu">浏览器:</strong>控制应用程序，包括地址栏、书签、后退和前进按钮。还处理web浏览器中不可见的特权部分，如网络请求和文件访问。</p><p id="185b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">渲染器:</strong>控制显示网站的标签中的任何内容。</p><p id="c956" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">插件:</strong>控制网站使用的任何插件，例如flash。</p><p id="23e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> GPU: </strong>独立于其他进程处理GPU任务。它被分成不同的进程，因为GPU处理来自多个应用程序的请求，并将它们绘制在同一个表面上。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/2099f7173b18ccfb3f79bddb561f043c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f0BYrCmx9w2eBacEW6zNLA.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">不同的进程指向浏览器UI的不同部分</figcaption></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="d8e5" class="mw lj it bd lk mx my mz ln na nb nc lq nd ne nf lt ng nh ni lw nj nk nl lz nm bi translated">google chrome如何使用进程和线程</h1><p id="604c" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">Chrome有一个多进程架构，每个进程都是多线程的。主要目标是保持主线程(浏览器进程中的“UI”线程)和IO线程(每个进程用于处理IPC的线程)的响应性。这意味着将任何阻塞I/O或其他昂贵的操作卸载到其他线程。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/5c4a94c777a361d5fbf74f0eb895135d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zciUhE5jY9BZxiWVkpyJ5A.png"/></div></div></figure><h2 id="e6ad" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">线</h2><p id="d323" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">每个铬工艺都有，</p><p id="a7be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="no">一个主线程</em></p><ul class=""><li id="adb0" class="np nq it kd b ke kf ki kj km nr kq ns ku nt ky nu nv nw nx bi translated">在浏览器进程中(BrowserThread::UI):更新用户界面</li><li id="4493" class="np nq it kd b ke ny ki nz km oa kq ob ku oc ky nu nv nw nx bi translated">在渲染器进程中(闪烁主线程):运行大部分闪烁</li></ul><p id="8376" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个IO线程</p><ul class=""><li id="38b6" class="np nq it kd b ke kf ki kj km nr kq ns ku nt ky nu nv nw nx bi translated">在浏览器进程中(BrowserThread::IO):处理IPC和网络请求</li><li id="0306" class="np nq it kd b ke ny ki nz km oa kq ob ku oc ky nu nv nw nx bi translated">在渲染器进程中:处理IPC。</li></ul><p id="903a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="no">多几根专用线。</em></p><p id="f866" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="no">和一个通用线程池。</em></p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="01af" class="mw lj it bd lk mx my mz ln na nb nc lq nd ne nf lt ng nh ni lw nj nk nl lz nm bi translated">Firefox如何使用进程和线程</h1><p id="4fbd" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">几年前，Mozilla对Firefox开发的未来做出了一个重大决定，这使得在现有浏览器中集成多处理变得更加困难。大约10年前，Firefox与Internet Explorer的主要区别在于它对插件和扩展的支持。但是，使浏览器流行的附加功能也使得增加多处理器支持变得困难。因此，Mozilla致力于从其旧的附加模型过渡到多浏览器web扩展支持，同时启动电解项目以创建支持多处理架构的新浏览器版本。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/f0dda2bcf403e2c76d9aa931ac1cefa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1GDtrKXip4lX2dPv1fTuyg.png"/></div></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="1c69" class="mw lj it bd lk mx my mz ln na nb nc lq nd ne nf lt ng nh ni lw nj nk nl lz nm bi translated">比较Chrome和Firefox</h1><p id="1f4b" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">Chrome和Firefox现在都支持多线程，但它们支持的方式不同。在Chrome中，你打开的每一个标签都有自己的内容处理过程。十个标签，十个流程。一百个标签，一百个流程。这种方法最大限度地提高了性能，但是在内存消耗和电池寿命方面付出了巨大代价。Firefox没有采用这种方法来解决这个问题，而是默认旋转多达四个内容处理线程。在Firefox中，前4个标签使用这4个进程，其他标签使用这些进程中的线程。流程中的多个选项卡共享内存中已有的浏览器引擎，而不是各自创建自己的引擎。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/d1517ebaa8872514f390b4647ea62d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R4gxbsv-WLn34L9VW4DGzw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">Chrome为每个网站实例使用单独的内容进程和引擎，但Firefox重用进程和引擎来限制内存使用</figcaption></figure><p id="50f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Mozilla声称Firefox使用的内存也比其他竞争浏览器少得多，Chrome在64位模式下使用的内存是Firefox的1.77倍，在32位模式下是2.44倍。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/fe7935b2038a89b3fba5b144a2a36bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AyNT6jwz-8jonBZSHRUIhw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">Firefox比其他浏览器使用更少的内存</figcaption></figure><h2 id="219b" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">为什么Chrome变得过热，而Firefox却没有</h2><p id="ff42" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">虽然Firefox和Chrome现在都使用多个进程运行，但Firefox做了一些不同的事情，以避免耗尽电脑有限的内存。</p><p id="5917" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，Chrome会为你访问的每个站点创建一个单独的内容流程。在Chrome中打开10个不同的标签和10个网站，你会有10个不同的流程。每个进程都有自己的内存——有自己的浏览器引擎实例。Chrome中一个打开的标签页通常会占用数百兆的内存。Chrome创建进程的自由方法会导致非常高的内存使用率。</p><p id="d5aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，Firefox使用进程的方式更保守，这往往导致Firefox使用的内存比Chrome少。默认情况下，Firefox现在为网页内容创建多达4个独立的进程。因此，您的前4个选项卡都使用这4个进程，其他选项卡使用这些进程中的线程运行。流程中的多个选项卡共享内存中已有的浏览器引擎，而不是各自创建自己的引擎。</p></div></div>    
</body>
</html>