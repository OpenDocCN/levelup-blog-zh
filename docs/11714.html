<html>
<head>
<title>A Guide to Heaps, Stacks, References and Values in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的堆、栈、引用和值指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-guide-to-heaps-stacks-references-and-values-in-javascript-3a6fd8e013c3?source=collection_archive---------10-----------------------#2022-04-08">https://levelup.gitconnected.com/a-guide-to-heaps-stacks-references-and-values-in-javascript-3a6fd8e013c3?source=collection_archive---------10-----------------------#2022-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/da28e3b7598908086a807462b9ae5a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l51cz83MjNIQFvVn0hEUTQ.png"/></div></div></figure><p id="c95d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一般来说，软件工程中的一个常见概念是引用与值的概念。Javascript有一种存储变量、对象和函数的有趣方式，误解这种方式会导致进一步的混乱。对于开发人员来说，了解这些概念是如何工作的非常重要，因为这是Javascript的基础。在本文中，我们将介绍Javascript如何管理值和引用，这将在处理复杂的应用程序和网站时带来好处。</p><h1 id="3eb8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Javascript中的内存存储</h1><p id="7baf" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了理解我们所说的Javascript存储值和引用是什么意思，我们需要理解Javascript将它们存储在哪里。Javascript在两个地方存储这些数据:</p><ul class=""><li id="bb3d" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">堆栈是当前Javascript线程的暂存空间。由于Javascript通常只是单线程的，所以通常只有一个堆栈。堆栈的大小也是有限的，这就是为什么Javascript中的数字只能有这么大。</li><li id="68ad" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated"><strong class="ka ir">堆</strong>是应用程序级的动态内存存储。从堆中访问和检索数据稍微复杂一点，但是数据存储是动态的——这意味着如果需要，它会扩展，并且不受限制。</li></ul><p id="59cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当某个东西存储在<strong class="ka ir">堆栈</strong>中时，它由<strong class="ka ir">值</strong>存储。当某个东西被存储在<strong class="ka ir">堆</strong>中时，它被<strong class="ka ir">引用</strong>存储。</p><h1 id="46e8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">堆栈存储器</h1><p id="2a7f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Javascript在堆栈中存储常规的原语类型，如<code class="fe mn mo mp mq b">number</code>、<code class="fe mn mo mp mq b">string</code>、<code class="fe mn mo mp mq b">boolean</code>、<code class="fe mn mo mp mq b">null</code>、<code class="fe mn mo mp mq b">undefined</code>和<code class="fe mn mo mp mq b">bigint</code>。在代码中定义变量时，它们会被添加到堆栈的顶部:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="d7dd" class="mz kx iq mq b gy na nb l nc nd">let myVar = 15;<br/>let myName = 'Johnny';<br/>let someOtherVar = false;<br/>let check = null;</span></pre><p id="12fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">堆栈:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/1d0ff8287038cdbf94ef64277e1a64b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*668SqY1GKAV3nnpn.png"/></div></div></figure><p id="d488" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着如果我们在Javascript中重定义一个变量，它会变成一个全新的值。例如:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="d1cb" class="mz kx iq mq b gy na nb l nc nd">let myNumber = 5;<br/>let newNumber = myNumber;</span><span id="c3ba" class="mz kx iq mq b gy nf nb l nc nd">++newNumber;</span><span id="504b" class="mz kx iq mq b gy nf nb l nc nd">// Returns 5, 6<br/>console.log(myNumber, newNumber);</span></pre><p id="0907" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">堆栈:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/6591ca5507949e1486b7f3845f1cef0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p4FaaPDGonvNud_L.png"/></div></div></figure><p id="bffc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于Javascript为存储在堆栈中的任何东西创建一个新值，即使我们提到newNumber与myNumber相同，它们也不是指同一个东西。这两个变量变得相互独立，因此改变一个不会改变另一个。</p><h1 id="2780" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">堆存储</h1><p id="a095" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果你定义的东西不是一个基本类型，而是一个对象，那么它被存储在堆中。在Javascript中，函数和数组也属于“对象”类别。</p><p id="4163" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">堆的定义需要更多的思考，而不是在堆栈中容易访问。存储在堆中的所有东西都被赋予了一个引用。</p><p id="b2f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">示例</strong></p><p id="888a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们在Javascript中定义了一个对象和一个函数:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="360b" class="mz kx iq mq b gy na nb l nc nd">let myObject = { name: "Hello" };<br/>let myFunction = function() {<br/>    return "Hello World";<br/>}</span></pre><p id="9f0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如下所示，为每个myObject和myFunction创建了一个新的引用，引用分别为#000和#001。该引用是它们在内存中的存储位置。</p><p id="9403" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">堆存储</strong></p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/2ac17751dc1c0b6d25f68683b0b93d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ACB-ku32MvdrWP9r.png"/></div></div></figure><p id="6c67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与堆栈相比，堆存储的主要区别在于，如果我们再次引用一个对象，引用保持不变。这意味着如果我们尝试创建myObject的新版本，它将保留相同的引用:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="0aab" class="mz kx iq mq b gy na nb l nc nd">let myObject = { name: "Hello" };<br/>let newObject = myObject;<br/>newObject.name = "Goodbye";</span><span id="35a1" class="mz kx iq mq b gy nf nb l nc nd">// Returns { name: "Goodbye" }, { name: "Goodbye" }<br/>console.log(myObject, newObject);</span></pre><p id="d5ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们改变一个时，两个都改变——这与我们在堆栈中存储数据时相反。</p><p id="93ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">堆存储</strong></p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/9e54879dadba4d1d5c37d21bcb506c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9_fEAFTZZ1yy9NAY.png"/></div></div></figure><h1 id="3b2b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">值和引用的等价性</h1><p id="6aa0" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">由于Javascript将对象的定义存储为引用，这可能会有点混乱。对于值，我们可以很容易地比较两个事物是否相等:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="7cb9" class="mz kx iq mq b gy na nb l nc nd">let a = 5;<br/>let b = 5;</span><span id="e24c" class="mz kx iq mq b gy nf nb l nc nd">// Returns true<br/>console.log(a === b);</span></pre><p id="82e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们很容易比较这两者，因为它们都是值。不过，作为参考，这是一个不同的故事。比较两个对象，通过引用进行比较。即使它们的值相同，它们也不相等，因为它们的引用不同:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="70d1" class="mz kx iq mq b gy na nb l nc nd">let a = { name: "Hello" };<br/>let b = { name: "Hello" };</span><span id="ee30" class="mz kx iq mq b gy nf nb l nc nd">// Returns false<br/>console.log(a === b);</span></pre><h1 id="dffb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="bfb8" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">引用和值对您的代码有着真正的影响——尤其是在进行比较时，理解它们的区别是至关重要的。不仅如此，就性能而言，堆栈比堆要便宜得多，而且如果您不知道它是如何工作的，很容易创建太多的堆栈条目。</p><p id="f3fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您知道Javascript如何处理堆和堆栈存储，您就可以开始优化您的应用程序的性能，以便在这些规则内最佳地工作。我希望你喜欢这个关于Javascript中引用和值如何工作的快速指南。<a class="ae ni" href="https://fjolt.com/category/javascript" rel="noopener ugc nofollow" target="_blank">如果你想要更多的Javascript内容，可以在这里找到</a>。</p></div></div>    
</body>
</html>