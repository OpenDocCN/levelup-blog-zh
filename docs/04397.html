<html>
<head>
<title>Frontend Go — interacting with graphics and charts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Frontend Go —与图形和图表交互</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/frontend-go-interacting-with-graphics-and-charts-70201c3f03e1?source=collection_archive---------8-----------------------#2020-06-24">https://levelup.gitconnected.com/frontend-go-interacting-with-graphics-and-charts-70201c3f03e1?source=collection_archive---------8-----------------------#2020-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/30a5004ad49174ef4f5c1f1441e1f2a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GioZU9Oqf97W8aia"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@goumbik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡斯·布拉塞克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2b43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在以前的文章中(<a class="ae kf" href="https://medium.com/@sean_24982/experimenting-with-full-stack-development-in-go-part-1-setting-the-scene-963adb40b189" rel="noopener">入口点</a>)，我描述了如何在一个玩具应用程序的前端和后端都使用Go。这最初的工作是基本的，我想深入一点。在这里，我报告了我使用Go获得(稍微)更复杂的前端操作的经验。</p><p id="518f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想有一个基本的前端，可以显示图表内容；最初，我考虑使用简单的图形作为图表的基础，基于一些<a class="ae kf" href="https://medium.com/@PepsRyuu/why-i-no-longer-use-d3-js-b8288f306c9a" rel="noopener">观察，这可能比使用D3 </a>更容易。随后，我考虑了如何与功能丰富的Javascript图表库Apache ECharts进行交互。和之前的帖子一样，前端工作全部基于<code class="fe le lf lg lh b"><a class="ae kf" href="https://github.com/gopherjs/vecty" rel="noopener ugc nofollow" target="_blank">vecty</a></code>。</p><p id="ce0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">添加基于SVG的图表</strong></p><p id="4497" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我首先检查了如何在<code class="fe le lf lg lh b">vecty</code>中显示SVG内容。<code class="fe le lf lg lh b">vecty</code>本身(目前)没有特定的SVG支持，但是我发现了一个相对较新的Go包——<code class="fe le lf lg lh b"><a class="ae kf" href="https://github.com/nathanhack/svg" rel="noopener ugc nofollow" target="_blank">nathanhacks/svg</a></code>——它专注于在这个上下文中提供SVG支持。使用这个库，可以生成简单的折线图、饼图和条形图，如下面的视频所示。</p><p id="cd2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于该库仍然是新的，正在努力完善其功能和接口。该库基于<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/SVGElement" rel="noopener ugc nofollow" target="_blank"> SVG Web API </a>提供了与SVG图形交互的基本原语；那里定义的概念和API调用非常直接地映射到库功能。SVG模型的一个有趣的方面是可以灵活地定义显示坐标系的哪一部分，并且确实可以动态修改以提供不同的视觉效果，如运动和平移。这意味着原则上可以选择平面上的任意区域来放置和显示图形。这在显示饼图时很有用:最方便的工作是将平面的一部分集中在<code class="fe le lf lg lh b">(0, 0)</code>上，而不是将这个点放在<code class="fe le lf lg lh b">viewport</code>的左上方。</p><p id="b6ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个在开始时并不明显的问题——主要是由于我缺乏SVG知识——是它有一个非常复杂的路径模型<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d#Path_commands" rel="noopener ugc nofollow" target="_blank">,它被用作创建除了最简单的形状以外的所有形状的基础:例如，为了生成饼图的片段，有必要构造一个正确形状的填充路径——基本思想见下文。</a></p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="4cc0" class="lq lr it lh b gy ls lt l lu lv">func renderSector() *vecty.HTML {</span><span id="7278" class="lq lr it lh b gy lw lt l lu lv">  openingAngle=initialPercentage*2*math.Pi<br/>  segmentAngle=additionalPercentage*2*math.Pi</span><span id="fe34" class="lq lr it lh b gy lw lt l lu lv">  p := path.MoveTo(0, 0)</span><span id="f5f4" class="lq lr it lh b gy lw lt l lu lv">  x = float64(rx) * math.Cos(openingAngle)<br/>  y = -float64(ry) * math.Sin(openingAngle)<br/>  p = p.LineTo(x, y)</span><span id="c9e5" class="lq lr it lh b gy lw lt l lu lv">  closingAngle = openingAngle + segmentAngle<br/>  x = float64(rx) * math.Cos(closingAngle )<br/>  y = -float64(ry) * math.Sin(closingAngle)<br/>  p = p.Arc(rx, ry, 0.0, 0, 0, x, y)</span><span id="f5bc" class="lq lr it lh b gy lw lt l lu lv">  p = p.ClosePath()</span><span id="c4e3" class="lq lr it lh b gy lw lt l lu lv">  image := []svg.Component{<br/>    attr.Class("svg-image"),<br/>    attr.Width(300),<br/>    attr.Height(300),<br/>    attr.ViewBox(0, 0, 100, 100),<br/>    attr.Stroke("red"),<br/>    svgelem.Path(attr.Stroke("red"), attr.Fill("red"), attr.D(p)),<br/>   }</span><span id="2b1f" class="lq lr it lh b gy lw lt l lu lv">  return elem.Div(<br/>    vecty.Markup(<br/>      vecty.Class("chart-panel"),<br/>    ),<br/>    svg.Render(image),<br/>  )<br/>}</span></pre><p id="5fd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">添加基于Apache ECharts的图表</strong></p><p id="6cb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理解了SVG库的基本机制和设计之后，我意识到使用这种方法支持不同的图表类型需要相当大的努力。</p><p id="f703" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来我研究了如何使用ECharts，并考虑如何从<code class="fe le lf lg lh b">vecty</code>中使用它。考虑特定的图表集成很有意思，但更一般地理解Go/Javascript集成机制也很有意思，这样就可以从Go调用任意的Javascript功能。</p><p id="444b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">全面的<code class="fe le lf lg lh b">go-echarts</code>库提供了一个很好的起点:<code class="fe le lf lg lh b">go-echarts</code>提供了在Go中创建许多不同图表类型的功能，并输出HTML/Javascript来可视化图表。关键的一点是它只支持静态图表:图表和相关数据在生成器代码中定义，静态HTML/Javascript被输出——它(还)没有提供一种方法使图表显示在通过Go动态控制的HTML页面中。</p><p id="d8a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ECharts提供了一个扩展的JS API，它通过两个特定的调用控制图表交互的许多方面，这两个调用说明了许多关键功能:<code class="fe le lf lg lh b">echarts.init</code>在页面内的特定容器中创建图表的实例，<code class="fe le lf lg lh b">&lt;chart&gt;.setOptions</code>将图表参数化—包括图表类型、图表数据、图例等—并相应地显示它。这两个功能是<code class="fe le lf lg lh b">go-echarts</code>使用的。</p><p id="7a7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用这些功能，首先需要创建一个可以插入图表的<code class="fe le lf lg lh b">div</code>；当<code class="fe le lf lg lh b">div</code>被插入页面时，上面提到的<code class="fe le lf lg lh b">echarts</code>函数被调用。由于<code class="fe le lf lg lh b">vecty </code>的<em class="lx">存在的理由</em>是为了支持页面内容的动态控制，所以不能假定<code class="fe le lf lg lh b">div </code>是事先生成的:<code class="fe le lf lg lh b">vecty </code>应该在必要时向页面添加内容。这就产生了一个小问题:对应于<code class="fe le lf lg lh b">div</code>的Javascript对象需要提供给<code class="fe le lf lg lh b">echarts.init</code>函数，但是不能确定它是否存在于页面中。<code class="fe le lf lg lh b">vecty Components</code>可以处理这一点，提供一个<code class="fe le lf lg lh b">Mount()</code>调用作为接口的一部分，当<code class="fe le lf lg lh b">Component</code>在页面中呈现时调用该接口:对于本例中的每个图表类型——折线图、饼图和条形图，都创建了一个<code class="fe le lf lg lh b">Component</code>,当<code class="fe le lf lg lh b">div</code>被插入到页面中时，它具有调用<code class="fe le lf lg lh b">echarts</code>函数的功能。</p><p id="a0ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在初始化<code class="fe le lf lg lh b">div</code>上的<code class="fe le lf lg lh b">echarts</code>后，有必要使用<code class="fe le lf lg lh b">setOptions</code>调用来配置图表。为<code class="fe le lf lg lh b">setOptions</code>调用提供正确的输入需要一些努力——在Javascript世界中，它需要一个有效的Javascript对象，但是<code class="fe le lf lg lh b">go-echarts</code>库没有提供将图表状态导出到这样一个对象的机制。因此，需要对<code class="fe le lf lg lh b">go-echarts</code>库进行修改。由于这些对象必须使用<code class="fe le lf lg lh b">syscall/js ValueOf</code>函数转换成Javascript实体，图表选项必须是特定的格式(<code class="fe le lf lg lh b">ValueOf</code>要求Javascript对象是<code class="fe le lf lg lh b">map[string]interface{}</code>而列表是<code class="fe le lf lg lh b">[]interface{}</code>):因此我为不同的图表类型添加了一个新函数<code class="fe le lf lg lh b">GenerateOptions()</code>，它将存储在<code class="fe le lf lg lh b">go-echarts</code>中的状态转换成可以动态传递给<code class="fe le lf lg lh b">echarts</code>的状态。值得注意的是，Go <code class="fe le lf lg lh b"><a class="ae kf" href="https://github.com/fatih/structs" rel="noopener ugc nofollow" target="_blank">structs</a></code>包完成了大量的转换工作。</p><p id="21a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">演示</strong></p><p id="921b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">演示非常简单，提供了显示(非常)基本的基于SVG的图表集或更复杂的电子图表集的选项；可以在两者之间动态切换。下面的短片展示了在一个干净的虚拟机中的安装和构建过程以及最终的输出。</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="ly lz l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">显示安装过程和结果输出的视频</figcaption></figure><p id="0d20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">结束语</strong></p><p id="c068" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它没有回答所有关于Go/JS集成的问题:目前还不清楚ECharts JS库所做的页面修改是否会对Go/WASM应用程序产生负面影响，因为后者看不到这些变化。对于这个简单的演示，没有观察到负面影响，但是对于更复杂的应用程序，可能会出现这样的问题。</p><p id="88d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">包含内容的github repo这里是<a class="ae kf" href="https://github.com/seanrmurphy/go-vecty-experiments" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="6df6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">鸣谢:感谢nathanhack在这项工作的SVG方面提供的帮助。</p></div></div>    
</body>
</html>