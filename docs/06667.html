<html>
<head>
<title>Build and Deploy a Django Application using Docker and Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker和Compose构建和部署Django应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-and-deploy-a-django-application-using-docker-and-compose-9bf0d8dc5ebb?source=collection_archive---------3-----------------------#2020-12-18">https://levelup.gitconnected.com/build-and-deploy-a-django-application-using-docker-and-compose-9bf0d8dc5ebb?source=collection_archive---------3-----------------------#2020-12-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d2b7d3dd59e4a9126979e359ff4c464d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnQ20WU7ibZyycmNYa_1PQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@sigmund?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kf" href="https://unsplash.com/s/photos/cloud-computing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="3756" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本教程将讨论Docker，然后在Django和postgres数据库中构建一个简单的任务管理系统，并将其部署到Ubuntu 16服务器中的Docker。</p><h1 id="57b5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是Docker</h1><p id="ee27" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Docker是一个软件容器化平台，其中不同的应用程序以及它们的库和依赖项运行在不同的容器中。集装箱运输有以下好处:</p><p id="51fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">*它降低了总体拥有成本。<br/> *由于容器重量轻，因此易于维护和扩展系统。<br/> *集装箱化带来了隔离，因此最大限度地减少了过度依赖，因为流程在不同的集装箱中运行。<br/>* RAM容器的正确使用只占用运行其操作所需的空间。<br/> *易于交付代码——Docker为从开发到生产的应用程序提供了一个标准化的环境，因此开发人员不必担心这种兼容性<br/> *更快的集成——这意味着只需几个命令，您就可以在同一容器或不同容器中交付不同的应用程序实例。例如，您可以在不同的容器中有两个不同的Django应用程序，运行在不同版本的Python中。</p><h1 id="e5a5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Docker撰写</h1><p id="b664" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。使用用于配置应用程序服务的YAML文件，这是可能的。然后，只需从配置中发出一个命令，就可以创建和启动这些服务。</p><h1 id="e15b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Docker图像和容器</h1><p id="a0b1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">docker映像包含应用程序所需的软件组件的指令，容器是映像的运行实例。</p><h2 id="de0c" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">基本Docker命令</h2><p id="60d1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">下面是你应该掌握的基本Docker命令。</p><p id="9905" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">*<strong class="ki iu">docker PS</strong>–我们使用这个命令列出所有正在运行的容器。<br/>*<strong class="ki iu">docker PS a</strong>–我们使用这个命令列出所有的容器(包括那些没有运行的)。<br/>*<strong class="ki iu">docker images</strong>-该命令用于列出所有图像。<br/>*<strong class="ki iu">docker run[image-id]</strong>–该命令将运行指定的图像。<br/>*<strong class="ki iu">Docker pull[image]</strong>–该命令将从Docker注册表中提取一个图像。例如，要获取ubuntu图像，我们将运行:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="2e7f" class="mh lf it my b gy nc nd l ne nf">docker pull ubuntu</span></pre><h1 id="b064" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">入门指南</h1><p id="1360" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在我们开始项目之前，我们需要确保我们的服务器包是最新的。更新系统软件包:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="eaaf" class="mh lf it my b gy nc nd l ne nf">apt-get update</span></pre><p id="df0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步将是安装Docker。您可以通过发出以下命令来做到这一点。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7701" class="mh lf it my b gy nc nd l ne nf">apt install docker.io</span></pre><p id="758a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">安装docker-compose </strong></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="a202" class="mh lf it my b gy nc nd l ne nf">apt install docker-compose</span></pre><p id="c356" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要检查是否安装了Docker和Docker Compose，请发出以下命令:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="0626" class="mh lf it my b gy nc nd l ne nf">docker -v<br/>Docker version 18.06.1-ce, build e68fc7a<br/>docker-compose -v<br/>docker-compose version 1.8.0, build unknown</span></pre><p id="6d5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经安装了Docker Compose，可以准备应用程序进行部署了。<br/>创建一个新目录，djangoapps</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="776f" class="mh lf it my b gy nc nd l ne nf">mkdir djangoapps</span></pre><p id="e9fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在根目录下创建一个requirements.txt文件。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="49de" class="mh lf it my b gy nc nd l ne nf">touch requirements.txt</span></pre><p id="6eb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们将在Django项目中使用的所有包添加到这个文件中:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="bdae" class="mh lf it my b gy nc nd l ne nf">#requirements.txt<br/>Django==2.1.5<br/>djangorestframework==3.9.1<br/>gunicorn==19.9.0<br/>psycopg2==2.7.7</span></pre><p id="93cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">创建Docker文件</strong><br/>Docker文件包含构建映像的指令。在项目的根目录中创建Dockefile。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4f22" class="mh lf it my b gy nc nd l ne nf">cd djangoapps<br/>touch Dockerfile</span></pre><p id="2204" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">典型的Dockefile将包含以下实体:</p><p id="a641" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">* base image <br/> * maintainer <br/> *关于项目将如何存储在容器中的命令指令<br/> *在容器内部执行的默认指令</p><p id="fce8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将以下内容添加到Docker文件中。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="a7d9" class="mh lf it my b gy nc nd l ne nf">FROM python:3<br/>RUN mkdir /project<br/>WORKDIR /project<br/>COPY requirements.txt /project/<br/>RUN pip install -r requirements.txt<br/>COPY . /project/</span></pre><p id="8477" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在下面解释上面的命令:</p><p id="e736" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">* FROM python:3 —提取Python 3映像<br/>* RUN mkdir/project—创建名为project <br/> * WORKDIR /project的目录—将project设置为复制和运行命令的工作目录。<br/>* COPY requirements . txt/project/—将需求文件复制到项目目录下<br/> *运行pip install -r requirements.txt —安装需求文件中的包<br/> * COPY。/project/ —将当前目录中的内容复制到Docker映像中的目标项目目录</p><p id="6e76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Docker最后的要求是**docker-compose.yml**文件。这个文件包含应用程序所需的不同服务、它们的卷、如何链接它们以及它们公开的端口。例如，在我们的例子中，我们有main和Postgres服务。</p><p id="59f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个名为**docker-compose.yml**的文件，并将以下内容添加到该文件中。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4c5f" class="mh lf it my b gy nc nd l ne nf"> version: ‘2’<br/> services:<br/> web:<br/> build: .<br/> command: gunicorn docker_django.wsgi:application — bind 0.0.0.0:8000<br/> volumes:<br/> — .:/project<br/> ports:<br/> — 8001:8001”<br/> depends_on:<br/> — db<br/> db:<br/> image: postgres</span></pre><p id="da9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成Docker配置后，我们可以开始Django项目了。<br/>我们将首先安装Django。</p><p id="6e21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Django项目将位于根目录中。如图所示创建</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4df3" class="mh lf it my b gy nc nd l ne nf">Django-admin startproject docker_django .</span></pre><p id="d71c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建一个名为“任务”的新应用程序。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="ee68" class="mh lf it my b gy nc nd l ne nf">Django-admin.py startapp tasks</span></pre><p id="3668" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将tasks和rest框架添加到settings.py文件中已安装应用程序的列表中。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="c1b5" class="mh lf it my b gy nc nd l ne nf">#docker-django settings.py</span><span id="6896" class="mh lf it my b gy ng nd l ne nf"># Application definition<br/>INSTALLED_APPS = [<br/> …………..<br/> tasks’, # add here<br/> <br/> ]</span></pre><p id="4a56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编辑已配置的SQLite数据库，并使用Postgres数据库。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="c4ce" class="mh lf it my b gy nc nd l ne nf">DATABASES = {<br/> ‘default’: {<br/> ‘ENGINE’: ‘django.db.backends.postgresql_psycopg2’,<br/> ‘NAME’: ‘postgres’,<br/> ‘USER’: ‘postgres’,<br/> ‘PASSWORD’: ‘postgres’,<br/> ‘HOST’: ‘db’,<br/> ‘PORT’: ‘5432<br/> <br/> }<br/> }</span></pre><p id="5635" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在tasks/models.py中，我们首先创建任务模型来存储任务细节。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="dc22" class="mh lf it my b gy nc nd l ne nf">from django.db import models<br/> import datetime<br/> import uuid<br/> from django.utils import timezone<br/> now = timezone.now</span><span id="a446" class="mh lf it my b gy ng nd l ne nf"># Create your models here.<br/>class Task(models.Model):<br/> id = models.UUIDField(primary_key=True, default=uuid.uuid4)<br/> name = models.CharField(max_length=30, null=False, blank=False)<br/> description = models.CharField(max_length=30, null=False, blank=False)<br/> date = models.DateTimeField(default=timezone.now)<br/> <br/> class Meta:<br/> app_label = ‘tasks’</span></pre><p id="117f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的应用程序现在可以部署了。转到根文件夹，发出Docker build命令来构建我们的映像。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="d1f3" class="mh lf it my b gy nc nd l ne nf">docker-compose build</span></pre><p id="b39e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该命令将构建两个映像:</p><p id="1467" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在后台启动服务。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="15ca" class="mh lf it my b gy nc nd l ne nf">docker-compose up -d</span></pre><p id="1b1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后迁移数据库模型:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="e4e4" class="mh lf it my b gy nc nd l ne nf">docker-compose run main python manage.py migrate<br/>docker-compose run main Python manage.py makemigrations</span></pre><p id="eab9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建超级用户</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="1c5c" class="mh lf it my b gy nc nd l ne nf">docker-compose main Python manage.py createsuperuser</span></pre><h2 id="afad" class="mh lf it bd lg mi mj dn lk mk ml dp lo kr mm mn ls kv mo mp lw kz mq mr ma ms bi translated">Bash交互式shell</h2><p id="961c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">或者，您可以使用exec命令在映像中运行bash。首先通过发出。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="79bb" class="mh lf it my b gy nc nd l ne nf">docker container ps<br/> CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<br/> f2b050f94771 djangoapps_main “python manage.py ru…” 4 minutes ago Up 4 minutes 0.0.0.0:8001-&gt;8001/tcp djangoapps_main_1<br/> dc7661187cc5 postgres “docker-entrypoint.s…” 6 minutes ago Up 6 minutes 5432/tcp djangoapps_db_1</span></pre><p id="dbd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，您可以通过运行**exec**命令来执行容器中的命令。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="2777" class="mh lf it my b gy nc nd l ne nf">docker exec -it [container_name] /bin/bash</span></pre><p id="a8df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的案例中，它将是:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="99eb" class="mh lf it my b gy nc nd l ne nf">root@villehub:~/djangoapps# docker exec -i -t f2b050f94771 /bin/bash<br/> root@f2b050f94771:/project#</span></pre><p id="1bc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您在上面看到的，目录变成了</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="26e6" class="mh lf it my b gy nc nd l ne nf">root@f2b050f94771:/project#</span></pre><p id="3e38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还可以打开一个shell环境，在这里您可以执行命令，比如与数据库交互。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="0d79" class="mh lf it my b gy nc nd l ne nf">root@f2b050f94771:/project# python manage.py shell<br/> Python 3.7.2 (default, Dec 23 2020, 02:31:57)<br/> [GCC 6.3.0 20170516] on linux<br/> Type help”, copyright”, credits” or license” for more information.<br/> (InteractiveConsole)<br/> &gt;&gt;&gt;</span></pre><p id="aed5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，要在数据库中添加任务，我们将执行以下操作:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="baba" class="mh lf it my b gy nc nd l ne nf">&gt;&gt;&gt; from tasks.models import Task<br/>&gt;&gt;&gt; task1 = Task(name=”Task1",description=”Perform task 1")<br/>&gt;&gt;&gt; task1.save()<br/>&gt;&gt;&gt; task2 = Task(name=”Task2",description=”Perform task 2")<br/>&gt;&gt;&gt; task1.save()<br/>&gt;&gt;&gt; task3 = Task(name=”Task3",description=”Perform task 3")<br/>&gt;&gt;&gt; task1.save()</span></pre><p id="10d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">检索所有任务</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="8f74" class="mh lf it my b gy nc nd l ne nf">&gt;&gt;&gt; all = Task.objects.all()<br/>&gt;&gt;&gt; all<br/>&lt;QuerySet [&lt;Task: Task object (1914b174–031e-430c-b33c-43f9ce08161d)&gt;, &lt;Task: Task object (3510833a- bfcb-447a-8bc2–3c3bfa814559)&gt;, &lt;Task: Task object (6c01815a-1fe4–4381-af51–63637ab93d5b)&gt;]&gt;</span></pre><h1 id="1995" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="9962" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在本教程中，您了解了成功构建一个可靠的Django系统并将其部署到Docker Compose的必要条件。现在，您可以在端口8000导航到您的服务器的IP地址，您的Django应用程序应该已经启动并运行了。</p></div></div>    
</body>
</html>