<html>
<head>
<title>Building an RSocket based Springboot application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建基于RSocket的Springboot应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-an-rsocket-based-springboot-application-e386c84ec801?source=collection_archive---------12-----------------------#2020-10-11">https://levelup.gitconnected.com/building-an-rsocket-based-springboot-application-e386c84ec801?source=collection_archive---------12-----------------------#2020-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f51e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">权威指南</h2><div class=""/><div class=""><h2 id="42a0" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">RSocket是一种二进制协议，用于TCP、WebSockets和Aeron等字节流传输。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/08465e795c547f7fe4bebfa78aa6007a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AmL5RMEJprE6dAv5XwvJPg.jpeg"/></div></div></figure><h1 id="e930" class="ld le it bd lf lg lh li lj lk ll lm ln ki lo kj lp kl lq km lr ko ls kp lt lu bi translated">介绍</h1><p id="5cf7" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated">RSocket(反应式套接字)是一种通过TCP或Websockets工作的消息传递协议。该协议提供的通信模式有“一劳永逸”、“请求-响应”和“流式传输”。因为RSocket是完全反应式的，所以它是高吞吐量应用程序的理想选择。</p><p id="abac" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">在本帖中，我们将探索三种通信模式，即<code class="fe mw mx my mz b">fire-and-forget</code>、<code class="fe mw mx my mz b">request-response</code>和<code class="fe mw mx my mz b">streaming</code>，并用<code class="fe mw mx my mz b">RSocket Client CLI (RSC)</code>进行测试，这是一种邮差类型的应用程序，但要通过套接字测试应用程序。</p><h1 id="f906" class="ld le it bd lf lg lh li lj lk ll lm ln ki lo kj lp kl lq km lr ko ls kp lt lu bi translated">设置</h1><ol class=""><li id="2fd0" class="na nb it lx b ly lz mb mc me nc mi nd mm ne mq nf ng nh ni bi translated">安装Java最好是版本15。</li><li id="6999" class="na nb it lx b ly nj mb nk me nl mi nm mm nn mq nf ng nh ni bi translated">Spring boot骨架项目</li><li id="a087" class="na nb it lx b ly nj mb nk me nl mi nm mm nn mq nf ng nh ni bi translated">导航到<code class="fe mw mx my mz b">start.spring.io</code>，选择<code class="fe mw mx my mz b">RSocket</code>作为spring boot版本的依赖和稳定版本，点击<code class="fe mw mx my mz b">Generate</code>会给出一个zip文件，其中包含一个可以开始运行的框架项目。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi no"><img src="../Images/6c38bacc84fa86769eb6393e73668b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Awy9R-R49okcfHmF"/></div></div></figure><p id="e798" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">初始项目结构如下</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi np"><img src="../Images/92ce6023c6cfbc241eb4e6f789586989.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/0*vQZTyYGEKvURof0f"/></div></figure><ol class=""><li id="5cda" class="na nb it lx b ly mr mb ms me nq mi nr mm ns mq nf ng nh ni bi translated">应用程序配置</li><li id="134a" class="na nb it lx b ly nj mb nk me nl mi nm mm nn mq nf ng nh ni bi translated">接下来，通过修改文件<code class="fe mw mx my mz b">application.properties</code>来设置运行该应用程序的端口</li></ol><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="3f40" class="nx le it mz b gy ny nz l oa ob">spring.rsocket.server.port=7000<br/>spring.main.lazy-initialization=true</span></pre><ol class=""><li id="d639" class="na nb it lx b ly mr mb ms me nq mi nr mm ns mq nf ng nh ni bi translated">测试服务器应用程序的客户端:</li><li id="31c3" class="na nb it lx b ly nj mb nk me nl mi nm mm nn mq nf ng nh ni bi translated">这里我使用的是由<a class="ae oc" href="https://github.com/making/rsc" rel="noopener ugc nofollow" target="_blank"> Toshiaki Maki </a>创建的<strong class="lx jd"> RSC客户端</strong>。设置说明在他的GitHub页面上。</li></ol><p id="2646" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd">数据模型:</strong></p><p id="23f7" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">我们创建一个新的POJO类来表示客户机和服务器交换的数据。这个类现在将由两个成员变量组成，它们是<code class="fe mw mx my mz b">message</code> <code class="fe mw mx my mz b">created</code></p><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="48d2" class="nx le it mz b gy ny nz l oa ob">package com.example.rsocket;</span><span id="fbca" class="nx le it mz b gy od nz l oa ob">import java.time.Instant;</span><span id="c147" class="nx le it mz b gy od nz l oa ob">public class Message {</span><span id="11d7" class="nx le it mz b gy od nz l oa ob">  private String message; <br/>  private long created = Instant.now().getEpochSecond(); </span><span id="6d3e" class="nx le it mz b gy od nz l oa ob">  public Message(String message) {<br/>    this.message = message;<br/>  }</span><span id="24ce" class="nx le it mz b gy od nz l oa ob">  public String getMessage() {<br/>    return message;<br/>  }</span><span id="5c6f" class="nx le it mz b gy od nz l oa ob">  public void setMessage(String message) {<br/>    this.message = message;<br/>  }</span><span id="ec61" class="nx le it mz b gy od nz l oa ob">  public long getCreated() {<br/>    return created;<br/>  }</span><span id="e5e7" class="nx le it mz b gy od nz l oa ob">  public void setCreated(long created) {<br/>    this.created = created;<br/>  }<br/>}</span></pre><p id="f0dd" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">这应该得到基本项目设置，并准备好编写代码和通过套接字公开。</p><h1 id="ecf4" class="ld le it bd lf lg lh li lj lk ll lm ln ki lo kj lp kl lq km lr ko ls kp lt lu bi translated">通信模式1:请求-响应</h1><p id="f7e2" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated"><strong class="lx jd">发展</strong></p><p id="2cf3" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">请求-响应是一种经典的通信方式，客户端发出的每个请求都会得到响应。这是通过包含以下代码片段来实现的(完整代码可从Github资源库获得:<a class="ae oc" href="https://github.com/rockey5520/rsocket" rel="noopener ugc nofollow" target="_blank">https://github.com/rockey5520/rsocket</a>)</p><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="b1a8" class="nx le it mz b gy ny nz l oa ob">@MessageMapping("request-response")<br/>	Mono&lt;Message&gt; requestResponse(final Message message) {<br/>		System.out.println("Received request-response message: {}"+message);<br/>		return Mono.just(new Message("You said: " + message.getMessage()));<br/>	}</span></pre><p id="d0d3" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">上面代码的关键部分是<code class="fe mw mx my mz b">@MessageMapping("request-response")</code>,我们让spring boot知道当客户端使用<code class="fe mw mx my mz b">request-response</code>通信模式进行调用时，应该调用这个方法<code class="fe mw mx my mz b">requestResponse</code>。这里我们使用POJO类<code class="fe mw mx my mz b">Message</code>作为从客户端接收和响应客户端的有效负载。</p><p id="08e1" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">因为这是一个请求和响应模型，其中服务器对Spring Reactor <code class="fe mw mx my mz b">reactor.core</code>的客户端<code class="fe mw mx my mz b">Mono</code>发出的请求发送响应，这是完美的，因为只需要对每个请求发送一次响应。</p><p id="a600" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd">测试</strong></p><p id="ff78" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">使用安装的RSC客户端，如果您通过以下说明</p><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="58b3" class="nx le it mz b gy ny nz l oa ob">rsc --debug --request --data "{\"message\":\"Hello\"}" --route request-response --stacktrace tcp://localhost:7000</span></pre><p id="6409" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">如果运行成功，您将看到如下输出</p><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="315b" class="nx le it mz b gy ny nz l oa ob">Frame =&gt; Stream ID: 1 Type: REQUEST_RESPONSE Flags: 0b100000000 Length: 49<br/>Metadata:<br/>         +-------------------------------------------------+<br/>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br/>+--------+-------------------------------------------------+----------------+<br/>|00000000| fe 00 00 11 10 72 65 71 75 65 73 74 2d 72 65 73 |.....request-res|<br/>|00000010| 70 6f 6e 73 65                                  |ponse           |<br/>+--------+-------------------------------------------------+----------------+<br/>Data:<br/>         +-------------------------------------------------+<br/>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br/>+--------+-------------------------------------------------+----------------+<br/>|00000000| 7b 22 6d 65 73 73 61 67 65 22 3a 22 48 65 6c 6c |{"message":"Hell|<br/>|00000010| 6f 22 7d                                        |o"}             |<br/>+--------+-------------------------------------------------+----------------+<br/>2020-10-11 10:15:29.750 DEBUG --- [actor-tcp-nio-1] i.r.FrameLogger : receiving -&gt; <br/>Frame =&gt; Stream ID: 1 Type: NEXT_COMPLETE Flags: 0b1100000 Length: 56<br/>Data:<br/>         +-------------------------------------------------+<br/>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br/>+--------+-------------------------------------------------+----------------+<br/>|00000000| 7b 22 6d 65 73 73 61 67 65 22 3a 22 59 6f 75 20 |{"message":"You |<br/>|00000010| 73 61 69 64 3a 20 48 65 6c 6c 6f 22 2c 22 63 72 |said: Hello","cr|<br/>|00000020| 65 61 74 65 64 22 3a 31 36 30 32 34 31 31 33 32 |eated":160241132|<br/>|00000030| 39 7d                                           |9}              |<br/>+--------+-------------------------------------------------+----------------+<br/>{"message":"You said: Hello","created":1602411329}</span></pre><p id="3dcf" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">收到的响应由3个消息帧构成</p><p id="c5c3" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd">第1帧</strong></p><p id="2664" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">第一帧标记为元数据，显示发送到服务器的路由元数据(请求-响应)</p><p id="030d" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd">第二帧</strong></p><p id="e10a" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">第二帧显示了我们发送给服务器的数据(在本例中是“Hello”)一个JSON字符串</p><p id="dcf4" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd">第三帧</strong></p><p id="04c3" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">第三帧显示了发送回客户端的服务器响应。</p><h1 id="c5ff" class="ld le it bd lf lg lh li lj lk ll lm ln ki lo kj lp kl lq km lr ko ls kp lt lu bi translated">沟通模式2:解雇并忘记</h1><p id="2212" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated"><strong class="lx jd">发展</strong></p><p id="73e5" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">“一劳永逸”是另一种通信方式，在这种方式下，客户端发出的请求不会从服务器得到响应。这是通过包含以下代码片段来实现的(完整代码可从Github库获得:<a class="ae oc" href="https://github.com/rockey5520/rsocket" rel="noopener ugc nofollow" target="_blank">https://github.com/rockey5520/rsocket</a>)</p><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="4e1c" class="nx le it mz b gy ny nz l oa ob">@MessageMapping("fire-and-forget")<br/>	public Mono&lt;Void&gt; fireAndForget(final Message message) {<br/>		System.out.println("Received fire-and-forget request: {}"+ message);<br/>		return Mono.empty();<br/>	}</span></pre><p id="3903" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">上面代码的关键部分是<code class="fe mw mx my mz b">@MessageMapping("fire-and-forget")</code>,我们让spring boot知道，当客户端使用<code class="fe mw mx my mz b">fire-and-forget communication mode. Here we are using the POJO class </code>消息作为从客户端接收的有效载荷进行调用时，应该调用这个方法<code class="fe mw mx my mz b">fireAndForget</code>。</p><p id="f90c" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd">测试</strong></p><p id="3fdb" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">使用安装的RSC客户端，如果您通过以下说明</p><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="c664" class="nx le it mz b gy ny nz l oa ob">rsc --debug --fnf --data "{\"message\":\"Hello\"}" --route fire-and-forget --stacktrace tcp://localhost:7000</span></pre><p id="253b" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">如果运行成功，您将看到如下输出</p><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="c2dc" class="nx le it mz b gy ny nz l oa ob">2020-10-11 10:31:28.398 DEBUG --- [     parallel-2] i.r.FrameLogger : sending -&gt; <br/>Frame =&gt; Stream ID: 1 Type: REQUEST_FNF Flags: 0b100000000 Length: 48<br/>Metadata:<br/>         +-------------------------------------------------+<br/>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br/>+--------+-------------------------------------------------+----------------+<br/>|00000000| fe 00 00 10 0f 66 69 72 65 2d 61 6e 64 2d 66 6f |.....fire-and-fo|<br/>|00000010| 72 67 65 74                                     |rget            |<br/>+--------+-------------------------------------------------+----------------+<br/>Data:<br/>         +-------------------------------------------------+<br/>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br/>+--------+-------------------------------------------------+----------------+<br/>|00000000| 7b 22 6d 65 73 73 61 67 65 22 3a 22 48 65 6c 6c |{"message":"Hell|<br/>|00000010| 6f 22 7d                                        |o"}             |<br/>+--------+-------------------------------------------------+----------------+</span></pre><p id="b38b" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">收到的响应由两个消息帧构成</p><p id="c898" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd">第一帧</strong></p><p id="f60b" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">第一帧标记为元数据，显示发送到服务器的路由元数据(请求-响应)</p><p id="5b00" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd">第二帧</strong></p><p id="a680" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">第二帧显示了我们发送给服务器的数据(在本例中是“Hello”)一个JSON字符串</p><h1 id="1f0f" class="ld le it bd lf lg lh li lj lk ll lm ln ki lo kj lp kl lq km lr ko ls kp lt lu bi translated">通信模式3:请求流</h1><p id="d4a1" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated"><strong class="lx jd">发展</strong></p><p id="fcd5" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">这种通信模式适用于客户端发出单个请求，服务器以一系列响应进行响应的通信。这是通过包含以下代码片段来实现的(完整代码可从Github资源库获得:<a class="ae oc" href="https://github.com/rockey5520/rsocket" rel="noopener ugc nofollow" target="_blank">https://github.com/rockey5520/rsocket</a>)</p><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="eaec" class="nx le it mz b gy ny nz l oa ob">@MessageMapping("request-stream")<br/>	Flux&lt;Message&gt; stream(final Message message) {<br/>		return Flux<br/>				// create a new indexed Flux emitting one element every second<br/>				.interval(Duration.ofSeconds(1))<br/>				// create a Flux of new Messages using the indexed Flux<br/>				.map(index -&gt; new Message("You said: " + message.getMessage() + ". Response #" + index))<br/>				// show what's happening<br/>				.log();<br/>	}</span></pre><p id="6d63" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">上面代码的关键部分是<code class="fe mw mx my mz b">@MessageMapping("request-stream")</code>,我们让spring boot知道，当客户端使用<code class="fe mw mx my mz b">request-stream communication mode. Here we are using the POJO class </code>消息作为有效负载进行调用时，应该调用这个方法<code class="fe mw mx my mz b">stream</code>,以便每1秒钟从客户端接收和发送一次Message类型的响应流，这是通过使用<code class="fe mw mx my mz b">Flux</code>实现的。</p><p id="d95e" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd">测试</strong></p><p id="7aeb" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">使用安装的RSC客户端，如果您通过以下说明</p><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="c6e6" class="nx le it mz b gy ny nz l oa ob">rsc --debug --stream --data "{\"message\":\"Hello\"}" --route request-stream --stacktrace tcp://localhost:7000</span></pre><p id="a399" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">如果运行成功，您将看到如下输出</p><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="2aff" class="nx le it mz b gy ny nz l oa ob">2020-10-11 10:42:40.638 DEBUG --- [     parallel-2] i.r.FrameLogger : sending -&gt; <br/>Frame =&gt; Stream ID: 1 Type: REQUEST_STREAM Flags: 0b100000000 Length: 51 InitialRequestN: 9223372036854775807<br/>Metadata:<br/>         +-------------------------------------------------+<br/>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br/>+--------+-------------------------------------------------+----------------+<br/>|00000000| fe 00 00 0f 0e 72 65 71 75 65 73 74 2d 73 74 72 |.....request-str|<br/>|00000010| 65 61 6d                                        |eam             |<br/>+--------+-------------------------------------------------+----------------+<br/>Data:<br/>         +-------------------------------------------------+<br/>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br/>+--------+-------------------------------------------------+----------------+<br/>|00000000| 7b 22 6d 65 73 73 61 67 65 22 3a 22 48 65 6c 6c |{"message":"Hell|<br/>|00000010| 6f 22 7d                                        |o"}             |<br/>+--------+-------------------------------------------------+----------------+<br/>2020-10-11 10:42:41.749 DEBUG --- [actor-tcp-nio-1] i.r.FrameLogger : receiving -&gt; <br/>Frame =&gt; Stream ID: 1 Type: NEXT Flags: 0b100000 Length: 69<br/>Data:<br/>         +-------------------------------------------------+<br/>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br/>+--------+-------------------------------------------------+----------------+<br/>|00000000| 7b 22 6d 65 73 73 61 67 65 22 3a 22 59 6f 75 20 |{"message":"You |<br/>|00000010| 73 61 69 64 3a 20 48 65 6c 6c 6f 2e 20 52 65 73 |said: Hello. Res|<br/>|00000020| 70 6f 6e 73 65 20 23 30 22 2c 22 63 72 65 61 74 |ponse #0","creat|<br/>|00000030| 65 64 22 3a 31 36 30 32 34 31 32 39 36 31 7d    |ed":1602412961} |<br/>+--------+-------------------------------------------------+----------------+<br/>{"message":"You said: Hello. Response #0","created":1602412961}<br/>2020-10-11 10:42:42.707 DEBUG --- [actor-tcp-nio-1] i.r.FrameLogger : receiving -&gt; <br/>Frame =&gt; Stream ID: 1 Type: NEXT Flags: 0b100000 Length: 69<br/>Data:</span></pre><p id="df95" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">收到的此响应是返回到rsc客户端的响应流。</p><h1 id="cf1a" class="ld le it bd lf lg lh li lj lk ll lm ln ki lo kj lp kl lq km lr ko ls kp lt lu bi translated">沟通模式4:渠道</h1><p id="8f34" class="pw-post-body-paragraph lv lw it lx b ly lz kd ma mb mc kg md me mf mg mh mi mj mk ml mm mn mo mp mq im bi translated"><strong class="lx jd">发展</strong></p><p id="bab7" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">这种通信模式用于客户端和服务器可以发送消息流的通信，本质上是双向的消息流。这是通过包含以下代码片段来实现的(完整代码可从Github资源库获得:<a class="ae oc" href="https://github.com/rockey5520/rsocket" rel="noopener ugc nofollow" target="_blank">https://github.com/rockey5520/rsocket</a>)</p><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="0ac8" class="nx le it mz b gy ny nz l oa ob">@MessageMapping("stream-stream")<br/>	Flux&lt;Message&gt; channel(final Flux&lt;Integer&gt; input) {<br/>		System.out.println("Received stream-stream (channel) request...");<br/>		return settings<br/>				.doOnNext(input -&gt; System.out.println("Requested interval is {} seconds."+ setting))<br/>				.doOnCancel(() -&gt; System.out.println("The client cancelled the channel."))<br/>				.switchMap(input -&gt; Flux.interval(Duration.ofSeconds(input))<br/>						.map(index -&gt; new Message("Stream Response #" + index)))<br/>				.log();<br/>	}</span></pre><p id="3969" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">上面代码的关键部分是<code class="fe mw mx my mz b">@MessageMapping("stream-stream")</code>,我们让spring boot知道当客户端使用<code class="fe mw mx my mz b">stream-stream</code>通信模式进行调用时，应该调用这个方法<code class="fe mw mx my mz b">channel</code>。</p><p id="c3da" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">这里，我们为作为流的一部分发送的每个请求(<code class="fe mw mx my mz b">input</code>)返回<code class="fe mw mx my mz b">Flux</code>，通过实现<code class="fe mw mx my mz b">back pressure</code>，使用输入有效负载中发送的持续时间创建新的出站流量，其中客户端控制服务器响应流的速度。对于视频流等功能来说，这是一个非常好的特性，用户可以根据客户端的互联网速度来控制服务器传输视频的速度</p><p id="e2ab" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd">测试</strong></p><p id="7330" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">使用安装的RSC客户端，如果您通过以下说明</p><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="01c5" class="nx le it mz b gy ny nz l oa ob">rsc --debug --channel --data - --route stream-stream --stacktrace tcp://localhost:7000</span></pre><p id="d8fe" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">现在，命令行等待用户输入的时间间隔以秒为单位，假设1个服务器每1秒钟响应一次消息流，当消息流传输时，您可以更改为10，并看到服务器将其传输速度从1秒钟更改为10秒钟，当您需要构建一个客户端需要施加反压力并让服务器知道它期望的响应速度的应用程序时，这是非常惊人的。</p><pre class="ks kt ku kv gt nt mz nu nv aw nw bi"><span id="e8a5" class="nx le it mz b gy ny nz l oa ob">rockey@ubuntu:~/projects/rsocket$ rsc --debug --channel --data - --route stream-stream --stacktrace tcp://localhost:7000<br/>3<br/>2020-10-11 11:06:39.843 DEBUG --- [     parallel-2] i.r.FrameLogger : sending -&gt; <br/>Frame =&gt; Stream ID: 1 Type: REQUEST_CHANNEL Flags: 0b100000000 Length: 32 InitialRequestN: 9223372036854775807<br/>Metadata:<br/>         +-------------------------------------------------+<br/>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br/>+--------+-------------------------------------------------+----------------+<br/>|00000000| fe 00 00 0e 0d 73 74 72 65 61 6d 2d 73 74 72 65 |.....stream-stre|<br/>|00000010| 61 6d                                           |am              |<br/>+--------+-------------------------------------------------+----------------+<br/>Data:<br/>         +-------------------------------------------------+<br/>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br/>+--------+-------------------------------------------------+----------------+<br/>|00000000| 33                                              |3               |<br/>+--------+-------------------------------------------------+----------------+<br/>2020-10-11 11:06:39.847 DEBUG --- [actor-tcp-nio-1] i.r.FrameLogger : receiving -&gt; <br/>Frame =&gt; Stream ID: 1 Type: REQUEST_N Flags: 0b0 Length: 10 RequestN: 9223372036854775807<br/>Data:</span><span id="3868" class="nx le it mz b gy od nz l oa ob">2020-10-11 11:06:42.849 DEBUG --- [actor-tcp-nio-1] i.r.FrameLogger : receiving -&gt; <br/>Frame =&gt; Stream ID: 1 Type: NEXT Flags: 0b100000 Length: 59<br/>Data:<br/>         +-------------------------------------------------+<br/>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br/>+--------+-------------------------------------------------+----------------+<br/>|00000000| 7b 22 6d 65 73 73 61 67 65 22 3a 22 53 74 72 65 |{"message":"Stre|<br/>|00000010| 61 6d 20 52 65 73 70 6f 6e 73 65 20 23 30 22 2c |am Response #0",|<br/>|00000020| 22 63 72 65 61 74 65 64 22 3a 31 36 30 32 34 31 |"created":160241|<br/>|00000030| 34 34 30 32 7d                                  |4402}           |<br/>+--------+-------------------------------------------------+----------------+<br/>{"message":"Stream Response #0","created":1602414402}<br/>10<br/>2020-10-11 11:06:45.216 DEBUG --- [oundedElastic-1] i.r.FrameLogger : sending -&gt; <br/>Frame =&gt; Stream ID: 1 Type: NEXT Flags: 0b100100000 Length: 29<br/>Metadata:<br/>         +-------------------------------------------------+<br/>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br/>+--------+-------------------------------------------------+----------------+<br/>|00000000| fe 00 00 0e 0d 73 74 72 65 61 6d 2d 73 74 72 65 |.....stream-stre|<br/>|00000010| 61 6d                                           |am              |<br/>+--------+-------------------------------------------------+----------------+<br/>Data:<br/>         +-------------------------------------------------+<br/>         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |<br/>+--------+-------------------------------------------------+----------------+<br/>|00000000| 31 30                                           |10              |<br/>+--------+-------------------------------------------------+----------------+</span></pre><p id="1a44" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated">收到的此响应是返回到rsc客户端的响应流。</p><p id="613e" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><strong class="lx jd">附加阅读材料:</strong></p><p id="9746" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><a class="ae oc" href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web-reactive.html#rsocket-annot-responders" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-framework/docs/current/spring-framework-reference/we B- reactive . html # r socket-annot-responders</a></p><p id="4e8e" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><a class="ae oc" href="https://github.com/benwilcock/springone-2020-rsocket-talk/tree/master/rsocket-server" rel="noopener ugc nofollow" target="_blank">https://github . com/benwilcock/spring one-2020-rsocket-talk/tree/master/rsocket-server</a></p><p id="f5b0" class="pw-post-body-paragraph lv lw it lx b ly mr kd ma mb ms kg md me mt mg mh mi mu mk ml mm mv mo mp mq im bi translated"><a class="ae oc" href="https://benwilcock.wordpress.com/2020/06/25/getting-started-with-rsocket-on-spring-boot/" rel="noopener ugc nofollow" target="_blank">https://benwilcock . WordPress . com/2020/06/25/getting-started-with-rsocket-on-spring-boot/</a></p></div></div>    
</body>
</html>