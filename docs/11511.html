<html>
<head>
<title>Queue using Two Stacks —Hackerrank</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用两个堆栈的队列—Hackerrank</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/queue-using-stacks-leetcode-972bd1d53a9c?source=collection_archive---------14-----------------------#2022-03-22">https://levelup.gitconnected.com/queue-using-stacks-leetcode-972bd1d53a9c?source=collection_archive---------14-----------------------#2022-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/5f5160a27b3e9edb64996138c678a7b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*U-hts_af2-XGTY4jh0wrYA.jpeg"/></div></figure><h1 id="4f06" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">问题</h1><p id="c7bd" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">使用两个堆栈实现队列。然后处理<code class="fe lq lr ls lt b">q</code>个查询，其中每个查询都是以下<code class="fe lq lr ls lt b">3</code>种类型之一:</p><ol class=""><li id="c308" class="lu lv iq ku b kv lw kz lx ld ly lh lz ll ma lp mb mc md me bi translated">将元素<code class="fe lq lr ls lt b">x</code>放入队列的末尾</li><li id="6d94" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">将队列前面的元素出队</li><li id="1953" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">打印队列前面的元素</li></ol><h2 id="6d7c" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">例子</h2><h2 id="28bd" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">投入</h2><p id="bb54" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">第一行包含一个整数q，表示查询的次数。</p><p id="8f8b" class="pw-post-body-paragraph ks kt iq ku b kv lw kx ky kz lx lb lc ld mw lf lg lh mx lj lk ll my ln lo lp ij bi translated"><code class="fe lq lr ls lt b">q</code>后续行的每一行<code class="fe lq lr ls lt b">i</code>都包含一个查询，其形式如上述问题陈述中所述。所有三个查询都以表示查询<code class="fe lq lr ls lt b">type</code>的整数开始，但是只有查询<code class="fe lq lr ls lt b">1</code>后面跟有一个附加的空格分隔值<code class="fe lq lr ls lt b">x</code>，表示要排队的值。</p><ul class=""><li id="995f" class="lu lv iq ku b kv lw kz lx ld ly lh lz ll ma lp mz mc md me bi translated">1 →排队</li><li id="d2f4" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mz mc md me bi translated">2 →出列</li><li id="5ddd" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mz mc md me bi translated">3 →打印队列的最前面</li></ul><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/9b4b70e08d821acc29a1cd0c7b5fd8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*ditpe6Zf2zy3zQBbzPzjmw.png"/></div></figure><h2 id="9a46" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">输出</h2><p id="0385" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">对于每个类型为<code class="fe lq lr ls lt b">3</code>的查询，在新的一行中打印队列前面的元素的值。</p><pre class="nb nc nd ne gt nf lt ng nh aw ni bi"><span id="ca11" class="mk jv iq lt b gy nj nk l nl nm">14<br/>14</span></pre><h2 id="0a73" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">说明</h2><p id="c879" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">执行以下一系列操作:</p><ol class=""><li id="7cda" class="lu lv iq ku b kv lw kz lx ld ly lh lz ll ma lp mb mc md me bi translated">排队42；队列= {42}</li><li id="3a84" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">将队列头的值出队，42；队列= {}</li><li id="9696" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">排队14；队列= {14}</li><li id="e822" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">打印队列头的值，14；队列= {14}</li><li id="d147" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">排队28；队列= {14，28}</li><li id="23b4" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">打印队列头的值，14；队列= {14，28}</li><li id="12fa" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">排队60；队列= {14，28，60}</li><li id="5b56" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">排队78；queue = {14，28，60，78}</li><li id="0006" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">将队列头的值出队，14；队列= {28，60，78}</li><li id="7c46" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mb mc md me bi translated">将队列头的值出队，28；队列= {60，78}</li></ol><h1 id="724c" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">算法走查</h1><h2 id="4098" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">排队42</h2><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/2a2ce6f4b2c6973a11d9add3ac4627a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*HhaHV4Hsdgy4cGcqXheWww.jpeg"/></div></figure><h2 id="03a2" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">出列</h2><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/e4abf83791e98021f971c60166762636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*WhophOGpjV0lrFINpTe1YQ.jpeg"/></div></figure><h2 id="345a" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">排队14</h2><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/fdc1861342269e642c42a1b8d4225a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*CzQsK1AAlj5HfnDS99vQzw.jpeg"/></div></figure><h2 id="0662" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">检查传入堆栈的顶部</h2><p id="1bfd" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">答案是14。</p><h2 id="f6bc" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">排队28</h2><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/ba34a36b0c4035582591c5c084bb53f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*-g_1XQ-5b1vi2invVwppAg.jpeg"/></div></figure><h2 id="13c5" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">检查传入堆栈的底部</h2><p id="c9b5" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">答案是14。</p><h2 id="635d" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">排队60</h2><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/14871d4b798cc11bd356792c62873de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*FdGeNsN0XhOP8q5RCCjv8Q.jpeg"/></div></figure><h2 id="de77" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">排队78</h2><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/9ecb7ab7d6960846aa0fc79af451f57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*sgAgCX9cxKcUEnu69ZQP2g.jpeg"/></div></figure><h2 id="f0be" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">出列</h2><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/bb49723b3d483a61dab44749c97dd3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*IhXcpPBqkq6mIPR-6i34yQ.jpeg"/></div></figure><h2 id="a59a" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">出列</h2><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/9ad369e8ffd9105f4a97a513af56e3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*u3NT2MVfnho7WqiV-CqZXg.jpeg"/></div></figure><h2 id="24d5" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">检查传出堆栈的顶部</h2><p id="c869" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">答案是60。</p><h1 id="3e8b" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">解决办法</h1><pre class="nb nc nd ne gt nf lt ng nh aw ni bi"><span id="a93d" class="mk jv iq lt b gy nj nk l nl nm">def Solution(input_arr):<br/>    out_stack, in_stack = [], []<br/>    <br/>    for _input in input_arr:<br/>        val = list(map(<br/>            int, <br/>            _input.split()<br/>        ))<br/>        <br/>        if val[0] == 1:<br/>            in_stack.append(val[1])<br/>            <br/>        elif val[0] == 2:<br/>            if not out_stack :<br/>                while in_stack:<br/>                    out_stack.append(<br/>                        in_stack.pop()<br/>                    )<br/>            out_stack.pop()<br/>            <br/>        else:<br/>            print(out_stack[-1] if out_stack else in_stack[0])<br/>            <br/>Solution([<br/>    "1 42",<br/>    "2",<br/>    "1 14",<br/>    "3",<br/>    "1 28",<br/>    "3",<br/>    "1 60",<br/>    "1 78",<br/>    "2",<br/>    "2"<br/>])</span></pre><h2 id="8321" class="mk jv iq bd jw ml mm dn ka mn mo dp ke ld mp mq ki lh mr ms km ll mt mu kq mv bi translated">时间和空间复杂性</h2><ul class=""><li id="dee1" class="lu lv iq ku b kv kw kz la ld nq lh nr ll ns lp mz mc md me bi translated"><strong class="ku ir">时间复杂度</strong> : O(N*N)。给定N是数组中元素的数量。可能存在这样一种情况，其中存在所有入队命令，然后当调用出队命令时，可能需要N次才能从传入堆栈弹出并推入传出堆栈。</li><li id="efdd" class="lu lv iq ku b kv mf kz mg ld mh lh mi ll mj lp mz mc md me bi translated"><strong class="ku ir">空间复杂度</strong>:如果要考虑栈，那么应该是O(N+N)。</li></ul><h1 id="c272" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">外卖食品</h1><p id="d874" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">感谢您阅读这个简短的解题问题。如果有人知道更好或更快的时间复杂度来解决这个问题，请随意评论和反馈。和平！✌️</p></div></div>    
</body>
</html>