<html>
<head>
<title>The Key Concepts You Need to Understand About React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您需要了解的关于React的关键概念</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/new-to-react-you-need-to-understand-these-key-concepts-before-anything-else-2247efc1eaac?source=collection_archive---------2-----------------------#2019-01-29">https://levelup.gitconnected.com/new-to-react-you-need-to-understand-these-key-concepts-before-anything-else-2247efc1eaac?source=collection_archive---------2-----------------------#2019-01-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq"><p id="a80e" class="jr js it bd jt ju jv jw jx jy jz ka dk translated">你刚刚完成的那个在线教程并没有教会你React的“大局”。不要犯和我一样的错误…</p></blockquote><figure class="kc kd ke kf kg kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kb"><img src="../Images/0df59f320902185b9fa1f2a7822eb0fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJP-4Gjm_udlp-onF15kCw.png"/></div></div></figure><h1 id="1915" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">了解全局</h1><blockquote class="jq"><p id="590d" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">起初React难倒了我。</p></blockquote><p id="a4c8" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">在线教程甚至官方文档有时在解释React如何工作以及为什么这样工作方面做得很差。</p><p id="afde" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">如果你正在学习React，你可能不会完全理解所有的东西是如何组合在一起的。如果没有这种理解，你就会遇到障碍，你会花更多的时间去适应。</p><p id="e204" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">React是世界上最受欢迎的前端库，这是有原因的，但一开始你可能会很难学会用React的术语来思考。尤其是如果你从未使用过其他前端库/框架的话。</p><p id="6c6f" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">当我开始学习React时，我很困惑。组件、道具、构造函数、组件状态和JSX一起搅乱了我的大脑。直到我退一步看大局，做一些研究，我终于明白了一切是如何结合在一起的。</p><blockquote class="jq"><p id="9e0c" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">在这篇文章中，我将省去你阅读和研究的时间。我已经把我学习React如何工作的所有笔记放在一起，并提炼出最基本的要点来帮助你理解React。</p></blockquote><p id="e643" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">React可能很复杂，大多数教程都让它太复杂、太快。然而，如果你正在学习React，你只需要知道几个关键概念就可以释放它的力量。我将在这里分享这些概念。</p><h1 id="d3ca" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">React不是一个框架，所以不要称它为框架</h1><p id="f87a" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">React经常与Angular混为一谈，被称为“前端框架”</p><p id="dd6f" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">这似乎是一个很小的区别，但是这个术语——“框架”——伴随着很多包袱。框架意味着一个相互依赖的工具生态系统。当你创建一个Angular应用时，你必须按照Angular的方式来做。</p><blockquote class="jq"><p id="b26d" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">但是React不是这样的。</p></blockquote><p id="0a3c" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">它不依赖于特定的生态系统来工作。简单多了。React是一个“库”，而不是一个框架。</p><p id="18c2" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">这种区别对于如何使用React有着深远的影响。它可以在不同种类的后端上工作，你可以在同一个应用程序中把它和其他工具一起部署。</p><p id="b9e2" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">如果你已经有一个现有的应用程序，随着时间的推移慢慢加入React是完全可能的。只是一次构建一个组件！</p><h2 id="fe1b" class="my kp it bd kq mz na dn ku nb nc dp ky mc nd ne lc mg nf ng lg mk nh ni lk nj bi translated"><strong class="ak">啊哈时刻:</strong></h2><blockquote class="nk nl nm"><p id="fcca" class="lr ls nn lt b lu mo lw lx ly mp ma mb no mq me mf np mr mi mj nq ms mm mn ka im bi translated">当你用React构建一些东西时，你并不是真正在构建一个“React应用程序”</p></blockquote><p id="486d" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">相反，您只是在React中构建一部分网页，React负责处理这部分网页的功能和呈现方式。</p><h1 id="2fc9" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">组件很酷！</h1><blockquote class="jq"><p id="8f24" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">由于React是一个库，而不是一个框架，我们在React中构建网页片段，而不是整个React应用程序。</p></blockquote><p id="ccac" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">当然，如果您想将多个部分组合成一个完整的应用程序，这取决于您。但是如果你愿意的话，你也可以在普通的HTML页面中放置一些React。</p><p id="fddc" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">这些“网页片段”是React的“组件”。</p><p id="956c" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">当您使用React时，您是在使用JavaScript创建可以放在web页面中的组件。</p><p id="1f6f" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">这种关系通常采取创建组件的形式:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="b3d0" class="my kp it nw b gy oa ob l oc od">class Hello extends React.Component {<br/>  render() {<br/>    return &lt;h1&gt;Hello World&lt;/h1&gt;;  <br/>  }<br/>}</span></pre><p id="06ea" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">然后像使用html标记一样使用该组件。我们使用JavaScript告诉浏览器在哪里放置我们的新组件。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="8161" class="my kp it nw b gy oa ob l oc od">ReactDOM.render(&lt;Hello /&gt;, document.getElementById('root'));</span></pre><p id="32fc" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">上面的代码告诉React将新组件放入我们的HTML文件中，只要有一个id为“root”的元素。</p><p id="fcfd" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">(如果您是React新手，您可能正在为将HTML标签直接混合到JavaScript中而挠头。别担心，这不是真正的HTML，而是React的一种特殊标记，叫做JSX。在“你对JSX的问题是你不了解JSX”一节中会有更多的介绍。)</p><h2 id="a9b5" class="my kp it bd kq mz na dn ku nb nc dp ky mc nd ne lc mg nf ng lg mk nh ni lk nj bi translated"><strong class="ak">啊哈时刻:</strong></h2><p id="061d" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">您可以在React中构建一个完全静态的站点，它根本不是交互式的。你只需要用JSX创建组件，然后把它们放到你的网站上。反应不一定要互动，只要<strong class="lt iu"> <em class="nn">能</em> </strong>能并且擅长就行。</p><p id="e718" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">需要明确的是，对于静态网站，React和JSX并不是模板语法的好选择。您可能想选择其他不太复杂且开销较少的东西。</p><blockquote class="jq"><p id="bd0b" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">不过，最基本的是，React是一种使用JavaScript定义网页的一部分，然后将该组件放入网页的方法。</p></blockquote><p id="0576" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">组件也是可重用的，所以如果我们定义了它，我们就可以在我们站点的任何地方使用它。</p><h1 id="a700" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">与DOMs的交易</h1><p id="e34a" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">看起来很酷，对吧？模板化和可重用组件离突破性还很远，但在基本的、直观的层面上，这就是React正在做的事情。</p><blockquote class="nk nl nm"><p id="5aad" class="lr ls nn lt b lu mo lw lx ly mp ma mb no mq me mf np mr mi mj nq ms mm mn ka im bi translated">但是React是如何使用JavaScript将组件放置到网页中的呢？</p></blockquote><p id="6280" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">当您使用JavaScript在网页上做一些事情(任何事情)时，您编写的JavaScript需要一种方式来与HTML和组成网页的其他文档进行交互。</p><p id="7689" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">JavaScript通过一个称为文档对象模型(DOM)的API来实现这一点。如果您编写过JavaScript，那么您可能听说过DOM并与之交互过。</p><figure class="nr ns nt nu gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oe"><img src="../Images/9a1e0169b2c3988ab9ff5207b973bc62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aE2z8HxZ8lr8cIbz4waKog.png"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">大教堂</figcaption></figure><p id="ac29" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">然而，对于复杂的网站来说，管理和修改DOM很快就会成为一个挑战。当多个脚本需要访问多个DOM对象时，维护DOM的一致状态需要各种操作和检查，有些事情您可能想做却完全不可能。</p><blockquote class="jq"><p id="64ff" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">管理DOM是React的一项突破性技术。</p></blockquote><p id="c596" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">React没有试图直接管理DOM，而是创建了一个新版本，称为React虚拟DOM。当您编写React代码时，您是在对虚拟DOM进行更改，而不是对真实DOM进行更改。</p><p id="668e" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">这就是为什么在我给出的Hello示例中，我们呈现给ReactDOM，而不是直接呈现给实际的DOM:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="063a" class="my kp it nw b gy oa ob l oc od">ReactDOM.render(&lt;Hello /&gt;, document.getElementById('root'));</span></pre><p id="7796" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">当用户单击按钮或在React组件中输入值时，React会将虚拟DOM的状态与真实DOM的状态进行比较。如果它们相同，React不需要做任何事情。如果它们不同，React会更新真实DOM以匹配虚拟DOM。</p><h2 id="6e3e" class="my kp it bd kq mz na dn ku nb nc dp ky mc nd ne lc mg nf ng lg mk nh ni lk nj bi translated">啊哈时刻:</h2><blockquote class="jq"><p id="d827" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">React“反应”虚拟DOM中的变化，并在真实DOM中进行这些变化。</p></blockquote><p id="5006" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">惊呆了。？？</p><p id="6d6c" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">那么到目前为止我们学到了什么？</p><ul class=""><li id="a2a9" class="oj ok it lt b lu mo ly mp mc ol mg om mk on ka oo op oq or bi translated">React是一个允许你创建可重用组件的库。</li><li id="8cd8" class="oj ok it lt b lu os ly ot mc ou mg ov mk ow ka oo op oq or bi translated">它还是一个DOM管理器，可以比较站点文档对象树的虚拟和真实版本。</li></ul><p id="266e" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">这种组合的含义是，您可以在组件内部和组件之间编写复杂的交互，无需重新加载页面即可无缝呈现。</p><p id="2d67" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">此外，您不再需要担心DOM并对其进行修改。相反，React会在编译时提醒您任何问题。</p><h1 id="17b7" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">请把道具递过来</h1><figure class="nr ns nt nu gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/d54e313aa82e7479998af0447b394b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*djk0MzJw0BiDnZupDCX1hw.jpeg"/></div></div><figcaption class="of og gj gh gi oh oi bd b be z dk translated">React有点像家庭晚餐，父母把东西传给孩子</figcaption></figure><p id="3189" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">好了，我们已经了解了React的核心概念:创建组件并在虚拟DOM中呈现它们。理解这些基本概念是理解当事情变得更加复杂时React为什么以及如何工作的关键。</p><blockquote class="jq"><p id="3801" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">在React中，组件可以相互调用和对话。当它们这样做时，它们可以将信息作为属性在它们之间传递。</p></blockquote><p id="c04d" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">假设我们在React中创建了一个数独、跳棋或国际象棋游戏。委员会的基本结构是:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="86a2" class="my kp it nw b gy oa ob l oc od">class Board extends React.Component {<br/>  <br/>  ...</span><span id="eb64" class="my kp it nw b gy oy ob l oc od">  renderSquare(squareValue) {<br/>    return (<br/>      &lt;Square <br/>        value={squareValue}<br/>      /&gt;<br/>    );<br/>  }<br/>  <br/>  ...<br/>}</span></pre><p id="1e5f" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">为了突出一个组件如何调用另一个组件，上面我已经省略了Board组件的很多细节。</p><p id="ea9c" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">在Board的<code class="fe oz pa pb nw b">renderSquare()</code>方法中，它返回一个<code class="fe oz pa pb nw b">&lt;Square /&gt;</code>。这是React应用程序中的常见模式。</p><p id="0fc2" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">很可能，在Board类的其他地方，Board会多次调用<code class="fe oz pa pb nw b">renderSquare()</code>，创建许多不同的Square组件，这些组件都是Board的子组件。</p><p id="f3e2" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">随着<code class="fe oz pa pb nw b">renderSquare()</code>的每次调用，变量<code class="fe oz pa pb nw b">squareValue</code>会发生变化。因此，每个新的方块可能有不同的值。</p><p id="4bc8" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">这些从父节点传递到子节点的值就是React中的“道具”(属性的缩写)。</p><p id="4cb3" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">在Square类的声明中，我们现在可以访问板子作为道具传入的任何信息。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="debc" class="my kp it nw b gy oa ob l oc od">class Square extends React.Component {<br/>  render () {<br/>    return (<br/>      &lt;button&gt;{props.value}&lt;/button&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="ae9f" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">使用<code class="fe oz pa pb nw b">props.value</code> React知道使用我们在创建正方形时传入的<code class="fe oz pa pb nw b">value</code>。</p><p id="3d79" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">(这个例子来自React官方教程，其中你构建了一个井字游戏。Board组件呈现并管理9个方块作为子组件。参见Codepen 上的这个<a class="ae pc" href="https://codepen.io/gaearon/pen/gWWZgR?editors=0010" rel="noopener ugc nofollow" target="_blank">工作示例。)</a></p><h2 id="09a6" class="my kp it bd kq mz na dn ku nb nc dp ky mc nd ne lc mg nf ng lg mk nh ni lk nj bi translated">啊哈时刻</h2><blockquote class="jq"><p id="ab96" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">React使组件之间传递信息变得非常简单。但是有一点要尽早意识到，道具只在一个方向起作用。</p></blockquote><p id="b12e" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">父母可以将信息传递给他们的孩子，但是如果孩子需要将信息传递回父母，你需要在你的父母中定义一个函数，允许孩子将信息向上移动。</p><p id="e37a" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">将道具传递给错误的方向或试图将道具传递给父母是React初学者犯的最大错误之一。</p></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><h1 id="3388" class="ko kp it bd kq kr pk kt ku kv pl kx ky kz pm lb lc ld pn lf lg lh po lj lk ll bi translated">喜欢你在这里读到的吗？</h1><p id="6e69" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">我免费与我的电子邮件列表分享我最好的内容。</p><p id="7968" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated"><a class="ae pc" href="https://sunny-architect-5371.ck.page/0a60026a5d" rel="noopener ugc nofollow" target="_blank">加入我的电子邮件系列中目前的500名其他开发人员。</a></p></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><h1 id="835b" class="ko kp it bd kq kr pk kt ku kv pl kx ky kz pm lb lc ld pn lf lg lh po lj lk ll bi translated">沿着链条向上移动权力</h1><p id="aedc" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">让我们想象一下，当一个按钮被点击时，我们想要做一些事情。</p><p id="e8ba" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">在普通的JavaScript中，我们使用onclick事件来更新DOM。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="9677" class="my kp it nw b gy oa ob l oc od">&lt;button onclick="myFunction()"&gt;Click me&lt;/button&gt;</span></pre><p id="72ed" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">React也使用onClick，但是现在我们可以用它从我们的组件中调用其他方法。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="cd9a" class="my kp it nw b gy oa ob l oc od">class Button extends React.Component {<br/>  handleClick() {<br/>    // do something<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;button onClick={() =&gt; this.handleClick()}&gt;<br/>        {buttonValue}<br/>      &lt;/button&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="a2a1" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">如果我们想将信息传递回父组件，我们可以在父组件中定义<code class="fe oz pa pb nw b">handleClick()</code>方法，然后将该方法作为道具传递给子组件。</p><p id="fbac" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">现在，按钮组件被简化为:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="afc9" class="my kp it nw b gy oa ob l oc od">class Button extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;button onClick={props.onClick}&gt;<br/>        {buttonValue}<br/>      &lt;/button&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="4823" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">Button的父节点现在将<code class="fe oz pa pb nw b">onClick</code>方法作为道具传入:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="578b" class="my kp it nw b gy oa ob l oc od">class ButtonList extends React.Component {<br/>  handleClick() {<br/>    // do something<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;Button onClick={() =&gt; this.handleClick()} /&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="5cf1" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">敏锐的读者会注意到，我们只用了大约20行React来做一些如果我们直接管理按钮，用一两行JavaScript就可以完成的事情。</p><blockquote class="jq"><p id="a5c6" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">你是对的！如果你所需要的只是应用程序中单个按钮的单个功能，那就不要使用React！</p></blockquote><p id="629b" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">只有当我们需要呈现多个按钮时，上面的结构才变得有价值，每个按钮都有自己唯一的标识符，但是所有的按钮都需要一个共享的<code class="fe oz pa pb nw b">handleClick</code>方法。</p><p id="d170" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">想象一个管理多个按钮的<code class="fe oz pa pb nw b">ButtonList</code>组件:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="92a7" class="my kp it nw b gy oa ob l oc od">class ButtonList extends React.Component {<br/>  renderButton() {<br/>    return (<br/>      &lt;Button onClick={() =&gt; this.handleClick()} /&gt;<br/>    );<br/>  }<br/>  renderButtonList() {<br/>    let buttonList = [];<br/>    for (let i=0; i&lt;10; i++) {<br/>      buttonList.push(this.renderButton());<br/>    }<br/>    return buttonList;<br/>  }<br/>  handleClick() {<br/>    // do something<br/>  }<br/>  render() {<br/>    return &lt;div&gt;{this.renderButtonList()}&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="b006" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">通过将<code class="fe oz pa pb nw b">handleClick</code>提升到父组件，我们至少做了两件事:</p><ol class=""><li id="0ba3" class="oj ok it lt b lu mo ly mp mc ol mg om mk on ka pp op oq or bi translated">我们在创建一个新按钮的时候不会重复自己(干巴巴的)。<code class="fe oz pa pb nw b">handleClick</code>方法在<code class="fe oz pa pb nw b">ButtonList</code>的所有子按钮上都是标准化的。</li><li id="b75b" class="oj ok it lt b lu os ly ot mc ou mg ov mk ow ka pp op oq or bi translated">我们获得了查看所有<code class="fe oz pa pb nw b">Buttons</code>当前状态的完整列表的能力，因为每次它们被点击时都会传回信息。不再需要单独查看每个按钮的状态，我们现在可以跟踪所有按钮的状态，甚至恢复更改(参见下面的“const vs let ”,了解更多详细信息)。</li></ol><p id="0467" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">当然，有编写React代码经验的读者会注意到我上面的例子是不正确的。我们仍然缺少管理多个子组件的关键部分；).</p><p id="841a" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">有经验的React用户还会指出，我可以用更短的语法认真清理这两个代码示例。这些例子不需要这么长。</p><p id="3df3" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">出于教育目的，我一直保持冗长，但不用担心！我会缩短一些东西！(参见下面的功能组件)。</p><h1 id="d29f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">不要忘记“钥匙”</h1><p id="6f3e" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">我们已经看到，React可以轻松地创建多个子组件，通过props将信息传递给这些子组件，甚至可以从父组件跟踪这些子组件的状态。</p><figure class="nr ns nt nu gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ox"><img src="../Images/445f9ffe67664fe653143ea34a662258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebjc6tZABbzz1qAWURYtXA.jpeg"/></div></div></figure><p id="9222" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">不过，React面临的部分挑战是记住哪些孩子发生了变化。如果您的应用程序涉及到操纵子组件的顺序，这一点尤其正确。</p><p id="760b" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">例如，想象一下，如果我们允许用户拖动并重新排列ButtonList中十个按钮的位置。当列表索引不断变化时，React如何保持每个按钮的状态？</p><blockquote class="jq"><p id="2cfc" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">如果我们给用户删除他们不需要的按钮组件的能力，这尤其危险。React可能会误删错误信息！</p></blockquote><p id="834b" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">为了解决这个问题，React希望您为您创建的每个子组件提供一个唯一的标识符。这个唯一的id在React中被称为<code class="fe oz pa pb nw b">key</code>。</p><p id="e4cc" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">因为我们的是一个简单的按钮列表，所以添加按键非常简单:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="83ed" class="my kp it nw b gy oa ob l oc od">class ButtonList extends React.Component {<br/>  renderButton(i) {<br/>    return (<br/>      &lt;Button <br/>        key={i} // The Button now has a key!<br/>        onClick={(i) =&gt; this.handleClick(i)} <br/>      /&gt;<br/>    );<br/>  }<br/>  renderButtonList() {<br/>    let buttonList = [];<br/>    for (let i=0; i&lt;10; i++) {<br/>      buttonList.push(this.renderButton(i));<br/>    }<br/>    return buttonList;<br/>  }<br/>  handleClick(i) {<br/>    // do something to the button where key===i<br/>  }<br/>  render() {<br/>    return &lt;div&gt;{this.renderButtonList()}&lt;/div&gt;;<br/>  }<br/>}</span></pre><h2 id="ba60" class="my kp it bd kq mz na dn ku nb nc dp ky mc nd ne lc mg nf ng lg mk nh ni lk nj bi translated">啊哈时刻</h2><p id="cf1a" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">在上面的例子中，您可以看到我们为对<code class="fe oz pa pb nw b">renderButton</code>的调用添加了一个键。但是我们也给所有对<code class="fe oz pa pb nw b">onClick</code>和<code class="fe oz pa pb nw b">handleClick</code>的呼叫添加了关键字<code class="fe oz pa pb nw b">i</code>。这样，React就知道当有点击事件时应该更新哪个<code class="fe oz pa pb nw b">Button</code>组件。</p><p id="0fd1" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">键非常重要，它们可以变得更加复杂，但是它们允许React跟踪页面上大量不同组件的独特状态。</p><h1 id="9376" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">构造函数，super()，局部状态:打开潘多拉的盒子</h1><p id="cba5" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">说到跟踪状态，React允许您存储一些关于组件状态的本地信息。如果您想在工作流程中保留组件进度的历史记录或信息，这将非常有用。</p><p id="e77d" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">例如，在我们的<code class="fe oz pa pb nw b">ButtonList</code>示例中，如果我们想要记录按钮被点击的次数和顺序，我们需要在<code class="fe oz pa pb nw b">ButtonList</code>组件中保存一些列表状态的信息。</p><p id="6483" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">为此，我们使用一个构造函数来初始化组件状态:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="60c7" class="my kp it nw b gy oa ob l oc od">class ButtonList extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      clickCount: 0,<br/>    };<br/>  }</span><span id="4065" class="my kp it nw b gy oy ob l oc od">  ... // The rest of the component that we've already seen.</span><span id="3933" class="my kp it nw b gy oy ob l oc od">}</span></pre><p id="5662" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">所有的React组件都有一个内置的状态，所以我们需要调用<code class="fe oz pa pb nw b">super(props)</code>来访问父类的(React。组件)构造函数能够更新状态。</p><p id="1a47" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">现在我们已经构建了我们的构造函数，我们可以修改和使用状态:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="54d5" class="my kp it nw b gy oa ob l oc od">...</span><span id="5d8c" class="my kp it nw b gy oy ob l oc od">  handleClick(i) {<br/>    const clickCount = this.state.clickCount;<br/>    <br/>    ... // Do something</span><span id="84e4" class="my kp it nw b gy oy ob l oc od">    this.setState({<br/>      clickCount: clickCount + 1,<br/>    });<br/>  }</span><span id="0d98" class="my kp it nw b gy oy ob l oc od">  ...</span></pre><p id="24d7" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">我们现在有一个计数器，每次点击一个<code class="fe oz pa pb nw b">Button</code>就会增加。</p><p id="2dea" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">这是一个说明状态的简单例子。我不建议你在实际应用中把它当作计数器使用。相反，您可能希望创建一个<code class="fe oz pa pb nw b">this.state.history</code>变量，它将哪个按钮在哪个点被点击的确切信息存储为不同时间点的当前状态的数组。</p><p id="3a34" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">然后，如果您需要一个点击计数，您可以使用<code class="fe oz pa pb nw b">this.state.history.length</code>来访问它，即使您撤销了过去的更改，这个点击计数也将是正确的。</p><h2 id="7577" class="my kp it bd kq mz na dn ku nb nc dp ky mc nd ne lc mg nf ng lg mk nh ni lk nj bi translated">啊哈时刻</h2><p id="393b" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">状态和历史为潜在的应用打开了一个全新的世界。现在，您可以用React构建一些复杂的东西，只需存储状态信息。</p><blockquote class="jq"><p id="1bc9" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">想在购物车中添加/删除商品吗？反应状态可以处理这个问题。</p><p id="ad8e" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">在浏览器象棋游戏中撤销移动？组件状态为您提供了保护。</p><p id="cf42" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">基于用户切换不同地呈现组件？国家也可以在这方面帮助你。</p></blockquote><p id="e558" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">理解并擅长<code class="fe oz pa pb nw b">this.state</code>(还有<code class="fe oz pa pb nw b">this.props</code>)是擅长React的关键。</p><h1 id="0a57" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">对简单的东西使用功能组件</h1><p id="d022" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">因为在React中我们将所有的权力都给了父组件，所以子组件最终会变得很笨。</p><p id="e6c0" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">考虑我们的基本<code class="fe oz pa pb nw b">Button</code>组件的最终版本:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="de0e" class="my kp it nw b gy oa ob l oc od">class Button extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;button onClick={props.onClick}&gt;<br/>        {props.buttonValue}<br/>      &lt;/button&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="c1d2" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">该组件所做的只是呈现一个按钮。因为它非常简单，所以我们实际上不需要在React中为它创建一个完整的类。</p><p id="a084" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">相反，只要让它成为一个函数:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="fc7b" class="my kp it nw b gy oa ob l oc od">function Button(props) {<br/>  return (<br/>    &lt;button onClick={props.onClick}&gt;<br/>      {props.buttonValue}<br/>    &lt;/button&gt;<br/>  );<br/>}</span></pre><p id="9e56" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">我们删除了两行代码，但是我们也避免了扩展<code class="fe oz pa pb nw b">React.Component</code>。<code class="fe oz pa pb nw b">Button</code>维护和使用变得简单多了。</p><h1 id="ba37" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">你和JSX的问题是你不了解JSX</h1><p id="d0a2" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">到目前为止，我一直在避免使用它，但是如果您是React新手，您会注意到React将一些看起来像HTML的东西与JavaScript符号直接混合在一起。</p><p id="f100" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">这让很多新人反应混乱，因为他们以为它<strong class="lt iu"> <em class="nn">就是</em> </strong> HTML。</p><blockquote class="jq"><p id="8b05" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">不是的。React中的标记实际上被称为JSX，它与HTML有一些关键的不同，这些不同会影响到你如何使用它。</p></blockquote><p id="3cee" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">了解JSX最重要的一点是，Babel(React使用的JavaScript编译器)正在幕后将JSX转变为JavaScript。</p><p id="5349" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">当你在JSX写作时:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="3471" class="my kp it nw b gy oa ob l oc od">const element = (<br/>  &lt;h1 className="greeting"&gt;<br/>    Hello, world!<br/>  &lt;/h1&gt;<br/>);</span></pre><p id="49d1" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">巴别塔将其转化为:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="ef79" class="my kp it nw b gy oa ob l oc od">const element = React.createElement(<br/>  'h1',<br/>  {className: 'greeting'},<br/>  'Hello, world!'<br/>);</span></pre><p id="387c" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">ReactDOM就是这样知道要呈现什么的。</p><p id="4a6d" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">你可以直接使用<code class="fe oz pa pb nw b">React.createElement</code>而不是JSX来编写整个React组件。但是JSX看起来更好，因为所有的web开发人员都知道HTML，所以更容易理解这个元素会发生什么。</p><p id="ee3a" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">不过，巴别尔对JSX教的皈依有一些重要的含义。</p><p id="ddd1" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">首先，<code class="fe oz pa pb nw b">React.createElement()</code>只创建一个元素。该元素中可以嵌套子元素，但是Babel不知道如何处理多个元素。</p><p id="bdd7" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">例如，这在JSX行不通:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="4185" class="my kp it nw b gy oa ob l oc od">return (<br/>  &lt;h1&gt;Hello World&lt;/h1&gt;<br/>  &lt;p&gt;Nice to meet you&lt;/p&gt;<br/>);</span></pre><p id="7c87" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">但是，如果我们将这些元素嵌套在另一个元素中，它将会工作:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="d5d2" class="my kp it nw b gy oa ob l oc od">return (<br/>  &lt;div&gt;<br/>    &lt;h1&gt;Hello World&lt;/h1&gt;<br/>    &lt;p&gt;Nice to meet you&lt;/p&gt;<br/>  &lt;/div&gt;<br/>);</span></pre><p id="04f3" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">如果您发现自己经常需要像这样返回多个元素，您可以考虑使用<code class="fe oz pa pb nw b">React.Fragment</code>来代替:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="e42f" class="my kp it nw b gy oa ob l oc od">return (<br/>  &lt;React.Fragment&gt;<br/>    &lt;h1&gt;Hello World&lt;/h1&gt;<br/>    &lt;p&gt;Nice to meet you&lt;/p&gt;<br/>  &lt;/React.Fragment&gt;<br/>);</span></pre><p id="200e" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated"><code class="fe oz pa pb nw b">React.Fragment</code>允许您添加多个元素，而无需向DOM添加一堆不必要的<code class="fe oz pa pb nw b">div</code>。</p><p id="2f31" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">JSX还允许您将JavaScript直接嵌入到语法中，以便在编译后进行评估:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="309d" class="my kp it nw b gy oa ob l oc od">function getGreeting(user) {<br/>  if (user) {<br/>    return &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;;<br/>  }<br/>  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;<br/>}</span></pre><p id="2628" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">JSX对注射攻击是安全的。您可以根据用户输入创建JSX变量，然后在整个应用程序中使用这些变量，不会出现任何问题。React对JSX中嵌入的所有值进行转义，并在渲染之前将所有内容转换为字符串。</p><p id="e332" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">绊倒新来者的另一个挑战是JSX更接近JavaScript而不是HTML。因此，它将camelCase用于所有命名方案。</p><p id="b360" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">注意，我在我们的<code class="fe oz pa pb nw b">ButtonList</code>例子中使用了<code class="fe oz pa pb nw b">onClick</code>，而不是标准的HTML <code class="fe oz pa pb nw b">onclick</code>。</p><p id="0e5e" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">由于JSX将成为JavaScript，JavaScript关键字是禁区。因此，如果您需要在JSX指定一个CSS类，您将需要调用它<code class="fe oz pa pb nw b">className</code>。</p><h1 id="1a7f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">render()方法中的循环和条件</h1><blockquote class="jq"><p id="3d94" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">JSX和React对可以在组件的<code class="fe oz pa pb nw b">render()</code>方法中使用的条件和循环施加了一些限制。</p></blockquote><p id="b5ad" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">这可能会让新来者感到沮丧。但是通常解决方案是简单地创建一个单独的方法来运行循环或条件，然后从<code class="fe oz pa pb nw b">render()</code>中调用该方法。</p><p id="19df" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">React中经常看到的一种模式是使用<code class="fe oz pa pb nw b">.map()</code>将数组转换成一组元素。</p><p id="6e0e" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">例如，通常保存一个<code class="fe oz pa pb nw b">this.state.history</code>,其中包含给定组件过去发生了什么的信息。它通常被格式化为一个对象数组，其中<code class="fe oz pa pb nw b">this.state.history[0]</code>是组件在会话开始时的状态，<code class="fe oz pa pb nw b">this.state.history[this.state.history.length]</code>是最近的更改。</p><p id="e117" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">让我们假设您想以列表的形式列出最近的更改。</p><p id="cc07" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">为此，我们将使用<code class="fe oz pa pb nw b">.map()</code>:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="bf89" class="my kp it nw b gy oa ob l oc od">const history = this.state.history;</span><span id="2dd2" class="my kp it nw b gy oy ob l oc od">const changes = history.map((changeNum, changeDesc) =&gt; {<br/>  return &lt;li key={changeNum}&gt;{changeDesc}&lt;/li&gt;;<br/>}</span></pre><p id="50f2" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">您可以根据需要使<code class="fe oz pa pb nw b">.map()</code>变得复杂，在您调用的arrow函数中创建变量，以便根据需要呈现元素、CSS类和内容。</p><h1 id="1d4b" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">const vs let &amp;为什么React更喜欢不变性</h1><p id="43a0" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">如果你能坚持到这一步，我为你喝彩。您致力于学习React基础知识！</p><blockquote class="jq"><p id="442d" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">一旦你有了这个核心的理解，你将学习的关于React的其他一切都是有趣的部分！</p></blockquote><p id="dac5" class="pw-post-body-paragraph lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn ka im bi translated">JavaScript引入了新的关键字来声明ES6中的变量。关于关键词<code class="fe oz pa pb nw b">let</code>和<code class="fe oz pa pb nw b">const</code>以及为什么你会使用它们而不是<code class="fe oz pa pb nw b">var</code>已经有很多文章了。然而，理解这些新声明如何影响React是很重要的。</p><blockquote class="nk nl nm"><p id="8297" class="lr ls nn lt b lu mo lw lx ly mp ma mb no mq me mf np mr mi mj nq ms mm mn ka im bi translated">React官方倾向于在声明变量时使用<code class="fe oz pa pb nw b">const</code>。</p></blockquote><p id="b709" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">当然，这意味着你不能在程序的后面更改<code class="fe oz pa pb nw b">const</code>。相反，您需要确保您的常量变量声明在函数和其他作用域块中有良好的作用域，以便可以保存和返回值。</p><p id="48e0" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">这并不是说你不会在React中使用<code class="fe oz pa pb nw b">let</code>或<code class="fe oz pa pb nw b">var</code>！可变变量仍有大量的应用。</p><p id="bc4d" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">React之所以在可能的情况下更倾向于不变性，是因为React中有太多其他的东西在变化。当底层变量不能改变时，预测您的应用程序将做什么变得更加容易。</p><p id="cfb9" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">此外，不变性允许我们保存某些变量的过去值。如果我们在函数中使用一个<code class="fe oz pa pb nw b">const</code>，然后将那个<code class="fe oz pa pb nw b">const</code>的值加到<code class="fe oz pa pb nw b">this.state.history</code>(反之亦然)，那么我们就有了状态历史的基础，允许我们撤销/重做并恢复到特定的时间点。</p><p id="c918" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">考虑我们上面使用的例子:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="4545" class="my kp it nw b gy oa ob l oc od">const history = this.state.history;</span><span id="c204" class="my kp it nw b gy oy ob l oc od">const changes = history.map((changeNum, changeDesc) =&gt; {<br/>  return &lt;li key={changeNum}&gt;{changeDesc}&lt;/li&gt;;<br/>}</span></pre><p id="fe23" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">因为我们从状态历史中获取值，所以我们知道这些值不需要改变。当它们发生变化时，我们会将这些变化保存为<code class="fe oz pa pb nw b">this.state.history</code>中的新条目。</p><h1 id="c8c9" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">欢迎反应！</h1><p id="7602" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">咻，那是一个了不起的向导！我希望它是有用的。</p><p id="c798" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">现在，您已经了解了React如何组合在一起的更广泛的背景，开发React web应用程序和了解React中的复杂项目变得更加容易。</p><blockquote class="jq"><p id="bcad" class="jr js it bd jt ju lm ln lo lp lq ka dk translated">我错过了什么或者犯了什么错误吗？请在评论里告诉我！</p></blockquote></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><h1 id="fd76" class="ko kp it bd kq kr pk kt ku kv pl kx ky kz pm lb lc ld pn lf lg lh po lj lk ll bi translated">关于班尼特</h1><p id="8959" class="pw-post-body-paragraph lr ls it lt b lu mt lw lx ly mu ma mb mc mv me mf mg mw mi mj mk mx mm mn ka im bi translated">我是一名用Python和JavaScript构建东西的web开发人员。</p><p id="cb89" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated"><em class="nn">想要我关于web开发和成为更好的程序员的最佳内容吗？</em></p><p id="4f29" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated">我在邮件列表中分享我最喜欢的建议——没有垃圾邮件，没有推销内容，只有有用的内容。</p><p id="9562" class="pw-post-body-paragraph lr ls it lt b lu mo lw lx ly mp ma mb mc mq me mf mg mr mi mj mk ms mm mn ka im bi translated"><a class="ae pc" href="https://sunny-architect-5371.ck.page/0a60026a5d" rel="noopener ugc nofollow" target="_blank">加入我的电子邮件系列中目前的500名其他开发人员。</a></p></div></div>    
</body>
</html>