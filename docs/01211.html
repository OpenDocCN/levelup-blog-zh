<html>
<head>
<title>ES6 Generators in JavaScript, a Real-World Use Case</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的ES6生成器，一个真实的用例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/es6-generators-in-javascript-9cc301ed7665?source=collection_archive---------1-----------------------#2019-11-28">https://levelup.gitconnected.com/es6-generators-in-javascript-9cc301ed7665?source=collection_archive---------1-----------------------#2019-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b18b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开发人员很难理解何时使用生成器——通过理解这个真实世界的用例来学习如何集成它们。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/848b0cbd12b6ccd1a3eaecdf90e4fd58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Tza6ZxXKKU_yli7CV509Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@eyefish73?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">乔恩·赛勒</a>在<a class="ae ky" href="https://unsplash.com/s/photos/generator?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="b3b0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">我对发电机的问题</h1><p id="50d7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我不介意承认，自从发电机问世以来，我很难理解它们能为我解决什么问题。虽然<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noopener ugc nofollow" target="_blank">文档</a>全面而有用，但我仍然对它们的应用感到有点不确定。</p><p id="ca5a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我最近偶然发现了一个我认为有效的用例，它可能对帮助其他人理解他们能做什么大有帮助。这绝不是对JavaScript中生成器的深入探究。然而，对于那些和我一样，仍然在寻找可以使用这个新特性的上下文的人来说，它可能是对文档的补充。</p><p id="75a5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我保证没有涉及质数或斐波那契模式的例子。</p><h1 id="450d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">发电机粗略指南</h1><p id="ee69" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们看一些代码之前，我想我应该总结一下我对生成器的理解。</p><p id="f70a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">来自<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="ms mt mu"><p id="bb3f" class="lr ls mv lt b lu mn ju lw lx mo jx lz mw mp mc md mx mq mg mh my mr mk ml mm im bi translated">生成器函数允许您通过编写一个不连续执行的函数来定义迭代算法</p></blockquote><p id="c831" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里的区别是不连续的执行。当我们用JavaScript编写同步函数时，我们通常期望函数内部的代码会一直执行，直到我们到达一个返回语句、一个错误或函数块的末尾:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="36d4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过一个生成器函数，我们用关键字<code class="fe nb nc nd ne b">yield</code>改变了期望值。当我们在函数中遇到<code class="fe nb nc nd ne b">yield</code>时，我们表示希望暂停执行，允许我们在完成执行之前从函数<em class="mv">中获取一个值，或者将一个值放入函数<em class="mv">中:</em></em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1e89" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个公认的人为例子中，我们可以在到达返回语句之前从函数<em class="mv">中提取出<em class="mv"> shouty </em>值。让我们看看如何向暂停的函数传递一个值:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f2ec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">向由<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol" rel="noopener ugc nofollow" target="_blank">迭代器协议</a>公开的<code class="fe nb nc nd ne b">next()</code>方法传递一个值允许我们在恢复执行时使用它。</p><p id="f57a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正是这些类型的例子让我想知道更多，并让我更多地考虑生成器的实际应用。</p><h1 id="bab2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">打字机的问题</h1><p id="660f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在开发文本冒险游戏引擎时，我需要创建一种模拟字符串输入效果的方法。我想要一个实现，在这个实现中，我可以用一个字符串递归地调用一个函数，来检索这个字符串的新的类型化表示，直到它完成为止。</p><p id="1401" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我的第一个方法是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e8f8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个解决方案在很大程度上满足了我的需求。但是，有一件事感觉不太对劲。由于函数的连续性，我<em class="mv">有</em>向它公开我的<code class="fe nb nc nd ne b">print</code>函数。这是作为上面示例中的参数注入的，还是在封闭范围或上下文中公开的。</p><p id="b985" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有了这个约束，我的输入函数不仅负责输入字符串，还负责打印它。这种隐式打印感觉有些不对劲，如果我想对字符串的类型化状态的每次迭代做些别的事情呢？</p><p id="e268" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果有一种方法可以在每次迭代中暂停函数的执行并提取值，我可以简单地将该值传递给负责打印的函数——或者其他任何相关的函数。</p><p id="d5a4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这听起来像是一个发电机能够解决的实际问题！值得注意的是，在没有生成器的情况下，实现我所需要的<em class="mv">当然是可能的。然而，在这种情况下，我发现生成器实现更简洁，也更容易推理:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="acfa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里我们可以用一种更简单的非连续方式来表达我们的递归。我们的<code class="fe nb nc nd ne b">type</code>函数现在对打印我们的值一无所知，也没有隐式处理打印的副作用。</p><p id="915a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了完整起见，这里有一个完整问题的模拟实现，我们的关注点是分开的。根据您的浏览器的年龄，您应该能够将它直接复制并粘贴到您的控制台中，以查看它的运行情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="977d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个例子的特点是模拟人类输入短语的<code class="fe nb nc nd ne b">print</code>函数的异步实现。我们在字符串的每次迭代之间添加一个定义好的短暂停顿。现在我们的<code class="fe nb nc nd ne b">print</code>函数可以处理<em class="mv">只是</em>打印，而我们的<code class="fe nb nc nd ne b">type</code>函数可以处理<em class="mv">只是</em>打字。</p><h1 id="6e5a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">进一步阅读</h1><p id="9d95" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我的实现中，有一点我没有提到，但我认为值得一提的是在事先不知道集合长度的情况下迭代集合的能力。当考虑性能和内存消耗时，在这种情况下暂停迭代执行的能力是至关重要的。</p><p id="61ac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了将它放在我的输入示例的上下文中，想想如果我们事先不知道这个短语，或者如果我们不确定这个短语是否包含无限数量的字符，我们将如何处理这个问题。我们可能想要暂停当前的迭代，以确保我们有足够的资源来处理下一个迭代<em class="mv">。</em></p><h1 id="c6a2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="8676" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我希望这有助于那些和我一样，在规范第一次引入时感到有点困惑的人理解生成器。这个例子仅仅触及了生成器和迭代器的表面，所以我鼓励大家看看<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>，并开始思考它们在什么地方可以为现实世界的问题提供简洁。</p></div></div>    
</body>
</html>