<html>
<head>
<title>Dockerizing Scala/Redis/NGINX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">dockering Scala/Redis/NGINX</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dockerizing-scala-redis-nginx-c97d067244d9?source=collection_archive---------4-----------------------#2021-03-10">https://levelup.gitconnected.com/dockerizing-scala-redis-nginx-c97d067244d9?source=collection_archive---------4-----------------------#2021-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a142e1555ebd48d9e6d52930443c8bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L04mheM7ZXHbAHQpNz1R-A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来自<a class="ae kc" href="https://pixabay.com/users/michaelgaida-652234/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3859710" rel="noopener ugc nofollow" target="_blank">迈克尔·盖达</a>来自<a class="ae kc" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3859710" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="7dd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着我们的初创公司发展成为一家成熟的公司，我们的客户群也在增长，是时候改变我们目前基于脚本的部署实践了。考虑到这一点，我决定看看Kubernetes到底是什么，这促使我考虑使用docker作为容器。</p><p id="71b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于在研究和评估新技术时，我的手指在键盘上工作得最好，所以我决定创建一个环境，在这个环境中，NGINX、Akka-Http和Redis作为我的数据存储都是容器化的，并且可以相互双向通信。我想添加akka-http服务器，将事件发送到客户端浏览器，并让Redis将密钥和事件更改发布到我的RESTful akka-http服务器——我的想法是，让我们测试一下容器之间的联网情况:-)。</p><blockquote class="lb lc ld"><p id="96fb" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">我在Github上发布了两个项目，欢迎大家来看看和使用:<a class="ae kc" href="https://github.com/colinbes/server-akka" rel="noopener ugc nofollow" target="_blank"> akka-http server </a>和<a class="ae kc" href="https://github.com/colinbes/dockerized-akka-app" rel="noopener ugc nofollow" target="_blank"> docker-compose setup </a></p></blockquote><p id="b303" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我决定先从最简单的组件开始，创建/设置一个Redis容器。</p><h1 id="13dd" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Redis容器</h1><p id="9d9d" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">网上有很多关于设置和运行Redis容器的信息。</p><p id="d335" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的例子中，我想为Redis添加发布密钥空间和事件通知的能力，这是弄清楚如何配置Redis' <code class="fe ml mm mn mo b">notify-keyspace-events</code>,而不必依赖应用程序来执行这个操作所必需的。事实证明，这可以通过docker-compose提供的redis.conf文件轻松完成。</p><p id="9039" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建父文件夹<code class="fe ml mm mn mo b">dockerized-akka-app</code>后，我添加了一个<code class="fe ml mm mn mo b">redis-config</code>子文件夹，包含以下<em class="le"> redis.conf </em>文件。注意该文件夹可以从<a class="ae kc" href="https://github.com/colinbes/dockerized-akka-app" rel="noopener ugc nofollow" target="_blank"> docker-compose设置</a>项目中提取。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">redis.conf文件</figcaption></figure><p id="e8d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在父文件夹<code class="fe ml mm mn mo b">dockerized-akka-http, </code>下创建了一个<em class="le"> docker-compose.yml </em>文件。</p><blockquote class="lb lc ld"><p id="cc58" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">在这篇文章中，我们将在这个文件的基础上最终管理我们的三个容器。</p><p id="1892" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">在继续之前，您需要创建一个对接网络，这可以使用<em class="iq">对接网络</em>命令:<code class="fe ml mm mn mo b"><em class="iq">docker network create external-example</em></code>来完成</p></blockquote><p id="7a6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建redis <em class="le">服务，绑定内部和外部卷以允许容器的外部配置。</em></p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">初始只重新编辑docker-compose文件。</figcaption></figure><ul class=""><li id="4920" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><code class="fe ml mm mn mo b">volumes</code>指示容器将redis-config文件夹下的内容绑定到docker文件夹<code class="fe ml mm mn mo b">/usr/local/etc/redis</code></li><li id="b0c0" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ml mm mn mo b">ports</code>将标准redis内部端口6379暴露给外部端口12345。严格来说，这不是必须的，但在开发周期中是一种便利。</li><li id="0621" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ml mm mn mo b">command</code>运行redis服务器，传递redis.conf文件的位置。</li><li id="159a" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ml mm mn mo b">networks</code>允许在docker-compose文件中的容器之间建立一个docker网络——稍后将详细介绍。</li></ul><p id="64e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导航到父文件夹，确保docker在您的系统上运行后，在命令提示符下执行<code class="fe ml mm mn mo b">docker-compose up -d</code>来创建redis容器。</p><p id="b0ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的机器上本地安装了redis，您可以使用<code class="fe ml mm mn mo b">redis-cli -p 12345</code>连接并验证连接。如果没有，那么可以通过执行<code class="fe ml mm mn mo b">docker exec -it &lt;container-name&gt; sh</code>连接到容器并运行shell</p><p id="d616" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要确定容器名，您可以查看运行<code class="fe ml mm mn mo b">docker ps</code>的输出，它将在最后一列显示容器名——在我的例子中，显示的名称是<code class="fe ml mm mn mo b">akka-app_redis_1</code>。</p><p id="3cda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦连接到docker容器并且shell可用，您就可以从docker容器中运行<em class="le"> redis-cli </em>并进行测试——例如:</p><pre class="mp mq mr ms gt nj mo nk nl aw nm bi"><span id="afe2" class="nn lj iq mo b gy no np l nq nr"><strong class="mo ir">❯</strong> docker exec -it akka-app_redis_1 sh<br/>/data #redis-cli<br/>127.0.0.1:6379&gt; ping<br/>PONG</span></pre><blockquote class="lb lc ld"><p id="dbd5" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">现在，您已经成功地创建并部署了一个带有外部配置的Redis容器。</p></blockquote><h1 id="50ea" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Akka-Http后端服务器</h1><p id="b334" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">继续我们的探索，创建我们的Akka-Http RESTful后端服务。在这篇文章中，我不会去创建scala akka-http项目，并且对编码标准进行了诗意的许可，但是我想把重点放在这篇文章的细节上。完整的可用源代码可以在<a class="ae kc" href="https://github.com/colinbes/server-akka" rel="noopener ugc nofollow" target="_blank"> akka-http server </a>存储库中找到。</p><blockquote class="lb lc ld"><p id="daab" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">如果你有兴趣了解更多关于EventSource和SSE的信息，可以看看<a class="ae kc" href="https://medium.com/@bester.colin/vuejs-akka-http-and-sse-a301ca13eae5" rel="noopener"> medium </a> post。</p></blockquote><p id="9b37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">scala应用程序提供了一个基本的VUE页面，显示部署的参与者列表，能够在Redis中设置一个键/值对，并显示通过Redis的发布功能接收到的通知更改，为了好玩，添加了一个计时器标记，通过SSE将日期时间发送到前端。对于一个简单的例子来说有点过分，但我关心的是网络方面，所以想在评估中涵盖我的基础。</p><p id="4b03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了方便向redis事件提供订阅资源，我决定使用订阅者角色，在Akka代码中，我可以发送订阅消息和回调函数。更多细节，我建议参考<a class="ae kc" href="https://github.com/colinbes/server-akka" rel="noopener ugc nofollow" target="_blank"> akka-http server </a>项目。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Redis订阅演员。</figcaption></figure><p id="0e74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，创建docker映像相对简单，我最终使用了<a class="ae kc" href="https://github.com/sbt/sbt-native-packager" rel="noopener ugc nofollow" target="_blank"> sbt-native-packager </a>。遵从他们的指示对我来说很有帮助。下面是与创建docker映像相关的build.sbt行。</p><blockquote class="lb lc ld"><p id="e5ec" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">注意，在第12行，dockerCommands允许向Dockerfile添加命令行。当我使用alpine image来减少内存占用时，我需要添加不属于标准图像的<code class="fe ml mm mn mo b">bash</code>。这允许我在容器内部运行bash shell进行调试。</p></blockquote><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">docker build . SBT中的相关行</figcaption></figure><p id="7468" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在运行sbt docker:publishLocal时，下载了必要的图像，并且在<code class="fe ml mm mn mo b">target</code>文件夹下创建了Dockerfile，并且创建了一个图像并可以使用。</p><p id="a3d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在开始有趣的部分，设置docker的网络，允许akka应用程序直接与redis通信。</p><p id="dd6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更新<code class="fe ml mm mn mo b">docker-compose.yml</code>文件的时间到了。</p><p id="da30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在父文件夹下添加了一个新文件夹，将其命名为<code class="fe ml mm mn mo b">akka-config</code>，并创建了用于配置Akka应用程序的<em class="le"> logback.xml </em>和<em class="le"> application.conf </em>文件。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Akka-Http后端的配置文件。</figcaption></figure><p id="7803" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要设置scala应用程序来访问容器化的Redis应用程序，打开<code class="fe ml mm mn mo b">docker-compose</code>文件并将新的<code class="fe ml mm mn mo b">akka-server</code>服务添加到服务中。</p><blockquote class="lb lc ld"><p id="f446" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">请注意，服务名称将自动创建网络别名，您将使用这些别名来配置网络。</p></blockquote><p id="dedd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，在<code class="fe ml mm mn mo b">application.conf</code>中创建条目来配置redis Url，注意Redis的服务名是用于从Akka容器访问Redis的别名。</p><pre class="mp mq mr ms gt nj mo nk nl aw nm bi"><span id="6101" class="nn lj iq mo b gy no np l nq nr">redis-server {<br/>  uri = "<strong class="mo ir">redis</strong>://redis:6379"<br/>}</span></pre><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">组合redis和akka服务docker-compose文件。</figcaption></figure><p id="756d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一切都很顺利，但我确实努力让我的EventSource注册和响应正常工作。在docker环境之外，一切都像预期的那样工作，但是当我添加docker容器时，我无法再让它处理CORS问题等等。</p><p id="3d55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我花了一些时间研究EventSource的Javascript，直到我意识到在注册到端点时可以将选项传递给EventSource。</p><p id="dce9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的<em class="le"> setupStream </em>函数中，我必须包含对象<code class="fe ml mm mn mo b">{withCredentials: true}</code>。来自Mozilla的开发者网站:</p><blockquote class="lb lc ld"><p id="0189" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><strong class="kf ir">xmlhttprequest . with credentials</strong>属性是一个布尔值，它指示是否应该使用cookies、授权头或TLS客户端证书等凭据来发出跨站点访问控制请求。withCredentials设置对同一站点请求没有影响。</p></blockquote><pre class="mp mq mr ms gt nj mo nk nl aw nm bi"><span id="f803" class="nn lj iq mo b gy no np l nq nr">let evtSource = new EventSource("api/events",<br/>    {withCredentials: true})</span><span id="35aa" class="nn lj iq mo b gy ns np l nq nr">evtSource.addEventListener('myEvent', event =&gt; {<br/>  let data = JSON.parse(event.data)<br/>  if (data.event === 'date') {<br/>      this.now = data.value<br/>      this.value = data.value<br/>  } else if (data.event="userchange") {<br/>      this.username = data.value.name<br/>      this.online = data.value.online<br/>  }<br/>}, false)</span></pre><p id="009f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要重新运行docker-compose并启动Redis和Akka应用程序，请导航回父目录并关闭服务，然后使用docker-compose down/up将它们重新启动。</p><pre class="mp mq mr ms gt nj mo nk nl aw nm bi"><span id="43c8" class="nn lj iq mo b gy no np l nq nr">❯ docker-compose down<br/>Stopping akka-app_akka-server_1 ... done<br/>Stopping akka-app_redis_1       ... done<br/>Removing akka-app_akka-server_1 ... done<br/>Removing akka-app_redis_1       ... done<br/>Network external-example is external, skipping</span><span id="3089" class="nn lj iq mo b gy ns np l nq nr">akka-app on  main took 2s <br/>❯ docker-compose up -d<br/>Creating akka-app_redis_1       ... done<br/>Creating akka-app_akka-server_1 ... done</span><span id="7098" class="nn lj iq mo b gy ns np l nq nr">akka-app on  main <br/>❯</span></pre><p id="96b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打开你最喜欢的浏览器(我用Chrome和Brave做开发工作),导航到<code class="fe ml mm mn mo b"><a class="ae kc" href="http://localhost:8082" rel="noopener ugc nofollow" target="_blank">http://localhost:8082</a></code>查看客户端屏幕。启动时，将显示各种参与者路径，SSE将显示大约5秒钟的等待状态，然后更新，如下所示:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/9c7f6654097202f231b69b438dc53dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YB1zy1X96uq2munlQdkg1w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">初始视图</figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/74810947da09fe91c71cb358d40535c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dfBpj4x8Pxnly8fSLHl96Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">推送数据延迟5秒后</figcaption></figure><h1 id="a249" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">NGINX</h1><p id="dd2d" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">现在进入我们实验的最后一部分，创建一个NGINX服务来重定向/代理调用。</p><p id="e499" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个Akka示例中，VueJs前端应用程序由一个简化的<em class="le">index.html</em>和<em class="le"> myScript.js </em>文件提供服务。在真实的应用程序中，前端应用程序会更多地通过vue-cli或Vites模块捆绑器进行打包。NGINX非常适合服务这些文件，将流量导向网页和restful端点(通常通过一些<code class="fe ml mm mn mo b">api</code>路径)。目前我们停留在一条简单的路线上。</p><blockquote class="lb lc ld"><p id="56c2" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">如果有兴趣，我会在完整的Vite-vue应用程序上发布帖子，通过NGINX与后端处理SSL/TLS证书等进行通信。</p></blockquote><p id="557d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些年来，设置NGINX变得越来越容易。现在最大的问题是弄清楚你实际上想用它做什么——下面也是配置NGINX的基本模板。</p><p id="84ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先导航到docker-compose父文件夹，创建两个目录<em class="le"> nginx-config </em>和<em class="le"> Nginx-certs </em>。现在，我们将证书目录留空。</p><p id="7431" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="le"> nginx-config </em>中，我们将创建我们的nginx配置文件。作为这个文件的引用，从github中复制<em class="le"> mime.types </em>文件并放入文件夹。然后编辑<em class="le"> nginx.conf </em>，如下所示:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">nginx.conf文件</figcaption></figure><p id="2db5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在更新docker-compose文件以添加NGINX服务，注意NGINX是列表中的最后一个服务，顺序很重要。如果NGINX服务是在akka-server之前定义的，那么docker-compose会抱怨网络<em class="le"> akka-server </em>无法解析。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">完成docker-compose文件。</figcaption></figure><p id="d0ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重新启动docker容器:</p><pre class="mp mq mr ms gt nj mo nk nl aw nm bi"><span id="e604" class="nn lj iq mo b gy no np l nq nr">❯ docker-compose down<br/>Stopping akka-app_akka-server_1 ... done<br/>Stopping akka-app_redis_1       ... done<br/>Removing akka-app_akka-server_1 ... done<br/>Removing akka-app_redis_1       ... done<br/>Network external-example is external, skipping</span><span id="904f" class="nn lj iq mo b gy ns np l nq nr">akka-app on  main took 2s <br/>❯ docker-compose up -d<br/>Creating reverse                ... done<br/>Creating akka-app_redis_1       ... done<br/>Creating akka-app_akka-server_1 ... done</span><span id="e3fd" class="nn lj iq mo b gy ns np l nq nr">akka-app on  main <br/>❯</span></pre><p id="4caf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在添加nginx和重启服务后，我确实遇到了缓存问题，简单地清除浏览器缓存并导航到<a class="ae kc" href="http://localhost" rel="noopener ugc nofollow" target="_blank"> http://localhost </a>就可以了！</p></div></div>    
</body>
</html>