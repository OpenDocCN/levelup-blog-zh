<html>
<head>
<title>Filtering LinkedIn Job Alerts with Serverless Python.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用无服务器Python过滤LinkedIn工作警报。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/filtering-linkedin-job-alerts-with-serverless-python-62bdd07cb81d?source=collection_archive---------13-----------------------#2020-01-23">https://levelup.gitconnected.com/filtering-linkedin-job-alerts-with-serverless-python-62bdd07cb81d?source=collection_archive---------13-----------------------#2020-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1cc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我目前住在荷兰，正在找工作。可悲的是，我不会说荷兰语。(我应该说“我还不会说荷兰语”——希望总是存在的，对吗？)但我没有被吓倒，我在LinkedIn上为本地工作设置了电子邮件提醒。大约三分之一的招聘信息是用英语描述的工作，其余的是荷兰语。我的工作假设是，如果工作描述是英文的，那么他们有可能在办公室说英语，这是值得了解的。</p><p id="5c23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个问题是，我无法立即找到一种方法，通过工作描述的语言来过滤我收到的工作。通常职位是英文的，但描述是荷兰语的。我想这对大多数荷兰人来说不成问题，因为他们的英语非常好。但是，对我来说，点击所有电子邮件链接的过程可能会令人沮丧。我将能够根据描述的语言过滤工作警报。现在，如果我能把邮件转发到某个地方，然后把一个经过过滤的列表发送回来，那就足够好了。</p><p id="aef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章描述了我在一个周末沿着这些思路拼凑的一个解决方案。这样，我学会了如何使用亚马逊的<a class="ae km" href="https://aws.amazon.com/ses/" rel="noopener ugc nofollow" target="_blank"> SES </a>和<a class="ae km" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> Lambda </a>服务。我还发现了几个以前没听说过的有用的Python包。在这个过程中有一些错误的步骤，我希望通过写下它们，你将能够避免它们(以长期缠绕为代价)。</p><p id="3c5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将任务分成4个任务:</p><ol class=""><li id="0bcb" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk ks kt ku kv bi translated">研究如何从LinkedIn发送的工作提醒电子邮件中提取工作描述URL。</li><li id="982e" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">获得完整的职位描述，并决定用什么语言。</li><li id="7afe" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">创建一封包含(过滤后的)工作列表的电子邮件。</li><li id="831b" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk ks kt ku kv bi translated">了解如何接收电子邮件，处理邮件内容，然后发回。</li></ol><p id="7b3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我从处理最熟悉的任务开始。您可能对将AWS服务链接在一起的部分最感兴趣。在这种情况下，请跳到任务4。</p><h2 id="896e" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">任务1:研究如何解析电子邮件，提取每个工作的URL，并获取工作描述。</h2><p id="d9f2" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">事实上，我对电子邮件知之甚少，除了有时候你可以用纯文本的方式请求它们。我从LinkedIn收到的电子邮件看起来像HTML。当然，事实证明，电子邮件有一种古老的标准格式。</p><p id="31ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用GMail中的“显示原件”选项，您可以查看或下载这种格式的“原始”电子邮件。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/07a702b99a1b1fac55d3c1d6884561d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H6hXzNgsNayRvhcLvnKBCQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">使用GMail的“显示原件”命令查看收到的实际邮件。</figcaption></figure><p id="0045" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自LinkedIn的邮件是一个由两部分组成的多部分信息。每个部分都包含一个作业列表，首先是纯文本格式，然后是HTML格式。每个列表都包含LinkedIn上完整职位描述的URL。我想用Python从电子邮件中提取这些URL。我很快发现Python标准库有一个包叫做<code class="fe mp mq mr ms b"><a class="ae km" href="https://docs.python.org/2/library/email.html#module-email" rel="noopener ugc nofollow" target="_blank">email</a></code>。用这个包加载一个示例电子邮件给了我两个内容类型为<code class="fe mp mq mr ms b">['text/plain', 'text/html']</code>的<code class="fe mp mq mr ms b">Message</code>对象:</p><pre class="ma mb mc md gt mt ms mu mv aw mw bi"><span id="100a" class="lb lc iq ms b gy mx my l mz na">import email</span><span id="168e" class="lb lc iq ms b gy nb my l mz na">with open('sample_email.eml','r') as f:<br/>    e = email.message_from_file(f).get_payload()</span><span id="2fcc" class="lb lc iq ms b gy nb my l mz na">print([ms.get_content_type() for ms in e])</span></pre><p id="6a02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">起初我认为用像<a class="ae km" href="https://lxml.de/" rel="noopener ugc nofollow" target="_blank"> lxml </a>这样的库来解析HTML部分会更健壮。但那是多么混乱啊！为了让他们的电子邮件成为p̵r̵e̵t̵t̵y̵ /品牌，电子邮件营销人员必须内嵌所有的CSS。这似乎不利于语义。</p><p id="c01e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，我编写了一个代码片段来从纯文本中提取URL和其他细节:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">这看起来很好，因为LinkedIn永远不会改变你的工作提醒邮件格式，不是吗？；-)</figcaption></figure><p id="3958" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">近期更新:</strong>事实上这一点也不健壮，并不是因为LinkedIn改变了消息格式。它在我从GMail下载的示例邮件中运行良好。但是当我把所有的东西都连接在一起并测试后，我根本没有收到任何工作！事实证明，当你转发一封电子邮件时，GMail发送的不是你“显示原件”时看到的那个原件版本。相反，它发送一个预处理版本，这不会保留纯文本部分的格式。</p><p id="cd34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用<a class="ae km" href="https://docs.python.org/2/library/re.html" rel="noopener ugc nofollow" target="_blank">正则表达式</a>重新做了解析器来查找作业URL。这可能是一个更好的方法:</p><pre class="ma mb mc md gt mt ms mu mv aw mw bi"><span id="3518" class="lb lc iq ms b gy mx my l mz na">import re</span><span id="c0c6" class="lb lc iq ms b gy nb my l mz na">LI_BASE_URL='https://www.linkedin.com/comm/jobs/view/'</span><span id="c0a8" class="lb lc iq ms b gy nb my l mz na"># extract matching urls from the plain text of email message<br/>urls = re.findall(LI_BASE_URL+r”\d+”, plain_text_body)</span><span id="4598" class="lb lc iq ms b gy nb my l mz na"># extract the id numbers from the found urls<br/>job_ids = set([x.split(‘/’)[-1] for x in urls])</span></pre><h2 id="c782" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">任务2。获取完整的职位描述，并决定用什么语言。</h2><p id="b52a" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated"><strong class="jp ir">获取职位描述。有了工作id列表，我可以获取每个工作id的工作描述，并确定它是否是英文的。我用了两个包来做这个:来自标准库的<code class="fe mp mq mr ms b">requests</code>、<code class="fe mp mq mr ms b">langdetect,</code>和<code class="fe mp mq mr ms b">html</code>。</strong></p><p id="2384" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://requests.readthedocs.io/en/master/user/quickstart/" rel="noopener ugc nofollow" target="_blank">请求</a>让我们从LinkedIn获取职位描述:</p><pre class="ma mb mc md gt mt ms mu mv aw mw bi"><span id="5da5" class="lb lc iq ms b gy mx my l mz na">import requests</span><span id="1ee1" class="lb lc iq ms b gy nb my l mz na"># assume job_id is from above e.g. 1691926414<br/>BASE_URL = 'https://www.linkedin.com/comm/jobs/view/'</span><span id="c0dd" class="lb lc iq ms b gy nb my l mz na">r = requests.get(f'{BASE_URL}{job_id}')</span></pre><p id="1213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我想减少第三方库的数量，所以我使用Python标准库<a class="ae km" href="https://docs.python.org/3/library/html.parser.html" rel="noopener ugc nofollow" target="_blank"> html.parser </a>编写了一个定制的HTML解析器。这将在职位描述页面上运行，并提取描述和其他元数据，如职位、公司和位置。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">用于提取作业信息的自定义parser.HTML解析器</figcaption></figure><p id="f217" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对HTML响应调用解析器，如下所示:</p><pre class="ma mb mc md gt mt ms mu mv aw mw bi"><span id="c867" class="lb lc iq ms b gy mx my l mz na"># create instance of parser<br/>dp=DescriptionParser()</span><span id="3d5b" class="lb lc iq ms b gy nb my l mz na"># feed it the HMTL from the email<br/>dp.feed(r.text)</span><span id="bb55" class="lb lc iq ms b gy nb my l mz na"># access captured data from the parser instance<br/># e.g.<br/>title = dp.data.get('title','No Title Found')</span><span id="c898" class="lb lc iq ms b gy nb my l mz na">place = title.split(' in ')[1].split(' | ')[0]<br/>job_title = title.split(' hiring ')[1].split(' in ')[0]<br/>company = title.split(' hiring')[0]</span></pre><p id="719f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">检测描述的语言。</strong></p><p id="db29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我正要去打电话给0800-Google Translate-API，这时我发现了一个很棒的python包<code class="fe mp mq mr ms b"><a class="ae km" href="https://github.com/Mimino666/langdetect" rel="noopener ugc nofollow" target="_blank">langdetect</a></code>。它显然支持55种现成的语言。我们可以简单地将工作描述的文本输入到<code class="fe mp mq mr ms b">detect</code>函数，它将返回检测到的语言。</p><pre class="ma mb mc md gt mt ms mu mv aw mw bi"><span id="fce3" class="lb lc iq ms b gy mx my l mz na">from langdetect import detect</span><span id="6e79" class="lb lc iq ms b gy nb my l mz na">language = detect(dp.data['description'])</span></pre><p id="e9f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我收到的工作描述是荷兰语和英语的混合。我通过传递一些示例描述，对<code class="fe mp mq mr ms b">langdetect</code>的性能进行了一次不科学的测试。它似乎一直都是对的。因为这里没有人的生命受到威胁，这对我来说已经足够了。</p><p id="90e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以现在我需要做的就是将最后3部分打包成一个循环，创建一个只有英语描述的工作列表。我希望这段代码不言自明:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="7b66" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">任务三。创建一个过滤后的工作的电子邮件发送给我自己。</h2><p id="aab0" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">现在我有了过滤后的工作列表，我需要创建一封电子邮件发送给自己。让我们用明文和HTML来实现MIME多部分消息，就像我从LinkedIn收到的那样。这项任务有两个部分:构建明文和HTML消息部分，然后将它们包装成标准格式的电子邮件。</p><p id="7c3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">明文部分非常简单。我将每个作业的元数据和URL连接成一个字符串。</p><p id="3f56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了制作HTML部分，我发现有用的<a class="ae km" href="https://github.com/Knio/dominate" rel="noopener ugc nofollow" target="_blank">占据了</a>包。经过几次迭代后，我决定将作业列表放在一个&lt;表&gt;元素中。我也觉得我通过包含一些内嵌css回馈了电子邮件营销社区。；-)</p><p id="43d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个要点展示了一个构建回复的这些部分的函数:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">为电子邮件传递构建明文和HTML消息的功能</figcaption></figure><p id="24ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我第一次尝试将这些消息打包成一封电子邮件，使用了标准库中的<a class="ae km" href="https://docs.python.org/3/library/email.examples.html" rel="noopener ugc nofollow" target="_blank"> email </a>包。遵循<a class="ae km" href="https://docs.python.org/3/library/email.examples.html" rel="noopener ugc nofollow" target="_blank">文档</a>中的例子非常简单。但是我最终去掉了那些代码，转而使用<code class="fe mp mq mr ms b">boto3</code> API来创建和发送电子邮件。我们接下来看这部分。</p><h2 id="b5c3" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">任务4:找出如何接收电子邮件，处理邮件内容，然后发送回邮件。</h2><p id="1915" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">在这篇文章的开始，我描述了我的总体计划。这是为了将工作提醒电子邮件转发给某个python进程进行过滤。为了制定这个计划，我需要能够接收电子邮件，并将电子邮件的内容输入过滤代码。</p><p id="0568" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我知道人们运行他们自己的电子邮件服务器，我假设有一些python包可以做到这一点。但当我只是偶尔收到工作邮件时，运行服务器似乎是一种浪费。相反，这听起来像是无服务器方法的一个很好的用例。我希望有一个“唤醒”功能，过滤电子邮件，然后再次关机。</p><p id="a00e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AWS的Lambda似乎是一个合理的起点。但是我仍然需要一种在收到邮件时触发Lambda函数的方法。当然，AWS有这方面的服务。它被称为简单电子邮件服务(SES)。</p><blockquote class="ne nf ng"><p id="44fe" class="jn jo kl jp b jq jr js jt ju jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj kk ij bi translated">当您使用Amazon SES接收消息时，您可以配置Amazon SES在消息到达时调用您的Lambda函数— AWS文档</p></blockquote><p id="e330" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完美！我开始阅读关于创建Lambda函数和使用SES的内容，遵循<a class="ae km" href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-getting-started.html" rel="noopener ugc nofollow" target="_blank">接收电子邮件入门指南</a>。SES的管理步骤很少。首先，你必须<a class="ae km" href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-getting-started-verify.html" rel="noopener ugc nofollow" target="_blank">确认你拥有你想要发送邮件的域名</a>。此外，所有新的SES帐户都是从<a class="ae km" href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/request-production-access.html" rel="noopener ugc nofollow" target="_blank">沙盒</a>中开始的。这意味着您只能向您已经<a class="ae km" href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html" rel="noopener ugc nofollow" target="_blank">验证过的</a>地址发送电子邮件。对于这个项目，这些限制无关紧要。我只想从一个电子邮件地址发送和接收，这是我自己的。</p><p id="42e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SES的主要概念之一是<em class="kl">接收规则集</em>。接收规则指定Amazon SES应该如何处理收到的邮件。为了让SES在收到电子邮件时调用Lambda，我开始遵循官方文档。我曾设想电子邮件的内容会传递给Lambda。我很快发现<a class="ae km" href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-action-lambda-event.html" rel="noopener ugc nofollow" target="_blank"> <em class="kl">传入邮件的正文被省略了。</em> </a></p><p id="1087" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在Lambda函数中获取电子邮件的内容，我们必须配置SES将电子邮件的副本放入S3桶中。Lambda然后可以使用SES提供的信息从S3获取电子邮件。我担心事情变得复杂了。</p><p id="9992" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">后来，我欣慰地看到了这个由 <a class="ae km" href="https://gist.github.com/dkavraal" rel="noopener ugc nofollow" target="_blank">丁切尔·卡夫拉尔</a>创作的<a class="ae km" href="https://gist.github.com/dkavraal/356dc60f8f6beb8b5070e891adadab96" rel="noopener ugc nofollow" target="_blank">例子，它成了我的解决方案的支柱。关于设置角色的部分对我来说很重要，我花了一点时间来熟悉它。如果你自己小心地一步一步来，它应该可以工作。因此，我能够设置SES和Lambda来接收电子邮件和回复。</a></p><p id="c869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">把过滤代码硬塞进Lambda。</strong></p><p id="f92e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们有一个接收和发送电子邮件的有效工具。现在我需要把我的邮件过滤代码放到这个框架中。到目前为止，我一直在Lambda控制台中直接编辑(或者更准确地说，复制/粘贴)代码。它工作得很好，但我知道我的过滤代码依赖于一些额外的python包。我会想办法把它们捆起来，推到Lambda上。起初，我对此有点不知所措。</p><p id="1b95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我发现了另一个很大的帮助，那就是<code class="fe mp mq mr ms b">python-lambda </code>包。我按照<a class="ae km" href="https://hackersandslackers.com/improve-your-aws-lambda-workflow-with-python-lambda/" rel="noopener ugc nofollow" target="_blank">这些指南</a>来安装它并建立一个新的本地文件夹。然后从一个新的<code class="fe mp mq mr ms b">pipenv</code> shell中，我调用<code class="fe mp mq mr ms b">lambda init</code>来创建以下文件:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nk"><img src="../Images/68ec42e79fce2958ecb52c6fcace0aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ikBeqYaflPYTRSeb_RY2dw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated"><a class="ae km" href="https://hackersandslackers.com/improve-your-aws-lambda-workflow-with-python-lambda/" rel="noopener ugc nofollow" target="_blank"> python-lamda </a>创建的目录结构</figcaption></figure><p id="238f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mp mq mr ms b">service.py</code>内部是最重要的<code class="fe mp mq mr ms b">handler()</code>函数，每当<a class="ae km" href="https://docs.aws.amazon.com/lambda/latest/dg/python-programming-model.html" rel="noopener ugc nofollow" target="_blank">λ被调用</a>时，这个函数就会被调用。</p><p id="79c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，首先我将Karvaal的示例代码复制到处理函数中。然后我可以移植我自己的邮件过滤脚本的一部分。</p><p id="26a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我的代码的主要修改是在管道上:</p><ul class=""><li id="68b4" class="kn ko iq jp b jq jr ju jv jy kp kc kq kg kr kk nl kt ku kv bi translated">使用从S3获取的内容，而不是从文件中阅读电子邮件</li><li id="6bfb" class="kn ko iq jp b jq kw ju kx jy ky kc kz kg la kk nl kt ku kv bi translated">使用<code class="fe mp mq mr ms b">boto3</code> API打包并发送电子邮件，而不是标准的python <code class="fe mp mq mr ms b">email</code>包。</li></ul><p id="43b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整代码可在<a class="ae km" href="https://github.com/wooduk/lifilter" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><p id="bfd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mp mq mr ms b">python-lambda</code>的美妙之处在于，设置好<code class="fe mp mq mr ms b">config.yaml</code>文件后，我可以简单地将这些代码部署到AWS。要么直接(<code class="fe mp mq mr ms b">lambda deploy)</code>，通过S3 ( <code class="fe mp mq mr ms b">lambda deploy-s3</code>)或创建一个手动上传的zip文件(<code class="fe mp mq mr ms b">lambda build</code>)。选择其中一个选项后,<code class="fe mp mq mr ms b">python-lambda</code>将所有的源代码和包打包成一个zip文件。<code class="fe mp mq mr ms b">build</code>选项使这变得更加透明，因为它创建了一个名为<code class="fe mp mq mr ms b">dist/</code>的目录并将zip文件放在那里。我惊喜地发现这变得如此简单。</p><h2 id="9a73" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">任务5。转发一些提醒邮件给系统工程师。</h2><p id="36e8" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">因此，随着代码的捆绑和部署，我准备好将电子邮件转发到我的新服务。多刺激啊！但是…真令人失望！起初，我没有收到工作提醒。机器的主要部分似乎在运转。我转发的电子邮件已收到，并已回复。它只是没有任何工作机会。</p><p id="f0c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我之前描述的问题，Gmail不转发我们最初看到的原始邮件，而是发送一个预处理版本。我使用正则表达式调整了电子邮件解析器，并再次尝试。这一次它成功了，看起来很令人满意。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/fb3299ceaf0200690d513fbdd9488d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*q7wzyj1lt62OvJJKw34bpA.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">按我的收件箱中描述的语言过滤的工作通知。</figcaption></figure><h2 id="2fdf" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">任务6。沉浸在荣耀中。</h2><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/a7206fc91eadb3ac386211bc3bc72f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*V9aELtX8XElqME9z-4rPwA.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">可能有更简单的方法！</figcaption></figure><p id="731f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">利用其他人的例子，我能够在相对较短的时间内将这些整合在一起。鉴于我之前没有使用过SES或Lambda，我很惊讶它看起来如此简单。我不得不承认，这并不是完全没有头痛。我发现为AWS服务配置相互通信的权限变得有点棘手。有时AWS文档会让你觉得在兜圈子。感谢<a class="ae km" href="https://gist.github.com/dkavraal" rel="noopener ugc nofollow" target="_blank">丁切尔·卡夫拉尔</a>和<a class="ae km" href="https://hackersandslackers.com/improve-your-aws-lambda-workflow-with-python-lambda/" rel="noopener ugc nofollow" target="_blank">托德·伯查德</a>的例子，是他们让我走上了这条路。</p><p id="4452" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里创建的接收、触发过滤、发送的基本框架已经在另一个项目中派上了用场。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h2 id="4be9" class="lb lc iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">笔记</h2><p id="6581" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">[1]是的，我正在等待它被指出按语言过滤是多么明显，但我想要一个辅助项目。</p><p id="f9ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2]我不是在鼓吹AWS胜过谷歌云或微软Azure，我只是先在那里看了看，找到了我想要的。</p></div></div>    
</body>
</html>