<html>
<head>
<title>Azure Durable Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure持久功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/azure-durable-functions-ec535551751b?source=collection_archive---------5-----------------------#2020-02-09">https://levelup.gitconnected.com/azure-durable-functions-ec535551751b?source=collection_archive---------5-----------------------#2020-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9df7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Azure持久功能有助于在无状态功能的代码中定义有状态的工作流。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f721030e6caf1c7c0c73ec38750f388e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MiVnU9RTe47fZWUdoQaOmg.png"/></div></div></figure><p id="e35f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">耐用功能简单来说:</strong></p><ul class=""><li id="2328" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">Azure函数的扩展</li><li id="a658" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">无服务器环境中的有状态函数</li><li id="be1e" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">在代码中定义工作流</li></ul><h2 id="1fd7" class="ll lm iq bd ln lo lp dn lq lr ls dp lt jy lu lv lw kc lx ly lz kg ma mb mc md bi translated">持久功能的主要优势</h2><p id="5eb6" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">持久功能的一些主要优点是</p><ul class=""><li id="0cc6" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">功能的并行执行(扇出&gt;扇入)</li><li id="f415" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">中央错误处理</li><li id="a222" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">通过“Orchestrator函数”易于理解函数之间的依赖关系</li></ul><h1 id="ad72" class="mj lm iq bd ln mk ml mm lq mn mo mp lt mq mr ms lw mt mu mv lz mw mx my mc mz bi translated">概观</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/993c44be11e136966ca347c82e178f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*NWzhr3JBCCnZWOhNIfCfdA.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">耐久功能概述</figcaption></figure><p id="81d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">启动函数</strong>:简单的Azure函数，通过调用Orchestrator函数来启动编排。它使用了一个<code class="fe nf ng nh ni b">OrchestrationClient</code>绑定。</p><p id="3cf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OrchestrationClient负责启动/停止编排器并监控它们的状态。</p><p id="536b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Orchestrator函数</strong>:在代码中定义有状态工作流，并调用活动函数。活动调用期间休眠，唤醒时重放。这也为定义工作流和执行实际活动提供了关注点的分离。</p><p id="d4b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">orchestrator函数中的代码必须是确定性的，因为在流程中，代码将被反复执行，直到所有活动函数完成。通过使用<code class="fe nf ng nh ni b">OrchestrationTrigger</code>将一个函数声明为orchestrator</p><p id="fd61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">编排功能限制:</strong></p><ul class=""><li id="f606" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">确定性:没有NewGuid()，Random，DateTime。现在，Http调用等。</li><li id="9e06" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">无阻塞:没有I/O操作(例如:表存储逻辑等。)，没有线程. sleep等..</li><li id="f557" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">在不使用上下文的情况下，永远不要启动任何异步操作</li></ul><p id="90bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">活动函数</strong>:简单的Azure函数，执行工作流中的单个步骤，可以接收或返回数据。活动函数使用一个<code class="fe nf ng nh ni b">ActivityTrigger</code>,这样就可以被编排器调用</p><h2 id="a059" class="ll lm iq bd ln lo lp dn lq lr ls dp lt jy lu lv lw kc lx ly lz kg ma mb mc md bi translated"><strong class="ak">子编排:</strong></h2><p id="5e25" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">持久函数也支持子编排。这个特性使我们能够创建协调多个活动的子协调器。一个编制器函数可以使用<code class="fe nf ng nh ni b">CallSubOrchestratorAsync</code>或<code class="fe nf ng nh ni b">CallSubOrchestratorWithRetryAsync</code>方法调用另一个编制器函数。</p><p id="ac19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它可以方便地用于:</p><ul class=""><li id="0680" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">复杂的编排</li><li id="18a8" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">在需要重试机制的情况下。</li><li id="cb81" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">在活动函数中需要延迟的情况下。活动功能中的延迟将被视为功能执行时间的一部分，因此将被计费，而orchestrator中的定时器延迟不会被计费，因为orchestrator将进入睡眠状态，直到定时器被触发。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/714b5edf4af1c9caa9584b7d46654b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*-vHtO4l6a9R43ZKziD6gew.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">副指挥</figcaption></figure><h1 id="130f" class="mj lm iq bd ln mk ml mm lq mn mo mp lt mq mr ms lw mt mu mv lz mw mx my mc mz bi translated">模式</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nk"><img src="../Images/1f239ecb94c28736cbe0b2923e97c5ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2rt6peaAIzWgWagrSN9Lyw.png"/></div></div></figure><h1 id="30f1" class="mj lm iq bd ln mk ml mm lq mn mo mp lt mq mr ms lw mt mu mv lz mw mx my mc mz bi translated">持久功能内部机制</h1><p id="6cef" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">持久函数利用了<strong class="jp ir">存储队列。队列中的消息</strong>触发下一个函数。编排状态保存在<strong class="jp ir">存储表中。</strong>它利用事件源播放当前事件并触发下一个事件。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/ea4ad83abe31502baa1c5e25001b3414.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*WFEhFrf3UQcfa0Q5EI6N9A.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">持久功能存储队列和表</figcaption></figure><p id="6cf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">事件源事件:</strong></p><p id="d629" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在工作流执行期间，会为以下活动存储事件:</p><ul class=""><li id="a162" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">Orchestrator已启动</li><li id="9279" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">活动1已安排</li><li id="f3a2" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">Orchestrator进入睡眠状态(没有为其注册明确的事件)</li><li id="8932" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">Orchestrator启动(唤醒) &gt;活动1完成</li><li id="6e2a" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">计划的活动2</li><li id="2e4b" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">编制器已完成</li></ul><p id="fe91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">存储表:</strong></p><ul class=""><li id="cdfc" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><strong class="jp ir">DurableFunctionsHubInstances</strong>:包含每个orchestrator实例的记录及其输入、最终输出和运行时状态</li><li id="6a90" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated"><strong class="jp ir">durablefunctionshubhhistory:</strong>包含每个orchestrator实例的事件源事件。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/0450e970499042681a4880a2e8090590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Th38ZRsf3WPuPVEN.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">持久功能内部机制</figcaption></figure><p id="4b75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nn">注意</em> </strong> <em class="nn">:上面提到的表&amp;队列名称是持久函数的默认名称；如果存储在不同的功能应用之间共享，那么建议在host.json中指定自定义集线器名称</em></p><pre class="km kn ko kp gt no ni np nq aw nr bi"><span id="a61d" class="ll lm iq ni b gy ns nt l nu nv"><em class="nn">Function Version 2.0 host.json:</em></span><span id="2a12" class="ll lm iq ni b gy nw nt l nu nv"><em class="nn">"extensions": {</em></span><span id="7228" class="ll lm iq ni b gy nw nt l nu nv"><em class="nn">     "durableTask": {</em></span><span id="868f" class="ll lm iq ni b gy nw nt l nu nv"><em class="nn">            "hubName": "PeppolSupportedDocumentUpdaterHub"</em></span><span id="5572" class="ll lm iq ni b gy nw nt l nu nv"><em class="nn">      }<br/>}</em></span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="0fea" class="mj lm iq bd ln mk ml mm lq mn mo mp lt mq mr ms lw mt mu mv lz mw mx my mc mz bi translated">监测进展</h1><p id="23e1" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">带有HttpTrigger的Starter / OrchestrationClient可以返回带有“CreateCheckStatusResponse”的响应，该响应包含可用于监控工作流进度的“statusQueryGetUri”。</p><pre class="km kn ko kp gt no ni np nq aw nr bi"><span id="dc47" class="ll lm iq ni b gy ns nt l nu nv">statusQueryGetUri:</span><span id="3c31" class="ll lm iq ni b gy nw nt l nu nv"><a class="ae nz" href="http://localhost:7071/runtime/webhooks/durabletask/instances/{instance" rel="noopener ugc nofollow" target="_blank">http://{BaseUri}/runtime/webhooks/durabletask/instances/{Instance</a>Id}?taskHub=DurableFunctionsHub&amp;connection=Storage&amp;code={FunctionKey}</span></pre><p id="9728" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果涉及子任务，则可以通过向“statusQueryGetUri”添加以下附加查询参数来监控子任务的进度/输出:</p><pre class="km kn ko kp gt no ni np nq aw nr bi"><span id="bd99" class="ll lm iq ni b gy ns nt l nu nv">  &amp;showHistoryOutput=true&amp;showHistory=true</span></pre><h1 id="7d7c" class="mj lm iq bd ln mk ml mm lq mn mo mp lt mq mr ms lw mt mu mv lz mw mx my mc mz bi translated">延迟和重试机制</h1><p id="f9fd" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">语境。CreateTimer，可用于在链中的单个任务执行之间添加延迟。</p><pre class="km kn ko kp gt no ni np nq aw nr bi"><span id="443f" class="ll lm iq ni b gy ns nt l nu nv">var activityTask = context.CallActivityAsync&lt;ActivityLog&gt;(nameof(FunctionName), inputValueToFunction);</span><span id="6292" class="ll lm iq ni b gy nw nt l nu nv">//add 3-sec delay between execution of tasks<br/>var timeToStart = await context.CurrentUtcDateTime.AddSeconds(3);</span><span id="2c84" class="ll lm iq ni b gy nw nt l nu nv">var delayedActivityTask =  context.CreateTimer(timeToStart, CancellationToken.None).ContinueWith(t =&gt; activityTask);</span><span id="b819" class="ll lm iq ni b gy nw nt l nu nv">tasks.Add(delayedActivityTask);</span><span id="9358" class="ll lm iq ni b gy nw nt l nu nv">await Task.WhenAll(tasks);</span><span id="f423" class="ll lm iq ni b gy nw nt l nu nv">var result = tasks.Select(task =&gt; task.Result).ToList();</span><span id="0653" class="ll lm iq ni b gy nw nt l nu nv">return result;</span></pre><p id="ec8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Activity函数可以在Orchestrator中重试，也可以指定每次重试之间的延迟。也可以选择指定要重试活动的异常。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oa"><img src="../Images/f80642782766d3799f8c63b0bb4378a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FErWVsjPnD40JyoVrmOqoQ.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">重试“InvalidOperationException”的活动函数</figcaption></figure><h2 id="6f0c" class="ll lm iq bd ln lo lp dn lq lr ls dp lt jy lu lv lw kc lx ly lz kg ma mb mc md bi translated">其他资源:</h2><div class="ob oc gp gr od oe"><a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview?tabs=csharp#application-patterns" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">持久功能概述- Azure</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">Azure函数的持久函数扩展介绍。</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">docs.microsoft.com</p></div></div><div class="on l"><div class="oo l op oq or on os kv oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://www.serverless360.com/blog/azure-durable-functions-patterns-best-practices" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">持久功能模式的Azure最佳实践|无服务器360</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">在Serverless360博客的上一篇文章中，我们介绍了持久功能，后来讨论了何时选择持久…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">www.serverless360.com</p></div></div><div class="on l"><div class="ot l op oq or on os kv oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-sub-orchestrations?tabs=csharp" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">持久功能的子流程- Azure</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">除了调用活动函数，orchestrator函数还可以调用其他orchestrator函数。比如说…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">docs.microsoft.com</p></div></div><div class="on l"><div class="ou l op oq or on os kv oe"/></div></div></a></div><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ov ny l"/></div></figure></div></div>    
</body>
</html>