<html>
<head>
<title>Refactoring a Complex React Component — 5 Best Practices to Write Efficient and Readable Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构复杂的React组件——编写高效可读组件的5个最佳实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/refactoring-a-complex-react-component-5-best-practices-to-write-efficient-and-readable-components-b0d06f4f22b4?source=collection_archive---------1-----------------------#2019-09-30">https://levelup.gitconnected.com/refactoring-a-complex-react-component-5-best-practices-to-write-efficient-and-readable-components-b0d06f4f22b4?source=collection_archive---------1-----------------------#2019-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9cf97eac5abd2026401467ae3b466e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fyw4kFfXiHbQDjGS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">萨法尔·萨法罗夫在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="3e26" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">这个问题</h1><p id="d9c4" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">React.js已经成为最受欢迎的web组件视图库，它跨越了多种特性，如今已成为创建令人惊叹的web应用程序的完整工具。</p><p id="c91e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">该社区呈指数级增长，尤其是在过去的2-3年里，网上充斥着数以千计的关于这项技术的教程。</p><p id="45bb" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">所以，每个初学者在开始学习React时应该做的，正如我在<a class="ae kf" href="https://codeworks.me/?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=marco_ghiani_hackernoon_how_to_write_clean_react_components" rel="noopener ugc nofollow" target="_blank"><strong class="lg iu"><em class="mh">Codeworks</em></strong></a>开始我的道路时所做的，是阅读文档或教程来创建他们的第一个组件。</p><p id="9444" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">但是我的问题是:<strong class="lg iu">你确定你的React组件遵循了最佳实践吗？或者简单地说，它们仅仅是工作吗？</strong></p><h1 id="3dc5" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">肮脏的组件是什么样子的</h1><p id="a7cf" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为了更好地解释我的观点，让我们看一下下面的React组件:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mi"><img src="../Images/8ef7d56b50311fb0b890622437824355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yMx7iU9sxrxnUOVZSs_rCg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">肮脏的反应元件</figcaption></figure><p id="0eb3" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">这是一个完全工作的React组件，可以在整个应用程序中多次使用，呈现一个按钮列表，该列表有一个用途，并显示最后单击的按钮是什么。很简单。</p><p id="5705" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">你可能会想"<em class="mh">嗯……如果它能工作，那就好了！</em></p><p id="8dc1" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">但是，如果您知道如何用几行代码编写相同的组件，而不是现在的62行代码，会怎么样呢？<strong class="lg iu"> <em class="mh">先从清理开始吧！</em>💎</strong></p><h1 id="3180" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">1.具有反作用钩优选功能部件</h1><p id="938c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">随着React 16.8中钩子的引入，我们通过在类声明上使用功能组件来实现有状态组件的能力(如果我们需要处理任何逻辑的话)。</p><p id="1df6" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">在本文中，我们不会深入讨论类与功能组件或React挂钩。然而，众所周知，在React社区中，创建功能组件是更好的选择，尤其是现在我们可以使用钩子了。</p><blockquote class="mn"><p id="ca18" class="mo mp it bd mq mr ms mt mu mv mw mb dk translated">钩子允许你在不改变组件层次结构的情况下重用有状态逻辑。</p></blockquote><p id="9ce5" class="pw-post-body-paragraph le lf it lg b lh mx lj lk ll my ln lo lp mz lr ls lt na lv lw lx nb lz ma mb im bi translated">因此，让我们看看第一次重构后的组件是什么样的:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/e1c277905f11d4f7b25918ef1530a61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvZkBh47Dti0Tr7n5IlExg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">用React钩子重构功能组件。</figcaption></figure><p id="f561" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">好了，我们的组件已经更短了，我们放弃了<em class="mh">类</em>语法，但是仍然需要做很多优化。</p><h1 id="89ba" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">2.擦干湿的！</h1><p id="06e1" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们能识别出这个组件中的任何模式吗？查看代码，似乎我们每次都呈现一个相似的按钮元素，每个元素都接受一些相似的道具，这是将这个长组件分成小部分的完美例子。</p><p id="c3a5" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">所以我们可以重构它，创建另一个小的功能组件来呈现按钮，传递一些属性，如<code class="fe nd ne nf ng b">action</code> <strong class="lg iu"> <em class="mh">，</em> </strong> <code class="fe nd ne nf ng b">setClicked</code> <strong class="lg iu"> <em class="mh">，</em> </strong>和<strong class="lg iu"> <em class="mh"> </em> </strong> <code class="fe nd ne nf ng b">title</code>:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/8cbfab2bd5ae037800b5747cfa12fef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zffuDNX_JhPuGS-PFAjcyw.png"/></div></div></figure><p id="5031" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">好了，我们的组件开始有一个更好的形状，但仍有改进的余地，让我们继续！</p><h1 id="ca38" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">3)恰当的命名和道具解构</h1><p id="1b16" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><code class="fe nd ne nf ng b">setLastClickedButton</code> <em class="mh"> </em>是我们的setter函数的描述性名称，但是我们需要保持代码的可读性和简短性，所以保持我们使用的名称简洁和必要是很重要的。我们将把它改名为<code class="fe nd ne nf ng b">setClicked</code>。</p><p id="6d63" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">同样，只要有可能，从道具对象中析构你所需要的可以避免不断重复<code class="fe nd ne nf ng b">props</code> <em class="mh"> </em>单词。在我们的<code class="fe nd ne nf ng b">ListItem</code>组件中，我们现在通过析构函数参数<code class="fe nd ne nf ng b">{ action, title, setClicked }</code>中的名称来访问props。</p><p id="6995" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">让我们来看看这两个变化:</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/bd74880407c904d6610c5440cb6e9b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgcbNoelw2NBBFt6lF-ZGA.png"/></div></div></figure><p id="dfe5" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">太好了，我们大大减少了组件声明的长度，但是我们还可以做得更好！🚀</p><h1 id="a062" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">4.愿PropTypes与你同在！</h1><p id="0185" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">清理之后，是时候在编写组件时应用绝对最佳实践了！有了<a class="ae kf" href="https://www.npmjs.com/package/prop-types" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> PropTypes </strong> </a>，我们就可以对接收到的道具进行验证，避免因数据类型不同而产生错误，比如接收到字符串“0”并试图将其与数字0进行严格比较(<strong class="lg iu">“0”= = = 0-&gt;FALSE！！！</strong>):</p><figure class="mj mk ml mm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/a74c7cbd092a493a92a14100f0d5fcf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ym-t_qLHswY-14aKh6e7bg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">属性类型验证。</figcaption></figure><h1 id="2488" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">5.分成小块</h1><p id="c8c4" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">猜猜看，我们的组件或多或少和初始版本一样长，但是仔细看看我们现在拥有的代码。</p><p id="de3e" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">我们看到两个不同的组件，我们可以将它们分成两个模块，使它们可以在整个应用程序中重用。</p><div class="mj mk ml mm gt ab cb"><figure class="ni ju nj nk nl nm nn paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/800390d1bcf6dd09d7bc7c1cc10e1736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*J37slRTcWt7a8AgAGhygQQ.png"/></div></figure><figure class="ni ju no nk nl nm nn paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/bb76e6d3b0d33cc241a4b9c918d92983.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*zkHad6Ktu2nPDU8pFEzL9Q.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk np di nq nr translated">List.js &amp; ListItem.js</figcaption></figure></div><h1 id="a6d9" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="2f92" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">应用于我们初始组件的这种清理展示了当您开始深入研究React组件时可以遵循的一些好的实践。</p><p id="5ecd" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">当然，我们可以对这个最终结果进行大量的其他优化，但是要一步一步来。要遵循的五个良好实践是一个很好的起点😉</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="7e16" class="pw-post-body-paragraph le lf it lg b lh mc lj lk ll md ln lo lp me lr ls lt mf lv lw lx mg lz ma mb im bi translated">关于这个话题的评论、分享和讨论总是很受欢迎，我很乐意回答你的任何问题！</p><blockquote class="nz oa ob"><p id="7149" class="le lf mh lg b lh mc lj lk ll md ln lo oc me lr ls od mf lv lw oe mg lz ma mb im bi translated"><strong class="lg iu">随时联系我</strong> <a class="ae kf" href="https://www.linkedin.com/in/marcoantonioghiani/" rel="noopener ugc nofollow" target="_blank"> <strong class="lg iu"> Linkedin </strong> </a></p></blockquote><div class="of og gp gr oh oi"><a href="https://medium.com/better-programming/javascript-tips-4-array-flat-and-flatmap-implementation-2f81e618bde" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">Javascript技巧#4:数组平面和平面图实现</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">对新的flat和flatMap方法的潜力的有用介绍</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow jz oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/better-programming/javascript-tips-3-convert-error-first-callback-functions-to-promises-f2561d2aaefd" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">JavaScript技巧#3:将错误优先回调函数转换为承诺</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">JavaScript异步概述和保证错误优先回调的实用程序</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow jz oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/better-programming/javascript-tips-2-object-array-deep-clone-implementation-2d6a43e43d2a" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">JavaScript技巧#2:对象/数组深度克隆实现</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">JavaScript中深度克隆方法的简单实现</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow jz oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/better-programming/javascript-tips-1-the-filter-method-for-object-properties-a2d6869b5127" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">JavaScript技巧#1:对象属性的过滤方法</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">应用于对象属性的过滤器数组方法的简单JavaScript聚合填充</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="oz l ot ou ov or ow jz oi"/></div></div></a></div></div></div>    
</body>
</html>