<html>
<head>
<title>Simple Modern CMake Tutorial Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的现代CMake教程第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simple-modern-cmake-tutorial-b0c1c362cd2c?source=collection_archive---------1-----------------------#2020-05-23">https://levelup.gitconnected.com/simple-modern-cmake-tutorial-b0c1c362cd2c?source=collection_archive---------1-----------------------#2020-05-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b99c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">“面向对象”的现代计算机动画简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ade109afe8115a0640cd3ed00f75414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g_emRdckKU6jKJr1"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Artem Sapegin 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CMake是一个用于管理软件构建过程的开源工具。CMake是一个流行的工具，尤其是在C++社区中。目前很多C++项目都在使用CMake。正如你在下面看到的Google趋势结果，与其他构建系统如SCons、Bazel相比，更多的人对CMake感兴趣(所以熟悉它肯定是个好主意！).</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/36e38a19b019f7e84c9ab58ca32cd94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAWdVK-4h5Pc08BNhX-crA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">不同构建系统(Bazel，CMake，SCons)上的Google趋势。</figcaption></figure><p id="79e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，CMake并不像以前那样流行，因为它的一些语法和不太优雅的特性。然而，自CMake 3 . x(2014年6月6日发布)以来，它增加了新的功能，使CMake更加强大、干净和优雅。较新版本的CMake (3.1或更高版本)有时被称为“现代CMake”。</p><p id="dafd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将用一些简单的例子解释现代CMake的某些方面(这里是<a class="ae ky" href="https://github.com/rjhcnf/cmake_tutorial" rel="noopener ugc nofollow" target="_blank">到Github库的链接</a>)。<br/>特别是，我想谈的几点是:</p><ul class=""><li id="5b08" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">在面向对象编程中，将“构建目标”(即使用CMake构建的可执行文件或库)视为“对象”的概念，以便更好地构建您的项目，以及构建依赖项的继承的概念是可传递的(可传递依赖项)。</li><li id="ad5d" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如何导出/安装CMake包并从另一个CMake项目导入它。</li></ul><p id="ae73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Daniel Pfeifer的有效的CMake⁴演讲给了我很多有用的见解来理解现代的CMake concept⁵，并帮助我写了这篇文章。</p><h1 id="ccd4" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">示例CMake包</h1><p id="b3e0" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">首先，让我看一下我们将在本教程中使用的项目结构。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="942b" class="nm ml it ni b gy nn no l np nq">cmake_tutorial<br/>|__ app                 # <strong class="ni iu">MyApplication package</strong> <br/>|   |__ CMakeLists.txt<br/>|   |__ src<br/>|       |__ main.cpp<br/>|    <br/>|<br/>|__ my_libraries       # <strong class="ni iu">MyLibraries package</strong><br/>|   |__ CMakeLists.txt<br/>|   |__ cmake<br/>|   |   |__ MyLibrariesConfig.cmake<br/>|   |<br/>|   |__ include<br/>|   |   |__ my_libraries<br/>|   |      |__ my_library_a.hpp<br/>|   |<br/>|   |__ src<br/>|       |__ my_library_a.cpp<br/>|   <br/>| <br/>|__ some_libraries     # <strong class="ni iu">SomeLibraries package</strong><br/>   |__ CMakeLists.txt<br/>   |__ cmake<br/>   |   |__ SomeLibrariesConfig.cmake<br/>   |<br/>   |__ include<br/>   |   |__ some_libraries<br/>   |     |__ some_library_a.hpp<br/>   |     |__ some_library_b.hpp<br/>   |__ src<br/>       |__ some_library_a.cpp<br/>       |__ some_library_b.cpp</span></pre><p id="dd1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nr"> app </em>目录包含MyApplication可执行包。<em class="nr"> my_libraries </em>目录包含MyLibraries库包。<em class="nr"> some_libraries </em>包含SomeLibraries库包。我的应用程序依赖于我的库，而我的库又依赖于一些库。所以3个包之间的关系如下。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f486" class="nm ml it ni b gy nn no l np nq">MyApplication --depends--&gt; MyLibraries --depends--&gt; SomeLibraries</span></pre><p id="aab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，有三种方法可以从另一个CMake项目访问一个CMake项目:子目录、导出的构建目录和导入已经安装的预构建包。在这篇文章中，我想解释第三种选择；如何安装一个CMake包并从另一个CMake项目中导入(所以，我们假设MyApplication、MyLibraries和SomeLibraries分别作为单独的包开发)。因此，这三个包在同一个CMake树中是<strong class="lb iu">而不是</strong>。</p><h1 id="5980" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">安装一些库包</h1><p id="59b3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">由于每个人都依赖于一些库(间接的MyApplication和直接的MyLibraries)，我们需要构建和安装它以便其他人可以使用它。some_libraries目录下的CMakeLists.txt如下图所示，</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="bef7" class="nm ml it ni b gy nn no l np nq">## CMakeLists.txt for SomeLibraries ##</span><span id="bd40" class="nm ml it ni b gy ns no l np nq">cmake_minimum_required(VERSION 3.5)<br/>project(SomeLibraries VERSION 1.0 LANGUAGES CXX)</span><span id="894d" class="nm ml it ni b gy ns no l np nq">add_library(SomeLibraryA src/some_library_a.cpp)</span><span id="0a74" class="nm ml it ni b gy ns no l np nq">target_include_directories(SomeLibraryA <br/>PUBLIC <br/>$&lt;INSTALL_INTERFACE:include&gt;<br/>$&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;<br/>)</span><span id="1c3c" class="nm ml it ni b gy ns no l np nq">add_library(SomeLibraryB src/some_library_b.cpp)</span><span id="ce81" class="nm ml it ni b gy ns no l np nq">target_include_directories(SomeLibraryB<br/>PUBLIC<br/>$&lt;INSTALL_INTERFACE:include&gt;<br/>$&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;<br/>)</span><span id="1c9e" class="nm ml it ni b gy ns no l np nq">install(TARGETS SomeLibraryA SomeLibraryB<br/>EXPORT SomeLibraries-export<br/>LIBRARY DESTINATION lib<br/>ARCHIVE DESTINATION lib<br/>)</span><span id="9a4d" class="nm ml it ni b gy ns no l np nq">install(EXPORT SomeLibraries-export<br/>FILE<br/>SomeLibrariesTargets.cmake<br/>NAMESPACE<br/>SomeLibraries::<br/>DESTINATION<br/>lib/cmake/SomeLibraries<br/>)</span><span id="3d47" class="nm ml it ni b gy ns no l np nq">install(FILES<br/>${CMAKE_CURRENT_SOURCE_DIR}/include/SomeLibraries/some_library_a.hpp<br/>${CMAKE_CURRENT_SOURCE_DIR}/include/SomeLibraries/some_library_b.hpp<br/>DESTINATION "include/SomeLibraries")</span><span id="5401" class="nm ml it ni b gy ns no l np nq">install(FILES<br/>${CMAKE_CURRENT_SOURCE_DIR}/cmake/SomeLibrariesConfig.cmake<br/>DESTINATION "lib/cmake/SomeLibraries" )</span></pre><p id="26d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，您可能已经注意到SomeLibraries包定义了两个目标，SomeLibraryA和SomeLibraryB。它们都有需要安装的公共头文件some_library_a.hpp和some_library_b.hpp(见前面展示的目录树)。</p><p id="e018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的部分从下面的部分开始。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="19c5" class="nm ml it ni b gy nn no l np nq">target_include_directories(SomeLibraryA <br/>PUBLIC <br/>$&lt;INSTALL_INTERFACE:include&gt;<br/>$&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;<br/>)</span></pre><p id="fbce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<em class="nr">target _ include _ directory</em>，它为目标SomeLibraryA指定包含路径。实际上，你可以看到对象“SomeLibraryA”正在调用它的成员函数<em class="nr">target _ include _ directories</em>，就像面向对象的编程范例一样来设置对象的数据(在本例中是包含路径)。像一些类的普通Setter函数一样，它设置对象的属性。指定的包含路径用于构建SomeLibraryA目标，但是，由于它具有<em class="nr"> PUBLIC </em>关键字，当它通过<em class="nr"> target_link_libraries(稍后解释)向SomeLibraryA添加依赖项时，包含路径将被传递给SomeLibraryA的用户。在这个例子中，SomeLibraryA有一个公开的头。</em></p><p id="64d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的<a class="ae ky" href="https://cmake.org/cmake/help/v3.5/manual/cmake-generator-expressions.7.html" rel="noopener ugc nofollow" target="_blank">生成器表达式</a>用于根据情况有选择地选择包含路径。在<em class="nr">$&lt;BUILD _ INTERFACE:&gt;</em>中指定的包含路径在构建<em class="nr"/><em class="nr"/>some library a目标本身时使用。另一方面，假设我们构建了SomeLibraryA目标，并且我们成功地安装了它，以便它可以用于另一个CMake项目(我们将在后面深入讨论安装部分)。那么，如果我们使用<a class="ae ky" href="https://cmake.org/cmake/help/latest/command/find_package.html" rel="noopener ugc nofollow" target="_blank"><em class="nr">find _ package</em></a><em class="nr">(</em>SomeLibraryA<em class="nr">)</em>并在另一个依赖于SomeLibraryA的CMake项目中导入some library a目标，那么<em class="nr">$&lt;INSTALL _ INTERFACE:&gt;</em>中指定的include路径就是<em class="nr"> </em> used <em class="nr">。同样的事情也适用于一些图书馆。</em></p><p id="2d62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要为SomeLibraryA(B)的构建工件指定安装位置。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="3b1f" class="nm ml it ni b gy nn no l np nq">install(TARGETS SomeLibraryA SomeLibraryB<br/>EXPORT SomeLibraries-export<br/>LIBRARY DESTINATION lib<br/>ARCHIVE DESTINATION lib<br/>)</span><span id="63f2" class="nm ml it ni b gy ns no l np nq">install(EXPORT SomeLibraries-export<br/>FILE<br/>SomeLibrariesTargets.cmake<br/>NAMESPACE<br/>SomeLibraries::<br/>DESTINATION<br/>lib/cmake/SomeLibraries<br/>)</span></pre><p id="973b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的第一次<a class="ae ky" href="https://cmake.org/cmake/help/v3.13/command/install.html" rel="noopener ugc nofollow" target="_blank"> <em class="nr">安装</em> </a>时，设置每个目标的安装位置，并将信息输出到某个库-导出。在第二次<em class="nr">安装时，</em>它将设置为SomeLibraries-export的信息写入somebrariestargets . cmake文件，并将somebrariestargets . cmake文件复制到lib/cmake/SomeLibraries目录。可以为每个导出的目标指定名称空间。你可以把它想象成C++这样的编程语言中的名称空间。(除了普通名称空间概念带来的好处之外，它还防止了一些特定于CMake上下文的小问题，但是为了不分散注意力，我现在将跳过它。一般来说，使用名称空间是一个好习惯。</p><p id="b244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，它将公共头复制到安装位置。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="7fb9" class="nm ml it ni b gy nn no l np nq">install(FILES<br/>${CMAKE_CURRENT_SOURCE_DIR}/include/SomeLibraries/some_library_a.hpp<br/>${CMAKE_CURRENT_SOURCE_DIR}/include/SomeLibraries/some_library_b.hpp<br/>DESTINATION "include/SomeLibraries")</span></pre><p id="cd5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个安装位置应该对应于我们之前用<em class="nr">target _ include _ directory、</em>$&lt;INSTALL _ INTERFACE:include&gt;指定的位置。否则，当构建依赖于SomeLibraryA(B)的另一个包时，将找不到公共头文件，因为导入的SomeLibraryA(B)属性与实际安装不匹配。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="3ed7" class="nm ml it ni b gy nn no l np nq">install(FILES<br/>${CMAKE_CURRENT_SOURCE_DIR}/cmake/SomeLibrariesConfig.cmake<br/>DESTINATION "lib/cmake/SomeLibraries" )</span></pre><p id="65ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，它将cmake/中的SomeLibrariesConfig.cmake复制到常规位置“lib/cmake/SomeLibraries”(我们复制SomeLibrariesTargets.cmake的同一个位置，见前面几段。</p><p id="69cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SomeLibrariesConfig.cmake如下图，</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="922a" class="nm ml it ni b gy nn no l np nq">include(CMakeFindDependencyMacro)</span><span id="0a87" class="nm ml it ni b gy ns no l np nq">include("${CMAKE_CURRENT_LIST_DIR}/SomeLibrariesTargets.cmake")</span></pre><p id="a1ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当另一个包使用<em class="nr">find _ package</em>(some libraries)时，CMake搜索这个SomeLibrariesConfig.cmake文件。SomeLibrariesConfig.cmake包含SomeLibrariesTargets.cmake文件，该文件包含目标SomeLibraryA和SomeLibraryB的导出信息，这就是如何将目标及其属性导入到另一个项目中。</p><p id="f9c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。这是您需要在CMakeLists.txt和SomeLibrariesConfig.cmake中指定的最小值，以便从SomeLibraries包中安装SomeLibraryA(B)目标，这样其他包就可以导入并使用它们。现在，您只需要运行cmake并执行make install，如下所示。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="fae0" class="nm ml it ni b gy nn no l np nq">cd some_libraries<br/>mkdir build<br/>cd build<br/>cmake ..<br/>cmake --build . --target install</span></pre><h1 id="9604" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">将SomeLibraries包中的SomeLibraryA(B)目标导入MyLibraries项目</h1><p id="2d29" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">现在，我们已经构建并安装了一些库包，我们准备构建依赖于它的MyLibraries包。MyLibraries包的CMakeLists.txt文件如下所示，</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="c256" class="nm ml it ni b gy nn no l np nq">## CMakeLists.txt for MyLibraries ##</span><span id="8aa5" class="nm ml it ni b gy ns no l np nq">cmake_minimum_required(VERSION 3.5)<br/>project(MyLibraries VERSION 1.0 LANGUAGES CXX)</span><span id="a165" class="nm ml it ni b gy ns no l np nq">find_package(SomeLibraries REQUIRED)</span><span id="7d0a" class="nm ml it ni b gy ns no l np nq">add_library(MyLibraryA src/my_library_a.cpp)</span><span id="7cb2" class="nm ml it ni b gy ns no l np nq">target_include_directories(MyLibraryA<br/>PUBLIC<br/>$&lt;INSTALL_INTERFACE:include&gt;<br/>$&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;<br/>)</span><span id="4d65" class="nm ml it ni b gy ns no l np nq">target_link_libraries(MyLibraryA<br/>PUBLIC<br/>SomeLibraries::SomeLibraryA<br/>PRIVATE<br/>SomeLibraries::SomeLibraryB<br/>)</span><span id="a44e" class="nm ml it ni b gy ns no l np nq">install(TARGETS MyLibraryA<br/>EXPORT  MyLibraries-export<br/>LIBRARY DESTINATION lib<br/>ARCHIVE DESTINATION lib<br/>)</span><span id="d28c" class="nm ml it ni b gy ns no l np nq">install(EXPORT MyLibraries-export<br/>FILE<br/>MyLibrariesTargets.cmake<br/>NAMESPACE<br/>MyLibraries::<br/>DESTINATION<br/>lib/cmake/MyLibraries}<br/>)</span><span id="a10f" class="nm ml it ni b gy ns no l np nq">install(FILES<br/>${CMAKE_CURRENT_SOURCE_DIR}/include/MyLibraries/my_library_a.hpp<br/>DESTINATION "include/MyLibraries")</span><span id="289e" class="nm ml it ni b gy ns no l np nq">install(FILES<br/>${CMAKE_CURRENT_SOURCE_DIR}/cmake/MyLibrariesConfig.cmake<br/>DESTINATION "lib/cmake/MyLibraries" )</span></pre><p id="3992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它使用<a class="ae ky" href="https://cmake.org/cmake/help/v3.0/command/find_package.html" rel="noopener ugc nofollow" target="_blank"><em class="nr">find _ package</em></a><em class="nr">(SomeLibraries REQUIRED)</em>来<em class="nr"> </em>导入some libraries包。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a599" class="nm ml it ni b gy nn no l np nq">find_package(SomeLibraries REQUIRED)</span></pre><p id="231f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将触发CMake搜索SomeLibrariesConfig.cmake文件。这最终将<em class="nr"> SomeLibraries </em>包中的SomeLibraryA(B)目标及其所有属性导入MyLibraries CMake项目。</p><p id="54d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，这里是有趣的部分，使用<a class="ae ky" href="https://cmake.org/cmake/help/latest/command/target_link_libraries.html" rel="noopener ugc nofollow" target="_blank"><em class="nr">target _ link _ libraries</em></a></p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="6994" class="nm ml it ni b gy nn no l np nq">target_link_libraries(MyLibraryA<br/>PUBLIC<br/>SomeLibraries::SomeLibraryA<br/>PRIVATE<br/>SomeLibraries::SomeLibraryB<br/>)</span></pre><p id="3f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“目标和属性”的基本概念以及“对象和成员函数”的类比同样适用于<em class="nr"> target_link_libraries </em>正如<em class="nr"> </em>它们适用于我们之前讨论过的<em class="nr">target _ include _ directory</em>。</p><p id="f4fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，<em class="nr"> SomeLibraries </em>是我们在生成SomeLibrariesTargets.cmake文件时用<em class="nr"> install </em>函数指定的名称空间。通过将SomeLibraries::SomeLibraryA(B)指定为依赖项，MyLibraryA目标继承了SomeLibraryA(B)目标的所有公共属性。此外，通过添加关键字PUBLIC，MyLibraryA将把从SomeLibraryA继承的属性传递给将MyLibraryA作为依赖关系链接到其CMakeLists.txt. <em class="nr"> </em>中的<em class="nr"> target_link_libraries </em>的任何其他目标。另一方面，通过添加关键字private，它指定MyLibraryA对SomeLibraryB的依赖关系为“PRIVATE”，并且从SomeLibraryB继承的属性将<strong class="lb iu">而不是</strong>被<strong class="lb iu"> </strong>传递给链接my library的其他目标这是现代CMake中传递依赖如何工作的基础。</p><p id="6e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，为了使用MyApplication包中的MyLibraries包，我们需要安装MyLibraries包。基本上，我们需要做和安装一些库包一样的事情。</p><p id="7182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要编写MyLibrariesConfig.cmake来安装MyLibraries包，就像我们安装SomeLibraries包一样。需要注意的一点是，在MyLibrariesConfig.cmake内部，我们需要用<em class="nr">find _ dependency(SomeLibraries REQUIRED)</em>指定对some libraries的依赖关系，如下所示，</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f598" class="nm ml it ni b gy nn no l np nq">include(CMakeFindDependencyMacro)</span><span id="c927" class="nm ml it ni b gy ns no l np nq">find_dependency(SomeLibraries REQUIRED)</span><span id="6646" class="nm ml it ni b gy ns no l np nq">include("${CMAKE_CURRENT_LIST_DIR}/MyLibrariesTargets.cmake")</span></pre><p id="d757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们只需要执行下面的命令，</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0a50" class="nm ml it ni b gy nn no l np nq">cd my_libraries<br/>mkdir build<br/>cd build<br/>cmake ..<br/>cmake --build . --target install</span></pre><h1 id="2096" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">将MyLibraries包中的MyLibraryA目标导入MyApplication项目</h1><p id="deed" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">最后，我们准备构建MyApplication可执行包。MyApplication可执行包的CMakeLists.txt如下所示，</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="10b7" class="nm ml it ni b gy nn no l np nq">## CMakeLists.txt for the MyApplication executable package ##</span><span id="74a4" class="nm ml it ni b gy ns no l np nq">cmake_minimum_required(VERSION 3.5)<br/>project(MyApplication VERSION 1.0 LANGUAGES CXX)</span><span id="5a07" class="nm ml it ni b gy ns no l np nq">find_package(MyLibraries REQUIRED)</span><span id="f334" class="nm ml it ni b gy ns no l np nq">add_executable(MyApplication src/main.cpp)</span><span id="79e1" class="nm ml it ni b gy ns no l np nq">target_link_libraries(MyApplication PRIVATE MyLibraries::MyLibraryA)</span></pre><p id="5190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，如你所见，没什么新东西。由于MyLibraryA目标传递SomeLibraryA目标的公共属性(在本例中，是安装公共头文件的include路径)，所以在MyApplication目标的构建过程中可以找到some_library_a.hpp。</p><h1 id="a640" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">摘要</h1><p id="14c6" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在本教程中，我解释了现代CMake的以下方面。</p><ul class=""><li id="1dbc" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">在面向对象编程中，为了更好地构建项目，将“构建目标”(即使用CMake构建的可执行文件或库)视为“对象”的概念，以及构建依赖项传递性继承的思想(传递依赖项)。</li><li id="ecbc" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如何导出/安装CMake包并从另一个CMake项目导入它。</li></ul><p id="4381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@koheiotsuka701/simple-modern-cmake-tutorial-part-2-285614d6a0ce" rel="noopener">Simple Modern CMake Tutorial Part 2 </a></p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><p id="81dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]: <a class="ae ky" href="https://cmake.org/" rel="noopener ugc nofollow" target="_blank">https://cmake.org/ </a></p><p id="662e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]: <a class="ae ky" href="https://scons.org/" rel="noopener ugc nofollow" target="_blank">https://scons.org/ </a></p><p id="e2da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3]: <a class="ae ky" href="https://bazel.build/" rel="noopener ugc nofollow" target="_blank">https://bazel.build/ </a></p><p id="6dae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[4]: C++Now 2017:Daniel Pfeifer “Effective CMake” <a class="ae ky" href="https://www.youtube.com/watch?v=bsXLMQ6WgIk" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=bsXLMQ6WgIk </a></p><p id="07bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[5]: <a class="ae ky" href="https://cliutils.gitlab.io/modern-cmake/" rel="noopener ugc nofollow" target="_blank">https://cliutils.gitlab.io/modern-cmake/ </a></p></div></div>    
</body>
</html>