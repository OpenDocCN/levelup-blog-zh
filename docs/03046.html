<html>
<head>
<title>Unit Testing In JavaScript For Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的JavaScript单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-testing-in-javascript-for-beginners-cf6db5c72fbc?source=collection_archive---------20-----------------------#2020-04-16">https://levelup.gitconnected.com/unit-testing-in-javascript-for-beginners-cf6db5c72fbc?source=collection_archive---------20-----------------------#2020-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/859f4e71d3d6548dcaef43da7c45d70a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rdhh9tvdNwzRCo7aUvU8aA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">“是啊。我会飞。”</figcaption></figure><p id="639a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">测试是一个非常有价值的过程。甚至托尼·斯塔克也做测试。在没有测试的情况下构建任何东西，都是在假设的基础上构建的。这是一种潜在的危险、昂贵或低效的方法。计算机编程是许多真正受益于测试的复杂构建实践之一。作为一个初学者，它不是一个课程或项目成功的必要条件，但是，在规模化的专业水平上，测试是标准的，这样网站不会崩溃，数据库不会损坏，天网不会在审判日进行报复。即使对初学者来说，测试也是一项需要掌握和养成习惯的技能。本文将通过运行时<code class="fe la lb lc ld b"><a class="ae le" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">Node.js</a></code>帮助指导<code class="fe la lb lc ld b">JavaScript</code>中单元测试的基本设置。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="105e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有不同类型的开发，<em class="lm">例如</em>行为驱动、错误驱动、测试驱动。我们将关注测试驱动的开发，它优雅地采用了单元测试。测试驱动的开发支持快速反馈循环的概念——构建、测试、重构、重复——这意味着关注小的部分或单元。请记住，测试有不同的模式，<em class="lm">例如，</em>集成、系统、验收，但是单元测试是测试序列的第一层。从底层到顶层，从细节到大局。单元测试是至关重要的基础，程序员只需做一点准备就可以轻松完成。</p><p id="dc42" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您已经编写了一个程序，然后运行该程序来评估性能，或者向控制台记录一条消息来验证数据类型或返回值，那么您已经执行了一次单元测试，尽管这是一次低效的测试。初学者的一个习惯，我可以说是舒适区，是依赖<code class="fe la lb lc ld b">console.log</code>和终端输出。这有时是一个很好的过程，但是随着代码库越来越复杂，它很快就变得不可行了。有一个模块化的概念——可以说是一种分工——这意味着一个程序文件可以从另一个脚本，一个测试脚本中进行测试。这允许一个有组织的、模块化的测试套件，它可能是自动化的。</p><p id="4d9f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">多亏了我们在万维网上的好朋友，现在有了测试框架来赋予我们功能和更大的便利性。本指南将使用一个名为<code class="fe la lb lc ld b"><a class="ae le" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">Mocha</a></code>的开源<code class="fe la lb lc ld b">JavaScript</code>测试框架，用于<code class="fe la lb lc ld b">Node.js</code>和网络浏览器，以及一个名为<code class="fe la lb lc ld b"><a class="ae le" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank">Chai</a></code>的补充断言库。注意，还有其他的测试框架和断言库，<code class="fe la lb lc ld b">Mocha</code>和<code class="fe la lb lc ld b">Chai</code>只是很普通，用得很好。带上你的咖啡师，我们开始吧。</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/03736e94557fe8c6fc436f4a7de83d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*l_hAxkF_1wG55b7VwL7WfA.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一杯非常好的咖啡。</figcaption></figure><p id="0a79" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个例子中，我将使用一个基本的<code class="fe la lb lc ld b">Node.js</code>文件。我假设您的项目的文件目录和包管理器已经安装并启动。否则，停下来看看如何启动你的项目，无论是<code class="fe la lb lc ld b">Node.js</code>、<code class="fe la lb lc ld b">React</code>、<code class="fe la lb lc ld b">Angular</code>、<code class="fe la lb lc ld b">Vue</code>等等。只要您有一个文件目录、像<code class="fe la lb lc ld b">index.js</code>这样的根文件和<code class="fe la lb lc ld b">package.json</code>文件，您就应该能够理解。抱歉<code class="fe la lb lc ld b">Yarn</code>用户，但你可能还是会跟着做。</p><p id="6663" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，有一个名为<code class="fe la lb lc ld b">unit-test-demo</code>的父目录，一个简单的文件结构，包括一个<code class="fe la lb lc ld b">index.js</code>文件，我将在其中编写一个程序，位于名为<code class="fe la lb lc ld b">src</code>的目录中(source——这是一个常规目录),以及一个与<code class="fe la lb lc ld b">package-lock.json</code>文件配对的<code class="fe la lb lc ld b">package.json</code>文件。</p><pre class="lo lp lq lr gt ls ld lt lu aw lv bi"><span id="1a51" class="lw lx iq ld b gy ly lz l ma mb">|-- unit-test-demo<br/>| |-- src<br/>| | |-- index.js<br/>| |-- package-lock.json<br/>| |-- package.json</span></pre><p id="2cab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于下一步，我通常会看到首先安装的包和依赖项，但是我喜欢首先为要添加的工作准备我的文件结构。对我来说，工作站在工具出来之前就准备好了是有道理的。这就是我，做让<em class="lm">你</em>开心的事。</p><p id="0ad2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从前面对模块化的讨论中我们知道，我们应该创建一个专用的测试目录。这很重要，因为程序最终会增长，并且因为<code class="fe la lb lc ld b">Mocha</code>测试框架依赖于所述测试目录。在测试目录中，我们可以创建一个特定于我们想要运行单元测试的文件的测试文件，在本例中是<code class="fe la lb lc ld b">index.js</code>。您可以直接使用您的文本编辑器或者使用终端命令来创建测试目录和文件。从父目录中(单元测试演示):</p><pre class="lo lp lq lr gt ls ld lt lu aw lv bi"><span id="c28c" class="lw lx iq ld b gy ly lz l ma mb">mkdir test</span></pre><p id="a7e6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后从测试目录中:</p><pre class="lo lp lq lr gt ls ld lt lu aw lv bi"><span id="877c" class="lw lx iq ld b gy ly lz l ma mb">touch indexTest.js</span></pre><p id="58ca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">文件结构将如下所示:</p><pre class="lo lp lq lr gt ls ld lt lu aw lv bi"><span id="35d9" class="lw lx iq ld b gy ly lz l ma mb">|-- unit-test-demo<br/>| |-- src<br/>| | |-- index.js<br/>| |-- test<br/>| | |-- indexTest.js<br/>| |-- package-lock.json<br/>| |-- package.json</span></pre><p id="494d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在可以安装<code class="fe la lb lc ld b">Mocha</code>和<code class="fe la lb lc ld b">Chai</code>了。在终端中运行两者的安装命令。<code class="fe la lb lc ld b">i</code>是缩写的<code class="fe la lb lc ld b">install</code>命令，<code class="fe la lb lc ld b">--save-dev</code>是将安装保存为项目开发依赖项的标志。</p><pre class="lo lp lq lr gt ls ld lt lu aw lv bi"><span id="1998" class="lw lx iq ld b gy ly lz l ma mb">npm i mocha --save-dev</span><span id="fde7" class="lw lx iq ld b gy mc lz l ma mb">npm i chai --save-dev</span></pre><p id="e276" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">瞧啊。您的taquitor应该已经成功安装了新的brew。你可以通过检查<code class="fe la lb lc ld b">package.json</code>文件来验证。注意<code class="fe la lb lc ld b">“devDependencies”</code>键。</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/b86d20dfcea0d2c501c8ae8b56eca783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-7kujlmJnelPRSLtF7kiQ.png"/></div></div></figure><p id="7dec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">*注线</strong> <code class="fe la lb lc ld b"><strong class="ke ir">7</strong></code>。安装完<code class="fe la lb lc ld b">Mocha</code>后，我手动添加了<code class="fe la lb lc ld b">“mocha”</code>作为测试脚本。这使得测试可以通过使用终端命令<code class="fe la lb lc ld b">npm test</code>来运行。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="2104" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用<code class="fe la lb lc ld b">Mocha</code>进行测试的语法近似于英语，而<code class="fe la lb lc ld b">Chai</code>则细化了这种近似。您可以不用像<code class="fe la lb lc ld b">Chai</code>这样的断言库来编写测试，但是由于断言库如此普遍地被使用并且使得编写测试更加容易，我们将直接跳到它上面。如果你想用<code class="fe la lb lc ld b">Mocha</code>探索更基本的测试，请探索<a class="ae le" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">文档</a>或其他资源。</p><p id="37e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，让我们准备好<code class="fe la lb lc ld b">indexTest.js</code>文件来使用测试工具。<code class="fe la lb lc ld b">Mocha</code>被我们的测试脚本触发和访问。我们需要使用<code class="fe la lb lc ld b">Node.js()</code> <code class="fe la lb lc ld b">require()</code>函数来导入<code class="fe la lb lc ld b">Chai</code>。我们将把它赋给一个变量，然后建立<code class="fe la lb lc ld b"><a class="ae le" href="https://www.chaijs.com/guide/styles/#expect" rel="noopener ugc nofollow" target="_blank">expect</a></code>断言风格并把它赋给一个变量。我们还将<code class="fe la lb lc ld b">require()</code>我们想要测试的<code class="fe la lb lc ld b">index.js</code>文件。</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/d97ba3ddd062fca9653484abf3473cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IeP1ifIWbMEesRsB-uukKA.png"/></div></div></figure><p id="9e9d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，我们来看一个单元测试。编写它是为了测试<code class="fe la lb lc ld b">index.js</code>文件中一个名为<code class="fe la lb lc ld b">launchSkynet</code>的函数。仔细检查一下，然后我们会分解它。</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/4a97ae358ac5b93aecd1cad2e9a6b849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0DVlm7fY8cZRFOMjD8W_OA.png"/></div></div></figure><p id="6e8a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">第<code class="fe la lb lc ld b">6</code>行是单元测试的外部范围。<code class="fe la lb lc ld b">describe()</code>函数接受两个参数:一个描述符和一个回调，用于指定和分组测试主题。可以看到，<code class="fe la lb lc ld b">describe()</code>是可以嵌套的。通俗地说:一个名为<code class="fe la lb lc ld b">index</code>的文件正在被评估。在<code class="fe la lb lc ld b">index</code>内部，一个名为<code class="fe la lb lc ld b">launchSkynet</code>的函数正在被评估。</p><p id="3bfb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第<code class="fe la lb lc ld b">8</code>、<code class="fe la lb lc ld b">11</code>和<code class="fe la lb lc ld b">14</code>行，我们看到了<code class="fe la lb lc ld b">it()</code>函数。<code class="fe la lb lc ld b">it()</code>也接受一个描述符和一个回调，并评估一个特定的测试用例。这里，我们有三个测试用例:</p><ol class=""><li id="475d" class="mf mg iq ke b kf kg kj kk kn mh kr mi kv mj kz mk ml mm mn bi translated">是否定义了<code class="fe la lb lc ld b">launchSkynet</code>？</li><li id="759e" class="mf mg iq ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><code class="fe la lb lc ld b">launchSkynet</code>是函数吗？</li><li id="569d" class="mf mg iq ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><code class="fe la lb lc ld b">launchSkynet</code>是否返回消息:<code class="fe la lb lc ld b">string</code> <code class="fe la lb lc ld b">TERMINATOR</code>？</li></ol><p id="158a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是<code class="fe la lb lc ld b">Chai</code>的用武之地。在每个<code class="fe la lb lc ld b">it()</code>函数的回调中，会产生一个断言。在这种情况下，使用了expect断言样式，除了去掉空格、用点符号连接和用括号修改之外，它看起来就像英语一样简单！</p><ul class=""><li id="5fc3" class="mf mg iq ke b kf kg kj kk kn mh kr mi kv mj kz mt ml mm mn bi translated">我期望名为<code class="fe la lb lc ld b">launchSkynet</code>的东西存在于名为<code class="fe la lb lc ld b">index</code>的文件中。</li><li id="3c70" class="mf mg iq ke b kf mo kj mp kn mq kr mr kv ms kz mt ml mm mn bi translated">我希望<code class="fe la lb lc ld b">index</code>中叫做<code class="fe la lb lc ld b">launchSkynet</code>的东西是一个函数。</li><li id="4a68" class="mf mg iq ke b kf mo kj mp kn mq kr mr kv ms kz mt ml mm mn bi translated">我期望<code class="fe la lb lc ld b">launchSkynet</code>返回的值是<code class="fe la lb lc ld b">TERMINATOR</code>。</li></ul></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="83d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">太棒了，我们已经编写了一个单元测试！现在我们可以使用终端命令<code class="fe la lb lc ld b">npm test</code>来执行测试。</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/187e77adc70daac9c7dd190ef47df391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynlOto-Yt3813Xs0it5mCg.png"/></div></div></figure><p id="a011" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是用像<code class="fe la lb lc ld b">Mocha</code>这样的框架编写单元测试的强大之处:多个指导性错误消息的整洁列表直接显示在终端输出中。谢谢你，塔吉特。当你有这样的信息时，你——<em class="lm">或另一个程序员</em>——确切地知道<code class="fe la lb lc ld b">index.js</code>文件中需要什么。让我们定义一个名为<code class="fe la lb lc ld b">launchSkynet</code>的函数，它返回<code class="fe la lb lc ld b">string</code> <code class="fe la lb lc ld b">TERMINATOR</code>。注意，由于我们正在处理一个基本的<code class="fe la lb lc ld b">Node.js</code>项目，我们需要用<code class="fe la lb lc ld b">module.exports</code>导出<code class="fe la lb lc ld b">index.js</code>模块。</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/c8047bd9e7ab4217e2c8358268377a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BcJ7nNnXKixChKRwbkWfXA.png"/></div></div></figure><p id="5d60" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们用<code class="fe la lb lc ld b">npm test</code>再次运行我们的测试，我们应该看到通过测试的摘要，而不是失败的测试和错误消息。</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/88587e59a9c28b4755b3ef97bf896a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pGufMrRJyJmDX4u_vMHMA.png"/></div></div></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="7ec6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当然，测试可能会变得更加复杂，处理异步代码等等，但是本指南旨在让您熟悉测试的概念以及在<code class="fe la lb lc ld b">JavaScript</code>中开始测试所需的基本工具集和指令。浏览一些文档并编写一些测试！请尽你的一份力量来阻止天网和审判日。</p><p id="235c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">【github.com/dangrammer<br/>T5<a class="ae le" href="https://github.com/dangrammer" rel="noopener ugc nofollow" target="_blank">linked.com/in/danieljromans</a><br/>T8】danromans.com</p></div></div>    
</body>
</html>