<html>
<head>
<title>Structuring a Large Production Flask Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建大型生产烧瓶应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/structuring-a-large-production-flask-application-7a0066a65447?source=collection_archive---------3-----------------------#2020-01-11">https://levelup.gitconnected.com/structuring-a-large-production-flask-application-7a0066a65447?source=collection_archive---------3-----------------------#2020-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7de3970311d6e6e5dcafd3376967bc20.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*0G5zu7CnXdMT9pGbYUTQLQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">烧瓶蟒</figcaption></figure><p id="2f40" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Python web框架的世界里，<a class="ae la" href="https://flask.palletsprojects.com/en/1.1.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a>和<a class="ae la" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>被认为是两个主要选项。Flask是一个微框架，通常更容易开始构建应用程序。Django是一个包含电池的框架，预装了几乎所有你需要的东西。使用过这两个工具之后，我是Flask的忠实粉丝，在过去的6年里，我们一直用它来构建我们的web应用程序。我不会在这里讨论Flask vs Django的细节，但是你可以在这里了解更多关于它们和其他Python框架的信息。</p><p id="efd5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">尽管Flask是一个很棒的框架，但是它的一个缺点是它没有提供项目结构或者设计模式。如果您想快速开始，但最终在一个较大的应用程序中成为一个问题，这是非常好的。当构建应该由当前和未来的开发人员维护的大型生产应用程序时，拥有内置结构并遵循清晰的设计模式至关重要。在这里，我将讨论我在设计Flask应用程序时学到的东西，希望可以帮助其他人。作为免责声明，我们的Flask应用程序主要是基于api的，尽管我们也提供一些途径，如通过Flask模板登录。</p><p id="5d3b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是Flask应用程序结构的概要:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b531" class="lk ll iq lg b gy lm ln l lo lp">~/YourApplication             <br/>    |-- requirements.txt                                                  <br/>    |-- config.py<br/>    |-- wsgi.py                # wsgi server<br/>    |__ .env                   # Virtual Environment<br/>    |__ /app                   # Our Application package<br/>         |-- __init__.py       # <strong class="lg ir">Application factory method</strong> <br/>         |-- errors.py         # Custom error classes <br/>         |-- db.py             # Database connection <br/>         |-- utils.py          # Utility helper functions <br/>         |-- services.py       # Business logic<br/>         |-- daos.py           # Database access object<br/>         |-- models.py         # Database models<br/>         |-- security.py       # Security access checks<br/>         |__ /routes           # <strong class="lg ir">Routes package (Blueprints)</strong><br/>             |-- __init__.py<br/>             |-- users.py           <br/>         |__ /templates<br/>         |__ /static<br/>    |__ ..<br/>    |__ .</span></pre><p id="d049" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在根目录中，我将虚拟环境目录作为一个隐藏的<code class="fe lq lr ls lg b">.env</code>文件夹。我更喜欢将虚拟env放在应用程序文件夹中，而不是放在一个公共目录中。这为所有项目保持了一个通用的<code class="fe lq lr ls lg b">.env</code>命名约定，我不需要找到虚拟env文件夹的位置。我还在我的全局git配置中放置了一个对<code class="fe lq lr ls lg b">.env</code>的全局忽略，以使其不受版本控制。</p><p id="e63b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">应用工厂</strong>:开始使用Flask最简单的方法是创建Flask类的一个实例，并在该实例上设置配置。然后，应用程序实例可用于路由和注册中间件，如官方文档所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="db5c" class="lk ll iq lg b gy lm ln l lo lp"><strong class="lg ir">from</strong> flask <strong class="lg ir">import</strong> Flask<br/>app = Flask<strong class="lg ir">(</strong>__name__<strong class="lg ir">)</strong><br/><br/>@app.route<strong class="lg ir">(</strong>'/'<strong class="lg ir">)</strong><br/><strong class="lg ir">def</strong> hello_world<strong class="lg ir">():</strong><br/>    <strong class="lg ir">return</strong> 'Hello, World!'</span></pre><p id="efd8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是这种模式在较大的Flask应用程序中很快就失效了，因为会有一些环境，比如staging、dev和testing。您需要对应用程序实例进行不同的设置和配置，这种方法很难管理。</p><p id="d5ac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">相反，更好的方法是使用应用程序工厂，它是一个返回应用程序实例的函数。有了这个函数，你就可以传入不同的参数来设置你的应用。这将应用程序的配置和设置与应用程序本身的创建分离开来。现在，在您的开发或测试环境中，您可以传入不同的配置设置。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="45c9" class="lk ll iq lg b gy lm ln l lo lp"><em class="lt">app/__init__.py</em></span><span id="be63" class="lk ll iq lg b gy lu ln l lo lp"><strong class="lg ir">def</strong> create_app<strong class="lg ir">(</strong>config_filename<strong class="lg ir">):</strong><br/>    app = Flask<strong class="lg ir">(</strong>__name__<strong class="lg ir">)</strong><br/>    app.config.from_pyfile<strong class="lg ir">(</strong>config_filename<strong class="lg ir">)</strong><br/><br/>    <strong class="lg ir">return</strong> app</span></pre><p id="d613" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在生产环境中运行时，您将使用不同的文件来导入工厂函数，并创建您的应用程序实例，然后传递给gunicorn或您选择的wsgi web服务器。应用程序工厂方法也适用于Blueprint，我们将在下面介绍它。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e521" class="lk ll iq lg b gy lm ln l lo lp"><em class="lt">wsgi.py</em></span><span id="6743" class="lk ll iq lg b gy lu ln l lo lp">from app import create_app<br/>config = "config.Production"</span><span id="0c71" class="lk ll iq lg b gy lu ln l lo lp">application = create_app(config) # call from wsgi server</span></pre><p id="bacd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">蓝图</strong> : Flask路由是通过使用应用程序实例作为route函数的装饰器来设置的。这迫使您在与应用程序实例相同的文件中声明所有路由。这在有很多路径的大flask应用程序中是不可维护的。</p><p id="236b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将路线分解成单独文件的方法是使用烧瓶<a class="ae la" href="http://flask.palletsprojects.com/en/1.1.x/blueprints/#blueprints" rel="noopener ugc nofollow" target="_blank">蓝图</a>。如果你的Flask应用是基于api的，那么你可以将文件名和资源匹配起来。因此，在routes目录中会有一个<em class="lt"> user.py </em>文件，其中包含与用户相关的所有路由，这可以扩展到其他资源。蓝图是组织路线的好方法，也是大型应用程序的必备工具。</p><p id="7442" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">服务/dao单例设计模式:我发现一个在Flask应用中非常有效的模式是服务/DAO(数据库访问对象)单例模式。这种模式的总结如下:</p><ul class=""><li id="1e8c" class="lv lw iq ke b kf kg kj kk kn lx kr ly kv lz kz ma mb mc md bi translated">业务逻辑放在服务方法中。</li><li id="1466" class="lv lw iq ke b kf me kj mf kn mg kr mh kv mi kz ma mb mc md bi translated">数据库访问(ORM)在使用模型的dao方法中。</li><li id="6f1c" class="lv lw iq ke b kf me kj mf kn mg kr mh kv mi kz ma mb mc md bi translated">路由是轻量级的，要么使用服务，要么使用dao方法。</li></ul><p id="b7d4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了演示这种模式，我将使用一个获取所有用户的示例。</p><p id="536c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">声明您的用户模型(这是基于sqlalchemy ORM的)。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ab13" class="lk ll iq lg b gy lm ln l lo lp"><em class="lt">app/models.py</em></span><span id="e938" class="lk ll iq lg b gy lu ln l lo lp">class User:<br/>    id = Column<strong class="lg ir">(</strong>Integer<strong class="lg ir">,</strong> primary_key=<strong class="lg ir">True)</strong><br/>    username = Column<strong class="lg ir">(</strong>String<strong class="lg ir">(</strong>80<strong class="lg ir">),</strong> unique=<strong class="lg ir">True,</strong> nullable=<strong class="lg ir">False)</strong><br/>    email = Column<strong class="lg ir">(</strong>String<strong class="lg ir">(</strong>120<strong class="lg ir">),</strong> unique=<strong class="lg ir">True,</strong> nullable=<strong class="lg ir">False)</strong></span></pre><p id="a611" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，使用与数据库中的用户模型交互的方法来声明UserDao类。我们为可以在整个应用程序中使用的dao实例创建一个singleton对象。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3666" class="lk ll iq lg b gy lm ln l lo lp"><em class="lt">app/daos.py</em></span><span id="0258" class="lk ll iq lg b gy lu ln l lo lp">from app.models import User<br/>from app.db import session</span><span id="ae45" class="lk ll iq lg b gy lu ln l lo lp">class UserDAO:<br/>    def __init__(self, model):<br/>        self.model = model    <br/>    <br/>    def get_all(self):<br/>        return session.query(self.model).all()</span><span id="7a40" class="lk ll iq lg b gy lu ln l lo lp">    def get_by_username(self, username -&gt; str):<br/>        return (<br/>            session.query(self.model)<br/>            .filter_by(get_by_username=username)<br/>            .first()<br/>         )</span><span id="4821" class="lk ll iq lg b gy lu ln l lo lp">    def get_by_email(self, email -&gt; str):<br/>        return (<br/>            session.query(self.model)<br/>            .filter_by(email=email)<br/>            .first()<br/>         )</span><span id="a969" class="lk ll iq lg b gy lu ln l lo lp">user_dao = UserDAO(User)</span></pre><p id="9dfc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，在您的蓝图路由中定义get all用户路由。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="86f5" class="lk ll iq lg b gy lm ln l lo lp"><em class="lt">app/routes/users.py</em></span><span id="fe09" class="lk ll iq lg b gy lu ln l lo lp">from flask import Blueprint, jsonfiy<br/>from app.daos import user_dao</span><span id="d51a" class="lk ll iq lg b gy lu ln l lo lp">user_bp = Blueprint<strong class="lg ir">(</strong>'user_bp'<strong class="lg ir">,</strong> __name__<strong class="lg ir">)</strong></span><span id="c5e3" class="lk ll iq lg b gy lu ln l lo lp">@user_bp.route("/api/users", methods=["GET])<br/>def get_users():<br/>    return jsonify(user_dao.get_all())</span></pre><p id="a403" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在任何情况下，如果您需要用户的业务逻辑，那么它将在服务中创建，如图所示。比方说，当更新用户模型时，您需要某种逻辑。像在dao模块中一样，单例对象将在整个应用程序中声明和使用</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4094" class="lk ll iq lg b gy lm ln l lo lp"><em class="lt">app/services.py</em></span><span id="8c6c" class="lk ll iq lg b gy lu ln l lo lp">from app.daos import user_dao</span><span id="c088" class="lk ll iq lg b gy lu ln l lo lp">class UserService:<br/>    def update_user(self, user_id, data -&gt; dict):<br/>        user = user_dao.get(user_id)<br/>        # Update user with data        <br/>        # check user for business logic<br/>        # example: lowercase all emails<br/>        return user</span><span id="d27f" class="lk ll iq lg b gy lu ln l lo lp">user_service = UserService()</span></pre><p id="bea7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，您可以在您的蓝图路线中使用此服务，如下所示。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d630" class="lk ll iq lg b gy lm ln l lo lp"><em class="lt">app/routes/users.py</em></span><span id="00c4" class="lk ll iq lg b gy lu ln l lo lp">from flask import Blueprint, jsonfiy, request<br/>from app.services import user_service</span><span id="b48c" class="lk ll iq lg b gy lu ln l lo lp">user_bp = Blueprint<strong class="lg ir">(</strong>'user_bp'<strong class="lg ir">,</strong> __name__<strong class="lg ir">)</strong></span><span id="7cee" class="lk ll iq lg b gy lu ln l lo lp">@user_bp.route("/api/users", methods=["GET])<br/>def get_users():<br/>    return jsonify(user_dao.get_all())</span><span id="5be9" class="lk ll iq lg b gy lu ln l lo lp"><strong class="lg ir">@user_bp.route("/api/users/&lt;int:user_id&gt;", methods=["POST"])<br/>def update_user(user_id):<br/>    </strong><strong class="lg ir">data = request.json</strong><strong class="lg ir">    <br/>    user = user_service.update_user(user_id, data)<br/>    return jsonify(user)</strong></span></pre><p id="101c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您的models.py、services.py或daos.py文件变得太大，您可以将它们转换成具有较小模块的包。如何定义较小的模块将取决于应用程序的类型和您自己的用例。</p><p id="ed17" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在过去的6年里，我们在生产应用程序中使用了这种设计模式，它为我们提供了很好的服务。我计划更详细地介绍运行生产Flask应用程序的其他方面，如配置管理、第三方api集成、后台任务、docker设置等等。如果你想得到所有的文章，一定要跟随。</p></div></div>    
</body>
</html>