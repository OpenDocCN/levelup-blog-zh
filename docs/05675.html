<html>
<head>
<title>Go: Helm, Kubernetes &amp; Docker Desktop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go: Helm，Kubernetes &amp; Docker桌面</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-helm-kubernetes-docker-desktop-bf59f4eb9e9d?source=collection_archive---------3-----------------------#2020-09-21">https://levelup.gitconnected.com/go-helm-kubernetes-docker-desktop-bf59f4eb9e9d?source=collection_archive---------3-----------------------#2020-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a7c5a25ab092ab52b6401388eecc9e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*33HDlIEUZ-mqgJtF"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">乔希·里德在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2cce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想在工作中真正理解Go代码到产品的流程。我看了看他们所有的<a class="ae kf" href="https://en.wikipedia.org/wiki/Infrastructure_as_code" rel="noopener ugc nofollow" target="_blank"> IaC </a>代码，被淹没了——涉及这么多工具，这么多配置。所以我做了代码猴子的事情，走到一个黑暗的角落，自己实现了<em class="le">最小的</em>来学习。</p><p id="f1b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一篇很长的文章，但是请坚持下去，查看一下<a class="ae kf" href="https://github.com/nwillc/webgo" rel="noopener ugc nofollow" target="_blank">相关的库</a>，您将能够创建一个程序并将其部署到您自己的机器上的Kubernetes集群中——不会太差。</p><h1 id="01b6" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">这个计划</h1><p id="214f" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">这里的总体课程计划是在一台Mac上实现:</p><ul class=""><li id="2e8e" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated">写一个简单的围棋程序</li><li id="eeb6" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">把它放进码头集装箱</li><li id="0f4c" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">使用头盔将容器放入Kubernetes</li></ul><p id="6876" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将继续介绍上述每一项的其他具体目标。</p><h1 id="3692" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">先决条件</h1><p id="5e80" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我们需要一堆工具，所有这些工具的最新版本都应该可以工作，但是我找到了:</p><ul class=""><li id="71b8" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated">Docker桌面</li><li id="d92b" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">戈朗1.15.1</li><li id="b289" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">掌舵人3.3.3</li><li id="f3cb" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">kubectl 1.19.2</li><li id="e4a6" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">kubectx 0.9.1</li></ul><h1 id="6918" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">获取先决条件</h1><p id="8f53" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">对于Docker Desktop，只需访问他们的网站并做必要的事情。我抓住了<em class="le">边缘</em>但是<em class="le">稳定</em>应该工作正常。对于所有其他人来说，有很多方法来处理安装，但我将推荐一个我喜欢的一站式购物解决方案— <a class="ae kf" href="https://asdf-vm.com/#/core-manage-asdf" rel="noopener ugc nofollow" target="_blank"> asdf </a>。是的，又一个安装工具！值了。前往他们的<a class="ae kf" href="https://asdf-vm.com/#/core-manage-asdf?id=install" rel="noopener ugc nofollow" target="_blank">安装指南</a>并做必要的工作。asdf就位后:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="c06f" class="nf lg it nb b gy ng nh l ni nj">asdf plugin-add golang <a class="ae kf" href="https://github.com/kennyp/asdf-golang.git" rel="noopener ugc nofollow" target="_blank">https://github.com/kennyp/asdf-golang.git</a><br/>asdf install golang 1.15.1</span><span id="eeca" class="nf lg it nb b gy nk nh l ni nj">asdf plugin-add helm <a class="ae kf" href="https://github.com/Antiarchitect/asdf-helm.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Antiarchitect/asdf-helm.git</a><br/>asdf install helm 3.3.3</span><span id="77f7" class="nf lg it nb b gy nk nh l ni nj">asdf plugin-add kubectl <a class="ae kf" href="https://github.com/Banno/asdf-kubectl.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Banno/asdf-kubectl.git</a><br/>asdf install kubectl 1.19.2</span><span id="63f2" class="nf lg it nb b gy nk nh l ni nj">asdf plugin add kubectx<br/>asdf <!-- -->install<!-- --> kubectx 0.9.1</span><span id="0647" class="nf lg it nb b gy nk nh l ni nj"># Go to the directory you'll be working in...<br/>asdf local golang 1.15.1<br/>asdf local helm 3.3.3<br/>asdf local kubectl 1.19.2<br/>asdf local kubectx 0.9.1</span></pre><p id="b416" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完成了。我为什么主张<em class="le"> asdf </em>？因为它允许您轻松地维护多个版本，并且对于这些工具，不同的项目将有非常具体的版本要求，我不想为整个机器强加一个单一的版本</p><h1 id="7c8f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">拿到回购</h1><p id="5a10" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我在所有这些工作中使用的repo在GitHub上(<a class="ae kf" href="https://github.com/nwillc/webgo" rel="noopener ugc nofollow" target="_blank"> nwillc/webgo </a>)。我将从头到尾引用它，并且我涉及的一些内容更加精炼，所以如果您打算在我们进行的过程中一起玩，我会抓住它。</p><h1 id="fd19" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">写一个简单的围棋程序</h1><p id="bf8b" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我想要一个可以在Kubernetes运行的非常简单的围棋程序。我想从它那里得到的只是读取一些配置值，然后继续运行，将周期性的<em class="le">滴答</em>消息记录到它的日志中。</p><p id="00f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="103d" class="nf lg it nb b gy ng nh l ni nj"># Create a directory to work in:<br/>mkdir webgo<br/>cd webgo</span><span id="7920" class="nf lg it nb b gy nk nh l ni nj"># Define the version of Go<br/>echo golang 1.15.1 &gt;&gt; .tool-versions</span><span id="c492" class="nf lg it nb b gy nk nh l ni nj"># Let asdf set up Go for us<br/>cd .</span><span id="e43c" class="nf lg it nb b gy nk nh l ni nj"># Get Go Modules kicked off:<br/>go mod init github.com/nwillc/webgo</span></pre><p id="8e48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，我们已经建立了项目文件夹，并进入其中。下面是一个简单的程序，<em class="le"> main.go: </em></p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d840" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，上面的代码访问一个环境变量，每五秒钟调用一次goroutine来记录<em class="le">消息</em>，然后在端口8888上设置一个HTTP响应器，以允许Kubernetes或您对其进行健康检查。</p><p id="36d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们构建并测试它:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="544a" class="nf lg it nb b gy ng nh l ni nj">$ go build<br/>$ CONFIG_MESSAGE=tick ./webgo<br/>2020/09/20 13:13:07 tick<br/>2020/09/20 13:13:12 tick</span></pre><h1 id="873a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">码头集装箱</h1><p id="e89e" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">现在我们需要将Go程序放入docker容器中。我的目标是构建二进制文件并放到容器中。许多基于Go的容器使用了<a class="ae kf" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank"> <em class="le">多阶段构建</em> </a>，但是我特别想使用一个外部构建的二进制文件，因为那是我自己想要的。</p><p id="fb8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，首先我们需要将Go构建为适用于容器的二进制文件:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="2963" class="nf lg it nb b gy ng nh l ni nj"><em class="le">$ rm </em>-rf bin/amd64/webgo<br/>$ GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o bin/amd64/webgo</span></pre><p id="4cef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将构建一个<em class="le"> amd64 </em>架构<em class="le"> linux </em>二进制文件，并将其输出到<code class="fe nn no np nb b">bin/amd64/webgo</code>。现在我们需要一个<code class="fe nn no np nb b">Dockerfile</code>来创建容器:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="875a" class="nf lg it nb b gy ng nh l ni nj"><em class="le">FROM </em>alpine:3.12.0<br/><em class="le">ADD </em>.<em class="le">/</em>bin<em class="le">/</em>amd64<em class="le">/</em>webgo <em class="le">/</em>go<em class="le">/</em>bin<em class="le">/</em>webgo<br/><em class="le">ENTRYPOINT /</em>go<em class="le">/</em>bin<em class="le">/</em>webgo</span></pre><p id="6603" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是全部。让我们构建它，另外<em class="le">给</em>标记一个版本号以备将来参考:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="06fd" class="nf lg it nb b gy ng nh l ni nj"><em class="le">docker </em>build -t <strong class="nb iu"><em class="le">nwillc</em></strong>/webgo:<strong class="nb iu"><em class="le">1.0.0</em></strong> -f Dockerfile .</span></pre><p id="bf71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">容器映像将被构建，命名为<em class="le"> nwillc/webgo </em>并标记为版本<em class="le"> 1.0.0 </em>。现在，让我们来测试一下:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="f362" class="nf lg it nb b gy ng nh l ni nj">$ docker run -e CONFIG_MESSAGE=ping <strong class="nb iu">nwillc</strong>/webgo:1.0.0<br/>2020/09/20 17:47:18 ping<br/>2020/09/20 17:47:23 ping<br/>^C%</span></pre><p id="0960" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好的，这样码头工人就可以运行我们的集装箱了！</p><h1 id="0707" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使容器可用</h1><p id="980c" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">虽然您可以从本地docker服务器运行容器，但Helm希望从存储库中提取容器。最简单的方法是建立一个Docker Hub账户并使用它。所以去那里创建一个免费账户吧。我在那里的用户名是<em class="le"> nwillc </em>，这就是为什么我的容器名以<code class="fe nn no np nb b">nwillc/</code>开头，但是你会想用你创建的那个替换它。</p><p id="3865" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们将容器推到docker hub:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="47f0" class="nf lg it nb b gy ng nh l ni nj">$ docker login<br/><em class="le">Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to </em><a class="ae kf" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank"><em class="le">https://hub.docker.com</em></a><em class="le"> to create one.<br/>Username: </em><strong class="nb iu"><em class="le">nwillc</em></strong><em class="le"><br/>Password:<br/>Login Succeeded</em></span><span id="fd9b" class="nf lg it nb b gy nk nh l ni nj">$ <em class="le">docker </em>push <strong class="nb iu">nwillc</strong>/webgo:1.0.0<br/><em class="le">Successfully tagged nwillc/webgo:1.0.0<br/>The push refers to repository [docker.io/nwillc/webgo]<br/>8331a716ff6a: Pushed<br/>e04313dfc306: Layer already exists<br/>50644c29ef5a: Layer already exists<br/>1.0.0: digest: sha256:6253c09bea106ce240ff64b9f9c6a076cd7a16bd33fa17de12efd60d3a2c43ef size: 950</em></span></pre><p id="7221" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，现在您的容器映像可以从docker hub repo获得了！</p><h1 id="19b8" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">舵和海图</strong></h1><p id="50f5" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Helm 是Kubernetes的产品包经理。我们将使用它将我们的容器从docker hub部署到我们的Kubernetes集群。Helm使用<em class="le">图表</em>来定义一个包及其部署。由于库伯内特斯非常丰富和复杂，所以是头盔。我不打算尝试并详尽地介绍Helm，但让我们来看一下基础知识。</p><p id="7fda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，开始创建你的舵图:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="b32a" class="nf lg it nb b gy ng nh l ni nj">$ mkdir charts<br/>$ cd charts<br/>$ helm create webgo</span></pre><p id="3e34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将创建一个名为<code class="fe nn no np nb b">webgo</code>的目录，其中有一个初始的<em class="le">图表</em>。那是我开始的地方，但是我把它们剥离了很多。让我们来看看我的变化:</p><ul class=""><li id="7c5f" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated">我删除了<code class="fe nn no np nb b">templates/tests</code>文件夹，因为我们这里不需要它。</li><li id="46e9" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">我删除了<code class="fe nn no np nb b">templates/hpa.yaml</code>,因为它不会自动缩放。</li><li id="5f3b" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">我添加了<code class="fe nn no np nb b">templates/_flattenmap.tpl</code>来提供一个实用程序，将地图中的YAML值转换成适合环境变量的字典——稍后会详细介绍。</li><li id="e6d1" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">我修改了<code class="fe nn no np nb b">Chart.yaml</code>、<code class="fe nn no np nb b">values.yaml</code>和<code class="fe nn no np nb b">templates/deployment.yaml</code>。</li></ul><p id="bb97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要查看我的所有变化，请查看<a class="ae kf" href="https://github.com/nwillc/webgo/tree/master/charts" rel="noopener ugc nofollow" target="_blank">我的回购图表</a>，以下是重点。</p><ul class=""><li id="c3c8" class="mi mj it ki b kj kk kn ko kr mk kv ml kz mm ld mn mo mp mq bi translated">在<code class="fe nn no np nb b">Chart.yaml</code>中，我为图表设置了<em class="le">版本</em>，并将<em class="le"> apiVersion </em>设置为对应于我的docker容器标记版本(<em class="le"> 1.0.0 </em>)。</li><li id="f43e" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">在<code class="fe nn no np nb b">values.yaml</code>中，我将<em class="le">存储库</em>设置为与容器的docker hub repo(<em class="le">nwillc/webgo</em>)相对应，并将I changer <em class="le">端口</em>关联到我们的应用程序端口(<em class="le"> 8888 </em>)。</li><li id="df06" class="mi mj it ki b kj mr kn ms kr mt kv mu kz mv ld mn mo mp mq bi translated">在<code class="fe nn no np nb b">templates/deployment.yaml</code>中，我再次更改了<em class="le">容器端口</em>来关联我们的端口(<em class="le"> 8888 </em>)，并添加了一点魔法:</li></ul><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="958d" class="nf lg it nb b gy ng nh l ni nj">imagePullPolicy: {{ .Values.image.pullPolicy }}<br/>env: {{ list .Values.config "CONFIG" | include "flattenmap" | nindent 12 }}<br/>ports:</span></pre><p id="81f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<em class="le">imagepulpolicy</em>和<em class="le">端口</em>之间以<em class="le"> env </em>开始的行使用我们添加的<em class="le"> flattenmap </em>实用程序。它将在我们的helm值中查找所有名为<em class="le"> config </em>的YAML地图，并将内容转换为程序可以在Kubernetes中访问的环境变量！因此，当您稍后运行helm并添加命令行参数<code class="fe nn no np nb b">--values config.yaml</code>时，一个YAML文件如下所示:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="d316" class="nf lg it nb b gy ng nh l ni nj">config:<br/>    message: "Ping!"<br/>    database:<br/>      name: "server.name.com"<br/>      port: 2056</span></pre><p id="cf77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">会向您的程序公开以下环境变量:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="0dde" class="nf lg it nb b gy ng nh l ni nj">CONFIG_MESSAGE=Ping!<br/>CONFIG_DATABASE_NAME=server.name.com<br/>CONFIG_DATABASE_PORT=2056</span></pre><p id="56dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将让我们为我们的程序提供一个基于文件的配置，而无需将文件移动到容器中！</p><h1 id="d35a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">开始你的Kubernetes</h1><p id="a03d" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">要让Kubernetes在本地运行，只需在Docker桌面<em class="le">偏好设置</em>中打开它:</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/5eeb4bd2893d3dd5d9e228987c52b7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHHB92GETd4TCZ5CWq-72A.png"/></div></div></figure><p id="0e8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让它做它该做的事。重启后，让我们看看它是否启动了:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="8616" class="nf lg it nb b gy ng nh l ni nj">$ kubectx docker-desktop<br/><em class="le">Switched to context "docker-desktop".</em><br/>$ kubectl get namespaces<br/><em class="le">NAME              STATUS   AGE<br/>default           Active   3d20h<br/>docker            Active   3d20h<br/>kube-node-lease   Active   3d20h<br/>kube-public       Active   3d20h<br/>kube-system       Active   3d20h</em><br/>$ kubectl -n kube-system get pods<br/><em class="le">NAME                                     READY   STATUS    RESTARTS   AGE<br/>coredns-5644d7b6d9-22pbx                 1/1     Running   0          3d21h<br/>coredns-5644d7b6d9-b68tx                 1/1     Running   0          3d21h<br/>etcd-docker-desktop                      1/1     Running   0          3d21h<br/>kube-apiserver-docker-desktop            1/1     Running   0          3d21h<br/>kube-controller-manager-docker-desktop   1/1     Running   0          3d21h<br/>kube-proxy-p6qdv                         1/1     Running   0          3d21h<br/>kube-scheduler-docker-desktop            1/1     Running   0          3d21h<br/>storage-provisioner                      1/1     Running   0          3d21h<br/>vpnkit-controller                        1/1     Running   0          3d21hIf you see something similar, you’ve got a cluster up and running!</em></span></pre><p id="7d0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看到类似的东西，您就有了一个正在运行的集群！</p><h1 id="b778" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">用头盔展开</h1><p id="0bad" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">因此，我们有一个程序，它在一个容器中，该容器被推送到一个存储库，Kubernetes是可用的，我们有一个掌舵图准备就绪。我们来验证一下:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="292b" class="nf lg it nb b gy ng nh l ni nj"># Got the binary?<br/>$ ls bin/amd6<br/><em class="le">webgo</em></span><span id="423b" class="nf lg it nb b gy nk nh l ni nj"># Got a container?<br/>$ docker image ls | grep webgo<br/><em class="le">nwillc/webgo     1.0.0   c6d89abedb96    6 hours ago    14.3MB</em></span><span id="697d" class="nf lg it nb b gy nk nh l ni nj"><em class="le"># Is it pushed?<br/>$ </em>curl <a class="ae kf" href="https://hub.docker.com/v2/repositories/nwillc/webgo/tags" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/v2/repositories/nwillc/webgo/tags</a><br/><em class="le">{"count":1,"next":null,"previous":null,"results":[{"creator":359475,"id":118144715,"image_id":null,"images":[{"architecture":"amd64","features":"","variant":null,"digest":"sha256:6253c09bea106ce240ff64b9f9c6a076cd7a16bd33fa17de12efd60d3a2c43ef","os":"linux","os_features":"","os_version":null,"size":8256287}],"last_updated":"2020-09-20T19:07:51.630637Z","last_updater":359475,"last_updater_username":"nwillc","name":"1.0.0","repository":9856000,"full_size":8256287,"v2":true}]}</em></span><span id="963a" class="nf lg it nb b gy nk nh l ni nj"># Kubernetes is running? We checked that above...</span><span id="7e30" class="nf lg it nb b gy nk nh l ni nj"># Got our charts?<br/> $ ls -1R charts<br/><em class="le">webgo</em></span><span id="23b2" class="nf lg it nb b gy nk nh l ni nj"><em class="le">charts/webgo:<br/>Chart.yaml<br/>templates<br/>values.yaml</em></span><span id="8104" class="nf lg it nb b gy nk nh l ni nj"><em class="le">charts/webgo/templates:<br/>NOTES.txt<br/>_helpers.tpl<br/>deployment.yaml<br/>flattenmap.yaml<br/>ingress.yaml<br/>service.yaml<br/>serviceaccount.yaml</em></span></pre><p id="40e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们配置最后一位。还记得掌舵图表中的<em class="le">配置_消息</em>变量和<em class="le">环境</em>子句吗？让我们来设置一下:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="c380" class="nf lg it nb b gy ng nh l ni nj">$ cat &lt;&lt;! &gt; config.yaml<br/>config:<br/>  message: "BEEP"<br/>!</span></pre><p id="96b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好的，我们准备好了。但是让我们先检查一下:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="9e0b" class="nf lg it nb b gy ng nh l ni nj"><em class="le">$ </em>helm<em class="le"> </em>upgrade --install --values config.yaml webgo --dry-run --debug ./charts/webgo</span></pre><p id="6dd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将把所有东西缝合在一起，并向您显示输出。假设我们都很好:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="3784" class="nf lg it nb b gy ng nh l ni nj"><em class="le">$ </em>helm<em class="le"> </em>upgrade --install --values config.yaml webgo ./charts/webgo<br/><em class="le">Release "webgo" does not exist. Installing it now.<br/>NAME: webgo<br/>LAST DEPLOYED: Sun Sep 20 22:54:24 2020<br/>NAMESPACE: default<br/>STATUS: deployed<br/>REVISION: 1<br/>TEST SUITE: None<br/>NOTES:<br/>1. Get the application URL by running these commands:<br/>  export POD_NAME=$(kubectl get pods --namespace default -l "app.kubernetes.io/name=webgo,app.kubernetes.io/instance=webgo" -o jsonpath="{.items[0].metadata.name}")<br/>  echo "Visit </em><a class="ae kf" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank"><em class="le">http://127.0.0.1:8080</em></a><em class="le"> to use your application"<br/>  kubectl --namespace default port-forward $POD_NAME 8080:80</em></span></pre><p id="09b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">成功了吗？</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="9bf4" class="nf lg it nb b gy ng nh l ni nj">$ helm ls<br/><em class="le">NAME  NAMESPACE REVISION UPDATED                              STATUS   CHART       APP VERSION<br/>webgo default   1        2020-09-20 22:54:24.523039 -0400 EDT deployed webgo-1.0.0 1.0.0</em></span></pre><p id="2832" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">赫尔姆是这样认为的。库伯内特公司有吗？</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="ea0b" class="nf lg it nb b gy ng nh l ni nj">$ kubectl get pods<br/><em class="le">NAME                     READY   STATUS    RESTARTS   AGE<br/>webgo-67b895b98b-jd2tw   1/1     Running   0          3m45s</em></span></pre><p id="fd5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">检查日志…</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="e243" class="nf lg it nb b gy ng nh l ni nj">$ kubectl logs webgo-67b895b98b-jd2tw<br/>2020/09/21 02:54:30 BEEP<br/>2020/09/21 02:54:35 BEEP<br/>2020/09/21 02:54:40 BEEP<br/>2020/09/21 02:54:45 BEEP</span></pre><p id="ec21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们能从外面进入程序吗？</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="03f6" class="nf lg it nb b gy ng nh l ni nj">$ kubectl get services webgo<br/><em class="le">NAME  TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE<br/>webgo NodePort   10.106.214.152   &lt;none&gt;        8888:30090/TCP   21m</em><br/>$ curl <a class="ae kf" href="http://localhost:30090" rel="noopener ugc nofollow" target="_blank">http://localhost:30090</a><br/><em class="le">ACK</em></span></pre><p id="9160" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">成功了。首尾相连。搞定了。看一下repo的README.md，查看任何更新和执行我手动描述的步骤的脚本。</p><h1 id="7f6e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">奖励积分:k9s</h1><p id="7f6f" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">想要一种简单的方法来查看您的Kubernetes集群吗？轻松观看您的程序日志！Get <em class="le"> k9s </em>！</p><figure class="mw mx my mz gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/146c3d134c2a60f72480fbc06939a2ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7sPska7zyjsVrSrcp97fg.png"/></div></div></figure><p id="d4aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可以让你忘记<em class="le"> kubectl </em>的神秘命令。为此安装<em class="le"> asdf </em>:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="10fc" class="nf lg it nb b gy ng nh l ni nj">$ asdf plugin-add k9s <a class="ae kf" href="https://github.com/looztra/asdf-k9s" rel="noopener ugc nofollow" target="_blank">https://github.com/looztra/asdf-k9s</a><br/>$ asdf install k9s 0.21.1<br/>$ asdf global k9s 0.21.1</span></pre></div></div>    
</body>
</html>