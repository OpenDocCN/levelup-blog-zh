<html>
<head>
<title>Threading and Multiprocessing Modules in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的线程和多处理模块</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/threading-and-multiprocessing-modules-in-python-14363c13fe9d?source=collection_archive---------6-----------------------#2020-04-02">https://levelup.gitconnected.com/threading-and-multiprocessing-modules-in-python-14363c13fe9d?source=collection_archive---------6-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq jr js"><p id="70e1" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">本文提供了python中的<a class="ae ks" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank">线程</a>和<a class="ae ks" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">多重处理</a>模块背后的基本思想。</p></blockquote><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/72b2da25cb5a97e703e0ebdcc49ddbff.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*GseYSJU4oWjmP-2EsRVddw.png"/></div></figure><p id="9247" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">线程背后的基本思想是在程序中执行一系列这样的指令，这些指令可以独立于其他代码执行。</p><p id="6cd9" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">那么线程化和多处理有什么区别呢？当我们想要同时运行不同的任务时，我们通常使用线程，当我们想要执行基于进程的并行时，则使用多处理。</p><h2 id="502e" class="le lf it bd lg lh li dn lj lk ll dp lm lb ln lo lp lc lq lr ls ld lt lu lv lw bi translated">受计算和I/O限制的任务</h2><p id="9914" class="pw-post-body-paragraph jt ju it jw b jx lx jz ka kb ly kd ke lb lz kh ki lc ma kl km ld mb kp kq kr im bi translated">在计算范围内，计算的进展速度完全取决于CPU的性能，而在I/O范围内，进程的进展速度受到输入和输出系统速度的限制。</p><p id="c8a4" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">在受计算约束的任务中，程序大部分时间只是使用CPU，即进行计算。一个沉迷于处理数字的程序更有可能是一个计算密集型的任务。</p><p id="339a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">与所需的计算量相比，处理大量磁盘数据的任务(例如，计算文件中的行数)很可能会受到I/O的限制。</p><h2 id="9dd3" class="le lf it bd lg lh li dn lj lk ll dp lm lb ln lo lp lc lq lr ls ld lt lu lv lw bi translated">Python的GIL问题</h2><p id="201b" class="pw-post-body-paragraph jt ju it jw b jx lx jz ka kb ly kd ke lb lz kh ki lc ma kl km ld mb kp kq kr im bi translated">一般来说，Python只使用一个线程来执行写好的语句集。这意味着在python中一次只能执行一个线程。python中单线程进程和多线程进程的性能是一样的，这是因为python中的<a class="ae ks" href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener ugc nofollow" target="_blank"> GIL </a>(全局解释器锁)。我们不能在python中实现多线程，因为我们有一个全局解释器锁，它限制线程并作为一个单独的线程工作。</p><p id="3260" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated"><strong class="jw iu">进程</strong>加速CPU密集型的Python操作，因为它们受益于多核并避免了GIL，而<strong class="jw iu">线程</strong>最适合IO任务或涉及外部系统的任务，因为线程可以更有效地组合它们的工作。流程需要处理它们的结果来组合它们，这需要时间。</p><p id="e2d9" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated"><strong class="jw iu">由于GIL，线程</strong>在python中对CPU密集型任务没有提供任何好处。</p><h2 id="f16d" class="le lf it bd lg lh li dn lj lk ll dp lm lb ln lo lp lc lq lr ls ld lt lu lv lw bi translated">为什么是GIL？</h2><p id="a0ef" class="pw-post-body-paragraph jt ju it jw b jx lx jz ka kb ly kd ke lb lz kh ki lc ma kl km ld mb kp kq kr im bi translated">线程模块使用线程，多处理模块使用进程。区别在于线程运行在同一个内存空间，而进程有各自独立的内存。这使得在具有多重处理的进程之间共享对象有点困难，因此通常通过酸洗对象来实现。由于线程使用相同的内存，因此必须采取预防措施，否则两个线程将同时写入相同的内存。这就是全局解释器锁的用途。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="fab8" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">如果我们运行一个python脚本，它只是执行一个简单的睡眠任务(这肯定会很耗时，哈哈哈！)那么脚本应该是这样的。</p><pre class="ku kv kw kx gt mj mk ml mm aw mn bi"><span id="3ae6" class="le lf it mk b gy mo mp l mq mr">import time</span><span id="2c3b" class="le lf it mk b gy ms mp l mq mr">start = time.perf_counter()</span><span id="3061" class="le lf it mk b gy ms mp l mq mr">def please_sleep(n):<br/>    print("Sleeping for {} seconds".format(n))<br/>    time.sleep(n)<br/>    print("Done Sleeping")</span><span id="22a7" class="le lf it mk b gy ms mp l mq mr">for i in range(1,5):<br/>   please_sleep(i)</span><span id="2cb1" class="le lf it mk b gy ms mp l mq mr">finish = time.perf_counter()</span><span id="dd46" class="le lf it mk b gy ms mp l mq mr">print("Finished in {} seconds".format(finish-start))</span></pre><p id="dbb7" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">我们得到了我们都期望的结果</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/9d850efe5b0b59caff1fa142801411ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*K6AL21xxdfHUlAs8MUybVg.png"/></div></figure><p id="a7ea" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">该脚本的工作流程如下所示:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/de779e36fecf320d28e190a6e933539f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_lsrPgIbF_Hbq-VDX-K-A.jpeg"/></div></div></figure><p id="6de2" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated"><em class="jv">让我们从线程模块</em>开始</p><h1 id="c8d0" class="mz lf it bd lg na nb nc lj nd ne nf lm ng nh ni lp nj nk nl ls nm nn no lv np bi translated">线程模块</h1><p id="0bbc" class="pw-post-body-paragraph jt ju it jw b jx lx jz ka kb ly kd ke lb lz kh ki lc ma kl km ld mb kp kq kr im bi translated">线程的工作流程可以描述如下:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nq"><img src="../Images/39853f862bd258c45c72c77d2dbd4334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A9_360zBbE6RgVpaYYFWpA.jpeg"/></div></div></figure><p id="2940" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">我们首先需要导入线程模块(显然！)</p><p id="58d2" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">为了使用线程复制上面提到的脚本，我们需要创建多个线程，这可以通过多次执行简单的<strong class="jw iu">线程</strong>方法来完成。其语法如下所示</p><pre class="ku kv kw kx gt mj mk ml mm aw mn bi"><span id="0110" class="le lf it mk b gy mo mp l mq mr">thread1 = threading.Thread(target = method_name, args = [list of arguments])</span></pre><p id="d129" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">一旦我们创建了线程，我们需要使用<strong class="jw iu"> start </strong>方法来启动它们</p><pre class="ku kv kw kx gt mj mk ml mm aw mn bi"><span id="e940" class="le lf it mk b gy mo mp l mq mr">thread1.start()</span></pre><p id="f62f" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">让我们举一个简单的例子，先创建2个线程，然后我们将尝试复制上面的脚本</p><pre class="ku kv kw kx gt mj mk ml mm aw mn bi"><span id="a0bd" class="le lf it mk b gy mo mp l mq mr">import time<br/>import threading</span><span id="11ff" class="le lf it mk b gy ms mp l mq mr">start = time.perf_counter()</span><span id="e250" class="le lf it mk b gy ms mp l mq mr">def please_sleep(n):<br/>    print("Sleeping for {} seconds".format(n))<br/>    time.sleep(n)<br/>    print("Done Sleeping")</span><span id="352e" class="le lf it mk b gy ms mp l mq mr">t1 = threading.Thread(target = please_sleep, args = [1])<br/>t2 = threading.Thread(target = please_sleep, args = [2])</span><span id="3336" class="le lf it mk b gy ms mp l mq mr">t1.start()<br/>t2.start()</span><span id="b08b" class="le lf it mk b gy ms mp l mq mr">finish = time.perf_counter()</span><span id="cfbc" class="le lf it mk b gy ms mp l mq mr">print("Finished in {} seconds".format(finish-start))</span></pre><p id="818d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">根据工作流，我们现在应该认为这段代码应该执行大约2秒钟。现在让我们看看输出。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/60e776e76a4dff00dce71412f013d809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*5xsy7YW9-utL4Bb2CmKUoA.png"/></div></figure><p id="74f6" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">哎呀，这是意料之外的，对吧？发生这种行为是因为在两个线程都启动后，当线程都在休眠时，我们的脚本同时运行，并继续执行脚本的其余部分。从而立即计算出结束时间。</p><p id="c931" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">为了防止这种情况，我们应该使用<strong class="jw iu"> join </strong>方法。当调用<strong class="jw iu"> join </strong>方法时，调用线程(在我们的例子中是主线程)被阻塞，直到调用它的线程对象(please_sleep方法)被终止。我们可以以类似于<strong class="jw iu"> start </strong>方法的方式调用它</p><pre class="ku kv kw kx gt mj mk ml mm aw mn bi"><span id="9178" class="le lf it mk b gy mo mp l mq mr">thread1.join()</span></pre><p id="7a17" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">现在让我们用我们学过的概念复制主脚本。</p><pre class="ku kv kw kx gt mj mk ml mm aw mn bi"><span id="1cce" class="le lf it mk b gy mo mp l mq mr">import time<br/>import threading</span><span id="19b8" class="le lf it mk b gy ms mp l mq mr">start = time.perf_counter()</span><span id="615d" class="le lf it mk b gy ms mp l mq mr">def please_sleep(n):<br/>    print("Sleeping for {} seconds".format(n))<br/>    time.sleep(n)<br/>    print("Done Sleeping for {} seconds".format(n))</span><span id="a281" class="le lf it mk b gy ms mp l mq mr">threads = []</span><span id="77ff" class="le lf it mk b gy ms mp l mq mr">for i in range(1,5):<br/>    t = threading.Thread(target = please_sleep, args = [i])<br/>    t.start()<br/>    threads.append(t)</span><span id="8429" class="le lf it mk b gy ms mp l mq mr">for t in threads:<br/>    t.join()</span><span id="d0d9" class="le lf it mk b gy ms mp l mq mr">finish = time.perf_counter()</span><span id="f314" class="le lf it mk b gy ms mp l mq mr">print("Finished in {} seconds".format(finish-start))</span></pre><p id="f5a9" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">这将打印出预期的结果。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/e6d49b3c1606ffd929a1aaee5f48dd0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*_wnzHat7pyooDEURuzI1Nw.png"/></div></figure><p id="34c0" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">因此，我们在将近4秒内成功地执行了这4项任务，而这些任务原本需要将近10秒。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="5a3d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated"><em class="jv">使用多处理模块可以完成这项任务吗？是的，让我们看一看。</em></p><h1 id="aba1" class="mz lf it bd lg na nb nc lj nd ne nf lm ng nh ni lp nj nk nl ls nm nn no lv np bi translated">多重处理模块</h1><p id="2aa3" class="pw-post-body-paragraph jt ju it jw b jx lx jz ka kb ly kd ke lb lz kh ki lc ma kl km ld mb kp kq kr im bi translated">我的机器上有4个内核，所以我将参照我的机器进行说明。这是多重处理的工作流程。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nt"><img src="../Images/28885d680770d7d7b234be2a4e2fe70f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BvEzyrdrL_2-ux_2wJT_Fg.jpeg"/></div></div></figure><p id="d8e1" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">开始一个过程的过程😛类似于螺纹。这里我们首先导入多处理模块，然后调用<strong class="jw iu"> Process </strong>方法，后面跟着一个start方法。</p><pre class="ku kv kw kx gt mj mk ml mm aw mn bi"><span id="7b55" class="le lf it mk b gy mo mp l mq mr">process1 = multiprocessing.Process(target = method_name, args = [list of arguments])<br/>process1.start()</span></pre><p id="4712" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">与进程相比，线程更加轻量级，开销也更低。因此，生成进程比生成线程要慢一些。让我们借助一个例子来看看。</p><pre class="ku kv kw kx gt mj mk ml mm aw mn bi"><span id="0e1e" class="le lf it mk b gy mo mp l mq mr">import time<br/>import multiprocessing</span><span id="9b0b" class="le lf it mk b gy ms mp l mq mr">start = time.perf_counter()</span><span id="982a" class="le lf it mk b gy ms mp l mq mr">def please_sleep(n):<br/>    print("Sleeping for {} seconds".format(n))<br/>    time.sleep(n)<br/>    print("Done Sleeping for {} seconds".format(n))</span><span id="18d1" class="le lf it mk b gy ms mp l mq mr">p1 = multiprocessing.Process(target = please_sleep, args = [1])<br/>p2 = multiprocessing.Process(target = please_sleep, args = [2])</span><span id="2eb8" class="le lf it mk b gy ms mp l mq mr">p1.start()<br/>p2.start()</span><span id="f666" class="le lf it mk b gy ms mp l mq mr">finish = time.perf_counter()</span><span id="0f05" class="le lf it mk b gy ms mp l mq mr">print("Finished in {} seconds".format(finish-start))</span></pre><p id="70e9" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">下面描述的输出显示，在整个脚本运行之后，进程已经启动。这证明了我们的上述声明。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/44b36262eb72828ab6e5a1c434326fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*HDTSP3isRjh6cfoAoNSWDQ.png"/></div></figure><p id="4583" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">此处的<strong class="jw iu"> join </strong>方法还防止在调用后执行进一步的脚本，直到流程完成。它可以作为</p><pre class="ku kv kw kx gt mj mk ml mm aw mn bi"><span id="8888" class="le lf it mk b gy mo mp l mq mr">process1.join()</span></pre><p id="f149" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">现在让我们创建一个脚本，它使用多线程来并行化该方法。</p><pre class="ku kv kw kx gt mj mk ml mm aw mn bi"><span id="2b26" class="le lf it mk b gy mo mp l mq mr">import time<br/>import multiprocessing</span><span id="118d" class="le lf it mk b gy ms mp l mq mr">start = time.perf_counter()</span><span id="c5c0" class="le lf it mk b gy ms mp l mq mr">def please_sleep(n):<br/>    print("Sleeping for {} seconds".format(n))<br/>    time.sleep(n)<br/>    print("Done Sleeping for {} seconds".format(n))</span><span id="8a87" class="le lf it mk b gy ms mp l mq mr">processes = []</span><span id="2295" class="le lf it mk b gy ms mp l mq mr">for i in range(1,6):<br/>    p = multiprocessing.Process(target = please_sleep, args = [i])<br/>    p.start()<br/>    processes.append(p)</span><span id="de90" class="le lf it mk b gy ms mp l mq mr">for p in processes:<br/>    p.join()</span><span id="bde6" class="le lf it mk b gy ms mp l mq mr">finish = time.perf_counter()</span><span id="612b" class="le lf it mk b gy ms mp l mq mr">print("Finished in {} seconds".format(finish-start))</span></pre><p id="eb52" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">输出将根据工作流程。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/5402235e6b369ca700a67efd05d8e2a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*LN2tu2rA-09PnGTnGi5Rvw.png"/></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="6777" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">使用并行总是伴随着效率的损失，也就是说，它利用了更多的资源，因此并行执行的计算的总时间通常比串行更快。在<a class="ae ks" href="https://en.wikipedia.org/wiki/Amdahl%27s_law" rel="noopener ugc nofollow" target="_blank">阿姆达尔定律</a>的帮助下，我们可以说，多处理器并行计算只对高度可并行化的程序有用。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nw"><img src="../Images/3a0ac841fad467f4d6c456401887f12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QNQ-MhaetUMnn8hm8Ff9eA.png"/></div></div><figcaption class="nx ny gj gh gi nz oa bd b be z dk translated">这张图片取自<a class="ae ks" href="https://en.wikipedia.org/wiki/Amdahl%27s_law#/media/File:AmdahlsLaw.svg" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="ff69" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">我很欣赏你的耐心，谢谢你坚持到现在。</p><p id="476a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">欢迎建议！</p><p id="a835" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke lb kg kh ki lc kk kl km ld ko kp kq kr im bi translated">谢谢😺</p></div></div>    
</body>
</html>