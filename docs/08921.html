<html>
<head>
<title>Simplifying Connected Props with Redux and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Redux和TypeScript简化连接的道具</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simplifying-connected-props-with-redux-and-typescript-62163cc5a25c?source=collection_archive---------5-----------------------#2021-06-18">https://levelup.gitconnected.com/simplifying-connected-props-with-redux-and-typescript-62163cc5a25c?source=collection_archive---------5-----------------------#2021-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/5cb84e85b6f9231b5988f739fb67b3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*SNAWNjjqYpC18ylr.jpeg"/></div></figure><p id="5c26" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当使用Redux连接的组件时，可以有多达三个道具源:</p><ul class=""><li id="e248" class="kv kw it jz b ka kb ke kf ki kx km ky kq kz ku la lb lc ld bi translated">从父组件传递的道具，</li><li id="e8e6" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">从<code class="fe lj lk ll lm b">mapStateToProps</code>返回的道具，</li><li id="4966" class="kv kw it jz b ka le ke lf ki lg km lh kq li ku la lb lc ld bi translated">从<code class="fe lj lk ll lm b">mapDispatchToProps</code>返回的道具。</li></ul><p id="f4ab" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当与TypeScript一起使用时，所有这些属性都需要有类型。如果它是有状态的基于类的组件，状态也需要被类型化。这是大量的手动类型声明，将来也需要维护。幸运的是，从<code class="fe lj lk ll lm b">@types/react-redux</code>包的7.1.2版本开始，在大多数情况下可以自动推断连接道具的类型。在<a class="ae ln" href="https://react-redux.js.org/using-react-redux/usage-with-tsx#inferring-the-connected-props-automatically" rel="noopener ugc nofollow" target="_blank"> React Redux文档</a>中记录了这样做的方法，在这篇文章中，我们将看到一个具体例子的应用。</p><p id="ac3e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将重构一个示例<code class="fe lj lk ll lm b">App</code>组件，为了简洁起见，简化了它的实现(但不是类型)细节。组件本身在挂载时(通过Redux动作)获取一个项目列表，然后呈现从props接收的列表。此外，该组件使用React router，从那里接收URL参数作为道具。</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="53a6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意，我们使用<code class="fe lj lk ll lm b">typeof</code>来推断动作的类型，而<code class="fe lj lk ll lm b">mapStateToProps</code>中的类型基本上是<code class="fe lj lk ll lm b">AppState</code>和<code class="fe lj lk ll lm b">OwnProps</code>类型的组合。看起来我们正在为其他地方已经可用的类型做大量的手动类型声明，那么为什么不使用类型信息并自动推断组件属性呢？</p><p id="72ec" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这里的另一个问题是被调度的动作返回一个<code class="fe lj lk ll lm b">ThunkAction</code>类型的函数，该函数又返回<code class="fe lj lk ll lm b">void</code>(即nothing)。当将组件连接到Redux并以严格模式运行TypeScript时，我们会得到以下错误:</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="810f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后一部分，<code class="fe lj lk ll lm b">Type 'void' is not assignable to type 'ThunkAction&lt;void, AppState, undefined, { payload: any; type: string; }&gt;'.</code>这里最重要。即使<code class="fe lj lk ll lm b">loadData</code>的类型是<code class="fe lj lk ll lm b">() =&gt; ThunkAction =&gt; void</code>，由于React-Redux解析thunks的方式，实际推断的类型将是<code class="fe lj lk ll lm b">() =&gt; void.</code></p><p id="864e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是<code class="fe lj lk ll lm b">ConnectedProps</code>助手类型变得有用的地方。它允许从<code class="fe lj lk ll lm b">mapStateToProps</code>和<code class="fe lj lk ll lm b">mapDispatchToProps</code>推断连接的类型，并且它将正确地解析thunks的类型。首先，让我们把<code class="fe lj lk ll lm b">mapStateToProps</code>和<code class="fe lj lk ll lm b">mapDispatchToProps</code>移到文件的顶部，并把它们从所有的泛型类型声明中去掉，因为它们不再是必需的。</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="7a84" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来我们需要通过组合Redux中的道具来创建一个<code class="fe lj lk ll lm b">connector</code>函数。我们在声明组件之前这样做，因为我们将在创建<code class="fe lj lk ll lm b">Props</code>类型时使用这个函数。</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="aee3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在是时候使用<code class="fe lj lk ll lm b">ConnectedProps</code> helper提取连接道具的类型了。在此之前，我们还需要移除我们的<code class="fe lj lk ll lm b">ConnectedProps</code>和<code class="fe lj lk ll lm b">DispatchProps</code>接口。</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="131e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，我们将这些道具与自己的道具结合起来，为组件创建<code class="fe lj lk ll lm b">Props</code>类型。</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="f93c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最终的结果会是这样的。</p><figure class="lo lp lq lr gt ju"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="7f80" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们已经通过去除从Redux接收的道具的手动声明简化了我们的组件。它们现在是从我们在状态和动作中为它们设置的类型中自动推断出来的。这大大提高了应用程序的可维护性，也修复了错误推断Redux thunk操作返回类型的问题。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="ab29" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="mb">原载于</em><a class="ae ln" href="https://claritydev.net/blog/simplifying-connected-props-with-redux-and-typescr/" rel="noopener ugc nofollow" target="_blank"><em class="mb">https://claritydev.net</em></a><em class="mb">。</em></p></div></div>    
</body>
</html>