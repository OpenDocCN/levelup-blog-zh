<html>
<head>
<title>System Design Fundamentals: Data Replication and Partitioning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">系统设计基础:数据复制和分区</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/system-design-fundamentals-data-replication-and-partitioning-ab109a46b633?source=collection_archive---------3-----------------------#2022-04-26">https://levelup.gitconnected.com/system-design-fundamentals-data-replication-and-partitioning-ab109a46b633?source=collection_archive---------3-----------------------#2022-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a10afcb2011f9ec537df0d15faf64e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HqBR-UhPL2BW85DB"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">粘土银行</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><div class=""/><p id="59ec" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章是我的系统设计系列的一部分。您可以在此找到其他主题:</p><ol class=""><li id="0d79" class="le lf jj ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/system-design-basics-distributed-systems-9aac8a11177c">分布式系统</a></li><li id="5bf3" class="le lf jj ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/system-design-fundamentals-load-balancers-e608d30afa65">负载平衡器</a></li></ol><p id="bd3d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">系统的性能通常取决于其数据库的性能。如果一个系统的数据库停机，整个系统很可能不可用。类似地，如果系统的数据库具有高延迟，那么系统本身也将具有高延迟。</p><p id="03d6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了提高数据库的可用性和可靠性，我们可以使用<strong class="ki jk"> <em class="ls">数据复制</em> </strong>和<strong class="ki jk"> <em class="ls">数据分区</em> </strong>。</p><h1 id="6431" class="lt lu jj bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">什么是数据复制？</h1><p id="2bb6" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">假设您有一个只有一个主数据库的系统，而这个数据库已经关闭了。如果发生这种情况，您将无法再向数据库中读取或写入数据。所有的数据都会丢失。</p><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mw"><img src="../Images/8fa1ec0804ddc91c6a44ed2f9e47d03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*B4DlzGuL-xTgRQ51zvHRlA.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图1:只有一个数据库关闭的系统。</figcaption></figure><p id="b56c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">复制使我们能够解决这个问题，方法是让数据库的备份副本处于备用状态，以备出现此类问题时使用。</p><p id="c1b0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主数据库处理来自应用服务器的读写请求，并将写入备份数据库以保持最新。如果主数据库关闭，应用服务器将切换到备份数据库，以保持系统可用。然后，备份将成为主数据库，当另一个数据库再次运行时，它会将其所有数据复制到主数据库。</p><figure class="mx my mz na gt iv gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/b67e2513acd367423e0edceec67ed3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*HMyLhzUI2nX3tzgQUN6H6w.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图2:具有用于更好可用性的复制数据库的系统</figcaption></figure><p id="0af1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个术语是冗余。<a class="ae jg" href="https://en.wikipedia.org/wiki/Redundancy_(engineering)" rel="noopener ugc nofollow" target="_blank">冗余</a>是系统关键组件或功能的复制，目的是增加系统的可靠性，通常以备份或故障安全的形式，或提高实际系统性能。</p><h2 id="d14b" class="nc lu jj bd lv nd ne dn lz nf ng dp md kr nh ni mh kv nj nk ml kz nl nm mp nn bi translated">副本数据库如何保持最新？</h2><p id="677b" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">主数据库被写入，然后被传递到副本数据库。每个副本都会输出一条消息，声明它已成功接收到更新。</p><p id="af15" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您希望数据库在主数据库出现故障时接管主数据库，那么数据库之间的数据必须始终完全同步。当写入主数据库时，它应该同步更新备份数据库，并且只有当所有副本都返回成功响应时才完成写入请求。</p><p id="8978" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果让所有数据库中的所有数据完全同步并不重要，您可以使用异步写入。</p><p id="0b2f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这方面的一个例子是用户在Instagram上发布照片。Instagram可能有不同地区的数据库。如果加利福尼亚州的用户发布了一张照片，它将首先被写入地区数据库，但是等待它写入所有其他地区数据库可能会增加太多的延迟。此外，想要访问该帖子的其他用户很可能位于同一地区。一种解决方案是异步更新其他区域。通过这种方式，加利福尼亚的其他用户可以立即访问该帖子，而一旦该帖子复制到其他地区，韩国的其他用户也可以访问该帖子。</p><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/e1ce30ca027e365a3d6ffc6b639429ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dB51oJnihOLDrL7lOiVd3w.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图3:为了最终的一致性而异步更新数据库</figcaption></figure><p id="ae88" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种类型的异步更新称为<a class="ae jg" href="https://www.scylladb.com/glossary/eventual-consistency/#:~:text=Eventual%20Consistency%20is%20a%20guarantee,time%20the%20data%20is%20queried." rel="noopener ugc nofollow" target="_blank">最终一致性</a>。</p><h1 id="fcb8" class="lt lu jj bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">什么是数据分区？</h1><p id="5936" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">数据分区是一种将大型数据库分割成许多较小部分的方法。当您有一个读写请求过载的数据库，并且您想要通过<a class="ae jg" href="https://medium.com/gitconnected/system-design-basics-distributed-systems-9aac8a11177c" rel="noopener">扩展</a>来提高吞吐量时，这是非常有用的。</p><p id="e5bb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据被分割到多个数据库中，以提高应用程序的可管理性、性能、可用性和负载平衡。</p><h2 id="bb94" class="nc lu jj bd lv nd ne dn lz nf ng dp md kr nh ni mh kv nj nk ml kz nl nm mp nn bi translated">水平分割</h2><p id="6a2c" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">水平分区，也称为<strong class="ki jk"> <em class="ls">数据分片</em> </strong>，将一个数据库按行分割成单独的数据库。</p><figure class="mx my mz na gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/1c2196868e49fc9bed1fc3dc5dcbde39.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*JCB0MpSLBUz8WCMoxpTZQw.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图4:表A被水平分成两个表。表A包含项目1–5000，表B包含项目5001–10000</figcaption></figure><p id="9273" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在图4中，假设我们有一个只有一个表的数据库，表A，它有10000行。我们可以通过在两个表(也称为碎片)之间分割数据来水平分割这个表。一个表包含前1–5000个项目，第二个表包含5001–10000个项目。</p><p id="7b4c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">水平分区的一个问题是，如果没有仔细选择分区策略，您可能会得到不平衡的数据库(例如，一个数据库保存的数据比其他数据库多得多)。一个例子是，如果我们想根据用户名将一个数据库划分成多个碎片，如下图5所示。</p><figure class="mx my mz na gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/149310425c3f9bc8ced41908d5f33141.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*WuViH_3wdwkqxBcTfUiOBA.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图5:按用户名划分的用户数据库</figcaption></figure><p id="11c5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果用户名以这些字母开头的用户较少，那么最终存储用户名U-Z的数据库可能会比其他碎片少很多。</p><p id="d696" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用哪些分区策略？</p><ol class=""><li id="e6a2" class="le lf jj ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated"><strong class="ki jk">基于键或散列的分区</strong>:我们可以使用散列函数来决定哪块数据去哪个碎片。通过使用<a class="ae jg" href="https://en.wikipedia.org/wiki/Consistent_hashing" rel="noopener ugc nofollow" target="_blank">一致散列</a>，我们可以确保数据均匀分布，并且能够根据需要轻松添加额外的碎片。</li><li id="95b5" class="le lf jj ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki jk">列表分区</strong>:每个分区被分配一个值列表。当我们想要插入一个新记录时，我们根据它属于哪个列表来确定哪个分区。图5中的例子使用了列表分区。</li><li id="296b" class="le lf jj ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><strong class="ki jk">混合散列和列表分区</strong>:您可以同时应用这两种策略来对数据库进行分区。《出埃及记》散列数据，然后使用散列范围作为列表分区。</li></ol><h2 id="2ab0" class="nc lu jj bd lv nd ne dn lz nf ng dp md kr nh ni mh kv nj nk ml kz nl nm mp nn bi translated">垂直分割</h2><p id="2be5" class="pw-post-body-paragraph kg kh jj ki b kj mr kl km kn ms kp kq kr mt kt ku kv mu kx ky kz mv lb lc ld im bi translated">使用这种方法，数据是按列而不是按行拆分的。例如，如果我们有一个在用户表中存储用户信息的数据库，如图6所示:</p><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/305352bf20ac79a8d42aa72ebb979674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zskwyspYFlYZI6gY4Ms81w.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图6:一个用户表</figcaption></figure><p id="9f55" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过建立一个单独的数据库来保存个人资料照片，另一个用于保存朋友列表，从而对这个表进行分区。</p><figure class="mx my mz na gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nr"><img src="../Images/c776ec46cde19ea5942e7fc000149062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMzJcHCZyIyyShfO2hv21Q.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图7:用户数据已经被划分到不同的表中</figcaption></figure><p id="2cf3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用垂直分区，如果一个分区变得太大，您还可以对该分区应用水平分区来进一步扩展。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="cdc9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望您喜欢阅读这篇文章，并且现在知道如何在分布式系统中分发数据。</p><h1 id="6c87" class="lt lu jj bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">参考</h1><div class="is it gp gr iu nz"><a href="https://www.digitalocean.com/community/tutorials/understanding-database-sharding" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd jk gy z fp oe fr fs of fu fw ji bi translated">了解数据库分片|数字海洋</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">任何有显著增长的应用程序或网站最终都需要扩展以适应增长…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.digitalocean.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ja nz"/></div></div></a></div><figure class="mx my mz na gt iv"><div class="bz fp l di"><div class="oo op l"/></div></figure><figure class="mx my mz na gt iv"><div class="bz fp l di"><div class="oo op l"/></div></figure></div></div>    
</body>
</html>