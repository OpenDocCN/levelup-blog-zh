<html>
<head>
<title>Start Implementing your own Typescript Method Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始实现你自己的类型脚本方法装饰器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/start-writing-your-own-typescript-method-decorators-c921cdc3d1c1?source=collection_archive---------0-----------------------#2020-11-20">https://levelup.gitconnected.com/start-writing-your-own-typescript-method-decorators-c921cdc3d1c1?source=collection_archive---------0-----------------------#2020-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2684ee804f0770304163d525abbf046b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8OkgdcucVTg6mB7S3AcgqQ.png"/></div></div></figure><h2 id="b8d7" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">什么是室内设计师？</h2><p id="1962" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">它是一种结构设计模式，通过将这些对象放在包含这些行为的特殊包装器对象中(<a class="ae lp" href="https://refactoring.guru/design-patterns/decorator" rel="noopener ugc nofollow" target="_blank">引用</a>)，可以将新的行为附加到这些对象上。</p><p id="ecac" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">当我们使用Typescript方法装饰器时，它们是帮助我们改变方法行为或对参数做一些事情的高阶函数。</p><p id="4568" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated"><strong class="kw ir"> Typescript方法装饰定义</strong> : <em class="lv">方法装饰可以用来观察、修改或替换一个方法定义(</em> <a class="ae lp" href="https://www.typescriptlang.org/docs/handbook/decorators.html#method-decorators" rel="noopener ugc nofollow" target="_blank"> <em class="lv">引用</em> </a> <em class="lv"> ) </em></p><p id="5e63" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">现在，让我们看看如何定义一个简单的方法装饰器。</p><h2 id="470a" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">设置</strong></h2><p id="c15b" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">为了运行Typescript代码，我们需要使用Typescript编译器来编译它们。</p><p id="b1cb" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">我们需要一个<code class="fe lw lx ly lz b">tsconfig.json</code>文件:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="ec91" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">我们必须启用<code class="fe lw lx ly lz b">experimentalDecorators</code>。还有，目标不能少于<code class="fe lw lx ly lz b">ES5</code>。</p><p id="4fd5" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">如果您不想使用<code class="fe lw lx ly lz b">tsconfig</code>文件，您可以直接传递这些选项:</p><pre class="ma mb mc md gt mg lz mh mi aw mj bi"><span id="a6f2" class="jy jz iq lz b gy mk ml l mm mn">tsc --experimentalDecorators // If you installed tsc globaly<br/>npx tsc --experimentalDecorators // If you installed tsc in your current directory</span></pre><p id="193d" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">现在，通过在当前目录下运行<code class="fe lw lx ly lz b">tsc</code>，类型脚本文件将被编译成javascript文件，我们可以使用Node运行它们。</p><h2 id="7b4e" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">定义一个方法装饰器</h2><p id="688c" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">typescript中方法装饰器的一般结构如下:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="a764" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">向装饰者传递参数<br/> 我们可以向装饰者传递一个变量，并且我们可以在装饰者内部访问它。我们在第13行传递了一个对象，它将成为第1行的参数。</p><p id="3328" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">return函数有3个参数。<br/> * <strong class="kw ir"> <em class="lv">目标</em> </strong>:包含我们的目标(我们要用它做点什么的函数、类、属性)<br/><strong class="kw ir"><em class="lv">* key</em></strong><em class="lv">:</em>在方法装饰器中，是方法的名字。<br/> <strong class="kw ir"> <em class="lv"> *描述符</em> </strong>:这是一个属性描述符，它给了我们<code class="fe lw lx ly lz b">descriptor.value</code>中的子函数(方法)，我们可以改变方法的行为。</p><p id="1864" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">如果你不熟悉属性描述符<a class="ae lp" href="https://www.javascripture.com/PropertyDescriptor#:~:text=A%20PropertyDescriptor%20describes%20a%20property,treated%20as%20undefined%20or%20false%20." rel="noopener ugc nofollow" target="_blank">，这篇文章</a>将帮助你理解它，但是用简单的语言来说，它可以帮助我们定义一个对象的属性，我们有一些选项，或者我们可以对那个属性设置约束。</p><p id="4649" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">在第一个例子中，我们想做一些非常简单的事情，我们想在每次有人调用函数时记录它的名字。</p><p id="7ac2" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated"><strong class="kw ir">示例1:函数名记录器</strong></p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">函数记录器定义</figcaption></figure><p id="98a9" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">我们在这个装饰器中所做的就是在第<code class="fe lw lx ly lz b">7</code>行记录这个键。</p><p id="94cd" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated"><strong class="kw ir"> <em class="lv">重要</em> </strong> <em class="lv">:不能在类之外使用装饰器(装饰器在我们使用类的时候是有意义的)</em></p><p id="3ea1" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">现在，如果我使用这个命令运行这个文件:<code class="fe lw lx ly lz b">npx tsc; node loggerDecorator.js</code> <br/>我可以在我的控制台中看到这个函数的名字:<code class="fe lw lx ly lz b">Sum</code>。</p><p id="0e57" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated"><strong class="kw ir">例2:检查重复用户</strong></p><p id="f6cd" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">现在让我们写一些更真实的东西，看看我们如何使用描述符。我们想写一个装饰器来检查用户邮件是否重复。我们可以在我们的方法中实现类似这样的东西，但是如果我们想在代码中不止一次地使用它，一个decorator来检查这一点将会很有帮助，并且必须知道这只是一个假想的例子，向您展示它是如何工作的(<em class="lv">有无数种方法可以比示例更好地实现它:)不要陷入太多的困境</em>)。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="8826" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">让我们一行一行地看看这里发生了什么:</p><p id="635f" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated"><em class="lv">第1行</em>:我们有一个<code class="fe lw lx ly lz b">const</code> <code class="fe lw lx ly lz b">userEmails</code>，它包含一个用户电子邮件的样本数组。这应该来自数据库。</p><p id="b070" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated"><em class="lv">第8行</em>:如果用户没有被复制，我们想要运行子函数，所以我们需要将原始方法存储在一个变量中。</p><p id="9e02" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">第9行:这就是我们改变函数的方法。我们可以在这里访问子函数的参数，因为我们可能有多个参数，我们需要像提取数组一样提取参数(通过使用<code class="fe lw lx ly lz b">…</code>)。</p><p id="8269" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">第11行:我们正在检查邮件是否重复。我们希望第一个参数是用户对象，所以要访问它，我们必须使用<code class="fe lw lx ly lz b">args[0]</code>，我们使用<code class="fe lw lx ly lz b">indexOf</code>检查电子邮件是否存在，当元素不在数组中时，这个方法返回<code class="fe lw lx ly lz b">-1</code>。如果电子邮件是重复的，我们将返回<code class="fe lw lx ly lz b">null</code>,因此该方法将不会被调用。如果用户没有被复制，我们必须执行这个方法，所以我返回了<code class="fe lw lx ly lz b">childFunction.apply(this, args)</code>,结果，如果用户没有被复制，这个方法将带着它的参数执行。</p><p id="b48d" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated"><em class="lv">第21行</em>:这是用户服务类，它有一个名为<code class="fe lw lx ly lz b">createUser</code>的方法，我们使用我们的方法装饰器来检查用户是否重复。如果用户是重复的，我们应该在控制台中看不到什么，如果用户是唯一的，应该调用方法，因此，我们应该在控制台上看到日志。</p><p id="d21f" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated"><em class="lv">第28行</em>:我们从<code class="fe lw lx ly lz b">UserService</code>类实例化，之后，我们在第29-30行使用了两次<code class="fe lw lx ly lz b">createUser</code>方法。其中一个电子邮件以前被使用过，所以我们期望方法<code class="fe lw lx ly lz b">createUser</code>对于电子邮件:<code class="fe lw lx ly lz b">john.smith@gmail.com</code>的用户只被调用一次</p><p id="16e1" class="pw-post-body-paragraph ku kv iq kw b kx lq kz la lb lr ld le kh ls lg lh kl lt lj lk kp lu lm ln lo ij bi translated">这是我的控制台上的结果:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/f12bf18f402b4e7250066d154229447a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_m_vfK3Eu02A7GxYFIeN7Q.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">控制台中的代码结果</figcaption></figure><h2 id="bd49" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">结论</strong></h2><p id="ca64" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">使用方法装饰器并不困难，如果我们使用类型脚本和面向对象编程，我们可以使用装饰器来改变方法行为。我们可以访问方法的参数和装饰器的参数，我们可以基于参数做一些事情。</p></div></div>    
</body>
</html>