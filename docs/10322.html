<html>
<head>
<title>Practical SOLID in Golang: Dependency Inversion Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中的实用实体:依赖反转原理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-solid-in-golang-dependency-inversion-principle-8cbd4eed484b?source=collection_archive---------0-----------------------#2021-11-22">https://levelup.gitconnected.com/practical-solid-in-golang-dependency-inversion-principle-8cbd4eed484b?source=collection_archive---------0-----------------------#2021-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e32f" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">坚实的原则</h2><div class=""/><div class=""><h2 id="7dab" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我们通过展示对Go中的单元测试影响最大的一个原则——依赖倒置原则，来继续坚实的原则之旅。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/e3ac59821d9c36a32981552cd09da8d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m6MWHIA3RgzVkVtZ"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">Jonny Gios 在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="6318" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">学习一门新的编程语言通常是一个简单的过程。经常听到:“你一年学的第一门编程语言。一个月内的第二起。一周内第三次，然后一天内每下一次。”。</p><p id="d199" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这么说有些夸张，但在某些情况下，这与事实并不太遥远。例如，跳到与前一种语言相对相似的语言，如Java和C#，可能是一个简单的过程。</p><p id="a073" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是有时候，切换是很棘手的，即使我们从一种面向对象语言切换到另一种。如果一种语言有接口、抽象类或根本没有类，那么许多特性都会影响这种转换，比如强类型或弱类型。</p><p id="ee54" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其中一些困难是我们在转换后立即经历的，我们采用了一种新的方法。但是我们后来经历的一些问题，例如在<a class="ae lh" href="https://betterprogramming.pub/5-and-a-half-techniques-for-effectively-writing-unit-tests-in-go-1b87b94abd21" rel="noopener ugc nofollow" target="_blank">单元测试</a>期间。然后，我们学习为什么依赖倒置原则是必要的，特别是在围棋中。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="6eeb" class="mj mk it mf b gy ml mm l mn mo">Other articles from the SOLID series:</span><span id="bf52" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-single-responsibility-principle-20afb8643483"><strong class="mf jd">Practical SOLID in Golang: Single Responsability Principle</strong></a></span><span id="48ff" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-open-closed-principle-1dd361565452"><strong class="mf jd">Practical SOLID in Golang: Open/Closed Principle</strong></a></span><span id="5b2c" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-liskov-substitution-principle-e0d2eb9dd39"><strong class="mf jd">Practical SOLID in Golang: Liskov Substitution Principle</strong></a></span><span id="d88d" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-interface-segregation-principle-f272c2a9a270"><strong class="mf jd">Practical SOLID in Golang: Interface Segregation Principle</strong></a></span><span id="b2b8" class="mj mk it mf b gy mp mm l mn mo">Some articles from the DDD series:</span><span id="9f83" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1.</strong> <a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="a559" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="e0b4" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-aggregate-de13f561e629"><strong class="mf jd">Practical DDD in Golang: Aggregate</strong></a></span><span id="b17a" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-repository-d308c9d79ba7"><strong class="mf jd">Practical DDD in Golang: Repository</strong></a></span><span id="7ea4" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">5. ...</strong></span></pre><div class="mq mr gp gr ms mt"><a href="https://blog.ompluscator.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jd gy z fp my fr fs mz fu fw jc bi translated">通过我的推荐链接加入媒体——马尔科·米洛耶维奇</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">blog.ompluscator.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh lb mt"/></div></div></a></div><h1 id="2ebf" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">当我们不尊重依赖性倒置时</h1><blockquote class="nz oa ob"><p id="4cbe" class="li lj oc lk b ll lm kd ln lo lp kg lq od ls lt lu oe lw lx ly of ma mb mc md im bi translated">高层模块不应该依赖低层模块。两者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。</p></blockquote><p id="d3c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以从上面看到倾角的定义。鲍勃叔叔在他的论文中提出了它。他的<a class="ae lh" href="https://blog.cleancoder.com/uncle-bob/2016/01/04/ALittleArchitecture.html" rel="noopener ugc nofollow" target="_blank">博客</a>里面也有更多的细节。</p><p id="2262" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，如何理解这一点，尤其是在围棋语境中？首先，我们应该接受<em class="oc">抽象</em>作为OOP <a class="ae lh" href="https://eng.libretexts.org/Courses/Delta_College/C_-_Data_Structures/06%3A_Abstraction_Encapsulation/1.01%3A_Difference_between_Abstraction_and_Encapsulation" rel="noopener ugc nofollow" target="_blank">概念</a>。我们使用这样一个概念来暴露本质行为，隐藏它们实现的细节。</p><p id="5883" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">二、什么是高低级模块？Go环境中的高级模块是应用程序顶层使用的软件组件，就像用于表示的代码一样。</p><p id="8c5a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它也可以是接近顶层的代码，比如业务逻辑或一些用例组件的代码。有必要将它理解为一个为我们的应用程序提供真正商业价值的层。</p><p id="59e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，低级别的软件组件大多是支持高级别的小代码片段。它们隐藏了不同基础设施集成的技术细节。</p><p id="9da4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，它可以是一个结构，用于保存从数据库检索数据、发送SQS消息、从Redis获取值或向外部API发送HTTP请求的逻辑。</p><p id="29e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，当我们打破依赖倒置原则，我们的高级组件依赖于一个低级组件时，会是什么样子呢？让我们看看下面的例子:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="7883" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码片段中，我们定义了一个高级组件<code class="fe oi oj ok mf b">EmailService</code>。这个struct属于应用层，负责给刚注册的客户发邮件。</p><p id="5e38" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个想法是要有一个方法，<code class="fe oi oj ok mf b">SendRegistrationEmail</code>，它需要一个<code class="fe oi oj ok mf b">User</code>的ID。在后台，它从<code class="fe oi oj ok mf b">UserRepository</code>中检索一个<code class="fe oi oj ok mf b">User</code>，然后(可能)将它交付给某个<code class="fe oi oj ok mf b">EmailSender</code>服务来执行电子邮件交付。</p><p id="9817" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">带有<code class="fe oi oj ok mf b">EmailSender</code>的部分现在不在我们的关注范围内。相反，让我们专注于<code class="fe oi oj ok mf b">UserRepository</code>。该结构表示与数据库通信的存储库，因此它属于基础设施层。</p><p id="8fc6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，看来我们的高层组件<code class="fe oi oj ok mf b">EmailService</code>依赖于低层组件<code class="fe oi oj ok mf b">UserRepository</code>。实际上，如果没有定义到数据库的连接，我们就不能启动用例结构。</p><p id="5a09" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种反模式会直接影响我们在Go中的单元测试。假设我们想要测试EmailService，如下面的代码片段所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="6b41" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与一些语言不同，如<a class="ae lh" href="https://phpunit.readthedocs.io/en/9.5/test-doubles.html" rel="noopener ugc nofollow" target="_blank"> PHP </a>，我们不能在Go中随意模仿。Go中的模仿依赖于接口的使用，为此我们可以定义一个模仿的实现，但我们不能对结构做同样的事情。</p><p id="0131" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们不能模仿UserRepository，因为它是一个结构体。在这种情况下，我们需要在较低的级别上进行模拟，在这种情况下，在<a class="ae lh" href="https://gorm.io/index.html" rel="noopener ugc nofollow" target="_blank"> Gorm </a>连接对象上，我们可以用<a class="ae lh" href="https://github.com/DATA-DOG/go-sqlmock" rel="noopener ugc nofollow" target="_blank"> SQLMock </a>包来完成。</p><p id="f60e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是即使有了它，它也不是一个可靠的、有效的测试方法。我们需要模拟太多的SQL查询，了解太多的数据库模式。数据库内部的任何变化，我们都需要调整单元测试。</p><p id="a219" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">单元测试放在一边，现在我们有一个更大的问题。如果我们决定把存储换成其他东西，比如<a class="ae lh" href="https://cassandra.apache.org/_/index.html" rel="noopener ugc nofollow" target="_blank">卡珊德拉</a>，会发生什么？主要是我们未来计划为客户提供的分布式存储？</p><p id="b481" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果出现这种情况，并且我们使用UserRepository的这种实现，许多重构将随之而来。</p><p id="4de3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们看到高层组件依赖于低层组件的含义是什么。但是依赖细节的抽象又如何呢？让我们检查下面的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="1bd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要解决高级和低级组件的第一个问题，我们应该从定义一些接口开始。在这种情况下，我们可以将<code class="fe oi oj ok mf b">UserRepository</code>定义为域层上的一个接口。</p><p id="23a1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，它提供了一个从数据库中解耦<code class="fe oi oj ok mf b">EmailService</code>的机会，但仍然不是完全解耦。看看<code class="fe oi oj ok mf b">User</code>结构。它仍然提出了映射到数据库的定义。</p><p id="09c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">而且，即使这样的结构在域层内部，它仍然拥有基础设施的细节。我们的新接口<code class="fe oi oj ok mf b">UserRepository</code>(抽象)依赖于数据库模式的<code class="fe oi oj ok mf b">User</code>结构(细节)，我们仍然打破了DIP。</p><p id="c722" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">改变数据库模式不可避免地会改变我们的界面。该接口仍然可以使用相同的用户结构，但是它将保存来自低级别层的更改。</p><p id="9bec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，通过这种重构，我们一无所获。我们仍然处于错误的位置。带来许多后果:</p><ol class=""><li id="fa00" class="ol om it lk b ll lm lo lp lr on lv oo lz op md oq or os ot bi translated">我们不能正确地测试我们的业务或应用程序逻辑。</li><li id="8fe2" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated">对数据库引擎或表结构的任何更改都会影响我们的最高级别。</li><li id="ba5b" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated">我们不能轻易切换到不同类型的存储。</li><li id="bed5" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated">我们的模型与存储紧密相关。</li><li id="d928" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi">…</li></ol><p id="897d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，让我们再一次重构这段代码。</p><h1 id="a9bd" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">我们如何尊重依赖倒置</h1><blockquote class="nz oa ob"><p id="340c" class="li lj oc lk b ll lm kd ln lo lp kg lq od ls lt lu oe lw lx ly of ma mb mc md im bi translated">高层模块不应该依赖低层模块。两者都应该依赖于抽象概念。抽象不应该依赖于细节。细节应该依赖于抽象。</p></blockquote><p id="774c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们回到依赖倒置的原始指令，检查加粗的句子。他们已经给出了重构的一些方向。</p><p id="afc2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们应该定义一些抽象(一个接口)，我们的组件<code class="fe oi oj ok mf b">EmailService</code>和<code class="fe oi oj ok mf b">UserRepository</code>都将依赖于这些抽象。另外，这样的抽象不应该依赖于任何技术细节(像Gorm对象)。</p><p id="c462" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们从下面检查代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="aeab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在新的代码结构中，我们可以看到<code class="fe oi oj ok mf b">UserRepository</code>接口是一个依赖于<code class="fe oi oj ok mf b">User</code>结构的组件，它们都在域层内部。</p><p id="e00d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe oi oj ok mf b">User</code>结构不再反映数据库模式，但是我们使用了<code class="fe oi oj ok mf b">UserGorm</code>结构。该结构位于基础结构层。它提供了一个方法<code class="fe oi oj ok mf b">ToUser</code>，将它映射到实际的<code class="fe oi oj ok mf b">User</code>结构。</p><p id="3e93" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这个场景中，我们可以使用<code class="fe oi oj ok mf b">UserGorm</code>作为<code class="fe oi oj ok mf b">UserDatabaseRepository</code>内部使用的细节的一部分，作为<code class="fe oi oj ok mf b">UserRepository</code>的实际实现。</p><p id="0061" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在域和应用层内部，我们只依赖于来自域的<code class="fe oi oj ok mf b">UserRepository</code>接口和<code class="fe oi oj ok mf b">User</code>T24】实体。</p><p id="ee38" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在基础设施层内部，我们可以根据需要为<code class="fe oi oj ok mf b">UserRepository</code>定义尽可能多的实现。例如，可以是<code class="fe oi oj ok mf b">UserFileRepository</code>或<code class="fe oi oj ok mf b">UserCassandraRepository</code>。</p><p id="662b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">高层组件(<code class="fe oi oj ok mf b">EmailService</code>)依赖于抽象——它包含一个类型为<code class="fe oi oj ok mf b">UserRepository</code>的字段。尽管如此，低层组件如何依赖抽象？</p><p id="c32f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Go中，structs隐式地实现接口<a class="ae lh" href="https://tour.golang.org/methods/10" rel="noopener ugc nofollow" target="_blank"/>。这意味着我们不需要在<code class="fe oi oj ok mf b">UserDatabaseRepository</code>显式实现<code class="fe oi oj ok mf b">UserRepository</code>的地方添加代码，但是我们可以添加一个带有空白标识符的检查。</p><p id="eef6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用这种方法，我们可以更容易地控制我们的依赖性。我们的结构依赖于接口，当我们想要改变我们的整体依赖时，我们可以定义不同的实现并注入它们。</p><p id="61de" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种技术在任何框架中都很常见，我们用<a class="ae lh" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入模式</a>来解决它。在围棋中，有很多DI库，比如来自<a class="ae lh" href="https://github.com/facebookarchive/inject" rel="noopener ugc nofollow" target="_blank">脸书</a>、<a class="ae lh" href="https://github.com/google/wire" rel="noopener ugc nofollow" target="_blank">钢丝</a>或者<a class="ae lh" href="https://github.com/i-love-flamingo/dingo" rel="noopener ugc nofollow" target="_blank">野狗</a>的库。</p><p id="302c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们的单元测试情况如何？让我们检查一下。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="c0ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过这种重构，我们可以提供一个简单的模仿对象<code class="fe oi oj ok mf b">GetByIDFunc</code>，作为一个新的类型，它从<code class="fe oi oj ok mf b">UserRepository</code>中定义了一个我们想要模仿的函数。下面是Go中定义一个函数类型，并给它分配一个方法来实现一个接口的常用方法。</p><p id="38f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们的测试更加优雅和高效。我们可以为<code class="fe oi oj ok mf b">UserRepository</code>注入不同的实现，用于任何用例，并控制测试的结果。</p><h1 id="a8de" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">更多的例子</h1><p id="5864" class="pw-post-body-paragraph li lj it lk b ll oz kd ln lo pa kg lq lr pb lt lu lv pc lx ly lz pd mb mc md im bi translated">我们可以在其他组件中体验breaking DIP，而不仅仅是结构。例如，可以具有纯的、独立的功能:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="d688" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，我们想为一个<code class="fe oi oj ok mf b">User</code>读取数据。为此，我们可以使用文件和JSON格式。方法<code class="fe oi oj ok mf b">GetUser</code>从文件中读取并将文件内容转换成实际的<code class="fe oi oj ok mf b">User</code>。</p><p id="f199" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">方法本身依赖于文件的存在，如果我们想要正确地测试它，我们需要依赖于这样的文件。因此，为这个方法编写测试是不方便的，例如，测试验证规则，如果我们稍后将它们添加到<code class="fe oi oj ok mf b">GetUser</code>方法中。</p><p id="862c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，我们的代码依赖于太多的细节，做一些抽象会很好:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="5a67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有了新的实现，我们让方法<code class="fe oi oj ok mf b">GetUser</code>依赖于<code class="fe oi oj ok mf b">Reader</code>接口的一个实例。它是来自Go核心包<a class="ae lh" href="https://pkg.go.dev/io" rel="noopener ugc nofollow" target="_blank"> IO </a>的一个接口。</p><p id="a010" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，我们可以定义许多不同的方式来提供<code class="fe oi oj ok mf b">Reader</code>接口的实现，比如<code class="fe oi oj ok mf b">GetUserFile</code>、<code class="fe oi oj ok mf b">GetUserHTTP</code>、<code class="fe oi oj ok mf b">GetDummyUser</code>(我们可以用它们来测试方法<code class="fe oi oj ok mf b">GetUser</code>)。</p><p id="5d76" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方法我们可以在许多不同的情况下使用。每当我们在进行适当的单元测试时遇到困难，或者甚至在Go中遇到依赖循环时，我们应该通过提供一个接口和尽可能多的实现来尝试去耦合它。</p><h1 id="0dff" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">结论</h1><p id="485e" class="pw-post-body-paragraph li lj it lk b ll oz kd ln lo pa kg lq lr pb lt lu lv pc lx ly lz pd mb mc md im bi translated">依存倒置原则是最后一个立体原则，它代表单词<em class="oc">立体</em>中的字母<em class="oc"> D </em>。它声称高级组件不应该依赖于低级组件。</p><p id="64cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，我们所有的组件都应该依赖于抽象，或者更好地说，依赖于接口。这样的抽象允许我们更灵活地使用我们的代码，并正确地测试它。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="2735" class="mj mk it mf b gy ml mm l mn mo">Other articles from the SOLID series:</span><span id="4161" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-single-responsibility-principle-20afb8643483"><strong class="mf jd">Practical SOLID in Golang: Single Responsability Principle</strong></a></span><span id="2a21" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-open-closed-principle-1dd361565452"><strong class="mf jd">Practical SOLID in Golang: Open/Closed Principle</strong></a></span><span id="4898" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-liskov-substitution-principle-e0d2eb9dd39"><strong class="mf jd">Practical SOLID in Golang: Liskov Substitution Principle</strong></a></span><span id="f1af" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-interface-segregation-principle-f272c2a9a270"><strong class="mf jd">Practical SOLID in Golang: Interface Segregation Principle</strong></a></span><span id="7a87" class="mj mk it mf b gy mp mm l mn mo">Some articles from the DDD series:</span><span id="23f7" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1.</strong> <a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="35c3" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="6563" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-aggregate-de13f561e629"><strong class="mf jd">Practical DDD in Golang: Aggregate</strong></a></span><span id="92d9" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-repository-d308c9d79ba7"><strong class="mf jd">Practical DDD in Golang: Repository</strong></a></span><span id="454f" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">5. ...</strong></span></pre></div></div>    
</body>
</html>