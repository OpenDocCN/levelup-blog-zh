<html>
<head>
<title>Run Your Node API with Express/ TypeScript on Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Heroku上用Express/ TypeScript运行节点API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/run-your-node-api-with-express-typescript-on-heroku-1a3bd3c9c487?source=collection_archive---------8-----------------------#2022-08-03">https://levelup.gitconnected.com/run-your-node-api-with-express-typescript-on-heroku-1a3bd3c9c487?source=collection_archive---------8-----------------------#2022-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/743d4f8e7dfd26417d531c593ac6c058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zc0vux8Rmkg2Oz4gPoToPQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:stock.adobe.com</figcaption></figure><p id="ff19" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我在客户项目中工作时，云提供商通常在企业范围内被授权。几乎没有任何回旋的余地。基本上有两个大玩家被使用:微软Azure或AWS。两种云环境都非常优秀、稳定，并提供足够的选项或服务来实现任何规模的项目。</p><p id="ba35" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于这两个玩家来说，提供的服务种类和由此产生的可能性似乎是无穷无尽的。经常有人问我觉得Azure好还是AWS好。我无法回答这个问题。两者都非常好，我喜欢用Azure和AWS来实现项目。</p><p id="3f3f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">尽管欢欣鼓舞，但即使是简单服务的推出也需要一定的专业知识和相应的时间。您很快就会面临这样的问题:使用托管Kubernetes集群还是弹性容器服务更好，等等。</p><p id="e797" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，在很多情况下，我们只是想推出一个REST API或app，而不是在CI/CD管道上花费大量的时间和精力。整件事应该还是符合专业标准的。</p><p id="5ae4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我看来，像Vercel或Heroku这样的公司为这些用例提供了非常好的替代方案。定价期权尤其有趣。您一定要仔细看看这些，因为Kubernetes集群或其他指向互联网的容器服务(NAT网关)的操作在任何情况下都会产生运行成本，即使没有或几乎没有流量。尤其是在MVP/原型阶段，或者在最初几个月你可能只期待零星流量的想法实现阶段，你应该寻找可靠的替代方案。其中一个对我来说是赫罗库。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi la"><img src="../Images/ab873a3e920072f98a918ac3db2164e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VluZ2XQ8TnlIvyGwYZaKJQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:stock.adobe.com</figcaption></figure><p id="3322" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我想展示在Heroku上推出一个简单的NodeJs/ Express REST API是多么容易。</p><h1 id="22ed" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">概观</h1><p id="d198" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">首先，简要概述一下我们将在本文中学习的内容:<br/> 1)使用TypeScript创建Express Server<br/>2)将代码发布到GitHub <br/> 3)在Heroku上推出API</p><h1 id="91c2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">先决条件</h1><p id="4114" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">为了能够对我的示例进行编程，您的机器至少需要满足以下要求。</p><ul class=""><li id="569d" class="mi mj iq ke b kf kg kj kk kn mk kr ml kv mm kz mn mo mp mq bi translated">您的计算机上安装的NodeJS/ npm</li><li id="310e" class="mi mj iq ke b kf mr kj ms kn mt kr mu kv mv kz mn mo mp mq bi translated"><a class="ae mw" href="https://heroku.com" rel="noopener ugc nofollow" target="_blank"> Heroku </a>记述</li><li id="bd6c" class="mi mj iq ke b kf mr kj ms kn mt kr mu kv mv kz mn mo mp mq bi translated"><a class="ae mw" href="https://github.com" rel="noopener ugc nofollow" target="_blank"> GitHub </a>账户</li><li id="1c49" class="mi mj iq ke b kf mr kj ms kn mt kr mu kv mv kz mn mo mp mq bi translated">Git CLI</li><li id="4f58" class="mi mj iq ke b kf mr kj ms kn mt kr mu kv mv kz mn mo mp mq bi translated">Heroku CLI </li></ul><p id="384c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">检查节点是否正在您的计算机上运行。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="c2ac" class="nc lg iq my b gy nd ne l nf ng">$ node --version<br/>v18.3.0</span></pre><p id="0589" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要检查git是否正在运行，请使用下面显示的命令。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="63be" class="nc lg iq my b gy nd ne l nf ng">$ git --version<br/>git version 2.32.0</span></pre><p id="463c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您尚未安装Heroku CLI，可以在Mac上使用brew进行安装。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="2440" class="nc lg iq my b gy nd ne l nf ng">$ brew tap heroku/brew &amp;&amp; brew install heroku</span></pre><h1 id="6244" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第一步</h1><p id="ab19" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">首先，我们想在本地机器上运行一个简单的Express服务器。我们用以下命令创建一个新目录并初始化一个NPM项目。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="71d9" class="nc lg iq my b gy nd ne l nf ng">$ mkdir express-api-heroku <br/>$ cd express-api-heroku<br/>$ npm init -y</span></pre><p id="4c49" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一步，我们安装运行TypeScript所需的依赖项。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="50bb" class="nc lg iq my b gy nd ne l nf ng">$ yarn add -D typescript<br/>$ yarn add -D tslint</span></pre><p id="3d9f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">…最后表达。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="cf12" class="nc lg iq my b gy nd ne l nf ng">$ yarn add express<br/>$ yarn add -D @types/express</span></pre><p id="0f25" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们仍然需要初始化或配置TypeScript。为此，我们可以手动创建一个tsconfig.json，或者只运行下面的命令。对于我们的例子，默认设置就足够了。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="94d4" class="nc lg iq my b gy nd ne l nf ng">$ tsc --init</span></pre><p id="18fa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">tsconfig.json文件应该如下所示。当然，您也可以创建一个名为tsconfig.json的文件，并粘贴以下代码片段。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="1843" class="nc lg iq my b gy nd ne l nf ng">{<br/>  "compilerOptions": {<br/>    "module": "commonjs",<br/>    "esModuleInterop": true,<br/>    "target": "es6",<br/>    "moduleResolution": "node",<br/>    "sourceMap": true,<br/>    "outDir": "dist"<br/>  },<br/>  "lib": ["es2015"]<br/>}</span></pre><p id="f0f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在package.json中，脚本部分必须修改如下。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="2034" class="nc lg iq my b gy nd ne l nf ng">"main": "dist/index.js",<br/>"scripts": {<br/>  "dev": "tsc &amp;&amp; node dist/index.js"<br/>},</span></pre><p id="0201" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要运行一个简单的Express服务器，我们仍然需要添加一个index.ts文件，代码如下。这只是一个非常简单的例子，根路由是“/”。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="2e6a" class="nc lg iq my b gy nd ne l nf ng">import express, { Express, Request, Response } from 'express';<br/><br/>const app: Express = <em class="nh">express</em>();<br/>const port = 3000;<br/><br/>app.get('/', (req: Request, res: Response) =&gt; {<br/>    res.send('Code with Rico. Ready to run on Heroku.');<br/>});<br/><br/>app.listen(port, () =&gt; {<br/>    return console.log(`[server]: Server is running on ${port}`);<br/>});</span></pre><p id="ea94" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看服务器是否准备好运行。使用以下命令。输出应该如下所示。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="cac0" class="nc lg iq my b gy nd ne l nf ng">$ yarn dev<br/>yarn run v1.22.17<br/>$ tsc &amp;&amp; node dist/index.js<br/>[server]: Server is running on 3000</span></pre><p id="d6a1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当服务器运行时，我们可以检查输出。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="0b9b" class="nc lg iq my b gy nd ne l nf ng">$ curl localhost:3000<br/>Code with Rico. Ready to run on Heroku.</span></pre><p id="aefa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这样，我们使用Express framework建立了一个节点项目，它使用TypeScript进行编译和运行。</p><h1 id="82ec" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加Heroku特定的东西</h1><p id="7a47" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">接下来，我们需要添加一个负责端口的配置。为此，我们仍然需要包<em class="nh"> dotnev </em>作为依赖项。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="3645" class="nc lg iq my b gy nd ne l nf ng">$ yarn add dotenv</span></pre><p id="6eaa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们创建config.ts文件，其内容如下所示。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="0c8c" class="nc lg iq my b gy nd ne l nf ng">import dotenv from 'dotenv';<br/><br/>dotenv.<em class="nh">config</em>();<br/><br/>const PORT = process.env.PORT || 3000;<br/><br/>export const config = {<br/>    server: {<br/>        port: PORT<br/>    }<br/>};</span></pre><p id="ebc8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">重要！！！</strong></p><p id="8edc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要在这里使用<em class="nh"> process.env </em>声明端口的原因是Heroku将尝试注入它自己的端口。如果我们不这样声明它，它将导致应用程序在Heroku上一次又一次地崩溃。</p><p id="d7cf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们现在需要修改index.ts来从这个配置中获取端口。下面的代码显示了更新后的index.ts。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="a8c9" class="nc lg iq my b gy nd ne l nf ng">import express, { Express, Request, Response } from 'express';<br/>import {config} from "./config";<br/><br/>const app: Express = <em class="nh">express</em>();<br/><br/>app.get('/', (req: Request, res: Response) =&gt; {<br/>    res.send('Code with Rico. Ready to run on Heroku.');<br/>});<br/><br/>app.listen(config.server.port, () =&gt; {<br/>    return console.log(`[server]: Server is running on ${config.server.port}`);<br/>});</span></pre><p id="8fe3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，让我们扩展package.json以在Heroku上运行我们的API。Heroku想运行JavaScript，而不是TypeScript。这就是为什么必须将“postinstall”命令添加到out package.json的脚本部分的原因。该命令将确保我们不必在build或dist文件夹中上传编译后的代码。Heroku将调用管道中命令来在线编译类型脚本代码。</p><p id="e9c7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，更新的脚本部分应该如下所示:</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="2aa1" class="nc lg iq my b gy nd ne l nf ng">"scripts": {<br/>  "dev": "tsc &amp;&amp; node dist/index.js",<br/>  "start": "node dist/index.js",<br/>  "postinstall": "tsc"<br/>},</span></pre><p id="18dc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，我们现在需要在我们的应用程序的根目录中有Heroku特有的<em class="nh"> Procfile </em>。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="338f" class="nc lg iq my b gy nd ne l nf ng">$ touch Procfile</span></pre><p id="490f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们唯一要声明的是。我们必须给Heroku我们的开始命令。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="35b5" class="nc lg iq my b gy nd ne l nf ng">worker: npm start</span></pre><p id="81b8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="nh">好了</em>，现在我们已经基本准备好了运行Heroku的Express API。</p><p id="47ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在有两种方法可以让我们的Express API在Heroku上工作。由于使用代码库是有意义的，我将通过GitHub repo展示这种方式。当然，也可以使用Heroku CLI将app从您的本地机器部署到Heroku。</p><p id="dd81" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，在本文中，我们当然会使用Heroku CLI在Heroku上设置管道和应用程序。</p><h1 id="bad8" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">把代码推给GitHub</h1><p id="906e" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">在这个例子中，我在我的GitHub帐户上创建了一个新的存储库。我将它设为“公共的”,这样文章的读者就可以访问代码。当然，你也可以为你的代码创建一个私有的回购协议。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/02fe9631777f16347694b9f625d34e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-60XxBAhKMO9FhNWOggpw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在GitHub上创建代码报告。</figcaption></figure><p id="7ce0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一步，我们返回到项目目录(使用终端或bash)并为存储库初始化git。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="aa10" class="nc lg iq my b gy nd ne l nf ng">$ git init</span></pre><p id="0bec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们再加一个。gitignore file，因为我们不想提交所有文件。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="fdd7" class="nc lg iq my b gy nd ne l nf ng">$ touch .gitignore</span></pre><p id="ac7a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">的内容。gitignore文件应该是这样的。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="01b7" class="nc lg iq my b gy nd ne l nf ng"><em class="nh"># IDE<br/></em>.idea/<br/>*zip<br/><br/><em class="nh"># IDE - VSCode<br/></em>.vscode/*<br/>!.vscode/settings.json<br/>!.vscode/tasks.json<br/>!.vscode/launch.json<br/>!.vscode/extensions.json<br/><br/><em class="nh"># BUILD<br/></em>dist/<br/>node_modules/</span></pre><p id="6e41" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">之后，我们可以在GitHub上添加远程存储库。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="9145" class="nc lg iq my b gy nd ne l nf ng">$ git remote add origin <a class="ae mw" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:codewithrico/express-api-heroku.git</span></pre><p id="c83a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们添加如下未跟踪的文件，并提交更改。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="3203" class="nc lg iq my b gy nd ne l nf ng">$ git add .<br/>$ git commit -m "init"</span></pre><p id="2fda" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">之后，我们将这个提交推送到GitHub。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="c03d" class="nc lg iq my b gy nd ne l nf ng">$ git push -u origin main</span></pre><p id="ae33" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">酷，我们的代码现在可以在GitHub上找到了。现在是时候在Heroku上安装API了。</p><h1 id="6b4e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在Heroku上部署Express API</h1><p id="88a7" class="pw-post-body-paragraph kc kd iq ke b kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv mh kx ky kz ij bi translated">本文的一个目标是展示免费或低价提供一个API是完全可能的，例如用于测试目的。这个想法是，我们不需要在部署和创建CI/CD管道上花费任何额外的精力，或者需要相应的专业知识。我认为GitHub的集成在Heroku做得非常好，使用起来非常简单直观。最终的结果是，我们有了一个在专业和稳定的环境中运行的API实例。</p><p id="4003" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我假设你已经创建了一个Heroku帐号。</p><p id="399f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将在终点站下车。当浏览器关闭时，凭据将被删除。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="2c87" class="nc lg iq my b gy nd ne l nf ng">$ heroku login<br/>heroku: Press any key to open up the browser to login or q to exit: <br/>Opening browser to https://cli-auth.heroku.com/auth/cli/browser/...<br/>Logging in... done<br/>Logged in as codewithrico</span></pre><p id="c24e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将允许我们向Heroku帐户添加新的应用程序。使用下面的命令，我在欧洲地区添加了一个名为“codewithrico-express-api”的新应用程序。如果没有指定地区，缺省值是US。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="ad0f" class="nc lg iq my b gy nd ne l nf ng">$ heroku apps:create codewithrico-express-api --region eu</span></pre><p id="e30e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，我们用下面显示的命令创建一个管道。我选择“发展”作为舞台。</p><pre class="lb lc ld le gt mx my mz na aw nb bi"><span id="ac74" class="nc lg iq my b gy nd ne l nf ng">$ heroku pipelines:create codewithrico<br/>? Stage of codewithrico-express-api <br/>❯ development <br/>  staging <br/>  production<br/>Creating codewithrico pipeline... done<br/>Adding ⬢ codewithrico-express-api to codewithrico pipeline as development... done</span></pre><p id="2208" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Heroku仪表板中，我们创建的资源现在应该是这样的。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/738fd3f56908bd550ac3fabc0f1219a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EpyaB3imSbX3KSRFdfo8uQ.png"/></div></div></figure><p id="26a5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">GitHub将Heroku Dashboard访问权授予相应的GitHub组织是很重要的。在我的例子中，我允许Heroku访问组织“codewithrico”。见下图。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/4982ed740505daf3db35551373f54c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7reKmaxVjl8G9HD8WNaNQw.png"/></div></div></figure><p id="2dc9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Heroku仪表板中，我们现在转到我们的应用程序，然后转到Deploy选项卡。我们选择GitHub作为部署方法。在“连接到GitHub”下，我们可以搜索存储库。在选择列表中，您应该会看到相应的GitHub组织。<br/>如果在那里发现了存储库，那么回购就可以被连接。为此，我们只需点击“连接”按钮。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/969e9212b9ec6c17ee3097ac0b56eab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m0PO9dq_OHgHFY0AjCyV4g.png"/></div></div></figure><p id="4a13" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在成功地将存储库链接到Heroku应用程序或部署它之后，将出现以下部分。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/1d7ec6ac0d9cd69284c9b1ae4788273e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAGRo_tWgr-P8fyO9yk08Q.png"/></div></div></figure><p id="199e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过启用“启用自动部署”按钮，每次按下主分支都会更新Heroku上的API。<br/>要展示我们Express API的当前状态，我们只需点击“Deploy Branch”。</p><p id="41cc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">之后，您可以看到以下输出。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/e1f97b3c4cad2718f20819727e6c6f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pvjbsFcIGQFs0qLgveutdQ.png"/></div></div></figure><p id="32d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过单击“View”按钮，我们可以在浏览器中查看Express API的测试输出。</p><p id="469f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我希望通过这篇文章展示在Heroku上运行TypeScript/ NodeJS应用程序是多么容易。</p><p id="adf4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">干杯！</p><p id="8a98" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一如既往，你可以在GitHub上找到我的代码:https://github.com/codewithrico/express-api-heroku<a class="ae mw" href="https://github.com/codewithrico/express-api-heroku" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>