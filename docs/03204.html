<html>
<head>
<title>ES6 Equivalents of ES5 or Earlier Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES6等同于ES5或更早的特性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/es6-equivalents-of-es5-or-earlier-features-e8a32b2bfac7?source=collection_archive---------3-----------------------#2020-04-25">https://levelup.gitconnected.com/es6-equivalents-of-es5-or-earlier-features-e8a32b2bfac7?source=collection_archive---------3-----------------------#2020-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/92468d6a5068345aa099068b5febbedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RFN-ZpiN6EV9Muty"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Borna Bevanda 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="049d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是世界上最流行的编程语言之一。自2015年以来，JavaScript增加了许多伟大的功能，旨在取代早期版本JavaScript的旧功能。</p><p id="c36e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看哪个ES6特性取代了哪个旧特性。每当我们写代码的时候，我们都应该使用新的。</p><h1 id="a8c5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从<code class="fe mc md me mf b">apply()</code>到展开操作符(<code class="fe mc md me mf b">...</code></h1><p id="1e92" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">当我们将多个参数传递给像<code class="fe mc md me mf b">Math.max</code>这样的函数时，我们应该使用spread操作符，而不是调用<code class="fe mc md me mf b">apply</code>。</p><p id="2fff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为我们不需要担心使用spread操作符的<code class="fe mc md me mf b">this</code>的值。此外，它更干净、更容易阅读，并且可以处理任何可迭代或类似数组的对象。</p><p id="9b1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="8e21" class="mt lf it mf b gy mu mv l mw mx">const max = Math.max.apply(Math, [1, 2, 3, 4, 5]);</span></pre><p id="64e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="bf8b" class="mt lf it mf b gy mu mv l mw mx">const max = Math.max(...[1, 2, 3, 4, 5]);</span></pre><p id="655d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，写的东西少了很多，我们也不必知道<code class="fe mc md me mf b">apply</code>是做什么的，第一个参数要传递什么。</p><p id="6ebc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个例子是用<code class="fe mc md me mf b">push</code>将多个项目追加到同一个数组中。</p><p id="53cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而不是写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="22ab" class="mt lf it mf b gy mu mv l mw mx">const arr1 = [1, 2];<br/>const arr2 = [3, 4];<br/>arr1.push.apply(arr1, arr2);</span></pre><p id="d384" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了将3和4推入<code class="fe mc md me mf b">arr1</code>，我们编写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="d5a2" class="mt lf it mf b gy mu mv l mw mx">const arr1 = [1, 2];<br/>const arr2 = [3, 4];<br/>arr1.push(...arr2);</span></pre><p id="52eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们写得更少，我们不必像调用<code class="fe mc md me mf b">apply</code>那样担心<code class="fe mc md me mf b">this</code>的值。对于<code class="fe mc md me mf b">apply</code>，我们必须确保通过将<code class="fe mc md me mf b">arr1</code>作为第一个参数传入来推入<code class="fe mc md me mf b">arr1</code>。</p><p id="b855" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用扩展操作符，我们只需将<code class="fe mc md me mf b">arr2</code>扩展成<code class="fe mc md me mf b">push</code>。</p><h1 id="7837" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从<code class="fe mc md me mf b">concat()</code>到展开操作符(<code class="fe mc md me mf b">...</code>)</h1><p id="f004" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">同样，我们可以用spread操作符替换<code class="fe mc md me mf b">concat</code>。</p><p id="0d6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们要将另一个数组的项追加到一个数组中，而不是写入:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="8ee1" class="mt lf it mf b gy mu mv l mw mx">const arr1 = [1, 2];<br/>const arr2 = [3];<br/>const arr3 = [4, 5];<br/>const arr = arr1.concat(arr2).concat(arr3);</span></pre><p id="1488" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="28d2" class="mt lf it mf b gy mu mv l mw mx">const arr1 = [1, 2];<br/>const arr2 = [3];<br/>const arr3 = [4, 5];<br/>const arr = [...arr1, ...arr2, ...arr3];</span></pre><p id="2163" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们都返回一个包含来自<code class="fe mc md me mf b">arr1</code>、<code class="fe mc md me mf b">arr2</code>和<code class="fe mc md me mf b">arr3</code>的所有条目的新数组。</p><p id="3564" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们不必调用<code class="fe mc md me mf b">arr1</code>上的<code class="fe mc md me mf b">concat</code>来追加条目。我们只是将数组的所有条目放入一个新的数组中。spread操作符将复制它传播的数组。</p><h1 id="ec8d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从对象文字中的函数表达式到方法定义</h1><p id="98d5" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在ES6之前的JavaScript版本中，我们使用如下方法创建对象:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="b4fb" class="mt lf it mf b gy mu mv l mw mx">var obj = {<br/>  foo: function() {},<br/>  bar: function() {<br/>    this.foo();<br/>  },<br/>}</span></pre><p id="a204" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过引用<code class="fe mc md me mf b">this</code>和带有<code class="fe mc md me mf b">function</code>关键字的定义方法来调用对象的方法。</p><p id="1bdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在ES6中，这可以缩短为:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="5f19" class="mt lf it mf b gy mu mv l mw mx">const obj = {<br/>  foo() {},<br/>  bar() {<br/>    this.foo();<br/>  },<br/>}</span></pre><p id="2085" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，它要短得多，但却能做同样的事情。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/d76278f3322e73927369c2745d770f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DSCmqOxykSmHuboa"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">维克多·格拉巴尔奇克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="99c2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从构造函数到类</h1><p id="3e5f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在JavaScript中，类只是构造函数的语法糖。例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="71df" class="mt lf it mf b gy mu mv l mw mx">function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}</span><span id="fab8" class="mt lf it mf b gy mz mv l mw mx">Person.prototype.fullName = function() {<br/>  return `${this.firstName} ${this.lastName}`;<br/>};</span><span id="9e0e" class="mt lf it mf b gy mz mv l mw mx">const person = new Person('Jane', 'Doe');<br/>console.log(person.fullName());</span></pre><p id="7353" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="1add" class="mt lf it mf b gy mu mv l mw mx">class Person {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }</span><span id="e5ee" class="mt lf it mf b gy mz mv l mw mx">  fullName() {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  };<br/>}</span><span id="bbbf" class="mt lf it mf b gy mz mv l mw mx">const person = new Person('Jane', 'Doe');<br/>console.log(person.fullName());</span></pre><p id="2d6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，我们不必再向构造函数的原型添加实例方法。相反，如果我们以前使用过任何其他面向对象的语言，这个类的语法看起来会很熟悉。</p><p id="30c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字段和方法都在类中，我们用<code class="fe mc md me mf b">this</code>引用实例。</p><p id="0967" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要创建从另一个构造函数继承成员的构造函数，我们使用ES6之前的代码执行以下操作:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="54da" class="mt lf it mf b gy mu mv l mw mx">function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}<br/>Person.prototype.fullName = function() {<br/>  return `${this.firstName} ${this.lastName}`;<br/>};</span><span id="df36" class="mt lf it mf b gy mz mv l mw mx">function Student(firstName, lastName, studentNum) {<br/>  Person.call(this, firstName, lastName);<br/>  this.studentNum = studentNum;<br/>}</span><span id="6a9b" class="mt lf it mf b gy mz mv l mw mx">Student.prototype = Object.create(Person.prototype);<br/>Student.prototype.constructor = Student;<br/>Student.prototype.describe = function() {<br/>  return `${Person.prototype.fullName.call(this)} ${this.studentNum}`<br/>};</span><span id="1373" class="mt lf it mf b gy mz mv l mw mx">const student = new Student('Jane', 'Doe', '123');<br/>console.log(student.describe());</span></pre><p id="e1bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码有一个从<code class="fe mc md me mf b">Person</code>构造函数继承成员的<code class="fe mc md me mf b">Student</code>构造函数。</p><p id="4c96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了继承<code class="fe mc md me mf b">Person</code>的原型，我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="7972" class="mt lf it mf b gy mu mv l mw mx">Student.prototype = Object.create(Person.prototype);</span></pre><p id="2d0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mc md me mf b">Student.prototype.constructor</code>必须被设置为<code class="fe mc md me mf b">Student</code>以确保<code class="fe mc md me mf b">Student</code>有正确的构造函数。</p><p id="7596" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用父构造函数的方法:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="dbd9" class="mt lf it mf b gy mu mv l mw mx">Person.prototype.fullName.call(this)</span></pre><p id="014f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将<code class="fe mc md me mf b">Person.prototype.fullName</code>的<code class="fe mc md me mf b">this</code>设置为<code class="fe mc md me mf b">Student</code>实例。</p><p id="afa5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们使用类语法编写以下内容:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="f773" class="mt lf it mf b gy mu mv l mw mx">class Person {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }<br/>  fullName() {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  };<br/>}</span><span id="ceda" class="mt lf it mf b gy mz mv l mw mx">class Student extends Person {<br/>  constructor(firstName, lastName, studentNum) {<br/>    super(firstName, lastName);<br/>    this.studentNum = studentNum;<br/>  }<br/>  describe() {<br/>    return `${super.fullName(this.firstName, this.lastName)} ${this.studentNum}`<br/>  }<br/>}</span><span id="c07a" class="mt lf it mf b gy mz mv l mw mx">const student = new Student('Jane', 'Doe', '123');<br/>console.log(student.describe());</span></pre><p id="5523" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，任何用基于类的面向对象语言编程的人都更熟悉类语法。</p><p id="5031" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe mc md me mf b">super</code>调用父类的构造函数，并通过调用上面的<code class="fe mc md me mf b">super.fullName</code>调用父类的方法。</p><p id="54fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们必须将<code class="fe mc md me mf b">extends Person</code>添加到<code class="fe mc md me mf b">Student</code>中，以确保<code class="fe mc md me mf b">Student</code>从<code class="fe mc md me mf b">Person</code>中继承成员。</p><p id="c0e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们拥有<code class="fe mc md me mf b">extends</code>时，如果我们忘记调用<code class="fe mc md me mf b">super</code>，我们将得到一个错误。这比老方法要好，如果我们错过了构建原型的任何代码行，老方法不会给我们任何错误。</p><h1 id="856d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="0999" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">ES6语法比早期的语法好得多，尤其是class语法。</p><p id="9a2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然spread操作符是一种非常有用的简写方式，但是类语法是创建构造函数时必须使用的特性，因为它更加简洁，JavaScript解释器会告诉我们是否犯了错误。</p></div></div>    
</body>
</html>