<html>
<head>
<title>4 pitfalls in Go I still occasionally fall into</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的4个陷阱我仍然偶尔会陷入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/4-pitfalls-in-go-i-still-occasionally-fall-into-7099eae3ecd1?source=collection_archive---------5-----------------------#2021-08-03">https://levelup.gitconnected.com/4-pitfalls-in-go-i-still-occasionally-fall-into-7099eae3ecd1?source=collection_archive---------5-----------------------#2021-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a7cf2945b0216946899b7c77779802ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6RDtvmB9_0o4Zoh6PHF3Q.jpeg"/></div></div></figure><p id="4a47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在之前的<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/8-code-hacks-for-go-that-i-wish-id-known-when-i-started-56a6f4399acf">文章</a>中，<a class="ae kz" href="https://www.linkedin.com/in/andrew-hayes-belfast/" rel="noopener ugc nofollow" target="_blank"> I </a>写了我多年来遇到的编程技巧。对于这篇文章，我决定写一些我也遇到过的陷阱。这些类型的错误会导致编译器会忽略的怪癖，并且在代码审查中很容易被遗漏。</p><h1 id="40e9" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.引用循环变量不是一个好主意</h1><p id="30c7" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这一个是相当众所周知的，但是它仍然不时地抓住我。如果您循环遍历值并创建一个指向循环变量的指针，可能不会得到您期望的结果。下面的代码是一个简单的函数，它接受一组用户并提取他们的id:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="a2ca" class="mm lb it mi b gy mn mo l mp mq">package main</span><span id="107b" class="mm lb it mi b gy mr mo l mp mq">import "fmt"</span><span id="fe00" class="mm lb it mi b gy mr mo l mp mq">type User struct {<br/> ID   int<br/> Name string<br/>}</span><span id="7909" class="mm lb it mi b gy mr mo l mp mq">func main() {<br/> users := []User{{1, "Andy"}, {2, "John"}, {3, "Jane"}}</span><span id="5a49" class="mm lb it mi b gy mr mo l mp mq"> userIDs := getUserIDs(users)<br/>  for _, id := range userIDs {<br/>   fmt.Println(*id)<br/>  }<br/>}</span><span id="87b6" class="mm lb it mi b gy mr mo l mp mq">func getUserIDs(users []User) []*int {<br/> ids := make([]*int, 0, len(users))<br/> for _, user := range users {<br/>  ids = append(ids, &amp;user.ID)<br/> }<br/> return ids<br/>}</span></pre><p id="2b88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样的输出是:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="abea" class="mm lb it mi b gy mn mo l mp mq">3<br/>3<br/>3</span></pre><p id="5c4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是围棋中循环方式的一个怪癖。当你引用一个循环变量时，它本身就是在引用数组中的值。这实际上意味着当你引用循环变量时，你最终引用了循环变量引用的最后一个值。简单的解决方案是更新循环，如下所示:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="c787" class="mm lb it mi b gy mn mo l mp mq">func getUserIDs(users []User) []*int {<br/> ids := make([]*int, 0, len(users))<br/> for _, user := range users {<br/>  id := user.ID<br/>  ids = append(ids, &amp;id)<br/> }<br/> return ids<br/>}</span></pre><p id="ad4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，它就获得了循环变量值的一个副本，并引用它。</p><h1 id="4756" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.当心影子变量！</h1><p id="f7bb" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">影子变量不仅有一个很酷的名字，而且它们也会导致错误。当您在较低的范围内重用变量名时，就会出现这种情况。当您在Go中使用“:=”来声明一个变量时，您是在它周围的“{}”范围内声明它的。但是您可以在较低的范围内愉快地使用相同的变量名，例如在“if”语句中。在下面的代码示例中，您可以看到“importantVariable”在函数的顶层被设置为默认值。然后，代码进行一些检查，并更新“if”语句中的变量。然而，它最后输出的值并不完全是我们想要的，看看您是否能找出原因:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="5d49" class="mm lb it mi b gy mn mo l mp mq">package main</span><span id="1aec" class="mm lb it mi b gy mr mo l mp mq">import (<br/> "fmt"<br/>)</span><span id="0e21" class="mm lb it mi b gy mr mo l mp mq">func main() {<br/> importantVariableValue := getImportantVariableValue()<br/> fmt.Println(importantVariableValue)<br/>}</span><span id="05dd" class="mm lb it mi b gy mr mo l mp mq">func getImportantVariableValue() string {<br/> importantVariable := "Default Value"<br/> if functionThatChecksShouldWeUseANoneDefaultValue() {<br/>  importantVariable := "Non-Default Value"<br/>  fmt.Printf("Important Variable updated to: %s\n", importantVariable)<br/> }<br/> return importantVariable<br/>}</span><span id="0014" class="mm lb it mi b gy mr mo l mp mq">func functionThatChecksShouldWeUseANoneDefaultValue() bool {<br/> return true<br/>}</span></pre><p id="7fe3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将打印:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="08fe" class="mm lb it mi b gy mn mo l mp mq">Important Variable updated to: Non-Default Value<br/>Default Value</span></pre><p id="f0cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原因是“importantVariable”在if语句中被重新声明，在这一行:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0f11" class="mm lb it mi b gy mn mo l mp mq">importantVariable := "Non-Default Value"</span></pre><p id="22e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着当if语句结束时，它是一个被丢弃的全新变量。</p><p id="df43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个简单的例子，所以问题很容易发现和解决。然而，在更复杂的代码中，这可能更难发现。由于影子变量导致的错误丢失也很常见，因为Go编码人员到处都使用变量名“err”。这可能会导致您在调试时误入歧途，并使其更加痛苦。好的一面是Go中的一些linters可以自动为你找到影子变量。</p><h1 id="7ae0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.方法上的类型接收器接收类型的副本</h1><p id="4b9b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">Go中的“方法”是与特定类型相关联的函数。例如:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="cb5e" class="mm lb it mi b gy mn mo l mp mq">type MyStruct struct {<br/> Name string<br/>}</span><span id="65e8" class="mm lb it mi b gy mr mo l mp mq">func (ms MyStruct) PrintNameMethod() {<br/> fmt.Println(ms.Name)<br/>}</span></pre><p id="ad34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这段代码中，“PrintNameMethod”函数与“MyStruct”类型相关联。它只能作为“MyStruct”实例的一部分被调用。在该方法的开始，您可以看到它在一个名为“ms”的“MyStruct”类型变量中接收。这允许您从方法内访问MyStruct实例的值。但是，如果您想要更新MyStruct数据，就像下面的例子一样，您希望会发生什么呢？</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="82df" class="mm lb it mi b gy mn mo l mp mq">package main</span><span id="29a7" class="mm lb it mi b gy mr mo l mp mq">import "fmt"</span><span id="4923" class="mm lb it mi b gy mr mo l mp mq">type MyStruct struct {<br/> Name string<br/>}</span><span id="1b24" class="mm lb it mi b gy mr mo l mp mq">func (ms MyStruct) PrintNameMethod() {<br/> fmt.Println(ms.Name)<br/>}</span><span id="e6cc" class="mm lb it mi b gy mr mo l mp mq">func (ms MyStruct) UpdateNameMethod(newName string) {<br/> ms.Name = newName<br/>}</span><span id="946e" class="mm lb it mi b gy mr mo l mp mq">func main() {<br/> mS := MyStruct{Name: "Joe"}<br/> mS.UpdateNameMethod("Jane")<br/> mS.PrintNameMethod()<br/>}</span></pre><p id="6381" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该代码将输出:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1496" class="mm lb it mi b gy mn mo l mp mq">Joe</span></pre><p id="e0e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原因是“UpdateNameMethod”函数收到了MyStruct的副本，然后更新了它。然而，最初的MyStruct保持不变。您需要更新接收器以接收指向该结构的指针，如下所示:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="378e" class="mm lb it mi b gy mn mo l mp mq">func (ms *MyStruct) UpdateName(newName string) {<br/> ms.Name = newName<br/>}</span></pre><p id="1bbe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个小小的改变意味着你可以直接修改这个结构。这样，原始的MyStruct被修改，代码输出我们期望的结果。</p><p id="a54a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是众所周知的，但是它很容易被忽略，就像本文中的其他例子一样，在尝试调试时，它可能会让您陷入徒劳的境地。</p><h1 id="307e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">4.您可以在nil结构上调用方法</h1><p id="e6ab" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这导致了痛苦，因为当你试图调试时，它会让你分心。在下面的示例代码中，您尝试创建一个DB结构，但是出现了一些错误。这显然是一个过于简化的例子，但它确实发生了。出错了，你错过了一个错误，留下了一个指向结构体的零指针。在这种情况下，您认为示例代码会在哪里死机？</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="cf35" class="mm lb it mi b gy mn mo l mp mq">package main</span><span id="d751" class="mm lb it mi b gy mr mo l mp mq">import "fmt"</span><span id="f728" class="mm lb it mi b gy mr mo l mp mq">type DBStruct struct {<br/> DBConnectionName string<br/>}</span><span id="7481" class="mm lb it mi b gy mr mo l mp mq">func (ms *DBStruct) PrintDBConnectionName() {<br/> fmt.Println(ms.DBConnectionName)<br/>}</span><span id="fab8" class="mm lb it mi b gy mr mo l mp mq">func main() {<br/> s, _ := getDBStruct()<br/> s.PrintDBConnectionName()<br/>}</span><span id="bca1" class="mm lb it mi b gy mr mo l mp mq">func getDBStruct() (*DBStruct, error) {<br/> return nil, fmt.Errorf("oh noes, couldn't create the DB connection")<br/>}</span></pre><p id="ac68" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对我来说，我预计它会在这一行惊慌失措:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0efc" class="mm lb it mi b gy mn mo l mp mq">s.PrintDBConnectionName()</span></pre><p id="626b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这一行，我们忽略了错误，s是零。所以它肯定会在那里恐慌吗？没有。它不会惊慌，直到这一行:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="504e" class="mm lb it mi b gy mn mo l mp mq">fmt.Println(ms.DBConnectionName)</span></pre><p id="c75d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是因为Go会很乐意调用nil结构上的函数。为什么这是一个陷阱，是因为它经常在调试时把你送上错误的道路。函数被调用ok，所以结构显然是好的，所以一定是别的什么导致了这个问题！最好的解决方案是牢记这一点，并确保在尝试使用nil指针之前检查它们。</p><h1 id="037d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="2e89" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这些陷阱都不是特别复杂，大多数都很容易理解。问题来自他们的微妙之处。它们很容易被编译器和代码审查遗漏。然后，当出现问题时，你可能会追着自己的尾巴跑，因为代码没有像你预期的那样工作，所以它们值得记住，以防万一。</p></div></div>    
</body>
</html>