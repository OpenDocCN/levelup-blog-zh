<html>
<head>
<title>How to Start Designing Front-end Architectures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何开始设计前端架构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-start-designing-front-end-architectures-b24ce7dcf606?source=collection_archive---------1-----------------------#2019-12-06">https://levelup.gitconnected.com/how-to-start-designing-front-end-architectures-b24ce7dcf606?source=collection_archive---------1-----------------------#2019-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7e77" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">这是关于</em> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/rethinking-the-front-end-c0d86ccbbfe7?source=friends_link&amp;sk=4e44c10ff075d46e3c7d8956097a89fe"> <em class="ki">重新思考前端</em> </a> <em class="ki">的多部分系列的第2部分。在这一部分中，我们将看一个设计相对较大的真实应用程序的具体例子。</em></h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/1f56b25186973e3d318b2e2b53d96436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yYenzAWnWSLsNAID1N9MCQ.jpeg"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">Paul Hanaoka 在<a class="ae kj" href="https://unsplash.com/s/photos/organization?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2317" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">作为一名开发人员，挑战之一是从初级到高级。这意味着超越实现，开始考虑设计和架构。</p><p id="30ba" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">设计涉及两个技能:1。创造/发现/考虑目标和问题，2。构建方法/解决方案。</p><p id="682b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本文中，我们将探讨一些最核心的考虑因素。</p><h2 id="de70" class="lw lx it bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">考虑所有利益相关者</h2><p id="9f6a" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">在编写一行代码之前，从多个角度考虑您的产品以创建正确的概念和抽象非常重要。</p><p id="af36" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">好的代码不仅仅是功能代码。一个代码库的质量只有在它服务于它所接触的人时才是好的。一般来说，大多数产品都有三个主要的利益相关者:最终用户、产品人员和开发人员。这些是你可以获得大部分目标的地方。</p><h2 id="667d" class="lw lx it bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated"><strong class="ak">最终用户和最终产品</strong></h2><p id="1271" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">要对您的前端系统做出正确的决策，需要对最终用户和产品有深入的了解。最终用户设计通常是由UX设计师、平面设计和产品管理(包括市场营销)共同完成的。虽然关于设计的主要决策可能是由其他人做出的，但是理解最终产品将帮助您弄清楚项目需求，并做出关于设计实体/数据结构的决策。</p><p id="9cbc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">例子:</strong></p><p id="67a1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在过去的一个月里，我的公司一直在开发一个工具来构建灵活的测验。我们的核心产品是为旅行者设计和创建定制旅程，这些旅行者希望获得真实的体验，而没有与旅行的每个方面的研究和预订相关的困难和压力。作为第一步，我们让顾客进行一次登机问卷调查，以帮助我们的旅行设计师设计完美的旅行。这意味着询问兴趣、旅行日期、价格、旅行原因等。</p><h2 id="58e8" class="lw lx it bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">发现重要需求</h2><p id="8ab0" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">最终用户和产品有助于理解所需的功能。将产品作为一个整体来理解，会使架构设计变得更加容易。既然你正在经历这个过程，试着想想你将如何实现每个部分，并考虑任何挑战和问题。例如，我们应用程序的一个重要特性是条件渲染:根据用户的反应改变显示的内容。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mu"><img src="../Images/d55241eb2472e84671ab0439e5fd7313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZh3WVlaDkgiGIkWTPJfWA.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">条件渲染</figcaption></figure><p id="b015" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">该功能根据用户的回答显示内容。如果我们没有提前考虑这一点，一个常见的前端错误可能是将问题的答案嵌入到组件本身中。</p><p id="c96b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">例如，<code class="fe mv mw mx my b">ButtonSelect</code>组件将把响应存储在它自己的本地状态中。在React中，你可以使用<code class="fe mv mw mx my b">useState</code>或<code class="fe mv mw mx my b">setState</code>，或者在Vue中，你可以使用<code class="fe mv mw mx my b">data</code>属性。</p><p id="ef44" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果是这样的话，你将如何处理条件渲染？从同级组件中读取数据总是很尴尬。当用户提交时，您将如何提取测验的所有答案？如果不止一个块需要设置/共享相同的数据怎么办？</p><h2 id="de0c" class="lw lx it bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">提取实体</h2><p id="5411" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">将你的程序实体与客户对你的产品的看法联系起来是很重要的。对齐的实体使所有相关方更容易设计和推理功能。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mz"><img src="../Images/9bec8ab3bcda1541531db3560e69080c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RwnZvMNl-CTez3Na9Uw1Eg.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">使用最终用户设计实体。</figcaption></figure><p id="0145" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">通过在这个层次上思考，你可以思考事情应该如何组织。测验有部分，部分有步骤，步骤有内容块，等等…</p><p id="c143" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">正如您在上面看到的，有一些特定的块可以适应任何情况，而更多的自定义功能可能应该是自定义块(不灵活)。提前理解这些类型的需求有助于设计数据和组件。</p><p id="3779" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">很多时候，后端团队的工作是做出关于数据结构、API和端点的决策。这是相当落后的，因为前端团队是数据的最终消费者。客户端的数据转换有很多问题(较大的包、较慢的运行时间、web和移动平台之间可能的不一致等)。一个运行良好的团队，其实会有这两个单元的对话。前端团队将描述使编写代码最方便的数据类型，而后端团队将任何关注点或实现困难推后。</p><h2 id="ee04" class="lw lx it bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated"><strong class="ak">产品人</strong></h2><p id="54e6" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">为了改进产品，代码还必须具有灵活性和适应性。产品人员总是在分析和设计新的功能，创造新的内容，并思考新的方法来瞄准客户并与客户沟通。除非你的架构在需要的地方是灵活的，否则工程将是一个巨大的瓶颈。</p><p id="26b1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在开始这个项目之前，我们以前的测验有一个问题。我们的调查问卷是用固定流程构建的:具有固定行为的预定义页面/视图。这使得A/B测试变得既困难又不可扩展，因为它需要工程人员对每个测试进行细微的编辑。我们需要的是一个工具，让我们的UX和非技术人员可以轻松地构建和编辑。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi na"><img src="../Images/55f52423dae3a6e64ad5805285049447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpGPFFZ_Hwv2XI-egnGr4w.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">开发1个月后的应用程序</figcaption></figure><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nb"><img src="../Images/1f43765982224d2622d7618c197142e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_DFTrWfQil8Nlg6ez_uL7Q.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">通过与产品人员交谈发现的特性:痛点。</figcaption></figure><p id="749c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">进行单个副本更改、添加新的条件消息或添加没有生成器的单个自定义跟踪事件，每次更改将花费大约30分钟到1小时。为什么这么久？这些变更中的大部分需要一个简短的会议来向工程师描述变更，工程师需要找到正确的文件，进行小的变更，然后创建一个拉请求。然后是QA、代码审查、代码测试和部署。</p><p id="1248" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">builder应用程序将周转时间改为大约一分钟。与人交谈，找出什么工具将产生最大的影响！</p><p id="af79" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">思考灵活性</strong></p><p id="ae29" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">内部CMS工具可能并不总是解决问题的正确方法。灵活性意味着您的代码易于更改和添加。这意味着关注点的良好分离(您可以进行更改，而不用担心它会影响其他事情)，并添加您可以翻转以进行更改的选项/开关。灵活性的策略将在后面的文章中讨论。</p><h2 id="bf7a" class="lw lx it bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated"><strong class="ak">开发商</strong></h2><p id="fba8" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">一个常见的统计数据是，开发人员花在阅读代码上的时间比写代码多9倍。为了获得良好的开发体验，应用程序内部的通信质量极其重要。</p><p id="863a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">没有人愿意花时间从一个文件跳到另一个文件，试图找出他们关心的内容。这意味着良好的组织是至关重要的。良好的组织需要一定的远见。这意味着要花一到两周的时间来创建一个好的架构，然后创建一个400-1000字的简短文档来帮助向团队传达架构。开始时的这种努力将为您和您的团队节省几个月的实现时间。</p><h2 id="51d6" class="lw lx it bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">好的代码组织？</h2><p id="0a9f" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">你有没有做过所有文件都按“类型”组织的项目？视图放在一个文件夹中，组件放在另一个文件夹中，操作放在另一个文件夹中。听起来不错，对吧？开发Ruby on Rails应用程序？在React app工作？注意所有的应用程序看起来或多或少都是一样的，即使它们在做完全不同的事情。有什么问题？</p><p id="1e9b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">按类型组织代码就像编写教科书，像字典或术语表一样组织所有的知识。人们阅读你的书，孤立地理解文件，但是如果他们试图了解你的程序总体上做了什么，他们会很困惑。</p><p id="b977" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">更有意义的是根据目标/关注点来组织事情。目标决定了我们必须在工作记忆中保存什么，以及代码在做什么。它帮助您找到您正在寻找的特定代码，而不会陷入上下文切换中。</p><h2 id="743b" class="lw lx it bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated"><strong class="ak">不要害怕非标准的文件结构</strong></h2><p id="5163" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">我们的应用程序的根目录如下:</p><p id="9574" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">开发者便利/框架特定文件夹</strong></p><ul class=""><li id="f5dc" class="nc nd it lc b ld le lg lh lj ne ln nf lr ng lv nh ni nj nk bi translated">资产—图像、字体等的文件夹</li><li id="a66a" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">块——通用可重用组件</li><li id="7923" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">成分—特定应用的组件</li><li id="a59b" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">库导入—不同库的初始化脚本</li><li id="687e" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">样式—包括所有变量、函数和混合的基本样式表。</li></ul><p id="4d79" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">基于特征的文件夹</strong></p><ul class=""><li id="98d8" class="nc nd it lc b ld le lg lh lj ne ln nf lr ng lv nh ni nj nk bi translated">构建器应用程序—用于构建测验的应用程序</li><li id="8fc4" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">查看器应用程序—用于查看测验的应用程序</li><li id="b7ae" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nh ni nj nk bi translated">步骤模块—用于在测验中构建步骤的组件</li></ul><p id="1e4b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您可以将文件夹的每一层视为一个关注层。这样，每个文件夹都有助于展示程序的一个层面。在顶层，你更关心的是各个部分如何组合在一起。随着对文件结构的深入研究，您会越来越关注实现。</p><p id="3e89" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里的想法是你的文件夹结构有助于交流你的程序是如何工作的。</p><p id="e7ca" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果做得正确，读者可以理解你的程序是如何组合在一起的。他们不需要在文件目录中搜寻与抽象层次相关的文件(都在文件夹中)。这也意味着，新文件和文件夹相对于该层应该放在哪里是非常清楚的，从而使贡献更容易。这也是自述文件的一个自然去处！</p><p id="5928" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">第二个好处是，它自然地提供了一个更加“插件式”/模块化的架构。不再需要这段代码了吗？您可以删除文件夹和相关导入。没有必要四处寻找其他文件，可能是自重。</p><h2 id="5b95" class="lw lx it bd ly lz ma dn mb mc md dp me lj mf mg mh ln mi mj mk lr ml mm mn mo bi translated">结论</h2><p id="0568" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">本文简要概述了设计良好前端所需的一些高级考虑因素。我们讨论了如何设定设计目标，以及您需要解决的一些大问题。</p><ol class=""><li id="876a" class="nc nd it lc b ld le lg lh lj ne ln nf lr ng lv nq ni nj nk bi translated">考虑所有利益相关者</li><li id="4f3d" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nq ni nj nk bi translated">发现实体</li><li id="e1fb" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nq ni nj nk bi translated">与您的后端通信以描述您想要的数据</li><li id="2a36" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nq ni nj nk bi translated">找出需求</li><li id="1554" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nq ni nj nk bi translated">提前考虑实施和潜在问题</li><li id="715b" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nq ni nj nk bi translated">决定什么需要灵活</li><li id="d2d8" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nq ni nj nk bi translated">考虑文件结构和文档</li></ol><p id="6d54" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">少了什么？</p><ol class=""><li id="c2b6" class="nc nd it lc b ld le lg lh lj ne ln nf lr ng lv nq ni nj nk bi translated">关注点分离</li><li id="fdbc" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nq ni nj nk bi translated">成分组成</li><li id="36b5" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nq ni nj nk bi translated">将目标和问题转化为架构</li><li id="c2b0" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nq ni nj nk bi translated">测试工具和策略</li><li id="6653" class="nc nd it lc b ld nl lg nm lj nn ln no lr np lv nq ni nj nk bi translated">规划和执行重构</li></ol><p id="f609" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下一章将讨论如何选择好的关注点分离/分组！</p><p id="1047" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">感谢阅读！请留下您想要涵盖的任何问题和反馈或主题！</p></div></div>    
</body>
</html>