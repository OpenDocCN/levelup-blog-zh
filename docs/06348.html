<html>
<head>
<title>The “Majority” WriteConcern of MongoDB Replica Sets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB副本集的“多数”写问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-majority-writeconcern-of-mongodb-replica-sets-be426f388782?source=collection_archive---------6-----------------------#2020-11-17">https://levelup.gitconnected.com/the-majority-writeconcern-of-mongodb-replica-sets-be426f388782?source=collection_archive---------6-----------------------#2020-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7804b425dcee3d6c90099737e8242228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2So4MioxxxOjg3_emUpWg.png"/></div></div></figure><p id="f076" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这节课中，我们将讨论readConcern。目前，我们只处理副本集的非事务读取中使用的读取问题。我们不处理事务和共享集群。</p><p id="053b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们需要回顾两个老概念:多版本并发控制和“持久”数据。</p><p id="4e1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">WiredTiger使用多版本并发控制来处理并发操作。</p><p id="d513" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在读或写操作开始时，wiredTiger向该操作提供数据的时间点快照。</p><p id="8b0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">时间点快照是给定时间点存储中数据的内存视图。这里，给定的时间点是读或写操作的开始。</p><p id="65ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，这是我们目前拥有的数据集。然后我们同时接收一个读和写操作。将数据集直接暴露给这两个操作是一个非常糟糕的想法，因为这两个操作会相互冲突。不能从变化的数据集中读取。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi kz"><img src="../Images/98ac861e0ab995b4ab53b700c062a6a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3oTW7JkW6lvw8CSm8jpjNg.png"/></div></div></figure><p id="a21c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在MVCC下，当写入和读取操作开始时，它们都将收到数据集的快照。这两个快照是独立的，不会互相干扰。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/3f323a29314d81e60362e7091b407808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lUdBr_XmVZqZUhR7XIilsA.png"/></div></div></figure><p id="f6b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">写操作只对自己的快照进行更改。读取操作仅从其自己的快照中读取数据。这两个操作可以同时进行，不会互相影响。</p><p id="23cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在检查点，写操作的快照将被刷新到磁盘，并修改原始数据集。以下读操作将返回写操作的结果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lf"><img src="../Images/8012243af4009a2d36083199629637fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xeP3K8PExQrrEWV5GNfUhw.png"/></div></div></figure><p id="e77d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Durable用于描述写操作的结果。如果写操作的结果可以在关机、崩溃和重新启动后保持不变，则认为写操作是持久的。</p><p id="cf98" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于单个mongod进程，一旦写入到服务器的日志文件中，写操作就是持久的。</p><p id="4a07" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是如果我们使用一个副本集，这是不够的。写操作只有在大多数投票节点上变得持久之后，才能被认为是持久的。这需要将写操作写入大多数投票节点的日志。</p><p id="8fa7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，我们这里有一个三节点副本集。每个节点都在投票并承载数据。</p><p id="51bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">a和B已被写入两个节点。因此它们不会回滚，这意味着它们是耐用的。</p><p id="8caf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">c只在主节点上是持久的。这对副本集来说是不持久的。如果主节点在复制到其他节点之前出现故障，则C将回滚。</p><p id="4139" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以持久数据总是可以检索的，除非我们删除它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lg"><img src="../Images/07970b0a5c7fd058a186bbc2c5c092aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4qKqX1b4DpHC-_ZwCRSiw.png"/></div></div></figure><p id="730f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">读取问题指定读取操作的隔离级别。简而言之，读关注将持久数据与非持久数据隔离开来。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lh"><img src="../Images/d426e99da0b4192296a212253bce8799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NFQaNPZK4LOKxdBTzek1GQ.png"/></div></div></figure><p id="7d45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个非事务读取操作都可以有自己的readConcern。我们用readConcern方法作为read方法的附录。然后，我们将级别名传递给readConcern方法。有五个级别名称:本地、可用、多数、可线性化和快照。</p><p id="7808" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在只处理非事务读取，所以我们将跳过快照，因为它只在事务中可用。我们将在下面的交易课程中学习。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi li"><img src="../Images/7137b5ff984b3ded5bd1ad7e9ce8ff5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWSsqNOW9HwpnH3sHoyGow.png"/></div></div></figure><p id="bf4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本地和可用是默认的读取问题。对于非共享集合，这两个是相同的。</p><p id="559e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它们都返回当前节点的所有内容。他们不关心返回的数据是否已经复制到其他节点。因此返回的数据可能会回滚。</p><p id="4ced" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Local是对主节点进行读取的默认值。</p><p id="ce2c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于与因果一致性会话无关的再次读取辅助节点，这也是默认设置。</p><p id="775e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Available是对不与因果一致会话相关联的辅助节点进行读取的默认值。</p><p id="1e0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Available不支持因果一致的会话或事务。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lj"><img src="../Images/01ea66fe51e17e24922b2cf1b942a418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e9XvLaBIV35lKcmoL8sYpA.png"/></div></div></figure><p id="58eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">总之，在默认的读取关注下，对副本的读取操作检索当前节点拥有的任何内容。</p><p id="3148" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果需要检索最新数据，请将readPreference设置为primary，并将readConcern设置为local或available。主服务器将始终拥有最新的数据。使用本地或可用的readConcern，我们可以获得主节点拥有的一切。</p><p id="7f62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们有一个三成员的副本集。每个节点都承载数据和投票。</p><p id="52cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">客户端想要读取副本集。它没有指定任何读取问题，因此读取操作将使用本地可用的默认读取问题。</p><p id="1de1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">read操作将它所读取的节点视为一个独立的mongod进程。它不关心其他集合成员。它检索节点中任何可用的内容。因此，检索到的数据可能不持久，以后可能会回滚。</p><p id="4572" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果从绿色节点读取，时间点快照只有一个。因此它将只获得一个。</p><p id="2e28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果它从也是主节点的蓝色节点读取，快照包含A、B和C。因此它将获得A、B和C。C只存在于主节点上，因此它可能会在以后回滚。</p><p id="ec74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果客户端从read节点读取，它将获得A和b。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lk"><img src="../Images/ff529c37f3f85fb651a4a31cd9532930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KF2bCDFQg4zAunTZFVyu2w.png"/></div></div></figure><p id="191f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们来谈谈多数阅读关注。这实际上比你想象的要复杂得多。</p><p id="11ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">多数readConcern返回的文档即使在失败的情况下也是持久的。这意味着大多数readConcern需要wiredTiger存储引擎。</p><p id="1f9e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只有主节点可以确认具有多数写入问题的写入。记住这一点，我们以后会需要它。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ll"><img src="../Images/c2cd8cb40ffac28e6155af681115e119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oZO3boNMX7JBPVKhpS-PVg.png"/></div></div></figure><p id="ddbc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设所有这些点代表存储在当前节点中的文档。</p><p id="1ceb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它们可以分为两部分。第一部分仅包括持久数据，第二部分仅包括非持久数据。</p><p id="4060" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">持久数据是多数提交写操作的结果。</p><p id="0dd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们使用majority readConcern进行读取，我们将只能从durable部分获得数据。</p><p id="5816" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，节点如何知道它执行的哪个写操作变得持久了呢？</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lm"><img src="../Images/d077381928739ab65063fe9eec8d0a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPTf8Iq_ptZf6JizqFX72A.png"/></div></div></figure><p id="cca7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个集合成员都有一个内存视图或快照，用于记录自己多数提交的写操作的结果。该视图由主节点更新。这就是集合成员如何知道它复制的哪个写操作已成为多数提交的。</p><p id="4085" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在以下课程中，我们将此快照称为多数快照或持久快照，而不是本地和可用readConcern使用的时间点快照。</p><p id="9106" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">多数快照是在副本集开始时创建的，并一直保持至今。它不反映当前节点上的最新数据集。它只保留多数提交的写入结果。</p><p id="9e05" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们使用多数readConcern进行读取时，我们实际上是从多数快照中检索数据。</p><p id="fdaa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于大多数快照，延迟是不可避免的。写操作成为多数提交需要时间，因此多数快照无法立即反映数据更改。因此，我们可能得不到最新的数据，但仍可能检索到最近删除的数据。保存和维护多数快照也会不断消耗内存空间。</p><p id="4d4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是大多数readConcern在性能成本上与其他Concern不相上下。这是因为多数readConcern只使用已经存在的多数快照，不需要任何新的时间点快照。总的来说，它的成本类似于其他需要时间点快照的读取问题。</p><p id="9a3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以手动禁用多数快照。但是强烈建议您保持启用状态。</p><p id="87ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们在mongod配置文件中设置复制部分时，该部分中的最后一个属性是enableMajorityReadConcern。其默认值为true。此属性启用多数快照。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ln"><img src="../Images/df5dc7d845b1ea07056c16c3426a3916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpLigCmfdJIyHA_hkt06Zg.png"/></div></div></figure><p id="c4d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们有一个三成员的副本集。所有成员都有数据和投票权。</p><p id="32d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">主节点已完成三次写入:A、B和c。</p><p id="db52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，红色节点已经复制了A和b。C仍处于待定状态。</p><p id="25f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">绿色节点较慢。它只复制了a。B和C正在等待。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lo"><img src="../Images/e2a1666ace3d435dafec9726a5d00de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWkoI5f2DUKNgvvsRIpkTw.png"/></div></div></figure><p id="96a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">主节点已经声明A和B是多数提交的。c，此时只存在于主节点中。因此，如果主节点在将它复制到辅助节点之前出现故障，它可能会回滚。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lp"><img src="../Images/c6c7de215e8139cabe5c5baab733813e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7LcpHNx6dqDGfMvDRXQQQ.png"/></div></div></figure><p id="90c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在多数读关注下开始读操作。如果我们从主节点读取，我们将得到A和b，C还没有包含在多数快照中。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lq"><img src="../Images/7fa1945cca7841b2884dbfd16b3dc332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fT3jYmD67Sqo4N5aGualMQ.png"/></div></div></figure><p id="2cbc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们从读取节点读取，我们将得到A和B，这是红色节点的所有内容。红色节点的所有东西都是耐用的。在这种情况下，无论我们使用哪个readConcern，都会得到相同的结果。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lr"><img src="../Images/8ec0871f59c5751659c899f3ab61b048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ZV031_3jsUEFr9Yv8rcBg.png"/></div></div></figure><p id="4041" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们从绿色节点读取，我们将只获得A。这是因为A是绿色节点已经完成的唯一写入操作，并且A是多数提交的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ls"><img src="../Images/428092c012c4253868d895704f6fea0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcdA-PJuo1d2XMwiPMUKIw.png"/></div></div></figure><p id="3c1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">你永远得不到当前节点没有得到的。但是您可以获得当前节点不再拥有的内容。</strong></p><p id="831d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，如果我们从主节点删除一个并立即从中读取，如果复制延迟足够长，我们仍然可以检索到一个。</p><p id="de21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">已从主节点中移除，这意味着主节点已完成删除操作。但是删除操作还没有成为多数提交。因此A仍然记录在主节点的多数快照中。因此，它仍然是可检索的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lt"><img src="../Images/f1acfaff4686642cb5d0078a930c08dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*knsNwE_rsF4xEOr95-kCMg.png"/></div></div></figure><p id="ab5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">记住这个结论:<strong class="kd iu">多数readConcern返回当前节点已经执行的持久写入的结果</strong>。</p><p id="e697" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们看看多数快照是如何维护的。一旦你知道它是如何维护的，你就可以准确地预测多数读取的结果。</p><p id="8718" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们仍将使用三个成员的副本集作为示例。每个成员都有投票权和数据。</p><p id="b26d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们为三个节点绘制三条时间线。</p><p id="62e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">蓝色节点是主节点，绿色和红色节点是次节点。</p><p id="ee21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对副本集的最后一次写操作是写零。它在所有三个节点中存储数据零。</p><p id="b1fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">写零已被所有集合成员复制，并已被主节点确认为多数提交。因此，所有集合成员都认为数据零是持久的。不管我们从哪个节点读取数据，也不管我们使用哪种readConcern级别，我们总是会得到零数据。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lu"><img src="../Images/c7ac7470a22c2ac275e0d69510bbec3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uf_VyxugzQTwwxOtPQEJlw.png"/></div></div></figure><p id="5455" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们开始一个新的write: writeOne。它将数据0变为数据1。</p><p id="4335" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">WriteOne将首先应用于主节点。假设主节点在T0完成了writeOne。</p><p id="e223" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果客户端使用writeConcern W One启动writeOne，我们可以在T0时向客户端确认写入。</p><p id="2810" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们使用本地或可用的readConcern从主节点读取，我们将获得dataOne。</p><p id="a5dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是如果我们使用多数readConcern，我们仍然会得到dataZero。DataOne还不耐用。</p><p id="d883" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在T0之后，writeOne将被复制到绿色和红色节点。假设这两个节点分别在T1和T2完成writeOne。红色节点稍微在绿色节点的后面。</p><p id="e9fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在T1，如果我们从绿色节点读取并使用本地或可用的readConcern，我们将获得dataOne。但是如果我们使用多数readConcern，我们仍然会得到dataZero。</p><p id="2ad8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">出于同样的原因，在T2，如果我们从红色节点读取，只有本地和可用的readConcern可以返回dataOne。多数readConcern仍然返回数据零，即使此时dataOne已经保存到所有集合成员中</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lv"><img src="../Images/1ee86c6465bddfaa55783159d8488cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JepPlqg-UbMFsw3i4eQqAA.png"/></div></div></figure><p id="1d36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在T1，writeOne已经复制到三分之二的投票成员。这意味着对于当前的副本集，数据一已经是持久的。</p><p id="4f37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是主节点还不知道这一点，并且只有主节点确认具有多数写关注的写。所以在T1之后，writeOne仍然不会被认为是多数提交的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lw"><img src="../Images/7ebc495d43b5805cf671461bca5037b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0dXxOLfXxEiQljrd7XhzPg.png"/></div></div></figure><p id="8370" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">复制writeOne后，绿色节点将向主节点发送确认，告诉它已成功执行writeOne。</p><p id="fcd0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设主节点在T3接收到确认。</p><p id="bf8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">显然T3是writeOne最关键的时刻。</p><p id="202b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">主节点现在知道两个投票成员已经完成了writeOne。因此，它可以确认writeOne是多数提交的。这使得T3成为提交点。主节点将更新其多数快照以包括数据一。</p><p id="abfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，从T3开始，如果我们从主节点读取并使用多数readConcern，我们将获得dataOne。</p><p id="ff12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">WriteOne在T3被正式声明为多数提交，但是如果我们使用多数readConcern从两个辅助节点读取，我们仍然会得到dataZero。这是因为他们的快照还没有更新。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lx"><img src="../Images/796e564c7011cd08b117f501fb7deac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9eL340l9sPoZxmcwAjZIvw.png"/></div></div></figure><p id="6a7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在收到来自绿色节点的确认后，主节点将发回通知，告知绿色节点writeOne已成为多数提交。</p><p id="cc2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">收到通知后，绿色节点将更新其多数快照以包括dataOne。</p><p id="1b6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，在T5之后，如果我们从多数读取关注下的绿色节点读取，我们将获得dataOne。</p><p id="b8d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">WriteOne在T3已经成为多数提交。但是红节点不会马上收到通知。这是因为主节点还没有收到来自红色节点的确认。因此它不知道红色节点是否已经完成writeOne，因此不会发送通知。</p><p id="0014" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着即使在T5之后，如果我们在多数读取关注下从红色节点读取，我们仍然会得到数据零。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ly"><img src="../Images/06f696b07309eab1cb24e19d2c9502fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AxOHMRXBRu99SeDPa-EB6A.png"/></div></div></figure><p id="e5f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">red将在主节点完成writeOne后对其进行确认。</p><p id="3d99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设T4的主节点收到了这个确认。如果writeOne在其writeConcern中使用W3，则T4是主节点确认客户端并声明writeOne成功的时刻。</p><p id="28c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此时，writeOne已经被声明为多数提交。因此，在收到来自红色节点的确认后，主节点将向红色节点发回通知，要求它更新其多数快照。</p><p id="b7bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设红色节点在T6收到通知。从T6开始，如果我们在多数读取关注下从红色节点读取，我们将能够获得dataOne。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lz"><img src="../Images/fc33d5fee25dc082de448d6672b45f3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJe-NLjML7y0eWpwQphjSw.png"/></div></div></figure><p id="d965" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您需要检索最新的数据，请从主节点读取并使用本地或可用的readConcern。</p><p id="39d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查看我们的完整视频课程:</p><p id="dd83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae ma" href="https://www.udemy.com/course/mongodb-4-complete-course/?referralCode=A5C4133CC04B751BD76C" rel="noopener ugc nofollow" target="_blank">https://www.udemy.com/course/mongodb-4-complete-course/?referral code = a5c 4133 cc 04 b 751 BD 76 c</a></p></div></div>    
</body>
</html>