<html>
<head>
<title>Knowledge Graph App in 15min</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">15分钟知识图谱App</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/knowledge-graph-app-in-15min-c76b94bb53b3?source=collection_archive---------0-----------------------#2020-03-11">https://levelup.gitconnected.com/knowledge-graph-app-in-15min-c76b94bb53b3?source=collection_archive---------0-----------------------#2020-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2b1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用JSONs、MongoDB和自动生成的GraphQL API原型化一个简单的知识图应用程序</p><p id="4579" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">这个帖子是与</em> <a class="ae km" href="https://medium.com/@annakoniec" rel="noopener"> <em class="kl">安娜</em> </a> <em class="kl">和</em> <a class="ae km" href="https://medium.com/@arturhaczek" rel="noopener"> <em class="kl">阿图尔</em> </a> <em class="kl">共同努力的结果。</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/f06d44ec13c535aca41560eed3ad2eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ASEVk51Qwx2UMSzRwYmPsQ.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">来源:<a class="ae km" href="http://demo.staple-api.org/" rel="noopener ugc nofollow" target="_blank">贵族人脉</a></figcaption></figure><h1 id="d60f" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="6f50" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">使用完全通过GraphQL层管理的JSON数据，可以轻松构建简单的知识图应用程序。我们描述了一个快速的原型制作方法，<a class="ae km" href="http://demo.staple-api.org/" rel="noopener ugc nofollow" target="_blank"> Noble Connections </a>，它包括:</p><ol class=""><li id="ca73" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">存储在自由层<a class="ae km" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> MongoDB Atlas </a>实例中的JSON文档</li><li id="5a2b" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">Staple API  —一个基于GraphQL的语义抽象中间件，用于访问数据并将其虚拟化为知识图</li><li id="ab1b" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">在<a class="ae km" href="https://repl.it/" rel="noopener ugc nofollow" target="_blank"> Repl.it </a> IDE上测试部署</li></ol><p id="2938" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此演示的代码和部署说明可从以下网址获得:</p><blockquote class="mu mv mw"><p id="fa36" class="jn jo kl jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated"><a class="ae km" href="https://github.com/epistemik-co/staple-api-kg-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/epistemik-co/staple-api-kg-demo</a></p></blockquote><h1 id="1395" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">简介:走在知识图表上，一步一个脚印</h1><p id="0b7e" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">所以你想构建一个简单的知识图驱动的应用程序？太好了！你知道它将是关于什么的，你已经起草了应该支撑你的知识图的核心数据模式，并且你已经有了填充该结构的初始数据集——没有什么非常复杂的东西可以开始，比如一些人、地点以及它们之间的一些基本关系。类似这样的<a class="ae km" href="http://demo.staple-api.org" rel="noopener ugc nofollow" target="_blank">贵族关系</a>演示可以让人们探索欧洲贵族之间不同的家庭关系。您认为将所有这些放在一起并通过一些基本的UI公开应该不会太难，但是突然您开始学习另一个教程，并确信您的下一个主要挑战是选择合适的技术堆栈。应该是什么？可能是一些“本地的”<em class="kl">图形数据库</em>实现了<em class="kl">标记的属性图</em>模型——但是是哪一个呢？可能性的范围很广，并且在迅速增长。或者也许你应该走RDF路线，使用<em class="kl"> W3C标准</em>来表示你的数据，并在<em class="kl"> RDF三重存储</em>中管理它？或者一个<em class="kl">多模型数据库</em>可能是最安全“包罗万象”的选择..？</p><p id="fff6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">知识图空间中有大量详细的比较，并推荐了最适合构建核心图驱动应用程序的高级工具。然而，在我们的情况下，他们最终似乎承诺的是一个相对陡峭的学习曲线，以换取在第一个知识图应用程序原型制作时可能不太清楚的收益。</p><blockquote class="mu mv mw"><p id="fff3" class="jn jo kl jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">最后，一切都归结到用例，可以说，简单的用例可以用简单的方法有效地解决。</p></blockquote><p id="be0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">人们常说，知识图仅仅是应用数据的抽象视图，与具体的数据库、数据架构或实现没有直接联系。知识图存在于关系数据库、文档存储、数据仓库、Web本身以及跨REST端点。</p><blockquote class="mu mv mw"><p id="07dc" class="jn jo kl jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">这实际上是要认识到，在你感兴趣的领域中，不同类型的实体通过不同的关系彼此内在地联系在一起。</p></blockquote><p id="ce77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这并不意味着需要对该结构运行复杂的网络分析，或者对其类型层次结构进行逻辑推理，或者并行路径搜索算法。这些确实都是有效的任务，并且在这些任务中，上面提到的高级工具完全提供了其与众不同的价值主张。</p><blockquote class="mu mv mw"><p id="4887" class="jn jo kl jp b jq jr js jt ju jv jw jx mx jz ka kb my kd ke kf mz kh ki kj kk ij bi translated">但有时真的只是在知识图上一步一步地走。</p></blockquote><p id="c711" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇博文中，我们描述了一个简单的知识图应用程序原型的快速制作方法，<a class="ae km" href="http://demo.staple-api.org/" rel="noopener ugc nofollow" target="_blank"> Noble Connections </a>，它利用了:</p><ul class=""><li id="c745" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk na mm mn mo bi translated">普通JSON文档，存储在自由层<a class="ae km" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> MongoDB Atlas </a>实例中，用来表示应用程序数据；</li><li id="7eb6" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk na mm mn mo bi translated">基于GraphQL的<a class="ae km" href="https://staple-api.org" rel="noopener ugc nofollow" target="_blank"> Staple API </a>服务，用于将数据自动结构化和虚拟化为图形。</li></ul><p id="8467" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该应用程序具有vis.js支持的前端图形可视化，最终使用Repl.it IDE环境进行现场部署。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/3472049206000928d42b3d2ac505d6e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*gtqlwVOyULCOYhe7nmBhPg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">Noble Connections应用程序的架构和部署。</figcaption></figure><h1 id="9079" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">I .用JSONs编码图形数据</h1><p id="68a3" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">JSON是一种简单但极其灵活的数据序列化格式，由于它非常流行，可能不需要向任何人介绍。从形式上讲，它的目的是表示树型结构，即:对象、它们的属性以及与其他具有属性的对象的外部关系，等等。然而，按照一点系统惯例，它也非常适合捕捉图形形状的模型。从本质上讲，这就是在所有JSON对象上一致地使用惟一标识符，并注意哪些属性用于引用这样的标识符。例如，下面两个JSON对象描述了伊丽莎白女王二世和英国。标识符，在这种情况下都是URIs，总是与关键字<code class="fe nc nd ne nf b">_id</code>、(因此分别是:<code class="fe nc nd ne nf b"><a class="ae km" href="http://dbpedia.org/resource/Elizabeth_II" rel="noopener ugc nofollow" target="_blank">http://dbpedia.org/resource/Elizabeth_II</a></code>和<code class="fe nc nd ne nf b"><a class="ae km" href="http://dbpedia.org/resource/United_Kingdom" rel="noopener ugc nofollow" target="_blank">http://dbpedia.org/resource/United_Kingdom</a></code>)相关联，并从属性<code class="fe nc nd ne nf b">birthCountry</code>、<code class="fe nc nd ne nf b">deathCountry</code>、<code class="fe nc nd ne nf b">parent</code>、<code class="fe nc nd ne nf b">child</code>和<code class="fe nc nd ne nf b">spouse</code>中进一步引用。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ng"><img src="../Images/0c8dbc550061505f5ec1c5232d1a1a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vYwsyGgLMWEQyHxWVdup5w.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">JSON中表示的实体“伊丽莎白二世女王”。</figcaption></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ng"><img src="../Images/969ddc56c6b22e209ddaa488ea0df44d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6ZTVzvnFx5Mhnnmnp9XOA.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">JSON中表示的实体“英国”。</figcaption></figure><p id="bad9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那些更熟悉关联数据标准的人可能会立即意识到这基本上是<a class="ae km" href="https://www.w3.org/TR/json-ld/" rel="noopener ugc nofollow" target="_blank"> JSON-LD </a>格式背后的建模原则。这里唯一缺少的组件是所谓的JSON-LD上下文，它正式强制执行上述约定，如下所示:</p><pre class="ko kp kq kr gt nh nf ni nj aw nk bi"><span id="ae7f" class="nl le iq nf b gy nm nn l no np">{<br/>    "_id": "@id",<br/>    "_type": "@type",<br/>    "@vocab": "http://example.com/",<br/>    "birthCountry": {<br/>        "@type": "@id"<br/>    },<br/>    "deathCountry": {<br/>        "@type": "@id"<br/>    },<br/>    "parent": {<br/>        "@type": "@id"<br/>    },<br/>    "child": {<br/>        "@type": "@id"<br/>    },<br/>    "spouse": {<br/>        "@type": "@id"<br/>    }<br/>}</span></pre><p id="8ec3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过采用这种表示方法，单个JSON对象可以自然地变成任意大且复杂的图形拼图，这就是问题的关键。上例中的两个JSONs一起陈述了一个叫“伊丽莎白二世”的人出生在一个叫“英国”的国家</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9d1e7ef6c31ad0d30be9e309615b4a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*R-gfmEfCdQVwpkUjjWVwLw.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">通过一致地使用惟一标识符，可以很容易地将图结构编码成JSON格式。</figcaption></figure><p id="feb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JSONs的另一个优点是围绕它的现有工具生态系统——例如，<a class="ae km" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> MongoDB Atlas </a> —一个流行的MongoDB JSON商店的基于云的版本，它提供高达512MB数据的自由层存储，零维护成本。为了给我们的Noble Connections应用程序部署<a class="ae km" href="https://github.com/epistemik-co/staple-api-kg-demo/blob/master/data.zip" rel="noopener ugc nofollow" target="_blank">数据</a>(最初从<a class="ae km" href="http://dbpedia.org/" rel="noopener ugc nofollow" target="_blank"> DBpedia </a>中提取)，我们创建了一个这样的免费实例和一个专用的文档集合，使用<a class="ae km" href="https://www.w3schools.com/python/python_mongodb_getstarted.asp" rel="noopener ugc nofollow" target="_blank"> python客户端</a>上传数据，并配置一个具有只读访问权限的访客用户来启用应用程序查询。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nr"><img src="../Images/6528fda2a0da17c99102191efd2ac832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qHG6vkdHiQwp7dC6Uu8QaA.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">MongoDB Atlas实例的web仪表板，带有Noble Connections数据。</figcaption></figure><h1 id="9423" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">二。graph QL——一个图形抽象中间件</h1><p id="ec7d" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">关于GraphQL、它多样化的数据管理能力以及它可能对如何构建数据驱动的API产生的变革性影响，已经说了很多。有趣的是，GraphQL也越来越被认为是知识图之上的一个方便的数据抽象和访问层，这主要是因为它的严格类型化模式和查询语言，这有助于导航语义知识图，以及从不同来源获取数据的灵活性。简单地说，GraphQL非常适合管理来自不同结构数据源的连接数据。特别是，它非常适合公开以JSON对象形式序列化的图形数据，如上所述。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ns"><img src="../Images/97f65e2e344f80bd3c6654505129e511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29DRgTZBEbQ_415AnKHQqQ.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">Staple API将来自不同后端的数据虚拟化为(链接数据)知识图，并通过自动生成的GraphQL服务公开它。</figcaption></figure><p id="3cc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了简化合适的GraphQL端点在MongoDB上的实现，我们使用了<a class="ae km" href="http://staple-api.org/" rel="noopener ugc nofollow" target="_blank">Staple API</a>——一个轻量级的基于GraphQL的API，用于管理不同数据存储后端之上的知识图，包括MongoDB。简而言之，Staple API接受一个指定的RDF本体(在Noble Connections示例中<a class="ae km" href="https://github.com/epistemik-co/staple-api-kg-demo/blob/master/docs/ontology.ttl" rel="noopener ugc nofollow" target="_blank">这个就足够了</a>)，一个后端源的配置，并自动启动一个准备好的GraphQL服务，以及一个相应的模式和解析器。这个过程的自动化实际上节省了大量的开发时间，因为通常GraphQL解析器依赖于基于高度重复模式的数据结构，而这些数据结构都必须手动编码。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nt nu l"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">根据提供的本体和MongoDB数据源配置构建一个Staple API服务器。</figcaption></figure><p id="c89a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GraphQL模式对其管理的数据实施了严格的结构，因此我们必须确保我们插入到MongoDB中的数据确实与从本体生成的模式相匹配。或者，我们可以使用由Staple API创建的相应突变，以便将数据插入MongoDB，并让GraphQL验证其正确的结构。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e2d4300428a139342cb61598fc4e8704.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*E9N92-qotuXOgFhMCH3mcg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">用于Noble Connections应用程序的GraphQL模式。</figcaption></figure><p id="ec4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦启动，Staple API就会公开一组查询，这些查询能够将单个数据点连接成整个知识图的更大片段。不可否认，GraphQL查询语言的表达能力主要允许“在图上行走”，即获取对象及其选定的邻居，以及这些对象的邻居等。但是如果行走是我们所追求的，那么GraphQL只是完成了任务。例如，下面的原型查询获取一个带有标识符<code class="fe nc nd ne nf b"><a class="ae km" href="http://dbpedia.org/resource/Elizabeth_II." rel="noopener ugc nofollow" target="_blank">http://dbpedia.org/resource/Elizabeth_II</a></code>的人及其出生国家，以及她的孩子，分别带有他们的父母和出生国家。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/e83c794aafd968626f4e1298858e71a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*YMe_I9573YSOekQNSEcRMA.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">用GraphQL查询Nobel连接数据。</figcaption></figure><p id="333b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种类型的查询是Noble Connections演示UI的全部内容，支持对整个图形的可控探索。</p><h1 id="58fa" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">三。Repl.it上的部署</h1><p id="e0b3" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">在线测试部署简单web应用程序的最快方法之一是使用<a class="ae km" href="https://repl.it" rel="noopener ugc nofollow" target="_blank"> Repl.it </a> IDE环境。</p><ol class=""><li id="7203" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">转到<a class="ae km" href="https://repl.it/" rel="noopener ugc nofollow" target="_blank"> https://repl.it </a>。</li><li id="a3cd" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">按<strong class="jp ir"> + new repl </strong>创建一个新的repl环境，选择从GitHub导入。</li><li id="c4df" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">粘贴演示库的URL(<a class="ae km" href="https://github.com/epistemik-co/staple-api-kg-demo/" rel="noopener ugc nofollow" target="_blank">https://github.com/epistemik-co/staple-api-kg-demo</a>)并导入它。</li><li id="3ef4" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">按下运行按钮，等待应用程序在自动生成的一个表单的网址启动:【https://* * *-five-nine.repl.co<a class="ae km" href="https://github.com/epistemik-co/staple-api-kg-demo/#" rel="noopener ugc nofollow" target="_blank">。</a></li></ol><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nx"><img src="../Images/be74ce82723e0488c8f389f392e7869f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9It9xY_1eQVrIB2zUX7Lkg.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">将GitHub项目导入Repl.it。</figcaption></figure><p id="bc06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该应用程序(从<a class="ae km" href="https://github.com/epistemik-co/staple-api-kg-demo/blob/master/demo.js" rel="noopener ugc nofollow" target="_blank"> demo.js </a>文件运行)公开了两个图形界面:</p><ul class=""><li id="dfb5" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk na mm mn mo bi translated"><a class="ae km" href="https://github.com/epistemik-co/staple-api-kg-demo/#" rel="noopener ugc nofollow" target="_blank">处的前端UI https://* * *-five-nine.repl.co</a></li><li id="4455" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk na mm mn mo bi translated">位于<a class="ae km" href="https://github.com/epistemik-co/staple-api-kg-demo/#" rel="noopener ugc nofollow" target="_blank">https://* * *-five-nine.repl.co/graphql</a>的底层Staple API的Apollo游乐场，</li></ul><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ny"><img src="../Images/15444cbda42c4eb47b508e41d03b9be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbIYXU-pULDsdzABM51HgA.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">在Repl.it中运行Noble连接</figcaption></figure><p id="f97a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成了。知识图表应用程序正在运行，并准备玩，因为欧洲贵族之间的联系即将被发现！:)</p><p id="d26f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前端UI上的核心图形可视化是使用流行的<a class="ae km" href="https://dataviz.tools/category/network-visualization/" rel="noopener ugc nofollow" target="_blank"> vis.js </a>库创建的，该库足以呈现中小型网络，并支持轻松定制的表示、行为和交互模式。Apollo playground通常不会作为应用程序本身的一部分公开，它被包含在内，以便在GraphQL查询级别上进一步探索数据集。</p><h1 id="4204" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">摘要</h1><p id="8560" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">很明显，在现实世界中，构建和管理知识图表没有一个放之四海而皆准的方法。具有复杂查询和分析需求的苛刻用例通常需要高级工具，如图形/三元存储、语义数据描述模型、推理引擎或图形计算框架。然而，在其他情况下，基于普通JSONs、MongoDB和GraphQL的更简单的解决方案将完全有效，并将很好地支持预期的使用场景，同时大大减少开发工作以及部署和维护应用程序的成本。</p></div></div>    
</body>
</html>