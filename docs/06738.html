<html>
<head>
<title>Go concurrency pattern: Semaphore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go并发模式:信号量</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-concurrency-pattern-semaphore-9587d45f058d?source=collection_archive---------0-----------------------#2020-12-25">https://levelup.gitconnected.com/go-concurrency-pattern-semaphore-9587d45f058d?source=collection_archive---------0-----------------------#2020-12-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/24275bebe08cb449dd864d3583ca2950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbBuz1TKmrjzp_sb_S01eA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">交通道路(图片由<a class="ae kc" href="https://www.pexels.com/photo/buildings-cars-city-cross-harbour-tunnel-262100/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>提供)</figcaption></figure><p id="a4ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用Go编程语言实现并发流程非常容易。只要用go前缀运行你的函数，砰的一声，你的函数不会阻塞你的主G <em class="lb">例程</em>。</p><p id="b9a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果您出色的并发函数负责机器的I/O呢？例如，您的函数将从其他服务向REST API发出100个并行HTTP POST请求。是的，您的网络I/O将忙于同时处理100个请求，这会降低您的I/O性能。</p><p id="2bbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于<a class="ae kc" href="https://en.wikipedia.org/wiki/Semaphore_(programming)" rel="noopener ugc nofollow" target="_blank">维基百科</a>的救援信号来了，</p><p id="3696" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">信号量是一种变量或抽象数据类型，用于控制并发系统(如多任务操作系统)中多个进程对公共资源的访问。”。</p><p id="b303" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于我们的例子，我们可以将并发进程减少到20个，并重复这个过程5次，而不是同时处理100个HTTP请求。是的，这将比同时处理100个请求花费更多的时间，但是这将给你的I/O网络带来喘息的机会，因为你的网络只需要同时处理20个请求。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/41c2ca3a7994fba906750e6d18264f81.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*ynSuMnw9G8L4-QtJqe0AzA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">请求同时使用100个goroutines</figcaption></figure><figure class="ld le lf lg gt jr gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/149270c38a38895edf72282875fddaea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*DVeEI7LE0xky0o9qmlEVDw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">请求同时使用5个goroutines</figcaption></figure></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="25f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是信号量的强大之处，我们可以将100个并发请求分成5 x 20个并发请求。不幸的是，Golang没有内置的信号量实现，但可以使用<a class="ae kc" href="https://tour.golang.org/concurrency/3" rel="noopener ugc nofollow" target="_blank">缓冲通道</a>轻松模拟。因为当缓冲通道已满时，通道将锁定<em class="lb"> Goroutine </em>并使其等待，直到有缓冲区可用。</p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="eb8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于一个基本的介绍来说已经足够了，让我们通过在Go中实现信号量来实践一下。首先，我们需要定义我们的信号量接口:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="7257" class="lu lv iq lq b gy lw lx l ly lz">type Semaphore interface {</span><span id="c9a2" class="lu lv iq lq b gy ma lx l ly lz">    Acquire()</span><span id="2103" class="lu lv iq lq b gy ma lx l ly lz">    Release()</span><span id="1623" class="lu lv iq lq b gy ma lx l ly lz">}</span></pre><p id="7bd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的实现有两个方法Acquire()和Release()。<strong class="kf ir">获取</strong>方法用于锁定资源，并将在调用我们的繁重/长时间运行的进程之前被调用<strong class="kf ir">。而<strong class="kf ir"> Release </strong>方法应该在</strong>长时间运行的流程处理完之后调用<strong class="kf ir">。</strong></p><p id="b7be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来是我们的实现:</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="8592" class="lu lv iq lq b gy lw lx l ly lz">type semaphore struct {</span><span id="8338" class="lu lv iq lq b gy ma lx l ly lz">    semC chan struct{}</span><span id="c247" class="lu lv iq lq b gy ma lx l ly lz">}</span><span id="e8e0" class="lu lv iq lq b gy ma lx l ly lz">func New(maxConcurrency int) Semaphore {</span><span id="55be" class="lu lv iq lq b gy ma lx l ly lz">    return &amp;semaphore{</span><span id="926f" class="lu lv iq lq b gy ma lx l ly lz">        semC: make(chan struct{}, maxConcurrency),</span><span id="c889" class="lu lv iq lq b gy ma lx l ly lz">    }</span><span id="5ac4" class="lu lv iq lq b gy ma lx l ly lz">}</span><span id="53dd" class="lu lv iq lq b gy ma lx l ly lz">func (s *semaphore) Acquire() {</span><span id="83ea" class="lu lv iq lq b gy ma lx l ly lz">    s.semC &lt;- struct{}{}</span><span id="4c0d" class="lu lv iq lq b gy ma lx l ly lz">}</span><span id="1bd6" class="lu lv iq lq b gy ma lx l ly lz">func (s *semaphore) Release() {</span><span id="8cba" class="lu lv iq lq b gy ma lx l ly lz">    &lt;-s.semC</span><span id="9f08" class="lu lv iq lq b gy ma lx l ly lz">}</span></pre><p id="53f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样，当通道已满时，我们通过将<strong class="kf ir"> maxConcurrency </strong>参数设置为通道大小来利用Go缓冲通道上的阻塞行为。当我们调用<strong class="kf ir"> Acquire() </strong>，<strong class="kf ir"> </strong>时，该通道将被一个空结构填充，如果达到最大值，该通道将被阻塞。当我们调用<strong class="kf ir"> Release() </strong>时，我们从通道中取出空结构，通道将可用于下一个值，通道将被解除阻塞。</p></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="17a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看信号量的实际实现。</p><pre class="ld le lf lg gt lp lq lr ls aw lt bi"><span id="7f8c" class="lu lv iq lq b gy lw lx l ly lz">func main() {</span><span id="7085" class="lu lv iq lq b gy ma lx l ly lz">    sem := semaphore.New(3)</span><span id="9ceb" class="lu lv iq lq b gy ma lx l ly lz">    doneC := make(chan bool, 1)</span><span id="2de9" class="lu lv iq lq b gy ma lx l ly lz">    totProcess := 10</span><span id="cc5a" class="lu lv iq lq b gy ma lx l ly lz">    for i := 1; i &lt;= totProcess; i++ {</span><span id="5b9b" class="lu lv iq lq b gy ma lx l ly lz">        sem.Acquire()</span><span id="b11f" class="lu lv iq lq b gy ma lx l ly lz">        go func(v int) { </span><span id="958d" class="lu lv iq lq b gy ma lx l ly lz">            defer sem.Release()</span><span id="83fb" class="lu lv iq lq b gy ma lx l ly lz">            longRunningProcess(v)</span><span id="7a40" class="lu lv iq lq b gy ma lx l ly lz">            if v == totProcess {</span><span id="3a96" class="lu lv iq lq b gy ma lx l ly lz">                doneC &lt;- true</span><span id="472c" class="lu lv iq lq b gy ma lx l ly lz">            }</span><span id="2203" class="lu lv iq lq b gy ma lx l ly lz">        }(i)</span><span id="6605" class="lu lv iq lq b gy ma lx l ly lz">    }</span><span id="4677" class="lu lv iq lq b gy ma lx l ly lz">    &lt;-doneC</span><span id="fd97" class="lu lv iq lq b gy ma lx l ly lz">}</span><span id="a108" class="lu lv iq lq b gy ma lx l ly lz">func longRunningProcess(taskID int) {</span><span id="0963" class="lu lv iq lq b gy ma lx l ly lz">    fmt.Println(<br/>        time.Now().Format(“15:04:05”), <br/>        “Running task with ID”, <br/>        taskID)</span><span id="d473" class="lu lv iq lq b gy ma lx l ly lz">    time.Sleep(2 * time.Second)</span><span id="454a" class="lu lv iq lq b gy ma lx l ly lz">}</span></pre><p id="7e21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们实例化一个大小为3的新信号量，这意味着我们的最大并发进程将被限制为3。然后我们在<strong class="kf ir"> longRunningProcess </strong>函数上模拟一些繁重的任务(我们使用2秒睡眠时间来阻塞进程)。最后，我们尝试同时运行<strong class="kf ir">longRunningProcess</strong><strong class="kf ir"/>10g<em class="lb">例程。</em>让我们看看输出:</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mb"><img src="../Images/9d53e0af74b468a8e41cbdce4b8accc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ckLNbLUdfnt9iwo7yDp7Mw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">并发调用函数的结果</figcaption></figure><p id="9d78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的例子可以看出，我们的函数可以同时运行3个进程，因为我们使用了信号量，所以我们的例子需要6秒来完成这个进程，相比之下，如果没有信号量，这个进程只需要2秒就可以完成。通过使用信号量，我们可以控制对共享资源的访问，如数据库、网络、磁盘等。</p><p id="84ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参考:</p><ol class=""><li id="a6e5" class="mc md iq kf b kg kh kk kl ko me ks mf kw mg la mh mi mj mk bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Semaphore_(programming)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Semaphore _(编程)</a></li><li id="dc76" class="mc md iq kf b kg ml kk mm ko mn ks mo kw mp la mh mi mj mk bi translated"><a class="ae kc" href="https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html" rel="noopener ugc nofollow" target="_blank">https://www . ardan labs . com/blog/2014/02/the-nature-of-channels-in-go . html</a></li><li id="8296" class="mc md iq kf b kg ml kk mm ko mn ks mo kw mp la mh mi mj mk bi translated"><a class="ae kc" href="https://github.com/syafdia/go-exercise/tree/master/src/concurrency/semaphore" rel="noopener ugc nofollow" target="_blank">https://github . com/syaf dia/go-exercise/tree/master/src/concurrency/semaphore</a></li></ol></div></div>    
</body>
</html>