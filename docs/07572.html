<html>
<head>
<title>Importance of Data Preprocessing and Scaling in Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据预处理和缩放在机器学习中的重要性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/importance-of-data-preprocessing-and-scaling-in-machine-learning-21db1d4377ec?source=collection_archive---------6-----------------------#2021-02-24">https://levelup.gitconnected.com/importance-of-data-preprocessing-and-scaling-in-machine-learning-21db1d4377ec?source=collection_archive---------6-----------------------#2021-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bc9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在实现不同的机器学习算法时，数据预处理和规范化变得非常重要。由于数据预处理会显著影响学习模型的结果，因此所有特征都在同一尺度上非常重要。归一化在诸如k-NN、支持向量机、神经网络、主成分等算法中是重要的。所需的特征预处理和归一化的类型取决于数据。</p><h2 id="ba4c" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><strong class="ak"> <em class="le">预处理类型</em> </strong></h2><p id="4623" class="pw-post-body-paragraph jn jo iq jp b jq lf js jt ju lg jw jx jy lh ka kb kc li ke kf kg lj ki kj kk ij bi translated">有几种不同的方法来重新调整数据。下图显示了机器学习算法中最常用的四种算法。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/33d77630f4c6f0479084ff4e3ac779b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyZ44rWdSgqJc9J6lbnViA.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated"><strong class="bd kn">对数据集进行重新标度和预处理的不同方法。</strong></figcaption></figure><p id="679a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原始数据下的第一个图显示了只有两个要素的合成两类分类数据集。第一个特征(x轴值)在10到15的范围内。第二个特征(y轴值)介于1和9之间。右边的四个图显示了产生更多标准范围的数据转换的不同方法。</p><p id="2994" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ma">标准缩放器</em> </strong>确保数据集中每个要素的均值为0，方差为1，并使所有要素达到相同的量级。这种缩放不能确保要素的任何最小值和最大值。</p><p id="2998" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ma">鲁棒定标器</em> </strong>的工作原理与标准定标器相似，但使用中值和四分位数，而不是平均值和方差。这使得scaler忽略与其他数据点非常不同的数据点(测量误差)。</p><p id="815a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ma">规格化器</em> </strong>缩放每个数据点，使得特征向量的欧几里德长度为1。每个数据点都按不同的数字缩放(按其长度的倒数)。当数据的唯一方向重要，而不是特征向量的长度重要时，使用这种归一化。</p><p id="ba69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ma"> MinMaxScaler </em> </strong>变换所有的输入变量，所以它们都在0和1之间的同一标度上。该方法计算训练数据上每个特征的最小值和最大值，然后对每个特征应用最小-最大变换。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/f9c732a6f070e2b72f407e1cfd4b8fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*GL6olh_qVjpOD2ltPP23yA.png"/></div></figure><blockquote class="mc md me"><p id="8de7" class="jn jo ma jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated"><strong class="jp ir">在ML中应用缩放比例</strong></p></blockquote><p id="f762" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下示例显示了如何将MinMaxScaler应用于要素。首先创建标量对象，然后使用训练数据X_train调用fit方法。这将计算该训练数据集中每个要素的最小和最大特征值。然后要应用标量，调用它的transform方法，并传入需要重新缩放的数据。输出将是输入数据的缩放版本。在这种情况下，我们希望缩放训练数据，并将其保存在一个名为X_train_scaled的新变量中。和测试数据，将其保存到一个名为X_test_scaled的新变量中。然后，我们只使用这些缩放版本的特征数据，而不是原始特征数据。</p><pre class="ll lm ln lo gt mi mj mk ml aw mm bi"><span id="18f6" class="kl km iq mj b gy mn mo l mp mq">from sklearn.preprocessing import MinMaxScaler<br/>scaler = MinMaxScaler()<br/>scaler.fit(X_train)<br/>X_train_scaled = scaler.transform(X_train)<br/>X_test_scaled = scaler.transform(X_test)<br/>clf = SVC().fit(X_test_scaled, y_train)<br/>r2_score = clf.score(X_test_scaled, y_test)</span></pre><p id="9ac9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有两件非常重要的事情。首先，相同的标量对象必须应用于训练和测试。第二，标量对象必须在训练数据上训练，而不是在测试数据上训练。</p><p id="5b9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在ML算法中预处理数据时，需要遵循以下重要方面:</p><ul class=""><li id="6988" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated">使用训练集拟合缩放器，然后应用相同的缩放器来转换测试集。</li><li id="e287" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">不要使用不同的缩放器来缩放训练集和测试集:这可能会导致数据中的随机偏差。</li><li id="a62e" class="mr ms iq jp b jq na ju nb jy nc kc nd kg ne kk mw mx my mz bi translated">不要使用测试数据的任何部分来安装定标器:引用测试数据会导致某种形式的数据泄漏。</li></ul><blockquote class="mc md me"><p id="56f1" class="jn jo ma jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated"><strong class="jp ir">预处理对监督学习的影响</strong></p></blockquote><p id="4a4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下示例展示了数据预处理在真实世界示例癌症数据集中的重要性。在原始数据上拟合SVC:</p><pre class="ll lm ln lo gt mi mj mk ml aw mm bi"><span id="cc22" class="kl km iq mj b gy mn mo l mp mq"># import SVC classifier<br/>from sklearn.svm import SVC</span><span id="a425" class="kl km iq mj b gy nf mo l mp mq"># split data<br/>X_train, X_test, y_train, y_test = train_test_split(cancer.data, cancer.target, random_state=0)</span><span id="3faf" class="kl km iq mj b gy nf mo l mp mq"># initialize classifier and fit data<br/>svm = SVC(C= 100)<br/>svm.fit(X_train, y_train)</span><span id="e74d" class="kl km iq mj b gy nf mo l mp mq"># checking accuracy for classifier<br/>print("Test set accuracy: {:.2f}".format(svm.score(X_test, y_test)))</span><span id="1b5c" class="kl km iq mj b gy nf mo l mp mq">&gt;&gt;&gt;&gt;&gt; Test set accuracy: 0.63</span></pre><p id="7e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下代码表示在拟合SVC分类器之前使用MinMaxScaler缩放数据:</p><pre class="ll lm ln lo gt mi mj mk ml aw mm bi"><span id="b655" class="kl km iq mj b gy mn mo l mp mq"># preprocessing using 0-1 scaling<br/>from sklearn.preprocessing import MinMaxScaler</span><span id="64f7" class="kl km iq mj b gy nf mo l mp mq">scaler = MinMaxScaler()<br/>scaler.fit(X_train)</span><span id="3bab" class="kl km iq mj b gy nf mo l mp mq">X_train_scaled = scaler.transform(X_train)<br/>X_test_scaled = scaler.transform(X_test)</span><span id="8b0f" class="kl km iq mj b gy nf mo l mp mq"># learning an SVM on the scaled training data<br/>svm.fit(X_train_scaled, y_train)</span><span id="07b2" class="kl km iq mj b gy nf mo l mp mq"># checking accuracy for classifier<br/>print("Test set accuracy: {:.2f}".format(svm.score(X_test_scaled, y_test)))</span><span id="bc21" class="kl km iq mj b gy nf mo l mp mq">&gt;&gt;&gt;&gt;&gt; Test set accuracy: 0.97</span></pre><p id="e591" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据精度结果，我们可以看出，缩放数据的影响非常显著。</p><blockquote class="mc md me"><p id="c608" class="jn jo ma jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated"><strong class="jp ir">结论</strong></p></blockquote><p id="eda4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于许多机器学习方法来说，数据转换是非常重要的。最适合应用的特征归一化类型取决于数据集、学习任务和要使用的学习算法。没有硬性的规则告诉我们什么时候对数据进行规范化或标准化。最好先将模型与原始数据、标准化数据和规范化数据进行拟合，然后比较性能以获得最佳结果。</p></div></div>    
</body>
</html>