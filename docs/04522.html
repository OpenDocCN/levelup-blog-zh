<html>
<head>
<title>Implement MVVM in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SwiftUI中实施MVVM</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implement-mvvm-in-swiftui-47f76dc28f1a?source=collection_archive---------9-----------------------#2020-06-30">https://levelup.gitconnected.com/implement-mvvm-in-swiftui-47f76dc28f1a?source=collection_archive---------9-----------------------#2020-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/e26941ec6560fd1c44c4fa972ec0e359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9-DI1vMGITMp0Fjot7SPaQ.png"/></div></div></figure><div class=""/><p id="7d8a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">软件架构是开发者的强大武器。</p><p id="edd6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在iOS开发中，SwiftUI出现之前，Cocoa MVC在大多数情况下是最适合的软件架构。(如果你想了解可可MVC，参考我的另一篇<a class="ae kz" href="https://dev.to/kazuooooo/get-hands-on-with-the-cocoa-mvc-pattern-2fg3" rel="noopener ugc nofollow" target="_blank">文章</a>)</p><p id="eaf6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是现在，SwiftUI中的EnvironmentObject的数据绑定特性允许轻松实现MVVM架构。所以我认为MVVM已经成为iOS应用(Swift UI)开发中的标准软件架构。</p><p id="40ff" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将描述什么是MVVM，以及如何通过创建一个简单的计数器应用程序在Swift UI中实现MVVM。</p><p id="f65a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅仅通过阅读很难在实际应用中使用软件架构。</p><p id="4f6c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，让我们自己来实现，用心去了解mvvm</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="2109" class="lh li je bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">什么是MVVM？</h1><p id="9518" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">MVVM是约翰·戈斯曼在2005年发明的一种软件架构。</p><p id="6a1a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">MVVM有三个组成部分<strong class="kd jf">M</strong>odel-<strong class="kd jf">V</strong>view-<strong class="kd jf">V</strong>view<strong class="kd jf">M</strong>odel</p><p id="824e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，视图和视图模型通过数据绑定连接，以共享视图模型状态。</p><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mk"><img src="../Images/ccf8c2a13b1f48dd640dde6cd71b4c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ik3gktGrn6zatPZ1R5hjw.png"/></div></div></figure><h2 id="d1ff" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">模型</h2><p id="da9f" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">模型具有与UI无关的域逻辑及其数据。模型与MVC、MVP等其他软件架构中的模型是一样的。</p><p id="1bff" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，访问数据库、控制设备、计算价格等——所有与UI无关的逻辑都包含在模型中</p><p id="830f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重要的是，模型完全独立于视图和视图模型，它必须能够单独构建。</p><h2 id="51c3" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">视角</h2><p id="cd9c" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">视图是接受用户输入并呈现用户界面以供显示的组件。视图有一个状态<strong class="kd jf">使用数据绑定</strong>与视图模型状态连接，并在视图模型状态因用户输入而改变时更新其视图。</p><h2 id="4506" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">视图模型</h2><p id="76dc" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">ViewModel充当了模型和视图之间的桥梁。</p><p id="cfab" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ViewModel有三个职责</p><ul class=""><li id="f97f" class="nb nc je kd b ke kf ki kj km nd kq ne ku nf ky ng nh ni nj bi translated">为视图存储数据。</li><li id="cf5f" class="nb nc je kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated">接受来自视图的事件并调用模型函数。</li><li id="5118" class="nb nc je kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated">接受来自视图的事件并更新状态。然后视图状态通过数据绑定自动更新。</li></ul><p id="1c87" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用这些组件，MVVM的基本数据流程图如下。</p><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/64354df69d12bec90652600cc2b97827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOyr_kNrFOKdDoythEYdvg.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">MVVM的基本流程</figcaption></figure><ol class=""><li id="1a27" class="nb nc je kd b ke kf ki kj km nd kq ne ku nf ky nu nh ni nj bi translated">视图接受用户输入。</li><li id="e303" class="nb nc je kd b ke nk ki nl km nm kq nn ku no ky nu nh ni nj bi translated">视图将用户输入传递给视图模型。</li><li id="cc78" class="nb nc je kd b ke nk ki nl km nm kq nn ku no ky nu nh ni nj bi translated">ViewModel调用模型函数处理数据。</li><li id="7dfa" class="nb nc je kd b ke nk ki nl km nm kq nn ku no ky nu nh ni nj bi translated">模型执行一些业务逻辑。</li><li id="ac7b" class="nb nc je kd b ke nk ki nl km nm kq nn ku no ky nu nh ni nj bi translated">模型将函数的结果返回给视图模型。</li><li id="bff5" class="nb nc je kd b ke nk ki nl km nm kq nn ku no ky nu nh ni nj bi translated">ViewModel用结果更新其状态。</li><li id="14d9" class="nb nc je kd b ke nk ki nl km nm kq nn ku no ky nu nh ni nj bi translated">视图模型状态通过数据绑定传播到视图。</li><li id="8bd9" class="nb nc je kd b ke nk ki nl km nm kq nn ku no ky nu nh ni nj bi translated">视图将更新的视图模型状态反映到它的视图中。</li></ol><p id="dd04" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">耶！我们快速浏览了一下MVVM。</p><p id="a4d9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没关系，如果你还不明白。<br/>我们将在自己实施MVVM后再次回顾此流程。</p><p id="27c8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们在下一章使用MVVM创建一个简单的应用程序。</p><h1 id="5de8" class="lh li je bd lj lk nv lm ln lo nw lq lr ls nx lu lv lw ny ly lz ma nz mc md me bi translated">在MVVM实施简单的柜台应用程序</h1><p id="5132" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">我们将创建如下非常简单的计数器应用程序。</p><p id="defb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用户可以通过点击加减按钮来上下计数。</p><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8d8e500070ae6905bee58bb8c1d71838.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/1*GvdQRr1pzv-mFvE1DRVtpw.gif"/></div></figure><p id="848c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经准备好包括开始和完成应用程序的存储库。您可以从Starter目录开始，也可以自己创建新项目。</p><p id="7d23" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://github.com/kazuooooo/SwiftUIMVVMFromScratch" rel="noopener ugc nofollow" target="_blank">https://github.com/kazuooooo/SwiftUIMVVMFromScratch</a></p><h2 id="b97c" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">反模型</h2><p id="b072" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">首先，我们实现了MVVM的M，反模型。</p><p id="7654" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它具有非常简单的业务逻辑，从参数中增加和减少值。</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="4ab3" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">对抗模型</h2><p id="aad7" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">其次，实现MVVM VM，对抗模型。</p><p id="6088" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">反视图模型有三个职责</p><ul class=""><li id="ee68" class="nb nc je kd b ke kf ki kj km nd kq ne ku nf ky ng nh ni nj bi translated">存储计数(存储数据以供查看。)</li><li id="69dd" class="nb nc je kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated">具有视图的向上计数和向下计数方法(从视图接受事件)</li><li id="bcd3" class="nb nc je kd b ke nk ki nl km nm kq nn ku no ky ng nh ni nj bi translated">调用CounterModel方法来递增和递减计数，并用返回值更新其计数(调用模型方法并更新其状态)</li></ul><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="7616" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">反对意见</h2><p id="be04" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">最后，实施MVVM V，提出对策。</p><p id="8511" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查看代码也很简单。<br/>请注意，视图具有使用EnvironmentObject的CounterViewModel对象。环境对象允许结构使用与可观察对象的数据绑定。</p><p id="4f82" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="od"> (️NOTE:只想着这个简单的应用，你最好用@ObservedObject。但这段代码旨在用简单的代码解释如何在一个嵌套视图更深、更复杂的应用程序中实现MVVM。所以，我这里用@EnvironmentObject。谢谢</em>@梵持M <em class="od"> ) </em></p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="cb36" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅此而已！请检查计数器是否正常工作</p><h1 id="714c" class="lh li je bd lj lk nv lm ln lo nw lq lr ls nx lu lv lw ny ly lz ma nz mc md me bi translated">查看带源代码的MVVM流程</h1><p id="7ed9" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">最后，让我们用刚刚编写的源代码来回顾一下MVVM数据流！<br/>通过重新回顾实现后的流程，我们可以比仅仅写代码更深刻地理解MVVM。</p><h2 id="17d1" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">1.查看接受用户输入</h2><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/ff1c6da7042eab6eb0298693bc43f00e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJC3ivEFwDiDBTbmPVXl1Q.png"/></div></div></figure><p id="2b0b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过+和-按钮接受用户输入</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="9c07" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">2.视图将用户输入传递给视图模型</h2><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/aee4082e8a7b3d0de312ff893a50a8f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJJfZcn_ImjYpzqpMkfesA.png"/></div></div></figure><p id="96ba" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">视图调用视图模型向上计数方法。</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="7fd4" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">3.ViewModel调用模型函数处理数据。</h2><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/0d21f4ec99985cc01289062f413235d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DXCcvrWQcMqppiwkpD-BQ.png"/></div></div></figure><p id="dfaf" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CounterViewModel调用CounterModel increment方法，将当前计数作为参数。</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="7cd6" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">4.模型执行一些业务逻辑</h2><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/8d4ca80fa8b19c7c09325adf5e0ec278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LaVXKVvR1QGvXtjbiZL7wQ.png"/></div></div></figure><p id="99b9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">CounterModel将计数增加到ViewModel中的参数计数。</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="379f" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">5.模型将函数的结果返回给视图模型。</h2><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/8ce41b5abf2030a0f98bf9fb73ef3d97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLuDmNHnFtumal5_rKd7yw.png"/></div></div></figure><p id="2acd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后Model将结果返回给ViewModel。</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="4a80" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">6.ViewModel用结果更新其状态。</h2><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/55bda6b5dbcf24c55ee232af0e39da49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IhzXBXANqj9c1o8_ILmmfw.png"/></div></div></figure><p id="063b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">计数器视图模型接收结果并更新其计数</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="2b08" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">7.视图模型状态通过数据绑定传播到视图</h2><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/36c5f97115b4992b957e0f5e756e04c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1c-puTP_3vJLuWN4UlEBA.png"/></div></div></figure><p id="cb23" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在ViewModel值更改时，更新的计数值会通过环境对象数据绑定立即传播到CounterView。</p><p id="bddd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">(此处无代码)</p><h2 id="fec2" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">8.视图将更新的视图模型状态反映到它的视图中。</h2><figure class="ml mm mn mo gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/0233c993bb0b94259dd8e615c93534d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UBttZu_BV87sCChogPd4Jw.png"/></div></div></figure><p id="8eb5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，视图将更新后的计数呈现给标签。</p><figure class="ml mm mn mo gt iv"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h2 id="b00c" class="mp li je bd lj mq mr dn ln ms mt dp lr km mu mv lv kq mw mx lz ku my mz md na bi translated">摘要</h2><p id="726f" class="pw-post-body-paragraph kb kc je kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">MVVM架构必须是SwiftUI iOS应用开发的强大工具。值得花时间去学习！<br/>感谢阅读！</p></div></div>    
</body>
</html>