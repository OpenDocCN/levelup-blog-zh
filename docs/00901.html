<html>
<head>
<title>React Lazy — Optimizing Bundle Size</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应迟缓—优化包大小</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-lazy-optimizing-bundle-size-fd82f4de2382?source=collection_archive---------3-----------------------#2019-09-09">https://levelup.gitconnected.com/react-lazy-optimizing-bundle-size-fd82f4de2382?source=collection_archive---------3-----------------------#2019-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="95b8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">根据应用程序路由动态加载代码块，以减少包的大小并提高性能。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c0f6972267cc7f5660e70184220fcf7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPd8h3sK5u48Qlf9Eg0gTw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用React Lazy &amp;悬念减少包的大小。</figcaption></figure></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="65b0" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">为什么</h1><p id="7495" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">不断有新的页面被添加到你的应用程序中，这导致了代码库的新增加，如组件、容器等。随着越来越多的组件被添加到您的应用程序中，很明显，最终捆绑包的大小可能会增加，达到开始影响应用程序性能的程度。包越大，浏览器加载网页的时间就越长。因此，优化包的大小是一个重要的话题。</p></div><div class="ab cl kv kw hu kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ij ik il im in"><h1 id="a400" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">怎么做</h1><p id="bcfc" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">React懒惰和悬念是一个强大的工具，帮助您实现我们所要求的优化。它的工作原理是，当你的应用程序需要组件时，动态地获取组件，而不是在一开始就将它们添加到浏览器拉取的主包中。</p><blockquote class="mq mr ms"><p id="6e52" class="lu lv mt lw b lx mu jr lz ma mv ju mc mw mx mf mg my mz mj mk na nb mn mo mp ij bi translated">文档链接:<a class="ae nc" href="https://reactjs.org/docs/code-splitting.html#reactlazy" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/code-splitting.html#reactlazy.</a></p></blockquote><p id="82f0" class="pw-post-body-paragraph lu lv iq lw b lx mu jr lz ma mv ju mc md mx mf mg mh mz mj mk ml nb mn mo mp ij bi translated">决定什么应该动态加载，什么应该作为核心包的一部分，对于每个应用程序来说都是非常具体的。此外，在这种情况下，将应用程序分解为非常精细的粒度来动态加载很可能不是最佳解决方案，因为每次延迟加载都意味着浏览器调用获取所需的内容。</p><p id="69d9" class="pw-post-body-paragraph lu lv iq lw b lx mu jr lz ma mv ju mc md mx mf mg mh mz mj mk ml nb mn mo mp ij bi translated">请记住，根据应用程序的路径划分代码块可能是一个有用的解决方案。让我们试一试。</p><h2 id="2349" class="nd ld iq bd le ne nf dn li ng nh dp lm md ni nj lo mh nk nl lq ml nm nn ls no bi translated">基于路由动态加载内容</h2><p id="1150" class="pw-post-body-paragraph lu lv iq lw b lx ly jr lz ma mb ju mc md me mf mg mh mi mj mk ml mm mn mo mp ij bi translated">让我们以一个相当常见的应用程序设计为例，它包含以下页面:</p><p id="0cd8" class="pw-post-body-paragraph lu lv iq lw b lx mu jr lz ma mv ju mc md mx mf mg mh mz mj mk ml nb mn mo mp ij bi translated">主页|关于我们|服务</p><p id="25df" class="pw-post-body-paragraph lu lv iq lw b lx mu jr lz ma mv ju mc md mx mf mg mh mz mj mk ml nb mn mo mp ij bi translated">假设单独的容器负责处理这些路线是安全的。那么，当用户登陆“主页”时，我们为什么需要将特定于“服务”页面的内容添加到捆绑包中呢？因此，惰性加载路径可以产生一种非常有效的代码分割解决方案。</p><p id="f57c" class="pw-post-body-paragraph lu lv iq lw b lx mu jr lz ma mv ju mc md mx mf mg mh mz mj mk ml nb mn mo mp ij bi translated">让我们为我们的应用程序实现React Lazy和悬念。</p><h2 id="15fd" class="nd ld iq bd le ne nf dn li ng nh dp lm md ni nj lo mh nk nl lq ml nm nn ls no bi translated">LazyLoader.js</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/903ec1af6b953ce0d05baacc925e4ef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YyaOCmeSxR5IGcz-CqXSoQ.png"/></div></div></figure><p id="1961" class="pw-post-body-paragraph lu lv iq lw b lx mu jr lz ma mv ju mc md mx mf mg mh mz mj mk ml nb mn mo mp ij bi translated">App.js</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/fbf4cdf9c6c1456f4a58ea5fe9a3d8bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gKKNCnA85uGxMnlUWPpfXg.png"/></div></div></figure><p id="6e91" class="pw-post-body-paragraph lu lv iq lw b lx mu jr lz ma mv ju mc md mx mf mg mh mz mj mk ml nb mn mo mp ij bi translated">这将最终导致为每条路线创建单独的块，而不是有一个单一的沉重的捆绑文件，让您进一步提高应用程序的性能。</p></div></div>    
</body>
</html>