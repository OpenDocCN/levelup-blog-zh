<html>
<head>
<title>JavaScript Object Features in TypeScript — Inheritance and Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的JavaScript对象特性—继承和类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-object-features-in-typescript-inheritance-and-classes-5fff7f1bcdb7?source=collection_archive---------15-----------------------#2020-06-09">https://levelup.gitconnected.com/javascript-object-features-in-typescript-inheritance-and-classes-5fff7f1bcdb7?source=collection_archive---------15-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ae08fba795912177f9b26eac4ee667da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uy99ZN0RIWR4qHUN"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">布鲁克·拉克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e84e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript是JavaScript的自然扩展，在许多项目中取代了JavaScript。</p><p id="cc57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，并不是每个人都知道它实际上是如何工作的。</p><p id="5d91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究访问被覆盖的原型方法和类语法。</p><h1 id="8c21" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">访问重写的原型方法</h1><p id="d984" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">即使我们在从父构造函数继承的构造函数中重写方法，我们仍然可以访问父构造函数对构造函数的实现。</p><p id="f788" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3399" class="mq lf it mm b gy mr ms l mt mu">const Animal = function(name) {<br/>  this.name = name;<br/>};<br/>Animal.prototype.toString = function() {<br/>  return `name: ${this.name}`;<br/>};</span><span id="aa32" class="mq lf it mm b gy mv ms l mt mu">const Dog = function(name, breed) {<br/>  Animal.call(this, name);<br/>  this.breed = breed;<br/>};<br/>Object.setPrototypeOf(Dog.prototype, Animal.prototype);<br/>Dog.prototype.toString = function() {<br/>  return `name: ${this.name}, breed: ${this.breed}`;<br/>};</span></pre><p id="d6c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以调用父构造函数的方法来替换<code class="fe mw mx my mm b">Dog</code>的原型的<code class="fe mw mx my mm b">toString</code>方法的一部分，编写如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="00a9" class="mq lf it mm b gy mr ms l mt mu">const Animal = function(name) {<br/>  this.name = name;<br/>};</span><span id="cabc" class="mq lf it mm b gy mv ms l mt mu">Animal.prototype.toString = function() {<br/>  return `name: ${this.name}`;<br/>};</span><span id="cc97" class="mq lf it mm b gy mv ms l mt mu">const Dog = function(name, breed) {<br/>  Animal.call(this, name);<br/>  this.breed = breed;<br/>};</span><span id="9028" class="mq lf it mm b gy mv ms l mt mu">Object.setPrototypeOf(Dog.prototype, Animal.prototype);</span><span id="3542" class="mq lf it mm b gy mv ms l mt mu">Dog.prototype.toString = function() {<br/>  const name = Animal.prototype.toString.call(this, this.name);<br/>  return `${name}, breed: ${this.breed}`;<br/>};</span></pre><p id="6178" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们重用了<code class="fe mw mx my mm b">Animal.prototype</code>的<code class="fe mw mx my mm b">toString</code>方法，形成了<code class="fe mw mx my mm b">Dog.prototype</code>的<code class="fe mw mx my mm b">toString</code>方法的一部分。</p><p id="ff5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们就不用重复任何代码了。</p><h1 id="b70d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">定义静态属性和方法</h1><p id="7745" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以将静态方法和属性定义为函数本身的属性。</p><p id="4dbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以这样做，因为函数只是普通的对象。</p><p id="6734" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5a59" class="mq lf it mm b gy mr ms l mt mu">const Animal = function(name) {<br/>  this.name = name;<br/>};<br/>Animal.type = 'animal';</span><span id="d20b" class="mq lf it mm b gy mv ms l mt mu">console.log(Animal.type);</span></pre><p id="a241" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们在<code class="fe mw mx my mm b">Animal</code>上定义了一个静态的<code class="fe mw mx my mm b">type</code>属性。</p><p id="6033" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过引用<code class="fe mw mx my mm b">Animal.type</code>来访问它。</p><h1 id="f6b9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JavaScript类</h1><p id="ab87" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript class是一种语法，可以简化从其他流行编程语言的转换。</p><p id="3207" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在幕后，它只是构造函数和原型的组合。</p><p id="4443" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript类和其他基于类的语言(如Java)有一些不同。</p><p id="0f88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有实例变量都是公共的。</p><p id="82f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以在<code class="fe mw mx my mm b">constructor</code>中返回任何我们想要的对象，当我们用<code class="fe mw mx my mm b">new</code>调用类时，我们返回那个对象。</p><p id="1e90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像构造函数一样，它是用关键字<code class="fe mw mx my mm b">new</code>调用的。</p><p id="36ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以这样定义一个类:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="411d" class="mq lf it mm b gy mr ms l mt mu">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="b40e" class="mq lf it mm b gy mv ms l mt mu">  toString() {<br/>    return `name: ${this.name}`;<br/>  }<br/>}</span></pre><p id="b91f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个<code class="fe mw mx my mm b">Animal</code>构造函数，它返回一个<code class="fe mw mx my mm b">Animal</code>实例，带有<code class="fe mw mx my mm b">name</code>属性和<code class="fe mw mx my mm b">toString</code>方法。</p><p id="bbd4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果我们通过编写以下内容来创建一个<code class="fe mw mx my mm b">Animal</code>实例:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="674b" class="mq lf it mm b gy mr ms l mt mu">const animal = new Animal('joe');</span></pre><p id="b92b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们查看<code class="fe mw mx my mm b">animal</code>的内容，我们会看到<code class="fe mw mx my mm b">animal</code>中的<code class="fe mw mx my mm b">name</code>属性。</p><p id="6528" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在它的<code class="fe mw mx my mm b">__proto__</code>属性中，我们看到了<code class="fe mw mx my mm b">toString</code>方法。</p><p id="1b4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了创建一个继承自父类的子类，我们使用了<code class="fe mw mx my mm b">extends</code>关键字。</p><p id="60cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="31f9" class="mq lf it mm b gy mr ms l mt mu">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="7089" class="mq lf it mm b gy mv ms l mt mu">  toString() {<br/>    return `name: ${this.name}`;<br/>  }<br/>}</span><span id="a0a8" class="mq lf it mm b gy mv ms l mt mu">class Dog extends Animal {}</span></pre><p id="c07c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建了一个继承自<code class="fe mw mx my mm b">Animal</code>父类的<code class="fe mw mx my mm b">Animal</code>子类。</p><p id="a4d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们写下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9f87" class="mq lf it mm b gy mr ms l mt mu">const dog = new Dog('joe');</span></pre><p id="0317" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并调用<code class="fe mw mx my mm b">toString</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b4f1" class="mq lf it mm b gy mr ms l mt mu">console.log(dog.toString());</span></pre><p id="356b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c6e8" class="mq lf it mm b gy mr ms l mt mu">name: joe</span></pre><p id="6da3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从控制台日志中。</p><p id="c558" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">toString</code>方法继承自<code class="fe mw mx my mm b">Animal</code>类。</p><p id="2f8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了调用父构造函数，我们使用了<code class="fe mw mx my mm b">super</code>关键字。</p><p id="60fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想调用父构造函数的方法，我们使用相同的关键字，后跟一个点和方法名。</p><p id="3ceb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想给<code class="fe mw mx my mm b">Dog</code>添加一个构造函数和一个<code class="fe mw mx my mm b">toString</code>方法，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4a6c" class="mq lf it mm b gy mr ms l mt mu">class Dog extends Animal {<br/>  constructor(name, breed) {<br/>    super(name);<br/>    this.breed = breed;<br/>  }</span><span id="aa2a" class="mq lf it mm b gy mv ms l mt mu">  toString() {<br/>    const name = super.toString();<br/>    return `${name} breed: ${this.breed}`;<br/>  }<br/>}</span></pre><p id="562d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">给定我们之前拥有的<code class="fe mw mx my mm b">Animal</code>类，我们可以通过编写调用<code class="fe mw mx my mm b">super.toString();</code>来调用<code class="fe mw mx my mm b">Animal</code>的<code class="fe mw mx my mm b">toString</code>。</p><p id="58ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们像在<code class="fe mw mx my mm b">Dog</code>的<code class="fe mw mx my mm b">constructor</code>中一样，通过使用<code class="fe mw mx my mm b">super</code>关键字来调用父节点的<code class="fe mw mx my mm b">constructor</code>。</p><p id="2c20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在构造函数体中，<code class="fe mw mx my mm b">super</code>调用必须在其他任何东西之前。</p><p id="b805" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关键字<code class="fe mw mx my mm b">extends</code>表明我们的<code class="fe mw mx my mm b">Dog</code>类继承了<code class="fe mw mx my mm b">Animal</code>类的成员。</p><p id="19f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，当我们通过编写以下代码创建一个新的<code class="fe mw mx my mm b">Dog</code>实例时:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8540" class="mq lf it mm b gy mr ms l mt mu">const dog = new Dog('joe', 'lab');<br/>console.log(dog.toString());</span></pre><p id="7945" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在上面调用<code class="fe mw mx my mm b">toString</code>，我们得到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9102" class="mq lf it mm b gy mr ms l mt mu">name: joe breed: lab</span></pre><p id="4ddb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从控制台日志中。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/adc8aea25ca0ef7f1ca7b333dfa6893c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l_hF-yVqMBXzj_0x"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@danielcgold?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹金</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="8d51" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="0555" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">类语法使得从其他面向对象语言的转换更加容易。</p><p id="3e9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它通过将构造函数代码放在一个整洁的包中来清理它们。</p><p id="95c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以用更简洁的方式调用父构造函数。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><div class="mh mi mj mk gt nh"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">编写面试问题</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">技术开发</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv jz nh"/></div></div></a></div></div></div>    
</body>
</html>