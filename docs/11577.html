<html>
<head>
<title>SOLID programming for Arduino: The Dependency Inversion Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Arduino的实体编程:依赖倒置原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solid-programming-for-arduino-the-dependency-inversion-principle-4ce3bdb787d1?source=collection_archive---------12-----------------------#2022-03-28">https://levelup.gitconnected.com/solid-programming-for-arduino-the-dependency-inversion-principle-4ce3bdb787d1?source=collection_archive---------12-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f0e435aa19596e9f0aa34582a30b90d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUtSx8-gdvIreENjRcvt7w.png"/></div></div></figure><div class=""/><div class=""><h2 id="cdea" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">面向对象程序设计在业余嵌入式系统中的应用。</h2></div><p id="d231" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi lm translated">如今，越来越多的人坚信，将有意识的软件开发实践应用到微控制器编程中即使不是有害的，也是很困难的。</p><p id="58c3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">首先，<a class="ae lv" href="https://en.wikipedia.org/wiki/Object-oriented_programming#:~:text=Object%2Doriented%20programming%20(OOP),(often%20known%20as%20methods)." rel="noopener ugc nofollow" target="_blank"> OOP(面向对象编程)</a>可能成本很高:使用抽象是简单性和效率的折中。此外，不必要的抽象可能会导致代码更加复杂！</p><p id="8857" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最后但并非最不重要的一点是，我们还必须考虑到，并不是每个摆弄Arduino兼容微控制器的人都有很强的电子、信息学或STEM背景。由于这个原因，当他们看到更高级的开发技术时，可能会感到有点害怕。</p><h2 id="79ba" class="lw lx jb bd ly lz ma dn mb mc md dp me kz mf mg mh ld mi mj mk lh ml mm mn mo bi translated"><em class="mp">今天我将为你提供一个有用的、易于遵循的经验法则，让你的Arduino相关代码在不同平台之间更加灵活和可移植。</em></h2></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="a70e" class="mx lx jb bd ly my mz na mb nb nc nd me kh ne ki mh kk nf kl mk kn ng ko mn nh bi translated">ase研究</h1><p id="7b0a" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi lm translated">几个月前，我不得不在我们的一个嵌入式项目中进行距离测量。在最初的步骤中，我认为一个普通的<em class="nn"> HCSR04 </em>就足以满足我们的需求。</p><p id="a1af" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然而，深入研究领域概念，我意识到我们需要一个防水解决方案，显然简单的HCSR04不再能解决我们的问题。</p><figure class="np nq nr ns gt is gh gi paragraph-image"><div class="gh gi no"><img src="../Images/fcabbee3396c0ef45cd7b280eb4e8987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*YKC0CIIquHgnztEapOW41Q.jpeg"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">HC-SR04超声波传感器</figcaption></figure><p id="cc66" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">几天后，我们换上了ST<a class="ae lv" href="https://www.st.com/content/st_com/en.html" rel="noopener ugc nofollow" target="_blank">和</a>生产的激光飞行时间(ToF)传感器，使用别人生产的Arduino库草拟了一些代码让它工作，一切都很顺利。</p><p id="efda" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">不用说，当我开始将传感器API集成到我们的定制固件中时，事情变得更加复杂:我在网上找到的库与并发代码不兼容，我利用了很多并发代码，因为我使用的是FreeRTOS。</p><p id="78b5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">此外，由于传感器寄存器映射太难处理，ST提供了一个用C编写的API来与设备交互。你所要做的就是把一个低级驱动程序和ST库连接起来，祈祷，希望一切都像预期的那样工作。</p><p id="0acf" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但是这有什么意义呢？</p><h2 id="b2f8" class="lw lx jb bd ly lz ma dn mb mc md dp me kz mf mg mh ld mi mj mk lh ml mm mn mo bi translated">这里的焦点是清晰易懂的代码:我们的整个应用程序应该关心不同类型的距离传感器吗？我会说不</h2><h2 id="029a" class="lw lx jb bd ly lz ma dn mb mc md dp me kz mf mg mh ld mi mj mk lh ml mm mn mo bi translated">相反，我们应该利用已经确立的原则，比如<a class="ae lv" href="https://deviq.com/principles/dependency-inversion-principle" rel="noopener ugc nofollow" target="_blank">依赖倒置原则</a>:我不会在这里复制和粘贴定义，但是让我用我们的案例研究来重申一下。</h2></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="6749" class="mx lx jb bd ly my mz na mb nb nc nd me kh ne ki mh kk nf kl mk kn ng ko mn nh bi translated"><span class="l ln lo lp bm lq lr ls lt lu di"> S </span>系统建模</h1><p id="6de9" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di"> S </span>假设您有一个C/C++模块，它必须与st传感器交互以执行读取，然后将结果发送到HTTP端点。对于那些熟悉<a class="ae lv" href="https://en.wikipedia.org/wiki/Unified_Modeling_Language" rel="noopener ugc nofollow" target="_blank">统一建模语言(UML) </a>的人来说，依赖关系可以用下面的类图来表示。</p><figure class="np nq nr ns gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/af1c91187474f90fd97d0124b37b8463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TpttQifM_gnM6TIFHAlrLg.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">我们最初的模型</figcaption></figure><p id="447b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">基本上，图表代表这段代码:</p><figure class="np nq nr ns gt is gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/2b882bfd5b24c17a2d7ed76cd00d9293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*ClJDIjJ7OFScDFAXWr_V5A.png"/></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">我们初始模型的(简化)代码</figcaption></figure><p id="69a1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这里的主要问题是，DomainTask中的每一段代码都可能容易受到ST_DistanceSensor中的更改的影响，这可能是一个正在开发中的自定义类！</p><h2 id="099d" class="lw lx jb bd ly lz ma dn mb mc md dp me kz mf mg mh ld mi mj mk lh ml mm mn mo bi translated">代码没有清楚地表明DomainTask唯一感兴趣的是<em class="mp">获得距离测量的方式</em>:据我们所知，这可能像读取常量变量一样简单，也可能像发射航天飞机一样困难！</h2><p id="51ba" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi translated">使用DIP的一个可能的解决方案是将前面的类图转换成下面的这个:</p><figure class="np nq nr ns gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/52b6cff944d60b612e072917cd39fc8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXjSpr1gJ49rXs2D1LJOZg.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">我们的精致模型</figcaption></figure><p id="1471" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这里，DistanceSensor代表<em class="nn">“一种获得距离测量的方法”。<br/> </em>代码方面，会是一个抽象类，没有具体的方法。<br/>是的，我说的是和Java/C#接口一模一样的东西！</p><p id="6674" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因为DistanceSensor接口不包含可执行代码，所以让其他模块依赖它并不容易。<br/>此外，具体的类可以实现我们的抽象所要求的行为，我们的系统将感觉更像一个干净、可理解的即插即用架构:为了说明这一点，我已经展示了如何通过添加一个实现抽象传感器的新类来表达HC-SR04传感器。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="cad9" class="mx lx jb bd ly my mz na mb nb nc nd me kh ne ki mh kk nf kl mk kn ng ko mn nh bi translated">包扎</h1><p id="ba6e" class="pw-post-body-paragraph kq kr jb ks b kt ni kc kv kw nj kf ky kz nk lb lc ld nl lf lg lh nm lj lk ll ij bi lm translated"><span class="l ln lo lp bm lq lr ls lt lu di">总而言之，每当你觉得你的代码被不明显和不合理的依赖所纠缠，考虑声明一个额外的类(即接口)，它表示您的系统模块必须满足才能与您的应用程序域兼容的协定。</span></p><p id="8757" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">非常感谢您的关注，我希望这篇文章对您的需求有用。关于进一步的细节，我真的向你推荐这本由罗伯特·c·马丁也就是鲍勃叔叔写的很棒的书。</p></div></div>    
</body>
</html>