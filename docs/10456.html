<html>
<head>
<title>API developers, stay away from the blame game when things go south</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">API开发者，当事情变糟时，远离指责游戏</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/api-developers-stay-away-from-the-blame-game-when-things-go-south-d175bca5cfd0?source=collection_archive---------11-----------------------#2021-12-07">https://levelup.gitconnected.com/api-developers-stay-away-from-the-blame-game-when-things-go-south-d175bca5cfd0?source=collection_archive---------11-----------------------#2021-12-07</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="6abb" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">设计API时的一些好的实践</h2><div class=""/><p id="5ed2" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">当事情不像预期的那样运行时，正确地记录日志以保持冷静和自信</p><figure class="kz la lb lc gu ld gi gj paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gi gj ky"><img src="../Images/eef93b9b51ef840d488d94ea86a64fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fk8U3EXzU4lreReP1fUQhA.jpeg"/></div></div></figure><p id="6a9e" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">API开发者和服务所有者，我们都遇到过这种情况。为了让我们的消费者满意，我们在开发时将血汗投入到代码中。</p><p id="28a7" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">但是，当事情不奏效时，人们会感到害怕，并开始相互指责。如果我们能在发展我们的服务时采取一些措施，我们就能轻松地通过这些指责游戏，并能放松下来。</p><p id="b423" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">当错误已经发生时，日志记录是调试中非常重要的一个方面。</p><p id="ad68" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">今天在这篇文章中，我将讨论一些记录日志的方法，特别是为了保持不被追究而记录什么。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h1 id="2375" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">追踪的重要性</h1><p id="d4a1" class="pw-post-body-paragraph ka kb iu kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx in bi translated">当我们构建一个服务时，它基本上是某种数据源，依赖于其他服务或者拥有自己的数据库。</p><blockquote class="mu"><p id="1791" class="mv mw iu bd mx my mz na nb nc nd kx dk translated">当我们依赖他人(他们的数据)并且我们无法控制他们的生命周期时，在需要的时候拥有证据总是一个好的做法，特别是当他们不合时宜并且试图将责任归咎于他人的时候。</p></blockquote><h1 id="31e4" class="lr ls iu bd lt lu ne lw lx ly nf ma mb mc ng me mf mg nh mi mj mk ni mm mn mo bi translated">分布式跟踪</h1><p id="67ab" class="pw-post-body-paragraph ka kb iu kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx in bi translated">分布式跟踪是一种我们可以在不同应用程序之间端到端跟踪数据流的方法。</p><div class="nj nk gq gs nl nm"><a href="https://opentracing.io/" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fp"><div class="no ab np cl cj nq"><h2 class="bd je gz z fq nr fs ft ns fv fx jd bi translated">OpenTracing项目</h2><div class="nt l"><h3 class="bd b gz z fq nr fs ft ns fv fx dk translated">本地启动Jaeger $ docker run-d-p 6831:6831/UDP-p 16686:16686 Jaeger tracing/all-in-one:最新$ export…</h3></div><div class="nu l"><p class="bd b dl z fq nr fs ft ns fv fx dk translated">opentracing.io</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa li nm"/></div></div></a></div><p id="7f95" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">但是在所有应用程序中配置它们通常需要相当大的努力，并且该配置必须存在于所有应用程序中，以便所有中间应用程序将跟踪信息转发给下一个应用程序。</p><h1 id="8e44" class="lr ls iu bd lt lu ne lw lx ly nf ma mb mc ob me mf mg oc mi mj mk od mm mn mo bi translated">跟踪日志记录</h1><p id="3b46" class="pw-post-body-paragraph ka kb iu kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx in bi translated">如果我们没有时间和金钱在所有的应用程序堆栈中实现分布式跟踪，我们可以通过添加一个简单的跟踪日志来实现不负责任(当我们实际上是时)或快速知道问题(当我们实际上是错误的来源时)并采取行动。</p><p id="ce73" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">我们将放置一个模式来记录相关数据，并且只记录搜索工具所需要的内容以<strong class="kc je">节省空间</strong>和<strong class="kc je">索引时间</strong>，搜索工具将扫描日志。</p><blockquote class="mu"><p id="2853" class="mv mw iu bd mx my mz na nb nc nd kx dk translated"><strong class="ak"> <em class="oe">这里的Schema基本上就是我们将日志记录在跟踪日志文件中的方式。这将是一个没有换行符和逗号分隔数据值的单行日志</em> </strong></p></blockquote><p id="efc8" class="pw-post-body-paragraph ka kb iu kc b kd of kf kg kh og kj kk kl oh kn ko kp oi kr ks kt oj kv kw kx in bi translated">例如，如果模式如下所示:</p><pre class="kz la lb lc gu ok ol om on aw oo bi"><span id="cd3a" class="op ls iu ol b gz oq or l os ot">TRACKING_ID, HOSTNAME, TIMESTAMP, RESPONSE_TIME, ACCOUNT_ID</span></pre><p id="8e5d" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">一个真实的跟踪日志数据将会是这样的:</p><pre class="kz la lb lc gu ok ol om on aw oo bi"><span id="a347" class="op ls iu ol b gz oq or l os ot">adef237-wkjh3j4h-218772, host-31a, 1638905687392, 300, 12891281928</span></pre><p id="665e" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">我们希望它们是单行的。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><blockquote class="mu"><p id="0907" class="mv mw iu bd mx my mz na nb nc nd kx dk translated">一旦调用完成，我们将进行日志记录，因此对于对我们应用程序的调用，我们将在发送响应之前进行日志记录。对于来自我们服务的后端调用，我们将在获得后端响应后立即记录。</p></blockquote><p id="cb9b" class="pw-post-body-paragraph ka kb iu kc b kd of kf kg kh og kj kk kl oh kn ko kp oi kr ks kt oj kv kw kx in bi translated">我们希望按照以下两种模式进行日志记录:</p><h2 id="1cd2" class="op ls iu bd lt ou ov dn lx ow ox dp mb kl oy oz mf kp pa pb mj kt pc pd mn ja bi translated">前端模式</h2><p id="2b47" class="pw-post-body-paragraph ka kb iu kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx in bi translated">这是日志的模式，当它到达我们的应用服务器时将记录调用。该日志模式日志将保存在<strong class="kc je">前端</strong>日志文件中。</p><pre class="kz la lb lc gu ok ol om on aw oo bi"><span id="3b21" class="op ls iu ol b gz oq or l os ot">TRACKING_ID, REMOTE_IP, HOSTNAME, TIMESTAMP, VERSION, RESPONSE_TIME, ACCOUNT_ID,... all other data comma separated</span></pre><p id="0f3f" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated"><strong class="kc je"> <em class="pe">分析</em> </strong>:</p><ul class=""><li id="3d2a" class="pf pg iu kc b kd ke kh ki kl ph kp pi kt pj kx pk pl pm pn bi translated">TRACKING_ID:这在所有调用中是唯一的，它可以由以前的应用程序转发(以便我们可以端到端地跟踪调用)。如果没有提供，我们将创建一个并发送给您</li><li id="57a2" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">REMOTE_IP:调用方的IP</li><li id="f5f0" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">主机名:我们的应用服务器的主机名</li><li id="d5c8" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">时间戳:呼叫的时间</li><li id="2bff" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">版本:我们的应用程序的版本，以了解新部署的应用程序是否有问题</li><li id="84b7" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">RESPONSE_TIME:调用在我们的服务器中花费的总时间</li><li id="9574" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">ACCOUNT_ID或<strong class="kc je">主数据元素</strong>:这应该是比呼叫中所有其他数据元素都重要的数据元素。例如，如果呼叫与帐户数据相关，则帐户是主要数据元素，如果呼叫需要地理定位，则纬度和经度是主要数据元素。</li></ul><h2 id="3387" class="op ls iu bd lt ou ov dn lx ow ox dp mb kl oy oz mf kp pa pb mj kt pc pd mn ja bi translated">后端模式</h2><p id="8cc6" class="pw-post-body-paragraph ka kb iu kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx in bi translated">这是从我们的服务器到我们所依赖的数据源的调用的跟踪日志的模式。该日志模式日志将保存在<strong class="kc je">后端</strong>日志文件中。</p><pre class="kz la lb lc gu ok ol om on aw oo bi"><span id="11da" class="op ls iu ol b gz oq or l os ot">TRACKING_ID, BACKEND_TRACKING_ID, TIMESTAMP, VERSION, ACCOUNT_ID, BACKEND_PRIMARY_DATA_ELEMENT, BACKEND_PRIMARY_RESPONSE_ELEMENT, BACKEND_RESPONSE_TIME, ... all other data</span></pre><p id="67fc" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated"><strong class="kc je"> <em class="pe">分析</em> </strong>:</p><ul class=""><li id="1741" class="pf pg iu kc b kd ke kh ki kl ph kp pi kt pj kx pk pl pm pn bi translated">TRACKING_ID:和以前一样，我们将把这个跟踪ID转发给我们从中获取数据的所有来源，并记录它。</li><li id="e5c1" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">BACKEND_TRACKING_ID:这将由我们的应用程序创建，对于我们调用的每个后端，我们将创建一个后端跟踪ID。所以会有<em class="pe">多</em><strong class="kc je"><em class="pe">back end _ TRACKING _ ID</em></strong><em class="pe">每</em><strong class="kc je"><em class="pe">TRACKING _ ID</em></strong></li><li id="dbb4" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">时间戳:呼叫的时间</li><li id="2e44" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">版本:我们的应用程序的版本，以了解新部署的应用程序是否有问题</li><li id="bbbd" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">RESPONSE_TIME:调用在我们的服务器中花费的总时间</li><li id="b5e0" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">ACCOUNT_ID或<strong class="kc je">主数据元</strong>:同上</li><li id="fa65" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">BACKEND_PRIMARY_DATA_ELEMENT:这是为了让后端调用知道向后端发送了什么，以便我们可以跟踪它。这可以通过一个以上的数据元素来实现</li><li id="c73a" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">back end _ PRIMARY _ RESPONSE _ ELEMENT:同上，但这是我们从那个响应中得到的。我可以是一个或多个。</li><li id="9eea" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pk pl pm pn bi translated">BACKEND_RESPONSE_TIME:服务或后端响应所花费的时间。</li></ul></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><h1 id="60ac" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">有用</h1><p id="a37a" class="pw-post-body-paragraph ka kb iu kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx in bi translated">现在我们已经正确设置了日志记录，让我们看看它是如何有用的:</p><h2 id="34d6" class="op ls iu bd lt ou ov dn lx ow ox dp mb kl oy oz mf kp pa pb mj kt pc pd mn ja bi translated">手动调试</h2><ol class=""><li id="9f48" class="pf pg iu kc b kd mp kh mq kl pt kp pu kt pv kx pw pl pm pn bi translated">一个调用来到我们的服务，我们处理它并调用一堆后端(db，api ),发送响应并记录在<strong class="kc je">前端</strong>日志文件中。</li><li id="2f67" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pw pl pm pn bi translated">在调用后端时，我们也将每个调用记录在<strong class="kc je">后端</strong>日志文件中。</li><li id="8061" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pw pl pm pn bi translated">此时，对于<strong class="kc je">前端</strong>日志的每一行，我们有多行<strong class="kc je">后端</strong>日志行，它们通过<strong class="kc je"> TRACKING_ID </strong>相互关联。</li><li id="733c" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pw pl pm pn bi translated">如果出现问题，涉众说我们的应用程序行为错误，发送了错误的数据，我们有适当的日志来支持。我们会询问呼叫的<strong class="kc je"> TRACKING_ID </strong>并跟踪我们的<strong class="kc je">前端</strong>和<strong class="kc je">后端</strong>日志文件中的所有日志，看看发生了什么以及我们返回了什么。</li><li id="1f6a" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pw pl pm pn bi translated">如果他们没有TRACKING_ID，我们会询问呼叫的主要数据元素，因为我们也记录了它，所以我们可以获得该呼叫的TRACKING_ID，并以类似的方式进行跟踪。</li><li id="8f00" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pw pl pm pn bi translated">此外，当我们在跟踪日志的同时记录后端数据元素时，我们将了解后端是否返回了错误的数据。</li><li id="2485" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pw pl pm pn bi translated">因为我们也记录了版本信息，我们也将了解一个问题是否源于我们的应用程序是因为新版本还是不是。</li></ol><h2 id="21f0" class="op ls iu bd lt ou ov dn lx ow ox dp mb kl oy oz mf kp pa pb mj kt pc pd mn ja bi translated">通过索引调试</h2><ol class=""><li id="9d00" class="pf pg iu kc b kd mp kh mq kl pt kp pu kt pv kx pw pl pm pn bi translated">由于日志文件是单行的并且有索引，我们可以很容易地使用日志跟踪工具如<strong class="kc je"> Splunk </strong>和<strong class="kc je"> Elastic Search </strong>等对其进行索引(通过逗号分隔。)</li><li id="1c6f" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pw pl pm pn bi translated">一旦建立索引，我们就可以根据数据得到很酷的图表，并对数据进行统计分析。</li><li id="6fee" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pw pl pm pn bi translated">我们甚至可以基于这些日志索引工具创建我们的应用程序仪表板，并将该仪表板发送给我们的利益相关者，以便他们也可以知道正在发生什么。</li><li id="ab9c" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pw pl pm pn bi translated">基于版本的图表对于检查我们部署的影响非常有用。</li><li id="055b" class="pf pg iu kc b kd po kh pp kl pq kp pr kt ps kx pw pl pm pn bi translated">如果我们想推出基于地理位置的功能，我们可以基于这些日志和版本信息创建图表并进行分析。</li></ol><h1 id="9136" class="lr ls iu bd lt lu ne lw lx ly nf ma mb mc ob me mf mg oc mi mj mk od mm mn mo bi translated">结论</h1><p id="5e91" class="pw-post-body-paragraph ka kb iu kc b kd mp kf kg kh mq kj kk kl mr kn ko kp ms kr ks kt mt kv kw kx in bi translated">这些类型的跟踪日志有很多优点，因为它们精确、小、索引速度快，而且可以很容易地格式化，以满足不同的统计分析需求。</p><p id="e74c" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">让我知道你对这种风格的跟踪日志的看法，会很有兴趣知道你的分析。</p></div><div class="ab cl lk ll hy lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="in io ip iq ir"><p id="8599" class="pw-post-body-paragraph ka kb iu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx in bi translated">如果你喜欢这篇文章，请分享或评论这篇文章。非常感谢任何形式的互动。如果你想支持我并接触到媒体中所有伟大的事物，请加入并成为会员。这是我的推荐链接:</p><div class="nj nk gq gs nl nm"><a href="https://susamn.medium.com/membership" rel="noopener follow" target="_blank"><div class="nn ab fp"><div class="no ab np cl cj nq"><h2 class="bd je gz z fq nr fs ft ns fv fx jd bi translated">加入Medium，我的推荐链接- Supratim Samanta</h2><div class="nt l"><h3 class="bd b gz z fq nr fs ft ns fv fx dk translated">作为一名中型会员，您的部分会员费将支付给您所阅读的作家，您可以完全接触到每个故事……</h3></div><div class="nu l"><p class="bd b dl z fq nr fs ft ns fv fx dk translated">susamn.medium.com</p></div></div><div class="nv l"><div class="px l nx ny nz nv oa li nm"/></div></div></a></div></div></div>    
</body>
</html>