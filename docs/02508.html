<html>
<head>
<title>Calculating Median in MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在MySQL中计算中位数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/calculating-median-in-mysql-fe0638a908c8?source=collection_archive---------5-----------------------#2020-03-18">https://levelup.gitconnected.com/calculating-median-in-mysql-fe0638a908c8?source=collection_archive---------5-----------------------#2020-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cee9f1dad1fa4853ea6695868fc41e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OR_XCqkuICJg1Ebk"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@helloquence?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">hello queue</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0b64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在网上磨砺我的SQL技能时，有人让我用蛮力(my SQL)计算MySQL表中一列的中值。通常情况下，我会将这些数据放入熊猫，然后很快完成，但我认为这个挑战会很有趣，也很有启发性。不出所料，的确如此，而且我在这个过程中学到了一些有趣的东西，这些东西对那些想提高自己技能的人来说很有用！</p><h2 id="bc2e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">中位数</h2><p id="f48a" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们先来概述一下中值的逻辑。为了找到一组数字的中间值，我们必须:</p><ol class=""><li id="d891" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated">对数组进行排序。</li><li id="96ab" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">找出数组中间项的值。</li></ol><p id="3713" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二步。可以通过两种方式之一进行:</p><ol class=""><li id="1f73" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated">如果数组包含奇数个项目，中值就是中间值。</li><li id="8022" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">如果数组包含偶数个项目，则中位数是中间两个值的平均值。</li></ol><p id="753d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们以某种聪明的方式使用上面的定义来解决这个问题。我在<a class="ae kc" href="https://www.eversql.com/how-to-calculate-median-value-in-mysql-using-a-simple-sql-query/" rel="noopener ugc nofollow" target="_blank"> EverSQL </a>上找到了一个解决方案，我将对其进行调整并详细分解，因为当我第一次通读他们的解决方案时，我感到非常困惑。</p><h2 id="0d8a" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">设置</h2><p id="dc2a" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我有一个AWS MySQL RDS实例，它有一个名为<code class="fe mn mo mp mq b">google_maps</code>的数据库，其中存储了<code class="fe mn mo mp mq b">trips</code>表。在<code class="fe mn mo mp mq b">trips</code>中有一个名为<code class="fe mn mo mp mq b">trip_duration</code>的列，它以整数形式存储以分钟为单位的旅行时间。我要去查询<code class="fe mn mo mp mq b">trip_duration</code>的中位数。</p><h1 id="4885" class="mr lc iq bd ld ms mt mu lg mv mw mx lj my mz na lm nb nc nd lp ne nf ng ls nh bi translated">解决方案1</h1><p id="28d3" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这里是第一个解决方案。它可以用几种不同的方式编写，但是我选择使用CTE ( <code class="fe mn mo mp mq b">WITH/AS</code>语法)来分隔子查询，以提高可读性。请看:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">解决方案1</figcaption></figure><p id="9b9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住，我们使用上面的逻辑作为解决这个问题的框架。</p><ol class=""><li id="1323" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated">生成一个添加了行索引的排序数组，以跟踪数组的长度(第1-10行)。</li><li id="c439" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">从数组的中间两个元素返回平均行程持续时间(代码的其余部分)。如果数组的长度是偶数，我们对两个中间的索引取平均值。如果数组的长度是奇数，那么中间的两个指数实际上是相等的，所以两者的平均值就是中间值本身。</li></ol><p id="82c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您很好地理解了代码，那么我向您致敬，并建议您跳到下一个解决方案。这个特殊的解决方案花了我一段时间来完全理解，所以我想提出另一个更详细的解释。</p><p id="c60e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，在第1行中，我们定义了变量<code class="fe mn mo mp mq b">@rowindex</code>,该变量将用于为每一行分配一个升序整数。</p><p id="664c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，第3–10行包含一个子查询，该子查询返回排序后的升序数据，行索引伴随每个旅行持续时间。细分一下，我们知道数据是按照<code class="fe mn mo mp mq b">ORDER BY trip_duration</code>子句排序的。我们还知道，由于第1行的原因，<code class="fe mn mo mp mq b">@rowindex</code>从-1开始。第5行告诉我们，第一个(也是由于排序而最小的)旅行持续时间被分配了一个索引</p><pre class="ni nj nk nl gt no mq np nq aw nr bi"><span id="e5dc" class="lb lc iq mq b gy ns nt l nu nv">@rowindex + 1 <br/>= -1 + 1<br/>= 0</span></pre><p id="da2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从而使列<code class="fe mn mo mp mq b">rowindex</code>从0开始。由于第5行，每个后续行的索引增加1。我们最终得到一个旅行持续时间的排序数组，每个数组都有一个唯一的行索引。整个子查询被打包到别名<code class="fe mn mo mp mq b">i</code>中，以便在下一段代码中引用，并增加可读性。</p><p id="db59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到最后一点。第13-18行是奇迹发生的地方。在13–16中，我们从子查询<code class="fe mn mo mp mq b">i</code>的结果中查询平均行程持续时间。然而，我们在17-18中增加了约束条件，即我们只取与具有中间两个指数的条目相对应的平均行程持续时间。此时，<code class="fe mn mo mp mq b">@rowindex</code>等于从<code class="fe mn mo mp mq b">i</code>获得的最高索引。因此，如果我们做<code class="fe mn mo mp mq b">@rowindex / 2</code>的下限和上限划分，那么我们应该能够考虑所有的可能性。让我们看两个例子来说明这一点。</p><h2 id="f2dc" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">示例1 —偶数个元素</strong></h2><p id="82da" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">考虑这样一种情况，我们有偶数个数据点，比如10个。这意味着<code class="fe mn mo mp mq b">@rowindex</code>将是9，因为第一个索引是0。为了找到中间值，我们需要第5和第6个元素的平均值，这将是<code class="fe mn mo mp mq b">@rowindex in (4, 5)</code>的旅行持续时间。为了对此进行编码，我们利用了<code class="fe mn mo mp mq b">CEIL</code>和<code class="fe mn mo mp mq b">FLOOR</code>函数:</p><pre class="ni nj nk nl gt no mq np nq aw nr bi"><span id="d285" class="lb lc iq mq b gy ns nt l nu nv">CEIL(@rowindex/2) = 5<br/>FLOOR(@rowindex/2) = 4</span></pre><p id="c09c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，回头看看13-18。我们取旅行持续时间的平均值，其中行索引在(4，5)中。正是我们想要的！</p><h2 id="4224" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">示例2 —奇数个元素</strong></h2><p id="da73" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在让我们考虑另一种选择。我们有奇数个数据点，比如说9个。这意味着<code class="fe mn mo mp mq b">@rowindex</code>将是8，因为第一个索引是0。中间值是第5个元素，意味着我们需要<code class="fe mn mo mp mq b">rowindex = 4</code>的旅行持续时间。这意味着上限和下限划分将产生相同的结果。</p><pre class="ni nj nk nl gt no mq np nq aw nr bi"><span id="6e6f" class="lb lc iq mq b gy ns nt l nu nv">CEIL(@rowindex/2) = FLOOR(@rowindex/2) = 4</span></pre><p id="ec97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们的<code class="fe mn mo mp mq b">WHERE</code>子句将遵循<code class="fe mn mo mp mq b">i.rowindex IN (4, 4)</code>的constriant，这在本质上与说<code class="fe mn mo mp mq b">rowindex = 4</code>相同。这也正是我们想要的。</p><p id="de1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对<strong class="kf ir">解决方案1 </strong>的说明到此结束。如果您仍然有疑问，我强烈建议您修改代码以适合您自己的表，并查看每个查询的结果。让我们转向另一个可能的解决方案。</p><h1 id="20f6" class="mr lc iq bd ld ms mt mu lg mv mw mx lj my mz na lm nb nc nd lp ne nf ng ls nh bi translated">解决方案2</h1><p id="a8e1" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">同样，有多种方式来写出这一切。我选择了我认为最清晰的。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">解决方案2</figcaption></figure><p id="3174" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个解决方案中的概念与第一个类似，主要区别是我使用窗口函数<code class="fe mn mo mp mq b">ROW_NUMBER()</code>来生成索引。下面是一般性的概述，再次供参考，虽然这段代码的主要区别在于步骤1。</p><ol class=""><li id="842f" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated">生成一个添加了行索引的排序数组，以跟踪数组的长度(第1–11行)。</li><li id="ca74" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">从数组的中间两个元素返回平均行程持续时间(代码的其余部分)。</li></ol><p id="ac60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，在第1–4行中，我们创建了变量<code class="fe mn mo mp mq b">@rowindex</code>,它存储了数组+ 1的长度。这是因为<code class="fe mn mo mp mq b">ROW_NUMBER()</code>的工作方式，我将在下面解释。</p><p id="58bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">7–11中的子查询使用<code class="fe mn mo mp mq b">ROW_NUMBER()</code>窗口函数为排序后的数组生成行索引。这个<code class="fe mn mo mp mq b">rowindex</code>列和解决方案1中的唯一区别是，现在我们的索引从1开始。这就是为什么<code class="fe mn mo mp mq b">@rowindex</code>需要是数组的长度+ 1！如果你需要复习一下<code class="fe mn mo mp mq b">ROW_NUMBER()</code>是如何工作的，看看我关于窗口功能的<a class="ae kc" href="https://medium.com/@marcosanchezayala/how-and-when-to-use-mysql-window-functions-910635f7c83d" rel="noopener">帖子</a>。</p><p id="320e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第14-19行与解决方案1中的相同，所以如果您是第一次加入，请检查该解释！</p><h1 id="abcf" class="mr lc iq bd ld ms mt mu lg mv mw mx lj my mz na lm nb nc nd lp ne nf ng ls nh bi translated">我学到了什么</h1><p id="cfbd" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这是一个将子查询与用户定义的变量结合起来的有趣练习。到目前为止，我实际上从未使用用户定义的变量运行过任何查询！当我第一次看到解决方案1的修改版本时，我真的很困惑，因为我不明白<code class="fe mn mo mp mq b">@rowindex</code>是如何在主查询中操作的。我猜EverSQL上的解释假设您理解了这段代码，但我并不理解。</p><p id="638c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，我重写了代码以适应<code class="fe mn mo mp mq b">trips</code>表。然后，我只是处理了查询的每一部分，一次只运行一小部分来理解每一行。一旦我掌握了所有的概念，我立即想到用<code class="fe mn mo mp mq b">ROW_NUMBER()</code>代替解决方案1中的方法来尝试索引。这让我想到了解决方案2！</p><p id="3d9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总的来说，这是一次愉快的学习经历，我相信在MySQL中有更多的方法来计算中位数。你有其他的解决方法吗？你能想出更好或更有效的方法让我写代码吗？请在评论中告诉我！</p></div></div>    
</body>
</html>