<html>
<head>
<title>Testing Redis Clients in Node.js with Testcontainers Node</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Testcontainers节点测试Node.js中的Redis客户端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/testing-redis-clients-in-node-js-with-testcontainers-node-8221aafffc57?source=collection_archive---------7-----------------------#2021-03-06">https://levelup.gitconnected.com/testing-redis-clients-in-node-js-with-testcontainers-node-8221aafffc57?source=collection_archive---------7-----------------------#2021-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b6ea34661e34bdc107cf2610410c97b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m_-xGC34UE18lgSzJXxjgA.jpeg"/></div></div></figure><h1 id="2b05" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">编写使用Testcontainers节点和Docker的真实Redis的单元测试。</h1><p id="2df9" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">自动化测试是确保任何软件产品质量的一个重要方面。然而，测试依赖于数据库或其他外部资源的系统通常是具有挑战性的。</p><p id="319c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">幸运的是，<a class="ae mc" href="https://www.testcontainers.org/" rel="noopener ugc nofollow" target="_blank"> Testcontainers </a>是一个很棒的项目，它通过提供一个编程接口在测试场景中运行Docker容器，使得设置外部资源变得更加容易。在本文中，我们将关注Node.js的Testcontainers社区端口(<a class="ae mc" href="https://www.npmjs.com/package/testcontainers" rel="noopener ugc nofollow" target="_blank"> testcontainers-node </a>)，以及我们如何运行依赖于单个Redis和Redis集群的测试。</p><p id="907d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">下面的例子将利用<a class="ae mc" href="https://www.npmjs.com/package/mocha" rel="noopener ugc nofollow" target="_blank"> mocha </a>作为测试运行器，<a class="ae mc" href="https://www.npmjs.com/package/chai" rel="noopener ugc nofollow" target="_blank"> chai </a>作为断言库，<a class="ae mc" href="https://github.com/luin/ioredis" rel="noopener ugc nofollow" target="_blank"> ioredis </a>作为我们的后备redis客户端。</p><p id="1ec2" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在继续之前，你可以完全跳过这篇文章，直接进入GitHub 上的一些<a class="ae mc" href="https://github.com/viglucci/testcontainers-node-redis-example" rel="noopener ugc nofollow" target="_blank">工作示例，如果那更符合你的风格的话。</a></p><h1 id="7e52" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">针对单个Redis进行测试</h1><p id="5525" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">针对单个Redis实例的测试非常简单。</p><p id="c4c1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">首先，我们将用一个<code class="fe md me mf mg b">before</code>钩子定义一个<code class="fe md me mf mg b">describe</code>块。在我们的<code class="fe md me mf mg b">before</code>钩子中，我们将创建运行Redis的Docker容器，我们还将创建Redis客户端实例。在调用任何测试之前，都会运行<code class="fe md me mf mg b">before</code>钩子。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a9c5" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">一旦我们创建了Docker容器和Redis客户端，我们将定义一个<code class="fe md me mf mg b">after</code>钩子来清理在<code class="fe md me mf mg b">before</code>钩子中创建的资源。当所有测试执行完毕时，调用<code class="fe md me mf mg b">after</code>钩子。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="7706" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">既然我们的Docker容器和Redis客户机已经创建好了，我们可以编写一个测试来调用运行Redis的命令。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="df6d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">综上所述，我们现在有了一个测试，可以针对正在运行的Redis实例调用命令，并对结果执行断言。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="fc5e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">针对Redis集群进行测试</h1><p id="94b1" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">针对Redis集群的测试可能比针对单个Redis的测试要复杂一些。这主要是因为Docker容器的本地网络不会映射到与主机上相同的IP和端口。不过，幸运的是，ioredis库支持所需的配置，使之成为可能。</p><p id="6c9a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">使用前一个例子中的<code class="fe md me mf mg b">before</code>钩子，我们需要做一些小的修改来运行Redis集群，而不是Docker容器中的单个Redis。这些变化包括:</p><ul class=""><li id="8d42" class="mn mo it lb b lc lx lg ly lk mp lo mq ls mr lw ms mt mu mv bi translated">将我们的Redis Docker图像更改为<code class="fe md me mf mg b">grokzen/redis-cluster</code>。</li><li id="2286" class="mn mo it lb b lc mw lg mx lk my lo mz ls na lw ms mt mu mv bi translated">创建码头工人网络。</li><li id="4a3b" class="mn mo it lb b lc mw lg mx lk my lo mz ls na lw ms mt mu mv bi translated">创建要连接的Redis节点列表。</li><li id="2f25" class="mn mo it lb b lc mw lg mx lk my lo mz ls na lw ms mt mu mv bi translated">创建一个<a class="ae mc" href="https://en.wikipedia.org/wiki/Network_address_translation" rel="noopener ugc nofollow" target="_blank"> NAT </a>映射，从内部Docker网络映射到主机网络。</li></ul><p id="b2f0" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">一旦我们的后备Redis客户端连接到集群中的任何节点，就有必要创建NAT映射；它将尝试自动发现属于该群集的任何其他节点。不幸的是，当客户机发现新节点时，这些节点将被本地地址引用到Docker容器，而不是主机。NAT映射将允许客户端将内部Docker地址正确转换为主机上的可用地址。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f97a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">随着Redis集群容器的运行和<code class="fe md me mf mg b">Redis.Cluster</code>客户端的创建，我们现在需要确保记住将新创建的<code class="fe md me mf mg b">network</code>资源添加到我们的<code class="fe md me mf mg b">after</code>钩子中。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="bb57" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">从这一点开始，一切都与消耗一个Redis相同。你可以在下面看到这一切。</p><figure class="mh mi mj mk gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="db4f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">既然您正在使用容器更自信地测试您的应用程序，不要忘记让我知道您是否觉得这篇文章有帮助！我很感激你提供的每一个赞、评论或问题！</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="cc37" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><em class="ni">最初发布于</em><a class="ae mc" href="https://viglucci.io/testing-redis-clients-in-nodejs-with-testcontainers-node" rel="noopener ugc nofollow" target="_blank">https://viglucci . io/testing-redis-clients-in-nodejs-with-test containers-node</a>。</p></div></div>    
</body>
</html>