<html>
<head>
<title>Keep calm and race on: a redux-saga case study</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保持冷静，继续前进:redux-saga案例研究</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/keep-calm-and-race-on-redux-saga-case-study-2f5b0a6630ae?source=collection_archive---------0-----------------------#2018-11-11">https://levelup.gitconnected.com/keep-calm-and-race-on-redux-saga-case-study-2f5b0a6630ae?source=collection_archive---------0-----------------------#2018-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0eb380073e3e01fb3c02fbc91ad7bd32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3InTJq7aDemxtgkNYanGQ.jpeg"/></div></div></figure><p id="75b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将通过构建一个web应用程序的轮询特性，展示一个使用<a class="ae kw" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux-Saga </a>、<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" rel="noopener ugc nofollow" target="_blank"> JavaScript生成器</a>和<a class="ae kw" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>的案例研究。poll API请求是一种按照设定的时间间隔向服务器发出AJAX调用以检查更新的请求。然后我们将使用<a class="ae kw" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank"> Cypress </a>测试我们的代码。</p><h1 id="747b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用Redux Saga构建一个轮询特性</h1><p id="fd4c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">假设您需要向服务器发出轮询请求，以接收由客户端触发的作业的状态。例如，让我们想象一个场景，用户上传一个文件。然后，上传成功完成后，服务器需要处理文件，然后才能在应用程序中查看。在这种情况下，您希望显示一个指示进度的状态栏，并阻止用户查看文件，直到文件完成。</p><p id="a140" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务器将对我们的轮询请求有3个响应:<code class="fe ma mb mc md b">started</code>、<code class="fe ma mb mc md b">succeeded</code>或<code class="fe ma mb mc md b">failed</code>。下面的代码展示了如何使用Redux Saga编写一个轮询请求。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="c88e" class="mm ky iq md b gy mn mo l mp mq">import { take, put, <em class="mr">delay</em> } from 'redux-saga/effects'</span><span id="3bbc" class="mm ky iq md b gy ms mo l mp mq">function* <em class="mr">checkJobStatus</em>() {<br/>  let jobSucceeded = false;<br/>  while (!jobSucceeded) {<br/>    yield put({type: "POLLING_ACTION_REQUEST"});<br/>    const pollingAction = yield take("POLLING_ACTION_RESPONSE");<br/>    const pollingStatus = pollingAction.payload.response.status;<br/>    switch (pollingStatus) {<br/>      case POLLING_STATUS.SUCCEEDED:<br/>        jobSucceeded = true;<br/>        yield put({type: "HANDLE_POLLING_SUCCESS"});<br/>        break;<br/>      case POLLING_STATUS.FAILED:<br/>        jobSucceeded = true;<br/>        yield put({type: "HANDLE_POLLING_FAILURE"});<br/>        break;<br/>      default:<br/>        break;<br/>    }<br/>    // delay the next polling request in 1 second<br/>    yield call(<em class="mr">delay</em>, 1000);<br/>  }<br/>}</span></pre><p id="782b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们通过使用'<a class="ae kw" href="https://redux-saga.js.org/docs/api/#putaction" rel="noopener ugc nofollow" target="_blank"> put </a>'效果执行一个请求，该效果分派一个动作。紧接着，我们使用一个名为“<a class="ae kw" href="https://redux-saga.js.org/docs/api/#takepattern" rel="noopener ugc nofollow" target="_blank"> take </a>”的Redux-Saga <a class="ae kw" href="https://redux-saga.js.org/docs/api/#effect-creators" rel="noopener ugc nofollow" target="_blank">效果</a>，它<strong class="ka ir">会阻止</strong>Saga的执行，直到有人调度作为参数给出的动作。一旦<code class="fe ma mb mc md b">POLLING_ACTION_RESPONSE</code>被调度，我们检查从服务器返回的状态。如果我们得到“完成”或“失败”状态，我们需要使用“<a class="ae kw" href="https://redux-saga.js.org/docs/api/#putaction" rel="noopener ugc nofollow" target="_blank"> put </a>”效果来相应地处理它们。否则，我们对服务器执行另一个轮询请求，依此类推，直到它完成。</p><blockquote class="mt mu mv"><p id="699c" class="jy jz mr ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">效果只是一个对象，它包含一些由中间件解释的信息。您可以查看效果，比如对中间件执行一些操作的指令(例如，调用一些异步功能，将一个动作分派给存储，等等。).</p></blockquote><p id="cd3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果您想处理的不仅仅是根据服务器对轮询请求的响应进行操作，那该怎么办呢？如果您想限制对服务器的轮询时间，比如说1分钟，该怎么办？如果您还想让用户在处理过程中取消文件的上传，该怎么办？这听起来有点复杂，不是吗？</p><p id="6f0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了redux-saga，这比你想象的要容易得多！</p><p id="b6b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们看一些代码之前，让我们把它分解一下，了解一下我们在这里面临的是什么。首先，我们有异步运行的轮询请求。现在，在这个请求运行的任何时间点，用户都可以取消这个操作。</p><p id="bb72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也不要忘记，这个请求可能因为许多原因而失败(服务器错误、错误的请求等)。这里的另一个元素是我们想要为这个请求设置的超时。当请求运行时，所有这些场景都可能在任何给定的时间发生，我们很想知道哪一个先执行，因此我们面临着一场行动的<strong class="ka ir">竞赛</strong>。</p><p id="f09e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看redux-saga是如何做到的:</p><p id="56de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下示例在四种效果之间运行一个<code class="fe ma mb mc md b"><strong class="ka ir">race</strong></code> Redux-Saga函数:</p><ol class=""><li id="e5c1" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated">对我们最初的<code class="fe ma mb mc md b">checkJobStatus</code>函数的调用。</li><li id="97df" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">一项<code class="fe ma mb mc md b">CANCEL_POLLING</code>行动，最终可能会在商场上展开。</li><li id="1c11" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">一项<code class="fe ma mb mc md b">POLLING_FAILED</code>行动，最终可能会在商店中执行。</li><li id="7fd4" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">对<a class="ae kw" href="https://redux-saga.js.org/docs/api/#delayms-val" rel="noopener ugc nofollow" target="_blank">的调用延迟</a>。<code class="fe ma mb mc md b">delay</code>是一个Redux-Saga实用函数，返回一个在X毫秒后解决的承诺。我们用它来设置比赛的暂停。</li></ol><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="fc5b" class="mm ky iq md b gy mn mo l mp mq">import { race, take, put, call, delay } from 'redux-saga/effects'</span><span id="c7cf" class="mm ky iq md b gy ms mo l mp mq">function* <em class="mr">startPollingSaga</em>(action) {<br/>    <em class="mr">// Race the following commands with a timeout of 1 minute<br/>    </em>const { <!-- -->response, <!-- -->failed, timeout } = yield <em class="mr">race</em>({<br/>      <!-- -->response<!-- -->: call(<em class="mr">checkJobStatus</em>),<br/>      cancel: take("CANCEL_POLLING"),<br/>      failed: take("POLLING_FAILED"),<br/>      timeout: call(<em class="mr">delay</em>, 60000)<br/>    });</span><span id="59fb" class="mm ky iq md b gy ms mo l mp mq">    // handle failure scenario<br/>    if (failed) {<br/>      yield put(<em class="mr">{type: "</em>HANDLE_POLLING_FAILURE<em class="mr">"}</em>);<br/>    }<br/>}</span></pre><p id="9082" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果<code class="fe ma mb mc md b">call(checkJobStatus)</code>先结束，<code class="fe ma mb mc md b">cancel</code>、<code class="fe ma mb mc md b">failed</code>、<code class="fe ma mb mc md b">timeout</code>将为<code class="fe ma mb mc md b">undefined</code>。在我们的例子中,<code class="fe ma mb mc md b">response</code>也将是<code class="fe ma mb mc md b">undefined</code>,因为<code class="fe ma mb mc md b">checkJobStatus</code>不返回承诺，而是自己处理轮询响应。</p><p id="562d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果<code class="fe ma mb mc md b">call(delay, 60000)</code>先解决，<code class="fe ma mb mc md b">timeout</code>将是<code class="fe ma mb mc md b">delay</code>和<code class="fe ma mb mc md b">cancel</code>的结果，<code class="fe ma mb mc md b">failed</code>和<code class="fe ma mb mc md b">response</code>将是<code class="fe ma mb mc md b">undefined</code>。</p><p id="8337" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果在<code class="fe ma mb mc md b">checkJobStatus</code>完成之前<code class="fe ma mb mc md b">CANCEL_POLLING</code>类型的动作被分派到商店上，<code class="fe ma mb mc md b">response</code>、<code class="fe ma mb mc md b">failed</code>和<code class="fe ma mb mc md b">timeout</code>将成为<code class="fe ma mb mc md b">undefined</code>并且<code class="fe ma mb mc md b">cancel</code>将获得被分派动作的值。</p><p id="4e0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果类型为<code class="fe ma mb mc md b">POLLING_FAILED</code>的动作在<code class="fe ma mb mc md b">checkJobStatus</code>完成之前被分派到商店，<code class="fe ma mb mc md b">response</code>、<code class="fe ma mb mc md b">cancel</code>和<code class="fe ma mb mc md b">timeout</code>将成为<code class="fe ma mb mc md b">undefined</code>并且<code class="fe ma mb mc md b">failed</code>将获得被分派动作的值。</p><p id="8f75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:在<code class="fe ma mb mc md b">POLLING_FAILED</code>或<code class="fe ma mb mc md b">CANCEL_POLLING</code>动作被调度的情况下，<code class="fe ma mb mc md b">race</code>效果会自动取消<code class="fe ma mb mc md b"><em class="mr">checkJobStatus</em></code>和<code class="fe ma mb mc md b"><em class="mr">delay</em></code> <em class="mr"> </em>并抛出取消错误。</p><h1 id="0f73" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用Cypress测试Redux Saga</h1><p id="4955" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在我们可以实现上面的场景了，让我们学习如何轻松地测试它！</p><p id="a5e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我将使用<a class="ae kw" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank"> Cypress </a>演示一个解决方案。</p><blockquote class="mt mu mv"><p id="392e" class="jy jz mr ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">注意:我决定展示一个测试超时场景的例子，因为这可能是最有趣的一个例子。所有其他场景都非常简单。</p></blockquote><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="1293" class="mm ky iq md b gy mn mo l mp mq"><strong class="md ir"><em class="mr">describe</em></strong>(<strong class="md ir">'ui test'</strong>, <strong class="md ir">function</strong>() {</span><span id="2b2c" class="mm ky iq md b gy ms mo l mp mq">  <strong class="md ir"><em class="mr">it</em></strong>(<strong class="md ir">'should wait for processing to timeout'</strong>, <strong class="md ir">function</strong>() {</span><span id="69ed" class="mm ky iq md b gy ms mo l mp mq"><em class="mr">    // Overrides native global functions related to time allowing<br/>    // them to be controlled synchronously before polling request<br/>    </em><strong class="md ir"><em class="mr">cy</em></strong>.clock();</span><span id="d940" class="mm ky iq md b gy ms mo l mp mq"><strong class="md ir"><em class="mr">    cy</em></strong>.route(<strong class="md ir">'GET'</strong>, 'upload file endpoint<strong class="md ir">'</strong>, uploadResponse)<br/>      .as('fileUploaded');</span><span id="6b5a" class="mm ky iq md b gy ms mo l mp mq"><strong class="md ir"><em class="mr">    cy</em></strong>.route(<strong class="md ir">'GET'</strong>, 'polling endpoint<strong class="md ir">'</strong>, pollingResponse)<br/>      .as('pollingStarted');</span><span id="841e" class="mm ky iq md b gy ms mo l mp mq">    // Since this article is talking about file upload we are using<br/>    // a custom command to imitate the file upload because it's not<br/>    // built-in in cypress.<br/>    <strong class="md ir"><em class="mr">cy</em></strong>.uploadFile('dropdown zone', 'file name<strong class="md ir">'</strong>);<br/>     <br/>    <strong class="md ir"><em class="mr">cy</em></strong>.wait('fileUploaded<strong class="md ir">'</strong>);</span><span id="4d69" class="mm ky iq md b gy ms mo l mp mq">    <strong class="md ir"><em class="mr">cy</em></strong>.wait('pollingStarted<strong class="md ir">'</strong>);</span><span id="c730" class="mm ky iq md b gy ms mo l mp mq">    <em class="mr">// Set the clock forward to cause a timeout<br/>    </em><strong class="md ir"><em class="mr">cy</em></strong>.clock().then((clock) =&gt; {<br/>      clock.tick(60000);<br/>      clock.restore();<br/>    });</span><span id="e41a" class="mm ky iq md b gy ms mo l mp mq">    // Here you can verify that the desired ui behavior is as<br/>    // expected  <br/>    <br/>  });<br/>});</span></pre><p id="fe9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们这里有什么？</p><p id="de69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在定义路由和执行轮询请求之前，我们希望覆盖与时间相关的本地全局函数。这将允许我们同步控制本地全局函数。为此，我们使用<code class="fe ma mb mc md b"><strong class="ka ir"><em class="mr">cy</em></strong>.clock();</code>,这样我们可以稍后决定将时钟向前设置，这样我们就可以导致超时。</p><p id="5d33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在定义了上传和轮询请求路由之后，我们提交一个文件并等待它上传和轮询开始。</p><p id="925d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以将时钟拨快:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="cdde" class="mm ky iq md b gy mn mo l mp mq"><strong class="md ir"><em class="mr">cy</em></strong>.clock().then((clock) =&gt; {<br/> clock.tick(60000);<br/> clock.restore();<br/>});</span></pre><p id="adb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">clock.tick(milliseconds)</code></p><blockquote class="mt mu mv"><p id="6796" class="jy jz mr ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">将时钟移动指定数量的<code class="fe ma mb mc md b"><em class="iq">milliseconds</em></code>。将调用受影响时间范围内的任何计时器。</p></blockquote><p id="1851" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">clock.restore()</code></p><blockquote class="mt mu mv"><p id="4d58" class="jy jz mr ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">恢复所有被覆盖的本机函数。这是在测试之间自动调用的，所以通常不需要。</p></blockquote><p id="6902" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，您就可以验证期望的UI行为是否符合预期了。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="b276" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么到目前为止我们学到了什么？我们了解到，当使用Redux-Saga时，管理多个动作之间的<strong class="ka ir">竞赛</strong>是非常容易的。就我个人而言，我喜欢你可以在一个地方管理所有这些操作，这使得它非常直观，易于维护。我们还了解到，在使用Cypress时，测试一个您的某个操作导致超时的场景是非常容易的。我们看到了如何以同步方式“等待”异步超时。</p><p id="64e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！现在轮到你试一试了！</p></div></div>    
</body>
</html>