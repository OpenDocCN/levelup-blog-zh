<html>
<head>
<title>How to type a payload received from an external source in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在TypeScript中键入从外部源接收的有效负载</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-type-a-payload-received-from-an-external-source-in-typescript-e12a31c6777a?source=collection_archive---------5-----------------------#2020-04-30">https://levelup.gitconnected.com/how-to-type-a-payload-received-from-an-external-source-in-typescript-e12a31c6777a?source=collection_archive---------5-----------------------#2020-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ebf28a4e929fb8851891c48744252153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HzPt5oHT7zeMz5nxry2AFw.jpeg"/></div></div></figure><div class=""/><p id="755f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们从外部来源接收到一些数据时(比如当您的web服务器接收到一个HTTP请求时，或者当我们调用一个外部API来获取一些数据时)，我们不知道数据看起来像什么，直到我们验证它。</p><p id="fbd4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们有一个啤酒服务，有一个函数<code class="fe kz la lb lc b">addFavoriteBeer</code>，我们可以调用它来添加我们喜欢的新啤酒。</p><figure class="ld le lf lg gt iv"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="e2ca" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们考虑一下控制器，它将接收HTTP请求，请求添加喜爱的啤酒，并调用这个服务来添加它们。</p><h1 id="c980" class="lj lk je bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">我们不应该这样做</h1><figure class="ld le lf lg gt iv"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="d876" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Typescript不会抱怨，因为从类型的角度来看它是有效的。但是如果我们在HTTP请求中给出下面的有效负载会怎么样呢？</p><pre class="ld le lf lg gt mh lc mi mj aw mk bi"><span id="9374" class="ml lk je lc b gy mm mn l mo mp">{ "hello": "world" }</span></pre><p id="cff5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们将把不是一个<code class="fe kz la lb lc b">Beer</code>的东西传递给<code class="fe kz la lb lc b">addFavoriteBeer</code>，而是像使用一个<code class="fe kz la lb lc b">Beer</code>一样使用它。这很糟糕。</p><figure class="ld le lf lg gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mq"><img src="../Images/42abd8f95840b39b63b2c348735974d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YjEzt33urW72UNupDcj_bQ.jpeg"/></div></div></figure><h1 id="5647" class="lj lk je bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">我们应该避免这样做</h1><p id="0b7c" class="pw-post-body-paragraph kb kc je kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">我们可以使用<a class="ae mw" href="https://www.npmjs.com/package/@hapi/joi" rel="noopener ugc nofollow" target="_blank"> Joi </a>或另一个模式验证库(或者甚至手动操作，如果我们感觉到的话)来确保我们得到的是我们所期望的。</p><p id="79e3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个Joi的例子</p><figure class="ld le lf lg gt iv"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="a6f9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当我们调用<code class="fe kz la lb lc b">addFavoriteBeer</code>时，我们知道它与<code class="fe kz la lb lc b">beerSchema</code>匹配，在这种情况下，它工作得很好，因为<code class="fe kz la lb lc b">beerSchema</code>与<code class="fe kz la lb lc b">Beer</code>类型匹配。但是它仍然不是类型安全的，因为我们仍然将<code class="fe kz la lb lc b">any</code>传递给<code class="fe kz la lb lc b">addFavoriteBeer</code>。</p><p id="6a1d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们这样改变<code class="fe kz la lb lc b">Beer</code>的定义会怎么样？</p><figure class="ld le lf lg gt iv"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="4cf6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们在<code class="fe kz la lb lc b">Beer</code>和<code class="fe kz la lb lc b">beerSchema</code>之间有了不一致，但是对于Typescript来说一切都很好。</p><p id="e86a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们将有效载荷发送给HTTP请求，它将通过验证，但不应该通过，因为<code class="fe kz la lb lc b">isFrenchBeer</code>不是布尔值。</p><pre class="ld le lf lg gt mh lc mi mj aw mk bi"><span id="d2aa" class="ml lk je lc b gy mm mn l mo mp">{<br/>    "name": "Chimay",<br/>    "degree": 9,<br/>    "isFrenchBeer": "hello world"<br/>}</span></pre><h1 id="6841" class="lj lk je bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">我们应该更喜欢这个</h1><p id="8344" class="pw-post-body-paragraph kb kc je kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">为了解决我们之前看到的问题，我们可以使用像<a class="ae mw" href="https://www.npmjs.com/package/io-ts" rel="noopener ugc nofollow" target="_blank"> io-ts </a>这样的库，它返回(在验证成功的情况下)一个对象，该对象具有我们在控制器中为验证定义的模式的形状。</p><figure class="ld le lf lg gt iv"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="678e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当<code class="fe kz la lb lc b">beer</code>匹配类型<code class="fe kz la lb lc b">Beer</code>时，<code class="fe kz la lb lc b">addFavoriteBeer</code>接受。</p><p id="1809" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是现在，如果我们像之前看到的那样在服务中更改类型<code class="fe kz la lb lc b">Beer</code>来添加布尔值<code class="fe kz la lb lc b">isFrenchBeer</code>，Typescript将会引发一个错误，因为<code class="fe kz la lb lc b">beer</code>缺少这个属性！为了解决这个问题，我们必须将这个属性添加到<code class="fe kz la lb lc b">BeerIO</code>中。</p><p id="e61c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">因此，如果我们在控制器中定义的模式和服务类型之间存在不一致，Typescript会引发错误，代码无法构建。</strong></p><h1 id="e975" class="lj lk je bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><ul class=""><li id="ce9a" class="mx my je kd b ke mr ki ms km mz kq na ku nb ky nc nd ne nf bi translated">不要做<strong class="kd jf"> <em class="ng">中提到的事情不要做这个</em> </strong>部分，因为这可能会让你的应用崩溃如果你收到了预期的有效负载(<code class="fe kz la lb lc b">cannot read property of undefined</code>)或者最坏的情况，你的应用可能会继续运行，但奇怪的事情会发生，你可能不会注意到它，或者你可能有安全问题。</li><li id="41c5" class="mx my je kd b ke nh ki ni km nj kq nk ku nl ky nc nd ne nf bi translated"><strong class="kd jf"> <em class="ng">中提出的避免做这个</em> </strong>部分是为了避免，如说。因为如果您的验证模式和预期类型不一致，Typescript不会抱怨，您可能会遇到与<strong class="kd jf"> <em class="ng">不要这样做</em> </strong>类似的问题。但是当你写Javascript而不是Typescript的时候，使用Joi这样的库仍然是一个很好的解决方案。</li><li id="e786" class="mx my je kd b ke nh ki ni km nj kq nk ku nl ky nc nd ne nf bi translated">更喜欢<strong class="kd jf"> <em class="ng">中呈现的内容更喜欢这个</em> </strong>部分，因为它更安全。并且你将知道在你验证的和你的类型之间是否有不一致。</li></ul><p id="7af8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你知道这种问题的其他解决方案，请在评论中分享，我很好奇:)</p></div></div>    
</body>
</html>