<html>
<head>
<title>React useEffect Data Fetching Pattern I Wish I Knew Sooner</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React useEffect数据获取模式我希望我能早点知道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-pattern-i-wish-i-knew-sooner-7dbccb3a8b62?source=collection_archive---------1-----------------------#2022-05-17">https://levelup.gitconnected.com/react-pattern-i-wish-i-knew-sooner-7dbccb3a8b62?source=collection_archive---------1-----------------------#2022-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9bc3a1933a0e49b02aea0bd40db16714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hufushT-44_jSNLyZzUgA.jpeg"/></div></div></figure><h1 id="fe58" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">目标</h1><p id="adef" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我在开发一个<a class="ae lu" href="https://mui.com/material-ui/react-dialog/" rel="noopener ugc nofollow" target="_blank">对话框组件</a>时遇到了一个小问题，每次打开它时，它都会从一个API端点异步获取一些数据，这在我的例子中是生成一个新代码。</p><p id="20ca" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我花了一些时间思考的问题是，由于它的实现方式，正在发生的重新渲染的数量。这是我想要实现的目标的一个最小的可重复的例子:</p><p id="6d0e" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">MyDialog.tsx:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="bae2" class="mj jz iq mf b gy mk ml l mm mn">interface MyDialogProps {<br/>  open: boolean;<br/>  name: string;<br/>  onClose: () =&gt; void;<br/>}</span><span id="62fe" class="mj jz iq mf b gy mo ml l mm mn">const MyDialog: FC&lt;MyDialogProps&gt; = ({ name, open, onClose }) =&gt; {<br/>  const [text, setText] = useState&lt;string&gt;("");</span><span id="980d" class="mj jz iq mf b gy mo ml l mm mn">  const fetchText = async () =&gt; {<br/>    <em class="mp">//fetching some data asynchronously<br/>    </em>setTimeout(() =&gt; setText(name + ": some value"), 5000);<br/>  };</span><span id="e6ea" class="mj jz iq mf b gy mo ml l mm mn">  const getText = () =&gt; {<br/>    setText("Loading");<br/>    fetchText();<br/>  };</span><span id="4b82" class="mj jz iq mf b gy mo ml l mm mn">  return (<br/>    &lt;&gt;<br/>      &lt;RenderCounter name={name} /&gt;<br/>      &lt;Dialog open={open} onClose={onClose}&gt;<br/>        &lt;DialogContent&gt;<br/>        &lt;h1&gt;{name}&lt;/h1&gt;<br/>        &lt;TextField value={text} contentEditable={false} /&gt;<br/>      &lt;/DialogContent&gt;<br/>      &lt;DialogActions&gt;<br/>        &lt;button onClick={getText}&gt;Get Text&lt;/button&gt;<br/>        &lt;button onClick={onClose}&gt;Cancel&lt;/button&gt;<br/>      &lt;/DialogActions&gt;<br/>      &lt;/Dialog&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span><span id="16fe" class="mj jz iq mf b gy mo ml l mm mn">export default MyDialog;</span></pre><p id="26c3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">App.tsx:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2ae8" class="mj jz iq mf b gy mk ml l mm mn">export default function App() {</span><span id="fa7a" class="mj jz iq mf b gy mo ml l mm mn">  const [open, setOpen] = useState&lt;boolean&gt;(false);</span><span id="4ae1" class="mj jz iq mf b gy mo ml l mm mn">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;h1&gt;App&lt;/h1&gt;<br/>      &lt;button onClick={() =&gt; setOpen(true)}&gt;open&lt;/button&gt;<br/>      &lt;RenderCounter name="app" /&gt;<br/>      &lt;MyDialog<br/>        name="component"<br/>        open={open}<br/>        onClose={() =&gt; setOpen(false)}<br/>      /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="4b9c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我从<a class="ae lu" href="https://felixgerschau.com/" rel="noopener ugc nofollow" target="_blank"> Felix Gerschau </a>那里借来的<code class="fe mq mr ms mf b">RenderComponent</code>(查看他关于<a class="ae lu" href="https://felixgerschau.com/react-rerender-components/" rel="noopener ugc nofollow" target="_blank"> React渲染</a>的文章)。这个组件是跟踪一个组件渲染了多少次的好方法。).</p><p id="0903" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">RenderComponent.tsx:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="718b" class="mj jz iq mf b gy mk ml l mm mn">interface RenderCounterProps {<br/>  name: string;<br/>}</span><span id="a6b6" class="mj jz iq mf b gy mo ml l mm mn">const RenderCounter: FC&lt;RenderCounterProps&gt; = ({ name }) =&gt; {<br/>  const rerenderCounter = React.useRef(0);<br/>  rerenderCounter.current += 1;<br/>  console.log(name + ":", rerenderCounter.current);<br/>  return &lt;&gt;&lt;/&gt;;<br/>};</span><span id="0359" class="mj jz iq mf b gy mo ml l mm mn">export default RenderCounter;</span></pre><p id="b11a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这是我试图实现的一个简化版本，即允许用户在单击按钮时打开一个对话框并获取一些数据:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/7a26e8cde8e2616cf6eaa2287cbb6e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JeDlOWnZOV_xs8GoHf7Gcw.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">单击该按钮时，数据会在5秒钟后加载</figcaption></figure><h1 id="21ea" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题是</h1><p id="5104" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这样做的问题是，数据不是每次都被重新获取，如果我关闭并重新打开对话框，获取的值仍然存在。</p><p id="8164" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">如果这是一个用于生成折扣代码、密钥或任何动态内容的对话框，许多教程指出的一个常见解决方法是将<code class="fe mq mr ms mf b">open</code>道具放入<code class="fe mq mr ms mf b">useEffect</code>中，并在对话框<strong class="ky ir">改变状态</strong>打开时擦除文本值，如下所示:</p><p id="0709" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">MyDialog.tsx:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="03d6" class="mj jz iq mf b gy mk ml l mm mn">const MyDialog: FC&lt;MyDialogProps&gt; = ({ name, open, onClose }) =&gt; {<br/>  const [text, setText] = useState&lt;string&gt;("");</span><span id="63f2" class="mj jz iq mf b gy mo ml l mm mn">  useEffect(() =&gt; {<br/>    if (open) {<br/>      setText("");<br/>    }<br/>  }, [open]);</span><span id="59ce" class="mj jz iq mf b gy mo ml l mm mn">  ...<br/>  // skipped for brevity<br/>};</span></pre><p id="2b42" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这种方法的问题在于，<code class="fe mq mr ms mf b">useEffect</code>是在组件渲染之后被调用的，因为它在组件内部调用了<code class="fe mq mr ms mf b">setText</code>，所以会导致第二次渲染。</p><p id="e3f4" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">通过点击按钮打开和关闭对话框，我们看到<code class="fe mq mr ms mf b">App</code>组件以与<code class="fe mq mr ms mf b">MyDialog</code>组件相同的速率被重新渲染。如果<code class="fe mq mr ms mf b">App</code>组件包含一堆其他组件，当用户打开和关闭对话框时，这些组件会被不必要地重新呈现，这就不好了。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/3abcf188d6c237344c4f3be1e1630fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*ZrM17ZKxV97AwWIe3deuxw.png"/></div></figure><p id="7e17" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这种方法另一个困扰我的地方是<code class="fe mq mr ms mf b">useEffect</code>钩子的用法。在本例中，观察<code class="fe mq mr ms mf b">open</code>道具的变化感觉是多余的<strong class="ky ir">，因为道具的变化会导致组件的重新渲染！</strong></p><h1 id="6993" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">解决方案:容器模式</h1><p id="e55f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><a class="ae lu" href="https://medium.com/@learnreact/container-components-c0e67432e005" rel="noopener">容器模式</a>是这个问题的绝佳解决方案，因为:</p><blockquote class="mz"><p id="ed2b" class="na nb iq bd nc nd ne nf ng nh ni lt dk translated">我们已经分离了我们的<strong class="ak">数据获取</strong>和<strong class="ak">渲染</strong>关注点。</p></blockquote><p id="c8c3" class="pw-post-body-paragraph kw kx iq ky b kz nj lb lc ld nk lf lg lh nl lj lk ll nm ln lo lp nn lr ls lt ij bi translated">通过将更新状态的代码放在定义状态的同一个地方，我们可以省去一个麻烦！代码如下:</p><p id="2ffd" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">MyCoolDialog.tsx:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f6d4" class="mj jz iq mf b gy mk ml l mm mn">interface MyCoolDialogProps {<br/>  open: boolean;<br/>  name: string;<br/>  onClose: () =&gt; void;<br/>  text: string;<br/>  getText: () =&gt; void;<br/>}</span><span id="1319" class="mj jz iq mf b gy mo ml l mm mn">const MyCoolDialog: FC&lt;MyCoolDialogProps&gt; = ({<br/>  name,<br/>  open,<br/>  onClose,<br/>  text,<br/>  getText<br/>}) =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;RenderCounter name={name} /&gt;<br/>      &lt;Dialog open={open} onClose={onClose}&gt;<br/>        &lt;DialogContent&gt;<br/>          &lt;h1&gt;{name}&lt;/h1&gt;<br/>          &lt;TextField value={text} contentEditable={false} /&gt;<br/>        &lt;/DialogContent&gt;<br/>        &lt;DialogActions&gt;<br/>          &lt;button onClick={getText}&gt;Get Text&lt;/button&gt;<br/>          &lt;button onClick={onClose}&gt;Cancel&lt;/button&gt;<br/>        &lt;/DialogActions&gt;<br/>      &lt;/Dialog&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span><span id="29d4" class="mj jz iq mf b gy mo ml l mm mn">export default MyCoolDialog;</span></pre><p id="f6df" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">DialogContainer.tsx:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f602" class="mj jz iq mf b gy mk ml l mm mn">interface DialogContainerProps {<br/>  name: string;<br/>}</span><span id="de20" class="mj jz iq mf b gy mo ml l mm mn">const DialogContainer: FC&lt;DialogContainerProps&gt; = ({ name }) =&gt; {<br/>  const [open, setOpen] = useState&lt;boolean&gt;(false);<br/>  const [text, setText] = useState&lt;string&gt;("");</span><span id="6562" class="mj jz iq mf b gy mo ml l mm mn">  const handleToggle = () =&gt; {<br/>    if (!open) {<br/>      setText("");<br/>    }<br/>    setOpen((o) =&gt; !o);<br/>  };</span><span id="5e56" class="mj jz iq mf b gy mo ml l mm mn">  const fetchText = async () =&gt; {<br/>    //some async function<br/>    setTimeout(() =&gt; setText(name + ": some value"), 5000);<br/>  };</span><span id="dff8" class="mj jz iq mf b gy mo ml l mm mn">  const getText = () =&gt; {<br/>    setText("Loading");<br/>    fetchText();<br/>  };</span><span id="19e9" class="mj jz iq mf b gy mo ml l mm mn">  return (<br/>    &lt;div&gt;<br/>      &lt;button onClick={handleToggle}&gt;open&lt;/button&gt;<br/>      &lt;MyCoolDialog<br/>        open={open}<br/>        name={name}<br/>        onClose={() =&gt; setOpen(false)}<br/>        text={text}<br/>        getText={getText}<br/>      /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="8038" class="mj jz iq mf b gy mo ml l mm mn">export default DialogContainer;</span></pre><p id="c8bb" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">App.tsx:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="204a" class="mj jz iq mf b gy mk ml l mm mn">export default function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;h1&gt;App&lt;/h1&gt;<br/>      &lt;RenderCounter name="app" /&gt;<br/>      &lt;DialogContainer name="container" /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><h2 id="adf4" class="mj jz iq bd ka no np dn ke nq nr dp ki lh ns nt km ll nu nv kq lp nw nx ku ny bi translated">论证</h2><p id="cce9" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">通过消除对<code class="fe mq mr ms mf b">useEffect</code>的需求，我们提高了对话框组件的性能。</p><p id="9511" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">通过将状态放在容器组件中，我们避免了更新父组件<code class="fe mq mr ms mf b">App</code>的状态，这将<strong class="ky ir">导致其所有子组件不必要地重新呈现。在这个特殊的例子中，<code class="fe mq mr ms mf b">App</code>组件只有子组件，所以这不是问题。然而，如果有许多子组件，这很容易成为一个问题。</strong></p><p id="50d4" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我觉得这个看起来很整齐，而且让<code class="fe mq mr ms mf b">MyCoolDialog</code> <strong class="ky ir">感觉功能性强了很多。</strong></p><h2 id="894f" class="mj jz iq bd ka no np dn ke nq nr dp ki lh ns nt km ll nu nv kq lp nw nx ku ny bi translated">边注</h2><p id="b21c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我认为在一个<code class="fe mq mr ms mf b">useEffect</code>的依赖数组中观看<code class="fe mq mr ms mf b">props</code>应该谨慎，<strong class="ky ir">但有时它就是有意义。</strong></p><p id="6c08" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><strong class="ky ir">在这种特殊情况下，</strong>对话框依赖于按钮，由于按钮的状态作为<code class="fe mq mr ms mf b">open</code>道具传递给对话框组件，<strong class="ky ir">观察对话框组件内按钮状态的变化是没有意义的。我没有在<code class="fe mq mr ms mf b">useEffect</code>内部做任何<strong class="ky ir">异步</strong>的事情，并且钩子对于<strong class="ky ir">基于<code class="fe mq mr ms mf b">props</code>的变化更新内部</strong>状态是不必要的。迈克尔·兰迪斯有一篇关于这方面的精彩文章。</strong></p><p id="edf0" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">然而，假设你想让<strong class="ky ir">执行异步</strong>操作，而<strong class="ky ir">依赖于一个被传递的属性</strong>，就像你想获取用户输入的位置的天气。</p><p id="3675" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">您可以有一个组件接收<code class="fe mq mr ms mf b">location</code>作为一个属性，并将它放在<code class="fe mq mr ms mf b">useEffect</code>的依赖数组中，它将执行异步搜索。</p><p id="ac1d" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在这种情况下，<strong class="ky ir">有意义的原因是<strong class="ky ir">异步操作完全依赖于作为道具传递的用户输入。在我看来，类似这样的事情是有道理的:</strong></strong></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f446" class="mj jz iq mf b gy mk ml l mm mn">interface WeatherDisplayProps {<br/>  location: string;<br/>}</span><span id="109a" class="mj jz iq mf b gy mo ml l mm mn">const WeatherDisplay: FC&lt;WeatherDisplayProps&gt; = ({ location }) =&gt; {<br/>  const [weather, setWeather] = useState&lt;number&gt;();</span><span id="db16" class="mj jz iq mf b gy mo ml l mm mn">  useEffect(() =&gt; {<br/>    const fetchWeather = async () =&gt; {<br/>      const response = await WeatherAPI.getWeather(location);<br/>      setWeather(response.celsius);<br/>    };</span><span id="c96d" class="mj jz iq mf b gy mo ml l mm mn">    fetchWeather();<br/>  }, [location]);</span><span id="1801" class="mj jz iq mf b gy mo ml l mm mn">return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Weather&lt;/h1&gt;<br/>      &lt;p&gt;<br/>        Today weather in {location} is {weather} celsius{" "}<br/>      &lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="7bcd" class="mj jz iq mf b gy mo ml l mm mn">export default WeatherDisplay;</span></pre><p id="2dc3" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><a class="ae lu" href="https://medium.com/@dan_abramov" rel="noopener">丹·阿布拉莫夫</a>注意到<a class="ae lu" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">这不再是绝对必要的</a>，但是如果它可以方便的话。</p><h1 id="95b1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="ed00" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">是一个很棒的钩子，但有时会很混乱。它可以用于预期目的之外的许多事情，但这并不意味着它应该如此。</p><p id="a310" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我犯了一个不必要的错误，使用它导致了性能的下降，但幸运的是，我找到了一个非常优雅的解决方案，并希望与每个遇到相同问题的人分享。</p><p id="fd9c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">引用:</p><p id="527b" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">[1] MUI对话框组件:<a class="ae lu" href="https://mui.com/material-ui/react-dialog/" rel="noopener ugc nofollow" target="_blank">https://mui.com/material-ui/react-dialog/</a></p><p id="0fc2" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">[2]费利克斯·格绍:<a class="ae lu" href="https://felixgerschau.com/" rel="noopener ugc nofollow" target="_blank">https://felixgerschau.com/</a></p><p id="14fd" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">[3]Felix Gerschau<em class="mp">React何时重新渲染组件？</em>:<a class="ae lu" href="https://felixgerschau.com/react-rerender-components/" rel="noopener ugc nofollow" target="_blank">https://felixgerschau.com/react-rerender-components/</a></p><p id="734a" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">[4]容器组件:<a class="ae lu" href="https://medium.com/@learnreact/container-components-c0e67432e005" rel="noopener">https://medium . com/@ learn react/Container-Components-c0e 67432 e 005</a></p><p id="2f71" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">[5]迈克尔·兰迪斯:<a class="ae lu" href="https://michaellandis.medium.com/" rel="noopener">https://michaellandis.medium.com/</a></p><p id="2b7f" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">[6]迈克尔·兰迪斯<em class="mp">用React钩子从属性更新状态</em>:<a class="ae lu" href="https://betterprogramming.pub/updating-state-from-properties-with-react-hooks-5d48693a4af8" rel="noopener ugc nofollow" target="_blank">https://better programming . pub/Updating-State-From-Properties-With-React-Hooks-5d 48693 a4 af 8</a></p><p id="c2ee" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">[7]丹·阿布拉莫夫:<a class="ae lu" href="https://medium.com/@dan_abramov" rel="noopener">https://medium.com/@dan_abramov</a></p><p id="0f39" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">[8] Dan Abramov <em class="mp">表象与容器组件</em>s:<a class="ae lu" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">https://medium . com/@ Dan _ abra mov/smart-and-dumb-components-7 ca 2 f 9 a 7 c7d 0</a></p></div></div>    
</body>
</html>