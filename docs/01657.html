<html>
<head>
<title>Advanced Concepts in C — Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C结构中的高级概念</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/advanced-concepts-in-c-structures-254fe156b3fb?source=collection_archive---------6-----------------------#2020-01-20">https://levelup.gitconnected.com/advanced-concepts-in-c-structures-254fe156b3fb?source=collection_archive---------6-----------------------#2020-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b88aa5c30ba34a9c8d208aacd7b298d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1gN4Tf4rHQOKDdKAsynnGg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@adigold1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿迪·戈尔茨坦</a>在<a class="ae kf" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5794" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天我想和大家分享一些C语言中的高级概念。我遇到了这些概念，它们是很好的特性，但是很少被使用，或者至少我没有经常看到它们被使用。今天我们将讨论…</p><h1 id="7321" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结构</h1><p id="bbf0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在我看来，很少有人使用结构或者知道它们是什么和有什么用处。</p><blockquote class="mh mi mj"><p id="8a36" class="kg kh mk ki b kj kk kl km kn ko kp kq ml ks kt ku mm kw kx ky mn la lb lc ld im bi translated">结构创建的数据类型可用于将可能不同类型的项分组为单一类型。</p></blockquote><p id="23d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结构更注重可读性。我们可以将属于同一类的变量分组。让我们假设您需要处理某人的地址。而不是这个:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e5d3" class="mx lf it mt b gy my mz l na nb">void main() {  <br/>        char street[50] = "Somestreet";  <br/>        int housenumber = 123;  <br/>        int postcode[5] = {4,3, 2, 1, 0};  <br/>        char city[20] = "SomeCity";<br/>}</span></pre><p id="242c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以把它组织成一个结构。首先，我们必须声明结构。我们声明了一个包含街道名、门牌号、5位邮政编码和城市的结构。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a2ab" class="mx lf it mt b gy my mz l na nb">struct address {<br/>        char street[50];<br/>        int housenumber;<br/>        int postcode[5];<br/>        char city[20];<br/>};</span></pre><p id="1025" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以在主函数中定义一个变量，并像下面这样初始化它:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ddb6" class="mx lf it mt b gy my mz l na nb">void main() {<br/>         struct address myAddress = {<br/>                "SomeStreet",<br/>                123,<br/>                {1, 2, 3, 4, 5},<br/>                "SomeCity"<br/>        };<br/>        printf("House Number: %u\n", myAddress.housenumber)<br/>}</span></pre><p id="0921" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这给了我们<code class="fe nc nd ne mt b">House Number: 123</code>。</p><p id="a9f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结构可以像其他变量一样处理。您可以将它传递给一个函数，构建一个结构数组，或者在结构中嵌套结构。</p><p id="3f5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结构对于将数据组织在一起非常有用。如果您需要处理数据，例如<code class="fe nc nd ne mt b">memcpy</code>，如果您已经将它们分组到一个结构中，就会容易得多。但是要小心:由于填充，结构在内存中可能更大。但是这是如何工作的呢？</p><h2 id="e170" class="mx lf it bd lg nf ng dn lk nh ni dp lo kr nj nk ls kv nl nm lw kz nn no ma np bi translated">“结构”的记忆结构</h2><p id="ccc2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们使用结构时，我们需要知道它们在内存中是如何排列的。数据结构成员按顺序存储在内存中，因此该结构的大小正好是它所包含成员的倍数。我给你举个例子。以下结构</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7ca8" class="mx lf it mt b gy my mz l na nb">struct data {<br/>    uint8_t val1;<br/>    uint8_t val2;<br/>    uint8_t val3;<br/>};</span></pre><p id="ff0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正好是三个字节。这里的对齐是一个字节，因为每个成员都是一个<code class="fe nc nd ne mt b">uint8_t</code>，这是一个字节，所以结构本身是其成员的倍数，三个字节。</p><blockquote class="nq"><p id="9b98" class="nr ns it bd nt nu nv nw nx ny nz ld dk translated">结构对齐取决于结构中的类型。</p></blockquote><p id="9283" class="pw-post-body-paragraph kg kh it ki b kj oa kl km kn ob kp kq kr oc kt ku kv od kx ky kz oe lb lc ld im bi translated">当我们使用混合型结构时，对齐会稍微复杂一点。以下结构</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4534" class="mx lf it mt b gy my mz l na nb">struct data2 {<br/>    uint8_t val1;<br/>    uint32_t val2;<br/>    uint8_t val3;<br/>};</span></pre><p id="b074" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">技术上是六个字节，对吗？我们有两个单字节值，一个四字节值等于六。<strong class="ki iu">很遗憾，这是不正确的</strong>。我们忘了衬垫。如果我们创建混合类型的结构，填充符通常也等于我们在结构中使用的最大类型。但是请注意——这是特定于实现的！我们来看看结构<code class="fe nc nd ne mt b">struct data2</code>在内存中是什么样子的。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div class="gh gi of"><img src="../Images/8d036ac18ee73988fcdd9f70bd12289a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*V4ZCduXs6-j3_qnSj5Mdqw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><strong class="bd lg">数据2 </strong>的存储结构</figcaption></figure><p id="052a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我之前说过的，内存中结构的对齐将等于我们的结构中使用的最大类型——所以它将是<code class="fe nc nd ne mt b">uint32_t</code> : 4字节。这意味着该结构将以4字节的块放入内存。如果下一个值不再适合4字节块，则当前块将用零填充(填充),并将使用新块。实际上，结构<code class="fe nc nd ne mt b">struct data2</code>在内存中是12字节<em class="mk">大</em>。</p><p id="7be4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们像这样重新排列结构</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3a63" class="mx lf it mt b gy my mz l na nb">struct data3 {<br/>    uint8_t val1;<br/>    uint8_t val3;<br/>    uint32_t val2;<br/>};</span></pre><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div class="gh gi of"><img src="../Images/052667d606e861094a5ac354f1c17f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Cf8HJ58muzApvYAFzGvxKA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><strong class="bd lg">数据3的存储结构</strong></figcaption></figure><p id="d9e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它仍然包含相同数量的值，但是在内存中，它看起来完全不同。</p><p id="5182" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，<em class="mk"> val1 </em>和<em class="mk"> val3 </em>适合放在一个块中。显然<em class="mk"> val2 </em>不再适合，所以该块被填充，<em class="mk"> val2 </em>进入下一个块。结构中变量的顺序对结构的大小有很大的影响。如果你考虑将数据直接存储到一个结构中，或者反之亦然，了解这一点是非常重要的。</p><h2 id="02f9" class="mx lf it bd lg nf ng dn lk nh ni dp lo kr nj nk ls kv nl nm lw kz nn no ma np bi translated">修改对齐方式</h2><p id="220c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有几种方法可以修改结构的对齐方式。它们都是特定于编译器的，但应该适用于大多数编译器。如果你想将对齐设置为一个字节，这样在结构的内存中就没有填充，你可以使用<code class="fe nc nd ne mt b">__packed</code>关键字。像这样定义你的结构</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="648b" class="mx lf it mt b gy my mz l na nb">struct __attribute__((__packed__)) data {<br/>    uint8_t val1;<br/>    uint32_t val2;<br/>    uint8_t val3;<br/>};</span></pre><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div class="gh gi og"><img src="../Images/e77b9c2c5c4c1ecb647ab0287ced7c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*bjAEmaaIuXuNyQx2UkAY5w.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">数据打包的存储结构</figcaption></figure><p id="df70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且您的编译器不会向该结构添加填充。记忆中，是这样的。</p><p id="0067" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该结构的大小正好是六个字节。请注意，删除填充会导致代码变慢。这应该只用于大小<strong class="ki iu">很重要或者你想直接从输入流中调用数据的情况，例如，串行到一个结构中。</strong></p><p id="354e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你在c语言中使用<code class="fe nc nd ne mt b">pragma</code>也能得到同样的效果。<code class="fe nc nd ne mt b">pragma pack</code>指令改变了最大对齐。聪明的做法是只为你想要的结构设置<code class="fe nc nd ne mt b">pragma pack</code>，而不是为整个项目设置。如果您想要更改对齐方式，它的工作方式如下:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="33dc" class="mx lf it mt b gy my mz l na nb">#pragma pack(push)<br/>#pragma pack(1)</span><span id="4053" class="mx lf it mt b gy oh mz l na nb">struct data {<br/>        uint8_t val1;<br/>        uint32_t val2;<br/>        uint8_t val3;<br/>};</span><span id="a5c3" class="mx lf it mt b gy oh mz l na nb">#pragma pack(pop)</span></pre><p id="c687" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne mt b">#pragma pack(push)</code>将实际校准设置推送到内部堆栈，以便我们稍后可以再次恢复该设置。<code class="fe nc nd ne mt b">#pragma pack(1)</code>将最大对齐设置为一个字节，后跟结构定义。之后，我们再次用<code class="fe nc nd ne mt b">#pragma pack(pop)</code>、<em class="mk">从内部堆栈中弹出</em>来恢复之前的对齐设置。</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><p id="a2d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您处理的数据能够以某种方式聚集在一起，那么结构会非常有用。即使它没有为您节省任何内存，您的代码将获得更好的可读性。</p><p id="939f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">感谢阅读！</strong></p></div></div>    
</body>
</html>