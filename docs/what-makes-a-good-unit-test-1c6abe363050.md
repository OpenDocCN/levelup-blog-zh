# 什么是好的单元测试？

> 原文：<https://levelup.gitconnected.com/what-makes-a-good-unit-test-1c6abe363050>

## 一个好的测试是你运行的测试。我们如何确保我们的单元测试是好的？

![](img/78e3ccba16a72e98d40f7db1252fd605.png)

在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上由 [Oleksandr Horbach](https://unsplash.com/@grbchh?utm_source=medium&utm_medium=referral) 拍摄的照片

每当围绕自动化测试的对话出现时，不可避免地，有人会提出这样的问题:什么是好的测试。这个问题的答案往好里说是相互矛盾的，往坏里说是非常有害的。

我的回答一直是，好的测试是你运行的测试。但是，当我这么说的时候，几乎总会有人用一个运行但从未中断的测试的例子来回应。对此，我说这不是一个测试。

因此，让我们定义一下本文中所谓的测试。

## 什么是(单元)测试？

在本文中，我们将特别关注单元测试。然而，在我们定义什么是单元*测试*之前，我们必须确定什么是*单元*。

> **单元**是从输入到输出的独立特征。

这是一个非常宽泛的定义，但是本质上，一个单元可以是一个单一的功能或者一组类，如果这些类作为一个团队来完成一个单一的*活动。*

如何分解这些活动是语义上的，在我看来，应该作为一个团队来讨论。

那么，既然我们知道了什么是单元，那么什么是单元测试呢？

> 一个**单元测试**是用来验证一个单元代码成功地帮助完成产品目标的代码。

同样，这是故意含糊其辞。在我的日常工作中，我安排我的单元测试，以便它们直接验证特性的接受标准，或者作为单独的测试，或者作为测试或断言的集合。通过这种方式，我可以编写表达商业价值的测试，而不是确认技术实现细节的测试。

## 什么是好的测试？

好的单元测试的定义和一般的单元测试的定义一样有争议。

然而，我有几条我试图遵循的准则:

一个*好的*单元测试应该:

*   富有表现力
*   清楚地落在单元的边界内
*   迅速执行
*   *可靠地执行*和**
*   *失败时产生有用的输出*

*让我们开始吧…*

## *表达测试*

*有几种方法可以让我们的测试更有表现力。最明显和最容易的是注释我们的代码。为每个测试写清楚全面的注释是很重要的。在我们的评论中，我们应该涵盖为什么测试是必要的，测试证明了什么，以及如果测试失败对产品的风险。*

*这是我看到大多数人忘记的最后一点，也是最重要的一点。*

*当一个测试失败了，而团队不知道为什么这个测试是必要的，会发生什么？在一个完美的世界中，团队将执行一些质量保证，找出测试失败的原因，并修复它。实际上，团队将执行一些质量保证，看不出产品有什么问题。*

*当一个测试失败了，没有人发现产品有任何问题，会发生什么？那个测试被删除了。*

*现在，关于这个测试在删除点有两件事是正确的:*

*   *测试本身毫无用处，没有人知道这一点。；或者*
*   *由于一个重要的原因，测试失败了，但是失败的结果被埋得足够深，以至于团队在将来会猛然醒悟。*

*虽然我们应该总是对这些关于测试的基本细节进行评论，但是还有其他方法可以让我们的测试更有表现力:通过意识到我们产品的架构，通过编写高质量的变量名，只是总体上关注干净的代码。*

## *落在单元边界内*

*当我们定义了我们的单元是什么时，我们应该确保我们在测试中不打破这个界限。设定清晰的界限意味着知道我们应该模仿什么代码，以及我们应该在哪里定义我们的断言。*

*这都属于安排、行动、断言的范畴。当我们安排我们的测试时，我们创建我们需要的任何模拟，并初始化我们将要进行测试的任何代码。*

*在我们的 Act 阶段，我们正在执行将要测试的代码单元。通常，这将是对单个方法的单个调用，但在某些情况下，我们可能会进行多次调用。这个想法是我们将调用限制在被测试的代码上。*

*最后，在我们的断言阶段，我们包含对测试中代码的预期输出的断言。*

*也就是说，这可能是一个棘手的情况。*

## *方案*

*你在为一个内容管理系统写代码。在这个系统中，您有一个特定的内容类型来引用外部实体，比如其他博客，并将您的用户链接到这些外部来源。*

*作为这个系统的一部分，您正在编写一个特性，检查被引用的内容是否是有问题的内容类型。如果是这样，任何指向该内容内部版本的链接都应该指向该内容的外部版本。*

*我们应该嘲笑什么？我们的断言应该是什么？*

## *回答*

*这是一个有点棘手的问题。我们不需要在这里嘲笑任何东西，因为这个单元是独立的。我们将在这里引用 CMS 的更深层次的部分——特别是检索 URL 的代码，可能还有创建内容的代码——但即使如此，这些都是“单元”的一部分，因此它们不需要被嘲笑。*

*他们应该被测试吗？可能不在我们的测试中。仅仅因为它们是这个单元的一部分，并不意味着在这个测试套件中测试它们有任何商业价值。在我们的情况下，我们应该假设它们有效。然而，如果存在失败，我们应该能够在调试中容易地追溯到这些方法。*

*但是我们的断言应该是什么呢？这就是事情变得棘手的地方。首先，我们需要断言来证明我们在这些内容类型上看到了正确的 URL。但是所有其他内容类型呢？我们需要在那里断言什么吗？*

*答案是主观的，但我要说，在这种情况下，它是有意义的。与我们的特定单元不相关的内容类型的断言仍然是对我们的单元的断言。*

*为什么因为我们正在执行我们所谓的*否定断言*。或者，简而言之，我们正在确保我们没有无意中弄糟其他东西。*

*我们执行这个断言的方式必须小心处理。如果我们过于具体，那么如果内容类型发生变化，我们就冒着断言失败的风险。*

*在这种情况下，我们不关心到该内容类型的实际链接是什么。相反，我们只关心链接是什么*而不是*。因此，我们编写断言来确保内容类型的链接是*而不是*到外部 URL 的链接。如果断言失败，我们的单元将影响其预期单元之外的代码。这是一个我们需要修复的失败，因此，这是一个合理的断言。*

## *快速执行*

*研究表明，人类的注意力持续时间约为 10 秒。任何超过 10 秒的事情都意味着我们容易分心。*

*这是写代码时的一个问题。*

*单元测试应该在你开发的时候运行。这意味着您应该在本地频繁地运行它们。因此，您正在执行的测试数量应该在 10 秒的限制内完成。*

*如果你每隔几行代码就执行一整套测试，那么整套测试应该在 10 秒内完成。相反，如果您将测试限制在您正在积极工作的测试上，那么您可能会延长测试时间。*

*运行测试所花费的时间应该尽可能少，以有效地满足所有其他需求。*

*一个好的经验法则是:如果你发现你的测试套件需要超过 10 秒的时间来完成，很有可能你的单元规模太大了。*

*你能找到一种方法把特征分成更小的单元吗？*

*你能找到一种方法来重构你的测试以提高速度吗？*

## *可靠地执行*

*使用 WordPress，我在测试代码时经常遇到的一件事是不可靠的测试。这是一个严重依赖全球范围的系统的症状。*

*有用的单元测试应该在每次连续运行时产生相同的结果。如果代码没有改变，那么在两次运行之间测试失败的风险应该为零。如果您发现这种情况发生，那么您的系统中的问题需要被解决——要么是测试本身的问题，要么是您正在使用的测试框架的问题。*

*我遇到的这种失败最常见的方式之一是在测试中使用随机化。有时这听起来像是唯一的选择——例如，在为 FakerPHP 的血型 faker 编写测试时，我最初的尝试是生成 100 种血型，并验证每种血型在输出中至少存在一次，当在本地执行时，在许多次运行中都没有失败。*

*问题是当像这样使用随机化的时候，T4 可能会失败。这是最重要的部分。因为风险就在那里——无论多么遥远——我们需要一个更好的选择。对我们来说幸运的是，faker 已经包含了名为`UniqueGenerator`的解决方案，它确实像它听起来的那样——它生成特定 Faker 的所有独特的可能输出。*

*在我们看来，在当时，这是验证特性功能的最有效的方法。*

*因为测试的质量不是二元的。有时候你必须牺牲性能来换取可靠性。*

## *失败时产生有用的输出*

*测试旨在证明我们代码的稳定性。这意味着有两种方法可以知道测试是否有效:如果测试从未失败，或者如果测试失败的原因与您的单元中的问题无关。*

*这两种情况都意味着你需要重新考虑你的测试，但让我们谈谈后一个问题。如果一个测试因为单元之外的原因失败了，我们就没有成功地包含我们的单元。我们在我们的代码中跨越了我们可能不应该跨越的边界。*

*在使用 WordPress 的过程中，我多次看到的另一种情况是肮脏的全局作用域在测试之间留下了工件。我们的`setUp`和`tearDown`方法确保我们在测试运行之间有一个干净的范围。*

*如果您的测试在您直接运行时通过了，但是在您运行整个测试套件时都失败了，那么您很可能正在处理这种类型的问题。解决方案根据确切的原因而变化，但是几乎总是可以通过在测试的清理操作中考虑脏范围来解决。*

*无论我们的测试如何失败，最重要的是要有清晰简洁的失败消息。如果你的信息只是简单地说了一些类似于`Failed asserting that false is equal to true`的话，那么你就没有足够的信息来解决这个问题。*

*然而，如果您的失败消息是这样的，`User authentication check returned false when we expected it to return true`我们现在确切地知道错误值来自哪里，并且我们对从哪里开始寻找问题有了一些想法。*

*测试永远也不能告诉我们代码到底出了什么问题，但是我们可以通过使我们的错误消息比平常更加健壮来帮助我们的调试过程。*

# *最后*

*如果你的单元测试不符合上面的标准，它们就不是好的单元测试。它们要么运行得不够，要么运行得很多，但不会为执行测试的开发人员提供任何实际价值。*

*最终，编写测试的目标是让我们的开发人员在实现变更时更轻松，并保护我们的软件在产品扩展时不会退化。编写大量的测试不足以完成这一点。*

*我宁愿有一个只有几个有价值的测试的测试套件，也不要有成千上万个没有价值的测试。*

*你喜欢这篇文章吗？ [*成为会员*](https://travisweston.com/membership) *阅读我写的所有东西——以及媒体上的所有内容。**

**已经是会员了？* [*订阅得到通知*](https://travisweston.com/subscribe) *当我放出新文章的时候。**

**我目前在* [*胡同*](https://alley.co/) *工作，一家文字社。我们目前正在招聘，那么为什么不* [*申请和我*](https://alley.co/careers/) *一起工作呢？**