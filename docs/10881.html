<html>
<head>
<title>Serverless Caching Strategies — Part 3 (Lambda Runtime) 🚀</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器缓存策略—第3部分(Lambda运行时)🚀</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/serverless-caching-strategies-part-3-lambda-runtime-b3d21250927b?source=collection_archive---------1-----------------------#2022-01-20">https://levelup.gitconnected.com/serverless-caching-strategies-part-3-lambda-runtime-b3d21250927b?source=collection_archive---------1-----------------------#2022-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8418148d31a79f698e2562802f3e7cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgTZPxqmXbKLts_DPO3mYg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/@maartendeckers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马腾·戴克斯</a>在<a class="ae jd" href="https://unsplash.com/s/photos/squares?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="9157" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">如何在您的解决方案中使用无服务器缓存策略，包括用TypeScript和CDK编写的代码示例和视觉效果，以及GitHub中的相关代码库。第3部分介绍Lambda运行时环境中的缓存。</h2></div><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi kv"><img src="../Images/ae84082cb2ee91775bc4d29dcbfff0ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lGRoZP_rhPkobZ-ZR0jJ0g.png"/></div></div></figure><h1 id="d69c" class="la lb jg bd lc ld le lf lg lh li lj lk km ll kn lm kp ln kq lo ks lp kt lq lr bi translated">介绍</h1><p id="7c5e" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">这是一系列文章的第3部分，涵盖了AWS上的无服务器缓存策略，以及为什么应该使用它们。Github回购可以在这里找到【https://github.com/leegilmorecode/serverless-caching T4】。</p><p id="7f53" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这一部分将介绍Lambda运行时环境中的缓存。</p><p id="a3d8" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵<a class="ae jd" href="https://leejamesgilmore.medium.com/serverless-caching-strategies-part-1-amazon-api-gateway-c2d680d5b3b" rel="noopener">本文的第1部分介绍了使用Amazon </a> API Gateway在API层进行缓存。</p><p id="c99c" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵<a class="ae jd" href="https://leejamesgilmore.medium.com/serverless-caching-strategies-part-2-amazon-dynamodb-dax-d841e1e1ad0e" rel="noopener">本文的第2部分使用<em class="mt"> DynamoDB DAX </em> </a>查看数据库级别的缓存。</p><p id="f2db" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵<strong class="lu jh">本文的第3部分将关注<em class="mt"> Lambda </em>运行时环境本身中的缓存。</strong></p><p id="66d4" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵<a class="ae jd" href="https://leejamesgilmore.medium.com/serverless-caching-strategies-part-4-appsync-7fe6ede93183" rel="noopener">本文的第4部分将着眼于<em class="mt"> AppSync </em>级别</a>的缓存。</p><p id="a0ed" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵本文的第5部分将讨论使用<em class="mt"> CloudFront </em>在CDN级别进行缓存。</p><p id="cba0" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">本文由<a class="ae jd" href="https://www.sedai.io/" rel="noopener ugc nofollow" target="_blank"> Sedai.io </a>赞助</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/4c77bc2d275bd557dda90aa2fe842d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJqkQYFI-KAGHOI3cHWxJQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://www.sedai.io/" rel="noopener ugc nofollow" target="_blank">https://www.sedai.io/</a></figcaption></figure><h1 id="28fe" class="la lb jg bd lc ld le lf lg lh li lj lk km ll kn lm kp ln kq lo ks lp kt lq lr bi translated">快速回顾👨‍🏫</h1><p id="0472" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">下图显示了您可以在无服务器解决方案中缓存的一些区域:</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mv"><img src="../Images/f8a01094186503102731ec93b378d901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZpr7lYQwhXqRsCSQWCTuQ.png"/></div></div></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="b9be" class="la lb jg bd lc ld nd lf lg lh ne lj lk km nf kn lm kp ng kq lo ks nh kt lq lr bi translated">我们在建造什么？🏗️</h1><p id="813a" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">正如本系列的第1部分所描述的，这是我们正在构建的；我们将重点关注本文中以粉色突出显示的区域:</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/9133489e20b068b8ac272524f9e16a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7hKKy6QllimzGDobLsw8EA.png"/></div></div></figure><h1 id="94ee" class="la lb jg bd lc ld le lf lg lh li lj lk km ll kn lm kp ln kq lo ks lp kt lq lr bi translated">无服务器博客✔️</h1><p id="bd12" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">无服务器博客有以下流程:</p><p id="d27f" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">⚪一个CloudFront发行版缓存了React网站，该网站以一个S3 bucket作为其源。我们可以在这个级别缓存web应用程序。</p><p id="2ec6" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">react应用程序利用GraphQL API通过AWS AppSync访问其数据。<em class="mt">对于某些端点，我们可能会考虑使用AppSync缓存。</em></p><p id="30b5" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">appsync api通过Lambda解析DynamoDB的数据，我们使用DAX作为数据库前端的缓存。在这里，我们可以利用DAX在数据库级别进行缓存。</p><h1 id="676e" class="la lb jg bd lc ld le lf lg lh li lj lk km ll kn lm kp ln kq lo ks lp kt lq lr bi translated">AWS新闻博客✔️</h1><p id="2a73" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">AWS新闻博客有以下流程:</p><p id="e558" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">⚪一个CloudFront发行版缓存了React网站，该网站以一个S3 bucket作为其源。<em class="mt">我们可以在这个级别缓存web应用。</em></p><p id="8d46" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">react应用程序通过亚马逊API网关为其数据利用REST API。<em class="mt">我们在API网关内的API级别进行缓存。</em></p><p id="64d3" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">⚪对于缓存未命中，我们使用Lambda函数从无服务器的Aurora数据库中检索数据。在这种情况下，我们还可以在lambda本身中缓存某些数据。</p><blockquote class="nj nk nl"><p id="ac55" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg">💡</em> <strong class="lu jh"> <em class="jg">注意</em> </strong> <em class="jg"> : </em>这是允许我们在文章中讨论关键架构点的最小代码和架构，因此这不是生产就绪的，并且不符合编码最佳实践。(例如，在端点上没有认证)。我还尽量不把代码分割得太多，这样所有依赖关系都在一个文件中的示例文件就很容易查看。</p></blockquote></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="1814" class="la lb jg bd lc ld nd lf lg lh ne lj lk km nf kn lm kp ng kq lo ks nh kt lq lr bi translated">我们如何在Lambda本身中进行缓存？✔️</h1><p id="aa3d" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">有几种方法可以在lambda本身中进行缓存:</p><p id="0a49" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵Lambda运行时环境中的缓存(内存中的<em class="mt"/>)。</p><p id="b13e" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵Lambda上/tmp文件夹中的缓存。</p><p id="bdba" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵使用AppConfig Lambda层缓存机密。</p><blockquote class="nj nk nl"><p id="0add" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg">💡</em> <strong class="lu jh">注意</strong>:使用lambda layers/extensions和AppConfig缓存秘密已经在下面的文章中讨论过了。</p></blockquote><div class="ip iq gp gr ir np"><a rel="noopener  ugc nofollow" target="_blank" href="/serverless-feature-flags-6e49d534e79f"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd jh gy z fp nu fr fs nv fu fw jf bi translated">无服务器功能标志🚀</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">带有lambda扩展和AppConfig的无服务器功能标志</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ix np"/></div></div></a></div><h2 id="b76d" class="oe lb jg bd lc of og dn lg oh oi dp lk mb oj ok lm mf ol om lo mj on oo lq op bi translated">Lambda运行时环境✔️中的缓存</h2><p id="5371" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">一旦Lambda容器被初始化并第一次运行，它将在以后的调用中持续存在(<em class="mt">，当连接到VPC时，它将在大约15分钟的不活动状态中保持温暖，当没有连接时，它将在大约5分钟内保持温暖</em>)。</p><p id="8148" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在Lambda处理程序本身之外创建的任何东西都将在Lambda容器预热期间保留在内存中，直到进一步调用。</p><p id="3de0" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们可以使用上面的这两个特性来允许我们在第一次运行时在Lambda处理程序之外填充一个变量；在我们的示例中，从数据库调用中填充数据(<em class="mt"> blogs </em>);然后对Lambda容器的后续调用将从内存中读取数据(<em class="mt">，而不是每次都返回数据库</em>)。</p><p id="2218" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">让我们看看下面一个带注释的基本代码示例:</p><figure class="kw kx ky kz gt is"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="3852" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在我们的场景中，我们很高兴文章列表很少改变(<em class="mt">比方说每月一次</em>)，并且这种方式的缓存可能比API网关级别的缓存更具成本效益，或者在每次lambda调用时从数据库中连续读取。还有一个巨大的性能增益。</p><p id="96b5" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">然而，我们确实需要考虑到，当一篇新的博客文章发表时，这些温暖的羔羊可能需要一点时间死去，内存中的缓存需要再次恢复水分。</p><blockquote class="nj nk nl"><p id="99bc" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg">💡</em> <strong class="lu jh"> <em class="jg">注意</em> </strong> <em class="jg"> : </em>我们当然可以通过在内存缓存中添加一个TTL来解决这个问题，并在给定的一段时间后重新水化。</p></blockquote><blockquote class="os"><p id="1c54" class="ot ou jg bd ov ow ox oy oz pa pb mn dk translated">“这种方式的缓存可能比API网关级别的缓存更具成本效益”</p></blockquote><p id="f376" class="pw-post-body-paragraph ls lt jg lu b lv pc kh lx ly pd kk ma mb pe md me mf pf mh mi mj pg ml mm mn ij bi translated">在这种情况下，我们需要考虑无服务器解决方案中可以缓存的所有方面，并根据成本、复杂性、业务需求和性能选择合适的解决方案。</p><blockquote class="nj nk nl"><p id="7ff6" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg">💡</em> <strong class="lu jh"> <em class="jg">注</em> </strong> <em class="jg"> : </em>过去的一个真实例子是Lambda缓存来自客户端的访问令牌-凭证授权流(机器到机器流)。这个访问令牌大约有24小时的有效期，所以我们不需要为每个请求生成令牌，而是将令牌缓存在内存中。</p></blockquote><blockquote class="os"><p id="b729" class="ot ou jg bd ov ow ox oy oz pa pb mn dk translated">“在这种情况下，我们需要考虑我们的无服务器解决方案中可以缓存的所有方面，并根据成本、复杂性和性能选择正确的解决方案。”</p></blockquote><h2 id="f851" class="oe lb jg bd lc of ph dn lg oh pi dp lk mb pj ok lm mf pk om lo mj pl oo lq op bi translated">Lambda ✔️上/tmp文件夹中的缓存</h2><p id="1419" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">与上面类似，我们能够在Lambda上填充高达512MB的<code class="fe pm pn po pp b">/tmp</code>文件夹，然后这个短暂的文件存储将在以后的调用中保持不变。</p><blockquote class="nj nk nl"><p id="cd42" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated">“Lambda执行环境为您的代码提供了一个在/tmp使用的文件系统。该空间的固定大小为512 MB。多个Lambda调用可以重用同一个Lambda执行环境来优化性能。/tmp区域在执行环境的生命周期内被保留，并为调用之间的数据提供临时缓存。每次创建新的执行环境时，都会删除这个区域。</p><p id="3119" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated">因此，这是一个短暂的存储区域。虽然函数可以在调用之间缓存数据，但它应该只用于代码在一次调用中需要的数据。它不是一个永久存储数据的地方，最好用于支持代码所需的操作。"—<a class="ae jd" href="https://aws.amazon.com/blogs/compute/choosing-between-aws-lambda-data-storage-options-in-web-apps/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/blogs/compute/choosing-between-AWS-lambda-data-storage-options-in-we B- apps/</a></p></blockquote><p id="7710" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在我们的例子中，我们从亚马逊S3提取一些静态对象(<em class="mt">徽标图像文件</em>，然后将它们写入Lambda上的<code class="fe pm pn po pp b">tmp</code>文件夹。在Lambda的进一步调用中，logo文件保留在tmp中，并且我们不再需要在第一次调用之后联系S3(每个Lambda实例)。</p><p id="8bb1" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在这种情况下，我们可以提高Lambdas的速度，并大幅降低成本；然而，如上所述，文件可能已经过时，不会改变，直到Lambda是一个新的容器。</p><p id="ba8a" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">下表显示了Lambda存储类型的相对速度:</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pq"><img src="../Images/42b5d20b4bfac16a2817dde3d94056db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yX1Y9OLyUowEHAg0meYeCQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://aws.amazon.com/blogs/compute/choosing-between-aws-lambda-data-storage-options-in-web-apps/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/blogs/compute/choosing-between-AWS-lambda-data-storage-options-in-web-apps/</a></figcaption></figure><blockquote class="os"><p id="7d49" class="ot ou jg bd ov ow ox oy oz pa pb mn dk translated">“在这种情况下，我们可以大幅提高速度和降低成本；然而，如上所述，这些文件可能已经过时，不会改变，直到Lambda再次成为一个新的容器。</p></blockquote><p id="9a93" class="pw-post-body-paragraph ls lt jg lu b lv pc kh lx ly pd kk ma mb pe md me mf pf mh mi mj pg ml mm mn ij bi translated">让我们看看下面的一个带注释的基本代码示例，它来自我们的repo，我们将S3的徽标文件缓存到tmp目录中:</p><figure class="kw kx ky kz gt is"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="b601" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">就像我们上面讨论的内存缓存一样，这是我们需要考虑我们的无服务器解决方案中可以缓存的所有领域，并根据成本、复杂性和性能(<em class="mt">以及限制，如512 MB的最大临时存储大小</em>)选择正确的解决方案。</p><blockquote class="nj nk nl"><p id="909e" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg">💡</em></p></blockquote></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="3c96" class="la lb jg bd lc ld nd lf lg lh ne lj lk km nf kn lm kp ng kq lo ks nh kt lq lr bi translated">入门！✔️</h1><p id="5afa" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">首先，使用以下git命令克隆以下repo:</p><pre class="kw kx ky kz gt pr pp ps pt aw pu bi"><span id="20d0" class="oe lb jg pp b gy pv pw l px py">git clone <a class="ae jd" href="https://github.com/leegilmorecode/serverless-caching" rel="noopener ugc nofollow" target="_blank">https://github.com/leegilmorecode/serverless-caching</a></span></pre><p id="4f3f" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这将把示例代码下载到您的本地机器上。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="1429" class="la lb jg bd lc ld nd lf lg lh ne lj lk km nf kn lm kp ng kq lo ks nh kt lq lr bi translated">部署解决方案！👨‍💻</h1><p id="8b82" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">🛑 <strong class="lu jh">注意</strong> : <em class="mt">运行以下命令将在您的AWS帐户上产生费用，并且一些服务不在免费层。</em></p><p id="0c69" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在repo的'<code class="fe pm pn po pp b">aws-blog</code>'文件夹中运行以下命令安装所有依赖项:</p><pre class="kw kx ky kz gt pr pp ps pt aw pu bi"><span id="b7d4" class="oe lb jg pp b gy pv pw l px py">npm i</span></pre><p id="dc81" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">完成此操作后，运行以下命令来部署解决方案:</p><pre class="kw kx ky kz gt pr pp ps pt aw pu bi"><span id="3336" class="oe lb jg pp b gy pv pw l px py">npm run deploy</span></pre><p id="3e8f" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🛑 <strong class="lu jh">注意</strong> : <em class="mt">记得在你完成后拆掉堆叠，这样你就不会继续被充电了，通过使用“npm运行移除”。</em></p><blockquote class="nj nk nl"><p id="4730" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg">💡</em> <strong class="lu jh"> <em class="jg">注意</em> </strong> <em class="jg"> : </em>我们使用CustomResource作为部署的一部分来创建blogs表，并用一些虚拟数据填充它，因此您可以直接使用它<em class="jg">。</em></p></blockquote></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="bdd5" class="la lb jg bd lc ld nd lf lg lh ne lj lk km nf kn lm kp ng kq lo ks nh kt lq lr bi translated">测试解决方案🎯</h1><p id="cd4b" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">现在我们已经部署了解决方案，您可以使用postman文件测试端点，该文件可以在这里找到:<code class="fe pm pn po pp b">aws-blog/postman/serverless-caching-aws-blogs.postman_collection.json</code></p><blockquote class="nj nk nl"><p id="44bc" class="ls lt mt lu b lv mo kh lx ly mp kk ma nm mq md me nn mr mh mi no ms ml mm mn ij bi translated"><em class="jg">💡</em> <strong class="lu jh"> <em class="jg">注意</em> </strong>:您还需要将一些示例图像放入已创建的S3桶中。</p></blockquote><h2 id="16f3" class="oe lb jg bd lc of og dn lg oh oi dp lk mb oj ok lm mf ol om lo mj on oo lq op bi translated">我们如何确定缓存正在工作？</h2><p id="cc18" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">让我们看看日志，看看缓存在我们的两个场景中是如何工作的:</p><p id="32b9" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu jh">缓存在内存中</strong> ✔️</p><p id="6004" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们要讨论的第一个场景是在内存中缓存博客，我们可以在下面看到:</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pz"><img src="../Images/be0d94307ef516ab04cbfc2a9764d767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B9RdONJ7MoKIUoFtmZU7gQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">调用内存中的博客端点</figcaption></figure><p id="931d" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们可以从下面的日志中看到:</p><ol class=""><li id="bdae" class="qa qb jg lu b lv mo ly mp mb qc mf qd mj qe mn qf qg qh qi bi translated">随着第一次调用(<em class="mt">和缓存</em> <em class="mt">为空</em>)lambda用了<strong class="lu jh"><em class="mt"/></strong>549毫秒完成(<em class="mt">主要是由于数据库调用和冷启动</em>)</li><li id="9fcc" class="qa qb jg lu b lv qj ly qk mb ql mf qm mj qn mn qf qg qh qi bi translated">对同一个lambda的第二次调用将博客文章缓存在内存中，lambda花了大约<strong class="lu jh"><em class="mt">21毫秒</em> </strong>才完成，根本没有调用数据库。</li></ol><p id="bbe4" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这极大地节省了延迟并提高了性能，而且我们不需要进行进一步的数据库调用，这在使用DynamoDB等数据库时会节省成本。</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qo"><img src="../Images/6d04f129988bc627c48b4bc2e4a29dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKtcGtUff0rdTI7_UN9dAg.png"/></div></div></figure><p id="d6f3" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu jh">临时缓存</strong> ✔️</p><p id="f2c2" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">接下来，我们将关注Lambda本身的<code class="fe pm pn po pp b">tmp</code>文件夹中的缓存文件，特别是从S3桶中提取图像(<em class="mt">徽标</em>)。我们可以从下面的日志中看到:</p><ol class=""><li id="dfcc" class="qa qb jg lu b lv mo ly mp mb qc mf qd mj qe mn qf qg qh qi bi translated">随着第一次调用(<em class="mt">和缓存</em> <em class="mt">为空</em>)的进行，lambda花费了<strong class="lu jh"><em class="mt"/></strong>197毫秒来完成(<em class="mt">主要是由于对S3的调用，以从S3桶和冷启动</em>中拉下标志)</li><li id="ad22" class="qa qb jg lu b lv qj ly qk mb ql mf qm mj qn mn qf qg qh qi bi translated">对同一个lambda的第二次调用将徽标图像缓存在lambda运行时环境中的<code class="fe pm pn po pp b">tmp</code>目录中，Lambda平均花费大约<strong class="lu jh"> <em class="mt"> 4ms </em> </strong>来完成。</li></ol><p id="17d1" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这大大节省了延迟并提高了性能，而且我们不需要再打电话到S3，这样也可以节省成本。</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qp"><img src="../Images/1736dc8a94180345cfd38c00c3c20493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmYpXqgGccdV9iz1fw6ucA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">呼叫徽标端点</figcaption></figure><p id="1ade" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">下面的日志显示了正在进行的缓存:</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi qq"><img src="../Images/68c6b867d67aa97696948f9aa8f9e1b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrQh0KO2sr_PHLh2stng1g.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">显示使用tmp目录进行缓存的示例日志</figcaption></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="b867" class="la lb jg bd lc ld nd lf lg lh ne lj lk km nf kn lm kp ng kq lo ks nh kt lq lr bi translated">有什么优缺点？</h1><p id="1c93" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">现在我们已经讨论了如何在我们的Lambdas中进行缓存；有什么优缺点？</p><h2 id="1862" class="oe lb jg bd lc of og dn lg oh oi dp lk mb oj ok lm mf ol om lo mj on oo lq op bi translated">优势</h2><p id="5de0" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">🔵潜在的成本节约。</p><p id="81ad" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵潜在的性能提升和延迟减少。</p><h2 id="6028" class="oe lb jg bd lc of og dn lg oh oi dp lk mb oj ok lm mf ol om lo mj on oo lq op bi translated">不足之处</h2><p id="2efa" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">🔵只要Lambda是热的，缓存就可以保持不变，因此是不确定的。(<em class="mt">你可以通过在缓存中存储一个TTL时间戳来解决这个问题</em>)。</p><p id="4c9b" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">🔵根据Lambda的吞吐量和伸缩性，可能会有更高效的缓存服务可供使用。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="b199" class="la lb jg bd lc ld nd lf lg lh ne lj lk km nf kn lm kp ng kq lo ks nh kt lq lr bi translated">摘要</h1><p id="b996" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我希望你觉得有用！请继续和我一起完成第4部分和第5部分的缓存之旅！</p><p id="48d1" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">请点击此处订阅我的企业无服务器新闻稿，了解更多相同的内容:</p><div class="ip iq gp gr ir np"><a href="https://www.linkedin.com/newsletters/enterprise-serverless-%F0%9F%9A%80-6875837779876605952/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd jh gy z fp nu fr fs nv fu fw jf bi translated">企业无服务器🚀LinkedIn</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">Lee Gilmore |面向AWS开发人员、DevOps工程师和云架构师的无服务器新闻和文章</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">www.linkedin.com</p></div></div><div class="ny l"><div class="qr l oa ob oc ny od ix np"/></div></div></a></div></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="0701" class="la lb jg bd lc ld nd lf lg lh ne lj lk km nf kn lm kp ng kq lo ks nh kt lq lr bi translated">包扎👋</h1><p id="c546" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">请<a class="ae jd" href="https://www.youtube.com/channel/UC_Bi6eLsBXpLnNRNnxKQUsA" rel="noopener ugc nofollow" target="_blank">前往我的YouTube频道</a>订阅类似内容！</p><figure class="kw kx ky kz gt is gh gi paragraph-image"><div class="gh gi qs"><img src="../Images/efbb111b6d8e2447223b65cbe60d0a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NFiNme3fkHxhXTdK.png"/></div></figure><p id="9e74" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我很乐意就以下任何一个方面与您联系:</p><p id="657d" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">【https://www.linkedin.com/in/lee-james-gilmore/】T3<br/>T5<a class="ae jd" href="https://www.linkedin.com/in/lee-james-gilmore/" rel="noopener ugc nofollow" target="_blank">https://twitter.com/LeeJamesGilmore</a></p><p id="695b" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果你觉得这些文章鼓舞人心或有用，请随时用虚拟咖啡<a class="ae jd" href="https://www.buymeacoffee.com/leegilmore" rel="noopener ugc nofollow" target="_blank">https://www.buymeacoffee.com/leegilmore</a>来支持我，不管怎样，让我们联系和聊天吧！☕️</p><p id="f56d" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果你喜欢这些帖子，请关注我的简介<a class="ae jd" href="https://medium.com/u/2906c6def240?source=post_page-----39c4f4ae5aff----------------------" rel="noopener">李·詹姆斯·吉尔摩</a>以获取更多的帖子/系列，不要忘记联系我并打招呼👋</p><p id="ebaf" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果你喜欢，也请使用帖子底部的“鼓掌”功能！(<em class="mt">可以不止一次鼓掌！！</em>)</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="13b1" class="la lb jg bd lc ld nd lf lg lh ne lj lk km nf kn lm kp ng kq lo ks nh kt lq lr bi translated">关于我</h1><p id="835e" class="pw-post-body-paragraph ls lt jg lu b lv lw kh lx ly lz kk ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">"<em class="mt">大家好，我是Lee，英国的AWS社区构建者、博客作者、AWS认证云架构师和首席软件工程师；目前是一名技术云架构师和首席无服务器开发人员，过去5年主要从事AWS上的全栈JavaScript工作。</em></p><p id="5d55" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><em class="mt">我认为自己是一名无服务器倡导者，热爱AWS、创新、软件架构和技术。</em></p><p id="70ae" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu jh"> ***所提供的信息是我个人的观点，我对这些信息的使用不承担任何责任。*** </strong></p><p id="ae45" class="pw-post-body-paragraph ls lt jg lu b lv mo kh lx ly mp kk ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">您可能还对以下内容感兴趣:</p><div class="ip iq gp gr ir np"><a href="https://leejamesgilmore.medium.com/serverless-content-46ef5b562d8e" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd jh gy z fp nu fr fs nv fu fw jf bi translated">无服务器内容🚀</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">我的所有无服务器内容的索引，可以在一个地方轻松浏览，包括视频、博客文章等..</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">leejamesgilmore.medium.com</p></div></div><div class="ny l"><div class="qt l oa ob oc ny od ix np"/></div></div></a></div></div></div>    
</body>
</html>