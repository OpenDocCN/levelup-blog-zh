<html>
<head>
<title>Simple Consumer Producer Parallelism using GoRoutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GoRoutines的简单消费者生产者并行</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simple-consumer-producer-parallelism-using-goroutines-f2b2bc654eed?source=collection_archive---------7-----------------------#2021-01-31">https://levelup.gitconnected.com/simple-consumer-producer-parallelism-using-goroutines-f2b2bc654eed?source=collection_archive---------7-----------------------#2021-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/38b34b5ac415674ff6b97fa8af4bf9c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FjFh0-2mEAkaSD1yGJvrRg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用GoRoutines的简单消费者生产者并行</figcaption></figure><h1 id="1070" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">为什么？</h1><p id="f343" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">Go编程语言的一个关键优势是通过使用GoRoutines提供了开箱即用的并发支持。大家都知道，GoRoutines可以支持并行支持。然而，并行性在某些情况下是有价值的，例如同时从多个机器学习模型中获得预测。在这种情况下，并发性并不理想。</p><p id="5019" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">现在的问题是一个简单的并行管道看起来像什么？在本文中，我将讨论一个如何使用GoRoutines实现并行的例子。</p><h1 id="2549" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">怎么</h1><p id="d199" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">下面是构成这个例子的组件，</p><ul class=""><li id="3026" class="md me iq lc b ld ly lh lz ll mf lp mg lt mh lx mi mj mk ml bi translated">消费者/来源</li><li id="069c" class="md me iq lc b ld mm lh mn ll mo lp mp lt mq lx mi mj mk ml bi translated">工人01</li><li id="d6c0" class="md me iq lc b ld mm lh mn ll mo lp mp lt mq lx mi mj mk ml bi translated">工人02</li><li id="2cec" class="md me iq lc b ld mm lh mn ll mo lp mp lt mq lx mi mj mk ml bi translated">生产者/接收器</li></ul><p id="1a89" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">在这个例子中，消费者/源将生成数据。接下来，数据将并行移动到worker 01和worker 02。Worker 01和worker 02将并行处理数据，并将处理后的数据移动到生产者/接收器，在这种情况下，生产者/接收器将结束流水线。</p><h2 id="3eda" class="mr kd iq bd ke ms mt dn ki mu mv dp km ll mw mx kq lp my mz ku lt na nb ky nc bi translated">消费者</h2><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="af7b" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">这里，我们设置了一个消费者/源函数，它无限循环地生成整数并存储在一个通道中。</p><h2 id="859d" class="mr kd iq bd ke ms mt dn ki mu mv dp km ll mw mx kq lp my mz ku lt na nb ky nc bi translated">工人01</h2><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="841f" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们定义worker 01，它打印出工人号和当前任务。然后，将消息存储在已完成任务的通道中，并通知等待组任务已完成。</p><h2 id="abd1" class="mr kd iq bd ke ms mt dn ki mu mv dp km ll mw mx kq lp my mz ku lt na nb ky nc bi translated">工人02</h2><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5aea" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">工人02被定义为与工人01相同。</p><h2 id="537b" class="mr kd iq bd ke ms mt dn ki mu mv dp km ll mw mx kq lp my mz ku lt na nb ky nc bi translated">生产者</h2><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e388" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">在这里，生产者/接收器打印出工人完成的任务。</p><h2 id="8509" class="mr kd iq bd ke ms mt dn ki mu mv dp km ll mw mx kq lp my mz ku lt na nb ky nc bi translated">主要功能</h2><figure class="nd ne nf ng gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0047" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">现在，最关键的部分。在main函数中，我们定义了固定数量的例程，并为完成的工作创建了一个通道。接下来，我们定义等待组，并将例程的数量添加到等待组中。</p><p id="4ac2" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们使用GoRoutine调用在后台运行的消费者。调用另一个GoRoutine从消费者/源检索任务。对于每个任务，worker 01和worker 02在后台处理相同的任务。然后，生产者检索由工人完成的任务。等待组在检索每个任务后存储相同数量的例程。</p><h1 id="3b68" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="a4fd" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我希望这个例子简单易懂。我在下面添加了源代码的链接，供你参考。感谢您的阅读。✌️</p><p id="3121" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">GitHub源代码:<a class="ae nj" href="https://github.com/leonardyeoxl/Consumer-Producer-Parallelism-using-Goroutines" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/leonardyoexl/Consumer-Producer-Parallelism-using-go routines</a></p></div></div>    
</body>
</html>