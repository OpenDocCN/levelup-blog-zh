<html>
<head>
<title>Builder explained — Design patterns in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建者解释Java中的设计模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/builder-explained-design-patterns-in-java-beadf8b32a51?source=collection_archive---------9-----------------------#2022-05-03">https://levelup.gitconnected.com/builder-explained-design-patterns-in-java-beadf8b32a51?source=collection_archive---------9-----------------------#2022-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b38a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将开始一系列文章，在Java代码示例上解释<a class="ae kl" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">设计模式</a>。对于任何想深入研究这些常见的OOP设计技术的人来说，这可能是有用的。掌握任何东西的最好方法是通过练习。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/8605e440b68c30018f45151e148bb2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3eYqoS0LF8QCYEpMMBt38w.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">本杰明·乔彭在<a class="ae kl" href="https://unsplash.com/s/photos/bricks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="151e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">建设者</h1><p id="c329" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Builder是一种<a class="ae kl" href="https://refactoring.guru/design-patterns/creational-patterns" rel="noopener ugc nofollow" target="_blank">创造性的设计模式</a>，它提供了一种构建复杂对象的替代方法。当我们想要使用相同的对象构建过程来构建不同的<a class="ae kl" href="https://howtodoinjava.com/java/basics/how-to-make-a-java-class-immutable/" rel="noopener ugc nofollow" target="_blank">不可变</a>对象时，应该使用这种模式。</p><blockquote class="mf mg mh"><p id="ec75" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">构建器模式旨在“将一个复杂对象的构建从它的表现中分离出来，以便同一个构建过程可以创建多个不同的表现。”</p></blockquote></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="5899" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们假设，我们需要创建一个<code class="fe mt mu mv mw b">Employee</code>对象，它有以下5个属性，即<code class="fe mt mu mv mw b">firstName</code>、<code class="fe mt mu mv mw b">secondName</code>、<code class="fe mt mu mv mw b">yearOfBirth</code>、<code class="fe mt mu mv mw b">employeeId</code>、<code class="fe mt mu mv mw b">registrationAddress</code>。</p><p id="78b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果只有<code class="fe mt mu mv mw b">firstName</code>、<code class="fe mt mu mv mw b">secondName</code>、<code class="fe mt mu mv mw b">employeeId</code>是必需的，而其余的字段是可选的，会怎么样呢？我们需要更多的建设者:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ad18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题被称为<strong class="jp ir">伸缩构造函数问题</strong>。想象一下，更多的属性需要多少构造函数。</p><p id="ba8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建器模式可以在一个类中描述，该类有一个创建方法和几个配置结果对象的方法。构建器方法通常支持链接，例如<code class="fe mt mu mv mw b">ObjectBuilder()-&gt;attrubute1(1)-&gt;attribute2(2)-&gt;build()</code>。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="15c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简称省略字段验证(如果字段值无效<code class="fe mt mu mv mw b">IllegalArgumentException</code>应该抛出)。请记住，上面创建的对象<strong class="jp ir">没有任何setter方法</strong>，因此它的状态一旦构建就不能更改。这提供了期望的不变性。</p><p id="b075" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该模式的用法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="1394" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Lombok @Builder注释</h1><p id="58bc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Project Lombok的<a class="ae kl" href="https://projectlombok.org/features/Builder" rel="noopener ugc nofollow" target="_blank"> <em class="mi"> @Builder </em> </a>是使用该模式的一种简单方法，无需编写样板代码。这里有一个例子:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f8b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以及代码中的一个使用示例:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="ab7f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><h2 id="3421" class="mz ld iq bd le na nb dn li nc nd dp lm jy ne nf lq kc ng nh lu kg ni nj ly nk bi translated">构建器模式优点</h2><ul class=""><li id="18d1" class="nl nm iq jp b jq ma ju mb jy nn kc no kg np kk nq nr ns nt bi translated">设计灵活性和可读性更强的代码。</li><li id="81cd" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated">构造函数的参数减少了，并在可读性很高的链式方法调用中提供。这样，在创建类的实例时，就不需要将可选参数的<code class="fe mt mu mv mw b">null</code>传递给构造函数。</li><li id="b92f" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated">实例总是在完整的状态下被实例化。</li><li id="f549" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated">在对象构建过程中，我们可以构建不可变的对象，而不需要太多复杂的逻辑。</li></ul><h2 id="52b1" class="mz ld iq bd le na nb dn li nc nd dp lm jy ne nf lq kc ng nh lu kg ni nj ly nk bi translated">构建模式缺点</h2><ul class=""><li id="27be" class="nl nm iq jp b jq ma ju mb jy nn kc no kg np kk nq nr ns nt bi translated">该模式需要大量代码</li></ul><h2 id="996f" class="mz ld iq bd le na nb dn li nc nd dp lm jy ne nf lq kc ng nh lu kg ni nj ly nk bi translated">在以下情况下使用生成器模式</h2><ul class=""><li id="88b0" class="nl nm iq jp b jq ma ju mb jy nn kc no kg np kk nq nr ns nt bi translated">创建复杂对象的算法应该独立于组成对象的部件以及它们是如何组装的</li><li id="5126" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated">构建过程必须允许被构建的对象有不同的表现形式</li></ul><h2 id="3a0a" class="mz ld iq bd le na nb dn li nc nd dp lm jy ne nf lq kc ng nh lu kg ni nj ly nk bi translated">Java核心库中构建器的使用:</h2><ul class=""><li id="8bdc" class="nl nm iq jp b jq ma ju mb jy nn kc no kg np kk nq nr ns nt bi translated"><a class="ae kl" href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" rel="noopener ugc nofollow" target="_blank"> StringBuilder </a></li><li id="9868" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated"><a class="ae kl" href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-" rel="noopener ugc nofollow" target="_blank"> StringBuffer </a></li></ul><p id="6528" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要查看关于给定代码示例的更多细节，请访问我的<a class="ae kl" href="https://github.com/alexshamrai/design-patterns" rel="noopener ugc nofollow" target="_blank">设计模式GitHub repo </a>。</p></div></div>    
</body>
</html>