# 砖家对类型理论的介绍。

> 原文：<https://levelup.gitconnected.com/a-brick-layers-introduction-to-type-theory-ea7d2bb652c2>

## 所有编程语言的基础。

![](img/63b598c4f99938b73bb1b1127fa48b9f.png)

## 用简单的术语来说，即使是砖瓦匠也能理解。

类型系统是计算机科学的基础构件。它们在当今使用的每一种编程语言中都发挥着作用。在这篇博客中，我将从 1000 英尺的角度介绍它是什么以及它是如何工作的。在这篇博客结束时，你将对现代编程语言如何工作以及如何改进它们有一个坚实的想法。

## 为什么这很重要？

我们生活在一个被科技过度掌控的世界。很快我们将达到一个点(有人说我们已经达到了)，这不再是一个选择加入的游戏。在那里，如果你不了解技术，至少相对较好，你会断然落后。

## 此外

类型理论是一个有很大发展空间的领域。今天，大多数现代语言都没有充分发挥它们的潜力。如果我们继续构建类型理论和类型系统，我们就可以改善每天困扰我们的大量问题。

在不久的将来，对类型理论的投资将在一些最重要的进步中发挥作用。以下是一些可能的好处:

*   永远不会崩溃的程序
*   更难破解的框架
*   在运行时运行得更快的程序。

![](img/3653a2a36e70a657fba8bd080ec659df.png)

# 我们开始吧

电脑在某些事情上比人类做得更好。举几个例子，他们可以永远重复地做一个特定的操作，而不会感到疲劳或厌烦。他们做某些事情比人类快得多，比如算术。

问题是，计算机不理解人类的语言，所以我们发明了语言来弥合这一差距。编程语言就是这样产生的。它开始时规模很小，用的是非常低级的汇编语言，但是经过一个激动人心的世纪，语言已经慢慢地在不断增加的层次上建立起来，直到我们今天所拥有的。

在古代，类似计算机的机器被指示明确地、逐字地做事情。它会接收一些可以解释为数字的东西，然后移动一些东西，输出一些可以解释为另一个数字的东西。

早期的机器使用类型理论，但是它们并没有像我们今天看到的那样的类型系统。

## 这是一个古代机器如何工作的例子

这个视频很好地演示了这个过程，通过为弹珠铺设轨道，我们可以“计算”弹珠将如何移动，并对每个给定的输入都有一些预期的结果。

在这个弹珠计算器中，我们在暗示弹珠的数量是一个数，并且最后弹珠的数量也是一个数。在视频中，他也将弹珠翻译成二进制，但在这一点上，我们应该明白，我们可以用其他东西来表示值。

在这篇博客中，你不需要了解它们，但是这些轨道是有限集合中逻辑门的组合。

## 类型理论家的观点

这个系统是有效的，但只是在特定的环境下。只要输入是弹球，输出是弹球，系统就被认为是类型安全的。

它会一直工作，不会失败。如果我们试图把硬币塞进轨道，硬币就会掉下来卡在轨道里。那么输出将不会如预期的那样。

一个为弹珠而构建的系统，但是插入了硬币，是一个不安全类型的系统，因为它无法执行完成。

现代编程过程已经变得越来越复杂，但是即使在今天，同样的陷阱仍然存在。

这就是类型系统诞生的过程。当我们处理的计算机不仅仅是把一些弹珠加在一起，我们必须确保我们的弹珠和我们的弹珠分类器在一起，我们的硬币和硬币分类器在一起。

# 跳过 100 年的计算机科学

## 我们不再和弹珠打交道了。

![](img/8f3f098e587edc4449e04c355dbfd1f9.png)

现代计算机有点像大理石机，只是大了一百万倍，也更复杂了。

大多数编程语言不是把弹珠放进我们的机器，而是处理一系列类型。有些类型几乎是通用的，但是许多语言尝试了新的选项。我在这里列出的类型在今天使用的几乎所有语言中都可以看到。

*   整数
*   线
*   布尔型
*   空的
*   空
*   不明确的
*   标志

为简单起见，假设这些翻译:

*   整数—是一个数字
*   字符串—是文本
*   布尔型—真/假
*   void —不返回输出的系统
*   null 没有值
*   undefined —机器识别为我们稍后将分配的值
*   符号——我们向机器引入的新术语

在现代语言中，我们可以这样说

```
let a = 5 + 5
```

> 这就是在 javascript 中定义符号的方式，JavaScript 是一种弱类型系统的语言。

这里的翻译是字母“a”是一个未知的符号(未知是因为计算机不知道它是什么),我们引入到机器中，我们说，字母“a”等于从 5+5 计算出的任何值。

由于数字被广泛接受和认同，我们总是可以从中期待某种结果。那是数字十。你可以用任何编程语言做同样的事情，并且总是期望看到数字 10。

```
a => 10
```

但是如果我们试图输入两种不同的数据类型，我们会在运行时得到一个错误**。**也就是说，在我们尝试运行程序之前，我们不会知道这会使程序崩溃。

```
let a = 5 + true

=> type error
```

在这种情况下，大多数人不知道如何将这些加在一起，更不用说我们的机器了，所以这将引发一个类型错误。机器退出运行时，无法完成执行。

这可能看起来无害，但当我们考虑到计算机负责一些重要的事情，如导弹发射或心脏监测时，我们可以看到像这样的运行时故障可能会导致数百万人丧生或数十亿美元的损失。

此外，一些程序包含数百万行代码和数百万个进程，所以大多数时候我们甚至不能确定在我们进行一系列测试运行后它是否会失败。

![](img/90ac90d610ba521ce576ca125ef9904d.png)

这正是类型系统存在的原因。我们已经围绕编程语言建立了类型系统来避免这种失败。

类型理论是一个长达 100 英里的学术领域。纵观历史，在计算的所有步骤中都发明了各种各样的类型检查器，但是大多数编程语言都采用了两种主要的理念来改进这个问题。

*   静态检查
*   动态检查

# 静态检查

编程语言解决这个问题的一个主要方法是在构建程序时强制执行类型定义。这样，编译器就可以在把文本翻译成机器码之前进行类型检查。

基本上，它在我们的大理石机器的顶部放置了一个防护装置，防止用户试图将硬币放入其中。

![](img/7cacef00bc9c86c9504e58cd249eab3e.png)

文本只有在通过了类型检查后才会被编译，因此在没有类型安全的情况下永远不会进入运行时。

比如像这样

```
public int a = 5 + 5
a => 10
```

> 这就是在 C#中定义符号的方式，C #是一种比 javascript 类型系统更强大的语言

然后，如果我们试图像以前一样做一些愚蠢的事情，我们不仅仅会在运行时得到一个类型错误。编译器会捕捉到这一点，并提前告诉我们这将导致失败。

```
public int a = 5 + true//error => symbol of type int cannot be added to type boolean
```

这有两个目的。静态类型器不仅能够识别这种情况，而且能够清楚地告诉我们需要做什么来编写更安全的程序。

这是一个明显的改进，但是仍然有一些边缘情况需要考虑。

例如，如果你将一个数除以 0。嗯，0 是一个奇怪的数字，没有值，所以它可以无限地进入任何其他数字，如果我们的计算机试图计算无穷大，它会卡住，这就像打字错误一样糟糕。

这就是动态类型检查的用武之地。

# 动态检查

尽管被零除可以被静态检查器捕获，并且大多数强类型语言都静态地检查被零除，但是一些语言创建者认为他们最好还是用动态检查器来做这些事情。

今天有许多动态语言严重依赖于动态检查器，例如 ruby、javascript 和 python。

动态检查器是一个系统，我们没有警卫保护我们的弹珠机，我们让用户把他们想要的东西扔到轨道上，但我们雇了一个人看着弹珠在机器中移动，如果机器卡住了，他会吹哨子。

尽管事实上动态检查器在运行前不捕捉错误，但它们仍然是常见的地方，因为在运行时有比类型检查更多的事情要做，并且有如此多的边缘情况，以至于我们需要一个适当的系统来确定失败是否已经发生。

# 今天大多数程序两者都用。

![](img/90271a5f6c3dd0fe64d89ac24feadbba.png)

今天的大多数程序使用不同严格程度的静态检查器和动态检查器，大多数语言创作者已经意识到这两种方法之间存在一些权衡。

依赖于动态检查的系统对于初学者来说通常更容易进入，并且在词汇上更令人愉快。意思是，他们的语法读起来更像英语。

此外，动态系统通常更适合快速构建原型，而强类型系统更适合可靠性和安全性。

在 ruby(一种动态语言)中，一个循环做 10 次:

```
10.times { puts “hello” }
```

在 Rust(一种具有强大静态系统的语言)中，一个循环做了 10 次:

```
for n in 1..=10 { 
println!("{}", n);
}
```

一个像 rust 这样具有非常强大的静态检查功能的系统会在编译时给你非常详细的错误信息，并且在运行时不太可能遇到无数的问题。它的运行速度也比大多数动态语言快，因为动态语言必须将计算能力分配给运行时检查器。

如果一个大公司想写一个永远不停机，每秒能处理一百万次运算的程序，它很可能会选择一种静态类型强的语言。

# 最后

这是你对类型系统和编程语言的 1000 英尺视角。我想讲得更详细，但这已经有点长了，我想让非程序员也能看得懂。

也许将来我会写另一篇博客，详细介绍如何使用类型理论来微调类型系统，以解决某些类型的错误。

它比你能想象的更深入。类型理论领域的一些领导者甚至能够证明我们可以明确地解释错误，并且我们可以明确地改变**错误的可能性**。

这意味着理论上我们可以构建可以静态检查几乎所有东西的语言。