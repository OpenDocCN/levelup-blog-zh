# 如何识别何时不应忽视

> 原文：<https://levelup.gitconnected.com/how-to-recognise-when-not-to-gitignore-e2e87edf2653>

## 一个关于粗心和愚蠢的故事

![](img/c60574a84ff6cf2d24e7b67f650ec7b1.png)

照片由[凯勒·特劳特纳](https://unsplash.com/@kylertrautner?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

我从事版本控制系统的工作已经有 20 年了，所以我真的应该了解更多。自从开始写简历以来，它就一直灌输给我:

> 检查你的来源，那些一旦丢失就无法恢复的东西

这条规则从来没有例外，如果你认为有例外，请三思。我的意思是:真的花点时间好好想想你的异常，然后意识到为什么你仍然应该对那个文件进行版本控制。

这是一个关于粗心的自动完成的小故事，是 Unix 的一个怪癖，也是一个仓促组装的。gitignore 文件。读者，当心。

# GitHub 页面

我责备 GitHub Pages 几乎和我责备自己一样多。它不仅免费得可笑，还让维护一个静态站点的整个过程变得简单得愚蠢。在这里，重点是在愚蠢的。

我不仅懒，而且有点吝啬。对于程序员来说，这通常是一个有用的组合，但在这种情况下，它让我更加重视节省空间。因为，你看，GitHub Pages *并不是*好得令人难以置信:有空间限制(一个站点 1 GB)。显然，这是有道理的，但是这让我想到我可以忽略一些我真的不应该忽略的东西。

# Sass 文件

[Sass](https://sass-lang.com/) 是一种 CSS 预处理语言:你用‘Sass 语言’编写样式表，然后用 Sass 生成相应的 CSS 文件。我仍在尝试与人斗嘴；现在，我只是用它来使我的主 CSS 文件不那么冗长。不管怎样，我使用的文件是——这是重点。

生成的文件,`.css`文件仍然是相同的，当然，这和我的灾难有点关系。我最大的错误是:**我签入了我的 CSS 文件，但没有签入我的 Sass 文件**。那个，我选择了`.gitignore`。

我的想法是这样的:*这是一个我从不想通过我的 GitHub Pages 站点提供的文件，它只是生成另一个文件——哪个* ***是*** *签入的——我可以让它不受版本控制*。愚蠢。

# 近乎灾难

以下是我典型的 Sass 流程:

```
$ sass css/styles.scss > css/styles.css
```

`sass`程序将一个输入文件作为它的参数，并输出生成的 CSS，我将它重定向到一个`.css`文件。

这是一个我经常使用的命令，我真的应该把它添加到 Makefile 中，但是它是如此的快速和简单，我只是在命令行上笨拙地输入，当我需要它的时候重新输入，就像一个穴居人一样。

不管怎样，今天我到了这一步，在扩展名的第一个字母后，我快速地打了个错别字，然后匆忙地自动补全:

```
$ sass css/styles.scss > css/styles.scss
```

读者，我可能只差半秒钟就要按下那个命令了。灾难性的，对吗？操作系统能把我从自己的愚蠢中拯救出来吗？当然不是。我会以两个相同的文件结束吗，每个文件都包含生成的 CSS 输出，所有重要的 Sass 源永远消失了吗？当然可以。

实际上，我的 Sass 代码可能会丢失，但有趣的是，实际结果会略有不同…

# 文件处理的一个题外话

下面是一个用 Sass 语言编写的输入文件示例:

```
$ cat styles.scssa {
    b {
        color: green;
    }
}
```

(注意用于区分 Sass 文件和 CSS 文件的标准`.scss`扩展名)

当一切进展顺利时，应该会发生以下情况:

```
$ sass styles.scss > styles.css
$ cat styles.cssa b {
  color: green;
}
```

但是下面是*实际上*发生的事情，有点令人惊讶，当你不小心重复同一个文件名时:

```
$ sass styles.scss > styles.scss
$ cat styles.scss
```

那就是没有产出。一个空文件。拉链。这与我的期望相差甚远；当然，`styles.css`依然完好无损，但是为什么`styles.scss`会被上面的命令彻底消灭？

[这个精彩的 StackExchange 回答](https://askubuntu.com/a/8418)总结了正在发生的事情:

> 当您像这样使用 I/O 重定向时，在执行命令之前，shell *会打开“输入”和“输出”文件。打开一个文件进行覆盖等同于在写入前截断它。结果: *[* `sass` *]* 在输入时看到一个空文件...*

换句话说，作为*输出*文件的`.scss`文件在作为*输入*文件读入之前被截断。

# 这堂课到此结束

如果你有`.scss`文件(或任何类似的东西)，*马上把它们签入你的存储库*。即使你不希望它们出现在你的网络服务器上，即使你担心它们正在消耗的`4.6K`，也不要像我一样。给他们登记。

```
$ git add styles.scss
```

是的，我现在在我的 web 服务器上有一个不需要的 Sass 文件，如果人们真的想查看的话，他们可以查看它。是的，它占用了(少量)宝贵的空间。不，这远不如意外删除一个无法恢复且不受版本控制的文件糟糕！

> 如果你关心它，就对它进行版本控制。