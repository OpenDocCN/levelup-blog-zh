<html>
<head>
<title>Multiparty video conference using Vue, WebRTC, SocketIO, Node, and Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vue、WebRTC、SocketIO、Node和Redis的多方视频会议</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/multiparty-video-conference-using-vue-webrtc-socketio-node-redis-e8c5a059d332?source=collection_archive---------3-----------------------#2020-06-15">https://levelup.gitconnected.com/multiparty-video-conference-using-vue-webrtc-socketio-node-redis-e8c5a059d332?source=collection_archive---------3-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ba2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在过去的几个月里，由于隔离时间的原因，视频会议应用出现了巨大的增长。几乎每个人无论身在何处都能见到自己的朋友，那么我们何不再次尝试构建自己的会议应用，让它更加真实呢？再来一次，让我们开始吧！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6f75f4fe8f99a9acddb57af5164355b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3amLoFFcWhNpsZFU-rAuFQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">缩放应用程序捕获</figcaption></figure><p id="09a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了实现这一目标，我们不会从头开始。在我的上一篇文章中，我们通过一对一 视频功能，完成了构建我们自己的带有私人聊天的视频聊天所需的所有步骤。在这里<strong class="js iu">我们将以此为起点</strong>进行推广，并最终为其添加<strong class="js iu"> <em class="le">多对多</em> </strong>功能。</p><div class="lf lg gp gr lh li"><a rel="noopener  ugc nofollow" target="_blank" href="/build-your-own-video-chat-with-vue-webrtc-socketio-node-redis-eb51b78f9f55"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">使用Vue、WebRTC、SocketIO、Node &amp; Redis构建您自己的视频聊天</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">通过水平缩放构建多房间视频聊天</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw ky li"/></div></div></a></div><blockquote class="lx ly lz"><p id="7a08" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated">如果你还没有检查它，我建议你在继续阅读这篇文章之前看一看，因为我们将提到几个已经解释过的概念。</p></blockquote><p id="3126" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我们会议的主要特点将是:</p><ul class=""><li id="8765" class="md me it js b jt ju jx jy kb mf kf mg kj mh kn mi mj mk ml bi translated">打开会议的用户将成为其<strong class="js iu"> <em class="le">管理员</em> </strong> <em class="le">，</em>是唯一一个能够将更多用户 添加到会议中的用户</li><li id="2f25" class="md me it js b jt mm jx mn kb mo kf mp kj mq kn mi mj mk ml bi translated">管理员只能从同一个公共房间 添加<strong class="js iu"> <em class="le">用户</em></strong></li><li id="0d1c" class="md me it js b jt mm jx mn kb mo kf mp kj mq kn mi mj mk ml bi translated">无论是开始一个会议还是加入一个会议，<strong class="js iu"> <em class="le">用户都不能与任何其他人私下交谈</em> </strong></li><li id="4685" class="md me it js b jt mm jx mn kb mo kf mp kj mq kn mi mj mk ml bi translated">已经在会议<strong class="js iu"> <em class="le">中的用户不能同时进行私人聊天</em> </strong>，因此<strong class="js iu"> <em class="le">没有人能够与他</em> </strong>交谈</li><li id="bebf" class="md me it js b jt mm jx mn kb mo kf mp kj mq kn mi mj mk ml bi translated">一旦管理员取消会议，所有用户将被自动踢出</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mr"><img src="../Images/3403a84071d47e2c39cfba364395253f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/1*w4R59QGL2sVrv6DSKOlFmg.gif"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">测试视频会议功能</figcaption></figure><p id="389a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是在深入研究实现细节之前，让我们快速浏览一下在讨论webRTC多方架构时的主要方法。</p><h2 id="278b" class="ms mt it bd mu mv mw dn mx my mz dp na kb nb nc nd kf ne nf ng kj nh ni nj nk bi translated">网状物</h2><p id="9efc" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated"><a class="ae nq" href="https://webrtcglossary.com/mesh/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">网状</strong> </a>拓扑是最简单的一种。所有对等体相互连接，直接向所有对等体发送它们的媒体。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/844141fbc01faf504a78539538e9295d.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*M41Om-snyPCCeOZzhkXyuA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">网状webRTC架构</figcaption></figure><p id="c600" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">优点:<br/>。</strong>基本而简单的webRTC实现<br/> <strong class="js iu">。</strong>不需要媒体中央服务器</p><p id="dc25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Const: </strong> <br/> <strong class="js iu">。</strong>过度的处理和带宽消耗(<strong class="js iu"> <em class="le"> N-1上行和下行</em> </strong>)</p><p id="6391" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">。</strong>无法扩展到大量参与者(<em class="le">最多4–6个同行</em>)</p><h2 id="1caa" class="ms mt it bd mu mv mw dn mx my mz dp na kb nb nc nd kf ne nf ng kj nh ni nj nk bi translated">混音和MCU(多点会议单元)</h2><p id="afdc" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">每个对等体将其媒体发送到中央服务器，并从中央服务器接收媒体。<a class="ae nq" href="https://webrtcglossary.com/mcu/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> MCU </strong> </a>充当混合点，接收来自所有对等体的输入媒体，<br/>将它们全部解码并混合，以最终将它们作为单个流发送给所有用户。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/d2294816431a9a611aaab53a4b24e33f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*9c5vH08EjpA2SIavp51g_g.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">MCU混合架构</figcaption></figure><p id="222c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">优点:</strong> <br/> <strong class="js iu">。</strong>客户端的基本webRTC实现</p><p id="951d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">。<em class="le"> 1上行和下行</em>每对端</strong></p><p id="05d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">缺点:</strong> <br/> <strong class="js iu">。</strong> MCU需要高处理能力的服务器端(<em class="le">解码和编码每个对等体的媒体</em></p><p id="8702" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如<a class="ae nq" href="https://doc-kurento.readthedocs.io/en/6.13.2/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">Kurento</strong></a><strong class="js iu"/>提供MCU媒体服务器来实现视频应用(除了下面提到的SFU拓扑)。</p><h2 id="9cbf" class="ms mt it bd mu mv mw dn mx my mz dp na kb nb nc nd kf ne nf ng kj nh ni nj nk bi translated">路由和SFU(选择性转发单元)</h2><p id="e481" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">每个对等体将其媒体发送到中央服务器，并从中央服务器接收所有其他对等体的媒体。<a class="ae nq" href="https://webrtcglossary.com/sfu/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> SFU </strong> </a>就像一个媒体路由器，接收来自所有用户的输入媒体，然后决定将哪些流发送给哪些用户。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/307af4ee4d008cacaeec3f129cbff0f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*m-wvaFohH2Bekb7lBqjsHQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">SFU路由体系结构</figcaption></figure><p id="9392" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">优点:</strong> <br/> <strong class="js iu">。</strong>服务器端的计算成本更低(<em class="le">比MCU </em>低)</p><p id="11d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">。</strong>要求非对称带宽(<strong class="js iu"> <em class="le"> 1上行和N-1下行</em> </strong>)，适用于ADSL连接</p><p id="fcec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Const: </strong> <br/> <strong class="js iu">。</strong>服务器端的复杂设计和实现</p><p id="9cf7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了路由媒体，SFU可以采用三种不同的方法:<em class="le">多单播</em>、<em class="le">联播</em>和<em class="le"> SVC </em>、<em class="le">(可伸缩视频编码)</em>。像<a class="nt nu ep" href="https://medium.com/u/5448cefded7f?source=post_page-----e8c5a059d332--------------------------------" rel="noopener" target="_blank"> OpenVidu </a>和<a class="ae nq" href="https://mediasoup.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> Mediasoup </strong> </a>这样的提供商提供了那种类型。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="094d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也就是说，在我们的例子中，我们将实现第一种方法:<strong class="js iu">网状</strong> <strong class="js iu">拓扑</strong>，支持<strong class="js iu">多达3个对等体(但是扩展到更多用户)</strong>，所以让我们开始吧！</p><h1 id="a3e4" class="oc mt it bd mu od oe of mx og oh oi na oj ok ol nd om on oo ng op oq or nj os bi translated">提高</h1><p id="d860" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">在会议开始之前，我们将做一些以前的改进，以帮助我们获得更干净和更好的结构化代码。</p><h2 id="d423" class="ms mt it bd mu mv mw dn mx my mz dp na kb nb nc nd kf ne nf ng kj nh ni nj nk bi translated">WebRTC通信机制</h2><p id="fdc3" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">如前所述，在网状架构中，所有对等体直接相互连接，因此在私聊中已经使用的在两个对等体之间建立连接的<a class="ae nq" rel="noopener ugc nofollow" target="_blank" href="/build-your-own-video-chat-with-vue-webrtc-socketio-node-redis-eb51b78f9f55#b2b9">机制和配置将完全相同。因此，我们将<code class="fe ot ou ov ow b"><strong class="js iu">WebRTC.js</strong></code>文件中的所有内容隔离为</a><a class="ae nq" href="https://vuejs.org/v2/guide/mixins.html" rel="noopener ugc nofollow" target="_blank"> <em class="le"> mixin </em> </a>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">WebRTC混合</figcaption></figure><p id="ca34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，我们就有了一个通用的方法来创建所需的所有步骤<strong class="js iu"><em class="le">RTCPeerConnection</em></strong>不可知，因此适当的组件将负责提供和处理PeerConnection对象以及流程中所需的所有合适的信息<em class="le">(远程描述、候选人、报价、答案等等)</em>。</p><blockquote class="lx ly lz"><p id="ed00" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated">使用mixins时，检查所有的<a class="ae nq" href="https://vuejs.org/v2/guide/mixins.html#Option-Merging" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">合并策略</strong> </a></p></blockquote><h2 id="f7d7" class="ms mt it bd mu mv mw dn mx my mz dp na kb nb nc nd kf ne nf ng kj nh ni nj nk bi translated">视频和控件</h2><p id="0c97" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated"><a class="ae nq" href="https://www.w3schools.com/html/html5_video.asp" rel="noopener ugc nofollow" target="_blank">视频</a>相关内容，我们创建了一个通用的<code class="fe ot ou ov ow b"><strong class="js iu">Video.vue</strong></code>组件来简化事情:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">视频组件</figcaption></figure><p id="5c12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在每种情况下，组件将获得正确的<a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream" rel="noopener ugc nofollow" target="_blank">媒体流</a>以及其余的输入值。</p><blockquote class="lx ly lz"><p id="b5fd" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated">pauseVideo和pauseAudio将是通用的mixin媒体方法</p></blockquote><p id="9ab1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们还添加了视频-音频控件(<code class="fe ot ou ov ow b"><strong class="js iu">AudioVideControls.vue</strong></code>)，这样每个对等点将能够分别<em class="le">暂停/恢复</em>和<em class="le">关闭/打开</em>自己的视频和音频，如下所示:</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="ee2a" class="ms mt it ow b gy pd pe l pf pg"><strong class="ow iu">// Pause video</strong><br/>this.ls.getVideoTracks().forEach(<em class="le">t</em> <em class="le">=&gt;</em> t.enabled = !t.enabled)<br/><strong class="ow iu">// Pause audio</strong><br/>this.ls.getAudioTracks().forEach(<em class="le">t</em> <em class="le">=&gt;</em> t.enabled = !t.enabled)</span></pre><p id="e3a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">那个</strong> <strong class="js iu">不是指每次都恢复webRTC连接</strong>，而只是启用/禁用音频/视频本地流轨道。</p><h2 id="c7e0" class="ms mt it bd mu mv mw dn mx my mz dp na kb nb nc nd kf ne nf ng kj nh ni nj nk bi translated">声音的</h2><p id="1f60" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">在之前的版本中有一些讨厌的音频问题，所以我们已经解决了它们，在请求<a class="ae nq" href="https://developer.mozilla.org/es/docs/Web/API/Navigator/getUserMedia" rel="noopener ugc nofollow" target="_blank">用户媒体</a>时，在通用配置中设置了一些限制:</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="9698" class="ms mt it ow b gy pd pe l pf pg">constraints: {<br/> audio: {<br/>  echoCancellation: true,<br/>  noiseSuppression: true,<br/>  autoGainControl: false<br/> }<br/>}</span></pre><blockquote class="lx ly lz"><p id="7ae1" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated">您可以在<a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">media track API</strong></a>中检查所有可用的约束</p></blockquote><p id="70eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是这还不够，为了消除回声和噪声，我们还需要将<a class="ae nq" href="https://www.w3schools.com/tags/att_video_muted.asp" rel="noopener ugc nofollow" target="_blank">静音</a>并将<a class="ae nq" href="https://www.w3schools.com/tags/av_prop_volume.asp" rel="noopener ugc nofollow" target="_blank">音量设置为0</a><strong class="js iu"><em class="le"/></strong><strong class="js iu"><em class="le"/></strong><strong class="js iu">本地视频</strong>元素如下:</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="051e" class="ms mt it ow b gy pd pe l pf pg">// Local video<br/>&lt;video id="localVideo" autoplay="true" <strong class="ow iu">muted</strong>&gt; &lt;/video&gt;</span><span id="22ce" class="ms mt it ow b gy ph pe l pf pg">// Fix volume to 0<strong class="ow iu"><br/>this.myVideo.volume = 0</strong></span></pre><p id="45c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住<strong class="js iu">这并不意味着你静音正在进行的音频流</strong> <strong class="js iu">本身</strong> <strong class="js iu">而只是本地播放。</strong></p><h2 id="7315" class="ms mt it bd mu mv mw dn mx my mz dp na kb nb nc nd kf ne nf ng kj nh ni nj nk bi translated">WebRTC适配器</h2><p id="53a9" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">为了处理潜在的浏览器问题，我们将<a class="ae nq" href="https://github.com/webrtc/adapter" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"><em class="le">webrtc-adapter</em></strong></a>作为粘合剂，将代码粘贴到不同的WebRTC浏览器实现中。</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="de7b" class="ms mt it ow b gy pd pe l pf pg"><strong class="ow iu">import adapter from ‘webrtc-adapter’</strong></span><span id="04eb" class="ms mt it ow b gy ph pe l pf pg"><em class="le">console</em>.log(`Browser ${adapter.browserDetails.browser} — version ${adapter.browserDetails.version}`)</span></pre><h2 id="75b3" class="ms mt it bd mu mv mw dn mx my mz dp na kb nb nc nd kf ne nf ng kj nh ni nj nk bi translated">用户信息</h2><p id="73ab" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">如前所述，用户不能同时进行私人聊天和会议，因此我们在用户加入房间(<code class="fe ot ou ov ow b">joinRoom</code> web socket server listener)时，为存储在Redis中的对象添加了一个会议标志，以跟踪用户状态:</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="aed7" class="ms mt it ow b gy pd pe l pf pg">try {<br/>  // add user to the suitable ROOM<br/>  await ChatRedis.addUser(room, userName, { username, status,   <br/>   privateChat: false, <br/>   <strong class="ow iu">conference: false </strong><br/>  })<br/><em class="le">  const</em> users = await ChatRedis.getUsers(room)<br/>  // Notify all the users in the same room   <br/>  namespace.in(room).emit(‘newUser’, { users, username })<br/>} catch (error) {<br/>  <em class="le">console</em>.log(error)<br/>}</span></pre><blockquote class="lx ly lz"><p id="12c6" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated">请注意，我们已经更改了redis <a class="ae nq" href="https://redis.io/commands/hset" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> hash </strong> </a>模式中的密钥(用户名，而不是以前的socketId ),现在它对于从任何web套接字连接获取任何用户信息都更有用</p></blockquote><h1 id="ac33" class="oc mt it bd mu od oe of mx og oh oi na oj ok ol nd om on oo ng op oq or nj os bi translated">正式会议</h1><p id="3add" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">会议将以用户<strong class="js iu">发起会议</strong> <strong class="js iu">开始，因此<strong class="js iu">成为其管理员</strong>。一旦打开，管理员将自动加入由自己的用户名</strong>定义的<strong class="js iu">会议室。</strong></p><blockquote class="pi"><p id="fa25" class="pj pk it bd pl pm pn po pp pq pr kn dk translated">请记住，用户名在系统中是唯一的，因此每个web socket会议室都是唯一的</p></blockquote><p id="1892" class="pw-post-body-paragraph jq jr it js b jt ps jv jw jx pt jz ka kb pu kd ke kf pv kh ki kj pw kl km kn im bi translated">为此，我们设置了一个新的<code class="fe ot ou ov ow b"><strong class="js iu">joinConference</strong></code>服务器监听器:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="ak">join conference</strong>web套接字服务器监听器</figcaption></figure><blockquote class="lx ly lz"><p id="e50b" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated">使用<code class="fe ot ou ov ow b">conference: to</code> <strong class="js iu">时，同一会议</strong>内的所有对等体将具有<strong class="js iu">相同的会议标志值</strong>:管理员用户名</p></blockquote><p id="0f95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就前端而言，新的<code class="fe ot ou ov ow b"><strong class="js iu">Conference.vue</strong></code>组件将拥有相关的功能:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><strong class="ak"> Conference.vue </strong>组件</figcaption></figure><p id="1e2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ot ou ov ow b"><strong class="js iu">peers</strong></code>对象将跟踪会议中的所有用户:</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="4b32" class="ms mt it ow b gy pd pe l pf pg">peers: {<br/>  userA: {<br/>    username: <strong class="ow iu">// Peer username</strong><br/>    pc: <strong class="ow iu">// RTCPeerConnection </strong><br/>    peerStream: <strong class="ow iu">//Peer media stream</strong><br/>    peerVideo: <strong class="ow iu">// Peer video element</strong><br/>  },<br/>  userB: { .. },<br/>  ..<br/>}</span></pre><p id="bfd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于每个用户，我们将存储用户名、对等连接对象(<a class="ae nq" href="https://developer.mozilla.org/es/docs/Web/API/RTCPeerConnection" rel="noopener ugc nofollow" target="_blank"><em class="le">RTCPeerConnection</em></a>)、为该对等用户定位的视频元素以及连接成功建立后获得的视频流。</p><blockquote class="lx ly lz"><p id="c4a0" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated">为此，我们也可以使用一个<a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">映射</strong> </a>作为数据结构。在我们的例子中，对象结构已经足够好了，但是Map在存储大型数据集时性能更好(O(1))，所以对于大型会议来说，它可能是一个更好的选择</p></blockquote><p id="9c9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当管理员开始会议时，<code class="fe ot ou ov ow b">Conference</code>组件被实例化，我们得到媒体并自动加入房间。从那时起，<strong class="js iu">管理员将通过<code class="fe ot ou ov ow b"><strong class="js iu">conferenceInvitation</strong></code>事件向每个新的对等方</strong>发送邀请:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">会议邀请web套接字服务器侦听器</figcaption></figure><p id="a9a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，管理员和第一个用户之间的机制如下:</p><ol class=""><li id="c214" class="md me it js b jt ju jx jy kb mf kf mg kj mh kn px mj mk ml bi translated"><strong class="js iu">管理员(A) </strong>打开会议并加入房间- <code class="fe ot ou ov ow b"><em class="le">joinConference</em></code> <em class="le"> </em>套接字事件</li><li id="8156" class="md me it js b jt mm jx mn kb mo kf mp kj mq kn px mj mk ml bi translated"><strong class="js iu"> A </strong> <strong class="js iu"> <em class="le">向<strong class="js iu">用户B</strong>-<strong class="js iu"/><code class="fe ot ou ov ow b"><em class="le">conferenceInvitation</em></code><em class="le"/>socket事件发送邀请</em> </strong></li><li id="e4e9" class="md me it js b jt mm jx mn kb mo kf mp kj mq kn px mj mk ml bi translated"><strong class="js iu"> B </strong>收到邀请<strong class="js iu"> <em class="le">加入会议室</em> </strong> - <code class="fe ot ou ov ow b"><em class="le">joinConference</em></code></li><li id="5286" class="md me it js b jt mm jx mn kb mo kf mp kj mq kn px mj mk ml bi translated"><strong class="js iu"> A </strong> <strong class="js iu"> <em class="le">接收</em></strong><strong class="js iu"><em class="le">确认</em> </strong>，<strong class="js iu"> <em class="le">添加</em> </strong> <strong class="js iu"> B </strong>为会议成员(对其自身的<code class="fe ot ou ov ow b">peers</code>对象)，创建<strong class="js iu"><em class="le"/></strong><strong class="js iu"><em class="le"/></strong>发送<strong class="js iu"><em class="le"/></strong></li><li id="4dc1" class="md me it js b jt mm jx mn kb mo kf mp kj mq kn px mj mk ml bi translated"><strong class="js iu"> B </strong>得到提议，<strong class="js iu"> <em class="le">添加</em> A </strong>为会议成员(对其自身的<code class="fe ot ou ov ow b">peers</code>对象)，创建并发送<strong class="js iu"> <em class="le">答案</em> </strong>给<strong class="js iu"> A </strong></li></ol><blockquote class="lx ly lz"><p id="2d74" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated">正如我们在<a class="ae nq" rel="noopener ugc nofollow" target="_blank" href="/build-your-own-video-chat-with-vue-webrtc-socketio-node-redis-eb51b78f9f55#397c">之前</a>所做的，我们已经在父<code class="fe ot ou ov ow b"><strong class="js iu"><em class="it">Chat.vue</em></strong></code>视图组件中实现了合适的FE套接字监听器来处理邀请和确认事件</p></blockquote><p id="ff8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了相应地管理对等体对象之外，从第4点开始，webRTC机制与上一篇文章中在之前解释的<a class="ae nq" rel="noopener ugc nofollow" target="_blank" href="/build-your-own-video-chat-with-vue-webrtc-socketio-node-redis-eb51b78f9f55#8700">完全相同，但是现在<strong class="js iu">会议室将成为会议中所有对等体之间的信令机制。</strong></a></p><p id="1e11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它的目的保持不变，提供一种方式<strong class="js iu">与会议中的所有对等方进行通信，以交换通信所需的元数据</strong>。为了简单起见，在这种情况下，我们在我们的<code class="fe ot ou ov ow b">Chat.vue</code>视图中用相关的监听器方法定义了另一个信令套接字事件<code class="fe ot ou ov ow b"><strong class="js iu">PCSignalingConference</strong></code> <strong class="js iu"> </strong>:</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="5292" class="ms mt it ow b gy pd pe l pf pg">PCSignalingConference: <em class="le">function</em>({ <em class="le">desc</em>, <em class="le">from</em>, <em class="le">to</em>, <em class="le">candidate</em> }) {<br/> <br/> // Rule out message when needed<br/> if (from === this.$store.state.username || <br/>    (!!to &amp;&amp; to !==  this.$store.state.username)) return</span><span id="6f04" class="ms mt it ow b gy ph pe l pf pg"> if (desc) {<br/>   <strong class="ow iu">// Offer</strong><br/>   if (desc.type === DESCRIPTION_TYPE.offer)<br/>     this.conference = { <br/>       …this.conference, <br/>       offer: { from, desc }, <br/>       open: true <br/>     }<br/>   <strong class="ow iu">// Answer</strong><br/>   else if (desc.type === DESCRIPTION_TYPE.answer)<br/>     this.conference = { <br/>       …this.conference, <br/>       answer: { from, desc } <br/>     }</span><span id="04ad" class="ms mt it ow b gy ph pe l pf pg"> } else if (candidate) {<br/>   <strong class="ow iu">// Candidate</strong><br/>   this.conference = { <br/>     …this.conference, <br/>    candidate: { from, candidate } <br/>   }<br/> }<br/>}</span></pre><p id="f21b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与之前相同，基于通过信令信道发送的信息，我们区分要添加到连接的<em class="le">提议</em>、回答<em class="le">T21或者新的<a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/icecandidate_event" rel="noopener ugc nofollow" target="_blank">候选</a>。</em></p><blockquote class="pi"><p id="0b92" class="pj pk it bd pl pm pn po pp pq pr kn dk translated">但是，即使遵循相同的过程，管理员和用户B到底是如何处理的呢？</p></blockquote><p id="9465" class="pw-post-body-paragraph jq jr it js b jt ps jv jw jx pt jz ka kb pu kd ke kf pv kh ki kj pw kl km kn im bi translated">当B确认到达时，管理员激活会议，因此我们将向我们的<code class="fe ot ou ov ow b"><strong class="js iu">Conference.vue</strong></code>组件添加以下内容:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">对会议中的新用户做出反应</figcaption></figure><p id="72a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于每个新用户，管理员将启动webRTC机制，通过<code class="fe ot ou ov ow b">initWebRTC</code>方法创建一个要约，方式与我们在私聊中的方式相同，但现在使用mixin提供的方法。</p><blockquote class="lx ly lz"><p id="1407" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated">注意，我们使用<code class="fe ot ou ov ow b"><strong class="js iu">this.$set</strong></code>向我们的<code class="fe ot ou ov ow b">peers</code>对象添加一个新的对等体。这是由于在实例初始化后检测属性添加或删除时的限制。点击阅读更多关于反应性的信息<a class="ae nq" href="https://vuejs.org/v2/guide/reactivity.html" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><p id="a8b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，用户B在得到管理员提议之前不会发起会议，所以我们也将在我们的<code class="fe ot ou ov ow b"><strong class="js iu">Conference.vue</strong></code>组件中进行新的更改:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">新用户获得优惠</figcaption></figure><p id="2a60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦接收到提议，新的对等体通过上述相同的逻辑<code class="fe ot ou ov ow b">initWebRTC</code>创建并发送答案。</p><blockquote class="pi"><p id="0bd6" class="pj pk it bd pl pm pn po pp pq pr kn dk translated">如果会议已经有两个用户，而管理员邀请了第三个用户，该怎么办？</p></blockquote><p id="a205" class="pw-post-body-paragraph jq jr it js b jt ps jv jw jx pt jz ka kb pu kd ke kf pv kh ki kj pw kl km kn im bi translated">上述过程将是相同的，但扩展到更多的用户:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi py"><img src="../Images/6018031aeba97cba1b7af4fd6c4d5e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kdBfM3fNrjUZwAkgiMnRcQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">访客B加入具有两个用户现有会议</figcaption></figure><p id="b171" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如图所示，在管理员邀请<strong class="js iu"><em class="le">【1】</em></strong>之后，会议中的所有用户在得到确认<strong class="js iu"><em class="le">【2】</em></strong>后，会立即向新的对等方发送一个要约<strong class="js iu"><em class="le">【3】</em></strong>。此后，新对等体将向他们中的每一个回复一个答案<strong class="js iu"> <em class="le"> (4) </em> </strong>，从而建立两个连接<strong class="js iu"> <em class="le"> (N-1个上行和下行链路)</em> </strong></p><blockquote class="lx ly lz"><p id="0577" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated">基于这一点，你可以想象一旦我们想把它扩展到更多的用户，事情会变得有点麻烦</p></blockquote><p id="a198" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，尽管<strong class="js iu">和</strong>不会同时发生，因此<strong class="js iu">不会以任何特定的顺序到达新的对等体</strong>，因此<code class="fe ot ou ov ow b">GuestB</code>需要处理我们的<code class="fe ot ou ov ow b">Conference.vue</code>组件中缺乏同步性的问题:</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="0a42" class="ms mt it ow b gy pd pe l pf pg">watch: {<br/>   conference: <em class="le">function</em>({ <em class="le">offer</em> }, <em class="le">oldVal</em>) {<br/>     <strong class="ow iu">// New offer</strong><br/>     if(offer &amp;&amp; offer !== oldVal.offer &amp;&amp; !!oldVal.offer){<br/>       <em class="le">const</em> { from, desc } = offer<br/>       this.init(from, desc)<br/>     }<br/>   }<br/>}</span></pre><p id="db8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如所指出的，第一个报价将启动会议，所以我们需要在那之后发现新的报价。在我们的例子中，我们通过props <code class="fe ot ou ov ow b"><strong class="js iu">conference</strong></code>对象一次只处理一个offer，所以在处理几个连续的offer时，我们需要小心不要误导对象引用，因此在两种情况下检索offer信息时都要创建常量。</p><blockquote class="lx ly lz"><p id="ab46" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated"><code class="fe ot ou ov ow b">conference</code>对象只是一个包含正确信息的对象，这些信息在每种情况下都与提议、回答、ice候选、远程用户等有关。</p></blockquote><p id="c613" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后但同样重要的是，当会议结束时，我们离开会议并停止所有媒体:</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="7944" class="ms mt it ow b gy pd pe l pf pg">beforeDestroy() {<br/>  <strong class="ow iu">// Close all peer connections</strong><br/>  <em class="le">Object</em>.values(this.peers).forEach(<em class="le">peer</em> <em class="le">=&gt;</em> peer.pc.close())<br/>  this.peers = {}<br/>  <strong class="ow iu">// Leave conference</strong><br/>  this.$socket.emit(WS_EVENTS.leaveConference, { <br/>    …this.$store.state,<br/>    from: this.username,<br/>    conferenceRoom: this.conference.room<br/>  })<br/>},</span></pre><p id="562b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个对等体将重置所有对等体连接，并通过<code class="fe ot ou ov ow b"><strong class="js iu">leaveConference</strong></code>事件离开会议，适当地重置会议标志:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">离开会议web套接字服务器侦听器</figcaption></figure><p id="bd10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">媒体相关，<code class="fe ot ou ov ow b">webRTC</code> mixin将在被破坏之前重置本地媒体流:</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="389b" class="ms mt it ow b gy pd pe l pf pg">beforeDestroy() {<br/>  this.localStream.getTracks().forEach(<em class="le">track</em> <em class="le">=&gt;</em> track.stop())<br/>}</span></pre><blockquote class="pi"><p id="5ab9" class="pj pk it bd pl pm pz qa qb qc qd kn dk translated">把所有东西拼凑在一起，我们就可以试一试我们的解决方案了！</p></blockquote><p id="832d" class="pw-post-body-paragraph jq jr it js b jt ps jv jw jx pt jz ka kb pu kd ke kf pv kh ki kj pw kl km kn im bi translated">为了进行测试，我们将为每个用户创建一个应用实例，因此我们将通过<code class="fe ot ou ov ow b"><strong class="js iu">docker-compose.yml</strong></code>文件向<a class="ae nq" rel="noopener ugc nofollow" target="_blank" href="/build-your-own-video-chat-with-vue-webrtc-socketio-node-redis-eb51b78f9f55#e1f4">配置</a>添加我们应用的第三个副本:</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="9f2d" class="ms mt it ow b gy pd pe l pf pg"><strong class="ow iu"># Copy 3<br/></strong>chat3:<br/> build:<br/>  context: .<br/>  args:<br/>   VUE_APP_SOCKET_HOST: localhost<br/>   VUE_APP_SOCKET_PORT: 3002<br/> ports:<br/>  - 3002:3002<br/> networks:<br/>  - video-chat<br/> depends_on:<br/>  - redis<br/> environment:<br/>  PORT: 3002<br/>  REDIS_HOST: redis<br/>  REDIS_PORT: 6379</span></pre><p id="2fbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，我们将拥有以下本地测试环境:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/8c01ed801a4f441acd5d76a9fb61448b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*5MtWFHMZdt7BnhYkKyC7sA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">本地测试环境</figcaption></figure><p id="e87e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们只需要通过<code class="fe ot ou ov ow b">docker-compose</code>构建并运行我们的容器，瞧！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qf"><img src="../Images/bad94e099b16efdb3b7583b4b664e0a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zUxpt0wvDdNjgqTGau9JCw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">3个对等方的视频会议本地测试(每个用户一个实例)</figcaption></figure><p id="8e10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将有三个用户连接到不同的实例，并通过对等连接在他们之间进行会议。</p><blockquote class="lx ly lz"><p id="bff3" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated">webRTC应用程序中的错误追踪和解决有时可能有点复杂。有了Firefox你可以查看页面<strong class="js iu">关于:webrtc </strong>。它将为您提供关于SDP会议、ICE候选人等非常方便的信息。</p></blockquote><blockquote class="pi"><p id="7837" class="pj pk it bd pl pm pz qa qb qc qd kn dk translated">请记住，WebRTC使用ICE框架来克服网络复杂性</p></blockquote><p id="0d08" class="pw-post-body-paragraph jq jr it js b jt ps jv jw jx pt jz ka kb pu kd ke kf pv kh ki kj pw kl km kn im bi translated">在本地环境中进行测试时，一切都应该运行顺利。在这种情况下，对等体将通过<code class="fe ot ou ov ow b"><strong class="js iu">host</strong></code>候选者交换网络信息，这意味着ip地址是远程对等体的真实地址(同一网络内的所有对等体)。查看小型<em class="le"> UDP报价</em>平板的示例:</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="6eff" class="ms mt it ow b gy pd pe l pf pg">a=candidate:0 1 <strong class="ow iu">UDP</strong> 2122121471 198.167.1.138 54056 <strong class="ow iu">typ host</strong><br/>a=candidate:6 1 <strong class="ow iu">UDP</strong> 2122252543 fd8b:15c5:43b9:9m00:1c89:1vvc:2592:c9c6 54057 <strong class="ow iu">typ host</strong><br/>a=candidate:18 1 <strong class="ow iu">TCP</strong> 2105393407 192.168.1.130 9 <strong class="ow iu">typ host</strong> tcptype <strong class="ow iu">active</strong></span></pre><blockquote class="lx ly lz"><p id="c814" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated">TCP候选仅在UDP不可用或受到限制而不适合媒体流时使用</p></blockquote><p id="3bcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而在真实环境中，信息交换通常会通过来自<a class="ae nq" href="https://www.3cx.com/pbx/what-is-a-stun-server/" rel="noopener ugc nofollow" target="_blank"> STUN </a>服务器的<code class="fe ot ou ov ow b"><strong class="js iu">srflx</strong></code>和<code class="fe ot ou ov ow b"><strong class="js iu">prflx</strong></code>候选者，让双方发现他们的公共IP地址和他们背后的NAT类型。在大多数情况下，这只是在连接建立期间需要的，因为一旦连接建立，媒体将在对等体和视频网关之间直接流动。</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="a096" class="ms mt it ow b gy pd pe l pf pg">a=candidate:1 1 UDP 1685921791 212.194.185.191 47355 <strong class="ow iu">typ</strong> <strong class="ow iu">srflx</strong> raddr 192.168.1.130 rport 54056</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi qg"><img src="../Images/5cdb485756bfff682910f27ee083a67b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXIna65MtzlDlIJxaexrfA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">WebRTC网络方案</figcaption></figure><p id="dc53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是在其他一些情况下，远程对等体生活在非常严格的网络后面，这将需要使用<a class="ae nq" href="https://webrtc.org/getting-started/turn-server" rel="noopener ugc nofollow" target="_blank"> TURN </a>服务器和<code class="fe ot ou ov ow b"><strong class="js iu">relay</strong></code>候选者。中继候选者的IP地址是当直接连接失败时TURN服务器用来在两个对等体之间转发媒体的地址。</p><pre class="kp kq kr ks gt oz ow pa pb aw pc bi"><span id="dfa1" class="ms mt it ow b gy pd pe l pf pg">a=candidate:3 1 UDP 92086015 133.244.182.3 60795 <strong class="ow iu">typ</strong> <strong class="ow iu">relay</strong> raddr 134.219.114.1 rport 60795</span></pre><p id="f1d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于它们的性质，你会发现有许多公共眩晕服务器(就像这个<a class="ae nq" href="https://gist.github.com/mondain/b0ec1cf5f60ae726202e" rel="noopener ugc nofollow" target="_blank">列表</a>)但是很少或者没有公共眩晕服务器，因为媒体流过它们意味着带宽消耗💶💶</p><p id="16ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以请记住<strong class="js iu">如果你不提供合适的TURN服务器配置</strong>(同样，如果你不为其他情况提供正确的STUN配置)，限制性网络<strong class="js iu">后面的所有连接</strong>都将失败。<strong class="js iu"> <em class="le"> </em> </strong>记住你可以在这里<a class="ae nq" href="https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/" rel="noopener ugc nofollow" target="_blank">检查任何服务器的连通性。</a></p><blockquote class="lx ly lz"><p id="95a9" class="jq jr le js b jt ju jv jw jx jy jz ka ma kc kd ke mb kg kh ki mc kk kl km kn im bi translated">如果你对TURN服务器感兴趣，有一些像<a class="ae nq" href="https://github.com/coturn/coturn" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> coturn </strong> </a>这样的开源工具可以让你创建自己的服务器。</p></blockquote><h1 id="3a08" class="oc mt it bd mu od oe of mx og oh oi na oj ok ol nd om on oo ng op oq or nj os bi translated">结论</h1><p id="dadc" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">这是一个潜在的例子，包含了使用网状架构<strong class="js iu">建立<strong class="js iu">多对多</strong>视频会议所需的所有步骤。</strong>理想情况下，对于少于4个用户的非常简单的情况，这种拓扑是合理的选择。</p><p id="db83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你真的打算大规模构建一些东西，像<em class="le"> MCU </em>和<em class="le"> SFU </em>这样的方法是合适的选择，将大部分精力和责任集中在服务器实现上。</p><p id="9eeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在同一个存储库中的处找到源代码<a class="ae nq" href="https://github.com/adrigardi90/video-chat" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="eeda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你已经发现它很有趣，如果你已经喜欢它并且想要更多相关的内容，请分享并且粉碎👏</p><p id="a9ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意安全！😷</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><div class="kp kq kr ks gt li"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd iu gy z fp ln fr fs lo fu fw is bi translated">编写面试问题</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">技术开发</p></div></div><div class="lr l"><div class="qh l lt lu lv lr lw ky li"/></div></div></a></div></div></div>    
</body>
</html>