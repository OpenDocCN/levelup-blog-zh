<html>
<head>
<title>Why Are You Still Creating CRUD APIs?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么还在创建CRUD APIs？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-are-you-still-creating-crud-apis-8790ca261bfb?source=collection_archive---------0-----------------------#2021-07-10">https://levelup.gitconnected.com/why-are-you-still-creating-crud-apis-8790ca261bfb?source=collection_archive---------0-----------------------#2021-07-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c480" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">固执己见的观点</h2><div class=""/><div class=""><h2 id="e461" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">这是一个古老的模式，最好留下来。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ae20e088240747167a3b9f9e0f2baaa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sWcfZpIgUnPCz4lhQTb7Cw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="lh li ep" href="https://medium.com/u/7c7a43b3d9de?source=post_page-----8790ca261bfb--------------------------------" rel="noopener" target="_blank">尼可拉斯·米勒德</a></figcaption></figure><p id="1e9a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我开始学习编程和web开发时，我就听说过CRUD。这很像是使用的<em class="mf">和</em>方法。我会花时间思考作为“资源”的实体，以及如何编写令人惊叹的基于CRUD的应用程序，其中每个资源都被创建、读取、更新或删除，仅此而已。本质上，最好的描述是“原始思维”</p><p id="d2ef" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">创建、读取、更新、删除。很简单——这正是问题所在。</p><blockquote class="mg"><p id="137c" class="mh mi it bd mj mk ml mm mn mo mp me dk translated">您上次仅从存储管理的角度考虑您的领域是什么时候？</p></blockquote><p id="c594" class="pw-post-body-paragraph lj lk it ll b lm mq kd lo lp mr kg lr ls ms lu lv lw mt ly lz ma mu mc md me im bi translated">但是我明白为什么初学者喜欢这种方法。CRUD思想可以很好地转化为现有的编程概念，如SQL的<code class="fe mv mw mx my b">INSERT, SELECT, UPDATE, DELETE</code>或HTTP的<code class="fe mv mw mx my b">GET, POST, PUT/PATCH, DELETE</code>。</p><h1 id="79e5" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">基于CRUD的应用有什么问题？</h1><p id="0e59" class="pw-post-body-paragraph lj lk it ll b lm nr kd lo lp ns kg lr ls nt lu lv lw nu ly lz ma nv mc md me im bi translated">在我看来，主要的问题是你在创建基于CRUD的界面时完全忽略了用户的意图。意图是一个重要的方面，作为开发人员，我们不能掩盖它。</p><p id="1ae1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一旦开始以类似CRUD的方式设计应用程序的接口(例如HTTP端点),问题就出现了。</p><blockquote class="nx ny nz"><p id="2b81" class="lj lk mf ll b lm ln kd lo lp lq kg lr oa lt lu lv ob lx ly lz oc mb mc md me im bi translated">顺便说一下，<a class="ae nw" rel="noopener ugc nofollow" target="_blank" href="/whats-wrong-with-your-crudy-interfaces-besides-everything-bde4f4c8cb8a">这里有一篇关于CRUD over REST问题的更深入的文章</a>。</p></blockquote><p id="b3be" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">例如，假设您有一个“作者”模型——尽管是人为的——定义如下，并且您正在开发一个web API，它对作者执行一些操作并将其存储在数据库中。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/a0319e163fe543e8f143bd7bceea6e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVG5LJ09hRwiMFRKiyAbuw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">人为的作者模型。</figcaption></figure><p id="799d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">还有一个作者希望有一个额外的笔名——顺便说一下，笔名就像作者的“伪”名——但是应用程序只支持将完整的作者模型作为输入的<code class="fe mv mw mx my b">PATCH api/authors/{id}</code>。</p><p id="c6b8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">起初，你可能认为这没什么大不了的。</p><p id="1abf" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">但是，这对应用程序开发人员来说是一个巨大的烦恼。没有机会猜测需要更新什么，所以实现可能会变得过于冗长，更新每个属性，如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oe"><img src="../Images/f74bbcbfc19749308eee2648f7fc5daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZIX1-d_RYgtSKXOCaOJ7w.png"/></div></div></figure><p id="2370" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这非常混乱，记住我们只是想再添加一个笔名——现在想象一下如果我们添加了错误处理和条件分支。这很快就变成了一场维护噩梦。</p><p id="dec8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我是一名软件顾问时，我注意到一些开发人员试图避免更新每个属性。他们的解决方案是在相同的方法中增加一个额外的层:他们会收到一个属性，告诉他们用户的意图。</p><p id="a971" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">那我们就会有像这样的东西。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi of"><img src="../Images/2890c2a4e599e734a7e510cce4ff2367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdaRf6OBo1EfT2I-EYpnPg.png"/></div></div></figure><p id="a37a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这个想法很好。但是我认为这个问题没有得到正确的解决，因为<a class="ae nw" rel="noopener ugc nofollow" target="_blank" href="/why-cognitive-and-cyclomatic-complexity-matters-in-software-development-5fce1efb56ab">圈和认知复杂性</a>都开始不受控制地螺旋式上升。<a class="ae nw" rel="noopener ugc nofollow" target="_blank" href="/writing-readable-code-exemplified-bd387cd93b6b">可读性也在窗外</a>。</p><p id="74ae" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">显然，尽管保留了粗糙的API，基于任务的方法正在悄然出现。这种方法出现了一个明显的陷阱:模型混乱。</p><p id="0764" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">作为API的客户，我仍然被允许完全合并<code class="fe mv mw mx my b">UpdateAuthorConditionally</code>模型，即，用数据填充所有属性，但是，<code class="fe mv mw mx my b">UpdateReason</code>属性是决定哪些作者属性被实际更新的属性。</p><p id="d2e0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">所以，令人困惑的部分是:如果我只想添加一个新的笔名，为什么允许我填充<code class="fe mv mw mx my b">Email</code>？</p><p id="21c7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">🔔想要更多这样的文章吗？在这里签名。</p><h1 id="6f3b" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">有一个简单愚蠢的解决方案。</h1><p id="1195" class="pw-post-body-paragraph lj lk it ll b lm nr kd lo lp ns kg lr ls nt lu lv lw nu ly lz ma nv mc md me im bi translated">停止“设计”基于CRUD的界面。相反，基于任务的界面是一个很好的选择，你的客户和开发人员会非常喜欢。</p><p id="0518" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">以上面类似CRUD的接口为例，我们可以提取以下端点:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/9dad07703eead14f96d39851d12bf5f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xIICu2kHriCXavRQ-dUiFA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">基于任务的端点。</figcaption></figure><p id="9719" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">更多的方法、类和更多的代码行。那么，这怎么更好呢？</p><p id="9d1c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">就<a class="ae nw" rel="noopener ugc nofollow" target="_blank" href="/writing-cleaner-code-with-examples-69be2160b4c1">干净多了</a>。传统的条件分支语句已经一去不复返了。</p><p id="9d1f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">每种方法都有明显的责任。每种方法只做一件事，而且每种方法都可以独立于其他方法而发展。</p><p id="9bf8" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">一旦你开始应用这种方法，圈复杂度和认知复杂度就会降到最低点。</p><p id="2ac1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">代码更容易阅读和维护。不再需要猜测—您和您的客户确切知道什么时候更新了什么。</p><h1 id="3a95" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">"你只是在做地产级别的垃圾！"</h1><p id="4d92" class="pw-post-body-paragraph lj lk it ll b lm nr kd lo lp ns kg lr ls nt lu lv lw nu ly lz ma nv mc md me im bi translated">当然，这可能看起来像是因为我直接将基于CRUD的接口转换为基于任务的接口。但是，希望这将有助于许多人的理解，因为除了CRUDy API中已经确定的任务之外，没有“新的”任务。</p><p id="3a55" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">此外，我相信大多数人可以从实现中抽象出这个概念:在使用您的应用程序时，无论客户有什么样的意图，都可以使用更专门化的端点。</p><p id="e4c9" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，让我清楚地说明这一点:我并不是说每个对象属性都应该有一个端点。我的意思是，您应该拥有与客户意图和他们想要执行的操作相匹配的端点。</p><h1 id="73f4" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">“但是现在你需要调用5个端点而不是一个！”</h1><p id="b95a" class="pw-post-body-paragraph lj lk it ll b lm nr kd lo lp ns kg lr ls nt lu lv lw nu ly lz ma nv mc md me im bi translated">对，现在你确切地知道每个端点将做什么。</p><p id="9ec6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">当我为丹麦教育部创建应用程序时，我们不得不与第三方服务提供商合作，他们拥有学校、教师、班级和学生的所有数据。</p><p id="4f95" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">项目开始几周后，我们需要给一所学校增加学生。因此，我简单地调用了他们的端点，并为一名学生提供了XML数据。这该死的东西擦干净了整个学校，又增加了这个<em class="mf">一个</em>的新生。所以，结果基本上是1个学生的小学(而且不，他们的端点根本没有提到这个行为)。</p><p id="20cd" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果他们有一个像<code class="fe mv mw mx my b">POST/PATCH api/schools/{id}/AddStudent</code>这样的终点，我们就可以避免这种头痛。</p><p id="1509" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">有趣的补充说明:由于第三方API很难使用，大多数学校会将excel表发送给第三方，他们会手动处理这些excel表。</p><h1 id="8640" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">“粗糙的应用程序有时肯定没问题吧？”</h1><p id="dada" class="pw-post-body-paragraph lj lk it ll b lm nr kd lo lp ns kg lr ls nt lu lv lw nu ly lz ma nv mc md me im bi translated">当然可以。基于CRUD的应用程序可能有它们的位置，尽管我主张让它们消失。主要的优势是开发速度，这是肯定的。</p><p id="5f38" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">It <em class="mf">也许</em>可以抛弃一个短命的概念验证(PoC)应用程序。然而，众所周知，没有什么东西是短暂的或可以丢弃的。</p><p id="1e9b" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果证明是可行的、可行的和令人满意的，POC通常会升级到生产状态。</p><h1 id="477c" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">所以，总的来说…</h1><p id="cb7a" class="pw-post-body-paragraph lj lk it ll b lm nr kd lo lp ns kg lr ls nt lu lv lw nu ly lz ma nv mc md me im bi translated">初学者经常学习如何创建基于CRUD的应用程序接口，尤其是在学习如何创建web APIs时，但是他们很少花时间去思考这种看似简单的方法可能存在的一些困难。</p><p id="e577" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">应用基于任务的方法是粗糙界面的一个很好的替代方法。基于任务的接口传达意图和目的，允许每个端点单独发展，比CRUD更容易维护。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="05e1" class="mz na it bd nb nc oo ne nf ng op ni nj ki oq kj nl kl or km nn ko os kp np nq bi translated">让我们保持联系！</h1><p id="c086" class="pw-post-body-paragraph lj lk it ll b lm nr kd lo lp ns kg lr ls nt lu lv lw nu ly lz ma nv mc md me im bi translated"><a class="ae nw" href="https://nmillard.medium.com/subscribe" rel="noopener">点击这里</a>订阅时事通讯，获取类似文章的通知，并查看新的YouTube频道<a class="ae nw" href="https://www.youtube.com/channel/UCaUy83EAkVdXsZjF3xGSvMw" rel="noopener ugc nofollow" target="_blank"><em class="mf">(@ Nicklas Millard)</em></a></p><p id="d0a4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><em class="mf">连接上</em><a class="ae nw" href="https://www.linkedin.com/in/nicklasmillard/" rel="noopener ugc nofollow" target="_blank"><em class="mf">LinkedIn</em></a></p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="d4b6" class="mz na it bd nb nc oo ne nf ng op ni nj ki oq kj nl kl or km nn ko os kp np nq bi translated">我想你会喜欢类似的材料。</h1><ul class=""><li id="c4d2" class="ot ou it ll b lm nr lp ns ls ov lw ow ma ox me oy oz pa pb bi translated"><a class="ae nw" href="https://youtu.be/goVjlWLY9NQ" rel="noopener ugc nofollow" target="_blank">干净代码示例(YouTube) </a></li><li id="f250" class="ot ou it ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated"><a class="ae nw" rel="noopener ugc nofollow" target="_blank" href="/remove-your-if-else-and-switch-cases-1ed2b625b4cf">移除If-Else和开关盒</a></li><li id="1554" class="ot ou it ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated"><a class="ae nw" rel="noopener ugc nofollow" target="_blank" href="/why-cognitive-and-cyclomatic-complexity-matters-in-software-development-5fce1efb56ab">为什么认知和圈复杂度在软件开发中很重要</a></li><li id="3ffb" class="ot ou it ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated"><a class="ae nw" rel="noopener ugc nofollow" target="_blank" href="/writing-cleaner-code-with-examples-69be2160b4c1">编写更干净的代码(附例子)</a></li></ul></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="0c38" class="mz na it bd nb nc oo ne nf ng op ni nj ki oq kj nl kl or km nn ko os kp np nq bi translated">好奇者的资源</h1><ul class=""><li id="752a" class="ot ou it ll b lm nr lp ns ls ov lw ow ma ox me oy oz pa pb bi translated">📚<a class="ae nw" href="https://github.com/NMillard/SimpleWebApps/tree/master/src/GeneralPractices/CrudOrTaskBased/CrudApp" rel="noopener ugc nofollow" target="_blank">源代码【GitHub】作者</a><a class="lh li ep" href="https://medium.com/u/7c7a43b3d9de?source=post_page-----8790ca261bfb--------------------------------" rel="noopener" target="_blank">尼可拉斯·米勒德</a>作者</li><li id="c2e1" class="ot ou it ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated"><a class="ae nw" href="https://www.infoq.com/news/2009/07/CRUDREST/" rel="noopener ugc nofollow" target="_blank">CRUD不利于休息吗？鲍里斯·卢布林斯基</a></li><li id="c363" class="ot ou it ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated"><a class="ae nw" href="https://blog.softmemes.com/2016/11/12/using-cqrs-with-event-sourcing/" rel="noopener ugc nofollow" target="_blank">将CQRS用于事件采购或CRUD有什么问题？</a>克里斯蒂安·弗瑞德</li><li id="3e87" class="ot ou it ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated"><a class="ae nw" href="https://www.codecademy.com/articles/what-is-crud" rel="noopener ugc nofollow" target="_blank">code academy上的CRUD </a>是什么</li><li id="0ee5" class="ot ou it ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated"><a class="ae nw" href="http://codebetter.com/iancooper/2011/07/15/why-crud-might-be-what-they-want-but-may-not-be-what-they-need/" rel="noopener ugc nofollow" target="_blank">为什么CRUD可能是他们想要的，但可能不是他们需要的</a>Ian Cooper</li><li id="534e" class="ot ou it ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated"><a class="ae nw" href="https://cqrs.wordpress.com/documents/task-based-ui/" rel="noopener ugc nofollow" target="_blank">cqrs.wordpress.com上基于任务的用户界面</a></li><li id="af89" class="ot ou it ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated">Mathias Verraes提出的CRUD是一个反模式</li></ul></div></div>    
</body>
</html>