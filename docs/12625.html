<html>
<head>
<title>Stop doing Token Auth in the Frontend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止在前端进行令牌认证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/secure-frontend-authorization-67ae11953723?source=collection_archive---------0-----------------------#2022-06-24">https://levelup.gitconnected.com/secure-frontend-authorization-67ae11953723?source=collection_archive---------0-----------------------#2022-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e440" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为单页应用程序构建安全认证过程的现代方法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ba43f518ca007609bab27e315223a9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IVX0atuxLpoYZ616"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@adnan10?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿德南·汗</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6f18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇与框架无关的文章中，我将向您介绍一种为SPA构建安全认证过程的现代方法。如果您已经熟悉JWT令牌和OAuth 2.0，那么您很可能会从阅读本文中受益，因为本文解释了为什么不应该在浏览器中存储令牌，并将向您展示一种结合cookies和JWT令牌来创建更安全的应用程序的现代方法。</p><h1 id="530c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">OAuth 2.0</h1><p id="fcb2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有很多很好的文章完美地解释了OAuth 2.0的细节，所以我将重点向您提供OAuth 2.0的一个非常简单的概述。因此，原则上OAuth 2.0是为任何类型的应用程序创建安全认证流的事实上的行业标准。基本上，客户端向身份验证提供者发送一个登录请求，然后身份验证提供者发送一个302重定向，这将触发浏览器重定向到身份验证提供者提供的登录页面。登录后，认证提供者重定向回客户端触发登录过程的原始路由，此外还发送一个<strong class="lb iu">访问令牌</strong>和一个<strong class="lb iu">刷新令牌</strong>，它们在使用<strong class="lb iu">承载认证</strong>(事实标准)时用于认证。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/4c7113c80df5f1ec7e8834cddde11638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BiD2wbB0A590rw1L9Jbqcw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">强简化过程</figcaption></figure><p id="93c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">访问令牌</strong>作为授权参数被附加在每个HTTP请求头中，以便API可以向认证提供者验证令牌是否有效。通常，访问令牌具有较短的到期时间，有时甚至只有几分钟，因为这允许更好的安全性，使得如果恶意方不能使用访问令牌足够长的时间来进行许多恶意请求。</p><p id="1e24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">当当前访问令牌过期时，客户端使用刷新令牌</strong>从身份验证提供者处获取新的访问令牌。</p><p id="d524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个令牌都被认为是一个JWT (JSON Web令牌),它基本上是一个JSON对象，包含标准数据，但也包含特定于应用程序的数据。</p><p id="9280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">OAuth 2.0非常方便，允许轻松集成第三方身份提供商，如谷歌身份、脸书、微软、Azure Active Directory等。因此，我们触发登录过程，只需在本地存储中存储访问令牌和刷新令牌，然后将令牌附加到HTTP头。就这么简单。<strong class="lb iu">但是……</strong></p><h1 id="20e6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">跨站点脚本</h1><p id="e852" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">但愿没有这个叫跨站脚本的烦人东西，简称:<strong class="lb iu"> XSS </strong>。如果我们关心安全和防御XSS，我们就不能简单地将令牌存储在本地存储中。</p><p id="8856" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">XSS是一种黑客技术，用于在运行时将自定义JavaScript注入DOM。例如，黑客可以在输入字段中注入JavaScript代码，方法是用“-”符号对输入进行转义，然后执行定制的JavaScript代码，而恶意攻击者可以访问每个JavaScript API。因此，攻击者可以很容易地从本地存储器中读取条目，并获得手中的令牌。从这一点上，你只能希望最好的，同时希望你已经把更多的努力放在第一位的应用程序。那么解决办法是什么呢？</p><h1 id="7c33" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">令牌处理程序模式</h1><p id="b9f2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们回到过去，讨论一下前端和后端应用程序之间的一种更老的认证方法。在过去，我们没有那些花哨的令牌，但是我们使用简单的cookies来验证用户是否登录。当时，前端向后端发送用户名和密码，后端创建一个类似授权状态的cookie，并将其设置在HTTP头中，前端将总是在每个请求的HTTP头中发送cookie。</p><p id="cfdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到我们的例子，这里的问题是我们在客户端存储令牌。遗憾的是，我们无法将令牌安全地存储在客户机中，因为我们不希望JavaScript访问它们。绕过这个问题的唯一方法是创建一个专用的后端来处理登录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/ea618d807a3dd3133b0b99ae76f3f17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X6OTNQx8QiNvJB4iXi9aQg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">简化过程</figcaption></figure><p id="b0b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前端只与一个<strong class="lb iu">中间件</strong>通信，该中间件处理认证/授权并充当API和前端之间的代理。中间件触发一个<strong class="lb iu"> HTTP 302重定向</strong>，这将自动迫使浏览器重定向到身份提供者提供的登录页面。登录后，身份提供者重定向到一个<strong class="lb iu"> redirect_url </strong>，它必须在原始重定向请求中指定。redirect_url指向前端的专用路由，而身份提供者将向查询参数添加一个<strong class="lb iu">认证代码</strong>。然后，前端将验证码发送到后端，后端使用验证码生成令牌。这些令牌将被存储在一个HTTP-only cookie中，该cookie在对前端的响应的HTTP头中设置。然后，前端将这个cookie存储在浏览器中，并通过将参数<strong class="lb iu">credentials:“include”</strong>添加到初始请求中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/915fb2915726f461ae13e34466ce57b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8FRhWvHV5k-0Ee00ZgWqg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">详细的登录工作流程</figcaption></figure><p id="cebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是<strong class="lb iu"> HttpOnly </strong>到底是什么意思，为什么这比在客户端存储令牌更安全？</p><h1 id="d75c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">仅限HTTP的Cookies</h1><p id="73ca" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为什么将令牌存储在cookie中比存储在本地存储中更安全？默认情况下不是，因为JavaScript API也可以通过访问<strong class="lb iu"> document.cookie </strong>轻松读取所有cookie。因此，现在XSS又成了一个问题。</p><p id="bbf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但幸运的是，我们可以使用所谓的<strong class="lb iu"> HTTP专用cookie</strong>，JavaScript API无法访问它们。尽管它们在浏览器中的存储方式与普通cookie完全相同，但它们只能附加到HTTP请求中。例如，您可以从fetch API中设置选项<strong class="lb iu"> credentials:'include' </strong>,以便在请求头中包含所有cookie，包括只包含HTTP的cookie。这样，XSS攻击者就不可能获得HTTP-only cookie，因此也就无法获得令牌。</p><h1 id="5668" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">第一方与第三方Cookies</h1><p id="9f63" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们还需要讨论一件事——第三方和第一方cookies之间的区别。在另一个域上创建的cookie始终被视为第三方cookie，而在托管前端的域上创建的cookie则被视为第一方cookie。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/a6289d068076597852a1361c96e23c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lcb7ku4Qx1sfSaPlr45wJg.png"/></div></div></figure><p id="898d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后端托管在不同的域上并不罕见，尤其是当前端是单页面应用程序(SPA)时。在这种情况下，另一个XSS攻击仍然是可能的，因为攻击者可以将执行HTTP请求的代码注入到他自己的API中，并包括cookie，这样他的API将读取HTTP-only cookie。</p><p id="086a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，还有一种方法可以防止这种情况，通过制作第一方cookie并设置头参数<strong class="lb iu"> SameSite='strict' </strong>，这样cookie就只发送给目标相同域的请求。我们只需要在同一个域上部署中间件。</p><h1 id="1dc0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">无服务器令牌处理程序</h1><p id="6812" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">虽然这不是必需的，但这是使用<strong class="lb iu">无服务器计算</strong>的完美场景，而不是为中间件创建专用的API。</p><p id="f40b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无服务器计算是一种云服务，允许开发和部署简单的无状态功能，而不必考虑基础设施和服务器。虽然这个名字可能会引起误解，但是这些功能仍然会在云计算提供商托管的服务器上运行，但是我们不必考虑服务器。它们可以根据需要扩展，也可以缩小，这样您只需为实际使用付费。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/76f7d620cd814225f576b8fc15376367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XcH2YlJmZUeZB6l_h9rb5w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Azure Functions徽标</figcaption></figure><p id="9f83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建两个简单的函数，使得整个Web API只用于不必要的中间件。第一个函数是登录函数，第二个函数是代理函数，它总是将请求重定向到API，并在头中附加访问令牌。</p><h1 id="725c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="c6d7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">坦率地说，没有一个系统是绝对安全的。但是这个假设不应该阻止我们创建更加安全的应用程序。这种方法可能阻止XSS攻击能够检索JWT令牌，但引入了CSRF的风险，这基本上是一种攻击者直接使用其cookie从客户端发送请求的攻击。没有一个解决方案是完美的，有它的优点和缺点，但是作为软件工程师，我们的工作就是为我们的商业案例制定正确的解决方案。</p><p id="1ba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如果你喜欢这篇文章，并且想在Medium上无限阅读，你可以通过我的推荐链接加入Medium:</strong></p><div class="mx my gp gr mz na"><a href="https://medium.com/@stefan.haas.privat/membership" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">通过我的推荐链接-斯特凡·哈斯加入媒体</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">medium.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ks na"/></div></div></a></div></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="fece" class="lv lw it bd lx ly nw ma mb mc nx me mf jz ny ka mh kc nz kd mj kf oa kg ml mm bi translated"><strong class="ak">参考文献</strong></h1><ul class=""><li id="1228" class="ob oc it lb b lc mn lf mo li od lm oe lq of lu og oh oi oj bi translated"><strong class="lb iu"> OAuth 2.0。维基百科。</strong><a class="ae ky" href="https://en.wikipedia.org/wiki/OAuth#OAuth_2.0" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/OAuth#OAuth_2.0</a></li><li id="61f9" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><strong class="lb iu"> XSS。维基百科。</strong><a class="ae ky" href="https://en.wikipedia.org/wiki/Cross-site_scripting" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Cross-site_scripting</a></li><li id="1ad2" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><strong class="lb iu"> JWT。维基百科。</strong><a class="ae ky" href="https://en.wikipedia.org/wiki/JSON_Web_Token" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/JSON_Web_Token</a></li><li id="2350" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><strong class="lb iu">令牌处理程序模式。好奇。</strong><a class="ae ky" href="https://curity.io/resources/learn/token-handler-spa-example/" rel="noopener ugc nofollow" target="_blank">https://curity . io/resources/learn/token-handler-spa-example/</a></li><li id="7663" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><strong class="lb iu"> HttpOnly Cookie。Owasp.org</strong><a class="ae ky" href="https://owasp.org/www-community/HttpOnly" rel="noopener ugc nofollow" target="_blank">https://owasp.org/www-community/HttpOnly</a></li><li id="084a" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated"><strong class="lb iu">无服务器计算。维基百科。</strong><a class="ae ky" href="https://en.wikipedia.org/wiki/Serverless_computing" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Serverless_computing</a></li><li id="5566" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">CSRF。维基百科。<a class="ae ky" href="https://en.wikipedia.org/wiki/Cross-site_request_forgery" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Cross-site_request_forgery</a></li></ul></div></div>    
</body>
</html>