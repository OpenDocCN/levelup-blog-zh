<html>
<head>
<title>Apollo and RxJava: Android GraphQL the Right Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apollo和RxJava:正确使用Android GraphQL</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/apollo-rxjava-android-graphql-the-right-way-a1f2b10a9ac8?source=collection_archive---------7-----------------------#2020-12-02">https://levelup.gitconnected.com/apollo-rxjava-android-graphql-the-right-way-a1f2b10a9ac8?source=collection_archive---------7-----------------------#2020-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b52a7459be68cd862bc0f23becadbe5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5tpj2rcm80RCmFhE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="071d" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="2015" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">自诞生以来，GraphQL已经发展成为构建后端API的一个非常流行的框架。然而，我仍然没有在Android上看到它经常使用。我认为原因是在Android上使用GraphQL的资源不多，确实存在的都是过时的或者没有利用新技术。在本文中，我想介绍一种在Android上设置GraphQL客户端的“最佳实践”方法。我们将制作一个简单的Android应用程序，它使用SpaceX GraphQL API来显示火箭列表。通过利用<a class="ae kc" href="https://github.com/apollographql/apollo-android" rel="noopener ugc nofollow" target="_blank"> Apollo Android </a>和<a class="ae kc" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>，我们将以正确的方式在Android上运行GraphQL。</p><h1 id="3fbb" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">设置</h1><p id="8c99" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在开始之前，我们必须准备好所有的依赖项。首先，将以下内容粘贴到您的项目级别<code class="fe lz ma mb mc b">build.gradle</code>:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="a039" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">这将添加我们为RxJava需要的apollo插件和maven repo。接下来，将这些依赖项和插件添加到您的应用程序级别<code class="fe lz ma mb mc b">build.gradle</code>:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="59e0" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">这里我们添加了两个与Apollo相关的依赖项，一个用于库本身，另一个用于Rx支持。我们还添加了RxJava的Android端口RxAndroid，以及RxJava本身。我们显式地添加RxJava，因为RxAndroid不经常更新，所以手动定义它可以让我们及时更新错误修复。不要忘记在你的gradle文件末尾添加<code class="fe lz ma mb mc b">apply plugin: “com.apollographql.apollo”</code>，否则你以后会遇到编译问题。</p><h1 id="568d" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">编写GraphQL查询</h1><p id="1ba8" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">创建目录<code class="fe lz ma mb mc b">src/main/graphql/com/example</code>，但是用您自己的包名替换<code class="fe lz ma mb mc b">example</code>。之后，运行以下命令获取一个GraphQL模式:</p><pre class="md me mf mg gt mo mc mp mq aw mr bi"><span id="3675" class="ms ke iq mc b gy mt mu l mv mw">./gradlew downloadApolloSchema <br/>--endpoint="https://api.spacex.land/graphql/" <br/>--schema="src/main/graphql/com/example/schema.json"</span></pre><blockquote class="mx my mz"><p id="f756" class="lb lc na ld b le mj lg lh li mk lk ll nb ml lo lp nc mm ls lt nd mn lw lx ly ij bi translated"><em class="iq">如果你在Windows上用</em> <code class="fe lz ma mb mc b"><em class="iq">gradlew.bat</em></code> <em class="iq">替换</em> <code class="fe lz ma mb mc b"><em class="iq">./gradlew</em></code> <em class="iq">。</em></p></blockquote><p id="2057" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">该命令将在SpaceX API上运行自省，并为我们创建一个<code class="fe lz ma mb mc b">schema.json</code>。接下来，我们将编写我们的GraphQL查询，我们将使用它来获取火箭列表。在与<code class="fe lz ma mb mc b">schema.json</code>相同的目录下创建一个名为<code class="fe lz ma mb mc b">rockets.graphql</code>的文件，并粘贴以下内容:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="c9c9" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">这是一个非常基本的GraphQL查询，它以<code class="fe lz ma mb mc b">rockets</code>端点为目标，获取一个火箭列表，每个条目包含火箭的id、名称和描述。API实际上提供了比这更多的信息，但是我们只需要这三个数据点。因为GraphQL让我们只获取我们需要的东西，所以我们不必用不必要的信息来减缓我们的请求。‌如果你特别想了解更多关于GraphQL的知识，<a class="ae kc" href="https://medium.com/free-code-camp/so-whats-this-graphql-thing-i-keep-hearing-about-baf4d36c20cf" rel="noopener">这篇文章</a>是一个很好的起点。</p><p id="0558" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">现在我们已经编写了查询，构建项目。Apollo将读取我们创建的graphql文件，并自动生成用于对服务器进行查询的类。如果您将项目视图设置为Android，您应该会看到以下内容:</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/6c60533c189e267f888d3c359ad0471d.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*uHDE8Zo5AsLlPnJoAWqGIQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">见java中的RocketQuery类(生成)？</figcaption></figure><h1 id="686c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">发出GraphQL请求</h1><p id="df3b" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在我们已经设置好了所有的GraphQL，我们可以开始编写一些Java代码了。将所有与服务器相关的代码放在一个类中是很好的做法，我们称之为<code class="fe lz ma mb mc b">Server</code>。下面是该类的外壳:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="bee7" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">这个类使用单例模式创建一个<code class="fe lz ma mb mc b">ApolloClient</code>实例。我们将在查询中使用这个助手方法，这样我们就不必为每个查询创建一个客户机。</p><p id="0e2d" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">接下来让我们为我们的<code class="fe lz ma mb mc b">rockets</code>查询创建一个方法:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="45fb" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">这段代码相当密集，所以让我们慢慢来。首先，我们用<code class="fe lz ma mb mc b">RocketsQuery</code>创建一个<code class="fe lz ma mb mc b">ApolloQueryCall</code>对象，这个类是从我们之前编写的GraphQL文件中生成的。该对象定义了我们想要对SpaceX API进行的GraphQL查询。‌</p><p id="4126" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">然后，我们使用助手类<code class="fe lz ma mb mc b">Rx3Apollo</code>将调用转换成RxJava对象，这让我们可以在其上完成所有的Rx魔术。指定我们希望这个请求在后台线程上运行。对于<code class="fe lz ma mb mc b">observeOn</code>，我们说我们希望在主线程上处理响应，因为我们将使用响应更新UI。最后，我们添加一个过滤器来丢弃空响应，以防止任何空指针异常。</p><p id="e9fd" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">该方法返回一个<code class="fe lz ma mb mc b">Observable</code>，我们可以在活动代码中使用它来处理加载和错误状态，并在得到响应时更新UI。</p><p id="6507" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">现在我们将使用我们创建的<code class="fe lz ma mb mc b">fetchRockets</code>方法来填充一个列表:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="d4ba" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">在这个代码片段中，我们首先显示加载指示器，因为我们将要获取数据。然后，我们使用我们的<code class="fe lz ma mb mc b">Server</code>类进行rockets查询，并创建一个<code class="fe lz ma mb mc b">DisposableObserver</code>来处理结果。这就是RxJava配合Apollo Android使用的好处之一。<code class="fe lz ma mb mc b">DisposableObserver</code>有三种方法可以用来处理结果:<code class="fe lz ma mb mc b">onNext</code>、<code class="fe lz ma mb mc b">onError</code>和<code class="fe lz ma mb mc b">onComplete</code>。当收到有效响应时调用<code class="fe lz ma mb mc b">onNext</code>，如果出现错误则调用<code class="fe lz ma mb mc b">onError</code>。不管结果如何，一旦请求完成，就会调用<code class="fe lz ma mb mc b">onComplete</code>。这让我们可以分别定义加载、错误和数据状态，这大大简化了我们的代码。在这个代码片段中，我们将火箭附加到一个定制的适配器上(<a class="ae kc" href="https://github.com/Ninjaman494/Android-GraphQL-Example/blob/main/app/src/main/java/com/n494/spacex/RocketsAdapter.java" rel="noopener ugc nofollow" target="_blank">代码，这里是</a>)，然后隐藏装载指示器。请注意，加载部分是在<code class="fe lz ma mb mc b">onComplete</code>中处理的，因为即使发生错误，我们也想隐藏它。</p><h1 id="dcaf" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="e646" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在本文中，我们通过利用Apollo Android和RxJava库，介绍了在Android上使用GraphQL的正确方法。然而，我们所经历的例子是最简单的请求场景之一。对于更高级的场景，如并行和依赖请求，请查看本文的<a class="ae kc" href="https://github.com/Ninjaman494/Android-GraphQL-Example" rel="noopener ugc nofollow" target="_blank">配套报告</a>。你也可以阅读我的下一篇文章，在那里我们将仔细看看这个回购中的一些高级例子。</p><p id="03a7" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">一如既往，感谢阅读并给我一个👏如果你喜欢这篇文章！我很想听听你的意见，所以请在评论区留下你的反馈。</p></div></div>    
</body>
</html>