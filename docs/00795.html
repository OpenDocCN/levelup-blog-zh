<html>
<head>
<title>Build Your Own Video Chat with Vue, WebRTC, SocketIO, Node &amp; Redis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vue、WebRTC、SocketIO、Node &amp; Redis构建您自己的视频聊天</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-your-own-video-chat-with-vue-webrtc-socketio-node-redis-eb51b78f9f55?source=collection_archive---------0-----------------------#2019-08-01">https://levelup.gitconnected.com/build-your-own-video-chat-with-vue-webrtc-socketio-node-redis-eb51b78f9f55?source=collection_archive---------0-----------------------#2019-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1e0d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过水平缩放构建多房间视频聊天</h2></div><p id="4e9a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如今，市场上有很多免费的应用程序提供聊天和视频会议功能。几乎只需一次点击，我们就可以与世界上任何地方的任何人交流，但是，为什么我们不尝试构建自己的应用程序，让它变得更加真实呢？我们开始吧！</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/5a5ee337857c6d19d68991508f8bdee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJ6fiZSExCQ8-4Zj9PnJJQ.jpeg"/></div></div></figure><p id="1134" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的应用程序的主要特点将是:</p><ul class=""><li id="99ae" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lv lw lx ly bi translated">几个可用的房间和跳过它们的可能性</li><li id="414f" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">用户状态(在线/缺席/不可用)</li><li id="0971" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">能够与同一个房间中的任何人进行私聊(同一时间只能进行一次私聊),并获得该用户是已经在与其他人交谈还是已经结束聊天的通知</li><li id="df8b" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">能够在同一个私聊中开始视频会议</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi me"><img src="../Images/9d7d61b5e303421dc550a97cdf7c0247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*lZBDjDqA209gf9prgFnukw.gif"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">私人聊天和视频示例</figcaption></figure><p id="39a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了建造它，我们将使用以下技术:</p><ul class=""><li id="4ef9" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lv lw lx ly bi translated"><strong class="kk iu"> Vue.js </strong>作为前端框架。Vue最近越来越流行了，赶上它是个好机会。我们还将使用<strong class="kk iu"> Vuex </strong>来存储用户和聊天信息</li><li id="aaa9" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">后端将通过<strong class="kk iu"> Express </strong>在<strong class="kk iu"> NodeJS </strong>中实现</li><li id="4362" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu"> Socket.io </strong>和<strong class="kk iu"> WebRTC </strong>用于实时引擎和通信</li><li id="dbb6" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu"> Redis </strong>作为内存中的数据库</li><li id="effb" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu">Docker</strong>&amp;<strong class="kk iu">Docker Compose</strong></li></ul><p id="981f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谈到这种技术(特别是Sockets和WebRTC ),我们可以想走多远就走多远，在更复杂的方面深入探讨，但这不是目的。我们希望构建一些简单的东西来理解每个部分的基本要点，但完全可以工作，所以让我们开始吧。</p><p id="c79a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">一个新的抬头！我刚刚发布了一篇新文章，讨论如何实现多对多功能的视频会议。这是我们在这里解释和构建的一个扩展，所以在完成这篇文章后看看吧！</strong></p><div class="mj mk gp gr ml mm"><a href="https://medium.com/@adrigardi90/multiparty-video-conference-using-vue-webrtc-socketio-node-redis-e8c5a059d332" rel="noopener follow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">使用Vue、WebRTC、SocketIO、Node &amp; Redis的多方视频会议</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">第二部分:对等网格体系结构</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">medium.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na lo mm"/></div></div></a></div></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="c781" class="ni nj it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">应用程序框架</h1><p id="a5c0" class="pw-post-body-paragraph ki kj it kk b kl oa ju kn ko ob jx kq kr oc kt ku kv od kx ky kz oe lb lc ld im bi translated">首先，我们安装使用<code class="fe of og oh oi b"><a class="ae oj" href="https://cli.vuejs.org/" rel="noopener ugc nofollow" target="_blank">@vue/cli</a></code>轻松创建主骨架:</p><pre class="lf lg lh li gt ok oi ol om aw on bi"><span id="87a8" class="oo nj it oi b gy op oq l or os">npm install -g @vue/cli <br/>vue create video-chat</span></pre><p id="d907" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，系统会提示您选择一个预设。在我们的例子中，我们手动选择<em class="ot"> Babel </em>、<em class="ot"> Router </em>、<em class="ot"> Vuex </em>、<em class="ot"> CSS预处理器</em>和<em class="ot"> Linter </em>支架</p><p id="35a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了加速这个过程，我们将使用<code class="fe of og oh oi b"><a class="ae oj" href="https://vuematerial.io/getting-started" rel="noopener ugc nofollow" target="_blank">vue-materia</a>l</code>作为一个风格框架(尽管他们声称API不会改变，但它仍然是测试版)</p><pre class="lf lg lh li gt ok oi ol om aw on bi"><span id="46a0" class="oo nj it oi b gy op oq l or os">npm install vue-material --save</span></pre><p id="fe04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于HTTP和WebSocket通信，我们将使用<code class="fe of og oh oi b"><a class="ae oj" href="https://github.com/pagekit/vue-resource" rel="noopener ugc nofollow" target="_blank">vue-resource</a></code>和<code class="fe of og oh oi b"><a class="ae oj" href="https://github.com/MetinSeylan/Vue-Socket.io" rel="noopener ugc nofollow" target="_blank">vue-socket.io</a></code>作为Vue.js的定制实现</p><pre class="lf lg lh li gt ok oi ol om aw on bi"><span id="374c" class="oo nj it oi b gy op oq l or os">npm install vue-resource <!-- -->vue-socket.io <!-- -->--save</span></pre><p id="8a82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦全部安装完毕，我们可以在我们的<strong class="kk iu"> <em class="ot"> main.js </em> </strong>文件中配置它们:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div></figure><blockquote class="ow ox oy"><p id="d3a6" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated">通过vuex配置中的<strong class="kk iu"> actionPrefix </strong>和<strong class="kk iu"> mutationPrefix </strong> <em class="it">，我们可以分别触发服务器端vuex </em> <a class="ae oj" href="https://vuex.vuejs.org/guide/actions.html" rel="noopener ugc nofollow" target="_blank">动作</a> <em class="it">和</em> <a class="ae oj" href="https://vuex.vuejs.org/guide/mutations.html" rel="noopener ugc nofollow" target="_blank">突变</a> <em class="it">。在我们的例子中，我们不会使用它们，因为我们将在监听套接字服务器事件</em>后在客户机中分派动作</p></blockquote><p id="ef33" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于<em class="ot"> VueSocketIO </em>和<em class="ot"> Vue </em>实例所附带的商店，我们可以在<strong class="kk iu"> <em class="ot"> store.js </em> </strong>文件中对其进行如下配置:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="11fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当用户触发一个动作时，我们将把它分派给存储，生成一个突变执行，并以一个新的状态结束。</p><blockquote class="ow ox oy"><p id="6e3a" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated">通常，无论您选择哪种框架，状态管理模式都是非常相似的。在这种情况下，查看<a class="ae oj" href="https://vuex.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> Vuex </strong> </a>实现以了解更多细节</p></blockquote><p id="5caf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，套接字配置需要一个连接url，所以在继续登录页面之前，让我们构建服务器的主要基础</p><h1 id="6703" class="ni nj it bd nk nl pc nn no np pd nr ns jz pe ka nu kc pf kd nw kf pg kg ny nz bi translated">计算机网络服务器</h1><p id="a709" class="pw-post-body-paragraph ki kj it kk b kl oa ju kn ko ob jx kq kr oc kt ku kv od kx ky kz oe lb lc ld im bi translated">首先，我们需要安装所有的主要软件包来设置我们的服务器基础</p><pre class="lf lg lh li gt ok oi ol om aw on bi"><span id="22c3" class="oo nj it oi b gy op oq l or os">npm install express http body-parser path cors socket.io --save</span></pre><p id="7358" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其次，在项目根目录下的<code class="fe of og oh oi b">/server</code>文件夹中，我们创建了<strong class="kk iu"> <em class="ot"> index.js </em> </strong>和<strong class="kk iu"> <em class="ot"> app.js </em> </strong>文件作为我们的主服务器入口点:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">服务器index.js文件。我们服务器的入口点</figcaption></figure><blockquote class="ow ox oy"><p id="019f" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated"><em class="it">我们在</em> config.js <em class="it">文件中定义所有的服务器配置。这将有助于我们将来轻松配置应用程序的几个实例</em></p></blockquote><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="1337" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用之前的配置，我们主要实现了:</p><ul class=""><li id="4fdd" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lv lw lx ly bi translated">创建和配置http和express服务器</li><li id="1d7b" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">为登录和房间定义REST APIs(为了简单起见，这两个API都将信息存储在内存中)</li><li id="3492" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">创建静态服务器，为我们前端的所有静态文件提供服务</li><li id="7651" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">创建websocket名称空间并配置其服务器事件</li></ul><blockquote class="ph"><p id="a8d5" class="pi pj it bd pk pl pm pn po pp pq ld dk translated">但是，名称空间的确切含义是什么？那些服务器事件是什么？</p></blockquote><p id="7127" class="pw-post-body-paragraph ki kj it kk b kl pr ju kn ko ps jx kq kr pt kt ku kv pu kx ky kz pv lb lc ld im bi translated"><a class="ae oj" href="https://socket.io/docs/rooms-and-namespaces/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">名称空间</strong> </a> <strong class="kk iu"> </strong>本质上是我们的WS连接的端点或路径。默认情况下总是<code class="fe of og oh oi b">/</code>，它是socket.io客户端默认连接的对象。在我们的例子中，我们将它设置为<code class="fe of og oh oi b">/video-chat</code></p><blockquote class="ow ox oy"><p id="e1a4" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated">这就是套接字客户端连接到<code class="fe of og oh oi b">${url}/video-chat</code>的原因</p></blockquote><p id="bfb1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于事件，现在我们只定义了基本事件<em class="ot">加入房间。</em>在<code class="fe of og oh oi b">/chat_namespace</code>文件夹下，我们创建<strong class="kk iu"> <em class="ot"> index.js </em> </strong>文件:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">joinRoom服务器侦听器</figcaption></figure><p id="7c7b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在连接回调中，我们正在监听<code class="fe of og oh oi b">joinRoom</code>事件。一旦它被触发，我们加入房间，我们将用户添加到房间中，并通过<code class="fe of og oh oi b">newUser</code>事件发送回房间中的所有用户。因此，我们的前端将发出<strong class="kk iu"><em class="ot">join joum</em></strong>事件，它将侦听<strong class="kk iu"> <em class="ot"> newUser </em> </strong> one</p><blockquote class="ow ox oy"><p id="d89c" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated">您可以在socket . io<a class="ae oj" href="https://socket.io/docs/emit-cheatsheet/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">emit cheat sheet</strong></a>中查看所有可用的服务器事件</p></blockquote><p id="457b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此时，我们已经准备好开始构建我们的前端</p><h1 id="a7b8" class="ni nj it bd nk nl pc nn no np pd nr ns jz pe ka nu kc pf kd nw kf pg kg ny nz bi translated">前端</h1><p id="0592" class="pw-post-body-paragraph ki kj it kk b kl oa ju kn ko ob jx kq kr oc kt ku kv od kx ky kz oe lb lc ld im bi translated">我们将有两个主页:登录和主聊天页面。</p><p id="4e14" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不会使用任何认证机制，所以对于第一个，我们只需要用户和房间加入。用户将作为系统中的主键，因此用户名必须是唯一的。除了主房间，想法是<strong class="kk iu"> <em class="ot">使用用户名作为私人对话的房间值</em> </strong></p><blockquote class="ow ox oy"><p id="ed99" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated">如果我们想同时允许一个以上的私人聊天，我们可以用私人对话中涉及的两个用户名创建一个唯一的约束名</p></blockquote><p id="9b53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一个新的<code class="fe of og oh oi b">/views</code>文件夹中，我们创建文件<strong class="kk iu"> <em class="ot"> Home.vue </em> </strong>，如下所示:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="93de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们只需要获取房间并提交用户信息:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="3000" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae oj" href="https://vuejs.org/v2/guide/instance.html#Lifecycle-Diagram" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="ot">创建</em></strong></a><strong class="kk iu"><em class="ot">d</em></strong>生命周期方法中，我们获取房间并将其保存在我们的商店中。提交表单时也一样，一旦用户发送了正确的信息，我们就保存房间并导航到主聊天页面。</p><blockquote class="ow ox oy"><p id="f625" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated">我们改变状态，将事件和适当的有效负载一起发送到商店<code class="fe of og oh oi b">this.$store.dispatch(&lt;name&gt;, payload)</code></p></blockquote><p id="5f53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于主聊天页面，为了获得一些结构上的帮助，我们将主要使用<a class="ae oj" href="https://vuematerial.io/components/app" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="ot">素材app</em></strong></a><strong class="kk iu"><em class="ot"/></strong>组件，包含以下部分:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi pw"><img src="../Images/e127348507f85c4371a5dcfafeb143c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jIYMs456r9HC1x_Iu6SyQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">公共休息室</figcaption></figure><p id="37da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">-更换房间选择</p><p id="d8a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">-标题(房间名称和注销按钮)</p><p id="eec9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">-用户列表区(及其状态)</p><p id="91b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">-消息区</p><p id="e906" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">-发送消息的文本区域</p><p id="9609" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于私聊，我们将使用<a class="ae oj" href="https://vuematerial.io/components/dialog" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="ot">素材对话框</em> </strong> </a>组件。</p><blockquote class="ow ox oy"><p id="496b" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated">即使我们使用了material组件，我们仍然需要一些调整:)<br/>为此，我在除了两个父页面(登录和聊天)之外的所有子组件中使用了<a class="ae oj" href="https://vue-loader.vuejs.org/guide/scoped-css.html#mixing-local-and-global-styles" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">样式封装</strong> </a>。对于这些，我使用全局范围，因为他们的自力更生的性格和简单性，当覆盖一些材料的风格。你可以在这里查看Vue.js中作用域CSS的解释</p></blockquote><p id="837b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此时我们可以区分以下事件:</p><ul class=""><li id="19d8" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lv lw lx ly bi translated"><strong class="kk iu"> <em class="ot">加入房间</em> </strong>:加入一个主房间(如上所述)</li><li id="0044" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu"><em class="ot">public message</em></strong>:用户发送消息时。服务器向同一房间内的所有用户发回一个带有消息的<strong class="kk iu"> <em class="ot">新消息</em> </strong>事件</li><li id="6aae" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu"> <em class="ot">离开房间</em> </strong>:当用户改变房间时。服务器离开房间并发回该房间的新用户列表。之后，客户端将在<em class="ot"> joinRoom </em>事件之后加入新房间</li><li id="40a7" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu"> <em class="ot"> leaveChat </em> </strong>:用户注销时。服务器通过<strong class="kk iu"> <em class="ot"> leaveChat </em> </strong>事件发出新用户列表并离开套接字空间</li><li id="e810" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu"> <em class="ot"> changeStatus </em> </strong>:用户改变状态时。服务器对其进行更新，并使用与之前相同的<strong class="kk iu"> <em class="ot"> newUser </em> </strong>事件发回新值</li><li id="15df" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu"> <em class="ot"> joinPrivateRoom </em> </strong>:当用户(A)打开与别人(B)的私聊时。服务器加入房间，并发回一个<strong class="kk iu"> <em class="ot"> privateChat </em> </strong>事件来通知另一个用户(B)。如果最终用户(B)已经在讲话，服务器通知用户(A)并通过<strong class="kk iu"><em class="ot">leavePrivateRoom</em></strong>事件迫使他离开私人房间</li><li id="6ba1" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu"><em class="ot">leavePrivateRoom</em></strong>:用户关闭私聊时。服务器发出相同的事件来通知其他用户</li><li id="b58f" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu"><em class="ot">private message</em></strong>:用户发送私人消息时。服务器向双方用户发送回带有<strong class="kk iu"><em class="ot">private message</em></strong>事件的消息</li></ul><p id="b7e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在同一个<code class="fe of og oh oi b">/views</code>文件夹下，我们创建了<strong class="kk iu"> <em class="ot"> Chat.vue </em> </strong>文件<strong class="kk iu"> <em class="ot"> </em> </strong>，其中包含了我们主聊天页面的主要组件:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">主要聊天组件</figcaption></figure><p id="397c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们的父组件，它将负责监听服务器发出的所有套接字事件。为此，我们只需要在我们的Vue组件中创建一个<a class="ae oj" href="https://www.npmjs.com/package/vue-socket.io#-component-level-usage" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="ot">套接字对象</em> </strong> </a>，并为每个服务器事件创建一个<em class="ot">监听器方法:</em></p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">加入主房间。新消息发射器和监听器的示例</figcaption></figure><p id="bc7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在那个例子中，当用户发送一条公共消息时，我们发出<strong class="kk iu"><em class="ot">public message</em></strong>事件，我们监听<strong class="kk iu"> <em class="ot"> newMessage </em> </strong>服务器事件来获取消息。</p><blockquote class="ow ox oy"><p id="9bd9" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated">请记住，所有用户都将运行相同的客户端代码，因此我们需要构建一种通用方法来处理任何情况下的所有逻辑</p></blockquote><p id="e094" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">浏览每个组件的所有细节会花费很长时间，所以我们将解释主要的功能。它们基本上只是在套接字侦听器被触发后获取输入数据，并在用户操作下向父对象发出事件:</p><ul class=""><li id="33dd" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lv lw lx ly bi translated"><strong class="kk iu"> <em class="ot"> &lt;消息区&gt; </em> </strong>文本区发送消息。每当用户发送公共消息时，它向父节点发出一个事件，向服务器发出一个<strong class="kk iu"><em class="ot">public message</em></strong>套接字事件</li><li id="475d" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu"> <em class="ot"> &lt;聊天区&gt; </em> </strong>它显示一个房间内的所有公共消息，根据用户使用指令格式化消息:</li></ul><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">指令来显示公共消息</figcaption></figure><ul class=""><li id="b45d" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lv lw lx ly bi translated"><strong class="kk iu"><em class="ot">&lt;UserList&gt;</em></strong>显示当前用户状态和用户列表及其状态。当用户想要打开私聊时，它向父节点发出一个事件来打开私聊模式，并发出<strong class="kk iu"><em class="ot">joinPrivateRoom</em></strong>socket事件。当用户改变状态时，它更新状态并发出<strong class="kk iu"> <em class="ot"> changeStatus </em> </strong>套接字事件。</li><li id="7b05" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated"><strong class="kk iu"><em class="ot">&lt;chat dialog&gt;</em></strong>私聊。对于每个消息，它发出一个<strong class="kk iu"><em class="ot">private message</em></strong>套接字事件。当关闭对话时，它向发出<strong class="kk iu"><em class="ot">leavePrivateRoom</em></strong>套接字事件的父节点发出一个事件。它还包含了具有所有视频功能的<strong class="kk iu"><em class="ot">&lt;video area&gt;</em></strong>组件</li></ul><p id="df78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，是时候将新的监听器添加到我们之前的服务器文件<strong class="kk iu"> <em class="ot"> index.js </em> </strong>的<code class="fe of og oh oi b">/chat_namespace</code>文件夹中了:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">新事件监听器</figcaption></figure><p id="6113" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着我们获得更多的事件，我们对该文件做了轻微的修改，并在同一个<code class="fe of og oh oi b">/chat_namespace</code>文件夹下创建了一个新的<strong class="kk iu"> <em class="ot"> events.js </em> </strong>文件，其中包含所有的回调函数:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">所有监听器的回调函数实现</figcaption></figure><blockquote class="ph"><p id="cf8f" class="pi pj it bd pk pl pm pn po pp pq ld dk translated">等等，但是如果我们有多个实例运行我们的服务器，会发生什么呢？</p></blockquote><p id="90cb" class="pw-post-body-paragraph ki kj it kk b kl pr ju kn ko ps jx kq kr pt kt ku kv pu kx ky kz pv lb lc ld im bi translated">在整个过程中，我们把所有的信息都存储在内存中。这种方法适用于简单的情况，但是一旦我们需要扩展，它就不能正常工作了，因为每个服务器实例都有自己的用户副本。不仅如此，用户可能连接到不同的实例，因此没有办法与两个套接字连接进行通信。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi px"><img src="../Images/7ac615f19645885487d3406482b4797f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjIprYQ6b43mOxTvAQyAHw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">两个实例的水平缩放</figcaption></figure><h2 id="e076" class="oo nj it bd nk py pz dn no qa qb dp ns kr qc qd nu kv qe qf nw kz qg qh ny qi bi translated">添加Redis</h2><p id="de17" class="pw-post-body-paragraph ki kj it kk b kl oa ju kn ko ob jx kq kr oc kt ku kv od kx ky kz oe lb lc ld im bi translated">在我们的服务器上实现<a class="ae oj" href="https://github.com/socketio/socket.io-redis" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="ot"> Redis适配器</em> </strong> </a>解决了这个问题。</p><pre class="lf lg lh li gt ok oi ol om aw on bi"><span id="1c53" class="oo nj it oi b gy op oq l or os">npm install socket.io-redis redis --save</span></pre><p id="c4bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在服务器入口点<strong class="kk iu"> <em class="ot"> index.js </em> </strong>我们添加以下几行:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">为socket.io添加redis adator</figcaption></figure><p id="15b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们将使用<a class="ae oj" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"><em class="ot">Redis</em></strong></a>作为数据库来存储所有连接的用户。为此，我们在服务器的新<code class="fe of og oh oi b">/redis</code>文件夹中创建一个<strong class="kk iu"> <em class="ot"> index.js </em> </strong>文件:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">Redis作为一个数据库。哈希模式</figcaption></figure><blockquote class="ow ox oy"><p id="ce3a" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated">在我们的例子中，我们实现了<a class="ae oj" href="https://redis.io/commands/hset" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">散列</strong> </a>模式来存储数据，但是我们可以根据搜索需求使用更多的<a class="ae oj" href="https://redis.io/topics/data-types-intro" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">数据类型和抽象</strong> </a>。此外，还有一些node.js <br/> <a class="ae oj" href="https://redis.io/clients" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> redis客户端</strong> </a>通过一层抽象提供额外的功能</p></blockquote><p id="50de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，我们只需要更新内存中对用户的所有引用，并将其更改为使用我们的redis实现。</p><blockquote class="ph"><p id="9bb3" class="pi pj it bd pk pl qj qk ql qm qn ld dk translated">视频呢？你忘了吗？</p></blockquote><h1 id="b2b9" class="ni nj it bd nk nl pc nn no np pd nr ns jz qo ka nu kc qp kd nw kf qq kg ny nz bi translated">WebRTC</h1><p id="7342" class="pw-post-body-paragraph ki kj it kk b kl oa ju kn ko ob jx kq kr oc kt ku kv od kx ky kz oe lb lc ld im bi translated"><a class="ae oj" href="https://webrtc.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"><em class="ot">WebRTC</em></strong></a>是一个免费开放的项目，通过简单的API为web和移动应用程序提供实时通信(RTC)功能。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi qr"><img src="../Images/143e675cccdcbb9754ac6a2754734a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwq7jVwdhqv7sgArn7XuYQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">JSEP (Javascript会话建立协议)架构</figcaption></figure><p id="910e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">WebRTC支持点对点通信，尽管它仍然需要一个服务器来处理<em class="ot">信令</em>过程。<a class="ae oj" href="https://www.html5rocks.com/en/tutorials/webrtc/infrastructure/#what-is-signaling" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="ot">信令</em> </strong> </a>是协调两个客户端之间的通信以交换建立通信所需的某些元数据(会话控制和错误消息、媒体元数据等)的过程。然而，WebRTC并没有为此指定任何方法和协议，所以由应用程序来实现适当的机制。</p><p id="dd0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">在我们的例子中，我们将使用私人房间作为两个用户之间的信令机制</strong></p><blockquote class="ow ox oy"><p id="7133" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated">为了保护生产中的WebRTC应用，必须使用<a class="ae oj" href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> TLS </strong> </a> <strong class="kk iu">(传输层安全)</strong> <em class="it">作为信令机制</em></p></blockquote><p id="7d6e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们将在服务器配置中添加一个新的服务器监听器:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="8700" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在A(呼叫者)和B(被呼叫者)之间建立通信的机制如下:</p><ol class=""><li id="c9ca" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld qs lw lx ly bi translated"><strong class="kk iu">一个</strong>用<strong class="kk iu"> <em class="ot"> ICE服务器</em> </strong>配置创建一个<strong class="kk iu"><em class="ot">RTCPeerConnection</em></strong>对象</li><li id="80f7" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld qs lw lx ly bi translated"><strong class="kk iu"> A </strong>使用RTCPeerConnection<strong class="kk iu"><em class="ot">create offer</em></strong>方法创建报价(SDP会话描述)</li><li id="1a99" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld qs lw lx ly bi translated"><strong class="kk iu">一个</strong>调用<strong class="kk iu"> <em class="ot"> setLocalDescription(提供)</em> </strong> <em class="ot"> </em>方法<em class="ot"> </em>同提供</li><li id="0101" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld qs lw lx ly bi translated"><strong class="kk iu"> A </strong>使用信令机制(<strong class="kk iu"><em class="ot">privateMessagePCSignaling</em></strong>)向<strong class="kk iu"> B </strong>发送要约</li></ol></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><ol class=""><li id="0471" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld qs lw lx ly bi translated"><strong class="kk iu"> B </strong>得到报价，用<strong class="kk iu"> A的报价</strong>调用<strong class="kk iu"><em class="ot">setRemoteDescription()</em></strong>(所以B RTCPeerConnection知道A的设置)</li><li id="db67" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld qs lw lx ly bi translated"><strong class="kk iu"> B </strong>用RTCPeerConnection<strong class="kk iu"><em class="ot">create answer</em></strong>方法创建答案</li><li id="14b3" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld qs lw lx ly bi translated"><strong class="kk iu"> B </strong>调用<strong class="kk iu"> <em class="ot"> setLocalDescription(答案)</em> </strong> <em class="ot"> </em>方法<em class="ot"> </em>同答案</li><li id="d2e6" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld qs lw lx ly bi translated"><strong class="kk iu"> B </strong>使用信令机制(<strong class="kk iu"><em class="ot">privateMessagePCSignaling</em></strong>)将答案发回给<strong class="kk iu"> A </strong></li><li id="3b76" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld qs lw lx ly bi translated"><strong class="kk iu"> A </strong>使用<strong class="kk iu"><em class="ot">setRemoteDescription()</em></strong>方法将<strong class="kk iu"> B的答案</strong>设置为远程会话描述</li></ol><p id="d1f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了该过程之外，两个用户都必须设置以下内容:</p><ul class=""><li id="fdf5" class="lq lr it kk b kl km ko kp kr ls kv lt kz lu ld lv lw lx ly bi translated">访问摄像机，获取流并将其附加到本地视频标签</li><li id="e84b" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">在添加流 监听器上设置RTCPeerConnection <strong class="kk iu"> <em class="ot">以获取远程轨道媒体<em class="ot"> </em>并将其附加到远程视频标签</em></strong></li><li id="2eb2" class="lq lr it kk b kl lz ko ma kr mb kv mc kz md ld lv lw lx ly bi translated">设置rtcpeer connection<strong class="kk iu"><em class="ot">onicecandidate</em></strong>监听器将任何ice候选发送给其他对等</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi qt"><img src="../Images/61f8a80e3b9296e192bcff62a21cdb88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DtJY0aXmUREIqoFLUDmvTg.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">真实世界点对点连接。冰框架。眩晕&amp;转身服务器</figcaption></figure><p id="f1b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">会话建立后，WebRTC会尝试直接连接客户端(点对点，无需任何服务器)进行媒体和数据流传输。然而，在现实世界中，大多数设备都位于一层或多层<a class="ae oj" href="https://www.iplocation.net/nat" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu"><em class="ot">NAT</em></strong></a>之后，因此WebRTC使用<a class="ae oj" href="https://www.avaya.com/blogs/archives/2014/08/understanding-webrtc-media-connections-ice-stun-and-turn.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="ot"> ICE框架</em> </strong> </a>来克服这些复杂性</p><blockquote class="ow ox oy"><p id="e298" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated">这就是我们在创建RTCPeerConnection对象时需要ICE服务器配置的原因。您可以在此 测试任何STUN/TURN服务器的连接性，以检查它们是否处于活动状态并正确响应连接</p></blockquote><p id="3d3a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">组件<strong class="kk iu"> <em class="ot">将包含所有的逻辑:</em></strong></p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">视频聊天组件。简单的呼叫者/被呼叫者机制</figcaption></figure><p id="3a20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">调用者使用<strong class="kk iu"><em class="ot">privateMessagePCSignaling</em></strong>套接字事件将本地描述和要约一起发送给其他用户，因此我们需要在我们的客户端中有一个<strong class="kk iu"> <em class="ot">套接字监听器</em> </strong>来处理被调用者端的消息(当被调用者将答案发送回调用者时，情况正好相反)</p><p id="83b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面提到的<strong class="kk iu"> <em class="ot"> ChatDialog </em> </strong>组件负责私人聊天，所以我们将在那里添加逻辑来监听我们的信令机制并控制我们传递给<strong class="kk iu"> <em class="ot"> VideoArea </em> </strong>组件的数据:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">ChatDialog组件。信令机制监听器</figcaption></figure><p id="6df2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基于消息信息，我们检测它是否是一个来电、一个呼叫的应答或者仅仅是一个要添加到对等对象的新候选，在每种情况下相应地采取行动。</p><blockquote class="ph"><p id="2832" class="pi pj it bd pk pl qj qk ql qm qn ld dk translated">至此，我们已经准备好测试我们的视频聊天了！</p></blockquote><p id="efd8" class="pw-post-body-paragraph ki kj it kk b kl pr ju kn ko ps jx kq kr pt kt ku kv pu kx ky kz pv lb lc ld im bi translated">我们将创建3个容器:2个视频聊天实例和一个Redis实例:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi qu"><img src="../Images/acc3d22783291fda8119154431350f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqun6bLBsO2ThLucb87WTw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">本地容器测试</figcaption></figure><p id="e1f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们将在项目的根目录下创建一个<strong class="kk iu"><em class="ot">docker-compose . yml</em></strong>文件，配置如下:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">docker-撰写配置</figcaption></figure><p id="4ef4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ot"> </em> <strong class="kk iu">上下文</strong> <em class="ot"> </em>属性定义了<em class="ot"/><a class="ae oj" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">docker file</strong></a><em class="ot"/>目录。在这里，我们描述了在每种情况下编译我们的客户机并使用适当的配置运行服务器的步骤。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">Dockerfile文件配置</figcaption></figure><p id="b1cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们只需要构建并运行包含<code class="fe of og oh oi b">docker-compose build</code>和<code class="fe of og oh oi b">docker-compose up</code>的容器，并在浏览器中打开两个视频聊天副本:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi qv"><img src="../Images/59ace922b61ac7a14be01b5de347adc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNMGarTk-7T6XEL9th75eg.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">本地测试日志</figcaption></figure><blockquote class="ow ox oy"><p id="d2fb" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated">我们观察每个应用程序如何创建与其服务器的web套接字连接，因此Redis将是两个连接通信的唯一方式。</p></blockquote><blockquote class="ph"><p id="6e55" class="pi pj it bd pk pl pm pn po pp pq ld dk translated">如果你到了这里…我们终于做到了！:)</p></blockquote><figure class="qx qy qz ra rb lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi qw"><img src="../Images/5e377597df7272ca2b3af9004022e800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjrVm6meUmqnjKqhB99fLg.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">连接到不同视频聊天实例的本地测试</figcaption></figure><p id="1689" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们完了！我们已经看到了如何不用太多代码就能建立一个简单的视频聊天。这是一个非常简单的例子，涵盖了基本要点，我们可以从几个方面进行改进:添加登录和websocket身份验证，处理重新连接，增强WebRTC功能，改进摄像头和声音处理，允许多个私人聊天，有机会接受或拒绝私人视频通话等等。</p><p id="a54c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在下面的<a class="ae oj" href="https://github.com/adrigardi90/video-chat/tree/video-one-to-one" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">回购</strong> </a>中查看所有代码</p><p id="34b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你也可以在下面的<a class="ae oj" href="https://vue-video-chat.surge.sh/#/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">网址</strong> </a>中找到一个简单的版本</p><p id="8678" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我已经用<a class="ae oj" href="https://surge.sh/" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">surge</strong></a><strong class="kk iu"><em class="ot"/></strong>部署了前端，并在AWS的一个微EC2实例中部署了服务器端，所以尽量不要让它过载太多:)</p><blockquote class="ow ox oy"><p id="96f1" class="ki kj ot kk b kl km ju kn ko kp jx kq oz ks kt ku pa kw kx ky pb la lb lc ld im bi translated">根据位置，WebRTC媒体有时会由于ICE服务器配置而失败(或者您可能需要多次尝试视频呼叫),因此需要更新和改进其他内容</p></blockquote><p id="c97c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你已经发现它有趣。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><div class="lf lg lh li gt mm"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">编写面试问题</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">技术开发</p></div></div><div class="mv l"><div class="rc l mx my mz mv na lo mm"/></div></div></a></div><div class="mj mk gp gr ml mm"><a href="https://gitconnected.com/learn/vue-js" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">学习Vue.js -最佳Vue.js教程(2019) | gitconnected</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">Vue是开发人员用来构建用户界面(UI)的JavaScript库，旨在简化前端工程…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">gitconnected.com</p></div></div><div class="mv l"><div class="rd l mx my mz mv na lo mm"/></div></div></a></div></div></div>    
</body>
</html>