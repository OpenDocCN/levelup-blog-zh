<html>
<head>
<title>The Magician’s Guide to Algorithms, part 6: The Depth First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">魔术师算法指南，第6部分:深度优先搜索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-magicians-guide-to-algorithms-part-5-the-depth-first-search-2223203174bb?source=collection_archive---------0-----------------------#2017-11-19">https://levelup.gitconnected.com/the-magicians-guide-to-algorithms-part-5-the-depth-first-search-2223203174bb?source=collection_archive---------0-----------------------#2017-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/65857213ab389dbbffd62113a4db59b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*bq3m2tZADiZNwWUL8BszdQ.gif"/></div></figure><p id="2262" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以上周你向麦格教授展示了你的<a class="ae ks" href="https://medium.com/gitconnected/the-magicians-guide-to-algorithms-part-4-the-breadth-first-search-b800aec8ccf8" rel="noopener">广度优先搜索</a> (BFS)法术。她说这很好，但想给你看另一种方法来做同样的事情。这叫做深度优先搜索(DFS)。</p><p id="f8d8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">深度优先搜索</strong></p><p id="b6f1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">咒语是这样的:</p><figure class="kt ku kv kw gt jr"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="f471" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于此问题，您将使用上周文章中的同一数组:</p><pre class="kt ku kv kw gt kz la lb lc aw ld bi"><span id="2472" class="le lf iq la b gy lg lh l li lj">var tree = [<br/>    {value: 6, left: 1, right: 2},<br/>    {value: 5, left: 3, right: 4},<br/>    {value: 7, left: null, right: 5},<br/>    {value: 3, left: 6, right: null},<br/>    {value: 4, left: null, right: null},<br/>    {value: 9, left: 7, right: 8},<br/>    {value: 2, left: 9, right: null},<br/>    {value: 8, left: null, right: null},<br/>    {value: 10, left: null, right: null},<br/>    {value: 1, left: null, right: null}<br/>    ]</span></pre><p id="9fda" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当用图表表示时，它看起来像这样:</p><pre class="kt ku kv kw gt kz la lb lc aw ld bi"><span id="aea6" class="le lf iq la b gy lg lh l li lj">                                   6<br/>                                  / \<br/>                                 5   7<br/>                                / \   \<br/>                               3   4   9<br/>                              /       / \<br/>                             2       8   10<br/>                            /<br/>                           1</span></pre><p id="d10f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你仔细看上面的咒语，它和BFS版本是一样的，只有一个小的不同。您可以使用堆栈，而不是使用队列来存储您想要浏览的节点。</p><p id="69d9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">BFS vs DFS</strong></p><p id="21e8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">解释本周的咒语只是简单地重复上周的相同帖子，所以我们将通过比较两者并涵盖它们的用法来改变事情。</p><p id="1294" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从它们的名字就可以猜到，BFS算法从浅层开始，逐行深入。另一方面，DFS可以快速地深入到你正在搜索的结构中，快速到达底部，然后返回到顶部。</p><p id="eea2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么你应该什么时候使用这些呢？如果解决方案离树的根不远，那么使用BFS是显而易见的，因为它首先快速搜索数据结构的顶部。但是，如果您的解决方案能够深入到数据结构内部，DFS算法将会快速地向下搜索它。此外，在宽树的情况下，DFS搜索更有效，而窄树容易被BFS搜索遍历。</p><p id="6e98" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">同样值得注意的是:就我所发现的，在移动到右边之前，先穿过树的左边似乎是一种惯例。这涵盖了该算法的第二个细微变化。</p><p id="6efe" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">结论</strong></p><p id="737d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就结束了这一点神奇。我还不确定下周我会讲什么，但我有一种感觉，它可能与斐波那契数列有关。我们会看到的。干杯！</p></div></div>    
</body>
</html>