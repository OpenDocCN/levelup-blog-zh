<html>
<head>
<title>In-depth implementation of Azure Service Bus with C# and .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C#和深入实现Azure服务总线。网</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/in-depth-implementation-of-azure-service-bus-with-c-and-net-9f52948ec1d7?source=collection_archive---------5-----------------------#2022-01-24">https://levelup.gitconnected.com/in-depth-implementation-of-azure-service-bus-with-c-and-net-9f52948ec1d7?source=collection_archive---------5-----------------------#2022-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="315e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何设置服务并处理主题和订阅</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/92de95a179d05837e928d060bdb230ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4YEULtxwPn1gpiUzo5xBQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">麦克斯韦·尼尔森在T2的照片</figcaption></figure><p id="32b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是Azure Service Bus的新手，或者你不知道它到底是如何工作的，我建议你阅读<a class="ae ky" href="https://blog.devgenius.io/message-broker-architecture-what-is-it-and-how-does-it-work-60a62f8ce784" rel="noopener ugc nofollow" target="_blank">我关于这个主题的文章</a>，这样你就可以更好地理解整个架构以及队列、主题和订阅是如何工作的。这将有希望使这里讨论的事情更清楚。好了，现在，让我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="7275" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">主题和订阅</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/52b78b736ced494f9e659b35a3e17bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tD-MsFv0Bj1L9A70oN5orQ.png"/></div></div></figure><p id="eae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们将使用上图所示的场景。首先，订单正在创建，如果订单确实成功创建，我们将发送消息向客户发送确认电子邮件，并更新产品库存水平。</p><p id="fb34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主题和订阅背后的基本思想是你有一个主题和几个听众(订阅者)。因此，我们需要创建一个<em class="mw">订单服务</em>，我们将使用<em class="mw"> </em>将消息添加到服务总线中，还需要创建一个<em class="mw">订单电子邮件消费者服务和订单股票消费者服务</em>，它将监听任何消息并相应地采取行动。</p><p id="3140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在我们开始编写代码之前，我想澄清一下,<em class="mw">主题</em>和<em class="mw">订阅</em>的创建将通过编程完成，因为如果团队中有人删除了主题或订阅，在Azure Portal中直接创建它们可能会导致问题，这将导致代码中出现错误，因为您试图连接到不存在的<em class="mw">主题/订阅。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="4c79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">创建主题</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a53c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将是我们的OrderService，并将使用AddMessage将消息发送到服务总线，其中<em class="mw">电子邮件消费者</em>和<em class="mw">股票更新消费者</em>监听任何传入的消息。</p><p id="9a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构造函数所做的是获取<em class="mw">服务总线连接字符串</em>，然后如果主题还没有创建，就用它来创建一个新主题。</p><p id="0bfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道enum是什么，它将包含我们拥有的所有不同类型的消息-目前是电子邮件和股票。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">添加用户</strong></p><p id="ee86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，我们需要创建两个<em class="mw">消费者服务</em>，但是为了保持简洁，并且第二个服务几乎完全相同，我将只放其中一个，希望这一切都有意义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="cbad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">势不可挡，对吧？当你开始阅读代码时，它并不那么糟糕。现在，您可能会发现，我们也在对该主题进行检查，看它是否存在。这是因为如果你运行多个微服务，可能会有一个比另一个快，如果我们的<em class="mw">电子邮件服务</em>在这种情况下更快，它会在尝试连接到尚未创建的主题时抛出错误，因此检查该主题并继续订阅它是一个好习惯。</p><p id="7682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里另一个奇怪的部分是我们可以看到设置的过滤器和规则。如果我们回到前面的代码示例，我们将消息添加到<em class="mw">服务总线</em>中，我们可以看到我们正在将类型添加到消息的<em class="mw">用户属性</em>中。我们在这里做的是在订阅上设置一个过滤器，只接受我们想要的特定类型的消息，在我们的例子中，是<em class="mw"> Email </em>。</p><p id="0f94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以省去过滤器，接收所有消息，然后在<em class="mw"> ProcessMessagesAsync </em>中进行检查，查看类型是否为<em class="mw"> Email，</em>但这并不高效，因为如果流量很大，您会强制服务对数百或数千条消息进行检查。因此，最好的方法是添加一个过滤器来阻止任何不属于服务本身的消息进入。</p><p id="f0cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<em class="mw"> ProcessMessagesAsync </em>方法会将消息反序列化为我们想要的对象，然后将该消息传递给<em class="mw"> EmailDomain </em>，在这里我们可以实现我们想要的逻辑。</p><p id="303c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有效载荷看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b16f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们要做的是<em class="mw"> StockUpdate服务</em>,那么有效负载应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f53d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里您将传递订单上的<em class="mw">产品Id </em>和<em class="mw">数量</em>，以便您可以相应地进行调整。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="f3d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">队列</strong></p><p id="af5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是专门针对主题和订阅的，但是我只想提一下这两者和队列之间的区别，如果有兴趣的话，我可以写另一篇文章更侧重于队列和预定队列。</p><p id="f045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这个主题支持多个接收者(订阅者),但是队列只限于一个。此外，如果你只使用Azure服务总线的基本层，你将只有队列，而你需要为主题付费。</p><p id="9ca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是撇开价格不谈，如果您有对时间敏感的大量数据，您可能会更喜欢主题，因为扩展能力很强，而队列的可伸缩性有限。</p><p id="7b49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，对于低容量和非时间关键的消息，并且可以在队列中停留更长时间而不会成为问题，您可以很好地使用队列。</p></div></div>    
</body>
</html>