<html>
<head>
<title>Why Does My Colleague Use Thread.sleep(0) in their Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我的同事在他们的代码中使用Thread.sleep(0)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-does-my-colleague-use-thread-sleep-0-in-the-code-a3fd12dc98b7?source=collection_archive---------0-----------------------#2022-12-24">https://levelup.gitconnected.com/why-does-my-colleague-use-thread-sleep-0-in-the-code-a3fd12dc98b7?source=collection_archive---------0-----------------------#2022-12-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="171d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">看似无用的代码其实很有用。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/93d74d9ceaba1079a2ee09732341e04e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMFYlDy5C2eWaYQv8z71vw.jpeg"/></div></div></figure><p id="8a16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最近看到一个同事的一段代码，很迷茫。他在代码中使用了线程睡眠方法<code class="fe la lb lc ld b">Thread.sleep(long millis)</code>,但是将线程睡眠时间设置为0秒。这是代码。</p><pre class="kp kq kr ks gt le ld lf bn lg lh bi"><span id="f631" class="li lj it ld b be lk ll l lm ln"> int i = 0;<br/>        while (i&lt;10000000) {<br/>            // business logic<br/><br/>            //prevent long gc<br/>            if (i % 3000 == 0) {<br/>                try {<br/>                    Thread.sleep(0);<br/>                } catch (InterruptedException e) {<br/>                    e.printStackTrace();<br/>                }<br/>            }<br/>        }</span></pre><p id="50d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">睡觉0秒，不就是不睡觉吗？我第一反应是这个代码没用，但是看到他的评论引起了我的兴趣。让我感觉这段代码是作者专门为了优化而写的。为了了解原因，我又查了一遍Java文档。</p><blockquote class="lo lp lq"><p id="b73a" class="jq jr lr js b jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km kn im bi translated">使当前正在执行的线程休眠(暂时停止<br/>执行)指定的毫秒数，取决于<br/>系统定时器和调度程序的精度和准确度。线程<br/>不会失去任何监视器的所有权。</p></blockquote><p id="3300" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，很明显，文档的描述无法回答我的问题，所以我向作者寻求帮助。然后作者告诉我用<code class="fe la lb lc ld b">Thread.sleep(0)</code>可以暂时释放CPU时间轴，然后我恍然大悟。这是一段非常有用的代码。</p><h2 id="114c" class="lv lj it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">时间片循环调度算法</h2><p id="4c82" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">在操作系统中，CPU有很多竞争策略。Unix系统使用时间片循环调度算法。在该算法中，所有进程被分组到一个队列中。操作系统按顺序给每个进程分配一定的时间，即允许进程运行的时间。如果该进程在该时间片结束时仍在运行，CPU将被剥夺并分配给另一个进程，如果该进程在该时间片内阻塞或结束，CPU将立即切换。调度员所要做的就是维护一个就绪进程表。当进程用完时间片时，它将被移动到队列的末尾。</p><p id="a127" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码中有一个死循环。作者希望一直用一个线程来处理业务逻辑。如果不使用<code class="fe la lb lc ld b">Thread.sleep(0)</code>主动放弃CPU时间片，线程资源就会一直被占用。众所周知，GC线程的优先级较低，因此使用<code class="fe la lb lc ld b">Thread.sleep(0)</code>来帮助GC线程尝试竞争CPU时间片。但是为什么作者说长GC是可以预防的呢？这是关于JVM的垃圾收集原理。</p><h2 id="a7b8" class="lv lj it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">安全点</h2><p id="e9f0" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated">以HotSpot虚拟机为例，JVM不会在代码指令流中的任何位置暂停来启动垃圾收集，而是强制执行必须到达一个安全点才能暂停。换句话说，在达到安全点之前，JVM不会停止GC。</p><p id="f565" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JVM将在一些循环跳转和方法调用上设置安全点。但为了避免过多safepoints带来的沉重负担，HotSpot虚拟机也有针对循环的优化措施。如果循环次数少，执行时间不宜过长。因此，默认情况下，使用int或更小数据类型作为索引值的循环不会与safepoint放在一起。这种循环称为可数循环。相应地，使用long或更大范围的数据类型作为索引值的循环被称为未计数循环，并将被放置在安全点。</p><p id="5aef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，我们碰巧在这里有一个可数循环，所以我们的代码不会放在安全点。因此，GC线程必须等到线程完成执行，并且可以执行到最近的安全点。但是如果使用<code class="fe la lb lc ld b">Thread.sleep(0)</code>，可以在代码中放置一个安全点。我在热点的<code class="fe la lb lc ld b">safepoint.cpp</code>里发现了以下评论。</p><pre class="kp kq kr ks gt le ld lf bn lg lh bi"><span id="d633" class="li lj it ld b be lk ll l lm ln">// Begin the process of bringing the system to a safepoint.<br/>  // Java threads can be in several different states and are<br/>  // stopped by different mechanisms:<br/>  //<br/>  //  1. Running interpreted<br/>  //     The interpeter dispatch table is changed to force it to<br/>  //     check for a safepoint condition between bytecodes.<br/>  //  2. Running in native code<br/>  //     When returning from the native code, a Java thread must check<br/>  //     the safepoint _state to see if we must block.  If the<br/>  //     VM thread sees a Java thread in native, it does<br/>  //     not wait for this thread to block.  The order of the memory<br/>  //     writes and reads of both the safepoint state and the Java<br/>  //     threads state is critical.  In order to guarantee that the<br/>  //     memory writes are serialized with respect to each other,<br/>  //     the VM thread issues a memory barrier instruction<br/>  //     (on MP systems).  In order to avoid the overhead of issuing<br/>  //     a memory barrier for each Java thread making native calls, each Java<br/>  //     thread performs a write to a single memory page after changing<br/>  //     the thread state.  The VM thread performs a sequence of<br/>  //     mprotect OS calls which forces all previous writes from all<br/>  //     Java threads to be serialized.  This is done in the<br/>  //     os::serialize_thread_states() call.  This has proven to be<br/>  //     much more efficient than executing a membar instruction<br/>  //     on every call to native code.<br/>  //  3. Running compiled Code<br/>  //     Compiled code reads a global (Safepoint Polling) page that<br/>  //     is set to fault if we are trying to get to a safepoint.<br/>  //  4. Blocked<br/>  //     A thread which is blocked will not be allowed to return from the<br/>  //     block condition until the safepoint operation is complete.<br/>  //  5. In VM or Transitioning between states<br/>  //     If a Java thread is currently running in the VM or transitioning<br/>  //     between states, the safepointing code will wait for the thread to<br/>  //     block itself when it attempts transitions to a new state.</span></pre><p id="8d25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而<code class="fe la lb lc ld b">Thread.sleep(long millis)</code>是一个本土的方法。</p><h2 id="4e60" class="lv lj it bd lw lx ly dn lz ma mb dp mc kb md me mf kf mg mh mi kj mj mk ml mm bi translated">最后</h2><p id="5c0d" class="pw-post-body-paragraph jq jr it js b jt mn jv jw jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn im bi translated"><code class="fe la lb lc ld b">Thread.sleep(0)</code>不是无用的代码。sleep方法可用于在java代码中放置一个安全点。它可以提前触发长循环中的GC，防止GC线程长时间等待，从而避免延长GC时间的目标。写这个代码的人太强了。真的很牛逼。</p><div class="ms mt gp gr mu mv"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-draw-a-technical-architecture-diagram-2d2c3b4a1d07"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">如何绘制技术架构图</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">什么是架构图？为什么要画架构图？怎样才能画出一个简单易懂的…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ky mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a rel="noopener  ugc nofollow" target="_blank" href="/seven-intellij-debug-tricks-that-every-java-developer-must-know-de26aaac736a"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">每个Java开发人员都必须知道的七个Intellij调试技巧</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">你知道这些把戏吗？这些一定会提高你的开发效率。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj ky mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a href="https://medium.com/javarevisited/five-api-performance-optimization-tricks-that-every-java-developer-must-know-75324ee1d244" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">每个Java开发人员都必须知道的五个API性能优化技巧</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">为什么你的API响应这么慢？也许你需要解决这些问题。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">medium.com</p></div></div><div class="ne l"><div class="nl l ng nh ni ne nj ky mv"/></div></div></a></div></div></div>    
</body>
</html>