<html>
<head>
<title>One-To-Many Relationships with Fluent NHibernate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">流畅的一对多关系</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/one-to-many-relationships-with-fluent-nhibernate-a26dcad42427?source=collection_archive---------2-----------------------#2021-01-06">https://levelup.gitconnected.com/one-to-many-relationships-with-fluent-nhibernate-a26dcad42427?source=collection_archive---------2-----------------------#2021-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d195" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何处理亲子关系？NET与Fluent Migrator的Fluent接口</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/329506cd8f317ea64cc3937563547d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*qnPSV-0RCmEijjaqo6BBiA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">待办事项列表可以有许多待办事项列表项</figcaption></figure><p id="531d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中:</p><ul class=""><li id="3b6f" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">添加测试</li><li id="b86c" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">扩展领域模型</li><li id="2cf7" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">更新对象关系映射代码</li><li id="b11d" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">解决常见的NHibernate和数据库异常</li><li id="cb53" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">惰性装载</li><li id="7f77" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">通过使用约定简化映射代码</li></ul><h1 id="24eb" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">介绍</h1><h2 id="b17c" class="mw mf it bd mg mx my dn mk mz na dp mo ld nb nc mq lh nd ne ms ll nf ng mu nh bi translated">概述</h2><p id="7fb8" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">在之前的文章中，我们介绍了作为对象关系映射器(ORM) 的<a class="ae nn" href="https://medium.com/nerd-for-tech/easy-database-access-with-nhibernate-in-net-5-0-3cc7e36510c9?sk=d83d22c7197e509193c59eafc848e18c" rel="noopener"> NHibernate来访问关系数据库中的数据。然后我们</a><a class="ae nn" href="https://medium.com/swlh/database-transactions-with-nhibernate-in-net-5-0-caab8c82d62a?sk=cac595c539cff46f7e883385febb6602" rel="noopener">添加了事务</a>来保持数据的一致性。这在本文中将变得更加重要，因为我们将使用一对多关系来扩展我们的领域模型。</p><h2 id="bf3f" class="mw mf it bd mg mx my dn mk mz na dp mo ld nb nc mq lh nd ne ms ll nf ng mu nh bi translated">运行示例</h2><p id="28e9" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">在本文中，我们将再次使用一个名为“Mahi”的虚构产品作为运行示例。Mahi一词在Te Reo毛利语中的意思是“任务”,这是奥特罗亚(也称为新西兰)土著人所说的语言。</p><p id="782b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Mahi是一个非常简单的任务管理器。请记住，代码库并不是用于生产的。目的是阐明有用的软件工程概念。</p><h2 id="d072" class="mw mf it bd mg mx my dn mk mz na dp mo ld nb nc mq lh nd ne ms ll nf ng mu nh bi translated">先决条件</h2><ul class=""><li id="4746" class="lq lr it kw b kx ni la nj ld no lh np ll nq lp lv lw lx ly bi translated">VS代码</li><li id="bbec" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">VS代码扩展包“远程开发”</li><li id="01ec" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">您平台的Git客户端</li><li id="daee" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">适用于您平台的Docker，例如适用于Windows或MacOS的Docker Desktop，或适用于Linux的Docker engine</li></ul><p id="21e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">使用WSL1或WSL2的Windows用户注意:</strong>请确保您熟悉文章<a class="ae nn" rel="noopener ugc nofollow" target="_blank" href="/docker-desktop-on-wsl2-the-problem-with-mixing-file-systems-a8b5dcd79b22?sk=53d24e33a9f247fd626e3aa6959de7d4">“wsl 2上的Docker桌面:混合文件系统的问题”</a>的内容。</p><h2 id="d7fb" class="mw mf it bd mg mx my dn mk mz na dp mo ld nb nc mq lh nd ne ms ll nf ng mu nh bi translated">源代码</h2><p id="bb8b" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">本文的完整源代码可在https://github.com/mahi-app/CmdLine<a class="ae nn" href="https://github.com/mahi-app/CmdLine" rel="noopener ugc nofollow" target="_blank">获得。该条的起始位置为</a><a class="ae nn" href="https://github.com/mahi-app/CmdLine/tree/article-2021-01-02" rel="noopener ugc nofollow" target="_blank">分支“article-2021–01–02”</a>。截至本文结尾的代码库在<a class="ae nn" href="https://github.com/mahi-app/CmdLine/tree/article-2021-01-06" rel="noopener ugc nofollow" target="_blank">分支“文章-2021–01–06”</a></p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="66a8" class="me mf it bd mg mh ny mj mk ml nz mn mo jz oa ka mq kc ob kd ms kf oc kg mu mv bi translated">写作测试</h1><p id="da5b" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">到目前为止，我们已经实现了保存和检索“ToDoList”对象的代码。此时，该类的代码非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="57ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一步，我们通过引入一个新的类“TodoListItem”来扩展它。每个列表可以有任意数量的项目，也可以没有项目。这是我们想要实现的目标的类图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/329506cd8f317ea64cc3937563547d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*qnPSV-0RCmEijjaqo6BBiA.png"/></div></figure><p id="5626" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如上一篇文章中的<a class="ae nn" href="https://medium.com/nerd-for-tech/easy-database-access-with-nhibernate-in-net-5-0-3cc7e36510c9?sk=d83d22c7197e509193c59eafc848e18c" rel="noopener">，我们从一个测试开始。理想情况下，我们希望向列表中添加一个项目并存储它。然后，当我们读取列表时，我们的代码也应该从数据库中读取该列表的项目。</a></p><p id="eae4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在“TodoListRepositoryTest”类中，我们添加了以下测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="8cf6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了进行编译，我们还需要一个新类“TodoListItem ”,如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="4bf2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们向类“TodoList”添加一个新属性“Items”:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="388c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些代码更改可以编译。然而，当我们执行时</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="7298" class="mw mf it og b gy ok ol l om on">dotnet test</span></pre><p id="6ad0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将观察到如下错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><div class="gh gi oo"><img src="../Images/2210e9e897a646f8f39fd45cf82062f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DIQt40Nc116VvwEhiDZr_g.png"/></div></div></figure><p id="cba0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">原因是当我们读取TodoList对象时，属性“Items”将被初始化为null。这很容易解决。我们只是通过给属性赋一个初始值来修改TodoList类(见第10行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="77ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们再次执行测试时，他们无法断言我们刚刚从数据库中读取的列表包含一个项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/d2e8c7fddfccb3a628e20b82d6c1c301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*M0Pb1US28cD_B1ivvgwlEg.png"/></div></figure><p id="b66c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">断言失败，因为项数为零而不是一。这并不奇怪，因为我们还没有给NHibernate提供如何在类TodoListItem和数据库之间映射的指令。</p><p id="5105" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此时，我们添加了一个失败的测试。换句话说，我们从“绿色”(所有测试都通过)到“红色”(一个或多个测试失败)。从“绿”到“红”，再从“红”到“绿”，这是一个不太坏的习惯。而后者正是我们要做的。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="12f4" class="me mf it bd mg mh ny mj mk ml nz mn mo jz oa ka mq kc ob kd ms kf oc kg mu mv bi translated">更新对象关系映射代码</h1><p id="fad8" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">描述如何在类和数据库之间映射的一种机制是映射类。我们需要一个“TodoListItem”的映射类。我们已经有了一个名为“DataAccess/Maps”的文件夹，所以我们将在这里创建它。它的实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="767b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经将属性“Items”添加到类“TodoList”中，因此需要相应地修改映射类。这就是我们引入Fluent NHibernate新元素的地方:“HasMany()”。这个指令告诉NHibernate一个属性代表一对多关系。</p><p id="c6b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是类“TodoListMap”的更新实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="df52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这个，让我们再次尝试我们的测试。错误消息已经改变，这表明了进度，因为这意味着我们正在代码库的正确区域进行探索:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><div class="gh gi ou"><img src="../Images/a966b1427312974677a02804a6e9a649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zoAdPbI1JtNcUpNh9MQKLg.png"/></div></div></figure><h2 id="499d" class="mw mf it bd mg mx my dn mk mz na dp mo ld nb nc mq lh nd ne ms ll nf ng mu nh bi translated">解决“TransientObjectException”</h2><p id="8462" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">让我们反思一下我们迄今为止所做的事情。我们有可以保存和读取“TodoList”对象的代码。我们还更新了对象关系(OR)映射。然而，我们忘记告诉NHibernate我们也想让“TodoListItem”对象持久化。一种选择是将“TodoListRepository”的实现更改如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/95ec0ed64ea5bd90be3ee12d41594947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*zwQ64zszcLh1h5pyzxVMlQ.png"/></div></figure><p id="038a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就够了。然而，我们有不同的选择。我们可以通过向“HasMany()”指令添加更多细节来更新OR映射。这些额外的细节告诉NHibernate如何根据父记录来处理子记录。换句话说，我们希望将某些事件“级联”到孩子身上。</p><p id="d6a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我们想要传播，即“级联”，当“TodoList”对象被保存时，我们也想要保存该列表中的项目。下面是改进后的类“TodoListMap”:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="8283" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们现在运行测试，我们将再次得到不同的错误消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><div class="gh gi ow"><img src="../Images/b0280716af02397c461d842f1466cb43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQiLyite4CN9A_ke8iS55A.png"/></div></div></figure><h2 id="64c8" class="mw mf it bd mg mx my dn mk mz na dp mo ld nb nc mq lh nd ne ms ll nf ng mu nh bi translated">正在解析“无效的对象名‘TodoListItem’”</h2><p id="20ae" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">这个错误消息并不奇怪。我们还没有为“TodoListItem”创建表。让我们添加缺失的迁移:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="f575" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将使我们跨越障碍，但当我们重新运行测试时，我们有一个新的问题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><div class="gh gi ou"><img src="../Images/bf25b6bee5e7e457c856f3b6e9918ca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XahVldFWAT-7hgHO-qQSAg.png"/></div></div></figure><h2 id="6092" class="mw mf it bd mg mx my dn mk mz na dp mo ld nb nc mq lh nd ne ms ll nf ng mu nh bi translated">解析“无法将值NULL插入到列“TodoListId”中”</h2><p id="5260" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">出现此错误消息的原因是，尽管我们将项目添加到了列表中，但是ORM还不能映射列表项目。让我们做一些小的改变来实现这一点。</p><p id="8c63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个变化是在类“TodoListItem”中，我们添加了一个引用TodoList的属性(第8行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e122" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还更新了映射类“TodoListItemMap”:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="fb1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第12行，我们添加了对“TodoList”引用的映射，即一对多关系的“一”端。</p><p id="1096" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要更新测试。当我们创建“TodoListItem”对象时，我们设置了属性“TodoList ”,参见下面要点中的第7行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="200a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们再次重新运行测试，看看这次我们能走多远:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><div class="gh gi ox"><img src="../Images/cc564ff51ee087b19818fee3140a942b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ziTU_zDRZX8W__bJ6Wd55w.png"/></div></div></figure><h2 id="473c" class="mw mf it bd mg mx my dn mk mz na dp mo ld nb nc mq lh nd ne ms ll nf ng mu nh bi translated">解决LazyInitializationException</h2><p id="9e41" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">“LazyInitializationException”值得稍微解释一下。当我们从数据库中读取“TodoList”对象(父对象)时，NHibernate还没有读取“TodoListItem”对象(子对象)。默认情况下，它使用了一个叫做“延迟加载”(又名“延迟初始化”)的概念。这意味着它只在代码访问“TodoList”对象上的属性“items”时加载项目。</p><p id="7900" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在再看一下更新后的测试(参见上面最新的代码片段)。在第10行，我们调用了</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="0abd" class="mw mf it og b gy ok ol l om on">retrieved.Items.Count </span></pre><p id="f0ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当零件“取回”时。Items”时，延迟加载开始并尝试从数据库中加载项目。但是，问题是，此时我们没有数据库连接。NHibernate使用一个只有在执行“TodoListRepository”时才可用的会话。</p><p id="7caa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有不同的方法来解决这个问题。一种方法是在更广的范围内划分会话边界。我们将在以后的文章中研究这个选项。</p><p id="3c6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一种选择是告诉NHibernate在这个实例中不要使用延迟加载。对于此选项，我们需要更新类“TodoList”的映射，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="ba5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，在第14行，我们通过使用“. Not.LazyLoad()”明确地关闭了延迟加载。考虑到我们在每个列表中只有少量的待办事项，阅读全部是可以接受的。但是，如果出现可能有大量子记录的情况。在这些场景中，出于性能原因，可能需要不同的方法。不过，我们不会在本文中讨论这个问题。</p><p id="9199" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们使用这个额外的更改再次运行测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="op oq di or bf os"><div class="gh gi oy"><img src="../Images/8cf49413f50b31e10eb13b594bc9f259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DHDeVJbUbgIvwKrCOGGVsw.png"/></div></div></figure><p id="a1bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">厉害！正是我们想要的。我们从一个失败的测试开始，这导致我们从“绿色”(即所有测试都通过)到“红色”(一个或多个测试失败)。然后我们一次从“红”到“绿”一个问题。请记住，这仍然不是测试驱动的，但至少它是测试优先的。我们编写了测试，然后进行了足够的代码修改以使测试通过。(你可能会说，这是一种不同的“懒加载”😊)</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="b527" class="me mf it bd mg mh ny mj mk ml nz mn mo jz oa ka mq kc ob kd ms kf oc kg mu mv bi translated">家政</h1><p id="79dd" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">尽管我们现在只有一小段代码，但寻找可以清理的东西是值得的。</p><p id="7704" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个明显的候选是我们用来存储“TodoList”对象的表“List”。这与我们存储在名为“TodoListItem”的表中的类“TodoListItem”不一致。</p><p id="3777" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决这个问题只需要少量的更改。让我们从重命名表的迁移开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="21fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们可以将“TodoListMap”类简化如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="9cfd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们在这个类中不再调用“table(“List”)”。我们现在依赖于Fluent Migrator使用的约定。因此，重命名该表是正确的做法。</p><p id="3a43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们现在看一下数据库模式，画面看起来也更加一致:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/3e4579ec4e1775fa59678e38efb42ea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*6n-jX7YuppTw--xBO6BI0w.png"/></div></figure><p id="5b13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想知道:我正在使用一个名为“Azure Data Studio”的工具。它是开源的，基于VS代码。下载说明可以在微软的网站上找到。该工具适用于Windows、macOS和Linux。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="c496" class="me mf it bd mg mh ny mj mk ml nz mn mo jz oa ka mq kc ob kd ms kf oc kg mu mv bi translated">包扎</h1><p id="f5b2" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">添加一对多关系是一个相当简单的步骤。然而，接下来我们需要看一些东西。例如，如果我们想从待办事项列表中更新或删除一个项目，该怎么办？或者，如果只是想要一个所有待办事项列表的名称及其id的列表呢？当然，我们不希望读取所有列表中的所有项目。这可能会变得非常昂贵。所以，我们可能也想调查一下。</p><p id="76a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个挑战是我们必须显式禁用延迟加载。理想情况下，我们不需要首先考虑这个问题。但是，我们如何在一次会议的范围内做到这一点呢？</p><p id="9e07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有这些都是我们在实践中面临的许多项目中的重要考虑因素。我将在接下来的几篇文章中提出我的建议。请在下面的评论中留下你的问题和建议。谢谢大家！</p><p id="71b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读！</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="de33" class="me mf it bd mg mh ny mj mk ml nz mn mo jz oa ka mq kc ob kd ms kf oc kg mu mv bi translated">参考资料和附加材料</h1><p id="627c" class="pw-post-body-paragraph ku kv it kw b kx ni ju kz la nj jx lc ld nk lf lg lh nl lj lk ll nm ln lo lp im bi translated">您可能会发现有助于进一步探索的参考资料和其他材料的链接:</p><ul class=""><li id="dc87" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">文章<a class="ae nn" href="https://medium.com/swlh/easy-schema-migrations-in-net-core-abd214fa054c?sk=f81e1d26a7e58c1a864fb4f85895fe13" rel="noopener">“轻松的模式迁移。净芯"</a></li><li id="ea9f" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">文章<a class="ae nn" href="https://medium.com/nerd-for-tech/easy-database-access-with-nhibernate-in-net-5-0-3cc7e36510c9?sk=d83d22c7197e509193c59eafc848e18c" rel="noopener">“使用NHibernate轻松访问数据库”</a></li><li id="d5f3" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated">文档流畅迁移器的<a class="ae nn" href="https://fluentmigrator.github.io/articles/fluent-interface.html" rel="noopener ugc nofollow" target="_blank">“流畅接口”</a></li></ul></div></div>    
</body>
</html>