<html>
<head>
<title>Automatic Applications in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的自动应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/automatic-applications-in-go-c6cca3d42f84?source=collection_archive---------14-----------------------#2020-06-23">https://levelup.gitconnected.com/automatic-applications-in-go-c6cca3d42f84?source=collection_archive---------14-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1fcdbf5a32648823327e28b62b785cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ssj-L97dn2ieAS0N1UzyKg.png"/></div></div></figure><div class=""/><div class=""><h2 id="c92b" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">更好的自动代码创建和使用工具。</h2></div><p id="d676" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这篇文章不是关于工具的内部，而是关于它们是如何发展的，我如何使用它们，以及你如何也能使用它们。出于好奇，这里记录了这些的起源<a class="ae lp" rel="noopener ugc nofollow" target="_blank" href="/metaprogram-in-go-5a2a7e989613"/>和这里<a class="ae lp" rel="noopener ugc nofollow" target="_blank" href="/automatic-testing-in-go-ce581238eb57"/>，尽管请记住最新版本已经有了相当大的变化。确保您为遗留版本签出了正确的标签(参见README。MD)。</p><p id="88e3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我继续研究这些工具，因为它们对我现在做的一些工作非常有用。这需要大量新数据集和模式的快速原型制作。我向代码生成工具本身添加了更多的功能，但我也在生成的代码之上编写了越来越多的手动应用程序代码，后者越来越难以转移到新生成的代码——显然我需要某种方法来自动化这一过程，这就是MetaSplice的动机，它是该系列中最新的小工具。现在，只需更改sql，发出几个命令，然后几乎回到我离开的地方，只是使用全新的模式、api和测试，这是一件非常令人高兴的事情。更重要的是，我可以快速迭代新的想法，并在风险很小的情况下进一步开发它们。</p><p id="5484" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">简单回顾一下，我们从<a class="ae lp" href="https://github.com/exyzzy/metaapi" rel="noopener ugc nofollow" target="_blank"> metaapi </a>工具开始，它最初创建了一个基于PosgreSQL表定义的CRUD模型api。然后我们添加了<a class="ae lp" href="https://github.com/exyzzy/metaproj" rel="noopener ugc nofollow" target="_blank"> metaproj </a>来为metaapi项目创建初始文件，并扩展了metaapi来为CRUD模型api添加自动测试。</p><p id="42fc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">从那以后</strong>，除了修复了很多bug，我还补充了以下内容:</p><ul class=""><li id="1449" class="lq lr je kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">使用Vue/Vuetify的全功能web服务器的项目设置(我的前端选择)</li><li id="0247" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">CRUD api之上的自动公共HTTP api(路由和处理程序，Gorilla Mux)</li><li id="7c9f" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">HTTP api的自动测试</li><li id="717a" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">支持Go/PostgreSQL空字段/数据</li><li id="21c9" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">数据的简单验证表视图页</li><li id="8990" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">一个新的工具，<strong class="kv jf"> MetaSplice </strong>，用于从一个生成的项目中捕获和重新合并差异。稍后将详细介绍。</li></ul><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi me"><img src="../Images/724f952993315063061e7f010ed1485e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gOL55sVmN72En3ggPrq9XQ.png"/></div></div></figure><h2 id="dc06" class="mj mk je bd ml mm mn dn mo mp mq dp mr lc ms mt mu lg mv mw mx lk my mz na nb bi translated">环境</h2><p id="164c" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">本文假设您在Linux/UNIX环境中的PC上安装了以下软件:</p><ul class=""><li id="0a11" class="lq lr je kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated"><a class="ae lp" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VS代码</a>，或者其他类似的编辑器</li><li id="df5f" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated"><a class="ae lp" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a></li><li id="5eda" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated"><a class="ae lp" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank">出发</a></li><li id="8974" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated"><a class="ae lp" href="https://curl.haxx.se/" rel="noopener ugc nofollow" target="_blank">卷曲</a></li><li id="b777" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated"><a class="ae lp" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>(或<a class="ae lp" href="https://postgresapp.com/" rel="noopener ugc nofollow" target="_blank"> mac </a></li></ul><h1 id="23a8" class="nh mk je bd ml ni nj nk mo nl nm nn mr kk no kl mu kn np ko mx kq nq kr na nr bi translated">工作流程</h1><p id="b2db" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">我的工作流程现在是这样的:</p><p id="ba27" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">1.定义一些SQL表</p><p id="0fa5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">2.运行metaproj来自动生成初始项目并为metaapi设置</p><p id="0658" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">3.在项目上运行<code class="fe ns nt nu nv b">go generate</code>,它运行metaapi来自动创建:</p><ul class=""><li id="ee0e" class="lq lr je kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">CRUD api</li><li id="7d26" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">污垢测试</li><li id="b758" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">api测试数据</li><li id="1048" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">HTTP api</li><li id="2f5f" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">HTTP测试</li><li id="7bd5" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">自述文件</li><li id="dce5" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">表格视图html</li><li id="603d" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">表格视图Vue js</li></ul><p id="60fb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">4.在生成代码的许多<em class="nw">接合点</em>中的任何一个中编写一些自定义代码，并添加所有新文件。根据需要向metaapi或metaproj添加更多的拼接点，尽管我已经有一段时间没有这样做了。</p><p id="a1ec" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">5.创建并维护一个extractsplice/extractsplice.go文件，该文件只告诉metasplice我在哪里接触了东西。</p><p id="3e5f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，有趣的事情来了。当我不可避免地想要更改或添加模式时:</p><p id="e369" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">6.Cd放入extractsplice目录并运行<code class="fe ns nt nu nv b">go generate</code>。这在go项目级别创建了一个新的“diff”项目，它包括我原来的extractsplice目录，还包括一个新的自动生成的applysplice目录和所有的splice diff文件，这些文件允许我将所有的更改重新集成到一个新的metaapi项目中。方法如下:</p><p id="a1af" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">7.编辑*。我的diff/applysplice目录中的sql文件，以便对模式进行任何更改或添加</p><p id="555a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">8.删除(或者只是重命名，如果偏执)我的最后一个项目目录</p><p id="f807" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">9.运行metaproj，根据修改后的sql和metaapi的设置自动生成新的初始项目(再次执行上面的步骤2)</p><p id="e89b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">10.在运行metaapi的项目上运行<code class="fe ns nt nu nv b">go generate</code>(再次执行上面的步骤3 ),以基于新的SQL创建新的api文件</p><p id="edce" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">11.在diff/applysplice上运行<code class="fe ns nt nu nv b">go generate</code>——这将我在步骤6中的所有差异添加回我的新项目中。<strong class="kv jf">现在我又回到了我离开的地方，这里有全功能的CRUD api、HTTP api和新SQL的测试！</strong>甚至git文件也被保留。</p><p id="c8f0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">12.修复由模式更改导致的任何编译错误。</p><p id="796b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">13.转到步骤4</p><p id="5c18" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">令人欣慰的是，所有api管道代码(通常是许多愚蠢错误的来源)都是由SQL表定义的数据驱动的。自动生成和应用diff(拼接)代码也非常好。让我们做一个小例子来说明这个流程。无处不在的ToDo应用。</p><h1 id="17d7" class="nh mk je bd ml ni nj nk mo nl nm nn mr kk no kl mu kn np ko mx kq nq kr na nr bi translated">待办事项演示</h1><p id="9277" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">我们将构建一个简单的示例来展示整个过程，归结起来就是:</p><ol class=""><li id="af99" class="lq lr je kv b kw kx kz la lc ls lg lt lk lu lo nx lw lx ly bi translated">基于模式自动创建初始项目(A)</li><li id="7fcc" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo nx lw lx ly bi translated">在(A)中写入新的唯一代码(B)</li><li id="fd99" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo nx lw lx ly bi translated">将唯一代码(B)提取到一个不同的项目(C)中</li><li id="dc6c" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo nx lw lx ly bi translated">基于新架构自动创建新项目(D)</li><li id="3709" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo nx lw lx ly bi translated">将我们的差异项目(C)应用到新项目(D)</li></ol><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/e384433e0903b323f4ba7658dc61973b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4usTTyI_JTRYqK6cdNVBKg.png"/></div></div></figure><p id="4a1a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">首先，让我们安装我们需要的工具:</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="c87e" class="mj mk je nv b gy od oe l of og">go get github.com/exyzzy/metaapi<br/>go install $GOPATH/src/github.com/exyzzy/metaapi<br/>go get github.com/exyzzy/metaproj<br/>go install $GOPATH/src/github.com/exyzzy/metaproj<br/>go get github.com/exyzzy/metasplice<br/>go install $GOPATH/src/github.com/exyzzy/metasplice</span></pre><h2 id="4d02" class="mj mk je bd ml mm mn dn mo mp mq dp mr lc ms mt mu lg mv mw mx lk my mz na nb bi translated">创建初始项目</h2><p id="6fb3" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">首先，我们将在项目级别为我们的todos定义一个PostgreSQL表:</p><p id="d1ba" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">todos.sql</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="2a1a" class="mj mk je nv b gy od oe l of og">create table todos (<br/>    id           integer generated always as identity primary key,<br/>    updated_at   timestamptz not null,<br/>    done         boolean not null,<br/>    title        text not null<br/>);</span></pre><p id="cc1c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在我们将运行metaproj，然后使用go generate(它将运行metaapi)来创建我们的初始项目</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="a426" class="mj mk je nv b gy od oe l of og">metaproj -sql=todos.sql -proj=todo -type=vue<br/>cd todo<br/>go generate<br/>go install</span></pre><p id="785f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可以在VS代码中打开您的项目，并查看到目前为止生成的所有文件。这些是使用Go/Vue/Vuetify为您的模式编译和运行的基本文件集。我不打算在这里花时间解释所有这些是什么，但没有什么是太难的，所以请随意探索自己生成的代码。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/4d5206210d04bf3a6e7dea6d562d61e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*LoUbm65kKIX_GeaBLHsQVQ.png"/></div></figure><p id="c816" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们需要创建项目本地使用的初始PostgreSQL角色和数据库。这是在生成的文件data/configlocaldb.json中假定的。</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="3e5a" class="mj mk je nv b gy od oe l of og">createuser -P -d todo &lt;pass: todo&gt;<br/>createdb todo</span></pre><p id="a90d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在您可以运行CRUD和HTTP api测试了</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="4a55" class="mj mk je nv b gy od oe l of og">cd data<br/>go test<br/># should PASS<br/>cd ..<br/>go test<br/># should PASS<br/>todo</span></pre><p id="14ac" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这两个都应该通过，现在让我们启动并查看应用程序，输入<code class="fe ns nt nu nv b">todo</code>，然后在新的终端窗口<code class="fe ns nt nu nv b">open <a class="ae lp" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank">http://localhost:8000</a></code>中，或者打开浏览器并输入localhost:8000。您应该会看到一个外观精美的基本web应用程序:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/3b5a3a6f518883d98d47bce80b8d1f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y6ymtKqtzCIC95qLsQtmNA.png"/></div></div></figure><p id="e155" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你现在点击我的数据。表，您将看到下面的表视图。因为还没有数据，所以没什么可看的。</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/8c3230a53bf878f20f1c3343c8082cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2JYTqELzzsmbXLXbijVGg.png"/></div></div></figure><p id="7016" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们添加一些数据并练习api。如果您看一下生成的文件，todos_README。在VS代码中，它将概述我们刚刚完成的所有步骤，以及生成的HTTP api:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/d8cac7448ad7c400d3c7ea429b3cf8e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*D9eNIDS0w9gmOiW9UMqPtw.png"/></div></figure><p id="61ac" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">基于此，我们可以使用curl生成一些数据:</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="c555" class="mj mk je nv b gy od oe l of og">curl -d '{"done":false, "title":"Buy Some Milk"}' -H "Content-Type: application/json" -X POST <a class="ae lp" href="http://localhost:8000/api/todo" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/api/todo</a></span><span id="ae6c" class="mj mk je nv b gy ol oe l of og">curl -d '{"done":false, "title":"Walk The Dog"}' -H "Content-Type: application/json" -X POST http://localhost:8000/api/todo</span></pre><p id="8f41" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">果然，新数据出现在我们的表格视图中:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/7ebef90d6b939f39adae0e54039ad2d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ammQhNwKnfyYbNhnusCNQ.png"/></div></div></figure><p id="0ef0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们尝试更多的api:</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="ef96" class="mj mk je nv b gy od oe l of og">curl -d '{"done":true, "title":"Buy Some Chocolate Milk"}' -H "Content-Type: application/json" -X PUT <a class="ae lp" href="http://localhost:8000/api/todo/1" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/api/todo/1</a></span><span id="0faa" class="mj mk je nv b gy ol oe l of og">curl -H "Content-Type: application/json" -X GET http://localhost:8000/api/todo/2</span><span id="ee47" class="mj mk je nv b gy ol oe l of og">curl -H "Content-Type: application/json" -X DELETE http://localhost:8000/api/todo/2</span></pre><p id="db46" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">所有这些都返回正确的JSON响应，应用程序看起来也是正确的:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/8ed682e4308207acf746272e190f21f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5kj5t2q1Y5zkvHMr2NdNA.png"/></div></div></figure><p id="49ae" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您现在就可以部署它，并拥有一个具有广泛开放的公共api的全功能网站。我们还没有编写任何代码，所以让我们这样做并练习metasplice工具。</p><p id="0185" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">注意</strong>:如果你正在使用VS代码或者其他一些在保存时自动格式化的编辑器，确保它被设置为不修改导入语句，纯gofmt应该没问题。这确保了对导入的拼接更改得以保留。</p><p id="2d47" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在让我们初始化我们的git repo，这样我们就可以捕获最初的生成。</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="042d" class="mj mk je nv b gy od oe l of og">git init<br/>git add .<br/>git commit -m "initial commit"</span></pre><h2 id="f7f4" class="mj mk je bd ml mm mn dn mo mp mq dp mr lc ms mt mu lg mv mw mx lk my mz na nb bi translated">添加新的唯一代码</h2><p id="0784" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">现在，我们将开始对基线生成的代码进行更改，我们需要做一些设置来跟踪我们的更改，以便拼接工具可以完成它的工作。这是一笔微不足道的前期开销，设置好之后就很容易维护了。我们要做的第一件事是创建提取文件夹和文件来跟踪我们的更改。</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="e6c1" class="mj mk je nv b gy od oe l of og">mkdir extractsplice</span></pre><p id="395e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">extractsplice/extractsplice.go</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="cce8" class="mj mk je nv b gy od oe l of og">package splice</span><span id="a6a6" class="mj mk je nv b gy ol oe l of og">//go:generate  mkdir -p ../../tododiff<br/>//go:generate  mkdir -p ../../tododiff/templates<br/>//go:generate  mkdir -p ../../tododiff/extractsplice<br/>//go:generate  cp ../extractsplice/extractsplice.go ../../tododiff/extractsplice/extractsplice.go</span><span id="c54a" class="mj mk je nv b gy ol oe l of og"><strong class="nv jf">//place any new mkdir -p ../../tododiff/&lt;somefolder&gt; commands here<br/>//place any new cp ../&lt;somefolder&gt;/&lt;somefile&gt; ../../tododiff/&lt;somefolder&gt;/&lt;somefile&gt; commands here</strong></span><span id="2bd2" class="mj mk je nv b gy ol oe l of og"><strong class="nv jf">//place any metasplice -src=../&lt;somefolder&gt;/&lt;somefile&gt; -dest=../../tododiff/&lt;somefolder&gt;/&lt;somedifffile&gt; -mode=extract</strong></span><span id="8da5" class="mj mk je nv b gy ol oe l of og">//go:generate  metasplice -src=../extractsplice/extractsplice.go -dest=../../tododiff/applysplice/applysplice.go -mode=applyfile</span><span id="bfe7" class="mj mk je nv b gy ol oe l of og">//go:generate cp -R ../.git ../../tododiff/.git</span><span id="9b40" class="mj mk je nv b gy ol oe l of og">//go:generate  cp ../todos.sql ../../tododiff/applysplice/todos.sql</span></pre><p id="696b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这是样本extractsplice.go文件的模式。它在做什么？</p><ul class=""><li id="9441" class="lq lr je kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">创建必要的文件夹结构。请注意，我们将所有内容都放在名为tododiff的diff项目文件夹中——您可以随意命名，只要与extractsplice.go文件中的所有命令保持一致。请注意，metasplice假设它看到的第一个mkdir命令在最后一个“/”后包含(目标)diff项目名</li><li id="8e77" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">创建任何新文件夹并复制任何不是由metaproj/metaapi生成的新文件。当您将更多的文件添加到项目中时，您将保留此部分。</li><li id="0070" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">对任何生成的需要从拼接点提取的文件运行带提取模式的metasplice。</li><li id="7483" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">使用applyfile模式运行metasplice。这使用extractsplice/extractsplice.go作为输入，在我们的diff项目中生成一个匹配的applysplice/applysplice.go文件。</li><li id="e53d" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">复制我们的git目录(递归)。请注意，这个git与diff项目文件夹不匹配，如果在那里使用，它会看起来很疯狂，不要在diff文件夹中使用git——它意味着在我们的新schema项目上运行applysplice后被复制到最终项目中。</li><li id="b133" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">复制我们当前的项目。sql文件添加到applysplice目录。这不是真正必要的，并且会在反向应用生成时出错，但是我喜欢这样做来捕获与差异相关的模式，并作为新模式更改的起点。这样做没什么坏处。</li></ul><p id="db6a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">就这样，现在我们准备添加一些新的代码。我们将通过添加一个交互式的vue/vue化界面来稍微修饰一下UI。这将允许我们演示现有文件内的更改和添加新文件。我们将通过构建一个新的vue组件来完成大部分工作，然后在主页上使用它。</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="5f86" class="mj mk je nv b gy od oe l of og">mkdir -p public/components</span></pre><p id="0286" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">public/components/vuetodo.js</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="8256" class="mj mk je nv b gy od oe l of og">Vue.component('todo-list', {<br/>    // delimiters: ['${', '}'],   CUSTOM DELIMITERS DO NOT WORK IN COMPONENTS, AND ARE NOT NEEDED BY GO!!<br/>    data: () =&gt; ({<br/>        todos: []<br/>    }),<br/>    mounted: function() {<br/>        this.$nextTick(function () {<br/>            this.loadTodos();<br/>        })<br/>    },<br/>    methods: {<br/>        addTodo() {</span><span id="18c6" class="mj mk je nv b gy ol oe l of og">axios.post('/api/todo', {"title": "Todo"}<br/>            )<br/>            .then((response) =&gt; {<br/>                this.todos.unshift(response.data)<br/>            })<br/>            .catch((error) =&gt; {<br/>                if (error.response) {<br/>                // The request was made and the server responded with a status code<br/>                // that falls out of the range of 2xx<br/>                console.log(error.response.data);<br/>                console.log(error.response.status);<br/>                console.log(error.response.headers);<br/>                } else if (error.request) {<br/>                // The request was made but no response was received<br/>                // `error.request` is an instance of XMLHttpRequest in the browser and an instance of<br/>                // http.ClientRequest in node.js<br/>                console.log(error.request);<br/>                } else {<br/>                // Something happened in setting up the request that triggered an Error<br/>                console.log('Error', error.message);<br/>                }<br/>                console.log(error.config);<br/>            });</span><span id="5169" class="mj mk je nv b gy ol oe l of og">},<br/>        deleteTodo(item) {<br/>            axios.delete('/api/todo/'+item.id.toString()<br/>            )<br/>            .then((response) =&gt; {<br/>                let index = this.todos.indexOf(item)<br/>                this.todos.splice(index, 1)<br/>            })<br/>            .catch((error) =&gt; {<br/>                if (error.response) {<br/>                console.log(error.response.data);<br/>                console.log(error.response.status);<br/>                console.log(error.response.headers);<br/>                } else if (error.request) {<br/>                console.log(error.request);<br/>                } else {<br/>                console.log('Error', error.message);<br/>                }<br/>                console.log(error.config);<br/>            });<br/>            <br/>        },<br/>        updateTodo(item) {<br/>            axios.put('/api/todo/'+item.id.toString(), <br/>                item <br/>            )<br/>            .then((response) =&gt; {<br/>                //vuetify handles checkbox/textfiled update<br/>                return<br/>            })<br/>            .catch((error) =&gt; {<br/>                if (error.response) {<br/>                console.log(error.response.data);<br/>                console.log(error.response.status);<br/>                console.log(error.response.headers);<br/>                } else if (error.request) {<br/>                console.log(error.request);<br/>                } else {<br/>                console.log('Error', error.message);<br/>                }<br/>                console.log(error.config);<br/>            });</span><span id="2016" class="mj mk je nv b gy ol oe l of og">},<br/>        loadTodos () {<br/>            axios.get('/api/todos', <br/>            )<br/>            .then((response) =&gt; {</span><span id="89f1" class="mj mk je nv b gy ol oe l of og">if (response.data == null ) {<br/>                    console.log("no todos returned")<br/>                } else {</span><span id="2004" class="mj mk je nv b gy ol oe l of og">for (let i= 0; i &lt; response.data.length; i++) {<br/>                        this.todos.push(response.data[i])<br/>                    }</span><span id="d758" class="mj mk je nv b gy ol oe l of og">}<br/>            })<br/>            .catch((error) =&gt; {<br/>                if (error.response) {<br/>                    console.log(error.response.data);<br/>                    console.log(error.response.status);<br/>                    console.log(error.response.headers);<br/>                    } else if (error.request) {<br/>                    console.log(error.request);<br/>                    } else {<br/>                    console.log('Error', error.message);<br/>                    }<br/>                    console.log(error.config);<br/>                });<br/>        }</span><span id="1bda" class="mj mk je nv b gy ol oe l of og">},<br/>    template: `<br/>    &lt;v-card<br/>    max-width="600"<br/>    class="mx-auto"<br/>    &gt;<br/>        &lt;v-toolbar<br/>            color="green accent-1"<br/>        &gt;<br/>            &lt;v-toolbar-title&gt;My Todos&lt;/v-toolbar-title&gt;<br/>            &lt;v-spacer&gt;&lt;/v-spacer&gt;<br/>            &lt;v-btn<br/>                color="blue darken-1"<br/>                <a class="ae lp" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>="addTodo()"<br/>                dark<br/>            &gt;<br/>            Add Todo<br/>            &lt;/v-btn&gt;<br/>        &lt;/v-toolbar&gt;<br/>        &lt;v-list &gt;<br/>            &lt;v-list-item <br/>                v-for="todo in todos"<br/>                :key = todo.id<br/>            &gt;<br/>                    &lt;template v-slot:default="{ active, toggle }"&gt;<br/>                    &lt;v-list-item-action&gt;<br/>                        &lt;v-checkbox<br/>                        v-model="todo.done"<br/>                        <a class="ae lp" href="http://twitter.com/change" rel="noopener ugc nofollow" target="_blank">@change</a>="updateTodo(todo)"<br/>                        color="blue darken-1"<br/>                        &gt;&lt;/v-checkbox&gt;<br/>                    &lt;/v-list-item-action&gt;<br/>    <br/>                    &lt;v-list-item-content&gt;<br/>                        &lt;v-list-item-title&gt;<br/>                            &lt;v-text-field <br/>                                dense <br/>                                hide-details <br/>                                v-model="todo.title"<br/>                                <a class="ae lp" href="http://twitter.com/change" rel="noopener ugc nofollow" target="_blank">@change</a>="updateTodo(todo)"<br/>                            &gt;&lt;/v-text-field&gt;<br/>                        &lt;/v-list-item-title&gt;<br/>                    &lt;/v-list-item-content&gt;<br/>                    &lt;v-list-item-action&gt;<br/>                        &lt;v-tooltip top&gt;<br/>                            &lt;template v-slot:activator="{ on }"&gt;<br/>                                &lt;v-icon <br/>                                <a class="ae lp" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>="deleteTodo(todo)"<br/>                                v-on="on"<br/>                                color="blue darken-1"<br/>                                &gt;<br/>                                mdi-delete<br/>                                &lt;/v-icon&gt;<br/>                            &lt;/template&gt;<br/>                            Delete Todo<br/>                        &lt;/v-tooltip&gt;            <br/>                    &lt;/v-list-item-action&gt;<br/>                    &lt;/template&gt;<br/>            &lt;/v-list-item&gt;<br/>        &lt;/v-list&gt;<br/>    &lt;/v-card&gt;<br/>    `<br/>});</span></pre><p id="a0ca" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可以轻松地创建一个新页面来使用这个新的vue组件，或者只是完全替换主页，这正是我要做的，但是作为如何在拼接点内集成的示例，我们将把它拼接到现有的默认主页中。如果我们打开home.html文件，我们可以看到一个拼接点:<code class="fe ns nt nu nv b">&lt;!--#SPLICE# body {[&lt; template "body" . &gt;]} #SPLICE# end --&gt;</code></p><p id="7166" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">拼接点表示由分隔符限定的生成代码中的命名提取/插入点。我们在这些分隔符范围内编写的任何代码都可以安全地从我们的项目提取到diff项目中，然后可以在代码流中相同的相对点重新插入到任何新生成的schema项目中。因为它们被嵌入在注释中，所以根据文件类型的不同，它们看起来会有所不同。因为。去吧。他们看起来像:</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="fe74" class="mj mk je nv b gy od oe l of og">//#SPLICE# tagname {[&lt; template "tagname" . &gt;]}<br/>//#SPLICE# end</span></pre><p id="d1ff" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">而对于。它们看起来像:</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="d269" class="mj mk je nv b gy od oe l of og">&lt;!--#SPLICE# tagname {[&lt; template "tagname" . &gt;]} #SPLICE# end --&gt;</span></pre><p id="2159" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">标记名将根据接合点所在的代码段而变化。我们只需要用新代码替换<code class="fe ns nt nu nv b">{[&lt; template "tagname" . &gt;]}</code>。拼接点总是由这种模式界定:开头是<code class="fe ns nt nu nv b">#SPLICE# &lt;tagname&gt;</code>，结尾是<code class="fe ns nt nu nv b">#SPLICE# end</code>，我们编写的独特代码位于它们之间。因为我们在一个。使用多行注释的html文件，我们必须在分割拼接点的时候加上注释，这对于go文件拼接点来说是不正确的。</p><p id="e9bc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在使用这个系统一段时间后，我的经验是，你需要偶尔拼接生成的代码，如果你不能这样做，这将是使用生成代码的一个障碍，但这并不频繁——大多数独特的代码将在新文件中。下面是我们将如何拼接到主页(见粗体):</p><p id="22f4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">templates/home.html</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="6415" class="mj mk je nv b gy od oe l of og">{{ define "content" }}<br/>&lt;v-container&gt;<br/>    &lt;v-row column align="center" justify="center"&gt;<br/>        &lt;v-col&gt;<br/>            &lt;h1 color="grey darken-3" class="mb-5 mt-4 display-1 text-center"&gt;<br/>                Todo Site<br/>            &lt;/h1&gt;<br/>            &lt;p color="grey darken-3" class="mt-4 text-center"&gt;<br/>                Made with:<br/>            &lt;/p&gt;<br/>            &lt;div color="grey darken-3" class="subheading text-center"&gt;<br/>                &lt;a href="<a class="ae lp" href="https://github.com/exyzzy/metaproj" rel="noopener ugc nofollow" target="_blank">https://github.com/exyzzy/metaproj</a>"&gt;metaproj&lt;/a&gt;&lt;br&gt;<br/>                &lt;a href="<a class="ae lp" href="https://github.com/exyzzy/metaapi" rel="noopener ugc nofollow" target="_blank">https://github.com/exyzzy/metaapi</a>"&gt;metaapi&lt;/a&gt;&lt;br&gt;<br/>            &lt;/div&gt;<br/>            <strong class="nv jf">&lt;!--#SPLICE# body --&gt;<br/>            &lt;todo-list class="mt-4"&gt;&lt;/todo-list&gt;        <br/>            &lt;!--#SPLICE# end --&gt;      </strong>  <br/>        &lt;/v-col&gt;<br/>    &lt;/v-row&gt;<br/>&lt;/v-container&gt;<br/>{{ end }}</span></pre><p id="ec4a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们还需要在脚本拼接点将组件添加到vue.js文件中:</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="d3bd" class="mj mk je nv b gy od oe l of og">//#SPLICE# script {[&lt; template "script" . &gt;]}<br/>//#SPLICE# end</span></pre><p id="c0c7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">像这样:</p><p id="b5e2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">模板/home.vue.js</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="5933" class="mj mk je nv b gy od oe l of og">{{ define "vue" }}<br/><strong class="nv jf">//#SPLICE# script<br/>&lt;script src="/static/components/vuetodo.js"&gt;&lt;/script&gt;<br/>//#SPLICE# end</strong><br/>&lt;script&gt;<br/>    new Vue({<br/>    delimiters: ["${", "}"], //required to not conflict with go template action delimiters<br/>    el: "#app",<br/>    vuetify: new Vuetify(),<br/>    data: () =&gt; ({})<br/>});<br/>&lt;/script&gt;<br/>{{ end }}</span></pre><p id="c447" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当然，由于metaapi和metaproj是开源的，所以您可以在生成的代码中随意创建新的接合点，或者完全更改底层代码生成。这些工具旨在被理解并适应您的使用，它是一个流动的工具集。你现在在里面看到的，正是我目前需要的。</p><p id="55ac" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，如果您编译并运行新版本，您将在主页上看到一个新的Vue/Vue化交互UI，它现在使用我们的新组件。点击添加待办事项按钮添加新项目，点击文本编辑/更新文本。点击方块将其取消，点击垃圾图标将其删除。</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="f64a" class="mj mk je nv b gy od oe l of og">go install<br/>todo</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/aa82c38d871bd9425f7cb4e37c4d1a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Hk3obxpGbawXRHPlKibTg.png"/></div></div></figure><p id="3cab" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们剩下要做的就是在extractsplice.go文件中跟踪我们的更改(新的唯一代码)，我们将在下面的<strong class="kv jf">粗体</strong>中添加它。</p><p id="8edf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">extractsplice/extractsplice.go</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="b823" class="mj mk je nv b gy od oe l of og">package splice</span><span id="eeff" class="mj mk je nv b gy ol oe l of og">//go:generate  mkdir -p ../../tododiff<br/>//go:generate  mkdir -p ../../tododiff/templates<br/>//go:generate  mkdir -p ../../tododiff/extractsplice<br/>//go:generate  cp ../extractsplice/extractsplice.go ../../tododiff/extractsplice/extractsplice.go</span><span id="8f87" class="mj mk je nv b gy ol oe l of og"><strong class="nv jf">//go:generate  mkdir -p ../../tododiff/public/components</strong></span><span id="d2b6" class="mj mk je nv b gy ol oe l of og"><strong class="nv jf">//go:generate  cp ../public/components/vuetodo.js ../../tododiff/public/components/vuetodo.js</strong></span><span id="d7f3" class="mj mk je nv b gy ol oe l of og"><strong class="nv jf">//go:generate  metasplice -src=../templates/home.html -dest=../../tododiff/templates/home.diff.html -mode=extract</strong></span><span id="9d88" class="mj mk je nv b gy ol oe l of og"><strong class="nv jf">//go:generate  metasplice -src=../templates/home.vue.js -dest=../../tododiff/templates/home.vue.diff.js -mode=extract</strong></span><span id="1dba" class="mj mk je nv b gy ol oe l of og">//go:generate  metasplice -src=../extractsplice/extractsplice.go -dest=../../tododiff/applysplice/applysplice.go -mode=applyfile</span><span id="f39a" class="mj mk je nv b gy ol oe l of og">//go:generate cp -R ../.git ../../tododiff/.git</span><span id="8024" class="mj mk je nv b gy ol oe l of og">//go:generate  cp ../todos.sql ../../tododiff/applysplice/todos.sql</span></pre><p id="c5d6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">更新git以添加组件。</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="0a58" class="mj mk je nv b gy od oe l of og">git add .<br/>git commit -m "add vuetodo component"</span></pre><h2 id="e56e" class="mj mk je bd ml mm mn dn mo mp mq dp mr lc ms mt mu lg mv mw mx lk my mz na nb bi translated">提取唯一代码</h2><p id="0e71" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">在我们假设的工作流程中，我们已经定义了初始模式，然后我们基于该模式自动生成我们的项目，然后我们添加了一个全新的文件，并且还向生成的文件添加了代码。到目前为止还不错，但是现在假设我们认为现有的模式不足以满足我们接下来要做的事情？也许我们想添加一个我们的todos可以引用的事件记录。所以todos可以围绕一些特殊的事件来组织。通常，您必须更改您的模式，然后基于该模式手动更新所有代码层。CRUD模型、CRUD模型测试、api层、api测试、新的表格视图——然后测试/调试所有这些。我们要做一些不同的事情。我们只需将我们所有独特的工作保存到一个diff项目中，丢弃原始生成的代码，自动生成所有新代码，然后将我们独特的代码重新插入其中。让我们添加我们的假想事件模式。</p><p id="ec15" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">要创建diff项目，我们需要做的就是在extractsplice文件夹中运行<code class="fe ns nt nu nv b">go generate</code>。</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="61c7" class="mj mk je nv b gy od oe l of og">cd extractsplice<br/>go generate</span></pre><p id="64ef" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，如果我们进入新的diff项目tododiff，我们可以看到刚刚生成的内容:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/ac4c8a09e99ef88ae55ec0c815c1cd7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*G2yzM1cuGva6-PRMKyJpow.png"/></div></figure><p id="cb2a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">正如所料，它遵循了我们如上所述的extractsplice脚本，并捕获了我们所有独特的代码更改。我们现在可以将这些更改应用到新项目中。git repo也作为一个隐藏文件夹存在。</p><p id="a10c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果我们打开home.diff.html，我们可以看到基本的diff结构，它只是一个go嵌套文本模板，将应用于我们生成的代码的body部分。</p><p id="405e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">home.diff.html</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="c710" class="mj mk je nv b gy od oe l of og">package main</span><span id="8ab9" class="mj mk je nv b gy ol oe l of og">{[&lt; define "body" &gt;]}<br/>--&gt;<br/>&lt;todo-list class="mt-4"&gt;&lt;/todo-list&gt;<br/>&lt;!--{[&lt; end &gt;]}</span></pre><p id="6c90" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">请注意，metasplice会自动限定下一次插入时将使用的html注释。</p><p id="96be" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您还可以在applysplice目录中看到todos.sql。如上所述，metasplice不使用它，但它是进行更改和记录从中提取当前差异的模式的良好起点。</p><h2 id="b4ce" class="mj mk je bd ml mm mn dn mo mp mq dp mr lc ms mt mu lg mv mw mx lk my mz na nb bi translated">创建新项目</h2><p id="4681" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">现在我们有了diff项目，我们可以删除todo项目并重新开始。实际上，谨慎的做法是对其进行重命名——您可能弄乱了extractsplice.go文件，或者遗漏了某些内容。在这种情况下，只需修复extractsplice.go并重新创建diff项目(确保首先将项目重命名回原来的名称)。</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="6654" class="mj mk je nv b gy od oe l of og">mv todo todosave1<br/>cp tododiff/applysplice/todos.sql .</span></pre><p id="7c1f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在我们要改变我们的。sql文件来用事件反映我们的新模式</p><p id="8fcf" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">todos.sql</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="b1bc" class="mj mk je nv b gy od oe l of og"><strong class="nv jf">create table events (<br/>    id         integer generated always as identity primary key,<br/>    created_at timestamptz not null,<br/>    name       text not null,<br/>    type       integer not null,<br/>    event_date timestamptz not null<br/>);</strong></span><span id="8791" class="mj mk je nv b gy ol oe l of og">create table todos (<br/>    id           integer generated always as identity primary key,<br/>    updated_at   timestamptz not null,<br/>    done         boolean not null,<br/>    title        text not null<strong class="nv jf">,</strong><br/>    <strong class="nv jf">event_id     integer references events(id)</strong><br/>);</span></pre><p id="227c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">接下来，我们将以通常的方式生成一个新项目。</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="ad2a" class="mj mk je nv b gy od oe l of og">metaproj -sql=todos.sql -proj=todo -type=vue<br/>cd todo<br/>go generate<br/>go install</span></pre><p id="2e07" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当然所有的<code class="fe ns nt nu nv b"> go test</code>也应该通过。我们可以在todos_README中看到我们刚刚制作的新api。医学博士</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/10a2cc4edc9256b436aef93e86a0c8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Q327SzxLuNPSJNCR2PlIA.png"/></div></div></figure><p id="af37" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">该项目缺少我们所做的vue组件更改，我们将在下一步添加。</p><h2 id="5bec" class="mj mk je bd ml mm mn dn mo mp mq dp mr lc ms mt mu lg mv mw mx lk my mz na nb bi translated">将唯一代码应用于新项目</h2><p id="05a5" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">最后，我们到了有趣的部分。让我们使用metasplice将我们的diff文件应用到我们刚刚用新模式生成的项目中。</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="0d1a" class="mj mk je nv b gy od oe l of og">cd tododiff/applysplice<br/>go generate</span></pre><p id="7a86" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">它会抱怨找不到../todos.sql —这是因为我们更改了它的位置，在初始提取时将它放在applysplice目录下，只是为了保存一个副本。我们实际上并不想将它复制到我们的新项目中，因为生成的项目是正确的。如果这条消息困扰你，只需删除todo diff/apply splice/apply splice . go中的最后一行(自我提醒:修复这一点)</p><p id="2633" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">好，我们现在是最新的。请注意，我们的vue组件已经复制到public/components中，如果您查看一下templates/home.html和templates/home.vue.js，我们可以看到我们的拼接已经正确地应用到这些生成的文件中。此外，如果您在VS代码上设置了源代码控制，您将能够在该视图中看到所有的src差异。因为我们总是在新代码生成之前进行git提交，并且提取/应用保存它，所以这允许您只看到由生成器创建的更改——这是一个很好的健全性检查，表明一切都在按预期工作。让我们点燃它，看看会发生什么。</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="581c" class="mj mk je nv b gy od oe l of og">cd todo<br/>go install<br/>todo</span></pre><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/54e0faa09cd45341a2c33f66dd942afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUCmmClwZj6JO7mY61fsDQ.png"/></div></div></figure><p id="848e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">哎呀，当我们运行它时，我们的新组件出现了，但是它是空的并且不工作——这是怎么回事？记住，我们只是更改了todos模式，实际上是向events表中添加了一个引用列。所以我们当前在PostgreSQL中的todos表与我们的代码已经过时了。如果我们打开chrome控制台，果然有一个500错误告诉我们:<strong class="kv jf"> '"pq: column "event_id "不存在" '。</strong>易于修复，我们生成的create table api会在使用新模式重新创建表之前删除该表，这将修复问题(但会丢失所有测试数据):</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="5f6c" class="mj mk je nv b gy od oe l of og">curl -X DELETE <a class="ae lp" href="http://localhost:8000/api/todo/createtable" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/api/todo/createtable</a></span></pre><p id="aa57" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">刷新页面。因此，现在当我们发布或添加新的待办事项时，大家都很高兴:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi or"><img src="../Images/1cab76dbcb7bd908d51a8aa718cb967c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y6ryo7H818Gt3I4UpCIh7Q.png"/></div></div></figure><p id="25f9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们还可以使用我们的新api来发布一个事件，并在我们的todos中引用它。</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="9493" class="mj mk je nv b gy od oe l of og">curl -d '{"name":"Joan'\''s Party"}' -H "Content-Type: application/json" -X POST <a class="ae lp" href="http://localhost:8000/api/todo" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/api/e</a>vent</span></pre><p id="78dc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然后在我们的todo中引用它</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="ad58" class="mj mk je nv b gy od oe l of og">curl -d '{"done":false, "title":"Get Party Balloons", "eventid":{"int32":1, "valid":true}}' -H "Content-Type: application/json" -X POST <a class="ae lp" href="http://localhost:8000/api/todo" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/api/todo</a></span></pre><p id="835c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，当我们查看tables视图时，我们可以看到post api正在工作，todo.event_id正在引用我们的新事件:</p><figure class="mf mg mh mi gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/0741abf5af375e7f5ab10211c2a5c4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*baOYp3h4PBKKoJ-iLFB38g.png"/></div></div></figure><p id="3dc7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当然，我们的vuetodo组件还不知道event_id，大概我们现在会构建一个新的事件组件，然后更新todo组件。或许我们也可以让所有的时间戳都起作用。</p><h2 id="235f" class="mj mk je bd ml mm mn dn mo mp mq dp mr lc ms mt mu lg mv mw mx lk my mz na nb bi translated">元分裂</h2><p id="36a9" class="pw-post-body-paragraph kt ku je kv b kw nc kf ky kz nd ki lb lc ne le lf lg nf li lj lk ng lm ln lo im bi translated">我在以前的文章中介绍过metaapi和metaproj，让我们快速看一下新工具metasplice。Metasplice做三件事:</p><ol class=""><li id="47be" class="lq lr je kv b kw kx kz la lc ls lg lt lk lu lo nx lw lx ly bi translated">提取由#SPLICE#标记分隔的代码片段，并将它们转换成嵌套模板，称为diff文件</li><li id="7675" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo nx lw lx ly bi translated">从现有的extractsplice.go文件创建applysplice.go文件</li><li id="8be2" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo nx lw lx ly bi translated">将以前提取的diff文件应用于metaproj/metaapi生成的项目</li></ol><p id="3fe7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">metasplice/main.go</p><pre class="mf mg mh mi gt nz nv oa ob aw oc bi"><span id="0ff5" class="mj mk je nv b gy od oe l of og">package main</span><span id="7da5" class="mj mk je nv b gy ol oe l of og">import (<br/>    "errors"<br/>    "flag"<br/>    "fmt"<br/>    "io/ioutil"<br/>    "log"<br/>    "os"<br/>    "path/filepath"<br/>    "regexp"<br/>    "strings"<br/>    "text/template"<br/>)</span><span id="a6fe" class="mj mk je nv b gy ol oe l of og">func main() {<br/>    srcPtr := flag.String("src", "", "source file")<br/>    destPtr := flag.String("dest", "", "destination file")<br/>    modePtr := flag.String("mode", "splice", "mode: splice (default), extract, generator")</span><span id="01b0" class="mj mk je nv b gy ol oe l of og">    flag.Parse()<br/>    if flag.NFlag() == 0 {<br/>        fmt.Println(" valid usage is:")<br/>        //splice: default applies diff file to current source<br/>        fmt.Println("  metasplice -src=sourcefile.diff.go -dest=destinationfile.go")<br/>        fmt.Println("  metasplice -src=sourcefile.diff.go -dest=destinationfile.go -mode=splice")<br/>        //extract: create a new .diff.go from the splice points in the source<br/>        fmt.Println("  metasplice -src=sourcefile.go -dest=destinationfile.diff.go -mode=extract")<br/>        //applyfile: create the applysplice.go file from the extractsplice.go file<br/>        fmt.Println("  metasplice -src=extractsplice.go -dest=applysplice.go -mode=applyfile")<br/>        os.Exit(1)<br/>    }<br/>    if (filepath.Base(*srcPtr) == "") || (filepath.Base(*destPtr) == "") {<br/>        log.Panic("Invalid File Params")<br/>    }<br/>    fmt.Print("metasplice -src=", *srcPtr, " -dest=", *destPtr)<br/>    if *modePtr == "extract" {<br/>        fmt.Println(" -mode=extract")<br/>        //extract splices<br/>        err := extractFile(*srcPtr, *destPtr)<br/>        if err != nil {<br/>            log.Panic(err.Error())<br/>        }<br/>    } else if *modePtr == "applyfile" {<br/>        fmt.Println(" -mode=applyfile")<br/>        //make generate file<br/>        err := applyFile(*srcPtr, *destPtr)<br/>        if err != nil {<br/>            log.Panic(err.Error())<br/>        }<br/>    } else {<br/>        fmt.Println()<br/>        //apply splices<br/>        err := spliceFile(*srcPtr, *destPtr)<br/>        if err != nil {<br/>            log.Panic(err.Error())<br/>        }<br/>    }<br/>}</span><span id="e20b" class="mj mk je nv b gy ol oe l of og">//go through src, find all text between #SPLICE# tag ... #SPLICE# end and create template file<br/>func extractFile(src, dest string) error {<br/>    //get file type<br/>    ext := strings.TrimSpace(strings.ToLower(filepath.Ext(src)))<br/>    dat, err := ioutil.ReadFile(src)<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="ff72" class="mj mk je nv b gy ol oe l of og">    destPath := filepath.Dir(dest)<br/>    err = os.MkdirAll(destPath, os.FileMode(0755))<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="d5fd" class="mj mk je nv b gy ol oe l of og">    fout, err := os.Create(dest)<br/>    if err != nil {<br/>        return err<br/>    }<br/>    defer fout.Close()</span><span id="4d51" class="mj mk je nv b gy ol oe l of og">    //find splice tag for .go/.js and .html "\\#SPLICE# foo ", or "&lt;!--#SPLICE# foo --&gt;"<br/>    re1 := regexp.MustCompile(`(\/\/\s*#SPLICE#\s+\w+.*|&lt;!--\s*#SPLICE#\s+\w+\s+--&gt;)`)<br/>    //find the tagname within a splice tag<br/>    re2 := regexp.MustCompile(`#SPLICE#\s+(\w+)`)</span><span id="87fe" class="mj mk je nv b gy ol oe l of og">    //FindAllIndex returns array of pair: [index of string start and index 1 past end]<br/>    idx := re1.FindAllIndex(dat, -1)<br/>    _, err = fout.WriteString("package main\n")<br/>    if err != nil {<br/>        return err<br/>    }<br/>    splicestart := 0<br/>    splicename := "end"<br/>    for _, v := range idx { //go through each pair of FindAllIndex<br/>        subdat := dat[v[0]:v[1]]</span><span id="1a75" class="mj mk je nv b gy ol oe l of og">        loc := re2.FindSubmatchIndex(subdat)<br/>        if (len(loc) == 0) || (loc[3]-loc[2] == 0) {<br/>            err = errors.New("No tagname detected after #SPLICE#")<br/>            return err<br/>        }<br/>        tagname := string(subdat[loc[2]:loc[3]]) //regex submatch<br/>        if tagname == "end" {                    //if tagname is "end" write the template splice tag name &amp; splice code<br/>            if splicename == "end" {<br/>                err = errors.New("No beginning splice name detected")<br/>                return err<br/>            }<br/>            _, err = fout.WriteString("{[&lt; define \"" + splicename + "\" &gt;]}\n")<br/>            if err != nil {<br/>                return err<br/>            }<br/>            if ext == ".html" { //if html then cap off the multiline comment<br/>                _, err = fout.WriteString("--&gt;\n")<br/>                if err != nil {<br/>                    return err<br/>                }<br/>            }<br/>            _, err = fout.WriteString(string(dat[splicestart:v[0]]) + "\n") //up to beginning of end splice<br/>            if err != nil {<br/>                return err<br/>            }</span><span id="a4f7" class="mj mk je nv b gy ol oe l of og">            if ext == ".html" { //cap on both sides<br/>                _, err = fout.WriteString("\n&lt;!--")<br/>                if err != nil {<br/>                    return err<br/>                }<br/>            }<br/>            _, err = fout.WriteString("{[&lt; end &gt;]}\n")<br/>            if err != nil {<br/>                return err<br/>            }<br/>        } else { //otherwise capture the splice code start and tagname<br/>            splicestart = v[1] //start after tag<br/>            splicename = tagname<br/>        }<br/>    }<br/>    fout.Sync() //all done<br/>    return err<br/>}</span><span id="4704" class="mj mk je nv b gy ol oe l of og">//create the applysplice.go file from the extractsplice.go file<br/>func applyFile(src, dest string) error {<br/>    dat, err := ioutil.ReadFile(src)<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="84e6" class="mj mk je nv b gy ol oe l of og">    destPath := filepath.Dir(dest)<br/>    err = os.MkdirAll(destPath, os.FileMode(0755))<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="c0ff" class="mj mk je nv b gy ol oe l of og">    fout, err := os.Create(dest)<br/>    if err != nil {<br/>        return err<br/>    }<br/>    defer fout.Close()</span><span id="c9cb" class="mj mk je nv b gy ol oe l of og">    re := regexp.MustCompile(`go:generate.+\n`)<br/>    idx := re.FindAllIndex(dat, -1)<br/>    destName := ""<br/>    srcName := ProjName()<br/>    _, err = fout.WriteString("package splice\n\n")<br/>    if err != nil {<br/>        return err<br/>    }<br/>    for _, v := range idx {<br/>        //todo: switch to regex instead of fields<br/>        fields := strings.Fields(string(dat[v[0]:v[1]]))<br/>        switch fields[1] {<br/>        case "mkdir":<br/>            if destName == "" {<br/>                destName = DestName(fields[len(fields)-1])<br/>            }<br/>            str := "//go:generate mkdir -p "<br/>            str += strings.Replace(fields[len(fields)-1], destName, srcName, 1) + "\n"<br/>            _, err = fout.WriteString(str)<br/>            if err != nil {<br/>                return err<br/>            }<br/>        case "cp":<br/>            str := "//go:generate cp "<br/>            if fields[len(fields)-3] != "cp" { //preserve a single cp flag if exists (like -R)<br/>                str += fields[len(fields)-3] + " "<br/>            }<br/>            str += fields[len(fields)-2] + " "<br/>            str += strings.Replace(fields[len(fields)-1], destName, srcName, 1) + "\n"<br/>            _, err = fout.WriteString(str)<br/>            if err != nil {<br/>                return err<br/>            }<br/>        case "metasplice":<br/>            if fields[len(fields)-1] == "-mode=applyfile" {<br/>                break<br/>            }<br/>            str := "//go:generate metasplice "<br/>            li := strings.LastIndex(fields[2], ".")<br/>            str += fields[2][:li] + ".diff" + fields[2][li:] + " "<br/>            s := strings.Replace(fields[3], destName, srcName, 1)<br/>            str += strings.Replace(s, ".diff", "", 1) + "\n"<br/>            _, err = fout.WriteString(str)<br/>            if err != nil {<br/>                return err<br/>            }<br/>        }<br/>    }<br/>    fout.Sync() //all done<br/>    return err<br/>}</span><span id="7f68" class="mj mk je nv b gy ol oe l of og">//execute the nested template splice file against the commented template invocation in dest, specific delims<br/>func spliceFile(src, dest string) error {<br/>    destb, err := ioutil.ReadFile(dest)<br/>    if err != nil {<br/>        return err<br/>    }</span><span id="70fd" class="mj mk je nv b gy ol oe l of og">    tt := template.Must(template.New("dest").Delims("{[&lt;", "&gt;]}").Parse(string(destb)))<br/>    template.Must(tt.New("src").Delims("{[&lt;", "&gt;]}").ParseFiles(src))</span><span id="2930" class="mj mk je nv b gy ol oe l of og">    file, err := os.Create(dest)<br/>    if err != nil {<br/>        return err<br/>    }<br/>    err = tt.ExecuteTemplate(file, "dest", nil)<br/>    file.Close()<br/>    return err<br/>}</span><span id="e1f9" class="mj mk je nv b gy ol oe l of og">//assume that src path always ends in /extractsplice under project<br/>func ProjName() string {<br/>    wd, _ := os.Getwd()<br/>    li := strings.LastIndex(wd, "/extractsplice")<br/>    fi := strings.LastIndex(wd[:li], "/")<br/>    return wd[fi+1 : li]<br/>}</span><span id="6e55" class="mj mk je nv b gy ol oe l of og">//asssume a mkdir that ends in /destname as first line<br/>func DestName(path string) string {<br/>    li := strings.LastIndex(path, "/")<br/>    return (path[li+1:])<br/>}</span></pre><p id="7263" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">extractFile函数使用regex来查找#SPLICE#标记，并获取这些标记中的标记名。applyFile函数也使用regex来查找go:generate语句，并做出一些假设，如最后两个函数ProjName()和DestName()所示。spliceFile函数是一个简单的文本模板应用程序，请注意，它希望非常具体的分隔符(" {[]} ")不会与metaapi分隔符("&lt;&gt; ")或默认的go分隔符(" {{ "，" }} ")冲突。</p><p id="2fc6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">用了一段时间后，我自然会改变/改进很多东西。例如，使用嵌套模板作为拼接机制起初看起来很聪明和方便，但现在看起来有局限性——虽然现在它完成了我需要的工作。自动化更多的extractsplice.go维护也是列表中的重点。</p><p id="20cc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们已经完成了开发流程的一个周期，meta*工具为我们做了大部分的苦差事——管理细节，这样我们就可以专注于高层次的独特设计。这是一个非常简单的拼接示例，但是在代码中有足够多的拼接点，您可以拼接到这些拼接点中来执行更重要的任务，例如添加到main init、添加到routes，甚至扩展单个api结构。当然，您还可以在任何地方添加更多拼接点。</p><p id="196b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可以在以下网址找到所有源代码:</p><ul class=""><li id="a4e5" class="lq lr je kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated"><a class="ae lp" href="https://github.com/exyzzy/metaapi" rel="noopener ugc nofollow" target="_blank">https://github.com/exyzzy/metaapi</a></li><li id="990a" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">https://github.com/exyzzy/metaproj<a class="ae lp" href="https://github.com/exyzzy/metaproj" rel="noopener ugc nofollow" target="_blank"/></li><li id="eda0" class="lq lr je kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">【https://github.com/exyzzy/metasplice T4】</li></ul><p id="a729" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">玩得开心。</p></div></div>    
</body>
</html>