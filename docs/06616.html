<html>
<head>
<title>The mystery of session timeout in ASP.NET Core 3.1 &amp; 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP.NET核心3.1 &amp; 5中会话超时之谜</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-mystery-of-session-timeout-in-asp-net-core-3-1-5-70bb854fe168?source=collection_archive---------1-----------------------#2020-12-13">https://levelup.gitconnected.com/the-mystery-of-session-timeout-in-asp-net-core-3-1-5-70bb854fe168?source=collection_archive---------1-----------------------#2020-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/91ca969aa54751386c6d0dcb245e6958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CC6coTZI82Hyb8fF.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">https://pixabay.com/images/id-2910951/<a class="ae kc" href="https://pixabay.com/images/id-2910951/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><h2 id="8c86" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">一点历史和怀旧</h2><p id="5436" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">嗯，我怀念过去的日子，那时一切都很简单，没有太多的方法来完成某项任务。现在，有很多图书馆在做类似的事情。大多数软件应用程序涉及许多抽象层，这些抽象层应该使事情变得简单，并促进不重新发明轮子的概念。</p><p id="ec0a" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我最近将. NET Core 3.1 web应用程序升级到了。净5。升级本身非常简单明了。升级后，有一些警告说<strong class="lb ir"> Azure AD </strong>认证库已经过时，应该由<strong class="lb ir">微软取代。Identity.Web </strong>。</p><p id="ec86" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">好吧，没什么大不了的。让我们开始吧。切换新库也很容易，但之后我开始注意到用户会话没有像以前那样过期。不清楚发生了什么变化或者根本原因是什么。可能是升级到。NET 5或微软的<strong class="lb ir">。Identity.Web </strong>。我不知道，并希望深入了解是什么控制会话超时/持续时间，以及如果默认设置不适合我的应用程序要求，如何调整它。</p><p id="d6c7" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">在过去快乐的日子里，检查或调整会话超时是<code class="fe lz ma mb mc b">web.config</code>中的一行代码，但现在它变得更加复杂。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="4433" class="kd ke iq mc b gy ml mm l mn mo">&lt;system.web&gt;<br/>    &lt;sessionState mode="InProc" timeout="20"&gt;&lt;/sessionState&gt;<br/>&lt;/system.web&gt;</span></pre><p id="2f59" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">会话状态通常存储在服务器在身份验证过程中创建的cookie中，然后发送到浏览器。这个cookie有几个比特的信息，一个比特是时间戳，告诉会话何时到期。还有滑动过期因素，但让我们忽略它，当没有滑动过期时，我们的讨论集中在会话超时上。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h2 id="c1c1" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Azure AD家政服务</h2><p id="d0fb" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">是时候接触一些代码了，因为我非常喜欢边做边学。我将要研究的应用程序使用Azure AD对用户进行身份验证。您将需要一个Azure AD实例来为我们将创建的应用程序创建应用程序注册。</p><p id="e382" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">按照<strong class="lb ir">步骤1:注册您的应用程序</strong><strong class="lb ir"/>部分的<a class="ae kc" href="https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-v2-aspnet-core-webapp" rel="noopener ugc nofollow" target="_blank">这个微软文档页面</a>创建一个应用程序注册。</p><p id="eade" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir"> P.S. </strong>最新版本的VS代码使用端口5001服务。NET核心web应用程序。所以建议将上述指南中的任何端口引用更改为5001。</p><p id="6faf" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">请注意以下事项:</p><ul class=""><li id="c83f" class="mw mx iq lb b lc lu lg lv km my kq mz ku na lt nb nc nd ne bi translated">域名(可能看起来像<code class="fe lz ma mb mc b">some-domain@onmicrosoft.com</code>)。在Azure广告概览页面中，它将是标题为“租户信息”的框中的主要域。</li><li id="3e62" class="mw mx iq lb b lc nf lg ng km nh kq ni ku nj lt nb nc nd ne bi translated">租户Id(这是您的Azure AD实例的唯一标识符)</li><li id="42a5" class="mw mx iq lb b lc nf lg ng km nh kq ni ku nj lt nb nc nd ne bi translated">应用程序Id</li></ul><h2 id="985f" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">创造。网芯3.1应用</h2><p id="42db" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">您需要最新版本的VS Code plus。NET 3.1 &amp; 5 SDKs。如果你的电脑上还没有这些软件，谷歌搜索会帮助你下载并安装它们。本文中概述的步骤是针对Windows机器的，但我想说它们在Linux或Mac上的工作应该是差不多的。</p><p id="68e7" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">打开一个新的终端窗口，运行下面的程序来引导一个. NET Core 3.1应用程序，它通过Azure AD的认证。用您自己设置的值替换方括号中的值。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="bdb7" class="kd ke iq mc b gy ml mm l mn mo">dotnet new mvc --auth SingleOrg --domain [DOMAIN-NAME] --tenant-id  [TENTANT-ID] --client-id [CLIENT-ID]--framework netcoreapp3.1 --language C# --name MyApp3.1</span></pre><p id="76b4" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">使用VS代码打开新创建的名为<strong class="lb ir"> MyApp3.1 </strong>的文件夹，点击Ctrl+F5运行web应用程序。如果VS代码提示选择环境类型，选择<strong class="lb ir">。网芯</strong>。如果事情按预期进行，你将被自动重定向到Azure广告登录屏幕。为Azure AD实例中的任何用户提供有效凭据，您将被重定向到应用程序主页。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/8cd826e599c603c623dc3028530ec649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lboK2mHma4fTGUxbx12T9g.png"/></div></div></figure><p id="27b8" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">你可以在这里阅读更多关于OAuth2和隐性资助流<a class="ae kc" href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-implicit-grant-flow?WT.mc_id=Portal-Microsoft_AAD_RegisteredApps" rel="noopener ugc nofollow" target="_blank">的内容。为了简单起见，我们只需要知道，一旦用户通过Azure AD的身份验证，就会在</a><a class="ae kc" href="https://localhost:5001/signin-oidc" rel="noopener ugc nofollow" target="_blank">https://localhost:5001/sign in-oidc</a>触发一个表单post，其中提交的表单数据包含一个ID令牌和一些额外的验证字段。您可以使用浏览器开发工具来检查这个网络调用。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/48072fcf355d05bc868ee6f27dfc29d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tYCU3skeXbXj7PZzNnZeCg.png"/></div></div></figure><p id="be6b" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">复制<strong class="lb ir"> id_token </strong>表单字段的值，并在<a class="ae kc" href="https://jwt.io" rel="noopener ugc nofollow" target="_blank"> https://jwt.io </a>上解码</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/99b82a6e453f682566417d9d9cbdb5d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUXeuBnGUYBcIrNOTl5K0g.png"/></div></div></figure><p id="087b" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">上面的模糊字段分别包含您的Azure AD应用客户端Id和租户Id。然后有三个时间戳。前两个是在“发布”时间和“不在之前”时间令牌。两者具有相同的值，比实际令牌发布时间早5分钟。我猜这是为了解决全球不同机器上的时钟差异。</p><p id="c896" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">名为“exp”的最终时间戳是令牌的到期时间。在我们的例子中，这是令牌发布时间之后的一个小时(忽略5分钟的事情)。</p><p id="919b" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我们在这里得到了第一点信息。Azure AD id令牌(使用默认配置)有一个小时的过期时间。记住这个事实，因为我们很快就会用到它。</p><p id="47d0" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">答。使用Azure AD进行身份验证的NET Core 3.1 web应用程序对<strong class="lb ir"> Microsoft有一个nuget依赖项。AspNetCore . authentic ation . azuread . ui</strong>。这个图书馆是同一个图书馆的一部分。GitHub上的NET Core回购。请记住这一点。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/f62702e6e2628bb48167042120221dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cPw9vobm5CCHA59emq_hoA.png"/></div></div></figure><h2 id="e288" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">设置VS代码以单步执行外部代码</h2><p id="cc87" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">。NET Core是一项在GitHub上开发的开源技术，拥有令人惊叹的社区和工具。有一个很酷的特性可以帮助我们，那就是使用微软符号服务器单步执行框架代码的能力。要启用该功能，请按如下方式编辑<code class="fe lz ma mb mc b">.vscode/launch.json</code>文件。更多细节请看<a class="ae kc" href="https://devblogs.microsoft.com/dotnet/improving-debug-time-productivity-with-source-link/#visual-studio-code" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/6cb789fb3587c2e5e8010b8f9d455e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t5mFRA9IpljkvM5T1Cuwpg.png"/></div></div></figure><p id="980d" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">现在点击F5(不是Ctrl+F5)以调试模式启动应用程序。一切都应该像以前一样工作，但是您将在调试控制台窗口中看到许多行，显示从Microsoft参考服务器下载文件，或者如果已经从以前的调试会话下载了文件，则从本地文件夹加载文件。也要有耐心，加载所有依赖项需要一点时间，但投资回报是值得的。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/d51f5e8eee59e3658a579517bca22e0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hQOrMX2bujw4YdUNruiCOA.png"/></div></div></figure><p id="54f3" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">在深入研究源代码之前，让我们在浏览器中检查会话cookie。加载并登录应用程序后，打开浏览器开发工具(通常按F12即可)。切换到应用程序选项卡，展开侧菜单中的Cookies链接，然后单击带有我们的应用程序URL的行。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/d3fdec4f9f2297b3c9378255e344e7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O9k3f3TjSZgxmNtt0bo8wA.png"/></div></div></figure><p id="5f51" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">有两个cookies，一个用于用户会话信息，一个用于Azure应用洞察。会话cookie没有显式的过期/最长期限属性。这是一个会话cookie，而不是一个<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies" rel="noopener ugc nofollow" target="_blank">持久/永久cookie </a>。如果浏览器关闭，它将被删除。如果浏览器保持打开，关于会话何时到期的信息被注入到cookie内容中，但是是以只有服务器可读的加密形式。</p><h2 id="76d2" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">检查会话cookie的内容</h2><p id="d279" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">如果会话仍处于打开状态，请按Shift+F5停止调试会话。现在在VS代码中打开调试窗口，并在<code class="fe lz ma mb mc b">CookieAuthenticationHandler</code>类构造函数上添加一个断点。当您将鼠标悬停在断点部分时，可以通过单击出现的+号来添加断点。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/78ce28ffae65878cf42bdfd60308201b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*rjhDX4EYtjN3i1gkYcABUA.png"/></div></figure><p id="2867" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我发现将某个类强制加载到调试器会话中是一个很好的技巧。现在点击F5，让我们开始调试。</p><p id="f841" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">应该命中断点。恭喜你，你可以单步进入ASP.NET核心源代码，自己研究东西，甚至在同一个类的其他行上应用其他断点。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/d1cf2b06bf3848dcf9f5ea040315acd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YKOP4kmdWtDHkbzhevL4A.png"/></div></div></figure><p id="61cb" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我可以就此打住，让你来做回溯，戴上夏洛克·福尔摩斯的帽子，但我愿意和你一起继续这段旅程。在同一个文件中，搜索包含此内容的行，并在其上放置一个断点。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="c7c7" class="kd ke iq mc b gy ml mm l mn mo">return AuthenticateResult.Success(ticket);</span></pre><p id="0f51" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">添加这个断点可以使用传统的方法，单击行号的左边，然后按F5键继续。第二个断点将被命中，我们可以在手表中添加<code class="fe lz ma mb mc b">ticket</code>变量来检查它。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/7a7574345eeeaaba903d172f4b02dc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3UwpRjsfc9nrkO0s7O6ssQ.png"/></div></div></figure><p id="f20e" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">很好，我们可以看到会话cookie的所有原始细节(假设用户已经过身份验证)并检查各个值。会话超时不再是一个谜，您可以确定会话超时的确切值，它是上面检查的票证变量的<code class="fe lz ma mb mc b">ExpiresAt</code>属性。一旦您意识到真正的会话超时值，您就可以更深入地挖掘并理解它为什么有这个特定值。如果您就此打住，确切地知道应用程序应该如何运行仍然是有价值的。</p><blockquote class="nu nv nw"><p id="0222" class="kz la nx lb b lc lu le lf lg lv li lj ny lw ll lm nz lx lo lp oa ly lr ls lt ij bi translated">由于HTTP管道的复杂性、多个移动部分以及身份验证过程中如此多的抽象层，可能很难仅从文档或在线资源中判断某个应用程序的会话超时值应该是多少。当使用不同的身份验证方法(如Identity Server或)时，可以使用这里概述的方法。NET Core内置身份识别功能。</p></blockquote><h2 id="649d" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">解释一小时的课程</h2><p id="04d7" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">让我们继续使用相同的调试器技术，并尝试理解为什么会话持续一个小时。我猜你可能认为这与从Azure AD收到的id令牌的持续时间有关。</p><p id="9eb9" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">你是100%正确的，但是让我们证明它。从现在开始，我会变得不那么啰嗦。</p><p id="379b" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">如果当前调试会话仍处于打开状态，则停止该会话，并添加以下新断点:</p><ul class=""><li id="5032" class="mw mx iq lb b lc lu lg lv km my kq mz ku na lt nb nc nd ne bi translated"><code class="fe lz ma mb mc b">AzureADOpenIdConnectOptionsConfiguration</code>的构造函数然后一旦命中就在<code class="fe lz ma mb mc b">Options.UseTokenLifetime = true;</code>行添加一个断点</li><li id="c4d5" class="mw mx iq lb b lc nf lg ng km nh kq ni ku nj lt nb nc nd ne bi translated"><code class="fe lz ma mb mc b">OpenIdConnectHandler </code>的构造函数然后在以<code class="fe lz ma mb mc b">private ClaimsPrincipal ValidateToken</code>开始的行上添加一个断点</li></ul><p id="112d" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我将解释您通常会从调试会话中得到什么。<strong class="lb ir">微软。AspNetCore . authentic ation . azuread . ui</strong>库(是ASP.NET核心回购的一部分)将名为<strong class="lb ir"> UseTokenLifetime </strong>的<strong class="lb ir"> OpenID Connect </strong>配置选项设置为true <strong class="lb ir">。</strong>此标志指示cookie管道获取id令牌持续时间，并使用它来控制会话持续时间。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/6743a0f2278c2b49c91b77beb4dedd92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRbZeouz1ncJKGw5SoGBEQ.png"/></div></div></figure><p id="8818" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><code class="fe lz ma mb mc b">OpenIdConnectHandler</code>类中的<code class="fe lz ma mb mc b">ValidateToken</code>方法检查<strong class="lb ir"> UseTokenLifetime </strong>属性，如果为真，它会将属性包(稍后用于控制会话持续时间)中的值设置为从身份提供者(在我们的示例中为Azure AD)检索的id令牌的持续时间。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/2d345f9d0bd452b2ddea99e08a846f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qk4z1WwLASB63ytVuuzZLw.png"/></div></div></figure><p id="6de6" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">这解释了在. NET Core 3.1 web应用程序中使用Azure AD时一个小时的会话持续时间。</p><h2 id="ed73" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">正在升级到。网络5</h2><p id="b5d1" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">现在，假设我们想使用闪亮的玩具并升级到。NET 5，并将Azure广告认证库升级到最新版本。该项目将编译，但我们会得到一些警告。AspNetCore . authentic ation . azuread . ui已经过时，我们应该升级到<strong class="lb ir">微软。Identity.Web </strong>实际上是在ASP.NET核心回购协议之外托管的。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/0096214dc35299c286457930427eabc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8UP0MUm3EAF3_cM04PXVkg.png"/></div></div></figure><p id="908f" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我们可以继续调整代码来进行升级，但我们也可以使用<code class="fe lz ma mb mc b">dotnet new</code>命令，选择ASP.NET 5模板，该模板带有对<strong class="lb ir">微软的nuget引用。Identity.Web </strong>并具有所需的管道设置。</p><p id="2b90" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">在终端窗口中运行下面的代码片段，它与前面的运行非常相似，但是具有不同的项目名称和目标框架。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="322c" class="kd ke iq mc b gy ml mm l mn mo">dotnet new mvc --auth SingleOrg --domain [DOMAIN-NAME] --tenant-id  [TENTANT-ID] --client-id [CLIENT-ID]--framework <strong class="mc ir">net5.0</strong> --language C# --name <strong class="mc ir">MyApp5.0</strong></span></pre><p id="9b6a" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">从VS代码运行新的web应用程序，并确保它像以前一样通过Azure AD验证。网芯3.1 app。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/33e1e99b25198fac95f6d52a919fe0ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDVlRxv1gKmSI8jCUUPjAQ.png"/></div></div></figure><p id="12b5" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">您可以验证项目文件是否引用了。NET 5目标框架和<strong class="lb ir"> Microsoft.Identity.Web. </strong></p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/740f6bd52aa5f3d37a3a6cb00fbbf686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2sKYWTZA0G2GBpHMsooYg.png"/></div></div></figure><h2 id="b8d2" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">升级后的应用程序的会话持续时间是多长？</h2><p id="a9d2" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">您可以使用与。NET Core 3.1应用程序来查找会话持续时间。NET 5 app。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/7fbb644f908537815271c4205139a94f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6tt_dEujlLvpfnmqHiV-A.png"/></div></div></figure><p id="c91c" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir">惊喜！</strong></p><p id="7e18" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">会话持续时间现在是14天。这与最初的一小时会议有很大的不同。但是为什么呢？是不是和……NET 5或由于对<strong class="lb ir">Microsoft . identity . web .</strong>的更改</p><p id="6f0d" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">不幸的是<strong class="lb ir">微软。Identity.Web </strong>不属于。NET Core repo，因此它的调试信息可能在Microsoft Symbol服务器上不可用。不过，它是开源的，我们可以在本地提取回购协议进行检查，或者直接在GitHub上检查源代码。</p><p id="feec" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><a class="ae kc" href="https://github.com/AzureAD/microsoft-identity-web/blob/00bb0a87f7c4583b3c4aed7763fba019209c22e6/src/Microsoft.Identity.Web/WebAppExtensions/MicrosoftIdentityWebAppAuthenticationBuilderExtensions.cs#L408" rel="noopener ugc nofollow" target="_blank">https://github . com/AzureAD/Microsoft-identity-web/blob/00 bb 0a 87 f 7 c 4583 B3 C4 aed 7763 FBA 019209 c22e 6/src/Microsoft。identity . Web/webapp extensions/microsoftidentitywebappauthenticationbuilderextensions . cs # L408</a></p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/79011abfb7ca213ab9f9cec2b72d1986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IqulpfSsknS5g8bSPJ5xw.png"/></div></div></figure><p id="0550" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir"> UseTokenLifetime </strong>不是被初始化为硬编码的true，而是被初始化为源自另一个名为<strong class="lb ir">Microsoft identity options</strong>的类的值，该类继承自<strong class="lb ir"> OpenIdConnectOptions。</strong>似乎除非显式设置该值，否则它将默认为布尔变量的默认值，即false。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/9b6565c23fdd170606a09ce51e59a8eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgHKc2Hty-7AM31oTGwfXw.png"/></div></div></figure><p id="f7db" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">好的，这意味着会话持续时间不再与id令牌到期挂钩。那么，现在是什么在控制它呢？</p><p id="c72a" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">在默认配置中，有一个用于设置cookie身份验证选项的类，它将cookie的到期时间默认设置为14天。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/b0ead3f1c3e5de6b2d71eed6518bff2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0wODz_2ZWoDSxcl7CM1MMQ.png"/></div></div></figure><p id="970d" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">这用于指定到期值，该值将在以后分配给会话cookie到期属性，因此将会话持续时间设置为14天(请记住，我忽略了滑动到期，尽管它默认为true)。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/90ecb509276f8233b085cee28a215424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pR15KH4yFD9_3PE526rSMQ.png"/></div></div></figure><h2 id="129f" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">我们被困在14天了吗？</h2><p id="1e1a" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">不，我们可以将会话持续时间调整为对用例有意义的任何值。假设会话持续时间应该是一天。在引导身份验证管道时，我们可以使用另一个重载来为会话持续时间或滑动过期等设置设置自定义值。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/037e3fcc0bfd98ea3b72aca975aa907e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-At1sRPD9nQqETBYx68FaQ.png"/></div></div></figure><p id="6b93" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">如果您现在检查会话cookie，它应该会反映上述更改。</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/7df31c7380367bfdf2a9cda81128060e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1c6hoZ5xGGbuz5ZichMyhA.png"/></div></div></figure><p id="a2fd" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我不确定旧的Azure广告认证库是否有类似的工具来调整会话超时或什么。实际上自从我升级到。微软。Identity.Web ，我不需要尝试调整旧的库。</p><h2 id="5797" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">包裹</h2><p id="160b" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">有时文档在某些方面不是很明显，或者库/框架在短时间内变化很快。因此，关注在线资源可能会造成混乱，而不是有所帮助。在本文中，我希望我已经阐明了ASP.NET核心应用程序中如何控制会话超时，以及如果您想100%确定幕后发生了什么，如何排除故障或调查低级应用程序行为。</p><p id="773b" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我认为有某种方法可以为像<strong class="lb ir">微软这样的库包含调试符号。但是那是另一天的挑战。</strong></p><h2 id="cac3" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">进一步阅读</h2><ul class=""><li id="3ce6" class="mw mx iq lb b lc ld lg lh km ok kq ol ku om lt nb nc nd ne bi translated"><a class="ae kc" href="https://www.cloudidentity.com/blog/2016/07/25/controlling-a-web-apps-session-duration-2/" rel="noopener ugc nofollow" target="_blank">https://www . cloud identity . com/blog/2016/07/25/controlling-a-web-apps-session-duration-2/</a></li><li id="9255" class="mw mx iq lb b lc nf lg ng km nh kq ni ku nj lt nb nc nd ne bi translated"><a class="ae kc" href="https://github.com/aspnet/Security/issues/147" rel="noopener ugc nofollow" target="_blank">https://github.com/aspnet/Security/issues/147</a></li><li id="c53a" class="mw mx iq lb b lc nf lg ng km nh kq ni ku nj lt nb nc nd ne bi translated"><a class="ae kc" href="https://github.com/aspnet/Security/issues/1177#issuecomment-294162446" rel="noopener ugc nofollow" target="_blank">https://github . com/aspnet/Security/issues/1177 # issue comment-294162446</a></li></ul></div></div>    
</body>
</html>