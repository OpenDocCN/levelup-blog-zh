<html>
<head>
<title>AEM: 5 Best practices for overlays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AEM:覆盖层的5个最佳实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/aem-5-best-practices-for-overlays-4babcbbb8a80?source=collection_archive---------1-----------------------#2019-11-13">https://levelup.gitconnected.com/aem-5-best-practices-for-overlays-4babcbbb8a80?source=collection_archive---------1-----------------------#2019-11-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="40f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何像老板一样叠加</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3312ec2ea6aada9f27b73a866c035598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Vd-wc9W8TFe30SwppnCEA.png"/></div></div></figure><p id="5279" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">AEM提供了两种定制OOTB资源的方法:</p><ol class=""><li id="33a4" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated"><strong class="kw iu">覆盖</strong>，允许<em class="lz">重新定义</em>现有资源(即:替换当前行为)。</li><li id="ca82" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated"><strong class="kw iu">覆盖</strong>，允许您<em class="lz">扩展</em>现有资源(即:添加新行为)。</li></ol><p id="e662" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文假设您已经使用了覆盖，并将讨论这样做的一些最佳实践。如果你不清楚覆盖是如何工作的，或者它们与覆盖有什么不同，我推荐Adobe的<a class="ae mf" href="https://helpx.adobe.com/experience-manager/6-5/sites/developing/using/sling-resource-merger.html" rel="noopener ugc nofollow" target="_blank">这篇文章或者aemvardhan 的</a>覆盖和覆盖的比较，其中包括一个快速教程。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="9910" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">外科覆盖物</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/832f31b216bd5277152b24bc7cc8e534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQLyeihLNmUYDSEvQZvhQA.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">照片由<a class="ae mf" href="https://unsplash.com/@darksidoo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">贾法尔·艾哈迈德</a>在<a class="ae mf" href="https://unsplash.com/s/photos/surgery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ce7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">“最好的代码是没有代码”——这是你经常会在文章中读到的，比如<em class="lz">如何成为一名高级程序员</em>或<em class="lz">如何像10x开发人员一样编程的7个技巧</em>或<em class="lz">如何获得一艘游艇并使用Java勾引超级模特</em>...你明白了。你做的所有东西都可能坏掉，你写的每一行都需要维护，任何开发都是如此，AEM也不例外。</p><p id="56e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">减少覆盖影响的关键是理解AEM中的Sling资源合并，它发生在节点级和属性级。AEM将获取<code class="fe nk nl nm nn b">/libs</code>的内容，并仅覆盖<em class="lz">您在</em> <code class="fe nk nl nm nn b">/apps</code>中指定的节点和属性。</p><p id="06d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个节点级资源合并的例子(灰色的<code class="fe nk nl nm nn b">/libs</code>，绿色的<code class="fe nk nl nm nn b">/apps</code>):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/105aa1d3b4f4e94c9c3625577733546c.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*caXj3e8Jikns8jRby88Znw.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">在节点级别合并资源</figcaption></figure><p id="a1fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，要向<code class="fe nk nl nm nn b">1</code>添加一个<code class="fe nk nl nm nn b">B</code>节点，没有必要复制节点<code class="fe nk nl nm nn b">1/A</code>，因为AEM会从<code class="fe nk nl nm nn b">/libs</code>中获取它。但是节点<code class="fe nk nl nm nn b">1</code>的属性呢？如果你不指定它们，它们也会从<code class="fe nk nl nm nn b">/libs</code>中获取:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/a2239b71f23aff770164c0fbb1a8c7e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*2GziNtERAgRDgXnDIH4Lhg.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">财产层面的资源合并</figcaption></figure><p id="a26a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着，要使你的覆盖“外科手术”,你应该只覆盖那些你实际上需要改变的节点和属性，而把其余的留为空白。</p><p id="a07a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过将整个子树从<code class="fe nk nl nm nn b">/libs</code>复制到<code class="fe nk nl nm nn b">/apps</code>来改变一些属性，使覆盖变得太“大”了。)有时是由AEM开发新手和有老版本CQ或AEM经验的人来完成的，这导致了更难维护的开发。如果将来的升级在复制到<code class="fe nk nl nm nn b">/apps</code>的子树中的<code class="fe nk nl nm nn b">/libs</code>下做了改变，那么这些改变将会被埋没在“覆盖层”下，你将不会从中受益。</p><p id="e48b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要轻松创建手术覆盖，请使用CRX DE中的<em class="lz">覆盖节点</em>功能，右键单击树中的节点即可进入:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/0fc648879544404ebfcd5a7538374dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*RfmniHwWx2ktUVfRqO32uA.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">CRX德的覆盖节点特征</figcaption></figure><p id="6099" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将创建一个覆盖图，其中包含:</p><ul class=""><li id="9fd6" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nr lw lx ly bi translated">有问题的节点及其所有属性</li><li id="65dc" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp nr lw lx ly bi translated">一系列空节点用来创建<code class="fe nk nl nm nn b">/apps</code>下的路径</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="3ec7" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">避免重叠文件</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/566037604a27d346ddffa61835b3b7bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*utGi74FmQem9f96UZYxT3w.jpeg"/></div></div></figure><p id="d932" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于资源合并的主题:它存在于节点和节点属性，但<em class="lz">不存在于文件内容</em>。这意味着，为了更改JS脚本中的一行，您必须覆盖整个文件(有时有数百或数千行)。如果此文件在将来的升级中发生了更改，您将看不到这些更改，直到您修补覆盖图(即:将Adobe对文件的更改与您自己的更改合并)。修补可能是一个繁琐的过程，忽略它可能会破坏某些功能，因此如果可能，请避免覆盖文件，而首选覆盖节点和属性。</p><p id="d1d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nk nl nm nn b">/libs</code>下的许多HTL、JSP或JS文件从JCR中获取节点和属性，并对它们执行逻辑以达到期望的结果。通过更改这些文件的输入数据(JCR内容),您会发现您可以操纵结果。</p><p id="2979" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里是我以前发表的文章中的一个例子，目的是禁止文件上传到一个图像组件，而是强迫用户从DAM中选择一个图像。这可以通过两种方式实现:</p><ol class=""><li id="3c16" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">通过在<code class="fe nk nl nm nn b">/libs/cq/gui/components/authoring/dialog/fileupload/render.jsp</code>修改JSP</li><li id="8d1d" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">通过向组件<code class="fe nk nl nm nn b">cq:dialog</code>中的节点添加一个<code class="fe nk nl nm nn b">allowUpload — Boolean — false</code>属性。</li></ol><p id="37f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个选项的优点是这会影响所有使用<code class="fe nk nl nm nn b">fileupload</code>组件的组件，但是每次升级后都需要打补丁。</p><p id="72e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二种选择的优点是更快、更简单、更易维护。</p><p id="e498" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于不同的需求，总是有不同的解决方案，但是每当您觉得需要更改一个文件以达到您想要的结果时，就很有必要检查一下是否可以用一种更干净、更易维护的方式达到相同的结果。<a class="ae mf" href="https://helpx.adobe.com/experience-manager/6-5/sites/developing/using/reference-materials/granite-ui/api/jcr_root/libs/granite/ui/index.html" rel="noopener ugc nofollow" target="_blank"> Granite </a>和<a class="ae mf" href="https://helpx.adobe.com/experience-manager/6-3/sites/developing/using/reference-materials/coral-ui/coralui3/documentation.html#coralUI3Migration" rel="noopener ugc nofollow" target="_blank"> Coral </a>文档可能是一个很好的起点，但是阅读该文件并理解其工作原理可以揭示官方文档中没有的解决方案(并让您感觉像夏洛克·福尔摩斯)。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="a922" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">进行不变的首次提交</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/807ce2bdca682d2c365cec94e533db84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FqMHtGelseEqn5nrXxAI8g.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">照片由<a class="ae mf" href="https://unsplash.com/@nasa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> NASA </a>在<a class="ae mf" href="https://unsplash.com/s/photos/surgery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="fff3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设(不管什么原因)你没有选择，只能在<code class="fe nk nl nm nn b">/libs/cq/gui/components/authoring/dialog/fileupload/clientlibs/fileupload/js/fileuploadfield.js</code>覆盖文件。从6.5.1开始，这个文件有680行长。为了让你的同事清楚你的改变，你应该:</p><ol class=""><li id="eed2" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">覆盖物</li><li id="6f28" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">导入到项目中</li><li id="dfdd" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">犯罪</li><li id="63ef" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">做出改变</li><li id="3dc9" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">再次提交</li></ol><p id="ef5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您在同一次提交中覆盖<em class="lz">和</em>变更文件，然后将您的特性分支发送给代码审查，您的同事将不得不在680多行代码中找到那个变更，这是一个大麻烦。</p><p id="a37d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">他们必须在<code class="fe nk nl nm nn b">/libs</code>中找到文件，将它复制到一个diff工具中，然后回到您的代码审查工具中获得反馈，等等。</p><p id="ee85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就算你不喜欢你的同事，也是为了你自己的名声。尽管我很喜欢使用Adobe产品，但他们的开发人员并不是上帝！您可能会覆盖一个包含错误、不良做法或遗留待办事项的文件。通过在您的更改之前为覆盖创建一个单独的提交，您就脱离了任何OOTB猴子业务😉</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="b88b" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">让你的代码与众不同</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/9d327ff798113692b418db196888697e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXEg1NfxPNaJkI2oxvAeZA.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">希望你的代码看起来更快乐</figcaption></figure><p id="61ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">按照同样的思路，尽你所能将你的代码与OOTB代码区分开来。仔细考虑你的定制做了什么和它的技术实现，并尝试找到一种方法来清楚地区分你的定制和Adobe的代码。</p><p id="4030" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果你的特性可以被视为纯粹的<em class="lz">附加的</em>(即:它增加了功能而不改变现有的行为)，那么为什么不创建一个新的clientlib，而是将它添加到一个现有的类别中呢？这将导致您的代码与OOTB Adobe代码同时加载。</p><p id="38bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您的特性实现覆盖了Adobe代码，那么创建一个带有<em class="lz">自定义</em>类别的clientlib，并使用覆盖将该类别添加到您需要的任何地方。当您的定制是基于CSS时，这种技术很有用，例如:只需将CSS clientlib类别<em class="lz">添加到包含它所覆盖的样式的类别</em>之后(clientlib按照其类别列出的顺序加载)。</p><p id="82ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您决定您需要覆盖一个文件，同样的原则适用。抵制冲动(无论多么诱人😉)来重构现有代码，并避免在现有代码块中编写代码。</p><p id="9563" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果可能的话，不要修改十行Adobe代码，而是在文件的底部写一个十行的函数，并在上面调用一次。这将大大降低升级/更新AEM实例时打补丁过程中出现冲突的风险。尽管如此，如果发生冲突，它们至少会更清晰、更容易解决，而不需要对特性有深入的先验知识。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="7279" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">将自定义与项目分开</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/39c306e1a4118f3c290f1ee88fdec6bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfeWQxK5AmP9EpDTxCFJmA.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">希瑟·福特在<a class="ae mf" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f402" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我在这里使用术语“项目”来指代一个站点以及所有特定于站点的代码和逻辑，例如,<code class="fe nk nl nm nn b">projectA</code>将是一个包含实现站点a所需的所有组件和逻辑的Maven项目存储库。如果您的AEM实例托管多个站点(或者将来可能托管多个站点),那么第二个<code class="fe nk nl nm nn b">projectB</code>将是一个类似于站点B的项目。</p><p id="14d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么AEM平台的定制属于哪里呢？因为<code class="fe nk nl nm nn b">projectA</code>应该只影响站点A，而<code class="fe nk nl nm nn b">projectB</code>应该只影响站点B，但是定制会影响站点A和站点B的作者，所以它们属于一个单独的项目:<code class="fe nk nl nm nn b">projectX</code>。</p><p id="960f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设站点A的用户希望在DAM资产名称中允许某些特殊字符，但是SiteB与第三方接口，因此必须严格地在文件名中只使用小写字母数字字符。两个团队都可以通过在<code class="fe nk nl nm nn b">/libs/dam/gui/coral/components/commons/fileupload/clientlibs/fileupload/js/fileupload.js</code>覆盖脚本来实现他们的定制，但是不是让<em class="lz">拥有两个</em>特性，最后部署的项目会覆盖另一个项目的变更:不好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/7c645dc832eba6c9ceb3bc94b1af4cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5fS3SsSQdky2l2UBBPx0g.png"/></div></div></figure><p id="857d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果定制存在于一个单独的项目中，两个团队都可以访问(最好是由另一方进行代码审查)，那么这两个特性可以合并到一个定制中，这样大家都满意，双赢！</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="686f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！请记住，这些只是我为创建AEM平台最易维护的定制而提出的指导方针。过去，为了得到我想要的结果，我不得不打破我自己的许多规则，但是在我承诺之前，我总是停下来想是否有更好的方法，即使答案有时是…“没有”🤷‍♂️</p><p id="398f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我对这个问题的看法😊您遵循的其他最佳实践中有没有我可能遗漏的？欢迎在评论中分享，或者<a class="ae mf" href="https://www.linkedin.com/in/theo-pendle-1630a52a/" rel="noopener ugc nofollow" target="_blank">在LinkedIn </a>上联系我，我们可以讨论理论！</p></div></div>    
</body>
</html>