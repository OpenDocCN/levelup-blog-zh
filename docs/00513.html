<html>
<head>
<title>Solid — The Best JavaScript UI Library You’ve Never Heard Of</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">solid——你从未听说过的最好的JavaScript UI库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solid-the-best-javascript-ui-library-youve-never-heard-of-297b22848ac1?source=collection_archive---------0-----------------------#2019-04-05">https://levelup.gitconnected.com/solid-the-best-javascript-ui-library-youve-never-heard-of-297b22848ac1?source=collection_archive---------0-----------------------#2019-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d023b9e3fbea4d11a0db1c2ac6d63d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-uRBe0VwtIlvQVftVk7Cw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来自Shutterstock</figcaption></figure><p id="ece7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">任何人都不希望看到另一个JavaScript UI库/框架。持续的决策和追逐独角兽的沉重负担已经超出了疲劳。做东西变得如此容易。Web组件似乎每隔一天就要负责一个新的“框架”。所以为什么要这么麻烦呢？</p><p id="481d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我每一步都意识到这个问题。它始于一个明确的目标。</p><blockquote class="la lb lc"><p id="0e40" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">证明细粒度的变化检测在现代JavaScript UI中占有一席之地。</p></blockquote><p id="3a05" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我知道这是雄心勃勃的，所以我必须把标准定得很高。仅仅有趣或优秀是不够的。我显然认为<a class="ae lh" href="https://github.com/ryansolid/solid" rel="noopener ugc nofollow" target="_blank">的世界是坚实的</a>，但是我希望在这篇文章之后你会有同样的感觉。</p><h1 id="d974" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">表演</h1><p id="7b1e" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">虽然这应该是你考虑库的最低标准，但我知道这是我需要开始的地方。有很多选择，为了让这个库值得任何人花费时间，它必须要快。不。快还不够。它无疑是最快的。</p><p id="225a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你所知道的最快的UI库是什么？是Vue，React，Inferno，Svelte，lit-html，Imba？许多图书馆都声称，至少有一些好的基准。我个人遵从<a class="ae lh" href="https://github.com/krausest/js-framework-benchmark" rel="noopener ugc nofollow" target="_blank"> JS框架基准</a>。我写了一篇关于我的基准测试方法的文章，你可以<a class="ae lh" href="https://medium.com/@ryansolid/b-y-o-f-part-4-rendering-the-dom-753657689647" rel="noopener">在这里阅读</a>。与此同时，这里是Chrome 72官方回购的几个选择框架的截屏:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/add76bf21565e48b8c9a1a38700f9584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uycel33xQ3jeGMLovLw2sA.png"/></div></div></figure><p id="ae92" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最下面一行实际上是平均分数。如你所见，与流行的库相比，Solid的性能完全不同。</p><h1 id="4e3f" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">应用程序接口</h1><p id="a38b" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">Solid建立在细粒度的变化检测之上，KnockoutJS和MobX也是建立在同样的基础之上。这是一种基于可组合原语的开发体验。有了这样的系统，就不需要虚拟DOM了。在许多方面，组件边界是一种去优化，这些原语可以管理自己的更新周期。</p><p id="951d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我还想借用Reacts对读写隔离的使用，因为至少给人以不变性的印象是非常强大的。这种控制解决了这种方法的许多传统缺点。我知道我想让它变得现代和可编译，所以我选择JSX作为我的模板语言。这提出了一个有趣的挑战，因为虽然控制流可以在JS中完成，但我想抽象记忆化和细粒度执行的细节。解决方案是对控制流使用JSX标记。</p><p id="d48e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我确实觉得我做这件事有点疯狂，既不是反应也不是典型的细粒度的。但在过去的5个月里，React的方向肯定验证了我的方法。首先是使用非常相似的原语的React钩子，最近是由<a class="mq mr ep" href="https://medium.com/u/d9b1a61823fa?source=post_page-----297b22848ac1--------------------------------" rel="noopener" target="_blank">李·拜伦</a>的“Velcro架构”，正如这里<a class="ae lh" href="https://github.com/leebyron/react-loops#what-is-react-velcro" rel="noopener ugc nofollow" target="_blank">所描述的</a>。除了我觉得固体做得更好。</p><pre class="mm mn mo mp gt ms mt mu mv aw mw bi"><span id="d920" class="mx lj iq mt b gy my mz l na nb">const App = () =&gt; {<br/>  const [state, setState] = createState({ counter: 0 }),<br/>    timer = setInterval(() =&gt;<br/>      setState({ counter: state.counter + 1 })<br/>    , 1000);<br/>  onCleanup(() =&gt; clearInterval(timer));<br/>  return &lt;div&gt;{( state.counter )}&lt;/div&gt;<br/>}</span></pre><p id="1650" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每个框架都有它的“反”例子，所以这看起来应该是相似的，除非你将它与React挂钩进行比较，你会注意到缺少了一些，但它仍然工作。你可以在这里看到它的作用<a class="ae lh" href="https://codesandbox.io/s/solid-counter-8no2n9k94l" rel="noopener ugc nofollow" target="_blank">。这就是Solid的特点，它始终以最少的代码开发解决方案。</a></p><h1 id="65d9" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">哲学</h1><p id="d8e8" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">设计Solid归结为几个原则。这些来自于在React的设计哲学的视角下进行细粒度变更管理的基础。</p><ol class=""><li id="ea11" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated"><strong class="ke ir">声明性数据(不仅仅是视图)。这是一种描述数据行为及其定义的方法。通过将数据行为的所有方面打包在一个地方，这使得组合变得容易。</strong></li><li id="32cf" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated"><strong class="ke ir">数据流与UI模块性没有紧密耦合。如何模块化代码的决定不应该受到性能或数据更新问题的限制。你应该能够根据用户界面的需要分解组件。</strong></li><li id="1de1" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated"><strong class="ke ir">读/写隔离。</strong>这是React的核心要点。单向流和不可变数据只是实现。只要您以这种粒度控制访问，大型系统就可以变得更加可预测。</li><li id="d5fb" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated"><strong class="ke ir">简单胜于容易。对于细粒度的魔法来说，这是一个难以接受的教训。明确和一致的约定即使需要更多的工作也是值得的。目的是提供最少的工具作为构建的基础。</strong></li></ol><p id="48e4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我发现这些原则是非常强大的基石，它们使Solid开发变得可预测，并为如何解决任何需要解决的潜在问题提供了强有力的指导。</p><h1 id="8210" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">特征</h1><p id="1cde" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">这绝对是一个可能成为陷阱的领域，就像它最大的影响KnockoutJS和React一样，Solid使它变得简单。这只是一个库，不是框架。像挖空视图一样，旧组件的模型只是功能。因为Solid使用细粒度的更新，并且组件只完整地呈现一次，所以可以简单地通过使用闭包来包装状态。一方面，Solid只是提供了一组简单的原语，如createState、createEffect、createMemo等..这些可以被组合以创建更强大的行为。另一方面，它使用控制流的思想，不仅实现了条件和回退循环，还实现了入口和悬念。当这一切走到一起时，意味着支持大多数JSX惯例，如跨页、引用和作为标签的组件。</p><p id="070c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">更重要的是，这种实体不会遭受与大型不可变数据快照进行细粒度反应的传统弱点。Solid提供了一个数据协调器，它像虚拟DOM区分节点一样区分数据，从而允许与Redux或Apollo等不可变数据存储进行干净的集成，并能够使用类似的模式来管理状态。</p><pre class="mm mn mo mp gt ms mt mu mv aw mw bi"><span id="ea1a" class="mx lj iq mt b gy my mz l na nb">const useReducer = (reducer, init) =&gt; {<br/>  const [state, setState] = createState(init),<br/>    [getAction, dispatch] = createSignal();<br/>  createEffect((prevState = init) =&gt; {<br/>    let action, next;<br/>    if (!(action = getAction())) return prevState;<br/>    next = reducer(prevState, action);<br/>    setState(reconcile(next));<br/>    return next;<br/>  }, [ getAction ])<br/>  return [state, dispatch];<br/>}</span></pre><p id="0044" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但这还不够。我希望这是Web组件友好的。这是大多数虚拟DOM库不支持的一件事。这意味着暗影王国意识到半合成事件委托。让模态与Web组件一起正常工作也很重要，所以让门户与它们自己的影子根一起工作是必须的。</p><p id="f6a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那还剩下什么？带时间切片的异步渲染？Solid是细粒度的，因此独立地安排更新是轻而易举的。不需要特殊的构造来异步应用更新。Solid自己的原语可以推迟和控制更新的传播方式。查看Solid对Sierpinski的三角形演示的实现，该演示由React Fiber推广。</p><h1 id="8be7" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">我为什么要在乎？</h1><p id="f4e3" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">这是最难的。尽管Solid已经取得了一些成就，但在一个过度饱和的市场中，它仍然是一个挑战者。仍有许多领域需要关注。CLI和开发工具是显而易见的。这也需要证明。但这只是伴随着一个寻求改进的社区。我并没有将Solid定位为一个真正有竞争力的选项，只是可能是你从未听说过的最好的选项。</p><p id="b955" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在Solid是一个让你自己尝试的好地方，看看你是否喜欢它。如果我在本文中涉及的任何方面看起来有趣，请到Github上查看并给它一颗星。我现在最大的挑战是试图建立势头，通过现有的比较继续推广它。我已经花了4年多的时间来研究这个，即使这些碎片仅仅在一年多前才真正全部组合在一起。我在这方面花了很多时间，并不断寻找改进的方法。如果有任何值得做的地方，请表示你的支持，我会一如既往地欢迎任何反馈。</p><div class="nq nr gp gr ns nt"><a href="https://github.com/ryansolid/solid" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">瑞安固体/固体</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">一个用于构建用户界面的声明式、高效且灵活的JavaScript库。-瑞安固体/固体</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">github.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh jw nt"/></div></div></a></div></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="f83d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用Solid构建Todo应用程序:</p><div class="nq nr gp gr ns nt"><a rel="noopener  ugc nofollow" target="_blank" href="/building-a-simple-javascript-app-with-solid-ff17c8836409"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">用Solid构建一个简单的JavaScript应用——你从未听说过的最好的JavaScript UI库</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">使用Solid JS库构建待办事项列表应用程序的指南</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oc l"><div class="op l oe of og oc oh jw nt"/></div></div></a></div></div></div>    
</body>
</html>