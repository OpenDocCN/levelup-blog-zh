<html>
<head>
<title>Selecting &amp; Replacing Values In Pandas DataFrame Effectively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效地选择和替换Pandas数据框架中的值</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/selecting-replacing-values-in-pandas-dataframe-effectively-69c5cee9f526?source=collection_archive---------10-----------------------#2022-12-19">https://levelup.gitconnected.com/selecting-replacing-values-in-pandas-dataframe-effectively-69c5cee9f526?source=collection_archive---------10-----------------------#2022-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f0df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated">作为一名数据科学家，使用正确的工具和技术来充分利用数据是非常重要的。Pandas库是一个非常棒的数据操作、分析和可视化工具，也是任何数据科学家工具箱中必不可少的一部分。然而，有效地使用熊猫是一个挑战，这会导致时间和精力的浪费。</p><p id="e718" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，有一些最佳实践可以帮助数据科学家充分利用他们的熊猫体验。从使用矢量化操作到利用内置函数，这些最佳实践将帮助数据科学家使用Pandas快速准确地分析和可视化数据。了解并应用这些最佳实践将有助于数据科学家提高工作效率和准确性，从而更快地做出更好的决策。</p><p id="4572" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将重点关注您通常会在数据框架上执行的两个最常见的任务，尤其是在数据科学项目的数据操作阶段。这两个任务是有效地选择特定和随机的行和列，以及使用<strong class="js iu"> replace() </strong>函数使用列表和字典替换一个或多个值。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/be8fd67c1194ff7464f6d8cdbe75a3ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SnhM5eowyU43u2gz"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">照片由<a class="ae ln" href="https://unsplash.com/@redaquamedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼·米勒</a>在<a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h2 id="7851" class="lo lp it bd lq lr ls dn lt lu lv dp lw kb lx ly lz kf ma mb mc kj md me mf mg bi translated">目录:</h2><ol class=""><li id="f966" class="mh mi it js b jt mj jx mk kb ml kf mm kj mn kn mo mp mq mr bi translated">为什么我们需要高效的编码？</li><li id="3288" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">使用有效地选择行和列。iloc[] &amp;。位置[]</li><li id="a094" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">有效替换数据帧中的值</li><li id="150b" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">选择和替换值的最佳实践摘要</li></ol><p id="2c7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在GitHub资源库中找到本文中使用的数据和代码:</p><div class="mx my gp gr mz na"><a href="https://github.com/youssefHosni/Efficient-Python-for-Data-Scientists" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">GitHub-youssefHosni/面向数据科学家的高效Python</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">作为数据科学家学习如何编写高效的python代码如何编写Python干净的代码[文章]编写高效…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">github.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no lh na"/></div></div></a></div><p id="72c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将使用三个数据集:</p><ul class=""><li id="236c" class="mh mi it js b jt ju jx jy kb np kf nq kj nr kn ns mp mq mr bi translated"><a class="ae ln" href="https://github.com/youssefHosni/Advanced-Python-for-Data-Scientists/blob/main/Datasets/poker_hand.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">扑克牌游戏数据集</strong> </a></li><li id="d260" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn ns mp mq mr bi translated"><a class="ae ln" href="https://github.com/youssefHosni/Advanced-Python-for-Data-Scientists/blob/main/Datasets/Popular_Baby_Names.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">流行的宝宝名字</strong> </a></li></ul><p id="e69f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个数据集是<a class="ae ln" href="https://github.com/youssefHosni/Advanced-Python-for-Data-Scientists/blob/main/Datasets/poker_hand.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">扑克牌游戏数据集</strong> </a> <strong class="js iu"> </strong>，如下所示。</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="53fe" class="ny lp it nu b be nz oa l ob oc">poker_data = pd.read_csv('poker_hand.csv')<br/>poker_data.head()</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi od"><img src="../Images/475a8654937fed12e81ac39d83854a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/0*clzVFjR2tdDAKm5Q.png"/></div></figure><p id="fefe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在每一轮扑克游戏中，每个玩家手里都有五张牌，每张牌都有其符号和等级，符号可以是红心、方块、梅花或黑桃，等级从1到13不等。该数据集由一个人可能拥有的五张卡的所有可能组合组成。</p><ul class=""><li id="2112" class="mh mi it js b jt ju jx jy kb np kf nq kj nr kn ns mp mq mr bi translated">Sn:第n张牌的符号，其中:1(红心)，2(方块)，3(梅花)，4(黑桃)</li><li id="7d5a" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn ns mp mq mr bi translated">Rn:第n张牌的等级，其中:1(王牌)，2–10，11(杰克)，12(王后)，13(国王)</li></ul><p id="abef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用的第二个数据集是<a class="ae ln" href="https://github.com/youssefHosni/Advanced-Python-for-Data-Scientists/blob/main/Datasets/Popular_Baby_Names.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">流行的婴儿名字</strong> </a> <strong class="js iu"> </strong>数据集，它包括2011年至2016年间给新生儿起的最流行的名字。数据集已加载，如下所示:</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="c4e7" class="ny lp it nu b be nz oa l ob oc">names = pd.read_csv('Popular_Baby_Names.csv')<br/>names.head()</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi od"><img src="../Images/47f29ee198341bbd591e8997400efbcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/0*FbaH_hKqsZb7WA_R.png"/></div></figure><p id="aab0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该数据集包括按年份、性别和种族划分的美国最受欢迎的名字等信息。例如，2011年，克洛伊这个名字在所有亚裔和太平洋岛民的新生儿中排名第二。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="7d0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如果你想免费学习数据科学和机器学习，看看这些资源:</strong></p><ul class=""><li id="6d73" class="mh mi it js b jt ju jx jy kb np kf nq kj nr kn ns mp mq mr bi translated">免费互动路线图，自学数据科学和机器学习。从这里开始:<a class="ae ln" href="https://aigents.co/learn/roadmaps/intro" rel="noopener ugc nofollow" target="_blank">https://aigents.co/learn/roadmaps/intro</a></li><li id="5ec4" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn ns mp mq mr bi translated">数据科学学习资源搜索引擎(免费)。将你最喜欢的资源加入书签，将文章标记为完整，并添加学习笔记。<a class="ae ln" href="https://aigents.co/learn" rel="noopener ugc nofollow" target="_blank">https://aigents.co/learn</a></li><li id="d26e" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn ns mp mq mr bi translated">想要在导师和学习社区的支持下从头开始学习数据科学吗？免费加入这个学习圈:<a class="ae ln" href="https://community.aigents.co/spaces/9010170/" rel="noopener ugc nofollow" target="_blank">https://community.aigents.co/spaces/9010170/</a></li></ul></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="c01f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想在数据科学&amp;人工智能领域开始职业生涯，但不知道如何开始。我提供数据科学指导课程和长期职业指导:</p><ul class=""><li id="922f" class="mh mi it js b jt ju jx jy kb np kf nq kj nr kn ns mp mq mr bi translated">长期指导:<a class="ae ln" href="https://lnkd.in/dtdUYBrM" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/dtdUYBrM</a></li><li id="c794" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn ns mp mq mr bi translated">辅导课程:<a class="ae ln" href="https://lnkd.in/dXeg3KPW" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/dXeg3KPW</a></li></ul><p id="2f80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ol">加入</em> </strong> <a class="ae ln" href="https://youssefraafat57.medium.com/membership" rel="noopener"> <strong class="js iu"> <em class="ol">中等会员</em> </strong> </a> <strong class="js iu"> <em class="ol">计划继续无限制学习。如果你使用下面的链接，我会收到一小部分会员费，不需要你额外付费。</em> </strong></p><div class="mx my gp gr mz na"><a href="https://youssefraafat57.medium.com/membership" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">加入我的介绍链接媒体-优素福胡斯尼</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">阅读Youssef Hosni(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">youssefraafat57.medium.com</p></div></div><div class="nj l"><div class="om l nl nm nn nj no lh na"/></div></div></a></div></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="1a28" class="on lp it bd lq oo op oq lt or os ot lw ou ov ow lz ox oy oz mc pa pb pc mf pd bi translated">1.为什么我们需要高效的编码？</h1><p id="20cb" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb pe kd ke kf pf kh ki kj pg kl km kn im bi translated">高效代码是指执行速度更快、计算内存更少的代码。在本文中，我们将使用<strong class="js iu"> time() </strong>函数来测量计算时间。这个函数测量当前时间，所以我们将在代码执行前和执行后把它赋给一个变量，然后计算差值，就知道代码的计算时间。下面的代码显示了一个简单的例子:</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="0287" class="ny lp it nu b be nz oa l ob oc">import time<br/># record time before execution<br/>start_time = time.time()<br/># execute operation<br/>result = 5 + 2<br/># record time after execution<br/>end_time = time.time()<br/>print("Result calculated in {} sec".format(end_time - start_time))</span></pre><p id="f1f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一些应用高效代码方法将如何提高代码运行时间和降低计算时间复杂性的例子:我们将计算从零到一百万的每个数字的平方。首先，我们将使用list comprehension来执行这个操作，然后使用for循环重复相同的过程。</p><p id="a2af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一次使用列表理解:</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="c561" class="ny lp it nu b be nz oa l ob oc">#using List comprehension <br/><br/>list_comp_start_time = time.time()<br/>result = [i*i for i in range(0,1000000)]<br/>list_comp_end_time = time.time()<br/>print("Time using the list_comprehension: {} sec".format(list_comp_end_time -<br/>list_comp_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/a3864a5125d782afa89fcf9d77e2ed9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/0*4kwWE6W24Y8kWC3A.png"/></div></figure><p id="c390" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们将使用for循环来执行相同的操作:</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="24d8" class="ny lp it nu b be nz oa l ob oc"># Using For loop<br/><br/>for_loop_start_time= time.time()<br/>result=[]<br/>for i in range(0,1000000):<br/>  result.append(i*i)<br/>for_loop_end_time= time.time()<br/>print("Time using the for loop: {} sec".format(for_loop_end_time - for_loop_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/4520b533375944f4924e8d7335c040c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/0*Yrcs9cMhA9Id0V7_.png"/></div></figure><p id="567c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到它们之间有很大的差异，我们可以用百分比来计算它们之间的差异:</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="7181" class="ny lp it nu b be nz oa l ob oc">list_comp_time = list_comp_end_time - list_comp_start_time<br/>for_loop_time = for_loop_end_time - for_loop_start_time<br/>print("Difference in time: {} %".format((for_loop_time - list_comp_time)/<br/>list_comp_time*100))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/ff0be850bb90000839a751d8278dbc0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/0*1qPM5deWRy_PlmOh.png"/></div></figure><p id="4999" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有另一个例子来展示编写高效代码的效果。我们想计算从1到100万的所有连续数字的总和。有两种方法第一种是使用蛮力，我们将一个接一个地增加到一百万。</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="f7b0" class="ny lp it nu b be nz oa l ob oc">def sum_brute_force(N):<br/>  res = 0<br/>  for i in range(1,N+1):<br/>    res+=i<br/>  return res<br/><br/># Using brute force<br/>bf_start_time = time.time()<br/>bf_result = sum_brute_force(1000000)<br/>bf_end_time = time.time()<br/><br/>print("Time using brute force: {} sec".format(bf_end_time - bf_start_time))</span></pre><p id="af24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个更有效的方法是用公式来计算。当我们想计算从1到一个数的所有整数的和时，比如说N，我们可以把N乘以N+1，然后除以2，这样就会得到我们想要的结果。这个问题实际上在19世纪就交给了德国的一些学生，一个名叫卡尔-弗里德里希·高斯的聪明学生设计了这个公式来在几秒钟内解决这个问题。</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="6e02" class="ny lp it nu b be nz oa l ob oc">def sum_formula(N):<br/>  return N*(N+1)/2<br/>  <br/># Using the formula<br/>formula_start_time = time.time()<br/>formula_result = sum_formula(1000000)<br/>formula_end_time = time.time()<br/><br/>print("Time using the formula: {} sec".format(formula_end_time - formula_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/25e6c7819deb0695721c56cd4fbabe34.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/0*dImuSiuIuDRISIAZ.png"/></div></figure><p id="3d81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行这两种方法后，我们实现了超过160，000%的巨大改进，这清楚地表明了为什么我们需要高效和优化的代码，即使对于简单的任务也是如此。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="f480" class="on lp it bd lq oo op oq lt or os ot lw ou ov ow lz ox oy oz mc pa pb pc mf pd bi translated">2.使用有效地选择行和列。iloc[] &amp;。位置[]</h1><p id="aa7c" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb pe kd ke kf pf kh ki kj pg kl km kn im bi translated">在这一节中，我们将介绍如何使用<strong class="js iu">从数据帧中有效地定位和选择行。iloc</strong>&amp;<strong class="js iu">。loc[] </strong>熊猫功能。我们将使用<strong class="js iu"> iloc[] </strong>作为索引号定位器，使用<strong class="js iu"> loc[] </strong>作为索引名定位器。</p><p id="2d50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的例子中，我们将选择扑克数据集的前500行。首先使用<strong class="js iu">。loc[] </strong>功能，然后通过使用<strong class="js iu">。iloc[] </strong>功能。</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="2c8b" class="ny lp it nu b be nz oa l ob oc"># Specify the range of rows to select<br/><br/>rows = range(0, 500)<br/># Time selecting rows using .loc[]<br/>loc_start_time = time.time()<br/>poker_data.loc[rows]<br/>loc_end_time = time.time()<br/>print("Time using .loc[] : {} sec".format(loc_end_time - loc_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/a785532c1e2bd981005f6ffd6e2062df.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/0*eVjOtkaea10wTWLI.png"/></div></figure><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="94f4" class="ny lp it nu b be nz oa l ob oc"># Specify the range of rows to select<br/>rows = range(0, 500)<br/># Time selecting rows using .iloc[]<br/>iloc_start_time = time.time()<br/>poker_data.iloc[rows]<br/>iloc_end_time = time.time()<br/>print("Time using .iloc[]: {} sec".format(iloc_end_time - iloc_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/feb90bd109d60687de54a07b3996a2f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/0*eAvHuwlh3xrYQoWG.png"/></div></figure><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="ea38" class="ny lp it nu b be nz oa l ob oc">loc_comp_time = loc_end_time - loc_start_time<br/>iloc_comp_time = iloc_end_time - iloc_start_time<br/>print("Difference in time: {} %".format((loc_comp_time - iloc_comp_time)/<br/>iloc_comp_time*100))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/d1b270294388a2a45f4ea70c404cb4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/0*mSxn8tkzKP2TLdOX.png"/></div></figure><p id="357a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这两种方法具有相同的语法，但是<strong class="js iu"> iloc[] </strong>的执行速度比<strong class="js iu"> loc[] </strong>快近70%。<strong class="js iu">。iloc[]函数</strong>利用了已经排序的索引的顺序，因此速度更快。</p><p id="96ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还可以用它们来选择列，而不仅仅是行。在下一个示例中，我们将使用两种方法选择前三列。</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="894b" class="ny lp it nu b be nz oa l ob oc">iloc_start_time = time.time()<br/>poker_data.iloc[:,:3]<br/>iloc_end_time = time.time()<br/>print("Time using .iloc[]: {} sec".format(iloc_end_time - iloc_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi po"><img src="../Images/9f40c53f3786518678488cea2db2445d.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/0*i4N0ILTh1H7_6Ke7.png"/></div></figure><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="3651" class="ny lp it nu b be nz oa l ob oc">names_start_time = time.time()<br/>poker_data[['S1', 'R1', 'S2']]<br/>names_end_time = time.time()<br/>print("Time using selection by name: {} sec".format(names_end_time - names_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/dfd9535ed12db368457cea64323e904d.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/0*ZrPd-eE0A7TVSkaj.png"/></div></figure><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="8b33" class="ny lp it nu b be nz oa l ob oc">loc_comp_time = names_end_time - names_start_time<br/>iloc_comp_time = iloc_end_time - iloc_start_time<br/>print("Difference in time: {} %".format((loc_comp_time - iloc_comp_time)/<br/>loc_comp_time*100))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/ff4ec5e43a59e0efded93385902e6856.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/0*rnsGykLVE4euCh-n.png"/></div></figure><p id="aac4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还可以看到，使用列索引。<strong class="js iu"> iloc[] </strong>还是快了80%。所以用起来比较好。<strong class="js iu"> iloc[] </strong>因为这样更快，除非更容易使用<strong class="js iu"> loc[] </strong>按名称选择某些列。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="7b91" class="on lp it bd lq oo op oq lt or os ot lw ou ov ow lz ox oy oz mc pa pb pc mf pd bi translated">3.有效替换数据帧中的值</h1><p id="8127" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb pe kd ke kf pf kh ki kj pg kl km kn im bi translated">替换数据帧中的值是一项非常重要的任务，尤其是在数据清理阶段。因为您必须保持代表相同对象的所有值不变。</p><p id="395d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看我们之前加载的流行婴儿名字数据集:</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/0d0ab828196cec5671b55e828bd0ff30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/0*awXcw-nu17LMf2JJ.png"/></div></figure><p id="472b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们仔细看看<strong class="js iu">性别</strong>特征，看看它们有什么独特的价值:</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="d824" class="ny lp it nu b be nz oa l ob oc">names['Gender'].unique()</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/d9d99161393fd1a04f9efb59fd89ea52.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/0*TpyTF7UH5kKqXdBj.png"/></div></figure><p id="80e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到，女性用大写和小写两个值来表示。这在真实数据中很常见，一种简单的方法是用一个值替换另一个值，以使其在整个数据集中保持一致。有两种方法可以做到这一点第一种是简单地定义我们想要替换的值，然后我们想要用什么来替换它们。这显示在下面的代码中:</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="b2d7" class="ny lp it nu b be nz oa l ob oc">start_time = time.time()<br/>names['Gender'].loc[names.Gender=='female'] = 'FEMALE'<br/>end_time = time.time()<br/><br/>pandas_time = end_time - start_time<br/>print("Replace values using .loc[]: {} sec".format(pandas_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ph"><img src="../Images/0d0bd68c2cd0bcfbc813a95366f73c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/0*x9yZU1r9-praH0m0.png"/></div></div></figure><p id="aec0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二种方法是使用熊猫的内置功能<strong class="js iu">。replace() </strong>如下面的代码所示:</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="fffe" class="ny lp it nu b be nz oa l ob oc">start_time = time.time()<br/>names['Gender'].replace('female', 'FEMALE', inplace=True)<br/>end_time = time.time()<br/>replace_time = end_time - start_time<br/><br/>print("Time using replace(): {} sec".format(replace_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/7f16d405002f7ca4b155a7c09a3319a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/0*iCdoGVXxFFU5vYJj.png"/></div></figure><p id="b331" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到，内置函数<strong class="js iu">的时间复杂度比使用<strong class="js iu">快157% </strong>。loc() </strong>方法找到行和列的索引值并替换它。</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="a6fc" class="ny lp it nu b be nz oa l ob oc">print('The differnce: {} %'.format((pandas_time- replace_time )/replace_time*100))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/ce421221785eb730097f73f146828608.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/0*qRfI2eAHDTj4-x2R.png"/></div></figure><p id="8f8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以使用列表替换多个值。我们的目标是将所有被归类为非西班牙裔白人(T14)或非HISP裔白人(T16)的种族(T17)转变为WNH人(T19)。使用<strong class="js iu">。loc[] </strong>函数，我们将使用‘or’语句(在Python中用管道符号表示)定位我们正在寻找的种族的婴儿。然后我们将分配新的值。和往常一样，我们也测量这个操作所需的CPU时间。</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="372a" class="ny lp it nu b be nz oa l ob oc">start_time = time.time()<br/><br/>names['Ethnicity'].loc[(names["Ethnicity"] == 'WHITE NON HISPANIC') |<br/>(names["Ethnicity"] == 'WHITE NON HISP')] = 'WNH'<br/><br/>end_time = time.time()<br/>pandas_time= end_time - start_time<br/>print("Results from the above operation calculated in %s seconds" %(pandas_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/40a266311975beac4c91264c552996e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/0*Wp-Zw-KxoqQ4ObhV.png"/></div></figure><p id="5360" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以使用<strong class="js iu">进行同样的操作。替换()</strong>熊猫内置函数如下:</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="fb81" class="ny lp it nu b be nz oa l ob oc">start_time = time.time()<br/>names['Ethnicity'].replace(['WHITE NON HISPANIC','WHITE NON HISP'],<br/>'WNH', inplace=True)<br/><br/>end_time = time.time()<br/>replace_time = end_time - start_time<br/><br/>print("Time using .replace(): {} sec".format(replace_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/ccbb160290e08531424624ceec86e14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/0*Wc8jYBvH3q8zncjZ.png"/></div></figure><p id="9d05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<strong class="js iu">我们可以再次看到这一点。replace() </strong>方法比使用<strong class="js iu">要快得多。loc[] </strong>法。为了更直观地了解速度有多快，让我们运行下面的代码:</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="529b" class="ny lp it nu b be nz oa l ob oc">print('The differnce: {} %'.format((pandas_time- replace_time )/replace_time*100))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/4a6234dac37c500747472f4e04c945d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/0*HPjnuCXfxsXjgfnI.png"/></div></figure><p id="22f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">。replace() </strong>方法比使用<strong class="js iu">快<strong class="js iu"> 87% </strong>。loc[] </strong>方法。如果你的数据很大，需要大量清理，这个技巧将减少数据清理的计算时间，使你的熊猫代码更快，因此更有效。</p><p id="a824" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们还可以使用<strong class="js iu">字典</strong>来替换数据帧中的单个和多个值。如果您想在一个命令中使用多个替换功能，这将非常有用。</p><p id="73aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将使用字典将每个男性的性别替换为男孩，将每个女性的性别替换为女孩。</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="4df7" class="ny lp it nu b be nz oa l ob oc">names = pd.read_csv('Popular_Baby_Names.csv')<br/><br/>start_time = time.time()<br/>names['Gender'].replace({'MALE':'BOY', 'FEMALE':'GIRL', 'female': 'girl'}, inplace=True)<br/>end_time = time.time()<br/>dict_time = end_time - start_time<br/>print("Time using .replace() with dictionary: {} sec".format(dict_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/5cca325fc7ec7aee074acdfbf59aed22.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/0*53q-yhlqJE4cxQh9.png"/></div></figure><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="1161" class="ny lp it nu b be nz oa l ob oc">names = pd.read_csv('Popular_Baby_Names.csv')<br/><br/>start_time = time.time()<br/><br/>names['Gender'].replace('MALE', 'BOY', inplace=True)<br/>names['Gender'].replace('FEMALE', 'GIRL', inplace=True)<br/>names['Gender'].replace('female', 'girl', inplace=True)<br/><br/>end_time = time.time()<br/><br/>list_time = end_time - start_time<br/>print("Time using multiple .replace(): {} sec".format(list_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/95318a51a56cd60bf98a0b8c988466a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/0*iqmse7rmquRFu4Qc.png"/></div></figure><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="0bbf" class="ny lp it nu b be nz oa l ob oc">print('The differnce: {} %'.format((list_time- dict_time )/dict_time*100))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi px"><img src="../Images/dc4be92c29a450232e367a441520c357.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/0*R198fN0yZT-0FIo1.png"/></div></figure><p id="d290" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以对列表做同样的事情，但是会更加冗长。如果我们比较这两种方法，我们可以看到字典运行大约快了<strong class="js iu"> 22% </strong>。一般来说，与列表相比，在Python中使用字典是非常高效的:浏览列表需要传递列表中的每个元素，而查看字典则直接指向与条目匹配的键。这种比较有点不公平，因为两种结构服务于不同的目的。</p><p id="e4b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<strong class="js iu">字典</strong>允许你替换几个不同列上的相同值。在前面的所有示例中，我们指定了要替换的值所来自的列。我们现在要用一个公共值替换同一列中的几个值。我们想把所有种族分为三大类:黑人、亚洲人和白人。语法也非常简单。我们在这里使用嵌套字典:外键是我们想要替换值的列。这个外键的值是另一个字典，其中的键是要替换的种族，以及新的种族(黑人、亚洲人或白人)的值。</p><pre class="ky kz la lb gt nt nu nv bn nw nx bi"><span id="b1c1" class="ny lp it nu b be nz oa l ob oc">start_time = time.time()<br/>names.replace({'Ethnicity': {'ASIAN AND PACI': 'ASIAN', 'ASIAN AND PACIFIC ISLANDER': 'ASIAN',<br/>'BLACK NON HISPANIC': 'BLACK', 'BLACK NON HISP': 'BLACK',<br/>'WHITE NON HISPANIC': 'WHITE', 'WHITE NON HISP': 'WHITE'}})<br/>print("Time using .replace() with dictionary: {} sec".format (time.time() - start_time))</span></pre></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><h1 id="f407" class="on lp it bd lq oo op oq lt or os ot lw ou ov ow lz ox oy oz mc pa pb pc mf pd bi translated">4.选择和替换值的最佳实践摘要</h1><ul class=""><li id="a4fa" class="mh mi it js b jt mj jx mk kb ml kf mm kj mn kn ns mp mq mr bi translated">使用可以更快地选择行和列。<strong class="js iu"> iloc[] </strong>功能。所以除非使用<strong class="js iu">更容易或者更方便，否则还是用起来比较好。而且速度不是重点或者你只是做一次。</strong></li><li id="5b82" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn ns mp mq mr bi translated">使用内置的<strong class="js iu"> replace() </strong>函数比仅仅使用传统方法要快得多。</li><li id="e2da" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn ns mp mq mr bi translated">使用python字典替换多个值比使用列表更快。</li></ul></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="f8a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ol">感谢阅读！如果你喜欢这篇文章并愿意支持我，请务必:</em> </strong></p><ul class=""><li id="d105" class="mh mi it js b jt ju jx jy kb np kf nq kj nr kn ns mp mq mr bi translated"><strong class="js iu">👏为这个故事鼓掌(50次)并跟我来👉</strong></li><li id="7a51" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn ns mp mq mr bi translated"><strong class="js iu">📰查看我的媒体档案中的更多内容</strong></li><li id="082b" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn ns mp mq mr bi translated"><strong class="js iu">🔔关注我:</strong><a class="ae ln" href="https://www.linkedin.com/in/youssef-hosni-b2960b135/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">LinkedIn</strong></a><strong class="js iu">|</strong><a class="ae ln" href="https://medium.com/@youssefraafat57" rel="noopener"><strong class="js iu">Medium</strong></a><strong class="js iu">|</strong><a class="ae ln" href="https://github.com/youssefHosni" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">GitHub</strong></a><strong class="js iu">|</strong><a class="ae ln" href="https://twitter.com/Youssef70125494" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">Twitter</strong></a></li><li id="83fc" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn ns mp mq mr bi translated"><em class="ol">🚀👉</em> <strong class="js iu"> <em class="ol">加入</em> </strong> <a class="ae ln" href="https://youssefraafat57.medium.com/membership" rel="noopener"> <strong class="js iu"> <em class="ol">中等会员</em> </strong> </a> <strong class="js iu"> <em class="ol">计划继续无限制学习。如果你使用下面的链接，我会收到一小部分会员费，不需要你额外付费。</em> </strong></li></ul><div class="mx my gp gr mz na"><a href="https://youssefraafat57.medium.com/membership" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">加入我的介绍链接媒体-优素福胡斯尼</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">阅读Youssef Hosni(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">youssefraafat57.medium.com</p></div></div><div class="nj l"><div class="om l nl nm nn nj no lh na"/></div></div></a></div></div></div>    
</body>
</html>