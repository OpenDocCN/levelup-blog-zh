<html>
<head>
<title>Connascence —Part II: Types of connascence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">共生第二部分:共生的类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/connascence-part-ii-types-of-connascence-35ce49f7c1b0?source=collection_archive---------3-----------------------#2020-12-16">https://levelup.gitconnected.com/connascence-part-ii-types-of-connascence-35ce49f7c1b0?source=collection_archive---------3-----------------------#2020-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0d44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/connascence-a-methodical-way-to-detect-code-smell-part-i-5450c104fea5?source=your_stories_page-------------------------------------">之前的故事(第一部分)</a>中，我向你介绍并给了你“同生”这个概念的定义。在这篇文章(第二部分)中，我会更深入地向你解释不同的<em class="kp">类型</em>。在最后一部分(第三部分)，我将向您展示如何将您的代码从一个不好的从属关系重构为一个好的从属关系的例子。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="1bc1" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">名称的关联</strong></h1><p id="1edb" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">我想从最令人向往的共生类型——名字的共生——开始，并告诉你为什么它是所有其他类型中最好的。</p><p id="e4a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">名称的一致性是指两个组件必须在某个事物的名称上达成一致。</p><p id="2122" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的例子中,<code class="fe ma mb mc md b">Age</code>在Customer类中被提及，并在后面的第8行被引用。如果您想将第3行中的属性<code class="fe ma mb mc md b">Age</code>更改为其他属性，那么您必须更改第8行中引用它的引用(以及其他任何地方)。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/7c7b029131116f8a31cf9452a48535f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LO0_-nWOViWyD07M01-89A.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">名称的关联性</figcaption></figure><p id="d0b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很容易理解为什么这种亲密关系是所有其他类型中最受欢迎的。修改名称的从属关系实际上是一件很容易的事情。现代的ide可以自动为你做这件事。这就是为什么你应该一直努力争取这种亲密关系。<em class="kp">因为在这种状态下代码耦合性最小，最容易修改。</em></p><h2 id="d848" class="mu ky it bd kz mv mw dn ld mx my dp lh kb mz na ll kf nb nc lp kj nd ne lt nf bi translated"><strong class="ak">类型的相关性</strong></h2><p id="cbce" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">下一个共生是类型的共生。这意味着两个组件必须在某个事物的类型上达成一致。</p><p id="8bcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的例子中，函数<code class="fe ma mb mc md b">sayHello</code>接受一个参数并返回一个字符串。但是在第10行，您看到您向我们的<code class="fe ma mb mc md b">sayHello</code>函数传递了一个数字。通常你不想把不同类型的人混在一起。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ng"><img src="../Images/d38e1ccb9b920a0168dab83529c15954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCp9Z1Zzd7wY269qQalstQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">具有相近位置的类型的相关性</figcaption></figure><p id="8a43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在不支持强类型的编程语言中，例如JavaScript，很容易意外地支持强类型。现在你可以说“嘿，我是Java或C++开发人员。这种代码甚至不能在我的平台上编译。这是否意味着类型的一致性不适用于用强类型语言写作的人？”</p><p id="97be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好问题。让我们看下一个例子:下面我们有另一个关于类型同生的例子。这一次是一个数据库调用，创建一个Payment-table，它的列Amount类型为integer。然而，在代码中，我们将它们称为具有小数类型的属性Amount的支付类。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nh"><img src="../Images/ce22db57b141500a555869813a6e1ae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*inyYA5OFBtyqHDX4VPZTiQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">具有远路局部性的类型的共生</figcaption></figure><p id="415a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你必须修改数据库或你的部分代码，以使整个系统再次正确。因此，强类型语言也是如此。</p><h2 id="7621" class="mu ky it bd kz mv mw dn ld mx my dp lh kb mz na ll kf nb nc lp kj nd ne lt nf bi translated"><strong class="ak">意义的关联</strong></h2><p id="9761" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">接下来是意义的归属。这意味着两个组件必须对一个值的解释达成一致。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ni"><img src="../Images/e29cc900d6b4057a58e92814e9940977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynzFWGCwmAZUvHjQjrAV5g.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">意义的归属</figcaption></figure><p id="67c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">123.45这个值实际上代表了什么？你只知道它可能代表钱。但是用什么货币呢？欧元？美元？日元？土豆？绵羊？好吧，最后两个是个玩笑。但关键是:我们不知道。</p><p id="fc16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能已经遇到过那个问题，但是叫做“神奇数字”问题。这也是关于共生的另一件很酷的事情:它给现存的问题一个名字，并把它放到一个环境中。</p><h2 id="53ba" class="mu ky it bd kz mv mw dn ld mx my dp lh kb mz na ll kf nb nc lp kj nd ne lt nf bi translated"><strong class="ak">位置相关性</strong></h2><p id="ccab" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">下一个伴随是位置的伴随。这意味着两个组件必须相邻或以特定顺序出现。以下示例显示了一个采用3个参数的函数。调用这个函数意味着你必须按照一定的顺序<em class="kp">放置参数</em>。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/bb1e0be0ad5843c38ff7118ef982e9aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*o9vSlv7EHQSsBvl_LS6MyQ.png"/></div></figure><p id="da33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于3个参数必须以相同的顺序出现，因此该函数是3度位置的伴随函数。</p><p id="86ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，你可能认为，共生只适用于编程语言。然而，这个例子表明它也适用于HTML和CSS:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nk"><img src="../Images/1c315b48f17ebd008e6e701c8caa268d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*ZLcOl8UNrHx-7RGqYI5ROg.png"/></div></div></figure><p id="ec5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">左边的HTML代码显示了一个包含一个<code class="fe ma mb mc md b">header</code>和<code class="fe ma mb mc md b">content</code>的<code class="fe ma mb mc md b">section</code>的嵌套结构。右边的CSS代码显示，该部分的第一个子部分的文本颜色应该是红色。HTML代码具有位置相关性，因为元素的正确显示取决于HTML元素的位置。改变HTML元素的位置，例如通过切换<code class="fe ma mb mc md b">content</code>和<code class="fe ma mb mc md b">header</code>的位置，将导致元素的错误显示。</p><p id="5b1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个例子显示了connascence不仅可以应用于强类型和松散类型的语言，也可以应用于标记语言，比如HTML和CSS。它基本上涵盖了前端到后端。</p><h2 id="e80f" class="mu ky it bd kz mv mw dn ld mx my dp lh kb mz na ll kf nb nc lp kj nd ne lt nf bi translated">算法的一致性</h2><p id="21bf" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">这种一致性意味着两个组件必须在特定的算法上达成一致才能正确工作。例如加密，如SHA-2、SHA512等。如果发送方改变它的加密算法，接收方也必须改变它的解密算法。</p><h2 id="d2c1" class="mu ky it bd kz mv mw dn ld mx my dp lh kb mz na ll kf nb nc lp kj nd ne lt nf bi translated">执行命令的一致性</h2><p id="83a7" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">每当两个组件的执行对于代码交付正确的结果很重要时，就会遇到执行顺序的一致性。典型的例子是资源的锁定和解锁。或者流打开和关闭。很容易理解为什么执行顺序对于代码正确工作很重要:只有在分别锁定和打开一个资源之后，才能解锁或关闭。这种一致性在过程式编程语言中最为普遍，但在函数式语言中远没有这么普遍。</p><h2 id="5711" class="mu ky it bd kz mv mw dn ld mx my dp lh kb mz na ll kf nb nc lp kj nd ne lt nf bi translated">时间的伴随性</h2><p id="be12" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">时序的一致性是指两个组件必须在执行的时序上达成一致。这通常发生在并发元素中。反面的例子是竞争条件。</p><h2 id="0216" class="mu ky it bd kz mv mw dn ld mx my dp lh kb mz na ll kf nb nc lp kj nd ne lt nf bi translated">价值的一致性</h2><p id="774a" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">这意味着几个值必须一起改变，代码才能正常工作。下面的函数返回第<code class="fe ma mb mc md b">72</code>行中的值<code class="fe ma mb mc md b">50</code>，并期望第<code class="fe ma mb mc md b">66</code>行中有相同的值。改变函数值也意味着改变断言中的值。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9c96978e1a74dc74cf9a46bd433da615.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*JpbMXOJgBBs3SQJnSKXL4w.png"/></div></figure><h2 id="d423" class="mu ky it bd kz mv mw dn ld mx my dp lh kb mz na ll kf nb nc lp kj nd ne lt nf bi translated">身份认同</h2><p id="699b" class="pw-post-body-paragraph jq jr it js b jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj lz kl km kn im bi translated">相同性意味着两个组件必须引用同一个实体。当您从代码不同部分的数据库中获取一个对象并希望更新该对象时，就会发生这种情况。一旦再次放回数据库，更新必须保持一致。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="12a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些到目前为止还挺多的。在下一部分中，我将展示一些例子，说明如何将一个更高级别的代码重构为一个更低级别的代码，从而使它变得更好。</p><p id="c905" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我很想知道，你们中有谁在日常工作中使用过connascence吗？到目前为止，你的经历是什么？</p></div></div>    
</body>
</html>