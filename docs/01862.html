<html>
<head>
<title>Pure Function vs Referential Transparency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纯函数与参照透明性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/pure-function-vs-referential-transparency-7192553d9d1?source=collection_archive---------10-----------------------#2020-02-03">https://levelup.gitconnected.com/pure-function-vs-referential-transparency-7192553d9d1?source=collection_archive---------10-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/73d4c9e2974a08b406303015c433373e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vQd_jwl3wuWfXW10.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="kf">最初发表于</em><a class="ae kg" href="https://edward-huang.com/functional-programming/tech/programming/scala/2020/01/30/pure-function-vs-referential-transparency/" rel="noopener ugc nofollow" target="_blank"><em class="kf"/></a><em class="kf">。</em></figcaption></figure><p id="ec6c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">今天我在给同事们讲授scala课程中的函数式编程，并提出了一些关于纯函数和引用透明性的问题。其中一个问题比较棘手，测试当前函数是否纯。事情是这样的:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="7b8b" class="lo lp it lk b gy lq lr l ls lt">val one = 1<br/>def method(num:Int) : Int = {<br/>  one + num<br/>}</span></pre><p id="6c78" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这个问题给出了一个有趣的讨论，函数在哪里是纯的或者不是纯的。其中一位同事说，这是一个纯函数，因为同样的输入，你总是得到同样的输出。然而，在一个纯函数中，它在定义中提到它没有“后门”，这意味着它不依赖于函数范围之外的任何隐藏值。</p><p id="c0f4" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这个函数纯不纯？</p><p id="4b10" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我给了一个答案提到基于纯函数定义，它是不纯的。</p><p id="5e17" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">我错了。</p><p id="541c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">答案是这个函数是纯函数，它是引用透明的。</p><p id="0bb2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在我们讨论纯函数和引用透明性之前，让我们先讨论一下这些术语是什么。</p><h1 id="5899" class="lu lp it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">什么是纯函数</h1><p id="efbd" class="pw-post-body-paragraph kh ki it kj b kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la mv lc ld le im bi translated">一个纯函数依赖于输入参数和算法来产生结果。</p><p id="c640" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">对于一个纯函数来说，输出依赖于输入函数，你不必担心相同的输入函数会产生不同的输出函数。</p><p id="a720" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">pure函数还具有没有副作用的功能。有什么副作用？</p><p id="afaa" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你可以认为副作用是任何使功能不可预测的东西。你希望你的函数是可预测的，这样你就永远不需要为函数的输出绞尽脑汁。</p><p id="f238" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">通常，纯函数是在运行时100%产生相同输出的函数。</p><p id="8c9b" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><code class="fe mw mx my lk b">foreach</code>仅用于其副作用。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="3248" class="lo lp it lk b gy lq lr l ls lt">def foreach(f:(A) =&gt; Unit):Unit</span></pre><p id="422e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><code class="fe mw mx my lk b">foreach</code>不产生任何回报的事实并不是一个纯粹的函数，因为该函数意味着产生副作用，比如<code class="fe mw mx my lk b">println</code>或者修改内部的某些变量。</p><p id="fc15" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">副作用意味着它依赖于任何外部I/O。一个纯粹的功能不能依赖于来自文件、数据库、web服务、UI的输入；它不能产生输出，如写入文件、数据库或web服务。</p><p id="e1eb" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">关于纯函数的另一个重要的事情是，如果一个函数是纯的，它也是引用透明的。</p><h1 id="6e10" class="lu lp it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">什么是参照透明性</h1><p id="9623" class="pw-post-body-paragraph kh ki it kj b kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la mv lc ld le im bi translated">如果你以前从未接触过函数式编程，你可能从未听说过这个术语。在我从事Scala项目之前，我从未听说过引用透明。面向对象编程在软件开发中非常流行，在软件工程师的面试中，这4个原则被广泛讨论，以测试候选人对面向对象编程的理解。然而，越来越多的应用程序是建立在函数式范例之上的，而引用透明性就像函数式编程的原则之一。</p><p id="b028" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">引用透明性意味着您可以用它的值替换函数，并获得相同的输出。</p><p id="e871" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">您可以构建一个映射，将函数作为键，将值作为键的另一个表示，并且可以确保无论在什么场景下，键-值对总是保持不变。</p><p id="f322" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">举个例子:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8235" class="lo lp it lk b gy lq lr l ls lt">def square(x:Int) : Int = x * x</span></pre><p id="dc59" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当你执行<code class="fe mw mx my lk b">square(2)</code>时，你将得到4。你可以在运行时用<code class="fe mw mx my lk b">x*x</code>替换<code class="fe mw mx my lk b">square(x)</code>，它会得到相同的输出，而不会真正改变程序的行为。因此，<code class="fe mw mx my lk b">square(1) + square(2)</code>可以用<code class="fe mw mx my lk b">1*1 + 2*2</code>替换，它仍然会产生相同的值。</p><p id="d4b9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">非参照透明的一个例子:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="2b0a" class="lo lp it lk b gy lq lr l ls lt">def addRandom(x:Int) : Int = {<br/>  (new util.Random).nextInt(10) + x<br/>}</span></pre><p id="a07d" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">上面的示例代码不是引用透明的，因为您不能用该函数中任何定义的值替换<code class="fe mw mx my lk b">addRandom</code>来获得相同的输出——即<code class="fe mw mx my lk b">addRandom(1) ≠ addRandom(1)</code>。</p><p id="4a17" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">另一个非引用透明的例子是Future:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="2e22" class="lo lp it lk b gy lq lr l ls lt">for {<br/>  _ &lt;- Future{println("Future1")}<br/>  _ &lt;- Future{println("Future1")}<br/>} yield {}</span></pre><p id="1459" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">未来陈述本质上是<a class="ae kg" href="http://scalapro.net/scala-futures-traverse-and-side-effects/" rel="noopener ugc nofollow" target="_blank">热切</a>的。因此，它向控制台打印两次。但是，如果Future是参照透明的，如果您这样做，它也会打印两次:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="42cb" class="lo lp it lk b gy lq lr l ls lt">val f = Future{println("Future1")}<br/>for {<br/>  _ &lt;- f<br/>  _ &lt;- f<br/>} yield {}</span></pre><p id="a278" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">但是，在这种情况下，未来只能打印一次。它表明，未来是不透明的。</p><h1 id="93ee" class="lu lp it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">纯函数等于指称透明吗？</h1><p id="4186" class="pw-post-body-paragraph kh ki it kj b kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la mv lc ld le im bi translated">声明:有很多关于<a class="ae kg" href="https://stackoverflow.com/questions/4865616/purity-vs-referential-transparency" rel="noopener ugc nofollow" target="_blank">纯度vs </a>参照透明的<a class="ae kg" href="https://www.reddit.com/r/haskell/comments/21y560/purity_and_referential_transparency_are_different/" rel="noopener ugc nofollow" target="_blank">讨论</a>，不同的人对它的实际含义有不同的看法。本文基于我在学习函数式编程语言Scala的过程中的观点和观察。</p><p id="f439" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">纯函数是参照透明的子集。为什么？因为要纯粹，你不需要有副作用和参照透明。然而，反过来可能就不对了。</p><p id="2801" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">拿这个函数来说:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8d61" class="lo lp it lk b gy lq lr l ls lt">def method(x:Int) : Int = {<br/>  println(x)<br/>  x<br/>}</span></pre><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/a03a871fb3594ce09aed111d6e69d427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XGi_upjnfoU0V1gO.png"/></div></div></figure><p id="d0b1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这个函数是引用透明的，因为您可以用print语句和x来更改底层方法；它产生相同的结果。<code class="fe mw mx my lk b">method(1)</code>将始终等于<code class="fe mw mx my lk b">method(1)</code>，<code class="fe mw mx my lk b">method(42)</code>可以替换为<code class="fe mw mx my lk b">print(42); 42</code>。但是，这个函数并不纯粹，因为它有一个IO，print语句。</p><h1 id="d617" class="lu lp it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">2020年05月30日更新</strong>:</h1><p id="333c" class="pw-post-body-paragraph kh ki it kj b kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la mv lc ld le im bi translated">学习函数式编程一段时间后，我想修改一下我写的这个语句。如果一个函数是参照透明的，那么它也是纯的。正如在Scala 的<a class="ae kg" href="https://www.manning.com/books/functional-programming-in-scala" rel="noopener ugc nofollow" target="_blank"> Functional中提到的，表达式是引用透明的——在任何程序中，表达式都可以被它的结果替换，而不会改变程序的含义。如果用引用透明参数调用一个函数也是引用透明的，我们可以说这个函数是纯的。</a></p><h1 id="866b" class="lu lp it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">主要外卖</h1><ul class=""><li id="80bb" class="nb nc it kj b kk mr ko ms ks nd kw ne la nf le ng nh ni nj bi translated">如果一个函数不是引用透明的，请注意具有相同输入的函数被多次调用时会产生一些意外的输出。</li><li id="a0b0" class="nb nc it kj b kk nk ko nl ks nm kw nn la no le ng nh ni nj bi translated">纯函数比引用透明性更具约束性。</li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="e95d" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">感谢阅读！如果你喜欢这篇文章，请随意<a class="ae kg" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank">订阅</a>我的时事通讯，每周都会收到关于科技职业的文章、有趣的链接和内容！</p><p id="b537" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">你可以关注我，也可以在<a class="ae kg" href="https://medium.com/@edwardgunawan880" rel="noopener">媒体</a>上关注我，以获得更多类似的帖子。</p></div></div>    
</body>
</html>