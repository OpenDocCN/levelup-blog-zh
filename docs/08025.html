<html>
<head>
<title>Effortless Index Files with VS Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用VS代码轻松索引文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/effortless-index-files-with-vs-code-14de324e0917?source=collection_archive---------4-----------------------#2021-03-29">https://levelup.gitconnected.com/effortless-index-files-with-vs-code-14de324e0917?source=collection_archive---------4-----------------------#2021-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="0f27" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">为什么要使用索引文件？</h1><p id="872a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果您在日常编码中大量使用Javascript/Typescript，您将会非常清楚处理导入的痛苦。跟踪保存了可重用变量/函数的深层嵌套文件会令人疲惫和困惑。如果下面显示的混乱的进口陈述让你焦虑，那么继续读下去！</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/e038be7357fb3d31e9dbaa47a47687b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6tb9ie0-2lHG94JGxVSURg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">以错误的方式导入</figcaption></figure><p id="91ac" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">我们可以通过在<code class="fe me mf mg mh b">ComponentOne</code>目录中创建一个<code class="fe me mf mg mh b">index.js</code>文件来简化上面的导入，如下所示。它充当文件中所有可导出变量和函数的目录表。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mi"><img src="../Images/d523aa5e5dabc78ca88b10e522f9c16b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UwQdqTfM-XcJYst8Rn-EAw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">索引文件充当目录</figcaption></figure><p id="f9ce" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">现在，当我们想要导入<code class="fe me mf mg mh b">NestedComponentOne</code>时，我们不需要知道它的确切文件位置。相反，我们只需要知道它所在的根目录名。当一个文件名没有在import语句中被引用时，Javascript和Typescript会自动寻找一个<code class="fe me mf mg mh b">index</code>文件来找到您想要的内容。它允许像这样干净的导入。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mj"><img src="../Images/f4890c4ad736fec46facc7686163910f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ku5cjb1Ch5rSkGLIsxpcPw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">进口做得好</figcaption></figure><h1 id="9690" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">简化您的工作流程</h1><p id="52b9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">使用<code class="fe me mf mg mh b">index</code>文件的唯一缺点是手动跟踪一个目录中的所有可导出文件。这就是我创建<a class="ae mk" href="https://marketplace.visualstudio.com/items?itemName=JordanEckowitz.indexify" rel="noopener ugc nofollow" target="_blank"> Indexify </a>的原因！安装完扩展后，您所要做的就是右键单击VS代码资源管理器中的任何目录，您将获得创建浅索引或深索引的选项(不同之处将在下面解释)。一次点击，你所有的索引为你处理！</p><p id="bf46" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">Indexify处理所有新旧Javascript/Typescript/Node.js导出格式。它还自动确定是否需要一个<code class="fe me mf mg mh b">index.js</code>或<code class="fe me mf mg mh b">index.ts</code>文件(基于导出的内容)。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ml"><img src="../Images/22bb521a5ca1c07b94a9708871a98817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yS584uxUpEKDiA7X91GAuQ.png"/></div></div></figure><h1 id="6451" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">创建浅层索引</h1><p id="3ff5" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">创建浅层索引将只包括所选目录根目录中的文件。所选文件夹中的所有子目录都将被忽略。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mm"><img src="../Images/ae57cbdaa783919cd573259bec165c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CkIMQinNrl-xjvvXtsrxxw.gif"/></div></div></figure><h1 id="288f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">创建深度索引</h1><p id="ee10" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">创建深度索引将分析所选文件夹中的所有文件和目录(无论文件嵌套有多深，它们都将被索引！).</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mm"><img src="../Images/9e053d55430cbb38abd867d4d678d8de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mBa1rgsoXEYysHTumoqreQ.gif"/></div></div></figure><h1 id="95f7" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">事后思考</h1><p id="7a4c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果您在使用该扩展时发现任何错误，请在这里或Visual Studio Marketplace中发表评论，我将很乐意解决它。我希望你和我一样觉得这个扩展很有用。</p><p id="c5b7" class="pw-post-body-paragraph kl km iq kn b ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li ij bi translated">你可以在这里找到更多细节:<a class="ae mk" href="https://marketplace.visualstudio.com/items?itemName=JordanEckowitz.indexify" rel="noopener ugc nofollow" target="_blank">https://marketplace.visualstudio.com/items?itemName = jordaneckowitz . indexify</a></p></div></div>    
</body>
</html>