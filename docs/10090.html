<html>
<head>
<title>Go Loop Exploration: Go vs. Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go循环探索:Go与Java</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-go-loop-exploration-e2d465af8c25?source=collection_archive---------3-----------------------#2021-10-25">https://levelup.gitconnected.com/the-go-loop-exploration-e2d465af8c25?source=collection_archive---------3-----------------------#2021-10-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="763e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">for和for-range、Go和Java之间的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/056572e6922d81748266ef5b1dad1e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ByFeuey3KoROTZow"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Go VS. Java，来自unsplash，<a class="ae ky" href="https://unsplash.com/photos/diRzqWT67CA" rel="noopener ugc nofollow" target="_blank"> @chipsundhampagner </a></figcaption></figure><p id="64ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过比较学习总是有助于加深理解。作为一名Java老手，我忍不住将我学习的任何新语言与它进行比较，这让我对每种语言的优缺点有了全面的了解。并且在同一种语言中的不同实现之间进行比较，这样你就能记住它们的特性，这永远不会让你失望。我不得不承认，在研究了Go语言的编码策略和内部实现逻辑之后，我越来越喜欢它了。</p><p id="c9f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go的效率部分是由于它的底层实现，我想在本文中深入探讨这一点，以最常用的语法<code class="fe lv lw lx ly b">for loop</code>为例。Go中的<code class="fe lv lw lx ly b">for loop</code>不仅支持简单的索引遍历，还支持<code class="fe lv lw lx ly b">for-range</code>遍历，有点类似于Java中传统的<code class="fe lv lw lx ly b">for</code>和<code class="fe lv lw lx ly b">foreach</code>语法。让我送你下去。</p><h1 id="2f62" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">关键要点</h1><ul class=""><li id="05a8" class="mr ms it lb b lc mt lf mu li mv lm mw lq mx lu my mz na nb bi translated"><code class="fe lv lw lx ly b">for-range</code>和<code class="fe lv lw lx ly b">for</code>的区别</li><li id="24ea" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe lv lw lx ly b">for-range</code>和<code class="fe lv lw lx ly b">for</code>的性能</li><li id="ab81" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe lv lw lx ly b">for-range</code>的底层实现</li><li id="4171" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">Go的<code class="fe lv lw lx ly b">for-range</code>与Java的<code class="fe lv lw lx ly b">for/foreach</code>的性能比较</li><li id="ca56" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe lv lw lx ly b">For-range</code>的可能性</li></ul><h1 id="aaaa" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">在Go中为-range和For</h1><p id="0a75" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><code class="fe lv lw lx ly b">For</code>只能通过索引访问数组或切片，而<code class="fe lv lw lx ly b">for-range</code>可以支持索引和值得遍历。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bc35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且<code class="fe lv lw lx ly b">for-range</code>支持更多的遍历类型，比如字符串、映射、通道、切片等。上述示例中的<code class="fe lv lw lx ly b">i</code>和<code class="fe lv lw lx ly b">val</code>可以替换为<code class="fe lv lw lx ly b">_</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e0da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记下以下几点可以帮助你避免错误。</p><ul class=""><li id="2a86" class="mr ms it lb b lc ld lf lg li nm lm nn lq no lu my mz na nb bi translated"><code class="fe lv lw lx ly b">for-range</code>中的<code class="fe lv lw lx ly b">val</code>是一个值副本，不能直接使用和修改，只能赋给一个新变量后使用。</li><li id="4d0b" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe lv lw lx ly b">For-range</code>遍历地图，结果未排序。在上面的<code class="fe lv lw lx ly b">map</code>例子中，多次执行后结果可能会有所不同。</li><li id="f610" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe lv lw lx ly b">For-range</code>只能通过索引修改元素值。</li></ul><p id="b300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将跳过例子，其中一些可以在我以前的文章<a class="ae ky" href="https://laiyuanyuan-sg.medium.com/top-10-go-coding-traps-ff3a546ec9e6" rel="noopener"> <em class="np">十大Go编码陷阱</em> </a>中找到。</p><h1 id="d036" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">对于范围和性能而言</h1><p id="1c02" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们看看在基准测试中使用<code class="fe lv lw lx ly b">for</code>索引、<code class="fe lv lw lx ly b">for-range</code>索引和<code class="fe lv lw lx ly b">for-range</code>值时的性能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="edbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里看不出有多大区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/75d863deb7768689db39b5c4b401e2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Pj4zo4KGdngjaAHa"/></div></div></figure><p id="979b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我们将遍历对象从int改为包含大数组的struct时，即使没有调用大数组，这种差异也会显现出来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/3a830fb3a8407580f062aa06a7eaef1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i7E5Lx91gliMZ1Iy"/></div></div></figure><p id="2547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯值遍历的性能很差，只要看一眼源代码就能很容易地找出原因。</p><h1 id="8e62" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">For-range底层实现</h1><p id="1cdd" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们从第一次基准测试中可以看到，因为在底层实现 <code class="fe lv lw lx ly b"><strong class="lb iu">for-range</strong></code> <strong class="lb iu">时应用了<code class="fe lv lw lx ly b"><strong class="lb iu">for</strong></code> <strong class="lb iu">循环，所以<code class="fe lv lw lx ly b">for-range</code>和<code class="fe lv lw lx ly b">for</code>循环在正常情况下的性能几乎相同。</strong></strong></p><p id="be26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然不同的类型有不同的实现，但它们基本上共享下面的<a class="ae ky" href="https://github.com/golang/gofrontend/blob/925ace70ac7426c3f8b5c0bfb75aa9601f071de4/go/statements.cc#L6538" rel="noopener ugc nofollow" target="_blank">代码结构</a>。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="ac58" class="nw ma it ly b gy nx ny l nz oa">// Arrange to do a loop appropriate for the type.  We will produce</span><span id="c6b8" class="nw ma it ly b gy ob ny l nz oa">//   for INIT ; COND ; POST {</span><span id="66b2" class="nw ma it ly b gy ob ny l nz oa">//           ITER_INIT</span><span id="e048" class="nw ma it ly b gy ob ny l nz oa">//           INDEX = INDEX_TEMP</span><span id="7276" class="nw ma it ly b gy ob ny l nz oa">//           VALUE = VALUE_TEMP // If there is a value</span><span id="1137" class="nw ma it ly b gy ob ny l nz oa">//           original statements</span><span id="f8bd" class="nw ma it ly b gy ob ny l nz oa">//   }</span></pre><p id="dfdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，slice的<code class="fe lv lw lx ly b">for-range</code>实现的<a class="ae ky" href="https://github.com/golang/gofrontend/blob/925ace70ac7426c3f8b5c0bfb75aa9601f071de4/go/statements.cc#L6758" rel="noopener ugc nofollow" target="_blank">主逻辑</a>:</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="f320" class="nw ma it ly b gy nx ny l nz oa">// The loop we generate:</span><span id="0e03" class="nw ma it ly b gy ob ny l nz oa">//   for_temp := range</span><span id="aec8" class="nw ma it ly b gy ob ny l nz oa">//   len_temp := len(for_temp)</span><span id="6c55" class="nw ma it ly b gy ob ny l nz oa">//   for index_temp = 0; index_temp &lt; len_temp; index_temp++ {</span><span id="f83c" class="nw ma it ly b gy ob ny l nz oa">//           value_temp = for_temp[index_temp]</span><span id="9b03" class="nw ma it ly b gy ob ny l nz oa">//           index = index_temp</span><span id="753c" class="nw ma it ly b gy ob ny l nz oa">//           value = value_temp</span><span id="ffda" class="nw ma it ly b gy ob ny l nz oa">//           original body</span><span id="a54d" class="nw ma it ly b gy ob ny l nz oa">//   }</span></pre><p id="4089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们抓住了第二个性能测试缓慢的根本原因。由于每次都要复制值，所以当值是一个巨大的对象时，占用的内存更多，执行的GC也更频繁。</p><p id="56e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，其他四种类型的<code class="fe lv lw lx ly b">for-range</code>结构都是在:</p><ul class=""><li id="2d8f" class="mr ms it lb b lc ld lf lg li nm lm nn lq no lu my mz na nb bi translated">对于数组，<a class="ae ky" href="https://github.com/golang/gofrontend/blob/925ace70ac7426c3f8b5c0bfb75aa9601f071de4/go/statements.cc#L6641" rel="noopener ugc nofollow" target="_blank"> lower_range_array </a></li><li id="3992" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">对于字符串，<a class="ae ky" href="https://github.com/golang/gofrontend/blob/925ace70ac7426c3f8b5c0bfb75aa9601f071de4/go/statements.cc#L6743" rel="noopener ugc nofollow" target="_blank">下限_范围_字符串</a></li><li id="a784" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">对于地图，<a class="ae ky" href="https://github.com/golang/gofrontend/blob/925ace70ac7426c3f8b5c0bfb75aa9601f071de4/go/statements.cc#L6992" rel="noopener ugc nofollow" target="_blank">下限_范围_地图</a></li><li id="a0f2" class="mr ms it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">对于通道，<a class="ae ky" href="https://github.com/golang/gofrontend/blob/925ace70ac7426c3f8b5c0bfb75aa9601f071de4/go/statements.cc#L7094" rel="noopener ugc nofollow" target="_blank">下限_范围_通道</a></li></ul><p id="c380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，<code class="fe lv lw lx ly b">for-range</code>其实就是一个简单的句法糖。读下面两个循环代码的汇编代码，你会发现基本上是一样的。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="a061" class="nw ma it ly b gy nx ny l nz oa">s := []int{1, 2, 3}<br/>for i, val := range s {<br/>  println(i, ":", val)<br/>}</span><span id="ead4" class="nw ma it ly b gy ob ny l nz oa">for i := 0; i &lt; len(s); i++ {<br/>  println(i, ":", s[i])<br/>}</span></pre><p id="b3d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查下面的结果，如果感兴趣，完整的编译<a class="ae ky" href="https://gist.github.com/slaise/8cfdca8cad9d0510968d3b6a3aac838b" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/103c09c1527116d37306faedb755d7fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CfGJSC4YrZsdi745"/></div></div></figure><p id="c99e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不去分析汇编代码的生成，这太复杂了。但是循环的本质是处理<code class="fe lv lw lx ly b">OFOR</code>类型的节点。详细代码见<a class="ae ky" href="http://cmd/compile/internal/gc/ssa.go" rel="noopener ugc nofollow" target="_blank">src/cmd/compile/internal/GC/SSA . go</a>。</p><h1 id="6468" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Go for-range和Java for/foreach</h1><p id="7284" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">看到Java在相同条件下如何表现的想法一闪而过。为什么不尝试使用与第一个基准测试中的Go代码相似的Java代码呢？</p><p id="8e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我使用<a class="ae ky" href="https://github.com/openjdk/jmh" rel="noopener ugc nofollow" target="_blank"> jmh </a>基准框架来执行下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d5ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代10次后，最终的测试报告出来了。查看完整记录<a class="ae ky" href="https://gist.github.com/slaise/53a858330cf012c1321808d2299a70d3" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/08b47e617256cdbfc18b42c14912ef5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Pu0MXzTcVFUEgaBB"/></div></div></figure><p id="2afe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">令人惊讶的是，</strong>平均153.44ns/op，几乎比Go代码快4倍！🙀</p><p id="f6a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java beats🤜以性能优异著称的围棋？这怎么可能呢？</p><p id="6572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我猜原因是JVM的动态编译出色，优化了基准代码循环中的无效代码，一定程度上提升了性能。</p><p id="2d2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过<code class="fe lv lw lx ly b">javap -v</code>查看汇编代码，你会发现<code class="fe lv lw lx ly b">foreach</code>实际上是通过<code class="fe lv lw lx ly b">list.iterator</code>和<code class="fe lv lw lx ly b">hasNext/next</code>方法实现的，其中<code class="fe lv lw lx ly b">hasNext</code>和<code class="fe lv lw lx ly b"> next</code>只执行一次，因此性能很高。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/74bb2f665bf288863a736ef276d85ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YFDWvcjX_JPVXwL1"/></div></div></figure><p id="e050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，Java编译器(JIT)寻求通过那些有用的循环优化方法来优化代码，比如<a class="ae ky" href="https://blogs.oracle.com/javamagazine/post/loop-unrolling" rel="noopener ugc nofollow" target="_blank">循环展开</a>、<a class="ae ky" href="https://www.sciencedirect.com/topics/computer-science/loop-tiling" rel="noopener ugc nofollow" target="_blank">循环平铺</a>、<a class="ae ky" href="http://underpop.online.fr/j/java/help/loop-interchange-compiler-java-programming-language.html.gz" rel="noopener ugc nofollow" target="_blank">循环互换</a>、<a class="ae ky" href="https://stackoverflow.com/questions/42804226/loop-fusion-of-stream-in-java-8-how-it-works-internally" rel="noopener ugc nofollow" target="_blank">循环融合</a>等。</p><p id="6fa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免编译器优化，我做了一个简单的迂回，给数组赋值，而不是引用数组元素的默认值。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="a995" class="nw ma it ly b gy nx ny l nz oa">public void foreach(int times) {<br/>  int[] l = new int[1024];<br/>  for (int i = 0; i &lt; times; i++) {<br/>     int a = 0;<br/>     for (int j = 0; j &lt; l.length; j++) {<br/>       l[j] = a++;<br/>     }<br/>     int b = a;<br/>  }<br/>}</span></pre><p id="4b52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后再考，再惊。性能大大降低。随着nanoTime值的立即提升，我无法测量这种降低，或者可能是百万分之一(240937626对153)？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/de4e7aa9af90f789a029481cda7d5f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5OmyCDYcxWrv2Ght"/></div></div></figure><p id="56f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，用同样的方法重写Go代码后，测试结果并没有太大的不同，甚至有所改善。</p><pre class="kj kk kl km gt ns ly nt nu aw nv bi"><span id="3eb6" class="nw ma it ly b gy nx ny l nz oa">func BenchmarkFor(b *testing.B) {<br/>  var items [1024]int<br/>  for i := 0; i &lt; b.N; i++ {<br/>    var tmp int<br/>    for k := 0; k &lt; len(items); k++ {<br/>      items[k] = tmp<br/>      tmp = tmp+1<br/>    }<br/>    _ = tmp<br/>  }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/f06e0741613963c99c567c5e174d290a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XtA1FOsJqYQqjtB9"/></div></div></figure><h1 id="f3bf" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">射程的可能性</h1><p id="1879" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">毫无疑问，Go为for-loop相关的实现提供了足够的支持，满足了几乎所有的需求。然而，一些问题仍然没有解决，其中最受关注的是<code class="fe lv lw lx ly b">for i, val:= range arr</code>中的<code class="fe lv lw lx ly b">val</code>值复制。要使用它，你需要在循环中给一个新的变量赋值，这容易出错而且很麻烦。另一个令人头痛的问题是命名变量，许多地鼠都注意到了这一点，所以这里出现了<a class="ae ky" href="https://github.com/golang/go/issues/20733" rel="noopener ugc nofollow" target="_blank">在每次迭代中重新定义范围循环变量的提议</a>。还是保持对Go2的期待吧。</p><h1 id="59b6" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结束了</h1><p id="16d0" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">一系列的实践、测试和源代码跟踪加深了我对<code class="fe lv lw lx ly b">for-range</code>底层实现的理解，探索本身非常有趣。将Go与其他语言进行比较有助于想象它的优点和缺点。永远保持学习、比较和反思我们的围棋之旅！</p></div></div>    
</body>
</html>