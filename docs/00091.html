<html>
<head>
<title>Learn Redux by Building Redux from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过从头开始构建Redux来学习Redux</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-redux-by-building-redux-from-scratch-dcbcbd31b0d0?source=collection_archive---------0-----------------------#2018-02-26">https://levelup.gitconnected.com/learn-redux-by-building-redux-from-scratch-dcbcbd31b0d0?source=collection_archive---------0-----------------------#2018-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a409" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过逐步构建来理解核心Redux库的教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d873921238069ca7a1e285d2b008fcd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gHAUdUHThcLbSufj0kPxzg.jpeg"/></div></div></figure><p id="9805" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本教程将介绍如何从头构建核心Redux库。完成之后，通过将这个库应用到一个简单的Redux应用程序中，您将理解Redux的基本概念。</p><div class="lq lr gp gr ls lt"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">React的前48门课程。教程由开发者提交并投票，让你找到最好的反应…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">gitconnected.com</p></div></div><div class="mc l"><div class="md l me mf mg mc mh ks lt"/></div></div></a></div><p id="9feb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">刚接触Redux的开发人员经常被库吓倒。但是，核心原理其实很有道理理解。一旦您了解了React的绑定等附加细节并将其集成到项目中，您将了解为什么它被称为一个简单且可预测的状态管理库。</p><h1 id="c3aa" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">核心概念</h1><blockquote class="na"><p id="0b9f" class="nb nc it bd nd ne nf ng nh ni nj lp dk translated">" Redux是JavaScript应用程序的可预测状态容器."</p></blockquote><p id="d55a" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">在深入研究代码之前，我们先简要介绍一下Redux。如果这还没有意义，请在完成示例后继续参考它。</p><p id="0155" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Redux用于存储应用程序状态。应用程序状态由两个关键输入组成:</p><ol class=""><li id="4452" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp nu nv nw nx bi translated">从服务器发送的数据</li><li id="b119" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated">用户与用户界面/应用程序的交互</li></ol><p id="7ba9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Redux管理<code class="fe od oe of og b">store</code>中的应用状态。状态本身只是一个普通的JavaScript对象。该存储还提供了更新状态和读取状态的方法。</p><p id="320b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Redux的核心是发布/订阅(PubSub)模式，这是一种类似于JavaScript中大量使用的事件驱动架构的<a class="ae oh" href="https://github.com/millermedeiros/js-signals/wiki/Comparison-between-different-Observer-Pattern-implementations" rel="noopener ugc nofollow" target="_blank">观察者模式</a>的形式。在Redux中，当用户与UI交互时，它可以分派(发布)一个动作。不应该过多考虑动作的概念——它只是一个普通的JavaScript对象，包含一个用于标识它的唯一键<code class="fe od oe of og b">type</code>和一个额外的数据<code class="fe od oe of og b">payload</code>。</p><p id="8858" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用该动作，基于接收到的<code class="fe od oe of og b">type</code>和<code class="fe od oe of og b">payload</code>更新状态。组件可以订阅状态更改，并将基于新的状态树更新UI。</p><p id="6cf9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个流程的一个简单表示就是<code class="fe od oe of og b">user interaction publishes an action -&gt; the reducer updates the state -&gt; subscribed components update the UI based on the new state</code>。基于这一概念，Redux有三个核心原则:</p><ol class=""><li id="2ed5" class="np nq it kw b kx ky la lb ld nr lh ns ll nt lp nu nv nw nx bi translated"><strong class="kw iu">真理的单一来源</strong>。UI的整个状态是从单个对象派生的。</li><li id="4eeb" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated"><strong class="kw iu">状态为只读</strong>。视图和回调都不能写入状态。状态只能在发出一个动作(发布)时改变，这个动作只是一个普通的JavaScript对象，作为一个参数传递给reducer。</li><li id="fbc6" class="np nq it kw b kx ny la nz ld oa lh ob ll oc lp nu nv nw nx bi translated"><strong class="kw iu">纯功能的变化</strong>。状态不会直接更新。<a class="ae oh" href="http://redux.js.org/docs/Glossary.html#reducer" rel="noopener ugc nofollow" target="_blank"> reducer函数</a>采用之前的状态(也是一个普通对象)并基于之前的状态和动作对象创建一个新的状态对象。你应该总是返回一个新的对象，不要改变当前的对象。</li></ol><p id="9e07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样——简而言之就是Redux。如果它看起来令人困惑，不要担心，当我们实现代码时，一切都会变得清晰。</p><h1 id="8d27" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated"><strong class="ak">初级冗余方法</strong></h1><p id="4e8c" class="pw-post-body-paragraph ku kv it kw b kx oi ju kz la oj jx lc ld ok lf lg lh ol lj lk ll om ln lo lp im bi translated">Redux以<code class="fe od oe of og b">store</code>为中心。store是一个JavaScript对象，它包含状态以及更新(<code class="fe od oe of og b">dispatch()</code>)和读取(<code class="fe od oe of og b">subscribe()/getState()</code>)状态的方法。还有<code class="fe od oe of og b">listeners</code>根据订阅的组件的状态变化执行功能。从视觉上看，商店采用以下形式:</p><pre class="kj kk kl km gt on og oo op aw oq bi"><span id="4c64" class="or mj it og b gy os ot l ou ov">const store = {<br/>  state: {}, // state is an object<br/>  listeners: [], // listeners are an array of functions<br/>  dispatch: () =&gt; {}, // dispatch is a function<br/>  subscribe: () =&gt; {}, // subscribe is a function<br/>  getState: () =&gt; {}, // getState is a function<br/>}</span></pre><p id="f786" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了利用这个存储对象来管理状态，我们将构建一个<code class="fe od oe of og b">createStore()</code>函数。我把<code class="fe od oe of og b">createStore()</code>的最终形态贴在下面，然后我们一节一节的分解。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="oy oz gj gh gi pa pb bd b be z dk translated">Redux的核心只有18行代码，这很疯狂，对吗？</figcaption></figure><p id="392d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe od oe of og b">createStore</code>函数有两个参数，一个<code class="fe od oe of og b">reducer</code>和一个<code class="fe od oe of og b">initialState</code>。我们将在下一节中深入讨论reducer，但是现在只知道它是一个指示状态应该如何更新的函数。</p><p id="af97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe od oe of og b">createStore</code>函数从创建<code class="fe od oe of og b">store</code>对象开始。然后它初始化<code class="fe od oe of og b">store.state = initialState</code>，如果开发者没有提供的话，它将是未定义的。<code class="fe od oe of og b">state.listeners</code>被初始化为空数组。</p><p id="4cbd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们定义为商店一部分的第一个功能是<code class="fe od oe of og b">getState()</code>。这只是在被调用时返回<code class="fe od oe of og b">state</code>。<code class="fe od oe of og b">store.getState = () =&gt; store.state;</code></p><p id="b539" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们允许我们的UI<code class="fe od oe of og b">subscribe</code>适应状态的变化。订阅的行为意味着我们向subscribe方法传递一个函数，这个侦听器函数被添加到listeners数组中。<code class="fe od oe of og b">typeof listener === 'function' // true</code>。</p><p id="81f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在每次状态改变时，我们遍历整个函数数组并执行每个函数。</p><pre class="kj kk kl km gt on og oo op aw oq bi"><span id="461e" class="or mj it og b gy os ot l ou ov">store.listeners.forEach(listener =&gt; listener());</span></pre><p id="b1b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来我们定义<code class="fe od oe of og b">dispatch</code>函数。当用户与UI交互时，组件将调用调度函数。Dispatch接受一个参数，这个参数是一个<code class="fe od oe of og b">action</code>对象。该动作应该完整地描述用户接收到的交互。与当前状态一起，动作被传递给reducer函数，然后该函数返回一个全新的应用程序状态。</p><p id="f85a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在reducer创建了新的<code class="fe od oe of og b">state</code>之后，listeners数组被遍历，每个函数都被执行。通常在<code class="fe od oe of og b">listener</code>函数内部调用<code class="fe od oe of og b">getState</code>函数，因为其目的是对状态变化做出反应。</p><p id="c057" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，这个流程是一个非常线性和同步的过程。侦听器函数被添加到单个侦听器数组中。当用户与应用程序交互时，它可以导致调度一个操作。此操作将创建状态的可预测的离散变化。然后，侦听器数组按照每个被调用的侦听器函数的顺序循环。</p><p id="c60a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个过程是单向数据流。只有一种方法可以创建应用程序中的更改并对其做出反应。没有什么奇特的技巧，只是一步一步地遵循与应用程序交互的简单模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><div class="lq lr gp gr ls lt"><a href="https://gitconnected.com/portfolio-api" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">组合API —轻松发展您的编码事业| gitconnected</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">消除在每个单独位置手动更新您的详细信息的痛苦。只需在您的中更改一次数据…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">gitconnected.com</p></div></div><div class="mc l"><div class="pd l me mf mg mc mh ks lt"/></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><h1 id="ed73" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">什么是减速器功能</h1><p id="83b0" class="pw-post-body-paragraph ku kv it kw b kx oi ju kz la oj jx lc ld ok lf lg lh ol lj lk ll om ln lo lp im bi translated">在上一节中，我们介绍了reducer函数作为输入，它实际上决定了状态的变化。让我们仔细看看这实际上意味着什么。</p><p id="1af2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">减速器是一个接受<code class="fe od oe of og b">state</code>和<code class="fe od oe of og b">action</code>并返回新状态的函数。我们知道在基本层面上，它必须有这样的形式:</p><pre class="kj kk kl km gt on og oo op aw oq bi"><span id="28e9" class="or mj it og b gy os ot l ou ov">const reducer = (prevState, action) =&gt; {<br/>  let nextState = {}; // an object representing the new state</span><span id="720f" class="or mj it og b gy pe ot l ou ov">  // ...<br/>  // Code that creates new state using the previous state and action<br/>  // ...</span><span id="7225" class="or mj it og b gy pe ot l ou ov">  return nextState;<br/>};</span></pre><p id="dc5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中<code class="fe od oe of og b">prevState</code>、<code class="fe od oe of og b">nextState</code>和<code class="fe od oe of og b">action</code>都是JavaScript对象。</p><p id="ecf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们更仔细地看一下<code class="fe od oe of og b">action</code>对象，了解如何使用它来更新状态。我们知道这个动作将包含一个<code class="fe od oe of og b">type</code>,它是一个唯一的字符串，用来指示用户触发的交互。</p><p id="a8b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，假设您使用Redux创建了一个简单的待办事项列表。当用户点击提交按钮将一个项目添加到待办事项列表时，会触发一个类型为<code class="fe od oe of og b">ADD_TODO</code>的动作。这既是理解正在发生的事情的一种人类可读的方式，也清楚地表明了行动的目的。当添加一个项目时，它还将包含待办事项的<code class="fe od oe of og b">text</code>,可以通过有效载荷传入。因此，将待办事项添加到列表中完全可以通过下面的action对象来实现。</p><pre class="kj kk kl km gt on og oo op aw oq bi"><span id="f321" class="or mj it og b gy os ot l ou ov">const todoAction = {<br/>  type: 'ADD_TODO',<br/>  text: 'Get milk from the store',<br/>};</span></pre><p id="6954" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以使用这些信息为一个简单的待办应用程序构建一个缩减器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="774a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，每次调用reducer时，我们都会创建一个新的对象。我们利用以前状态的数据，但是创建一个全新的状态对象。这是使redux如此可预测的另一个重要原则。通过将状态分解成离散的步骤，开发人员能够准确定位应用程序中正在发生的事情。虽然这超出了本教程的范围，但是我们可以通过重新呈现与状态变化直接对应的UI部分来优化应用程序的更新。</p><p id="e109" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会经常看到与Redux一起使用的<code class="fe od oe of og b">switch</code>语句。这是一种将字符串(在我们的例子中是动作的<code class="fe od oe of og b">type</code>)与更新状态的代码块匹配的便捷方式。这与使用如下的<code class="fe od oe of og b">if...else</code>语句来编写它没有什么不同。</p><pre class="kj kk kl km gt on og oo op aw oq bi"><span id="5240" class="or mj it og b gy os ot l ou ov">if (action.type === 'ADD_TODO') {<br/>  const nextState = {<br/>    todoList: [...prevState.todoList, action.text],<br/>  }</span><span id="76b3" class="or mj it og b gy pe ot l ou ov">  return nextState;<br/>} else {<br/>  return prevState;<br/>}</span></pre><p id="cd23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Redux不知道reducer中实际包含了什么。它是由开发人员定义的创建新状态的函数。事实上，用户几乎控制了一切——缩减器、正在使用的动作、通过subscribe执行的监听器方法。Redux只是一个薄层，它将这些联系在一起，并提供一个公共接口来与状态交互。</p><blockquote class="pf pg ph"><p id="0f49" class="ku kv pi kw b kx ky ju kz la lb jx lc pj le lf lg pk li lj lk pl lm ln lo lp im bi translated">注意:如果你以前见过<code class="fe od oe of og b">combineReducers</code>函数，它只是一个允许你在<code class="fe od oe of og b">state</code>对象中创建独立键的实用方法。它是一种封装状态树中相关的不同部分的方法，并允许开发人员编写干净的代码。在本教程中包含更多的细节可能只会造成混乱，所以你应该知道它实际上并没有改变单一状态树的实现。它将树分成块，然后将它们组合成我们已经习惯的最终单个状态对象。</p></blockquote><h1 id="324f" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">使用我们的Redux实现构建一个简单的应用程序</h1><p id="af08" class="pw-post-body-paragraph ku kv it kw b kx oi ju kz la oj jx lc ld ok lf lg lh ol lj lk ll om ln lo lp im bi translated">我们现在已经涵盖了redux理念和核心包的全部。我们可以将它们联系在一起，通过一个简单的计数器应用程序来观察它们端到端的工作情况。</p><p id="b667" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将制作一个带有<code class="fe od oe of og b">&lt;div&gt;</code>的HTML文档，包含来自Redux存储的计数。我们将打开一个脚本标签，并将目标指向<code class="fe od oe of og b">id="count”</code>节点。</p><pre class="kj kk kl km gt on og oo op aw oq bi"><span id="358e" class="or mj it og b gy os ot l ou ov">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;  <br/>  &lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;  <br/>  &lt;body&gt;<br/>    &lt;div&gt;<br/>      Random Count: &lt;span id="count"&gt;&lt;/span&gt;<br/>    &lt;/div&gt;<br/>  &lt;/body&gt;<br/>  &lt;script&gt;<br/>    const counterNode = document.getElementById('count');<br/>  &lt;/script&gt;<br/>&lt;/html&gt;</span></pre><p id="bfe1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在柜台下面的<code class="fe od oe of og b">&lt;script&gt;</code>里面，我们可以粘贴我们的<code class="fe od oe of og b">createStore</code>函数。在这个函数下面，我们将创建我们的减速器。这个缩减器将寻找一个类型为<code class="fe od oe of og b">'COUNT'</code>的动作，然后将来自动作有效负载的计数添加到已经存储在状态中的计数中。</p><pre class="kj kk kl km gt on og oo op aw oq bi"><span id="3870" class="or mj it og b gy os ot l ou ov">const getInitialState = () =&gt; {<br/>  return {<br/>    count: 0,<br/>  };<br/>};</span><span id="b34a" class="or mj it og b gy pe ot l ou ov">const reducer = (state = getInitialState(), action) =&gt; {<br/>  switch (action.type) {<br/>    case 'COUNT':<br/>      const nextState = {<br/>        count: state.count + action.payload.count,<br/>      };</span><span id="6d36" class="or mj it og b gy pe ot l ou ov">      return nextState;<br/>    default:<br/>      return state;<br/>  }<br/>};</span></pre><p id="1bad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了一个缩减器，我们可以创建商店了。使用我们新创建的商店，我们将为它订阅商店状态的更新。在每次状态改变时，我们将从状态中读取<code class="fe od oe of og b">count</code>,并将其写入DOM。</p><pre class="kj kk kl km gt on og oo op aw oq bi"><span id="b60f" class="or mj it og b gy os ot l ou ov">const store = createStore(reducer);</span><span id="1aaf" class="or mj it og b gy pe ot l ou ov">store.subscribe(() =&gt; {<br/>  const state = store.getState();<br/>  const count = state.count;<br/>  counterNode.innerHTML = count;<br/>});</span></pre><p id="ef43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们的应用程序正在监视状态的变化，让我们创建一个简单的事件侦听器来增加计数。侦听器将调度一个动作，该动作还发送一个随机数1–10作为要添加到缩减器中的计数。</p><pre class="kj kk kl km gt on og oo op aw oq bi"><span id="89ce" class="or mj it og b gy os ot l ou ov">document.addEventListener('click', () =&gt; {        <br/>  store.dispatch({          <br/>    type: 'COUNT',          <br/>    payload: {            <br/>      count: Math.ceil(Math.random() * 10),          <br/>    },        <br/>  });<br/>});</span></pre><p id="e942" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们分派一个空操作来初始化状态。由于没有action类型，所以它会命中reducer的<code class="fe od oe of og b">default</code>块，生成一个与我们从<code class="fe od oe of og b">getInitialState()</code>返回的内容相对应的状态对象。</p><pre class="kj kk kl km gt on og oo op aw oq bi"><span id="0eae" class="or mj it og b gy os ot l ou ov">store.dispatch({}); // Sets the inital state</span></pre><p id="e938" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将所有这些放在一起，我们有下面的应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="ed3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的屏幕应该类似于下图，每次单击屏幕，计数都会随机增加。注意，有一些额外的日志语句可以直观地显示状态变化时发生的情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/d613bfdcbf6bf46a0e6cba0453af2886.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/1*c04m8HCuMUywv8tGgblbrw.gif"/></div></figure><h1 id="2186" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">包裹</h1><p id="f120" class="pw-post-body-paragraph ku kv it kw b kx oi ju kz la oj jx lc ld ok lf lg lh ol lj lk ll om ln lo lp im bi translated">没你想的那么糟，对吗？您甚至可以在普通应用程序中使用Redux的这种实现，而不需要依赖第三方。我不建议在生产中推出它，因为仍然有边缘情况和优化，但我希望这简化了Redux并有助于您的理解。下一步是了解Redux的一些<a class="ae oh" href="http://redux.js.org/docs/advanced/" rel="noopener ugc nofollow" target="_blank">高级特性</a>。</p><p id="454b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果在你第一次阅读的时候，本教程的所有观点都没有达成一致，不要担心。在采取这一步骤之前，可能有必要先了解一下发布/订阅的基本原则。只要继续练习，参考这篇文章，最终都会点击的。</p><p id="4de3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个很好的资源是丹·阿布拉莫夫的T2视频。为了更深入地理解你何时以及为什么想要用Redux管理状态，Dan有一篇<a class="ae oh" href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" rel="noopener">文章</a>将它与React中的内部状态管理进行了比较。</p><div class="lq lr gp gr ls lt"><a href="https://gitconnected.com/learn/redux" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">学习Redux -最佳Redux教程(2019) | gitconnected</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">7大Redux教程。课程由开发者提交并投票，使您能够找到最好的Redux课程…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">gitconnected.com</p></div></div><div class="mc l"><div class="pp l me mf mg mc mh ks lt"/></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://levelup.gitconnected.com/"><div class="gh gi pq"><img src="../Images/439094b9a664ef0239afbc4565c6ca49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uYu-fFL3hIQLGVu0o-EQ.png"/></div></a></figure></div><div class="ab cl pr ps hx pt" role="separator"><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw"/></div><div class="im in io ip iq"><p id="74e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="pi">如果您觉得本文有帮助，请点击</em>👏<em class="pi">。</em> <a class="ae oh" href="https://medium.com/@treyhuffine" rel="noopener"> <em class="pi">关注我</em> </a> <em class="pi">获取更多关于区块链、React、JavaScript和开源软件的文章！你也可以在</em><a class="ae oh" href="https://twitter.com/treyhuffine" rel="noopener ugc nofollow" target="_blank"><em class="pi">Twitter</em></a><em class="pi">或者</em><a class="ae oh" href="https://gitconnected.com/treyhuffine" rel="noopener ugc nofollow" target="_blank"><em class="pi">git connected</em></a><em class="pi">上找到我。</em></p></div></div>    
</body>
</html>