<html>
<head>
<title>IList<t> vs List<t> Performance</t></t></title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">IList <t> vs List <t>性能</t> </t></h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ilist-t-vs-list-t-performance-dad1688a374f?source=collection_archive---------2-----------------------#2021-06-15">https://levelup.gitconnected.com/ilist-t-vs-list-t-performance-dad1688a374f?source=collection_archive---------2-----------------------#2021-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="29bf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看一下每个in的内存消耗。NET 5.0</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/117b42d7a26e1e66930f78b164b21065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PMzmn0T0j_KM1ivo"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">本杰明·沃罗斯在<a class="ae ky" href="https://unsplash.com/photos/phIFdC6lA4E" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6f50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个<code class="fe lv lw lx ly b">foreach</code>循环来比较迭代一个<code class="fe lv lw lx ly b">IList&lt;T&gt;</code>和一个<code class="fe lv lw lx ly b">List&lt;T&gt;</code>，看看哪一个使用更多的内存。</p><p id="b04b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我使用<a class="ae ky" href="https://github.com/dotnet/BenchmarkDotNet" rel="noopener ugc nofollow" target="_blank"> BenchmarkDotNet </a> NuGet包来查看分配的内存。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h2 id="fd89" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">结果</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/184c52812c3393dba329f669168099b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BHNjkoGxsI6ADBL9M_-Fg.png"/></div></div></figure><p id="5801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">IList&lt;T&gt;</code>比<code class="fe lv lw lx ly b">List&lt;T&gt;</code>多使用40个字节。</p><h2 id="30ea" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">GetEnumerator()实现</h2><p id="8c8d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">IList&lt;T&gt;</code>的额外40个字节的原因与调用<code class="fe lv lw lx ly b">GetEnumerator()</code>的时间有关，每当你越过<code class="fe lv lw lx ly b">IEnumerable</code>发现<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/foreach-and-ienumerable-ca7b9ebed754">不是数组</a>时，这就会在后台发生。</p><p id="deb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">List&lt;T&gt;</code>的<a class="ae ky" href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs#L597" rel="noopener ugc nofollow" target="_blank">源代码</a>中，你会发现三个<code class="fe lv lw lx ly b">GetEnumerator()</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="8b57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">List&lt;T&gt;</code>实现<code class="fe lv lw lx ly b">IEnumerable&lt;T&gt;</code>和<code class="fe lv lw lx ly b">IEnumerable</code>。</p><p id="8557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这两个接口都声明了一个<code class="fe lv lw lx ly b">GetEnumerator()</code>方法，所以这两个实现都使用了显式接口实现。</p><h2 id="e45f" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">拳击</h2><p id="506c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在<code class="fe lv lw lx ly b">List&lt;T&gt;</code>内部，<code class="fe lv lw lx ly b">Enumerator</code>类型是一个结构。结构不在堆上(除了作为类成员的结构)，这意味着垃圾收集器的压力更小。</p><p id="0910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当调用<code class="fe lv lw lx ly b">GetEnumerator()</code>的接口版本时，该结构被装箱并作为接口类型返回(<code class="fe lv lw lx ly b">IEnumerator</code>)。这会导致在堆上分配一个对象，这是我们可以从BenchmarkDotNet中看到的额外的40个字节。</p><p id="b847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么<code class="fe lv lw lx ly b">IList&lt;T&gt;</code>会比<code class="fe lv lw lx ly b">List&lt;T&gt;</code>使用更多内存的原因，因为<code class="fe lv lw lx ly b">List&lt;T&gt;</code>会使用返回一个unboxed struct的<code class="fe lv lw lx ly b">public Enumerator GetEnumerator(){}</code>。</p><h2 id="8e98" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">结论</h2><p id="0d2d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我并不是建议不应该使用<code class="fe lv lw lx ly b">GetEnumerator()</code>接口方法。大多数时候，您不会注意到任何性能瓶颈。但是，如果您正在编写一个性能关键的应用程序，了解实现细节会非常方便。</p></div></div>    
</body>
</html>