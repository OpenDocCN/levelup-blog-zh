<html>
<head>
<title>Complete guide to using TypeORM and TypeScript for data persistence in Node.js module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js模块中使用TypeORM和TypeScript进行数据持久化的完整指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/complete-guide-to-using-typeorm-and-typescript-for-data-persistence-in-node-js-module-bfce169959d9?source=collection_archive---------0-----------------------#2019-07-18">https://levelup.gitconnected.com/complete-guide-to-using-typeorm-and-typescript-for-data-persistence-in-node-js-module-bfce169959d9?source=collection_archive---------0-----------------------#2019-07-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><p id="1068" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">TypeORM是一个运行在Node.js中的高级对象关系管理模块。在本文中，我们将了解如何使用TypeORM来设置实体对象以在数据库中存储数据，如何使用CustomRepository实例来操作数据库表，以及如何使用实体实例之间的关系来模拟数据库连接。</p><figure class="kq kr ks kt gu ku gi gj paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gi gj kp"><img src="../Images/d4d213bdb792e019b2afb6f25a5b482f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I77m_A0idECSxpbC.png"/></div></div></figure><p id="f671" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">首先，您必须阅读本系列的前两篇文章:</p><ol class=""><li id="da90" class="lb lc iu jt b ju jv jy jz kc ld kg le kk lf ko lg lh li lj bi translated"><a class="ae lk" href="https://itnext.io/choosing-typescript-vs-javascript-technology-popularity-ea978afd6b5f" rel="noopener ugc nofollow" target="_blank">选择TypeScript vs JavaScript:技术，流行度</a></li><li id="7436" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko lg lh li lj bi translated"><a class="ae lk" href="https://medium.com/@7genblogger/how-to-set-up-typescript-compiler-and-editing-environment-with-node-js-68952aebbe1d" rel="noopener">如何用Node.js设置Typescript编译器和编辑环境</a>(TechSparx上也有<a class="ae lk" href="https://techsparx.com/nodejs/typescript/setup.html" rel="noopener ugc nofollow" target="_blank">)</a></li><li id="12b3" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko lg lh li lj bi translated"><a class="ae lk" href="https://techsparx.com/nodejs/typescript/modules-01.html" rel="noopener ugc nofollow" target="_blank">如何使用Typescript创建Node.js模块</a></li></ol><p id="b874" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="lq">这篇文章摘自我的书</em> <a class="ae lk" href="https://www.amazon.com/gp/product/B07S87X4ZK/ref=dbs_a_def_rwt_bibl_vppi_i1" rel="noopener ugc nofollow" target="_blank"> <em class="lq">在Node.js应用程序中使用Typescript和TypeORM的快速入门</em> </a></p><p id="cd1e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在本文中，我们将为Node.js创建一个简单的TypeScript模块来处理应用程序在数据库中存储数据的问题。我们遵循的概念是，大学注册办公室需要一个数据库和相应的应用程序来存储有关学生和课程的数据。</p><p id="4ed1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">因为我们使用的是TypeScript，所以使用TypeORM来简化数据库管理是很自然的。我们将创建两个实体— <em class="lq">学生</em>和<em class="lq">提供的类</em> —每个实体都有一个对应的<em class="lq">自定义存储库</em>实例。CustomRepository类将为数据库提供高级功能。</p><h1 id="0072" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">初始化模块package.json和测试目录</h1><p id="67e1" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">正如我们对所有Node.js项目所做的那样，我们首先使用<code class="fe mu mv mw mx b">npm init</code>或<code class="fe mu mv mw mx b">yarn init</code>来初始化目录，并进行其他初始化。</p><p id="c870" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们正在初始化的是一个模块，用于处理这个概念化的大学注册应用程序的数据库。我们稍后将创建代码，在这个阶段，我们只是在打基础。</p><p id="73f6" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">创建一个目录<code class="fe mu mv mw mx b">ts-example</code>，并在其中创建一个目录<code class="fe mu mv mw mx b">registrar</code>。</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="7780" class="nc ls iu mx b gz nd ne l nf ng">$ mkdir ts-example<br/>$ cd ts-example<br/>$ mkdir registrar<br/>$ cd registrar<br/>$ npm init<br/>.. answer questions</span></pre><p id="f3b5" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">初始化<code class="fe mu mv mw mx b">package.json</code>。</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="a4cc" class="nc ls iu mx b gz nd ne l nf ng">$ npm install @types/node --save-dev<br/>$ npm install typescript ts-node --save-dev<br/>$ npm install typeorm sqlite3 reflect-metadata --save</span></pre><p id="34ae" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这些包中的大部分已经在前面的文章中讨论过了。<code class="fe mu mv mw mx b">typeorm</code>包当然提供了TypeORM库。对于这个例子，我们将使用SQLite3来存储数据库，因此是<code class="fe mu mv mw mx b">sqlite3</code>包。最后，TypeORM需要<code class="fe mu mv mw mx b">reflect-metadata</code>包。</p><p id="3c9c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">创建一个名为<code class="fe mu mv mw mx b">tsconfig.json</code>的文件，其中包含:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="ceec" class="nc ls iu mx b gz nd ne l nf ng">{<br/>    "compilerOptions": {<br/>        "lib": [ "es5", "es6", "es7",<br/>                 "es2015", "es2016",<br/>                 "es2017", "es2018",<br/>                 "esnext" ],<br/>        "target": "es2017",<br/>        "module": "commonjs",<br/>        "moduleResolution": "Node",<br/>        "outDir": "./dist",<br/>        "rootDir": "./lib",<br/>        "declaration": true,<br/>        "declarationMap": true,<br/>        "inlineSourceMap": true,<br/>        "inlineSources": true,<br/>        "emitDecoratorMetadata": true,<br/>        "experimentalDecorators": true<br/>    }<br/>}</span></pre><p id="b5dc" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这与“<a class="ae lk" href="https://techsparx.com/nodejs/typescript/modules-01.html" rel="noopener ugc nofollow" target="_blank">如何使用Typescript </a>创建Node.js模块”中的略有不同。这些参数意味着:</p><ul class=""><li id="c0d6" class="lb lc iu jt b ju jv jy jz kc ld kg le kk lf ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">target</code>行表示输出ES2017代码，我们需要它，因为该版本支持异步/等待功能。</li><li id="1fc3" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">module</code>行描述将要使用的输出模块格式，<code class="fe mu mv mw mx b">commonjs</code>匹配使用CommonJS模块格式的决定。</li><li id="4b95" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">moduleResolution</code>参数表示像NodeJS一样在<code class="fe mu mv mw mx b">node_modules</code>目录中查找模块。</li><li id="a3bc" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">outDir</code>参数表示将文件编译到指定目录中，<code class="fe mu mv mw mx b">rootDir</code>参数表示将文件编译到指定目录中。</li><li id="027f" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">declaration</code>和<code class="fe mu mv mw mx b">declarationMap</code>参数表示生成申报文件。</li><li id="612f" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">inlineSourceMap</code>和<code class="fe mu mv mw mx b">inlineSources</code>表示在JavaScript源文件中生成源映射数据。</li><li id="26ab" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko nh lh li lj bi translated">TypeORM在生成代码时使用<code class="fe mu mv mw mx b">emitDecoratorMetadata</code>和<code class="fe mu mv mw mx b">experimentalDecorators</code>。</li></ul><p id="d70f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这意味着我们的源代码将在<code class="fe mu mv mw mx b">lib</code>中，TypeScript将把它编译成<code class="fe mu mv mw mx b">dist</code>。</p><p id="c6d1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们在<code class="fe mu mv mw mx b">package.json</code>中有一点小小的改变:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="d6b1" class="nc ls iu mx b gz nd ne l nf ng">{<br/>  ...<br/>  "main": "dist/index.js",<br/>  "types": "./dist/index.d.ts",<br/>  "type": "commonjs",<br/>  "scripts": {<br/>    "build": "tsc",<br/>    "watch": "tsc --watch",<br/>    "test": "cd test &amp;&amp; npm run test"<br/>  },<br/>  ...<br/>}</span></pre><p id="82b5" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe mu mv mw mx b">build</code>脚本只是运行<code class="fe mu mv mw mx b">tsc</code>来编译源代码。<code class="fe mu mv mw mx b">test</code>脚本切换到<code class="fe mu mv mw mx b">test</code>目录来运行测试套件。</p><p id="ef47" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个包的<code class="fe mu mv mw mx b">main</code>是生成的<code class="fe mu mv mw mx b">index</code>模块，具体是<code class="fe mu mv mw mx b">dist/index.js</code>。对于前面显示的<code class="fe mu mv mw mx b">tsconfig.json</code>，TypeScript源代码在<code class="fe mu mv mw mx b">lib</code>目录中，因此模块的主接口应该在<code class="fe mu mv mw mx b">lib/index.ts</code>中。TypeScript编译器编译<code class="fe mu mv mw mx b">lib/index.ts</code>到<code class="fe mu mv mw mx b">dist/index.js</code>。<code class="fe mu mv mw mx b">type</code>属性是NodeJS 12.x的新特性，它允许我们声明这个包中使用的模块种类。如果<code class="fe mu mv mw mx b">dist/index.js</code>改为ES6模块格式，属性值将改为<code class="fe mu mv mw mx b">module</code>。</p><p id="7c9e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe mu mv mw mx b">types</code>字段向世界声明这个模块包含类型定义。自动生成类型定义是一种很好的形式，前面显示的<code class="fe mu mv mw mx b">tsconfig.json</code>文件就是这样做的，然后确保全世界都知道包含了类型定义。</p><h1 id="3204" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">设置测试目录</h1><p id="f428" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">与应用程序代码一起创建单元测试套件是很有用的。单元测试有很多种方法，所以把这当成一个人的意见。</p><p id="93f3" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">ts-example/registrar</code>目录中，创建一个名为<code class="fe mu mv mw mx b">test</code>的目录，并初始化一个新的<code class="fe mu mv mw mx b">package.json</code>。</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="5379" class="nc ls iu mx b gz nd ne l nf ng">$ mkdir test<br/>$ cd test<br/>$ npm init<br/>.. answer questions<br/>$ npm install chai mocha --save-dev</span></pre><p id="d1d3" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们将使用Chai和Mocha来编写测试。因为我们已经配置了TypeScript来生成CommonJS模块，所以我们将以默认方式使用Mocha。Mocha目前支持测试CommonJS模块，而使用Mocha测试ES6模块需要经过几道关卡。</p><p id="2373" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">现在编辑<code class="fe mu mv mw mx b">test</code>目录中的<code class="fe mu mv mw mx b">package.json</code>，使其看起来像这样:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="54c0" class="nc ls iu mx b gz nd ne l nf ng">{<br/>    "name": "registrar-test",<br/>    "version": "1.0.0",<br/>    "description": "Test suite for student registrar library",<br/>    "main": "index.js",<br/>    "scripts": {<br/>        "pretest": "cd .. &amp;&amp; npm run build",<br/>        "test": "rm -f registrardb.sqlite &amp;&amp; mocha ./index"<br/>    },<br/>    "author": "David Herron &lt;david@davidherron.com&gt;",<br/>    "license": "ISC",<br/>    "devDependencies": {<br/>        "chai": "^4.2.0",<br/>        "mocha": "^6.1.4"<br/>    },<br/>    "dependencies": {}<br/>}</span></pre><p id="04ba" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">对于Mocha和Chai版本号，请使用最新版本。这里重要的是两个脚本。为了运行测试，我们使用了<code class="fe mu mv mw mx b">mocha</code>命令，但是在运行测试之前，我们希望确保源代码被重新构建。因此<code class="fe mu mv mw mx b">pretest</code>脚本转到父目录并运行构建脚本。</p><p id="668e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">因为我们还没有编写测试代码，或者应用程序代码，所以我们还不能运行任何东西。耐心点，我们会在文章结束前进行测试。</p><h1 id="059a" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">index.ts —注册模块的主要编程接口</h1><p id="b3b1" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">打下基础后，我们可以开始编写代码来处理数据库。在<code class="fe mu mv mw mx b">lib</code>目录下创建一个名为<code class="fe mu mv mw mx b">index.ts</code>的文件。记住，<code class="fe mu mv mw mx b">lib/index.ts</code>被编译成<code class="fe mu mv mw mx b">dist/index.js</code>，并将作为这个模块的主入口点。</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="9689" class="nc ls iu mx b gz nd ne l nf ng">import "reflect-metadata";<br/>import { createConnection, Connection } from "typeorm";<br/>import { Student } from './entities/Student';<br/>export { Student } from './entities/Student';<br/>import { StudentRepository } from './StudentRepository';<br/>export { StudentRepository } from './StudentRepository';<br/>import { OfferedClassRepository } from './OfferedClassRepository';<br/>export { OfferedClassRepository } from './OfferedClassRepository';<br/>import { OfferedClass } from './entities/OfferedClass';<br/>export { OfferedClass } from './entities/OfferedClass';</span><span id="9890" class="nc ls iu mx b gz ni ne l nf ng">var  _connection: Connection;</span><span id="56f3" class="nc ls iu mx b gz ni ne l nf ng">export async function connect(databaseFN: string) {<br/>    _connection = await createConnection({<br/>        type: "sqlite",<br/>        database: databaseFN,<br/>        synchronize: true,<br/>        logging: false,<br/>        entities: [<br/>            Student, OfferedClass<br/>        ]<br/>     });<br/>}</span><span id="fd26" class="nc ls iu mx b gz ni ne l nf ng">export function connected() { <br/>    return typeof _connection !== 'undefined'; <br/>}</span><span id="0c83" class="nc ls iu mx b gz ni ne l nf ng">export function getStudentRepository(): StudentRepository {<br/>    return _connection.getCustomRepository(StudentRepository);<br/>}</span><span id="a310" class="nc ls iu mx b gz ni ne l nf ng">export function getOfferedClassRepository(): OfferedClassRepository {<br/>    return _connection.getCustomRepository(OfferedClassRepository);<br/>}</span></pre><p id="6679" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">如果这看起来不太像，请考虑所有的功能都存在于这里导入的文件中。考虑如何构建覆盖大型数据库的API。你想把所有的功能都集成到一个模块中吗？不，那一个模块会很笨重。相反，你应该把事情模块化，就像这里看到的。这里所有的都是管理数据库连接的函数。名为<em class="lq"> StudentRepository </em>和<em class="lq"> OfferedClassRepository </em>的类包含了相应表的CRUD操作。</p><p id="dbfc" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这两个类是TypeORM CustomRepository类的实例。CustomRepository本身是Repository的一个实例，提供了处理对应于TypeORM实体的数据库表的基本功能。</p><p id="2d4d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">通常情况下，您会像这样使用基本存储库类:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="bcb5" class="nc ls iu mx b gz nd ne l nf ng">const studentRepository = getRepository(Student);</span></pre><p id="e84b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">但是我们想在我们的应用程序中添加一些自定义函数。因此，我们将实现所谓的<em class="lq">自定义存储库</em>类。<em class="lq"> getStudentRepository </em>函数处理定制存储库实现的生成。</p><p id="0ef6" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">另一段重要的代码是建立数据库连接的<em class="lq"> connect </em>函数。这应该在应用程序启动后立即调用。它只是使用<code class="fe mu mv mw mx b">createConnection</code>初始化数据库连接。该函数使用一个描述符对象来连接实际的数据库，并进行其他配置。</p><p id="b27e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">TypeORM当然支持多种数据库，为了简单起见，我们使用SQLite3，因为它不需要设置数据库服务器。</p><p id="1ea7" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe mu mv mw mx b">entities</code>数组是我们告诉TypeORM可用对象类型的方式。它创建一个匹配每个实体的数据库表，从实体字段定义表模式。</p><p id="741d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在这种情况下,<code class="fe mu mv mw mx b">entities</code>数组包含稍后将定义的实体类。每当我们添加另一个实体类时，我们都必须记住更新这个文件，以便TypeORM知道这个实体。也可以传递一个通配符文件名，以便TypeORM自动获取所有实体。</p><p id="5867" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">如果你搞乱了<code class="fe mu mv mw mx b">entities</code>配置，就有可能花很长时间来调试。TypeORM会告诉你它找不到实体的元数据，而且不清楚为什么会这样。如果我们要像这里显示的那样做，并在<code class="fe mu mv mw mx b">entities</code>数组中传递实体，那么我们必须小心。它必须是实体类引用，而不是包含实体类的模块。</p><h1 id="eddd" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">创建类型实体类和CRUD方法</h1><p id="e08e" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">在上一节中，我们实现了注册数据库的主API。但是我们引用了几个提供大部分功能的类。</p><p id="6531" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在这个应用程序中，我们使用了TypeORM的两个主要特性:</p><ol class=""><li id="813d" class="lb lc iu jt b ju jv jy jz kc ld kg le kk lf ko lg lh li lj bi translated">实体类-将简单的对象定义映射到数据库表</li><li id="a0d8" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko lg lh li lj bi translated">自定义存储库类——用于操作数据库表的有用API函数</li></ol><p id="29ec" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">每个存储库类都与一个实体类相关联，因此它的函数操作与该实体相关联的表。通过实现一个定制的存储库类，我们将创建额外的功能。</p><h1 id="32a9" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">类型实体</h1><p id="37dc" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">在TypeORM中，一个<em class="lq">实体</em>在一个TypeScript类和一个数据库表之间映射。通过在类定义的顶部添加<code class="fe mu mv mw mx b">@Entity()</code>注释，然后为类中的每个字段添加一个<code class="fe mu mv mw mx b">@Column</code>(或类似的)注释，可以创建一个实体。这些注释为TypeORM提供了设置数据库表所必需的信息。</p><p id="2037" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">看来我们不会给实体类添加任何函数。相反，我们简单地添加字段定义。在后台，TypeORM必须设置getter和setter函数以及其他支持函数。</p><h1 id="d460" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">学生实体</h1><p id="6dae" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">在<code class="fe mu mv mw mx b">lib</code>目录下创建一个名为<code class="fe mu mv mw mx b">entities</code>的目录。我们将把所有实体类定义放在这个目录中。然后创建一个名为<code class="fe mu mv mw mx b">lib/entities/Student.ts</code>的文件</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="92b8" class="nc ls iu mx b gz nd ne l nf ng">import { <br/>    Entity, Column, PrimaryGeneratedColumn,<br/>    ManyToMany, JoinTable<br/>} from "typeorm";<br/>import { OfferedClass } from './OfferedClass';</span><span id="6817" class="nc ls iu mx b gz ni ne l nf ng">@Entity()<br/>export class Student {<br/>    @PrimaryGeneratedColumn()  id: number;<br/>    @Column({<br/>        length: 100<br/>    })  name: string;<br/>    @Column("int")  entered: number;<br/>    @Column("int")  grade: number;<br/>    @Column()  gender: string;</span><span id="d9ed" class="nc ls iu mx b gz ni ne l nf ng">    @ManyToMany(() =&gt; OfferedClass, oclass =&gt; oclass.students)<br/>    @JoinTable()<br/>    classes: OfferedClass[];<br/>}</span></pre><p id="b891" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">正如我们前面所说的,<code class="fe mu mv mw mx b">@Entity()</code>说类将被TypeORM视为一个实体。为了让TypeORM识别实体，我们必须在连接描述符中配置<code class="fe mu mv mw mx b">entities</code>数组，以便TypeORM能够找到实体类。</p><p id="627f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们有五个字段:</p><ul class=""><li id="271d" class="lb lc iu jt b ju jv jy jz kc ld kg le kk lf ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">id</code>是学生表的主键</li><li id="2fb3" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">name</code>是学生的名字</li><li id="a570" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">entered</code>学生进入大学的年份</li><li id="319d" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">grade</code>是他们目前所在的年级</li><li id="33bc" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">gender</code>表示他们是男性还是女性。这本来是一个名为<code class="fe mu mv mw mx b">Gender</code>的<code class="fe mu mv mw mx b">enum</code>，但是SQLite3似乎不支持枚举字段。</li></ul><h1 id="62cd" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">TypeORM中的实体关系—多对多</h1><p id="d4d6" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">还有一个额外的字段<code class="fe mu mv mw mx b">students</code>，需要更深入的解释。它有两个注解，<code class="fe mu mv mw mx b">@ManyToMany</code>和<code class="fe mu mv mw mx b">@JoinTable</code>。这是一个实体关系的例子，是TypeORM的特性之一。</p><p id="9dfe" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">对于实体关系，TypeORM自动处理表之间的连接。在这种情况下，我们希望支持以下情况</p><ol class=""><li id="9ed6" class="lb lc iu jt b ju jv jy jz kc ld kg le kk lf ko lg lh li lj bi translated">一个学生可以注册多门课程</li><li id="5276" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko lg lh li lj bi translated">提供的课程可以有多个学生注册</li></ol><p id="6912" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">换句话说，许多学生实例引用许多提供的类实例，反之亦然。这就是TypeORM所说的双向多对多关系。</p><p id="5990" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这里的<code class="fe mu mv mw mx b">@JoinTable</code>注释表明<code class="fe mu mv mw mx b">Student</code>类是关系的所有者。在幕后，该注释导致创建一个表，即<em class="lq">连接表</em>，它帮助将<em class="lq">学生</em>和<em class="lq">提供的类</em>的实例连接在一起。</p><p id="22d5" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">对于ManyToMany，两个实体都需要<code class="fe mu mv mw mx b">@ManyToMany</code>注释。现在让我们看看提供的类实体。</p><h1 id="ebd9" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">提供的类实体</h1><p id="36eb" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">显然，我们的学生会很高兴能够注册上课。到目前为止，我们只有一份学生名单，没有办法让他们报名参加任何活动。我们是哪种注册服务商？</p><p id="2114" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">为了纠正这一点，我们需要设置一个或多个附加表来保存关于类的信息。为此，我们可以拿出Enterprise Architect的副本，设计出一个完整的类层次结构。为了简洁起见，让我们做简单的事情。我们将添加一个名为<em class="lq">提供类</em>的实体，然后使用TypeORM注释来分配<em class="lq">学生</em>实例和<em class="lq">提供类</em>实例之间的关系。</p><p id="678b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">创建名为<code class="fe mu mv mw mx b">lib/entities/OfferedClass.ts</code>的文件</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="c21b" class="nc ls iu mx b gz nd ne l nf ng">import { <br/>    Entity, <br/>    Column, <br/>    PrimaryColumn, <br/>    OneToMany,<br/>    ManyToMany<br/>} from "typeorm";<br/>import { Student } from './Student';</span><span id="70cf" class="nc ls iu mx b gz ni ne l nf ng">@Entity()<br/>export class OfferedClass {</span><span id="cd20" class="nc ls iu mx b gz ni ne l nf ng">    @PrimaryColumn({<br/>        length: 10<br/>    }) code: string;<br/>    @Column({<br/>        length: 100<br/>    })  name: string;<br/>    @Column("int")  hours: number;</span><span id="eddf" class="nc ls iu mx b gz ni ne l nf ng">    @ManyToMany(type =&gt; Student, student =&gt; student.classes)<br/>    students: Student[];<br/>}</span></pre><p id="318f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个实体记录了大学提供的课程的数据。这些字段是:</p><ul class=""><li id="6b35" class="lb lc iu jt b ju jv jy jz kc ld kg le kk lf ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">code</code>是班级编号，例如<code class="fe mu mv mw mx b">CS101</code></li><li id="3bc7" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">name</code>是类的描述性名称，例如<code class="fe mu mv mw mx b">Computer Science 101</code></li><li id="319e" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko nh lh li lj bi translated"><code class="fe mu mv mw mx b">students</code>是<code class="fe mu mv mw mx b">@ManyToMany</code>关系的另一面</li></ul><p id="3fe4" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe mu mv mw mx b">students</code>字段上的<code class="fe mu mv mw mx b">@ManyToMany</code>注释是学生实体中相应注释的另一半。多对多关系要求双方都声明。</p><h1 id="ef9a" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">自定义存储库类来管理学生和提供的类实体— CRUD操作等等</h1><p id="ee2d" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">现在我们已经定义了数据库实体，我们需要一些有用的函数来管理这些实体。正如我们前面所说的，开箱即用的TypeORM提供了一个默认的<em class="lq">存储库</em>类，其中包含了许多有用的函数。但是我们希望RegistrarDB提供更高的抽象层。</p><p id="b1ef" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">index.ts</code>中，我们已经声明将会有两个类，<em class="lq"> StudentRepository </em>和<em class="lq"> OfferedClassRepository </em>。这些将是自定义存储库实例，提供我们想要的功能。</p><h1 id="e2b0" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">StudentRepository —学生实体的CRUD操作</h1><p id="2196" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">因此<em class="lq"> StudentRepository </em>类将实现CRUD函数(创建、读取、更新和删除)来管理学生实例，以及一些其他有用的函数。</p><p id="9ef6" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">创建一个名为<code class="fe mu mv mw mx b">lib/StudentRepository.ts</code>的文件:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="e551" class="nc ls iu mx b gz nd ne l nf ng">import { <br/>    EntityRepository, Repository, getRepository <br/>} from "typeorm";<br/>import { Student } from "./entities/Student";<br/>import * as util from 'util';</span><span id="7c77" class="nc ls iu mx b gz ni ne l nf ng">export type GenderType = "male" | "female";</span><span id="8e94" class="nc ls iu mx b gz ni ne l nf ng">export enum Gender {<br/>    male = "male", female = "female"<br/>}</span><span id="31ad" class="nc ls iu mx b gz ni ne l nf ng">@EntityRepository(Student)<br/>export class StudentRepository extends Repository&lt;Student&gt; {<br/>    ...<br/>}</span></pre><p id="db00" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们将添加更多的内容，但这只是开始的结构。我们从<code class="fe mu mv mw mx b">typeorm</code>以及学生实体引进了一些东西。正如我们所说的，<code class="fe mu mv mw mx b">Student</code>中的<code class="fe mu mv mw mx b">gender</code>字段是一个名为Gender的枚举，我们已经在这里定义了它。</p><p id="a19d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个模块的主要特点是StudentRepository类。实现定制存储库的指令是以这种方式扩展<code class="fe mu mv mw mx b">Repository</code>类的定义，并使用这里所示的<code class="fe mu mv mw mx b">EntityRepository</code>注释。</p><p id="ed1c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">通过扩展<code class="fe mu mv mw mx b">Repository</code>类，<code class="fe mu mv mw mx b">StudentRepository</code>类自动访问<code class="fe mu mv mw mx b">Repository</code>类的函数。因此，我们的功能将建立在存储库API之上，并遵循该API设置的模式。</p><p id="295a" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">StudentRepository</code>类中添加这个函数:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="4dd6" class="nc ls iu mx b gz nd ne l nf ng">async createAndSave(student: Student): Promise&lt;number&gt; {<br/>    let stud = new Student();<br/>    stud.name = student.name;<br/>    stud.entered = normalizeNumber(student.entered, 'Bad year entered');<br/>    stud.grade = normalizeNumber(student.grade, 'Bad grade');<br/>    stud.gender = student.gender;<br/>    await this.save(stud);<br/>    return stud.id;<br/>}</span></pre><p id="f05d" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在TypeORM文档中建议使用名称<code class="fe mu mv mw mx b">createAndSave</code>。顾名思义，这个函数处理创建一个学生对象，然后将其保存到数据库中。这是CRUD操作的第一步。</p><p id="3dee" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们创建一个新的<code class="fe mu mv mw mx b">Student</code>对象，以确保保存到数据库的对象只有在<code class="fe mu mv mw mx b">Student</code>中定义的字段。传递的对象可以很容易地拥有其他字段，并且仍然与<code class="fe mu mv mw mx b">Student</code>类型兼容。</p><p id="11c4" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">设置好学生对象后，我们将它保存到数据库中。TypeORM的作用是将它转换为已配置的底层数据库连接。</p><p id="89eb" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">将这些函数添加到<code class="fe mu mv mw mx b">StudentRepository</code>类中:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="a0e0" class="nc ls iu mx b gz nd ne l nf ng">async allStudents(): Promise&lt;Student []&gt; {<br/>    let students = await this.find();<br/>    return students;<br/>}</span><span id="3f1f" class="nc ls iu mx b gz ni ne l nf ng">async findOneStudent(id: number):<br/>            Promise&lt;Student&gt; {<br/>    let student = await this.findOne({ <br/>        where: { id: id }<br/>    });<br/>    if (!StudentRepository.isStudent(student)) {<br/>        throw new Error(`Student id ${util.inspect(id)} did not retrieve a Student`);<br/>    }<br/>    return student;<br/>}</span></pre><p id="f284" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">findOneStudent</code>中，我们有下一个CRUD操作，从数据库中读取一个学生对象。<code class="fe mu mv mw mx b">findOne</code>方法是搜索数据库以检索数据的一种方式。<code class="fe mu mv mw mx b">where</code>子句让我们描述如何从数据库中选择我们想要检索的项目。</p><p id="f6df" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">StudentRepository</code>类中添加这个函数:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="a83d" class="nc ls iu mx b gz nd ne l nf ng">async updateStudent(id: number, student: Student):<br/>            Promise&lt;number&gt; {<br/>    if (typeof student.entered !== 'undefined') {<br/>        student.entered = normalizeNumber(student.entered, 'Bad year entered');<br/>    }<br/>    if (typeof student.grade !== 'undefined') {<br/>        student.grade = normalizeNumber(student.grade, 'Bad grade');<br/>    }<br/>    if (!StudentRepository.isStudentUpdater(student)) {<br/>        throw new Error(`Student update id ${util.inspect(id)} did not receive a Student updater ${util.inspect(student)}`);<br/>    }<br/>    await this.manager.update(Student, id, student);<br/>    return id;<br/>}</span></pre><p id="e379" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">updateStudent</code>中，我们有下一个CRUD操作，更新一个学生对象。我们需要学生的ID来更新，然后是一个允许更新对象的对象。在TypeORM中，<code class="fe mu mv mw mx b">update</code>方法让我们指定一个部分对象，它将更新已设置的字段。<code class="fe mu mv mw mx b">isStudentUpdater</code>方法检查它是否有对更新学生对象有效的字段。</p><p id="e908" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">StudentRepository</code>类中添加这个函数:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="26a7" class="nc ls iu mx b gz nd ne l nf ng">async deleteStudent(student: number | Student) {<br/>    if (typeof student !== 'number'<br/>     &amp;&amp; !StudentRepository.isStudent(student)) {<br/>        throw new Error('Supplied student object not a Student');<br/>    }<br/>    await this.manager.delete(Student, <br/>            typeof student === 'number' <br/>                ? student : student.id);<br/>}</span></pre><p id="68c9" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">deleteStudent</code>中，我们有最后一个CRUD操作，删除一个学生。我们既可以使用ID号，也可以使用Student对象(从中我们可以获得ID号)。</p><p id="d2c5" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">StudentRepository</code>类的主体之外添加这个函数:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="ac29" class="nc ls iu mx b gz nd ne l nf ng">export function normalizeNumber(<br/>            num: number | string, errorIfNotNumber: string)<br/>        : number {<br/>    if (typeof num === 'undefined') {<br/>        throw new Error(`${errorIfNotNumber} -- ${num}`);<br/>    }<br/>    if (typeof num === 'number') return num;<br/>    let ret = parseInt(num);<br/>    if (isNaN(ret)) {<br/>        throw new Error(`${errorIfNotNumber} ${ret} -- ${num}`);<br/>    }<br/>    return ret!;<br/>}</span></pre><p id="6875" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个函数用在几个地方。根据数据源的不同，例如从web浏览器提交的表单，我们可能会收到一个实际上是数字的字符串。该功能通过使用<code class="fe mu mv mw mx b">parseInt</code>来适应这种可能性。</p><h1 id="4448" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">用于学生的类型检查功能</h1><p id="2009" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">TypeScript不支持运行时类型检查。要进行运行时类型检查，匹配TypeScript提供的编译时类型检查，我们必须自己实现它。这是TypeScript与Java或C#等语言的另一个区别。</p><p id="064c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">为了实现运行时类型检查，TypeScript希望我们实现名为<em class="lq">类型保护</em>的函数。这些函数接受一个对象，并且应该测试对象的特征以查看它是否是正确的类型，然后返回一个布尔指示符。</p><p id="3fb2" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">将这些静态函数添加到StudentRepository类中:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="59fd" class="nc ls iu mx b gz nd ne l nf ng">static isStudent(student: any): student is Student {<br/>    return typeof student === 'object'<br/>        &amp;&amp; typeof student.name === 'string'<br/>        &amp;&amp; typeof student.entered === 'number'<br/>        &amp;&amp; typeof student.grade === 'number'<br/>        &amp;&amp; StudentRepository.isGender(student.gender);<br/>}</span><span id="93b8" class="nc ls iu mx b gz ni ne l nf ng">static isStudentUpdater(updater: any): boolean {<br/>    let ret = true;<br/>    if (typeof updater !== 'object') {<br/>        throw new Error('isStudentUpdater must get object');<br/>    }<br/>    if (typeof updater.name !== 'undefined') {<br/>        if (typeof updater.name !== 'string') ret = false;<br/>    }<br/>    if (typeof updater.entered !== 'undefined') {<br/>        if (typeof updater.entered !== 'number') ret = false;<br/>    }<br/>    if (typeof updater.grade !== 'undefined') {<br/>        if (typeof updater.grade !== 'number') ret = false;<br/>    }<br/>    if (typeof updater.gender !== 'undefined') {<br/>        if (!StudentRepository.isGender(updater.gender)) ret = false;<br/>    }<br/>    return ret;<br/>}</span><span id="e244" class="nc ls iu mx b gz ni ne l nf ng">static isGender(gender: any): gender is Gender {<br/>    return typeof gender === 'string'<br/>        &amp;&amp; (gender === 'male' || gender === 'female');<br/>}</span></pre><p id="5d9f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">还记得我们之前说过<code class="fe mu mv mw mx b">gender</code>字段应该是一个<code class="fe mu mv mw mx b">enum</code>字段。我们在顶部定义了<code class="fe mu mv mw mx b">enum Gender</code>，函数<code class="fe mu mv mw mx b">isGender</code>验证<code class="fe mu mv mw mx b">string</code>是否与<code class="fe mu mv mw mx b">enum Gender</code>中允许的值相匹配。</p><p id="8b34" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">仔细看，你会发现<code class="fe mu mv mw mx b">isGender</code>有一个返回类型<code class="fe mu mv mw mx b">gender is Gender</code>。还有什么语言有这样的返回类型？这就是TypeScript所描述的<em class="lq">类型谓词</em>。TypeScript文档对此没有进一步解释。但是从上下文中可以清楚地看出，“<code class="fe mu mv mw mx b">object is Class</code>”谓词是用来表示单词所说的内容，意思是表示该对象与该类匹配。</p><p id="5117" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe mu mv mw mx b">isStudent</code>功能检查一个对象，看它是否与<code class="fe mu mv mw mx b">Student</code>对象的形状相匹配。当我们希望对象包含所有对应于Student的字段时，将会用到这一点。</p><p id="e121" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">相比之下,<code class="fe mu mv mw mx b">isStudentUpdater</code>应该用在对象拥有学生类中的一些字段的环境中。在这两种情况下，我们都确定字段类型与学生类中的字段类型相匹配。</p><h1 id="a203" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">OfferedClassRepository —对OfferedClass实体的CRUD操作和测试</h1><p id="117d" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">为了遵循已经设置的模式，创建一个名为<code class="fe mu mv mw mx b">lib/OfferedClassRepository.ts</code>的文件。这将处理OfferedClass表。</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="f6b7" class="nc ls iu mx b gz nd ne l nf ng">import {<br/>    EntityRepository, <br/>    Repository, <br/>    getRepository <br/>} from "typeorm";<br/>import { <br/>    OfferedClass <br/>} from './entities/OfferedClass';<br/>import { <br/>    normalizeNumber, <br/>    StudentRepository <br/>} from './StudentRepository';<br/>import { <br/>    getStudentRepository <br/>} from './index';<br/>import * as util from 'util';<br/>import * as yaml from 'js-yaml';<br/>import * as fs from 'fs-extra';<br/></span><span id="d1e2" class="nc ls iu mx b gz ni ne l nf ng">@EntityRepository(OfferedClass)<br/>export class OfferedClassRepository extends Repository&lt;OfferedClass&gt; {<br/>    ...<br/>}</span></pre><p id="2b1a" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这就像我们放在<code class="fe mu mv mw mx b">StudentRepository.ts</code>顶部的一样，但是增加了一些内容。也就是说，我们正在导入<code class="fe mu mv mw mx b">js-yaml</code>和<code class="fe mu mv mw mx b">fs-extra</code>。我们将使用这些来读取班级数据库。要支持这些模块，请键入:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="cd09" class="nc ls iu mx b gz nd ne l nf ng">$ npm install --save js-yaml fs-extra<br/>$ npm install --save-dev @types/js-yaml</span></pre><p id="83f2" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们将编写的第一个测试用例将使用来自YAML文件的类描述初始化RegistrarDB。我们将遵循的理论是，注册器偶尔会添加一个类，删除一个类，或者改变一个类的某些内容。虽然他们可以从CRUD API中完成，但是他们也可以使用YAML文件。</p><p id="501a" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">OfferedClassRepository</code>类中添加这些函数:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="bcaf" class="nc ls iu mx b gz nd ne l nf ng">async updateClasses(classFN: string) {</span><span id="b1f9" class="nc ls iu mx b gz ni ne l nf ng">    const yamlText = await fs.readFile(classFN, 'utf8');<br/>    const offered = yaml.safeLoad(yamlText);</span><span id="32ce" class="nc ls iu mx b gz ni ne l nf ng">    if (typeof offered !== 'object'<br/>     || !Array.isArray(offered.classes)) {<br/>        throw new Error(`updateClasses read incorrect data file from ${classFN}`);<br/>    }</span><span id="9b8a" class="nc ls iu mx b gz ni ne l nf ng">    let all = await this.allClasses();<br/>    for (let cls of all) {<br/>        let stillOffered = false;<br/>        for (let ofrd of offered.classes) {<br/>            if (ofrd.code === cls.code) {<br/>                stillOffered = true;<br/>                break;<br/>            }<br/>        }<br/>        if (!stillOffered) {<br/>            this.deleteOfferedClass(cls.code);<br/>        }<br/>    }<br/>    for (let updater of offered.classes) {<br/>        if (!OfferedClassRepository<br/>                    .isOfferedClassUpdater(updater)) {<br/>            throw new Error(`updateClasses found classes entry that is not an OfferedClassUpdater ${util.inspect(updater)}`);<br/>        }<br/>        let cls;<br/>        try { <br/>            cls = await this.findOneClass(updater.code); <br/>        } catch (e) { cls = undefined }<br/>        if (cls) {<br/>            await this.updateOfferedClass(updater.code, updater)<br/>        } else {<br/>            await this.createAndSave(updater)<br/>        }<br/>    }<br/>    <br/>}</span><span id="c7b1" class="nc ls iu mx b gz ni ne l nf ng">static isOfferedClass(offeredClass: any): offeredClass is OfferedClass {<br/>    return typeof offeredClass === 'object'<br/>        &amp;&amp; typeof offeredClass.code === 'string'<br/>        &amp;&amp; typeof offeredClass.name === 'string'<br/>        &amp;&amp; typeof offeredClass.hours === 'number';<br/>}</span><span id="b5fa" class="nc ls iu mx b gz ni ne l nf ng">static isOfferedClassUpdater(updater: any): boolean {<br/>    let ret = true;<br/>    if (typeof updater !== 'object') {<br/>        throw new Error('isOfferedClassUpdater must get object');<br/>    }<br/>    if (typeof updater.code !== 'undefined') {<br/>        if (typeof updater.code !== 'string') ret = false;<br/>    }<br/>    if (typeof updater.name !== 'undefined') {<br/>        if (typeof updater.name !== 'string') ret = false;<br/>    }<br/>    if (typeof updater.hours !== 'undefined') {<br/>        if (typeof updater.hours !== 'number') ret = false;<br/>    }<br/>    return ret;<br/>}</span></pre><p id="7211" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe mu mv mw mx b">updateClasses</code>函数读入一个YAML文件，该文件必须有一个<code class="fe mu mv mw mx b">classes</code>数组。该数组将包含与<code class="fe mu mv mw mx b">OfferedClassUpdater</code>模式匹配的对象。还有两种类型的保护功能，<code class="fe mu mv mw mx b">isOfferedClass</code>和<code class="fe mu mv mw mx b">isOfferedClassUpdater</code>用于测试对象。</p><p id="7804" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">因为YAML文件可以是任何东西，所以我们必须测试文件是否包含我们期望的内容，否则将抛出一个错误。</p><p id="1ce1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">因为YAML文件中的对象可以是任何东西，我们没有任何类型信息来帮助。但这也是我们写<code class="fe mu mv mw mx b">isOfferedClassUpdater</code>的原因。有了这个，我们可以测试来自YAML文件的对象。</p><p id="406f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">第一阶段是检测YAML文件中没有列出的类实例。这样的课程将从课程目录中删除，因为它已经不存在了。我们通过循环所有现有的类来检测这些类，如果它没有在YAML中列出，那么我们知道它应该被删除。</p><p id="ffca" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">第二阶段是根据YAML文件中的数据添加一个新的类，或者更新一个现有的类。</p><p id="3c55" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">顺便说一句，我们本来打算单独测试这个函数，但是因为它引用了其他CRUD函数，所以我们必须实现它们。</p><p id="3962" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">OfferedClassRepository</code>类中添加这个函数:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="b797" class="nc ls iu mx b gz nd ne l nf ng">async allClasses(): Promise&lt;OfferedClass []&gt; {<br/>    let classes = await this.find({<br/>        relations: [ "students" ]<br/>    });<br/>    return classes;<br/>}</span></pre><p id="880f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">使用<code class="fe mu mv mw mx b">allClasses</code>,我们检索所有提供的类实例。</p><p id="183c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">带有<code class="fe mu mv mw mx b">relations</code>的位告诉TypeORM加载关系中的数据，如果有的话。出于某种原因，TypeORM似乎认为关系中的数据是可选的，并不总是需要加载。为了加载关系数据，您需要传递这个<code class="fe mu mv mw mx b">relations</code>字段，该字段包含一个字符串数组，该数组指定了您想要加载的关系。</p><p id="bd4c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">当加载一个<code class="fe mu mv mw mx b">OfferedClass</code>时，我们希望总是加载学生关系，因此我们必须记住总是列出这个关系字段。</p><p id="2fe1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">不同的是:</p><ul class=""><li id="217e" class="lb lc iu jt b ju jv jy jz kc ld kg le kk lf ko nh lh li lj bi translated">无<code class="fe mu mv mw mx b">relations</code>:仅加载<code class="fe mu mv mw mx b">code</code>和<code class="fe mu mv mw mx b">name</code>和<code class="fe mu mv mw mx b">hours</code>字段。</li><li id="a4da" class="lb lc iu jt b ju ll jy lm kc ln kg lo kk lp ko nh lh li lj bi translated">With <code class="fe mu mv mw mx b">relations</code>:这些字段加上<code class="fe mu mv mw mx b">students</code>字段是一个数组，包含与给定OfferedClass关联的学生。</li></ul><p id="afc0" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">OfferedClassRepository</code>类中添加这个函数:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="1985" class="nc ls iu mx b gz nd ne l nf ng">async createAndSave(offeredClass: OfferedClass)<br/>            : Promise&lt;any&gt; {<br/>    let cls = new OfferedClass();<br/>    cls.code = offeredClass.code;<br/>    cls.name = offeredClass.name;<br/>    cls.hours = normalizeNumber(offeredClass.hours, 'Bad number of hours');<br/>    if (!OfferedClassRepository<br/>            .isOfferedClass(cls)) {<br/>        throw new Error(`Not an offered class ${util.inspect(offeredClass)}`);<br/>    }<br/>    await this.save(cls);<br/>    return cls.code;<br/>}</span></pre><p id="5378" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">通过<code class="fe mu mv mw mx b">createAndSave</code>,我们向数据库添加了一个新的OfferedClass。这类似于StudentsRepository中的相同功能。</p><p id="1be6" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">OfferedClassRepository</code>类中添加该函数:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="605c" class="nc ls iu mx b gz nd ne l nf ng">async findOneClass(code: string)<br/>        : Promise&lt;OfferedClass&gt; {<br/>    let cls = await this.findOne({ <br/>        where: { code: code },<br/>        relations: [ "students" ]<br/>    });<br/>    if (!OfferedClassRepository.isOfferedClass(cls)) {<br/>        throw new Error(`OfferedClass id ${util.inspect(code)} did not retrieve a OfferedClass`);<br/>    }<br/>    return cls;<br/>}</span></pre><p id="ae03" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">通过<code class="fe mu mv mw mx b">findOneClass</code>我们找到一个代码名为的提供类。我们再次将<code class="fe mu mv mw mx b">relations</code>字段添加到选项中，以确保并拉入关系数据。这类似于StudentsRepository中的对应函数。</p><p id="bcc9" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">OfferedClassRepository</code>类中添加该函数:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="579a" class="nc ls iu mx b gz nd ne l nf ng">async updateOfferedClass(<br/>                code: string,<br/>                offeredClass: OfferedClass)<br/>            : Promise&lt;any&gt; {<br/>        if (typeof offeredClass.hours !== 'undefined') {<br/>            offeredClass.hours = normalizeNumber(<br/>                    offeredClass.hours, 'Bad number of hours');<br/>        }<br/>        if (!OfferedClassRepository<br/>                .isOfferedClassUpdater(offeredClass)) {<br/>            throw new Error(`OfferedClass update id ${util.inspect(code)} did not receive a OfferedClass updater ${util.inspect(offeredClass)}`);<br/>        }<br/>        await this.manager.update(OfferedClass,<br/>                    code, offeredClass);<br/>        return code;<br/>    }</span></pre><p id="7ef7" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">对于<code class="fe mu mv mw mx b">updateOfferedClass</code>,我们采用一个<code class="fe mu mv mw mx b">OfferedClassUpdater</code>对象，并使用它来更新数据库中的条目。TypeORM <code class="fe mu mv mw mx b">update</code>函数负责根据设置或未设置的字段有选择地更新项目。这类似于StudentsRepository中的对应函数。</p><p id="24f9" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">OfferedClassRepository</code>类中添加这个函数:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="9498" class="nc ls iu mx b gz nd ne l nf ng">async deleteOfferedClass(<br/>                offeredClass: string | OfferedClass) {<br/>    if (typeof offeredClass !== 'string'<br/>        &amp;&amp; !OfferedClassRepository.isOfferedClass(offeredClass)) {<br/>        throw new Error('Supplied offeredClass object not a OfferedClass');<br/>    }<br/>    await this.manager.delete(OfferedClass,<br/>        typeof offeredClass === 'string'<br/>                ? offeredClass : offeredClass.code);<br/>}</span></pre><p id="e1ae" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">使用<code class="fe mu mv mw mx b">deleteOfferedClass</code>,我们试图删除一个OfferedClass实例。这类似于StudentsRepository中的对应函数。</p><p id="0025" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">接下来，我们想支持学生注册一个课程。</p><p id="7cc1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">OfferedClassRepository</code>类中添加这个函数:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="3fbc" class="nc ls iu mx b gz nd ne l nf ng">async enrollStudentInClass(<br/>            studentid: any, code: string) {<br/>    let offered = await this.findOneClass(code);<br/>    if (!OfferedClassRepository<br/>            .isOfferedClass(offered)) {<br/>        throw new Error(`enrollStudentInClass did not find OfferedClass for ${util.inspect(code)}`);<br/>    }<br/>    let student = await getStudentRepository()<br/>                        .findOneStudent(studentid);<br/>    if (!StudentRepository.isStudent(student)) {<br/>        throw new Error(`enrollStudentInClass did not find Student for ${util.inspect(studentid)}`);<br/>    }<br/>    <br/>    if (!student.classes) student.classes = [];<br/>    student.classes.push(offered);<br/>    await getStudentRepository().manager.save(student);<br/>}</span></pre><p id="8271" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">第一部分验证我们已经得到了一个已知学生和一个已知班级的良好标识符。</p><p id="8103" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">然后，将学生添加到提供的班级就很容易了。只需将OfferedClass实例添加到Student对象的<code class="fe mu mv mw mx b">classes</code>数组中，然后将其保存回数据库。在幕后，TypeORM负责一切。</p><p id="bc28" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">另一个期望的操作是一次在多个班级中注册学生。与其一次注册一个，不如接收一组课程代码并确保学生注册了每个课程代码，这样可能更有效。此外，如果该学生目前注册的班级不在该阵列中，我们应该将该学生从该班级中除名。</p><p id="1bc8" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在<code class="fe mu mv mw mx b">OfferedClassRepository</code>类中添加这个函数:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="307f" class="nc ls iu mx b gz nd ne l nf ng">async updateStudentEnrolledClasses(<br/>            studentid: any, codes: string[]) {<br/>    let student = await getStudentRepository()<br/>                        .findOneStudent(studentid);<br/>    if (!StudentRepository.isStudent(student)) {<br/>        throw new Error(`enrollStudentInClass did not find Student for ${util.inspect(studentid)}`);<br/>    }<br/>    let newclasses = [];<br/>    for (let sclazz of student.classes) {<br/>        for (let code of codes) {<br/>            if (sclazz.code === code) {<br/>                newclasses.push(sclazz);<br/>            }<br/>        }<br/>    }<br/>    for (let code of codes) {<br/>        let found = false;<br/>        for (let nclazz of newclasses) {<br/>            if (nclazz.code === code) {<br/>                found = true;<br/>            }<br/>        }<br/>        if (!found) {<br/>            newclasses.push(await this.findOneClass(code));<br/>        }<br/>    }<br/>    student.classes = newclasses;<br/>    await getStudentRepository().save(student);<br/>}</span></pre><p id="b96e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">遵循的方法是首先检索学生实例，然后操作学生注册的<code class="fe mu mv mw mx b">classes</code>，最后保存学生。</p><p id="eaf8" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">我们创建一个空数组来保存学生注册的新班级。然后我们使用几个<code class="fe mu mv mw mx b">for</code>循环来正确设置这个数组。首先，我们复制仍然列在类代码数组中的提供的类实例。在第二个例子中，我们传递可用类的数组，对于任何不在数组中的类，我们将它的OfferedClass实例推入数组。</p><p id="8c21" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">结果是<code class="fe mu mv mw mx b">newclasses</code>提供的类实例与我们得到的代码相对应。我们只需保存学生实例。</p><h1 id="d3cc" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">单元测试学生和提供的类实体</h1><p id="6fd7" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">在<code class="fe mu mv mw mx b">test</code>目录中，我们已经建立了Node.js项目的框架。</p><p id="38f4" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在该目录中，创建一个名为<code class="fe mu mv mw mx b">index.js</code>的文件。这将包含一个摩卡/柴测试套件。因为我们想要测试注册器模块的JavaScript接口，所以测试套件是用JavaScript编写的。</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="5816" class="nc ls iu mx b gz nd ne l nf ng">const util = require('util');<br/>const path = require('path');<br/>const assert = require('chai').assert;<br/>const { <br/>    connect, <br/>    connected,<br/>    Student,<br/>    getStudentRepository,<br/>    StudentRepository,<br/>    getOfferedClassRepository,<br/>    OfferedClassRepository<br/>} = require('../dist/index');</span><span id="89f1" class="nc ls iu mx b gz ni ne l nf ng">describe('Initialize Registrar', function() {<br/>    before(async function() {<br/>        try {<br/>            await connect("registrardb.sqlite");<br/>        } catch (e) {<br/>            console.error(`Initialize Registrar failed with `, e);<br/>            throw e;<br/>        }<br/>    });</span><span id="ece4" class="nc ls iu mx b gz ni ne l nf ng">    it('should successfully initialize the Registrar', async function() {<br/>        assert.isTrue(connected());<br/>    });<br/>});</span></pre><p id="66c7" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这就建立了所需的模块，并实现了一个初始测试用例。</p><p id="f2b1" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">因为<code class="fe mu mv mw mx b">test</code>目录是<code class="fe mu mv mw mx b">registrar</code>模块的子目录，我们可以像这里一样使用相对路径引用来加载模块。生成的源代码在<code class="fe mu mv mw mx b">dist</code>目录中，因此我们从那里加载模块。</p><p id="869e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这里的<code class="fe mu mv mw mx b">before</code>函数用于初始化RegistrarDB连接。没有什么需要测试的，因为我们所做的只是实例化数据库。因此，这个测试的主要目的是初始化数据库，但是它确实对数据库是否成功配置做了一点验证。</p><p id="af9e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">测试可以这样运行:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="4488" class="nc ls iu mx b gz nd ne l nf ng">$ npm test</span><span id="0049" class="nc ls iu mx b gz ni ne l nf ng">&gt; registrar@1.0.0 test /Volumes/Extra/ebooks/typescript-nodejs/examples/registrar<br/>&gt; cd test &amp;&amp; npm run test<br/></span><span id="174e" class="nc ls iu mx b gz ni ne l nf ng">&gt; registrar-test@1.0.0 pretest /Volumes/Extra/ebooks/typescript-nodejs/examples/registrar/test<br/>&gt; cd .. &amp;&amp; npm run build<br/></span><span id="982d" class="nc ls iu mx b gz ni ne l nf ng">&gt; registrar@1.0.0 build /Volumes/Extra/ebooks/typescript-nodejs/examples/registrar<br/>&gt; tsc<br/></span><span id="6419" class="nc ls iu mx b gz ni ne l nf ng">&gt; registrar-test@1.0.0 test /Volumes/Extra/ebooks/typescript-nodejs/examples/registrar/test<br/>&gt; mocha ./index</span><span id="6528" class="nc ls iu mx b gz ni ne l nf ng">  Initialize Registrar<br/>    ✓ should successfully initialize the Registrar</span><span id="e547" class="nc ls iu mx b gz ni ne l nf ng">  1 passing (13ms)</span></pre><h1 id="b0d5" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">测试学生对象</h1><p id="edcf" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">让我们稍微充实一下测试套件。我们在本书中没有足够的空间来全面测试所有的东西，所以让我们只展示几个测试案例。</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="1787" class="nc ls iu mx b gz nd ne l nf ng">describe('Add students to registry', function() {<br/>    let stud1 = {<br/>        name: "John Brown", <br/>        entered: 1997, grade: 4,<br/>        gender: "male"<br/>    };<br/>    let stud2 = {<br/>        name: "John Brown", <br/>        entered: "trump1", grade: "senior",<br/>        gender: "male"<br/>    };<br/>    let studentid1;<br/>    let studentid2;</span><span id="1991" class="nc ls iu mx b gz ni ne l nf ng">    it('should add a student to the registry', async function() {<br/>        studentid1 = await getStudentRepository().createAndSave(stud1);<br/>        let student = await getStudentRepository().findOneStudent(studentid1);<br/>        assert.exists(student);<br/>        assert.isObject(student);<br/>        assert.isString(student.name);<br/>        assert.equal(student.name, stud1.name);<br/>        assert.isNumber(student.entered);<br/>        assert.equal(student.entered, stud1.entered);<br/>        assert.isNumber(student.grade);<br/>        assert.equal(student.grade, stud1.grade);<br/>        assert.isString(student.gender);<br/>        assert.equal(student.gender, stud1.gender);<br/>    });</span><span id="a796" class="nc ls iu mx b gz ni ne l nf ng">    it('should fail to add a student with bad data', async function() {<br/>        let sawError = false;<br/>        try {<br/>            await getStudentRepository().createAndSave(stud2);<br/>        } catch (err) {<br/>            sawError = true;<br/>        }<br/>        assert.isTrue(sawError);<br/>    });</span><span id="cdd9" class="nc ls iu mx b gz ni ne l nf ng">});</span></pre><p id="c8bc" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">两个对象，<code class="fe mu mv mw mx b">stud1</code>和<code class="fe mu mv mw mx b">stud2</code>，分别代表肯定测试(预期成功)和否定测试(预期失败)。首先，我们调用<code class="fe mu mv mw mx b">addStudent</code>，然后检索Student对象，然后对照该对象检查它的值。</p><p id="6575" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在柴的断言中有一个非常有用的方法，<code class="fe mu mv mw mx b">deepEqual</code>，在这里就更可取了。但是，从<code class="fe mu mv mw mx b">getStudent(studentid1)</code>返回的对象是一个TypeScript对象。通过检查对象，我发现它有名为<code class="fe mu mv mw mx b">_name</code>等的字段，您会记得这些字段是保存实际数据的私有字段。getter方法未被识别为字段名，因此我们无法执行:<code class="fe mu mv mw mx b">assert.deepEqual(student, stud1)</code>，因为字段名不匹配。</p><p id="83ab" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">因此，我们最终使用单独的<code class="fe mu mv mw mx b">assert.isNumber</code>和<code class="fe mu mv mw mx b">assert.isString</code>检查。或者，我们可以简单地使用<code class="fe mu mv mw mx b">isStudent</code>类型的guard来检查返回的对象是否如预期的那样。</p><p id="2628" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在否定的测试用例中(<em class="lq">应该无法添加</em>)，我们会传入<code class="fe mu mv mw mx b">stud2</code>。这个对象有字符串而不是数字字段，这些字符串不能转换成数字。<code class="fe mu mv mw mx b">createStudent</code>函数检测到这个问题并抛出一个错误。我们捕获该错误，并将<code class="fe mu mv mw mx b">sawError</code>标志设置为<code class="fe mu mv mw mx b">true</code>，断言将会成功。如果没有抛出错误，标志保持<code class="fe mu mv mw mx b">false</code>，断言将失败。</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="db8d" class="nc ls iu mx b gz nd ne l nf ng">$ npm test</span><span id="36ad" class="nc ls iu mx b gz ni ne l nf ng">&gt; registrar@1.0.0 test /Volumes/Extra/ebooks/typescript-nodejs/examples/registrar<br/>&gt; cd test &amp;&amp; npm run test</span><span id="2e26" class="nc ls iu mx b gz ni ne l nf ng">&gt; registrar-test@1.0.0 pretest /Volumes/Extra/ebooks/typescript-nodejs/examples/registrar/test<br/>&gt; cd .. &amp;&amp; npm run build</span><span id="07d6" class="nc ls iu mx b gz ni ne l nf ng">&gt; registrar@1.0.0 build /Volumes/Extra/ebooks/typescript-nodejs/examples/registrar<br/>&gt; tsc</span><span id="c82e" class="nc ls iu mx b gz ni ne l nf ng">&gt; registrar-test@1.0.0 test /Volumes/Extra/ebooks/typescript-nodejs/examples/registrar/test<br/>&gt; mocha ./index</span><span id="3bc8" class="nc ls iu mx b gz ni ne l nf ng">  Initialize Registrar<br/>    ✓ should successfully initialize the Registrar</span><span id="bd77" class="nc ls iu mx b gz ni ne l nf ng">  Add students to empty registrar<br/>    ✓ should add a student to the registrar<br/>    ✓ should fail to add a student with bad data</span><span id="3b08" class="nc ls iu mx b gz ni ne l nf ng">  3 passing (46ms)</span></pre><p id="6296" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在更多的工作之后，测试结果可能看起来像这样:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="e9bf" class="nc ls iu mx b gz nd ne l nf ng">&gt; registry-test@1.0.0 test /Volumes/Extra/ebooks/typescript-nodejs-quick-start/registrar/test<br/>&gt; rm -f registrardb.sqlite &amp;&amp; mocha ./index</span><span id="3357" class="nc ls iu mx b gz ni ne l nf ng">  Initialize Registrar<br/>    ✓ should successfully initialize the Registrar</span><span id="f512" class="nc ls iu mx b gz ni ne l nf ng">  Add students to registry<br/>    ✓ should add a student to the registry<br/>    ✓ should fail to add a student with bad data</span><span id="c49f" class="nc ls iu mx b gz ni ne l nf ng">  Update student in registry<br/>    ✓ should update student (44ms)<br/>    ✓ should fail to update student with bad data</span><span id="e9f7" class="nc ls iu mx b gz ni ne l nf ng">  Delete student from registry<br/>    ✓ should not fail to delete student using bad ID<br/>    ✓ should delete student using good ID<br/></span><span id="d634" class="nc ls iu mx b gz ni ne l nf ng">  7 passing (861ms)</span></pre><h1 id="36a4" class="lr ls iu bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">测试提供的类实体</h1><p id="e3e6" class="pw-post-body-paragraph jr js iu jt b ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko in bi translated">写了几个学生实体的测试之后，我们需要验证所提供的类实体。与学生实体不同，我们需要初始化一个提供的类对象列表。</p><p id="291b" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">第一步是创建一个YAML格式的数据文件。创建一个名为<code class="fe mu mv mw mx b">test/students.yaml</code>的文件:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="6c0f" class="nc ls iu mx b gz nd ne l nf ng">classes:<br/>  - code: BW101<br/>    name: Introduction to Basket Weaving<br/>    hours: 3<br/>  - code: BW102<br/>    name: Underwater Basket Weaving<br/>    hours: 3<br/>  - code: BW103<br/>    name: Basket Weaving while Sky Diving<br/>    hours: 3<br/>  - code: BW201<br/>    name: Basket Weaving Fundamentals<br/>    hours: 3<br/>  - code: BW202<br/>    name: Historical Basket Weaving<br/>    hours: 3<br/>  - code: BW203<br/>    name: Development of Modern Basket Weaving<br/>    hours: 3<br/>  - code: BW301<br/>    name: Topics on Contemporary Basket Weaving<br/>    hours: 3<br/>  - code: BW302<br/>    name: Basket Weaving Theory<br/>    hours: 3<br/>  - code: BW303<br/>    name: Basket Weaving and Graph Theory<br/>    hours: 3<br/>  - code: BW401<br/>    name: Advanced Basket Weaving<br/>    hours: 3<br/>  - code: BW402<br/>    name: Basket Weaving Research Practicum<br/>    hours: 3</span></pre><p id="9ce8" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">这个数据文件包含一个对篮子编织感兴趣的假想大学的班级列表。</p><p id="8817" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">然后添加这个测试组:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="6dc6" class="nc ls iu mx b gz nd ne l nf ng">describe('Initialize Offered Classes in registry', function() {<br/>    before(async function() {<br/>        await getOfferedClassRepository()<br/>            .updateClasses(path.join(__dirname, 'classes.yaml'));<br/>    });</span><span id="ce95" class="nc ls iu mx b gz ni ne l nf ng">    it('should have offered classes', async function() {<br/>        let classes = await getOfferedClassRepository()<br/>                            .allClasses();<br/>        assert.exists(classes);<br/>        assert.isArray(classes);<br/>        for (let offered of classes) {<br/>            assert.isTrue(OfferedClassRepository<br/>                        .isOfferedClass(offered));<br/>        }<br/>    });<br/>});</span></pre><p id="976c" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><code class="fe mu mv mw mx b">before</code>函数将YAML文件中的任何内容插入数据库。初始化我们的测试数据。我们终于可以实现大学时代的梦想，在课程目录上看到<em class="lq">水下篮子编织</em>。</p><p id="f49f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在测试用例中，我们读取所有的类，并验证所有的东西确实是一个提供的类。</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="819d" class="nc ls iu mx b gz nd ne l nf ng">&gt; rm -f registrardb.sqlite &amp;&amp; mocha ./index</span><span id="9260" class="nc ls iu mx b gz ni ne l nf ng">  Initialize Registrar<br/>    ✓ should successfully initialize the Registrar</span><span id="348d" class="nc ls iu mx b gz ni ne l nf ng">  Add students to registry<br/>    ✓ should add a student to the registry<br/>    ✓ should fail to add a student with bad data</span><span id="c73c" class="nc ls iu mx b gz ni ne l nf ng">  Update student in registry<br/>    ✓ should update student<br/>    ✓ should fail to update student with bad data</span><span id="919d" class="nc ls iu mx b gz ni ne l nf ng">  Delete student from registry<br/>    ✓ should not fail to delete student using bad ID<br/>    ✓ should delete student using good ID</span><span id="0f89" class="nc ls iu mx b gz ni ne l nf ng">  Initialize Offered Classes in registry<br/>    ✓ should have offered classes<br/></span><span id="d8a4" class="nc ls iu mx b gz ni ne l nf ng">  8 passing (369ms)</span></pre><p id="1e1e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">酷，我们已经验证了所提供的类实例存在并且具有正确的类型。现在，我们需要测试将学生添加到班级和其他地方。</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="4f21" class="nc ls iu mx b gz nd ne l nf ng">let stud1 = {<br/>    name: "Mary Brown", <br/>    entered: 2010, grade: 2,<br/>    gender: "female"<br/>};<br/>let studentid1;</span><span id="9795" class="nc ls iu mx b gz ni ne l nf ng">it('should add student to a class', async function() {<br/>    studentid1 = await getStudentRepository()<br/>                        .createAndSave(stud1);<br/>    await getOfferedClassRepository()<br/>            .enrollStudentInClass(studentid1, "BW102");<br/>    let student = await getStudentRepository()<br/>            .findOneStudent(studentid1);<br/>    assert.isTrue(StudentRepository<br/>                .isStudent(student));<br/>    assert.isArray(student.classes);<br/>    let foundbw102 = false;<br/>    for (let offered of student.classes) {<br/>        assert.isTrue(OfferedClassRepository<br/>                    .isOfferedClass(offered));<br/>        if (offered.code === "BW102") foundbw102 = true;<br/>    }<br/>    assert.isTrue(foundbw102);<br/>});</span></pre><p id="65c6" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">和前面一样，我们有一个静态对象，可以从中创建一个学生。然后我们给学生注册一个班级。然后我们再次检索学生，并检查它的<code class="fe mu mv mw mx b">classes</code>数组以确保她正在取BW102。</p><p id="9b8f" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated">在一些额外的测试用例开发之后，我们有:</p><pre class="kq kr ks kt gu my mx mz na aw nb bi"><span id="9328" class="nc ls iu mx b gz nd ne l nf ng">&gt; rm -f registrardb.sqlite &amp;&amp; mocha ./index</span><span id="bc27" class="nc ls iu mx b gz ni ne l nf ng">  Initialize Registrar<br/>    ✓ should successfully initialize the Registrar</span><span id="1dc5" class="nc ls iu mx b gz ni ne l nf ng">  Add students to registry<br/>    ✓ should add a student to the registry<br/>    ✓ should fail to add a student with bad data</span><span id="1c3e" class="nc ls iu mx b gz ni ne l nf ng">  Update student in registry<br/>    ✓ should update student<br/>    ✓ should fail to update student with bad data</span><span id="8387" class="nc ls iu mx b gz ni ne l nf ng">  Delete student from registry<br/>    ✓ should not fail to delete student using bad ID<br/>    ✓ should delete student using good ID</span><span id="7a17" class="nc ls iu mx b gz ni ne l nf ng">  Initialize Offered Classes in registry<br/>    ✓ should have offered classes<br/>    ✓ should add student to a class<br/>    ✓ should add student to three classes<br/>    ✓ should show students registered in class</span><span id="2d1a" class="nc ls iu mx b gz ni ne l nf ng">  11 passing (372ms)</span></pre><p id="d94e" class="pw-post-body-paragraph jr js iu jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko in bi translated"><em class="lq">本文原载于</em><a class="ae lk" href="https://techsparx.com/nodejs/typescript/typeorm.html" rel="noopener ugc nofollow" target="_blank"><em class="lq">TechSparx</em></a><em class="lq">。</em></p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><div class="kq kr ks kt gu nq"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fp"><div class="ns ab nt cl cj nu"><h2 class="bd iv gz z fq nv fs ft nw fv fx it bi translated">编写面试问题</h2><div class="nx l"><h3 class="bd b gz z fq nv fs ft nw fv fx dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="ny l"><p class="bd b dl z fq nv fs ft nw fv fx dk translated">技术开发</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kz nq"/></div></div></a></div></div></div>    
</body>
</html>