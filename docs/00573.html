<html>
<head>
<title>Vue.js Internals — What’s involved in a method call?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js内部——方法调用涉及什么？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/vue-js-internals-whats-involved-in-a-method-call-7624c6994778?source=collection_archive---------0-----------------------#2019-05-13">https://levelup.gitconnected.com/vue-js-internals-whats-involved-in-a-method-call-7624c6994778?source=collection_archive---------0-----------------------#2019-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b24720768352df7620231d07b497eda0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Ay6nvMbOmgYgWL5nojedg.png"/></div></div></figure><p id="9670" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Vue是Javascript <strong class="ka ir"> <em class="kw">魔法</em> </strong>。Vue提供了快速创建交互式用户界面的工具。这是通过可重用的<em class="kw">组件</em>的概念来实现的，这些组件基于组件的<em class="kw">数据</em>来呈现和更新html。在开发界，这被称为<em class="kw">双向数据绑定</em>。对数据进行更改，并观察HTML自动更新。有HTML输入元素吗？告诉Vue将表单绑定到数据中，并在输入文本时观察数据的变化。看到了吗？<em class="kw">魔法</em>。</p><p id="300e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Vue组件也有你可以调用的方法。这些方法更常用作事件处理程序。想在点击按钮时运行代码吗？在Vue组件中分配一个函数作为它的处理程序。在您的方法中，您可以操作组件的数据，然后再次观察html如何变化。这是生命的循环。</p><p id="5b01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个html片段，可能在你的组件的HTML中。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="5826" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可能是您简单的Vue应用程序</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="28ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意您是如何在名为<em class="kw">方法</em>的属性中创建一个名为<em class="kw">增量</em>的函数的。引用该方法时不使用该属性名。当你试图在组件外调用这个方法时，你根本不用<em class="kw">方法</em>属性。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="bd56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，我们如何在不引用methods属性的情况下调用该方法呢？Vue是如何做到这一点的？</p><p id="fd7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们直接在Chrome DevTools中检查Vue实例'<em class="kw"> app </em>'，我们会看到一个非常丰富的对象，如下所示。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ld"><img src="../Images/acc06f24cd2637337875aed258501e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*YTitE3wJdEvBiB53caQ7nA.png"/></div></div></figure><p id="a1ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个对象内置了大量的行为。您可以看到与观察器、生命周期事件等相关的属性和功能。在这个对象中，你还可以看到一个<em class="kw">增量</em>函数。该<em class="kw">增量</em>功能具有附加属性，包括<em class="kw">目标功能</em>、<em class="kw">边界</em>和<em class="kw">边界</em>。这告诉我们一些有趣的事情。秘密在于<em class="kw">增量</em>函数<strong class="ka ir"> <em class="kw">根本不是我们的</em> </strong> <em class="kw"> </em>增量<em class="kw">函数。这是一个<em class="kw">包装器</em>，它指向我们的<em class="kw">增量</em>函数。Vue是如何？JS这样做？</em></p><h1 id="5c69" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">您的Vue实例的内部构建</h1><p id="4942" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">当我们使用<em class="kw"> new Vue({…}) </em>实例化一个新的Vue实例时，我们会传入一个<em class="kw"> options </em>对象，它包含我们的应用程序的状态和行为。结果我们得到的是Vue对一个新对象的组合，它包装了所有围绕我们意图的动态绑定和行为。我们来看看Vue源代码中的Vue构造函数文件。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="4c48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们调用Vue构造函数时，它在内部调用新Vue对象上的<em class="kw"> _init </em>函数，传递我们的options对象。这个<em class="kw"> _init </em>函数在<em class="kw"> initMixin </em>中定义。在<em class="kw"> _init </em>函数中，Vue开始构建包装行为。在这个调用嵌套中有一个<em class="kw"> initMethods </em>函数调用，当我们的options对象中有一个Methods属性时，这个函数调用就会发生。让我们来看看<em class="kw"> initMethods </em>函数。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="dc08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数用一个<em class="kw"> vm </em>参数调用，该参数指向正在构建的新Vue实例。<em class="kw">方法</em>参数包含了我们所有的方法定义，准备分配给我们的实例。</p><p id="4b57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果所有的错误检查看起来都很好，包括确保我们没有与数据属性相同的函数名，那么我们调用<em class="kw"> bind </em>函数，传入我们自己的函数声明和对新Vue实例的引用作为<em class="kw"> vm </em>。我们来看看Vue的<em class="kw">绑定</em>函数声明。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="31d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在实用程序文件中看到，<em class="kw"> bind </em>函数将为没有本机<em class="kw">function . prototype . bind</em>函数的Javascript环境使用自定义的<em class="kw"> bind </em>实现。否则，它将利用内置的Function.prototype.bind函数，确保函数中的<em class="kw"> this </em>上下文指向我们新的Vue实例。</p><p id="17a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到我们的<em class="kw"> initMethods </em>函数，在我们示例的上下文中，代码如下所示。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="171a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">属于<em class="kw"> Function.prototype </em>的<em class="kw"> bind </em>函数返回一个新函数，当调用该函数时，会将<em class="kw"> this </em>关键字设置为传递给bind的参数。然后使用括号符号将<em class="kw">绑定</em>调用的结果分配给我们的新Vue实例。关于<em class="kw">function . prototype . bind</em>函数的更多信息可以在Mozilla的Web开发者文档中找到。</p><div class="mh mi gp gr mj mk"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">函数.原型.绑定()</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">bind()方法创建了一个新函数，当调用该函数时，它的this关键字被设置为提供的值，并带有一个…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">developer.mozilla.org</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my jw mk"/></div></div></a></div><p id="27e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们的Vue对象被创建并由Vue构造函数返回，最终的对象有一个增量属性，它引用了由<em class="kw">绑定</em>调用返回的新函数。这就是你的函数如何利用<em class="kw"> this </em>关键字，该关键字现在正确地引用了它所属的Vue组件。</p><h1 id="880f" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">性能呢？</h1><p id="9d8d" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">当您在我们创建的新Vue实例上调用<em class="kw"> increment </em>方法时，您实际上是在调用由<em class="kw"> bind </em>调用准备的函数。每个Javascript引擎都以不同的方式实现内部绑定，并且浏览器之间存在<strong class="ka ir">和</strong>性能差异。在Chrome的最近版本中，当v8引擎优化你的代码时，没有可察觉的差异。然而，在其他浏览器中，如Microsoft Edge和Firefox，绑定函数和非绑定函数的性能差异可能非常显著。您可以查看这些测试的结果，并使用下面的jsPerf测试自己运行它们。</p><div class="mh mi gp gr mj mk"><a href="https://jsperf.com/performance-of-function-binding" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">属于对象的绑定和非绑定函数之间的性能差异</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">利用Function.prototype.bind将函数的this绑定到对象的上下文，并将其执行时间与对象中直接定义的函数进行比较的测试。</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">jsperf.com</p></div></div></div></a></div><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/87bdc4ed06f6926079c578894124d384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l6nFygJFIdnKX0zUuq9tjg.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">jsPerf测试显示了微软Edge(显示为Chrome 64)、谷歌Chrome和Firefox 66.0的最新版本的结果</figcaption></figure><p id="e14d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最新版本的Microsoft Edge在jsPerf图表中标识为Chrome 64。你可以看到使用Function.prototype.bind绑定的函数在调用性能上的显著差异。如果Chrome理解你在做什么，它的最新版本可以围绕这一点进行优化。</p><h1 id="2bf2" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么这很重要？</h1><p id="f370" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">对你来说可能无所谓。当你不需要考虑内部的时候，Vue.js是很神奇的。就起来用吧。调用方法所涉及的潜在性能开销对您来说可能也无关紧要，因为Vue.js内部的交互不需要高度性能驱动来提供丰富的交互式用户体验。</p><h1 id="536b" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么这对我很重要</h1><p id="3b4b" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated">我目前正在用Vue.js构建一个用Javascript编写的任天堂模拟器。这要求一切都尽可能快。Vue.js中的每个包装行为都有性能成本，我发现自己不得不将更多的模拟器行为移出Vue.js，以达到必要的速度。</p><p id="4dd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们知道魔法是有代价的。</p><p id="79a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过跟随我的代码库，跟随我用Vue.js用Javascript编写的8位任天堂仿真器的开发。</p><div class="mh mi gp gr mj mk"><a href="https://github.com/tdondich/triforce" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">t向下/三向力</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">用VueJS - tdondich/triforce用Javascript写的8位任天堂模拟器</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">github.com</p></div></div><div class="mt l"><div class="ne l mv mw mx mt my jw mk"/></div></div></a></div></div></div>    
</body>
</html>