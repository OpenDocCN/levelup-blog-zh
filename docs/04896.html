<html>
<head>
<title>Dependency Injection vs Inversion of Control</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入与控制反转</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dependency-injection-vs-inversion-of-control-e8a9fcc7d9f7?source=collection_archive---------0-----------------------#2020-07-22">https://levelup.gitconnected.com/dependency-injection-vs-inversion-of-control-e8a9fcc7d9f7?source=collection_archive---------0-----------------------#2020-07-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="d1dc" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">动机</h1><p id="3862" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">关于依赖注入和控制反转之间的区别，软件工程师中有一个广泛传播的误解。这两个概念经常被认为是一回事。我甚至知道这样一个案例，一位面试官在一次技术面试中问及两者的区别，并期望得到“没有区别”的答案。依赖注入框架，如<a class="ae lm" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring </a>和<a class="ae lm" href="https://github.com/google/guice" rel="noopener ugc nofollow" target="_blank"> Google Guice </a>，也被称为控制容器反转(IoCC)，这是一个误导性的名称，只会增加更多的混乱。</p><p id="6e47" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">本文从软件架构的角度阐述了这两个概念。在本文中，我们将看到这些术语之间的不同，以及如何使用依赖注入来实现控制反转。我们还将看到一个没有控制反转的依赖注入的例子和一个没有依赖注入的控制反转的例子。</p><p id="511a" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">这篇文章使用了<a class="ae lm" href="https://medium.com/@volodymyrfrolov/nouml-afbb7f07f369" rel="noopener"> NoUML </a>符号。尽管这不是绝对必要的，因为符号是不言而喻的，您可以在继续之前参考符号的描述。</p><h1 id="3da2" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">控制反转</h1><p id="1cec" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在控制流命令式编程中，我们指的是代码执行从一个抽象(模块、类、对象、函数等)开始的情况。)到另一个。例如，如果函数<em class="ls"> f </em>调用函数<em class="ls"> g </em>，我们说控制从<em class="ls"> f() </em>流向<em class="ls"> g() </em>。经常出现的情况是，如果<em class="ls"> f </em>调用<em class="ls"> g </em>，那么它也依赖于<em class="ls"> g </em>。所以依赖关系和控制流都有相同的方向。</p><p id="ec01" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">但事实并非如此。为了调用<em class="ls"> g </em>，<em class="ls"> f </em>不一定要依赖它。事实上，<em class="ls"> f </em>和<em class="ls"> g </em>之间可能根本没有依赖关系。例如，<em class="ls"> f </em>可能会接收<em class="ls"> g </em>作为回调参数并调用它。在这种情况下，控制仍然从<em class="ls"> f() </em>流向<em class="ls"> g() </em>，但是<em class="ls"> f </em>和<em class="ls"> g </em>并不相互依赖。</p><p id="d773" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">在软件架构中，通过反转一个依赖项的方向来重构系统是一种常见的做法。出于多种原因，可能需要它，例如打破循环依赖，或者遵循SOLID原则中的依赖倒置原则(另一个不幸的名称，经常与依赖注入混淆)。但是，控制流不必和依赖项一起自动反转。</p><blockquote class="lt"><p id="7bc3" class="lu lv it bd lw lx ly lz ma mb mc ll dk translated">当抽象A依赖于抽象B，但是控制从B流向A的方向相反时，就会发生控制反转。</p></blockquote><figure class="me mf mg mh mi mj gh gi paragraph-image"><div class="gh gi md"><img src="../Images/ae23240df7b1cf258a76fc989f734048.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*KJ9AVfXaGgmKzvERtRfsZg.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">控制反转的一个例子。a依赖于B，但控制流向相反，从B到a。</figcaption></figure><p id="094a" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">插件Architecture⁴是一个没有依赖注入的控制反转的例子。微内核调用插件，因此控制权从微内核流向插件。但是插件实现了由微内核提供的接口，所以依赖是反方向的。</p><h1 id="33ad" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">依赖注入</h1><blockquote class="lt"><p id="a3c8" class="lu lv it bd lw lx ly lz ma mb mc ll dk translated">依赖注入是一种技术，在这种技术中，抽象被免除了管理其依赖项的生命周期的责任。</p></blockquote><p id="9aa8" class="pw-post-body-paragraph ko kp it kq b kr mq kt ku kv mr kx ky kz ms lb lc ld mt lf lg lh mu lj lk ll im bi translated">使用依赖注入，如果抽象<em class="ls"> A </em>依赖于<em class="ls"> B </em>，它不会创建或者显式查找<em class="ls"> B </em>的实现。假设<em class="ls"> B </em>的实例由专用IoCC管理，并且当<em class="ls"> A </em>需要执行其业务逻辑时，其中一个实例被提供给<em class="ls"> A </em>。</p><p id="2804" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">没有控制反转的依赖注入的一个例子是由IoCC管理的单例。</p><figure class="mw mx my mz gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mv"><img src="../Images/c30012624ee22571f79e7f4b596dcc76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*uM603t2BQdi8FEWXKRuL5Q.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">IoCC管理的Singleton就是一个没有控制反转的依赖注入的例子。这里的IoCC抽象是指应用程序的IoCC配置。容器本身显然不依赖于MySingleton。</figcaption></figure><p id="9008" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">上图中，<em class="ls"> MyService </em>依赖于<em class="ls"> MySingleton </em>，控制流向相同。这里使用依赖注入来减轻<em class="ls"> MyService </em>通过调用<em class="ls"> getInstance() </em>或类似方法显式查找<em class="ls"> MySingleton </em>实例的负担。将来，@Singleton注释可以从<em class="ls"> MySingleton </em>中移除，而不必修改<em class="ls"> MyService </em>实现。</p><h2 id="4188" class="ne jr it bd js nf ng dn jw nh ni dp ka kz nj nk ke ld nl nm ki lh nn no km np bi translated">控制反转的依赖注入</h2><p id="dfee" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">依赖注入仍然是实现控制反转的最简单的方法之一。一个模块可以提供一个接口并使用这个接口的实现，而不知道具体是如何实现的。这些实现可以很容易地在单元测试和生产中进行交换，而不需要对模块进行任何修改。</p><h1 id="cf9b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="f2b3" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">系统中的依赖关系可以在不改变相应控制流方向的情况下被逆转。控制反转是在那种情况下发生的效果。在多架构中，这种效果是可取的，因为它允许通过消除不希望的方向上的依赖性来实施架构boundaries⁵，同时保留控制流结构。实现控制反转的最简单的方法是通过依赖注入和控制容器的反转，尽管这不是唯一可行的方法。</p><h1 id="f266" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">参考</h1><p id="5a08" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Martin Fowler，<a class="ae lm" href="https://martinfowler.com/articles/injection.html" rel="noopener ugc nofollow" target="_blank">控制容器的倒置和依赖注入模式</a>，2004。<br/>沃洛季米尔·弗罗洛夫，<a class="ae lm" href="https://medium.com/@volodymyrfrolov/nouml-afbb7f07f369" rel="noopener">努米尔</a>，2018。<br/>罗伯特·c·马丁，清洁建筑；《软件结构与设计工匠指南》，2018年，第87页。<br/> ⁴大卫赖斯，马特福梅尔，外挂；《企业应用架构的模式》，马丁·福勒，第499页。<br/>⁵·沃洛季米尔·弗罗洛夫，<a class="ae lm" href="https://medium.com/@volodymyrfrolov/nouml-2-9734a2746258" rel="noopener">具有抽象层次的nouml】，2019。</a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="c075" class="jq jr it bd js jt nx jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj ob kl km kn bi translated">分级编码</h1><p id="ea13" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">感谢您成为我们社区的一员！<a class="ae lm" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="kq iu">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae lm" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq iu"> Skilled.dev编码面试课程</strong> </a>。</p><div class="oc od gp gr oe of"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">编写面试问题</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">掌握编码面试的过程</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">技术开发</p></div></div><div class="oo l"><div class="op l oq or os oo ot mk of"/></div></div></a></div></div></div>    
</body>
</html>