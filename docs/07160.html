<html>
<head>
<title>Merkle Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Merkle树</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/merkle-trees-e4fdaeaa3094?source=collection_archive---------6-----------------------#2021-01-28">https://levelup.gitconnected.com/merkle-trees-e4fdaeaa3094?source=collection_archive---------6-----------------------#2021-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8df5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">概念和应用-简单明了！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aad446c22f7ba0f254f338a4ccb649d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ykn20LKvw2hyuyGV4ps5dA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Merkle树是一种二叉树，数据位于叶节点。所有内部节点都是散列。图片由马丁·托马斯提供。</figcaption></figure><p id="eb02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Merkle树是在对等网络中使用的数据结构。它是一棵二叉树，其中内部节点的值是其叶节点的散列。该树的根节点被称为“Merkle根”或“根散列”。</p><p id="3978" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于定义就说这么多。对我来说，知道技术解决的问题对真正理解它总是有帮助的。</p><h1 id="fe55" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">比特流</h1><p id="8143" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如何通过随机引入错误的网络发送大量数据？当你只是发送一个数据流时，你不能保证它的完整性。</p><p id="f076" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一个改进是添加散列函数的值:</p><div class="mr ms gp gr mt mu"><a rel="noopener  ugc nofollow" target="_blank" href="/the-3-applications-of-hash-functions-fab1a75f4d3d"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd iu gy z fp mz fr fs na fu fw is bi translated">哈希函数的3个应用</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">它们是什么，有哪些选择，以及它们为什么重要</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ks mu"/></div></div></a></div><p id="ab18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果下载文件的哈希值不等于预期的哈希值，您只需再次下载文件。</p><p id="7092" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很明显，这是低效的，因为错误很少发生。很有可能，文件的大部分都是完全没问题的。也许只有一个比特改变了它的值。你想下载的越少越好，只修复坏掉的部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/6174a624ab180119d85c828d3ad6c0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*VWinFE8Gmh8pmcg_IoN-ow.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个分成8块的大文件。2号块坏了，其余的都好。图片由马丁·托马斯提供。</figcaption></figure><p id="a38a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一个想法是搭积木。你存储每个块的散列。当你下载文件时，你首先下载一个文件头。报头包含元信息，例如块的总数、每个块的散列和元数据本身的散列。如果元数据块损坏，您需要重新下载它。然后你下载每个块并验证它。如果一个块被破坏，该块将被再次下载。</p><p id="d739" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在的问题是哪种块大小最有意义。块越小，出错时下载的数据就越少。但是块越多，需要存储的元数据就越多。举个最极端的例子:每一位都有自己的哈希值。典型散列值有256位。这意味着总大小将增加257倍！换句话说:你可以下载文件257次。</p><p id="c151" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们要下载的文件大小为4 GiB。然后，下表给出了块的数量和您必须下载的额外大小。如果您为一个32字节的散列创建32字节大小的块，您需要下载双倍的数据。这还意味着100%:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="3536" class="np lv it nl b gy nq nr l ns nt">block size     :       blocks  additional download size<br/>-------------------------------------------------------<br/>        32 Byte:  134,217,728  100.00%<br/>       128 Byte:   33,554,432   25.00%<br/>       512 Byte:    8,388,608    6.25%<br/>         1 KiB :    4,194,304    3.12%<br/>       256 KiB :       16,384    0.01%<br/>         1 MiB :        4,096    0.00%</span></pre><p id="73e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">BitTorrent的torrent文件本质上是包含以下信息的字典:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="04f6" class="np lv it nl b gy nq nr l ns nt">{<br/> "announce": "tracker url",<br/> "info": {<br/>  "length": "file size in bytes",<br/>  "name": "suggested file name",<br/>  "piece length": "typically 256 KiB",<br/>  "pices": [<br/>   "sha-1 hash of block #1",<br/>   "sha-1 hash of block #2",<br/>   "sha-1 hash of block #3"<br/>  ]<br/> }<br/>}</span></pre><p id="9d78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总结:块的哈希值列表可以大大加快通过不可靠网络下载文件的速度。</p><h1 id="e271" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">包含证明</h1><p id="6e92" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">假设您想要显示一段数据是您的数据结构的一部分。这对于Merkle树来说很容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aad446c22f7ba0f254f338a4ccb649d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ykn20LKvw2hyuyGV4ps5dA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">爱丽丝想向鲍勃证明红色方块“6”包含在Merkle树中。鲍勃知道绿色的根节点。Alice提供了3个蓝色节点H(12，34)、H(78)、“5”和红色节点“6”。然后，鲍勃计算了两个黄色节点。鲍勃永远不必看到白色的节点。马丁·托马斯的形象。</figcaption></figure><p id="58b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Merkle树允许它证明交易被包括在内。假设爱丽丝想向鲍勃证明交易T发生了。为此，她提供:</p><ul class=""><li id="d9fc" class="nu nv it la b lb lc le lf lh nw ll nx lp ny lt nz oa ob oc bi translated">交易本身，鲍勃可以很容易地为其创建一个散列。</li><li id="8338" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">计算根散列所缺少的所有散列</li></ul><p id="6d6a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，Bob必须验证Merkle根是否等于他的根。他还需要对事务进行哈希处理，并将所有哈希构建到Merkle根。由于加密哈希函数使得不可能找到哈希函数来伪造图像(<a class="ae oi" rel="noopener ugc nofollow" target="_blank" href="/the-3-applications-of-hash-functions-fab1a75f4d3d">碰撞-抗攻击性</a>)，所以Bob不必拥有所有数据。知道使用哪个根就足够了。</p><p id="e4c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">提供的哈希(蓝色节点)被称为<strong class="la iu"> Merkle证明</strong>。您证明了数据属于Merkle树。如果你想看另一个例子，看看<a class="oj ok ep" href="https://medium.com/u/a4280b6f29b4?source=post_page-----e4fdaeaa3094--------------------------------" rel="noopener" target="_blank">贝拉瓦迪·普拉哈拉德</a>文章<a class="ae oi" href="https://medium.com/crypto-0-nite/merkle-proofs-explained-6dd429623dc5" rel="noopener">墨克尔校样解释</a>。</p><p id="f684" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在比特币的上下文中，这被称为<strong class="la iu">简化支付验证(SPV) </strong>。这是第八章的<a class="ae oi" href="https://bitcoin.org/bitcoin.pdf" rel="noopener ugc nofollow" target="_blank">比特币纸</a>，或者<a class="ae oi" href="https://medium.com/coinmonks/spv-proofs-explained-f38f8bb8f580" rel="noopener"> SVP校样解释</a>由<a class="oj ok ep" href="https://medium.com/u/eee428731f69?source=post_page-----e4fdaeaa3094--------------------------------" rel="noopener" target="_blank">阿尔伯特·阿塞布龙</a>。</p><h1 id="1001" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">比特币如何使用默克莱树？</h1><p id="137b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">每个块都包含一个Merkle事务树。由于各种原因，比特币块的大小限制为4 MB。只有Merkle Trees根哈希用于哈希块。这意味着比特币节点可以丢弃相当多的数据，但仍然可以计算相同的哈希。</p><h1 id="28f0" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">Merkle树的应用</h1><ul class=""><li id="ab73" class="nu nv it la b lb mm le mn lh ol ll om lp on lt nz oa ob oc bi translated"><strong class="la iu"> Git </strong>使用哈希树来存储它的数据(<a class="ae oi" href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects" rel="noopener ugc nofollow" target="_blank">来源</a>)。如果你想理解为什么要阅读《T4走向再现性》:马丁·卡瓦拉的《git》</li><li id="eb85" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated"><strong class="la iu">数据库系统</strong> : Apache Cassandra使用Merkle树来检测副本中的不一致性(<a class="ae oi" href="https://docs.datastax.com/en/archived/cassandra/3.0/cassandra/operations/opsRepairNodesManualRepair.html" rel="noopener ugc nofollow" target="_blank">来源</a>，<a class="ae oi" href="https://www.youtube.com/watch?v=1Sz_K8UID6E" rel="noopener ugc nofollow" target="_blank">视频</a>)</li><li id="abd6" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated"><strong class="la iu">比特币&amp; IPFS，以及</strong> <a class="ae oi" href="https://storj.io/storj2014.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> Storj </strong> </a>:存储数据的核心数据结构</li><li id="2244" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">以太坊也使用Merkle树，但与比特币的类型不同。以太坊用的是Merkle Patricia Trie。</li></ul><h1 id="bf9d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">下一步是什么</h1><p id="f4c3" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">本文是我关于区块链系列的一部分:</p><ul class=""><li id="a6a6" class="nu nv it la b lb lc le lf lh nw ll nx lp ny lt nz oa ob oc bi translated">第一部分:<a class="ae oi" href="https://medium.com/coinmonks/the-blockchain-473aac352e5" rel="noopener">区块链介绍</a></li><li id="dfaa" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">第二部分:<a class="ae oi" rel="noopener ugc nofollow" target="_blank" href="/the-3-applications-of-hash-functions-fab1a75f4d3d">哈希函数的3个应用</a></li><li id="3988" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">第3部分:Merkle树</li></ul><p id="b73e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我接下来要考虑的主题:</p><ul class=""><li id="3690" class="nu nv it la b lb lc le lf lh nw ll nx lp ny lt nz oa ob oc bi translated">默克尔帕特里夏试图</li><li id="57a9" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">公钥加密和RSA:公钥和私钥，数字签名，陷门函数。它是什么，为什么如此重要</li><li id="8398" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">工作证明:如何工作，难度如何，比特币/以太/恒星有什么用途。</li><li id="b25c" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">智能合约:它们是什么以及它们如何工作；例如以以太为例</li><li id="9c36" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated"><a class="ae oi" href="https://en.wikipedia.org/wiki/Initial_coin_offering" rel="noopener ugc nofollow" target="_blank">首次发行硬币</a> (ICO)</li><li id="d832" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">比特币共识算法</li><li id="b463" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">比特币和网络:人们如何联系？</li><li id="3f52" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">比特币钱包</li><li id="172c" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated">点对点的东西:八卦协议是如何工作的</li></ul><p id="9c7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我知道你对什么感兴趣！</p><h1 id="bb8d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">请参见</h1><ul class=""><li id="830b" class="nu nv it la b lb mm le mn lh ol ll om lp on lt nz oa ob oc bi translated">Tara Vancil:<a class="ae oi" href="https://www.youtube.com/watch?v=YIc6MNfv5iQ" rel="noopener ugc nofollow" target="_blank">Merkle Trees如何实现分散式网络！</a>，YouTube上2017。</li><li id="8943" class="nu nv it la b lb od le oe lh of ll og lp oh lt nz oa ob oc bi translated"><a class="oj ok ep" href="https://medium.com/u/5874217ef543?source=post_page-----e4fdaeaa3094--------------------------------" rel="noopener" target="_blank">gaur av Sen</a>:<a class="ae oi" href="https://www.youtube.com/watch?v=qHMLy5JjbjQ" rel="noopener ugc nofollow" target="_blank">Merkle Tree with real-world examples</a>，YouTube上2019。</li></ul></div></div>    
</body>
</html>