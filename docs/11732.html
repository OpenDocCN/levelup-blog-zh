<html>
<head>
<title>How I save a few hours each week on testing Graphql in Nest.js (typescript)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在Nest.js (typescript)中每周节省几个小时来测试Graphql</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-save-a-few-hours-each-week-on-testing-graphql-in-nest-js-typescript-1afd8ceeacf7?source=collection_archive---------3-----------------------#2022-04-11">https://levelup.gitconnected.com/how-i-save-a-few-hours-each-week-on-testing-graphql-in-nest-js-typescript-1afd8ceeacf7?source=collection_archive---------3-----------------------#2022-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/10c0d34e46c9f0be14c4d5f0f28097c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZAHZ7GvucYj1KFHSiPEpw.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">智能测试节省时间。<a class="ae jg" href="https://pixabay.com/images/id-1274699/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-1274699/</a></figcaption></figure><div class=""/><p id="af41" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将向您展示如何自动化graphql测试过程。我们将从手工编写的查询转移到由类型支持的完全自动生成的查询/变化</p><h2 id="6cb2" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">问题是</h2><p id="0581" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在一些项目中，我们在Nest.js中使用GraphQL获得了很多乐趣。但有一件事一直困扰着我们……当我们想要使用我们的GQL模式作为契约来测试端到端的任何功能时，我们需要做大量的手工工作。它看起来像这样:</p><ol class=""><li id="4d61" class="mc md jj ki b kj kk kn ko kr me kv mf kz mg ld mh mi mj mk bi translated">编写查询/变异</li><li id="55a5" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">为测试目的创建一个新的普通字符串查询</li><li id="6c87" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">创建一个将使用此查询的函数</li><li id="bc56" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">通过supertest使用此功能</li></ol><p id="e0fe" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许看起来没那么糟，但是相信我。当代码库增长时，这4步过程是最无聊的事情之一…</p><p id="882f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但这不是终点！当您更改代码库中影响现有模式的某些内容时，您还需要记住在查询定义和测试中更改它。</p><p id="7b0e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们从应用程序源导入输入类型，以便至少有一些typescript支持，创建与每个测试的额外耦合。</p><h2 id="81d4" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">故事</h2><p id="165c" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">每次当这个问题出现时，我都在想我们如何自动化这个过程。我在互联网上搜索，考虑一些带有类型提示的查询生成器，等等…但是我找不到任何可以解决这个问题的方法。</p><p id="bc2e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一天，当我加入另一个尚未创建e2e测试设置的项目时，我决定再试一次。我查看了主要在前端使用的可用工具，并将它们组合在一起以实现我的目标。</p><h2 id="5868" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">解决方案</h2><p id="619c" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我找到了一个满足我所有要求的GraphQL客户端:<code class="fe mq mr ms mt b">graphql-request</code>由<code class="fe mq mr ms mt b">@graphql-codegen</code>支持。所以我开始尝试生成查询，最终我找到了解决方案，它以一种简单明了的方式给了我所有可用的查询。</p><p id="c5da" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将展示一个完整的例子，用GraphQL创建一个基于Nest.js的示例应用程序。如果您熟悉这个堆栈，可以跳过这一步，继续本文的下一部分。</p><h1 id="4d57" class="mu lf jj bd lg mv mw mx lj my mz na lm nb nc nd lp ne nf ng ls nh ni nj lv nk bi translated"><strong class="ak">示例应用</strong></h1><p id="d4b6" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们将从使用<code class="fe mq mr ms mt b">@nestjs/cli</code>创建一个空巢. js项目开始。如果你还没有这个包，你可以在这里找到如何得到它<a class="ae jg" href="https://docs.nestjs.com/first-steps" rel="noopener ugc nofollow" target="_blank">https://docs.nestjs.com/first-steps</a>。您也可以将本教程与其他工具一起使用。您需要的只是Typescript和生成的GraphQL模式。</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="fb53" class="le lf jj mt b gy nt nu l nv nw">nest new graphql-testing-example</span></pre><p id="a744" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">生成应用程序后，我们可以稍微清理一下src文件夹。删除<code class="fe mq mr ms mt b">app.controller.ts app.controller.spec.ts</code>和<code class="fe mq mr ms mt b">app.module.ts</code>中相应的注册。</p><p id="5237" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们需要安装所需的依赖项:</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="ee89" class="le lf jj mt b gy nt nu l nv nw">yarn add <a class="ae jg" href="http://twitter.com/nestjs/graphql" rel="noopener ugc nofollow" target="_blank">@nestjs/graphql</a> <a class="ae jg" href="http://twitter.com/nestjs/apollo" rel="noopener ugc nofollow" target="_blank">@nestjs/apollo</a> graphql apollo-server-express</span></pre><p id="30f7" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在是时候在我们的应用程序中注册GraphQLModule了:</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a9d2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这段代码中，声明<code class="fe mq mr ms mt b">autoSchemaFile</code>很重要。稍后我们将使用它来基于模式生成类型。</p><p id="8f74" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在是时候创建一些代码了，出于示例的目的，我们将创建2个文件并调整<code class="fe mq mr ms mt b">app.service.ts</code>。</p><p id="7e5e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mq mr ms mt b">gql-dtos.ts</code> —为了简化示例，我们将在一个文件中创建所有的类。</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8881" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mq mr ms mt b">app.service.ts</code> —我们将在这里创建我们的“业务逻辑”。这将非常简单——我们将允许我们的用户对用户进行基本的CRUD操作。</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2021" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mq mr ms mt b">app.resolver.ts</code> —我们的GraphQL解析器，基于这个文件Nest.js将生成模式，稍后将处理我们的请求。</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="106c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们运行:<code class="fe mq mr ms mt b">yarn start:dev</code>我们将有一个工作的应用程序！现在我们可以进入这篇文章的核心部分。GraphQL测试！</p><h1 id="57d2" class="mu lf jj bd lg mv mw mx lj my mz na lm nb nc nd lp ne nf ng ls nh ni nj lv nk bi translated">GraphQL测试工具</h1><h2 id="acc9" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">先决条件</h2><p id="b138" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们需要从安装所需的包开始。</p><pre class="nl nm nn no gt np mt nq nr aw ns bi"><span id="d1bd" class="le lf jj mt b gy nt nu l nv nw">yarn add -D gql-generator <a class="ae jg" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/cli <a class="ae jg" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/introspection <a class="ae jg" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/typescript <a class="ae jg" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/typescript-graphql-request <a class="ae jg" href="http://twitter.com/graphql" rel="noopener ugc nofollow" target="_blank">@graphql</a>-codegen/typescript-operations <a class="ae jg" href="http://twitter.com/types/node-fetch" rel="noopener ugc nofollow" target="_blank">@types/node-fetch</a></span></pre><p id="3b6b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许我会解释为什么有这么多的包。</p><p id="4713" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mq mr ms mt b">gql-generator</code>用于根据<code class="fe mq mr ms mt b">schema.gql</code>生成原子对象和输入。</p><p id="8aba" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mq mr ms mt b">@graphql-codegen/*</code>包用于将之前生成的文件转换成<code class="fe mq mr ms mt b">graphql-request</code>的类型和Sdk。</p><p id="e56a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mq mr ms mt b">@types/node-fetch</code>我们将使用它来基于<code class="fe mq mr ms mt b">supertest</code>键入我们自己的<code class="fe mq mr ms mt b">fetch</code>实现。</p><p id="8f96" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，当我们拥有所有需要的包时，我们可以将它们组合在一起以实现我们的目标:节省时间！</p><h2 id="015b" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">履行</h2><p id="464e" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们将从创建SessionFactory开始。我们的工厂将为我们生成新的会话，在我们的示例中，它不会有太大用处。但是当你在测试期间需要基于两个不同的用户与应用程序交互时，这将允许我们这样做。</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="e312" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以深入到这段代码中，它只创建了一个工厂方法，该方法将返回我们的Sdk实例。每个Sdk实例都是独立的，因此，举例来说，每个实例可以有不同的cookies或标题。同样，在这个方法中，您可以实现某种用户流。例如，如果您的应用程序有用户和管理员，您可以创建2个工厂方法。每个方法都将调用您的API来接收基于类型的授权令牌，并返回准备好授权请求的Sdk。</p><p id="85d4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mq mr ms mt b">supertestFetch</code>是一个supertest代理实例，通过抽象来实现<code class="fe mq mr ms mt b">fetch</code>接口。这是因为<code class="fe mq mr ms mt b">graphql-request</code>在引擎盖下使用fetch。</p><p id="5d39" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们在示例中使用Nest.js时，我们将创建util来抽象公共代码。</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b89e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将在这个位置创建一个SessionFactory，并返回现有的实例。它将在每次测试中节省几行代码；)</p><h2 id="4ceb" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">使用</h2><p id="99ac" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">现在是表演时间了！</p><figure class="nl nm nn no gt iv"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="70d7" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很难展示它有多强大。正如您在上面的例子中看到的，<code class="fe mq mr ms mt b">Sdk</code>包含了您的后端提供的所有可用的查询和变异。我还建议下载存储库并尝试更改输入、突变，观察当您重新生成Sdk时，什么类型的脚本会告诉您哪里出错了。</p><h1 id="b42b" class="mu lf jj bd lg mv mw mx lj my mz na lm nb nc nd lp ne nf ng ls nh ni nj lv nk bi translated">摘要</h1><p id="56a1" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在本文中，我向您展示了如何测试GraphQL。希望你喜欢这个教程，它会改变你的生活，就像我一样！另外:</p><ul class=""><li id="127c" class="mc md jj ki b kj kk kn ko kr me kv mf kz mg ld nz mi mj mk bi translated">也许你知道如何在node.js中测试GraphQL的其他方法？</li><li id="e2db" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld nz mi mj mk bi translated">有什么改进的办法吗？</li></ul><p id="1ba8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">把它们留在评论区吧！</p><p id="9adc" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">链接到存储库:<a class="ae jg" href="https://github.com/adziok/nestjs-graphql-testing" rel="noopener ugc nofollow" target="_blank">https://github.com/adziok/nestjs-graphql-testing</a></p></div></div>    
</body>
</html>