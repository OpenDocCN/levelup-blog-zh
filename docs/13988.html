<html>
<head>
<title>How to Eliminate Injecting ILogger<t> Everywhere in .NET</t></title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何消除注射ILogger <t>无处不在？网络</t></h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-eliminate-injecting-ilogger-t-everywhere-in-net-301be7b367a8?source=collection_archive---------0-----------------------#2022-10-23">https://levelup.gitconnected.com/how-to-eliminate-injecting-ilogger-t-everywhere-in-net-301be7b367a8?source=collection_archive---------0-----------------------#2022-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b632" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将您的所有服务从这个显式注入中解放出来</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4befa7839e691ceb90113333ee4f8fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iq7mtfz5hLlQsCI3"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">扎克·杜兰特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="91b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖注入是很棒的，它为你节省了大量的连接和创建实例的手动设置，这些实例可以在你的整个应用程序中使用。然而，这也带来了一个问题。我们越来越习惯于简单地向另一个服务添加一个新的依赖项，以至于我们可能做得有点过头了。对服务的依赖太多是不干净的，应该重构。尽管如此，总有这样一种依赖性，它存在于如此多的构造函数中，存在于如此多的项目中——<code class="fe lv lw lx ly b">ILogger&lt;T&gt;</code>。</p><p id="04f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将向您展示一种至少可以从您的构造函数中消除这个<code class="fe lv lw lx ly b">ILogger&lt;T&gt;</code>的方法。这不会明显地消除依赖性，但它会从构造函数中移除一个参数，从而使测试期间模仿您的类更容易，并且为每个类节省一行代码。</p><h2 id="d1a2" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">咨询通知</h2><p id="b66c" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">下面的方法当然有它的缺点，并且<strong class="lb iu">不</strong>符合传统的干净代码/干净架构模式。通过从构造函数中移除<code class="fe lv lw lx ly b">ILogger</code>，你实际上<strong class="lb iu">隐藏了</strong>一个依赖。当将类移动或复制到另一个不能访问静态记录器工厂的存储库时，这个隐藏的依赖项可能需要更多的工作来调整。此外，您可能不得不在测试期间做额外的工作，并且可能会使不熟悉这种方法的其他程序员感到困惑。只有当你确信它的好处大于它的缺点时，才使用这个解决方案。</p><p id="2bf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，与在构造函数中注入<code class="fe lv lw lx ly b">ILogger</code>的“干净”方式相比，这种方法有几个好处，前提是你有一个单一的解决方案，即<strong class="lb iu">而不是</strong>像微服务那样是分布式环境的一部分。</p><ul class=""><li id="72f4" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">您可以使用日志记录器，否则它只能作为参数传递，例如静态类、方法和扩展方法。</li><li id="68d6" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">测试只是比DI更难。您没有将ILoggerFactory-Mock传递给DI容器，而是将其传递给静态记录器工厂，这花费了您一行代码。</li><li id="9deb" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">如果<code class="fe lv lw lx ly b">ILogger</code>接口保持不变，那么改变记录器实现只需要改变静态记录器工厂。</li><li id="583b" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">当一个类不能被DI实例化时，你不必考虑如何为这个类获得一个日志记录器。例如一个工厂，在这里注入ILoggerFactory。</li><li id="e068" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">消除日志依赖的“干净”方法，如装饰模式、动态代理或中间件，只允许在方法之前和之后记录日志，而不是在方法之间。</li></ul><h2 id="2a17" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">静态记录器工厂</h2><p id="63ca" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">消除任何类型的注入的第一步可能是将它作为<code class="fe lv lw lx ly b">static</code>保存在任何地方。对于<code class="fe lv lw lx ly b">ILogger</code>来说，这可以通过保持一个<code class="fe lv lw lx ly b">ILoggerFactory</code>静态可访问来实现。为此，我创建了一个名为<code class="fe lv lw lx ly b">StaticLoggerFactory</code>的静态类。这个类拥有一个静态的<code class="fe lv lw lx ly b">ConcurrentDictionary&lt;Type, ILogger&gt;</code>，它保存所有的<code class="fe lv lw lx ly b">ILogger</code>实例，并使它们可以并发访问。我还为方便的方法<code class="fe lv lw lx ly b">GetOrAdd()</code>选择了这个类，它给了我们一个创建实例的liner，如果它不在字典中，如果在，就返回一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="58fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类必须用一个<code class="fe lv lw lx ly b">ILoggerFactory</code>来初始化。在您将日志添加到您的<code class="fe lv lw lx ly b">IServiceCollection</code>之后，您可以从<code class="fe lv lw lx ly b">IServiceProvider</code>中获得一个这样的实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="be40" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">使用StaticLoggerFactory</h2><p id="a8e3" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">这就是设置，现在我们将看看如何在其他课程中使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="19e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需调用我们的静态日志工厂的<code class="fe lv lw lx ly b">GetStaticLogger&lt;T&gt;</code>函数，就可以了。顺便说一下，如果您将下面一行添加到全局usings(.NET 6及以上):</p><p id="59c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">global using static &lt;YourNameSpace&gt;.StaticLoggerFactory;</code></p><p id="30a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行使您能够简单地调用静态方法，而不用提及类名<code class="fe lv lw lx ly b">StaticLoggerFactory</code>，正如您在上面的例子中所看到的。</p><p id="1684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们将它与之前注射<code class="fe lv lw lx ly b">ILogger&lt;T&gt;</code>的方式进行比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注入和空检查使用了<code class="fe lv lw lx ly b">92</code>个额外的字符，而静态方法只使用了<code class="fe lv lw lx ly b">35</code>个字符(计算在属性名之后)。因此，通过使用这种方法，您可以保护多几行代码，并且不必再担心在您的测试中创建多个<code class="fe lv lw lx ly b">ILogger</code>模拟。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="5f39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请在评论中告诉我你对这种方法的看法。是干净了，还是把事情搞复杂了？你是愿意把字典放在一边还是留着它？</p><p id="347e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想查看代码，你可以在我的github上找到它:</p><div class="nu nv gp gr nw nx"><a href="https://github.com/TobiStr/LoggerElimination" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">GitHub-TobiStr/logger elimination:如何消除在。网</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">只需创建一个静态类，它包含一个字典，并从启动逻辑中初始化一个静态LoggerFactory</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="bf35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您花时间阅读这篇文章。我希望，你会觉得它有知识性、教育性和趣味性。非常感谢您的支持和参与。</p><p id="2403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有兴趣了解干净架构、干净编码和最新技术栈的最新趋势、技巧和诀窍，尤其是在C#环境中。净和有棱角——如果你考虑跟踪我，我会很感激。</p><p id="5f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你有美好的一天！</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/429378e6a7aee01df92851fb0e90e385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK4zVN8TtnIM37dhEhE54g.png"/></div></div></figure><p id="2357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有每天使用媒体来增长你的知识，现在是开始的最佳时机！借助Medium，您可以轻松获得更多关于高度专业的主题的知识，发布高质量的内容，并接触到更广泛的受众。要开始，只需使用以下链接创建一个中型帐户:</p><p id="28a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@tobias.streng/membership" rel="noopener"> <em class="on">现在加入中等</em> </a></p><p id="cb60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，你将获得一个强大的平台，可以帮助你联系新的作者和读者，每天学习新的东西。</p></div></div>    
</body>
</html>