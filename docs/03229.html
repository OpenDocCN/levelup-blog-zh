<html>
<head>
<title>Handle Authentication For Cloud Function Client In Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang中为云功能客户端处理认证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handle-authentication-for-cloud-function-client-in-golang-9337b20f9650?source=collection_archive---------14-----------------------#2020-04-26">https://levelup.gitconnected.com/handle-authentication-for-cloud-function-client-in-golang-9337b20f9650?source=collection_archive---------14-----------------------#2020-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bf74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">注</em> </strong> <em class="kl">:我为此发布了一个开源库</em><a class="ae km" href="https://github.com/CodeLinkIO/go-cloudfunction-auth" rel="noopener ugc nofollow" target="_blank"><em class="kl">go-cloud function-auth</em></a><em class="kl">。如果你遇到同样的需求，你可以直接使用这个库(见示例</em> <a class="ae km" href="https://github.com/CodeLinkIO/go-cloudfunction-auth/blob/master/samples/main.go" rel="noopener ugc nofollow" target="_blank"> <em class="kl">此处</em> </a> <em class="kl">)。在这篇文章中，我将更多地谈论我是如何调查和解决这个问题的。</em></p><p id="f745" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几周前，我需要将我的后端与部署在云功能上的另一项服务相集成。最初，我认为这种集成应该是直接的，因为我的后端和新服务都是由谷歌的服务支持的。使用我的谷歌服务账户认证云功能应该很简单。</p><p id="45d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个假设对于Javascript是正确的。google-auth-library 很好地支持了这种情况。下面的JS代码运行良好:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="7307" class="kw kx iq ks b gy ky kz l la lb">const {GoogleAuth} = require('google-auth-library');<br/><br/>const targetAudience = "cloud-function-url"<br/><br/>async function run() {<br/>	const auth = new GoogleAuth();<br/><br/>	const client = await auth.getIdTokenClient(targetAudience);<br/>	const res = await client.request({ url });<br/>	console.info(res.data);<br/>}</span></pre><h1 id="49c9" class="lc kx iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">它不起作用！</h1><p id="c255" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">google在Golang也有<a class="ae km" href="https://godoc.org/golang.org/x/oauth2" rel="noopener ugc nofollow" target="_blank"> OAuth2 </a>库，其中包含支持Google服务认证的子包<a class="ae km" href="https://godoc.org/golang.org/x/oauth2/google" rel="noopener ugc nofollow" target="_blank"> google </a>。读了一会儿文档后，我想到了下面的代码。但是好像不管用…</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="3c88" class="kw kx iq ks b gy ky kz l la lb">import	"golang.org/x/oauth2/google"<br/>func getToken() (err error) {<br/>    scope := "https://www.googleapis.com/auth/cloud-platform"<br/>    client, err := google.DefaultClient(context.Background(), scope)<br/>    if err != nil {<br/>    	return<br/>    }<br/>    res, err := client.Get("cloud-function-url")<br/>    if err != nil {<br/>	    return<br/>    }<br/>    fmt.Println(res)<br/>    return<br/>}</span></pre><p id="4d3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与Nodejs代码相比，我认为上面的代码缺少了<code class="fe me mf mg ks b">targetAudience</code> param，而它可能是一个强制参数。嗯，有道理。过了一会儿，我深入研究了这个库，以这段代码结束。还是不行！</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="c8cc" class="kw kx iq ks b gy ky kz l la lb">baseUrl := "your-cloudfunction-baseurl"<br/>ctx := context.Background()<br/>targetAudience := baseUrl<br/>credentials, err := google.FindDefaultCredentials(ctx)<br/>if err != nil {<br/>	fmt.Printf("cannot get credentials: %v", err)<br/>	os.Exit(1)<br/>}<br/><br/>tokenSrc, err := google.JWTAccessTokenSourceFromJSON(credentials.JSON, targetAudience)<br/>if err != nil {<br/>	fmt.Printf("cannot create jwt source: %v", err)<br/>	os.Exit(1)<br/>}<br/><br/>client := oauth2.NewClient(context.Background(), tokenSrc)<br/>if err != nil {<br/>	return<br/>}<br/>res, err := client.Get(baseUrl + "sub-url")<br/>if err != nil {<br/>	return<br/>}</span></pre><p id="cd04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过一段时间的反复检查，以确保服务帐户在我的本地环境中设置正确，我知道这一部分可能比我预期的要长得多。我需要深入研究OAuth2代码。</p><h1 id="212d" class="lc kx iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">调查</h1><p id="c3bf" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">由于我的Nodejs代码已经运行，我开始比较双方生成的JWT令牌。下面是来自GCP的JWT令牌的结构，它允许我验证云函数调用:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="78d5" class="kw kx iq ks b gy ky kz l la lb">{<br/> alg: "RS256",<br/> kid: "...",<br/> typ: "JWT"<br/>}.<br/>{<br/> aud: "&lt;my cloud function base url&gt;",<br/> azp: "&lt;my service account email&gt;",<br/> email: "&lt;my service account email&gt;",<br/> email_verified: true,<br/> exp: &lt;time&gt;,<br/> iat: &lt;time&gt;,<br/> iss: "https://accounts.google.com",<br/> sub: "&lt;a string of digits&gt;"<br/>}.<br/>[signature]</span></pre><p id="e296" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我从Golang代码中收到的JWT:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="c850" class="kw kx iq ks b gy ky kz l la lb">{<br/> alg: "RS256",<br/> kid: "...",<br/> typ: "JWT"<br/>}.<br/>{<br/> iss: "&lt;my service account email&gt;",<br/> aud: "&lt;my cloud function base url&gt;",<br/> exp: &lt;time&gt;,<br/> iat: &lt;time&gt;,<br/> sub: "&lt;my service account email&gt;"<br/>}.<br/>[signature]</span></pre><p id="d389" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结构差别很大。但至少我找到了一丝光亮。无效登录可能是由于JWT的结构无效。我开始实现google库的修改版本，按照我的Nodejs输出来改变JWT结构。</p><p id="c122" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过一段时间的编码，我使输出结构匹配。可惜还是不行。这里有什么问题？我感到很失落。过了一会儿，似乎最好离开IDE，去拿我的咖啡。</p><p id="1353" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题似乎比我想象的更复杂。我决定深入研究谷歌的<a class="ae km" href="https://developers.google.com/identity/protocols/oauth2/service-account" rel="noopener ugc nofollow" target="_blank"> OAuth2协议</a>。授权流程有两个主要步骤，如下图所示:</p><figure class="kn ko kp kq gt mi gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/6793f89b869e0aa0a78fe6b8b75465c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/0*I3oQY4aMFGL1ilky.png"/></div></figure><p id="49c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个流中生成了两个不同的jwt。第一个由客户端代码创建和签名，而第二个由Google的服务器生成。Google返回的JWT应该是最后一个，并附加到HTTP客户端的请求头中。Nodejs库也是如此。当我添加了一个断点来跟随它的执行流时，我可以看到它生成了一个签名的JWT，调用Google，并为以后的请求捕获响应的JWT。</p><p id="8e5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Golang图书馆没有。它产生一个JWT并直接使用这个值。这个流程可能适用于Google的其他产品，其中Google API接受从我们的服务帐户生成的令牌。另一方面，我的云函数是一个自定义API，需要来自谷歌的签名JWT。</p><p id="b9b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，我可以解决Golang库的两个问题:</p><ul class=""><li id="f61d" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">它没有遵循Google的OAuth2流程。虽然这种实现可能适用于其他服务，但它不适用于云功能。</li><li id="58e6" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">Golang库的输出JWT的结构与Nodejs库生成的第一个JWT不匹配。为此，我需要一些自定义代码。</li></ul><h1 id="83be" class="lc kx iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解决办法</h1><p id="8b00" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">调查是正确的。我设法让我的自定义代码工作。以下是我所做的总结:</p><ul class=""><li id="56b4" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">在本地生成并签署JWT。令牌应该包括<code class="fe me mf mg ks b">audience</code>字段，该字段设置为我们的云函数的基本URL。</li><li id="6392" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">将这个JWT发送到Google，遵循他们的规范，从响应中分离返回的令牌。</li><li id="37e8" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">将这个最后的令牌附加到所有HTTP客户端的头部</li></ul><p id="0b3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是我的代码的一些主要部分:</p><pre class="kn ko kp kq gt kr ks kt ku aw kv bi"><span id="8fe4" class="kw kx iq ks b gy ky kz l la lb">const GOOGLE_TOKEN_URL = "https://oauth2.googleapis.com/token"<br/><br/>func JWTAccessTokenSourceFromJSON(jsonKey []byte, audience string) (oauth2.TokenSource, error) {<br/>	cfg, err := google.JWTConfigFromJSON(jsonKey)<br/>	if err != nil {<br/>		return nil, fmt.Errorf("google: could not parse JSON key: %v", err)<br/>	}<br/>	pk, err := internal.ParseKey(cfg.PrivateKey)<br/>	if err != nil {<br/>		return nil, fmt.Errorf("google: could not parse key: %v", err)<br/>	}<br/>	ts := &amp;jwtAccessTokenSource{<br/>		email:    cfg.Email,<br/>		audience: audience,<br/>		pk:       pk,<br/>		pkID:     cfg.PrivateKeyID,<br/>	}<br/>	tok, err := ts.Token()<br/>	if err != nil {<br/>		return nil, err<br/>	}<br/>	return oauth2.ReuseTokenSource(tok, ts), nil<br/>}<br/><br/>type TokenResponse struct {<br/>	IdToken string `json:"id_token"`<br/>}<br/><br/>func Authenticate(tokenSource oauth2.TokenSource) (token oauth2.Token, err error) {<br/>	jwt, err := tokenSource.Token()<br/>	if err != nil {<br/>		return<br/>	}<br/><br/>	client := &amp;http.Client{Timeout: time.Second * 10}<br/>	payload := strings.NewReader("grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&amp;assertion=" + jwt.AccessToken)<br/>	req, _ := http.NewRequest("POST", GOOGLE_TOKEN_URL, payload)<br/>	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")<br/>	res, err := client.Do(req)<br/>	if err != nil {<br/>		return<br/>	}<br/>	defer res.Body.Close()<br/>	body, err := ioutil.ReadAll(res.Body)<br/>	if err != nil {<br/>		return<br/>	}<br/>	tokenRes := &amp;TokenResponse{}<br/>	err = json.Unmarshal(body, tokenRes)<br/>	if err != nil {<br/>		fmt.Println(err.Error())<br/>	}<br/>	token = oauth2.Token{<br/>		AccessToken: tokenRes.IdToken,<br/>	}<br/>	return<br/>}<br/><br/>func NewClient(jwtSource oauth2.TokenSource) *http.Client {<br/>	token, err := Authenticate(jwtSource)<br/>	if err != nil {<br/>		fmt.Printf("cannot authenticate with google: %v", err)<br/>		os.Exit(1)<br/>	}<br/><br/>	return &amp;http.Client{<br/>		Transport: &amp;oauth2.Transport{<br/>			Base: http.DefaultClient.Transport,<br/>			Source: &amp;googleTokenSource{<br/>				GoogleToken: &amp;token,<br/>			},<br/>		},<br/>	}<br/>}</span></pre><h1 id="1d5a" class="lc kx iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="b8d8" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">这一部分比我计划的要长得多。由于我与Nodejs的其他集成运行得相当顺利，我认为它与Golang的集成也会很简单，特别是当Golang是Google的语言时。令人惊讶的是，我在网上找不到任何好的文档或对话。</p><p id="3617" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从积极的一面来看，深入这个问题让我对JWT一代和OAuth2流有了更多的了解。我将我的代码作为开源库发布<a class="ae km" href="https://github.com/CodeLinkIO/go-cloudfunction-auth" rel="noopener ugc nofollow" target="_blank"> go-cloudfunction-auth </a>。我希望这篇文章和这个库可以帮助其他遇到类似问题的人。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="3fb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">最初发布于</em><a class="ae km" href="https://huynvk.dev/blog/handle-authentication-for-cloud-function-client-using-google-service-account" rel="noopener ugc nofollow" target="_blank"><em class="kl">https://huynvk . dev</em></a><em class="kl">。</em></p></div></div>    
</body>
</html>