<html>
<head>
<title>A Solid RealWorld Demo Comparison of JavaScript Framework Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript框架性能的真实演示比较</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-solid-realworld-demo-comparison-8c3363448fd8?source=collection_archive---------5-----------------------#2020-02-27">https://levelup.gitconnected.com/a-solid-realworld-demo-comparison-8c3363448fd8?source=collection_archive---------5-----------------------#2020-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7d5b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">SolidJS作为现实世界演示中的最新挑战者进入拳击场。让我们看看它是如何堆积起来的。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7adb783e968bce21eea3815fffc03093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tuxKv-hVTjGvZ_VqeD89FQ.png"/></div></div></figure><p id="917e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于我，你应该知道的第一件事是，我对性能基准非常着迷。我开始着手编写反应式JavaScript UI库，并试图证明一些东西。这种方法的某些本质上吸引了我，在证明它优于虚拟DOM之前，我不会罢休。对我来说，这始于表现。但那是5年前，他们花了4年时间才达到那个目标。</p><p id="1a1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以没错，我说的是<a class="ae ln" href="https://github.com/ryansolid/solid" rel="noopener ugc nofollow" target="_blank"> SolidJS </a>，一个现代的全功能反应式JavaScript UI库。它检查所有带有JSX组件的盒子，类似钩子的API，上下文，门户，片段，悬念，Web组件支持，SSR，你能想到的。它可能是你见过的最具性能的库(见下文)，但这不是我们今天关注的重点。我们不再深究渲染性能，而是更全面地审视应用程序性能。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lo"><img src="../Images/54ab9ac975cc5a863ca4f4f43063b472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*171wYvnqvRYsLNkeEsXV1Q.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">JS框架基准测试结果Chrome 80(2020年2月)</figcaption></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8bc6" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">真实世界演示</h1><div class="ms mt gp gr mu mv"><a href="https://github.com/gothinkster/realworld" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">哥特斯特/现实世界</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">虽然大多数“待办事项”演示提供了一个框架功能的极好的粗略浏览，但它们通常不会传达…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj kp mv"/></div></div></a></div><p id="f647" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">RealWorld演示是一个大型的社区支持的开源项目，它通过构建一个示例应用程序来展示所有的web框架客户端或服务器端，这个示例应用程序比典型的TodoMVC玩具演示或基准测试中的剥离场景要丰富得多。作为Conduit，一种中等的克隆，您的应用程序必须处理诸如身份验证、路由和异步数据加载等实际问题。它有一个标准化的规范，使它成为购买下一个库或框架的更好的地方。</p><p id="d66d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，这并没有把我们这些性能迷拒之门外。我们不再关注在一个表中呈现10000个旋转的立方体或行，而是着眼于加载优化、代码大小以及用户和开发人员的体验。因此，雄心勃勃的任务似乎很简单。做出最小和最快的实现，每个人都会看到并希望在他们的项目中使用。对于Solid来说，这意味着突出它的优势，同时测试纯客户端渲染的单页面应用程序的极限。在这个过程中，Solid将不得不使用SSR与包括Svelte在内的其他库竞争。所以我想验证一个假设。</p><p id="0584" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我在低性能设备上见证过，尤其是高性能和低性能库之间的渲染性能差距越来越大。如果像Solid这样的库在渲染大量节点时已经快了几百毫秒，那么使用SSR得到的更早的第一个有意义的内容时间在哪些方面不会产生有意义的影响呢？</p><h1 id="b4ee" class="ma mb iq bd mc md nk mf mg mh nl mj mk jw nm jx mm jz nn ka mo kc no kd mq mr bi translated">测试</h1><p id="9c05" class="pw-post-body-paragraph kr ks iq kt b ku np jr kw kx nq ju kz la nr lc ld le ns lg lh li nt lk ll lm ij bi translated">所以我马上要说，这里的测试方法很难说是决定性的。我只是简单地将每个实现运行10次，然后取前3个结果的平均值。我基于他们每年做的比较。关于2019年版，请参见:</p><div class="ms mt gp gr mu mv"><a href="https://www.freecodecamp.org/news/a-realworld-comparison-of-front-end-frameworks-with-benchmarks-2019-update-4be0d3c78075/" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">前端框架与基准测试的真实对比(2019年更新)</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">作者亚采克·沙也有以下版本:土耳其语-感谢@额尔德尼兹，波图格斯-感谢@菲利佩菲亚略第三次…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">www.freecodecamp.org</p></div></div><div class="ne l"><div class="nu l ng nh ni ne nj kp mv"/></div></div></a></div><p id="59cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种比较测试了3个指标:性能、大小和LOC。我从我的运行中收集了一些其他指标，以提供更好的洞察力，但这本质上是相同的测试。性能通过Chrome Inspectors Lighthouse审计。Size是为呈现初始登录页面而发送的JavaScript的总大小(kb)。最后，使用<a class="ae ln" href="https://github.com/kentcdodds/cloc" rel="noopener ugc nofollow" target="_blank"> cloc </a>测量loc，将src文件夹中的JS、CSS和HTML的总行数相加(即不包括库代码)。</p><p id="dd39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这绝不是官方的比较。<a class="ae ln" href="https://github.com/gothinkster/realworld/issues/471" rel="noopener ugc nofollow" target="_blank"> Solid目前正在等待合并</a>，所以我想借此机会看看它的进展如何。我从2019年的comparison +热门库React、Angular和Vue中挑选了表现最好的库，并进行了测试。你可以试试Solid的应用程序:</p><div class="ms mt gp gr mu mv"><a href="https://ryansolid.github.io/solid-realworld/" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">水管</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">可靠的真实世界示例应用程序</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">ryansolid.github.io</p></div></div></div></a></div></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ede5" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">表演</strong></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/b07c3caaa6a9f636934fd145e28d9a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gdSsQSH5FpCjn5zbXJ6hZw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">灯塔绩效得分(越高越好)</figcaption></figure><p id="8062" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑到这里库的分布，这个基准比大多数基准要接近得多。Lighthouse审计基本上根据初始加载指标对每个库打分(满分为100分)，比如到达第一个字节的时间、第一次内容丰富的绘制、交互时间、最大输入延迟。所有库都在CPU和网络节流下运行，以模拟低端设备和恶劣的网络条件。这里有一半的图书馆仍然得分近乎完美。流行的库有点慢，Vue领先，现在过时的React Redux落后。</p><p id="1342" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在分数上没有真正的区别。那么让我们来看一个更夸张的分数时间互动(TTI)。这是页面准备好接收用户输入的时候。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/46396452ab44d3850a333b6f6f94d536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9qxpti_syV842LTK9nsXtA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">灯塔到交互的时间(以秒为单位，越短越好)</figcaption></figure><p id="943a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管如此，排名前五的图书馆离这里很近。在酷热中苗条而结实。如果有什么不同的话，这只是举例说明了Angular和React Redux花费超过5.5秒进行交互时，性能下降对流行库的实际影响。</p><p id="8b0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这一点上，我查看了一些其他的存储库，看看是否有其他真实的例子有更好的性能数字。在尝试了十几个其他的回购后，我只找到了一个:微软Blazor。Blazor是一个Web程序集库，允许实现者用C#编写他们的应用程序，并在浏览器中运行它们。它得了99分。令人印象深刻。</p><p id="25a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">…如果它不是我见过的最慢的图书馆的话，那就是了。如此之慢，以至于Chrome认为它已经在加载屏幕上完成了加载，所以它给了它很高的分数，因为它加载加载屏幕很快。所以我开始查看Chrome的性能时间表，我发现了一个非常不同的故事。在看到它们之间的区别后，我决定看看这些库是如何堆叠的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/7f67c3bbb1d7e778da3632cedd189a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dN7sDpYY_aZuYeIiVIhxZw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">Chrome Inspector Trace(毫秒——越低越好)</figcaption></figure><p id="272c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，从Inspector时间线加载资源的总时间线并不能清楚地表明页面的加载速度，因为有JavaScript加载和运行以及DOM节点呈现。与TTI相反，这些数字大约是1秒。这里唯一有趣的事情是，除了Solid (Svelte，AppRun)之外，使用代码分割的库相对于它们的大小来说要慢一些。像Elm和HyperApp这样的中等大小的代码捆绑在一个文件中，加载速度要快得多。</p><p id="b644" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个区别是，固体应用程序只分为3块，而苗条和AppRun有大约8块。考虑到浏览器对并发连接数的限制，初始资源加载可能会因过多的代码分割而出现瓶颈。Solid还使用了一个“随取随渲染”实现，在加载路由代码之前进行API调用，这也可能有助于加快资源加载时间。</p><p id="6a17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">结论:</strong>对于这种测试来说，性能最好的库的性能过于接近，难以区分。为此，我们必须继续使用合成基准。Solid的客户端渲染应用程序在所有测试中都名列前茅，因此没有投诉。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="255b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">大小</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/987003fc562eba0ec1309e03f5af31d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5z67nsKZDvV60E-KrebRlQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">初始页面JS大小(kb——越小越好)</figcaption></figure><p id="2355" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在过去，人们只关注初始代码块，以不同的方式衡量这个测试。我认为有必要查看加载第一页所需的所有JS。Solid的12.1kb超过了之前的领跑者Svelte的14.8kb。这是有史以来第一次测试Solid更小。苗条的通常小50%。之前的比较显示，当所有JS加载所有页面时，Svelte的代码大小实际上比Elm的大，这表明Svelte在大小上可能不如组件。大多数基准测试鼓励您在单个组件中完成所有工作。从那以后，整个应用程序的AppRun大约为18kb，使它成为非代码分割库的赢家。</p><p id="c891" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ny">2020年3月24日编辑:自从这篇文章发表以来，Solid已经将另一个kb缩减到11.1 kb。</em></p><p id="482e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">结论:</strong>所有被考虑的事情都在朝着正确的方向发展。React Redux一度让Angular看起来很庞大，现在像Solid这样的库的实现几乎小了20倍。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a32c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">代码行</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/9fed550d48505f03710f74fe134d9644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7lGPwIsW7XphclmuB1hk-g.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">代码行(越少越好)</figcaption></figure><p id="e34d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">苗条无疑保持了它在这里的声誉。也许令人惊讶的是，接下来的4个库都使用JSX，接着是Vue和Angular的字符串模板，然后是一个JSX库，最后是Elm。Elm是代码行上的庞然大物。它几乎是其他一切的两倍。但是快速看一下源代码就知道为什么了，因为它写得更垂直。固体也具有与其尺寸相比更高LOC量。我决定用图表示它(见下文)，但不确定它有什么意义。我想我应该怪漂亮的人。</p><p id="c52e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">结论:</strong>仍然不清楚这个LOC实际上是否意味着什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/5dec92f4dc113bd16d5099a6c3698cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHxuWg6PkvZhBiA2cgEhOA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">大小/位置(kb/位置*1000)</figcaption></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="2284" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">一个“真实世界”的演示？？</h1><p id="7d37" class="pw-post-body-paragraph kr ks iq kt b ku np jr kw kx nq ju kz la nr lc ld le ns lg lh li nt lk ll lm ij bi translated">算是吧。Solid在演示中遵循了极简主义的悠久传统。没有使用第三方AJAX党库。几十行写的路由器。没有全球状态管理系统。没有表单验证库。</p><p id="a21b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管如此，这里仍有很多东西可以展示。该应用程序很好地利用了商店中Solid的原语和上下文API，创建了一些你可能会在外部库中找到的东西。该应用程序充分利用了懒惰组件和数据抓取的悬念。特别是，在提取时渲染技术中，数据提取是在解析主块中的路径时初始化的，并且数据和代码是同时提取的。如果代码首先加载，它开始在屏幕外呈现，只有在数据到达时暂停完成。</p><p id="1169" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我会写一篇后续文章解释代码和过程。但目前就这样了。查看Solid，并确保亲自查看演示应用程序。直到下次。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt mv"><a href="https://github.com/ryansolid/solid-realworld" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">瑞安索利德/固体-现实世界</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">Solid.js代码库包含符合现实世界的真实示例(CRUD、auth、高级模式等)。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="oa l ng nh ni ne nj kp mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a href="https://github.com/ryansolid/solid" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">瑞安固体/固体</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">一个用于构建用户界面的声明式、高效且灵活的JavaScript库。-瑞安固体/固体</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="ob l ng nh ni ne nj kp mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a href="https://medium.com/better-programming/the-fastest-way-to-render-the-dom-e3b226b15ca3" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">呈现DOM的最快方法</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">虚拟DOM、带标签的模板文字还是细粒度的可观察对象速度最快？</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">medium.com</p></div></div><div class="ne l"><div class="oc l ng nh ni ne nj kp mv"/></div></div></a></div></div></div>    
</body>
</html>