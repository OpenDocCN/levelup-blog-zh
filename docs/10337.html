<html>
<head>
<title>Builder Design Pattern in .NET C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中的生成器设计模式。NET C#</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/builder-design-pattern-in-net-c-bbf11c891548?source=collection_archive---------1-----------------------#2021-11-24">https://levelup.gitconnected.com/builder-design-pattern-in-net-c-bbf11c891548?source=collection_archive---------1-----------------------#2021-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7459" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">设计模式</h2><div class=""/><div class=""><h2 id="5111" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">一步一步的指南，从零开始开发一个流畅的API。NET C#使用生成器设计模式。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/67a874e07b0ae2d5b9f00e54ce03d3e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J87HufKgAPiLRsmPxegUcA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://unsplash.com/@inkyhills?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卡勒姆希尔</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="9ad7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我相信这不是你第一次听说<strong class="lk jd"> Builder设计模式</strong>。然而，我向你保证，你会在这篇文章中发现一些不同的东西。</p><p id="4045" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将介绍使用<strong class="lk jd"> Builder设计模式</strong>开发一个<strong class="lk jd"> Fluent API </strong>的整个过程，从最初的思考到最近的测试。</p><p id="1369" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，系好安全带，让我们开始我们的旅程。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt ml"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jd gy z fp mq fr fs mr fu fw jc bi translated">订阅艾哈迈德的时事通讯？</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">medium.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz lb ml"/></div></div></a></div></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b7c6" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">什么是生成器设计模式？</h1><p id="7ece" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">这是一个<strong class="lk jd">创造性的设计模式</strong>，它允许将复杂的对象一个接一个地创建成简单的小步骤。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="41db" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">构建器设计模式的优点是什么？</h1><p id="ff84" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">生成器设计模式的一些众所周知的优点是:</p><ol class=""><li id="b4bb" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated">它有助于将创建复杂对象的过程分解成更易于控制的小块。</li><li id="af25" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">它支持使用终端用户可以使用的<strong class="lk jd">领域特定语言(DSL) </strong>。</li><li id="afd2" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">它有助于从我们正在构建的对象的一般定义转移到更具体的粒度定义。</li></ol></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="f909" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">构建器设计模式的缺点是什么？</h1><p id="1aed" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">大多数情况下，它给代码增加了额外的复杂性，您会在本文实现的结尾注意到这一点。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="ba3e" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">如何实现生成器设计模式？</h1><p id="67db" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">是的，这是我知道你感兴趣的问题。然而，这一次我们不会直接跳到代码实现。我们将从设计的早期阶段开始经历整个过程。</p><p id="db8a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们开始吧。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="c229" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">这个例子</h1><p id="2d9d" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">首先，让我们想出一个使用through或trip的例子。我选择了一个简单的学校注册过程的例子。</p><p id="9fdc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单来说，在整个解决方案的某个点上，你将需要定义一些老师和一些学生。让我们假设这些教师和学生对象非常复杂，我们需要开发一个流畅的API来创建它们。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/728f2d39f8b62bab15a247681b04376d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JWOukUlbbs3I273UzEUMhA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae lh" href="https://unsplash.com/@mikael_seegen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Mikael Seegen </a>拍照</figcaption></figure><h1 id="9b29" class="na nb it bd nc nd om nf ng nh on nj nk ki oo kj nm kl op km no ko oq kp nq nr bi translated">放弃</h1><ol class=""><li id="6228" class="nx ny it lk b ll ns lo nt lr or lv os lz ot md oc od oe of bi translated">一些最佳实践可能会被忽略/放弃，以便将主要焦点转移到本文中针对的其他最佳实践上。</li><li id="964a" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">本文中使用的示例仅用于演示目的。它不是应用生成器设计模式的最佳候选。</li><li id="c28e" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">我们可以将不同的实践与构建器设计模式集成在一起，比如使用泛型和其他东西，但是，为了使示例尽可能简单，所有这些都被放弃了。</li><li id="7918" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">在实现构建器设计模式的方式上存在合理的差异，因此，您可能会发现一些不同于我们在本文中使用的其他实现。</li><li id="9bad" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">尽量只在实际需要时使用构建器设计模式，因为它会增加整个解决方案的复杂性。</li></ol></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="f4a3" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">窥视未来</h1><p id="6a9c" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">如果您完全按照本文中的步骤操作，您应该会得到这样的解决方案结构:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/6459cd5f1e7ac8a6ab40da7dd155a116.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*m1L0U1XYy848D5Rutg4kSg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="c452" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以写一些像这样的代码:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/61f901f715b89344e964d25139623d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*Cmd4GcphfHTdnGr2SSAOyg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="be9d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有这个:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/f9077dc4a5036ae3a5ff8c47047f99a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*1kgAx-_OI8nptn1U3yX6dw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片来自<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a></figcaption></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="53d7" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">勾画流畅的API</h1><p id="090a" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">现在，我们将从我们的流畅API的草图开始。你可以在一张纸上，Excel表格上，或者任何你喜欢的草图工具上这样做。</p><p id="687c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，我们的草图应该是这样的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/d6b28c86e034095ab51dc99ed62e90a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lhnXZzRy5MBWVhSuMd7Ekg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><h2 id="8904" class="oy nb it bd nc oz pa dn ng pb pc dp nk lr pd pe nm lv pf pg no lz ph pi nq iz bi translated">注意事项:</h2><ol class=""><li id="7a08" class="nx ny it lk b ll ns lo nt lr or lv os lz ot md oc od oe of bi translated"><strong class="lk jd">构建器</strong>是主入口点。从那里我们将转移到新的。</li><li id="8da1" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">那么我们可以有两种选择；<strong class="lk jd">带姓名</strong>和<strong class="lk jd">带年龄</strong>。</li><li id="dc37" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">然而，下一步，如果你已经来自<strong class="lk jd">并有名字</strong>，我们只允许年龄的<strong class="lk jd">。按照同样的概念，如果你已经从<strong class="lk jd">来，年龄</strong>，我们只允许名字</strong>的<strong class="lk jd">。</strong></li><li id="54b2" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">那么我们将会合并到一个公共点。</li><li id="e33f" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">从这个共同点出发，我们有两个选择；<strong class="lk jd">作为教师</strong>和<strong class="lk jd">作为学生</strong>。</li><li id="bb98" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">从<strong class="lk jd">作为教师</strong>开始，流程将是<strong class="lk jd">教学(科目)</strong> &gt; &gt; <strong class="lk jd">带时间表(日程)</strong>。</li><li id="d3f4" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">从<strong class="lk jd">学生开始，</strong>流程将会是<strong class="lk jd">学习(科目)</strong> &gt; &gt; <strong class="lk jd">有时间表(stydingSchedule) </strong>。</li><li id="4a54" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">最后，它们都合并到<strong class="lk jd"> Build() </strong>命令中。</li></ol></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="a463" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">定义接口</h1><p id="8518" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">现在，让我们开始编写代码。</p><h2 id="ecf7" class="oy nb it bd nc oz pa dn ng pb pc dp nk lr pd pe nm lv pf pg no lz ph pi nq iz bi translated">步伐</h2><p id="bd14" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">打开VS或者你喜欢的IDE。</p><p id="aa48" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">创建新的类库或控制台应用程序。我将我的项目命名为<strong class="lk jd"> FluentApi </strong>。</p><p id="a6cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我的项目中，我创建了以下文件夹:</p><ol class=""><li id="df2f" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated">建设者</li><li id="c242" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">生成器\Dtos</li><li id="bd97" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">生成器\ Dtos \描述符</li><li id="4fd2" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">构建器\实现</li><li id="bb9b" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">构建器\接口</li></ol><p id="15ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在你需要记住一件重要的事情，我们在实现的时候需要在<strong class="lk jd">接口</strong>和<strong class="lk jd">dto</strong>之间来回跳转，这是正常的。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="9c51" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们从我们的第一个界面开始，<code class="fe pj pk pl pm b">IMemberBuilder</code>。这里有一个重要的窍门。我在<strong class="lk jd">接口</strong>文件夹下创建了一个文件，并将其命名为<strong class="lk jd"> 01。IMemberBuilder.cs </strong></p><p id="dcee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个<strong class="lk jd"> 01。</strong>开头的名字有助于我轻松跟踪整个过程的顺序。否则，对于一个小的更改，您可能需要浏览所有的文件来找出应用您的更改的位置。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="dcd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从<strong class="lk jd">草图</strong>中我们知道，我们的构建器应该公开一个<code class="fe pj pk pl pm b">New</code>属性，这个属性应该引导我们去公开两个方法；<code class="fe pj pk pl pm b">WithName(name)</code>和<code class="fe pj pk pl pm b">WithAge(age)</code>。</p><p id="c616" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，新的属性应该返回，比如说一个叫做<code class="fe pj pk pl pm b">IHuman</code>的新接口。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="c952" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">移动到下一步，让我们定义<code class="fe pj pk pl pm b">IHuman</code>接口。所以，创建一个<strong class="lk jd"> 02。IHuman.cs </strong>文件，定义接口如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="e099" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从<strong class="lk jd">草图</strong>中我们知道<code class="fe pj pk pl pm b">IHuman</code>接口应该有两个方法<code class="fe pj pk pl pm b">WithName(name)</code>和<code class="fe pj pk pl pm b">WithAge(age)</code>。但是，这两种方法应该有不同的返回类型。为什么？？？</p><p id="22fc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为我们希望一旦调用了<code class="fe pj pk pl pm b">WithName(name)</code>，唯一可用的选项是调用<code class="fe pj pk pl pm b">WithAge(age)</code>，而不是另一个<code class="fe pj pk pl pm b">WithName(name)</code>。这同样适用于<code class="fe pj pk pl pm b">WithAge(age)</code>。</p><p id="4721" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意</strong>:你可能也更喜欢只有一个方法，同时接受姓名和年龄，这也是对的，但我更喜欢抓住机会向你展示不同的选项。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="9b1f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">移动到下一步，让我们定义<code class="fe pj pk pl pm b">IHaveAgeAndCanHaveName</code>接口。所以，创造一个<strong class="lk jd"> 03。IHaveAgeAndCanHaveName.cs </strong>文件，定义接口如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="d22c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从<strong class="lk jd">草图</strong>中我们知道，<code class="fe pj pk pl pm b">IHaveAgeAndCanHaveName</code>接口应该有方法<code class="fe pj pk pl pm b">WithName(name)</code>。这个方法应该返回公开<code class="fe pj pk pl pm b">AsTeacher</code>和<code class="fe pj pk pl pm b">AsStudent</code>属性的东西。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="bb4d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，按照同样的方式，让我们定义<code class="fe pj pk pl pm b">IHaveNameAndCanHaveAge</code>接口。所以，打造一个<strong class="lk jd"> 03。ihavenamedcanhaveage . cs</strong>文件(注意该文件编号为<strong class="lk jd"> 03 </strong>，因为它还在整个流程的第三步)，定义接口如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="4980" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从<strong class="lk jd">草图</strong>中我们知道<code class="fe pj pk pl pm b">IHaveNameAndCanHaveAge</code>接口应该有方法<code class="fe pj pk pl pm b">WithAge(age)</code>。而且这个方法应该返回一些公开<code class="fe pj pk pl pm b">AsTeacher</code>和<code class="fe pj pk pl pm b">AsStudent</code>属性的东西，和<code class="fe pj pk pl pm b">IHaveAgeAndCanHaveName.WithName(name)</code>一样。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="f948" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">转到下一步，让我们定义<code class="fe pj pk pl pm b">IHasRole</code>接口。所以，创造一个<strong class="lk jd"> 04。IHasRole.cs </strong>文件，定义接口如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="43c3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从<strong class="lk jd">草图</strong>中我们知道<code class="fe pj pk pl pm b">IHasRole</code>接口应该有两个属性<code class="fe pj pk pl pm b">AsTeacher</code>和<code class="fe pj pk pl pm b">AsStudent</code>。根据草图上的以下步骤，这些属性中的每一个都应该返回不同的内容。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="2acd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">转到下一步，让我们定义<code class="fe pj pk pl pm b">IAmStudying</code>接口。所以，打造一个<strong class="lk jd"> 05。iam studining . cs</strong>文件，定义接口如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="20f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从<strong class="lk jd">草图</strong>中我们知道<code class="fe pj pk pl pm b">IAmStudying</code>接口应该有方法<code class="fe pj pk pl pm b">Studying(subjects)</code>。该方法应该期待一个类型为<code class="fe pj pk pl pm b">Subject</code>的数组输入。所以，我们需要定义类<code class="fe pj pk pl pm b">Subject</code>。</p><p id="ee50" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有，<code class="fe pj pk pl pm b">Studying(subjects)</code>应该返回揭露<code class="fe pj pk pl pm b">WithSchedule(subjectsSechedules)</code>的东西。</p><p id="681f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们在<strong class="lk jd"> Dtos </strong>文件夹中创建一个<strong class="lk jd"> Subject.cs </strong>文件，代码如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="463f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里要注意什么:</p><ol class=""><li id="07f6" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated">它只有一个<code class="fe pj pk pl pm b">Name</code>属性。</li><li id="5581" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">它是不可改变的。</li><li id="72aa" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">它继承了<code class="fe pj pk pl pm b">IEquatable&lt;Subject&gt;</code>接口，我们生成了所有需要的成员。</li><li id="7e79" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">我们定义了构造函数<code class="fe pj pk pl pm b">public Subject(Subject other)</code>来提供从另一个主题克隆主题的方法。构建器模式中的克隆功能非常重要，因为在每一步中，您都需要处理一个与上一步和下一步完全不同的对象(具有不同的引用)。</li><li id="8fa8" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">我们还定义了对<code class="fe pj pk pl pm b">IEnumerable&lt;Subject&gt;</code>的扩展方法<code class="fe pj pk pl pm b">Clone</code>，以避免在不同的地方重复相同的代码。</li><li id="a53d" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">在扩展方法中，我们使用了在<code class="fe pj pk pl pm b">Subject</code>类中定义的<code class="fe pj pk pl pm b">public Subject(Subject other)</code>构造函数。</li></ol></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="831e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">转到下一步，让我们定义<code class="fe pj pk pl pm b">IAmTeaching</code>接口。所以，打造一个<strong class="lk jd"> 05。IAmTeaching.cs </strong>文件，定义接口如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="4aa1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从<strong class="lk jd">草图</strong>中我们知道<code class="fe pj pk pl pm b">IAmTeaching</code>接口应该有方法<code class="fe pj pk pl pm b">Teaching(subject)</code>。这个方法应该期待一个类型为<code class="fe pj pk pl pm b">Subject</code>的输入。</p><p id="7574" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另外，<code class="fe pj pk pl pm b">Teaching(subject)</code>应该返回暴露<code class="fe pj pk pl pm b">WithSchedule(sechedules)</code>的内容。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="c716" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">转到下一步，让我们定义<code class="fe pj pk pl pm b">IHasStudyingSchedule</code>接口。所以，打造一个<strong class="lk jd"> 06。ihassstudyingschedule . cs</strong>文件，定义接口如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="e1d7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从<strong class="lk jd">草图</strong>中我们知道<code class="fe pj pk pl pm b">IHasStudyingSchedule</code>接口应该有方法<code class="fe pj pk pl pm b">WithSchedule(subjectsSchedules)</code>。该方法应该期待一个类型为<code class="fe pj pk pl pm b">SubjectSchedule</code>的数组输入。</p><p id="f50d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，<code class="fe pj pk pl pm b">WithSchedule(subjectsSchedules)</code>应该返回一些公开方法<code class="fe pj pk pl pm b">Build()</code>的内容。</p><p id="f77c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们在<strong class="lk jd"> Dtos </strong>文件夹中创建<strong class="lk jd"> Schedule.cs </strong>和<strong class="lk jd"> SubjectSchedule.cs </strong>文件，代码如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="5127" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们遵循与<code class="fe pj pk pl pm b">Subject</code>类中相同的规则。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="2e7b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">移动到下一步，让我们定义<code class="fe pj pk pl pm b">IHasTeachingSchedule</code>接口。所以，打造一个<strong class="lk jd"> 06。ihastagechingship . cs</strong>文件，定义接口如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="b2c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从<strong class="lk jd">草图</strong>中我们知道，<code class="fe pj pk pl pm b">IHasTeachingSchedule</code>接口应该有方法<code class="fe pj pk pl pm b">WithSchedule(schedules)</code>。这个方法应该期待一个<code class="fe pj pk pl pm b">SubjectSchedule</code>的数组类型的输入。</p><p id="facd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另外，<code class="fe pj pk pl pm b">WithSchedule(schedules)</code>应该返回一些公开方法<code class="fe pj pk pl pm b">Build()</code>的东西。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="5027" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">移动到下一步，让我们定义<code class="fe pj pk pl pm b">ICanBeBuilt</code>接口。所以，创建一个<strong class="lk jd"> 07。icanbebuild . cs</strong>文件，定义接口如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="0446" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从<strong class="lk jd">草图</strong>中我们知道，<code class="fe pj pk pl pm b">ICanBeBuilt</code>接口应该有方法<code class="fe pj pk pl pm b">Build()</code>，该方法返回最终组合的<code class="fe pj pk pl pm b">MemberDescriptor</code>。</p><p id="b2f6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们在<strong class="lk jd"> Dtos &gt; Descriptors </strong>文件夹中创建一个<strong class="lk jd"> SubjectSchedule.cs </strong>文件。</p><p id="945b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个<code class="fe pj pk pl pm b">MemberDescriptor</code>类要暴露一个成员的所有细节，不管他是<strong class="lk jd">老师</strong>还是<strong class="lk jd">学生</strong>。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="168a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">成员描述符</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="9156" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里要注意什么:</p><ol class=""><li id="1a36" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated"><code class="fe pj pk pl pm b">MemberDescriptor</code>类公开了一个成员的基本信息。关于<strong class="lk jd">老师</strong>或<strong class="lk jd">学生</strong>的更具体的信息将存在于<strong class="lk jd">老师</strong>和<strong class="lk jd">学生</strong>的另外两个类中。</li><li id="0375" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">这个类不是不可变的，这是因为在创建过程的每一步，你都会给对象增加一个小细节。所以，你不会一下子就知道所有的细节。然而，您仍然可以选择使它成为不可变的，但是您需要为每一步提供多个符合您需要的构造函数。</li><li id="3f0f" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">如前所述，我们仍然提供了用于克隆目的的<code class="fe pj pk pl pm b">public MemberDescriptor(MemberDescriptor other = null)</code>构造函数。</li><li id="9685" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">而且我们因为一个重要的原因增加了一个<code class="fe pj pk pl pm b">public virtual MemberDescriptor Clone()</code>方法。在流程的某些步骤中，您可能会从一个更具体的案例合并到一个更一般的案例。在这种情况下，您的接口实现需要处理父类<code class="fe pj pk pl pm b">MemberDescriptor</code>，而不是它的任何子类。并且，它需要克隆实体，而不知道它最初是一个<strong class="lk jd">教师</strong>或<strong class="lk jd">学生</strong>。</li></ol><p id="0d13" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，在这个合并步骤中</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/251a2b45c9370db3b655cb4ceb0c543f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_KUC5n7PpI2tHJ8RX9CgAw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a></figcaption></figure><p id="d84d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当实现<code class="fe pj pk pl pm b">ICanBeBuilt</code>接口时，它应该期待一个<code class="fe pj pk pl pm b">MemberDescriptor</code>的实例，它不能是一个<strong class="lk jd">老师</strong>或<strong class="lk jd">学生</strong>的特定描述符，因为它是两条路径的公共步骤。另外，你需要在最后克隆传入的<code class="fe pj pk pl pm b">MemberDescriptor</code>。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="eb64" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">教师描述符</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="af38" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里要注意什么:</p><ol class=""><li id="8b34" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated">在克隆构造函数中，我们需要检查空属性，因为如前所述，细节是在不止一个步骤中一点一点添加的。</li><li id="c5a8" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">我们也在使用<code class="fe pj pk pl pm b">IEnumerable&lt;Schedule&gt;</code>扩展方法进行克隆。</li><li id="9f29" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">我们定义了一个对<code class="fe pj pk pl pm b">Clone</code>方法的覆盖，现在我们正在使用我们特定类型的克隆构造函数。</li></ol></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="ca8c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">学生描述符</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="00a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">遵循与<code class="fe pj pk pl pm b">TeacherDescriptor</code>中相同的概念。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="26c9" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">接口实现</h1><p id="5567" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">现在，我们开始实现我们的接口。</p><p id="9aed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们定义实现<code class="fe pj pk pl pm b">IMemberBuilder </code>接口的<code class="fe pj pk pl pm b">MemberBuilder</code>类。所以，创建一个<strong class="lk jd"> 01。MemberBuilder.cs </strong>文件，并如下定义该类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="bbe4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe pj pk pl pm b">New</code>属性，应该返回一个<code class="fe pj pk pl pm b">IHuman</code>接口。所以，我们现在将实现<code class="fe pj pk pl pm b">IHuman</code>接口，但是我们需要记住一些重要的事情。我们需要继续传递部分完成的<code class="fe pj pk pl pm b">MemberDescriptor</code>,因为每一步都会添加一些细节，直到它最终完成。</p><p id="2379" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<code class="fe pj pk pl pm b">MemberBuilder</code>类上，我们没有任何要添加的细节，但是，这是我们的起点，所以该类应该创建初始的<code class="fe pj pk pl pm b">MemberDescriptor</code>来开始，然后将它传递给下一步。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="4c8d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">继续定义实现<code class="fe pj pk pl pm b">IHuman</code>接口的<code class="fe pj pk pl pm b">Human</code> <strong class="lk jd"> </strong>类。所以，创建一个<strong class="lk jd"> 02。Human.cs </strong>文件，并如下定义该类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="3678" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们定义了一个构造函数，它接受一个<code class="fe pj pk pl pm b">MemberDescriptor</code>并将它保存到一个本地只读变量中。</p><p id="3aa2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们也实现了这两个方法，但是这里需要注意的是，在向<code class="fe pj pk pl pm b">MemberDescriptor</code>添加任何细节之前，我们首先创建了它的一个克隆。要创建一个克隆，我们可以使用克隆构造函数或者调用<code class="fe pj pk pl pm b">MemberDescriptor</code>类上的<code class="fe pj pk pl pm b">Clone</code>方法。</p><p id="1fe4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每个方法都会返回不同的接口，所以现在我们需要实现这些接口。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="2806" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">继续定义实现<code class="fe pj pk pl pm b">IHaveAgeAndCanHaveName</code>接口的<code class="fe pj pk pl pm b">HaveAgeAndCanHaveName</code> <strong class="lk jd"> </strong>类。所以，创建一个<strong class="lk jd"> 03。HaveAgeAndCanHaveName.cs </strong>文件，并如下定义该类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="3099" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">遵循同样的模式，我们创建了构造函数，实现了方法，创建了克隆，添加了细节，将克隆中传递的新对象返回给构造函数。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="89c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">继续定义实现<code class="fe pj pk pl pm b">IHaveNameAndCanHaveAge</code>接口的<code class="fe pj pk pl pm b">HaveNameAndCanHaveAge</code> <strong class="lk jd"> </strong>类。所以，打造一个<strong class="lk jd"> 03。HaveNameAndCanHaveAge.cs </strong>文件，并如下定义该类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="fae7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">遵循同样的模式，我们创建了构造函数，实现了方法，创建了克隆，添加了细节，将克隆中传递的新对象返回给构造函数。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="d3d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">继续定义实现<code class="fe pj pk pl pm b">IHasRole</code>接口的<code class="fe pj pk pl pm b">HasRole</code>类。所以，打造一个<strong class="lk jd"> 04。HasRole.cs </strong>文件，并将该类定义如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="13e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">遵循同样的模式，我们创建了构造函数，实现了方法，创建了克隆，添加了细节，将克隆中传递的新对象返回给构造函数。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="4181" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">继续定义实现<code class="fe pj pk pl pm b">IAmStudying</code>接口的<code class="fe pj pk pl pm b">AmStudying</code>类。所以，打造一个<strong class="lk jd"> 05。am studining . cs</strong>文件，并将该类定义如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="5f0d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">遵循同样的模式，我们创建了构造函数，实现了方法，创建了克隆，添加了细节，将克隆中传递的新对象返回给构造函数。</p><p id="da87" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里要注意的是，构造函数期望的是一个<code class="fe pj pk pl pm b">StudentDescriptor</code>而不是一个<code class="fe pj pk pl pm b">MemberDescriptor</code>，这是因为在构造<code class="fe pj pk pl pm b">AmStudying</code>的时候就很清楚了。</p><p id="da4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另外，请注意，我们甚至使用之前创建的扩展方法克隆了传入的数组<code class="fe pj pk pl pm b">Subject</code>。通过这种方式，我们可以确保最终用户对传入的数组<code class="fe pj pk pl pm b">Subject</code>所做的任何更改都不会影响我们的构建器状态。</p><p id="9d3e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果出于某种原因，这不是您想要做的，那么您可以通过按原样传入传入的数组来更改这段代码。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="ee80" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">继续定义实现<code class="fe pj pk pl pm b">IAmTeaching</code>接口的<code class="fe pj pk pl pm b">AmTeaching</code>类。所以，打造一个<strong class="lk jd"> 05。AmTeaching.cs </strong>文件，并将类定义如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="e311" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">遵循同样的模式，我们创建了构造函数，实现了方法，创建了克隆，添加了细节，将克隆中传递的新对象返回给构造函数。</p><p id="17ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里要注意的是，构造函数期望的是一个<code class="fe pj pk pl pm b">TeacherDescriptor</code>而不是一个<code class="fe pj pk pl pm b">MemberDescriptor</code>,这是因为在构造<code class="fe pj pk pl pm b">AmTeaching</code>的时候就很清楚了。</p><p id="5d7d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，这里我们传递的不是最终用户传入的那个<code class="fe pj pk pl pm b">Subject</code>，而是一个克隆。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="b344" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">继续定义实现<code class="fe pj pk pl pm b">IHasStudyingSchedule</code>接口的<code class="fe pj pk pl pm b">HasStudyingSchedule</code>类。所以，创建一个<strong class="lk jd"> 06。HasStudyingSchedule.cs </strong>文件，并将该类定义如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="f783" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">遵循同样的模式，我们创建了构造函数，实现了方法，创建了克隆，添加了细节，将克隆中传递的新对象返回给构造函数。</p><p id="e3c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里要注意的是，我们添加了一些断言来检查是否有一些已注册的主题没有被调度，或者有一些已调度的主题没有被注册。这只是一个例子，当然你也可以在任何需要的时候在每一步中添加所有的业务规则。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="aac1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">继续定义实现<code class="fe pj pk pl pm b">IHasTeachingSchedule</code>接口的<code class="fe pj pk pl pm b">HasTeachingSchedule</code>类。所以，创建一个<strong class="lk jd"> 06。HasTeachingSchedule.cs </strong>文件，并如下定义该类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="b081" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">遵循同样的模式，我们创建了构造函数，实现了方法，创建了克隆，添加了细节，将克隆中传递的新对象返回给构造函数。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="ce6d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">继续定义实现<code class="fe pj pk pl pm b">ICanBeBuilt</code>接口的<code class="fe pj pk pl pm b">CanBeBuilt</code>类。所以，创建一个<strong class="lk jd"> 07。canbe build . cs</strong>文件，并如下定义该类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="0c3e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">遵循同样的模式，我们创建了构造函数，实现了方法，创建了克隆，添加了细节，将克隆中传递的新对象返回给构造函数。</p><p id="b306" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里要注意的是，构造函数期望一个<code class="fe pj pk pl pm b">MemberDescriptor</code>，因为此时传入的<code class="fe pj pk pl pm b">MemberDescriptor</code>可能是一个<code class="fe pj pk pl pm b">TeacherDescriptor</code>或一个<code class="fe pj pk pl pm b">StudentDescriptor</code>。</p><p id="3338" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，在<code class="fe pj pk pl pm b">Build</code>方法中，我们返回描述符的克隆，但是这次我们不能使用克隆构造函数，就好像你使用<code class="fe pj pk pl pm b">MemberDescriptor</code>类的克隆构造函数一样，你最终会返回一个<code class="fe pj pk pl pm b">MemberDescriptor</code>的实例，既不是<code class="fe pj pk pl pm b">TeacherDescriptor</code>也不是<code class="fe pj pk pl pm b">StudentDescriptor</code>，这是不对的。相反，我们使用在运行时返回正确实例的<code class="fe pj pk pl pm b">Clone</code>方法。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="8baf" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">测试时间</h1><p id="2909" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">现在，通过一个简单的控制台应用程序，我们可以尝试运行以下代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn po l"/></div></figure><p id="cc1e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你会注意到:</p><ol class=""><li id="267e" class="nx ny it lk b ll lm lo lp lr nz lv oa lz ob md oc od oe of bi translated">我们流畅的API工作正常。</li><li id="9960" class="nx ny it lk b ll og lo oh lr oi lv oj lz ok md oc od oe of bi translated">对于这个例子，您可能会发现为这样简单的对象创建一个流畅的API有点大材小用，但是，我们使用这个简单的例子只是为了演示。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pq"><img src="../Images/a5a9227f7b98c6c7ae270ef7106932f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ykfzQ9f933sfAS10_QhocQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@rayhennessy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">雷·轩尼诗</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="62fe" class="na nb it bd nc nd om nf ng nh on nj nk ki oo kj nm kl op km no ko oq kp nq nr bi translated">最后的话</h1><p id="1cdf" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">构建器设计模式有一些优点，但也增加了复杂性。因此，您只需要在实际需要时使用它。</p><p id="a382" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就这样，希望你觉得读这个故事和我写它一样有趣。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="7a82" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="cec8" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">如果您还不是<strong class="lk jd">中</strong>会员，您可以使用<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="lk jd">我的推荐链接</strong> </a>，这样我就可以从<strong class="lk jd">中</strong>获得您的一部分费用，您无需支付任何额外费用。订阅<a class="ae lh" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"> <strong class="lk jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他有趣的东西直接发送到您的收件箱。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="ff93" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">其他资源</h1><p id="98c3" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">这些是你可能会发现有用的其他资源。</p><div class="pr ps gp gr pt ml"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-fully-cover-i-o-file-based-applications-in-net-c-with-unit-tests-ca75c07f3b2c"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jd gy z fp mq fr fs mr fu fw jc bi translated">如何在中全面介绍基于I/O文件的应用程序。带有单元测试的. NET C#</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">学习如何将应用程序划分成更小的模块，这样你就可以100%覆盖这些模块</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mu l"><div class="pu l mw mx my mu mz lb ml"/></div></div></a></div><div class="pr ps gp gr pt ml"><a href="https://itnext.io/when-string-gethashcode-in-net-c-drives-you-crazy-c97ac7507d7b" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jd gy z fp mq fr fs mr fu fw jc bi translated">当字符串。中的GetHashCode()。NET C#让你抓狂</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">知道什么时候依赖字符串。中的GetHashCode()。NET C#，而当不是。</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">itnext.io</p></div></div><div class="mu l"><div class="pv l mw mx my mu mz lb ml"/></div></div></a></div></div></div>    
</body>
</html>