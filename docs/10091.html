<html>
<head>
<title>Covariance and Contravariance in .NET C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中的协方差和逆变。NET C#</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/covariance-and-contravariance-in-net-c-c2b8576b2155?source=collection_archive---------0-----------------------#2021-10-26">https://levelup.gitconnected.com/covariance-and-contravariance-in-net-c-c2b8576b2155?source=collection_archive---------0-----------------------#2021-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1fcf" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">回归基础</h2><div class=""/><div class=""><h2 id="55d8" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">很难理解吗？让我为你简化它。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/6d9513d16f99ceb9b0a25de9a974c5c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhsJIOo3n2zjo-N4x3ufpA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@wocintechchat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Christina@wocintechchat.com</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="3d33" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你很难理解<strong class="lk jd">中的<strong class="lk jd">协变</strong>和<strong class="lk jd">逆变</strong>是什么。NET C# </strong>的意思是，不要为此感到羞耻，你不是一个人。</p><p id="508b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这发生在我和许多其他开发人员身上。我甚至认识一些有经验的开发人员，他们要么不知道它们，正在使用它们，但仍然不能很好地理解它们。</p><p id="0633" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我看来，这种情况正在发生，因为每次我看到一篇谈论<strong class="lk jd">协方差</strong>和<strong class="lk jd">逆变</strong>的文章，我都发现它专注于一些技术术语，而不是关心我们最初为什么会有它们以及如果它们不存在我们会错过什么。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt ml"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jd gy z fp mq fr fs mr fu fw jc bi translated">订阅艾哈迈德的时事通讯？</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">medium.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz lb ml"/></div></div></a></div></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi na"><img src="../Images/ec1ccc44db5d360cada8320dea4b4dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gbCmQ3j0RAcWW0aa.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@olga_o?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Olga Thelavart </a>在<a class="ae lh" href="https://unsplash.com/s/photos/note?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>修改</figcaption></figure><h2 id="ddb8" class="nb nc it bd nd ne nf dn ng nh ni dp nj lr nk nl nm lv nn no np lz nq nr ns iz bi">2021–11–04</h2><blockquote class="nt nu nv"><p id="4b95" class="li lj nw lk b ll lm kd ln lo lp kg lq nx ls lt lu ny lw lx ly nz ma mb mc md im bi translated">我注意到理解<strong class="lk jd">不变性</strong>、<strong class="lk jd">协变性</strong>和<strong class="lk jd">逆变性</strong>将有助于你理解其他主题并做出正确的设计决策。你可以在我的故事<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/a-best-practice-for-designing-interfaces-in-net-c-2c6ebdb4f1c1?sk=1f07b674adf763b7567d652ddd9f4a43"> <strong class="lk jd">中了解更多。NET c#；定义imi interface&lt;T&gt;够了吗？我也需要IMyInterface吗？</strong>T29】</a></p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/8fd6c8d84ef5ffac2d524d5bb3a9aa06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09u_9YpDdTA_SyZHFQYMaQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@stadsa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">塔达斯·萨</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="f41a" class="ob nc it bd nd oc od oe ng of og oh nj ki oi kj nm kl oj km np ko ok kp ns ol bi translated">微软的定义</h1><p id="a9f8" class="pw-post-body-paragraph li lj it lk b ll om kd ln lo on kg lq lr oo lt lu lv op lx ly lz oq mb mc md im bi translated">如果你查看<a class="ae lh" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/covariance-contravariance/" rel="noopener ugc nofollow" target="_blank">微软的文档</a>中<strong class="lk jd">中的<strong class="lk jd">协方差</strong>和<strong class="lk jd">方差</strong>。NET C# </strong>，你会发现这个定义:</p><blockquote class="nt nu nv"><p id="c31a" class="li lj nw lk b ll lm kd ln lo lp kg lq nx ls lt lu ny lw lx ly nz ma mb mc md im bi translated">在C#中，协变和逆变支持数组类型、委托类型和泛型类型参数的隐式引用转换。协方差保持赋值兼容性，逆变则相反。</p></blockquote><p id="9822" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你明白了吗？你喜欢吗？</p><p id="8efe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在网上搜索，你会找到大量关于这个话题的资源。你会遇到定义，历史，当介绍时，代码样本，…和许多其他的，这不是你在这个故事中会发现的。我向你保证，你在这里看到的是不同的…</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/3efb87c2404ec929df4c77283444822c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwMyZMxmrJFFAVwP6fBpZQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@rhyskentish?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">里斯·肯特什</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="3a1e" class="ob nc it bd nd oc od oe ng of og oh nj ki oi kj nm kl oj km np ko ok kp ns ol bi translated">它们实际上是什么？</h1><p id="fc21" class="pw-post-body-paragraph li lj it lk b ll om kd ln lo on kg lq lr oo lt lu lv op lx ly lz oq mb mc md im bi translated">基本上，微软所做的是在你定义通用模板类型占位符的方式上添加了一个小的附加物，著名的<em class="nw"> &lt; T &gt; </em>。</p><p id="7639" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在定义一个通用接口时，你通常会遵循模式<code class="fe os ot ou ov b">public interface IMyInterface&lt;T&gt; {…}</code>。引入协方差和逆变后，现在可以遵循模式<code class="fe os ot ou ov b">public interface IMyInterface&lt;<strong class="lk jd">out</strong> T&gt; {…}</code>或<code class="fe os ot ou ov b">public interface IMyInterface&lt;<strong class="lk jd">in</strong> T&gt; {…}</code>。</p><p id="d113" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">多出来的<code class="fe os ot ou ov b"><strong class="lk jd">out</strong></code>和<code class="fe os ot ou ov b"><strong class="lk jd">in</strong></code> <strong class="lk jd"> </strong>你认得出来吗？你在别的地方见过他们吗？<br/>可能是靠这个出名的。网<code class="fe os ot ou ov b">public interface IEnumerable&lt;<strong class="lk jd">out</strong> T&gt;</code>？<br/>还是著名的。网<code class="fe os ot ou ov b">public interface IComparable&lt;<strong class="lk jd">in</strong> T&gt;</code>？</p><p id="500f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">微软引入了一个新概念，以便编译器在设计时确保您使用和传递给泛型成员的对象类型不会引发由错误的类型预期导致的运行时异常。</p><p id="f3d9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还是不清楚吧？请容忍我...让我们假设编译器没有应用任何设计时限制，看看会发生什么。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ow"><img src="../Images/e4a80d52a2fbef0c9539f94d10101176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQ9Uk-RgSLzXhgXABBK2tA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">里克·蒙泰罗在Unsplash上的照片</figcaption></figure><h1 id="dd26" class="ob nc it bd nd oc od oe ng of og oh nj ki oi kj nm kl oj km np ko ok kp ns ol bi translated">如果编译器不应用任何设计时限制会怎样？</h1><p id="9b5a" class="pw-post-body-paragraph li lj it lk b ll om kd ln lo on kg lq lr oo lt lu lv op lx ly lz oq mb mc md im bi translated">为了能够处理适当的示例，让我们定义以下内容:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="b190" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">查看上面的代码，您会注意到:</p><ol class=""><li id="712c" class="oz pa it lk b ll lm lo lp lr pb lv pc lz pd md pe pf pg ph bi translated">A类定义了<code class="fe os ot ou ov b">F1()</code>。</li><li id="7abd" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">B类定义了<code class="fe os ot ou ov b">F1()</code>和<code class="fe os ot ou ov b">F2()</code>。</li><li id="9022" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">C类定义了<code class="fe os ot ou ov b">F1()</code>、<code class="fe os ot ou ov b">F2()</code>和<code class="fe os ot ou ov b">F3()</code>。</li><li id="56f1" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">接口<code class="fe os ot ou ov b">IReaderWriter</code>有<code class="fe os ot ou ov b">Read()</code>和<code class="fe os ot ou ov b">Write(TEntity entity)</code>，前者返回一个类型为<code class="fe os ot ou ov b">TEntity</code>的对象，后者需要一个类型为<code class="fe os ot ou ov b">TEntity</code>的参数。</li></ol><p id="dac9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么让我们定义一个<code class="fe os ot ou ov b">TestReadWriter()</code>方法如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ox oy l"/></div></figure><h2 id="51ab" class="nb nc it bd nd ne nf dn ng nh ni dp nj lr nk nl nm lv nn no np lz nq nr ns iz bi translated">传入<code class="fe os ot ou ov b">IReaderWriter&lt;B&gt;</code>的实例时调用<code class="fe os ot ou ov b">TestReadWriter()</code></h2><p id="fbea" class="pw-post-body-paragraph li lj it lk b ll om kd ln lo on kg lq lr oo lt lu lv op lx ly lz oq mb mc md im bi translated">这应该没问题，因为我们没有违反任何规则。<code class="fe os ot ou ov b">TestReadWriter()</code>已经需要类型为<code class="fe os ot ou ov b">IReaderWriter&lt;B&gt;</code>的参数。</p><h2 id="2a28" class="nb nc it bd nd ne nf dn ng nh ni dp nj lr nk nl nm lv nn no np lz nq nr ns iz bi translated">传入<code class="fe os ot ou ov b">IReaderWriter&lt;A&gt;</code>的实例时调用<code class="fe os ot ou ov b">TestReadWriter()</code></h2><p id="f251" class="pw-post-body-paragraph li lj it lk b ll om kd ln lo on kg lq lr oo lt lu lv op lx ly lz oq mb mc md im bi translated"><em class="nw">记住编译器不应用任何设计时间限制的假设</em>，这意味着:</p><ol class=""><li id="51e9" class="oz pa it lk b ll lm lo lp lr pb lv pc lz pd md pe pf pg ph bi translated"><code class="fe os ot ou ov b">param.Read()</code>将返回类<strong class="lk jd"> A </strong>，<strong class="lk jd">B</strong><br/><strong class="lk jd">=&gt;</strong>的一个实例，因此，<code class="fe os ot ou ov b">var b</code>实际上将是类型<strong class="lk jd"> A </strong>，<strong class="lk jd">B</strong><br/><strong class="lk jd">=&gt;</strong>这将导致<code class="fe os ot ou ov b">b.F2()</code>行以<strong class="lk jd">失败</strong>作为<code class="fe os ot ou ov b">var b</code>——这实际上是类型<strong class="lk jd">A</strong></li><li id="2b71" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">上面代码中的<code class="fe os ot ou ov b">param.Write()</code>行将期望接收类型为<strong class="lk jd"> A </strong>的参数，而不是<strong class="lk jd"> B </strong> <br/> = &gt;因此，在传入类型为<strong class="lk jd"> B </strong>的参数时调用<code class="fe os ot ou ov b">param.Write()</code>将会使两个<strong class="lk jd">都工作正常</strong></li></ol><p id="696e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，既然在点<strong class="lk jd"> #1 </strong>中我们预期运行时失败，那么我们不能通过传入<code class="fe os ot ou ov b">IReaderWriter&lt;A&gt;</code>的实例来调用<code class="fe os ot ou ov b">TestReadWriter()</code>。</p><h2 id="848b" class="nb nc it bd nd ne nf dn ng nh ni dp nj lr nk nl nm lv nn no np lz nq nr ns iz bi translated">传入<code class="fe os ot ou ov b">IReaderWriter&lt;C&gt;</code>的实例时调用<code class="fe os ot ou ov b">TestReadWriter()</code></h2><p id="5483" class="pw-post-body-paragraph li lj it lk b ll om kd ln lo on kg lq lr oo lt lu lv op lx ly lz oq mb mc md im bi translated"><em class="nw">记住编译器不应用任何设计时间限制的假设</em>，这意味着:</p><ol class=""><li id="4d56" class="oz pa it lk b ll lm lo lp lr pb lv pc lz pd md pe pf pg ph bi translated"><code class="fe os ot ou ov b">param.Read()</code>将返回类<strong class="lk jd"> C </strong>的实例，而不是<strong class="lk jd"> B </strong> <br/> <strong class="lk jd"> = &gt; </strong>因此，<code class="fe os ot ou ov b">var b</code>实际上将是类型<strong class="lk jd"> C </strong>，而不是<strong class="lk jd"> B </strong> <br/> <strong class="lk jd"> = &gt; </strong>这将导致<code class="fe os ot ou ov b">b.F2()</code>行到<strong class="lk jd">工作正常</strong>，因为<code class="fe os ot ou ov b">var b</code>将有<code class="fe os ot ou ov b">F2()</code></li><li id="6d6f" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">上面代码中的<code class="fe os ot ou ov b">param.Write()</code>行将期望接收类型为<strong class="lk jd"> C </strong>的参数，而不是<strong class="lk jd"> B </strong> <br/> = &gt;的参数。因此，在传入类型为<strong class="lk jd"> B </strong>的参数时调用<code class="fe os ot ou ov b">param.Write()</code>会导致<strong class="lk jd">失败</strong>，因为您无法用父<strong class="lk jd"> B </strong>替换<strong class="lk jd"> C </strong></li></ol><p id="109a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，既然在点<strong class="lk jd"> #2 </strong>中我们预期运行时失败，那么我们不能通过传入<code class="fe os ot ou ov b">IReaderWriter&lt;C&gt;</code>的实例来调用<code class="fe os ot ou ov b">TestReadWriter()</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/c4709ecb92a63cf32cd3381344fa62fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HxHoLEPKokFwd0_NMVnXUQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">马库斯·温克勒在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3835" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们分析一下到目前为止我们发现了什么:</p><ol class=""><li id="0215" class="oz pa it lk b ll lm lo lp lr pb lv pc lz pd md pe pf pg ph bi translated">当传入一个<code class="fe os ot ou ov b">IReaderWriter&lt;B&gt;</code>的实例时调用<code class="fe os ot ou ov b">TestReadWriter(IReaderWriter&lt;B&gt; param)</code>总是没问题的。</li><li id="714a" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">如果我们没有<code class="fe os ot ou ov b">param.Read()</code>调用，那么在传入<code class="fe os ot ou ov b">IReaderWriter&lt;A&gt;</code>的实例时调用<code class="fe os ot ou ov b">TestReadWriter(IReaderWriter&lt;B&gt; param)</code>就可以了。</li><li id="9be6" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">如果我们没有<code class="fe os ot ou ov b">param.Write()</code>调用，那么在传入<code class="fe os ot ou ov b">IReaderWriter&lt;C&gt;</code>的实例时调用<code class="fe os ot ou ov b">TestReadWriter(IReaderWriter&lt;B&gt; param)</code>就可以了。</li><li id="3430" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">然而，由于我们总是在<code class="fe os ot ou ov b">param.Read()</code>和<code class="fe os ot ou ov b">param.Write()</code>之间混合使用，我们将总是坚持调用<code class="fe os ot ou ov b">TestReadWriter(IReaderWriter&lt;B&gt; param)</code>并传入<code class="fe os ot ou ov b">IReaderWriter&lt;B&gt;</code>的实例，除此之外别无其他。</li><li id="78fd" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">除非……</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/489efd7e4fd8979c252556433e9983fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIalJUmZN88XP3ZQZXBCBw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@halacious?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">哈尔·盖特伍德</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="0b60" class="ob nc it bd nd oc od oe ng of og oh nj ki oi kj nm kl oj km np ko ok kp ns ol bi translated">替代方案</h1><p id="8db9" class="pw-post-body-paragraph li lj it lk b ll om kd ln lo on kg lq lr oo lt lu lv op lx ly lz oq mb mc md im bi translated">如果我们确保<code class="fe os ot ou ov b">IReaderWriter&lt;TEntity&gt;</code>接口定义了<code class="fe os ot ou ov b">TEntity Read()</code>或<code class="fe os ot ou ov b">void Write(TEntity entity)</code>，而不是同时定义了两者，那会怎么样？</p><p id="c04a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，如果我们删除<code class="fe os ot ou ov b">TEntity Read()</code>，我们将能够通过传入<code class="fe os ot ou ov b">IReaderWriter&lt;A&gt;</code>或<code class="fe os ot ou ov b">IReaderWriter&lt;B&gt;</code>的实例来调用<code class="fe os ot ou ov b">TestReadWriter(IReaderWriter&lt;B&gt; param)</code>。</p><p id="8400" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">类似地，如果我们删除<code class="fe os ot ou ov b">void Write(TEntity entity)</code>，我们将能够通过传入<code class="fe os ot ou ov b">IReaderWriter&lt;B&gt;</code>或<code class="fe os ot ou ov b">IReaderWriter&lt;C&gt;</code>的实例来调用<code class="fe os ot ou ov b">TestReadWriter(IReaderWriter&lt;B&gt; param)</code>。</p><p id="f5fe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这对我们更好，因为限制更少，对吗？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pp"><img src="../Images/38ceb38c5357f6acd3248bd895074755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1N2ihMRmi_XX4st_Mz2xw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@olloweb?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">通讯社跟随</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="4fa1" class="ob nc it bd nd oc od oe ng of og oh nj ki oi kj nm kl oj km np ko ok kp ns ol bi translated">是时候了解一些事实了</h1><ol class=""><li id="0222" class="oz pa it lk b ll om lo on lr pq lv pr lz ps md pe pf pg ph bi translated">在现实世界中，编译器——在设计时——永远不会允许通过传入<code class="fe os ot ou ov b">IReaderWriter&lt;A&gt;</code>的实例来调用<code class="fe os ot ou ov b">TestReadWriter(IReaderWriter&lt;B&gt; param)</code>。您将得到一个编译错误。</li><li id="6dbc" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">此外，编译器在设计时不允许通过传入<code class="fe os ot ou ov b">IReaderWriter&lt;C&gt;</code>的实例来调用<code class="fe os ot ou ov b">TestReadWriter(IReaderWriter&lt;B&gt; param)</code>。您将得到一个编译错误。</li><li id="ecff" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">从点#1和点#2，这被称为<strong class="lk jd">不变性</strong>。</li><li id="0f02" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">即使您从<code class="fe os ot ou ov b">IReaderWriter&lt;TEntity&gt;</code>接口中删除了<code class="fe os ot ou ov b">TEntity Read()</code>，编译器在设计时也不会允许您通过传入<code class="fe os ot ou ov b">IReaderWriter&lt;A&gt;</code>的实例来调用<code class="fe os ot ou ov b">TestReadWriter(IReaderWriter&lt;B&gt; param)</code>。您将得到一个编译错误。这是因为编译器不会——自己隐式地——查看定义在接口中的成员，看看它是否会一直在运行时工作。您需要通过<code class="fe os ot ou ov b">&lt;<strong class="lk jd">in</strong> TEntity&gt;</code>自己完成这项工作。这相当于你对编译器的承诺，接口中的所有成员要么不依赖于<code class="fe os ot ou ov b">TEntity</code>，要么把它作为<strong class="lk jd">输入</strong>，<strong class="lk jd">而不是输出</strong>。这叫做<strong class="lk jd">逆变</strong>。</li><li id="c1e8" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">类似地，即使您从<code class="fe os ot ou ov b">IReaderWriter&lt;TEntity&gt;</code>接口中删除了<code class="fe os ot ou ov b">void Write(TEntity entity)</code>，编译器在设计时也不会允许您通过传入<code class="fe os ot ou ov b">IReaderWriter&lt;C&gt;</code>的实例来调用<code class="fe os ot ou ov b">TestReadWriter(IReaderWriter&lt;B&gt; param)</code>。您将得到一个编译错误。这是因为编译器不会——自己隐式地——查看定义在接口中的成员，看看它是否会一直在运行时工作。您需要通过<code class="fe os ot ou ov b">&lt;<strong class="lk jd">out</strong> TEntity&gt;</code>自己完成这项工作。这相当于你对编译器的承诺，接口中的所有成员要么不依赖于<code class="fe os ot ou ov b">TEntity</code>，要么把它作为<strong class="lk jd">输出</strong>，<strong class="lk jd">而不是输入</strong>。这叫做<strong class="lk jd">协方差</strong>。</li><li id="c98e" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">因此，添加<code class="fe os ot ou ov b">&lt;<strong class="lk jd">out </strong>&gt;</code>或<code class="fe os ot ou ov b">&lt;<strong class="lk jd">in</strong> &gt;</code>使得编译器在满足我们的需求时限制更少，而不是像一些开发人员认为的那样限制更多。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/f00871c34b6b30b8f06944cdec399f99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CBrnK4hi6OItpSE6CWctzA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://pixabay.com/users/harishs-3407954/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3245793" rel="noopener ugc nofollow" target="_blank">哈里什·夏尔马</a>提供，来自<a class="ae lh" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3245793" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><h1 id="d6f7" class="ob nc it bd nd oc od oe ng of og oh nj ki oi kj nm kl oj km np ko ok kp ns ol bi translated">摘要</h1><p id="798e" class="pw-post-body-paragraph li lj it lk b ll om kd ln lo on kg lq lr oo lt lu lv op lx ly lz oq mb mc md im bi translated">至此，你应该已经明白了<strong class="lk jd">不变性</strong>、<strong class="lk jd">协变性</strong>和<strong class="lk jd">逆变性</strong>的全部故事。但是，快速回顾一下，您可以将以下内容作为<strong class="lk jd">备忘单</strong>:</p><ol class=""><li id="e6b2" class="oz pa it lk b ll lm lo lp lr pb lv pc lz pd md pe pf pg ph bi translated">输入和输出之间混合泛型类型= &gt;不变性= &gt;最严格= &gt;不能用父或子替换。</li><li id="88d3" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">增加了<code class="fe os ot ou ov b">&lt;<strong class="lk jd">in</strong> &gt;</code> = &gt;只需<strong class="lk jd">输入</strong> = &gt; <strong class="lk jd">逆变</strong> = &gt; <strong class="lk jd">本身或替换为父母</strong>。</li><li id="1c2d" class="oz pa it lk b ll pi lo pj lr pk lv pl lz pm md pe pf pg ph bi translated">增加了<code class="fe os ot ou ov b">&lt;<strong class="lk jd">out</strong> &gt;</code> = &gt;仅<strong class="lk jd">输出</strong> = &gt; <strong class="lk jd">协方差</strong> = &gt; <strong class="lk jd">本身或替换为子</strong>。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://medium.com/@eng_ahmed.tarek"><div class="gh gi pu"><img src="../Images/4c6839e239d5355073195b6d74e60117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85tBjg8Kkt-54vhvVr8tNQ.png"/></div></a><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="621a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，在后来的故事中，我注意到理解<strong class="lk jd">不变性</strong>、<strong class="lk jd">协方差</strong>和<strong class="lk jd">逆变</strong>将有助于你理解其他主题并做出正确的设计决策。你可以在我的故事<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/a-best-practice-for-designing-interfaces-in-net-c-2c6ebdb4f1c1?sk=1f07b674adf763b7567d652ddd9f4a43"> <strong class="lk jd">中了解更多。NET c#；定义imi interface&lt;T&gt;够了吗？我也需要IMyInterface吗？</strong> </a></p><div class="pv pw gp gr px ml"><a rel="noopener  ugc nofollow" target="_blank" href="/a-best-practice-for-designing-interfaces-in-net-c-2c6ebdb4f1c1"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jd gy z fp mq fr fs mr fu fw jc bi translated">中设计界面的最佳实践。NET C#</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">定义imi interface<t>够了吗？我也需要IMyInterface吗？</t></h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mu l"><div class="py l mw mx my mu mz lb ml"/></div></div></a></div><p id="ebe9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我会在这里放一些代码供您检查。这会帮助你多练习。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="a8da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就这样，希望你觉得读这篇文章和我写这篇文章一样有趣。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="01fc" class="ob nc it bd nd oc pz oe ng of qa oh nj ki qb kj nm kl qc km np ko qd kp ns ol bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="4238" class="pw-post-body-paragraph li lj it lk b ll om kd ln lo on kg lq lr oo lt lu lv op lx ly lz oq mb mc md im bi translated">如果您还不是<strong class="lk jd">中型</strong>会员，您可以使用<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="lk jd">我的推荐链接</strong> </a>，这样我就可以从<strong class="lk jd">中型</strong>中获得您的一部分费用，您无需支付任何额外费用。订阅<br/><a class="ae lh" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"><strong class="lk jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他很酷的东西直接发送到您的收件箱。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="97c1" class="ob nc it bd nd oc pz oe ng of qa oh nj ki qb kj nm kl qc km np ko qd kp ns ol bi translated">资源</h1><p id="56f3" class="pw-post-body-paragraph li lj it lk b ll om kd ln lo on kg lq lr oo lt lu lv op lx ly lz oq mb mc md im bi translated">这些资源可能对你有用。</p><div class="pv pw gp gr px ml"><a href="https://betterprogramming.pub/when-not-to-use-di-ioc-and-ioc-containers-f95881d0fe0" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jd gy z fp mq fr fs mr fu fw jc bi translated">何时不使用DI、IoC和IoC容器</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">知道什么时候DIs不是正确的解决方案，什么时候应该使用更好的设计</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">better编程. pub</p></div></div><div class="mu l"><div class="qe l mw mx my mu mz lb ml"/></div></div></a></div><div class="pv pw gp gr px ml"><a rel="noopener  ugc nofollow" target="_blank" href="/how-string-in-net-c-works-f1d69bfa30f5"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jd gy z fp mq fr fs mr fu fw jc bi translated">怎么串进去的。NET C#工程</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">关于字符串及其在。NET C#</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mu l"><div class="qf l mw mx my mu mz lb ml"/></div></div></a></div><div class="pv pw gp gr px ml"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-fully-cover-i-o-file-based-applications-in-net-c-with-unit-tests-ca75c07f3b2c"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jd gy z fp mq fr fs mr fu fw jc bi translated">如何在中全面介绍基于I/O文件的应用程序。带有单元测试的. NET C#</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">学习如何将应用程序划分成更小的模块，这样你就可以100%覆盖这些模块</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mu l"><div class="qg l mw mx my mu mz lb ml"/></div></div></a></div><div class="pv pw gp gr px ml"><a rel="noopener  ugc nofollow" target="_blank" href="/strategy-design-pattern-in-net-c-b9dbd863c31e?sk=e96fabc74efc59f6ba55784788b3b69f"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jd gy z fp mq fr fs mr fu fw jc bi translated">中的策略设计模式。NET C#</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">了解中的策略设计模式。NET C#</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mu l"><div class="qh l mw mx my mu mz lb ml"/></div></div></a></div></div></div>    
</body>
</html>