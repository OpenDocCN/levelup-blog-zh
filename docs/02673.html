<html>
<head>
<title>Coding with QML &amp; Qt C++: The Epic Guide to Improve Your App Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用QML和Qt C++编码:改进应用程序开发的史诗指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/coding-with-qml-qt-c-class-the-epic-guide-to-improve-your-app-development-e851a7aa0fd1?source=collection_archive---------1-----------------------#2020-03-29">https://levelup.gitconnected.com/coding-with-qml-qt-c-class-the-epic-guide-to-improve-your-app-development-e851a7aa0fd1?source=collection_archive---------1-----------------------#2020-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5a7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用QML进行应用程序开发既简单又强大。但是Qt C++性能更好，提供了许多特性，并且不容易出错。这篇文章向你展示了如何创建利用这两种语言的应用程序。</p><h1 id="34a5" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">C++和QML如何通信</h1><p id="8b98" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">为应用程序的不同功能选择正确的语言非常重要。将C++组件与QML集成，让您的移动应用开发更上一层楼。</p><h1 id="73ec" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">编码在QML的优势</h1><p id="a7cf" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">用于基于Qt的移动应用和游戏的Felgo引擎使用了<strong class="js iu"> Qt Quick </strong> (QML + Javascript)的强大功能。这种声明式脚本语言非常强大，与其他编程语言相比，它可以节省多达60%的代码行。</p><p id="404b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lr" href="https://felgo.com/qt/qt-tutorials-resources-for-beginners" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">在QML </strong> </a> <strong class="js iu"> </strong>编码有<strong class="js iu">几个优点</strong>比<strong class="js iu">用C++开发:</strong></p><ul class=""><li id="9aed" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">用<a class="ae lr" href="https://felgo.com/qt/qt-tutorials-resources-for-beginners" rel="noopener ugc nofollow" target="_blank"> QML + JavaScript </a>编码非常容易学习，并且可以减少所需的代码量。</li><li id="1ff8" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">像状态、信号或属性绑定这样的语言概念可以节省大量时间。</li><li id="1592" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">QML让添加动画变得简单。您可以使用简单的动画组件来制作QML类型的每个属性的动画。</li><li id="a064" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">QML具有可扩展性和灵活性。例如，您可以内嵌新的属性和功能来扩展对象。无需为小型扩展创建新的可重用类型。</li><li id="8247" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">QML渲染引擎提供了出色的性能。渲染器使用C++ Qt，并依赖于硬件加速场景图。这使得它的速度足以支持高性能游戏。</li></ul><h1 id="9625" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">何时使用C++代替</h1><p id="9b7a" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated"><a class="ae lr" href="https://felgo.com/mobile-app-development" rel="noopener ugc nofollow" target="_blank">用C++ </a>开发Qt app也有优势。对于某些场景，您需要只有Qt C++才有的特性。此外，C++是快速和类型安全的。这允许为长时间运行和数据密集型计算提供最佳性能。</p><p id="8139" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这些例子，你会<strong class="js iu">选择C++而不是QML </strong>:</p><ul class=""><li id="dd63" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">原生C++代码是数据密集型操作的正确选择。它将胜过解释的QML/JavaScript代码。</li><li id="9e5b" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">C++代码是类型安全的，被编译成目标代码。对于稳定性和安全性很重要的部分，使用C++有助于使你的应用程序不容易出错。</li><li id="31c3" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">Qt C++组件提供了不同的特性，在某些情况下比QML类型提供了更多的特性。例如，高级网络功能。</li><li id="3b75" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">也可以将C++与Android(通过JNI)或iOS (Obj-C或Swift)的原生代码混合使用。这也允许为QML提供这样的本地功能。</li></ul><p id="ae6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lr" href="https://felgo.com/" rel="noopener ugc nofollow" target="_blank"> Felgo引擎</a>为手机app和游戏开发扩展Qt。它已经涵盖了像访问原生设备特性这样的任务——所以你不必担心深入C++或Java和Obj-C。</p><p id="f843" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不过，为了充分利用您的应用程序，您可以利用这两种语言的优势。该指南的完整示例也可在<a class="ae lr" href="https://github.com/FelgoSDK/VPlayCppQML-Example" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得:</p><h1 id="ba2b" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">如何从QML访问C++对象</h1><p id="5208" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在我们进入任何细节之前，让我们先用Qt Creator创建一个简单的Felgo Apps项目。如果你是Felgo新手，不知道如何操作，请考虑看看<a class="ae lr" href="https://felgo.com/doc/apps-getting-started/" rel="noopener ugc nofollow" target="_blank">入门教程</a>或<a class="ae lr" href="https://felgo.com/doc/vplay-video-tutorials/#video-tutorial-v-play-visual-designer-highlights-video" rel="noopener ugc nofollow" target="_blank"> Felgo设计师教程视频</a>。</p><p id="a359" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要注册并安装Felgo，请参见Felgo网站的<a class="ae lr" href="https://felgo.com/download/" rel="noopener ugc nofollow" target="_blank">下载页面</a>。</p><p id="2182" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>用<a class="ae lr" href="https://felgo.com/updates/release-2-14-0-live-code-reloading-for-desktop-ios-android" rel="noopener ugc nofollow" target="_blank"> QML Live </a>测试时不支持添加自定义C++代码。请使用经典的“运行”按钮构建您的项目，以测试下面的示例。</p><h1 id="ae78" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">在您的Felgo项目中创建一个C++类</h1><p id="6f74" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">1.创建新的应用程序项目后，首先用以下基本结构替换Main.qml中的代码:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=681af288" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="19d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它只包括主<a class="ae lr" href="https://felgo.com/doc/vplayapps-app/" rel="noopener ugc nofollow" target="_blank">应用</a>窗口和NavigationStack中的<a class="ae lr" href="https://felgo.com/doc/vplayapps-page/" rel="noopener ugc nofollow" target="_blank">页面</a>以显示包含页面标题的导航栏:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/169f5ee0cf3bad00572b49f6a14faaec.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/0*DwFCVhhdpYuqUYSh.png"/></div></figure><p id="0795" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.这对于我们的基本QML设置来说已经足够了。让我们继续创建一个新的C++类。首先，在Qt Creator中右键单击项目的C++“Sources”文件夹，选择“Add New…”并在c++部分选择“C++ Class”模板:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/eedceb070ef2125f8eefb4e958e7dc18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fpeC3mx6fLx3qdlm.png"/></div></div></figure><p id="1c69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.然后将“<em class="mz">my global object”</em>设置为<em class="mz">类名</em>并选择“Include QObject”以包含<strong class="js iu"> QObject </strong>类型，因为准备我们的类以供QML使用的主要要求是从QObject派生。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi na"><img src="../Images/4e721e67d092c99e275b6b4768233682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W8xALVjA5OLG-4T7.png"/></div></div></figure><p id="eaef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成向导后，您的项目在“Headers”文件夹中包含类定义<em class="mz"> myglobalobject.h </em>，在项目的“Sources”文件夹中包含实现<em class="mz"> myglobalobject.cpp </em>。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nb"><img src="../Images/b6762c9b5b44f4de82d0103a8a18a3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3qBgLJOUfZnANEMT.png"/></div></div></figure><p id="da79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意*。专业配置现在也包括新文件在<em class="mz">头</em>和<em class="mz">源</em>配置。</p><h1 id="3b31" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">使用信号和插槽实现C++类，以便与QML一起使用</h1><p id="f0e6" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">1.打开<em class="mz"> myglobalobject.h </em>并添加一些代码到从QObject 派生的<strong class="js iu">—所需的include语句已经就绪:</strong></p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=6b99d0a3" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="24c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要忘记在类定义中添加Q_OBJECT预处理宏。</p><p id="5932" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.现在我们有了一个新的QObject，让我们添加一个简单的方法，稍后我们将从QML调用它。为了使该方法在QML可用，需要将其标记为<strong class="js iu">公共槽</strong>:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=58376ee1" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="9711" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.为了完成我们的基本类，打开<em class="mz"> myglobalobject.cpp </em>并添加<em class="mz"> doSomething() </em>的方法实现。我们保持简单，只把给定的文本打印到调试输出中。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=271ea3d8" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><h1 id="fb92" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">将对象作为上下文属性公开给QML</h1><p id="d062" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在QML处理C++对象的一种可能方式是<strong class="js iu">将对象作为属性添加到QML树的根上下文</strong>。您可以决定属性的名称，然后在您的QML代码中全局可用。</p><p id="f9d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.为了创建我们类的新对象并将其作为属性添加，我们扩展了main.cpp代码:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=ff1284e2" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="1dc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:在C++中也可以完全使用这个对象。上面的代码示例已经包含了对我们的doSomething方法的测试调用。</p><p id="fdc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.在我们项目的Main.qml中，我们用一个列和第一个AppButton扩展了我们的页面，当单击它时调用doSomething()方法:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=530dcdd4" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/fee6e97873b45ff20042965a26a30d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/0*c57SXbPp9Jx3eFuH.png"/></div></figure><p id="793b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.让我们点击Qt Creator中的绿色运行按钮，看看它是如何工作的。调试输出显示main.cpp的初始方法调用，点击按钮会出现另一条消息:<br/><em class="mz">my global object do something with " TEXT FROM QML "</em></p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nc"><img src="../Images/37b523fa6389f3ff449b7608edcacb1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YMj15WnYinOdcBSI.png"/></div></div></figure><p id="af02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我们从QML调用C++对象的方法所需要的。这已经允许从QML到C++的简单通信，但是我们还可以做更多。QML支持许多令人惊奇的概念，比如属性的值改变监听器和属性绑定，这使得开发变得更加容易。所以让我们在C++类中添加一个全功能的QML属性吧！</p><h1 id="d24a" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">添加完全支持QML的类属性</h1><p id="649f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">1.打开<em class="mz"> mylgobalobject.h </em>并添加一个带有公共getter和setter方法的私有计数器属性。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=5f800d15" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="3380" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.实现所需的方法并初始化<em class="mz"> myglobalobject.cpp </em>中的计数器属性</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=d2f1a6fb" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="c0b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.与QML的其他属性类似，我们也希望能够对QML代码中的属性变化做出动态反应。换句话说，当C++属性改变时，我们希望在QML中触发函数。与<strong class="js iu">插槽</strong>不同，插槽使<strong class="js iu"> C++方法可在QML </strong>中调用，<strong class="js iu">信号</strong>可用于<strong class="js iu">从C++ </strong>中触发QML代码。所以数据流看起来像这样:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/04b436bee4df98af78b221c6a6a890ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/0*kj09JvPPdOCSnqp3.png"/></div></figure><p id="35a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们添加一个信号<em class="mz">反转</em>并在我们的<em class="mz"> setCounter </em>实现中触发它:</p><p id="7a68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> myglobalobject.h: </strong></p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=8fa374a5" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="01ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> myglobalobject.cpp: </strong></p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=ade866a3" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="273f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.这个简单的改变已经允许我们为QML中的<em class="mz">count changed()</em>信号添加处理函数。然而，我们的计数器属性仍然是一个普通的C++属性，带有一个getter和setter方法。我们可以用一个额外的预处理宏来解决这个问题:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=66c61079" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="2055" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Q_PROPERTY </strong>宏定义了属性<em class="mz">计数器</em>并配置了读写属性的方法，以及通知属性变化的信号。QML使用此配置来处理属性。</p><p id="da9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.让我们扩展Main.qml并使用新的计数器属性。以下代码片段添加了一个增加计数器的新按钮和一个显示值的文本项:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=778a359a" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="36a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的房产可以像QML的其他房产一样使用。感谢我们准备的计数器，每次更换计数器时，文本甚至会自动更新。</p><p id="898a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是最后一个示例的样子:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/3f40a8ec73a9b674cf1c9a7dad224a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/0*23FcDOr_0KpYUt4f.png"/></div></figure><h1 id="646b" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">如何将你的C++类注册为QML类型</h1><p id="0076" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在QML使用C++组件的第二种可能性是将类注册为QML类型。这允许直接在QML而不是C++中创建你的类型的对象。最棒的是，我们在前面的例子中使用的信号、插槽和属性的概念仍然适用。</p><h1 id="d113" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">何时使用上下文属性，何时使用QML对象</h1><p id="4028" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如果您只想在QML中使用一个对象实例，您可以将该对象添加为<strong class="js iu">上下文属性</strong>。当你的类有多个实例时，<strong class="js iu">将它注册为一个QML类型</strong>，并在你需要的地方直接在QML创建对象。</p><p id="1439" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.对于这个例子，我们将创建一个可以在QML使用的新类型。让我们从添加一个名为<em class="mz"> MyQMLType </em>的新C++类开始</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi na"><img src="../Images/6cd4edd58d4dab5801030ac9cb0c90f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SmFmRPjyH-b7AxoK.png"/></div></div></figure><p id="0c98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.用此实现替换<em class="mz"> myqmltype.h </em>中的代码:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=a86b1e03" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="c4e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与前面的例子类似，这个类型将有一个公共槽和一个全功能属性，该属性有一个getter方法、一个setter方法和一个属性更改信号。increment方法将给定的整数值加1，message属性将存储一个字符串值。</p><p id="7131" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.要完成该类，请为<em class="mz"> myqmltype.cpp </em>添加以下代码:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=075d4060" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><h1 id="eefe" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">在C++和QML之间可以传递哪些参数</h1><p id="3512" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">与前面的例子相反，我们的新类也为增量槽使用返回值。无需进一步调整即可在QML获得返回值。对于所有方法参数和返回值，Qt自动将基本C++类型映射到QML类型。</p><p id="8f5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有关可用Qt类型和相应QML类型的更多信息，请参见<a class="ae lr" href="http://doc.qt.io/qt-5/qtqml-cppintegration-data.html" rel="noopener ugc nofollow" target="_blank">QML和C++ </a>之间的数据类型转换。</p><h1 id="c570" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">注册并使用你的C++ QML类型</h1><p id="fd92" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">1.在main.cpp中，首先为新类添加一个include语句:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=f5cebc9e" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="720e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.然后使用<strong class="js iu"> qmlRegisterType </strong>将该类添加为QML类型。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=5a0d21da" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="7a39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该方法有几个参数:模块标识符和版本定义了使用该类型所需的QML导入。最后一个参数保存QML类型的名称，它可以不同于实际的C++类名。</p><p id="7ef9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.将与所使用的qmlRegisterType配置相匹配的导入添加到Main.qml:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=0a936d73" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="313b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.对于我们的新QML类型的示例用法，在第一个示例下面添加以下代码片段:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=d7852b80" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="a858" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码显示我们现在可以像使用任何其他QML项目一样使用<em class="mz"> MyQMLType </em>。<em class="mz">消息</em>属性通过属性绑定进行内联初始化，这显示了将<em class="mz"> myGlobalObject.counter </em>除以2的整数结果。每当计数器发生变化时，该表达式会自动重新计算。</p><p id="241c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，当消息依次改变时(每2个计数器步骤)，我们使用<em class="mz"> onMessageChanged </em>信号在日志输出中显示新消息。</p><p id="7695" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似于其他QML项目，当QML引擎创建对象时，<em class="mz"> Component.onCompleted </em>信号可用于执行初始化步骤。在这个例子中，我们使用<em class="mz">增量</em>槽将计数器增加1。</p><p id="21dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">底部的AppText只显示消息属性:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/fff83ae37a2683777562ede4d91e3718.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/0*rI7sejh-Z6Q7l5mW.png"/></div></figure><h1 id="27a5" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">使用属性、信号或插槽？</h1><p id="37f0" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">正如我们在前面的例子中已经看到的，属性、信号和插槽在C++和QML之间提供了不同类型的通信:</p><ul class=""><li id="f20e" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated"><strong class="js iu">插槽允许从QML到C++的通信:</strong>插槽用于触发来自QML的C++代码。您可以使用参数和返回值在C++之间传递数据。</li><li id="e45c" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated"><strong class="js iu">信号允许从C++到QML的通信:</strong>信号用于在C++发生某些事件时运行QML代码。你可以从C++向QML传递参数。但是，您不能从QML返回数据。<br/>与插槽相反，信号可以由零个、一个或多个组件处理。不能保证在C++中触发一个信号会真正运行QML代码，除非定义了一个处理程序。</li></ul><p id="b3f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">属性双向工作:属性在C++和QML中都是可读写的。为了支持QML中的属性绑定，请确保为属性添加一个changed-signal，并且不要忘记在C++中每当值改变时触发该信号。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/03a4df7a11f0fe44732cd8ec9dc34bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/0*zXa__VEY1_ZA6N6C.png"/></div></figure><h1 id="f451" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">如何从QML开始长期运行的C++操作</h1><p id="1b57" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">上面的例子已经完全涵盖了插槽和属性，但是只使用了一个信号作为属性配置的一部分。为了完成这个例子，让我们添加一个新的槽<em class="mz"> startCppTask </em>()、一个新的方法<em class="mz"> doCppTask </em>()和一个新的信号<em class="mz">cpptasktfinished</em>()到<em class="mz"> myqmltype.h </em>:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=759fa28f" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="9a6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们稍后将从QML调用slot <em class="mz"> startCppTask() </em>，它执行内部的<em class="mz"> doCppTask() </em>方法。例如，您可以在此时在另一个线程中运行计算，以避免在执行任务时阻塞QML用户界面。这对于您想在C++中处理的任何cpu密集型或长时间操作都很有用。通过将方法的实现添加到myqmltype.cpp，我们完成了C++部分。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=014d4db0" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="3481" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在一切都准备好了，我们可以添加另一个AppButton来启动我们的C++任务:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=7e2cb23f" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="7d8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">onCppTaskFinished()信号将在C++部分完成计算时通知我们:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=6e7ed854" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><p id="ffc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本例中，我们只需在信号触发时将全局计数器重置为零，这也将更新MyQMLType的message属性。</p><p id="ccb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是执行cpp任务后最后一个示例的样子:</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/0d51d7377e19619defa502b650574d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/0*hf_Tdiw72cCu6DEL.png"/></div></figure><p id="5ab1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:当使用<strong class="js iu">上下文属性</strong>时，要在QML处理自定义信号，请使用<em class="mz">连接</em> QML类型。以下代码片段向<em class="mz"> myGlobalObject </em>的<em class="mz"> counterChanged() </em>信号添加了一个处理程序:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated"><a class="ae lr" href="https://felgo.com/web-editor/?snippet=e658cfd3" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">现在在你的iOS或Android设备上运行这段代码</strong> </a> <strong class="ak">，并实时重新加载代码</strong></figcaption></figure><h1 id="8045" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">何时从QQuickItem而不是QObject派生</h1><p id="99e7" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在所有使用的例子中，我们创建了一个扩展QObject的C++类。但是，QObjects有一些限制:QObjects没有可视化表示。这意味着它们不能包含任何子项目，并且关于视觉特征(如大小、位置、可见性)的属性不可用。</p><p id="0481" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个QObject只保存您可以在QML中作为属性、信号和插槽使用的数据和逻辑。将QObject类注册为QML的类型时，请记住以下限制。要用C++创建一个QML项目，它应该支持具有所有默认属性的可视化表示，请改为从<strong class="js iu"> QQuickItem </strong>派生。</p><p id="43cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于这个简短的介绍并不包括QQuickItems的实现，请参见<a class="ae lr" href="http://doc.qt.io/qt-5/qquickitem.html" rel="noopener ugc nofollow" target="_blank"> Qt文档</a>了解更多信息。关于集成QML和C++的概述页面可以在<a class="ae lr" href="http://doc.qt.io/qt-5/qtqml-cppintegration-topic.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="de1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本指南中创建的项目的完整源代码可以在<a class="ae lr" href="https://github.com/FelgoSDK/VPlayCppQML-Example" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到:</p><h1 id="6244" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">更多这样的帖子</h1><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nf mm l"/></div></figure><p id="fa68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lr" href="https://felgo.com/cross-platform-app-development/how-to-add-chat-service-and-cross-platform-leaderboard-with-user-profiles-to-your-ios-or-android-app" rel="noopener ugc nofollow" target="_blank">向您的iOS或Android应用程序添加聊天服务和跨平台排行榜以及用户资料</a></p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ng"><img src="../Images/1f536598663b6e2b4feb1519b22342c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T11Ed83jHpRWVF5d.jpg"/></div></div></figure><p id="1102" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lr" href="https://felgo.com/updates/release-2-14-1-update-to-qt-5-9-3-use-live-code-reloading-on-macos-and-linux" rel="noopener ugc nofollow" target="_blank">2 . 14 . 1版:更新至Qt 5.9.3 |在macOS和Linux上使用实时代码重载</a></p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ng"><img src="../Images/ebea7eaaf48acd657d3b0e74b8a93919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rf5_4v8zFZ29dHzK.jpg"/></div></div></figure><p id="8396" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae lr" href="https://felgo.com/cross-platform-app-development/qt-v-play-apps-video" rel="noopener ugc nofollow" target="_blank">如何用Qt制作跨平台移动应用——fel go应用</a></p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/6fd9a9bd2fc2b46219514a22218308b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*VRr4raWzHcMFuuqB.png"/></div></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="7a10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">【https://felgo.com】原载于2020年3月29日<a class="ae lr" href="https://felgo.com/cross-platform-development/how-to-expose-a-qt-cpp-class-with-signals-and-slots-to-qml" rel="noopener ugc nofollow" target="_blank"><em class="mz"/></a><em class="mz">。</em></p></div></div>    
</body>
</html>