<html>
<head>
<title>Solve Readers-Writers Problem with Go in 5 Lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go用5行代码解决读者-作者问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solve-readers-writers-problem-with-go-in-5-lines-of-code-d9c5fc8a8262?source=collection_archive---------2-----------------------#2019-10-01">https://levelup.gitconnected.com/solve-readers-writers-problem-with-go-in-5-lines-of-code-d9c5fc8a8262?source=collection_archive---------2-----------------------#2019-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/90a108bc93c82da65d52ac87ef9b5271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CdjOgfolLt_GNJYBzI-1QQ.jpeg"/></div></div></figure><h2 id="37a5" class="iz ja jb bd b dl jc jd je jf jg jh dk ji translated" aria-label="kicker paragraph">令人敬畏的围棋— #1</h2><div class=""/><div class=""><h2 id="b2c8" class="pw-subtitle-paragraph kh jk jb bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">只用5行代码就解决了一个非常流行的关于Go中并发编程的编码练习和面试问题。</h2></div><h1 id="22d2" class="kz la jb bd lb lc ld le lf lg lh li lj kq lk kr ll kt lm ku ln kw lo kx lp lq bi translated">前言</h1><p id="a86c" class="pw-post-body-paragraph lr ls jb lt b lu lv kl lw lx ly ko lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">读者-作者问题是并发中常见计算问题的一个非常流行的例子。这也是技术面试中非常受欢迎的练习。</p><p id="faaf" class="pw-post-body-paragraph lr ls jb lt b lu mn kl lw lx mo ko lz ma mp mc md me mq mg mh mi mr mk ml mm ij bi translated">该问题处理许多线程试图同时访问同一个共享资源的情况。一些线程可以读取，一些线程可以写入，约束条件是当另一个进程正在写入共享资源时，没有进程可以访问该共享资源进行读取或写入。</p><p id="7807" class="pw-post-body-paragraph lr ls jb lt b lu mn kl lw lx mo ko lz ma mp mc md me mq mg mh mi mr mk ml mm ij bi translated">为了解决这种情况，作者应该获得对对象的独占访问。当编写器访问对象时，任何读取器或编写器都不能访问它，但是多个读取器可以同时访问它。这可以用<a class="ae ms" href="https://en.wikipedia.org/wiki/Mutex" rel="noopener ugc nofollow" target="_blank">互斥</a>或<a class="ae ms" href="https://en.wikipedia.org/wiki/Semaphore_(programming)" rel="noopener ugc nofollow" target="_blank">信号量</a>来实现。然而，<a class="ae ms" href="https://en.wikipedia.org/wiki/Readers–writer_lock" rel="noopener ugc nofollow" target="_blank">读写器锁</a>是解决这个问题最方便的数据结构。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="4fd2" class="kz la jb bd lb lc na le lf lg nb li lj kq nc kr ll kt nd ku ln kw ne kx lp lq bi translated">去同步。RWMutex</h1><p id="dead" class="pw-post-body-paragraph lr ls jb lt b lu lv kl lw lx ly ko lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">好在Go内置了readers-writer锁实现，就是<code class="fe nf ng nh ni b">sync.RWMutex</code>。</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="c782" class="nr la jb ni b gy ns nt l nu nv"><em class="nw">// Lock locks rw for writing. If the lock is already locked for reading or writing, Lock blocks until the lock is available.</em><br/>func (rw *<a class="ae ms" href="https://golang.org/pkg/sync/#RWMutex" rel="noopener ugc nofollow" target="_blank">RWMutex</a>) Lock()</span><span id="7e3b" class="nr la jb ni b gy nx nt l nu nv"><em class="nw">// RLock locks rw for reading.<br/></em>func (rw *<a class="ae ms" href="https://golang.org/pkg/sync/#RWMutex" rel="noopener ugc nofollow" target="_blank">RWMutex</a>) RLock()</span><span id="47a5" class="nr la jb ni b gy nx nt l nu nv"><em class="nw">// RUnlock undoes a single RLock call; it does not affect other simultaneous readers.</em><br/>func (rw *<a class="ae ms" href="https://golang.org/pkg/sync/#RWMutex" rel="noopener ugc nofollow" target="_blank">RWMutex</a>) RUnlock()</span><span id="83a0" class="nr la jb ni b gy nx nt l nu nv"><em class="nw">// Unlock unlocks rw for writing.</em><br/>func (rw *<a class="ae ms" href="https://golang.org/pkg/sync/#RWMutex" rel="noopener ugc nofollow" target="_blank">RWMutex</a>) Unlock()</span></pre></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="9a4b" class="kz la jb bd lb lc na le lf lg nb li lj kq nc kr ll kt nd ku ln kw ne kx lp lq bi translated">解决问题</h1><p id="338a" class="pw-post-body-paragraph lr ls jb lt b lu lv kl lw lx ly ko lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">有了内置的<code class="fe nf ng nh ni b">sync.RWMutex</code>，只需在现有的<code class="fe nf ng nh ni b">reader</code> <code class="fe nf ng nh ni b">writers</code>代码中增加5行代码就能解决问题。</p><figure class="nj nk nl nm gt is"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0aaf" class="pw-post-body-paragraph lr ls jb lt b lu mn kl lw lx mo ko lz ma mp mc md me mq mg mh mi mr mk ml mm ij bi translated">第一行是分配一个新的<code class="fe nf ng nh ni b">RWMutex</code>。</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="bb21" class="nr la jb ni b gy ns nt l nu nv"><strong class="ni jl">var</strong> mutex = new(sync.RWMutex)</span></pre><p id="750d" class="pw-post-body-paragraph lr ls jb lt b lu mn kl lw lx mo ko lz ma mp mc md me mq mg mh mi mr mk ml mm ij bi translated">在<code class="fe nf ng nh ni b">reader</code>中，在它上面增加2行来锁定和解锁读取。</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="02d6" class="nr la jb ni b gy ns nt l nu nv">mutex.RLock()<br/><strong class="ni jl">defer</strong> mutex.RUnlock()</span></pre><p id="2293" class="pw-post-body-paragraph lr ls jb lt b lu mn kl lw lx mo ko lz ma mp mc md me mq mg mh mi mr mk ml mm ij bi translated">同样的，在<code class="fe nf ng nh ni b">writer</code>中，在它上面加2行来锁定和解锁写。</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="748c" class="nr la jb ni b gy ns nt l nu nv">mutex.Lock()<br/><strong class="ni jl">defer</strong> mutex.Unlock()</span></pre><p id="24b6" class="pw-post-body-paragraph lr ls jb lt b lu mn kl lw lx mo ko lz ma mp mc md me mq mg mh mi mr mk ml mm ij bi translated">搞定了。正如您所看到的，使用Go <code class="fe nf ng nh ni b">defer</code>特性，您可以简单地将您的函数封装在一个安全锁中。<code class="fe nf ng nh ni b">defer</code>无论是成功返回还是惊慌失措后都会一直开火。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="e587" class="kz la jb bd lb lc na le lf lg nb li lj kq nc kr ll kt nd ku ln kw ne kx lp lq bi translated">在it实际使用案例中应用</h1><p id="29e3" class="pw-post-body-paragraph lr ls jb lt b lu lv kl lw lx ly ko lz ma mb mc md me mf mg mh mi mj mk ml mm ij bi translated">我还实现了这个问题的一个真实用例，它是一个抽象值，对于并发使用是安全的。</p><figure class="nj nk nl nm gt is"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div></div>    
</body>
</html>