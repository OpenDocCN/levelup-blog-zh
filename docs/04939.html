<html>
<head>
<title>Go: Achieving 70 Million Sets To Aerospike Database In 30 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">go:30分钟内气塞数据库达到7000万套</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-achieving-70-million-sets-to-aerospike-database-in-30-minutes-30d4018540ab?source=collection_archive---------5-----------------------#2020-07-25">https://levelup.gitconnected.com/go-achieving-70-million-sets-to-aerospike-database-in-30-minutes-30d4018540ab?source=collection_archive---------5-----------------------#2020-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b757" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我之前的文章中，我详细介绍了goroutines的局限性，在这篇文章中，我想分享我们如何在Go Worker Pool模式的帮助下，通过利用整个系统核心，在30分钟内实现了7000万个数据集到Aerospike数据库。</p><p id="8f46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">用例洞察</strong></p><ul class=""><li id="c0fb" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">目前，在GoIbibo，我们有近7000万用户，我们有一套每个用户所属的类别。这些类别描述了用户是否是新用户|欺诈|定期交易用户|去年没有交易的用户等等…</li><li id="2358" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">用户类别根据他们的行为动态变化，我们有一个生成任务，我们从多个来源收集数据并保存到我们的数据库中，关键字作为用户ID，值作为类别列表，每天必须为所有7000万用户生成。</li></ul><p id="d77a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">数据库洞察</strong></p><ul class=""><li id="8c25" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">对于那些不知道Aerospike的人来说，它是一个多线程的分布式键值存储，存储基于SSD。</li><li id="d6f0" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">我们有3个Aerospike实例，其中键被拆分并以期望的复制因子跨实例存储。</li></ul><p id="8263" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">优于Redis </strong></p><ul class=""><li id="5629" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">这是一个多线程的键值存储，不会阻止所有的请求，如果有任何缓慢的查询，不像Redis，如果一个请求变慢，就会阻止所有的请求</li><li id="34e8" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">SSD比RAM便宜，并且作为分布式数据库，我们总是有机会进行水平扩展，不像Redis，我们需要随着数据的增长进行垂直扩展。</li></ul><p id="77dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">弊端</strong></p><ul class=""><li id="a08f" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">这不支持批处理集，这意味着如果我们需要插入7000万个键值，我们需要对每个键进行1次DB调用，这相当于7000万次DB调用。</li></ul></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><p id="14ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">方法、陷阱和收购的</strong></p><p id="cf25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们聚集来自多个来源的数据，并将其作为映射数据结构存储在内存中，键是userID，值是类别列表。我们最初通过遍历映射以同步方式开始，其中我们一次向数据库设置一条记录。当我们试图计算估计时间时，上面的解决方案是最坏的可能。为什么？</p><p id="7aeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们运行在8核CPU和支持多线程的数据库上，但是从应用程序来看，我们仍然是顺序处理的。我们既没有利用系统内核，也没有利用数据库资源。让我们来计算一个连续生成所需的总时间。</p><p id="b755" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">70，00，00，000键* 2 ms(平均设定速度)= 140，00，000，000 ms = <strong class="js iu"> 39小时</strong></p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/f484cf2c0b953a246bdae47426d53d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/1*pD132t32_ayRMXi9lZ21QA.gif"/></div></figure><p id="5464" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我刚才到底看到了什么？一个每天都要生成两次的任务需要花费40个小时，接近2天。这可行吗？绝对没有。</p><p id="7ffd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们分析顺序处理不起作用的地方，我们必须通过使用整个系统和数据库资源来并行化任务，这时我们遇到了<strong class="js iu"> Go Worker Pool模式</strong>。</p><p id="69fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们先接触一下代码，我会让你看完每一行，并详细解释上下文切换是如何发生的。</p><figure class="ll lm ln lo gt lp"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="8b12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们看一下每一行代码。</p><p id="977d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们获得聚合数据，其中键作为用户id，值作为类别的一部分。</p><p id="dfc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">工人池模式(伪代码)</strong></p><ul class=""><li id="acbd" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">首先，我们宣传说，在任何给定的时间点，我们将通过缓冲的作业通道拥有最多100个作业。</li><li id="6598" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">然后我们招募60名工人，他们一直在等待工作。</li><li id="12fa" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">一旦我们把所有的工作都喂给了工人，我们就可以成功地终止工人。</li></ul><p id="b678" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">对代码的深入理解。</strong></p><p id="8716" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们调用<strong class="js iu"> createWorkers </strong> fn时，它在内部产生了60个Workers，也称为8核CPU上的goroutines。我们生成的每个worker都一直监听来自jobs通道的事件，直到它接收到for循环中的事件代码(AerospikeWrapper)。Set)不会被执行。</p><p id="ec38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然我们已经有了足够多的工人，是时候给工人们提供一些工作了。在我们的例子中，到worker的提要应该包含一个userID，特定用户的类别(通过userData struct传递),然后可以发送到DB。</p><p id="7719" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用一张图来表示这个场景，如下图所示。</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lu"><img src="../Images/8231cf07b48a0e00c87f4c5a1fc01533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ls1ShNEARtdTSe6U2BA0TQ.png"/></div></div></figure><p id="a9af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于我们在8个内核上产生了60个工作线程，每个内核平均负责处理近7–8个goroutines。这些goroutines中的每一个都不断地监听jobs通道来寻找新的作业，一旦它得到了一个作业，它就按顺序执行数据库设置。但是这里有一个问题。</p><p id="7f7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们都知道一个CPU内核几乎一次只能执行一条指令，这是否意味着我们可以只对*个CPU内核并行处理？该死的不…</p><p id="aa47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">这就是上下文切换发挥作用的地方。</strong></p><p id="e1ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个内核处理的第一个goroutine获得一个事件，只要我们在goroutine中启动一个数据库调用，它就会被推送到进程队列，因为数据库调用是异步的，下一个goroutine将开始监听作业通道，这个循环会重复，直到进程队列中的一个项目执行完毕。</p><p id="eb40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦进程队列中的项目执行完同步网络| I/O操作，CPU内核将再次选取进程队列中的该项目并执行该项目，直到它再次命中I/O或网络调用。如果没有，它将执行完该作业，并继续执行下一个作业。</p><p id="4521" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您看一下我们所做的操作序列，在任何给定的时间点，我们都会并行进行大约60 DB的调用，这与池中的工作线程数成正比。</p><p id="eae5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然上下文切换的过程比我所说的要复杂得多，但我只想给出一个关于它如何发生以及每个内核如何负责处理一组goroutines的顶级概述。</p><p id="285d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，我们达到了接近每秒10000个数据库集的Aerospike/Instance，并且我们有3个DB实例。</p><p id="6988" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以7，00，00，000 / 3万= 35分钟。</p><p id="7db3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望我已经传达了我想要的。如有任何问题，请发表评论，我一定会尽力回复。</p><p id="b857" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下一篇文章中，我将详细介绍如何使用HTOP可视化CPU利用率。</p><p id="904f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">敬请期待</strong></p></div></div>    
</body>
</html>