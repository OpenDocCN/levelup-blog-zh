<html>
<head>
<title>Getting Started with Web Components &amp; Lit | Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件入门&amp; Lit |第3部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-started-with-web-components-lit-part-3-81ba933f0f56?source=collection_archive---------8-----------------------#2022-07-03">https://levelup.gitconnected.com/getting-started-with-web-components-lit-part-3-81ba933f0f56?source=collection_archive---------8-----------------------#2022-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/44e89cd872f636775215e50e52775642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z9EoS3ndSqbtQonRdoc5GA.png"/></div></div></figure><h1 id="ce36" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">第3部分|用Lit构建单页面应用程序</h1><blockquote class="kw kx ky"><p id="8758" class="kz la lb lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><a class="ae ly" href="https://lit.dev" rel="noopener ugc nofollow" target="_blank"> <em class="iq">点亮</em> </a> <em class="iq">，来自Google，是一种简单的开始使用web组件的方法。在本系列的</em> <a class="ae ly" href="https://medium.com/@mimixco/getting-started-with-web-components-lit-part-1-911aa7058e9b" rel="noopener"> <em class="iq">第1部分</em> </a> <em class="iq">中，我解释了为什么我为web应用程序调用Lit的</em> <strong class="lc ir"> <em class="iq">反框架</em> </strong> <em class="iq">。在</em> <a class="ae ly" href="https://medium.com/@mimixco/getting-started-with-web-components-lit-part-2-3cd878aeca73" rel="noopener"> <em class="iq">第2部分</em> </a> <em class="iq">中，我们用Lit和Vite开发服务器创建了一个工作的web组件。在这篇文章中，我们将从头开始创建一个单页应用程序，让我们可以在没有框架的情况下导航到不同的网页内容面板… </em>！</p></blockquote><p id="ad5f" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated"><strong class="lc ir">快速索引</strong> <br/>第一部分:<a class="ae ly" href="https://medium.com/@mimixco/getting-started-with-web-components-lit-part-1-911aa7058e9b" rel="noopener">介绍Web组件</a> <br/>第二部分:<a class="ae ly" href="https://medium.com/@mimixco/getting-started-with-web-components-lit-part-2-3cd878aeca73" rel="noopener">设置Lit和Vite </a> <br/>第三部分:<a class="ae ly" href="https://medium.com/@mimixco/getting-started-with-web-components-lit-part-3-81ba933f0f56" rel="noopener">构建单页面App </a></p><h1 id="89cf" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">侏罗纪设计:个人网页</h1><p id="3569" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">回到web开发的侏罗纪时代，我们曾经为网站界面的每个功能制作单独的页面，比如用<code class="fe mh mi mj mk b">index.html</code>页面欢迎它们，但用<code class="fe mh mi mj mk b">cart.asp</code>显示购物车。用户进度的每个阶段都由服务器上该页面上的任何代码控制，以及用户通过URL导航到的任何页面。你可能记得看到过这个时代的警告，比如，“在这个过程中不要使用浏览器的后退按钮！”</p><p id="5a53" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">这种软件开发的另一个产物是具有超长URL的页面，这些URL包含大量不可读的代码和多个参数，如果没有复制或100%正确地输入，就会导致错误页面。你在电子邮件中收到过这种可怕的网址。他们通常只为你工作，或者只工作一次，或者只在其他情况下工作。</p><p id="5f3a" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">这种史前的导航方法也留下了恐龙大小的粪便供我们调试。当用户体验的每个方面都由独立的URL和代码页面控制时，我们作为人类很难了解界面是如何创建的，或者在出现错误时修复它。更糟糕的是，这类界面也非常难以添加功能，因为页面和URL彼此不了解。每一步都是独立的动物。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/169d3654e7ee305133b6411d271c0113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jxc73vAUqXyEPfmu2pgJJA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">我的游戏公司的商业网站是由我将在这里教你的东西的一个奇特版本制成的。所有的按钮和面板都是带有Lit的自定义web组件。</figcaption></figure><h1 id="d7ea" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">MVC的时刻</h1><p id="35ec" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">为了远离动物园，我们需要一种单一的方式来组织和呈现页面内容。这种方法叫做<a class="ae ly" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> MVC </strong> </a>或者模型-视图-控制器。这种方法有许多名字，有许多奇特的(和不相关的)味道，像MVVM和其他人。但是底线是我们需要一个<strong class="lc ir">模型</strong>来保存数据。所有数据都应该在模型中，而不是在其他地方。我们需要一个<strong class="lc ir">视图</strong>，它包含用户可以看到和触摸到的一切。我们还需要<strong class="lc ir">控制器</strong>软件来将东西移入和移出模型和视图。</p><h1 id="4f88" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">进入水疗中心</h1><p id="97aa" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">单页应用程序用一个单独的页面，通常是<code class="fe mh mi mj mk b">index.html</code>，取代了单独的代码页面和UI页面。该页面充当MVC设计模式中的<strong class="lc ir">控制器</strong>。页面加载的任何视图(在其HTML <code class="fe mh mi mj mk b">&lt;body&gt;</code>中)对用户来说都是他们正在查看的一个页面。任何数据对于<code class="fe mh mi mj mk b">index</code>加载的任何模块都是可用的，这是MVC的<strong class="lc ir">模型</strong>部分。如果<code class="fe mh mi mj mk b">index</code>能够获得数据，它就是我们模型的一部分。</p><p id="97a2" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">这种安排对于调试来说是极好的，因为不存在谁或什么在创建您所看到的任何输出的问题。答案总是一样的。输出来自你让<code class="fe mh mi mj mk b">index</code>加载的web组件绘制的HTML。通过仔细调整这些内容，您可以创建一个流畅的用户体验，而不需要不必要的长URL或组件之间复杂的数据传递。</p><p id="efc9" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">当今世界上许多最受欢迎的应用是温泉。它们在Spotify等面向消费者的应用程序中特别受欢迎，因为有了良好的MVC设计，单页应用程序可以在提供高质量的定制用户界面的同时保持健壮和一致。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/bc6a6e714101cbf3d9858849fb165016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J0C8m0M6m11PXGpr0Zuf3A.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">Spotify是一个很好的单页面应用程序的例子，它也是跨平台的，完全由web组件构建。点击按钮和专辑封面会触发<strong class="bd ka">控制器</strong>中的功能，更新<strong class="bd ka">视图</strong>。<strong class="bd ka">模型</strong>由两部分组成，一部分是你的数据模型，另一部分是Spotify音乐库的正交模型。</figcaption></figure><h1 id="ff26" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">用路由模拟导航</h1><p id="bdec" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">由于SPA中的URL不需要引用任何真实的代码(比如文件名或参数值)，所以我们可以按照自己的意愿设计我们的URL。我们用一个叫做<strong class="lc ir"> routing </strong>的想法将我们的设计者URL连接到一个可视视图。最初，这意味着通过将用户引导到另一个页面来模拟导航。但是由于我们不在其他任何人的框架内，我们可以让我们的路线代表我们想要的任何东西。</p><h1 id="532e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">创建多页面查看器</h1><p id="c4fe" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">让我们为一个页面查看器应用程序创建web组件，它就像一个简单的网站。我们将把所有页面数据存储在一个<a class="ae ly" href="https://en.wikipedia.org/wiki/JSON" rel="noopener ugc nofollow" target="_blank"> JSON </a>模型中，并编写两个定制的web组件，一个用于“主页”(页面的容器)，另一个用于页面本身。最后，我们将添加路由，以便查看者可以“访问”各种页面。</p><p id="754b" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">W3C关于web组件的规则之一是，您的定制组件必须有一个由两部分组成的名称，用破折号隔开。我们可以将它与另一个叫做<a class="ae ly" href="https://en.wikipedia.org/wiki/Namespace" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> namespacing </em> </a>的好的编程实践一起使用，通过对我们所有的部分和模块使用相同的起始字母来将我们的组件与其他任何组件分开。对于这个例子，我将用<strong class="lc ir"> dta </strong>启动我所有的web组件。所以我们将制作<code class="fe mh mi mj mk b">&lt;dta-home&gt;</code>和<code class="fe mh mi mj mk b">&lt;dta-page&gt;</code>。</p><p id="6393" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">我们正在构建的实际应用程序是DTA游戏公司网站的简化版本，你可以访问该网站，查看用这些相同的想法构建的一些更复杂的布局。</p><h1 id="6834" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">整理你的应用</strong></h1><p id="56ce" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">让我们设置一个<strong class="lc ir"> dta </strong>文件夹(或者您选择的名称空间名称)，然后创建一个<strong class="lc ir">组件</strong>文件夹和一个<strong class="lc ir">全局</strong>文件夹。您还需要一个<strong class="lc ir">模块</strong>文件夹用于将来的扩展。我使用这种模式来遵守一条严格的规则，即视图中的任何内容都必须位于components文件夹中。其他不依赖于特定视图的Typescript函数成为它们自己的模块，并驻留在该文件夹中。我把“触及一切”的东西，比如启动材料、加载器、字体和样式放到我的全局文件夹中。</p><blockquote class="kw kx ky"><p id="8466" class="kz la lb lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">要创建一个新文件夹，在VSCode的左侧，右键单击空白区域并选择<strong class="lc ir">新建文件夹</strong>。要在文件夹内创建新文件，右击文件夹并选择<strong class="lc ir">新建文件</strong>。</p></blockquote><h1 id="a4c1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">创建您的第一个组件</h1><p id="7a80" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">在components文件夹中创建一个新的<code class="fe mh mi mj mk b">dta-home.ts</code>文件(或者以您的名称空间开头的另一个名称)。这是一个带有自定义CSS样式和纯文本输出的简单组件。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/bc2ac7cc848d5f8d0db12baa5c1ed347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8U6BWpiaT6AQ-0WR6WFQA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">我们的定制元素只需要3个部分:一个<strong class="bd ka">导入</strong>语句，一个<strong class="bd ka">导出</strong>类，和一个<strong class="bd ka">呈现()</strong>函数。</figcaption></figure><p id="0ff9" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">这个在<code class="fe mh mi mj mk b">&lt;dta-home&gt;</code>的第一次尝试除了它的Lit导入之外只需要两个部分。首先是一个<code class="fe mh mi mj mk b">@customElement</code>装饰器，它是Lit中将HTML元素<code class="fe mh mi mj mk b">&lt;dta-home&gt;</code>连接到代码的快捷方式。您必须使用出现在您的HTML中的准确名称，用破折号分隔，在第6行显示为<code class="fe mh mi mj mk b">dta-home</code>。此外，为您的类使用相同名称的camelCase版本是一个很好的实践，如第7行所示<code class="fe mh mi mj mk b">dtaHome</code>。</p><blockquote class="kw kx ky"><p id="3e14" class="kz la lb lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我为这些截图中丑陋的警告和曲线道歉。不必要的警告可以通过一些设置调整删除，但那是另一篇文章。这都是正确的代码，我保证！</p></blockquote><h1 id="751c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使组件可访问</h1><p id="ec7e" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">我在第2部分提到过，Lit的模块化来自于导入和导出组件和Typescript模块。为了防止“导入意大利面条”，我使用了模块加载器技术。加载器导出你写的所有模块。然后，只需要加载或导入模块加载器本身，就可以在任何地方使用完整的组件库。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/8301bbef115f26368c9f739114ea7cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*McZFEaADzQ19ae-mTmUQZQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">使用全局<strong class="bd ka">组件加载器</strong>意味着你只需要导入一个文件就可以访问你输出的HTML中的所有组件。</figcaption></figure><p id="dcc2" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">在您的全局文件夹下添加一个<code class="fe mh mi mj mk b">component-loader.ts</code>文件。现在，它只需要导出我们编写的单个组件(第9行)。</p><h1 id="9c69" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">将组件添加到页面</h1><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/3c647f0ff1c15140c9dbe7afd2da3e54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ifBa--V_BsyhTZP3N_CSXw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">最小的<strong class="bd ka">index.html</strong>页面包含我们的新组件<strong class="bd ka"> &lt; dta-home &gt; </strong>和一个组件加载器。</figcaption></figure><p id="7473" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">我们的页面查看器的<code class="fe mh mi mj mk b">index.html</code>文件与我们在第2部分中从Vite看到的示例组件没有什么不同。但是对于我们的通用组件加载器，它在<code class="fe mh mi mj mk b">&lt;body&gt;</code>中有一个<code class="fe mh mi mj mk b">&lt;script&gt;</code>加载，而不是在<code class="fe mh mi mj mk b">&lt;head&gt;</code>中加载一个特定的组件。</p><p id="d8c3" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">为了将未来的组件添加到我们的应用程序中，我们只需要从组件加载器中导出它们，而不是在<code class="fe mh mi mj mk b">index.html</code>中摆弄它们。</p><h1 id="6fff" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">查看我们的输出</h1><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/8ad271c0028141c302c99b17a07b8a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RqFssY_Y-LQGTBar019IpQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">我们使用第2部分中提到的阴影DOM来创建这个丑陋的大橙色文本。</figcaption></figure><p id="0e2c" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">在我们写作的时候，Vite应该一直在后台。让我们看看<a class="ae ly" href="https://localhost:3000" rel="noopener ugc nofollow" target="_blank"> https://localhost:3000 </a>并查看我们的页面。</p><h1 id="b93f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">又是那个影子DOM</h1><p id="e946" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">这里需要注意两件事。风格从何而来，内容从何而来。这个难看的大文本是我前面提到的阴影DOM的一个例子。它只活在这个组件里(谢天谢地)，不能把它的丑陋传播给其他任何人。下面是创建它的代码:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/7bb6bbf8081670902137e81eb669ba63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*NINrEdQjs1c-LoFgO7afeg.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">影子DOM接受一个以<strong class="bd ka"> css </strong>装饰开始的参数。</figcaption></figure><p id="8bf7" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">Lit中的<code class="fe mh mi mj mk b">static</code>变量不是从外部传递的(比如属性或值)。这里的<code class="fe mh mi mj mk b">css</code> decorator是针对<em class="lb">反斜线</em>写的，是“这东西是CSS”的一种快捷方式。<code class="fe mh mi mj mk b">:host</code>语法意味着它是这个 web组件<code class="fe mh mi mj mk b">&lt;dta-home&gt;</code>的CSS。最后，文本的<code class="fe mh mi mj mk b">em</code>大小表示“正常的倍数”所以这种字体是用户正常文本大小的两倍。在一个小例子中有四个很酷的技巧。无畏的程序员，请注意！</p><h1 id="88dd" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">你为什么满足？</h1><p id="1730" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">问候文本本身来自<code class="fe mh mi mj mk b">render()</code>功能。让我们来看看:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/a8e56b92bcf0c8e6aa8659dd11d1a79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*Y7CJTlUfHHUzfgVi_cp_ZA.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">render()函数应该使用装饰符和反勾符号返回<strong class="bd ka"> html </strong>或<strong class="bd ka"> svg </strong>。</figcaption></figure><p id="e3c0" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">正如我在第2部分中提到的，每次组件更新时，render函数都会运行。在这种情况下，每当有人访问或刷新<code class="fe mh mi mj mk b">index.html</code>时就会发生，因为我们的<code class="fe mh mi mj mk b">&lt;dta-home&gt;</code>组件是<code class="fe mh mi mj mk b">index</code>的子组件。</p><p id="2387" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">注意这里使用的<code class="fe mh mi mj mk b">html</code>装饰符和反勾符号(称为<a class="ae ly" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">标记的模板文字</a>)，可以在其中隐藏变量和函数。我们稍后将在页面组件中讨论这一点。</p><p id="8fad" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">这个HTML非常简单，它只是普通文本，甚至不是一个<code class="fe mh mi mj mk b">&lt;div&gt;</code>。我给你看这个是有原因的。您可以使用这种简单性来编写任何您喜欢的更复杂的东西，从输出图形和动画的定制SVG组件，或者像已经编写了HTML的视频播放器这样的预构建组件，您希望用Lit来“点亮”它们。</p><h1 id="faff" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">添加页面组件</h1><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/5aa6747ad93859865ced2d9a000bf849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*hmAcJzc1x4KPwwKBxT3A8Q.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">我们可以为我们的组件设计API或语法，只需编写一个用例，然后为它编码。</figcaption></figure><p id="ca4c" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">让我们的<code class="fe mh mi mj mk b">&lt;dta-home&gt;</code>组件返回一个显示我们想要的页面的<code class="fe mh mi mj mk b">&lt;dta-page&gt;</code>组件，而不是这个问候。我们可以首先搭建我们想要的组件，然后编写行为。因为我们还没有任何路由，所以我们将硬编码一个页面名称，然后使用URL中的内容。</p><h1 id="9419" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">编写页面组件</h1><p id="75cd" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">让我们添加一个新的<code class="fe mh mi mj mk b">dta-page.ts</code>文件，其中包含一些我们可以查看的内容。我刚刚粘贴并编辑了<code class="fe mh mi mj mk b">dta-home.ts</code>文件的内容，你也可以。这是我的:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/a93c2e48a668eb3e6191b650a527b65f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUKtH5yocUazzV--9W2BQg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">对于我的<strong class="bd ka"> &lt; dta-page &gt; </strong>组件，我只是稍微改变了一下样式，添加了一些硬编码输出。</figcaption></figure><p id="e8a8" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">定制web组件的默认行为是<strong class="lc ir">什么都不做</strong>。这允许你设计一个新的组件，而不需要先把它连接起来，只需要写一个你想用的新组件的例子。您的无线组件不会导致任何错误，但它也不会做任何事情。如果您没有看到来自定制组件的任何输出，请检查类名(上面的第6行和第7行)是否与您编写的元素名称相对应，以及组件定义文件是否已经加载。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8f66ba3bfdb3cd5f95f9e655ebfb5bdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*V6ZSsVaW5qkH5RhQTDcs-w.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">将新组件添加到加载器中，以便您的页面可以访问它。</figcaption></figure><p id="72af" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">不要忘记将新组件添加到您的<code class="fe mh mi mj mk b">component-loader.ts</code>中，然后检查您的浏览器，查看新的<code class="fe mh mi mj mk b">&lt;dta-page&gt;</code>组件在<code class="fe mh mi mj mk b">&lt;dta-home&gt;</code>中的呈现。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/0c757afb5dbb94de2ccf7946d089aa9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6S8xQgRUzukSAQmiKuzx4w.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated"><strong class="bd ka"> &lt; dta-page &gt; </strong>组件也是静态的，但时间不长！</figcaption></figure><h1 id="9cef" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">加入魔法！</h1><p id="3d6b" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">到目前为止，所有这些内容都非常静态，非常乏味。让我们创建一个包含两个页面的数据模型，我们可以通过键访问这两个页面。每个页面本身都是HTML，提供了我们需要的所有灵活性。然后，我们将通过查找组件的<code class="fe mh mi mj mk b">page=</code>属性的值来提供来自模型的内容。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/30f5b582c994d4267577461cc858584a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JzYF5WsobDqEVVt9W31T6w.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">页面组件现在可以考虑传递给它的参数或属性，并使用语法从模型数据中提取内容。</figcaption></figure><p id="27f7" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">为了方便起见，我们将模型数据定义保留在组件中。它实际上应该在modules文件夹中的Typescript模块中，我们可以在以后重构这段代码，将它移到那里。我们的模型是一个JSON对象，带有一个键和一个<code class="fe mh mi mj mk b">TemplateResult</code>值，意味着HTML或其他Lit自定义组件输出。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/25c636d4adffb28dc5d71d08a37a3f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*EK0Q-34_lliaYuIgzQqHjA.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">我们的模型只是同一个文件中的一个JSON常量，带有键和HTML值。</figcaption></figure><h1 id="b81e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">访问模型中的数据</h1><p id="3f68" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">为了访问我们写入到<code class="fe mh mi mj mk b">&lt;dta-page&gt;</code>元素中的<code class="fe mh mi mj mk b">page</code>属性的值，我们需要一个具有匹配名称的<code class="fe mh mi mj mk b">@property()</code>。这里我们设置了一个默认值，可以作为主页。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/c71267b3c1fc1d31a688066e8df5121e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*tADn5g2Wp4p8qYvRbJFohw.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated"><strong class="bd ka"> @property() </strong> decorator定义了可以在我们的<strong class="bd ka"> &lt; dta-page &gt; </strong>元素上传递的属性。在本例中，它是我们希望从<strong class="bd ka"> Pages </strong>对象中得到的键。未定义为属性的特性将被忽略。</figcaption></figure><p id="e2bf" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">最后，在<code class="fe mh mi mj mk b">render()</code>函数中，我们使用<code class="fe mh mi mj mk b">${expression}</code>语法通过键访问变量的值。在Lit中，关键字<strong class="lc ir"> <em class="lb">这个</em> </strong>总是指“这个组件”，所以<code class="fe mh mi mj mk b">this.page</code>就是这个组件的<code class="fe mh mi mj mk b">page</code>属性。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/4fb17f278e1f53a2d3c2e8bccd0f57dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*MO5CWiDYplviOjSNbl15Ng.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">通过在<strong class="bd ka"> ${} </strong>中编写一个表达式，模板文字(在反斜线内)可以运行任何函数或从模型中获取任何数据。这里，我们使用从组件的<strong class="bd ka">页面</strong>属性传递的键来访问模型中的<strong class="bd ka">页面</strong>对象。</figcaption></figure><p id="861d" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">尽管这是最简单、最糟糕的一种数据模型(因为它与组件本身结合在一起)，但这里的要点是，无论组件上下文中有什么数据，都是模型的一部分。最好的设计会调用一个远程函数(希望在<em class="lb">模块</em>文件夹中)，传递他们想要的键，并获取要显示的页面内容或计算页面内容所需的值。考虑如何设计您的应用程序来使用像Firebase这样的远程数据源，或者远程API调用的结果，然后向您的组件提供这些数据(理想情况下，只有您需要的部分)。</p><p id="41b6" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">需要注意的是，用<code class="fe mh mi mj mk b">html</code> decorator定义的变量实际上是HTML，所以您可以在那里编写完整的语言，就像在这个例子中，我修改了<code class="fe mh mi mj mk b">welcome</code>页面的定义，将一个单词加粗，并改变另一个单词的颜色。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/25c636d4adffb28dc5d71d08a37a3f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*EK0Q-34_lliaYuIgzQqHjA.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">Lit中的HTML值是真正的HTML，包含了该语言的全部功能，以及所有的自定义组件。</figcaption></figure><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/7f0d2464050bbd84b146a1eed1e657ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*or6xOS2VFE4dh2IV4Fsxrg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">变量定义中带有HTML内联样式的输出。</figcaption></figure><h1 id="6240" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">添加路由</h1><p id="b954" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated">我们说过希望页面查看器对URL做出反应。如果我们对第二页的密钥进行硬编码，我们可以验证底层的概念是否有效。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/0b17586656046a58b4ec34b8aaebff35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*5-_XuBI5F3UOptDDBHWzXw.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">回到<strong class="bd ka"> &lt; dta-home &gt; </strong>，对第二页进行硬编码。</figcaption></figure><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/9cbde1d9b2e99dfd34ca411a08d1c807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CqMqOqdKdZ5owGYDiwkWdg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">对第二页的视图进行硬编码。</figcaption></figure><p id="4694" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">因为我们所需要的就是这个键来显示正确的页面，所以我们可以把它添加到我们的URL中，然后去掉它。MDN文档说有一个<code class="fe mh mi mj mk b">document.location.pathname</code>会给我们一个URL中的“路径”或斜杠值的列表。如果我们取第一个，并把它作为我们的<code class="fe mh mi mj mk b">page=</code>值传递，我们就应该得到我们想要的！</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/640848bfc9f1753ce2c3d8dbb1894458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cwai9MKNWwBjQ9O3WyE80Q.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">我们将第一个路径赋给一个变量，然后将它用作页面属性，用默认值捕捉null。</figcaption></figure><p id="5fc4" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">在这里，我为空的<code class="fe mh mi mj mk b">pageKey</code>添加了一个陷阱，替换第25行的“欢迎”。即使我们在它的组件定义中有这个属性的默认值，这个默认值只在属性<em class="lb">没有被提供</em>(如果我们没有在元素上写<code class="fe mh mi mj mk b">page= </code>)时生效，而不是在你提供一个null或空值时生效。</p><h1 id="f476" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">秀出你的招式！</h1><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/2c50047f1816115144d2fa924170c216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SG7nLKGrwAwo8WymfE_2OQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">您的路由代码应该根据地址栏中的URL显示第二页。</figcaption></figure><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/31e6774c21a68a4cc8174c048532c33f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxGvZFnj9df4qUQYtxmh1A.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">没有斜杠组件的URL应该显示我们的默认页面，在<strong class="bd ka"> &lt; dta-home &gt; </strong>中指定。</figcaption></figure><h1 id="5696" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">现在你知道了！</h1><p id="27dc" class="pw-post-body-paragraph kz la iq lc b ld mc lf lg lh md lj lk lz me ln lo ma mf lr ls mb mg lv lw lx ij bi translated"><em class="lb"> Et voilá… </em>您已经使用一些最佳实践指南，从自定义组件构建了一个单页面应用程序，并且可以扩展到您想要的任何类型的应用程序或用户界面。我的<a class="ae ly" href="https://hexxedgame.com" rel="noopener ugc nofollow" target="_blank"> Hexxed </a>游戏，这里显示的，已经点亮了输出HTML的web组件，花哨的编程CSS(甚至跨组件共享CSS)，以及带有动画的<a class="ae ly" href="https://www.w3schools.com/graphics/svg_intro.asp" rel="noopener ugc nofollow" target="_blank"> SVG </a>。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/180b9cfee235f3b5d4d4bb9a72d9ec56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0GO16qH7-jAh9IXQkQ6Xw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">我的在线游戏Hexxed正是基于我在这里向你展示的内容，证明你可以用文学和网络组件制作各种应用，而不仅仅是“网站”</figcaption></figure><p id="d7bc" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">一如既往，感谢你的加入！如果有兴趣的话，我会在以后的文章中关注重构和扩展这个例子。</p><p id="4689" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated">保重！</p><p id="4e3e" class="pw-post-body-paragraph kz la iq lc b ld le lf lg lh li lj lk lz lm ln lo ma lq lr ls mb lu lv lw lx ij bi translated"><em class="lb"> — D </em></p></div></div>    
</body>
</html>