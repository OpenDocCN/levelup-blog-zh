<html>
<head>
<title>Typical TypeScript: Using Unions to Enforce Inputs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">典型的类型脚本:使用联合强制输入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typical-typescript-using-unions-to-enforce-inputs-2413abb12805?source=collection_archive---------21-----------------------#2020-07-21">https://levelup.gitconnected.com/typical-typescript-using-unions-to-enforce-inputs-2413abb12805?source=collection_archive---------21-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="82a1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用类型表达业务逻辑</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4997fdb8e4ff7656a498b71ea22af5c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zJUshIh3G9U_sI24CgaIhA.jpeg"/></div></div></figure><p id="47a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">今年早些时候，我被拉进了一些与CCPA有关的紧急工作中。简而言之，当相关的票据离开队列时，服务没有正确地关闭它们，这导致了大量手工工作的积压。对任何参与其中的人来说都毫无乐趣。</p><p id="9f1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在调查过程中，我发现我们发送的记录中有几个令人苦恼的错误:</p><ul class=""><li id="6b68" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp me mf mg mh bi translated">必需的<code class="fe mi mj mk ml b">serviceNowTaskId</code>在几个关键地方被拼错了(启动时不一致)。例如，<code class="fe mi mj mk ml b">servideNowTaskid</code>😬</li><li id="803c" class="lz ma it kw b kx mm la mn ld mo lh mp ll mq lp me mf mg mh bi translated">更糟糕的是，<code class="fe mi mj mk ml b">clientRequestId</code>(也是必要的)在每次通话中都完全消失了，这加剧了失败💨</li></ul><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="783e" class="mv mw it ml b gy mx my l mz na"><em class="nb">// An example of what this looked like in practice<br/></em>sendRecords({<br/>  records: [<br/>    {<br/>      status: 'OK',<br/>      payload: {<br/>        assetId: 12345,<br/>        servidenowTaskid: 'doomed for failure',<br/>        workNotes: 'What could go wrong?',<br/>      },<br/>    },<br/>  ],<br/>  topic: 'It be like this sometimes',<br/>});</span></pre><p id="c610" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，这个项目<em class="nb">是用TypeScript编写的</em>，所以我非常好奇为什么这在一开始就有可能。让我感到恐怖的是，对罪魁祸首接口的快速调查显示:</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="c6c2" class="mv mw it ml b gy mx my l mz na">export interface SendRecordRequest {<br/>  readonly records: ReadonlyArray&lt;any&gt;; 🤦‍♂️<br/>  readonly topic: string;<br/>}</span></pre><p id="4963" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可怕的<code class="fe mi mj mk ml b">any</code>！这解释了为什么最初没有类型检查来捕捉错误。很可能是一个仓促的特点，需要一点勤奋。</p><h2 id="0b87" class="mv mw it bd nc nd ne dn nf ng nh dp ni ld nj nk nl lh nm nn no ll np nq nr ns bi translated">充实类型并获得内心的平静</h2><p id="d023" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">我们绝对可以在这里的<code class="fe mi mj mk ml b">record</code>类型上多下一点功夫，为我们自己和未来的任何人省去许多痛苦。为了确保我们发送的所有记录都具有正确的属性，我创建了一个简单的界面，并在我的IDE中看到了所有生成的红色曲线…</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="cf80" class="mv mw it ml b gy mx my l mz na">export interface SendRecordRequest {<br/><strong class="ml iu">  readonly records: SnowRecord[]; // 😀 type-checked records!<br/></strong>  readonly topic: string;<br/>}</span><span id="01b3" class="mv mw it ml b gy ny my l mz na">// Flesh out the type for an individual record<br/>export interface SnowRecord {<br/>  status: 'OK';<br/>  payload: {<br/>    clientRequestId: string;<br/>    serviceNowTaskId: string;<br/>    status: SnowStatus;<br/>    workNotes?: string | null;<br/>  };<br/>};</span><span id="0172" class="mv mw it ml b gy ny my l mz na">// Idea, move common strings into an enum for easy refactors...<br/>export enum SnowStatus {<br/>  WIP = 'Work in Progress',<br/>  CLOSED = 'Closed Complete',<br/>  ...<br/>};</span></pre><p id="7b45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这导致编译器在<code class="fe mi mj mk ml b">serviceNowTaskId</code>和其他属性被拼错的地方立即发出警告，如果我们缺少一个状态，包括一些意想不到的东西，以及所有其他来自TypeScript的一般优点，如自动完成建议。</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="ab63" class="mv mw it ml b gy mx my l mz na">// The new developer experience!<br/>sendRecords({<br/>  records: [<br/>    {<br/>      status: 'OK',<br/>      payload: { <strong class="ml iu">🚨 TS error, no `status`!</strong><br/>        assetId: 12345,<br/>        clientRequestId,<br/>        servicenowTaskid: snowId, <strong class="ml iu">🚨 TS error, unexpected prop!</strong><br/>        workNotes: "Wow, that's handy",<br/>      },<br/>    },<br/>  ],<br/>  topic: 'Confidence!',<br/>});</span></pre><p id="0fc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，世界的这一小块地方一切都很好，很正常。</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><h2 id="988f" class="mv mw it bd nc nd ne dn nf ng nh dp ni ld nj nk nl lh nm nn no ll np nq nr ns bi translated">新的要求来了</h2><p id="5111" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">在我解决了这个令人尴尬的问题后不久，来自管理层的新要求是给我们的有效载荷添加一个强制性的“闭包代码”。这将让他们更深入地了解票证被关闭的原因。很公平，但是如果一个给定的标签被设置为<code class="fe mi mj mk ml b">CLOSED</code>，那么包含关闭代码<em class="nb">只有</em>才有意义；你不会想让它出现在正在进行的票据上的！此外，如果记录包含关闭代码和非关闭状态，队列将拒绝该记录。</p><p id="ed29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这给我刚刚制作的干净、简单的界面带来了一个问题，也给我想让代码帮助指导未来落入这一领域的开发人员的梦想带来了问题。我当然可以给有效载荷添加一个<code class="fe mi mj mk ml b">closureCode?: string</code>，然后就结束了，但是这样我们就不会强制执行<code class="fe mi mj mk ml b">closureCode</code>和<code class="fe mi mj mk ml b">status</code>之间的关系。我可以只添加评论，但我想做得更好。</p><h2 id="4590" class="mv mw it bd nc nd ne dn nf ng nh dp ni ld nj nk nl lh nm nn no ll np nq nr ns bi translated">等等，我们可以用工会</h2><p id="6658" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">让我们来看看一个简单的方法，然后清理它！</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="1252" class="mv mw it ml b gy mx my l mz na">export interface SnowRecord {<br/>  status: 'OK';<br/><strong class="ml iu">  payload: SnowPayloadWip | SnowPayloadClosed;<br/></strong>}</span><span id="2561" class="mv mw it ml b gy ny my l mz na">interface SnowPayloadWip {<br/>  assetId: number;<br/>  serviceNowTaskId: string;<br/>  status: SnowStatus.WIP;<br/>  workNotes?: string | null;<br/>}</span><span id="c51c" class="mv mw it ml b gy ny my l mz na">interface SnowPayloadClosed {<br/>  assetId: number;<br/>  serviceNowTaskId: string;<br/>  status: SnowStatus.CLOSED;<br/>  workNotes?: string | null;<br/>  closureCode: SnowClosureCode;<br/>}</span></pre><p id="3022" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在实践中，用法也非常巧妙！</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="ed07" class="mv mw it ml b gy mx my l mz na">sendRecords({<br/>  records: [<br/>    {<br/>      status: 'OK',<br/>      payload: { <strong class="ml iu">🚨 TS error, expected `closureCode`</strong><br/>        assetId: 12345,<br/>        clientRequestId,<br/>        serviceNowTaskId: snowId,<br/>        status: SnowStatus.CLOSED,<br/>        workNotes: "Wow, that's handy",<br/>      },<br/>    },<br/>  ],<br/>  topic: 'Flexibility!',<br/>});</span><span id="6ce4" class="mv mw it ml b gy ny my l mz na">// Alternatively<br/>sendRecords({<br/>  records: [<br/>    {<br/>      status: 'OK',<br/>      payload: {<br/>        assetId: 12345,<br/>        clientRequestId,<br/>        serviceNowTaskId: snowId,<br/>        status: SnowStatus.WIP,<br/>        closureCode: SnowClosureCode.NO_DATA, <strong class="ml iu">🚨 TS error!</strong><br/>      },<br/>    },<br/>  ],<br/>  topic: 'Flexibility!',<br/>});</span></pre><p id="f032" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从有效载荷的角度来看这个问题，我想说的关键点是:</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="8dc9" class="mv mw it ml b gy mx my l mz na">payload: SnowPayloadWip | SnowPayloadClosed</span></pre><p id="4d05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">这是一个两种类型的<em class="nb">联合</em>，这意味着<code class="fe mi mj mk ml b">payload</code>可以是<em class="nb">WIP形状或闭合形状(或者更多，如果我们扩展联合！)，但不能两者兼而有之。这对于我们的情况来说是完美的，因为当开发人员试图创建无效的属性组合时，它会发出警告！例如，如果一个开发人员试图编写一个代码块，发送一个状态为WIP <em class="nb">的记录，并且</em>包含一个结束代码，他们会从IDE中得到一个关于<code class="fe mi mj mk ml b">closureCode</code>是一个意外属性的警告！同样，如果状态是closed，他们会因为没有包含<code class="fe mi mj mk ml b">closureCode</code>而收到警告。</em></p><p id="936c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是可行的，但是那些界面看起来非常重复，作为开发者，我们讨厌不必要的重复！</p><h2 id="0602" class="mv mw it bd nc nd ne dn nf ng nh dp ni ld nj nk nl lh nm nn no ll np nq nr ns bi translated">干的时候！</h2><p id="8196" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">使用一点额外的TypeScript-fu，我们可以<a class="ae og" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">通过创建所有公共属性的基本接口，然后用我们需要的每种组合的配置来扩展它，从而完成这个任务。</a></p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="bc4c" class="mv mw it ml b gy mx my l mz na">interface SnowPayload {<br/>  assetId: number;<br/>  serviceNowTaskId: string;<br/>  status: SnowStatus;<br/>  workNotes?: string | null;<br/>}</span><span id="7513" class="mv mw it ml b gy ny my l mz na">interface SnowPayloadWip extends SnowPayload {<br/>  status: SnowStatus.WIP;<br/>}</span><span id="664a" class="mv mw it ml b gy ny my l mz na">interface SnowPayloadClosed extends SnowPayload {<br/>  status: SnowStatus.CLOSED;<br/>  closureCode: SnowClosureCode;<br/>}</span></pre><p id="172d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们扩展了<code class="fe mi mj mk ml b">SnowPayload</code>，这些新接口中的每一个都包含了它的属性，并且还可以覆盖它们原来的定义(比如<code class="fe mi mj mk ml b">status</code>)或者添加其他的。这移除了两个接口之间的重复属性，并且更简洁地描述了唯一的位！</p><p id="0967" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总的来说，结果如下所示:</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="35ae" class="mv mw it ml b gy mx my l mz na">export interface SendRecordRequest {<br/>  readonly records: SnowRecord[];<br/>  readonly topic: string;<br/>}</span><span id="2180" class="mv mw it ml b gy ny my l mz na">export interface SnowRecord {<br/>  status: 'OK';<br/>  payload: SnowPayloadWip | SnowPayloadClosed; ✨<br/>}</span><span id="224e" class="mv mw it ml b gy ny my l mz na">interface SnowPayload {<br/>  assetId: number;<br/>  serviceNowTaskId: string;<br/>  status: SnowStatus;<br/>  workNotes?: string | null;<br/>}</span><span id="4ea6" class="mv mw it ml b gy ny my l mz na">interface SnowPayloadWip extends SnowPayload {<br/>  status: SnowStatus.WIP;<br/>}</span><span id="b68c" class="mv mw it ml b gy ny my l mz na">interface SnowPayloadClosed extends SnowPayload {<br/>  status: SnowStatus.CLOSED;<br/>  closureCode: SnowClosureCode;<br/>}</span><span id="91a5" class="mv mw it ml b gy ny my l mz na">export enum SnowStatus {<br/>  WIP = 'Work in Progress',<br/>  CLOSED = 'Closed Complete',<br/>  ...<br/>}</span><span id="95b1" class="mv mw it ml b gy ny my l mz na">export enum SnowClosureCode {<br/>  ...<br/>}</span></pre></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="0aa9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这有点长，但希望现在您对TypeScript如何帮助捕捉您自己或您团队的代码中的错误有了一点点的了解。此外，我希望这可以作为一个真实世界的例子，说明如何使用联合来严密地描述软件约束，让您的IDE保护您不犯业务逻辑错误，并且如果您的团队成员不得不用比您更少的上下文来维护代码，也可以帮助他们避免类似的问题😃。</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="fc9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">欲了解更多直接来自ts中工会来源的趣闻，<a class="ae og" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types" rel="noopener ugc nofollow" target="_blank">请查看文档</a>！</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="e478" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有更好的解决方案吗？觉得我能把这篇文章写得更好吗？在评论或消息中让我知道；我总是乐于接受更多的学习！</p></div></div>    
</body>
</html>