# 将 Saga 建模为状态机:管理分布式和长时间运行的事务的 orchestrator 驱动方法

> 原文：<https://levelup.gitconnected.com/modelling-saga-as-a-state-machine-cec381acc3ef>

这篇文章描述了在微服务生态系统中管理分布式和长时间运行的事务的架构和概念框架。本文主要讨论分布式事务面临的挑战以及如何有效地解决这个问题。

![](img/edd320719e6a283574892e3f67cc5125.png)

# 概观

微服务，在其真正的上下文中，是一个分布式系统。一个事务被分配给多个服务，这些服务被顺序或并行调用以完成整个事务。在微服务架构中，单个服务中的事务使用 ACID 事务来提供数据一致性。然而，挑战在于处理跨多个服务的事务，在某些情况下需要很长时间才能完成。在这种情况下，应用程序必须使用复杂的机制来管理事务。

# 方案

考虑一个使用微服务架构实现的简单机票预订场景。将会有一个微服务阻塞座位，另一个接受付款，最后，另一个微服务分配阻塞的座位，每个微服务实现一个本地事务。要成功完成旅行者的航班预订流程，必须完成所有三个步骤。如果任何一个步骤失败，前面完成的所有步骤都必须回滚。因为整个事务边界跨越多个服务和数据库，所以它被认为是一个分布式事务。

![](img/f32bcc54ea4d39f31ed527260187b260.png)

考虑通过微服务方法实现的订单履行的另一个场景。工作流事务从订单服务开始，首先创建订单，然后转到下一个服务进行支付，然后为事务创建发票，之后发送发货，最后订单交付并完成工作流，同样每个都实现本地事务。这里的订单处理实际上是分布式的，完成工作流程可能需要几天到几周的时间。这种事务可以称为长时间运行的事务，因为所有步骤不能一次执行，并且使用传统的 ACID 事务语义。

![](img/25895b28ab36bc7a3db392a809f9f169.png)

# 挑战

随着微服务架构的出现，关于分布式事务管理有两个关键问题:

*   原子性:原子性意味着事务中的所有步骤都必须成功，或者如果某个步骤失败，那么之前完成的所有步骤都应该回滚。然而，在微服务架构中，一个事务可以由不同微服务处理的多个本地事务组成。因此，如果其中一个本地事务失败，如何回滚以前完成的成功事务？
*   隔离:事务隔离级别指定了事务中一个语句可见的数据量，特别是当多个服务调用同时访问同一个数据源时。如果来自任何一个微服务的对象被持久化到数据库，而另一个请求同时读取相同的对象，那么服务应该返回旧数据还是新数据？

为了解决这些问题并提供有效的事务管理能力，可以采用两种方法:

*   两阶段提交(2PC)
*   冒险故事

# 2PC

跨多个服务维护数据一致性的传统方法是使用分布式事务。这方面的实际标准是 2PC(两阶段提交)。2PC 确保事务中的所有参与者不是提交就是回滚。它分两个阶段工作，第一阶段称为准备阶段，控制节点询问所有参与节点是否准备好提交，第二阶段称为提交阶段，如果所有节点的回答都是肯定的，则控制节点要求它们提交，否则回滚。尽管 2PC 可以帮助在分布式系统中提供事务管理，但它也成为了单点故障，因为事务的责任落在了协调器的身上，而且这种协调器的典型实现本质上是同步的，这可能会导致未来吞吐量的降低。因此，2PC 仍然有以下缺点:

*   像 MongoDB 和 Cassandra 这样的现代 NoSQL 数据库不支持它们。
*   像 Apache Kafka 这样的现代消息代理不支持它们。
*   同步 IPC 降低了可用性。
*   所有的参与者都必须到场。

# 冒险故事

为了解决在微服务架构中维护数据一致性这一更复杂的问题，应用程序必须使用一种不同的机制，这种机制建立在松耦合、异步服务的概念之上。这就是传奇故事的由来。Saga 是一种架构模式，它提供了一种优雅的方法来实现跨多个服务的事务，本质上是异步和反应式的。因此，可以将 saga 定义为事件驱动的本地事务序列，其中每个本地事务更新数据库并发布命令或事件来触发 saga 中的下一个本地事务。如果本地事务由于违反业务规则而失败，那么 saga 将执行一系列补偿事务，这些补偿事务将撤销之前的本地事务所做的更改。saga 实现确保执行所有事务或撤消所有更改，从而提供原子性保证。将 saga 设计为状态机模型将提供处理隔离的对策。

![](img/9d9289139db7edb0fd61328277a5b63d.png)

# 传奇模式有什么帮助

使用微服务架构，单个业务流程将多个微服务集合在一起，以提供整体解决方案。使用微服务架构实现 **ACID** (原子性、一致性、隔离性、持久性)事务非常困难，在某些情况下是不可能的。例如，在前面提到的机票预订场景中，具有 block seat 功能的微服务不能获得支付数据库的锁，因为在大多数情况下它可能是一个外部服务。但是仍然需要某种形式的事务管理，这种事务被称为 ***基本*** 事务: **B** 基本 **A** 可用， **S** oft 状态， **E** 最终一致。必须采取补偿措施来恢复作为事务一部分发生的任何事情。下面，我们可以看到一个传奇故事是如何在前面提到的机票预订场景中可视化的。

![](img/464dd6f1c3b2fba4e1605de8057ccbaf.png)

# 补偿交易

当 saga 的某个步骤由于违反业务规则而失败时，saga 必须通过执行补偿事务来显式撤销之前步骤所做的更新。假设一个 saga 的第( *n* + 1)笔交易失败。之前的 *n* 交易的影响必须撤销。从概念上讲，每个步骤 Ti 都有一个相应的补偿事务 Ci，它撤消 Ti 的影响。要取消前 *n* 步的效果，saga 必须以相反的顺序执行每个 Ci。步骤顺序是 T1 … Tn，Cn … C1，如图所示。在本例中，Tn+1 失败，这需要撤消步骤 T1 … Tn。saga 以与远期交易相反的顺序执行补偿交易:Cn … C1。对 ci 进行排序的机制与对 ti 进行排序没有任何不同。Ci 的完成必须触发 Ci-1 的执行。

![](img/4ce01e3df96468f3f28f274d45abba82.png)

# 透视和可重试的交易

下表显示了航班预订过程中每一步的补偿交易。机票预订传奇的三个步骤被称为补偿交易，因为接下来的步骤可能会失败。还需要注意的是，并非所有步骤都需要补偿事务。在 saga 模式中还有两种其他的事务类型，一种是 Pivot 事务，它就像 saga 中的 go/no-go 点。如果 pivot 事务提交，saga 将一直运行到完成。另一种是可重试交易*、*跟随枢纽交易并保证成功的交易。

![](img/4ad4e160a5618ca918001418fc4d5ad2.png)

# 世家担保

分布式传奇保证了以下两种结果之一。要么成功完成 saga 中的所有请求，要么执行请求及其补偿请求的子集。请求和补偿请求都需要遵守某些原则:

*   单个事务可以中止，并且必须是幂等的。
*   补偿事务必须是幂等的、可交换的，并且不能中止(必须无限期重试，或者在必要时通过手动干预解决)。

# Saga 协调策略

saga 执行协调员(SEC)是实施成功 Saga 流程的核心组件。Saga 协调可以在以下情况下实施:

*   **编排** —在 saga 参与者之间分配决策和排序。换句话说，参与者在没有集中控制点的情况下交换事件，并且每个本地事务发布触发其他服务中的本地事务的域事件。虽然 saga 编排是简单可靠的基于事件的通信，但是它对于简单的用例是理想的，并且有一些限制，这使得它不是管理分布式事务的理想候选。基于编排的传奇很难理解，经常产生循环依赖，而且传奇参与者之间存在紧密耦合的风险。

![](img/e9f74bd5e45c6e8f8425e01a58e623a8.png)

*   **编排—** 将 saga 的协调逻辑集中在一个 saga orchestrator 类中。saga 协调人员向 saga 参与者发送命令，并对事件结果采取行动。orchestrator 执行 saga 请求，存储和解释每个任务的状态，并使用补偿事务处理故障恢复。基于 Orchestrator 的 sagas 更适合复杂的事件处理，是管理分布式事务的理想选择。

![](img/377935e9d20747acc139af7aa321ff2f.png)

# 佐贺管弦乐团

正如 Saga“编排”模式所建议的，有一个单一的编排器组件负责管理整个流程工作流。使用编排时，定义一个编排器类，它的唯一职责是告诉 saga 参与者做什么。saga orchestrator 使用命令/异步回复式交互与参与者交流。为了执行 saga 步骤，它向参与者发送命令消息，告诉它要执行什么操作。saga 参与者执行完操作后，会向编制者发送回复消息。然后，编排器处理该消息，并确定下一步执行哪个 saga 步骤。

![](img/38c1d45f9bc0b0aa415c04c8485b311b.png)

上图显示了基于编排的航班预订传奇版本的设计。SagaOrchestrator 组件对 saga 进行编排，该组件使用异步请求/响应调用 saga 参与者。Saga orchestrator 跟踪流程，并通过命令生成器组件向 Saga 参与者发送命令操作，如 SeatBlockingService 和 PaymentService，并通过事件处理器从其回复通道读取回复消息，然后确定 saga 中的下一步(如果有)。快乐日传奇之路的步骤如下:

1.  前端 UI 向 saga orchestrator 发送座位预订请求。
2.  saga orchestrator 启动新的工作流程，并向 SeatBlockingService 发送 SeatBlockingCommand。
3.  SeatBlockingService 处理命令，并使用 SeatBlockedEvent 进行回复。
4.  saga orchestrator 触发工作流中的下一个操作，并向 PaymentService 发送 PaymentRequestCommand。
5.  PaymentService 用 PaymentSuccessEvent 进行回复。
6.  然后，saga orchestrator 向 SeatAllocationService 发送 SeatAllocationCommand。
7.  SeatAllocationService 用 SeatAllocatedEvent 进行回复。
8.  saga orchestrator 结束事务并完成工作流程。

但是，由于 SeatBlockingService、PaymentService 或 SeatAllocationService 中的一个故障，整个航班预订场景可能会失败。为了有效地管理工作流和处理故障，建议将 saga 建模为状态机，因为它描述了所有可能的场景，并让 orchestrator 确定需要执行什么操作。

# 作为国家机器的佐贺

将 saga orchestrator 建模为状态机不仅是管理分布式事务的有效方法，也是支持长期运行的业务事务的有效方法。状态机由一组状态和一组由事件触发的状态之间的转换组成。每个转换都可以有一个动作，对于一个 saga 来说就是调用一个 saga 参与者。状态之间的转换由 saga 参与者执行的本地交易的完成触发。本地事务的当前状态和特定结果决定了状态转换和要执行的动作(如果有的话)。因此，使用状态机模型使得设计、实现和测试 sagas 变得更加容易。

![](img/feab281c639b0f8872f5797181c6f8a6.png)

上图突出显示了机票预订的状态机模型。该状态机由许多状态和转换组成，包括:

*   订单打开—初始状态。Saga 在工作流程开始时设置此状态。
*   阻塞座位—在此状态下，saga 等待 SeatBlockingService 阻塞座位进行预订。
*   授权支付 saga 正在等待 PaymentService 对支付授权命令的回复。
*   分配座位—支付成功后，等待 SeatAllocationService 分配座位。
*   反向支付-如果座位分配失败，saga 将发送退款请求。
*   解锁席位—如果支付授权失败，saga 将向解锁席位发送失败事件。
*   订单完成——表示传奇成功完成的最终状态。
*   订单被拒绝——最终状态，表示订单被其中一个参与者拒绝。

![](img/d2fb0fc93bc9cfe8979141427e70c551.png)

最后，saga 工作流可以重新设计为 saga 状态机，如下所示。saga orchestrator 链接到一个状态机，该状态机负责通过状态管理器 API 管理事务状态。除此之外，它还负责将事务状态存储在持久数据存储中，以确保系统故障发生时的恢复。因此，saga 状态机有责任完成整个业务事务，或者让系统处于已知状态，以便它可以确定潜在执行下一个动作状态或补偿活动的顺序，无论发生的事务是自然分布的还是长期存在的。

# 优势和潜在使用案例

*   **更简单的依赖关系—**saga orchestrator 调用 saga 参与者，但参与者不调用 orchestrator。因此，编排者依赖于参与者，而不是相反，所以没有循环依赖。
*   **耦合度更低—** 每个服务都实现了一个由 orchestrator 调用的 API，因此它不需要知道 saga 参与者发布的事件。
*   **关注点分离—**saga 协调逻辑在 saga orchestrator 中本地化。领域对象更简单，不知道它们参与的故事。
*   **数据一致性—** 保持多个微服务之间的数据一致性，无需紧密耦合。
*   **开发人员体验—** 设计允许开发人员只关注 saga 参与者的业务逻辑，并简化 saga orchestrator 上有状态工作流的实施。

可以实现这种实现的几个潜在用例:

1.  订单管理系统

*   电子商务
*   食品配送
*   机票预订
*   酒店/出租车预订

2.结算交易。

# 指导方针和建议

如果我们正在设计和构建 orchestrator 驱动的 saga 以支持分布式和长时间运行的事务，建议遵循以下指导原则:

1.  Orchestrator 应该只负责管理事务和状态，这里不应该添加任何业务逻辑。业务逻辑应该在单个服务参与者中定义。
2.  所有进出 orchestrator 的事件和命令应该只携带事务数据，而不是引用数据。
3.  使用异步风格的消息传递在服务之间进行通信。
4.  如果使用像 Kafka 这样的消息代理，实现幂等性和弹性状态检查。
5.  适用于设计 CQRS 中的命令端(写模型)和事件源架构。

## **参考文献**

[T3【https://learning . oreilly . com/library/view/microservice-patterns/9781617294549](https://learning.oreilly.com/library/view/microservices-patterns/9781617294549/)

[*https://developer . IBM . com/dep models/micro services/articles/use-saga-to-solve-distributed-transaction-management-problems-in-a-micro services-architecture*](https://developer.ibm.com/depmodels/microservices/articles/use-saga-to-solve-distributed-transaction-management-problems-in-a-microservices-architecture/)