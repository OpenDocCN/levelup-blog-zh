<html>
<head>
<title>A Practical Guide to Higher Order Functions in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#高阶函数实用指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-practical-guide-to-higher-order-functions-in-c-efdd5fa4a439?source=collection_archive---------3-----------------------#2021-07-03">https://levelup.gitconnected.com/a-practical-guide-to-higher-order-functions-in-c-efdd5fa4a439?source=collection_archive---------3-----------------------#2021-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/922b00113a5d5d4d7d776c692e312367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pjqdg7kdttRQE-0y"/></div></div></figure><p id="1ece" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你已经编程一段时间了，你可能会遇到高阶函数，但是(像我一样)可能没有完全意识到它们有多强大。如果你以前没有听说过他们，不要害怕，我在下面有一个解释。</p><h1 id="5eac" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是高阶函数？</h1><p id="a2cc" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">简单来说，高阶函数就是输入或输出也是函数的函数。</p><p id="955f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的示例中，Map函数获取一个特定数据类型和一个函数的列表，并返回一个新列表，该列表中的每个元素都应用了该函数(基本上等同于LINQs Select方法)。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="78f0" class="mi kx iq me b gy mj mk l ml mm">// definition<br/>List&lt;TOut&gt; Map&lt;TIn, TOut&gt;(List&lt;TIn&gt; list, Func&lt;TIn, TOut&gt; mapper)<br/>{<br/>    var newList = new List&lt;TOut&gt;();<br/>    foreach (var item in list)<br/>    {<br/>        var newItem = mapper(item);<br/>        newList.Add(newItem);<br/>    }</span><span id="100d" class="mi kx iq me b gy mn mk l ml mm">return newList;<br/>}</span><span id="18fa" class="mi kx iq me b gy mn mk l ml mm">// usage<br/>var myList = new List&lt;int&gt; { 1, 2, 3, 4, 5 };</span><span id="0b27" class="mi kx iq me b gy mn mk l ml mm">int multiplyBy2 (int num) =&gt; num * 2;<br/>var multipliedList = Map(myList, multiplyBy2);<br/>// output { 2, 4, 6, 8, 10 };</span><span id="2a3d" class="mi kx iq me b gy mn mk l ml mm">bool isEven (int num) =&gt; num % 2 == 0;<br/>var isEvenList = Map(myList, isEven);<br/>// output { false, true, false, true, false };</span></pre><p id="2125" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个返回函数的高阶函数的示例。首先用一个给定的整数调用Add函数，它返回一个函数，将第一个整数与任何给定的其他整数相加。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="2ca2" class="mi kx iq me b gy mj mk l ml mm">Func&lt;int, int&gt; Add(int a) =&gt; (int b) =&gt; a + b;<br/>  <br/>var add9 = Add(9);<br/>  <br/>var sum1 = add9(1);<br/>// output 10</span><span id="0c88" class="mi kx iq me b gy mn mk l ml mm">var sum2 = add9(2);<br/>// output 11</span></pre><p id="4be2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望现在你能明白为什么高阶函数如此有用；通过让客户端定义自己的输入/输出函数，它们允许以高度灵活的方式重用复杂的代码。例如，如果不使用高阶函数，就必须为他们需要的每一种映射类型定义一个新的映射函数。</p><h1 id="21fb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">实际例子—存储库模式</h1><p id="8bf7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">存储库模式是一种非常常见的设计模式，用作数据访问抽象。它允许您执行典型的CRUD操作，而无需客户端直接与数据提供者交互。典型的存储库界面可能如下所示:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="16a1" class="mi kx iq me b gy mj mk l ml mm">public interface IProductRepository<br/>{<br/>    int Create(Product product);<br/>    bool Update(Product product);<br/>    bool Delete(int id);<br/>    Product GetById(int id);<br/>    IEnumerable&lt;Product&gt; GetAll();<br/>    IEnumerable&lt;Product&gt; GetByCategoryId(int categoryId);<br/>    IEnumerable&lt;Product&gt; GetActive();<br/>    // etc...<br/>}</span></pre><p id="a833" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在这个典型示例中看到的，有许多定义都返回<code class="fe mo mp mq me b">IEnumerable&lt;Product&gt;</code>，每次您需要另一种特定类型的产品过滤器时，都需要添加到接口中并编写一个全新的实现。这对可维护性不好...</p><p id="e474" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，使用更高阶的函数，我们可以定义一个单独的方法来获取接受一个过滤函数作为输入的<code class="fe mo mp mq me b">IEnumerable&lt;Product&gt;</code>。这样，客户端可以自由定义自己的过滤器，并且ProductRepository不需要不断更新新的实现。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="b9e7" class="mi kx iq me b gy mj mk l ml mm">interface IProductRepository<br/>{<br/>    // create, update, delete omitted<br/>    <br/>    IEnumerable&lt;Product&gt; Get(Func&lt;Product, bool&gt; filter = null);<br/>}</span><span id="6619" class="mi kx iq me b gy mn mk l ml mm">public class ProductRepository : IProductRepository<br/>{<br/>    private readonly List&lt;Product&gt; _products = new List&lt;Product&gt;(); // data source</span><span id="2af3" class="mi kx iq me b gy mn mk l ml mm">public IEnumerable&lt;Product&gt; Get(Func&lt;Product, bool&gt; filter = null)<br/>    {<br/>        // typically you might use the LINQ Where method here<br/>        // but using the foreach to be clear what is happening</span><span id="8f81" class="mi kx iq me b gy mn mk l ml mm">if (filter is null) return _products;</span><span id="07bf" class="mi kx iq me b gy mn mk l ml mm">var filteredList = new List&lt;Product&gt;();<br/>        foreach(var product in _products)<br/>        {<br/>            if(filter(product))<br/>            {<br/>                filteredList.Add(product);<br/>            }<br/>        }</span><span id="89c2" class="mi kx iq me b gy mn mk l ml mm">return filteredList;<br/>    }<br/>}<br/></span><span id="6bdc" class="mi kx iq me b gy mn mk l ml mm">// client code<br/>var allProducts = _productRepository.Get();<br/>var productsByCategoryId = _productRepository.Get(p =&gt; p.CategoryId == 1);<br/>var activeProducts = _productRepository.Get(p =&gt; p.Active);</span></pre><h1 id="926a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="aac7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在本文中，我介绍了高阶函数的概念，并展示了它们在创建易于维护和理解的可重用且灵活的代码时是多么有用。我还给出一个实际的用例，您可能会在. NET企业应用程序中找到——使存储库模式更加可重用。</p><p id="ebaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发布的大部分内容都是关于全栈的。NET和Vue web开发。为了确保你不会错过任何帖子，请关注这个博客并<a class="ae mr" href="https://samwalpole.com" rel="noopener ugc nofollow" target="_blank">订阅我的简讯</a>。如果你觉得这篇文章有帮助，请喜欢它并分享它。你也可以在<a class="ae mr" href="https://twitter.com/dr_sam_walpole" rel="noopener ugc nofollow" target="_blank">推特</a>上找到我。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="bf38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mz">最初发表于</em><a class="ae mr" href="https://samwalpole.com/a-practical-guide-to-higher-order-functions-in-c" rel="noopener ugc nofollow" target="_blank"><em class="mz">【https://samwalpole.com】</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>