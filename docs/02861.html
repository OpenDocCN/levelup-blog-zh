<html>
<head>
<title>Threads, Promises, Channels: Fundamentals in Asynchronous Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线程、承诺、通道:异步编程的基础</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/threads-promises-channels-1c8e86595286?source=collection_archive---------22-----------------------#2020-04-07">https://levelup.gitconnected.com/threads-promises-channels-1c8e86595286?source=collection_archive---------22-----------------------#2020-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9c0b7e69e2c288c66b25b52ea4081195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QJ9uSNYwJEoUbjCf"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@jpvalery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jp Valery </a></figcaption></figure><h1 id="15b3" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="02dc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">编写后端和前端代码时，经常需要异步编程。然而，不同的编程语言公开了执行异步任务的不同范例。本文将讨论的三个范例是线索、承诺和渠道。作为演示，我使用<a class="ae kc" href="https://pokeapi.co/" rel="noopener ugc nofollow" target="_blank"> PokéAPI </a>获取关于口袋妖怪的信息。示例代码发出一个初始请求来获取前10个Pokemon的URL，然后发出10个并行请求来获取详细信息。</p><h1 id="b1a4" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">线</h1><p id="d7a8" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">要理解线程，需要一些关于线程含义的背景知识。要理解什么是线程，我们必须首先理解进程。流程是一个程序。一个进程有自己的(虚拟)内存，独立于其他进程。一个进程有一个或多个线程。操作系统将在每个正在运行的进程之间公平地切换，以便所有进程都有公平的执行机会。现在，一个线程就像一个进程，有一个关键的区别，一个线程与进程中的其他线程共享内存。因此，借助线程的力量，单个进程(即程序)可以在相同的可用内存下同时执行多个任务。</p><p id="d4a8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在我们的例子中，我们使用线程来执行那些大部分时间都在网络上等待的任务。具体来说，示例中的每个线程调用函数“fetchPokemon ”,该函数将花费大部分时间等待网络请求完成。因此，通过并发运行这些I/O请求，我们的程序变得更加高效，因为我们可以在收到任何响应之前启动每个请求。</p><p id="d166" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">虽然线程是一个强大的工具，但也有一些困难需要警惕。首先，共享内存是众所周知的竞争条件错误的来源。为了避免这些错误，使用了互斥(即锁)。但是，如果程序员不小心的话，互斥可能会导致性能下降和死锁。因此，尽可能避免共享数据通常被认为是最佳实践。最后，重要的是要认识到不要过度使用线程。仅仅因为某个东西可以在一个单独的线程上并发运行，并不意味着这样做会提高性能。此外，由于操作系统必须执行上下文切换，因此在使用线程时还会有性能开销。俗话说，不要过早优化。</p><p id="9051" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下面是一个在C++中使用线程的例子。您可能会在Java和Python等语言中看到类似的代码。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="ca89" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">承诺</h1><p id="e914" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">承诺是一种在不直接使用线程和共享数据的情况下编排异步任务的方式。虽然promise语法出现在许多语言中，但我将从JavaScript/Node上下文中描述promise。</p><p id="2258" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在Node中，承诺通过事件循环工作。要理解这一点，重要的是要理解操作系统如何处理通常被承诺的任务。当你的程序执行I/O时，这被认为是一种特权操作，只有操作系统本身才能执行。因此，你的程序会要求操作系统代表你的程序进行I/O。现代操作系统提供阻塞和非阻塞接口来执行这些特权操作。在过去，存在的只是阻塞接口。因此，当您的程序发出I/O请求时，您的线程将被阻塞，直到操作系统完成操作。阻塞接口就是上面的C++例子中使用的接口。使用非阻塞接口，您的程序将请求排入操作系统，您的线程立即继续执行。稍后，操作系统会通知你的程序特权操作已经完成。在Node中，这些通知用于推动事件循环，并通过扩展来实现承诺。</p><p id="3340" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">promise语法支持异步任务的迭代式编程。此外，在有I/O需求的环境中，promises支持单线程环境，消除了共享数据错误的可能性。</p><p id="9204" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下面是一个在TypeScript中使用promises的例子。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="a26a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">频道</h1><p id="7e32" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们异步编程的最后一个范例是通道。与线程和承诺不同，渠道是一个抽象的话题。使用通道，异步编程是以发布者/订阅者的方式对数据流进行的。虽然这个概念出现在许多语言和库中(比如Kotlin和RxJava)，但我们将从Go的角度来探讨这个概念。</p><p id="30b7" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在Go中，有一个goroutine的概念，它是线程的抽象。要在goroutines之间进行通信，可以使用“共享数据”(带锁)或通道。一个goroutine可以写入一个通道，当另一个goroutine同时监听时，数据通过该通道在go routine之间传输。</p><p id="ead4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对于异步任务的编排，通道是一个强大的概念。通道允许您建立一个管道，在事件到来时处理它们。这可能比线程或承诺更有效。例如，由于通道的原因，下面的Go代码比上面的C++和TypeScript代码更有效。具体来说，返回的第一个Pokemon信息可以立即处理，而在C++和Typescript中，处理只能在最慢的请求完成后进行。</p><p id="495b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下面的Go代码演示了如何使用通道。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="eac8" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">摘要</h1><p id="99eb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">对于任何程序来说，拥有一致且有效的模式来执行异步任务都是一个重要的考虑因素。存在许多异步编程的范例，但是我希望您在本文中了解了线程、承诺和通道。</p></div></div>    
</body>
</html>