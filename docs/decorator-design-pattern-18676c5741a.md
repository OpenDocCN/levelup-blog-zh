# 装饰设计模式

> 原文：<https://levelup.gitconnected.com/decorator-design-pattern-18676c5741a>

装饰器是一种结构设计模式，它允许在现有对象上添加新功能，而不改变其底层结构。

![](img/c114c7fd40795e49fe16e6a24284dbd2.png)

[由 Freepik-flat icon 创建的画笔图标](https://www.flaticon.com/free-icons/brush)

# 优势

*   一个对象的行为可以在没有大的继承树的情况下被扩展。
*   附加功能可以很容易地添加或删除。这种功能也可以组合。
*   避免了创造一个*神的对象*。额外的功能和责任(想想 SRP)可以从具体的对象中分离出来。

# Python 实现

下面的例子展示了装饰者如何从一个假想的菜单中添加额外的食物。

## 首先是一些进口

__future__ 的注释允许在类的定义中对类进行类型提示。

## 连接

定义需要由具体对象、基本装饰者和装饰者实现的共享功能。

## 具体对象

实现基本行为，可以使用 decorators 扩展。

## 基础装饰工

将所有操作委托给包装的组件(可以是具体的对象或另一个装饰器)。

## 装修工

实现附加功能。在被包装的组件之前执行它们的行为。包装组件的行为由基本装饰器执行。

并非所有的功能都需要扩展。

## 添加附加功能

装饰设计模式的好处在这里可以真正看到。基本装饰器可以与具体对象和其他装饰器一起使用，因为它们都是从 IFood 接口派生的。这使得生菜和培根装饰，很容易结合，或删除任何顺序，在任何时候。

# 何时使用

*   需要向现有对象添加额外的功能，而不改变基本实现。
*   您希望避免给现有对象增加额外的责任。
*   当需要添加许多不同的附加功能，并且您希望避免创建一个大的继承树时。

# 为什么不只是…

…从具体的 burger 对象继承，然后覆盖并调用那里的父对象？您将无法轻松灵活地组合附加功能。您最终会将所有功能紧密耦合在一起，创建一个大的继承树。

…从装饰器调用被装饰的对象，而不使用基本装饰器？这给所有装饰者增加了额外的重复责任。这应该被提取(连同任何其他共享功能)到基本装饰器中。

# 不足之处

*   需要为每个单独的附加功能创建一个单独的对象。
*   更难调试，因为 decorators 可以以任何顺序组合。