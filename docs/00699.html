<html>
<head>
<title>Building a React Native Chat App — Part Two: Message History | PubNub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建React本地聊天应用程序—第二部分:消息历史| PubNub</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-react-native-chat-app-part-two-message-history-pubnub-8466de114146?source=collection_archive---------1-----------------------#2019-07-02">https://levelup.gitconnected.com/building-a-react-native-chat-app-part-two-message-history-pubnub-8466de114146?source=collection_archive---------1-----------------------#2019-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3c25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们正在进行的关于构建React原生聊天应用的系列教程的前一部分中，我们设置了基本的消息和聊天UI。在这一部分，我们将添加消息历史，这将允许您存储和获取历史消息。当用户重新启动他们的聊天应用程序时，他们将能够看到以前发送的消息。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="ab gu cl kr"><img src="../Images/76d7595985b3b50a2f0a16cccd2f025b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*rHrtWc8rGY9uEkJiWvTAQg.png"/></div></figure><p id="bbee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ku">注意，你需要完成</em> <a class="ae kl" href="https://dev.to/kris/building-a-react-native-chat-app-part-one-basic-messaging-5di3-temp-slug-8381702" rel="noopener ugc nofollow" target="_blank"> <em class="ku">第一部分</em> </a> <em class="ku">后才能开始学习本教程，因为我们也在那部分介绍了设置。</em></p><p id="d8c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一部分中，我们将讨论消息历史的两个主要方面:</p><ul class=""><li id="7ed3" class="kv kw iq jp b jq jr ju jv jy kx kc ky kg kz kk la lb lc ld bi translated">获取消息历史记录</li><li id="4bc9" class="kv kw iq jp b jq le ju lf jy lg kc lh kg li kk la lb lc ld bi translated">可视地显示哪个用户发送了消息</li></ul><h1 id="e8bd" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">获取消息历史记录</h1><p id="2428" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">目前，我们的聊天应用程序有一个全球聊天界面。当有人发送消息时，聊天消息会出现在所有连接用户的全局日志中。但是当我们关闭应用程序时，所有的消息都消失了。当我们重新打开应用程序时，消息日志是空的。这是因为消息历史记录没有存储在设备上。</p><p id="2e90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们在这一部分要解决的问题——存储和获取消息历史。我们将使用PubNub Storage &amp; Playback(有时称为<em class="ku">历史</em>或<em class="ku">历史API </em>)来完成这项工作。</p><p id="fc3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导航到您的<a class="ae kl" href="https://dashboard.pubnub.com/" rel="noopener ugc nofollow" target="_blank"> PubNub管理仪表板</a>，并激活该功能。</p><p id="798f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦存储和回放被激活，我们需要在应用程序刷新或恢复时获取存储的消息。为此，我们需要返回到<strong class="jp ir"> App.js </strong>文件，然后在应用程序启动时使用<strong class="jp ir">componentDidmount()</strong>React回调函数获取存储的消息。</p><p id="a019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下代码片段从PubNub通道获取消息历史记录:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="075a" class="mr lk iq mn b gy ms mt l mu mv">this.pubnub.history(<br/>  { channel: "MainChat", reverse: true, count: 15 },<br/>  (status, res) =&gt; {<br/>    console.log(newmessage);<br/>  }<br/>);</span></pre><p id="796f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数的工作原理是从一个名为MainChat的通道获取15条消息。可以在JavaScript开发人员控制台中看到获取的消息。</p><p id="a19b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到它像一个魔咒一样工作。但是当我们观察默认的天赋聊天消息结构时，它与我们的设计不符。因此，在将新消息附加到React状态之前，我们需要重建消息。您可以使用下面代码片段中的代码来构建一个新的消息数组，该数组将与天才聊天的消息结构相匹配:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="57b3" class="mr lk iq mn b gy ms mt l mu mv">componentDidMount() {<br/>  this.pubnub.history(<br/>    { channel: "MainChat", reverse: true, count: 15 },<br/>    (status, res) =&gt; {<br/>      let newmessage = [];<br/>      res.messages.forEach(function(element, index) {<br/>        newmessage[index] = element.entry[0];<br/>      });<br/>      console.log(newmessage);<br/>    }<br/>  );<br/>}</span></pre><p id="9e8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在下面的屏幕截图中看到消息结构是对齐的。</p><p id="8d83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们需要将新的消息数组添加到天赋聊天中。为此，您可以使用以下代码片段:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="914a" class="mr lk iq mn b gy ms mt l mu mv">componentDidMount() {<br/>  this.pubnub.history(<br/>    { channel: "MainChat", reverse: true, count: 15 },<br/>    (status, res) =&gt; {<br/>      let newmessage = [];<br/>      res.messages.forEach(function(element, index) {<br/>        newmessage[index] = element.entry[0];<br/>      });<br/>      console.log(newmessage);<br/>      this.setState(previousState =&gt; ({<br/>        messages: GiftedChat.append(<br/>          previousState.messages,<br/>          newmessage<br/>        )<br/>      }));<br/>    }<br/>  );<br/>}</span></pre><p id="dfd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，即使在应用程序刷新时，消息历史记录也会加载。</p><p id="343a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，消息的排序方向相反。因此，在将数组添加到天赋聊天之前，我们需要反转数组。您可以通过使用以下代码片段来实现这一点:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="dba9" class="mr lk iq mn b gy ms mt l mu mv">componentDidMount() {<br/>  this.pubnub.history(<br/>    { channel: "MainChat", reverse: true, count: 15 },<br/>    (status, res) =&gt; {<br/>      let newmessage = [];<br/>      res.messages.forEach(function(element, index) {<br/>        newmessage[index] = element.entry[0];<br/>      });<br/>      console.log(newmessage);<br/>      this.setState(previousState =&gt; ({<br/>        messages: GiftedChat.append(<br/>          previousState.messages,<br/>          newmessage.reverse()<br/>        )<br/>      }));<br/>    }<br/>  );<br/>}</span></pre><p id="3620" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，聊天信息现在可以被检索出来，并按照发送的正确时间顺序显示出来。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/87243e233fee9d391cb5fd31c8b8fdab.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/0*519sTraC_K14-jaF.gif"/></div></figure><h1 id="f703" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">将用户与聊天UI中的消息相关联</h1><p id="dbc9" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">你可以观察到，当你发送一条消息，刷新app时，消息全部显示在接收方。为什么会这样？我们在加载应用程序时随机创建了一个用户id，以模拟多个用户。</p><p id="9400" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要添加一点用户认证，这样我们就可以在聊天中识别用户。这将使我们能够在聊天界面的正确一侧显示消息。然后，用户将能够在视觉上区分他们的聊天消息和他们朋友的聊天消息。</p><p id="6c18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要在我们的应用程序目录中创建几个文件。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/9ee6eaa94a12a1d19b732430314dcf0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/0*dLepask_GHLcghtH.png"/></div></figure><p id="4260" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要将代码从App.js文件移动到MainChat.js，并将类名从App更改为MainChat，如下面的代码片段所示:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="616d" class="mr lk iq mn b gy ms mt l mu mv">import React, { Component } from "react";<br/>import {<br/>  View,<br/>  Text,<br/>  StyleSheet,<br/>  TextInput,<br/>  TouchableOpacity,<br/>  Image<br/>} from "react-native";<br/>export default class App extends Component {<br/>  render() {<br/>    return (<br/>      &lt;View style={styles.container}&gt;<br/>        &lt;View style={styles.logo}&gt;<br/>          &lt;Image<br/>            source={require("../img/react.jpg")}<br/>            style={{ width: 66, height: 58 }}<br/>          /&gt;<br/>          &lt;Image<br/>            source={require("../img/pubnublogo.png")}<br/>            style={{ width: 60, height: 60 }}<br/>          /&gt;<br/>        &lt;/View&gt;<br/>        &lt;Text style={styles.welcome}&gt;Chat with Pubnub&lt;/Text&gt;<br/>        &lt;TextInput<br/>          style={styles.input}<br/>          placeholder="Username"<br/>          autoCapitalize="none"<br/>          autoCorrect={false}<br/>          onChangeText={username =&gt; this.setState({ username })}<br/>        /&gt;<br/>        &lt;TextInput<br/>          style={styles.input}<br/>          secureTextEntry={true}<br/>          placeholder="Password"<br/>          onChangeText={password =&gt; this.setState({ password })}<br/>        /&gt;<br/>        &lt;View style={styles.btnContiner}&gt;<br/>          &lt;TouchableOpacity style={styles.btn} onPress={() =&gt; this.login()}&gt;<br/>            &lt;Text style={styles.btntext}&gt;Login&lt;/Text&gt;<br/>          &lt;/TouchableOpacity&gt;<br/>        &lt;/View&gt;<br/>      &lt;/View&gt;<br/>    );<br/>  }<br/>}<br/>const styles = StyleSheet.create({<br/>  container: {<br/>    flex: 1,<br/>    justifyContent: "center",<br/>    alignItems: "center",<br/>    bottom: 66<br/>  },<br/>  welcome: {<br/>    fontSize: 30,<br/>    textAlign: "center",<br/>    margin: 10,<br/>    fontWeight: "300"<br/>  },<br/>  input: {<br/>    width: "90%",<br/>    backgroundColor: "skyblue",<br/>    padding: 15,<br/>    marginBottom: 10<br/>  },<br/>  btnContiner: {<br/>    flexDirection: "row",<br/>    justifyContent: "center",<br/>    width: "80%"<br/>  },<br/>  btn: {<br/>    backgroundColor: "orange",<br/>    padding: 15,<br/>    width: "45%"<br/>  },<br/>  btntext: { fontSize: 16, textAlign: "center" },<br/>  logo: {<br/>    flexDirection: "row"<br/>  }<br/>});</span></pre><p id="c783" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在您可以看到我们的登录表单样式的结果。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi my"><img src="../Images/a3adc0a925ac106dcd11b5c62e32a824.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/0*qQBFvbKaMmocEnLl.png"/></div></figure><p id="16a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将添加用户身份验证功能。为此，首先，我们用两个变量<strong class="jp ir">用户名</strong>和<strong class="jp ir">密码</strong>创建一个状态对象，如下面的代码片段所示:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="6920" class="mr lk iq mn b gy ms mt l mu mv">state = { username: "", password: "" };</span></pre><p id="ce8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当用户在文本输入字段中键入内容时，我们将文本数据添加到状态变量中，如下面的代码片段所示:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="aed2" class="mr lk iq mn b gy ms mt l mu mv">&lt;View style={styles.container}&gt;<br/>  &lt;Text style={styles.welcome}&gt;Chat with Pubnub&lt;/Text&gt;<br/>  &lt;TextInput<br/>    style={styles.input}<br/>    placeholder="Username"<br/>    autoCapitalize="none"<br/>    autoCorrect={false}<br/>    onChangeText={username =&gt; this.setState({ username })}<br/>    /&gt;<br/>  &lt;TextInput<br/>    style={styles.input}<br/>    secureTextEntry={true}<br/>    placeholder="Password"<br/>    onChangeText={password =&gt; this.setState({ password })}<br/>    /&gt;<br/>  &lt;View style={styles.btnContiner}&gt;<br/>    &lt;TouchableOpacity style={styles.btn} &gt;<br/>      &lt;Text style={styles.btntext}&gt;Login&lt;/Text&gt;<br/>    &lt;/TouchableOpacity&gt;<br/>  &lt;/View&gt;<br/>&lt;/View&gt;</span></pre><p id="4094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当用户点击登录按钮时，会触发登录功能。</p><p id="73b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了进行简单快速的配置，我们创建了一个名为<strong class="jp ir"> user </strong>的<strong class="jp ir"> const </strong>变量，其中包含<strong class="jp ir">用户名</strong>和<strong class="jp ir">密码</strong>，如下面的代码示例所示。</p><p id="bfa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这纯粹是为了演示的目的。<em class="ku">不要在您的生产应用程序中这样做！构建一个安全的服务器编组身份验证系统。</em></p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="d820" class="mr lk iq mn b gy ms mt l mu mv">const user = {<br/>  0: { username: "user1", password: 1111 },<br/>  1: { username: "user2", password: 1111 }<br/>};</span></pre><p id="d0a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们使用这个变量来表示一个数据库，并创建一个登录函数，如下面的代码片段所示。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="31e7" class="mr lk iq mn b gy ms mt l mu mv">login() {<br/>  if (<br/>    (user[0].username == this.state.username &amp;&amp;<br/>      user[0].password == this.state.password) ||<br/>    (user[1].username == this.state.username &amp;&amp;<br/>      user[1].password == this.state.password)<br/>  ) {<br/>    this.props.navigation.navigate("MainChat", {<br/>      username: this.state.username<br/>    });<br/>  } else {<br/>    console.log(this.state);<br/>    alert("username or password is incorrect");<br/>  }<br/>}</span></pre><p id="395d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦完成，你就会得到类似这样的东西。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/01edcb65180807e28034daaab84db1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/0*-jEFnPYTZpR51du7.gif"/></div></figure><p id="5647" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到我们的登录认证是成功的。现在，我们需要在成功登录后将用户重定向到聊天室。</p><h1 id="d4d7" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">登录成功后重定向</h1><p id="b4c3" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">接下来，我们需要使用<strong class="jp ir"> react-navigation </strong>包来处理路由和重定向，比如网页。首先，您需要遵循此处的<a class="ae kl" href="https://reactnavigation.org/docs/en/getting-started.html#installation" rel="noopener ugc nofollow" target="_blank"> React导航安装说明</a>。然后我们需要把App.js的所有代码移到Login.js，并更改类名。然后我们需要让App.js与react-navigation的路线管理兼容。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="de4d" class="mr lk iq mn b gy ms mt l mu mv">import { createStackNavigator, createAppContainer } from "react-navigation";<br/>import Login from "./src/components/Login";<br/>import MainChat from "./src/components/MainChat";<br/>const AppNavigator = createStackNavigator(<br/>  {<br/>    Login: {<br/>      screen: Login<br/>    },<br/>    MainChat: {<br/>      screen: MainChat<br/>    }<br/>  },<br/>  {<br/>    initialRouteName: "Login"<br/>  }<br/>);<br/>export default createAppContainer(AppNavigator);</span></pre><p id="e140" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以在登录后将用户重定向到主聊天屏幕。添加导航功能后，该功能将会正常工作。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="b792" class="mr lk iq mn b gy ms mt l mu mv">login() {<br/>  if (<br/>    (user[0].username == this.state.username &amp;&amp;<br/>      user[0].password == this.state.password) ||<br/>    (user[1].username == this.state.username &amp;&amp;<br/>      user[1].password == this.state.password)<br/>  ) {<br/>    this.props.navigation.navigate("MainChat", {<br/>      username: this.state.username<br/>    });<br/>  } else {<br/>    console.log(this.state);<br/>    alert("username or password is incorrect");<br/>  }<br/>}</span></pre><p id="3df4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们需要指定您想在下一页使用的屏幕名称(即MainChat)和参数(即用户名)。</p><p id="4a0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们通过用一个参数值替换random ID来配置MainChat.js，如下面的代码片段所示:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="c9d7" class="mr lk iq mn b gy ms mt l mu mv">render() {<br/>  return (<br/>    &lt;GiftedChat<br/>      messages={this.state.messages}<br/>      onSend={messages =&gt; this.onSend(messages)}<br/>      user={{<br/>        _id: this.props.navigation.getParam("username")<br/>      }}<br/>    /&gt;<br/>  );<br/>}</span></pre><p id="f131" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们什么都试试吧！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/e6a9cba56cec509018eecd26f99da6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/0*IfVHrHKxL9Qxb1yf.gif"/></div></figure><p id="f306" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到user1登录，然后发送了一条新消息。用户1将在UI的适当一侧看到来自用户2的消息。</p><h1 id="6907" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">包扎</h1><p id="4c73" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">在本教程中，我们学习了如何存储和获取历史聊天消息，并按照接收的顺序显示它们。</p><p id="b732" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的聊天应用功能越来越多，但我们还可以做更多。密切关注后续关于打字指标、未读消息计数、用户状态等的帖子。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="f775" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ku">原载于2019年7月2日</em><a class="ae kl" href="https://www.pubnub.com/blog/building-a-chat-app-with-react-native-and-pubnub-part-two-message-history/" rel="noopener ugc nofollow" target="_blank"><em class="ku">【https://www.pubnub.com】</em></a><em class="ku">。</em></p></div></div>    
</body>
</html>