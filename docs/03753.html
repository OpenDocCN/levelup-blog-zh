<html>
<head>
<title>Reduce Lambda invocations and code boilerplate by adding a JSON Schema Validator to your API Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过向API网关添加JSON模式验证器，减少Lambda调用和代码样板文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/reduce-lambda-invocations-and-code-boilerplate-by-adding-a-json-schema-validator-to-your-api-db7928690025?source=collection_archive---------19-----------------------#2020-05-25">https://levelup.gitconnected.com/reduce-lambda-invocations-and-code-boilerplate-by-adding-a-json-schema-validator-to-your-api-db7928690025?source=collection_archive---------19-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="374b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你正在实现一个RESTful API，很可能你需要<strong class="js iu">验证请求</strong>参数或者请求体。</p><p id="932a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以通过多种方式实现。</p><h1 id="1c74" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">手动验证处理程序中的所有内容</h1><p id="d0df" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">第一种方法是在处理程序中包含解析和验证方法:</p><ul class=""><li id="f7ee" class="lr ls it js b jt ju jx jy kb lt kf lu kj lv kn lw lx ly lz bi translated">我体内是否有一个属性playerId？</li><li id="efdf" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">那个属性是整数吗？</li><li id="24db" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">我的URL字符串中有参数游戏吗？</li><li id="0658" class="lr ls it js b jt ma jx mb kb mc kf md kj me kn lw lx ly lz bi translated">这是在一定的数值范围内吗？</li></ul><p id="0635" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果不是，返回一个无效请求的错误。</p><p id="65eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以想象，根据有效载荷的大小及其约束，甚至在你到达你的处理程序的<em class="mf">果汁</em>之前，运行<strong class="js iu">就有很多样板代码。</strong></p><p id="5ac6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">也许在你所有的处理程序中，都必须以类似的方式完成。</p><blockquote class="mg mh mi"><p id="d51c" class="jq jr mf js b jt ju jv jw jx jy jz ka mj kc kd ke mk kg kh ki ml kk kl km kn im bi translated">但是有中间件可以做到这一点！</p></blockquote><p id="d657" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">真的！</p><h1 id="5df6" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">替换为中间件</h1><p id="0834" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">什么是中间件？它是一段代码，只要lambda处理程序被调用，就在它返回之前“神奇地”为您运行。通过这样做，您可以定义一组在之前运行的验证器(和一组在之后使用的错误响应)，并且您在处理程序中留下的只是您的业务逻辑所必需的代码。</p><p id="1ae0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您曾经使用过Express，您应该已经习惯了中间件的概念，对于Lambdas，一个非常有趣和有用的解决方案是<a class="ae mm" href="https://github.com/middyjs/middy/tree/master/packages/validator" rel="noopener ugc nofollow" target="_blank">Middy</a>——它附带了许多有用的中间件(从解析，到缓存，到<a class="ae mm" href="https://dev.to/dvddpl/warming-up-your-lambdas-schedule-or-plugin--flo" rel="noopener ugc nofollow" target="_blank">处理预热</a>，从<a class="ae mm" href="https://dev.to/dvddpl/where-do-you-keep-credentials-for-your-lambda-functions-5dno" rel="noopener ugc nofollow" target="_blank"> SecretManager和ParameterStore </a>中检索值)</p><p id="4b97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这样的中间件，样板文件验证的实现无疑更加结构化、优雅和可重用。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="494f" class="mw kp it ms b gy mx my l mz na">const schema = {<br/>  required: ['playerId', 'game'],<br/>  properties: {<br/>    playerId: {<br/>      type: 'integer'<br/>    },<br/>    game: {<br/>      type: 'string'<br/>    }<br/>  }<br/>}<br/><br/>handler.use(validator({<br/>  inputSchema: schema<br/>}))</span></pre><p id="04b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管如此，它并没有解决一个主要问题:<strong class="js iu">具有无效请求的lambdas调用的成本</strong>增加。</p><p id="b101" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的。</p><blockquote class="mg mh mi"><p id="50c8" class="jq jr mf js b jt ju jv jw jx jy jz ka mj kc kd ke mk kg kh ki ml kk kl km kn im bi translated"><em class="it">一旦你在你的API网关中收到一个请求，(你付费)它就被转发给你的lambda(你付费)；但是，一旦您到达那里，您验证主体或参数，您意识到请求是无效的，并立即返回一个错误！</em></p></blockquote><p id="4158" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">真是浪费…</p><p id="99a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，执行速度很快，并且防止了无效请求被传递到队列或数据库……但是这难道不能改进吗？</p><h2 id="3abc" class="mw kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated">如果我们已经知道请求是无效的，有办法阻止lambda被调用吗？</h2><p id="368f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">当然有，我们可以直接在API网关的层次上移动验证！！</p><h1 id="16c7" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">用JSON模型模式验证API网关请求。</h1><p id="b440" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">是的，您可以定义一个用JSON编写的验证，并将其交给API网关，这样如果主体不匹配，请求会立即被退回。<br/>你仍然要为APIGateway的使用付费，但是你不会有任何不必要的lambda调用，你在lambda中的代码会更干净，你可以很容易地为多个类似的端点重用那些模式。</p><p id="daa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有很多有用的资源详细解释了这一点，</p><p id="8669" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为在几个项目中，我们决定试用AWS CDK来描述我们的堆栈(这很好，但我们还没有决定是否使用无服务器框架……)，所以我想在这里解释一下如何使用<a class="ae mm" href="https://docs.aws.amazon.com/cdk/latest/guide/home.html" rel="noopener ugc nofollow" target="_blank"> AWS CDK </a>为您的API添加验证。</p><h1 id="b285" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">使用AWS CDK添加JSON验证</h1><h1 id="c6cc" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">创建您的验证器</h1><p id="6653" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">创建请求验证器的实例，并将其引用传递给网关API:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="232d" class="mw kp it ms b gy mx my l mz na">const requestValidator = new apigateway.RequestValidator(this, "MyPayloadValidator", {<br/>            restApi: API,  // &lt;-- this is the reference to your API<br/>            requestValidatorName: `myproj-${stage}-payload-validator`,<br/>            validateRequestBody: true,<br/>        })</span></pre><h1 id="7373" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">创建您的模型:</h1><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0ee2" class="mw kp it ms b gy mx my l mz na">const myModel = new apigateway.Model(this, "myValidationModel", {<br/>            restApi: api,<br/>            contentType: "application/json",  // &lt;-- this is necessary - even thought they mention it's an optional param   VERIFY WITH LATEST VERSIONS OF CDK<br/>            description: "Payload used to validate existing player and game",<br/>            schema: {<br/>                type: JsonSchemaType.OBJECT,<br/>                properties: {<br/>                    playerId: {<br/>                        type: JsonSchemaType.INTEGER<br/>                    },<br/>                    game: {<br/>                        description: "Codename of our games, usually 3 letters",<br/>                        type: JsonSchemaType.STRING,<br/>                        enum: ["AAA", "BBB "CCC"]<br/>                    },<br/>                    lang: {<br/>                      description: "Language Code / Locale used by player, like it_IT or de_DE", <br/>                        type: JsonSchemaType.STRING<br/>                    },<br/>                },<br/>                required: [<br/>                    "game",<br/>                    "playerId",<br/>                    "lang"<br/>                ]<br/>            }<br/>        })</span></pre><p id="87f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有几件棘手的事情。</p><p id="c232" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我从检查JSON模式的外观开始，并创建了一个如下所示的JSON模式:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="0f26" class="mw kp it ms b gy mx my l mz na">{<br/>  "$schema": "http://json-schema.org/draft-07/schema#",<br/>  "title": MyAwesomeValidation",<br/>  "description": "Payload used to validate existing player and game",<br/>  "type": "object",<br/>  "properties": {<br/>    "playerId": {<br/>      "type": "integer"<br/>    },<br/>    "gameId": {<br/>      "type": "string"<br/>    }<br/>  },<br/>  "required": [<br/>    "gameId",<br/>    "playerId"<br/>  ]<br/>}</span></pre><p id="0c4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我认为有可能直接进口。</p><p id="ce10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果是你必须将JSON转换成CDK对象映射<br/>并且<a class="ae mm" href="https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-apigateway.JsonSchema.html" rel="noopener ugc nofollow" target="_blank">文档</a>不是很清楚</p><p id="5a38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，我得到了一个ContentType的错误，尽管<a class="ae mm" href="https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-apigateway.Model.html#contenttype" rel="noopener ugc nofollow" target="_blank">文档</a>声明contentType是一个可选参数</p><blockquote class="mg mh mi"><p id="a2a9" class="jq jr mf js b jt ju jv jw jx jy jz ka mj kc kd ke mk kg kh ki ml kk kl km kn im bi translated"><em class="it">检测到1个验证错误:“createModelInput.contentType”处的值null无法满足约束:成员不能为null </em></p></blockquote><p id="70f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，当我卡住时，我总是运行<code class="fe nm nn no ms b">CDK synth</code>来检查正在生成的云形成模板，然后我直接检查云形成的<a class="ae mm" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-model.html" rel="noopener ugc nofollow" target="_blank">文档。在那里，我发现您需要通过<code class="fe nm nn no ms b">"ContentType": "application/json",</code>,这在UI控制台上也是非常简单的。</a></p><p id="6b94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我真的不知道如何使用CDK、无服务器框架或CloudFormation创建特定资源时，我会在UI控制台中手动完成:浏览所有数百次点击，直观地看到所有必要的选项、步骤和属性，这对理解该过程非常有帮助。</p><h1 id="2081" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">将模型和验证器分配给资源</h1><p id="d882" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">Rest API的每个端点——通常称为资源——都可以有特定的方法(GET、POST等)。要验证该方法中的有效负载或参数，请将对模型的引用和验证器分配给该API资源方法。</p><p id="6214" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我认为这很简单，但这正是我发现自己浪费时间的地方。</p><p id="b9b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">方法选项的文档声明请求模型是验证模型的映射。</p><blockquote class="mg mh mi"><p id="7d45" class="jq jr mf js b jt ju jv jw jx jy jz ka mj kc kd ke mk kg kh ki ml kk kl km kn im bi translated"><em class="it">描述请求载荷数据结构的模型</em></p></blockquote><p id="a783" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我应该添加什么作为密钥呢？</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="9ebc" class="mw kp it ms b gy mx my l mz na">myEndpoint.addMethod("POST", myLambdaIntegration, {<br/>                requestValidator: requestValidator,<br/>                requestModels: {"????": myValidationModel}  &lt;-- what is the key to be used here?<br/>            }<br/>        )</span></pre><p id="0ee5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次检查直接来自CloudFormation 而不是CDK的<a class="ae mm" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-method.html" rel="noopener ugc nofollow" target="_blank">文档，给出了一些提示:</a></p><blockquote class="mg mh mi"><p id="81d8" class="jq jr mf js b jt ju jv jw jx jy jz ka mj kc kd ke mk kg kh ki ml kk kl km kn im bi translated"><em class="it">用于请求内容类型的资源。将请求模型指定为键-值对(字符串到字符串的映射)，内容类型作为键，模型资源名称作为值。</em></p></blockquote><p id="656d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管这里的单词<em class="mf"> resource </em>有点误导，因为它不是API网关资源(您的端点)而是更一般的<strong class="js iu">任何AWS资源</strong>，这里重要的部分是:<strong class="js iu">作为键的内容类型</strong></p><p id="bbf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mm" href="https://dev.to/dvddpl/am-i-an-expert-developer-or-just-an-expert-googler-4390" rel="noopener ugc nofollow" target="_blank">经过一番搜索</a>我在AWS上找到了<a class="ae mm" href="https://aws.amazon.com/it/premiumsupport/knowledge-center/model-api-gateway/" rel="noopener ugc nofollow" target="_blank">这篇文章</a> : <br/> <strong class="js iu">我如何在API Gateway中将模型与我的API关联起来？我尝试直接从控制台添加模型，在那里我看到映射确实是用内容类型完成的，我添加的指定为键的确切内容是，嗯，如前所述，一个内容类型…</strong></p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="15af" class="mw kp it ms b gy mx my l mz na">requestModels: {"application/json": myValidationModel}</span></pre><h1 id="34b1" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">测试您的验证器</h1><p id="e87d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">当我最终能够部署时，我在控制台中仔细检查了所有的东西都在它的位置上并且配置正确，我试图从Postman发送一个带有错误负载的请求。</p><p id="b441" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">….它通过了。Lambda被触发，崩溃/从自身验证返回错误</p><p id="f1bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么！？！</p><figure class="mn mo mp mq gt nq gh gi paragraph-image"><div class="gh gi np"><img src="../Images/7f365bea907b5f1314fecc0ab30a59ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/0*LfSkuNsONj4stpKL.gif"/></div></figure><p id="3481" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从测试控制台(API / Resources / your_method / Test)尝试时，我得到了预期的结果:</p><figure class="mn mo mp mq gt nq gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/9a731db8717f451eb30f931012bb1e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*RBNB4CK6TubO9iBNYLrtig.png"/></div></figure><p id="cb2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它在伐木</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="28b4" class="mw kp it ms b gy mx my l mz na">Request body does not match model schema for content type application/json: [object has missing required properties (["theRightOne"])]</span></pre><p id="3ae0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在盯着Postman屏幕看了一会儿之后，我注意到由于某种原因，Body Type和Header Content-Type被设置为<code class="fe nm nn no ms b">application/text</code>！！<br/>更改为<code class="fe nm nn no ms b">application/json</code>后，请求被拒绝(不出所料！)</p><p id="6ac3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但这意味着，如果客户端用fetch/axios发送任何类型错误的请求，网关API会让它到达lambda！！</p><p id="5e3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我也尝试了这个选项<code class="fe nm nn no ms b">"passthroughBehavior": "never"</code>,但是它似乎不适用于代理集成。</p><p id="b47a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目前，解决方案是在其他类型的内容之上添加键映射，我们希望对这些内容类型应用验证。<br/>(虽然说实话。我更愿意有排除某些东西的可能性，或者拒绝除json之外的所有东西..将在下一个CDK版本中看到)</p><p id="25ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以最后，这是您需要向API方法添加JSON模式验证器的地方:</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="89ef" class="mw kp it ms b gy mx my l mz na">const api = new apigateway.RestApi(this, "AwesomeApi", {  <br/>            restApiName: `my-awesome-api`,  // &lt;--- this is the name of the gateway api in Console<br/>            description: "api to do awesome stuff"<br/>        })<br/> const resource = api.root.addResource("doStuff")  // this is the endpoint!  otherwise lambda is called directly under api root )<br/> const awesomeIntegration = new apigateway.LambdaIntegration(myLambda)<br/> const requestValidator = new apigateway.RequestValidator(this, "AwesomePayloadValidator", {<br/>            restApi: api,<br/>            requestValidatorName: `my-payload-validator`,<br/>            validateRequestBody: true,<br/>        })<br/>const model = new apigateway.Model(this, "AwesomeValidationModel", {<br/>            modelName: "myValidationModel",//`myproject-${stage}-validate-payload-model`,<br/>            restApi: api,<br/>            contentType: "application/json",  // this is necessary - even thought they mention it's an optional param<br/>            description: "Payload used to validate your requests",<br/>            schema: {<br/>                type: JsonSchemaType.OBJECT,<br/>                properties: {<br/>                    foo: {<br/>                        type: JsonSchemaType.STRING<br/>                    },<br/>                     bar: {<br/>                        type: JsonSchemaType.INTEGER,<br/>                        enum: [1, 2, 3]<br/>                    },<br/>   fizz: {<br/>                        type: JsonSchemaType.STRING<br/>                    },<br/>                },<br/>                required: [<br/>                    "foo",<br/>                    "bar"                <br/>                ]<br/>            }<br/>        })<br/>        resource.addMethod("POST", awesomeIntegration, {<br/>                requestValidator: awesomeValidator,<br/>                requestModels: {"application/json": awesomeModel}<br/>            }<br/>        )</span></pre><p id="d057" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用无服务器有点不那么简单。你需要几个插件，但这绝对是可行的。<br/><a class="ae mm" href="https://www.npmjs.com/package/serverless-reqvalidator-plugin" rel="noopener ugc nofollow" target="_blank">https://www . npmjs . com/package/server less-req validator-plugin</a><br/><a class="ae mm" href="https://stackoverflow.com/questions/49133294/request-validation-using-serverless-framework" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/49133294/request-validation-using-server less-framework</a></p><p id="a0b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，</p><h2 id="dd31" class="mw kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated">您应该为您的API网关实现模型模式验证器吗？</h2><p id="fee1" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">当然可以！</p><h2 id="dd0b" class="mw kp it bd kq nb nc dn ku nd ne dp ky kb nf ng lc kf nh ni lg kj nj nk lk nl bi translated">为什么？</h2><p id="0133" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">为了避免处理程序中的重复和笨拙的样板文件验证，最重要的是为了有更多的控制和防止不必要的(和昂贵的)lambda调用。</p><p id="fe62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想象一下，由于某种原因，您的前端出现了错误的更新，请求被错误地发送出去。您收到了一个请求高峰，所有请求都被退回，因为有效负载无效。至少通过API网关请求验证，您可以<strong class="js iu">降低服务器上的成本</strong>。</p><p id="835d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者更糟，想象一下某个<strong class="js iu">恶意攻击攻击您的端点</strong>:您至少可以通过阻止无效请求到达lambda来减轻它。(当然，在恶意攻击的情况下，很可能会使用有效的有效载荷，所以如果您通过节流和ACL规则添加一些安全措施，那就更好了:请看一下<a class="ae mm" href="https://aws.amazon.com/it/waf/" rel="noopener ugc nofollow" target="_blank"> AWS WAF </a>)</p><p id="cbe4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望有帮助。<br/>如果您对CDK或无服务器的实施有任何建议或替代方案，请随时添加到评论中。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="6ebf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mf">原载于2020年5月25日</em><a class="ae mm" href="https://dev.to/dvddpl/reduce-lambda-invocations-and-code-boilerplate-by-adding-a-json-schema-validator-to-your-api-gateway-15af" rel="noopener ugc nofollow" target="_blank"><em class="mf">https://dev . to</em></a><em class="mf">。</em></p></div></div>    
</body>
</html>