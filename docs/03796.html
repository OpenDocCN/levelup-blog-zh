<html>
<head>
<title>Data Transformation Using the Decorator Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用装饰模式的数据转换</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/data-transformation-using-the-decorator-pattern-d94441d13b66?source=collection_archive---------5-----------------------#2020-05-27">https://levelup.gitconnected.com/data-transformation-using-the-decorator-pattern-d94441d13b66?source=collection_archive---------5-----------------------#2020-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e0fae3cbce1ca7a02fbab0ed8559d678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSSQLSBS__r_yPlPIOA1Eg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由来自<a class="ae kc" href="https://www.pexels.com/photo/anonymous-female-cook-in-uniform-and-latex-gloves-decorating-cake-with-macaroons-in-light-kitchen-3983660/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae kc" href="https://www.pexels.com/@gustavo-fring?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">古斯塔沃·福林</a>拍摄</figcaption></figure><p id="a61b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">装饰模式是软件工程中最通用的设计模式之一。它允许动态地将行为添加到对象中，同时仍然遵守单一责任原则。它类似于我在这里写的的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/validation-using-the-chain-of-responsibility-pattern-236a6ded7078">责任链模式，但是一个关键的区别是，不是单个类(或者链中的一环)处理特定的请求或者动作，而是所有的类处理请求或者动作。</a></p><p id="56ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文展示了在转换数据时这是多么有用，通常作为提取、转换和加载管道的一部分。在这个例子中，我们将看到如何应用装饰模式来扩展一个对象的功能，同时保持与单一责任原则的一致性。</p><p id="ae66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧——我们继续干吧。</p><p id="5e82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，想象一个存储和处理商品数据的系统——关于石油、黄金、白银等的数据。具体来说，我们将看到一个数据传输对象，即DTO，它保存从数据库中检索到的数据。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/fe7085696df4fd43b05ed040e3da9e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzJusmSwnCRBJIKIWmd5yA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">商品模型</figcaption></figure><p id="f27e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个类<em class="lg"> Commodity </em>，在字典中存储商品的名称和一些时间序列数据。</p><p id="aefc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的系统需要处理这个模型的实例，并在JSON中产生一个输出。很简单吧？</p><p id="a214" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，差不多…</p><p id="ebd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您会看到输出需要包括未来几年<em class="lg"> ValueAtEndOfYear </em>的值。在我们的管道中的某个地方，我们将需要做一些数学和一些新的价值趋势。</p><p id="ec4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是装饰模式可以大放异彩的地方。</p><p id="13e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们继续之前，让我们问一个问题“我们能在模型类本身中放入做数学运算的功能吗？”</p><p id="b3ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简短的回答是一个强有力的“不”</p><p id="b3b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更长的答案是——是的，你可以。但你不会想的。这样做会违反单一责任原则(<em class="lg">商品</em>的责任是传输数据，而<strong class="kf ir">没有其他责任</strong>)，并引入会以封装、混淆的方式改变其自身状态的功能。这样一来，错误和意想不到的结果就会出现…</p><p id="dfb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，现在我们继续，开始实现装饰器模式。</p><p id="b432" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们看看预期的输出——这是一个简单的JSON对象。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lh"><img src="../Images/2a5efaa01529efe0afe3441b6eff2627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I_v-RB2YB4_CcTStMyOnrg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">期望的输出</figcaption></figure><p id="82aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的——这显然不同于DTO的结构，所以我们需要一个室内设计师来做一些转换，以及一些数学运算。我们做事情的方式没有太大关系，但首先做数学似乎是有意义的。这就是我们要做的。</p><p id="edc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要一个接口或基类。我在这个例子中使用了一个接口——ymmv，对于某些情况，基类可能更合适。我们需要这样做，因为我们的装饰者需要实现与被装饰对象相同的方法。</p><p id="6583" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们的接口，我们假设我们已经在<em class="lg">商品</em>类中实现了它。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lh"><img src="../Images/3e2e1dcacae853f91a602bad362ff934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BeFf3m9sdVHr_ca1aHc-fw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ICommodity界面</figcaption></figure><p id="7cef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们需要实现一个基本的装饰类。这抽象出了常见的功能。当你真的这么做时，确保你的焦点保持狭窄——你不想以一个<a class="ae kc" href="https://softwareengineering.stackexchange.com/questions/368797/sample-code-to-explain-banana-monkey-jungle-problem-by-joe-armstrong#368798" rel="noopener ugc nofollow" target="_blank">香蕉、大猩猩、丛林问题</a>结束吧！</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi li"><img src="../Images/976ab4ec788e049534633cd2eeb3571c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vbiHhvah47DWeavBJHnoGw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们的抽象基类</figcaption></figure><p id="5ee9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们的小例子，这个基类可能看起来有点多余(老实说，确实是这样)，但是如果你真的要实现它，你几乎肯定会希望在基类中弹出公共功能。</p><p id="adf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，基类完成了。现在让我们实现一个计算趋势值的装饰器。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lj"><img src="../Images/80020365475d5f1ed082eaa9bc3afa2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96CHFVo6TOLDHwr4CeBRQQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们的第一个装饰器实现——计算趋势值</figcaption></figure><p id="cb74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们快速看一下这里发生了什么。</p><p id="1cf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数获取了一个<em class="lg"> ICommodity </em>的实例——它可能是另一个装饰器或者是<em class="lg">商品</em>类的实例。它还采用了一个<em class="lg"> ITrend </em>的实例。我们不会详细讨论这是什么，但从本质上讲，它执行数学运算来确定值的趋势。</p><p id="3afa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主要动作发生在属性<em class="lg"> ValueAtEndOfYear </em>中。我们覆盖了基类中的实现(它反过来只是获取/设置装饰商品的属性)。我们调用方法<em class="lg"> TrendValues </em>，而不仅仅是从基类返回值。该方法使用<em class="lg"> ITrend </em>实例来确定值的趋势，然后将它们与存储在基类中的值一起返回。</p><p id="a4fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对——接下来是第二个装修工。这一个将处理数据转换，以便我们的输出匹配所需的模式。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/56f3b516b348627cf58c8ad61046a353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kVJGfihBTo0Qd91Ij8aZrw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">格式装饰者</figcaption></figure><p id="7bfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个装饰器中，我们覆盖了<em class="lg"> ToJsonString </em>方法。我们传入一个<em class="lg"> IFormatter </em>的实例，并使用它获得正确格式的字符串。和上面的<em class="lg"> ITrend </em>一样，在这个例子中我们把它当作一个黑盒，假设它像我们想要的那样工作；)</p><p id="1f9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您会注意到两个装饰器有一些共同点——它们都覆盖方法。这是理解我们是什么以及如何实现我们的目标的关键。我们使用decorator类来提供额外的数据，或者操作现有的数据，我们通过提供现有方法的覆盖来做到这一点。</p><p id="20be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，好东西。现在我们已经有了两个decorators，它们用来绘制值的趋势并创建格式正确的输出，我们需要做的就是连接它。</p><p id="18a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个处理导出的类的片段。我们一会儿就来看一下。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ll"><img src="../Images/8d86dd62014d8e9a7be62fef053edc39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ku2qfn8QUYG-aAzjcnTuRg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在exporter类中进行所有的连接</figcaption></figure><p id="9bc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们感兴趣的方法是<em class="lg"> ExportAsJson </em>。它以<em class="lg">商品</em>的一个实例作为它的参数，我们只对传递这个方法感兴趣，所以我们不使用接口。</p><p id="f75c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在第10行，我们创建了一个<em class="lg"> CommodityTrendDecorator </em>类的实例，并将这个商品传递给export和实现<em class="lg"> ITrend </em>(在这个实例中，我们预测这个商品的价值将呈指数增长)。</p><p id="e33b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第11行，我们创建了一个<em class="lg"> CommodityFormatDecorator </em>的实例，并将它传递给我们的trend decorator实例和一个<em class="lg">I matter</em>实例。</p><p id="a4c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们得到了想要的输出——为了简洁起见，我没有展示我们用这个格式良好的JSON实际做了什么。</p><p id="7873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您会注意到<em class="lg"> ExportAsJson </em>方法中的代码看起来与责任链非常相似。我在开始的时候说过装饰者和责任链模式是相似的，现在你可以看到为什么了！</p><p id="6722" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">区别也很明显——为了完成我们的操作，我们使用每个修饰的类，每个类执行一些动作，它们不把责任交给另一个类。</p><h2 id="bacd" class="lm ln iq bd lo lp lq dn lr ls lt dp lu ko lv lw lx ks ly lz ma kw mb mc md me bi translated">结论</h2><p id="5fce" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在本文中，我们已经看到了如何向类添加行为，如何扩展它的功能，而不违反单一责任原则。</p><p id="17a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经采取了一个简单的DTO，并提供了一个受控的，可管理的方式的状态突变。我们还实现了一种格式化数据以便导出的方法，而不必用许多无关的方法来污染DTO。</p><p id="1c2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种事情在我们的日常生活中是相当常见的，使用装饰者并不是唯一的解决方案。例如，我们在这里所做的可以通过将DTO传递给一个责任链来完成。也就是说，如果将装饰模式和策略模式结合起来，就可以创建灵活而健壮的系统。</p></div></div>    
</body>
</html>