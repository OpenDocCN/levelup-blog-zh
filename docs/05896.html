<html>
<head>
<title>Persist and Remember Page Scroll Position, i.e. window.scrollY Using React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保持并记住页面滚动位置，即使用React钩子进行window.scrollY</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/persist-and-remember-page-scroll-position-i-e-window-scrolly-using-react-hooks-f80884211f2d?source=collection_archive---------2-----------------------#2020-10-11">https://levelup.gitconnected.com/persist-and-remember-page-scroll-position-i-e-window-scrolly-using-react-hooks-f80884211f2d?source=collection_archive---------2-----------------------#2020-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3e00" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个优雅的反应钩完成任务！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cfe548a8fb3354523c4f7db3fc2ed4b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IMQ7jyacFtBIMQbNGvXGTQ.jpeg"/></div></div></figure><p id="75f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">* * 2020年10月16日更新:</strong>由于过于执着地追随ESLint，我意识到在<code class="fe ln lo lp lq b">useEffect</code>钩子中使用空的依赖数组(<code class="fe ln lo lp lq b">[]</code>)有时是可以的。这最终导致构建了一个不需要设置自定义滚动位置的钩子。详情请继续阅读。钩子现在是稳定的，并且已经在我们需要它的项目中交付生产了！</p><p id="0737" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">* 2020年10月14日更新</strong>:在意识到使用这个钩子可能会导致页面‘跳转’的副作用之后，我增加了需求3(并相应地修改了钩子)——使用这个钩子的组件中的任何状态变化当然都会重新触发，导致<code class="fe ln lo lp lq b">useWindowScrollPosition</code>中的逻辑<em class="lr">也</em>被执行。这篇文章可能会有进一步的更新，所以使用风险自担。抱歉，那些在这里复制代码的人，但是你应该知道这样做总是有风险的😉。</p><p id="2c18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章<a class="ae ls" href="https://chrisfrew.in/blog/persist-and-remember-page-scroll-position-with-react-hooks/" rel="noopener ugc nofollow" target="_blank">反映在我的博客chrisfrew.in </a>上。</p><p id="48a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在最近的一个项目中，我的任务是创建能够保持页面间滚动位置的功能。起初，我确信解决方案必须是复杂的，我们必须监听<code class="fe ln lo lp lq b"><strong class="kt ir">scroll</strong></code>事件监听器(从性能和效率的角度来看，这总是一项关键任务)，并共享各种页面滚动位置的复杂状态(<code class="fe ln lo lp lq b"><strong class="kt ir">window.scrollY</strong></code>的值)，以便一切正常工作。</p><p id="fca9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，利用<a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank"> localStorage </a>和React hooks的一些高级功能，产生了一个相当优雅的解决方案。</p><p id="0756" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我很乐意和你分享。</p><p id="0d4f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们走吧！</p><h1 id="1089" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">要求</h1><ol class=""><li id="7511" class="ml mm iq kt b ku mn kx mo la mp le mq li mr lm ms mt mu mv bi translated">首先，我们需要记住每页的<code class="fe ln lo lp lq b"><strong class="kt ir">window.scrollY</strong></code>值——这可以用<a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank"> localStorage </a>解决。我们将传递一个page键来标识哪个<code class="fe ln lo lp lq b"><strong class="kt ir">localStorage</strong></code>变量具有我们需要再水合的<code class="fe ln lo lp lq b"><strong class="kt ir">scrollY</strong></code>值。</li><li id="0bba" class="ml mm iq kt b ku mw kx mx la my le mz li na lm ms mt mu mv bi translated">我们只需要存储用户离开页面时的滚动位置<em class="lr">。这是我意识到不需要事件监听器的地方。不需要监听<code class="fe ln lo lp lq b"><strong class="kt ir">scroll</strong></code>事件来完成这个功能！(已经是巨大的加分了)。如果你愿意的话，这个“窍门”就是利用React的<code class="fe ln lo lp lq b"><strong class="kt ir">useEffect</strong></code> <code class="fe ln lo lp lq b"><strong class="kt ir">return</strong></code>值，它可以是一个函数，即一个<code class="fe ln lo lp lq b"><strong class="kt ir">useEffect</strong></code>调用可以具有以下形式:</em></li></ol><pre class="kg kh ki kj gt nb lq nc nd aw ne bi"><span id="f356" class="nf lu iq lq b gy ng nh l ni nj"><strong class="lq ir">useEffect(() =&gt; {<br/>    // ...some effect code here...<br/>    return () =&gt; {<br/>        // this code fires on unmount! Perfect for our use case!<br/>    }<br/>}, [])</strong></span></pre><p id="4254" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.最后，也可能是最棘手的一点:<em class="lr">我们应该在页面的全部内容加载完毕后再调整页面的滚动位置</em>。例如，如果我们从一个异步进程中加载一堆图片或图片(或者任何真正在DOM中结束的东西)，我们会在恢复我们的<code class="fe ln lo lp lq b"><strong class="kt ir">scrollY</strong></code>位置之前等待以确保数据在DOM中被设置。因此，我们的钩子也应该能够接受一个类型为<code class="fe ln lo lp lq b"><strong class="kt ir">boolean</strong></code>的参数。我把它叫做<code class="fe ln lo lp lq b"><strong class="kt ir">setCondition</strong></code>。只有当<code class="fe ln lo lp lq b"><strong class="kt ir">setCondition</strong></code>变量是<code class="fe ln lo lp lq b"><strong class="kt ir">true</strong></code>时，我们才会调用<code class="fe ln lo lp lq b"><strong class="kt ir">window.scrollTo</strong></code>。</p><h1 id="bb5e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">实施</h1><p id="d0e6" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la nk lc ld le nl lg lh li nm lk ll lm ij bi translated">我向你介绍<code class="fe ln lo lp lq b"><strong class="kt ir">useWindowScrollPosition</strong></code>(打字稿):</p><pre class="kg kh ki kj gt nb lq nc nd aw ne bi"><span id="72c0" class="nf lu iq lq b gy ng nh l ni nj"><strong class="lq ir">import { useEffect } from "react";<br/>import useLocalStorage from "./useLocalStorage";</strong></span><span id="5ad2" class="nf lu iq lq b gy nn nh l ni nj"><strong class="lq ir">// sets scrollY position of window based on a setting condition, i.e. when api calls are done<br/>// also sets the scroll position when unmounting, i.e. a user navigates to a different page<br/>export default function useWindowScrollPosition(localStorageKey: string, setCondition: boolean): void {<br/>    const [scrollYStorage, setScrollYStorage] = useLocalStorage(localStorageKey, 0);<br/>    useEffect(() =&gt; {<br/>        // if the setcondition is true (AKA everything in the DOM is loaded: fire off the scrollTo()!)<br/>        if (setCondition) {<br/>            window.scrollTo(0, scrollYStorage)<br/>        }<br/>    }, [setCondition, scrollYStorage])</strong></span><span id="98e1" class="nf lu iq lq b gy nn nh l ni nj"><strong class="lq ir">    // purely on un mount (and thus we ignore the ESLint warning): store the scroll position the user was at to localStorage<br/>    // see the yellow note at https://reactjs.org/docs/hooks-effect.html near the very bottom<br/>    useEffect(()=&gt; {<br/>        return () =&gt; {<br/>            setScrollYStorage(window.scrollY)<br/>        };<br/>       // eslint-disable-next-line react-hooks/exhaustive-deps<br/>    }, [])<br/>}</strong></span></pre><p id="e3ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中<code class="fe ln lo lp lq b"><strong class="kt ir">useLocalStorage</strong></code>是一个“依赖”，如果你愿意的话，<a class="ae ls" href="https://usehooks.com/useLocalStorage/" rel="noopener ugc nofollow" target="_blank">来自Gabe Ragland在他的<strong class="kt ir"> useHooks </strong>站点</a>上创建的一个漂亮的钩子。</p><p id="ab57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为这个钩子直接与窗口对象交互，所以在组件中使用它是一个真正的单行程序:</p><pre class="kg kh ki kj gt nb lq nc nd aw ne bi"><span id="8c5d" class="nf lu iq lq b gy ng nh l ni nj"><strong class="lq ir">import * as React from "react";<br/>import { useEffect, useState } from "react";<br/>import useWindowScrollPosition from "../hooks/useWindowScrollPosition";</strong></span><span id="7a01" class="nf lu iq lq b gy nn nh l ni nj"><strong class="lq ir">export default function MyAwesomeComponent() {<br/>    const [data, setData] = useState&lt;any&gt;(undefined);<br/>    const [isLoading, setIsLoading] = useState&lt;boolean&gt;(true);</strong></span><span id="4d18" class="nf lu iq lq b gy nn nh l ni nj"><strong class="lq ir">    // look at this; easy as pie:<br/>    useWindowScrollPosition('MyAwesomeComponent_ScrollY', !isLoading);<br/>    // done :)</strong></span><span id="7b19" class="nf lu iq lq b gy nn nh l ni nj"><strong class="lq ir">    // example of setting a loading to false, which upon being set to 'true', triggers the effectful parts of useWindowScrollPosition<br/>    const fetchData = async () =&gt; {<br/>        try {<br/>            const data = await fetch('https://your-api-url-here.com');<br/>            setData(data);<br/>            setIsLoading(false);<br/>        } catch (error) {<br/>            console.log(error);<br/>            setIsLoading(false);<br/>        }<br/>    };</strong></span><span id="4c82" class="nf lu iq lq b gy nn nh l ni nj"><strong class="lq ir">    useEffect(() =&gt; {<br/>        if (!data) {<br/>            fetchData();<br/>        }<br/>    });</strong></span><span id="a93b" class="nf lu iq lq b gy nn nh l ni nj"><strong class="lq ir">    return (<br/>        &lt;p&gt;Hello world!&lt;/p&gt;<br/>        &lt;button onClick={onClick}&gt;Click me!&lt;/button&gt;<br/>    );<br/>}</strong></span></pre><h1 id="dcf2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">最后备注和注释</h1><ul class=""><li id="8f46" class="ml mm iq kt b ku mn kx mo la mp le mq li mr lm no mt mu mv bi translated"><strong class="kt ir">最关键的</strong>，这个钩子在它的一个<code class="fe ln lo lp lq b">useEffect</code>钩子中利用了臭名昭著的空依赖数组。(你可以在代码的评论里看到关于这个特殊用法的React官方文档的链接，或者<a class="ae ls" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">点击这里</a>。).如果你正在使用ESLint(强烈推荐),当使用空数组时，你会得到一个警告。但是在这种情况下，我们真正想要的只是逻辑(设置localStorage键),特别是在组件卸载时，而不是其他时候。因此为第二个<code class="fe ln lo lp lq b"><strong class="kt ir">useEffect</strong></code>钩子提供空的依赖数组(<code class="fe ln lo lp lq b"><strong class="kt ir">[]</strong></code>)是合理的。</li><li id="9e5d" class="ml mm iq kt b ku mw kx mx la my le mz li na lm no mt mu mv bi translated">因为这个钩子利用了本地存储，所以这个解决方案既适用于单页应用程序，也适用于多页应用程序，比如用Gatsby生成的站点——比如这个博客！</li><li id="4149" class="ml mm iq kt b ku mw kx mx la my le mz li na lm no mt mu mv bi translated">你只需要提供<code class="fe ln lo lp lq b"><strong class="kt ir">localStorage</strong></code>键的名称，以及何时调用<code class="fe ln lo lp lq b"><strong class="kt ir">window.scrollTo</strong></code>的<code class="fe ln lo lp lq b"><strong class="kt ir">boolean</strong></code>触发条件。(如果想在mount上立即调用<code class="fe ln lo lp lq b"><strong class="kt ir">window.scrollTo</strong></code>，只需将<code class="fe ln lo lp lq b"><strong class="kt ir">true</strong></code>传递给钩子即可)。</li><li id="9280" class="ml mm iq kt b ku mw kx mx la my le mz li na lm no mt mu mv bi translated">我将<code class="fe ln lo lp lq b"><strong class="kt ir">localStorage</strong></code>键参数保留为<code class="fe ln lo lp lq b"><strong class="kt ir">string</strong></code>类型，但是您可以将其重构为特定的<code class="fe ln lo lp lq b"><strong class="kt ir">enum</strong></code>允许的页面名称，或者创建您自己的验证器。</li><li id="e812" class="ml mm iq kt b ku mw kx mx la my le mz li na lm no mt mu mv bi translated">最后，<strong class="kt ir">也是相当重要的</strong>，你应该在一个‘页面’内只使用这个钩子<em class="lr">一次</em>。如果<code class="fe ln lo lp lq b"><strong class="kt ir">setCondition</strong></code>可能位于页面的更深处，那么它<em class="lr">可以在页面的子组件中使用——但是尝试多次调用<code class="fe ln lo lp lq b"><strong class="kt ir">window.scrollTo()</strong></code>来恢复旧的滚动位置没有多大意义。我发现99%的时间我都可以在我的顶级页面组件中使用它——这是我进行所有API调用和加载处理的地方。</em></li></ul><h1 id="d1ad" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">谢谢！</h1><p id="48a3" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la nk lc ld le nl lg lh li nm lk ll lm ij bi translated">一如既往，感谢您的宝贵时间！希望这个钩子对你有用。</p><p id="b47d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">干杯！🍺</p><p id="52d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">克里斯</p></div></div>    
</body>
</html>