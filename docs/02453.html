<html>
<head>
<title>A comprehensive guide on testing and automation for Rails API’s with Rspec</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于使用Rspec测试和自动化Rails API的全面指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-comprehensive-guide-on-testing-automation-for-rails-apis-with-rspec-317c980f4818?source=collection_archive---------2-----------------------#2020-03-14">https://levelup.gitconnected.com/a-comprehensive-guide-on-testing-automation-for-rails-apis-with-rspec-317c980f4818?source=collection_archive---------2-----------------------#2020-03-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ce5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们如何创建一个自动化测试套件来测试模型、控制器、作业，并在最后计算测试覆盖率？请继续阅读，寻找答案。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/7c57fa658b998d6e70a23f319ba4459b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*J4XM5U-Rbf59DMLIOFt1JQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">图片由<a class="ae ku" href="https://hixonrails.com/ruby-on-rails-tutorials/ruby-on-rails-testing-rspec-configuration/" rel="noopener ugc nofollow" target="_blank">https://hixon rails . com/ruby-on-rails-tutorials/ruby-on-rails-testing-rspec-configuration/</a></figcaption></figure><p id="a239" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在本文的范围内，我们的自动化测试套件将由3个主要组件组成:一个<a class="ae ku" href="https://medium.com/@josh_works/testing-rake-tasks-in-rails-6573f7185a0a" rel="noopener"> <strong class="kx iu"> rake task </strong> </a>，它将设置环境并调用测试套件，<a class="ae ku" href="https://relishapp.com/rspec/" rel="noopener ugc nofollow" target="_blank"><strong class="kx iu">Rspec expectations</strong></a>，它将练习并观察我们代码的行为，最后<a class="ae ku" href="https://github.com/colszowka/simplecov" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu"> simpleCov </strong> </a>，它将在最后为我们生成一个小的web应用程序，以一种理智且符合人类工程学的方式检查我们的测试覆盖率。</p><h1 id="87d8" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">我们将测试的功能</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="08c6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">虽然我同意这不是一个特别有趣的特性，但我们仍然会测试Rails API的一部分，它会向新注册用户的收件箱发送电子邮件确认。该功能使应用程序能够通过确保地址所有权和电子邮件可送达性来验证电子邮件地址。</p><h2 id="48f2" class="ml ls it bd lt mm mn dn lx mo mp dp mb le mq mr md li ms mt mf lm mu mv mh mw bi translated">让我们来解决这个问题</h2><p id="7f63" class="pw-post-body-paragraph kv kw it kx b ky mx ju la lb my jx ld le mz lg lh li na lk ll lm nb lo lp lq im bi translated">让我们首先设置Rspec。我不打算在这里讨论这个，因为有很多优秀的指南可以教你如何去做(例如<a class="ae ku" href="https://medium.com/@amliving/my-rails-rspec-set-up-6451269847f9" rel="noopener">像这个</a>)。一旦Rspec启动并运行，我们将测试我们的模型、控制器、作业和邮件程序。</p><h2 id="3aef" class="ml ls it bd lt mm mn dn lx mo mp dp mb le mq mr md li ms mt mf lm mu mv mh mw bi translated">单元测试模型</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc mk l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">经过测试，我们的模型会像这样凶猛</figcaption></figure><p id="3dad" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">用户模型的应用程序代码如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="b1d6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它有两个需要测试的方法；<code class="fe nd ne nf ng b">generate_email_confirmation_link</code>创建一个唯一的令牌，它可以包含在发送到用户电子邮件地址的URL中。它在30分钟后过期，如果用户在此之前点击它，我们的客户端应用程序将从URL中提取令牌，并将其发送回我们的API。然后，API将调用<code class="fe nd ne nf ng b">verify_email</code>来设置<code class="fe nd ne nf ng b">email_verified</code>属性，以便验证特定用户的电子邮件。我们将这样测试这个模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="78f3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在第5行，我们使用<code class="fe nd ne nf ng b">factory_bot</code>来创建一个用户(如果您没有使用工厂来生成模拟数据，我强烈建议您查找一个关于如何做的指南)。在新创建的用户上，我们调用<code class="fe nd ne nf ng b">generate_confirmation_link</code>，这将生成一个指向该用户的URL。我们从生成的URL中提取令牌，并检查是否可以通过ID对其进行解码以找到用户(第8行)。最后，我们将时间推进到未来(使用Timecop)并检查令牌是否过期。</p><h2 id="8e2b" class="ml ls it bd lt mm mn dn lx mo mp dp mb le mq mr md li ms mt mf lm mu mv mh mw bi translated">控制器的单元测试</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mk l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">想象一下为这个控制器制造这个附件的测试。</figcaption></figure><p id="c751" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">之后，我们将测试向web公开这些功能的用户控制器。它的管道看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="dd3d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果用户创建成功，我们会通过调用后台作业向他们发送一封电子邮件。我们将不得不单独对这项工作进行单元测试，但是现在我们将简单地测试控制器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4990" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在第5行，我们用所需的参数调用控制器的create方法。我们断言响应是全绿200。接下来，我们将发送一个不完整的参数集，断言响应将是422。请注意，我使用的是“老学校”的控制器测试，而不是新的要求规格。这是因为所讨论的API需要签名的cookies，而目前(据我所知)还不可能用请求规范进行测试。</p><h2 id="6f69" class="ml ls it bd lt mm mn dn lx mo mp dp mb le mq mr md li ms mt mf lm mu mv mh mw bi translated">使用Rspec对作业进行单元测试</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh mk l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">这份工作的好坏取决于你为它写的最差的测试</figcaption></figure><p id="a3d8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">按照代码的执行路径，我们现在需要测试作业。这很容易测试。异步作业的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8814" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该作业将找到用户，将<code class="fe nd ne nf ng b">email_sent</code>属性设置为true，然后调用邮件程序，将电子邮件发送到他们的收件箱。测试这一点很简单，我们只需检查用户的属性是否得到更新。如果是的话，一切都好。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="af1c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里需要注意的一点是，我们不是在测试Sidekiq、Redis或者ActiveJob。我们不用担心这个。我们将简单地测试我们的应用程序代码是否合法，是否按照我们期望的方式运行。在每个测试之前(第7行)，我们调用inline testing，这意味着Rspec将把这个作业队列放入我们系统的内存中，并使用Sidekiq来处理它(在生产中，这个实现将使用Redis)。</p><h2 id="b671" class="ml ls it bd lt mm mn dn lx mo mp dp mb le mq mr md li ms mt mf lm mu mv mh mw bi translated">邮件程序的单元测试</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni mk l"/></div></figure><p id="e0eb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们就要结束测试了，坚持住。此操作的最后一站是邮件程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="59ed" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该邮件程序将在主题行中按用户姓名发送邮件，并将生成的URL注入邮件正文。对此的测试将简单地检查收件人是否准确，生成的主题行是否有意义，以及消息是否来自我们的应用程序的电子邮件地址。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="e387" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">好了，现在困难的工作已经解决了。你想炫耀的权利，这样做，让设置简单覆盖。它会在您每次运行测试套件时生成一个测试覆盖报告，向您的经理和同事展示您是多么的负责任和努力工作。</p><h2 id="cfd6" class="ml ls it bd lt mm mn dn lx mo mp dp mb le mq mr md li ms mt mf lm mu mv mh mw bi translated">计算测试覆盖率并提交报告</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj mk l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">当有人做出破坏测试套件的变更时</figcaption></figure><p id="f32a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为此，我们将在Rails应用程序中安装simpleCov，然后在我们的<code class="fe nd ne nf ng b">spec_helper.rb</code>中加入一些管道</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2254" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在第2行，我们配置simpleCov使用合并。这是为了确保我们最终生成的报告考虑到了这个Rails应用程序中存在的所有测试套件(我倾向于根据天气和我的感觉同时使用rspec和test unit)。如果您有多个测试套件，比如Rspec和Test unit(默认情况下Rails附带的)，您可以让simplecov根据测试套件类型来检测和分类测试覆盖率。要做到这一点，在一个测试文件中用某个名字提到它。例如:</p><pre class="kj kk kl km gt nk ng nl nm aw nn bi"><span id="6043" class="ml ls it ng b gy no np l nq nr">SimpleCov.command_name ‘rails test’</span></pre><p id="9c45" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在你的一个测试单元测试中</p><pre class="kj kk kl km gt nk ng nl nm aw nn bi"><span id="817b" class="ml ls it ng b gy no np l nq nr">SimpleCov.command_name 'rspec'</span></pre><p id="a32c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在你的一次Rspec测试中。这样，它不仅会为您提供每个套件的单独覆盖结果，还会在最后合并覆盖结果，从而为您提供一个总数。</p><h2 id="dcfe" class="ml ls it bd lt mm mn dn lx mo mp dp mb le mq mr md li ms mt mf lm mu mv mh mw bi translated">创建rake任务来自动化测试</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns mk l"/></div></figure><p id="1ce8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了让我们更接近甜蜜的自动化天堂，我们将创建一个rake任务来处理所有这些</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2b4c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以从我们的项目目录运行这个rake命令:</p><pre class="kj kk kl km gt nk ng nl nm aw nn bi"><span id="648c" class="ml ls it ng b gy no np l nq nr">rails test:full_suite</span></pre><p id="4056" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这里，我们检查Rails环境是否是生产环境之外的环境，如果是，那么套件运行。首先，我们将移除测试覆盖文件夹(如果它存在于之前的测试运行中)。我们将删除数据库，创建它，并使用第7–9行的代码从头开始迁移它(这将测试数据库连接和迁移历史的有效性)。然后它将调用rails测试，最后是我们的rspec测试。在一切运行成功之后，我们应该在我们的项目根目录下看到一个由simplecov生成的名为‘coverage’的文件夹。</p><h2 id="f9c3" class="ml ls it bd lt mm mn dn lx mo mp dp mb le mq mr md li ms mt mf lm mu mv mh mw bi translated">查看simpleCov测试/代码覆盖报告</h2><p id="2b88" class="pw-post-body-paragraph kv kw it kx b ky mx ju la lb my jx ld le mz lg lh li na lk ll lm nb lo lp lq im bi translated">运行<code class="fe nd ne nf ng b">rails test:full_suite</code>后，输入以下代码，在您最喜欢的/默认的网络浏览器上查看漂亮的报告。</p><pre class="kj kk kl km gt nk ng nl nm aw nn bi"><span id="45cc" class="ml ls it ng b gy no np l nq nr">open coverage/index.html</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/11c29858f21f45fd66b7e1aced7d88b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bwg4gbMiTHIZvnSq68C7nA.png"/></div></div></figure><p id="2af2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这里，我们看到我们刚刚测试的控制器有89%的覆盖率。为什么不是100分？让我们通过单击该特定测试来找出原因。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/5e9ed278e4d5ce3c3efa5a8d5f3868f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ON3lEtkceoDrW0lVVZV_LA.png"/></div></div></figure><p id="4186" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里我们看到我们没有测试用户无效的情况(第24行)。我们可以在未来改进这一点，但现在，你有它；一个关于如何测试Rails应用程序大部分部分的快速指南，以及一个自动化的工作流程，通过向您展示您的测试有多有效来增强您的信心。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ny"><img src="../Images/c1212b09341a3c39b79692b5e9b2b697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RvD8YPpeuLpD_GqLpGrvsw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">这里我们看到rails测试的覆盖率报告是36%</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nz"><img src="../Images/a8e8c53b1b68ba8fa327d30290ff15ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w2akQEdj7LScdhBQh4npHg.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">当rspec测试运行时，我们看到rails测试和rspec的总覆盖率是92%</figcaption></figure><h2 id="5d07" class="ml ls it bd lt mm mn dn lx mo mp dp mb le mq mr md li ms mt mf lm mu mv mh mw bi translated">打包放到Github上</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa mk l"/></div></figure><p id="2b2a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以通过添加Github工作流来进一步扩展这个练习，这样每当您或您的团队在Github上提交一个pull请求时，测试套件就会自动触发并验证所提交的代码。我设置的食谱是这样的。我定义了项目根(我正在处理的repo也包含其他内容)和一些特定于我的应用程序的环境变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h2 id="fbb1" class="ml ls it bd lt mm mn dn lx mo mp dp mb le mq mr md li ms mt mf lm mu mv mh mw bi translated">解决纷争</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob mk l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">并行测试就像并行停放工作一样棘手</figcaption></figure><p id="772a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于那些使用Rails 6和并行测试的人来说，这是一个快速的提示。在撰写本文时，simpleCov在计算并行工作者的覆盖率时遇到了一些问题。如果你看到奇怪的测试覆盖结果，请禁用它(在修复之前我得到0%)。在test_helper.rb中注释掉这一行</p><pre class="kj kk kl km gt nk ng nl nm aw nn bi"><span id="8d0d" class="ml ls it ng b gy no np l nq nr">parallelize(workers: :number_of_processors)</span></pre></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="c7a9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">沙希科是一名来自多伦多的软件工程师，也是T2 Restarone公司的创始人。当他不开发软件时，他就在Medium和<a class="ae ku" href="https://www.youtube.com/channel/UCFl6NiPZtdsLHWUPWhrJj3g" rel="noopener ugc nofollow" target="_blank"> YouTube </a>上创造内容，帮助人们过渡到科技行业。</p></div></div>    
</body>
</html>