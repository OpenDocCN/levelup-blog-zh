<html>
<head>
<title>Port an existing C/C++ app to Flutter with Dart FFI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将现有的C/C++应用程序移植到Dart FFI</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/port-an-existing-c-c-app-to-flutter-with-dart-ffi-8dc401a69fd7?source=collection_archive---------0-----------------------#2022-03-13">https://levelup.gitconnected.com/port-an-existing-c-c-app-to-flutter-with-dart-ffi-8dc401a69fd7?source=collection_archive---------0-----------------------#2022-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="dd7d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">挑战</h1><p id="401f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="lj">拿一个现有的C/C++ app，用Flutter升级它的UI，在所有平台(Linux、Windows、Android、macOS、iOS)上运行现代化的app。</em></p><p id="95dc" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我写了一个开源文本编辑器<a class="ae lp" href="https://github.com/icedman/ashlar-text" rel="noopener ugc nofollow" target="_blank"> Ashlar文本</a>。它是用Qt框架用C/C++写的。我之前做了几次尝试让app跨平台，包括在移动设备上运行。我已经放弃了Qt，尝试了Curses，甚至制作了自己的基于SDL的UI框架。我在这方面取得了一些成功(见<a class="ae lp" href="https://github.com/icedman/tashlar" rel="noopener ugc nofollow" target="_blank"> TAshlar </a>，它既可以在终端上运行，也可以在基于SDL的窗口上运行)——但仍然没有稳定的、值得发布的移动应用。</p><p id="1d12" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我准备放弃跨平台的想法和Ashlar Text Android。但是后来我发现了Flutter UI。Ashlar文本现在在PlayStore中的名称是<a class="ae lp" href="https://play.google.com/store/apps/details?id=com.munchyapps.ashlar.lite" rel="noopener ugc nofollow" target="_blank"> Ashlar代码</a>。编辑器代码、目录和文件管理、git集成、sftp、vscode兼容语法突出显示和主题化都在本机C/C++中运行。但是butter smooth UI呈现都是扑扑的。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lq"><img src="../Images/632ecb9847e16ff3526c82f9a47b4101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yA8GqBgD9qHTfQDo_DbrJQ.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">ashar Text(Linux)——下载Ashlar代码，看看它是如何在Android上运行的</figcaption></figure><p id="3a48" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，我们的挑战——将一些古老的应用移植并运行到新平台，尤其是移动设备上——将是一项可行且有趣的工作。</p><h1 id="657a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我们的目标—移动领域的Rogue 5.4</h1><p id="b98e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">github中有许多C/C++开源应用程序，它们只是乞求被移植到移动平台上。但可能没有一个应用程序的用户界面比基于诅咒的更古老。一款经典的地牢爬行游戏《盗贼》是一个很好的升级选择。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/c2a49c67889038d1f43ca13dd50d3410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*WYw2_67LrZkWKrJjyoIp9A.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">流氓档案截图</figcaption></figure><p id="9fa6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们应该能够做到以下几点:</p><ol class=""><li id="e333" class="mh mi iq kn b ko lk ks ll kw mj la mk le ml li mm mn mo mp bi translated">将地牢爬虫《流氓》——所有奇幻角色扮演游戏的祖母——移植到各大平台；</li><li id="0e26" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">用Flutter渲染它的UI；</li><li id="a639" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">它必须可以在手机上玩——有虚拟键盘和触摸界面；</li><li id="fe8d" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">可选:在Google PlayStore发布应用；</li><li id="f12f" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">可选:控制台文本用户界面看起来太过时了——用一点点图形增加应用程序的趣味；</li></ol><h1 id="fe19" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">重要的事情先来</h1><p id="5bda" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="lj">学点新东西——Dart FFI</em></p><p id="22cb" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在我们超越自我之前，我们必须首先解决我们即将面临的障碍。扑是用Dart写的。<em class="lj">注意，Flutter是UI框架——Dart是Flutter中使用的语言。</em>虽然Dart语言看起来非常类似于C和C++，但我们必须找到一种方法将我们用C/C++编写的代码与Dart语言连接起来。</p><p id="3469" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">Flutter为此提供了一个包— FFI。<em class="lj"> FFI </em>代表<a class="ae lp" href="https://en.wikipedia.org/wiki/Foreign_function_interface" rel="noopener ugc nofollow" target="_blank"> <em class="lj">对外函数接口。</em> </a> <em class="lj"> </em>我们将在这里学习如何使用它。</p><p id="12ad" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在Flutter中有一种调用原生代码的官方方式——<a class="ae lp" href="https://docs.flutter.dev/development/platform-integration/c-interop" rel="noopener ugc nofollow" target="_blank">使用dart:ffi </a>绑定到原生代码。这包括创建一个在你的Flutter应用上使用的Flutter插件。如果你有一个基于Flutter的应用程序，并且想用本地代码扩展它的功能，你可能更喜欢这条路。或者如果你需要创建一个像SQLite(用C语言编写)这样的插件来添加任何Flutter应用程序数据库功能。然后把插件分享给全世界。</p><p id="ac66" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然而，我们现在的概念是反过来的。我们有C/C++或原生应用程序。而且我们想用Flutter升级它的UI。在某种意义上，Flutter本身仅仅是我们的C/C++应用程序的UI插件。</p><p id="807d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">所以在这里，我们将以稍微不同的方式来处理<em class="lj"> FFI </em>。</p><h1 id="9605" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">对外函数接口</h1><p id="8741" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">FFI允许我们将C/C++代码绑定到Dart——或者将本机函数映射到Dart函数。它为两种语言提供了相互交流的途径。</p><p id="78ce" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们的目标是跨平台开发的圣杯——Linux、Android、Windows、macOS、iOS。每个平台构建环境都有自己的细微差别。Linux使用CMake进行编译器配置。在Android中，我们有grad le——幸运的是——可以将CMake作为外部构建。Windows还使用CMake来配置Visual Studio生成工具。在macOS和iOS中，我们会遇到Xcode。</p><p id="1445" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在一个普通的Flutter应用程序中，这些都无关紧要。CMake、Gradle、Xcode——这些由Flutter的构建环境负责。我们简单的称<em class="lj"> flutter build linux或者flutter build macos。但是既然我们足够大胆地让我们的C/C++代码跳动起来，我们将不得不熟悉一些新的构建设置和调整。</em></p><h1 id="d6f4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Linux上的FFI</h1><p id="5116" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将首先为Linux构建。Linux中的Flutter构建系统使用CMake。</p><p id="3f2b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果没有Linux系统，你可以从Windows开始，但是一定要通读这个Linux指南。如果您的Linux系统也有Android构建环境，我们将能够很容易地设置Android构建。</p><p id="69ed" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">首先创建“Hello Word”Flutter应用程序:</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="0ffc" class="na jo iq mw b gy nb nc l nd ne">flutter create testffi --platforms=linux,android,macos,windows</span></pre><p id="91c3" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><em class="lj">或者，你可以复制文章的</em> <a class="ae lp" href="http://github.com/icedman/flutter_ffi_test" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir"> <em class="lj">示例应用程序</em> </strong> </a> <em class="lj">，在通读时浏览代码。</em></p><p id="0698" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在项目文件夹中创建一个目录<em class="lj"> libs </em>。这是我们的本地代码将驻留的地方。我们称之为“<em class="lj">库</em>，因为我们也可以在这里添加其他第三方代码或库。</p><p id="c243" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">创建下一个文件<em class="lj"> CMakeLists.txt. </em></p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="5fd6" class="na jo iq mw b gy nb nc l nd ne"><a class="ae lp" href="https://github.com/icedman/flutter_ffi_test/commit/d25083be729cc2a0dbbaa406784b21adca82597d#diff-8f9a4b3c1e71669e52d39efa0f2d810e010fa1a95aad7c9d641aa6785ed09f88" rel="noopener ugc nofollow" target="_blank">testffi/libs/CMakeLists.txt</a></span></pre><p id="5055" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">添加以下几行:</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="4891" class="na jo iq mw b gy nb nc l nd ne">cmake_minimum_required(VERSION 3.10)                         project(api LANGUAGES CXX C)                         </span><span id="6c7e" class="na jo iq mw b gy nf nc l nd ne">add_library(api<br/>  SHARED<br/>  ./api.cpp<br/>)</span></pre><p id="f705" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这里，我们告诉CMake构建我们的共享原生库，名为<strong class="kn ir"> <em class="lj"> api </em> </strong> <em class="lj">。</em>它将被构建为<em class="lj"> libapi.so. </em></p><p id="8f65" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">创建<em class="lj"> api.cpp </em>，它将包含我们的C/C++代码。首先，使用以下示例:</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="d5ee" class="na jo iq mw b gy nb nc l nd ne">// testffi/libs/api.cpp</span><span id="1241" class="na jo iq mw b gy nf nc l nd ne">#define EXPORT extern "C" __attribute__((visibility("default"))) __attribute__((used))</span><span id="aa4e" class="na jo iq mw b gy nf nc l nd ne">#include &lt;cstring&gt;</span><span id="1309" class="na jo iq mw b gy nf nc l nd ne">EXPORT<br/>int add(int <em class="lj">a</em>, int <em class="lj">b</em>) {<br/>   return a + b;<br/>}</span><span id="11d9" class="na jo iq mw b gy nf nc l nd ne">EXPORT<br/>char* capitalize(char *<em class="lj">str</em>) {<br/>   static char buffer[1024];<br/>   strcpy(buffer, str);<br/>   buffer[0] = <!-- -->toupper(<!-- -->buffer[0]);<br/>   return buffer;<br/>}</span></pre><p id="85db" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">导出定义允许我们用Flutter/Dart使用的C风格符号导出我们的C++代码。</p><p id="562c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">作为例子，我们有两个简单的本地函数——<em class="lj">add</em>，它接受两个整数作为参数，将这两个数字相加，并返回一个整数；另一个<em class="lj">大写</em>，它接受一个char*字符串作为输入，操作该字符串，并返回一个char*字符串。</p><p id="3f09" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">编辑<em class="lj"> linux/CMakeLists.txt </em>来添加我们新创建的子目录<em class="lj">。/libs </em>。</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="953b" class="na jo iq mw b gy nb nc l nd ne">set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")</span><span id="33b7" class="na jo iq mw b gy nf nc l nd ne">...</span><span id="948d" class="na jo iq mw b gy nf nc l nd ne"># add this line<br/>add_subdirectory("./libs")</span></pre><p id="0075" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">重要提示:我们在项目或根目录中创建了我们的<em class="lj"> libs </em>文件夹，这样就可以很容易地从其他平台设置中访问它。但是，在CMake中添加子目录要求该目录是源树的一部分。</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="81fd" class="na jo iq mw b gy nb nc l nd ne">cd linux<br/>ln -s ../libs ./libs</span></pre><p id="7a27" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这创建了一个从<em class="lj"> testff/linux/libs到<em class="lj"> testffi/libs </em>目录的符号链接。这满足了CMake的要求。</em></p><p id="bfc9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">或者，您可以直接在<em class="lj"> testffi/linux — </em>下创建<em class="lj"> libs </em>文件夹，但是您必须更新<em class="lj"> CMakeLists </em>文件中的所有相对路径。</p><h1 id="6ab7" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><em class="ng">先造</em></h1><p id="7f93" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果我们运行<em class="lj"> flutter build linux </em>，作为构建过程的一部分，我们的<em class="lj"> api </em>库<em class="lj"> </em>现在将被构建为<em class="lj"> libapi.so </em>。输出将为:</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="ff52" class="na jo iq mw b gy nb nc l nd ne">testfii/build/linux/x86/release/libs/libapi.so</span></pre><p id="0b47" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们需要这个<em class="lj"> libapi.so </em>文件位于<em class="lj"> bundle </em>目录中，这样我们的库就可以很容易地被定位和加载。所以我们进一步修改<em class="lj"> linux/CMakeLists.txt </em>:</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="44ed" class="na jo iq mw b gy nb nc l nd ne"># === Installation ===</span><span id="1355" class="na jo iq mw b gy nf nc l nd ne">...</span><span id="eda6" class="na jo iq mw b gy nf nc l nd ne"># add this line at the very end of the install commands<br/>install(FILES ${PROJECT_BINARY_DIR}/libs/libapi.so DESTINATION "${INSTALL_BUNDLE_LIB_DIR}" COMPONENT Runtime)</span></pre><p id="27d5" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这将把我们的<em class="lj"> api </em>库复制到每次成功构建的正确位置。如果我们再次运行构建我们的<em class="lj"> libapi。</em>所以会被正确复制:</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="f3da" class="na jo iq mw b gy nb nc l nd ne">testffi/build/linux/x86/release/bundle/lib/libapi.so</span></pre><h1 id="0f53" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">快速回顾</h1><p id="e569" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们已经构建了我们的<em class="lj"> libapi.so </em>。到目前为止一切顺利。以下是我们刚刚所做工作的总结:</p><ol class=""><li id="d9ca" class="mh mi iq kn b ko lk ks ll kw mj la mk le ml li mm mn mo mp bi translated">创建一个<em class="lj"> libs </em>文件夹来保存我们的本地C/C++代码。目前我们只有<em class="lj">libs/API . CPP；</em></li><li id="9eb8" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">创建一个<em class="lj"> libs/CMakeLists.txt </em>来指导CMake如何构建我们的名为<em class="lj"> api的原生库；</em></li><li id="231f" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">修改<em class="lj"> linux/CMakeLists.txt </em>将我们的库包含在linux构建过程中，并将输出库<em class="lj"> libapi.so </em>复制到正确的位置；</li></ol><p id="552e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><em class="lj">简单如1，2，3。</em></p><h1 id="80a7" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">从Flutter/Dart调用本机C/C++</h1><p id="d0f2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们继续之前，我们将<em class="lj"> ffi </em>包添加到我们的项目中。</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="c79a" class="na jo iq mw b gy nb nc l nd ne">flutter pub add ffi</span></pre><p id="a6b9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">修改<em class="lj"> lib/main.dart </em>，添加如下代码:</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="e3ca" class="na jo iq mw b gy nb nc l nd ne">import 'dart:ffi';<br/>import 'package:ffi/ffi.dart';<br/> <br/>class FFIBridge {</span><span id="6e0e" class="na jo iq mw b gy nf nc l nd ne">static bool initialize() {<br/>   nativeApiLib =(DynamicLibrary.open('libapi.so')); // android and linux</span><span id="9190" class="na jo iq mw b gy nf nc l nd ne">   final _add = nativeApiLib.lookup&lt;NativeFunction&lt;Int32 <em class="lj">Function</em>(Int32, Int32)&gt;&gt;('add');<br/>   add = _add.asFunction&lt;int <em class="lj">Function</em>(int, int)&gt;();</span><span id="baa1" class="na jo iq mw b gy nf nc l nd ne">   final _cap = nativeApiLib.lookup&lt;NativeFunction&lt;Pointer&lt;Utf8&gt; <em class="lj">Function</em>(Pointer&lt;Utf8&gt;)&gt;&gt;('capitalize');<br/>   _capitalize = _cap.asFunction&lt;Pointer&lt;Utf8&gt; <em class="lj">Function</em>(Pointer&lt;Utf8&gt;)&gt;();<br/>   return true;<br/>}</span><span id="0725" class="na jo iq mw b gy nf nc l nd ne">static late DynamicLibrary nativeApiLib;<br/>static late Function add;<br/>static late Function _capitalize;</span><span id="7b77" class="na jo iq mw b gy nf nc l nd ne">static String capitalize(String <em class="lj">str</em>) {<br/>   final _str = <em class="lj">str</em>.toNativeUtf8();<br/>   Pointer&lt;Utf8&gt; res = _capitalize(_str);<br/>   calloc.free(_str);<br/>   return res.toDartString();<br/>}</span><span id="2e1c" class="na jo iq mw b gy nf nc l nd ne">}</span></pre><p id="990c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">上面的代码定义了一个类<em class="lj"> FFIBridge。</em>这是本地代码绑定或映射到Dart的地方。FFIBrdige 有一个静态函数<em class="lj"> initialize </em>，我们在运行应用程序时调用它。</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="6b26" class="na jo iq mw b gy nb nc l nd ne">void main() {<br/>   FFIBridge.initialize();<br/>   runApp(const MyApp());<br/>}</span></pre><ol class=""><li id="28a9" class="mh mi iq kn b ko lk ks ll kw mj la mk le ml li mm mn mo mp bi translated"><em class="lj">初始化</em>函数加载我们的库<em class="lj"> libapi.so </em></li></ol><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="cfd5" class="na jo iq mw b gy nb nc l nd ne">nativeApiLib = DynamicLibrary.open('libapi.so')</span></pre><p id="97a0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">2.然后它查找我们的本地函数<em class="lj"> add: </em></p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="6949" class="na jo iq mw b gy nb nc l nd ne">final _add = nativeApiLib.lookup&lt;NativeFunction&lt;Int32 <em class="lj">Function</em>(Int32, Int32)&gt;&gt;('add');</span></pre><p id="9794" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">3.这将返回对将映射到dart函数FFIBridge.add的本机函数的引用—参见类成员变量<em class="lj">静态后期函数add</em></p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="1f86" class="na jo iq mw b gy nb nc l nd ne">add = _add.asFunction&lt;int <em class="lj">Function</em>(int, int)&gt;();</span></pre><p id="41ff" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在我们有了一个本地函数到Dart函数的绑定。我们现在可以在Dart代码的任何地方调用<em class="lj"> int FFIBridge.add(int，int) </em>函数。</p><p id="0398" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><em class="lj">再简单如1、2、3。</em></p><p id="ab99" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">对原生函数<em class="lj">大写进行类似的处理。</em>然而，当我们将字符串参数传递给本机函数时，我们需要一个包装函数来将Dart <em class="lj">字符串</em>转换为<em class="lj">指针&lt; Utf8 &gt; </em>。并将返回的原生字符串<em class="lj">指针&lt;Utf8&gt;T29】转换回Dart <em class="lj">字符串。</em></em></p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="0652" class="na jo iq mw b gy nb nc l nd ne">static String capitalize(String <em class="lj">dart_str</em>) {<br/>   ... // convert dart_str<br/>   _res_native_str = _capitalize( _native_str ) <br/>   ... // convert _res_native_str<br/>   return _res_dart_str<br/>}</span></pre><h1 id="59ea" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">构建并运行</h1><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="679d" class="na jo iq mw b gy nb nc l nd ne">flutter build linux -v</span></pre><p id="14f3" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们的本机函数调用在起作用:</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="34ad" class="na jo iq mw b gy nb nc l nd ne">Column(children: [<br/>   Text('capitalize flutter=${FFIBridge.capitalize('flutter')}'),<br/>   Text('1+2=${FFIBridge.add(1, 2)}'),<br/>]);</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nh"><img src="../Images/d4778f75f57c2f6cf3a970158f66566a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P0Z6avFBDgOF6HxUJVGfpA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">我们Linux中的Flutter应用程序</figcaption></figure><h1 id="d5a4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Android上的FFI</h1><p id="b5a0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果您正确地遵循了Linux指令，并且您的Linux应用程序可以正确地调用本机函数，那么Android步骤将会非常非常快:</p><p id="ba29" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">修改<em class="lj">Android/app/build . gradle:</em></p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="034e" class="na jo iq mw b gy nb nc l nd ne">android {</span><span id="644d" class="na jo iq mw b gy nf nc l nd ne">    externalNativeBuild {<br/>        cmake {<br/>            path "../../libs/CMakeLists.txt"<br/>        }<br/>    }<br/></span></pre><p id="8e57" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们简单地将<em class="lj"> externalNativeBuild </em>定义添加到Gradle构建配置中。它指向我们为Linux编写的同一个<em class="lj"> CMakeLists.txt </em>文件。</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="85c6" class="na jo iq mw b gy nb nc l nd ne">flutter build apk -v</span></pre><p id="b55e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">你现在有了一个带有本地C/C++调用的Flutter Android应用程序。</p><h1 id="2a0c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">源代码</h1><p id="0603" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对于那些跳过了所有的剪切和粘贴，但希望看到应用程序实际构建和运行的人:</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="8972" class="na jo iq mw b gy nb nc l nd ne">git clone <a class="ae lp" href="https://github.com/icedman/flutter_ffi_test/" rel="noopener ugc nofollow" target="_blank">https://github.com/icedman/flutter_ffi_test/</a><br/>cd flutter_ffi_test<br/>flutter pub get<br/>flutter run -v</span></pre><h1 id="b980" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Windows上的FFI</h1><p id="c764" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">CMake也用于Windows的构建系统。设置类似于Linux，但有一些小的不同。</p><p id="f4c7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">首先，我们没有像在Android中那样使用CMakeLists.txt，而是修改了<em class="lj">testffi/windows/runner/cmakelists . txt。</em>在最后添加了我们的库配置:</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="10cf" class="na jo iq mw b gy nb nc l nd ne">add_library(api<br/>   SHARED<br/>   ../../libs/api.cpp<br/>   ../../libs/exports.def<br/>)</span></pre><p id="cad6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">相对路径不同于Linux CMakeLists，但是它们指向完全相同的C++文件。这将产生这样的效果:我们的<em class="lj"> api </em>就构建在我们的应用程序可执行文件旁边。与Linux不同，Windows应用程序目录结构没有<em class="lj">捆绑包</em>或<em class="lj">捆绑包/库</em>目录。我们的库Windows上的<em class="lj">api.dll</em>——应该位于与我们的<em class="lj"> testffi </em>可执行文件相同的目录中。</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="8fac" class="na jo iq mw b gy nb nc l nd ne">testffi/build/windows/runner/api.dll<br/>testffi/build/windows/runner/testffi.exe</span></pre><p id="86f8" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">第二个区别是<em class="lj"> exports.def </em>文件。在<em class="lj"> libs </em>文件夹中创建该文件，内容如下:</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="efeb" class="na jo iq mw b gy nb nc l nd ne">LIBRARY api<br/>EXPORTS<br/>    add<br/>    capitalize</span></pre><p id="5d03" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们想要导出的每个新函数都应该在<em class="lj"> exports.def </em>文件中定义。</p><p id="e7ee" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">并且还要修改<em class="lj"> api.app </em>导出定义:</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="f3a8" class="na jo iq mw b gy nb nc l nd ne">#ifdef WIN32<br/>   #define EXPORT __declspec(dllexport)<br/>#else<br/>   #define EXPORT extern "C" __attribute__((visibility("default"))) __attribute__((used))<br/>#endif</span></pre><p id="5be4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这些变化将正确地暴露我们的库—<em class="lj">api.dll的原生函数。</em></p><p id="bb93" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们还应该更新我们的<em class="lj"> FFIBridge </em>类:</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="9b3f" class="na jo iq mw b gy nb nc l nd ne">nativeApiLib = Platform.isMacOS || Platform.isIOS ? DynamicLibrary.process() // macos and ios<br/>: (DynamicLibrary.open(Platform.isWindows // windows<br/>? 'api.dll'<br/>: 'libapi.so')); // android and linux</span></pre><p id="460e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">Linux和Android加载<em class="lj"> libapi.so，</em> Windows加载<em class="lj">api.dll。</em>我们的macOS和iOS设置将直接从<em class="lj"> runner </em>应用程序库进程加载本机函数符号，而无需加载外部库。</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="a2fe" class="na jo iq mw b gy nb nc l nd ne">flutter build windows -v</span></pre><h1 id="113c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">macOS和iOS上的FFI</h1><p id="f124" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">macOS和iOS中的构建系统由Xcode处理——没有CMake。我们将本机C/C++代码直接整合到<em class="lj"> Runner </em>应用中。<em class="lj"> </em>打开<em class="lj">MAC OS/runner . xcode proj .</em></p><p id="846d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">添加新群组，而不创建新文件夹。称之为<em class="lj"> libs。</em></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/9a651f28a999a14d6c8da0d0a6a980b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*gfzxAAmjlM9Xebh2OxdJNw.png"/></div></figure><p id="e8c3" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">添加我们的<em class="lj"> api.cpp. </em></p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/a89d9e9a835e049a91361aa8040a2e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*uoH2Q68paD4xk8-H_n8hHQ.png"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">将我们的文件添加到新的Api组中</figcaption></figure><p id="3d22" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这对于macOS来说出奇的简单。对于iOS构建配置，我们遵循相同的方法。<em class="lj">免责声明:我其实还没有测试过iOS。</em></p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="4a6a" class="na jo iq mw b gy nb nc l nd ne">nativeApiLib = Platform.isMacOS || Platform.isIOS ? DynamicLibrary.process()</span></pre><p id="0641" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">本机函数的查找方式不同，因为它们不是从单独的动态库中加载的，而是从Flutter <em class="lj"> Runner </em>库本身加载的。</p><pre class="lr ls lt lu gt mv mw mx my aw mz bi"><span id="da51" class="na jo iq mw b gy nb nc l nd ne">flutter build macos -v</span></pre><h1 id="2e14" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">快速回顾</h1><ol class=""><li id="b459" class="mh mi iq kn b ko kp ks kt kw nj la nk le nl li mm mn mo mp bi translated">我们使用dart:ffi包加载并绑定我们的本地库到Dart；</li><li id="d3c3" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">Android设置就是在gradle中添加一个<em class="lj"> externalNativeBuild </em>定义，指向并重用Linux中使用的<em class="lj">CMakeLists</em>；</li><li id="0863" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">Windows设置略有不同——我们修改了<em class="lj">windows/runner/cmakelists . txt</em>,并在那里添加了我们的库构建配置；</li><li id="2a37" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">Windows需要一个<em class="lj"> exports.def </em>文件；</li><li id="1c61" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">Windows也有不同的导出函数签名——<em class="lj">_ _ declspec(DLL export)</em>——用于动态链接库(DLL)；</li><li id="ba7a" class="mh mi iq kn b ko mq ks mr kw ms la mt le mu li mm mn mo mp bi translated">macOS和iOS查找原生函数略有不同。没有CMake——但是处理Xcode并不困难；</li></ol><h1 id="a0b7" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">一次编写，随处运行</h1><p id="4d21" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们已经建立了一个Flutter应用程序，它调用本机C/C++代码，可以在Linux、Windows、Android、macOS、<em class="lj">(还有待完成和确认——iOS)上运行。</em></p><p id="cf3a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在我使用Flutter之前，我发现单独使用原生外部构建来设置、构建和测试Android非常麻烦。这篇文章展示了使用Flutter作为我们的<em class="lj">构建环境</em>可以减轻很多痛苦。我们已经简单地通过编辑几个文件介绍了几个平台。现在，我们的构建环境已经设置好了，可以用于Flutter/Dart + Native C/C++，我们应该——至少在理论上——确信我们的代码可以在我们所有的目标平台上运行。我们现在应该能够真正地<em class="lj">写一次就跑一次了。</em></p><p id="988f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">当我们在文章的第二部分移植和构建我们的Rogue 5.4应用程序时，我们将测试这个理论，并完成我们的挑战。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi nm"><img src="../Images/103a6586918a3f67c7ece670d458a5c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rzv2ZZD7CV4RZGFvgMSjug.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">预览— Rogue 5.4 on Flutter</figcaption></figure><p id="77ff" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><em class="lj">未完待续</em> <a class="ae lp" href="https://medium.com/@marvinsanchez_43796/port-an-existing-c-c-app-dungeon-crawler-rogue-to-flutter-with-dart-ffi-a701284aa289" rel="noopener"> <em class="lj">续</em></a><em class="lj">……</em></p></div></div>    
</body>
</html>