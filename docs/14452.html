<html>
<head>
<title>Inheritance Should Not Be Preferred as a Means to Extend Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">继承不应该作为扩展代码的首选方式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/inheritance-should-not-be-preferred-as-a-means-to-extend-code-569bfe63b85f?source=collection_archive---------28-----------------------#2022-11-28">https://levelup.gitconnected.com/inheritance-should-not-be-preferred-as-a-means-to-extend-code-569bfe63b85f?source=collection_archive---------28-----------------------#2022-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7fc8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">继承倾向于创建不灵活的代码库，并且经常被滥用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f407dbd165ebf740802fe5dd61fc189b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NVNz368q5R9eURNJ3kDV6A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://medium.com/@giedrius.kristinaitis" rel="noopener"> Giedrius Kristinaitis </a>提供</figcaption></figure><p id="5cc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继承是工具箱中一个强大的工具。它允许我们形成共享公共功能的相关对象的层次结构，最好的部分是父类型不需要知道关于子类型的任何事情，允许我们创建事物的无数变体。</p><p id="3612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在理论上听起来很好，然而，在实践中，知道何时使用继承有点棘手，继承经常被用来在不应该的时候扩展功能。</p><p id="f47a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当你阅读倒数第二段时，图像会更有意义。</p><h1 id="697a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">一切都受到保护</h1><p id="b7f4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">被继承污染的代码库过度使用了<code class="fe ms mt mu mv b">protected</code>访问修饰符。毕竟，如果默认情况下一切都是<code class="fe ms mt mu mv b">private</code>的话，继承就成问题了，因为你不能访问子类中的<code class="fe ms mt mu mv b">private</code>父类成员。</p><p id="de70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下到处使用<code class="fe ms mt mu mv b">protected</code>访问修饰符的经典论点是这样的:“<em class="mw">你永远不知道你将需要修改什么代码，你不知道你将需要如何修改它，因此，你应该使用</em> <code class="fe ms mt mu mv b"><em class="mw">protected</em></code> <em class="mw">访问修饰符，这将允许你在将来修改你的代码中的任何东西</em>”。</p><p id="7ef9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是真的，你真的不知道你需要扩展什么，只是整个<code class="fe ms mt mu mv b">protected</code>访问修饰符部分不对。</p><h1 id="4601" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">继承被用作扩展功能的首选方式</h1><p id="13c7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">默认情况下到处使用<code class="fe ms mt mu mv b">protected</code>访问修饰符是个坏主意。这种观点有一个很大的假设。假设<em class="mw">继承</em>是扩展功能的唯一和/或首选方式。这种假设阻碍了您的代码健康长寿。</p><p id="ec3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么继承作为扩展代码的一种方式有什么问题呢？理论上听起来不错。然而…</p><blockquote class="mx my mz"><p id="f765" class="kz la mw lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">实际上，对于一段给定的代码，通过<strong class="lb iu">使用继承来扩展功能往往只起一次或几次作用。</strong></p></blockquote><p id="cceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间过得越久，就越难做任何进一步的扩展。</p><h2 id="4a45" class="nd lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated">继承限制扩展</h2><p id="dc7b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设您决定用一堆<code class="fe ms mt mu mv b">protected</code>实例变量和方法来扩展一个类，假设这个类在屏幕上呈现HTML内容。</p><p id="fc03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要创建该类的两个变体:一个具有显示布局边界、边距和填充的调试功能，另一个使用HTML内容创建呈现日志。</p><p id="7ddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对代码设计有一点点的尊重，你就不会把所有的功能都挤到一个类中，因为，事实是渲染功能不需要调试或登录就能工作，把所有的功能都放在一个类中会创建一个god对象，它有一堆条件来控制应该(不应该)使用什么功能。</p><p id="e599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，假设您选择了第二个选项，即创建两个子类，一个用于调试，另一个用于日志记录。</p><p id="9067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设您在代码中有一个地方只需要调试功能，而另一个地方需要调试和日志记录功能。</p><p id="6c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你是做什么的？您需要提供一个HTML渲染器类型的类，但是，这些特性在两个独立的子类中，并且您只能使用一个。你无能为力，你不能同时使用两者。</p><p id="fa7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么通过使用继承来扩展功能变得非常有限，并导致无路可走的情况。</p><blockquote class="mx my mz"><p id="2e59" class="kz la mw lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">当子类中有两个或更多特性时，生活可能会变得很艰难，因为你不得不使用这些特性的组合只是时间问题。</p></blockquote><h1 id="e157" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">更多关于过度使用继承和受保护成员的争论</h1><h2 id="d8d6" class="nd lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated">这不会发生的</h2><p id="c3b8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">使用继承还有另一种说法，比如“<em class="mw">拜托，实际上，大多数时候，你没有父类的多个变体，你只扩展它一次，所以使用继承</em>就可以了。</p><p id="2cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个论点有一个缺陷，因为它假设你<em class="mw">确定</em>你将来不再需要扩展功能。</p><p id="76c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与使用继承来扩展功能的第一个论点相矛盾，即你不知道你需要扩展什么，因此，这是一个无效的论点。</p><h2 id="228a" class="nd lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated">开闭原则</h2><p id="9acc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">然后还有另一个使用<code class="fe ms mt mu mv b">protected</code>实例变量和方法以及使用继承来扩展功能的论点:“<em class="mw">如果你使用实例变量</em> <code class="fe ms mt mu mv b"><em class="mw">private</em></code> <em class="mw">，这违背了开闭原则</em>”。</p><p id="5ac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你做对了就不会。开闭原则并不意味着你应该在任何地方使用<code class="fe ms mt mu mv b">protected</code>访问修饰符，这与访问修饰符无关，因为如果是的话，你就不能在不支持访问修饰符或继承的语言中应用它。</p><h1 id="51d9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">继承之上的组合</h1><p id="3b2e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">使用继承来扩展功能是解决设计问题的权宜之计。相反，组合应该是扩展功能的首选方式。</p><p id="d6c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么是作文？这是一种通过使用单独实现部分功能的其他对象来组合功能的方式。</p><h2 id="6ba8" class="nd lw it bd lx ne nf dn mb ng nh dp mf li ni nj mh lm nk nl mj lq nm nn ml no bi translated">重温示例</h2><p id="0622" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们回到HTML呈现器的例子。你如何用作文解决这个问题？嗯，你可以用很多方法来作曲。您可以将呈现部分与HTML元素解析分开。</p><p id="72fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使HTML呈现器不关心在屏幕上呈现元素做了什么和如何做，并且可以接受多个这样的呈现器和呈现具有所提供的较小类的元素。一个渲染类可以是真正的渲染器，另一个是调试渲染器，您可以将它们单独或以复合的形式注入到HTML渲染器类中，并同时使用它们。</p><p id="d667" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于日志部分，它真的不应该是HTML呈现器的一部分，但是如果你在某种情况下必须是它的一部分，那么你可以做与呈现类似的事情。</p><blockquote class="mx my mz"><p id="2244" class="kz la mw lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">当你使用组合时，你有更多的选择来实现某些东西，并且有更多的自由来扩展你的实现。</p></blockquote><h1 id="1f49" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">是一种关系</h1><p id="28f5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当你的代码设计好的时候，继承没有什么意义，除非你有一个真正的<code class="fe ms mt mu mv b">is-a</code>关系。<code class="fe ms mt mu mv b">is-a</code>OOP中的关系通常是这样定义的:“<code class="fe ms mt mu mv b"><em class="mw">is-a</em></code> <em class="mw">当存在另一种类型的子类型</em>时，关系就存在”。换句话说，在继承的上下文中，当一个类扩展另一个类时。</p><p id="d626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这是一种糟糕的思考<code class="fe ms mt mu mv b">is-a</code>关系的方式(除非你正在研究编程语言理论或一些函数概念)。</p><p id="8764" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢从不同的角度思考这个问题。我想到了类型/类试图表现的基本概念。如果概念不是以一种<code class="fe ms mt mu mv b">is-a</code>的方式相关联，那么不管你是否使用继承，它仍然不会把它变成一种<code class="fe ms mt mu mv b">is-a</code>关系。</p><p id="e796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您扩展一个HTML renderer类来记录每个渲染，这不会创建一个<code class="fe ms mt mu mv b">is-a</code>关系，因为如果您看一下概念，日志记录不是渲染，即使在类层次结构中日志记录类扩展了渲染类，它在语义上看起来像一个<code class="fe ms mt mu mv b">is-a</code>关系。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="b8b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要点是，当涉及到扩展功能时，你应该更喜欢组合而不是继承，因为继承是非常有限的，除非你正在处理一个实际的<code class="fe ms mt mu mv b">is-a</code>关系。</p><p id="3337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过度使用<code class="fe ms mt mu mv b">protected</code>访问修饰符的被继承污染的代码库是不灵活的，应该引起关注。</p><p id="8d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">忘记经典的<code class="fe ms mt mu mv b">class Dog extends Animal</code>例子，它只有一个方法来打印动物发出的声音。现实世界要比这复杂得多。</p><p id="d1fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，不要把"<em class="mw"> OOP应该模拟真实世界</em>"的说法看得太过字面化(这种说法实际上有多真实还有待商榷(我认为这有点误导)，但我不会马上进入OOP vs <em class="mw"> &lt;这里插入你最喜欢的范例&gt; </em>【洞】(只是暂时的))，这可能会让你过度使用继承。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="9f76" class="lv lw it bd lx ly nw ma mb mc nx me mf jz ny ka mh kc nz kd mj kf oa kg ml mm bi translated">分级编码</h1><p id="e0e2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="2f2c" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="842c" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">📰查看更多内容请参见<a class="ae ky" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="dbb0" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">🔔关注我们:<a class="ae ky" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ky" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ky" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="5b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🚀👉<a class="ae ky" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>