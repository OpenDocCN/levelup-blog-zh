<html>
<head>
<title>App Lifecycle in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振中的应用生命周期</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/app-lifecycle-in-flutter-e4ba686d16fe?source=collection_archive---------0-----------------------#2021-03-14">https://levelup.gitconnected.com/app-lifecycle-in-flutter-e4ba686d16fe?source=collection_archive---------0-----------------------#2021-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cfb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">探索具有可重用逻辑的应用生命周期方法</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/efff700fa9e3305c060457fd3b2ce849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqOKBM2RCpdgu7IItven7A.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Flutter应用生命周期</figcaption></figure><p id="44b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和所有的框架一样，Flutter也有一个和每个应用相关的生命周期。在本文中，我们将看看Flutter中不同的应用生命周期方法。</p><p id="580b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将探讨如何在我们的应用程序中观察方向变化。最后，我们将看到如何重用生命周期逻辑，以便所有的生命周期方法在我们的应用程序中都可用。内容太多了，让我们开始吧！</p><h1 id="1163" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">应用生命周期方法</h1><p id="9486" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">下面是由<a class="ae me" href="https://api.flutter.dev/flutter/dart-ui/AppLifecycleState-class.html" rel="noopener ugc nofollow" target="_blank"><em class="mf">applifecyclsate</em></a><code class="fe mg mh mi mj b">enum</code>定义的Flutter中的app生命周期状态:</p><ul class=""><li id="d97f" class="mk ml iq jp b jq jr ju jv jy mm kc mn kg mo kk mp mq mr ms bi translated"><strong class="jp ir">分离的:</strong>应用程序仍然托管在一个颤振引擎上，但是从任何主机视图中分离。这可能是当引擎已经启动但没有连接到任何视图时，或者当视图由于导航器弹出而被破坏时。</li><li id="2df6" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated"><strong class="jp ir">不活动:</strong>应用程序处于不活动状态，没有接收用户输入。在两个平台上打电话时，应用程序都进入这种状态。处于这种状态的应用程序应该假设它们可能随时被暂停。</li><li id="99e0" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated"><strong class="jp ir">暂停</strong>:应用程序当前对用户不可见，正在后台运行。这是你按下Home键的时候。</li><li id="3c01" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated"><strong class="jp ir">恢复:</strong>应用程序可见并响应用户输入。在这种状态下，应用程序在前台。</li></ul><p id="025a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理论到此为止，是时候用代码来弄脏我们的手了。我们开始吧！</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="ed04" class="lb lc iq bd ld le nf lg lh li ng lk ll lm nh lo lp lq ni ls lt lu nj lw lx ly bi translated">履行</h1><p id="d79c" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">为了从widgets层观察不同的生命周期状态，我们使用了<a class="ae me" href="https://api.flutter.dev/flutter/widgets/WidgetsBindingObserver-class.html" rel="noopener ugc nofollow" target="_blank"> WidgetsBindingObserver </a>类。</p><p id="f72f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个<code class="fe mg mh mi mj b">StatefulWidget</code>和<code class="fe mg mh mi mj b">WidgetsBindingObserver</code>为:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c2a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用这个类时，我们需要通过添加和删除观察者来适当地管理它，如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3092" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们使用<code class="fe mg mh mi mj b">addObserver</code>方法添加观察者，并通过传递当前上下文使用<code class="fe mg mh mi mj b">removeObserver</code>方法移除观察者。</p><blockquote class="nm nn no"><p id="8c7f" class="jn jo mf jp b jq jr js jt ju jv jw jx np jz ka kb nq kd ke kf nr kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">为简洁起见，本文仅包含必要的代码，您可以在文章末尾找到GitHub到完整源代码库的链接。</em> </strong></p></blockquote><p id="6442" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mg mh mi mj b">WidgetsBindingObserver</code>类提供了各种方法，但是我们感兴趣的是<code class="fe mg mh mi mj b">didChangeAppLifecycleState</code>，它将<code class="fe mg mh mi mj b">AppLifecycleState</code>对象作为参数。在这里，我们可以检查前面提到的各种状态，并执行适当的操作。例如，我们可以在状态为<code class="fe mg mh mi mj b">paused</code>时暂停音频回放，并在状态为<code class="fe mg mh mi mj b">resumed</code>时再次继续回放。在这个例子中，为了简单起见，我们只使用print语句。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="43bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还使用<code class="fe mg mh mi mj b">OrientationBuilder</code>来跟踪器件方向。我们还有一个<code class="fe mg mh mi mj b">FlatButton</code>来导航到新的路线。本文后面将重点介绍它的用法。我们的构建方法如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1fa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们运行应用程序时，我们可以看到屏幕上显示的当前方向。</p><p id="3478" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您按下Home按钮时，您可以在日志中看到以下内容:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/af4b12ab7a14459cf7d6ea38a785c6d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0yg21vGo81lWimuXZHQFBg.png"/></div></div></figure><p id="86ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您再次打开应用程序时，您可以看到以下日志:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/cf9023416f9a251b0081b0d89e92bd08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PmLJ4sS9PweyHZ7MZ8xMcg.png"/></div></div></figure><p id="c689" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，日志中正确地反映了这些状态。现在，使用按钮导航到新路线，并遵循上述步骤。令人惊讶的是，您在日志中看不到任何正在打印的内容。这是因为新路由没有实现<code class="fe mg mh mi mj b">WidgetsBindingObserver</code>。让我们现在就解决这个问题。</p><p id="bc85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个简单但不太好的方法是在这里也实现<code class="fe mg mh mi mj b">WidgetsBindingObserver</code>类。但是，假设您希望该类跨越应用程序中的所有路由。在这种情况下，你需要在每个类中实现它，这不是一个明智的决定。</p><p id="4fea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种方法是创建一个新的小部件，并将其包装在<code class="fe mg mh mi mj b">MaterialApp</code>小部件周围，这样它就可以在我们应用程序的任何地方被访问。这里我们将使用第二种方法。</p><p id="4280" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一个新的小部件<code class="fe mg mh mi mj b">LifecycleManager</code>，并按照相同的步骤添加<code class="fe mg mh mi mj b">WidgetsBindingObserver</code>和<code class="fe mg mh mi mj b">didChangeAppLifecycleState</code>方法。添加一个类型为<code class="fe mg mh mi mj b">Widget</code>的新参数<code class="fe mg mh mi mj b">child</code>来显示应用程序中包含的小部件。</p><p id="bde0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终的<code class="fe mg mh mi mj b">LifecycleManager</code>是这样的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="659e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是用新创建的<code class="fe mg mh mi mj b">LifecycleManager</code>小部件包装<code class="fe mg mh mi mj b">MaterialApp</code>小部件，并将<code class="fe mg mh mi mj b">MaterialApp</code>作为子小部件传递。最后的<code class="fe mg mh mi mj b">main.dart</code>是这样的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f208" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在运行应用程序，并在两条路线上遵循相同的过程。您可以看到在两条路线上都打印了<code class="fe mg mh mi mj b">AppLifecycleState</code>日志。我们现在可以在应用程序的所有屏幕上访问应用程序的生命周期状态，并相应地执行所需的操作。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="87d5" class="lb lc iq bd ld le nf lg lh li ng lk ll lm nh lo lp lq ni ls lt lu nj lw lx ly bi translated">结论</h1><p id="c3a1" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">在本文中，我们探索了Flutter中不同的应用生命周期方法。我们还看到了如何通过创建一个单独的类来管理整个应用程序的生命周期状态，从而重用逻辑。</p><p id="1d9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的源代码可以在下面的链接中找到:</p><div class="nu nv gp gr nw nx"><a href="https://github.com/harshshinde07/Flutter-App-Lifecycle" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd ir gy z fp oc fr fs od fu fw ip bi translated">harsh shinde 07/Flutter-App-生命周期</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">通过在GitHub上创建帐户，为harsh shinde 07/Flutter-App-life cycle开发做出贡献。</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">github.com</p></div></div><div class="og l"><div class="oh l oi oj ok og ol kv nx"/></div></div></a></div></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h2 id="ca4c" class="om lc iq bd ld on oo dn lh op oq dp ll jy or os lp kc ot ou lt kg ov ow lx ox bi translated">感谢您阅读这篇文章。如果你喜欢这篇文章或者学到了新的东西，尽可能多地鼓掌以示支持。👏</h2><h2 id="eedf" class="om lc iq bd ld on oo dn lh op oq dp ll jy or os lp kc ot ou lt kg ov ow lx ox bi translated">这真的激励我继续写更多！:)</h2><h2 id="ff21" class="om lc iq bd ld on oo dn lh op oq dp ll jy or os lp kc ot ou lt kg ov ow lx ox bi translated">如果有错误，请随时纠正。</h2><h2 id="d21c" class="om lc iq bd ld on oo dn lh op oq dp ll jy or os lp kc ot ou lt kg ov ow lx ox bi translated">我们来连线:</h2><ul class=""><li id="344f" class="mk ml iq jp b jq lz ju ma jy oy kc oz kg pa kk mp mq mr ms bi translated"><a class="ae me" href="https://github.com/harshshinde07/" rel="noopener ugc nofollow" target="_blank"> GitHub </a></li><li id="c9de" class="mk ml iq jp b jq mt ju mu jy mv kc mw kg mx kk mp mq mr ms bi translated"><a class="ae me" href="https://www.linkedin.com/in/harshshinde07/" rel="noopener ugc nofollow" target="_blank">领英</a></li></ul></div></div>    
</body>
</html>