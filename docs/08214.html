<html>
<head>
<title>Handling Dependency Injection in Inherited Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理继承类中的依赖注入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handling-dependency-injection-in-inherited-classes-d7ae78952f1a?source=collection_archive---------9-----------------------#2021-04-11">https://levelup.gitconnected.com/handling-dependency-injection-in-inherited-classes-d7ae78952f1a?source=collection_archive---------9-----------------------#2021-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/81f49166ad5fc84d3206d44b0f7054e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Kl6AtKL6pL86KIGKPUrbQ.jpeg"/></div></div></figure><p id="81b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">依赖注入(DI)是一件很棒的事情。只需将您的依赖项作为一个参数添加到您的类的构造函数(最常见的),将它注册到您的DI容器中，然后您就可以离开了——DI容器将管理剩下的工作。DI的一些主要好处是:更好的可测试性、更好的可维护性和更好的可重用性。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="607a" class="lf lg iq lb b gy lh li l lj lk">// without DI<br/>public class OrderController : Controller<br/>{<br/>    public ActionResult Post(Order order)<br/>    {<br/>        using (var dbContent = new MyDbContext())<br/>        {<br/>            dbContext.Orders.Add(order);<br/>            dbContent.SaveChanges();</span><span id="6930" class="lf lg iq lb b gy ll li l lj lk">            return Ok();<br/>        }<br/>    }</span><span id="231e" class="lf lg iq lb b gy ll li l lj lk">    public ActionResult Get()<br/>    {<br/>        using (var dbContext = new MyDbContext())<br/>        {<br/>            var orders = dbContext.Orders.ToList();</span><span id="c66c" class="lf lg iq lb b gy ll li l lj lk">            return new JsonResult(orders);<br/>        }<br/>    }<br/>}</span><span id="9971" class="lf lg iq lb b gy ll li l lj lk">// with DI<br/>public class OrderController : Controller<br/>{<br/>    private readonly MyDbContext _dbContext;</span><span id="7242" class="lf lg iq lb b gy ll li l lj lk">    public OrderController(MyDbContext dbContext)<br/>    {<br/>        _dbContext = dbContext;<br/>    }</span><span id="0449" class="lf lg iq lb b gy ll li l lj lk">    public ActionResult Post(Order order)<br/>    {<br/>        _dbContext.Orders.Add(order);<br/>        _dbContent.SaveChanges();</span><span id="9895" class="lf lg iq lb b gy ll li l lj lk">        return Ok();<br/>    }</span><span id="1339" class="lf lg iq lb b gy ll li l lj lk">    public ActionResult Get()<br/>    {<br/>        var orders = _dbContext.Orders.ToList();</span><span id="8d6b" class="lf lg iq lb b gy ll li l lj lk">        return new JsonResult(orders);<br/>    }<br/>}</span></pre><p id="a1be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我最近遇到了一个用例，在这个用例中，DI真的很麻烦——继承类中的依赖注入。</p><h1 id="7f3c" class="lm lg iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">问题是</h1><p id="18a1" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我最近一直在使用<a class="ae mo" href="https://github.com/jbogard/MediatR" rel="noopener ugc nofollow" target="_blank">mediator</a>包，使用它的请求/请求处理程序模式在系统中发布命令(灵感来自<a class="ae mo" href="https://github.com/jasontaylordev/CleanArchitecture" rel="noopener ugc nofollow" target="_blank">贾森·泰勒的干净架构解决方案</a>)。</p><p id="9194" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我通常会创建一个RequestHandler基类，其中包含常见的依赖项和功能。然后，每个具体的请求处理程序都可以从这个基类继承。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="9324" class="lf lg iq lb b gy lh li l lj lk">public abstract class RequestHandler&lt;TRequest, TResponse&gt; : IRequestHandler&lt;TRequest, TResponse&gt;<br/>    where TRequest : IRequest&lt;TResponse&gt;<br/>{<br/>    public RequestHandler(IApplicationDbContext dbContext)<br/>    {<br/>        DbContext = dbContext;<br/>    }</span><span id="43d4" class="lf lg iq lb b gy ll li l lj lk">    protected IApplicationDbContext DbContext { get; }</span><span id="8a4e" class="lf lg iq lb b gy ll li l lj lk">    public abstract Task&lt;TResponse&gt; Handle(TRequest request, CancellationToken cancellationToken);<br/>}</span><span id="e16c" class="lf lg iq lb b gy ll li l lj lk">public MyRequestHandler : RequestHandler&lt;MyRequest, MyResponse&gt;<br/>{<br/>    public MyRequestHandler(IApplicationDbContext dbContext) : base(dbContext) { }</span><span id="9ed3" class="lf lg iq lb b gy ll li l lj lk">    public override Task&lt;MyResponse&gt; Handle(MyRequest request, CancellationToken cancellationToken)<br/>    {<br/>        // handler logic<br/>    }<br/>}</span></pre><p id="2d79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我想给基类添加更多的依赖项时，问题就来了。现在，我必须检查每一个具体的请求处理程序，并更新构造函数以获取新的依赖关系。幸运的是，如果我错过了一个，代码将不会编译，所以没有运行时错误的风险，但是必须更新每个请求处理程序仍然是令人难以置信的繁琐工作。此外，您可能会以非常大的构造函数而告终，这掩盖了类的意图。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="a46b" class="lf lg iq lb b gy lh li l lj lk">public abstract class RequestHandler&lt;TRequest, TResponse&gt; : IRequestHandler&lt;TRequest, TResponse&gt;<br/>    where TRequest : IRequest&lt;TResponse&gt;<br/>{<br/>    public RequestHandler(IApplicationDbContext dbContext, ICurrentUser currentUser)<br/>    {<br/>        DbContext = dbContext;<br/>        CurrentUser = currentUser;<br/>    }</span><span id="4c55" class="lf lg iq lb b gy ll li l lj lk">    protected IApplicationDbContext DbContext { get; }<br/>    protected ICurrentUser CurrentUser { get; }</span><span id="888f" class="lf lg iq lb b gy ll li l lj lk">    public abstract Task&lt;TResponse&gt; Handle(TRequest request, CancellationToken cancellationToken);<br/>}</span><span id="5878" class="lf lg iq lb b gy ll li l lj lk">public MyRequestHandler : RequestHandler&lt;MyRequest, MyResponse&gt;<br/>{<br/>    public MyRequestHandler(IApplicationDbContext dbContext, ICurrentUser currentUser) : base(dbContext, currentUser) { }</span><span id="7438" class="lf lg iq lb b gy ll li l lj lk">    public override Task&lt;MyResponse&gt; Handle(MyRequest request, CancellationToken cancellationToken)<br/>    {<br/>        // handler logic<br/>    }<br/>}</span></pre><h1 id="dc88" class="lm lg iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">解决方案—依赖关系聚合</h1><p id="cc85" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">这个问题的解决方法真的很简单。与其直接注入依赖项，不如创建一个包含依赖项的新类(称为聚合)并注入它。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="7ea4" class="lf lg iq lb b gy lh li l lj lk">public interface IDependencyAggregate <br/>{<br/>    IApplicationDbContext DbContext { get; }<br/>    ICurrentUser { get; }<br/>}</span><span id="fafd" class="lf lg iq lb b gy ll li l lj lk">public class DependencyAggregate : IDependencyAggregate<br/>{<br/>    public DependencyAggregate(IApplicationDbContext dbContext, ICurrentUser currentUser)<br/>    {<br/>        DbContext = dbContext;<br/>        CurrentUser = currentUser;<br/>    }</span><span id="28fd" class="lf lg iq lb b gy ll li l lj lk">    public IApplicationDbContext DbContext { get; }<br/>    public ICurrentUser CurrentUser { get; }<br/>}</span><span id="4736" class="lf lg iq lb b gy ll li l lj lk">public abstract class RequestHandler&lt;TRequest, TResponse&gt; : IRequestHandler&lt;TRequest, TResponse&gt;<br/>    where TRequest : IRequest&lt;TResponse&gt;<br/>{<br/>    public RequestHandler(IDependencyAggregate aggregate)<br/>    {<br/>        DbContext = aggregate.DbContext;<br/>        CurrentUser = aggregate.CurrentUser;<br/>    }</span><span id="33cb" class="lf lg iq lb b gy ll li l lj lk">    protected IApplicationDbContext DbContext { get; }<br/>    protected ICurrentUser CurrentUser { get; }</span><span id="77f3" class="lf lg iq lb b gy ll li l lj lk">    public abstract Task&lt;TResponse&gt; Handle(TRequest request, CancellationToken cancellationToken);<br/>}</span><span id="79e1" class="lf lg iq lb b gy ll li l lj lk">public MyRequestHandler : RequestHandler&lt;MyRequest, MyResponse&gt;<br/>{<br/>    public MyRequestHandler(IDependencyAggregate aggregate) : base(aggregate) { }</span><span id="a878" class="lf lg iq lb b gy ll li l lj lk">    public override Task&lt;MyResponse&gt; Handle(MyRequest request, CancellationToken cancellationToken)<br/>    {<br/>        // handler logic<br/>    }<br/>}</span></pre><p id="6878" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我想添加一个新的依赖项，我需要更改代码的地方只有DependencyAggregate类和RequestHandler基类(我不需要对继承的类做任何更改)。</p><h1 id="aef1" class="lm lg iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="2b97" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在这篇文章中，我描述了一个简单的方法来管理继承类中的依赖注入，通过创建一个依赖聚合类来注入基类。这确保了新的依赖关系可以很容易地引入，而不必对每个继承的类进行更改。</p><p id="e9e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发布的大部分内容都是关于全栈的。NET和Vue web开发。为了确保你不会错过任何帖子，请关注这个博客并<a class="ae mo" href="https://samwalpole.com" rel="noopener ugc nofollow" target="_blank">订阅我的简讯</a>。如果你觉得这篇文章有帮助，请喜欢它并分享它。你也可以在推特上找到我。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="8726" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mw">最初发表于</em><a class="ae mo" href="https://samwalpole.com/handling-dependency-injection-in-inherited-classes" rel="noopener ugc nofollow" target="_blank"><em class="mw">【https://samwalpole.com】</em></a><em class="mw">。</em></p></div></div>    
</body>
</html>