<html>
<head>
<title>Operating System — Inter-process Communication (IPC)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">操作系统—进程间通信(IPC)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/operating-system-inter-process-communication-ipc-60a288b11d18?source=collection_archive---------5-----------------------#2021-06-21">https://levelup.gitconnected.com/operating-system-inter-process-communication-ipc-60a288b11d18?source=collection_archive---------5-----------------------#2021-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dd93" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">仅用3分钟了解IPC</h2></div><p id="bdd4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进程间通信 ( <strong class="kh ir"> IPC </strong>)只是进程管理共享数据的一种机制。在两个进程之间共享数据最常用的对象是管道。</p><h2 id="098c" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">什么是烟斗？</strong></h2><p id="2126" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">管道是两个进程之间的共享对象，用于相互传输数据。它是单向的，这意味着数据只能从左向右流动。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/c5c6d50d77a4ee70107f0750216c7d23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zFOdnuaQbrVgqJRGNkGkcA.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">进程间通信的示例</figcaption></figure><p id="5fbd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在内核深处，pipe()系统调用在内核空间中创建了一个共享FIFO队列。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mp"><img src="../Images/86699cee0032a1a7d9c2d3ea110627e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rztxCQJ2d8b5zXlEMILJPw.png"/></div></div></figure><p id="80eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本例中，“ls”进程是一个生产者，它将数据写入管道。“less”进程是一个消费者，它从管道中读取数据。</p><p id="c03a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，你可能会意识到可能会有问题。缓冲区的大小有限。如果“ls”生产太快而“less”消耗太慢怎么办？</p><p id="2940" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这被称为<strong class="kh ir">生产者-消费者问题</strong>，是一个同步问题。生产者-消费者问题是经典的IPC问题之一，我稍后会谈到它。</p><p id="2a72" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于用户空间内存不能在进程间共享，即使它们是父进程和子进程，因此共享对象在内核级提供。除了管道，还有其他IPC问题。您可能必须直接使用共享内存和共享文件。并发访问可能会导致不可预知的结果，内核不会帮助你解决这个问题。</p><h2 id="eccd" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">竞争条件</h2><p id="fc46" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">当进程共享同一个内存时，我们不能不讨论竞争条件。如果我们不好好照顾它，它可能会变成一只虫子。</p><p id="34fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">竞争条件意味着执行的结果取决于访问共享资源的特定顺序。这可能发生在以下情况:</p><ol class=""><li id="5949" class="mq mr iq kh b ki kj kl km ko ms ks mt kw mu la mv mw mx my bi translated">有共享对象</li><li id="1558" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated">有多个过程</li><li id="e750" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated">这些进程同时访问共享对象</li></ol><p id="0cf2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">竞争条件总是一场噩梦，因为很难调试。</p><h2 id="9d6b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">如何解决共享对象上的竞争情况？</h2><p id="0c54" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><strong class="kh ir">互斥</strong></p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ne"><img src="../Images/573fc238f757b3cb935f030aed62ad6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_M0jjP4ZxG39zClYBxMypw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">互斥现象</figcaption></figure><p id="99e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我玩共享内存时，没有人能碰它。如果保证<em class="nf">互斥</em>，一组进程就不会有竞争条件的问题。</p><p id="ca67" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住。共享对象仍然是可共享的，但是:<br/> -共享对象不能同时共享<strong class="kh ir"/><br/>-必须逐个共享</p><p id="d491" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现互斥，程序代码可以分为3个部分:</p><ol class=""><li id="3bfa" class="mq mr iq kh b ki kj kl km ko ms ks mt kw mu la mv mw mx my bi translated"><strong class="kh ir">区段入口</strong>:临界区段的开始。告诉其他进程共享内存正在被使用。</li><li id="ea11" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated"><strong class="kh ir">临界区</strong>:访问共享对象的代码段。它应该尽可能的紧。</li><li id="67c4" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated"><strong class="kh ir">断面出口</strong>:临界断面结束。告诉其他进程共享内存现在是空闲的。</li></ol><p id="cf14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，互斥是通过在一个进程已经在访问临界区时阻止其他进程进入临界区来实现的。</p><h2 id="66ba" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">如何通过编程实现互斥？</strong></h2><p id="4219" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><strong class="kh ir">旋转锁</strong></p><p id="a56b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是在另一个共享对象上循环，<strong class="kh ir">转</strong>，检测其他进程的状态。</p><p id="4350" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，流程A:</p><pre class="ma mb mc md gt ng nh ni nj aw nk bi"><span id="6e23" class="lb lc iq nh b gy nl nm l nn no">while (TRUE) {<br/>  while( turn != <strong class="nh ir">0</strong> ) /* busy waiting */</span><span id="1de7" class="lb lc iq nh b gy np nm l nn no"><strong class="nh ir">  ----------------------<br/>  critical_section();</strong></span><span id="583e" class="lb lc iq nh b gy np nm l nn no"><strong class="nh ir">  ----------------------  </strong><br/>  <br/>  <strong class="nh ir">turn = 1;</strong><br/>  <br/>  remainder_section();<br/>}</span></pre><p id="4424" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">流程B:</p><pre class="ma mb mc md gt ng nh ni nj aw nk bi"><span id="ae93" class="lb lc iq nh b gy nl nm l nn no">while (TRUE) {<br/>  while( turn != <strong class="nh ir">1</strong>) /* busy waiting */</span><span id="7a02" class="lb lc iq nh b gy np nm l nn no"><strong class="nh ir">----------------------<br/>  critical_section();</strong></span><span id="5781" class="lb lc iq nh b gy np nm l nn no"><strong class="nh ir">----------------------  </strong><br/>  <br/>  <strong class="nh ir">turn = 0;</strong><br/>  <br/>  remainder_section();<br/>}</span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nq"><img src="../Images/5a678954e2bc07feec3c417fb3625472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7TaP5BxfPj5NnLVKcAEkw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">自旋锁示例</figcaption></figure><p id="90c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">彼得森的解决方案</strong></p><p id="deb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">彼得森的解决方案</strong>类似于自旋锁。除了“<strong class="kh ir"> turn </strong>之外，还使用了一个额外的共享对象“<strong class="kh ir">interest”</strong>。如果我不表现出兴趣，我会让其他进程使用共享内存。如果所有的进程都表现出兴趣，那么所有的进程必须轮流进行。</p><p id="4748" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，流程A:</p><pre class="ma mb mc md gt ng nh ni nj aw nk bi"><span id="ac5b" class="lb lc iq nh b gy nl nm l nn no"><strong class="nh ir">interested[process] = TRUE</strong>;</span><span id="0bba" class="lb lc iq nh b gy np nm l nn no">while( <strong class="nh ir">turn == process</strong> &amp;&amp; <strong class="nh ir">interested[other process] == TRUE</strong> )</span><span id="d4f7" class="lb lc iq nh b gy np nm l nn no">/* busy waiting */</span><span id="0253" class="lb lc iq nh b gy np nm l nn no"><strong class="nh ir">----------------------<br/>  critical_section();</strong></span><span id="1b74" class="lb lc iq nh b gy np nm l nn no"><strong class="nh ir">----------------------  </strong><br/>  <br/>  <strong class="nh ir">interested[process] = FALSE</strong>;<br/>  <br/>  remainder_section();<br/>}</span></pre><p id="3486" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">流程B(与流程A相同):</p><pre class="ma mb mc md gt ng nh ni nj aw nk bi"><span id="4950" class="lb lc iq nh b gy nl nm l nn no"><strong class="nh ir">interested[process] = TRUE</strong>;</span><span id="7728" class="lb lc iq nh b gy np nm l nn no">while( <strong class="nh ir">turn == process</strong> &amp;&amp; <strong class="nh ir">interested[other process] == TRUE</strong> )</span><span id="bb01" class="lb lc iq nh b gy np nm l nn no">/* busy waiting */</span><span id="87b2" class="lb lc iq nh b gy np nm l nn no"><strong class="nh ir">----------------------<br/>  critical_section();</strong></span><span id="2a78" class="lb lc iq nh b gy np nm l nn no"><strong class="nh ir">----------------------  </strong><br/>  <br/>  <strong class="nh ir">interested[process] = FALSE</strong>;<br/>  <br/>  remainder_section();<br/>}</span></pre><p id="940d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，互斥有一个明显的缺点。它阻碍了并行计算的性能。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h2 id="3338" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">后续步骤</h2><p id="c7c2" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如果你正在读这一行，恭喜你！！！你做到了。您已经学习了IPC的基础知识以及如何解决进程的竞争情况。有一些有趣的IPC问题，如生产者-消费者问题和用餐哲学家问题，绝对值得一提。希望我能在未来讨论其中的一些。</p><p id="6156" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请随意查看下面关于操作系统的其他文章:</p><div class="ny nz gp gr oa ob"><a href="https://mattchw.medium.com/overview-of-operating-system-cc3f6f6bb062" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">操作系统概述</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">操作系统一般是如何工作的？</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">mattchw.medium.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op mj ob"/></div></div></a></div><p id="a57c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要了解更多关于我的后端学习路径，请点击这里查看我的旅程:</p><div class="ny nz gp gr oa ob"><a href="https://medium.com/@matthew.chohin/my-backend-developer-learning-journey-%E6%88%91%E7%9A%84%E5%BE%8C%E7%AB%AF%E5%AD%B8%E7%BF%92%E4%B9%8B%E6%97%85-5315fe2fefc2" rel="noopener follow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi">My Backend Developer Learning Journey 我的後端學習之旅</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">毕业一年多了。拥有2年以上的前端和后端工作经验…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="oq l om on oo ok op mj ob"/></div></div></a></div></div></div>    
</body>
</html>