<html>
<head>
<title>Quit Believing In Framework “Magic”!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要相信框架“魔力”！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/youll-quit-believing-in-framework-magic-1d4b6f77fdaf?source=collection_archive---------22-----------------------#2022-11-28">https://levelup.gitconnected.com/youll-quit-believing-in-framework-magic-1d4b6f77fdaf?source=collection_archive---------22-----------------------#2022-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2491" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你真的需要使用所有这些框架和库吗？你知道如何实现它们吗？你能去掉它们中的任何一个吗？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/68792646697fc18e2f99c7b097a6fa19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cas99OsOr83b9HKV"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Hibernate的文档——由<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae le" href="https://unsplash.com/@dollargill?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dollar Gill </a>拍摄</figcaption></figure><h1 id="2b7b" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">1.“好的厨师不使用蛋糕配料”——克里斯汀·戈尔曼</h1><p id="63b2" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我最近在2011年的一次JavaZone会议上看到了一个有趣的简短演讲。在录音中，Christin Gorman用<em class="mi">现成的蛋糕配料</em>和<em class="mi"> Hibernate </em>之间的幽默类比来展示盲目采用“酷”框架和库的负面影响。</p><p id="dc00" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管我并不热衷于放弃Hibernate(<em class="mi">还没有</em>)，但我对视频中的想法产生了很多共鸣。</p><p id="9fcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，学习一个新的、看起来很酷的框架的诱惑，而不是投资一些时间来巩固基础。</p><p id="cc42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者努力使代码适应各种框架和库，而不是将创造性的精力投入到解决实际的业务问题中。</p><p id="0781" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该视频只有9分钟长，我强烈建议您观看:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mj mk l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="b927" class="lf lg it bd lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly mw ma mb mc bi translated"><strong class="ak"> 2。“让魔法消失吧！”—鲍勃大叔</strong></h1><p id="6374" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">看了Christin的演示，首先想到的是Bob大叔博客上的<em class="mi"/><a class="ae le" href="https://blog.cleancoder.com/uncle-bob/2015/08/06/LetTheMagicDie.html" rel="noopener ugc nofollow" target="_blank"><em class="mi">让魔法消失</em></a><em class="mi"/>文章<em class="mi">。</em>在这篇博文中，罗伯特·c·马丁从不同的角度讨论了同一个话题。</p><p id="8bd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">他从解释如何创建框架和库来补充编程语言的不足开始。</p><p id="271b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在那之后，他认为，作为开发人员，我们一直在寻找完美的语言或框架，因为我们相信魔法。</p><p id="1ef0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">他用“<em class="mi">魔法</em>”来比喻框架和它们提供的功能。我们不完全理解的功能，我们不知道如何实现自己，但认为是理所当然的。</p><p id="a61c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，Bob叔叔说，唯一的逃避就是在盲目使用框架之前，实现它必须提供的任何特性。这将“<em class="mi">让魔法消失</em>”，并帮助我们理解问题到底是什么，这个库做什么，并将帮助我们决定我们是否真的需要它。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/7811c49d26dc87bd6c054ea4b560da16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sJRdZlb-YO7aZ31D"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@dani3cla?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">达尼洛·达戈斯蒂诺</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="682b" class="lf lg it bd lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly mw ma mb mc bi translated">3.我个人的看法</h1><p id="0dc1" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这两个演讲真的让我思考。我开始思考我正在使用的所有不同的库和框架。我能去掉它们中的任何一个吗？如果没有，为什么？</p><p id="c255" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">过了一段时间，我得出结论，这个决定不必如此激进。在编程术语中，它不必是一个“布尔”值。</p><p id="bbff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，即使不可能(或者我们不想)完全放弃一个库，我们仍然可以将它的使用限制在带来最大价值的特性上。</p><p id="f22b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我提出了四个问题，可以指导我决定是否应该使用一个库或框架的特性。女士们先生们，请允许我向你们提出“<em class="mi"> M.U.L.E. </em>”问题:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi my"><img src="../Images/1f8b3650852c4c0951d8294cdb3ffc5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S0RRy285NEgg9C8U"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">劳拉·尼豪斯在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="85b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi mz translated"><span class="l na nb nc bm nd ne nf ng nh di">M</span>T12】agic:它带来多少<strong class="js iu">魔法</strong>？<br/>你能理解它是做什么的吗？即使之前没有使用过图书馆？即使没有阅读文档？你能自己实现它吗？</p><p id="9a94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi mz translated"><span class="l na nb nc bm nd ne nf ng nh di">U</span>T19】utility:它<strong class="js iu">有多大用处</strong>？<br/>它是在实现非常复杂的东西吗？这对你避免编写样板代码有帮助吗？它有更好的性能吗？如果您首先决定使用这个工具，它可能会提供一些东西。</p><p id="d1ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi mz translated"><span class="l na nb nc bm nd ne nf ng nh di">L</span>T26】层:在你系统的哪个<strong class="js iu">层</strong>里？<br/>离你的领域层越近，你就越不愿意添加它。换句话说，我们希望避免在我们的领域层中使用外部库或侵入式框架。另一方面，当谈到“<em class="mi">基础设施</em>”层时，我们会不那么严谨。例如，您不会想要从头构建一个OpenAPI/Swagger-UI网页。</p><p id="3a4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi mz translated"><span class="l na nb nc bm nd ne nf ng nh di">E</span><strong class="js iu">errors</strong>:如何<strong class="js iu">易错</strong>？<br/>用它容易出错吗？这会让你的代码更难测试吗？</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="93d3" class="lf lg it bd lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly mw ma mb mc bi translated">4.代码示例</h1><p id="2ff0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我希望你已经走了这么远。现在是时候做我们最喜欢的事情了，开始研究一些代码片段。</p><p id="f13e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这一节，我选择了三个流行的Java库/框架。对于它们中的每一个，我们将把它与潜在的普通Java替代方案进行比较，并使用M.U.L.E问题对其进行评估。</p><h2 id="c5f3" class="ni lg it bd lh nj nk dn ll nl nm dp lp kb nn no lt kf np nq lx kj nr ns mb nt bi translated">4.1.MapStruct</h2><p id="453b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">MapStruct是一个Java库，可以用最少的配置生成<em class="mi"> Mapper </em>对象。如果两个对象中的字段具有相同的名称和类型，它们将被自动映射。否则，将需要额外的注释。</p><pre class="kp kq kr ks gt nu nv nw bn nx ny bi"><span id="0051" class="nz lg it nv b be oa ob l oc od">@Mapper(componentModel = "spring")<br/>public interface EmployeeMapstructMapper {<br/><br/>   @Mapping(target="employeeId", source="employee.id")<br/>   @Mapping(target="employeeName", source="employee.name")<br/>   EmployeeDto toDto(Employee employee);<br/><br/>   @Mapping(target="id", source="dto.employeeId")<br/>   @Mapping(target="name", source="dto.employeeName")<br/>   Employee fromDto(EmployeeDto dto);<br/>}</span></pre><ul class=""><li id="53b7" class="oe of it js b jt ju jx jy kb og kf oh kj oi kn oj ok ol om bi translated"><strong class="js iu">魔法</strong>:我认为代码片段中的映射非常简单。如果没有以前的经验，我可能不知道<em class="mi"> componentModel = "spring" </em>是做什么的。</li><li id="c89e" class="oe of it js b jt on jx oo kb op kf oq kj or kn oj ok ol om bi translated">如果字段具有相同的名称和类型，Mapstruct允许我们通过自动映射字段来避免编写样板代码。</li><li id="a7e1" class="oe of it js b jt on jx oo kb op kf oq kj or kn oj ok ol om bi translated">层:我们将使用领域层之外的映射器。</li><li id="b34e" class="oe of it js b jt on jx oo kb op kf oq kj or kn oj ok ol om bi translated"><strong class="js iu">错误</strong>:如果我们决定重命名领域模型中的一个字段(例如“department”)，我们可能会忘记更新所有相关的映射器，并添加一个<em class="mi"> @Mapping </em>注释来指定新名称。</li></ul><pre class="kp kq kr ks gt nu nv nw bn nx ny bi"><span id="fa57" class="nz lg it nv b be oa ob l oc od">public class EmployeeMapper { <br/>  public static EmployeeDto toDto(Employee employee) {<br/>    if(isNull(employee)) {<br/>      return null;<br/>    }<br/>    EmployeeDto dto = new EmployeeDto();<br/>    dto.setEmployeeId(employee.getId());<br/>    dto.setEmployeeName(employee.getName());<br/>    dto.setDepartment(employee.getDepartment());<br/>    return dto;<br/>  }<br/>  <br/>  public static Employee fromDto(EmployeeDto dto) {<br/>    if(isNull(dto)) {<br/>      return null;<br/>    }<br/>    Employee employee = new Employee();<br/>    employee.setId(dto.getEmployeeId());<br/>    employee.setName(dto.getEmployeeName());<br/>    employee.setDepartment(dto.getDepartment());<br/>    return employee;<br/>  }<br/>}</span></pre><p id="1f64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于大部分字段重合的大模型，MapStruct可以派上用场。</p><p id="6c61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不过，对于更复杂的场景(例如，映射嵌套对象)，这个库会带来太多的<em class="mi">魔法</em>来迎合我的口味。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h2 id="e491" class="ni lg it bd lh nj nk dn ll nl nm dp lp kb nn no lt kf np nq lx kj nr ns mb nt bi translated">4.2.Spring自定义验证程序</h2><p id="c20b" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">让我们看看用Spring创建自定义验证的推荐方法。这通常通过一个新的定制注释和一个针对它的<em class="mi"> ConstraintValidator </em>实现来完成。</p><p id="00ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看它的样子，并将其与普通的Java替代方案进行比较:</p><pre class="kp kq kr ks gt nu nv nw bn nx ny bi"><span id="3e38" class="nz lg it nv b be oa ob l oc od">@Documented<br/>@Constraint(validatedBy = PhoneNumberValidator.class)<br/>@Target({ElementType.METHOD, ElementType.FIELD})<br/>@Retention(RetentionPolicy.RUNTIME)<br/>public @interface ValidPhoneNumber {<br/>  String message() default "Invalid phone number";<br/><br/>  Class&lt;?&gt;[] groups() default {};<br/><br/>  Class&lt;? extends Payload&gt;[] payload() default {};<br/>}<br/><br/>public class PhoneNumberValidator implements ConstraintValidator&lt;ValidPhoneNumber, String&gt; {<br/>  @Override<br/>  public boolean isValid(String phoneNumbe, ConstraintValidatorContext cxt) {<br/>   return phoneNumber != null<br/>     &amp;&amp; phoneNumber.matches("[0-9]+")<br/>     &amp;&amp; (phoneNumber.length() &gt; 8)<br/>     &amp;&amp; (phoneNumber.length() &lt; 14);<br/>  }<br/>}<br/><br/>public class Employee {<br/>  private String name;<br/>  private Long id;<br/>  @ValidPhoneNumber<br/>  private String phoneNumber;<br/><br/>  // all arguments constructor<br/>}</span></pre><ul class=""><li id="bfd5" class="oe of it js b jt ju jx jy kb og kf oh kj oi kn oj ok ol om bi translated"><strong class="js iu">魔法</strong>:我要说这里的“魔法”还真不少！我相信很难找到<em class="mi"> @ValidPhoneNumber的实现。</em>和<em class="mi">，</em>也许更重要的是<em class="mi">，</em>可能很难确定<em class="mi">何时</em>和<em class="mi">是否</em>将执行该验证。</li><li id="c943" class="oe of it js b jt on jx oo kb op kf oq kj or kn oj ok ol om bi translated"><strong class="js iu">实用程序</strong>:与普通的Java解决方案相比，定制约束在这个上下文中没有添加任何额外的值。</li><li id="9a71" class="oe of it js b jt on jx oo kb op kf oq kj or kn oj ok ol om bi translated"><strong class="js iu">层</strong>:如果<em class="mi"> Employee </em>类是域层的一部分，那么普通Java版本要好得多。使用自验证构造函数，我们可以确保我们将始终拥有从业务角度来看有效的对象。</li><li id="3ed4" class="oe of it js b jt on jx oo kb op kf oq kj or kn oj ok ol om bi translated"><strong class="js iu">错误:</strong>虽然自验证构造函数永远不会出错，但是Spring约束只能在Spring上下文中进行计算。</li></ul><pre class="kp kq kr ks gt nu nv nw bn nx ny bi"><span id="4c8e" class="nz lg it nv b be oa ob l oc od">public class PhoneNumber {<br/>  private final String value;<br/><br/>  public PhoneNumber(String value) {<br/>    if (value != null<br/>      &amp;&amp; value.matches("[0-9]+")<br/>      &amp;&amp; (value.length() &gt; 8)<br/>      &amp;&amp; (value.length() &lt; 14)) {<br/>      throw new IllegalArgumentException("invalid Phone Number!");<br/>    }<br/>    this.value = value;<br/>  }<br/><br/>  // getter for the 'value' field<br/>}<br/><br/><br/>public class Employee {<br/>  private final Long id;<br/>  private final String name;<br/>  private final PhoneNumber phoneNumber;<br/>  <br/>  // all arguments constructor<br/>}</span></pre><p id="3653" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，不依赖Spring的验证迫使我们想出一个很好的创造性解决方案，并丰富我们的领域模型。</p><h2 id="0d12" class="ni lg it bd lh nj nk dn ll nl nm dp lp kb nn no lt kf np nq lx kj nr ns mb nt bi translated">4.3.冬眠</h2><p id="fc7d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">是时候谈谈房间里的大象了。而且，当我说<em class="mi">大象</em>的时候，我是认真的:冬眠是巨大的！</p><p id="c419" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管——大多数时候JPA @实体存在于我们的核心域中，我们可以像Bob叔叔建议的那样，将数据库视为一个<em class="mi">细节</em>，一个外围组件。</p><p id="b71a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">诚然，Hibernate并不总是生成最好的SQL。但是，在我看来，它还能提供更多。例如，我不想实现诸如延迟加载或事务性之类的特性:它们与我试图解决的业务问题没有直接关系。</p><p id="749d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">个人认为Hibernate的“<em class="mi">实用</em>”维度正在弥补它带来的“<em class="mi">魔力</em>”。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="9fc6" class="lf lg it bd lh li ms lk ll lm mt lo lp lq mu ls lt lu mv lw lx ly mw ma mb mc bi translated">谢谢大家！</h1><p id="616f" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">感谢你阅读这篇文章，请让我知道你的想法！欢迎任何反馈。</p><p id="912b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想阅读更多关于干净的代码、设计、单元测试、函数式编程以及许多其他内容，请务必查看我的其他文章。</p><p id="f74d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢我的内容，可以考虑<a class="ae le" href="https://medium.com/@emanueltrandafir" rel="noopener">关注或者订阅</a>到邮件列表。</p><p id="b077" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，如果你考虑成为一个中等会员，支持我的博客，这里是我的<a class="ae le" href="https://medium.com/@emanueltrandafir/membership" rel="noopener">推荐人</a>。</p><p id="5205" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编码快乐！</p></div></div>    
</body>
</html>