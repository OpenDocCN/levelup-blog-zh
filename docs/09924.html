<html>
<head>
<title>Infinite scroll | Pagination on an API using JavaScript Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无限滚动|使用JavaScript生成器在API上分页</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/infinite-scroll-pagination-on-an-api-using-javascript-generators-55fae6e7c3e7?source=collection_archive---------3-----------------------#2021-10-03">https://levelup.gitconnected.com/infinite-scroll-pagination-on-an-api-using-javascript-generators-55fae6e7c3e7?source=collection_archive---------3-----------------------#2021-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/4bf83d7d652db80a2e96090b4c3632d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L6etp3ITRi7Th3SY"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/@olav_ahrens?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥拉夫·阿伦斯·罗特内</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="ea61" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">使用JavaScript生成器编写干净的代码</h2></div><p id="351d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在编写前端代码时，您可能需要使用分页从API中获取所有记录。为此，您可以将代码分解成多个函数。然而，维护如此多的变量并将状态从一个函数传递到另一个函数，并不像看起来那么简单。数据源的异步特性使得它更加复杂。然而，您可以使用<a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of" rel="noopener ugc nofollow" target="_blank">异步生成器</a>函数来简化它。在本文中，我将解释如何将复杂的逻辑分解成简单的函数。</p><h1 id="d97f" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">1.创建一个模拟的数据湖/源</h1><p id="3aa4" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">要测试功能，您需要一个数据源。为了模拟真实的api数据源，我将创建一个虚拟用户列表。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="247c" class="na lv jj mw b gy nb nc l nd ne">const users = Array(1000)<br/>  .fill()<br/>  .map((_, i) =&gt; ({ name: `user${i}`, id: `id_${i}` }));<br/>const TOTAL_RECORDS = users.length;</span><span id="bbf5" class="na lv jj mw b gy nf nc l nd ne">console.log({user: users[0], TOTAL_RECORDS});<br/>// { user: { name: 'user0', id: 'id_0' }, TOTAL_RECORDS: 1000 }</span></pre><h1 id="98f8" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">2.获取用户API函数</h1><p id="5892" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">您可以使用基于承诺的API函数来获取记录。然而，我将使用<a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await" rel="noopener ugc nofollow" target="_blank"> async-await </a>函数来创建这个获取用户API函数</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="b2a4" class="na lv jj mw b gy nb nc l nd ne">//service.js</span><span id="43ab" class="na lv jj mw b gy nf nc l nd ne">const delay = () =&gt; new Promise((r) =&gt; setTimeout(r, 1000));</span><span id="5760" class="na lv jj mw b gy nf nc l nd ne">/**<br/> * fetchUsers<br/> * <br/> * <a class="ae jg" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {page, limit} current page number, limit of the records to fecth<br/> * <a class="ae jg" href="http://twitter.com/default" rel="noopener ugc nofollow" target="_blank">@default</a> {0, 100}<br/> * <a class="ae jg" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> <br/> */<br/>const fetchUsers = async ({ page = 0, limit = 100 }) =&gt; {<br/>  const start = page * limit; // start index of the records<br/>  const end = (page + 1) * limit; // end index of the records<br/>  await delay(); // virtual delay of 1000ms<br/>  return {<br/>    data: users.slice(start, end), //Slice the records from start to end<br/>    done: end &gt;= TOTAL_RECORDS,<br/>    start,<br/>    end,<br/>  };<br/>};</span><span id="3a7a" class="na lv jj mw b gy nf nc l nd ne">// [optional]<br/>//export { fetchUsers };</span></pre><p id="db07" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的函数<code class="fe ng nh ni mw b">fetchUsers</code>采用类似<code class="fe ng nh ni mw b">page</code>和<code class="fe ng nh ni mw b">limit</code>的选项。Page定义为分页的当前页，limit定义为要获取的记录的限制。延迟仅仅是模拟实际网络的<em class="nj"> 1000ms </em>的虚拟延迟。</p><h1 id="1148" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">3.使用生成器函数提取所有记录</h1><p id="c6e8" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">传统上，你可以用递归来写一个函数来解决这个问题。然而，编写递归版本太复杂，难以理解。您也可以使用<em class="nj"> for-loop/while-loop </em>使用<em class="nj"> async-await </em>。看看下面的例子。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="11d7" class="na lv jj mw b gy nb nc l nd ne">async function main() {<br/>  let records = [];<br/>  let options = { page: 0, limit: 100, end: 100, total_records: Infinity };</span><span id="62f4" class="na lv jj mw b gy nf nc l nd ne">while (options.end &lt; options.total_records) {<br/>    const response = await fetchUsers(options);<br/>    records = records.concat(response.data);<br/>    options.end = response.end;<br/>    options.page = options.page + 1;<br/>    options.total_records = response.total_records;<br/>    console.log(records[records.length - 1], response.start, response.end);<br/>  }<br/>}<br/>// { name: 'user199', id: 'id_199' } 100 200<br/>// { name: 'user299', id: 'id_299' } 200 300<br/></span></pre><p id="3e51" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">输出:</strong></p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/9920617f7489bccacb5fe4f54ddcc1de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*KHUEHO-lmijuMKbNMWaHMQ.gif"/></div></figure><p id="ea6f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所看到的，使用while-loop函数，您的主函数必须过多地考虑其他变量，如<em class="nj">记录</em>、<em class="nj">分页选项</em>。在这种情况下，发电机表现出色。让我们试着把上面的例子转换成生成器。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="1900" class="na lv jj mw b gy nb nc l nd ne">/**<br/> *<br/> * <a class="ae jg" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {page, limit} start page index, limit/chunk of the records to fecth on each call<br/> * <a class="ae jg" href="http://twitter.com/default" rel="noopener ugc nofollow" target="_blank">@default</a> {0, 100}<br/> * <a class="ae jg" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a><br/> */<br/>async function* fetchAllRecords({ page = 0, limit = 100 } = {}) {<br/>  while (true) {<br/>    const records = await fetchUsers({ page: page++, limit });<br/>    yield records;<br/>    if (records.done) return;<br/>  }<br/>}</span><span id="bf8d" class="na lv jj mw b gy nf nc l nd ne">async function main() {<br/>  const api = fetchAllRecords();<br/>  let records = [];<br/>  for await (let record of api) {<br/>    records = records.concat(record.data);<br/>    console.log(records[record.end-1], record.start, record.end);<br/>  }<br/>}</span></pre><p id="fb35" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">输出:</strong></p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/3c738cc9b5acbe2deabba83d6afba940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*obxwn40367GEIw9mvWOtFg.gif"/></div></figure><p id="9989" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，使用生成器使代码看起来更加简单易读。</p><p id="7f61" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">注意:</strong>如果你注意到第<code class="fe ng nh ni mw b">for await (let record of api)</code>行，在这一行，我们看到发电机异步循环。这个<code class="fe ng nh ni mw b">await</code>信号通知<code class="fe ng nh ni mw b">for-loop</code>对象<code class="fe ng nh ni mw b">api</code>是<a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator" rel="noopener ugc nofollow" target="_blank">异步迭代器</a>函数要迭代。</p><p id="7d5f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> Codesandbox: </strong></p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="f39e" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">结论:</h1><p id="15dc" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Async await并不能让你的API运行得更快。它只是简化了代码，增加了代码的可读性。正如某位智者曾经说过的。</p><blockquote class="nn no np"><p id="ddfc" class="ky kz nj la b lb lc kk ld le lf kn lg nq li lj lk nr lm ln lo ns lq lr ls lt im bi translated">“任何傻瓜都能写出计算机能理解的代码。优秀的程序员会写出人类能理解的代码。”—马丁·福勒</p></blockquote></div></div>    
</body>
</html>