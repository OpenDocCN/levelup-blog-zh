<html>
<head>
<title>Sorting Data Structures in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的数据结构排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/sorting-data-structures-in-python-ceba201d33d2?source=collection_archive---------9-----------------------#2020-11-23">https://levelup.gitconnected.com/sorting-data-structures-in-python-ceba201d33d2?source=collection_archive---------9-----------------------#2020-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/709cf5d1c2ad0f6806321877696430a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tu1MfEXqqul9L7si"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@lukechesser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢克·切瑟</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8aa9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python为您提供了一些非常方便的函数，您可以使用它们高效地进行排序。您甚至可以进行链式排序，这样对于相同的数据，您可以先进行主排序，然后再进行次排序。</p><p id="0027" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，事不宜迟，我们开始吧。</p><h1 id="600e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">排序基础</h1><p id="cb44" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Python中有两种主要的排序方式:</p><ul class=""><li id="5077" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">sort</code>列表附带的方法</li><li id="6bc0" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">sorted</code>接受任何迭代的函数</li></ul><p id="ac20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，两者都会按升序对数据进行排序。但是这两种方法之间有一个重要的区别:</p><ul class=""><li id="ba00" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">sort</code>就地执行排序操作。所以你最终替换了原来的列表。</li><li id="131e" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">sorted</code>执行不适当的分类操作。这意味着，它返回一个新的列表，其中包含您的排序数据，而原始列表保持不变。这样，如果需要的话，两者都可以使用。</li></ul><p id="2e0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你唯一想使用<code class="fe mq mr ms mt b">sort</code>而不是<code class="fe mq mr ms mt b">sorted</code>的地方是当你有一个庞大的列表，并且你知道你不需要它的未排序版本的时候。这是因为，通过就地排序，<code class="fe mq mr ms mt b">sort</code>避免了创建全新列表的内存开销。</p><p id="8541" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有当您的列表非常大时，它才会对性能产生影响！否则，总是使用<code class="fe mq mr ms mt b">sorted</code>,因为它更具功能性和确定性。如果不改变现有的数据结构，就不太可能遇到错误。</p><h1 id="d39e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">数字或字符串列表</h1><p id="00bf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">首先，我们要看看最基本的情况，这将是一个数字或字符串的列表。</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="aa44" class="nh lf it mt b gy ni nj l nk nl">data_of_numbers = [50, 30, 20, 80, 10]<br/>data_of_strings = ['d', 'a', 'c', 'b']</span><span id="e211" class="nh lf it mt b gy nm nj l nk nl">data_of_numbers.sort()<br/>sorted_numbers = sorted(data_of_numbers)</span><span id="a24b" class="nh lf it mt b gy nm nj l nk nl"># Output:<br/># [10, 20, 30, 50, 80]<br/># ['a', 'b', 'c', 'd']</span></pre><p id="e9f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，Python按升序对数据进行排序。如果你想要降序，你可以传入一个<code class="fe mq mr ms mt b">reverse</code>参数:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="2cf4" class="nh lf it mt b gy ni nj l nk nl">sorted_numbers = sorted(data_of_numbers, reverse=True)<br/>sorted_strings = sorted(data_of_strings, reverse=True)</span></pre><h1 id="29f5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">元组或字典列表</h1><p id="1da4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在，让我们看看稍微复杂一点的列表。如果你的列表包含元组或者字典怎么办？</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="6130" class="nh lf it mt b gy ni nj l nk nl">data_points = [(10, 'c'), (40, 'b'), (20, 'a')]<br/>sorted_data = sorted(data_points) # [(10, 'c'), (20, 'a'), (40, 'b')]</span></pre><p id="c341" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，Python根据元组中的第一个元素对元组进行排序。所以你才会看到顺序:10，20，40。假设您想按第二个元素排序。你是做什么的？</p><p id="2c8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，您可以使用接受匿名函数的<code class="fe mq mr ms mt b">key</code>参数(或<code class="fe mq mr ms mt b">lambda</code>)。</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="47ef" class="nh lf it mt b gy ni nj l nk nl">data_points = [(10, 'c'), (40, 'b'), (20, 'a')]<br/>sorted_data = sorted(data_points, key=lambda x: x[1])</span><span id="b314" class="nh lf it mt b gy nm nj l nk nl"># [(20, 'a'), (40, 'b'), (10, 'c')]</span></pre><p id="c8d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">lambda函数接受当前元组作为参数。所以您可以在tuple中选择想要排序的项。</p><p id="b940" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字典的工作方式非常相似。假设我们有一个员工列表:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="2d97" class="nh lf it mt b gy ni nj l nk nl">employees = [{'name': 'Max', 'id': 30}, {'name': 'John', 'id': 20}, {'name': 'Ben', 'id': 100}]<br/>sorted_employees = sorted(employees)</span><span id="e556" class="nh lf it mt b gy nm nj l nk nl"># Errors out. Can't compare dictionary objects directly</span></pre><p id="5480" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，它出错是因为Python不知道如何在排序时比较两个字典条目。因此，您必须明确地告诉Python，您希望根据字典中的哪个属性进行排序:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="61d4" class="nh lf it mt b gy ni nj l nk nl">sorted_employees_by_name = sorted(employees, key=lambda x: x['name'])<br/>sorted_employees_by_id = sorted(employees, key=lambda x: x['id'])</span><span id="0046" class="nh lf it mt b gy nm nj l nk nl"># [{'name': 'Ben', 'id': 100}, {'name': 'John', 'id': 20}, {'name': 'Max', 'id': 30}]<br/># [{'name': 'John', 'id': 20}, {'name': 'Max', 'id': 30}, {'name': 'Ben', 'id': 100}]</span></pre><h1 id="f3d2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">自定义对象列表</h1><p id="57e8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在，让我们来看看自定义对象的列表。用Python创建类来保存数据是一种很常见的做法。我们可以有一个这些对象的列表，我们可能想把它们按不同的顺序排序。</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="dbdb" class="nh lf it mt b gy ni nj l nk nl">class Car():<br/>	def __init__(self, registration, wheels, color):<br/>		self.registration = registration<br/>		self.wheels = wheels<br/>		self.color = color</span><span id="4d80" class="nh lf it mt b gy nm nj l nk nl">	def __repr__(self):<br/>		return f'{self.registration}, {self.wheels}, {self.color}'</span><span id="d3e4" class="nh lf it mt b gy nm nj l nk nl">car_1 = Car(registration=10, wheels=2, color='blue')<br/>car_2 = Car(registration=100, wheels=4, color='red')<br/>car_3 = Car(registration=70, wheels=1, color='green')</span></pre><p id="acd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对这些对象进行排序非常简单。这个过程和我们刚才讨论的几乎完全一样。您只需使用<code class="fe mq mr ms mt b">key</code>参数定义想要排序的属性。</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="fb60" class="nh lf it mt b gy ni nj l nk nl">cars_list = [car_1, car_2, car_3]</span><span id="4e1f" class="nh lf it mt b gy nm nj l nk nl">cars_by_registration = sorted(cars_list, key=lambda x: x.registration)<br/>cars_by_wheels = sorted(cars_list, key=lambda x: x.wheels)<br/>cars_by_color = sorted(cars_list, key=lambda x: x.color)</span><span id="22c9" class="nh lf it mt b gy nm nj l nk nl"># [10, 2, blue, 70, 1, green, 100, 4, red]<br/># [70, 1, green, 10, 2, blue, 100, 4, red]<br/># [10, 2, blue, 70, 1, green, 100, 4, red]</span></pre><p id="d43d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们以三种不同的顺序对相同的数据排序三次。如您所见，我们根据排序键对每个排序列表进行了正确排序。</p><h1 id="2a53" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">链接排序在一起</h1><p id="5eba" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">到目前为止，无论你学到了什么，都是你在数据结构上做任何排序所需要的基础。然而，Python有一些实用函数，可以用来使代码更加整洁，排序更加强大。现在让我们来看看。</p><p id="a26a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用Python的<code class="fe mq mr ms mt b">operator</code>模块更清晰地定义您的排序键，并将多个排序链接在一起。</p><p id="0ab0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用<code class="fe mq mr ms mt b">itemgetter</code>函数来定义想要从元组中获取哪个元素。这使得代码更加清晰易读。</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="6d35" class="nh lf it mt b gy ni nj l nk nl">from operator import itemgetter</span><span id="6533" class="nh lf it mt b gy nm nj l nk nl">data_points = [(10, 'c'), (40, 'b'), (20, 'a')]<br/>sorted(data_points, key=itemgetter(2))</span></pre><p id="00d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似地，如果您正在对一个对象列表进行排序，您可以使用<code class="fe mq mr ms mt b">attrgetter</code>来定义对象的哪个属性被定义为排序关键字。</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="ce17" class="nh lf it mt b gy ni nj l nk nl">from operator import attrgetter<br/>cars_list = [car_1, car_2, car_3]<br/>cars_by_registration = sorted(cars_list, key=attrgetter('registration'))</span></pre><p id="9b1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，如你所见，这样的代码更容易阅读。</p><p id="5e5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mq mr ms mt b">operator</code>模块最酷的好处是，你可以将一系列排序链接在一起，让你的数据按照你想要的方式排列。</p><p id="494d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比方说，对于汽车数据，您希望首先按注册登记对列表进行排序，然后再按其中的车轮进行排序。让我们看看如何才能轻松做到这一点。</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="0845" class="nh lf it mt b gy ni nj l nk nl">car_4 = Car(registration=10, wheels=1, color='yellow')<br/>cars_list = [car_1, car_2, car_3, car_4]</span><span id="80e1" class="nh lf it mt b gy nm nj l nk nl">cars_by_registration_then_wheels = sorted(cars_list, key=attrgetter('registration', 'wheels'))</span></pre><p id="16a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种方式链接起来非常简单，所以您可以链接任意多的排序，完全按照您想要的方式获取数据！<code class="fe mq mr ms mt b">operator</code>模块还确保您以最有效的方式进行多重排序。</p><p id="e440" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是Python中对数据结构排序的全部内容。现在，您应该能够按照您想要的任何顺序对数据进行排序和呈现。</p><p id="9f60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢你能走到这一步。如果你对这些教程以及其他与编程和生产力相关的东西感兴趣，请跟我来。</p></div></div>    
</body>
</html>