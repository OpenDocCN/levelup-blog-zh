<html>
<head>
<title>State management in Tekton pipelines with Slack interactive messages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有松弛交互消息的Tekton流水线中的状态管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/state-management-in-tekton-pipelines-with-slack-interactive-messages-e9ed49d7b89?source=collection_archive---------15-----------------------#2020-08-13">https://levelup.gitconnected.com/state-management-in-tekton-pipelines-with-slack-interactive-messages-e9ed49d7b89?source=collection_archive---------15-----------------------#2020-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="22bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今年早些时候，我重新进入了令人眼花缭乱的CI/CD平台和解决方案世界。今天的市场提供了如此多的选择，我只能想象对于一个刚进入这个领域的人来说，决定选择什么样的解决方案是多么的困难。</p><p id="62af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">令人欣慰的是，行业开始投资于定义CI/CD系统的一些标准化和约定，以及围绕“管道”的概念，随着各种供应商频繁重复模式的成熟，需要一些标准化的基线水平。参与这项工作的组织之一是<a class="ae kl" href="https://cd.foundation/" rel="noopener ugc nofollow" target="_blank">持续交付基金会(CDF) </a>(与<a class="ae kl" href="http://cncf.io/" rel="noopener ugc nofollow" target="_blank"> CNCF </a>关系不太密切)，他们正在从事这些工作。在观察这个领域时，我偶然发现了<a class="ae kl" href="https://github.com/cdfoundation" rel="noopener ugc nofollow" target="_blank"> CDF的</a>核心项目之一，名为<a class="ae kl" href="https://tekton.dev" rel="noopener ugc nofollow" target="_blank"> Tekton </a>，它最初是由谷歌捐赠给<a class="ae kl" href="https://github.com/cdfoundation" rel="noopener ugc nofollow" target="_blank"> CDF </a>的。</p><p id="aac8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">(如果您只是在寻找一个Tekton兼容的工具来管理CI/CD状态w/ Slack交互性，您可以跳过其余部分，在GitHub </em>  <em class="km">上查看cicdstatemgr</em><a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr" rel="noopener ugc nofollow" target="_blank"><em class="km">)</em></a></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/6328339858f1e768bf28b9944b5783e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/0*sMwckTMFFv8Oke4v"/></div></figure><h1 id="bc83" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated"><strong class="ak">泰克顿</strong></h1><p id="4061" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">泰克顿项目由几个部分组成；三个关键的是<a class="ae kl" href="https://github.com/tektoncd/pipeline" rel="noopener ugc nofollow" target="_blank">管线</a>、<a class="ae kl" href="https://github.com/tektoncd/triggers" rel="noopener ugc nofollow" target="_blank">触发器</a>和<a class="ae kl" href="https://github.com/tektoncd/dashboard" rel="noopener ugc nofollow" target="_blank">仪表盘</a>。但是是什么让泰克顿与众不同？如果你看一下CI/CD系统，你会发现它们都有什么共同点？好吧，他们最终似乎都重写的一个大组件是由N个“任务”组成的“管道”由跨越N个“工人”的某种“主人”创建、分发/调度、执行和管理的方式，这通常都是由每个供应商反复编写的定制代码。</p><p id="25de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Tekton所做的是定义一些标准的方法，如何将“管道”和“任务”(以及各种其他关键模式)定义为Kubernetes资源(通过自定义CRD)，然后让Kubernetes本身管理这些东西的创建、调度、执行和管理(以包含由N个步骤(容器)组成的N个“任务”(k8s Pods)的“管道运行”的形式)。这实际上为您提供了一种Kubernetes进行CI/CD的本地方式，并提供了一些基础组件，通过这些组件，您可以构建更高级别的CI/CD系统，而不必重新编写所有调度/主/辅助代码，这些代码经常被每个CI/CD供应商以某种形式或方式重复使用。厉害！现在，我们离CI/CD系统的标准化又近了一步！值得注意的是，Tekton本身并不是一个现成的CI/CD解决方案，而是一个框架，通过它您可以在之上构建更高级别的CI/CD功能。几个项目已经建立在泰克顿之上，其中之一是<a class="ae kl" href="https://jenkins-x.io/" rel="noopener ugc nofollow" target="_blank">詹金斯-X </a>。如果你想了解更多关于<a class="ae kl" href="https://github.com/tektoncd/pipeline" rel="noopener ugc nofollow" target="_blank">泰克顿的事情，你可以在这里阅读更多。</a></p><h1 id="f194" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">该项目</h1><p id="bd15" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">作为我对CI/CD生态系统现状评估的一部分，我决定构建一个基于Tekton的解决方案原型，因为这些概念因其以Kubernetes为中心的关注点和云不可知的足迹而真正引起了我的兴趣。我最初花了一些时间尝试使用<a class="ae kl" href="https://jenkins-x.io/" rel="noopener ugc nofollow" target="_blank"> Jenkins-X </a>，但很快就遇到了太多的错误和/或缺乏支持，试图让它与特定的git提供商和特定的cloud k8s供应商一起工作，所以我决定放手，一旦Jenkins-X更加成熟，就回到那个项目。</p><p id="6587" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个概念相当简单，符合典型的CI/CD用例模式。我希望开发人员能够将标签推送到Git，触发构建，然后让他们控制何时验证/测试，部署到开发环境，并最终将标签“提升”到更高级别的环境，如生产环境。在<a class="ae kl" href="https://github.com/tektoncd/dashboard" rel="noopener ugc nofollow" target="_blank">仪表板项目</a>之外，Tekton实际上没有任何<em class="km">【用户界面】</em>(这对于查看Tekton内部发生的事情非常有用)，但并不是真正为了促进选择驱动的控制点而设计的，最终用户可以通过选择驱动的控制点与一组正在执行的管道进行交互，并对决策点等做出响应。考虑到这一点，我决定让最终用户体验(即开发人员或devops)通过交互式消息控件(即按钮)与Slack进行协调。其思想是，当各种管道开始/完成/失败或需要用户交互时，这将通过Slack来传达，Slack既作为状态的通知系统，也作为要做出的“选择”的交互点。</p><h1 id="ae24" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">样机研究</h1><p id="5c1a" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">从Tekton开始并不坏，在经过一些反复试验学习了管道、任务、管道运行的基础知识后，我得到了一个基本的“构建”管道功能，可以通过手动应用启动该过程的管道运行k8s清单来实例化。基本管道由从Git repo中提取的任务组成，在Kaniko 中进行映像<a class="ae kl" href="https://github.com/GoogleContainerTools/kaniko" rel="noopener ugc nofollow" target="_blank">构建/推送，然后通过调用在幕后利用</a><a class="ae kl" href="https://github.com/bitsofinfo/helmfile-deploy" rel="noopener ugc nofollow" target="_blank"> helmfile-deploy </a>的定制部署工具最终“部署”应用程序映像工件。</p><p id="8237" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个不错的开始，但是我接下来不得不研究Tekton Triggers项目，以便能够自动创建一个PipelineRun来响应被推送的Git标签；而不是人工制作不可持续的管道运行对象。简而言之，Tekton Triggers项目允许您公开自己的<a class="ae kl" href="https://github.com/tektoncd/triggers/blob/master/docs/eventlisteners.md" rel="noopener ugc nofollow" target="_blank"> EventListeners </a>(想想HTTP端点)，它可以接受另一个系统(通常是JSON)发送的有效负载，使用<a class="ae kl" href="https://github.com/tektoncd/triggers/blob/master/docs/cel_expressions.md" rel="noopener ugc nofollow" target="_blank"> CEL表达式</a>提取您关心的细节，然后将这些参数映射到您想要动态创建的Tekton管道资源(即PipelineRuns)。</p><p id="e31c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我已经具备了基于Git事件自动触发管道的基本能力，接下来就是创建这样一种能力，既可以发送关于管道内事件的Slack通知，也可以让Slack中的用户通过<a class="ae kl" href="https://api.slack.com/messaging/interactivity" rel="noopener ugc nofollow" target="_blank">交互组件(按钮)</a>做出选择，并通过一个定制的<a class="ae kl" href="https://api.slack.com/start" rel="noopener ugc nofollow" target="_blank"> Slack“应用”</a>响应这些通知。制作一些简单的通知发布到Slack并不复杂，只需要为消息创建交互按钮就可以了。当Slack消息按钮被按下时，Slack向您选择的端点发送一个HTTP POST在本例中，它是我的Tekton触发器<a class="ae kl" href="https://github.com/tektoncd/triggers/blob/master/docs/exposing-eventlisteners.md" rel="noopener ugc nofollow" target="_blank">事件监听器</a>端点。然而，在Slack上，他们的帖子增加了一个非常烦人的问题，不仅仅是发布JSON，而是将JSON嵌入到一个名为“payload”的传统url编码的表单post变量中。为此，我需要让EventListener调用一个定制的Tekton<a class="ae kl" href="https://github.com/tektoncd/triggers/blob/master/docs/eventlisteners.md#Webhook-Interceptors" rel="noopener ugc nofollow" target="_blank">web hook interceptor</a>，该拦截器可以<a class="ae kl" href="https://github.com/bitsofinfo/slack-payload-handler" rel="noopener ugc nofollow" target="_blank">提取它并将其作为普通的JSON </a>返回，这样就可以用CEL操作它。这是通过在松弛有效载荷处理器的<a class="ae kl" href="https://github.com/bitsofinfo/slack-payload-handler" rel="noopener ugc nofollow" target="_blank"> github上写一个go和its来完成的。</a></p><p id="5753" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦设置好了，在构建完成之后，会发送一个通知，然后在部署任务完成之后，会发送一组按钮，让用户迭代并“重新运行”整个管道。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ly"><img src="../Images/3028818bf44ac22b32c43b878b8f5372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hTd_NsmtkGOmceUu"/></div></div></figure><p id="19de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于一个原型来说，这工作得很好，老实说，大部分的挑战不是让Tekton本身工作，而是更多的关于争论你的管道将需要工作的所有东西的所有样板逻辑(考虑秘密、配置、密钥等)，迁移在Docker中构建得很好但当由Kaniko构建时行为不同的Docker文件，以及许多YAML工艺、参数映射、调试CEL表达式和所有你最终要做的编写任何软件的典型事情；<em class="km">是的，CI/CD是定制软件</em>，无论您是自己编写还是在另一个平台上配置。</p><p id="2cde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说到底，这只是一个概念证明，证明了什么是可能的，它有许多静态定义的、硬连接的假设和内置的复制粘贴脚本。为了使它达到更有用的状态，它需要做一些工作。</p><h1 id="b7d5" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">确定的要求</h1><p id="7d32" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">在Tekton上开发原型暴露了一些我发现自己在重复的模式，并且需要一个工具来简化其中的一些。我最终确定的未来需求领域如下:</p><h2 id="fafd" class="md kw iq bd kx me mf dn lb mg mh dp lf jy mi mj lj kc mk ml ln kg mm mn lr mo bi translated">任务结果、参数和共享的上下文状态数据</h2><p id="af35" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">一个管道内(可能跨越N个管道)的任务通常需要通过输入或输出在它们之间共享的上下文状态数据。如“环境”、“项目名称”、“版本”等以及其他常见的原始属性/值类型变量；包括有时更复杂的结构化值，如JSON/YAML代码片段。Tekton通过其<a class="ae kl" href="https://github.com/tektoncd/pipeline/blob/master/docs/tasks.md#specifying-parameters" rel="noopener ugc nofollow" target="_blank"> <em class="km">“任务参数”</em> </a>和<a class="ae kl" href="https://github.com/tektoncd/pipeline/blob/master/docs/tasks.md#emitting-results" rel="noopener ugc nofollow" target="_blank"> <em class="km">“任务结果”</em> </a>功能(即，命名结果指向磁盘上可以在管道中的N个任务之间共享的文件)提供了一种解决这一问题的机制。这对我来说没问题，但是任务“结果”的值大小限制为4096字节。可以通过将值(文件)写入更大的共享“工作区”卷来解决这一限制。<a class="ae kl" href="https://github.com/tektoncd/pipeline/blob/master/docs/tasks.md#emitting-results" rel="noopener ugc nofollow" target="_blank">任务结果</a>在单个<em class="km">管道</em>内的大部分时间都工作得很好，但是不容易解决跨由进程(和时间)边界分隔的多个管道存储结果或公共“状态”数据的问题。跨N个管道共享的结果/数据可以通过工作区来实现，但是我发现跨所有N个YAML文件来管理、思考和跟踪是很麻烦的。越来越多的需求是动态地添加和删除输入/输出，而不必在任务/流水线级别不断地重新声明结果和参数。</p><p id="ed40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有少量的输入或结果数据，这种机制是很好的，但是如果您超过了少数几个，您可能会花费大量的时间来来回回地在结果、任务和管道之间声明和映射参数。简而言之，随着管道变得越来越复杂，我认为这将成为一个更大的管理问题。理想情况下，使用任务结果和参数对于某些用例(比如移动跟踪标识符和简单的结果状态)来说是很好的，但是实际上我想限制我对它的使用，只保存指向一组更健壮的上下文状态数据的指针，这些数据与执行的逻辑线程(即应用程序发布/版本)相关，很容易使用和改变。</p><h2 id="d8c3" class="md kw iq bd kx me mf dn lb mg mh dp lf jy mi mj lj kc mk ml ln kg mm mn lr mo bi translated">上下文状态数据的范围</h2><p id="a239" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">在后一部分的基础上，很快就清楚了管道最终会变得通用。例如，将应用程序映像“部署”到集群的管道显然应该可以跨不同的执行“上下文”<em class="km">(即，部署到生产环境、qa环境和开发环境等)重用。</em>随之而来的需求是能够在每个应用的git项目中定义(在高层次上)，一种由开发人员轻松定义和定制每个管道执行行为的方法<em class="km">最终由这些执行“上下文”确定范围。</em>这个执行的“上下文”还会有一组与之相关的数据，这些数据更易变，更特定于运行时。任何CI/CD“上下文”的行为、数据和配置都可能互不相同。</p><h2 id="1a38" class="md kw iq bd kx me mf dn lb mg mh dp lf jy mi mj lj kc mk ml ln kg mm mn lr mo bi translated">执行模式&amp;对成功/失败的反应</h2><p id="a999" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">在这个简单的原型中出现了一个简单的模式:<em class="km">“这能被执行吗？”、“执行它”、“检查退出代码”、“调用端点”。</em>其中<em class="km">“调用端点”</em>可能是向Slack发送一些东西，或者递归调用主Tekton EventListener端点来触发Tekton内的其他东西(即相同或不同的管道)。随着管道越来越复杂，这种模式有可能变得更加普遍。我并不真的关心生成Tekton资源来产生一组条件/任务来实现这一点，因为有许多方法可以做到这一点，但我真的只是想要一种通用的方法，我可以用一种一致的和可定制的方式来处理每个应用程序的<em class="km">“调用端点</em>”动作，这些应用程序将利用这些管道。定义管道和任务的Tekton资源的管理将单独完成，但是可以从内部利用这个工具来简化调用。</p><h2 id="e8d9" class="md kw iq bd kx me mf dn lb mg mh dp lf jy mi mj lj kc mk ml ln kg mm mn lr mo bi translated">调用端点，自定义消息和选项</h2><p id="3f1a" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">由于每个管道的一个关键项目将是基于一些结果或任意定义的“事件”(即Tekton和/或Slack等)调用端点的能力，这将需要为定制提供一些东西。由于Slack是通知和最终用户交互发生的主要方式，因此需要一种方法来轻松地更改与此相关的所有选项(即消息、端点等的模板)。同样，调整将发送给EventListener本身的参数的能力，以便以自动化的方式基于结果重新调用Tekton。事实上，这个管道配置数据可以是任意的，完全自定义的。任务X需要选项Z的可配置性？将它添加到管道配置文件中，让开发人员调整它。</p><h2 id="4c6e" class="md kw iq bd kx me mf dn lb mg mh dp lf jy mi mj lj kc mk ml ln kg mm mn lr mo bi translated">获取响应并存储它们</h2><p id="48a1" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">在某个端点作为某个先前结果(即Tekton或Slack)的结果被调用后，您可能经常希望从该调用中捕获HTTP响应的某个部分，并随后将其存储回前面提到的共享“上下文状态数据”中，该数据将在整个执行流程中共享。人们反复需要能够解析HTTP响应，提取参数，然后存储它们以备将来使用。这与Tekton触发器中的CEL表达式提供的功能非常相似。在这里，我想到了诸如松弛线程id和审计跟踪项目之类的东西；或者甚至分析响应并生成要存储在上下文状态数据中的其他内容。</p><h2 id="2f69" class="md kw iq bd kx me mf dn lb mg mh dp lf jy mi mj lj kc mk ml ln kg mm mn lr mo bi translated">消费和变更上下文状态数据</h2><p id="5999" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">如前所述，我真的很想为Tekton之外的一个“执行”线程存储大量上下文“状态”数据，但也想让它非常容易从任务中访问和操作。也就是说，它应该可以在文件系统上本地访问，并且可以以一些常见的格式使用(YAML、JSON、<em class="km"> sourced </em> shell ENV vars等)。这些功能的组合应该允许任何“任务”,无论是Bash脚本还是自定义程序，都能够读取/使用数据，同时需要一个专用接口来改变数据。这也将减轻必须通过“结果/参数”机制在不同的管道/任务之间一遍又一遍地传输和重新声明这些值的负担。</p><h2 id="235f" class="md kw iq bd kx me mf dn lb mg mh dp lf jy mi mj lj kc mk ml ln kg mm mn lr mo bi translated">让开发者为每个应用定制行为</h2><p id="880e" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">最后，任何CI/CD系统的关键是，如果“管道”和“任务”设计得相当一般，那么应该有一种机制，通过这种机制，最终开发人员可以通过定制的任务可消费配置来调整管道的行为，以及(在这种情况下)定制消息和过程中每一步发生的交互。这种行为的大部分应该隐藏在某种可以扩展的“基线”配置中，但最终，至少应该从这些文件中消耗一些执行时的输入，这些文件由将代码推送到系统的最终开发人员管理。</p><h1 id="e1c1" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">从原型到迭代</h1><p id="73c0" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">好的，现在我已经确定了一些用例及模式，它们是实现一个更健壮的实现所需要的，是时候开始了。我并没有打算去构建一个<em class="km">“开箱即用的CI/CD系统”</em>，而只是一个工具，让你自己动手制作时变得更容易。这就是我开始写一些代码来创建一个实用程序的地方，这个实用程序可以从管道内部利用来解决上面列出的问题。经过几次迭代，这段代码被细化为<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"><em class="km">cicdstatemgr</em></strong></a>:CLI和python库，可以在CI/CD管道(如Tekton)中使用，以帮助解决我在上一节中列出的需求和用例。</p><h1 id="f445" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">cicdstatemgr</h1><p id="a0f5" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">那么<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr" rel="noopener ugc nofollow" target="_blank"> cicdstatemgr </a>到底能帮上什么忙呢？最好的展示方式可能是用它帮助解决的一般执行模式的图示(如下所示):</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mp"><img src="../Images/19f9ff6e2214287e638342319b0b5cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cSlY04dl1ZOyAKfZ"/></div></div></figure><p id="1537" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，上图中的任务模式不是由<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr" rel="noopener ugc nofollow" target="_blank"> cicdstatemgr </a>强加或实现的，只是为了说明我在<a class="ae kl" href="https://tekton.dev" rel="noopener ugc nofollow" target="_blank"> Tekton </a>中实现的一个通用模式，然后在任务中利用<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr" rel="noopener ugc nofollow" target="_blank"> cicdstatemgr的</a>功能。您可以完全自由地设计您的管道、流程和任务，并且<em class="km">在它们对您的特定用例最有意义的时候、如果和在哪里使用cicdstatemgr。</em></p><p id="7493" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面展示了一个用<em class="km">cicstatemgr</em>和Tekton实现的示例工作流，展示了“上下文”的概念以及如何在CI/CD中逻辑地使用它们。每个“上下文”都有自己的“cicdContextData”实例，可以在其中执行的所有管道之间共享。当一个新的“上下文”开始时，会创建一个新的实例，该实例可能会也可能不会植入来自先前上下文的数据。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mq"><img src="../Images/342a066e076aef356b0d5b30eaa1d387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sm8K-dn7IwHkLzu6"/></div></div></figure><h1 id="fee2" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">cicdstatemgr常规功能概述</h1><p id="70d3" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">开发者<a class="ae kl" href="https://github.com/bitsofinfo/nginx-hello-world/blob/master/app-pipeline-config.yaml" rel="noopener ugc nofollow" target="_blank">在每个应用的配置管理库中声明一个<em class="km">“app-pipeline-config . YAML”</em>文件</a>(随便你怎么命名)</p><p id="fb70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个app pipeline配置文件声明一个或多个可以从继承的<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/tree/master/examples/tekton/pipelines/bases" rel="noopener ugc nofollow" target="_blank">可选<em class="km">【基】</em>，<em class="km">【基】</em> YAML文件的格式/布局与app pipeline配置文件相同。应用程序管道配置文件旨在与<em class="km"> "bases" </em>合并，并覆盖它们。</a></p><p id="c198" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个应用程序管道配置文件定义一个或多个命名的<em class="km"> "cicd-contexts" </em>的配置，每个配置包含一个或多个命名的"管道"配置，这些配置可以包含<em class="km">完全任意的YAML结构</em>您定义的<em class="km"/>用于保存您想要的任何配置，这些配置随后可以被<em class="km"> cicdstatemgr的</em>使用、引用或变异。其他操作，例如或只是通过这些数据加载到任务的文件系统中，然后可以被任务中的任何工具使用或交叉引用</p><p id="ac8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您使用一组参数创建一个<em class="km"> "cicdContextData" </em>的新实例，这些参数使用一个应用程序管道配置文件，将它与其声明的<em class="km"> "bases" </em>合并，以产生" cicdContextData "对象的内容，该对象在其整个生命周期内以及跨进程边界都可以通过其" id "进行检索。这些数据存储在一个“主存储”中(目前支持redis)，并且可以根据需要以<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/tree/master/examples/basics/localdata" rel="noopener ugc nofollow" target="_blank"> YAML、JSON或sourceable“shell”格式加载到本地文件系统中。</a></p><p id="efce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在每个“pipeline”配置部分中，还有一个“event-handlers”部分，当调用<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/blob/master/examples/basics/HANDLE_EVENT.md" rel="noopener ugc nofollow" target="_blank"><em class="km">-handle-event&lt;pipeline name&gt;=&lt;event name&gt;</em></a>时会引用该部分。在这里，您可以定义N个命名的事件处理程序配置，包括<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/blob/master/examples/basics/HANDLE_EVENT.md" rel="noopener ugc nofollow" target="_blank">【通知】</a><a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/blob/master/examples/basics/HANDLE_EVENT.md" rel="noopener ugc nofollow" target="_blank">【手动选择】</a><a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/blob/master/examples/basics/HANDLE_EVENT.md" rel="noopener ugc nofollow" target="_blank">【设置值】</a><a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/blob/master/examples/basics/HANDLE_EVENT.md" rel="noopener ugc nofollow" target="_blank">【触发管道】</a>和<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/blob/master/examples/basics/HANDLE_EVENT.md" rel="noopener ugc nofollow" target="_blank">【响应】</a>。其中每一个都有一组特定的选项，你可以在这里阅读<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/blob/master/examples/basics/HANDLE_EVENT.md" rel="noopener ugc nofollow" target="_blank"/>，但是最终它们利用<a class="ae kl" href="https://github.com/pallets/jinja" rel="noopener ugc nofollow" target="_blank"> jinja2 </a>来呈现将被发送到端点的数据；或者从“cicdContextData”中的数据消费来设置新值。</p><p id="a0a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个单独的<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/blob/master/examples/basics/config.yaml" rel="noopener ugc nofollow" target="_blank">配置</a>和<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/blob/master/examples/basics/secrets.yaml" rel="noopener ugc nofollow" target="_blank">机密</a>文件用于<em class="km"> cicidstatemgr </em>本身，该文件旨在包含通用的低级配置/模板，而不管正在执行的底层应用程序管道配置。</p><p id="acb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="km">值得注意的是，除了在首次创建时播种新的“cicdContextData”实例的应用管道配置文件的一般框架结构之外，没有“模式”来描述“cicdContextData”必须看起来像什么样</em> </strong>。你可以自由地在这个对象上<em class="km"> -get/-set </em>任何k/v、嵌套、非嵌套的结构。这完全取决于你利用和设计你认为合适的结构。cicdstatemgr 大量使用JSONPath表达式获取/设置数据，并利用jinja2在其中评估或设置新数据。结构是任意的，你定义了“契约”。</p><p id="2352" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为<em class="km">cicstatemgr</em>也是一个Python模块，如果你想构建更高级的功能，你可以通过你自己的脚本直接使用它。不想那么做？没问题，直接使用CLI即可。</p><p id="1258" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">请注意，以上都没有为您建立/创建CI/CD系统。您仍然负责制作Tekton管道、触发器、从EventListeners消费输入数据以及将输入桥接到管道等等。</em><strong class="jp ir"><em class="km">cicdstatemgr</em></strong><em class="km">仅仅是你工具箱中的一个工具，你可以在你的任务中随时调用它。</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mr"><img src="../Images/481d467494d408be751e4600370756ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*agjuJ9t66W1lVCFL"/></div></div></figure><p id="a06e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是如何利用它的另一个例子:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ms"><img src="../Images/f24b0b99066e00c347bddc470ee62668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dbzcn2AAK4n1Z7zf"/></div></div></figure><h1 id="12d9" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">托多斯</h1><p id="dbdd" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">在撰写本文的时候，<em class="km"> cicdstatemgr </em>仍然非常新，我认为它是beta软件。它正被用于一个生产Tekton CI/CD实施中，该实施负责交付从开发到QA直至生产的众多“环境”中的30多个不同应用程序。也就是说，有几个短期目标，主要是:</p><ul class=""><li id="26fe" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">尽管最初的开发是为了与slack进行大量的交互，但其功能是非常通用的，并且代码只需做一些修改就可以“Slack”不可知。事实上，与“slack”唯一真正相关的是configs中几个配置变量的名称和几个slack特定的头。在jinja2模板中，99%的冗余“意识”被抽象出来，完全由操作员控制。想要与微软团队互动吗？这不是一个太大的飞跃。最终，我们的目标是使它能够与任何可以接受HTTP调用的东西完全互操作。</li><li id="9b20" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">除了“设置值”之外，一些“事件处理程序”配置只支持每个命名事件的单个操作。这需要改进以允许多个动作。</li><li id="41b9" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">为cicdContextData实现一个“锁定”抽象，这对于某些管道场景中的并发任务执行非常方便</li><li id="d113" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">记录如何添加额外的主数据源(Redis之外)</li></ul><h1 id="3f53" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">入门指南</h1><p id="169d" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">如果你想独立于Tekton使用<em class="km"> cicdstatemgr </em>，你可以通过做这些例子从<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/tree/master/examples/basics" rel="noopener ugc nofollow" target="_blank"> CLI基础开始</a></p><p id="d79d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对使用Tekton 的cicdstatemgr的<a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/tree/master/examples/tekton" rel="noopener ugc nofollow" target="_blank">例子感兴趣，你可以自己运行</a><a class="ae kl" href="https://github.com/bitsofinfo/cicdstatemgr/tree/master/examples/tekton" rel="noopener ugc nofollow" target="_blank">点击这里</a>。(查看下面的<a class="ae kl" href="https://www.youtube.com/watch?v=449xT2iDlzQ" rel="noopener ugc nofollow" target="_blank">截屏视频</a>)</p><p id="2fb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望这是对<a class="ae kl" href="https://tekton.dev" rel="noopener ugc nofollow" target="_blank"> Tekton </a>的一个体面的介绍，Tekton 是一个非常酷的实现CI/CD的前沿方式，可以在Kubernetes之上扩展。Tekton让您能够创建任何您可以想象的CI/CD系统，而不必担心它的所有低级服务器/执行方面。让k8s处理吧！</p><p id="de94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，我目前正在生产中使用它，到目前为止效果很好。感谢Tekton的人们为我们搭建了一个伟大的平台。</p><p id="9dad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论如何，感谢阅读，希望有人会发现它的用处。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nh ni l"/></div></figure><div class="nj nk gp gr nl nm"><a href="https://github.com/bitsofinfo/cicdstatemgr" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">bitsofinfo/cicdstatemgr</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">cicdstatemgr是一个Python包，它的目的是在开发CICD解决方案时让您的生活变得更加轻松</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa kt nm"/></div></div></a></div></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="4872" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">原载于2020年8月13日http://bitsofinfo.wordpress.com</em><a class="ae kl" href="https://bitsofinfo.wordpress.com/2020/08/13/tekton-pipelines-cicd-slack-triggers-state/" rel="noopener ugc nofollow" target="_blank"><em class="km"/></a><em class="km">。</em></p></div></div>    
</body>
</html>