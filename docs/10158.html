<html>
<head>
<title>How Google Computes the PageRank for the Whole Internet Efficiently (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google如何高效地计算整个互联网的PageRank(第一部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-google-computes-the-pagerank-for-the-whole-internet-efficiently-part-1-135ca6ef3247?source=collection_archive---------3-----------------------#2021-10-31">https://levelup.gitconnected.com/how-google-computes-the-pagerank-for-the-whole-internet-efficiently-part-1-135ca6ef3247?source=collection_archive---------3-----------------------#2021-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3296" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Google的PageRank算法和Pregel图形处理框架介绍</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/85a6d12eae1d5bf0a2bd2fc8ccd69c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fQh6kMHfqkeeYYzx"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">Solen Feyissa 在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="lj lk ll"><p id="93da" class="jn jo lm jp b jq jr js jt ju jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj kk ij bi translated">博客的第二部分可以在这里找到:<a class="ae li" href="https://megtechcorner.medium.com/how-google-computes-the-pagerank-for-the-whole-internet-efficiently-part-2-57224df8737c" rel="noopener">https://megtechcorner . medium . com/how-Google-computes-the-page rank-for-the-whole-internet-efficient-part-2-57224 df 8737 c</a></p></blockquote><p id="7f89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着互联网的出现，图形数据变得越来越丰富。一些例子是网络图(即互联网)、社交网络、交通路线和疾病爆发。高效挖掘图数据吸引了研究者和实践者的兴趣。在这篇博客中，我们将关注一个名为Pregel的框架，Google使用它来处理其海量的网络图数据。</p><p id="3ef5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从介绍PageRank算法开始，并说明什么是图形数据以及如何处理它们。然后我们将讨论Pregel框架的计算模型。接下来，我们将讨论框架的API和实现。</p><h1 id="f08e" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">PageRank</h1><p id="7840" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">互联网可以被建模为一个图，其中每个网页是一个顶点，网页之间的链接是边。PageRank算法的目标是为每个页面分配一个值，称为<em class="lm"> pagerank </em>，以表示网页的质量。如果网页具有较高的页面等级，则它被认为具有较好的质量，并且在搜索结果中显示在具有较低页面等级的网页之前。</p><blockquote class="lj lk ll"><p id="1e1b" class="jn jo lm jp b jq jr js jt ju jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj kk ij bi translated">请注意，下面的例子是基于Google的联合创始人Sergey和Page的论文[2]中的原始PageRank算法。其他优化已被纳入算法后来。感兴趣的用户可以参考<a class="ae li" href="https://en.wikipedia.org/wiki/PageRank#Variations" rel="noopener ugc nofollow" target="_blank">这个wiki页面</a>。</p></blockquote><p id="67aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">网页的页面排名(PR)用下面的公式计算。对于链接到w的所有网页，其页面排名的一部分被传播到w，其计算为其页面排名除以传出链接的数量。也就是说，网页的页面等级在它链接到的所有网页之间平均划分。</p><pre class="kt ku kv kw gt mt mu mv mw aw mx bi"><span id="745f" class="my lr iq mu b gy mz na l nb nc">PR(w) = 0.15 + 0.85 * (PR(w1)/num_of_outgoing_links(w1) + ... + PR(w_n)/num_of_outgoing_links(w_n))</span></pre><p id="f279" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象下面这个简单的案例。网页1链接到网页2和3。网页2链接到网页3，网页3链接到网页1。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nd"><img src="../Images/b7d651ccdd376bd3b4a0cb20fdfe5321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A09oKCmmaT5PoC_kK7LYag.png"/></div></div></figure><p id="429e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设网页1的页面排名为0.7，网页2的页面排名为0.8。网页3的页面排名是</p><pre class="kt ku kv kw gt mt mu mv mw aw mx bi"><span id="50ff" class="my lr iq mu b gy mz na l nb nc">0.15 + 0.85 * (0.7 / 2 + 0.8 / 1) = 1.1275</span></pre><p id="cd92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们得到网页3的页面排名后，很容易看出网页1的页面排名应该更新。</p><pre class="kt ku kv kw gt mt mu mv mw aw mx bi"><span id="ff5a" class="my lr iq mu b gy mz na l nb nc">0.15 + 0.85 * 1.1275 / 2 = 0.629</span></pre><p id="fe62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">网页2的页面排名也是如此。网页1和2的页面排名更新后，网页3的页面排名不同步，需要再次更新。这个过程将一直重复，直到我们达到平衡。也就是说，如果我们再次重复这个过程，网页的网页排名不再更新。</p><p id="0452" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的例子，处于平衡状态的网页的页面等级是:(网页1，1.163)，(网页2，0.644)，和(网页3，1.192)。例如，对于网页1和2的页面排名，网页3的页面排名是1.192。</p><pre class="kt ku kv kw gt mt mu mv mw aw mx bi"><span id="b738" class="my lr iq mu b gy mz na l nb nc">0.15 + 0.85 * (1.163 / 2 + 0.644) = 1.192</span></pre><p id="359a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发pregel框架是为了促进这种迭代过程达到图中的某种平衡状态。</p><h1 id="9973" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">预凝胶计算模型</h1><h2 id="f38c" class="my lr iq bd ls ne nf dn lw ng nh dp ma jy ni nj me kc nk nl mi kg nm nn mm no bi translated">顶点</h2><p id="c4e8" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">Pregel的计算模型密切反映了图形的概念。框架的核心是顶点的表示。顶点的界面如下所示。每个顶点包含用户定义的值。可以通过<em class="lm"> GetValue() </em>函数访问，通过<em class="lm"> MutableValue() </em>函数变异。在页面排名示例中，每个顶点将存储其页面排名值。</p><p id="3df0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顶点还保存了它所有的输出边，可以用GetOutEdgeIterator()函数访问它们。请注意，顶点不存储它们的传入边。这样做有两个原因。<strong class="jp ir">第一个原因</strong>是每个顶点只需要负责将消息发送到适当的顶点。消息转发和接收由Pregel框架处理。<strong class="jp ir">第二个原因</strong>是这个布局提供了一个清晰的机制来划分图表。一个分区是顶点及其所有输出边的子集。不同分区之间不会有重叠。</p><pre class="kt ku kv kw gt mt mu mv mw aw mx bi"><span id="07a7" class="my lr iq mu b gy mz na l nb nc">template&lt;typename VertexValue, <br/>         typename EdgeValue, <br/>         typename MessageValue&gt;<br/>class Vertex {<br/> public:<br/>  virtual void Compute(MessageIterator* msg) = 0;<br/>  <br/>  const std::string&amp; vertex_id() const;<br/>  int64 superstep() const;</span><span id="32a9" class="my lr iq mu b gy np na l nb nc">  const VertexValue&amp; GetValue();<br/>  VertexValue* MutableValue();<br/>  OutEdgeIterator GetOutEdgeIterator();</span><span id="f8db" class="my lr iq mu b gy np na l nb nc">  void SendMessageTo(const string&amp; dest_vertex, const MessageValue&amp; message);</span><span id="6acb" class="my lr iq mu b gy np na l nb nc">};</span></pre><h2 id="04d8" class="my lr iq bd ls ne nf dn lw ng nh dp ma jy ni nj me kc nk nl mi kg nm nn mm no bi translated">预凝胶计算循环</h2><p id="b471" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">在非常高的层次上，Pregel计算由一系列迭代组成，其中每个迭代被称为一个<strong class="jp ir">超步骤</strong>。在每个超级步骤中，框架调用用户逻辑(在Compute()函数中定义)。Compute()函数可以读取在前面的超级步骤中发送给它的消息。它还可以使用<em class="lm"> SendMessageTo() </em>函数向其他顶点发送消息，这些消息将在下一个超步骤中被接收。</p><p id="c23e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的代码总结了Pregel框架的概念计算循环。对于每个循环/超步骤，它用前一个超步骤中发送给它的消息填充顶点，并调用用户逻辑。</p><pre class="kt ku kv kw gt mt mu mv mw aw mx bi"><span id="7bc5" class="my lr iq mu b gy mz na l nb nc">for (int superstep=1; !shouldTerminate(); superstep()++) {<br/>  // At superstep s, we only allow access messages from superstep <br/>  // s-1. So we move the message to the `old_map` so that it is <br/>  // not updated while iteration s is running. </span><span id="1ee6" class="my lr iq mu b gy np na l nb nc">  for (Vertex v : all_vertices_) {<br/>    v.incrementSuperStep();  // private function<br/>    v.setMessage(old_map.at(v.vertex_id()); // private function. <br/>                     // Populate vertex v with all messages sent to <br/>                     // it in the previous superstep.</span><span id="2961" class="my lr iq mu b gy np na l nb nc">    v.Compute(); // user logic</span><span id="7fe8" class="my lr iq mu b gy np na l nb nc">    CollectMessage(v.getSentMessages(), &amp;map); // private function<br/>                     // Dumps all "sent" messages to the map.<br/>  }<br/>}</span></pre><h2 id="b0ee" class="my lr iq bd ls ne nf dn lw ng nh dp ma jy ni nj me kc nk nl mi kg nm nn mm no bi translated">信息传递</h2><p id="cd23" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">顶点通过发送消息直接相互通信。一个顶点可以在超级步骤s中发送任意数量的消息，但是这些消息将在超级步骤s+1中被接收。</p><p id="7128" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上面的概念计算循环中所总结的，框架收集所有发送的消息，代码为<em class="lm">collect message(v . getsentmessages()，&amp; map) </em>。这里我们假设顶点的<em class="lm"> SendMessageTo() </em>函数仅仅将消息存储在本地存储器中，这些消息可以通过<em class="lm"> getSentMessages() </em>函数访问。在下一次迭代开始时，这些消息对带有<code class="fe nq nr ns mu b">v.setMessage(map.at(v.vertex_id())</code>的顶点可用</p><blockquote class="lj lk ll"><p id="8bf3" class="jn jo lm jp b jq jr js jt ju jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj kk ij bi translated">请注意，这只是一个概念模型。在大规模系统中使用一个集中的协调器来传递消息实际上是非常低效的。关于它是如何实际实现的，请参考实现部分。</p></blockquote><h2 id="58f0" class="my lr iq bd ls ne nf dn lw ng nh dp ma jy ni nj me kc nk nl mi kg nm nn mm no bi translated">应用:PageRank</h2><p id="9fed" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">使用Pregel框架，可以用下面几行代码简洁地表达页面排名算法。前7行计算顶点的页面排名。最后两行向每个顶点发送一条消息，告诉它有多少页面等级将从顶点流向它。</p><pre class="kt ku kv kw gt mt mu mv mw aw mx bi"><span id="8d61" class="my lr iq mu b gy mz na l nb nc">class PageRankVertex : public Vertex&lt;double, void, double&gt; {<br/> public:<br/>  virtual void Compute(MessageIterator* msgs) {<br/>    // Compute the page rank of the vertex<br/>    if (superstep() &gt;= 1) {<br/>      double sum = 0;<br/>      for(; !msg-&gt;Done(); msgs-&gt;Next()) {<br/>        sum += msgs-&gt;Value();<br/>      }<br/>      *MutableValue() = 0.15 + 0.85 * sum();    <br/>    }</span><span id="9262" class="my lr iq mu b gy np na l nb nc">    // Propagate the page rank to the webpage that it links to.<br/>    const int64 n = GetOutEdgeIterator().size();<br/>    SendMessageToAllNeighbors(GetValue() / n);<br/>  }<br/>};</span></pre><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nt"><img src="../Images/f6774695bba1724bb49f456bff3dc380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1kNccidlk26A1q3Jb2VRg.png"/></div></div></figure><p id="2373" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与我们的示例一样，网页1将向网页2和3发送1条消息。这两个消息都包含值0.35，该值表示有多少页面排名从网页1传播到网页2和3。</p><h1 id="e8b3" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">履行</h1><p id="06b1" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">使用Pregel框架，用户只需提供一些功能来处理顶点的状态，而Pregel将负责图形的执行，如消息传递和顶点调度，并将其扩展到数Pb的数据和数千台机器！</p><p id="f7ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在博客的第2部分，我们将深入探讨Pregel框架的架构，以及它如何可靠地扩展到数千台机器。继续阅读这里:<a class="ae li" href="https://megtechcorner.medium.com/how-google-computes-the-pagerank-for-the-whole-internet-efficiently-part-2-57224df8737c" rel="noopener">https://megtechcorner . medium . com/how-Google-computes-the-page rank-for-the-whole-internet-efficient-part-2-57224 df 8737 c</a></p><h1 id="0ec9" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">参考</h1><p id="0649" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">[1] Malewicz，Grzegorz等，“Pregel:大规模图形处理系统”2010年ACM SIGMOD数据管理国际会议论文集。2010.</p><p id="cc94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2]布林、谢尔盖和劳伦斯·佩奇。“大规模超文本网络搜索引擎的剖析。”<em class="lm">计算机网络和ISDN系统</em>30.1–7(1998):107–117。</p></div></div>    
</body>
</html>