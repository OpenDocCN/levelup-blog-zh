<html>
<head>
<title>Kong custom plugin development using Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">孔使用Go开发自定义插件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kong-custom-plugin-development-using-go-abab906b89b4?source=collection_archive---------4-----------------------#2021-03-28">https://levelup.gitconnected.com/kong-custom-plugin-development-using-go-abab906b89b4?source=collection_archive---------4-----------------------#2021-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d94d04fdb919734baff285d27805b67e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zYH1yeIuh3AKH0PRpYhKaQ.png"/></div></div></figure><p id="fd27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从2.0版本开始，<a class="ae kw" href="https://konghq.com/kong/" rel="noopener ugc nofollow" target="_blank"> Kong </a>宣布将<a class="ae kw" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>作为除<a class="ae kw" href="http://www.lua.org/" rel="noopener ugc nofollow" target="_blank"> Lua </a>之外的一种用于Kong API Gateway插件开发的支持语言。孔在其官方知识库上为Go用户发布了<a class="ae kw" href="https://github.com/Kong/go-pdk" rel="noopener ugc nofollow" target="_blank">(PDK)</a>。在本文中，我们将尝试使用Go为Kong <a class="ae kw" href="https://docs.konghq.com/enterprise/2.3.x/external-plugins/" rel="noopener ugc nofollow" target="_blank"> 2.3 </a>开发和部署定制插件。</p><p id="2541" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用官方的<a class="ae kw" href="https://hub.docker.com/r/kong/go-plugin-tool" rel="noopener ugc nofollow" target="_blank"> go-plugin-tool </a>使用<a class="ae kw" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>构建Kong插件，本图使用1.13版本进行开发。我们的文档:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="e28f" class="lg lh iq lc b gy li lj l lk ll"># Stage 1 - Build plugin<br/># Pull image from official go-plugin-tool.</span><span id="991a" class="lg lh iq lc b gy lm lj l lk ll">FROM kong/go-plugin-tool:2.0.4-alpine-latest AS builder</span><span id="8364" class="lg lh iq lc b gy lm lj l lk ll"><br/># Copy current workspace to container.</span><span id="e5dd" class="lg lh iq lc b gy lm lj l lk ll">RUN mkdir -p /tmp/go-plugins/</span><span id="9d68" class="lg lh iq lc b gy lm lj l lk ll">COPY . /tmp/go-plugins/</span><span id="293d" class="lg lh iq lc b gy lm lj l lk ll"><br/># Build the plugin.</span><span id="4f25" class="lg lh iq lc b gy lm lj l lk ll">RUN cd /tmp/go-plugins/ &amp;&amp; \</span><span id="29c3" class="lg lh iq lc b gy lm lj l lk ll">    apk add make &amp;&amp; \</span><span id="33e9" class="lg lh iq lc b gy lm lj l lk ll">    make all</span><span id="eedd" class="lg lh iq lc b gy lm lj l lk ll"><br/># Stage 2 - Create Kong container and add custom plugin</span><span id="3cfc" class="lg lh iq lc b gy lm lj l lk ll"># Pull Kong version 2.3 from official repository.<br/>FROM kong:2.3.3-alpine</span><span id="8c70" class="lg lh iq lc b gy lm lj l lk ll"># Copy plugin from build container to Kong container<br/>RUN mkdir /tmp/go-plugins</span><span id="a9ca" class="lg lh iq lc b gy lm lj l lk ll">COPY --from=builder  /tmp/go-plugins/key-checker /usr/local/bin/key-checker</span><span id="703e" class="lg lh iq lc b gy lm lj l lk ll"># Copy Kong configuration to Kong container<br/>COPY config.yml /tmp/config.yml</span><span id="bf2c" class="lg lh iq lc b gy lm lj l lk ll"># Dump plugin info</span><span id="cb7f" class="lg lh iq lc b gy lm lj l lk ll">RUN /usr/local/bin/key-checker -dump</span></pre><p id="aec5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用Docker <a class="ae kw" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>来构建和安装我们的插件。首先，我们构建插件，然后我们将新创建的插件和Kong配置复制到一个单独的Kong容器中。对于这个插件开发，下面是我们的项目结构:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/a46773ec609def5d05d0698ddf067cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*ifdAmFSh0ArGgOUuNO9T1g.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">项目结构</figcaption></figure><p id="a20b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结构基于<a class="ae kw" href="https://github.com/golang-standards/project-layout" rel="noopener ugc nofollow" target="_blank">标准Go项目布局</a>(更详细的信息可以参考内嵌链接)，我们所有的插件都会放在<code class="fe ls lt lu lc b">cmd/kong</code>里面。每个插件都将被编译成独立的可执行二进制文件。而我们的主代码库会放在一个<code class="fe ls lt lu lc b">internal</code>目录下。我们使用<a class="ae kw" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">干净的架构</a>来管理我们的代码库。</p><p id="81da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于<a class="ae kw" href="https://docs.konghq.com/enterprise/2.3.x/external-plugins/" rel="noopener ugc nofollow" target="_blank">孔插件开发文档</a>，有一些契约要在我们的代码上实现。</p><ol class=""><li id="4522" class="lv lw iq ka b kb kc kf kg kj lx kn ly kr lz kv ma mb mc md bi translated"><strong class="ka ir">定义一个结构类型来保存配置</strong></li></ol><p id="e1bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该创建一个结构体来保存我们的插件配置，这个结构体的公共属性将被自动填充为Kong插件配置。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/98fd91890cc00b6abf684e575248df11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3YpC1iQCtg1wv3mxs82XA.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">配置结构</figcaption></figure><p id="d916" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于上面的结构，<code class="fe ls lt lu lc b">APIKey</code>属性将用来自孔的<code class="fe ls lt lu lc b">api_key</code>填充。例如，如果我们使用<a class="ae kw" href="https://docs.konghq.com/gateway-oss/2.3.x/db-less-and-declarative-config/" rel="noopener ugc nofollow" target="_blank">孔下面的声明性配置</a>，<code class="fe ls lt lu lc b">APIKey</code>值将<code class="fe ls lt lu lc b">mysecretconsumerkey</code>。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/83f7dc4861fb4d0e0fd1feb12017a6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*pAj4P7IHry7T-xAGDqQt4Q.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">孔陈述结构</figcaption></figure><p id="1e80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。编写一个函数来创建配置结构的实例</strong></p><p id="5928" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该定义一个函数来创建我们的配置结构的实例，返回类型应该是<code class="fe ls lt lu lc b">interface{}</code>例如:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/5a4429d30c65d7520a31c194e339d046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d8UzSEqH1SNSU4QooxSbIg.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">用于创建实例的函数</figcaption></figure><p id="2a80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3。向配置结构添加方法以处理阶段</strong></p><p id="9afa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以实现在请求处理生命周期的不同点执行的定制逻辑。根据Kong文档，在请求/响应生命周期中将执行一些阶段:</p><p id="9a0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">证书:</strong>在SSL握手的SSL证书服务阶段执行。</p><p id="67c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">重写:</strong>作为重写阶段处理程序，在从客户端接收到每个请求时执行</p><p id="729a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">访问</strong>:为来自客户端的每个请求执行，并且在它被代理到上游服务之前执行。</p><p id="e8d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">响应:</strong>在从上游服务接收到整个响应之后，但在向客户端发送任何部分之前执行。</p><p id="47b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">预读:</strong>每次连接执行一次</p><p id="f731" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Log: </strong>每次连接关闭后执行一次。</p><p id="2805" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 4。添加一个</strong> <code class="fe ls lt lu lc b"><strong class="ka ir">main()</strong></code> <strong class="ka ir">函数，调用</strong> <code class="fe ls lt lu lc b"><strong class="ka ir">server.StartServer</strong></code></p><p id="7813" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们将把插件编译成独立的可执行文件，我们将使用来自<code class="fe ls lt lu lc b">go-pdk</code>包的嵌入式服务器，并在我们的主函数上启动服务器。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/132d75bc63659d0c613afd3828efca92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pV81Wc1tXmrpsIjr9udHVg.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">初始化嵌入式服务器</figcaption></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="5fa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们通过开发我们的自定义插件来动手。我们将开发一个钥匙检查插件。这个插件从URL查询参数中获取密钥，并用我们配置中存储的密钥验证给定的密钥。这个简单的插件是受这篇文章<a class="ae kw" href="https://dev.to/_mertsimsek/go-plugin-development-on-kong-50pb" rel="noopener ugc nofollow" target="_blank">的启发，这个插件将用于我们的学习目的。</a></p><p id="c533" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将创建一个结构来保存配置，并实现<code class="fe ls lt lu lc b">Access</code>钩子来验证从下游到上游的每个请求。然后，我们应该将查询参数中的密钥与配置中的现有密钥进行比较。如果这个键与我们的配置键不匹配，我们将用HTTP 401错误进行响应，如果给定的键与我们的配置键匹配，请求将被转发到上游。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="8121" class="lg lh iq lc b gy li lj l lk ll">// KeyCheckerConfig will hold all Kong configuration data</span><span id="ffab" class="lg lh iq lc b gy lm lj l lk ll">// and injected use case module.</span><span id="72f3" class="lg lh iq lc b gy lm lj l lk ll">type KeyCheckerConfig struct {</span><span id="8bf3" class="lg lh iq lc b gy lm lj l lk ll">    APIKey        string `json:"api_key"`</span><span id="71b7" class="lg lh iq lc b gy lm lj l lk ll">    useCaseModule *di.UseCaseModule</span><span id="82ce" class="lg lh iq lc b gy lm lj l lk ll">}<br/></span><span id="5d1d" class="lg lh iq lc b gy lm lj l lk ll">// NewKeyChecker will create an instance of KeyCheckerConfig.</span><span id="a21b" class="lg lh iq lc b gy lm lj l lk ll">func NewKeyChecker() interface{} {</span><span id="94f8" class="lg lh iq lc b gy lm lj l lk ll">    return &amp;KeyCheckerConfig{useCaseModule: di.GetUseCaseModule()}</span><span id="aa28" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="3420" class="lg lh iq lc b gy lm lj l lk ll">func (conf *KeyCheckerConfig) Access(kong *pdk.PDK) {</span><span id="86e3" class="lg lh iq lc b gy lm lj l lk ll">    // Get `key` value from URL query <br/>    key, err := kong.Request.GetQueryArg("key")</span><span id="4777" class="lg lh iq lc b gy lm lj l lk ll">    if err != nil {</span><span id="8ddf" class="lg lh iq lc b gy lm lj l lk ll">        kong.Log.Err(err.Error())</span><span id="ba18" class="lg lh iq lc b gy lm lj l lk ll">    }<br/></span><span id="5ee2" class="lg lh iq lc b gy lm lj l lk ll">    // Validate given `key`, compare it with our key<br/>    // on configuration. Response with 401 if given key doesn't<br/>    // match with our key on configuration</span><span id="6537" class="lg lh iq lc b gy lm lj l lk ll">    ctx := context.Background()</span><span id="0f6b" class="lg lh iq lc b gy lm lj l lk ll">    respHeaders := make(map[string][]string)</span><span id="32a4" class="lg lh iq lc b gy lm lj l lk ll">    respHeaders["Content-Type"] = append(<br/>        respHeaders["Content-Type"], <br/>        "application/json"<br/>    )</span><span id="762f" class="lg lh iq lc b gy lm lj l lk ll">    err = conf.useCaseModule.ValidateKeyUseCase.Execute(<br/>        ctx, <br/>        keychecker.ValidateKeyInput{<br/>            GivenKey: key, <br/>            ValidKey: conf.APIKey,<br/>        }<br/>    )</span><span id="e4dd" class="lg lh iq lc b gy lm lj l lk ll">    if err != nil {</span><span id="31b6" class="lg lh iq lc b gy lm lj l lk ll">        switch err {</span><span id="ca3f" class="lg lh iq lc b gy lm lj l lk ll">            case keychecker.ErrKeyEmpty, keychecker.ErrKeyNotValid:</span><span id="3fb4" class="lg lh iq lc b gy lm lj l lk ll">                kong.Response.Exit(401, err.Error(), respHeaders)</span><span id="acf9" class="lg lh iq lc b gy lm lj l lk ll">            default:</span><span id="28f0" class="lg lh iq lc b gy lm lj l lk ll">                kong.Response.Exit(500, err.Error(), respHeaders)</span><span id="632a" class="lg lh iq lc b gy lm lj l lk ll">       }</span><span id="301f" class="lg lh iq lc b gy lm lj l lk ll">       return</span><span id="2bac" class="lg lh iq lc b gy lm lj l lk ll">   }</span><span id="007b" class="lg lh iq lc b gy lm lj l lk ll">    // Get exchange token based on given key, and append it to<br/>    // `X-Exchange-Token` header.</span><span id="ba49" class="lg lh iq lc b gy lm lj l lk ll">    token, err := conf.useCaseModule.GetTokenUseCase.Execute(<br/>        ctx, <br/>        key<br/>    )</span><span id="13ef" class="lg lh iq lc b gy lm lj l lk ll">    if err != nil {</span><span id="01f9" class="lg lh iq lc b gy lm lj l lk ll">        kong.Response.Exit(500, err.Error(), respHeaders)</span><span id="b22d" class="lg lh iq lc b gy lm lj l lk ll">       return</span><span id="8742" class="lg lh iq lc b gy lm lj l lk ll">    }</span><span id="9506" class="lg lh iq lc b gy lm lj l lk ll">    kong.Response.SetHeader("X-Exchange-Token", token)</span><span id="e414" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><p id="46ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码反映了我们的主要逻辑应该在Access hook上实现，你可以在这个GitHub repo <a class="ae kw" href="https://github.com/syafdia/go-exercise/tree/master/src/etc/demo-kong-plugin" rel="noopener ugc nofollow" target="_blank">上查看完整版本的代码https://GitHub . com/syaf dia/go-exercise/tree/master/src/etc/demo-kong-plugin</a>。</p><p id="72d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们在自定义的kong插件上运行，只需克隆上面提到的repo，并使用<code class="fe ls lt lu lc b">docker build -t kong-demo</code>运行构建映像，使用:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="4444" class="lg lh iq lc b gy li lj l lk ll">docker run -ti --rm --name kong-go-plugins \<br/>-e "KONG_DATABASE=off" \<br/>-e "KONG_DECLARATIVE_CONFIG=/tmp/config.yml" \<br/>-e "KONG_PLUGINS=bundled,key-checker" \<br/>-e "KONG_PLUGINSERVER_NAMES=key-checker" \<br/>-e "KONG_PLUGINSERVER_KEY_CHECKER_START_CMD=/usr/local/bin/key-checker" \<br/>-e "KONG_PLUGINSERVER_KEY_CHECKER_QUERY_CMD=/usr/local/bin/key-checker -dump" \<br/>-e "KONG_PROXY_LISTEN=0.0.0.0:8000" \<br/>-e "KONG_LOG_LEVEL=debug" \<br/>-p 8000:8000 \<br/> kong-demo</span></pre><p id="c8dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们试图使用一个无效的密钥访问我们的孔时，我们将得到HTTP 401响应和主体上的<code class="fe ls lt lu lc b">key is not valid</code>。但是当我们使用有效的键时，我们将在响应头和响应体上得到HTTP 200和<code class="fe ls lt lu lc b">X-Exchange-Token</code>。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/1c63036b92f55df6ec80a9e9bee8bf3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PGzdrytvpX_ydvIS0e6zkg.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">401来自自定义插件的响应</figcaption></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/892b135645ba6aab49028bd0d6f7141f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0-Zjfz4d_O93mM2--AgqyQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">来自自定义插件的附加X-Exchange-Token标头</figcaption></figure><p id="052a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了Kong 2 . x版本，我们可以使用Go构建我们的自定义插件，而从Kong 2.3版本开始，每个插件都可以是一个服务，被编译成一个独立的可执行二进制文件。</p><p id="5f44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">参考</strong>:</p><ul class=""><li id="b828" class="lv lw iq ka b kb kc kf kg kj lx kn ly kr lz kv mr mb mc md bi translated"><a class="ae kw" href="https://docs.konghq.com/enterprise/2.3.x/external-plugins/" rel="noopener ugc nofollow" target="_blank">https://docs.konghq.com/enterprise/2.3.x/external-plugins/</a></li><li id="e1ab" class="lv lw iq ka b kb ms kf mt kj mu kn mv kr mw kv mr mb mc md bi translated"><a class="ae kw" href="https://dev.to/_mertsimsek/go-plugin-development-on-kong-50pb" rel="noopener ugc nofollow" target="_blank">https://dev . to/_ mertsimsek/go-plugin-development-on-kong-50pb</a></li><li id="3d0c" class="lv lw iq ka b kb ms kf mt kj mu kn mv kr mw kv mr mb mc md bi translated"><a class="ae kw" href="https://medium.com/swlh/creating-a-go-plugin-in-kong-e54a1315faaa" rel="noopener">https://medium . com/swlh/creating-a-go-plugin-in-kong-e54a 1315 faaa</a></li></ul></div></div>    
</body>
</html>