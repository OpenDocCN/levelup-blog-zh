<html>
<head>
<title>Practical DDD in Golang: Specification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗实用DDD:规格</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-ddd-in-golang-specification-6523d14438e6?source=collection_archive---------6-----------------------#2021-10-11">https://levelup.gitconnected.com/practical-ddd-in-golang-specification-6523d14438e6?source=collection_archive---------6-----------------------#2021-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0ff2" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">领域驱动设计</h2><div class=""/><div class=""><h2 id="b166" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">多实践模式的用例，用于验证、创建和查询-规范。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/06c22c701fac3e9b1f5817c9bf4c70ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ci-o7tWPOsNNk3r9"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@estebancastle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃斯特万城堡</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="44f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没有那么多代码结构在我需要写的时候带给我欢乐。我第一次实现这样的代码是在Go中用一个轻量级的ORM，当时我们还没有这样的。</p><p id="c772" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，我使用ORM很多年了。在某些时候，当你依赖ORM时，使用<a class="ae lh" href="https://www.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/query-builder.html" rel="noopener ugc nofollow" target="_blank"> QueryBuilder </a>是不可避免的。在这里，您可能会注意到像<strong class="lk jd">谓词</strong>这样的术语。这就是我们可以找到规范模式的地方。</p><p id="2b9a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很难找到我们用作规范的任何模式，然而我们却听不到它的名字。我认为唯一困难的是不使用这种模式编写应用程序。</p><p id="1c92" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该规范有许多应用。我们可以用它来进行查询、创建或验证。我们可能会提供可以完成所有这些工作的独特代码，或者为不同的用例提供不同的实现。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="b553" class="mj mk it mf b gy ml mm l mn mo">Other articles from DDD series:</span><span id="ed2b" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="ec6f" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="ada2" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-service-4418a1650274"><strong class="mf jd">Practical DDD in Golang: Domain Service</strong></a></span><span id="7530" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-event-de02ad492989"><strong class="mf jd">Practical DDD in Golang: Domain Event</strong></a></span><span id="df48" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">5. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-module-51edf4c319ec"><strong class="mf jd">Practical DDD in Golang: Module</strong></a></span><span id="cfec" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">6. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-aggregate-de13f561e629"><strong class="mf jd">Practical DDD in Golang: Aggregate</strong></a></span><span id="2549" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">7. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-factory-5ba135df6362"><strong class="mf jd">Practical DDD in Golang: Factory</strong></a></span><span id="5f7f" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">8. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-repository-d308c9d79ba7"><strong class="mf jd">Practical DDD in Golang: Repository</strong></a></span></pre><div class="mq mr gp gr ms mt"><a href="https://blog.ompluscator.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jd gy z fp my fr fs mz fu fw jc bi translated">通过我的推荐链接加入媒体——马尔科·米洛耶维奇</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">blog.ompluscator.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh lb mt"/></div></div></a></div><h1 id="a02b" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">为了验证</h1><p id="88fa" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">规范模式的第一个用例是验证。我们主要验证<a class="ae lh" href="https://angular.io/guide/form-validation" rel="noopener ugc nofollow" target="_blank">表单</a>中的数据，但这是在表示级别上。有时，我们在创建过程中执行，比如对<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70">值对象</a>。</p><p id="3842" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在领域层的上下文中，我们可以使用规范来验证实体的状态，并从集合中筛选出实体。因此，域层上的验证已经比用户输入有了更广泛的含义。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用规范来验证数据</figcaption></figure><p id="af56" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上例中，有一个接口<code class="fe og oh oi mf b">ProductSpecification</code>。它只定义了一个方法<code class="fe og oh oi mf b">IsValid</code>，该方法需要<code class="fe og oh oi mf b">Product</code>的实例，如果<code class="fe og oh oi mf b">Product</code>通过了验证规则，则返回一个布尔值。</p><p id="2f08" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个接口的简单实现是验证最小数量<code class="fe og oh oi mf b">Product</code>的<code class="fe og oh oi mf b">HasAtLeast</code>。更有趣的验证器是两个函数，<code class="fe og oh oi mf b">IsPlastic</code>和<code class="fe og oh oi mf b">IsDeliverable</code>。</p><p id="9959" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以用一个特定的类型<code class="fe og oh oi mf b">FunctionSpecification</code>来包装这些函数。这种类型嵌入了与前面提到的两个签名相同的函数。除此之外，它还提供了尊重<code class="fe og oh oi mf b">ProductSpecification</code>接口的方法。</p><p id="7ac9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个例子是Go的一个很好的特性，我们可以将一个函数定义为一个类型，并为它附加一个方法，这样它就可以隐式地实现一些接口。我们这里有这样一个例子，它提出了执行嵌入函数的方法<code class="fe og oh oi mf b">IsValid</code>。</p><p id="9975" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，还有一个独特的规格，<code class="fe og oh oi mf b">AndSpecification</code>。这样一个结构帮助我们使用一个实现了<code class="fe og oh oi mf b">ProductSpecification</code>接口的对象，但是从所有包含的规范中分组验证。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">附加规格</figcaption></figure><p id="2560" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码片段中，我们可以找到两个附加的规范。一个是<code class="fe og oh oi mf b">OrSpecification</code>，它和<code class="fe og oh oi mf b">AndSpecification</code>一样，执行它持有的所有规范。只是，在这种情况下，它使用的是<code class="fe og oh oi mf b">or</code>算法，而不是<code class="fe og oh oi mf b">and</code>。</p><p id="1bcf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后一个是NotSpecification，它否定了嵌入规范的结果。<code class="fe og oh oi mf b">NotSpecification</code>也可以是功能规范，但我不想把它弄得太复杂。</p><h1 id="7454" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">用于查询</h1><p id="ab22" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">我已经在本文中提到了作为ORM一部分的规范模式的应用。在许多情况下，您不需要实现这个用例的规范，至少如果您使用任何ORM的话。</p><p id="6bc6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我在脸书的<a class="ae lh" href="https://entgo.io/" rel="noopener ugc nofollow" target="_blank"> Ent </a>库中找到了谓词形式的规范的优秀实现。从那时起，我没有用例来编写查询规范。</p><p id="826c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管如此，当您发现您对领域级存储库的查询过于复杂时，您需要更多的可能性来过滤所需的实体。实现可能如下例所示。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">查询示例</figcaption></figure><p id="fca3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在新的实现中，<code class="fe og oh oi mf b">ProductSpecification</code>接口提供了两个方法，<code class="fe og oh oi mf b">Query</code>和<code class="fe og oh oi mf b">Values</code>。我们使用它们来获取特定规范的查询字符串及其可能包含的值。</p><p id="221e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，我们可以看到额外的规格，<code class="fe og oh oi mf b">AndSpecification</code>和<code class="fe og oh oi mf b">OrSpecification</code>。在这种情况下，它们根据所提供的运算符连接所有底层查询，并合并所有值。</p><p id="f4b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在领域层有这样的规范是有问题的。正如您可以从输出中看到的，Specifications提供了SQLike语法，该语法过多地涉及了技术细节。</p><p id="7567" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，解决方案可能是在领域层为不同的规范定义接口，在基础设施层定义实际的实现。</p><p id="f088" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者重新构造代码，以便规范保存有关字段名、操作和值的信息。然后在基础设施层上有一些映射器，可以将这样的规范映射到SQL查询。</p><h1 id="4755" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">为了创作</h1><p id="6a7b" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">规范的一个简单用例是创建一个变化很大的复杂对象。在这种情况下，我们可以将它与工厂模式相结合，或者在域服务中使用它。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oe of l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">创作范例</figcaption></figure><p id="8d3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，我们可以找到规范的第三种实现。在这个场景中，<code class="fe og oh oi mf b">ProductSpecification</code>支持一个方法，<code class="fe og oh oi mf b">Create</code>，它期望<code class="fe og oh oi mf b">Product</code>，修改它，并返回它。</p><p id="0beb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，有<code class="fe og oh oi mf b">AndSpecification</code>来应用从多个规范定义的变更，但是没有<code class="fe og oh oi mf b">OrSpecification</code>。在创建对象的过程中，我找不到<code class="fe og oh oi mf b">or</code>算法的实际用例。</p><p id="df6d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">即使它不存在，我们也可以引入<code class="fe og oh oi mf b">NotSpecification</code>，它可以处理特定的数据类型，比如布尔值。尽管如此，在这个小例子中，我找不到一个合适的例子。</p><h1 id="8222" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">结论</h1><p id="7320" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">规格说明是一种模式，我们在许多不同的情况下到处使用。今天，如果不使用规范，在领域层提供验证是不容易的。</p><p id="7b88" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">规范，我们也可以用它来查询底层存储中的对象。今天，它们是ORM的一部分。第三种用法是创建复杂的实例，我们可以将它与工厂模式结合起来。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="aa00" class="mj mk it mf b gy ml mm l mn mo">Other articles from DDD series:</span><span id="6c10" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="4af7" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="dd87" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-service-4418a1650274"><strong class="mf jd">Practical DDD in Golang: Domain Service</strong></a></span><span id="f4d7" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-event-de02ad492989"><strong class="mf jd">Practical DDD in Golang: Domain Event</strong></a></span><span id="747a" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">5. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-module-51edf4c319ec"><strong class="mf jd">Practical DDD in Golang: Module</strong></a></span><span id="f342" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">6. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-aggregate-de13f561e629"><strong class="mf jd">Practical DDD in Golang: Aggregate</strong></a></span><span id="0a84" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">7. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-factory-5ba135df6362"><strong class="mf jd">Practical DDD in Golang: Factory</strong></a></span><span id="0c8c" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">8. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-repository-d308c9d79ba7"><strong class="mf jd">Practical DDD in Golang: Repository</strong></a></span></pre><h1 id="e90d" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">有用的资源:</h1><ul class=""><li id="a895" class="oj ok it lk b ll nz lo oa lr ol lv om lz on md oo op oq or bi translated"><a class="ae lh" href="https://martinfowler.com/" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/</a></li><li id="3fd2" class="oj ok it lk b ll os lo ot lr ou lv ov lz ow md oo op oq or bi translated"><a class="ae lh" href="https://www.domainlanguage.com/" rel="noopener ugc nofollow" target="_blank">https://www.domainlanguage.com/</a></li></ul></div></div>    
</body>
</html>