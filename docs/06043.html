<html>
<head>
<title>End-to-End Encrypted Chat with the Web Crypto API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Web Crypto API进行端到端加密聊天</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/end-to-end-encrypted-chat-with-the-web-crypto-api-dd30718ce884?source=collection_archive---------9-----------------------#2020-10-21">https://levelup.gitconnected.com/end-to-end-encrypted-chat-with-the-web-crypto-api-dd30718ce884?source=collection_archive---------9-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/22b15043862926acb025f9f157dc7b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qnZfplHpAmLTELGb"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">克里斯蒂安·威迪格在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="225f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当传输或存储用户数据，尤其是私人对话时，考虑使用加密技术来确保隐私是至关重要的。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi le"><img src="../Images/9cd5cddc7c406faca665fafbc93d0fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/0*GbpBNsKWC27B78iQ"/></div></figure><p id="9d74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过阅读本教程，您将了解如何在web应用程序中使用JavaScript和本地浏览器API<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API" rel="noopener ugc nofollow" target="_blank">Web Crypto API</a>进行端到端的数据加密。</p><p id="17c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">请注意，本教程非常基础，而且具有严格的教育性，可能包含简化内容，并且不建议开发自己的加密协议。如果在安全专家的帮助下使用不当，所使用的算法可能包含某些“陷阱”</strong></p><p id="f374" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你碰巧迷路了，你也可以在这个<a class="ae kf" href="https://github.com/GetStream/encrypted-web-chat" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到完整的项目。如果你有任何问题，请随时通过<a class="ae kf" href="https://twitter.com/cardosodev" rel="noopener ugc nofollow" target="_blank"> Twitter </a>:)联系我。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="5e20" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">什么是端到端加密？</h1><blockquote class="mo mp mq"><p id="9a49" class="kg kh mr ki b kj kk kl km kn ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ld im bi translated"><em class="it">端到端加密是一种通信系统，在这种系统中，只有通信人员才能读取消息。任何窃听者都无法获取解密对话所需的密钥，即使是运行消息服务的公司也不行。</em></p></blockquote><ul class=""><li id="7a3c" class="mv mw it ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated"><a class="ae kf" href="https://www.wired.com/2014/11/hacker-lexicon-end-to-end-encryption/" rel="noopener ugc nofollow" target="_blank"> <em class="mr">黑客词典:什么是端到端加密</em> </a></li></ul><h1 id="60ae" class="lq lr it bd ls lt ne lv lw lx nf lz ma mb ng md me mf nh mh mi mj ni ml mm mn bi translated">什么是Web加密API？</h1><blockquote class="mo mp mq"><p id="4930" class="kg kh mr ki b kj kk kl km kn ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ld im bi translated"><em class="it">Web Cryptography API定义了一个低级接口，用于与由用户代理管理或公开的密钥材料进行交互。API本身不知道密钥存储的底层实现，但提供了一组公共接口，允许富web应用程序执行诸如签名生成和验证、散列和验证、加密和解密等操作，而无需访问原始密钥材料。</em></p></blockquote><ul class=""><li id="2eea" class="mv mw it ki b kj kk kn ko kr mx kv my kz mz ld na nb nc nd bi translated"><a class="ae kf" href="https://www.w3.org/TR/WebCryptoAPI/" rel="noopener ugc nofollow" target="_blank"> <em class="mr"> W3C:网络加密API </em> </a></li></ul></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="d70d" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">基础知识</h1><p id="8a9d" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">在下面的步骤中，我们将声明端到端加密中涉及的基本功能。你可以把每一个都复制到一个专用的<code class="fe no np nq nr b">lib</code>文件夹下的<code class="fe no np nq nr b">.js</code>文件中。注意，由于Web Crypto API的异步特性，它们都是<code class="fe no np nq nr b"> async</code>函数。</p><p id="5cc9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:并不是所有的浏览器都实现了我们将要使用的算法。即Internet Explorer和Microsoft Edge。查看<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto#Browser_compatibility" rel="noopener ugc nofollow" target="_blank"> MDN web docs:微妙的加密-Web API</a>的兼容性表。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="2578" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">生成密钥对</h1><p id="bb94" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">加密密钥对对于端到端加密至关重要。一个<strong class="ki iu">密钥对</strong>由一个<strong class="ki iu">公钥</strong>和一个<strong class="ki iu">私钥</strong>组成。应用程序中的每个用户都应该有一个密钥对来保护他们的数据，公共组件对其他用户可用，私有组件只对密钥对的所有者可用。在下一节中，您将理解这些是如何发挥作用的。</p><p id="e2f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了生成密钥对，我们将使用<code class="fe no np nq nr b"><a class="ae kf" href="https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-generateKey" rel="noopener ugc nofollow" target="_blank">window.crypto.subtle.generateKey</a></code>方法，并使用<code class="fe no np nq nr b"><a class="ae kf" href="https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-exportKey" rel="noopener ugc nofollow" target="_blank">window.crypto.subtle.exportKey</a></code>以<a class="ae kf" href="https://tools.ietf.org/html/rfc7517" rel="noopener ugc nofollow" target="_blank"> JWK格式</a>导出私有和公共密钥。后者是保存或传输这些密钥所必需的。可以把它看作是在JavaScript之外序列化键的一种方式。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="81f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我选择了带有P-256椭圆曲线的ECDH算法，因为它得到了很好的支持，并且在安全性和性能之间取得了平衡。随着新算法的出现，这种偏好会随着时间而改变。</p><p id="4215" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:导出私钥会导致安全问题，因此必须小心处理。允许用户复制和粘贴它的方法将在本教程的集成部分介绍，这不是一个很好的实践，只是出于教育目的。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="ec9e" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">派生密钥</h1><p id="ebc7" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">我们将使用上一步中生成的密钥对来导出对称密钥，该密钥对数据进行加密和解密，并且对于任何两个通信用户都是唯一的。例如，用户A使用他们的私钥和用户B的公钥导出密钥，而用户B使用他们的私钥和用户A的公钥导出相同的密钥。没有人能够在不访问至少一个用户私钥的情况下生成<strong class="ki iu">派生密钥</strong>，因此保证它们的安全是至关重要的。</p><p id="eb82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上一步中，我们以JWK格式导出了密钥对。在我们可以导出密钥之前，我们需要使用<code class="fe no np nq nr b"><a class="ae kf" href="https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-importKey" rel="noopener ugc nofollow" target="_blank">window.crypto.subtle.importKey</a></code>将它们导入回初始状态。为了获得密钥，我们将使用<code class="fe no np nq nr b"><a class="ae kf" href="https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-deriveKey" rel="noopener ugc nofollow" target="_blank">window.crypto.subtle.deriveKey</a></code>。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="128d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我选择了<a class="ae kf" href="https://www.w3.org/TR/WebCryptoAPI/#aes-gcm" rel="noopener ugc nofollow" target="_blank"> AES-GCM算法</a>，因为它具有已知的安全性/性能平衡和浏览器可用性。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="ee31" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">加密文本</h1><p id="51bc" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">现在我们可以使用派生的密钥来加密文本，所以传输它是安全的。</p><p id="3e82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在加密之前，我们将文本编码成一个<code class="fe no np nq nr b">Uint8Array</code>，因为这是加密函数所需要的。我们使用<code class="fe no np nq nr b"><a class="ae kf" href="https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-encrypt" rel="noopener ugc nofollow" target="_blank">window.crypto.subtle.encrypt</a></code>对该数组进行加密，然后将它的<code class="fe no np nq nr b">ArrayBuffer</code>输出返回到<code class="fe no np nq nr b">Uint8Array</code>，然后再返回到<code class="fe no np nq nr b">string</code>并将其编码到<a class="ae kf" href="https://en.wikipedia.org/wiki/Base64" rel="noopener ugc nofollow" target="_blank"> Base64 </a>。JavaScript让它变得有点复杂，但这只是一种将加密数据转化为可传输文本的方式。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0d51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，AES-GCM算法参数包括一个<a class="ae kf" href="https://en.wikipedia.org/wiki/Initialization_vector" rel="noopener ugc nofollow" target="_blank">初始化向量</a> (iv)。对于每个加密操作，它可以是随机的，但绝对必须是唯一的，以确保加密的强度。它包含在消息中，因此可以在解密过程中使用，这是下一步。此外，虽然不太可能达到这个数字，但您应该在使用2次后丢弃密钥，因为随机IV会在该点重复。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="6662" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">解密文本</h1><p id="7138" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">现在我们可以使用派生的密钥来<strong class="ki iu">解密</strong>我们收到的任何加密文本，做的正好与加密步骤相反。</p><p id="b0ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在解密之前，我们检索初始化向量，将字符串从Base64转换回来，转换成一个<code class="fe no np nq nr b">Uint8Array</code>，并使用相同的算法定义解密。之后，我们解码<code class="fe no np nq nr b">ArrayBuffer</code>并返回人类可读的字符串。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1bcd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也有可能由于使用了错误的派生密钥或初始化向量而导致解密过程失败，这意味着用户没有正确的密钥对来解密他们收到的文本。在这种情况下，我们会返回一条错误消息。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="ee69" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">集成到您的聊天应用中</h1><p id="9146" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">这就是所有需要的加密工作！在接下来的部分中，我将解释我如何使用我们上面实现的方法对一个聊天应用程序进行端到端加密，这个应用程序是用<a class="ae kf" href="https://getstream.io/chat/react-chat/tutorial/" rel="noopener ugc nofollow" target="_blank"> Stream Chat的强大的React聊天组件</a>构建的。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="a0ab" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">克隆项目</h1><p id="7e17" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">在本地文件夹中克隆<a class="ae kf" href="https://github.com/getstream/encrypted-web-chat" rel="noopener ugc nofollow" target="_blank">加密网络聊天库</a>，安装依赖项并运行它。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="01f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，应该会打开一个浏览器选项卡。但是首先，我们需要用我们自己的流聊天API键来配置项目。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="a83f" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">配置流聊天仪表板</h1><p id="adac" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">在<a class="ae kf" href="https://getstream.io/" rel="noopener ugc nofollow" target="_blank"> GetStream.io </a>创建您的帐户，创建一个应用程序，并选择开发而不是生产。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/e0202aaf5e5c249e628d206ba7ca9978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jYf69notZLcts5qO"/></div></div></figure><p id="b526" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了简化，让我们禁用授权检查和权限检查。确保点击保存。当你的应用程序在生产中，你应该保持这些启用，并有一个后端为用户提供令牌。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/57f4938dd91c2270241878ba4a27c76d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*82JKb6kq9wwdJm7c"/></div></div></figure><p id="acd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如需进一步参考，请参见<a class="ae kf" href="https://getstream.io/chat/docs/tokens_and_authentication/?language=js" rel="noopener ugc nofollow" target="_blank">认证文档</a>和<a class="ae kf" href="https://getstream.io/chat/docs/chat_permission_policies/?language=js" rel="noopener ugc nofollow" target="_blank">权限文档</a>。</p><p id="e765" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意流凭据，因为我们将在下一步中使用它们来初始化应用程序中的聊天客户端。因为我们禁用了身份验证和权限，所以我们现在只需要密钥。不过，在未来，您将使用后端的秘密来<a class="ae kf" href="https://getstream.io/docs/auth_and_permissions/" rel="noopener ugc nofollow" target="_blank">实现身份验证，为流聊天</a>发布用户令牌，这样您的聊天应用程序就可以拥有适当的访问控制。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/916718027efed1e5ad56b87249088b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sunQU6-SxvBxAK_A"/></div></div></figure><p id="d5cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，我修改了我的钥匙。如果您妥善保管这些凭据，那将是最好的选择。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="916f" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">更改凭据</h1><p id="4f11" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">在<code class="fe no np nq nr b"><a class="ae kf" href="https://github.com/GetStream/encrypted-web-chat/blob/main/src/lib/chatClient.js" rel="noopener ugc nofollow" target="_blank">src/lib/chatClient.js</a></code>中，用你的钥匙更换钥匙。我们将使用这个对象进行API调用并配置聊天组件。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7a39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这之后，您应该能够测试应用程序了。在接下来的步骤中，您将理解我们定义的函数在哪里。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="bbf7" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">设置用户</h1><p id="d81f" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">在<code class="fe no np nq nr b"><a class="ae kf" href="https://github.com/GetStream/encrypted-web-chat/blob/main/src/lib/setUser.js" rel="noopener ugc nofollow" target="_blank">src/lib/setUser.js</a></code>中，我们定义了设置聊天客户端用户的函数，并用给定密钥对的公钥更新它。其他用户需要发送公钥来获取加密和解密与我们用户的通信所需的密钥。</p><figure class="lf lg lh li gt ju"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9ae5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个函数中，我们导入了上一步中定义的<code class="fe no np nq nr b">chatClient</code>。它获取一个用户id和一个<strong class="ki iu">密钥对</strong>，然后调用<code class="fe no np nq nr b">chatClient.setUser</code>来设置用户。之后，它检查该用户是否已经有了一个公钥，以及它是否与给定的密钥对中的公钥相匹配。如果公钥匹配或者不存在，我们用给定的公钥更新该用户；如果没有，我们断开连接并显示一个错误。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="1d0a" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">发送方组件</h1><p id="00f3" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">在<code class="fe no np nq nr b"><a class="ae kf" href="https://github.com/GetStream/encrypted-web-chat/blob/main/src/components/Sender.js" rel="noopener ugc nofollow" target="_blank">src/components/Sender.js</a></code>中，我们定义第一个屏幕，在这里我们选择我们的用户id，并且可以使用我们在<code class="fe no np nq nr b">generateKey.js</code>中描述的函数生成一个密钥对，或者，如果这是一个现有用户，粘贴在用户创建时生成的密钥对。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/61915ed9adbb576095c8c18bbe9ca6af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DzxTgVT9P3KepmAu"/></div></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="820a" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">收件人组件</h1><p id="4128" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">在<code class="fe no np nq nr b"><a class="ae kf" href="https://github.com/GetStream/encrypted-web-chat/blob/main/src/components/Recipient.js" rel="noopener ugc nofollow" target="_blank">src/components/Recipient.js</a></code>中，我们定义了第二个屏幕，在这里我们选择想要与之通信的用户的id。该组件将使用<code class="fe no np nq nr b"><a class="ae kf" href="https://getstream.io/chat/docs/query_users/?language=js" rel="noopener ugc nofollow" target="_blank">chatClient.queryUsers</a></code>获取该用户。调用的结果将包含用户的公钥，我们将使用它来导出加密/解密密钥。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/fa22b32cf81699d15880aaca573eb856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mKHadeVV6vfmjXN2"/></div></div></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="0e3a" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">KeyDeriver组件</h1><p id="3689" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">在<code class="fe no np nq nr b"><a class="ae kf" href="https://github.com/GetStream/encrypted-web-chat/blob/main/src/components/KeyDeriver.js" rel="noopener ugc nofollow" target="_blank">src/components/KeyDeriver.js</a></code>中，我们定义了第三个屏幕，在这里使用我们在<code class="fe no np nq nr b">deriveKey.js</code>中实现的方法，使用发送者(us)的私钥和接收者的公钥来导出密钥。该组件只是一个被动加载屏幕，因为所需的信息已在前两个屏幕中收集。但是如果键有问题，它会显示一个错误。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="4535" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">加密消息组件</h1><p id="986a" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">在<code class="fe no np nq nr b"><a class="ae kf" href="https://github.com/GetStream/encrypted-web-chat/blob/main/src/components/EncryptedMessage.js" rel="noopener ugc nofollow" target="_blank">src/components/EncryptedMessage.js</a></code>中，我们定制了流聊天的消息组件，使用我们在<code class="fe no np nq nr b">decrypt.js</code>中定义的方法以及加密数据和派生密钥来解密消息。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/b0f0b1181c5fa8bb4718e4bcd81fa109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QqDLCziLwOd5vHS5"/></div></div></figure><p id="8a9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有消息组件的这种定制，它将如下所示:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/cc854180df2a20d8a725054b19c914de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qy0MkGwIwkyvvkcm"/></div></div></figure><p id="2981" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定制是通过包装流聊天的<code class="fe no np nq nr b">MessageSimple</code>组件并使用<code class="fe no np nq nr b">useEffect</code>钩子通过解密方法修改消息属性来完成的。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="4570" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">EncryptedMessageInput组件</h1><p id="441e" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">在<code class="fe no np nq nr b"><a class="ae kf" href="https://github.com/GetStream/encrypted-web-chat/blob/main/src/components/EncryptedMessageInput.js" rel="noopener ugc nofollow" target="_blank">src/components/EncryptedMessageInput.js</a></code>中，我们定制了Stream Chat的MessageInput组件，在发送消息之前使用我们在<code class="fe no np nq nr b">encrypt.js</code>中定义的方法对消息进行加密。</p><p id="39b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定制是通过包装Stream Chat的<code class="fe no np nq nr b">MessageInputLarge</code>组件并将<code class="fe no np nq nr b">overrideSubmitHandler</code>属性设置为在发送到频道之前加密文本的函数来完成的。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="f0f7" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">聊天组件</h1><p id="7ddb" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">最后，在<code class="fe no np nq nr b"><a class="ae kf" href="https://github.com/GetStream/encrypted-web-chat/blob/main/src/components/Chat.js" rel="noopener ugc nofollow" target="_blank">src/components/Chat.js</a></code>中，我们使用Stream Chat的组件以及我们的自定义消息和EncryptedMessageInput组件构建了整个聊天屏幕。</p><p id="c79f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe no np nq nr b">MessageList</code>组件有一个<code class="fe no np nq nr b">Message</code>属性，设置为自定义的<code class="fe no np nq nr b">EncryptedMessage</code>组件，而<code class="fe no np nq nr b">EncryptedMessageInput</code>可以放在层次结构中它的正下方。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="b98e" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">Web加密API的后续步骤</h1><p id="f1c2" class="pw-post-body-paragraph kg kh it ki b kj nj kl km kn nk kp kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">恭喜你！您刚刚学习了如何在您的web应用程序中实现基本的端到端加密。要知道这是最基本的端到端加密形式，这一点很重要。它缺乏一些额外的调整，使其在现实世界中更加防弹，例如<a class="ae kf" href="https://en.wikipedia.org/wiki/Padding_(cryptography)#Randomized_padding" rel="noopener ugc nofollow" target="_blank">随机填充</a>、<a class="ae kf" href="https://en.wikipedia.org/wiki/Digital_signature" rel="noopener ugc nofollow" target="_blank">数字签名</a>和<a class="ae kf" href="https://en.wikipedia.org/wiki/Forward_secrecy" rel="noopener ugc nofollow" target="_blank">前向保密</a>等等。此外，对于现实世界的使用，获得应用程序安全专业人员的帮助是至关重要的。</p></div></div>    
</body>
</html>