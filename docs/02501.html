<html>
<head>
<title>Learning Go: A Slice of Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习围棋:围棋的一部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-go-a-slice-of-go-df70d6b854ef?source=collection_archive---------12-----------------------#2020-03-17">https://levelup.gitconnected.com/learning-go-a-slice-of-go-df70d6b854ef?source=collection_archive---------12-----------------------#2020-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/311f1a6ba8111c9b73c5b136459c67dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wb3CPd9lmGkfI0PF"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@henry_be?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亨利贝</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="db86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将演示如何使用切片数据结构。切片是同一类型的未绑定数据序列。切片可以增长和收缩，因此它的大小不像数组那样固定。关于切片有很多要说的，所以我也将在下一篇文章中继续讨论它们。</p><p id="2690" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我开始讨论如何使用片之前，我需要提到的是，现在绝大多数编程专家都说，当需要存储数据时，您应该考虑的第一个数据结构是某种类型的动态结构，比如片。现代编程语言实现这些数据结构的效率比过去高得多，而且像slice这样的动态结构带来了如此多的便利，以至于当slice、vector、ArrayList或List也可以使用时，使用数组就没有意义了。</p><h1 id="fac6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">切片基础</h1><p id="bb7f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">正如我提到的，切片是同一数据类型的未绑定数据序列。从头开始创建切片时，也会创建一个底层数组。如果从零开始创建一个存储片，它开始时的容量为0，随着新元素的添加，容量也会随之增加。这是通过向底层阵列分配新内存来实现的。</p><p id="86fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像数组一样声明一个片，但是没有指定大小。以下是一些例子:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6e83" class="mq lf it mm b gy mr ms l mt mu">var names[] string<br/>var numbers[] int<br/>var flags[] bool</span></pre><p id="6edd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也可以从现有阵列创建切片。通过使用slice操作符从数组中引用所需的元素，可以实现这一点。切片操作符写成<em class="mv">【start:stop】</em>，其中start是切片开始的元素，stop是要停止的元素，但不包括该元素。</p><p id="7645" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的示例中，切片<code class="fe mw mx my mm b">firstThree</code>获取了<code class="fe mw mx my mm b">numbers</code>数组的前三个元素:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e54b" class="mq lf it mm b gy mr ms l mt mu">numbers := [size]int{1,2,3,4,5}<br/>firstThree := numbers[0:3]</span></pre><p id="35c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过省略起始值和停止值，可以将整个数组移动到切片中:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c74a" class="mq lf it mm b gy mr ms l mt mu">firstThree := numbers[:]</span></pre><p id="dc8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是另一个从数组中提取切片的例子，该数组提取最后两个元素:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="21f9" class="mq lf it mm b gy mr ms l mt mu">lastTwo := numbers[3:]</span></pre><p id="48cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，如果基础数组的元素发生变化，基于基础数组的切片的元素也会发生变化。例如:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3031" class="mq lf it mm b gy mr ms l mt mu">func main() {<br/>  const size = 5<br/>  numbers := [size]int{1,2,3,4,5}<br/>  lastTwo := numbers[3:]<br/>  fmt.Println(lastTwo) // [4 5] is displayed<br/>  numbers[3] = 5<br/>  fmt.Println(lastTwo) // [5 5] is displayed<br/>}</span></pre><p id="d659" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建切片的另一种方法是使用内置的<code class="fe mw mx my mm b">make</code>函数。此函数采用数据类型切片说明符、切片长度和切片容量(可用的总元素)。<code class="fe mw mx my mm b">make</code>函数的语法模板如下所示:</p><p id="ce82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mv">切片名称:=制作([]数据类型，长度，容量)</em></p><p id="cff4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以省略容量，这将使其与长度参数相同。下面是语法模板:</p><p id="6cac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mv">切片名称:=制作([]数据类型，长度)</em></p><p id="dbc4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是演示如何使用<code class="fe mw mx my mm b">make</code>函数的代码片段:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3b2b" class="mq lf it mm b gy mr ms l mt mu">numbers := make([]int, 0)</span></pre><p id="6de7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您从一个空切片开始，您可以使用<code class="fe mw mx my mm b">append</code>函数向切片添加元素。追加的语法模板是:</p><p id="e317" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mv">切片名称=追加(切片名称，元素)</em></p><p id="62a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您必须将附加的切片重新分配回切片中，因为您无法确定新的切片是否仍将引用旧切片的基础数组。从语法上来说，你无论如何都要做作业。</p><p id="49a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个程序，它将十个随机生成的数字分配给一个切片:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="24c2" class="mq lf it mm b gy mr ms l mt mu">package main</span><span id="3b6e" class="mq lf it mm b gy mz ms l mt mu">import (<br/>  "fmt"<br/>  "math/rand"<br/>  "time"<br/>)</span><span id="3730" class="mq lf it mm b gy mz ms l mt mu">func main() {<br/>  seed := rand.NewSource(time.Now().Unix())<br/>  rng := rand.New(seed)<br/>  var numbers[] int<br/>  for i:=1; i&lt;=10; i++ {<br/>    numbers = append(numbers, rng.Intn(100))<br/>  }<br/>  fmt.Print(numbers)<br/>}</span></pre><h1 id="79b0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">复制切片和其他切片功能</h1><p id="ce84" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">先说对比。不能用<code class="fe mw mx my mm b">==</code>操作符比较两个切片是否相等。如果你尝试，你会得到一个错误。相反，你将不得不写一个函数来做这件事。这里有一个例子:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="df73" class="mq lf it mm b gy mr ms l mt mu">package main</span><span id="0f0c" class="mq lf it mm b gy mz ms l mt mu">import (<br/>  "fmt"<br/>  "math/rand"<br/>  "time"<br/>)</span><span id="2717" class="mq lf it mm b gy mz ms l mt mu">func equal(s1, s2 []int) bool {<br/>  if len(s1) != len(s2) {<br/>    return false<br/>  }<br/>  for i := range s1 {<br/>    if s1[i] != s2[i] {<br/>      return false<br/>    }<br/>  }<br/>  return true<br/>}</span><span id="cf59" class="mq lf it mm b gy mz ms l mt mu">func main() {<br/>  seed := rand.NewSource(time.Now().Unix())<br/>  rng := rand.New(seed)<br/>  numbers := make([]int, 0)<br/>  for i:=1; i&lt;=10; i++ {<br/>    numbers = append(numbers, rng.Intn(100))<br/>  }<br/>  numbersCopy := make([]int, len(numbers))<br/>  copy(numbersCopy, numbers)<br/>  fmt.Println(numbers)<br/>  fmt.Println(numbersCopy)<br/>  if equal(numbers, numbersCopy) {<br/>    fmt.Print("The same.")<br/>  } else {<br/>    fmt.Print("Different.") <br/>  }<br/>}</span></pre><p id="4b85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以编写一个函数来反转切片的内容(不像其他语言那样有内置的反转函数)。这里有一个来自多诺万和克尼根的Go编程语言的例子:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="47d5" class="mq lf it mm b gy mr ms l mt mu">package main</span><span id="eaf3" class="mq lf it mm b gy mz ms l mt mu">import (<br/>  "fmt"<br/>  "math/rand"<br/>  "time"<br/>)</span><span id="977e" class="mq lf it mm b gy mz ms l mt mu">func reverse(sl[] int) {<br/>  for i, j := 0, len(sl)-1; i &lt; j; i, j = i+1, j-1 {<br/>    sl[i], sl[j] = sl[j], sl[i]<br/>  }<br/>}</span><span id="6d98" class="mq lf it mm b gy mz ms l mt mu">func main() {<br/>  seed := rand.NewSource(time.Now().Unix())<br/>  rng := rand.New(seed)<br/>  numbers := make([]int, 0)<br/>  for i:=1; i&lt;=10; i++ {<br/>    numbers = append(numbers, rng.Intn(100))<br/>  }<br/>  fmt.Println(numbers)<br/>  reverse(numbers)<br/>  fmt.Println(numbers)<br/>}</span></pre><p id="c244" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有两个内置函数可用于切片。一个函数<code class="fe mw mx my mm b">len</code>返回切片的长度，如下例所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2595" class="mq lf it mm b gy mr ms l mt mu">for i:=1; i&lt;=10; i++ {<br/>  numbers = append(numbers, rng.Intn(100))<br/>}<br/>fmt.Println(numbers)<br/>fmt.Printf("The length of numbers is %d.\n", len(numbers))</span></pre><p id="b38e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以使用<code class="fe mw mx my mm b">cap</code>功能检索切片的<em class="mv">容量</em>。一个片的容量是可以添加到该片的元素总数，而不必为更多存储空间分配内存。</p><p id="787f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下程序演示了随着更多数据添加到原本为空的切片中，容量是如何分配的:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="16bf" class="mq lf it mm b gy mr ms l mt mu">func main() {<br/>  numbers := make([]int, 0)<br/>  for i:=1; i&lt;=10; i++ {<br/>    numbers = append(numbers, i)<br/>    fmt.Printf("The capacity of numbers is %d.\n", cap(numbers))<br/>  }<br/>}</span></pre><p id="7e8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8648" class="mq lf it mm b gy mr ms l mt mu">The capacity of numbers is 1.<br/>The capacity of numbers is 2.<br/>The capacity of numbers is 4.<br/>The capacity of numbers is 4.<br/>The capacity of numbers is 8.<br/>The capacity of numbers is 8.<br/>The capacity of numbers is 8.<br/>The capacity of numbers is 8.<br/>The capacity of numbers is 16.<br/>The capacity of numbers is 16.</span></pre><h1 id="7968" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">处理切片的所有元素</h1><p id="7f08" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有两种方法可以处理切片的所有元素。第一种方法是使用索引<code class="fe mw mx my mm b">for</code>循环。下面是一个演示这种技术的程序:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="989f" class="mq lf it mm b gy mr ms l mt mu">func main() {<br/>  grades := []int {88, 71, 91, 83, 100}<br/>  var total int<br/>  for i:=0; i&lt;len(grades); i++ {<br/>    total += grades[i] <br/>  }<br/>  average := float64(total) / float64(len(grades))<br/>  fmt.Printf("The average is %.2f.\n", average)<br/>}</span></pre><p id="b549" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">迭代切片值的更安全的方法是使用一个<code class="fe mw mx my mm b">range for</code>循环。下面是上面用一个<code class="fe mw mx my mm b">range for</code>循环重写的程序:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9702" class="mq lf it mm b gy mr ms l mt mu">func main() {<br/>  grades := []int {88, 71, 91, 83, 100}<br/>  var total int<br/>  for _, grade := range grades {<br/>    total += grade<br/>  }<br/>  average := float64(total) / float64(len(grades))<br/>  fmt.Printf("The average is %.2f.\n", average)<br/>}</span></pre><h1 id="2cd7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">一片切片</h1><p id="e69a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在这篇文章中，我只介绍了切片的一部分功能。在我的下一篇文章中，我将更详细地介绍如何使用切片的切片，这也是切片比使用数组真正有优势的地方。</p><p id="b444" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请发送电子邮件提出意见或建议。</p></div></div>    
</body>
</html>