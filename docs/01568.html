<html>
<head>
<title>Cool New Features Released with TypeScript 3.6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 3.6发布的很酷的新功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cool-new-features-released-with-typescript-3-6-aeba036b3191?source=collection_archive---------11-----------------------#2020-01-13">https://levelup.gitconnected.com/cool-new-features-released-with-typescript-3-6-aeba036b3191?source=collection_archive---------11-----------------------#2020-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/02cbdb8355b07303f6c7a458ffc400df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XhsYSJpOkO5oe5ox"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@genmai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">俊介小野</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0bb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript 3.6发布了许多新功能。它包含了可迭代的特性，比如更严格的生成器类型检查，更精确的数组分布，允许在<code class="fe le lf lg lh b">declare</code>语句中使用<code class="fe le lf lg lh b">get</code>和<code class="fe le lf lg lh b">set</code>，等等。</p><p id="3d92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将逐一介绍它们。</p><h1 id="db7f" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">对发电机进行更严格的类型检查</h1><p id="d304" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在TypeScript 3.6中，TypeScript编译器对生成器中的数据类型进行了更多的检查。</p><p id="4abc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有一种方法来区分我们的代码<code class="fe le lf lg lh b">yield</code>或<code class="fe le lf lg lh b">return</code>是否来自生成器。</p><p id="0895" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下生成器:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f095" class="mt lj it lh b gy mu mv l mw mx">function* bar() {<br/>    yield 1;<br/>    yield 2;<br/>    return "Finished!"<br/>}</span><span id="ce6f" class="mt lj it lh b gy my mv l mw mx">let iterator = bar();<br/>let curr = iterator.next();<br/>curr = iterator.next();</span><span id="fecc" class="mt lj it lh b gy my mv l mw mx">if (curr.done) {<br/>    curr.value<br/>}</span></pre><p id="62a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript 3.6编译器自动知道<code class="fe le lf lg lh b">curr.value</code>是一个字符串，因为我们在函数的末尾返回了一个字符串。</p><p id="989b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，当我们将<code class="fe le lf lg lh b">yield</code>赋值给某个对象时，<code class="fe le lf lg lh b">yield</code>不会被假定为<code class="fe le lf lg lh b">any</code>类型。</p><p id="2673" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们有以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0fa0" class="mt lj it lh b gy mu mv l mw mx">function* bar() {<br/>    let x: { foo(): void } = yield;    <br/>}</span><span id="ee4e" class="mt lj it lh b gy my mv l mw mx">let iterator = bar();<br/>iterator.next();<br/>iterator.next(123);</span></pre><p id="764a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在TypeScript编译器知道123不能赋给类型为<code class="fe le lf lg lh b">{ foo(): void }</code>的东西，类型为<code class="fe le lf lg lh b">x</code>。而在早期版本中，编译器不检查上面代码的类型。</p><p id="9c8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在TypeScript 3.6或更高版本中，我们会得到错误:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f9c2" class="mt lj it lh b gy mu mv l mw mx">Argument of type '[123]' is not assignable to parameter of type '[] | [{ foo(): void; }]'.</span><span id="04d6" class="mt lj it lh b gy my mv l mw mx">Type '[123]' is not assignable to type '[{ foo(): void; }]'.</span><span id="57e8" class="mt lj it lh b gy my mv l mw mx">Type '123' is not assignable to type '{ foo(): void; }'.</span></pre><p id="4ee6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，现在<code class="fe le lf lg lh b">Generator</code>和<code class="fe le lf lg lh b">Iterator</code>的类型定义有了<code class="fe le lf lg lh b">return</code>和<code class="fe le lf lg lh b">throw</code>方法，并且是可迭代的。</p><p id="b926" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript 3.6将<code class="fe le lf lg lh b">IteratorResult</code>转换为<code class="fe le lf lg lh b">IteratorYieldResult&lt;T&gt; | IteratorReturnResult&lt;TReturn&gt;</code>联合类型。</p><p id="33de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还可以从调用它的地方推断出从<code class="fe le lf lg lh b">next()</code>返回的值。</p><p id="0253" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，由于我们将正确类型的值传入了字符串<code class="fe le lf lg lh b">next()</code>，下面的代码将会编译并运行:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1d30" class="mt lj it lh b gy mu mv l mw mx">function* bar() {<br/>    let x: string = yield;<br/>    console.log(x.toUpperCase());<br/>}</span><span id="a9e5" class="mt lj it lh b gy my mv l mw mx">let x = bar();<br/>x.next(); <br/>x.next('foo');</span></pre><p id="7f4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，由于参数和<code class="fe le lf lg lh b">x</code>的类型不匹配，下面的代码将无法编译:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d6d0" class="mt lj it lh b gy mu mv l mw mx">function* bar() {<br/>    let x: string = yield;<br/>    console.log(x.toUpperCase());<br/>}</span><span id="58fb" class="mt lj it lh b gy my mv l mw mx">let x = bar();<br/>x.next(); <br/>x.next(42);</span></pre><p id="7c8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们必须传入一个字符串来修复从<code class="fe le lf lg lh b">x.next(42);</code>中产生的。此外，TypeScript编译器知道对<code class="fe le lf lg lh b">next()</code>的第一次调用没有任何作用。</p><h1 id="95fb" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">更精确的阵列排列</h1><p id="6f30" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在TypeScript 3.6中，当代码转换为ES5或更早的目标且<code class="fe le lf lg lh b">--downlevelIteration</code>打开时，一些数组展开运算符的转换现在会产生等效的结果。</p><p id="485c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该标志的目的是转换ES6迭代结构，如spread操作符和<code class="fe le lf lg lh b">for...of</code>循环，以将对ES6迭代结构的支持添加到转换到比ES6更老的代码中。</p><p id="da23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2253" class="mt lj it lh b gy mu mv l mw mx">[...Array(3)]</span></pre><p id="572c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="82ca" class="mt lj it lh b gy mu mv l mw mx">[undefined, undefined, undefined]</span></pre><p id="1471" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，早于3.6的TypeScript版本将<code class="fe le lf lg lh b">[…Array(3)]</code>更改为<code class="fe le lf lg lh b">Array(3).slice();</code></p><p id="dfda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将得到一个空数组，其中的<code class="fe le lf lg lh b">length</code>属性设置为3。</p><h1 id="a4f3" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用不良承诺代码引发错误</h1><p id="825c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">如果我们忘记在<code class="fe le lf lg lh b">async</code>函数中把<code class="fe le lf lg lh b">await</code>放在承诺之前，或者忘记在承诺之后调用<code class="fe le lf lg lh b">then</code>，TypeScript 3.6编译器会让我们知道。</p><p id="9d94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="322a" class="mt lj it lh b gy mu mv l mw mx">interface Person {<br/>    name: string;    <br/>}</span><span id="0fff" class="mt lj it lh b gy my mv l mw mx">let promise: Promise&lt;Person&gt; = Promise.resolve(&lt;Person&gt;{ name: 'Joe' });<br/>(async () =&gt; {<br/>    const person: Person = promise;<br/>})();</span></pre><p id="5614" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到错误:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8652" class="mt lj it lh b gy mu mv l mw mx">Property 'name' is missing in type 'Promise&lt;Person&gt;' but required in type 'Person'.</span></pre><p id="c925" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">promise</code>之前放入<code class="fe le lf lg lh b">await</code>可以解决问题:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4960" class="mt lj it lh b gy mu mv l mw mx">interface Person {<br/>    name: string;    <br/>}</span><span id="ef89" class="mt lj it lh b gy my mv l mw mx">let promise: Promise&lt;Person&gt; = Promise.resolve(&lt;Person&gt;{ name: 'Joe' });<br/>(async () =&gt; {<br/>    const person: Person = await promise;<br/>})();</span></pre><p id="6424" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">写着这样的东西:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f3ad" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>      fetch("https://reddit.com/r/javascript.json")<br/>        .json()<br/>})();</span></pre><p id="b781" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">会给我们带来错误:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="971f" class="mt lj it lh b gy mu mv l mw mx">Property 'json' does not exist on type 'Promise&lt;Response&gt;'.(2339)</span><span id="c2fc" class="mt lj it lh b gy my mv l mw mx">input.ts(3, 10): Did you forget to use 'await'?</span></pre><p id="b8eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下内容将修复该错误:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="970c" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  const response = await fetch("<a class="ae kf" href="https://reddit.com/r/javascript.json" rel="noopener ugc nofollow" target="_blank">https://reddit.com/r/javascript.json</a>")<br/>  const responseJson = response.json()  <br/>})();</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/5fca0ec1192c71327fb8a631d75c316d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FYjAIEdtd6weFWd0"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@eddyray?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃迪·拉克曼</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="bc6b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Unicode字符标识符</h1><p id="09e2" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">现在，我们可以使用Unicode字符作为TypeScript的标识符。例如:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="fa0c" class="mt lj it lh b gy mu mv l mw mx">const 😚 = 'foo';</span></pre><p id="f0d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将使用TypeScript 3.6编译器或更高版本。</p><h1 id="267a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在Declare语句中允许使用<code class="fe le lf lg lh b">get</code>和<code class="fe le lf lg lh b">set</code>访问器</h1><p id="7690" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们现在可以将<code class="fe le lf lg lh b">get</code>和<code class="fe le lf lg lh b">set</code>添加到<code class="fe le lf lg lh b">declare</code>语句中。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="738f" class="mt lj it lh b gy mu mv l mw mx">declare class Bar {    <br/>  get y(): number;<br/>  set y(val: number);<br/>}</span></pre><p id="78b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在TypeScript 3.7或更高版本中，生成的类型定义还将发出<code class="fe le lf lg lh b">get</code>和<code class="fe le lf lg lh b">set</code>访问器。</p><h1 id="6747" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">合并类和构造函数声明语句</h1><p id="18d3" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在TypeScript 3.6或更高版本中，编译器足够聪明，可以合并同名的函数构造函数和类<code class="fe le lf lg lh b">declare</code>语句。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="41e2" class="mt lj it lh b gy mu mv l mw mx">export declare function Person(name: string, age: number): Person;<br/>export declare class Person {<br/>    name: string;<br/>    age: number;<br/>    constructor(name: string, age: number);<br/>}</span></pre><p id="4fb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它知道函数是一个构造函数，类和函数是一样的。</p><p id="034c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数和类构造函数中的构造函数的签名不必匹配，因此:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="337c" class="mt lj it lh b gy mu mv l mw mx">export declare function Person(name: string): Person;<br/>export declare class Person {<br/>    name: string;<br/>    age: number;<br/>    constructor(name: string, age: number);<br/>}</span></pre><p id="6de4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仍然有效。</p><h1 id="187b" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">分号</h1><p id="ae6e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">现在，TypeScript足够智能，可以根据样式约定在需要分号的地方自动添加分号，而不是自动添加到每个语句中。</p><p id="902e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript 3.6是另一个功能丰富的版本。它专注于改进一些特性，比如推断类型和生成器中的类型检查，以及在ES5或更早版本中为代码提供更精确的数组分布。</p><p id="59c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，糟糕的承诺代码会引发错误，比如错过了<code class="fe le lf lg lh b">await</code>或<code class="fe le lf lg lh b">then</code>的错误。</p><p id="c81f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在也支持在<code class="fe le lf lg lh b">declare</code>语句中合并函数构造函数和类代码。</p><p id="6e27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">标识符现在支持Unicode字符，分号不会自动添加到每一行。</p></div></div>    
</body>
</html>