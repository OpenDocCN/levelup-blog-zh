<html>
<head>
<title>Implementing “Redux-style” state management with React’s useContext &amp; useReducer Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React的useContext &amp; useReducer钩子实现“Redux风格”的状态管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-redux-style-state-management-with-reacts-usecontext-usereducer-hooks-c1c5596d9619?source=collection_archive---------1-----------------------#2019-01-27">https://levelup.gitconnected.com/implementing-redux-style-state-management-with-reacts-usecontext-usereducer-hooks-c1c5596d9619?source=collection_archive---------1-----------------------#2019-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/66ea292bf6e84040ff0c25e8fd49ff40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*bCr9TeAoPaIT5L5VheAvGQ.png"/></div></figure><p id="615b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于那些还不知道的人，React团队最近<a class="ae ks" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">引入了钩子</a>作为一种采用更功能化的方法来编写组件的方式，它们已经在v 16 . 8 . 0-alpha 1中存在了几个月。不过，他们现在已经得到了<a class="ae ks" href="https://github.com/facebook/react/pull/14679" rel="noopener ugc nofollow" target="_blank"> <strong class="jw ir">和</strong> </a>的正式批准，将会包含在React即将推出的版本中🎉</p><p id="d199" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">(如果有一个视频是你<em class="kt">有</em>可以看的，那就是这个<a class="ae ks" href="https://www.youtube.com/watch?v=dpw9EHDh2bM&amp;feature=youtu.be" rel="noopener ugc nofollow" target="_blank">一个</a>)</p><p id="09ad" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">关于钩子将如何影响React生态系统有很多观点，特别是关于我们在React应用程序中管理状态的方式。如果你对React最近的活动有所了解，我敢肯定你已经看到了一篇名为“<em class="kt">钩子是冗余杀手吗？？？</em>”或大意如此的话。我的看法，不是。</p><p id="4488" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Redux肯定有它的学习曲线，在不真正需要它的小规模应用程序中很难理解它的神奇之处。有很多样板文件和我想称之为“仪式化”的代码，你必须编写这些代码来用Redux设置好一切，但是一旦它被正确地配置，它是非常惊人的。围绕Redux的工具，尤其是它的<a class="ae ks" href="https://www.npmjs.com/package/redux-devtools-extension" rel="noopener ugc nofollow" target="_blank">开发者工具</a>，也是非常出色的，在Redux实现之后，调试React应用程序会变得更加容易。然而，对于可能无法保证Redux的小型应用程序，可以使用替代方法(就像我下面将要描述的)。</p><p id="2396" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过从我在教程和关于钩子的演练中看到的方法中挑选和提取，我已经精心制作了一种方法来应用我们在Redux中看到使用的状态管理风格，但是只使用了<em class="kt">和</em> React。完全透明，我在其中使用该系统的应用程序规模相对较小，我认为有许多开发人员的大型应用程序肯定会从使用Redux中受益更多。</p><p id="3de3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该系统利用<code class="fe ku kv kw kx b"><a class="ae ks" href="https://www.npmjs.com/package/redux-devtools-extension" rel="noopener ugc nofollow" target="_blank">useContext</a></code>和<code class="fe ku kv kw kx b"><a class="ae ks" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a></code>挂钩。前者，如React文档中所述，“<em class="kt">接受一个上下文对象(从</em> <code class="fe ku kv kw kx b"><em class="kt">React.createContext</em></code> <em class="kt">返回的值)并返回当前上下文值，该值由给定上下文</em>的最近上下文提供者给出”，而后者“<em class="kt">接受一个类型为</em> <code class="fe ku kv kw kx b"><em class="kt">(state, action) =&gt; newState</em></code> <em class="kt">的缩减器，并返回与一个</em> <code class="fe ku kv kw kx b"><em class="kt">dispatch</em></code> <em class="kt">方法配对的当前状态。(如果你熟悉Redux，你已经知道这是如何工作的。).</em>”</p><p id="3466" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我的这些项目的文件结构如下所示:</p><pre class="ky kz la lb gt lc kx ld le aw lf bi"><span id="b49b" class="lg lh iq kx b gy li lj l lk ll">&gt; public<br/>&gt; src<br/> - components/<br/> - state/<br/>   - actions/<br/>   - reducers/<br/>   - context/<br/>   - constants.js<br/> - hooks/</span></pre><p id="f6c9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe ku kv kw kx b">context/index.js</code>中，我使用<code class="fe ku kv kw kx b">React.createContext</code>创建了一个上下文实例:</p><pre class="ky kz la lb gt lc kx ld le aw lf bi"><span id="8de4" class="lg lh iq kx b gy li lj l lk ll">import { createContext } from "react";</span><span id="c009" class="lg lh iq kx b gy lm lj l lk ll">const UserContext = createContext({<br/>  currentUser: localStorage.getItem("authenticated-user")<br/>  ? JSON.parse(localStorage.getItem("authenticated-user"))<br/>  : {}<br/> });</span><span id="2230" class="lg lh iq kx b gy lm lj l lk ll">export default UserContext;</span></pre><p id="9e59" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，在<code class="fe ku kv kw kx b">App.js</code>中，我定义了我的<code class="fe ku kv kw kx b">initialState</code>，在其中存储了<code class="fe ku kv kw kx b">useContext</code>钩子的返回值:</p><pre class="ky kz la lb gt lc kx ld le aw lf bi"><span id="02c7" class="lg lh iq kx b gy li lj l lk ll">const App = () =&gt; {<br/>const initialState = useContext(UserContext);<br/>const [{ currentUser }, dispatch] = useReducer(<br/>UserReducer,<br/>initialState<br/>);</span><span id="e36c" class="lg lh iq kx b gy lm lj l lk ll">return (<br/>&lt;UserContext.Provider <em class="kt">value</em>={{ currentUser, dispatch }}&gt;<br/>  &lt;Nav /&gt;<br/>  &lt;Router&gt;<br/>    &lt;Login <em class="kt">path</em>="/" /&gt;<br/>    &lt;Register <em class="kt">path</em>="/register" /&gt;<br/>    &lt;Dashboard <em class="kt">path</em>="/user/:id" /&gt;<br/>  &lt;/Router&gt;<br/>&lt;/UserContext.Provider&gt;<br/>)};</span></pre><p id="9766" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，在我的<code class="fe ku kv kw kx b">App</code>组件的顶部，我从从<code class="fe ku kv kw kx b">useReducer</code>的返回值中解构的状态中解构了<code class="fe ku kv kw kx b">currentUser</code>(~<em class="kt">解构启始</em> ~)。然后，我将从<code class="fe ku kv kw kx b">useReducer</code>接收到的<code class="fe ku kv kw kx b">currentUser</code>和<code class="fe ku kv kw kx b">dispatch</code>函数(我们将在一分钟后讨论)传递给上下文提供者，使其可用于我的应用程序中的每个组件。对于不熟悉解构的人，同样可以通过以下方式完成:</p><pre class="ky kz la lb gt lc kx ld le aw lf bi"><span id="bfa2" class="lg lh iq kx b gy li lj l lk ll">const [state, dispatch] = useReducer(UserReducer, initialState)<br/>...<br/>&lt;UserContext.Provider value={{ currentUser: state.currentUser, dispatch }}</span></pre><p id="6f92" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们来看看我在<code class="fe ku kv kw kx b">reducer/index.js</code>中的减速器:</p><pre class="ky kz la lb gt lc kx ld le aw lf bi"><span id="a78e" class="lg lh iq kx b gy li lj l lk ll">import { REGISTER_USER, LOGIN_USER, LOGOUT_USER } from "./constants";</span><span id="415c" class="lg lh iq kx b gy lm lj l lk ll">const initialState = {<br/>  currentUser: localStorage.getItem("authenticated-user")<br/>  ? JSON.parse(localStorage.getItem("authenticated-user"))<br/>  : {},<br/>  errorMessage: ""<br/>};</span><span id="131a" class="lg lh iq kx b gy lm lj l lk ll">const UserReducer = (state = initialState,<br/>{ type, registeredUser, loggedInUser, success, message, boards }<br/>) =&gt; {</span><span id="75f3" class="lg lh iq kx b gy lm lj l lk ll">switch (type) {<br/>  case REGISTER_USER:<br/>    console.log(<br/>     `%c {type: REGISTER_USER, registeredUser: ${JSON.stringify(<br/>       registeredUser )}}`, "color: yellow; font-weight: bold");</span><span id="0012" class="lg lh iq kx b gy lm lj l lk ll">return success ? { ...state, newUser: true }<br/> : { ...state, errorMessage: message };<br/>  <br/>  case LOGIN_USER:<br/>    console.log(`%c {type: LOGIN_USER, loggedInUser:<br/>      ${JSON.stringify(loggedInUser)}}`, "color: teal; font-weight:<br/>       bold");</span><span id="b457" class="lg lh iq kx b gy lm lj l lk ll"> return success ? { ...state, currentUser: loggedInUser }<br/>  : { ...state, errorMessage: message } </span><span id="f591" class="lg lh iq kx b gy lm lj l lk ll">case LOGOUT_USER:<br/>  console.log(<br/>    `%c {type: LOGOUT_USER, currentUser: {}} `,<br/>      "color: pink; font-weight: bold" );</span><span id="12e9" class="lg lh iq kx b gy lm lj l lk ll">return { ...state, currentUser: {} };</span><span id="a8f4" class="lg lh iq kx b gy lm lj l lk ll">default:<br/>  return state;<br/>}<br/>};</span><span id="de17" class="lg lh iq kx b gy lm lj l lk ll">export default UserReducer;</span></pre><p id="7746" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有几件事需要注意…首先，为什么我在文件顶部定义我的<code class="fe ku kv kw kx b">initialState</code>时要重复代码？为什么我不能像以前一样给<code class="fe ku kv kw kx b">initialState</code>赋值<code class="fe ku kv kw kx b">useContext(UserContext)</code>的返回值，或者为什么我不能在别处定义它，导出它，然后导入到我的reducer文件中？关于调用钩子的一个重要警告(来自React文档):"<strong class="jw ir"> <em class="kt">不要在循环、条件或嵌套函数中调用钩子。相反，总是在React函数的顶层使用钩子。通过遵循这条规则，您可以确保每次组件呈现时都以相同的顺序调用钩子。这就是为什么React能够正确保存多个</em> <code class="fe ku kv kw kx b"><em class="kt">useState</em></code> <em class="kt">和</em> <code class="fe ku kv kw kx b"><em class="kt">useEffect</em></code> <em class="kt">调用之间的钩子状态。</em>”换句话说，你只能在<em class="kt"> React </em>函数的顶层调用一个钩子，而不是普通的JavaScript函数。</strong></p><p id="7952" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还有，这个console.log到底是什么东西？好吧，如果你曾经使用过<a class="ae ks" href="https://www.npmjs.com/package/redux-logger" rel="noopener ugc nofollow" target="_blank"> redux-logger </a>中间件，这是我模仿该功能的廉价尝试，让我知道每个缩减器何时被调用。</p><p id="6921" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你还不知道，我是一个解构主义的超级粉丝，我已经在我的reducer函数的参数中解构了我的“有效载荷”(如果你熟悉Redux的话)。但是，请注意，总的来说，这遵循了与Redux reducer非常相似的结构——主要是因为它只是普通的JavaScript。</p><p id="795c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是我在<code class="fe ku kv kw kx b">actions/index.js</code>中的一个动作:</p><pre class="ky kz la lb gt lc kx ld le aw lf bi"><span id="07ce" class="lg lh iq kx b gy li lj l lk ll"><em class="kt">//user registration<br/></em>export const registerUser = async (user, dispatch) =&gt; {<br/>  const { username, email, password } = user;</span><span id="3754" class="lg lh iq kx b gy lm lj l lk ll">try {<br/> const registerRes = await fetch("/user/register", { method: "POST",<br/>  mode: "cors", cache: "no-cache", headers: { "Content-Type":<br/>  "application/json"<br/> },<br/> redirect: "follow", referrer: "no-referrer", body: JSON.stringify({<br/>   username, email, password })<br/> });</span><span id="9ac7" class="lg lh iq kx b gy lm lj l lk ll">const { token, success, user: registeredUser } = await <br/> registerRes.json();</span><span id="0954" class="lg lh iq kx b gy lm lj l lk ll">if (success) {<br/>  dispatch({ type: REGISTER_USER, registeredUser, success });<br/>   console.log(`${user.username}'s account was REGISTERED and set in <br/>   localstorage`);</span><span id="6109" class="lg lh iq kx b gy lm lj l lk ll">return localStorage.setItem( "authenticated-user", JSON.stringify({<br/>  token, username: registeredUser.username, id: registeredUser._id<br/> })<br/>);<br/>}</span><span id="4e6d" class="lg lh iq kx b gy lm lj l lk ll">} catch (error) {<br/>  console.error(error);<br/>  return dispatch({ type: ERROR, message: error.message });<br/> }<br/>};</span></pre><p id="1ddd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你曾经使用过redux-thunks，那基本上是我的每个动作创建者的形式。注意我是如何接受<code class="fe ku kv kw kx b">dispatch</code>函数作为参数的，它从调用它的组件传递给动作。</p><p id="7726" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么，你到底是怎么利用这些的呢？嗯，下面是我如何在我的<code class="fe ku kv kw kx b">components/Register.js</code>中使用它(利用上面定义的动作创建器):</p><pre class="ky kz la lb gt lc kx ld le aw lf bi"><span id="589c" class="lg lh iq kx b gy li lj l lk ll">import React, { useState } from "react";<br/>import { navigate } from "@reach/router";<br/>import { registerUser } from "../state/actions/user_actions";<br/>import { useContext } from "react";<br/>import UserContext from "../state/context";</span><span id="fa3c" class="lg lh iq kx b gy lm lj l lk ll">const initialFormState = {<br/>  username: "",<br/>  email: "",<br/>  password: "",<br/>  organization: ""<br/>};</span><span id="de78" class="lg lh iq kx b gy lm lj l lk ll">const Register = () =&gt; {<br/>  const [user, setUser] = useState(initialRegisterFormState);<br/>  const { dispatch } = useContext(UserContext);</span><span id="4f58" class="lg lh iq kx b gy lm lj l lk ll">  const handleInput = e =&gt; {<br/>    setUser({ ...user, [e.target.name]: e.target.value });<br/>  };</span><span id="52fa" class="lg lh iq kx b gy lm lj l lk ll">  const handleSubmit = e =&gt; {<br/>    e.preventDefault();<br/>    setUser(initialFormState);<br/>    registerUser(user, dispatch);<br/>    navigate("/");<br/> };</span><span id="7723" class="lg lh iq kx b gy lm lj l lk ll">...</span></pre><p id="e6cb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我能够从<code class="fe ku kv kw kx b">useContext</code>钩子的返回值中解构我的<code class="fe ku kv kw kx b">dispatch</code>函数，然后将它传递给我的<code class="fe ku kv kw kx b">registerUser</code>动作。很简单。注意我是如何利用<code class="fe ku kv kw kx b"><a class="ae ks" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">useState</a></code>钩子来管理组件的本地状态的。</p><p id="dc7d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">也就这样了！除了React，不需要其他依赖。提醒一下，这是我一直在玩的一个系统，我自己也还在学习如何使用钩子，尤其是在管理状态的时候。正如我之前提到的，当涉及到大规模应用程序时，我会说Redux可能是一个更好的选择，但是我鼓励您探索钩子的世界，以及它们如何允许您以多种方式管理应用程序的状态！</p><p id="d129" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">感谢您的倾听。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><figure class="ky kz la lb gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi lu"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="lv lw gp gr lx ly"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd ir gy z fp md fr fs me fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">排名前49的React教程-免费学习React。课程由开发人员提交并投票，使您能够…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">gitconnected.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm js ly"/></div></div></a></div></div></div>    
</body>
</html>