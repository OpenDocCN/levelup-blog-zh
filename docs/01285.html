<html>
<head>
<title>JavaScript: The fastest way to structure Strings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:构造字符串的最快方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-the-fastest-way-to-replace-strings-b304a511ec?source=collection_archive---------4-----------------------#2019-12-11">https://levelup.gitconnected.com/javascript-the-fastest-way-to-replace-strings-b304a511ec?source=collection_archive---------4-----------------------#2019-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/22326dbec8e401c126ff9968472f236f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oi-LeHD_yKRzNfHHShjHMA.jpeg"/></div></div></figure><p id="84ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用JavaScript已经将近十年了，这意味着我的大部分编码风格都是基于早期的习惯。在过去的几年里，JavaScript不仅提高了性能，还改进了编写代码的方式。</p><p id="4554" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是，用这些新的写作风格写更干净的代码，我们是在牺牲性能吗？</p><p id="fbd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了检验这个理论，我将向你展示如何使用这个句子:</p><p id="a4ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“有时候，最好是离开这些事情，等你心情更好的时候再去做。”——典型的程序员思维。</p><p id="c7f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是我过去如何操作字符串的一个例子:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="05c0" class="lf lg iq lb b gy lh li l lj lk">'Sometimes ' + wordList[0] + ' it ' + wordList[1] + ' is ' + wordList[2] + ' better ';</span></pre><p id="3e64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它看起来并不干净，但自从我开始学习以来，这是我选择构建字符串的典型方式。</p><p id="33d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我个人尽量避免的另一种方式:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="9fb2" class="lf lg iq lb b gy lh li l lj lk">'Sometimes [str] it [str] is [str] better'.replace('[str]', 'Some Word');</span></pre><p id="6246" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的方法用的是<strong class="ka ir">。替换('[str]'，'某个单词')；</strong>将第一次出现的<strong class="ka ir">【str】</strong>与<strong class="ka ir">【某词】</strong>互换。重复它，它会找到下一个出现的位置并将其换出。对我来说有点太笨重了。</p><p id="644c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前，我最喜欢的方法是<a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">模板文字</a>，这种方法在过去几年里获得了更广泛的支持:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="bc11" class="lf lg iq lb b gy lh li l lj lk">`Sometimes ${wordList[0]} it ${wordList[1]} is ${wordList[2]} better`;</span></pre><p id="5b9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于操作琴弦的三种风格，我想出了一个测试，看看哪一种最快。我遵循这些原则:</p><ol class=""><li id="9565" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv lr ls lt lu bi translated">测试应该尽可能相同</li><li id="f83d" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">他们应该运行足够长的时间，以建立一个很大的差距，这是更快的</li><li id="8a4f" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">每次运行应该产生相同的结果</li></ol><p id="72ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我想到了下面的脚本，它可以在NodeJS的当前LTS版本(v12.13.1)上运行。下面是GitHub的链接，你可以自己运行它:<a class="ae ll" href="https://github.com/CyberCyclone/js-string-benchmark/blob/master/index.js" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/cyber cyclone/js-string-benchmark/blob/master/index . js</a></p><p id="f968" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本质上，它由以下三个功能组成:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/402d6fbc5a74e6312e6b66648cd8ab9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0CMYUDsgAm_SCbksF_1xTg.png"/></div></div></figure><p id="9224" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个函数被传递一个24个字的字符串数组，每个测试都将它放在完全相同的位置。每一个函数在这一轮中都得到相同的单词表。</p><p id="a44e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的循环超过100万次，我已经运行了5次。结果如下:</p><figure class="kw kx ky kz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mb"><img src="../Images/ad378c489766f84497648913eeb1f069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VrDnXMyagCV2Qp4mcwOSXA.png"/></div></div></figure><p id="8909" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是从最快到最慢的结果:</p><ol class=""><li id="813e" class="lm ln iq ka b kb kc kf kg kj lo kn lp kr lq kv lr ls lt lu bi translated">单引号字符串长度:0.028秒</li><li id="b5c5" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">模板字符串:0.303秒</li><li id="1b98" class="lm ln iq ka b kb lv kf lw kj lx kn ly kr lz kv lr ls lt lu bi translated">字符串替换:7.35秒</li></ol><p id="346d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然我对<strong class="ka ir">并不感到意外。替换</strong>方法耗时最长，没想到<strong class="ka ir">串模板</strong>方法比<strong class="ka ir">串补</strong>方法慢了近10倍。</p><p id="e368" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给你。因此，虽然使用<strong class="ka ir">字符串模板</strong>方法有助于保持代码的整洁，但是如果你想尽可能地挤出所有的性能，你就要使用<strong class="ka ir">字符串构建</strong>方法。</p></div></div>    
</body>
</html>