<html>
<head>
<title>GraphQL vs REST API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL与REST API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphql-vs-rest-api-daddb5a5dee5?source=collection_archive---------18-----------------------#2022-12-14">https://levelup.gitconnected.com/graphql-vs-rest-api-daddb5a5dee5?source=collection_archive---------18-----------------------#2022-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="856a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">GraphQL与REST API的比较</h2></div><p id="3ba2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GraphQL和REST APIs都是通过web提供数据和功能访问的方式，它们有一些相似的特性。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/ec8e1ad8acabe872b55ac23bac7dc5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XFVYc56IzGvQPN8-.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">GraphQL徽标</figcaption></figure><p id="babc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，这两种方法之间存在一些关键的差异，这些差异会影响每种方法的优点和缺点。</p><p id="66f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章探讨了两个关键的区别，并试图概述GraphQL优于传统REST APIs的地方。</p><p id="caf7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">先来介绍两者。</p><h1 id="8478" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">REST API</h1><p id="b2e3" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">REST(表述性状态转移)是一种软件架构风格，它描述了两个系统可以用来交换信息的统一接口。</p><p id="9115" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对我们来说，有必要知道REST APIs有四个特点:</p><ul class=""><li id="5967" class="mr ms it kk b kl km ko kp kr mt kv mu kz mv ld mw mx my mz bi translated"><strong class="kk iu">统一接口</strong> —服务器以JSON等标准格式发送信息。然而，信息可以以不同的格式存储。</li><li id="964b" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><strong class="kk iu">无状态</strong> —客户端可以以任何顺序请求数据，每个请求都是相互独立的。</li><li id="dc53" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><strong class="kk iu">分层系统</strong> —允许客户端连接到客户端和服务器之间的授权中介，如其他服务器</li><li id="663c" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><strong class="kk iu">可缓存性</strong> —允许在客户端存储一些数据以提高性能</li></ul><h1 id="bcf5" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">GraphQL</h1><p id="f165" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">正如在<a class="ae nf" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank">文档</a>中所报道的，“GraphQL是一种用于API的查询语言，也是一种用现有数据完成这些查询的运行时。”</p><p id="f259" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以把它分解成GraphQL的双重性质:</p><ul class=""><li id="06a0" class="mr ms it kk b kl km ko kp kr mt kv mu kz mv ld mw mx my mz bi translated"><strong class="kk iu"> GraphQL是一种用于API的查询语言</strong> —它不像REST那样是一种软件架构风格。</li><li id="fea9" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated"><strong class="kk iu"> GraphQL是用于执行查询的运行时</strong>——作为服务器端应用程序的一部分实现的中介，它使用您的数据模式来理解传入查询的结构，并根据您的数据验证它们。</li></ul><p id="ba38" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GraphQL的其他一些特征包括:</p><ul class=""><li id="f58d" class="mr ms it kk b kl km ko kp kr mt kv mu kz mv ld mw mx my mz bi translated">通过一次呼叫请求特定数据</li><li id="6d14" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated">GraphQL使用类型来确保客户“只询问可能的情况，并提供清晰有用的错误。”</li></ul><h1 id="b805" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">主要差异</h1><p id="7c9f" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">虽然GraphQl和REST都提供了对数据的访问，但是它们访问数据的方式有很大的不同，尤其是在两个方面:</p><ol class=""><li id="9f52" class="mr ms it kk b kl km ko kp kr mt kv mu kz mv ld ng mx my mz bi translated"><strong class="kk iu">特异性</strong></li><li id="701a" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld ng mx my mz bi translated"><strong class="kk iu">类型的使用</strong></li></ol><p id="5ef1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些尺寸产生了一些相应的优点和缺点。</p><h1 id="ea86" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">1)特异性</h1><p id="e8b8" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">特异性是GraphQL和REST API的第一个关键区别。</p><p id="1768" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GraphQL允许客户机精确地指定它需要从服务器获得哪些数据。</p><p id="70bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这带来了几个好处:</p><ul class=""><li id="9967" class="mr ms it kk b kl km ko kp kr mt kv mu kz mv ld mw mx my mz bi translated">客户端可以在一次调用中访问它需要的特定数据，</li><li id="efcb" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated">它可以减少需要通过网络发送的数据量，从而减少带宽使用，</li><li id="fcf0" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld mw mx my mz bi translated">最终，它可以通过避免过度提取和提取不足来提高性能。例如，如果您对某个用户名感兴趣，您可以请求该值，并且只能请求该值，这样您就不会得到她的姓氏、年龄、地址和其他可能与数据库中的用户相关联的字段。</li></ul><p id="4e45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，REST APIs更加简单。</p><p id="3fe9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，REST APIs的简单性是以使用一组固定的端点为代价的，这些端点返回预定义的数据结构，这带来了过量提取和不足提取。</p><p id="dc3f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在某些情况下，REST APIs需要瀑布请求。</p><h2 id="fa9b" class="nh lv it bd lw ni nj dn ma nk nl dp me kr nm nn mg kv no np mi kz nq nr mk ns bi translated">REST示例</h2><p id="e70c" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">假设您想以编程方式检查我在Medium上的一篇文章。对于REST API(取决于它的结构)，您可能需要</p><ol class=""><li id="dd99" class="mr ms it kk b kl km ko kp kr mt kv mu kz mv ld ng mx my mz bi translated">执行一个HTTP请求来获取作者的数据，这可能会返回作者文章的id</li><li id="5be5" class="mr ms it kk b kl na ko nb kr nc kv nd kz ne ld ng mx my mz bi translated">执行第二个HTTP请求来获取特定的文章id</li></ol><p id="3187" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，您必须等待初始请求完成，以便了解可能用于获取文章的作者信息。</p><p id="6ba9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有在您收到第一个响应后，您才能使用此信息第二次请求检索作者的文章。</p><pre class="lf lg lh li gt nt nu nv bn nw nx bi"><span id="5caa" class="ny lv it nu b be nz oa l ob oc">// First call to users endpoint gets users data including articles id <br/>GET /users/123 <br/><br/>// Second call to articles endpoint gets the specific user's article<br/>GET /articles/xwz </span></pre><h2 id="0bca" class="nh lv it bd lw ni nj dn ma nk nl dp me kr nm nn mg kv no np mi kz nq nr mk ns bi translated">GraphQL示例</h2><p id="3bd3" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">在同一个例子中，<code class="fe od oe of nu b">query</code>关键字用于表示客户机正在向服务器请求数据。</p><p id="22dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe od oe of nu b">user</code>字段指定客户端想要访问哪个资源，而<code class="fe od oe of nu b">id</code>参数用于指定客户端想要检索的用户的ID。</p><p id="02df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe od oe of nu b">user</code>字段还包括一组子字段，指示客户端希望为用户接收的特定数据。在这种情况下，客户端请求用户的ID和文章。</p><pre class="lf lg lh li gt nt nu nv bn nw nx bi"><span id="f638" class="ny lv it nu b be nz oa l og oc">query {<br/>  user(id: "123") {<br/>    id<br/>    article {<br/>      id<br/>      title<br/>    }<br/>  }<br/>}</span></pre><p id="9c1d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些虚构的例子展示了GraphQL和REST APIs之间访问特定资源的语法是如何不同的。</p><p id="434c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在GraphQL中，客户端指定它想要接收的特定数据，而在REST中，服务器定义它返回的数据的结构。</p><h1 id="8f99" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">2)类型的使用</h1><p id="5dbb" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">GraphQL和REST API的第二个关键区别是类型的使用。</p><p id="3d6b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GraphQL是强类型的，这意味着GrapgQL运行时可以验证查询，以确保它们是格式良好的，并且它们请求的数据实际上是可用的。</p><p id="3c92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这有助于防止错误，并使使用API变得更容易。</p><h2 id="98cc" class="nh lv it bd lw ni nj dn ma nk nl dp me kr nm nn mg kv no np mi kz nq nr mk ns bi translated">GraphQL示例</h2><p id="a385" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">下面是一个典型的例子，其中<code class="fe od oe of nu b">UserType</code>类型定义了一个代表系统中用户的数据结构。</p><p id="fdee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe od oe of nu b">id</code>、<code class="fe od oe of nu b">name</code>、<code class="fe od oe of nu b">email</code>和<code class="fe od oe of nu b">age</code>字段都分别与特定类型<code class="fe od oe of nu b">ID</code>、<code class="fe od oe of nu b">String</code>、<code class="fe od oe of nu b">String</code>和<code class="fe od oe of nu b">Number</code>相关联。<code class="fe od oe of nu b">!</code>符号表示这些字段是必填的，不能为空。</p><pre class="lf lg lh li gt nt nu nv bn nw nx bi"><span id="c82e" class="ny lv it nu b be nz oa l og oc">type UserType {<br/>  id: ID!<br/>  name: String!<br/>  email: String!<br/>  age: Number!<br/>}<br/><br/>type Query {<br/>  user(id: ID!): UserType<br/>}</span></pre><h2 id="bcaa" class="nh lv it bd lw ni nj dn ma nk nl dp me kr nm nn mg kv no np mi kz nq nr mk ns bi translated">REST APIs和JSON模式</h2><p id="545e" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">相比之下，REST APIs通常更灵活，也更容易使用，因为它们不要求客户端确切地指定它需要哪些数据。</p><p id="6015" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以使REST API更容易上手，但是如果客户机请求不可用的数据或者服务器以客户机不期望的格式返回数据，也会导致问题。</p><p id="4387" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">REST APIs的一个很好的变通方法是JSON Schema。</p><p id="5161" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用JSON模式，REST API可以提供一种方法来指定服务器返回的数据的结构，这有助于确保数据以可预测和一致的格式返回。这可以提供强类型的一些好处，例如改进的数据验证和更容易与客户端应用程序集成。</p><p id="b66c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，JSON Schema不是REST的内置特性，也不是所有的REST APIs都会使用它。</p><h1 id="e167" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">总结GraphQL与REST API</h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oh"><img src="../Images/8b8a1b000207362ab65b58f58d7abe31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BOpqVuuc9dTZ7kvlXWIn9g.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">GraphQL和REST API之间主要差异的总结</figcaption></figure><h1 id="50f3" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">谁在使用GraphQL？</h1><p id="47d9" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">尽管脸书主要参与GraphQL定义和参考JavaScript实现，但其他知名公司也在使用它并为之做出贡献。GraphQL现在是一个开源项目。</p><p id="b62e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里是一些在他们的环境中使用GraphQL的公司。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oi"><img src="../Images/6e76dbac6236658656a21fe80cce9cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmIIIArNxNzVTJ_FEmcNsw.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">一些使用GraphQL的公司</figcaption></figure><p id="5e9b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然GraphQL生态系统正在成长，但采纳者和非采纳者之间并没有明显的界限。</p><p id="6079" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这似乎表明GraphQL可以在各行业表现得一样好。</p><h1 id="482b" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="6065" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">总的来说，GraphQL和REST APIs之间的选择取决于应用程序的特定需求和用例。</p><p id="27ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两种方法都有各自的优点和缺点，您的正确选择将取决于项目的需要。</p><p id="c1cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你有兴趣阅读更多内容，我建议你阅读罗宾·威鲁奇的<a class="ae nf" href="https://www.robinwieruch.de/why-graphql-advantages-disadvantages-alternatives/#a-growing-graphql-ecosystem" rel="noopener ugc nofollow" target="_blank"> Why GraphQL:优缺点</a>。尽管只有几年的历史，他的文章还是对这个话题进行了详细的概述。</p></div></div>    
</body>
</html>