<html>
<head>
<title>Create Infinite Preview Environments in AWS with Lambda@Edge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Lambda@Edge在AWS中创建无限预览环境</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/preview-environments-in-aws-with-cloudfront-and-lambda-edge-7acccb0b67d1?source=collection_archive---------4-----------------------#2020-06-27">https://levelup.gitconnected.com/preview-environments-in-aws-with-cloudfront-and-lambda-edge-7acccb0b67d1?source=collection_archive---------4-----------------------#2020-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="78ab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">针对托管在CloudFront/S3上的静态站点，在每个分支机构轻松部署一个环境</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/00a5e350e1a566c1f1d3a979f831ea99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Xapas3B_SHZvZUZJYKKXA.png"/></div></div></figure><p id="b72b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi ln translated"><span class="l lo lp lq bm lr ls lt lu lv di">大多数web开发团队的</span>目标是转移到<a class="ae lw" href="https://semaphoreci.com/community/tutorials/elements-of-a-continuous-deployment-workflow" rel="noopener ugc nofollow" target="_blank">持续部署</a>，有一件事可以带来巨大的不同，那就是每个特性分支都有自己的部署URL(例如my-feature.example.com)。</p><p id="5305" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">任何熟悉<a class="ae lw" href="https://vercel.com" rel="noopener ugc nofollow" target="_blank"> Vercel </a>的人都知道这些预览环境对开发团队有多有用。Vercel ，<a class="ae lw" href="https://aws.amazon.com/amplify/console/" rel="noopener ugc nofollow" target="_blank"> AWS Amplify Console </a>和其他，在大多数项目中都做得很好，但是，一旦你有了越来越多的需求，比如多个来源，不同的缓存行为等等，你可能需要自己管理一个CloudFront实例。</p><blockquote class="lx"><p id="884f" class="ly lz iq bd ma mb mc md me mf mg lm dk translated">对于拥有QA团队的大型项目，拥有一个“每个特性”的专用URL意味着你不会受到一些静态环境的限制，比如“测试”和“试运行”。您可以扩展您的开发团队，而不会影响您严格的QA需求。</p></blockquote><p id="2e4e" class="pw-post-body-paragraph kr ks iq kt b ku mh jr kw kx mi ju kz la mj lc ld le mk lg lh li ml lk ll lm ij bi translated">使用Terraform，我将向您展示，我认为这是一种使用AWS实现预览URL的好方法，无需额外的资源——无需构建新的CloudFront发行版，也无需为每个功能分支创建新的DNS记录。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mm"><img src="../Images/d71c82b3965c9cafade77770a57b3a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*z549YK-QggKj4fg0iiJ9QQ.gif"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">这就是我们将要建造的。使用AWS的简单预览环境。</figcaption></figure><p id="4f1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用以下资源。</p><ul class=""><li id="a7c8" class="mr ms iq kt b ku kv kx ky la mt le mu li mv lm mw mx my mz bi translated"><a class="ae lw" href="https://aws.amazon.com/cloudfront/" rel="noopener ugc nofollow" target="_blank">我们CDN的亚马逊CloudFront </a></li><li id="1110" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated"><a class="ae lw" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank">亚马逊S3 </a>为对象存储</li><li id="2160" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated"><a class="ae lw" href="https://aws.amazon.com/lambda/edge/" rel="noopener ugc nofollow" target="_blank"> Lambda@Edge </a>用于URL重写</li><li id="e64f" class="mr ms iq kt b ku na kx nb la nc le nd li ne lm mw mx my mz bi translated"><a class="ae lw" href="https://aws.amazon.com/route53/" rel="noopener ugc nofollow" target="_blank"> Route 53 </a>获取我们的DNS记录</li></ul><h1 id="43cf" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">方法</h1><p id="4b5b" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">我将使用通配符域。首先，我们将使用ACM创建SSL证书，然后将通配符域附加到CloudFront，并在Route 53中创建别名记录，最后添加Lambda@Edge函数将我们的动态子域重定向到S3上的正确路径。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/37a5f1b99a547ed222513f088a57607b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*hOcuKt1fY8xo2zCKijlcjA.jpeg"/></div></figure><p id="b042" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为简单起见，我们将对所有阶段和环境使用单一AWS帐户。</p><blockquote class="od oe of"><p id="536b" class="kr ks og kt b ku kv jr kw kx ky ju kz oh lb lc ld oi lf lg lh oj lj lk ll lm ij bi translated">这种设计的真正内容是在Lambda函数中，所以如果你熟悉CloudFront的设置，可以跳过这篇文章的前半部分。</p></blockquote><h1 id="16e1" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">通配符SSL证书</h1><p id="4cea" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">我将用terraform创建这个。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="4205" class="op ng iq ol b gy oq or l os ot"><strong class="ol ir">resource "aws_acm_certificate" "main" </strong>{<br/>  domain_name               = local.cdn_domain_name<br/>  subject_alternative_names = [local.wildcard_domain]<br/>  validation_method         = <strong class="ol ir">"DNS"<br/><br/>  lifecycle </strong>{<br/>    create_before_destroy = <strong class="ol ir">true<br/>  </strong>}<br/>}</span></pre><p id="6f01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这创建了证书，但是Amazon需要验证我们拥有这个域名，我们可以通过用Route 53添加DNS记录来自动完成。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="4360" class="op ng iq ol b gy oq or l os ot"><strong class="ol ir">resource "aws_route53_record" "validation" </strong>{<br/>  name    = aws_acm_certificate.main.domain_validation_options[0].resource_record_name<br/>  type    = aws_acm_certificate.main.domain_validation_options[0].resource_record_type<br/>  records = [aws_acm_certificate.main.domain_validation_options[0].resource_record_value]<br/><br/>  zone_id         = data.aws_route53_zone.external.zone_id<br/>  ttl             = 60<br/>  allow_overwrite = <strong class="ol ir">true<br/></strong>}</span></pre><p id="03f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后增加一个验证步骤。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="8309" class="op ng iq ol b gy oq or l os ot"><strong class="ol ir">resource "aws_acm_certificate_validation" "main" </strong>{<br/>  certificate_arn = aws_acm_certificate.main.arn<br/>  validation_record_fqdns = [<br/>    aws_route53_record.validation.fqdn<br/>  ]<br/><br/>  <strong class="ol ir">timeouts </strong>{<br/>    create = <strong class="ol ir">"10m"<br/>  </strong>}<br/>}</span></pre><h1 id="42a8" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">亚马逊S3</h1><p id="7ea5" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">亚马逊S3是存储HTML/CSS/JS等静态对象的绝佳场所。我们只需要一个基本的网站托管桶打开。你可以选择使用一个<a class="ae lw" href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html" rel="noopener ugc nofollow" target="_blank">源访问身份</a>来进一步保护你的文件，然而在大多数情况下，网站托管在S3是完全可以的。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="1134" class="op ng iq ol b gy oq or l os ot"><strong class="ol ir">resource "aws_s3_bucket" "bucket" </strong>{<br/>  bucket = local.bucket_name<br/>  acl    = <strong class="ol ir">"public-read"<br/>  </strong>policy = data.aws_iam_policy_document.bucket.json<br/><br/>  <strong class="ol ir">website </strong>{<br/>    index_document = <strong class="ol ir">"index.html"<br/>    </strong>error_document = <strong class="ol ir">"error.html"<br/>  </strong>}<br/>}<br/><strong class="ol ir">data "aws_iam_policy_document" "bucket" </strong>{<br/>  <strong class="ol ir">statement </strong>{<br/>    actions = [<strong class="ol ir">"s3:GetObject"</strong>]<br/>    resources = [<br/>      <strong class="ol ir">"arn:aws:s3:::${local.bucket_name}"</strong>,<br/>      <strong class="ol ir">"arn:aws:s3:::${local.bucket_name}/*"<br/>    </strong>]<br/>    <strong class="ol ir">principals </strong>{<br/>      identifiers = [<strong class="ol ir">"*"</strong>]<br/>      type        = <strong class="ol ir">"*"<br/>    </strong>}<br/>  }<br/>}</span></pre><h1 id="210b" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">部署管道</h1><p id="abff" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">这里没有提到的是CI渠道。您的构建过程应该正常运行，但是您的部署应该使用git branch slug作为bucket中的关键字前缀。</p><p id="d72f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GitLab的部署作业示例如下。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="f66d" class="op ng iq ol b gy oq or l os ot"><strong class="ol ir">deploy:<br/>  stage</strong>: deploy<br/>  <strong class="ol ir">script</strong>:<br/>    - S3="s3://example-bucket/$CI_COMMIT_REF_SLUG"<br/>    - aws s3 rm $S3 --recursive<br/>    - aws s3 cp $S3 --recursive<br/>  <strong class="ol ir">environment</strong>:<br/>    <strong class="ol ir">name</strong>: $CI_COMMIT_REF_SLUG<br/>    <strong class="ol ir">url</strong>: <a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/$CI_COMMIT_REF_SLUG.example.com">https://$CI_COMMIT_REF_SLUG.example.com</a></span></pre><p id="f02c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意我们是如何动态设置环境url的<a class="ae lw" href="https://docs.gitlab.com/ee/ci/environments/" rel="noopener ugc nofollow" target="_blank">，这对于拉请求来说是一个很好的特性，因为您可以看到部署历史，并且包含了一个方便的链接。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/c44b1a4022a115138b807514b89865bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oN8jsdcFeodW2XWYFoimvA.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">在本例中，我将环境设置为PR号</figcaption></figure><h1 id="172c" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">λ@边缘</h1><p id="6a59" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">这是关键部分，如果你不熟悉Lambda@Edge，它实际上是一个Lambda函数，可以自动全局复制。然后，您可以将它附加到CloudFront上的4个不同事件中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/c914e1378f61e393b50606060ee2a9cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiL0wRVVooYsi2wQYk_mfQ.jpeg"/></div></div></figure><p id="72ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了将请求定向到正确的特性，我们需要检查请求，以确定将请求定向到的S3文件夹。</p><p id="f28d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们希望所有的特征环境都以<em class="og"> preview为前缀。S </em> o对于我们的<em class="og">开发</em>目录，这可能是<code class="fe ow ox oy ol b">preview-develop.example.com</code> <strong class="kt ir">，</strong>但是对于所有不以<em class="og">预览</em>(例如<code class="fe ow ox oy ol b">www.example.com</code>)开始的子域，我们应该将它们指向主目录。</p><p id="b507" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们需要创建一个Lambda并将其附加到CloudFront的Origin请求事件。我选择这样做的方法是，通过用分支名称作为前缀来覆盖原始路径。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="b63d" class="op ng iq ol b gy oq or l os ot">exports.handler = (event, context, callback) =&gt; {<br/>  <strong class="ol ir">const </strong>{ request } = event.Records[0].cf;<br/><br/>  <strong class="ol ir">try </strong>{<br/>    <strong class="ol ir">const </strong>host = request.headers[<strong class="ol ir">'x-forwarded-host'</strong>][0].value;<br/>    <strong class="ol ir">const </strong>branch = host.match(/^preview-([^\.]+)/)[1];<br/>    request.origin.<em class="og">custom</em>.path = <strong class="ol ir">`/</strong>${branch}<strong class="ol ir">`</strong>;<br/>  } <strong class="ol ir">catch </strong>(e) {<br/>    request.origin.<em class="og">custom</em>.path = <strong class="ol ir">`/master`</strong>;<br/>  }<br/><br/>  <strong class="ol ir">return </strong>callback(<strong class="ol ir">null</strong>, request);<br/>};</span></pre><p id="01e5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这还不行，因为请求对象需要一个名为<code class="fe ow ox oy ol b">x-forwarded-host</code>的头，默认情况下，这个头在原始请求中不可用，但是可以在查看器请求事件lambda中写入这个头。所以我们需要为这个阶段创建一个lambda。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="1a37" class="op ng iq ol b gy oq or l os ot">exports.handler = (event, context, callback) =&gt; {<br/>  <strong class="ol ir">const </strong>{ request } = event.Records[0].cf;<br/><br/>  request.headers[<strong class="ol ir">'x-forwarded-host'</strong>] = [<br/>    {<br/>      key: <strong class="ol ir">'X-Forwarded-Host'</strong>,<br/>      value: request.headers.host[0].value<br/>    }<br/>  ];<br/><br/>  <strong class="ol ir">return </strong>callback(<strong class="ol ir">null</strong>, request);<br/>};</span></pre><p id="df99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了简洁起见，我在这里没有包括Terraform代码，但是我创建了一个简单的git repo，您可以自己挖掘并运行它。检查一下我的lambda模块，看看它需要哪些权限才能让CloudFront运行lambdas。</p><div class="oz pa gp gr pb pc"><a href="https://github.com/eknowles/aws-cloudfront-preview-domains" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">eknowles/AWS-cloudfront-预览-域</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">此报告包含Terraform代码，用于构建具有特征分支子域的CDN。我已经将HCL代码设置为…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">github.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq kp pc"/></div></div></a></div><h1 id="d4e6" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">亚马逊云锋</h1><p id="d58f" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">亚马逊CloudFront是一个快速内容交付网络(CDN)，它非常适合将web应用缓存到边缘位置。在我们的例子中，我们将创建一个CloudFront发行版，它只有一个S3源。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="081f" class="op ng iq ol b gy oq or l os ot"><strong class="ol ir">resource "aws_cloudfront_distribution" "cdn" </strong>{<br/>  enabled             = <strong class="ol ir">true<br/>  </strong>default_root_object = <strong class="ol ir">"index.html"<br/>  </strong>price_class         = <strong class="ol ir">"PriceClass_100"<br/>  </strong>aliases             = [local.cdn_domain_name, local.wildcard_domain]<br/><br/>  <strong class="ol ir">viewer_certificate </strong>{<br/>    acm_certificate_arn      = aws_acm_certificate.main.arn<br/>    ssl_support_method       = <strong class="ol ir">"sni-only"<br/>    </strong>minimum_protocol_version = <strong class="ol ir">"TLSv1.1_2016"<br/>  </strong>}<br/><br/>  <strong class="ol ir">origin </strong>{<br/>    domain_name = aws_s3_bucket.bucket.website_endpoint<br/>    origin_id   = <strong class="ol ir">"app"<br/><br/>    custom_origin_config </strong>{<br/>      http_port              = 80<br/>      https_port             = 443<br/>      origin_protocol_policy = <strong class="ol ir">"http-only"<br/>      </strong>origin_ssl_protocols   = [<strong class="ol ir">"TLSv1"</strong>, <strong class="ol ir">"TLSv1.1"</strong>, <strong class="ol ir">"TLSv1.2"</strong>]<br/>    }<br/>  }<br/><br/>  <strong class="ol ir">default_cache_behavior </strong>{<br/>    target_origin_id       = <strong class="ol ir">"app"<br/>    </strong>allowed_methods        = [<strong class="ol ir">"DELETE"</strong>, <strong class="ol ir">"GET"</strong>, <strong class="ol ir">"HEAD"</strong>, <strong class="ol ir">"OPTIONS"</strong>, <strong class="ol ir">"PATCH"</strong>, <strong class="ol ir">"POST"</strong>, <strong class="ol ir">"PUT"</strong>]<br/>    cached_methods         = [<strong class="ol ir">"GET"</strong>, <strong class="ol ir">"HEAD"</strong>]<br/>    min_ttl                = 0<br/>    default_ttl            = 0 # 3600<br/>    max_ttl                = 0 # 86400<br/>    viewer_protocol_policy = <strong class="ol ir">"redirect-to-https"<br/><br/>    lambda_function_association </strong>{<br/>      event_type   = <strong class="ol ir">"origin-request"<br/>      </strong>lambda_arn   = module.origin_request_lambda.qualified_arn<br/>      include_body = <strong class="ol ir">false<br/>    </strong>}<br/><br/>    <strong class="ol ir">lambda_function_association </strong>{<br/>      event_type   = <strong class="ol ir">"viewer-request"<br/>      </strong>lambda_arn   = module.viewer_request_lambda.qualified_arn<br/>      include_body = <strong class="ol ir">false<br/>    </strong>}<br/><br/>    <strong class="ol ir">forwarded_values </strong>{<br/>      query_string = <strong class="ol ir">false<br/>      </strong>headers      = [<strong class="ol ir">"x-forwarded-host"</strong>]<br/><br/>      <strong class="ol ir">cookies </strong>{<br/>        forward = <strong class="ol ir">"none"<br/>      </strong>}<br/>    }<br/>  }<br/><br/>  <strong class="ol ir">restrictions </strong>{<br/>    <strong class="ol ir">geo_restriction </strong>{<br/>      restriction_type = <strong class="ol ir">"none"<br/>    </strong>}<br/>  }<br/>}</span></pre><p id="7e20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有很多东西需要理解，CloudFront是一个很大的资源，可能需要10分钟来更新，我只包括了需要的东西。根据您的应用，您可以根据自己的喜好设置CDN，为不同的路由设置不同的缓存行为，但是请注意<code class="fe ow ox oy ol b">forwarded_values</code> <strong class="kt ir"> </strong>部分，务必将<code class="fe ow ox oy ol b">x-forwarded-host</code> <strong class="kt ir"> </strong>报头列入白名单，以便请求lambda可以看到这些值。</p><p id="e1d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于别名，我已经包括了裸域名<code class="fe ow ox oy ol b">example.com</code>和通配符域名<code class="fe ow ox oy ol b">*.example.com</code>，这很重要，所以你的CDN将解析这些请求。</p><p id="3d8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我已经假设你在一个非生产AWS帐户中运行这个，所以我已经将TTL设置为<code class="fe ow ox oy ol b">0</code></p><h1 id="934d" class="nf ng iq bd nh ni nj nk nl nm nn no np jw nq jx nr jz ns ka nt kc nu kd nv nw bi translated">使用Route53添加DNS记录</h1><p id="3935" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">最后，要将这一切联系在一起，你需要确保用户可以路由到你的CDN。在这里，我们简单地添加两个A记录，它们是您的CloudFront发行版的别名，一个用于通配符，一个用于裸域。</p><pre class="kg kh ki kj gt ok ol om on aw oo bi"><span id="96ef" class="op ng iq ol b gy oq or l os ot"><strong class="ol ir">resource "aws_route53_record" "wildcard_cdn" </strong>{<br/>  zone_id = data.aws_route53_zone.external.zone_id<br/>  name    = local.wildcard_domain<br/>  type    = <strong class="ol ir">"A"<br/><br/>  alias </strong>{<br/>    name                   = aws_cloudfront_distribution.cdn.domain_name<br/>    zone_id                = aws_cloudfront_distribution.cdn.hosted_zone_id<br/>    evaluate_target_health = <strong class="ol ir">false<br/>  </strong>}<br/>}<br/><strong class="ol ir">resource "aws_route53_record" "naked_cdn" </strong>{<br/>  zone_id = data.aws_route53_zone.external.zone_id<br/>  name    = local.cdn_domain_name<br/>  type    = <strong class="ol ir">"A"<br/><br/>  alias </strong>{<br/>    name                   = aws_cloudfront_distribution.cdn.domain_name<br/>    zone_id                = aws_cloudfront_distribution.cdn.hosted_zone_id<br/>    evaluate_target_health = <strong class="ol ir">false<br/>  </strong>}<br/>}</span></pre></div><div class="ab cl pr ps hu pt" role="separator"><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw"/></div><div class="ij ik il im in"><h1 id="c69c" class="nf ng iq bd nh ni py nk nl nm pz no np jw qa jx nr jz qb ka nt kc qc kd nv nw bi translated">包扎</h1><p id="cd25" class="pw-post-body-paragraph kr ks iq kt b ku nx jr kw kx ny ju kz la nz lc ld le oa lg lh li ob lk ll lm ij bi translated">所以我们有它！现在，您应该对如何使用通配符域为您的web应用程序创建无限预览环境有了很好的理解。下一步是什么？通过对照白名单检查请求IP，您可以使用查看器请求lambda来保护您的预览环境。在AWS博客上了解更多关于Lambda@Edge的信息。</p><div class="oz pa gp gr pb pc"><a href="https://aws.amazon.com/blogs/networking-and-content-delivery/category/networking-content-delivery/lambdaedge/" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">Lambda@Edge |网络和内容交付</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">游戏技术基础设施和自动化物联网机器学习管理工具媒体消息传递和定位…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">aws.amazon.com</p></div></div><div class="pl l"><div class="qd l pn po pp pl pq kp pc"/></div></div></a></div><p id="29a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望你已经发现这是有用的。有许多方法可以安排您的非生产环境，这只是其中一种，如果您有任何问题、顾虑或改进，请留下评论或在Twitter上关注我。<a class="ae lw" href="https://twitter.com/nedknowles" rel="noopener ugc nofollow" target="_blank"> @NedKnowles </a>。</p><p id="7344" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所有的terraform源代码和测试数据都可以在GitHub上找到。</p><div class="oz pa gp gr pb pc"><a href="https://github.com/eknowles/aws-cloudfront-preview-domains" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">eknowles/AWS-cloudfront-预览-域</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">此报告包含Terraform代码，用于构建具有特征分支子域的CDN。我已经将HCL代码设置为…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">github.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq kp pc"/></div></div></a></div></div></div>    
</body>
</html>