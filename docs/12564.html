<html>
<head>
<title>K-Means Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">k均值聚类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/k-means-clustering-c7a78b0fd1d3?source=collection_archive---------26-----------------------#2022-06-19">https://levelup.gitconnected.com/k-means-clustering-c7a78b0fd1d3?source=collection_archive---------26-----------------------#2022-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/5d272da8314215c5d2168756c688e79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QB12Npgp2LZELZjt3EUpyw.jpeg"/></div></figure><p id="acc5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">今天，我们将快速浏览一个二维数据集的K-Means聚类示例。如果你想跟进，下面是ipynb的链接。</p><div class="ks kt gp gr ku kv"><a href="https://colab.research.google.com/drive/1fM2SLTfZpr7NoHO2cCINsMK-wCqjQe-r" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">k表示聚类</h2><div class="lc l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">colab.research.google.com</p></div></div><div class="ld l"><div class="le l lf lg lh ld li js kv"/></div></div></a></div><p id="2000" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在前两个单元格中，我们导入所需的库，然后使用不同的范围创建一组随机点。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi lj"><img src="../Images/2a6c7bb902e14bc96e71e9f8c3f16495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fto32u5XKsUtMBaIM38v_w.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">我们图表的输出</figcaption></figure><p id="b383" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们将创建我们的彩色地图，我们将有6种颜色，1个用于我们的5个集群，1个用于开始的黑色。然后我们为每5种颜色随机分配1个点作为开始，这些是开始的k个质心。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi lw"><img src="../Images/61210d6ae067922d177d034f3f406e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mBP5hepenpRs2H3WFc6tg.png"/></div></div></figure><p id="2de3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们将编写一个简单的函数来计算两点之间的笛卡尔距离(我们将使用它来决定哪些点属于哪个簇。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/ce8410a15460a5214fb846fde1eb8e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*DxA4-4yzmBirESvKeUwsoA.png"/></div></figure><p id="4360" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们已经设置好了一切，我们可以开始聚类算法了</p><h1 id="859c" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">算法</h1><h2 id="03e9" class="mw lz iq bd ma mx my dn me mz na dp mi kf nb nc mm kj nd ne mq kn nf ng mu nh bi translated">1.对于数据集中的每个点</h2><ul class=""><li id="ce13" class="ni nj iq jw b jx nk kb nl kf nm kj nn kn no kr np nq nr ns bi translated">计算到k个质心的距离</li><li id="6fa4" class="ni nj iq jw b jx nt kb nu kf nv kj nw kn nx kr np nq nr ns bi translated">将该点指定给最近的质心</li></ul><h2 id="e804" class="mw lz iq bd ma mx my dn me mz na dp mi kf nb nc mm kj nd ne mq kn nf ng mu nh bi translated"><strong class="ak"> 2。对于每个点k组</strong></h2><ul class=""><li id="ea0f" class="ni nj iq jw b jx nk kb nl kf nm kj nn kn no kr np nq nr ns bi translated">获取第k组中各点的x和y平均值</li><li id="26ae" class="ni nj iq jw b jx nt kb nu kf nv kj nw kn nx kr np nq nr ns bi translated">将第k个组的质心更新为该平均值</li></ul><p id="f797" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在K-Means的一个生产用例中，我们将重复运行这个算法，直到我们到达一个阈值以下的点，这些点的组在一次迭代中被改变。对于我们的玩具例子，我们可以只运行细胞几次。下面是运行该单元几次的输出。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ny"><img src="../Images/81738a5cd8d2a316e470d9ad4bd8ac82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhZI7zZdC-O869JL1OK5mA.png"/></div></div></figure><p id="da78" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在不同维度空间的许多不同媒介中使用这种技术。例如，我们可以对3D空间中的点进行分组，以获得照片中的3种平均颜色，我们可以采用任意n维向量来获得任何空间中的组。我们还可以修改difference函数，根据其他度量对事物进行分组(比如字符串diff表示字符相似性，对具有相似字符的单词进行分组)。</p><p id="94e1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，如果我们更新距离函数，将y的差值提高到4的幂而不是2(这将为y点相距较远的点提供更大的距离值)，我们将得到以下结果。</p><figure class="lk ll lm ln gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nz"><img src="../Images/3547786756de5326ce91c12ad695b937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xeKPsMRY5rWEvZJp3w9xJA.png"/></div></div></figure><p id="abbb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们可以看到我们的聚类喜欢将y个点组合在一起。</p></div></div>    
</body>
</html>