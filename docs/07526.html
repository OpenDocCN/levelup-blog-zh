<html>
<head>
<title>Objective-C basics for Swift developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">目标Swift开发人员的基础知识</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/objective-c-basics-for-swift-developers-65a006b40234?source=collection_archive---------40-----------------------#2021-02-22">https://levelup.gitconnected.com/objective-c-basics-for-swift-developers-65a006b40234?source=collection_archive---------40-----------------------#2021-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eeb9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Swift开发人员快速参考和备忘单学习目标-C</h2></div><p id="edcb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Swift是一种功能强大的编程语言，在2014年WWDC上发布，作为Objective-C的替代品。但由于许多现有的应用程序都是用Objective-C编写的，所以了解或至少对Objective-C有基本的了解可能会很有用。</p><p id="9109" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章为想学习或查找Objective-C细节的Swift开发人员提供了一个关于Objective-C的快速参考。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/bf9e6522b288fe9d1bd575ff793b6e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aUs6FNB7Hs9E8l_n.jpg"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">老朋友Obji和Swifty</figcaption></figure><h1 id="84ea" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">变量</h1><p id="e163" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">雨燕</p><p id="af5d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于定义变量，Swift为常量提供了let关键字，为变量提供了var关键字。Swift提供了类型推断和可选的数据类型。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="74a1" class="mx lv it mt b gy my mz l na nb"><em class="mr">let</em> name = "Swifty" // declaring and assigning a constant</span><span id="b490" class="mx lv it mt b gy nc mz l na nb"><em class="mr">var</em> age: Int? // declaring an optional Int variable</span><span id="afdf" class="mx lv it mt b gy nc mz l na nb">age = 7 // reassigning the variable</span><span id="3f7d" class="mx lv it mt b gy nc mz l na nb">age = nil // nullifying the variable</span><span id="31d0" class="mx lv it mt b gy nc mz l na nb"><em class="mr">var</em> year = 2014 // the compiler automatically infers the `Int` type</span><span id="b1ab" class="mx lv it mt b gy nc mz l na nb"><em class="mr">let</em> fruits = ["apple", "orange"] // desclaring and assigning an array of strings</span></pre><p id="c2b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mr">目标-C </em></p><p id="e506" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Objective-C不支持类型推断，我们总是需要显式地指定变量的类型。有像int，float，char等基本类型。以及诸如NSString、NSNumber等对象类型。</p><p id="c8ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Objective-C没有显式的可选类型，所有对象类型都可以无效。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="9687" class="mx lv it mt b gy my mz l na nb">NSString const *name = @"Obji"; // declaring and assigning a constant</span><span id="c13f" class="mx lv it mt b gy nc mz l na nb">NSNumber *age; // declaring a variable</span><span id="5214" class="mx lv it mt b gy nc mz l na nb">age = 7; // reassigning the variable</span><span id="74da" class="mx lv it mt b gy nc mz l na nb">age = nil; // nullifying the variable</span><span id="463d" class="mx lv it mt b gy nc mz l na nb">NSArray&lt;NSString*&gt; *fruits = @[@"apple", @"orange"]; // desclaring and assigning an array of strings</span></pre><p id="e4a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Objective-C中的语法一开始可能会令人困惑。让我们来分解一下:</p><ul class=""><li id="f50e" class="nd ne it kk b kl km ko kp kr nf kv ng kz nh ld ni nj nk nl bi translated">Objective-C中的每个NSString都有一个@前缀。</li><li id="726e" class="nd ne it kk b kl nm ko nn kr no kv np kz nq ld ni nj nk nl bi translated">用星号*表示我们正在创建一个指向对象的指针。就像在Swift中声明一个引用类型变量一样。</li><li id="b61c" class="nd ne it kk b kl nm ko nn kr no kv np kz nq ld ni nj nk nl bi translated">在创建数组时，Objective-C提供了一个简短的语法，在[]前面带有前导@符号。</li></ul><h1 id="1659" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">性能</h1><p id="b94b" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">在这两种语言中，声明属性与声明变量的方式基本相同。不同之处在于，我们将它们声明为类型的一部分，并可以对它们应用附加属性，例如用于访问控制或内存管理。</p><p id="96b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mr">雨燕</em></p><p id="78b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Swift中，我们可以声明类、结构或枚举的存储属性。默认情况下，Swift属性很强，具有内部访问级别。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="9441" class="mx lv it mt b gy my mz l na nb"><em class="mr">private</em> <em class="mr">let</em> firstName: String // declaring a private constant property</span><span id="573f" class="mx lv it mt b gy nc mz l na nb"><em class="mr">private</em>(<em class="mr">set</em>) <em class="mr">var</em> lastName: String // declaring a read-only property</span><span id="31f6" class="mx lv it mt b gy nc mz l na nb"><em class="mr">var</em> age: Int // declaring an internal property</span><span id="6e43" class="mx lv it mt b gy nc mz l na nb"><em class="mr">weak</em> <em class="mr">public</em> <em class="mr">var</em> parent: Parent? // declaring a weak public property</span></pre><p id="d1a7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mr">物镜-C </em></p><p id="3dc3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Objective-C中，属性仅用作类的一部分。它们以@property关键字开头，后面是用于内存管理和访问控制的逗号分隔的属性。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="cbc8" class="mx lv it mt b gy my mz l na nb">@property NSString *firstName; // declaring a strong property</span><span id="378b" class="mx lv it mt b gy nc mz l na nb">@property (readonly) NSString *lastName; // declaring a read-only property</span><span id="06b2" class="mx lv it mt b gy nc mz l na nb">@property (<em class="mr">weak</em>) Parent *parent; // declaring a read-only property</span></pre><p id="38fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Objective-C属性的可见性不是通过属性实现的，而是通过我们在类声明中放置它们的位置实现的。我们会在课程部分讨论这个问题。</p><h1 id="7a7f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">方法</h1><p id="76c8" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated"><em class="mr">雨燕</em></p><p id="13e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Swift中，我们可以在类、结构和枚举上定义方法。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="dea0" class="mx lv it mt b gy my mz l na nb">// method declaration with no return type and no parameters</span><span id="1896" class="mx lv it mt b gy nc mz l na nb"><em class="mr">func</em> emptyCard()<br/></span><span id="1cd8" class="mx lv it mt b gy nc mz l na nb">// method declaration with two parameters and a return value</span><span id="c954" class="mx lv it mt b gy nc mz l na nb"><em class="mr">func</em> search(_ searchQuery: String, category: String) -&gt; [Tea]<br/></span><span id="0729" class="mx lv it mt b gy nc mz l na nb">// default parameters</span><span id="de88" class="mx lv it mt b gy nc mz l na nb"><em class="mr">func</em> walk(withSpeed speed: Int = 20)<br/></span><span id="668c" class="mx lv it mt b gy nc mz l na nb">// method implementation</span><span id="7922" class="mx lv it mt b gy nc mz l na nb"><em class="mr">func</em> search(_ searchQuery: String, category: String) -&gt; [Tea] {</span><span id="7288" class="mx lv it mt b gy nc mz l na nb"><em class="mr">   return</em> []</span><span id="6322" class="mx lv it mt b gy nc mz l na nb">}<br/></span><span id="5e04" class="mx lv it mt b gy nc mz l na nb">// calling a method</span><span id="1ea1" class="mx lv it mt b gy nc mz l na nb"><em class="mr">let</em> results = teaShop.search("camomile", category: "herbs")</span></pre><p id="228a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mr">物镜-C </em></p><p id="e8a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Objective-C中，类是唯一可以定义方法的类型。不支持默认参数。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="c81b" class="mx lv it mt b gy my mz l na nb">// method declaration with no return type and no parameters</span><span id="610f" class="mx lv it mt b gy nc mz l na nb">// `void` represents the absence of a type.</span><span id="377b" class="mx lv it mt b gy nc mz l na nb">- (void)emptyCard;<br/></span><span id="fc02" class="mx lv it mt b gy nc mz l na nb">// method declaration with two parameters and a return value</span><span id="67e3" class="mx lv it mt b gy nc mz l na nb">- (NSArray&lt;Tea *&gt; *)search:(NSString *)searchQuery category:(NSString *)category;<br/></span><span id="2be5" class="mx lv it mt b gy nc mz l na nb">// implementation of a method with two parameters and a return value</span><span id="c589" class="mx lv it mt b gy nc mz l na nb">- (NSArray&lt;Tea *&gt; *)search:(NSString *)searchQuery category:(NSString *)category {</span><span id="c627" class="mx lv it mt b gy nc mz l na nb"><em class="mr">  return</em> [];</span><span id="606f" class="mx lv it mt b gy nc mz l na nb">}<br/></span><span id="4c11" class="mx lv it mt b gy nc mz l na nb">// calling a method</span><span id="8f97" class="mx lv it mt b gy nc mz l na nb">NSArray&lt;NSString *&gt; *results = [teaShop search:@"camomile" category:@"herbs"];</span></pre><h1 id="106e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">类和结构</h1><p id="6fc0" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated"><em class="mr"> Swift </em></p><p id="9259" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Swift中，我们区分作为引用类型的类和作为值类型的结构。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="7e3f" class="mx lv it mt b gy my mz l na nb"><em class="mr">import</em> Foundation</span><span id="5c60" class="mx lv it mt b gy nc mz l na nb"><em class="mr">class</em> TeaShop {</span><span id="fa68" class="mx lv it mt b gy nc mz l na nb">// define public &amp; private properties &amp; methods</span><span id="57eb" class="mx lv it mt b gy nc mz l na nb">}</span><span id="9d98" class="mx lv it mt b gy nc mz l na nb"><em class="mr">struct</em> Tea {</span><span id="d39c" class="mx lv it mt b gy nc mz l na nb">// define public &amp; private properties &amp; methods</span><span id="7eba" class="mx lv it mt b gy nc mz l na nb">}</span><span id="d1bf" class="mx lv it mt b gy nc mz l na nb">// using a class</span><span id="758e" class="mx lv it mt b gy nc mz l na nb"><em class="mr">let</em> shop = TeaShop()</span><span id="488d" class="mx lv it mt b gy nc mz l na nb">// using a struct</span><span id="cb90" class="mx lv it mt b gy nc mz l na nb"><em class="mr">let</em> tea = Tea()</span></pre><p id="84d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mr">目标-C </em></p><p id="ea03" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Objective-C中，我们需要两个单独的文件来定义一个类——类标题为。h文件和类实现。m文件。所有类都是从基类NSObject派生的，它提供了内存分配和初始化的基本方法。</p><p id="493e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TeaShop.h</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="97b9" class="mx lv it mt b gy my mz l na nb">@<em class="mr">import</em> Foundation;</span><span id="79d7" class="mx lv it mt b gy nc mz l na nb">@interface TeaShop : NSObject</span><span id="65da" class="mx lv it mt b gy nc mz l na nb">// public properties &amp; method definitions</span><span id="f9e8" class="mx lv it mt b gy nc mz l na nb">@end</span></pre><p id="fbf7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TeaShop.m</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="795f" class="mx lv it mt b gy my mz l na nb">#<em class="mr">import</em> "TeaShop.h"</span><span id="bfdb" class="mx lv it mt b gy nc mz l na nb">@interface TeaShop ()</span><span id="9ecd" class="mx lv it mt b gy nc mz l na nb">// private properties &amp; method definitions</span><span id="40e9" class="mx lv it mt b gy nc mz l na nb">@end</span><span id="e9e3" class="mx lv it mt b gy nc mz l na nb">@implementation TeaShop {</span><span id="d01d" class="mx lv it mt b gy nc mz l na nb">// private instance variables</span><span id="be16" class="mx lv it mt b gy nc mz l na nb">}</span><span id="5d30" class="mx lv it mt b gy nc mz l na nb">// methods implementation</span><span id="2ed7" class="mx lv it mt b gy nc mz l na nb">@end</span></pre><p id="738e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Objective-C中创建新对象是一个两步过程。首先，我们为对象分配内存，然后初始化它。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="252b" class="mx lv it mt b gy my mz l na nb">TeaShop *shop = [[TeaShop alloc] <em class="mr">init</em>];</span><span id="5eca" class="mx lv it mt b gy nc mz l na nb">// or the shorter version, that will call `alloc` and `init` for us</span><span id="e5ae" class="mx lv it mt b gy nc mz l na nb">TeaShop *shop = [[TeaShop <em class="mr">new</em>];</span></pre><p id="0ea7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结构也受支持，但只是作为一个可以在Objective-C中使用的C构造，因为Objective-C是C的超集。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="92f1" class="mx lv it mt b gy my mz l na nb">// Declaration of a struct</span><span id="a6d1" class="mx lv it mt b gy nc mz l na nb"><em class="mr">struct</em> Position {</span><span id="b748" class="mx lv it mt b gy nc mz l na nb">  int x;</span><span id="65e7" class="mx lv it mt b gy nc mz l na nb">  int y;</span><span id="1a4d" class="mx lv it mt b gy nc mz l na nb">};</span><span id="5298" class="mx lv it mt b gy nc mz l na nb">// Usage of a struct</span><span id="f970" class="mx lv it mt b gy nc mz l na nb"><em class="mr">struct</em> Position position;</span><span id="2462" class="mx lv it mt b gy nc mz l na nb">position.x = 5;</span><span id="e8cd" class="mx lv it mt b gy nc mz l na nb">position.y = 10;</span></pre><h1 id="77f7" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">枚举</h1><p id="4617" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">雨燕</p><p id="5095" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像结构一样，Swift枚举也是一级类型，它提供了很多灵活性，比如关联类型、计算属性、自定义初始值设定项等等。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="448b" class="mx lv it mt b gy my mz l na nb"><em class="mr">enum</em> TeeCategory {</span><span id="70e6" class="mx lv it mt b gy nc mz l na nb"><em class="mr">  case</em> herbal</span><span id="b9c7" class="mx lv it mt b gy nc mz l na nb"><em class="mr">  case</em> green</span><span id="9909" class="mx lv it mt b gy nc mz l na nb"><em class="mr">  case</em> fruits</span><span id="741b" class="mx lv it mt b gy nc mz l na nb">}</span><span id="1bfd" class="mx lv it mt b gy nc mz l na nb"><em class="mr">let</em> category = TeeCategory.green</span></pre><p id="c494" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mr">目标-C </em></p><p id="2623" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与结构类似，Objective-C只有C枚举可用。这些比Swift枚举灵活得多。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="8879" class="mx lv it mt b gy my mz l na nb">typedef NS_ENUM(NSInteger, TeeCategory) {</span><span id="5171" class="mx lv it mt b gy nc mz l na nb">  TeeCategoryHerbal,</span><span id="72f2" class="mx lv it mt b gy nc mz l na nb">  TeeCategoryGreen,</span><span id="64f1" class="mx lv it mt b gy nc mz l na nb">  TeeCategoryFruits</span><span id="6248" class="mx lv it mt b gy nc mz l na nb">} TeeCategory;</span><span id="de19" class="mx lv it mt b gy nc mz l na nb">TeeCategory category = TeeCategoryFruits;</span></pre><h1 id="d1cb" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">扩展ˌ扩张</h1><p id="9da4" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated"><em class="mr">雨燕</em></p><p id="d073" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Swift中，我们可以通过使用扩展为现有的类、结构、枚举或协议添加新功能。</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="ecd9" class="mx lv it mt b gy my mz l na nb"><em class="mr">extension</em> String {</span><span id="5162" class="mx lv it mt b gy nc mz l na nb"><em class="mr">   var</em> asURL: URL? {</span><span id="6fd3" class="mx lv it mt b gy nc mz l na nb">      URL(string: <em class="mr">self</em>)</span><span id="7191" class="mx lv it mt b gy nc mz l na nb">   }</span><span id="2b56" class="mx lv it mt b gy nc mz l na nb">}</span></pre><p id="fe8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mr">物镜-C </em></p><p id="5da4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Objective-C中，我们可以使用类别为现有的类添加新的功能。像类一样，类别由两个文件组成，一个头文件和一个实现文件。</p><p id="2afc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NSString+URL.h</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="3902" class="mx lv it mt b gy my mz l na nb">@interface NSString (URL)</span><span id="388a" class="mx lv it mt b gy nc mz l na nb">-(NSURL*)toURL;</span><span id="50d9" class="mx lv it mt b gy nc mz l na nb">@end</span></pre><p id="7cba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NSString+URL.m</p><pre class="lf lg lh li gt ms mt mu mv aw mw bi"><span id="4017" class="mx lv it mt b gy my mz l na nb">#<em class="mr">import</em> "NSString+URL.h"</span><span id="8c0c" class="mx lv it mt b gy nc mz l na nb">@implementation NSString (URL)</span><span id="a90d" class="mx lv it mt b gy nc mz l na nb">-(NSURL*)toURL {</span><span id="9d81" class="mx lv it mt b gy nc mz l na nb"><em class="mr">   return</em> [[NSURL alloc] initWithString:<em class="mr">self</em>];</span><span id="e329" class="mx lv it mt b gy nc mz l na nb">}</span><span id="10ef" class="mx lv it mt b gy nc mz l na nb">@end</span></pre><h1 id="ad3a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="5524" class="pw-post-body-paragraph ki kj it kk b kl mm ju kn ko mn jx kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">本指南仅介绍了基本的Swift和Objective-C用法。当然，在这两种语言中还有很多东西需要探索，比如协议、泛型、错误处理等等。我希望，本指南已经为您深入研究更高级的语言特性打下了良好的基础。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="dbe8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mr">最初发表于</em><a class="ae ny" href="https://tanaschita.com/20210206-objective-c-for-swift-developers" rel="noopener ugc nofollow" target="_blank"><em class="mr">https://tanaschita.com</em></a><em class="mr">。</em></p></div></div>    
</body>
</html>