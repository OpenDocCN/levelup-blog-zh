<html>
<head>
<title>How Concurrency can Break your Software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并发性如何破坏你的软件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-concurrency-can-break-your-software-f777b97d3286?source=collection_archive---------9-----------------------#2021-10-14">https://levelup.gitconnected.com/how-concurrency-can-break-your-software-f777b97d3286?source=collection_archive---------9-----------------------#2021-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c0a7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">与不充分的事务隔离相关的竞争条件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bc586d8e68453e1e4db3ce4febe971ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NIZ8V0Banq3t3Cks"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">韦斯·希克斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="caee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的30年里，我们看到了硬件方面的显著进步。<a class="ae ky" href="https://en.wikipedia.org/wiki/Moore%27s_law" rel="noopener ugc nofollow" target="_blank">摩尔</a>观察到，密集集成电路(IC)中的晶体管数量大约每两年翻一番，CPU时钟频率从1970年的740 kHz增加到2021年的4.9 GHz，随着时间的推移，CPU可以执行的指令类型变得更加复杂。但是增加时钟频率和增加更复杂的指令是有限制的。CPU制造商没有这样做，而是增加了并发执行更多东西的可能性。这带来了它自己的一系列问题。</p><p id="e137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，最有趣的是在web服务的环境中。最突出的是，它与中央数据库交互，并与事务隔离相关。在本文中，您将了解最著名的缺少隔离的问题是什么，以及哪些事务隔离级别可以解决这些问题。开始吧！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7fef" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">基础知识📚</h1><p id="1dfe" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">数据库在<strong class="lb iu"> <em class="lv">事务</em> </strong>中组织多个操作。您可以将数据库想象成一系列事务。如果事务是数据库的一部分，我们说它是<em class="lv">提交的</em>。如果交易失败，则执行<strong class="lb iu"> <em class="lv">回滚</em> </strong>。交易被撤销。</p><p id="a3e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望事务是<strong class="lb iu"> <em class="lv">原子的</em></strong>——要么事务完全是数据库的一部分，要么根本不是。不应有部分提交的事务。</p><p id="9841" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还希望<strong class="lb iu"> <em class="lv">事务隔离</em> </strong> —事务的并发执行不会导致与串行执行不同的结果。事务是一个接一个执行还是并行执行并不重要。</p><p id="42cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在本文中研究的问题被称为<em class="lv">读取现象</em>，它们发生在隔离特性被破坏时。更强的隔离是有代价的。权衡是速度和保证某些问题不会发生。这些保证被称为事务隔离级别。控制问题也被称为<strong class="lb iu">并发控制</strong>。有<strong class="lb iu">乐观</strong>和<strong class="lb iu">悲观</strong>并发控制。乐观并发控制使用<strong class="lb iu">快照</strong>和验证，悲观并发控制使用<strong class="lb iu">锁</strong>。之所以称之为乐观，是因为它首先允许发生变化，并在必要时回滚。它假设事情会好起来，而锁则假设事情会出错。取决于什么事情发生得更频繁，乐观或悲观更便宜。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="dd3b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">自己动手！🔨</h1><p id="d8da" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果要执行以下语句，需要运行PostgreSQL:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d057" class="nf me it nb b gy ng nh l ni nj">$ sudo su - postgres<br/>$ psql<br/># CREATE TABLE balances (id varchar PRIMARY KEY, balance int);<br/>CREATE TABLE</span><span id="ccd4" class="nf me it nb b gy nk nh l ni nj"># INSERT INTO balances (id, balance) VALUES ('Alice', 500), ('Bob', 500);<br/>INSERT 0 2</span><span id="cc50" class="nf me it nb b gy nk nh l ni nj"># SELECT * FROM balances;</span><span id="4623" class="nf me it nb b gy nk nh l ni nj">id   | balance<br/>-------+---------<br/>Alice |     500<br/>Bob   |     500</span></pre><h1 id="e08f" class="md me it bd mf mg nl mi mj mk nm mm mn jz nn ka mp kc no kd mr kf np kg mt mu bi translated">脏读:读取未提交的数据</h1><blockquote class="nq"><p id="9832" class="nr ns it bd nt nu nv nw nx ny nz lu dk translated">当事务T2看到未提交的事务T1时，这被称为脏读。</p></blockquote><p id="9502" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">想象一下这个场景:爱丽丝和鲍勃在谈恋爱。艾丽丝擅长记账并记录财务状况，而鲍勃有时在财务上并不那么负责。在这种情况下，他想花600 €买一把玄幻剑。幸运的是，如果余额低于0 €，他们的银行会拒绝交易。但是爱丽丝在中间检查了鲍勃的账户。</p><p id="5b14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们有两个交易:</p><ul class=""><li id="7e3f" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">T1:鲍勃试图支付幻想剑，失败了，并得到回滚。</li><li id="75e7" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">T2:艾丽斯查看了账户。</li></ul><p id="78d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了对另一家银行执行交易，Alice和Bob的银行运行以下<code class="fe ot ou ov nb b">transfer_out</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="05ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两人的账户上最初都有500欧元。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="199c" class="nf me it nb b gy ng nh l ni nj">-- T1: Bob tries to get that fantasy sword<br/>BEGIN TRANSACTION<br/>    # Step 1: Pay for the sword<br/>    UPDATE balances SET balance = balance - 1000 WHERE id = 'Bob';</span><span id="8df1" class="nf me it nb b gy nk nh l ni nj">    # Step 2: Check if the balance got negative<br/>    SELECT balance FROM balances WHERE id = 'Bob';<br/>END TRANSACTION</span><span id="4ced" class="nf me it nb b gy nk nh l ni nj">-- T2: Bob's interaction with the bank<br/>BEGIN TRANSACTION<br/>    # Step 1: Reduce the balance of Bobs account by 150 EUR<br/>    UPDATE balances SET balance = balance - 150 WHERE id = 'Bob'<br/>    <br/>    # Step 2: Increase the balance of Alice account by 150 EUR<br/>    UPDATE balances SET balance = balance + 150 WHERE id = 'Alice'<br/>END TRANSACTION</span></pre><p id="eb54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们有两个事务，所以这两个步骤同时发生。这意味着可能是T1首先完全执行，然后是T2，但也可能是它们交错执行。例如:<br/>t1 . step 1➔T2 . step 1➔t1 . step 2➔T2 . step 2</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/8f94191ec0def3770c99bea698a519b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e666Cm_molYsQWVIDv5g_w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Alice读取到数据库的不一致状态，因为事务T1尚未完成。这让她得出了错误的结论，认为鲍勃欠了债，可能会导致高利率。马丁·托马斯创造形象</figcaption></figure><p id="95b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，这是有问题的。爱丽丝现在可能认为他们的钱比实际的少。</p><p id="c50f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<strong class="lb iu"> READ_COMMITTED </strong>事务隔离级别来防止脏读。由于在很多情况下读取未提交的数据是有问题的，PostgreSQL甚至不允许这样做:</p><blockquote class="oz pa pb"><p id="cd03" class="kz la lv lb b lc ld ju le lf lg jx lh pc lj lk ll pd ln lo lp pe lr ls lt lu im bi translated">SQL标准定义了一个额外的级别，READ UNCOMMITTED。在PostgreSQL中，未提交读被视为已提交读(<a class="ae ky" href="https://www.postgresql.org/docs/9.3/sql-set-transaction.html" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></blockquote><h1 id="32d6" class="md me it bd mf mg nl mi mj mk nm mm mn jz nn ka mp kc no kd mr kf np kg mt mu bi translated">不可重复读取🤷‍♀️</h1><blockquote class="nq"><p id="e518" class="nr ns it bd nt nu nv nw nx ny nz lu dk translated">当同一行在一个事务中被读取两次，但由于事务外部的更改而不包含相同的信息时，这是一种不可重复的读取(也称为读取偏差)。</p></blockquote><p id="c0cd" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">安娜喜欢记录他们的财务状况。其中一部分是得到他们余额的总和以及个人余额。然而，这次她倒霉了。在他们都支付400€租金之前，她读了余额的总数。之后，她会读取个人余额。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/0ad86ad2ccf8cfdfaaa588794d4ffa94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NoDm07xlWI9NGeE6QYI17g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">爱丽丝读了他们支付400€租金之前的余额总和以及之后的个人余额。现在她很困惑，因为她不知道发生了不可重复的读取。图片由马丁·托马斯提供。</figcaption></figure><p id="fd4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要亲自查看，您需要终端会话打开到您的PostgreSQL服务器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">如您所见，左边的事务2看到了不一致的状态:一方面，余额的总和是1000。另一方面，个人余额的总和只有200。</figcaption></figure><p id="2827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<strong class="lb iu"> REPEATABLE_READ </strong>事务隔离级别来防止不可重复的读取:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h1 id="7ebb" class="md me it bd mf mg nl mi mj mk nm mm mn jz nn ka mp kc no kd mr kf np kg mt mu bi translated">幻像读取👻</h1><blockquote class="nq"><p id="3516" class="nr ns it bd nt nu nv nw nx ny nz lu dk translated">如果同一个查询在一个事务中执行了两次，但行集不同，则会发生幻像读取。消失的行是幻影。</p></blockquote><p id="e1a7" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">根据ANSI SQL-92标准，可序列化隔离级别可防止幻像读取。但是，PostgreSQL中可重复读取事务隔离级别的实现也防止了幻像读取。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="cc2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查理是这里的幽灵👻</p><h1 id="0bfa" class="md me it bd mf mg nl mi mj mk nm mm mn jz nn ka mp kc no kd mr kf np kg mt mu bi translated">丢失更新</h1><blockquote class="nq"><p id="f009" class="nr ns it bd nt nu nv nw nx ny nz lu dk translated">当一个更新因为被第二个事务的另一个更新覆盖而丢失时，它被称为丢失的更新。</p></blockquote><p id="8cc2" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">举个例子，下面的情况。左侧和右侧是两个不同的事务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="a60e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您处于REPEATABLE_READ序列化级别，第二次更新(第11行)将触发一个异常:</p><blockquote class="oz pa pb"><p id="1171" class="kz la lv lb b lc ld ju le lf lg jx lh pc lj lk ll pd ln lo lp pe lr ls lt lu im bi translated">错误:由于并发更新，无法序列化访问</p></blockquote><h1 id="e1c2" class="md me it bd mf mg nl mi mj mk nm mm mn jz nn ka mp kc no kd mr kf np kg mt mu bi translated">Postgres如何实现事务隔离级别？</h1><p id="dc8f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Postgres对所有事务隔离级别使用快照隔离(<a class="ae ky" href="https://www.postgresql.org/docs/14/transaction-iso.html" rel="noopener ugc nofollow" target="_blank">来源</a>):</p><ul class=""><li id="c966" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">READ_COMMITTED看到事务中当前语句的<strong class="lb iu">开始时的快照</strong></li><li id="7427" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">REPEATABLE_READ看到事务中第一个非事务控制语句<strong class="lb iu">开始时的快照。</strong></li><li id="fd40" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">SERIALIZABLE类似于REPEATABLE_READ，但是它还监视可能使一组并发的可序列化事务的执行行为与这些事务的所有可能的串行(一次一个)执行行为不一致的条件</li></ul><p id="908c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Postgres使用多版本并发控制(MVCC)的一种变体，称为可序列化快照隔离。核心思想是每次更新都不会覆盖数据，而是用事务ID将数据添加到DB中。当执行SELECT时，可能会选择多个版本，这允许一个事务具有一致的快照。可序列化隔离级别的实现是复杂的。</p><h1 id="2504" class="md me it bd mf mg nl mi mj mk nm mm mn jz nn ka mp kc no kd mr kf np kg mt mu bi translated">其他异常情况</h1><p id="e2dc" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果这对你来说还不够，我推荐阅读贝伦森、伯恩斯坦、格雷、梅尔顿、奥尼尔和奥尼尔的《T2对ANSI SQL隔离级别的评论》。他们深入细节并指出其他异常之处。例如，所有隔离级别(甚至READ_UNCOMMITTED)都会阻止<strong class="lb iu">脏写</strong>。它不同于<strong class="lb iu">写偏斜</strong>。在Postgres的可序列化隔离级别中，写偏斜是被阻止的。</p><h1 id="ada5" class="md me it bd mf mg nl mi mj mk nm mm mn jz nn ka mp kc no kd mr kf np kg mt mu bi translated">摘要</h1><p id="2656" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">下面概述了哪些事务隔离级别可以防止哪些读取现象:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/afaa2ce6b488ed99da0579aa294ec04a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uur10boqar8yjEOlAYWUXg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">READ _ UNCIMMITTED事务隔离级别允许所有三种读取现象发生，而SERIALIZABLE隔离级别则阻止所有这些现象发生。图片由马丁·托马斯提供。</figcaption></figure><p id="658c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些隔离级别是在SQL标准中定义的。然而，各种数据库可能会提供更强的保证。例如，READ_UNCOMMITTED事务隔离级别等于Postgres中的READ_COMMITTED隔离级别。此外，REPEATABLE_READ隔离级别已经防止了Postgres中的幻像读取。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b191" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">参考</h1><p id="45a9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了写这篇文章，我读了很多书。最有价值的资源是:</p><ul class=""><li id="fb93" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated"><a class="ae ky" href="https://vladmihalcea.com/" rel="noopener ugc nofollow" target="_blank">Vlad Mihalcea</a>:<a class="ae ky" href="https://www.youtube.com/watch?v=onYjxRcToto" rel="noopener ugc nofollow" target="_blank">YouTube上Devoxx的事务和并发控制模式</a>，2017。</li><li id="4cb5" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><a class="ae ky" href="https://www.interdb.jp/pg/pgsql05.html" rel="noopener ugc nofollow" target="_blank">PostgreSQL的内部机制</a></li><li id="7c2e" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><a class="ae ky" href="https://www.sydney.edu.au/engineering/about/our-people/academic-staff/uwe-roehm.html" rel="noopener ugc nofollow" target="_blank">Uwe rhm</a>:<a class="ae ky" href="https://db.in.tum.de/teaching/ws1314/transactions/pdf/SnapshotIsolation.pdf?lang=de" rel="noopener ugc nofollow" target="_blank">交易系统</a>in 2267，2014。</li><li id="dce4" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">PostgreSQL文档:<a class="ae ky" href="https://www.postgresql.org/docs/14/transaction-iso.html" rel="noopener ugc nofollow" target="_blank">事务隔离</a></li><li id="bbcf" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">Berenson，Bernstein，Gray，Melton，O'Neil，O'Neil: <a class="ae ky" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf" rel="noopener ugc nofollow" target="_blank">对ANSI SQL隔离级别的批判</a>，2016。——阿德里安·科尔耶为《T2》写了一篇精彩的文章。</li></ul></div></div>    
</body>
</html>