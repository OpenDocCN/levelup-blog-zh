<html>
<head>
<title>Convert Existing React Components into WebComponents</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将现有的React组件转换为WebComponents</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/convert-existing-react-components-intowebcomponents-2b33b842ff9a?source=collection_archive---------4-----------------------#2020-04-11">https://levelup.gitconnected.com/convert-existing-react-components-intowebcomponents-2b33b842ff9a?source=collection_archive---------4-----------------------#2020-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1f5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决不同的问题，JS生态系统正朝着框架竞争发展。</p><ol class=""><li id="0aca" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">不同的框架可以和谐地一起工作。</li><li id="a769" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">Javascript开发者不需要依赖任何框架来开发基于组件的架构，双向绑定。</li><li id="9ad6" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">Web组件依赖于本地浏览器API，因此速度更快，并且不需要依赖。</li></ol><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/ac81433914c784e0922c6bb94fba2ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5H8IeMAYZfcewGREz3m3TA.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">将组件反应为web组件</figcaption></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="575a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">这是你的最终结果:</strong></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/3bdbd0a56e1877c7f3f17bfd229a68a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*RJUe1LSbP_qJ1RGD6vIRtw.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">由web组件包装器包装并在HTML页面中呈现的React组件</figcaption></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="73f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们直接进入代码。在大约5个步骤中，您将使用现有的React组件创建一个生产就绪的WebComponent。</p><p id="da75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第一步:</strong>用<strong class="js iu"> create-react-app </strong>创建一个新项目</p><p id="9d1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开VS代码，键入<code class="fe ma mb mc md b">npx create-react-app your-application-name</code>如果你需要任何帮助，检查这个<a class="ae me" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank">链接</a></p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="3b63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">步骤2: </strong>创建评级反应组件</p><p id="8b37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建名为RatingComponent.js的文件，并将下面代码片段中的代码添加到RatingComponent.js中。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="f8d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它只是一个基本的react组件，有3个属性，即1)<strong class="js iu">max value</strong>——用于控制它应该显示多少颗星星。2) <strong class="js iu"> value </strong> —用于设置当前选中的评级3) <strong class="js iu"> onRatingUpdatedEvt — </strong>回调函数，用于将选中的值发布给父级，这样他们就可以有自己的回调逻辑。</p><p id="52fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> componentDidMount中，</strong>我只是调用了<strong class="js iu"> createStars </strong>方法来基于初始<strong class="js iu"> maxValue </strong>和<strong class="js iu">值构建星星。</strong>我还为每个星星添加了对<strong class="js iu"> onMouseOver </strong>、<strong class="js iu"> onMouseOut </strong>事件的回调，并调用<strong class="js iu"> createStars </strong>函数来构建星星并将其分配给state，这反过来反映在UI中。并且我已经将每个star的<strong class="js iu"> onClick </strong>处理程序附加到了<strong class="js iu"> setValue </strong>函数中。每当用户点击任何星号<strong class="js iu"> setValue </strong>函数被触发，在其中，我将把当前选择的索引更新为值prop，并调用<strong class="js iu"> createStars </strong>方法来基于此构建列表。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="8374" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">步骤3: </strong> Web组件对包装器做出反应</p><p id="cc0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，我们将把web组件道具、事件和生命周期方法映射到React组件，反之亦然。</p><p id="b313" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从WebComponents基础开始。这些是WebComponents的生命周期事件，您可以在这里的<a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank">下找到它。我们将在本教程中使用其中的一些。</a></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mh"><img src="../Images/4c85a7c4e463546236df294cc08869a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o7DYCljMpLRm_uTD0XDMnQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">web组件的生命周期事件</figcaption></figure><blockquote class="mi mj mk"><p id="0cc9" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated">connectedCallback等效于componentDidMount</p><p id="86d0" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated">disconnectedCallback等效于componentWillUnMount</p><p id="d680" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated">adoptedCallback是生命周期事件，当试图将自定义元素从iframe移动到另一个iframe时会调用它。</p><p id="8ef2" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated">attributeChangedCallback非常等同于<em class="it"> getDerivedStateFromProps </em></p></blockquote><p id="681c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> connectedCallBack </strong>函数实现了从裸HTML获取属性名和事件，并尝试生成属性和回调，并将其绑定到React组件。</p><blockquote class="mi mj mk"><p id="d33a" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated"><rating-element maxvalue="5" value="0" onratingupdatedevt="”onratingupdatedevt”"> </rating-element></p></blockquote><p id="6751" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> convert </strong>方法里面，你会奇怪我为什么加了这个。基本上，我正在尝试转换字符串:</p><blockquote class="mp"><p id="cb89" class="mq mr it bd ms mt mu mv mw mx my kn dk translated">否则如果(/^{.*}/.exec(属性值))</p><p id="975d" class="mq mr it bd ms mt mu mv mw mx my kn dk translated">value = JSON . parse(attr value)；</p></blockquote><p id="974b" class="pw-post-body-paragraph jq jr it js b jt mz jv jw jx na jz ka kb nb kd ke kf nc kh ki kj nd kl km kn im bi translated">默认情况下，只能将字符串值赋给HTML元素的属性。WebComponents也是一个本地HTML，因此这里也适用。所以如果你想让你的WebComponents属性支持JSON对象，你必须把值赋值为上面的<em class="ml"> stringified </em>代码会把它应用到React组件</p><p id="c0e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> getEvents </strong>函数中，我按名称过滤以“on”开头的attr，并为每个事件附加代码<strong class="js iu"><em class="ml">this . dispatch event(new CustomEvent(ev . name，{…args })</em></strong>。它负责将每一个事件发送给父节点。</p><p id="6f08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后将构建的道具和事件都设置到React组件，并渲染它<strong class="js iu"><em class="ml">render(&lt;rating component {…props }/&gt;，this)；</em> </strong></p><p id="dd0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu"> disconnectedCallback </strong>方法中，基本上做的是当组件从DOM中卸载时的事情。我调用了<strong class="js iu"><em class="ml">unmountComponentAtNode</em></strong>，它基本上从DOM中移除了组件。</p><p id="d843" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<strong class="js iu">中，attributeChangedCallback </strong>基本上卸载并重新装载元素，以便组件反映最新的属性更新。</p><p id="6fd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们到了最后一部分，只需添加这一行，以便您的自定义组件注册为WebComponent，这样它就可以被浏览器识别并自动呈现。</p><p id="ab70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"><em class="ml">custom elements . define(' rating-element '，react element)；</em> </strong></p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7b8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并像上面那样更新index.js。我们不需要反应堆。渲染以将其附加到HTML元素，因为我们正在将其构建为WebComponent。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="6013" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第四步:Index.html</strong></p><p id="642d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在public/index.html下</p><p id="e595" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加一个带有您用来注册WebComponent的名称的标签，并添加逻辑来监听<strong class="js iu"> onratingupdatedevt </strong>事件。</p><p id="b8c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我添加了一个<strong class="js iu"> div </strong>来显示选定的评级，并添加了一个按钮来重置评级组件的值。您可以看到，每当您单击一个评级星，该值就会反映在<strong class="js iu"> results div中。</strong>无论何时点击重置按钮，它基本上将评级组件的值重置为<strong class="js iu"> 0，</strong>，这又调用属性回调并重置评级组件的状态。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mf mg l"/></div></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="6a0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第五步:运行项目</strong></p><p id="a3f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装<code class="fe ma mb mc md b">yarn add http-server -g</code>。<strong class="js iu"> <em class="ml"> </em> </strong> http-server用于托管和运行特定文件夹下的任何app。</p><p id="f770" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行<code class="fe ma mb mc md b">yarn build</code> <strong class="js iu"> <em class="ml"> </em> </strong>构建应用程序，这将为您创建一个构建文件夹，然后运行<code class="fe ma mb mc md b">yarn http-server ./build</code> <strong class="js iu"> <em class="ml"> </em> </strong>，这将尝试托管构建文件夹，您可以看到应用程序已经启动并正在运行。</p><p id="b92a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在Glitch中运行示例有任何问题，您可以从我的Github中克隆repos:</p><div class="ne nf gp gr ng nh"><a href="https://github.com/sarvabowmen/rating-webcomponent" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">sarva bowmen/评级-web组件</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">运行应用程序的步骤1。要安装依赖关系-纱index.html-有评级网页组件定义在html和…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">github.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv lm nh"/></div></div></a></div><p id="8655" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">参考文献</strong></p><div class="ne nf gp gr ng nh"><a href="https://custom-elements-everywhere.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">无处不在的自定义元素</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">自定义元素是一种新的web标准，它允许开发人员创建自己的HTML元素。因为它们是基于…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">custom-elements-everywhere.com</p></div></div><div class="nq l"><div class="nw l ns nt nu nq nv lm nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">Web组件</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">作为开发人员，我们都知道尽可能多地重用代码是一个好主意。传统上不是这样的…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">developer.mozilla.org</p></div></div><div class="nq l"><div class="nx l ns nt nu nq nv lm nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://github.com/w3c/webcomponents" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">W3C/web组件</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">Web组件是一个新的浏览器特性，它为Web提供了一个标准的组件模型，由几个…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">github.com</p></div></div><div class="nq l"><div class="ny l ns nt nu nq nv lm nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://medium.com/javascript-in-plain-english/create-micro-frontends-using-web-components-with-support-for-angular-and-react-2d6db18f557a" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">使用Web组件创建微前端(支持Angular和React)</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">如果你是React或Angular，Ember或Vue，让我们创建一个地方，让他们都可以生活在一起，在完美的和谐使用…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nz l ns nt nu nq nv lm nh"/></div></div></a></div></div></div>    
</body>
</html>