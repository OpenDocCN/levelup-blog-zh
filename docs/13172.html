<html>
<head>
<title>Exploring External Authentication with Envoy — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Envoy探索外部认证—第二部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/exploring-external-authorisation-with-envoy-part-ii-573c35f64c78?source=collection_archive---------9-----------------------#2022-08-14">https://levelup.gitconnected.com/exploring-external-authorisation-with-envoy-part-ii-573c35f64c78?source=collection_archive---------9-----------------------#2022-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0049773a7f092c81949a65073a16d1e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UykOP-FM-NNzUJ-rCGWZgg.png"/></div></div></figure><p id="0809" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是关于使用Envoy处理外部认证的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/exploring-external-authorisation-with-envoy-part-i-dd0b5fd83d8f">博客</a>的延续。我们将实现上述架构，其中<a class="ae kw" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使</a>将充当前台代理。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="01a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们克隆下面的存储库(【https://github.com/envoyproxy/envoy.git】T4)。我们需要去<em class="le"> examples/front-proxy </em>文件夹，在那里Envoy提供了一个完美的例子，我们可以从这里开始。docker-compose文件提供了两个相同的flask服务器以及一个Envoy代理实例。没有任何延迟，让我们构建docker映像并运行服务(使用以下命令)。</p><blockquote class="lf lg lh"><p id="a861" class="jy jz le ka b kb kc kd ke kf kg kh ki li kk kl km lj ko kp kq lk ks kt ku kv ij bi translated">$ git克隆<a class="ae kw" href="https://github.com/envoyproxy/envoy.git" rel="noopener ugc nofollow" target="_blank">https://github.com/envoyproxy/envoy.git</a><br/>$ CD特使/范例/前台代理<br/>$ docker-撰写up -d</p></blockquote><p id="85d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将打开如下所示的3个容器。其中两个将是flask服务器，一个将是特使本身。我们也可以尝试通过curl向特使请求。请注意，在端口8080上请求，将请求到特使，然后请求将被转发到flask服务。我们可以看到8080端口在<em class="le"> docker-compose </em>文件中被Envoy公开。</p><blockquote class="lf lg lh"><p id="d27e" class="jy jz le ka b kb kc kd ke kf kg kh ki li kk kl km lj ko kp kq lk ks kt ku kv ij bi translated">$ curl localhost:8080/service/1<br/>特使背后的你好(服务1)！主机名:0cd25dcc1c9d已解析主机名:172.18.0.2</p><p id="c199" class="jy jz le ka b kb kc kd ke kf kg kh ki li kk kl km lj ko kp kq lk ks kt ku kv ij bi translated">$ curl localhost:8080/service/2<br/>特使背后的你好(服务2)！主机名:2c8b3ed74e7d已解析主机名:172.18.0.3</p></blockquote><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ll"><img src="../Images/85f88debe789d856e138606f7d20ceb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cgFSrnh5zXxS2uvSzt3KpQ.png"/></div></div></figure><p id="2ec1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，还没有认证服务出现，每个到达特使的请求都将被转发到服务。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="293d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们构建一个虚拟身份验证服务，它将验证请求中出现的用户令牌。只有在请求头中存在有效的用户令牌时，authN服务才应该返回200，否则应该返回4XX(在我们的例子中是403)。</p><p id="c1f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以克隆下面的存储库(<a class="ae kw" href="https://github.com/samanway1996/dummy-auth-service" rel="noopener ugc nofollow" target="_blank">https://github.com/samanway1996/dummy-auth-service</a>)。这包括一个用于上述authN用例的Julia程序，以及docker文件。我们可以继续构建docker映像并从中运行容器(使用下面的命令)。</p><blockquote class="lf lg lh"><p id="1eba" class="jy jz le ka b kb kc kd ke kf kg kh ki li kk kl km lj ko kp kq lk ks kt ku kv ij bi translated">$ git克隆<a class="ae kw" href="https://github.com/samanway1996/dummy-auth-service" rel="noopener ugc nofollow" target="_blank">https://github.com/samanway1996/</a><a class="ae kw" href="https://github.com/samanway1996/dummy-auth-service" rel="noopener ugc nofollow" target="_blank">虚拟授权服务</a> <br/> $ cd <a class="ae kw" href="https://github.com/samanway1996/dummy-auth-service" rel="noopener ugc nofollow" target="_blank">虚拟授权服务</a><br/>$ docker build-t dummy _ auth。<br/>$ docker run-p 8083:8088-it dummy _ auth</p></blockquote><p id="4706" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个命令应该将服务作为容器运行，并将监听端口暴露给主机的端口号8083。在这一点上，列出所有的容器(使用<em class="le"> docker ps </em>命令)也应该显示我们新的authN服务容器。</p><p id="3d51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以尝试使用curl请求authN服务。如果报头中存在无效标记或者根本不存在报头，它应该返回403。</p><figure class="lm ln lo lp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/16f78d7804aa1b88f48806f6b8cc1a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8KuTFX3pIGX2118iPyotBg.png"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="4902" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们希望我们的特使将点击authN服务来验证令牌，而不应该将请求转发给flask服务，如果头部中的令牌无效的话。为此，我们需要修改Envoy配置文件，让它在转发每个请求之前验证来自authN服务的令牌。</p><p id="571a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面我们把front-envoy.yaml的内容替换成。(是的，我们会解释我们所做的改变！)现在我们需要构建特使容器并再次运行它。(使用这些命令)</p><blockquote class="lf lg lh"><p id="520a" class="jy jz le ka b kb kc kd ke kf kg kh ki li kk kl km lj ko kp kq lk ks kt ku kv ij bi translated">$ CD envoy/examples/front-proxy<br/>#现在需要用下面的代码替换front-envoy.yaml并重新构建<br/>$ docker-compose build<br/>$ docker-compose up-d</p></blockquote><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="97fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦特使集装箱再次上升，让我们尝试击中。又是同样的卷发。</p><blockquote class="lf lg lh"><p id="db65" class="jy jz le ka b kb kc kd ke kf kg kh ki li kk kl km lj ko kp kq lk ks kt ku kv ij bi translated">$ curl localhost:8080/service/1<br/>无效令牌:<strong class="ka ir"><br/></strong>$ curl localhost:8080/service/2<br/>无效令牌:</p></blockquote><p id="cfba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">瞧啊。！我们的前台代理这次没有让我们到达flask服务器。只有当我们在请求头中包含正确的令牌时，才会出现这种情况。</p><blockquote class="lf lg lh"><p id="1a63" class="jy jz le ka b kb kc kd ke kf kg kh ki li kk kl km lj ko kp kq lk ks kt ku kv ij bi translated">$ curl localhost:8080/service/1-H ' Token:abcde '<br/>无效令牌:abcde<br/>$ curl localhost:8080/service/2-H ' Token:abcdef '<br/>特使(service 2)背后的你好！主机名:2c8b3ed74e7d已解析主机名:172.18.0.3</p></blockquote></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="1296" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这看起来像魔术，但这都是逻辑。Envoy支持http过滤器，这有助于过滤请求。我们必须添加一个http过滤器，通过点击authN服务进行过滤。下面是我们在配置中添加的http过滤器。</p><figure class="lm ln lo lp gt jr"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="bfdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">server-uri中的uri参数告诉Envoy确切的authN服务URI(<em class="le">http://host . docker . internal:8083/auth</em>对于我们的例子，请记住，我们在端口号<em class="le"> 8083 </em>上运行我们的虚拟authN服务，用于访问外部authN服务。</p><p id="0edb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一点需要注意的是，我们是如何提到在向外部authN服务发送请求时使用哪个报头的。由于我们的authN服务需要请求中的<em class="le">令牌</em>报头，因此特使必须发送报头中的<em class="le">令牌</em>。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="6afb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">参考文献</strong> : <br/> 1。<a class="ae kw" href="https://github.com/envoyproxy/envoy" rel="noopener ugc nofollow" target="_blank">https://github.com/envoyproxy/envoy</a>2<br/>。<a class="ae kw" href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/http/ext_authz/v3/ext_authz.proto#envoy-v3-api-msg-extensions-filters-http-ext-authz-v3-httpservice" rel="noopener ugc nofollow" target="_blank">特使HTTP过滤器</a> <br/> 3。<a class="ae kw" href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/type/matcher/v3/string.proto#envoy-v3-api-msg-type-matcher-v3-stringmatcher" rel="noopener ugc nofollow" target="_blank">特使类型匹配</a></p></div></div>    
</body>
</html>