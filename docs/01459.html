<html>
<head>
<title>How to create an NPM package out of a React app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从React应用程序创建NPM包</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-npm-package-out-of-react-app-7556b9b47bce?source=collection_archive---------2-----------------------#2020-01-04">https://levelup.gitconnected.com/how-to-create-npm-package-out-of-react-app-7556b9b47bce?source=collection_archive---------2-----------------------#2020-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="169c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我们将看看如何在React应用程序的基础上创建一个NPM包。具体来说，我们将使用<a class="ae ko" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> Create-React-App </a>的构建输出，并创建一个将路径导出到<code class="fe kp kq kr ks b">index.html</code>和<code class="fe kp kq kr ks b">build</code>文件夹的包。这使得静态文件可以从后端提供，比如<code class="fe kp kq kr ks b">express</code>。尽管这个例子使用了React，但我认为这种技术应该适用于所有前端框架，因为它们最终都会生成HTML、JS和CSS以供浏览器呈现。</p><p id="b406" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会问:</p><blockquote class="kt ku kv"><p id="bf27" class="jq jr kw js b jt ju jv jw jx jy jz ka kx kc kd ke ky kg kh ki kz kk kl km kn im bi translated">你为什么想要创建一个包？</p></blockquote><p id="1c67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好问题！在大多数情况下，你的应用程序是在线部署的，并被视为一个网站，因此用户只需访问一个已知的URL，而不是下载一个包。在我的例子中，这个应用程序充当了一个接口，通过HTTP与运行在本地机器上的服务器进行通信。需要知道它们之间的API，并耦合更改。</p><p id="1332" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在普通网站中，UI和服务器都在您的控制之下，因此当您重新部署界面以使用需要新端点的新功能时。您还可以保证服务器得到更新，以公开特性所需的新端点。但是，当服务器运行在localhost上时(这是post范围之外的其他原因所必需的)，您不能保证它会被更新。</p><p id="65a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一要求使得将界面作为网站托管的传统做法不受欢迎。这将要求用户知道他们运行的是哪个版本的服务器，然后确保他们将相同的版本放在URL中，如<code class="fe kp kq kr ks b">www.react-ui.com/admin/v2.20.1/home</code>，由于版本不匹配，可能会有许多用户错误，由于只有部分API支持，这些错误很难诊断。</p><p id="ff9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相反，通过从本地服务器提供UI来消除这类错误。这个服务器知道自己的版本，它可以使用标准的NPM软件包版本请求正确的用户界面，这样就可以保证它们是相同的，并减轻客户的负担。你可以认为这类似于一个电子应用程序，它可以有一个用户界面和类似浏览器的功能，但也使用较低级别的节点功能，但这是一个更轻的解决方案，仍然使用正常的浏览器体验。这篇文章将关注用户界面，因为这是非传统的部分，也是有趣的部分。</p><p id="a338" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然我们清楚了为什么需要这个包。让我们看看如何创建包。</p><h1 id="a768" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">目标是什么？</h1><p id="b257" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">首先，让我们看看在Express上托管一个应用程序需要什么，并与CRA的输出进行比较。</p><p id="8c72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在CRA网站上，您可以看到如何从express输出服务器。</p><div class="md me gp gr mf mg"><a href="https://create-react-app.dev/docs/deployment#other-solutions" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">创建React应用程序通过运行一个命令设置一个现代化的web应用程序。</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">“npm运行构建”创建一个“构建”目录，其中包含应用程序的生产构建。设置您最喜欢的HTTP服务器，以便…</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">创建-反应-应用程序.开发</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu mv mg"/></div></div></a></div><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">如何用Express托管React app</figcaption></figure><p id="aba1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，这里我们需要的唯一信息是提供静态文件的/build文件夹的路径和路由所有请求的index.html的路径。</p><p id="1c0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">建立文件夹:</strong> <code class="fe kp kq kr ks b">path.join(__dirname, ‘build’)</code> <br/> <strong class="js iu">索引文件:</strong> <code class="fe kp kq kr ks b">path.join(__dirname, ‘build’, ‘index.html’)</code></p><p id="824e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们看看如何从包中获取这些信息。</p><h2 id="9276" class="nh lb it bd lc ni nj dn lg nk nl dp lk kb nm nn lo kf no np ls kj nq nr lw ns bi translated">创建新的React应用程序。</h2><p id="e5ae" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">首先创建一个新的react应用程序</p><pre class="mw mx my mz gt nt ks nu nv aw nw bi"><span id="9dc2" class="nh lb it ks b gy nx ny l nz oa">npx create-react-app cra-package --template typescript</span></pre><p id="795b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们进入项目<code class="fe kp kq kr ks b">cd cra-package</code>，然后构建应用<code class="fe kp kq kr ks b">npm run build</code>，注意上面提到的<code class="fe kp kq kr ks b">/build</code>文件夹和<code class="fe kp kq kr ks b">index.html</code>文件。</p><p id="752e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们需要创建一个这个构建文件夹内容的包，但是它也必须导出这些特殊的路径，并且不管它安装在本地机器的什么位置或者在<code class="fe kp kq kr ks b">node_modules</code>中都能工作。</p><p id="ad4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先让我们编写一个脚本来创建<code class="fe kp kq kr ks b">package</code>文件夹。</p><p id="7989" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe kp kq kr ks b">cra-package</code>的根目录下创建一个新的文件夹<code class="fe kp kq kr ks b">scripts</code>，其中将包含一个生成包文件夹的脚本。</p><p id="f3ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行以下命令</p><pre class="mw mx my mz gt nt ks nu nv aw nw bi"><span id="18a1" class="nh lb it ks b gy nx ny l nz oa">mkdir scripts<br/>cd scripts<br/>npx tsc --init</span></pre><p id="b527" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">调整<code class="fe kp kq kr ks b">tsconfig.json</code>,只编译我们现在要创建的<code class="fe kp kq kr ks b">createPackage.ts</code>。</p><p id="0768" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用以下内容创建<code class="fe kp kq kr ks b">createPackage.ts</code>:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="9972" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要点似乎被媒体剪辑了。这里是直接链接<br/><a class="ae ko" href="https://gist.github.com/mattmazzola/97c1b4fa2036f5b9ada78131e79e4bc1" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/mattmazzola/97 C1 B4 fa 2036 F5 B9 ada 78131 e 79 E4 BC 1</a></p><p id="09d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来让我们创建这个脚本所依赖的<code class="fe kp kq kr ks b">index.ts</code>脚本。</p><p id="cac3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似地，在<code class="fe kp kq kr ks b">cra-package</code>的根目录下创建一个新文件夹<code class="fe kp kq kr ks b">packageScripts</code>来表示我们将放入包中的脚本。这是一个单独的文件夹，因为它有单独的<code class="fe kp kq kr ks b">tsconfig.json</code>设置。</p><p id="0ee9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将再次使用typescript并利用编译过程输出到<code class="fe kp kq kr ks b">package</code>文件夹中。</p><pre class="mw mx my mz gt nt ks nu nv aw nw bi"><span id="31bf" class="nh lb it ks b gy nx ny l nz oa">mkdir packageScripts<br/>cd ./packageScripts<br/>npx tsx --init</span></pre><p id="a6cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建一个<code class="fe kp kq kr ks b">index.ts</code>文件来表示我们包的主脚本。</p><p id="4073" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加这些内容:</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5247" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意我们使用了<code class="fe kp kq kr ks b">__dirname</code>这是让包工作的原因，不管它安装在哪里，也不依赖于硬编码的路径。</p><p id="8623" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参见:<a class="ae ko" href="https://nodejs.org/api/modules.html#modules_dirname" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/modules.html#modules_dirname</a></p><h2 id="4686" class="nh lb it bd lc ni nj dn lg nk nl dp lk kb nm nn lo kf no np ls kj nq nr lw ns bi translated">创建并运行两个typescript项目的NPM脚本</h2><p id="d61b" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在package.json中添加一个NPM脚本，以实际利用您刚刚创建的这两个脚本，并创建<code class="fe kp kq kr ks b">package</code>文件夹。</p><pre class="mw mx my mz gt nt ks nu nv aw nw bi"><span id="aef3" class="nh lb it ks b gy nx ny l nz oa">"builduipackage": "tsc -p ./packageScripts/tsconfig.json --outDir ./package &amp;&amp; tsc -p ./scripts/tsconfig.json &amp;&amp; node ./scripts/createPackage.js",</span></pre><p id="1dad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提醒一下，<code class="fe kp kq kr ks b">packageScripts</code>的第一次编译有效地将输出复制到包文件夹中，然后<code class="fe kp kq kr ks b">createPackage.ts</code>脚本的执行有效地将<code class="fe kp kq kr ks b">build</code>文件夹复制到<code class="fe kp kq kr ks b">package</code>文件夹中，并创建一个新的<code class="fe kp kq kr ks b">package.json</code>，它重用了根的名称，但是由于没有依赖项，所以删除了依赖项。</p><p id="eab4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在,<code class="fe kp kq kr ks b">package</code>文件夹已经具备了作为NPM包发布的所有要求。你可以从那个文件夹中手动运行<code class="fe kp kq kr ks b">npm publish</code>，或者更好的是设置一个CD管道来发布和自动化版本控制，但这是另一篇文章的主题，因为有很多这样的文章。</p><p id="54d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于本文，我们将通过运行<code class="fe kp kq kr ks b">npm pack</code>创建一个本地包文件来进行本地测试。</p><p id="2cb7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们创建一个简单的服务器来测试我们的包功能。</p><h2 id="fa70" class="nh lb it bd lc ni nj dn lg nk nl dp lk kb nm nn lo kf no np ls kj nq nr lw ns bi translated">创建express服务器来服务React应用程序</h2><pre class="mw mx my mz gt nt ks nu nv aw nw bi"><span id="4d7d" class="nh lb it ks b gy nx ny l nz oa">git init express-server<br/>cd express-server<br/>npm init -y<br/>npm i typescript express<br/>npm i -D @types/express<br/>npx tsc --init</span></pre><p id="471f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.修改<code class="fe kp kq kr ks b">tsconfig.json</code>以编译到构建文件夹。</p><pre class="mw mx my mz gt nt ks nu nv aw nw bi"><span id="2557" class="nh lb it ks b gy nx ny l nz oa">"outDir": "./build"</span></pre><p id="7b2a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.安装上面创建的本地包文件。如:(文件路径可能不同)</p><pre class="mw mx my mz gt nt ks nu nv aw nw bi"><span id="b4aa" class="nh lb it ks b gy nx ny l nz oa">npm i E://Repos/cra-package/package/cra-package-0.1.0.tgz</span></pre><p id="cecc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">确保在<code class="fe kp kq kr ks b">package.json</code>中添加条目，例如:</p><pre class="mw mx my mz gt nt ks nu nv aw nw bi"><span id="7a2d" class="nh lb it ks b gy nx ny l nz oa">"cra-package": "file:../cra-package/package/cra-package-0.1.0.tgz",</span></pre><p id="2e3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加<code class="fe kp kq kr ks b">src/index.ts</code>来表示我们的服务器，使用React文档中给出的示例的稍微修改的版本，但是使用我们的包路径。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">index.ts</figcaption></figure><p id="8221" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用包装上的<code class="fe kp kq kr ks b">directoryPath</code>和<code class="fe kp kq kr ks b">defaultFilePath</code>。</p><p id="196f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们添加npm脚本来运行服务器！</p><pre class="mw mx my mz gt nt ks nu nv aw nw bi"><span id="3b2a" class="nh lb it ks b gy nx ny l nz oa">"start": "node build/index.js"</span></pre><p id="8dee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行<code class="fe kp kq kr ks b">build</code> (tsc)然后启动服务器。您应该看到默认的React应用程序显示在您的浏览器上。如果你愿意，你可以编辑React应用程序并重新发布以查看更改。</p><p id="0d08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您有了一个创建版本化react应用程序的流程，该应用程序利用了NPM发布的版本。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ob"><img src="../Images/2459a1cedc28e37d4023359ce3fd0ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vdxoDNBXfhnqV7Z-ApwhaA.png"/></div></div></figure><p id="a58a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望你能从这篇文章中学到一些东西。</p><p id="5a70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你对代码感兴趣，或者我在文章中犯了一个错误，这里有两个repos来测试你自己的最终设置。</p><ul class=""><li id="b420" class="oh oi it js b jt ju jx jy kb oj kf ok kj ol kn om on oo op bi translated"><a class="ae ko" href="https://github.com/mattmazzola/cra-package" rel="noopener ugc nofollow" target="_blank">https://github.com/mattmazzola/cra-package</a></li><li id="cb79" class="oh oi it js b jt oq jx or kb os kf ot kj ou kn om on oo op bi translated"><a class="ae ko" href="https://github.com/mattmazzola/express-package-host" rel="noopener ugc nofollow" target="_blank">https://github.com/mattmazzola/express-package-host</a></li></ul><h1 id="38d4" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">录像</h1><p id="af56" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">文件的一些脚本可能还不清楚，所以这里有一个视频。</p><figure class="mw mx my mz gt na"><div class="bz fp l di"><div class="ov nc l"/></div></figure></div></div>    
</body>
</html>