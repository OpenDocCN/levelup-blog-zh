<html>
<head>
<title>Operating System — Process Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">操作系统—流程管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/operating-system-process-management-26c73901166?source=collection_archive---------4-----------------------#2020-08-11">https://levelup.gitconnected.com/operating-system-process-management-26c73901166?source=collection_archive---------4-----------------------#2020-08-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f081" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于过程的基础、中级和高级知识</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/674abc3eb19b1ead6d745eb1f82970f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TC1DmcB4LrYVVG8F"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">迈克尔·泽兹奇在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8998" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">操作系统中的进程管理是一个重要的概念，因为我们在一天中执行不同的程序时会生成成百上千个进程。为了让您更容易理解流程管理，我将它分为三个级别，从最容易到最难:</p><ol class=""><li id="688d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">基础(工艺、PCB、工艺生命周期)</strong></li><li id="a23f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">中间(用户空间中的进程)</strong></li><li id="ff83" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">高级(内核空间中的进程)</strong></li></ol><h1 id="5ac3" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">第1级—你必须知道的基本概念</h1><h2 id="d20e" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">什么是过程？</h2><p id="13ee" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">一个<strong class="ky ir">进程</strong>是一个正在执行的程序。它包含该运行程序的所有信息:</p><ul class=""><li id="2dd8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated">当前程序计数器</li><li id="5f2d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated">累计运行时间</li><li id="0e9c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated">该程序当前打开的文件列表</li><li id="010b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated">页面表</li></ul><h2 id="2840" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">什么是过程控制块(PCB)？</h2><p id="88b0" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">每个过程都由一个称为<strong class="ky ir">过程控制块(PCB) </strong>的数据结构表示。PCB保存了工艺的所有重要信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/b047150477ed0756138d31d6d0d8f215.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*2KQbb1VgapNap_YCaY8zUA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">过程控制块</figcaption></figure><ul class=""><li id="9d58" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated"><strong class="ky ir">指针</strong>:指向父进程的指针。</li><li id="b10c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir">进程ID </strong>:代表一个进程的唯一ID号。</li><li id="4b6d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir">进程状态</strong>:任何进程当前所处的状态(就绪、等待、退出等)。</li><li id="aa4c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir">进程优先级</strong>:表示进程紧急程度的数值。具有最高优先级的进程将首先分配给CPU。</li><li id="db57" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir">程序计数器</strong>:进程中下一条指令的地址。</li><li id="5102" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir">记账信息</strong>:CPU使用量、时间限制、作业或进程号等。</li><li id="ba3f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir"> CPU寄存器</strong>:累加器、变址寄存器、通用寄存器等。</li><li id="cfe7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir"> I/O信息</strong>:分配给进程的打开文件和I/O设备的数组。</li></ul><h2 id="7ee4" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">什么是流程生命周期？</h2><p id="0070" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">每个过程都有一个生命周期。流程的状态包括开始、就绪、运行、等待和终止。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/0d53b816c2169a301aa1b43c3597781f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*LNPKoppfT6-1Kx-rbd6B7g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">流程生命周期</figcaption></figure><p id="c413" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">开始</strong>:一个流程的诞生。<br/>除了第一个进程“init”，每个进程都是使用<strong class="ky ir"> fork() </strong>创建的。</p><p id="2ad5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">就绪</strong>:流程准备就绪。<br/>表示准备运行，但没有运行。在以下情况之后，流程可能会变为“就绪”<br/>(可运行):</p><ul class=""><li id="36a4" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated">它是由<strong class="ky ir"> fork() </strong>创建的</li><li id="771c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated">它已经在CPU上运行了一段时间，操作系统选择运行另一个进程(预定的上下文切换)</li><li id="ee19" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated">从阻塞状态返回</li></ul><p id="6e0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">正在运行</strong>:进程正在运行。<br/>操作系统选择这个进程在CPU上运行，并将其状态改为“运行中”。</p><p id="34f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">等待/阻塞</strong>:进程被阻塞。<br/>当进程运行时，它可能会等待一些东西(例如getc()、wait())。有两种类型的等待，可中断的和不可中断的。</p><ul class=""><li id="90cb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated">可中断等待(Interruptible wait):有时，一个进程必须等待设备的响应，因此它被阻塞了。这种阻塞状态是可中断的。意思是按“Ctrl + C”可以让进程脱离等待状态。</li><li id="3756" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir">不可中断等待</strong>:有时候，一个流程需要等待一个资源，直到它真正得到响应。它处于不可中断状态。这意味着它不会被“Ctrl + C”中断。</li></ul><p id="c6da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">终止:</strong>进程即将死亡。<br/>流程可以选择自行终止或者强制终止。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="a5fa" class="mg mh iq bd mi mj nz ml mm mn oa mp mq jw ob jx ms jz oc ka mu kc od kd mw mx bi translated">第2级—中级知识(用户空间)</h1><p id="648f" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">有了基本概念后，我们将更深入地了解进程的系统调用，但重点是用户空间(从程序员的角度)。</p><ol class=""><li id="0d25" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如何识别流程？</li><li id="917c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如何创建新流程？</li></ol><h2 id="c26a" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">我们如何从一个到另一个识别过程？</h2><p id="e384" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">每个进程都有一个唯一的ID号，称为进程ID(PID)。系统调用<strong class="ky ir"> getpid() </strong>打印调用进程的pid。</p><p id="e345" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">getpid()的示例:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="8197" class="my mh iq of b gy oj ok l ol om">#include &lt;stdio.h&gt; // printf()<br/>#include &lt;unistd.h&gt; // getpid()</span><span id="0ba4" class="my mh iq of b gy on ok l ol om">int main(void) {</span><span id="d210" class="my mh iq of b gy on ok l ol om">  printf(“My PID is %d\n”, <strong class="of ir">getpid()</strong> );</span><span id="35bc" class="my mh iq of b gy on ok l ol om">  return 0;</span><span id="6d95" class="my mh iq of b gy on ok l ol om">}</span></pre><h2 id="7b00" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">我们如何创建一个新的流程？</h2><p id="b40f" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">为了创建一个流程，我们使用系统调用<strong class="ky ir"> fork() </strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/d3f5ba3d238e50addcafb2945b808413.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*nJ8DAPkwzMHBVnZMHDq79A.png"/></div></figure><p id="c74c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">fork()的示例:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="16ed" class="my mh iq of b gy oj ok l ol om">int main(void) {<br/>  printf(“Parent (PID = %d)\n”, getpid());<br/>  <strong class="of ir">fork()</strong>;<br/>  printf(“My PID is %d\n”, getpid() );<br/>  <strong class="of ir">return</strong> 0;<br/>}</span></pre><p id="25d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="030f" class="my mh iq of b gy oj ok l ol om">Parent (PID = 1234) &lt;- parent process<br/>My PID is 1234 &lt;- parent process<br/>My PID is 1235 &lt;- child process</span></pre><p id="3980" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们可以观察到:</p><ul class=""><li id="f409" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated">父进程和子进程都执行相同的程序</li><li id="1116" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir">子进程从返回fork()的位置开始执行，而不是从程序的开头开始执行</strong></li></ul><p id="518e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系统调用<strong class="ky ir"> fork() </strong>就像“细胞分裂”。它通过从父进程克隆来创建子进程，包括所有用户空间数据。</p><p id="aced" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一个进程只能复制自己，并且总是运行同一个程序，那就没什么意义了。那么，这里又来了一个问题——我们如何执行其他程序？</p><p id="3cc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来认识一下<strong class="ky ir"> exec*() </strong>系统调用家族！</p><h2 id="6cbf" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">我们怎样才能执行一个程序？</h2><p id="ec3e" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated"><strong class="ky ir"> exec*() </strong>是一个系统调用族，该族有6个成员(execl、execv、execlp、execvp、execle、execve)。</p><p id="fc89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们以execl()为例:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="6230" class="my mh iq of b gy oj ok l ol om"><strong class="of ir">execl(“/bin/ls”, “/bin/ls”, NULL);</strong></span></pre><p id="4fcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们希望运行“/bin/ls”命令。</p><ul class=""><li id="1334" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated">第一个参数“/bin/ls”:我们要执行的文件</li><li id="32f8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated">第二个参数“/bin/ls”:当进程切换到“/bin/ls”时，<br/>该字符串为程序参数[0]</li><li id="7602" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated">第三个参数“NULL”:表示程序参数列表的结尾</li></ul><p id="ffc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是execl()的另一个例子:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="b71d" class="my mh iq of b gy oj ok l ol om"><strong class="of ir">execl("/bin/ls", "/bin/ls", "-l", NULL);</strong></span></pre><p id="0dec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们有4个参数:</p><ul class=""><li id="2b2f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated">第一个参数“/bin/ls”:我们要执行的文件</li><li id="62ac" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated">第二个参数“/bin/ls”:当进程切换到“/bin/ls”时，<br/>该字符串是程序参数[0]</li><li id="c1c2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated">第三个参数"- l ":当进程切换到"/bin/ls "，<br/>这个字符串就是程序参数[1]</li><li id="9c80" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated">第四个参数“NULL”:表示程序参数列表的结尾</li></ul><p id="06fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个如何在C程序中使用execl()的例子:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="d84a" class="my mh iq of b gy oj ok l ol om">int main(void) {<br/>  printf(“before execl\n”);<br/>  <strong class="of ir">execl(“/bin/ls”, “/bin/ls”, NULL);</strong><br/>  printf(“after execl\n”);<br/>  return 0;<br/>}</span></pre><p id="2e59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果运行此程序，则不会打印“after execl”。这意味着没有到达“execl()”之后的代码行。父进程被终止。</p><p id="8ee0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">记住这一点</strong>:exec系统调用族不仅仅是一个调用命令的函数。“/bin/ls”中的“return”或“exit()”语句将终止该进程。所以，流程肯定回不到原程序了！</p><p id="134f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">问:怎样才能做出有意义的过程创作？</strong> <br/> <strong class="ky ir">答案:fork()+exec *()+wait()= system()</strong><br/>创建有意义流程的例子:</p><pre class="kg kh ki kj gt oe of og oh aw oi bi"><span id="9d93" class="my mh iq of b gy oj ok l ol om">int exec(const char *cmd) {<br/>  if(cmd == -1)<br/>    return -1;</span><span id="3e21" class="my mh iq of b gy on ok l ol om">  // if fork() returns 0, this is a child process  <br/>  if(<strong class="of ir">fork()</strong> == 0) { <br/>    <strong class="of ir">execl("/bin/sh", "/bin/sh", "-c", cmd_str, NULL);</strong></span><span id="c02f" class="my mh iq of b gy on ok l ol om">    fprintf(stderr, "%s: command not found\n", cmd_str);<br/>    exit(-1);<br/>  }</span><span id="1b2f" class="my mh iq of b gy on ok l ol om">  <strong class="of ir">wait(NULL)</strong>;<br/>  return 0;<br/>}</span><span id="e9b7" class="my mh iq of b gy on ok l ol om">// main<br/>int main(void) {<br/>  printf("before exec\n\n");<br/>  <strong class="of ir">exec("/bin/ls");</strong><br/>  printf("after exec\n");<br/>  return 0;<br/>}</span></pre><p id="4272" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">中止父进程的执行和在子进程终止后唤醒父进程的关键是使用<strong class="ky ir"> wait() </strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/f59629c5769d2f815137573716c85314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*2xH3zug4Dc0vgKSctZhnZA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">wait()如何挂起父进程</figcaption></figure><p id="5c31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> wait() </strong>用于将调用进程挂起至等待状态，当其子进程之一终止或收到信号时返回(唤醒)。</p><p id="9f46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，你知道了:</p><ul class=""><li id="86c1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated">系统()创建了一个新进程</li><li id="ef41" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated">进程是由<strong class="ky ir"> exec*() </strong>带入内存的程序</li><li id="3964" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated">c库调用，<strong class="ky ir"> system() </strong>，由<strong class="ky ir"> fork() </strong>，<strong class="ky ir"> exec*() </strong>，以及<br/> <strong class="ky ir"> wait() </strong>实现</li></ul><h1 id="c717" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">第3级—高级知识(内核空间)</h1><p id="f8f7" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">到目前为止，我们只讨论了用户空间中的过程。这是在进入内核空间之前的全貌:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/81d78dcef5ed424208fe3aeaa3069c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*39jvK6M51hnb1xOB7hENEA.png"/></div></div></figure><h2 id="07fa" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">当我们调用系统调用时发生了什么？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/61d459b073bb4da86591c630b1666271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*zi7DhP77-Dpz0awoeyC_OA.png"/></div></figure><p id="c58b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于代码在用户空间内存中，程序计数器指向用户空间内存。</p><p id="eebc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当进程调用系统调用(例如getpid())时，CPU从用户空间切换到内核空间，并从内核读取进程的pid。</p><p id="024e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当CPU执行完系统调用后，它切换回用户空间内存，并继续运行该程序代码。</p><p id="c4df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，CPU总是在用户空间和内核空间之间切换。我们可以检查执行程序时花费在用户空间和内核空间的时间。</p><ul class=""><li id="902f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated"><strong class="ky ir">用户时间</strong>:花费在用户空间内存代码上的CPU时间</li><li id="3f10" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir"> Sys time </strong>:花在内核空间内存代码上的CPU时间</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/94c23ba596d1079942266045b120049b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*deKFPZJ4QBYQk5Xq6GB0Wg.png"/></div></figure><p id="4a67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Linux中，有一个命令叫做<strong class="ky ir"> time </strong>来检查用户时间和系统时间。要了解更多信息，请查看:</p><div class="os ot gp gr ou ov"><a href="https://man7.org/linux/man-pages/man1/time.1.html" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">时间(1) - Linux手册页</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">time命令使用给定的参数运行指定的程序命令。当命令结束时，时间写一个…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">man7.org</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj kp ov"/></div></div></a></div><h2 id="a137" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">fork()是如何工作的？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/de43625d134c061037f3fdd2872914d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*Pkqc_eSLKSdezNzkPlWocg.png"/></div></figure><p id="7c06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个进程调用fork()时，会有一段处理时间，因为内核需要做一些事情。让我们看看内核到底在做什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/71b7b4f27007882d1b122586b9eb0a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u31tcQQcHoj8lHXVHUkaWQ.png"/></div></div></figure><p id="2df3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在内核空间中，进程被安排成一个双向链表，称为<strong class="ky ir">任务列表</strong>。</p><p id="5610" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是<strong class="ky ir"> fork() </strong>在用户空间和内核空间更新内存的方式:</p><ol class=""><li id="2feb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">父进程1234调用<strong class="ky ir"> fork() </strong></li><li id="e34a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">PCB在内核空间被复制，用户空间内存中的代码也被复制</li><li id="2045" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在内核空间中，复制的PCB的一些细节被更新</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/54aa3e28ce1241467482e61c5286efd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMGQcwZbNdq9-GV2CY2_rQ.png"/></div></div></figure><p id="c9ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用<strong class="ky ir"> fork() </strong>后，父进程和子进程都会从fork()返回。最后，在PCB中添加一个返回值。父进程的返回值将是其子进程的PID，子进程的返回值将是0。</p><h2 id="c26b" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">exec*)是如何工作的？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/cba5e6d38314bcffc32714399dd6ead4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ja093ol2wAF6ZmdC3xmvLw.png"/></div></div></figure><p id="b01b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个进程调用<strong class="ky ir"> exec() </strong>时，用户空间的内存会发生变化:</p><ul class=""><li id="15fe" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated"><strong class="ky ir">局部变量</strong> &amp; <strong class="ky ir">动态分配的内存</strong>被清除</li><li id="2283" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir">全局变量</strong>根据新代码重置</li><li id="1210" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr np ly lz ma bi translated"><strong class="ky ir">代码&amp;常量</strong>更改为新代码</li></ul><p id="d666" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，内核也会重置PCB中的寄存器值(例如程序计数器)。</p><h2 id="8eb6" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">wait()和exit()是如何工作的？</h2><h2 id="4eb6" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">退出()</h2><p id="3ecd" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我想先说说<strong class="ky ir"> exit() </strong>由于调用exit()而不调用wait()会导致一个严重的问题，<strong class="ky ir">僵尸进程</strong>。你很快就会明白的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/3beaed4abdd5eb46296e5881c398c509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mN3ag3ggTqZw3Y1Qf1mbsQ.png"/></div></div></figure><p id="118a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是<strong class="ky ir"> exit() </strong>释放用户空间和内核空间内存的方法:</p><ol class=""><li id="a721" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">子进程1235调用<strong class="ky ir"> exit() </strong></li><li id="425b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">内核空间中所有分配的内存都被释放。打开的文件列表全部关闭。(所以跳过fclose()没问题，但不建议)</li><li id="2b59" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">用户空间中所有分配的内存都被释放。(包括程序代码<br/>和分配的内存)</li><li id="6134" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">内核通知子进程的父进程关于其子进程的终止<br/>。内核向父进程发送一个信号。</li></ol><p id="3b88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于父进程1234没有调用wait()，它将忽略<strong class="ky ir"> SIGCHLD </strong>信号。因此，进程ID 1235仍然在内核的任务列表中。子进程的状态现在被称为<strong class="ky ir">僵尸进程</strong>。</p><h2 id="edd9" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">等待()</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/323051571c951d859cc06f561c2db285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFhsJYXjUJ4GgyWWliAv0Q.png"/></div></div></figure><p id="0938" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，每个进程不响应<strong class="ky ir"> SIGCHLD </strong>信号。父进程忽略他的子进程，除非它真的在等待子进程。</p><p id="f9b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一个进程调用了<strong class="ky ir"> wait() </strong>，内核将为该进程注册一个信号处理<br/>例程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/a8b10aa4f4d7fc741970a4b51d6c7560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*Tq72zQ9Hg6B_ZjS2lkBTWw.png"/></div></figure><p id="e782" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当内核向父进程发送<strong class="ky ir"> SIGCHLD </strong>时，相应的信号处理例程将被调用。</p><p id="3a0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是默认处理程序将要做的:</p><ol class=""><li id="db41" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">接受并移除<strong class="ky ir"> SIGCHLD </strong>信号；</li><li id="c09d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">销毁子进程(将其从进程表、任务列表等中移除。)</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/69758a38007ed6d28af538cb55058e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*yy0TtUiGTXV8ATO7SaYiag.png"/></div></figure><p id="5484" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在移除子进程之后，内核取消注册父进程的信号处理例程，并返回被终止的子进程的PID。</p><p id="27fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，调用<strong class="ky ir"> wait() </strong>非常重要！！！主要原因是<strong class="ky ir">系统资源管理</strong>。一个僵尸进程占用一个PID，但是PID的总数是有限的(32，768)。所以，永远记住首先在父进程中调用<strong class="ky ir"> wait() </strong>。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="754c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你正在读这一行，恭喜你！！！你做到了。从一级读到三级不容易。我相信您现在对流程管理有了非常具体的理解。</p><p id="4a17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解更多关于我的后端学习路径，请点击这里查看我的旅程:</p><div class="os ot gp gr ou ov"><a href="https://medium.com/@matthew.chohin/my-backend-developer-learning-journey-%E6%88%91%E7%9A%84%E5%BE%8C%E7%AB%AF%E5%AD%B8%E7%BF%92%E4%B9%8B%E6%97%85-5315fe2fefc2" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi">My Backend Developer Learning Journey 我的後端學習之旅</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">毕业一年多了。拥有2年以上的前端和后端工作经验…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">medium.com</p></div></div><div class="pe l"><div class="pq l pg ph pi pe pj kp ov"/></div></div></a></div></div></div>    
</body>
</html>