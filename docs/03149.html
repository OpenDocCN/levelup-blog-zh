<html>
<head>
<title>Why is “IN” query slow on indexed column in PostgreSQL?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL中索引列上的“IN”查询为什么很慢？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-is-in-query-slow-on-indexed-column-in-postgresql-b716d9b563e2?source=collection_archive---------3-----------------------#2020-04-22">https://levelup.gitconnected.com/why-is-in-query-slow-on-indexed-column-in-postgresql-b716d9b563e2?source=collection_archive---------3-----------------------#2020-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9279" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个星期五的下午，我收到一个传呼警报，说生产中的一个查询需要60多秒才能执行。它看起来是这样的:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="e40d" class="ku kv iq kq b gy kw kx l ky kz">SELECT * <br/>FROM <strong class="kq ir">user_profile_attributes</strong> <br/>WHERE <strong class="kq ir">user_id</strong> IN (...);</span></pre><p id="e72d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么这个查询很慢，尽管<code class="fe la lb lc kq b"><strong class="jp ir">user_id</strong></code>被索引了？这个问题使我困惑。我浏览了PostgreSQL文档，一些堆栈溢出的帖子，终于明白了为什么。</p><p id="c769" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文将解释为什么尽管有索引列,“in”条件运行缓慢。您将了解查询规划器如何处理查询中的一个或多个关系。接近尾声时，它还会提到一些你可以避免它的方法。</p><h2 id="720f" class="ku kv iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">先决条件</h2><p id="b96f" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">要想很好地理解这篇文章，你必须知道:</p><ul class=""><li id="ca17" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">基本SQL</li><li id="9385" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">主键在表中总是被索引为<em class="mn"/>。</li><li id="ffb4" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">表中的顺序扫描意味着按顺序对每个记录进行验证</li><li id="2e4e" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">B树上搜索和顺序扫描的算法时间复杂度</li><li id="886e" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">复合索引基于前缀进行索引。</li><li id="d008" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">为什么搜索复杂性很重要，并能理解复杂性分析</li></ul><p id="44ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安全了。让我们通过一个例子来理解查询规划器的工作原理。</p><h1 id="16bd" class="mo kv iq bd ld mp mq mr lg ms mt mu lj mv mw mx lm my mz na lp nb nc nd ls ne bi translated">例子</h1><p id="5924" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">我有一个包含以下模式的表<code class="fe la lb lc kq b">user_profile_attributes</code></p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="a5e0" class="ku kv iq kq b gy kw kx l ky kz">Column    | Type                   | Modifiers<br/>user_id   | integer                | not null<br/>key       | character varying(255) | not null<br/>value     | text                   | </span><span id="6d6a" class="ku kv iq kq b gy nf kx l ky kz">Indexes:<br/>    "user_profile_attributes_pkey" PRIMARY_KEY, btree (user_id)</span></pre><p id="88b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe la lb lc kq b">user_id</code>是主键。</p><p id="05b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个表包含大约64k行。</p><figure class="kl km kn ko gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ng"><img src="../Images/2c49f199df7196e9866c078f8739fafb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9avjOG4J6caKHgHD6m43w.png"/></div></div></figure><h2 id="23ef" class="ku kv iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">问题</h2><p id="5773" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">如果我查询大量的用户id(大约5000个)，那么查询运行非常慢，没有利用索引。</p><p id="0b57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个示例查询的样子:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="917c" class="ku kv iq kq b gy kw kx l ky kz">SELECT * <br/>FROM user_profile_attributes <br/>WHERE user_id IN ('abc', 'xyz');</span></pre><h1 id="f13c" class="mo kv iq bd ld mp mq mr lg ms mt mu lj mv mw mx lm my mz na lp nb nc nd ls ne bi translated">了解查询规划器📖</h1><p id="7a4a" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">PostgreSQL使用查询规划器来决定如何运行查询。为了理解什么是查询的搜索复杂度，我们需要知道PostgreSQL计划如何运行查询。</p><h2 id="95c3" class="ku kv iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">查询规划器</h2><p id="5163" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">计划者创建一个最佳的执行计划。给定的SQL查询(以及查询树)实际上可以以多种不同的方式执行，每种方式都会产生相同的结果集。它将检查每一个可能的执行计划，最终选择预计运行最快的执行计划。</p><h2 id="80ef" class="ku kv iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">计划</h2><ol class=""><li id="1cab" class="lz ma iq jp b jq lu ju lv jy no kc np kg nq kk nr mf mg mh bi translated">默认情况下，会生成顺序扫描计划。</li><li id="8703" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk nr mf mg mh bi translated">如果该列有可用的索引，则使用B树索引创建另一个计划来扫描关系。</li></ol><p id="6f67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个计划都有一个成本试探法，计划者选择成本最低的计划。启发法不一定每次都适用，计划者可以选择一个次优的计划。例如，<em class="mn">规划者可能会选择顺序扫描而不是索引扫描</em>(您将在下文提到的示例中看到)</p><h2 id="22e4" class="ku kv iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">2个或更多关系的计划</h2><p id="76b6" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">如果查询需要连接两个或多个关系，那么在为扫描单个关系找到所有可行的计划之后，考虑连接关系的计划。</p><figure class="kl km kn ko gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ns"><img src="../Images/b99a055fd123dae0980df6a63ed54259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4z6NKi0hw3Q2Iinc-1i7aw.jpeg"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">加入策略</figcaption></figure><p id="90f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">三种可用的连接策略是:</p><ul class=""><li id="dd0e" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated"><strong class="jp ir"> <em class="mn">嵌套循环连接</em> </strong>:对于左关系中找到的每一行，右关系扫描一次。这种策略很容易实现，但是非常耗时。然而，如果可以用索引扫描来扫描正确的关系，那么这可能是一个好策略。可以使用左关系当前行的值作为右关系索引扫描的键。</li><li id="7d6e" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated"><strong class="jp ir"> <em class="mn">合并连接</em> </strong>:在连接开始之前，每个关系按照连接属性进行排序。然后并行扫描这两个关系，并将匹配的行组合起来形成连接行。这种连接更有吸引力，因为每个关系只需扫描一次。所需的排序可以通过显式排序步骤来实现，也可以通过使用连接键上的索引以正确的顺序扫描关系来实现。</li><li id="dc79" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated"><strong class="jp ir"> <em class="mn"> Hash join </em> </strong>:首先扫描右关系，并将其加载到哈希表中，使用其join属性作为哈希键。接下来，扫描左边的关系，并将找到的每一行的适当值用作散列键来定位表中的匹配行。</li></ul><h2 id="ffa3" class="ku kv iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">查看这些计划的实施情况🔬</h2><p id="9731" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">在本帖中，我们将使用<code class="fe la lb lc kq b">EXPLAIN</code>来了解查询是否使用了任何索引或进行顺序扫描。我们将使用以下查询:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="4371" class="ku kv iq kq b gy kw kx l ky kz">SELECT * <br/>FROM user_profile_attributes <br/>WHERE user_id IN (<br/>    SELECT DISTINCT(user_id) <br/>    FROM user_profile_attributes <br/>    LIMIT n<br/>);</span></pre><p id="4ff1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该查询将获取用户id的所有记录。<br/>该语句有两个查询，一个嵌套在另一个中。我们将它们称为嵌套查询和父查询。</p><p id="fd14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们尝试为不同数量的用户运行查询，并分析行为。</p><p id="642c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">搜索1个用户id </strong></p><figure class="kl km kn ko gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nx"><img src="../Images/593083375d120c7d2e7a5261022a271f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlpgjAcsWjMofO_oxDvMtw.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">搜索1个用户id</figcaption></figure><p id="f122" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，这里有两个查询(关系)。规划者选择对<code class="fe la lb lc kq b">Nested Query</code>和<code class="fe la lb lc kq b">Parent Query</code>运行<em class="mn">索引扫描</em>，然后对二者执行<em class="mn">嵌套循环连接</em>。</p><p id="e6e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">搜索10个用户id</strong></p><figure class="kl km kn ko gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ny"><img src="../Images/b5a527e904c9aa627a182cc6ffeea39b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLHfoezcGm1czK8gCUGJjQ.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">搜索10个用户id</figcaption></figure><p id="f274" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">计划者选择了一个类似的计划，就像它为1个用户id所做的那样。</p><p id="42fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">搜索100和1000个用户id</strong></p><figure class="kl km kn ko gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nz"><img src="../Images/c38a130508d1bcf5c34e856efdecd103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEKK8bXT4j9VbNhDvGxcEQ.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">搜索100个用户id</figcaption></figure><figure class="kl km kn ko gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oa"><img src="../Images/c3e552e5081180d7955142c8b64cbc23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RbzLyfxFt6K8yOhiYZ1xeA.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">搜索1000个用户id</figcaption></figure><p id="192d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着记录数量的增加，计划程序在<code class="fe la lb lc kq b">Nested Query</code>上运行顺序扫描，在<code class="fe la lb lc kq b">Parent Query</code>上运行索引扫描。使用<em class="mn">散列连接</em>技术连接这两个关系。<br/></p><p id="5edd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">搜索5000个用户id</strong></p><figure class="kl km kn ko gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ob"><img src="../Images/18a27042703876e513806aded4ce6dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iX7UB-s3dL0ZCPgWfKkVGQ.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">搜索5000个用户id</figcaption></figure><p id="a142" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只要将用户id计数增加到5000，规划者就为<code class="fe la lb lc kq b">Nested Query</code>和<code class="fe la lb lc kq b">Parent Query</code>选择<em class="mn">顺序扫描</em>。使用<em class="mn">散列连接<br/> </em> <strong class="jp ir">将它们连接起来。注意:</strong>对于仅有的5000条记录，规划器选择了<em class="mn">顺序扫描，</em>因此不使用索引。</p><h2 id="fbee" class="ku kv iq bd ld le lf dn lg lh li dp lj jy lk ll lm kc ln lo lp kg lq lr ls lt bi translated">推理</h2><p id="f0dd" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">如果计划程序在“in”查询中发现大量记录，它将采用顺序扫描。这增加了查询时间，因为根本没有使用索引。</p><h1 id="0ae2" class="mo kv iq bd ld mp mq mr lg ms mt mu lj mv mw mx lm my mz na lp nb nc nd ls ne bi translated">替代ℹ️</h1><p id="6c11" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">有几种方法可以避免这种缓慢。</p><p id="47d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1。避免连续扫描<br/> </strong>规划器允许用户通过显示<code class="fe la lb lc kq b">enable_seqscan</code>标志来配置规划器行为。您不能禁用<em class="mn">顺序扫描</em>，但是关闭此标志，规划器将选择其他选项(如果可用)而不是<em class="mn">顺序扫描</em>。<br/>您可以通过运行以下命令来实现:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="d07e" class="ku kv iq kq b gy kw kx l ky kz">SET enable_seqscan = 'OFF';</span></pre><p id="d741" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关闭标志后，计划看起来是这样的</p><figure class="kl km kn ko gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi oc"><img src="../Images/374e2e823a162b42354904d7a0cafe6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GpKROlrhUkGCqKDWmzaGWQ.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">搜索5000个用户id</figcaption></figure><p id="6bdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">计划者为<code class="fe la lb lc kq b">Nested Query</code>和<code class="fe la lb lc kq b">Parent Query</code>选择了索引扫描。由于这两个关系需要被索引，所以使用<em class="mn">合并连接</em>来连接它们。点击阅读更多关于查询规划器配置<a class="ae od" href="https://www.postgresql.org/docs/9.5/runtime-config-query.html" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="6fb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:但是如果你不得不改变计划者的策略，你可能会后退一步，做些别的事情🤔。</p><p id="4dc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2 <strong class="jp ir">。你需要这么多数据的原因🤷🏻‍♀️ </strong> <br/>也许你一开始并不需要这么多数据，或者你可能只是在以后对这些数据进行汇总。在这些情况下，可能需要更少的数据和操作。例如，在我的例子中，我意识到我只需要用户的数量，而不是他们的详细信息，所以我最终放弃了这个查询😅。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="b8d0" class="mo kv iq bd ld mp ol mr lg ms om mu lj mv on mx lm my oo na lp nb op nd ls ne bi translated">进一步阅读</h1><ul class=""><li id="e28d" class="lz ma iq jp b jq lu ju lv jy no kc np kg nq kk me mf mg mh bi translated">详细阅读查询设计器—<a class="ae od" href="https://www.postgresql.org/docs/9.5/planner-optimizer.html" rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/docs/9.5/planner-optimizer.html</a></li><li id="44d3" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">了解基因查询优化—<a class="ae od" href="https://www.postgresql.org/docs/9.5/geqo-pg-intro.html" rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/docs/9.5/geqo-pg-intro.html</a></li></ul></div></div>    
</body>
</html>