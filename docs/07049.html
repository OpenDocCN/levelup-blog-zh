<html>
<head>
<title>Patterns for Coding Interviews — Tree Depth-first Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码面试的模式——树形深度优先搜索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/patterns-for-coding-interviews-tree-depth-first-search-9e567ae2b696?source=collection_archive---------9-----------------------#2021-01-20">https://levelup.gitconnected.com/patterns-for-coding-interviews-tree-depth-first-search-9e567ae2b696?source=collection_archive---------9-----------------------#2021-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec60" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过学习算法模式赢得任何编码面试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/80456d3cf61e5077f4d2051a2dab07a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-vww1zIg6T-6GzTw"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@nordwood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">诺德伍德主题</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="dd95" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="640e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">树DFS模式是一种在树内搜索时应用DFS技术的算法。该模式的特点是在回溯之前尽可能远地遍历每个树分支。它可以以迭代或递归的方式实现。本文将主要集中讨论递归方法。</p><h1 id="5073" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">方法</h1><p id="8477" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在开始之前，让我们回忆一下三种遍历树的方法，它们是前序、按序和后序。它们的模板如下所示:</p><p id="10ab" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">前序遍历</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/84c75b0b576bd1cc4e7f7bd4878144d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZF7vO4C1Uc8tzULZxUGxog.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2f7e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">有序遍历</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/14a974a4c258504bae1743a966acb2ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ec1lpIpfLerdPWRrtN7sug.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e11b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">后序遍历</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/fd35711ef1c25061d2ec0d17d1bd868d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFzGT9bQYX4EPeOVmLg83w.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f4e5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请记住这三个问题，它们中的任何一个都可以解决大多数树DFS问题。</p><p id="ad50" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们开始吧。我们先来看看Leetcode简单问题<a class="ae ky" href="https://leetcode.com/problems/path-sum" rel="noopener ugc nofollow" target="_blank">路径和</a>作为热身。这个问题的主要目标是看是否有一条路径(根到叶)的和等于给定的数。下面提供了一个例子:</p><p id="c90f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">给出下面的二叉树和<code class="fe mv mw mx my b">sum = 22</code>，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="19f8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">返回true，因为存在一条从根到叶的路径<code class="fe mv mw mx my b">5-&gt;4-&gt;11-&gt;2</code>，其总和为22。</p><p id="6ef7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我们前面提到的，大多数树DFS问题可以通过按序、前序或后序遍历来解决。因此，解决这个问题的第一步是决定我们应该应用哪种遍历。</p><p id="0d36" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">很明显，有序遍历是一种更合适的方式，因为路径包含从根到叶的节点，这是一种自顶向下的遍历。因此，算法过程将是这样的:</p><ol class=""><li id="7b8a" class="mz na it lt b lu mn lx mo ma nb me nc mi nd mm ne nf ng nh bi translated">查看当前节点是否是叶子，以及累积和(即路径和)是否等于我们的目标。</li><li id="6b25" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">递归计算左右子树的路径和。</li></ol><p id="d856" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">实现如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6247" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你看到图案了吗？也许仅仅举一个例子是不够的。让我们试试一个高级的— <a class="ae ky" href="https://leetcode.com/problems/validate-binary-search-tree" rel="noopener ugc nofollow" target="_blank">验证二叉查找树</a>。这个问题要求我们确定一个二叉树是否是一个有效的BST。参见下面的一些例子:</p><p id="e7c1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">例1: </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7201" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">例2: </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6f8f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">想想你在大脑里会怎么做。我相信大多数人会首先以根节点作为参考，并将其与左右子树中的节点进行比较。</p><p id="54b1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">永远记住解决树DFS问题的第一步是决定你想应用哪种遍历。上面说的思路很明显就是有序遍历(根→左→右)法。</p><p id="1245" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们可以深入这个算法的主要部分。注意BST的定义:</p><blockquote class="nn no np"><p id="f01a" class="lr ls nq lt b lu mn ju lw lx mo jx lz nr mp mc md ns mq mg mh nt mr mk ml mm im bi translated">假设BST定义如下:<br/> -节点的左子树只包含键<strong class="lt iu">小于节点键</strong>的节点。<br/> -节点的右子树只包含键<strong class="lt iu">大于节点键</strong>的节点。<br/> -左右子树也必须是二分搜索法树。</p></blockquote><p id="17a2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果只比较节点及其左右子树，而不比较左右子树，下面显示的情况将返回错误答案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d8f1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了避免上面描述的情况，我们应该记录根节点的值，以便在每次遍历过程中进行比较。因此，实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="f9de" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="d45e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">总之，树形DFS技术(递归)的过程可以分为如下几个步骤:</p><ol class=""><li id="c7fd" class="mz na it lt b lu mn lx mo ma nb me nc mi nd mm ne nf ng nh bi translated">确定哪种树遍历方法更适合解决问题。</li><li id="de62" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">找出递归过程的基本情况(例如root == null)。</li><li id="3b78" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">应用确定的遍历方法定义主(根)和子问题(左右子树)之间的关系。</li></ol></div></div>    
</body>
</html>