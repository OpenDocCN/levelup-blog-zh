<html>
<head>
<title>Async load an audio file and play it with howler.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步加载一个音频文件并用howler.js播放</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/async-load-an-audio-file-and-play-it-with-howler-js-fefc4f537656?source=collection_archive---------7-----------------------#2020-08-15">https://levelup.gitconnected.com/async-load-an-audio-file-and-play-it-with-howler-js-fefc4f537656?source=collection_archive---------7-----------------------#2020-08-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a5b7790be2ef35e08d17726d08b28a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXMoRwhgPNxNpd0D7hUU9w.jpeg"/></div></div></figure><p id="7b19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如何使用XHR将二进制文件下载到Javascript对象中。</p><p id="6812" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文以<a class="ae la" href="https://github.com/nzcodarnoc/korerorero-front-end/tree/v0.3.1" rel="noopener ugc nofollow" target="_blank"> Korerorero </a>项目为例。Korerorero是一个带有语音识别的动画聊天机器人的开源实现。</p><p id="52cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了实现聊天机器人的语音，语音音频由<a class="ae la" href="https://github.com/nzcodarnoc/korerorero-marytts" rel="noopener ugc nofollow" target="_blank">koerrorero-Mary TTS</a>服务创建。这些数据需要异步下载，然后存储在内存中，并传递到音频播放器库。<a class="ae la" href="https://github.com/goldfire/howler.js/" rel="noopener ugc nofollow" target="_blank"> howler.js </a>音频库需要文件的URL。</p><p id="3e3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了设置阶段，API已经返回了要下载的WAV文件的URL。下面的代码向音频服务发起一个<code class="fe lb lc ld le b">GET</code>请求，并将结果<code class="fe lb lc ld le b">arraybuffer</code>存储在内存中。这个<code class="fe lb lc ld le b">arraybuffer</code>然后被分派到<code class="fe lb lc ld le b">recieveAudio(…)</code>动作。</p><p id="7ea7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注:<a class="ae la" href="https://github.com/nzcodarnoc/korerorero-front-end/tree/v0.3.1" rel="noopener ugc nofollow" target="_blank">koreroro-前端</a>使用<a class="ae la" href="https://github.com/reduxjs/redux" rel="noopener ugc nofollow" target="_blank"> redux </a>进行状态管理，<a class="ae la" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>进行网络通信，<a class="ae la" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>进行异步管理。</p><h2 id="cf92" class="lf lg it bd lh li lj dn lk ll lm dp ln km lo lp lq kq lr ls lt ku lu lv lw lx bi translated">response.ts(用XHR获得二进制)</h2><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="be2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">来源:</em><a class="ae la" href="https://github.com/nzcodarnoc/korerorero-front-end/blob/v0.3.1/src/redux/actions/response.ts" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://github . com/nzcodarnoc/koerrorero-front-end/blob/v 0 . 3 . 1/src/redux/actions/response . ts</em></a></p><h2 id="676e" class="lf lg it bd lh li lj dn lk ll lm dp ln km lo lp lq kq lr ls lt ku lu lv lw lx bi translated">response.ts(文件同上)</h2><figure class="ly lz ma mb gt ju"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="ca84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为howler.js需要一个文件引用，上面的代码创建了一个<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL" rel="noopener ugc nofollow" target="_blank">对象URL </a>，这是一个引用存储音频的内存位置的URL。它们看起来像这样:</p><pre class="ly lz ma mb gt me le mf mg aw mh bi"><span id="0243" class="lf lg it le b gy mi mj l mk ml">&gt; URL.createObjectURL(new Blob())<br/>&lt; "blob:<a class="ae la" href="https://developer.mozilla.org/d2c2bedd-af4e-4ea8-a4c2-7cfe25884e5d" rel="noopener ugc nofollow" target="_blank">https://www.example.com/d2c2bedd-af4e-4ea8-a4c2-7cfe25884e5d</a>"</span></pre><p id="7d45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它们可以用在任何需要URL的地方，比如<code class="fe lb lc ld le b">audio</code>标签的<code class="fe lb lc ld le b">src</code>属性。</p><h2 id="1aa9" class="lf lg it bd lh li lj dn lk ll lm dp ln km lo lp lq kq lr ls lt ku lu lv lw lx bi translated">避免内存泄漏</h2><p id="d014" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">根据<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL" rel="noopener ugc nofollow" target="_blank">文档</a>的说法，内存需要手动管理，这对于长期的<a class="ae la" href="https://en.wikipedia.org/wiki/Single-page_application" rel="noopener ugc nofollow" target="_blank">spa</a>来说尤其重要，对于与台式机相比内存通常有限的移动平台来说更是如此。</p><blockquote class="mr ms mt"><p id="af6f" class="kb kc kz kd b ke kf kg kh ki kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ky im bi translated">当你不再需要它们时，必须通过调用<code class="fe lb lc ld le b"><a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL" rel="noopener ugc nofollow" target="_blank">URL.revokeObjectURL()</a></code>来释放它们。</p></blockquote><p id="9fc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">亲爱的读者，在写这篇文章的时候，我还没有实现这个重要的内存释放，所以这个应用程序有内存泄漏。猜猜看，我的待办事项列表的第一位是什么？</p></div></div>    
</body>
</html>