<html>
<head>
<title>How to Get the Intersection of Two Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何获得两个数组的交集</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-get-the-intersection-of-two-arrays-fed7e5138eea?source=collection_archive---------6-----------------------#2020-08-22">https://levelup.gitconnected.com/how-to-get-the-intersection-of-two-arrays-fed7e5138eea?source=collection_archive---------6-----------------------#2020-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="58ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，面试官会在看似简单的事情上测试你。我们在<a class="ae ko" href="https://algodaily.com/challenges/reverse-a-string" rel="noopener ugc nofollow" target="_blank">反转一串</a>中看到了这一点，并将在未来的挑战中看到更多。但是有时你可能会在一个概念上被测试，虽然这个概念有点琐碎，但是在日常的软件工程中非常有用。</p><p id="4ded" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中之一就是<code class="fe kp kq kr ks b">array manipulation</code>，或者说基本上是按照<code class="fe kp kq kr ks b">array</code>做事情，从而产生某种转变。</p><h1 id="3159" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">提示</h1><p id="61a7" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">你能写一个函数让<strong class="js iu">把两个数组作为输入</strong>并返回给我们它们的交集吗？让我们以数组的形式返回交集。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/e63fd0761c6a076c10d5c776ef559ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Hyq2r7w-bjBN_mX1.png"/></div></div></figure><p id="8950" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，最终结果中的所有元素都应该是唯一的。这里有一个例子:</p><pre class="lx ly lz ma gt mi ks mj mk aw ml bi"><span id="11b7" class="mm ku it ks b gy mn mo l mp mq">const nums1 = [1, 2, 2, 1];<br/>const nums2 = [2, 2];</span><span id="bf18" class="mm ku it ks b gy mr mo l mp mq">intersection(nums1, nums2);<br/>// [2]</span></pre><p id="ced6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是另一个:</p><pre class="lx ly lz ma gt mi ks mj mk aw ml bi"><span id="f84e" class="mm ku it ks b gy mn mo l mp mq">const nums1 = [4,9,5];<br/>const nums2 = [9,4,9,8,4];</span><span id="ecfb" class="mm ku it ks b gy mr mo l mp mq">intersection(nums1, nums2);<br/>// [9, 4]</span></pre><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1a73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mu">这一课最初发表在https://algodaily.com</em><em class="mu">的</em> <a class="ae ko" href="https://algodaily.com/challenges/array-intersection" rel="noopener ugc nofollow" target="_blank"> <em class="mu">上，我在那里开设了一门技术面试课程，并为雄心勃勃的开发人员撰写思考文章。</em></a></p><h1 id="81f3" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">蛮力</h1><p id="bd11" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">我们将慢慢开始，通过使用尽可能最小的样本输入来检查问题的构成。我们知道我们需要一个<code class="fe kp kq kr ks b">result</code>数组来返回，所以记住这一点:</p><pre class="lx ly lz ma gt mi ks mj mk aw ml bi"><span id="17b4" class="mm ku it ks b gy mn mo l mp mq">const results = [];</span></pre><p id="cfc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们需要找到两个数组的交集:<code class="fe kp kq kr ks b">[1]</code>和<code class="fe kp kq kr ks b">[1]</code>。在这种情况下，我们知道输出也是<code class="fe kp kq kr ks b">[1]</code>——这相当简单，因为我们只需要直接比较<code class="fe kp kq kr ks b">1</code>和<code class="fe kp kq kr ks b">1</code>。我们通过第一个<code class="fe kp kq kr ks b">[1]</code>，看到<code class="fe kp kq kr ks b">1</code>，并在第二个数组中定位它。因为它们是相同的，所以我们只返回一个匹配的<code class="fe kp kq kr ks b">result</code>。</p><p id="2f2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我们需要超越这一点。假设两个输入被修改为<code class="fe kp kq kr ks b">[1]</code>和<code class="fe kp kq kr ks b">[2]</code>。当我们比较这两个元素时，我们知道它们是不一样的。因此，我们不需要对<code class="fe kp kq kr ks b">result</code>做任何事情。</p><p id="3d9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当这种情况持续到一个数组元素之外时，我们可以继续检查第一个数组中的每个元素是否都存在于第二个数组中。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mv"><img src="../Images/afb384465b9980f96b986ad116e4faba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zEM5nx5KXwei0xrq.png"/></div></div></figure><pre class="lx ly lz ma gt mi ks mj mk aw ml bi"><span id="ab48" class="mm ku it ks b gy mn mo l mp mq">let intersection = firstArray.filter((el) =&gt; {<br/>  return secondArray.includes(el);<br/>};</span></pre><p id="4d30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">交集的概念是来自集合论，所以这个问题如果只是用<code class="fe kp kq kr ks b">Set</code> s的话真的很简单！在数学中，两个集合A和B的交集是包含A中也属于B的所有元素的集合。</p><p id="aa74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是大多数语言中的一种对象类型，允许你存储大多数原语的唯一值。</p><p id="d386" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们将输入数组转换成集合，我们可以利用<code class="fe kp kq kr ks b">filter</code>方法，并将其应用于其中一个集合——过滤掉不在另一个集合中的任何东西。</p><pre class="lx ly lz ma gt mi ks mj mk aw ml bi"><span id="cf34" class="mm ku it ks b gy mn mo l mp mq">function intersection(nums1, nums2) {<br/>  const set = new Set(nums1);<br/>  const fileredSet = new Set(nums2.filter((n) =&gt; set.has(n)));<br/>  return [ ...fileredSet ];<br/>}</span></pre><p id="f055" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将有一个<code class="fe kp kq kr ks b">O(n)</code>的时间复杂度。</p><p id="8447" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种方法是不使用<code class="fe kp kq kr ks b">Set</code>并保留数组来模拟输入。使用这种方法，我们还需要一个哈希<code class="fe kp kq kr ks b">Object</code>来确保唯一性。这是因为对象键必须是唯一的。</p><p id="2206" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过执行<code class="fe kp kq kr ks b">indexOf</code>检查来收集唯一的交集，然后以数组形式返回:</p><pre class="lx ly lz ma gt mi ks mj mk aw ml bi"><span id="aee3" class="mm ku it ks b gy mn mo l mp mq">function intersection(nums1, nums2) {<br/>  let intersection = {};</span><span id="fbeb" class="mm ku it ks b gy mr mo l mp mq">  for (const num of nums1) if (nums2.indexOf(num) !== -1) intersection[num] = 1;</span><span id="6109" class="mm ku it ks b gy mr mo l mp mq">  return Object.keys(intersection).map((val) =&gt; parseInt(val));<br/>}</span></pre><p id="a542" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管有两种方法，但如果你在面试中遇到类似的问题，使用<code class="fe kp kq kr ks b">Set</code>可能会有所帮助。这是因为它展示了常用的<code class="fe kp kq kr ks b">data structure</code>知识和数学背景。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="12f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">查看AlgoDaily.com的<a class="ae ko" href="https://algodaily.com/curriculum" rel="noopener ugc nofollow" target="_blank">技术挑战的更多可视化教程，并尝试</a><a class="ae ko" href="https://algodaily.com/challenges/daily" rel="noopener ugc nofollow" target="_blank">我们的每日编码问题简讯</a>！</p></div></div>    
</body>
</html>