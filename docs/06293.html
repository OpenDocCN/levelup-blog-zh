<html>
<head>
<title>React &amp; D3: Rendering A Map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React &amp; D3:渲染地图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-d3-rendering-a-map-5e006b2f4895?source=collection_archive---------3-----------------------#2020-11-12">https://levelup.gitconnected.com/react-d3-rendering-a-map-5e006b2f4895?source=collection_archive---------3-----------------------#2020-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/78b1074ff6bca57c5de8e3363abd24dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBNie05HRtNQh8uhi2d2RA.png"/></div></div></figure><p id="6795" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自从我发现了D3，我立刻就被它的所有功能迷住了。它是作为一个低级的JavaScript数据可视化库而构建的，这意味着你可以在屏幕上构建、渲染和交互的内容只受到你的想象力的限制。它也是Github上使用最广泛的JavaScript数据viz库之一，拥有超过95k颗星。</p><p id="14d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">早在2015年，我从GA的WDI(网络开发沉浸式)项目毕业后，我就认真研究了几年，甚至在2018年，在他们的纽约校园里举办了一次每周聚会。</p><p id="565c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2016年，我被GA聘用，教授我的第一个WDI项目，我需要学习React pronto，因为我的团队决定将它纳入我们的课程。我对React了解得越多，我就越感兴趣，因为要求掌握所有内容，D3被搁置了。</p><p id="2953" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">直到最后几个月，我决定最终跳回D3，并决定重构我以前构建的名为<a class="ae kw" href="https://codepen.io/jkeohan/project/full/ZvKkKE" rel="noopener ugc nofollow" target="_blank">街球圣地</a>的D3仪表板项目。</p><p id="9ebd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种重构大部分涉及替换D3来创建和/或更新/删除元素，并将其交给React。Reacts的优势之一是管理状态，所以最初选择了<strong class="ka ir"> useState </strong>，但后来将其重构为<strong class="ka ir"> useReducer </strong>，因为它是管理状态和复杂业务逻辑的更好选择。最后，为了便于管理，我将设计分成越来越小的组件。</p><h2 id="d1b1" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated"><strong class="ak">整合D3并做出反应</strong></h2><p id="a1c2" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">集成React和D3需要决定给D3多少控制权，或者从D3拿走多少控制权，因为D3和React都希望完全控制DOM。</p><p id="d40b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是你应该考虑的3种基本方法:</p><ul class=""><li id="efca" class="lv lw iq ka b kb kc kf kg kj lx kn ly kr lz kv ma mb mc md bi translated">React中的D3——React呈现一个svg，D3完成所有其他工作</li><li id="12d3" class="lv lw iq ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">D3独特的方法(比例、轴、投影等..)并对管理状态和更新DOM做出反应</li><li id="a636" class="lv lw iq ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">使用第三方React/D3库，比如像<a class="ae kw" href="https://nivo.rocks/#/" rel="noopener ugc nofollow" target="_blank"> Nivo </a>这样的高级库或者像<a class="ae kw" href="https://vx-demo.now.sh/https://vx-demo.now.sh/" rel="noopener ugc nofollow" target="_blank"> VX </a>这样的低级库。</li></ul><p id="e8fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每种方法都有其优点/缺点，最终归结为你最精通哪种技术，D3还是React。</p><h2 id="d28e" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">反应中的D3</h2><p id="db55" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">起初，我在React 方法中采用了<strong class="ka ir"> D3，因为这是移植现有代码库的最简单方法。在这一点上，我精通这两个库，但是将这两个库结合起来是一个新的尝试，需要一些研究和许多考验。</strong></p><p id="4407" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我检查了最初的设计后，我决定将D3限制在仅仅是<strong class="ka ir">地图、圆圈</strong>和<strong class="ka ir">条形图(包括x轴)</strong>，并允许React渲染所有其他元素。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/5ec61c4596b564b980631057a351d13b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-C6lKlZ5uBI5Y5kwqbaN4A.png"/></div></div></figure><h2 id="7260" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">D3地图组件</h2><p id="242f" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">对于地图，我主要是复制了<strong class="ka ir">的renderChart </strong>函数，并创建了一个对svg的<strong class="ka ir">引用(引用)</strong>。React中的Ref只是对DOM节点或JavaScript值的引用。在svg的用例中，我将其等同于使用<strong class="ka ir"> document.querySelector </strong>抓取<strong class="ka ir"> </strong>一个DOM元素。另一方面，将ref分配给JS值是为了在一个或多个状态变化期间保持该值。</p><p id="db2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ref是一个对象，它存储分配给当前键<strong class="ka ir">的值，然后将该值传递给<strong class="ka ir"> d3.select() </strong>以获取DOM元素。</strong></p><p id="faed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里使用<strong class="ka ir"> useRef </strong>钩子实例化ref，然后使用<strong class="ka ir"> ref={svgRef}将<strong class="ka ir"> svgRef </strong>分配给svg元素。</strong></p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="1255" class="kx ky iq mp b gy mt mu l mv mw">import React from 'react'<br/>import * as d3 from 'd3'</span><span id="0f14" class="kx ky iq mp b gy mx mu l mv mw">const Map = (props) =&gt; {</span><span id="9360" class="kx ky iq mp b gy mx mu l mv mw">   //////////////////////////////////////////////////////<br/>   // REFs<br/>   //////////////////////////////////////////////////////</span><span id="36cc" class="kx ky iq mp b gy mx mu l mv mw">   const svgRef = useRef();  </span><span id="af48" class="kx ky iq mp b gy mx mu l mv mw">   ////////////////////////////////////////////////////// <br/>   // RENDER THE CHART USING D3<br/>   //////////////////////////////////////////////////////   </span><span id="5dcc" class="kx ky iq mp b gy mx mu l mv mw">   const renderChart = (nyc, path) =&gt; {<br/>     d3.select(svgRef.current)<br/>      //...additional d3 code...<br/>   };</span><span id="dfd3" class="kx ky iq mp b gy mx mu l mv mw">    ////////////////////////////////////////////////////// <br/>    // RENDER THE SVG<br/>    //////////////////////////////////////////////////////</span><span id="cdd2" class="kx ky iq mp b gy mx mu l mv mw">   return(    <br/>     &lt;svg id="boroughs-map" ref={svgRef}&gt;&lt;/svg&gt;<br/>   )<br/>}</span></pre><p id="dd20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后为D3投影实例化了另一个ref，在本例中是<strong class="ka ir"> d3.geoMercator()。</strong>在本例中，它被用作功能组件中的<strong class="ka ir">实例变量</strong>，因为该值将在组件生命周期的不同时间被地图和圆圈引用。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="2445" class="kx ky iq mp b gy mt mu l mv mw">//////////////////////////////////////////////////////<br/>// REFs<br/>//////////////////////////////////////////////////////<br/>const svgRef = useRef()<br/>const projRef = useRef(d3.geoMercator()<br/>   .center([-73.93, 40.72]).scale(57500));</span></pre><p id="0ed5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> useEffect </strong> is <strong class="ka ir"> </strong>然后用于抓取用于使投影居中的svg的高度/宽度。<strong class="ka ir"> useEffect </strong>在这里被实现为一个<strong class="ka ir"> componentDidUpdate </strong>生命周期方法，它有一个<strong class="ka ir">依赖项。</strong>依赖关系值的任何变化都会导致<strong class="ka ir"> useEffect </strong>方法<strong class="ka ir"> </strong>重新运行。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7d14" class="kx ky iq mp b gy mt mu l mv mw">//////////////////////////////////////////////////////<br/>// USEEFFECT AS COMPONENTDIDUPDATE WITH DEPENDENCY<br/>//////////////////////////////////////////////////////<br/>useEffect(() =&gt; {</span><span id="cf58" class="kx ky iq mp b gy mx mu l mv mw">  const height = svgRef.current.clientHeight<br/>  const width = svgRef.current.clientWidth</span><span id="43dd" class="kx ky iq mp b gy mx mu l mv mw">  projRef.current.translate([width  / 2, height  / 2 ]);</span><span id="86e1" class="kx ky iq mp b gy mx mu l mv mw">}, [data])</span></pre><p id="508d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">投影是D3特有的，它定义了地图将如何显示。D3带有各种带有<strong class="ka ir">的凸起。geometric ator()</strong>最常用。在这个特殊的用例中，需要使用<strong class="ka ir">平移</strong>来居中，这需要高度/宽度值。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="294b" class="kx ky iq mp b gy mt mu l mv mw">//////////////////////////////////////////////////////<br/>// USEEFFECT AS COMPONENTDIDUPDATE WITH DEPENDENCY<br/>//////////////////////////////////////////////////////<br/>useEffect(() =&gt; {</span><span id="8729" class="kx ky iq mp b gy mx mu l mv mw">   const height = svgRef.current.clientHeight<br/>   const width = svgRef.current.clientWidth</span><span id="697e" class="kx ky iq mp b gy mx mu l mv mw">   projRef.current.translate([width  / 2, height  / 2 ]);</span><span id="a82a" class="kx ky iq mp b gy mx mu l mv mw">}, [data])</span></pre><p id="e90d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后将投影传递给<strong class="ka ir"> d3.geoPath() </strong>来绘制实际的svg路径，这些路径定义了地图中行政区的形状。我还包含了一个<strong class="ka ir"> if </strong>语句，该语句仅在有实际数据要渲染时将地图数据和路径传递给renderChart。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="b069" class="kx ky iq mp b gy mt mu l mv mw">//////////////////////////////////////////////////////<br/>// USEEFFECT AS COMPONENTDIDUPDATE WITH DEPENDENCY<br/>//////////////////////////////////////////////////////<br/>useEffect(() =&gt; {</span><span id="2ae6" class="kx ky iq mp b gy mx mu l mv mw">   const height = svgRef.current.clientHeight<br/>   const width = svgRef.current.clientWidth</span><span id="cdf8" class="kx ky iq mp b gy mx mu l mv mw">   projRef.current.translate([width  / 2, height  / 2 ]);</span><span id="ccd7" class="kx ky iq mp b gy mx mu l mv mw">   const path = d3.geoPath().projection(projeRef.current)</span><span id="18a5" class="kx ky iq mp b gy mx mu l mv mw">   if (data.length) {<br/>     renderChart(data[0], path)<br/>   }</span><span id="2f1c" class="kx ky iq mp b gy mx mu l mv mw">}, [data])</span></pre><p id="f9dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是目前为止所有的代码。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d846" class="kx ky iq mp b gy mt mu l mv mw">//////////////////////////////////////////////////////<br/>// REFs<br/>//////////////////////////////////////////////////////<br/>const svgRef = useRef()<br/>const projRef = useRef(d3.geoMercator()<br/>   .center([-73.93, 40.72]).scale(57500));</span><span id="352a" class="kx ky iq mp b gy mx mu l mv mw">//////////////////////////////////////////////////////<br/>// USEEFFECT AS COMPONENTDIDUPDATE WITH DEPENDENCY<br/>//////////////////////////////////////////////////////<br/>useEffect(() =&gt; {</span><span id="132a" class="kx ky iq mp b gy mx mu l mv mw">   const height = svgRef.current.clientHeight<br/>   const width = svgRef.current.clientWidth</span><span id="22ed" class="kx ky iq mp b gy mx mu l mv mw">    projRef.current.translate([width  / 2, height  / 2 ]);</span><span id="44d4" class="kx ky iq mp b gy mx mu l mv mw">   const path = d3.geoPath().projection(projeRef.current)</span><span id="fe03" class="kx ky iq mp b gy mx mu l mv mw">   if (data.length) {<br/>     renderChart(data[0].features, path)<br/>   }</span><span id="99a1" class="kx ky iq mp b gy mx mu l mv mw">}, [data])</span></pre><p id="9458" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至于<strong class="ka ir"> renderChart </strong>函数，它只有8行实际代码，全部是D3:</p><ul class=""><li id="1e32" class="lv lw iq ka b kb kc kf kg kj lx kn ly kr lz kv ma mb mc md bi translated">数据绑定— <strong class="ka ir">。数据(data) </strong></li><li id="47e6" class="lv lw iq ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">数据输入— <strong class="ka ir">。回车()</strong></li><li id="99e4" class="lv lw iq ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">追加数据<strong class="ka ir"> —。追加('路径')</strong></li><li id="8c99" class="lv lw iq ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">附加属性-。<strong class="ka ir">属性(' d '，路径)</strong></li><li id="e430" class="lv lw iq ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">附加样式-。<strong class="ka ir"> style('fill '，(d)=&gt;boroughLegend(d . properties . borough))</strong></li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="fdf1" class="kx ky iq mp b gy mt mu l mv mw">const renderChart = (data, path) =&gt; {<br/>   d3.select(svgRef.current).selectAll('path')<br/>     .data(data).enter().append('path')<br/>     .attr('class', (d) =&gt; d.properties.name)<br/>     .attr('d', path)<br/>     .style(‘fill’, (d) =&gt; boroughLegend(d.properties.borough))<br/>};</span></pre><h2 id="7290" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">D3用于数学，React用于DOM</h2><p id="2b2b" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">虽然这可以渲染地图，但我知道D3代码的某些部分可以用React代替。所以问题是React可以很容易地呈现哪些元素，答案非常清楚，即<strong class="ka ir">路径</strong>元素。</p><p id="7f31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，需要进行以下重构:</p><ul class=""><li id="0d00" class="lv lw iq ka b kb kc kf kg kj lx kn ly kr lz kv ma mb mc md bi translated">创建一个新的ref来存储d3.geoPath()的值—这是因为我决定将条件逻辑从useEffect移到return语句中</li><li id="95e2" class="lv lw iq ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">更新useEffect以更新新的pro</li><li id="76c6" class="lv lw iq ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">使用。map()迭代数据，创建路径元素，并为它们分配所需的属性</li><li id="46ff" class="lv lw iq ka b kb me kf mf kj mg kn mh kr mi kv ma mb mc md bi translated">如果有数据，请在组件返回语句中使用条件逻辑来呈现路径</li></ul><p id="138a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加新的ref几乎不费吹灰之力。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="f50f" class="kx ky iq mp b gy mt mu l mv mw">//////////////////////////////////////////////////////<br/>// REFs<br/>//////////////////////////////////////////////////////<br/>const svgRef = useRef()<br/>const projRef = useRef(d3.geoMercator()<br/>   .center([-73.93, 40.72]).scale(57500));<br/>const pathRef = useRef()</span></pre><p id="9499" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更新useEffect中的pathRef也没什么大不了的。我还通过移除条件逻辑来稍微清理了一下<strong class="ka ir"> useEffect </strong>。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="ac5d" class="kx ky iq mp b gy mt mu l mv mw">//////////////////////////////////////////////////////<br/>// USEEFFECT AS COMPONENTDIDUPDATE WITH DEPENDENCY<br/>//////////////////////////////////////////////////////<br/>useEffect(() =&gt; {</span><span id="6e11" class="kx ky iq mp b gy mx mu l mv mw">  const height = svgRef.current.clientHeight<br/>  const width = svgRef.current.clientWidth</span><span id="52f6" class="kx ky iq mp b gy mx mu l mv mw">   projRef.current.translate([width  / 2, height  / 2 ]);</span><span id="8fc9" class="kx ky iq mp b gy mx mu l mv mw">   pathRef.current = d3.geoPath().projection(projRef.current);</span><span id="5906" class="kx ky iq mp b gy mx mu l mv mw">}, [data])</span></pre><p id="e4ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">renderChart() 需要最大的努力，但我甚至不会走那么远。它所做的只是用数组映射替换了<strong class="ka ir"> D3的数据绑定</strong>和<strong class="ka ir"> enter </strong>方法，创建路径并分配属性。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="b161" class="kx ky iq mp b gy mt mu l mv mw">const renderChart = () =&gt; {<br/>  return data[0].features.map((d,i) =&gt; {<br/>    const featurePath = `${pathRef.current(d)}`<br/>      return (<br/>        &lt;path <br/>          key={i} <br/>          d={featurePath} <br/>          className={d.properties.name}<br/>          fill={boroughLegend(d.properties.borough)}<br/>        /&gt;<br/>       )<br/>   })<br/>};</span></pre><p id="566d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步是向Map components return语句添加条件逻辑。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="5272" class="kx ky iq mp b gy mt mu l mv mw">return (<br/>  &lt;svg id="boroughs-map" ref={svgRef}&gt;<br/>    {data.length &amp;&amp; renderChart()}<br/>  &lt;/svg&gt;<br/>);</span></pre><h1 id="2b5e" class="my ky iq bd kz mz na nb lc nc nd ne lf nf ng nh li ni nj nk ll nl nm nn lo no bi translated"><strong class="ak">结论</strong></h1><p id="9757" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">我不得不说，比起使用D3来渲染地图，我更喜欢这种方法。我想这是因为这些天我一直在与React打交道，所以我认为它应该尽可能地管理DOM，这几乎总是如此。</p><p id="8210" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在某种程度上，我几乎很难过用React来取代D3的这一功能，因为我已经习惯了D3的<strong class="ka ir">数据绑定</strong>和<strong class="ka ir">输入/更新/退出</strong>模式，这是我在任何D3课程介绍中一直强调的。</p><p id="2c00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，React似乎更适合呈现元素，并通过<strong class="ka ir"> useState </strong>或<strong class="ka ir"> useReducer跟踪任何状态变化。D3本身仍然是强大和高效的，并且提供了许多React中没有的特性，所以我很高兴我仍然能够将它融入到这个项目中。</strong></p><p id="edb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是用于地图和圆圈的<strong class="ka ir"> </strong> <a class="ae kw" href="https://codesandbox.io/s/d3-streetball-mecca-map-only-rsqpv?file=/src/components/Map/indexV2.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">代码沙箱</strong> </a>，包括2个文件，其中包含通过D3渲染地图的代码和refactor over。给他们两个都试一试，让我知道你是否看到任何额外的改进空间。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/dcf360de394d68fa448c502c35aee6c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*YKzKSwJE48WGND2fguKwwA.png"/></div></figure><p id="6d89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还包括了输入和下拉功能，用于根据选择的公园或选择的行政区过滤公园。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e10b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我正在写一篇后续文章，用一个React Circle组件替换D3来生成圆形并制作动画，同时加入<a class="ae kw" href="https://www.react-spring.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">React-Spring</strong></a><strong class="ka ir"/>来制作圆形动画。</p><p id="e774" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有兴趣阅读关于这个项目的更多信息，请查看我以前的文章<a class="ae kw" href="https://jkeohan.medium.com/react-managing-complex-state-transitions-with-usereducer-e37536b12944" rel="noopener"> React:用useReducer </a>管理复杂的状态转换。</p></div></div>    
</body>
</html>