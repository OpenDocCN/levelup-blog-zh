<html>
<head>
<title>Java, Go, and Python: a multi-thread performance comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java、Go和Python:多线程性能比较</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-go-and-python-a-multi-thread-performance-comparison-28e942cb73e6?source=collection_archive---------0-----------------------#2022-05-27">https://levelup.gitconnected.com/java-go-and-python-a-multi-thread-performance-comparison-28e942cb73e6?source=collection_archive---------0-----------------------#2022-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eda3029cade5faa2c1dcda6ed1bcbdcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgLOsE0mx8AuXERRyRbZEw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来自<a class="ae kc" href="https://www.educations.es/study-abroad/fontys-school-of-fine-and-performing-arts/bachelor-of-circus-and-performance-art-1395880" rel="noopener ugc nofollow" target="_blank">https://www . education s . es/study-overseas/font ys-school-of-fine-and-performance-arts/学士-of-circus-and-performance-art-1395880</a></figcaption></figure><h1 id="a09a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="56ad" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在计算机中，线程是可以由处理器独立执行的一小段指令序列。多线程在一个进程中是可能的，其中它们共享资源，例如指令和上下文。</p><p id="a22a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">新的编程语言正在开发，或者旧的编程语言正在改进，以允许软件更好地利用线程和并行性。因此，比较这些语言来确定它们处理多线程进程的能力是一个好主意。</p><p id="4d3f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">发现在运行多线程进程时具有最佳效率的编程语言是非常重要的，因为它可以帮助软件开发人员选择最有利的语言来实现他们的系统。</p><p id="34bc" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">本文的目的是分析和比较Java、Go和Python的性能，使用它们的并行工具解析几种算法，例如:Java和Python中的线程，以及Go中的goroutines。为了评估性能，我们编写了经典矩阵乘法算法、快速排序算法和康威生命游戏的并行实现。</p><h1 id="69ea" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">背景</h1><p id="5bb6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> Java </strong>:它是一种面向对象的编程语言，通过<em class="me">线程</em>类、<em class="me"> Runnable </em>接口以及<em class="me"> java.util.concurrent </em>包中包含的其他功能，内置了对并发的支持。</p><p id="0e05" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir"> Go </strong>:是Google在2012年发布的一种编程语言。它是一种类似C的过程化语言，具有垃圾收集器和对并发的内置支持。对于并发性和并行性，Go使用名为<em class="me"> goroutines </em>的线程实现。它使用一个内置的调度程序在幕后处理线程，并试图向用户隐藏日常线程管理的大部分复杂性，只需指定要运行的函数，并以<em class="me"> go </em>命令开始。Go在幕后使用操作系统(OS)线程。</p><p id="4a51" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir"> Python </strong>:标准库<em class="me">线程</em>，这个模块封装了线程，提供了一个干净的接口来处理它们。在这种方法中，操作系统实际上知道每个线程，并可以在任何时候中断它，开始运行不同的线程。使用被称为<em class="me">多处理</em>的其他标准库，可以在Python中获得并行性，而<em class="me">多处理</em> Python创建了新的进程。<em class="me">线程</em>模块使用线程，<em class="me">多处理</em>模块使用进程。其中一个区别是线程运行在同一个内存空间，而进程有独立的内存。</p><p id="341e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">矩阵乘法</strong>:这是线性代数中一个重要而简单的数学运算，经典的矩阵乘法算法(CMMA)可以很容易地在任何编程语言中实现。CMMA在<em class="me"> O(N^3) </em>中运行，其中<em class="me"> N </em>是矩阵的维数。</p><p id="ed89" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">快速排序</strong>:是分治算法。最初，它将数组分成两个子数组:较低的项和较高的项。然后递归排序这些子数组。其算法可以描述为:</p><ol class=""><li id="5ad5" class="mf mg iq ld b le lz li ma lm mh lq mi lu mj ly mk ml mm mn bi translated">从数组中选取一个透视元素。</li><li id="0062" class="mf mg iq ld b le mo li mp lm mq lq mr lu ms ly mk ml mm mn bi translated">对数组进行分区，使透视左侧的所有元素的值都小于透视值，透视右侧的所有元素的值都大于透视值。</li><li id="6e1e" class="mf mg iq ld b le mo li mp lm mq lq mr lu ms ly mk ml mm mn bi translated">对生成的子数组递归地执行上述步骤，直到获得完全排序的子数组。</li></ol><p id="d910" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">它的平均排序复杂度为<em class="me"> O(n log(n)) </em>，但在极少数情况下会退化为<em class="me"> O(n^2) </em>。</p><p id="b473" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">康威的生命游戏:它是由剑桥大学冈维尔和凯厄斯学院的数学家约翰·何顿·康威在60年代发明的。规则是:</p><ol class=""><li id="ce73" class="mf mg iq ld b le lz li ma lm mh lq mi lu mj ly mk ml mm mn bi translated">生存法则1:如果一个活细胞有两个或三个活邻居，它就能存活。</li><li id="de41" class="mf mg iq ld b le mo li mp lm mq lq mr lu ms ly mk ml mm mn bi translated">规则2死亡:如果一个活细胞的活邻居少于两个或多于三个，它就会死亡。</li><li id="0567" class="mf mg iq ld b le mo li mp lm mq lq mr lu ms ly mk ml mm mn bi translated">规则3出生:如果一个死细胞正好有三个活的邻居，它就出生了。</li></ol><p id="3369" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下一张图展示了从时间<em class="me"> T </em>到时间<em class="me"> T + 2 </em>康威生命游戏的几个场景。该算法的一个新实现将在步骤上检查每个单元，其时间复杂度为<em class="me"> O(M × N ) </em>，其中<em class="me"> M </em>表示网格的行数，而<em class="me"> N </em>表示网格的列数。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/0c4bdbd3645ec7ed0222ab7852eba9c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*SrL8elirY_Nm7moKl8J2Tg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">康威生活游戏的例子</figcaption></figure><h1 id="cb7f" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">解决办法</h1><p id="8002" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">所有的基准测试都在同一台计算机和同一环境中执行。表1显示了我们运行实验的硬件规格，表2显示了每种语言编程编译器的版本</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/fc59d5c08afdfabb55d0b598223f5b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*1x-ph5UletjQPqM34NZXkw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">硬件和软件(编程语言)概述</figcaption></figure><p id="a3db" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对于每个基准，我们计算其各自的加速和效率。加速比定义为最佳顺序时间与使用<em class="me"> p </em>个处理器的并行时间之比:<em class="me"> S = T1/Tp </em>。那么效率定义为:并行系统中各处理器的整体利用率:<em class="me"> E = S/p </em>。</p><p id="8109" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">矩阵乘法</strong>:在这个实验中，我们使用简单的矩阵乘法，通过<em class="me"> C = AB </em>来计算。矩阵的大小为512 × 512。我们正在运行一个顺序场景，然后是几个多线程场景，线程池大小为:2、4、8、16和32个线程。相同的矩阵<em class="me"> A </em>和<em class="me"> B </em>用于运行Java、Go和Python中的代码。这些矩阵将具有从0到1000(包括0和1000)的整数值。线程池将接收到代表矩阵<em class="me"> A </em>中的行数的<em class="me"> n </em>个工作，然后每个线程将执行该特定行的乘法，并用获得的结果更新<em class="me"> C </em>中的相应行。每次一个线程完成它的工作，它将从线程池接收一个新的任务，直到所有的工作都完成。下图说明了矩阵<em class="me"> C </em>的计算。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/856f9f7c04e596f80bb1411c8a1f53e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*-WgngTL2VDUwYv9-jspRQQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">矩阵乘法</figcaption></figure><p id="b7fe" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">快速排序:我们对10^7整数值数组进行排序，从0到10^7，包括0和。我们使用<em class="me"> ForkJoinPool </em>方法来处理这个实验。执行一个顺序运行，然后多线程测试从2到32个线程(2的幂)。这3个实现对相同的数组进行排序。在快速排序的并行实现中，分区后新子序列的排序可以并行执行，因为没有冲突。</p><p id="b89d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">康威的人生游戏:在康威的人生游戏中，有几个已知的初始模式会产生预期的结果，其中一个会无限增长，下一张图片的左侧显示了它的初始设置。在这个基准测试中，我们定义了一个28 × 28的2D网格，其中4个先前的模式彼此相邻，并在20，000代中执行该游戏，该网格看起来像下一个图形的右侧。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/6f4854d4ae9ce949f274e9d3862e19e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*bdIz7E34PNP-JeL2EU5s8A.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">无限增长模式</figcaption></figure><p id="2245" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对于这个实验，我们重复线程池方法，它将处理2、4、8、16和32个线程。此外，我们运行一个顺序实现。我们将决定细胞在每一代中是生存、死亡还是再生的规则并行应用。此外，为了得到一个细胞的邻居，我们不是把网格作为一个无限的网格，如果一个细胞的邻居在世界的界限之外，它被认为是死的。</p><h1 id="e5d4" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">贡献</h1><p id="855c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir">矩阵乘法</strong>:表III显示了运行矩阵乘法基准后得到的结果。Java是顺序执行中最好的，它在316 ms内运行512 × 512矩阵乘法，而Go消耗了453 ms，这表示在顺序运行中多了43.35%的时间。Python的性能最差，用时93，870毫秒(93.87秒)，相差约29，600%。</p><p id="4fc7" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">此外，从表III中可以看出，当使用2个线程执行基准测试时，Java的性能更好，但是当实验在4、8和16个线程中运行时，Go的性能优于Java和Python。我们可以在32个线程的阈值处检测到性能下降，这可能是由于创建过多线程的开销超过了CPU中的物理内核；即使在这种恶化的情况下，Go也比其他两种语言表现得更好。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/a98a1c19a537f462c63847abdfeaf13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*FT2fkHeM68v99eN-dm5odQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">矩阵乘法时间消耗(毫秒)。越低越好。</figcaption></figure><p id="2dd4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下一张图的左侧反映出，对于Go，2到4个线程的性能差异是显著的(大约92%的改进)，而从8到16个线程的性能差异是微不足道的，因为图中的曲线几乎保持不变，这告诉我们8个线程对于这个特定的场景是一个很好的数字。另一方面，Java的性能从2个线程稳步增加到16个线程；从这个图中，我们可以选择16个线程作为在Java中具有良好性能的线程数量。从下图的右侧可以看出，Python的资源利用率最低，而Go的资源利用率最高。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/c3c0d5723e8f48a956bacccd78c38632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*NDW00YobCs6Jh3U16q7bjA.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">矩阵乘法的加速和效率。</figcaption></figure><p id="8587" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">快速排序</strong>:在表4中，我们可以看到在测试的连续运行中，Go的性能最好，Python的性能最差。Python实现的一般行为非常糟糕，在16线程和32线程的场景中，应用程序无法完成执行(DNF代表没有完成)，从而卡住并阻塞了计算机。Go给出了有趣的结果，因为多线程运行的性能从差到最差。对于这一措施，Java获得了最好的多线程结果，但是在运行16和32个线程时，我们可以发现性能下降，其中16个线程的性能最差。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/36fd2bbb87ed05f56d0211c21bb3e52b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*hxbUKIs2f-2W2f1z0TPlVg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">快速排序耗时(毫秒)。越低越好。</figcaption></figure><p id="e922" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下图左侧的加速表明，当quicksort算法在Java中实现时，使用8个以上的线程来运行它是没有意义的。此外，我们可以看到，32个线程的运行比16个线程的运行稍好，但比8个线程的运行差。该图反映出Go多线程实现不如顺序实现好。即使Python的性能很差，2、4和8线程的运行也比顺序运行要好。</p><p id="e4e9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下图右侧反映的效率证实了我们在表IV中看到的最佳结果，但不是最差结果，因为该图可能会让我们认为Python比Go更好，然而时间消耗告诉我们不同的历史:Go优于Python。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/5b248e0c59fb0a3bbb11b4ba7200684f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*Ya-jxnN9OGFWwxSDeQFjgw.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">快速排序的加速和效率。</figcaption></figure><p id="b0d1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">康威的人生游戏</strong>:Python再次得到了所有3个实现中最差的结果，然而正如我们在表V中看到的，它是唯一一个从顺序实现到多线程实现有所改进的实现；然而，随着线程数量的增加，时间消耗也会增加。在Java和Go的例子中，顺序实现的性能最好。在Java场景中，从顺序版本到32线程版本的时间差是11，455%，这代表了两者之间的巨大差距。在Java实现中，每生成一个线程池就释放一个线程池，并创建一个新的线程池，这会产生相当大的开销。Go行为不稳定，时间利用率从顺序增加到2个线程的版本，然后在4、8和16个线程的版本中略有减少，最后在32个线程时再次增加。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/67d81361882ba62526c2f965043a6a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*FcWDUccHibPzv7Sqmd8R2A.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">康威的生命时间消耗游戏(毫秒)。越低越好。</figcaption></figure><p id="5e10" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">下图中的加速图证实了Conway的生命游戏的多线程实现的总体性能很差。围绕加速曲线的期望是，它应该遵循一个增加的行为，而这并没有发生。所报告的效率表明资源没有得到适当的开发。Java的效率非常接近于零，Go和Java只是有一点点的差别。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/3acf2a7a5f4cd781dc066298bab79103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*1vFojLXO3SiIEJyjIaN4PA.jpeg"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">康威生命游戏的加速和效率。</figcaption></figure><h1 id="1fba" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="6fa3" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">创建线程的开销会直接影响应用程序的性能。从表III中可以看出，在达到某个阈值后继续创建线程是没有意义的，因为性能会下降。</p><p id="47e9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如表V所示，使用多线程来解决问题并不能保证我们将获得更好的性能，有时顺序实现是最好的选择。</p><p id="4b5e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">处理并发和并行的Python标准库不如Java和Go等其他编程语言实现的标准库好。</p><p id="07d2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">很难说Java和Go哪个更好，因为Java在矩阵乘法基准测试中表现优于Go，但Go在快速排序实验中超过了Java。</p><p id="c1ec" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">未来工作</strong></p><p id="f4da" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这项工作仅限于每种算法的基本实现，下一步很好的做法是复制这项研究引入的场景，但使用每个基准的最佳实现。</p><p id="56b4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">用Python实现并行代码有几种选择，比如:MPI for Python、CharmPy、Numba等等。一个很好的实验是使用这个库用更有效的实现来代替编写的代码。</p><p id="8642" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">扩展这项研究的一个方法是考虑其他技术方面，如编译时间、文件大小和编写的代码行数。</p><h1 id="f526" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">参考</h1><p id="5ab9" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">[1] S. Majumdar、I. Jain和A. Gawade。"使用线程池模式的并行快速排序."载于:<em class="me">《国际计算机应用杂志》</em> 136期(2016年2月)，第36–41页。DOI: 10.5120/ijca2016908495。</p><p id="dac9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[2] T. Andersson和C. Brenden，“Go和Java中的并行性使用矩阵乘法的性能比较”，学位论文，2018。</p><p id="dc89" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[3]李“线程的问题”。载于:<em class="me">计算机</em> 39期(2006年6月)，第33–42页。DOI: 10.1109/MC</p><p id="1dd1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[4] J. Carl，《Go和Scala中的并行编程:性能比较》，学位论文，2015。</p><p id="b9d4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[5]“关键Java里程碑的时间线。”Oracle.com。<a class="ae kc" href="https://www.oracle." rel="noopener ugc nofollow" target="_blank">https://www . Oracle .</a>com/Java/moved-by-Java/(访问时间:2021年6月19日)。</p><p id="3238" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[6]“Oracle Java SE支持路线图。”Oracle.com。<a class="ae kc" href="https://www.oracle." rel="noopener ugc nofollow" target="_blank">https://www . Oracle .</a>com/Java/technologies/Java-se-support-roadmap . html(访问时间:2021年6月19日)。</p><p id="3c77" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[7] R. Buyya，“Java面向对象编程”，第14章，第367–368页，2009。塔塔麦格劳希尔教育私人有限公司。</p><p id="aee9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[8] N. Togashi和V. Klyuev，“web开发的新方法:使用GAE/Go的进度管理系统”，<em class="me"> 2015 IEEE第七届国际认知科学与技术大会(iCAST) </em>，2015年，第55–59页，doi:10.1109/icawst . 2015.314020</p><p id="a153" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[9]“下载。”Golang.org。<a class="ae kc" href="https://golang.org/dl/" rel="noopener ugc nofollow" target="_blank">https://golang.org/dl/</a>(访问时间:5月。21,2021).</p><p id="5b68" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[10]“常见问题”Golang.org<a class="ae kc" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank">https://golang.org/</a>文档/常见问题#goroutines(访问时间:5月。21, 2021).</p><p id="dea7" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[11]“Go调度器源代码。”Github.com。<a class="ae kc" href="https://github.com/golang/" rel="noopener ugc nofollow" target="_blank">https://github.com/golang/</a>go/blob/master/src/runtime/proc . go(访问时间:五月。21, 2021).</p><p id="6c1b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[12] A. A. A. Donovan和B. W. Kernighan，“共享变量的并发性”，见<em class="me">Go编程语言</em>，第1版。美国纽约州纽约市:艾迪森-卫斯理出版社，2015年，第280-283页。</p><p id="37af" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[13] J. J. Galvez，K. Senthil和L. Kale，“CharmPy:一个Python并行编程模型”，<em class="me"> 2018 IEEE集群计算国际会议(CLUSTER) </em>，2018，第423–433页，doi:10.1109/CLUS-ter . 2018.00059。</p><p id="7986" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[14] V .谢罗莫娃，“Python简史”，Exyte.com。<a class="ae kc" href="https://exyte." rel="noopener ugc nofollow" target="_blank"> https://exyte。com/blog/a-brief-history-of-python(访问时间:2021年6月19日)。</a></p><p id="19b2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[15]“下载Mac OS X的最新版本。”Python.org。https://www.python.org/downloads/(访问时间:2021年6月19日)。</p><p id="c5dc" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[16] J. Anderson，“Python中的线程介绍”RealPython.com。https://realpython.com/intro-to-python-threading/<a class="ae kc" href="https://realpython.com/intro-to-python-threading/" rel="noopener ugc nofollow" target="_blank">(访问时间:2021年6月19日)。</a></p><p id="8c77" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[17] J. Anderson，“用并发性加速您的Python程序”重新alPython.com。https://realpython.com/python-concurrency/<a class="ae kc" href="https://realpython.com/python-concurrency/" rel="noopener ugc nofollow" target="_blank">(访问时间:2021年6月19日)。</a></p><p id="424b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">[18] K. Khankasikam，“通过使用Conway的生命游戏识别印刷体Lanna字符”，<em class="me">第七届数字信息管理国际会议(ICDIM 2012) </em>，2012年，第104–109页，doi:10.1109/ICDIM . 2012 . 636364866</p></div></div>    
</body>
</html>