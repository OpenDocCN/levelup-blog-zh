<html>
<head>
<title>Code-first GraphQL Schema with GraphQL.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL.js的代码优先GraphQL模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/code-first-graphql-schema-with-graphql-js-bfec4664d1a5?source=collection_archive---------2-----------------------#2020-07-26">https://levelup.gitconnected.com/code-first-graphql-schema-with-graphql-js-bfec4664d1a5?source=collection_archive---------2-----------------------#2020-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="34f0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何以编程方式生成GraphQL模式</h2></div><h2 id="2588" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">GraphQL是什么？</h2><p id="036a" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">GraphQL是一种用于API的查询语言和运行时，它允许客户端定义服务器返回的响应的数据元素和结构。与典型的REST API不同，在REST API中，服务器根据预定义的数据契约进行响应，而使用GraphQL API，客户端可以请求并接收它需要的数据。</p><p id="408c" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">例如，考虑一个雇员<em class="lz"> </em> API，它允许客户查询组织中雇员的信息。从联系信息(电子邮件、电话)，到个人信息(出生日期、地址)，再到组织信息(工资、职位、部门)，有相当多的数据元素可以与一个员工相关联，而且任何一个客户都不可能对每个数据元素都感兴趣。</p><p id="e7cb" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">通过使用GraphQL查询，客户能够通过指定他们感兴趣的数据元素来定义雇员API响应的内容和结构。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/18247f26dd3197b6b78037bc10ee43ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hOIAIEjt2ugWtzCEhd_VA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">GraphQL查询示例。(图片由作者提供)</figcaption></figure><h2 id="adae" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">GraphQL模式</h2><p id="411e" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">GraphQL模式描述了由GraphQL服务器展示的可查询数据元素或字段的结构。回到上面的雇员示例，我们可以将模式定义为:</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="99ef" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">上面的语法被称为<strong class="ld ir">模式定义语言</strong>(或者<strong class="ld ir"> SDL </strong>)，正如您所看到的，它定义了对象类型(本例中为<em class="lz">雇员</em>)、对象的字段以及这些字段的数据类型。SDL也可以表示需要输入参数的类型。例如，这个API的客户端可能希望查询关于给定某个雇员标识符的特定雇员的数据。当对雇员进行查询时，GraphQL服务器可以要求将该标识符作为输入参数传递。产生的模式看起来像这样:</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="d96a" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated"><strong class="ld ir">注意:</strong><code class="fe ms mt mu mv b">String!</code>中的<code class="fe ms mt mu mv b">!</code>表示该参数不可为空。</p><h2 id="15ff" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是代码优先模式？</h2><p id="4eeb" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">虽然SDL是一种简单易读的表示模式的方式，但是以SDL的形式编写和维护GraphQL模式可能会变得很麻烦，尤其是当字段数量增加以及需要进行更改以反映API所连接的后端数据库的更改时。</p><p id="e7df" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">代码优先模式允许我们以编程方式定义GraphQL模式，而无需显式编写SDL。我们将通过一个示例应用程序来了解这是如何实现的。</p><h1 id="545c" class="mw kg iq bd kh mx my mz kk na nb nc kn jw nd jx kr jz ne ka kv kc nf kd kz ng bi translated">示例场景</h1><p id="4813" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">假设你在一家餐饮公司工作，该公司拥有遍布世界各地的快餐连锁店。您希望创建一个GraphQL API，允许客户查询各个城市中每个连锁店销售的餐食数量。</p><p id="143c" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">为了实现这一点，我们将使用Express和GraphQL.js创建一个GraphQL API服务器。我不会在本文的基础知识上花费太多时间，因为您可以在这里找到关于这些技术的入门教程:<a class="ae nh" href="https://graphql.org/graphql-js/running-an-express-graphql-server/" rel="noopener ugc nofollow" target="_blank">https://graph QL . org/graph QL-js/running-an-Express-graph QL-server</a>/</p><p id="dabe" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">然而，GraphQL文档中的代码示例都使用SDL来定义模式，而我们将使用代码优先的方法以编程方式生成模式。</p><h2 id="e9d8" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">构建应用程序</h2><p id="471b" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">从一个空的node.js项目开始，我们将使用NPM安装必要的包:</p><pre class="mb mc md me gt ni mv nj nk aw nl bi"><span id="16ea" class="kf kg iq mv b gy nm nn l no np">npm install express express-graphql graphql</span></pre><p id="5ce5" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">处理完依赖关系后，我们将填充应用程序入口点。我们使用<code class="fe ms mt mu mv b">graphqlHTTP</code>中间件来允许我们的Express应用程序接受GraphQL查询，传递模式(我们将很快定义)并指定<code class="fe ms mt mu mv b">graphiql: true</code>来启用基于web的GraphQL GUI，以便对我们的服务器执行graph QL查询。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="df87" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">创建一些示例数据</h2><p id="51ab" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">我们将创建几个简单的JSON文件来模拟后端数据库，而不是建立一个数据库服务器来存放我们的应用程序将使用的数据。</p><p id="3875" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">第一个文件包含三家快餐连锁店在不同地区的销售数据:</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="082e" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">第二个文件包含公司开展业务的所有不同地区。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="3a4a" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">有了一些示例数据，我们现在将创建一个数据访问对象，它公开了检索数据的函数。在现实世界的应用程序中，这些函数可能会对外部SQL数据库执行查询，而不是简单地从静态JSON文件中读取。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mq mr l"/></div></figure><h2 id="6327" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">定义模式</h2><p id="dca3" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">现在是精彩的部分。我们将为一个<code class="fe ms mt mu mv b">RestaurantSales</code>类型定义一个模式，客户可以用它来查询一个特定的连锁餐厅在多个地点的销售数据，我们不会编写任何SDL来创建这个模式。相反，我们将从我们创建的样本数据动态构建模式，这意味着随着底层数据的变化(例如，如果添加了新的区域)，我们的应用程序的模式将自动更新以反映这些变化。</p><p id="d0a1" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">首先，这里是前面在应用程序入口点中引用的<code class="fe ms mt mu mv b">schema</code>模块。当应用程序启动时，下面的<code class="fe ms mt mu mv b">GraphQLSchema</code>对象将被传递到<code class="fe ms mt mu mv b">graphqlHTTP</code>中间件中。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="20ee" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">让我们走一遍:</p><ul class=""><li id="ec2f" class="nq nr iq ld b le lu lh lv ko ns ks nt kw nu lt nv nw nx ny bi translated">首先，需要注意的是，<code class="fe ms mt mu mv b">query</code>类型是每个GraphQL服务共有的特殊类型。除了它是所有服务查询的入口点之外，<code class="fe ms mt mu mv b">query</code>类型就像任何其他类型一样(比如前面的Employee类型)。也就是说，服务中定义的所有其他类型都是顶级<code class="fe ms mt mu mv b">query</code>类型的字段。您可以在这里阅读关于<code class="fe ms mt mu mv b">query</code>类型和另一种特殊类型<code class="fe ms mt mu mv b">mutation</code>的更多信息:<a class="ae nh" href="https://graphql.org/learn/schema/#the-query-and-mutation-types" rel="noopener ugc nofollow" target="_blank">https://graph QL . org/learn/schema/# the-query-and-mutation-types</a></li><li id="ea17" class="nq nr iq ld b le nz lh oa ko ob ks oc kw od lt nv nw nx ny bi translated">在上面代码的<strong class="ld ir">第6行</strong>中，我们将<code class="fe ms mt mu mv b">query</code>类型定义为应用程序模式中的顶级对象。</li><li id="c11e" class="nq nr iq ld b le nz lh oa ko ob ks oc kw od lt nv nw nx ny bi translated">在<strong class="ld ir">第9行</strong>中，我们指定顶级<code class="fe ms mt mu mv b">query</code>类型包含一个名为<code class="fe ms mt mu mv b">restaurant</code>的字段，该字段属于<code class="fe ms mt mu mv b">RestaurantSales</code>类型(我们将很快定义该类型)，接受一个名为<code class="fe ms mt mu mv b">name</code>的参数，并通过使用前面的<code class="fe ms mt mu mv b">restaurantDataService</code>查询一家快餐连锁店的销售数据来解析。实际调用的是<code class="fe ms mt mu mv b">resolve</code>函数，用数据填充<code class="fe ms mt mu mv b">restaurant</code>字段。</li></ul><p id="f0d3" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">最后一步是定义<code class="fe ms mt mu mv b">RestaurantSales</code>类型。类似于<code class="fe ms mt mu mv b">query</code>类型，它将有一个名称和一个字段集合。<code class="fe ms mt mu mv b">ResaurantSales</code>类型的字段将是公司运营的不同区域，我们将使用之前放入“数据库”的区域列表以编程方式定义这些字段。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="mq mr l"/></div></figure><ul class=""><li id="b9f5" class="nq nr iq ld b le lu lh lv ko ns ks nt kw nu lt nv nw nx ny bi translated">在<strong class="ld ir">第12行，</strong>我们创建了<code class="fe ms mt mu mv b">RestaurantSales</code>类型作为<code class="fe ms mt mu mv b">GraphQLObjectType</code>的一个新实例，我们给该类型一个名称，并将该类型的字段设置为等于<code class="fe ms mt mu mv b">getRegionFields()</code>函数的结果。</li><li id="6da6" class="nq nr iq ld b le nz lh oa ko ob ks oc kw od lt nv nw nx ny bi translated"><code class="fe ms mt mu mv b">getRegionFields()</code>函数使用<code class="fe ms mt mu mv b">restaurantDataService</code>来查找区域列表，并为每个区域向<code class="fe ms mt mu mv b">fields</code>集合添加一个新字段。<code class="fe ms mt mu mv b">fields</code>对象是一个键-值映射，其中键是字段的名称，值是具有<code class="fe ms mt mu mv b">type</code>和<code class="fe ms mt mu mv b">description</code>的对象。每个字段的类型都是<code class="fe ms mt mu mv b">GraphQLInt</code>，并且有一个基于区域名称的简单描述。</li></ul><p id="d4f2" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">仅此而已。我们现在已经使用“数据库”中的区域列表定义了我们的<code class="fe ms mt mu mv b">RestaurantSales</code>类型，而不是显式地单独列出每个区域。让我们测试一下这个应用程序。</p><h2 id="641e" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">运行应用程序</h2><p id="f7f5" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">要启动该应用程序，请运行以下命令:</p><pre class="mb mc md me gt ni mv nj nk aw nl bi"><span id="ef92" class="kf kg iq mv b gy nm nn l no np">node index.js</span></pre><p id="13e7" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">您应该会看到如下输出消息:</p><pre class="mb mc md me gt ni mv nj nk aw nl bi"><span id="39b6" class="kf kg iq mv b gy nm nn l no np">Running a GraphQL API server at <a class="ae nh" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graphql</a></span></pre><p id="010f" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">导航到<a class="ae nh" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graph QL</a>，您应该会看到前面提到的GraphiQL GUI。它看起来会像这样:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi oe"><img src="../Images/fb5e4e2d6fdcad1aaa4e91cff9f69d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wp-g2MjJofCqutudUry5CA.jpeg"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">图形用户界面。(图片由作者提供)</figcaption></figure><p id="e10b" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">左窗格是我们可以编写针对服务器执行的GraphQL查询的地方，右窗格是我们可以看到服务器响应的地方。在我们执行任何查询之前，让我们通过展开右上角的<strong class="ld ir"> Docs </strong>菜单来检查服务器的模式。</p><p id="8fb4" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">从顶级的<code class="fe ms mt mu mv b">query</code>类型开始，我们可以深入到我们的自定义<code class="fe ms mt mu mv b">RestaurantSales</code>类型，查看我们类型的字段。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi of"><img src="../Images/6b5d3693a5317d0dc688c67946865769.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*7iuXDIDWldQ1wVe-n8IJ7Q.jpeg"/></div></figure><p id="7278" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">正如所料，<code class="fe ms mt mu mv b">RestaurantSales</code>类型包含一个字段，用于存储在我们后端“数据库”中的regions列表中定义的每个区域。</p><p id="62f1" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">这样做的好处是，当新的区域被添加到区域列表(或者可能是现实应用程序中的区域表)中时，我们的应用程序会自动选取它们，并在启动时将它们作为字段添加到<code class="fe ms mt mu mv b">RestaurantSales</code>类型中。</p><p id="b272" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">最后，让我们尝试一个销售数据查询。我们将获得纽约、迈阿密和旧金山的虚拟快餐连锁店Burger ballout销售的餐数。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi og"><img src="../Images/5ec8d60c2fb2621b656241e9b5cdca0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhO3WarHCRrEcwWssSirew.jpeg"/></div></div></figure><h1 id="c2a8" class="mw kg iq bd kh mx my mz kk na nb nc kn jw nd jx kr jz ne ka kv kc nf kd kz ng bi translated">结论</h1><p id="9e1a" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">在本文中，我们看到了如何使用代码优先的方法定义GraphQL模式，而不是使用SDL显式定义模式。这种代码优先的方法是编写和维护大型模式的好方法，这些模式可能像SDL一样难以阅读和修改。</p><p id="2c12" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">感谢阅读。如有任何问题或意见，请随时联系我们。</p><h2 id="efe6" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">参考</h2><p id="ebfa" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj ko lk ll lm ks ln lo lp kw lq lr ls lt ij bi translated">以下是我发现的一些有助于学习GraphQL和GraphQL模式的资源:</p><ul class=""><li id="5c56" class="nq nr iq ld b le lu lh lv ko ns ks nt kw nu lt nv nw nx ny bi translated"><a class="ae nh" href="https://graphql.org/graphql-js/" rel="noopener ugc nofollow" target="_blank">https://graphql.org/graphql-js/</a></li><li id="7c4f" class="nq nr iq ld b le nz lh oa ko ob ks oc kw od lt nv nw nx ny bi translated">https://graphql.org/learn/schema/<a class="ae nh" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank"/></li><li id="6916" class="nq nr iq ld b le nz lh oa ko ob ks oc kw od lt nv nw nx ny bi translated"><a class="ae nh" href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/" rel="noopener ugc nofollow" target="_blank">https://blog . log rocket . com/code-first-vs-schema-first-development-graph QL/</a></li></ul><p id="6bf9" class="pw-post-body-paragraph lb lc iq ld b le lu jr lg lh lv ju lj ko lw ll lm ks lx lo lp kw ly lr ls lt ij bi translated">这里有一个GitHub存储库，包含本文中提到的GraphQL服务器应用程序:</p><ul class=""><li id="1ecb" class="nq nr iq ld b le lu lh lv ko ns ks nt kw nu lt nv nw nx ny bi translated"><a class="ae nh" href="https://github.com/gnovack/code-first-graphql" rel="noopener ugc nofollow" target="_blank">https://github.com/gnovack/code-first-graphql</a></li></ul></div></div>    
</body>
</html>