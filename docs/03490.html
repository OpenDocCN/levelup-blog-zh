<html>
<head>
<title>AWS Lambda offline development with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Docker进行AWS Lambda离线开发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/aws-lambda-offline-development-with-docker-6a8cf8b186e7?source=collection_archive---------4-----------------------#2020-05-12">https://levelup.gitconnected.com/aws-lambda-offline-development-with-docker-6a8cf8b186e7?source=collection_archive---------4-----------------------#2020-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f65487094d79dec0085d16ac40c85518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4om5VyBwRHL0WoQv.jpg"/></div></div></figure><p id="4082" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我从事的项目越来越面向无服务器<strong class="kd iu">范式</strong>，并且越来越多地在AWS Lambda平台上实现。能够在您最喜欢的IDE中轻松地离线开发AWS Lambda函数，而不必上传代码来测试它，可以显著加快活动速度并提高效率。</p><h1 id="2594" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">docker中的AWS Lambda环境</h1><p id="5eaa" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">没错！<strong class="kd iu">允许我们在离线模式下开发AWS Lambda代码的解决方案</strong><strong class="kd iu">是</strong> <strong class="kd iu">使用docker镜像</strong>，它以与AWS实时环境几乎相同的方式复制。DockerHub上提供的<a class="ae mc" href="https://hub.docker.com/r/lambci/lambda/" rel="noopener ugc nofollow" target="_blank"> docker映像</a>构成了一个沙箱，在其中执行其功能，确保找到相同的库、文件结构和相关权限、环境变量以及生产上下文。太棒了。</p><p id="965f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Lambda函数很少“独立于”其他资源:它经常需要访问存储在S3桶中的对象，在SQS上排队消息，或者访问DynamoDB表。这个解决方案的有趣之处在于能够离线开发和测试代码，但是只需在环境变量中指定一对AWS访问键，就可以与真正的AWS服务和资源进行交互。</p><p id="b8e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae mc" href="https://github.com/lambci/docker-lambda" rel="noopener ugc nofollow" target="_blank">lambda ci项目</a>被频繁地更新和很好地文档化:它包括几个运行时环境，比如Python，我们将在接下来的段落中使用它。</p><p id="3474" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我用于开发的基本环境在这个库中<a class="ae mc" href="https://github.com/vittorio-nardone/aws-lambda-offline-development" rel="noopener ugc nofollow" target="_blank">可用。</a></p><h1 id="0384" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">样本函数</h1><p id="0c9a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">假设我们正在处理一个简单的Python函数，它处理SQS消息，并且使用一个通常不安装在AWS Lambda Python环境中的包。示例代码如下。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="e044" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，Logger对象被实例化:我们将使用它来跟踪SQS事件。消息正文中预见到了加数，结果将在日志中报告。我们还将跟踪PILLOW包的版本，通常在AWS Lambda环境中默认不安装，以验证附加包的安装是否成功。最后，在函数执行结束时，返回一个示例文本消息(“祝您一切顺利”)。</p><p id="2d55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">现在让我们看看如何在Docker容器内执行Lambda函数</strong>。</p><h1 id="710c" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Dockerfile和Docker-Compose</h1><p id="07e6" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">首先，我们需要考虑如何安装额外的Python包，在我们的示例PILLOW中。我们基于<strong class="kd iu"><em class="mj">λ/λ:python 3.6</em></strong>图像使用<strong class="kd iu"><em class="mj">Docker文件</em> </strong>创建新的Docker图像。让我们安装文件<strong class="kd iu"><em class="mj">requirements . txt</em></strong>中指定的所有附加包</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="2242" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，通过一个<strong class="kd iu"><em class="mj">docker-compose . yml</em></strong>文件，我们定义了一个用于离线调试的<strong class="kd iu"> lambda </strong>服务。目的是映射源代码的主机目录，并设置<strong class="kd iu"> PYTHONPATH </strong>使用<strong class="kd iu"><em class="mj">/var/task/lib</em></strong>中的附加包</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="25aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为第一个测试，只需启动docker-compose运行我们的Lambda函数，传递处理程序。</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="8c13" class="mp la it ml b gy mq mr l ms mt">docker-compose run lambda src.lambda_function.lambda_handler</span></pre><h1 id="6eb2" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">事件</h1><p id="6baf" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们的函数期望处理一个SQS事件。怎么发？首先我们需要获得一个测试JSON，并将其保存在一个文件中(例如<strong class="kd iu"> <em class="mj"> event.json </em> </strong>)。让我们在docker-compose命令行中指定它。</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="8402" class="mp la it ml b gy mq mr l ms mt">docker-compose run lambda \<br/>               src.lambda_function.lambda_handler \<br/>               <strong class="ml iu">"$(cat event.json)"</strong></span></pre><p id="c191" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们检查执行结果。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mu"><img src="../Images/18e69e825ad2198b3f1e06f8d3bfcc24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2BLgCQxLMxB6Y5fhdVjrKw.png"/></div></div></figure><p id="8e9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完美！我们的功能执行正确，结果与预期相符。<strong class="kd iu">启动Docker容器对应于AWS Lambda冷启动</strong>。让我们来看看如何让容器保持活动状态，以便多次调用该函数。</p><h1 id="a0b7" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">继续跑</h1><p id="6a43" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">或者，您可以启动并保持Lambda函数的容器运行:您可以快速地进行几次连续调用，而无需等待“冷启动”时间。在这种模式下，会启动一个API服务器，默认情况下它会响应端口9001。</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="a3ec" class="mp la it ml b gy mq mr l ms mt">docker-compose run <strong class="ml iu">-e DOCKER_LAMBDA_STAY_OPEN=1</strong> \<br/>                   -p 9001:9001 lambda \<br/>                   src.lambda_function.lambda_handler</span></pre><p id="9482" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用例如<strong class="kd iu"><em class="mj"/></strong>来调用我们的函数。</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="0dcf" class="mp la it ml b gy mq mr l ms mt">curl --data-binary "@event.json" \<br/>   <a class="ae mc" href="http://localhost:9001/2015-03-31/functions/myfunction/invocations" rel="noopener ugc nofollow" target="_blank">http://localhost:9001/2015-03-31/functions/myfunction/invocations</a></span></pre><p id="96cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Lambda函数的默认处理程序响应this端点。<strong class="kd iu"> <em class="mj"> data-binary </em> </strong>参数允许发送JSON文件的内容，采样SQS事件。</p><h1 id="c1be" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="0f06" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我在这个GitHub库中收集了重新创建Docker环境所需的文件<a class="ae mc" href="https://github.com/vittorio-nardone/aws-lambda-offline-development" rel="noopener ugc nofollow" target="_blank">，我使用这些文件在Python中离线开发和调试AWS Lambda函数。为了方便起见，我在一个<strong class="kd iu"><em class="mj">Makefile</em></strong><em class="mj"/>中收集了最频繁的操作。</a></p><p id="ffc6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"><em class="mj">make lambda-build</em></strong>命令实现该功能的部署包，包括附加包。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="1a85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是一个用<strong class="kd iu"> CloudFormation </strong>部署Lambda函数的例子。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="8ca0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="mj"> Makefile </em> </strong>中可用的其他命令有:</p><pre class="md me mf mg gt mk ml mm mn aw mo bi"><span id="0efc" class="mp la it ml b gy mq mr l ms mt">## create Docker image with requirements <br/>make docker-build</span><span id="efa5" class="mp la it ml b gy mv mr l ms mt">## run "src.lambda_function.lambda_handler" with docker-compose <br/>## mapping "./tmp" and "./src" folders. <br/>## "event.json" file is loaded and provided to function <br/>make lambda-run</span><span id="6db6" class="mp la it ml b gy mv mr l ms mt">## run API server on port 9001<br/>make lambda-stay-open</span></pre><p id="29a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们玩得开心吗？下次见！</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="1c81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mj">原载于2020年5月12日</em><a class="ae mc" href="https://www.vittorionardone.it/en/2020/05/12/aws-lambda-offline-development-with-docker/" rel="noopener ugc nofollow" target="_blank"><em class="mj">https://www . vittorionardone . it</em></a><em class="mj">。</em></p></div></div>    
</body>
</html>