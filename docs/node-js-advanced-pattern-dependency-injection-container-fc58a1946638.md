# Node.js 高级模式:依赖注入容器

> 原文：<https://levelup.gitconnected.com/node-js-advanced-pattern-dependency-injection-container-fc58a1946638>

![](img/5247623b7e45a233b2e2825dacd85bbf.png)

在这篇文章中，我将介绍依赖注入容器(DIC ),这是 Node.js 中大多数应用程序和库使用的一种高级模块连接模式。这种模式之所以广泛使用是有原因的，它通过提供依赖注入模式的所有好处，同时消除其大多数缺点，使您的代码更加灵活。我们将回顾模式的基本原则，然后编写我们自己的 DIC。

**如果你不熟悉模块连接和依赖注入，我推荐你先阅读我在模块连接** [**这里**](https://isamatov.com/node-module-wiring-dependencies/) **上的帖子。**

# 什么是依赖注入

简而言之，依赖注入(DI)是一种连接模式，其中依赖项不是硬编码在模块内部，而是由外部实体作为输入提供。

通常，开发人员使用`require`导入模块依赖。这种方法很好，但是它不太灵活，而且更难进行单元测试。让我们来看看这个简单的例子:

下面是我们如何使用 DI 来为我们的模块提供 db 实例:

现在假设我们想通过提供一个虚拟数据库实例来对这个模块进行单元测试。在第一个例子中，我们必须修改模块的代码，而在第二个例子中，我们所要做的就是提供虚拟实例作为参数。

## 依赖注入的优点:

*   更高的可重用性——在我们的例子中，通过不同的数据库实例使用我们的电影建议服务要容易得多。
*   更容易的单元测试——为单元测试提供虚拟数据变得微不足道。

## 依赖注入的大弊端

虽然 DI 有很多优点，但它也有一个缺点:随着项目依赖项数量的增长，手动管理它们变得更加困难。

例如，让我们来看一个样本`app.js`文件，我们用它来设置我们项目中的依赖图:

在上面的例子中，我们实际上是为我们的应用程序手动设置依赖图。每个对象的实例化依赖于前一个对象，实例化的顺序至关重要。我们可以看到，如果我们继续沿着这条路走下去，这很容易变得不可收拾。

那么是不是不值得使用依赖注入呢？幸运的是，在 DI 的基础上构建了一个更高级的模式，减轻了它的大部分缺点。

# 依赖注入容器

本质上，依赖注入容器是模块或外部服务，其唯一目的是处理项目中的依赖注入。使用 DIC，您可以享受依赖注入的所有优势，同时也不必手动处理项目的依赖图。

由于 DIC 的效率和可伸缩性，它被大量的 Node.js 库和项目所使用。

## 不同的依赖注入容器实现方法:

有多种不同的方法可以在运行时为 DIC 提供依赖列表，这里有两种最广泛使用的方法。

1.  **在运行时评估工厂参数的名称**。在第三方软件包的帮助下，您可以将给定函数的参数名提取为字符串数组。这用于在运行时预测依赖项的名称。
2.  **附加特殊属性。**您可以将自定义属性(`_inject`)附加到工厂函数的原型，并在该属性中指定工厂函数的所有依赖项名称。之后，您可以定制您的 DIC 来使用`_inject`在运行时获取依赖列表。

## 实现依赖注入容器

第一种方法侵入性最小，也最受欢迎，因此我们将使用这种方法来实现我们的 DIC。我们将使用`[parse-function](https://www.npmjs.com/package/parse-function)` npm 包，它可以用来解析任何给定函数的参数名:

这里需要注意几件事:

*   我们使用属性`this.dependencies`和`this.factories`进行缓存。
*   `register`是注册新依赖项的简单方法。
*   `factory`是注册依赖工厂的简单方法。
*   如果可用，方法返回注册的依赖项。否则，它使用其工厂实例化依赖项，然后返回它。
*   最后也是最重要的是`inject`方法。这个方法是我们 DIC 逻辑的核心所在。`inject`将工厂参数的名称提取为字符串数组。然后，它将每个参数与其他注册的依赖项进行匹配，并使用这些依赖项调用工厂函数。

**注意**:为了让`inject`方法工作，您必须确保注册的依赖项名称与依赖这些依赖项的工厂参数的名称相匹配。

现在让我们来看看重写后的`app.js`，它将处理依赖图的责任转移给了我们的`DiContainer`

我们所要做的就是创建一个新的`DiContainer`实例，并注册我们的依赖项和工厂。我们注册依赖关系的顺序不再重要。此外，我们不再需要担心向依赖工厂提供正确的参数。要得到一个`MovieController`的工作实例，我们所要做的就是调用`get`方法，剩下的由`DiContainer`来处理。

我们的`DiContainer`实现使用惰性加载方法，仅在应用程序需要时实例化依赖项。

## **使用依赖注入容器的好处:**

*   依赖注入的所有优点。
*   DIC 在运行时自动识别模块所需的依赖关系。这意味着我们不再需要担心为工厂提供正确的参数。
*   模块甚至不知道 DIC 的存在，这意味着 DIC 和模块是松耦合的。

## 第三方依赖注入容器

虽然编写我们自己版本的 DIC 有助于更好地理解其背后的原因，但使用第三方解决方案要实用得多。NPM 注册中心有很多 DIC 库，它们为我们提供了很多有用的特性，比如惰性加载和开箱即用的装饰器，其中之一就是`[bottlejs](https://www.npmjs.com/package/bottlejs)`。

这个帖子到此为止！Dependency Injection Container 是一种更高级的模块连接模式，不仅在 Node.js 中广泛使用，在一般的软件开发领域中也广泛使用。

*原载于 2019 年 6 月 29 日*[*https://isamatov.com*](https://isamatov.com/node-js-dependency-injection-container/)*。*