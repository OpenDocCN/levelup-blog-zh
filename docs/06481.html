<html>
<head>
<title>Patterns for Coding Interviews — Top ‘K’ Elements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码面试的模式——顶级“K”元素</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/patterns-for-coding-interviews-top-k-elements-1a1368c4cbf0?source=collection_archive---------0-----------------------#2020-11-30">https://levelup.gitconnected.com/patterns-for-coding-interviews-top-k-elements-1a1368c4cbf0?source=collection_archive---------0-----------------------#2020-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1de0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过学习算法模式赢得任何编码面试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/73b779328b9b60241e40ab5dd2c62a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g88A5EpayS9DxyxE"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">劳伦·曼克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="ac08" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="1230" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">top K elements模式是一种技术，旨在返回给定集合中给定数量的最频繁/最大/最小的元素。</p><p id="edec" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">解决前K个元素问题的关键数据结构是堆。作为最大堆和最小堆的特征，我们总能高效地得到最大和最小元素，即O(logN)。</p><h1 id="4133" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">方法</h1><p id="8088" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们看一些例子。我们首先来看一个LeetCode medium问题— <a class="ae ky" href="https://leetcode.com/problems/kth-largest-element-in-an-array" rel="noopener ugc nofollow" target="_blank">数组</a>中的第k个最大元素。它要求我们在一组整数中找到给定数目的最大元素。</p><p id="56ba" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下是一些例子:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5f3d" class="mx la it mt b gy my mz l na nb">Input: [3,2,1,5,6,4] and k = 2<br/>Output: 5</span><span id="31a6" class="mx la it mt b gy nc mz l na nb">Input: [3,2,3,1,2,4,5,5,6] and k = 4<br/>Output: 4</span></pre><p id="6d47" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一个强力的解决方案是简单地对数组进行排序，并找出第k个位置的元素。但是，由于算法的排序功能，该方法将导致O(NlogN)。</p><p id="02ee" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">那么我们能不能提高这个算法的时间复杂度呢？</p><p id="ddce" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">绝对的。我们可以维护一个K大小的堆，而不是分别排序和搜索，这样可以同时存储和排序访问过的元素。</p><p id="0564" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是我们应该使用什么样的堆呢？基本上最小堆和最大堆都能得到正确的解。这里我们将解释如何通过最小堆来解决这个问题。</p><p id="8de0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">决定了数据结构之后，我们现在可以进入主流程了。通过top K elements模式解决这个问题的想法是保持min堆的给定大小。</p><p id="64a9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于根元素在最小堆中总是最小的，如果堆的大小大于K，根元素应该被丢弃，因为它是迄今为止第(K+1)个最大的元素。</p><p id="f56a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，算法过程将类似于:</p><ol class=""><li id="fbfd" class="nd ne it lt b lu mn lx mo ma nf me ng mi nh mm ni nj nk nl bi translated">遍历数组元素，并将它们放入一个K大小的最小堆中。如果堆的大小大于K，弹出根元素。重复此过程，直到数组结束。</li><li id="4e5b" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated">返回最小堆的根元素，因为它是整个数组的第k个最大元素。</li></ol><p id="350d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">算法的可视化如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/fe8f6a3f0251310f794025ff13a2e8f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0nJtpO8bEdwdJyhB7SOrjQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="b2c1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们可以轻松地编写代码实现了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1aed" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通过应用top K elements模式，我们可以将解的时间复杂度提高到O(NlogK)，其中根元素的提取是O(logK)，我们需要遍历整个数组。</p><p id="1566" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，我们要看看另一个LeetCode中值问题— <a class="ae ky" href="https://leetcode.com/problems/k-closest-points-to-origin" rel="noopener ugc nofollow" target="_blank"> K个离原点最近的点</a>。这与上面的问题有点不同，上面的问题要求我们找到K个最大的元素，而这个问题要求找到K个最小的元素。</p><p id="8684" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下是一些例子:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5eb5" class="mx la it mt b gy my mz l na nb">Input: points = [[1,3],[-2,2]], K = 1<br/>Output: [[-2,2]]<br/>Explanation: <br/>The distance between (1, 3) and the origin is sqrt(10).<br/>The distance between (-2, 2) and the origin is sqrt(8).<br/>Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.<br/>We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].</span><span id="cc53" class="mx la it mt b gy nc mz l na nb">Input: points = [[3,3],[5,-1],[-2,4]], K = 2<br/>Output: [[3,3],[-2,4]]</span></pre><p id="7cd9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">像以前一样，我们都知道我们可以通过堆来解决问题，但是，我们应该使用哪种堆呢？</p><p id="7524" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">同样，对于前k个元素的问题，我们总是可以通过最大堆或最小堆来解决它们。这和他们处理问题的方式有点不同。对于这一个，我们将使用一个最大堆来展示如何处理K个最小的问题。</p><p id="d919" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们定义最大堆的方式也需要小心。这次我们不是直接比较每个整数，而是比较每个点到原点的距离。</p><p id="9116" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以我们的最大堆应该定义为:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9651" class="mx la it mt b gy my mz l na nb">PriorityQueue&lt;int[]&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; (b[0] * b[0] + b[1] * b[1]) - (a[0] * a[0] + a[1] * a[1]))</span></pre><p id="32c9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nu nv nw mt b">(b[0] * b[0] + b[1] * b[1]) - (a[0] * a[0] + a[1] * a[1])</code>表示b到原点的距离和a到原点的距离的比较。</p><p id="5ca6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">解决方案的其余部分将与上一个问题相同，我们将维护一个K大小的最大堆。这个堆中的元素将是离原点最近的K个点。所以这个过程会是这样的:</p><ol class=""><li id="d5dc" class="nd ne it lt b lu mn lx mo ma nf me ng mi nh mm ni nj nk nl bi translated">遍历并将这些点插入到max堆中。如果最大堆大小超过K，弹出根元素，因为它是到目前为止第(K+1)个最接近原点的点，我们不需要它。</li><li id="3dab" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated">返回最终的最大堆作为结果。</li></ol><p id="7699" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">可视化如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/476c579646985380463de33522708396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5zkEBFlmMjIZGyIlkLITg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</figcaption></figure><p id="4e2d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，我们现在可以实现解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="cad1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该算法的时间复杂度为O(NlogK)，空间复杂度为O(K)。</p><h1 id="3a86" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="2d9b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最终，我们看到了两种top K元素问题分别由最小堆和最大堆解决。总之，顶部K元素模式可以分为两个步骤:</p><ol class=""><li id="7215" class="nd ne it lt b lu mn lx mo ma nf me ng mi nh mm ni nj nk nl bi translated">决定你想要使用哪种堆。小心堆初始化，尤其是元素之间的比较方式。</li><li id="7191" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated">保持堆大小小于K，如果大于K，提取根元素。重复这个过程，直到结束。</li></ol><h1 id="73ce" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">相关问题</h1><ol class=""><li id="5393" class="nd ne it lt b lu lv lx ly ma ny me nz mi oa mm ni nj nk nl bi translated"><a class="ae ky" href="https://leetcode.com/problems/kth-largest-element-in-an-array" rel="noopener ugc nofollow" target="_blank">数组中第k个最大的元素</a></li><li id="5266" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated"><a class="ae ky" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst" rel="noopener ugc nofollow" target="_blank">BST中第k个最小元素</a></li><li id="e3b5" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated"><a class="ae ky" href="https://leetcode.com/problems/top-k-frequent-elements" rel="noopener ugc nofollow" target="_blank">前K个频繁元素</a></li><li id="f284" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated"><a class="ae ky" href="https://leetcode.com/problems/sort-characters-by-frequency" rel="noopener ugc nofollow" target="_blank">按频率排序字符</a></li><li id="b0c0" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated"><a class="ae ky" href="https://leetcode.com/problems/course-schedule-iii" rel="noopener ugc nofollow" target="_blank">课程表三</a></li><li id="0a7a" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated"><a class="ae ky" href="https://leetcode.com/problems/find-k-closest-elements" rel="noopener ugc nofollow" target="_blank">找到K个最近的元素</a></li><li id="47dc" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated"><a class="ae ky" href="https://leetcode.com/problems/reorganize-string" rel="noopener ugc nofollow" target="_blank">重组琴弦</a></li><li id="f960" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated"><a class="ae ky" href="https://leetcode.com/problems/maximum-frequency-stack" rel="noopener ugc nofollow" target="_blank">最大频率叠加</a></li><li id="3b7b" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated"><a class="ae ky" href="https://leetcode.com/problems/k-closest-points-to-origin" rel="noopener ugc nofollow" target="_blank"> K个离原点最近的点</a></li></ol><h1 id="d9f8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">参考</h1><ol class=""><li id="d5d9" class="nd ne it lt b lu lv lx ly ma ny me nz mi oa mm ni nj nk nl bi translated"><a class="ae ky" href="https://www.educative.io/courses/grokking-the-coding-interview" rel="noopener ugc nofollow" target="_blank">寻找编码面试:编码问题的模式</a></li><li id="d567" class="nd ne it lt b lu nm lx nn ma no me np mi nq mm ni nj nk nl bi translated"><a class="ae ky" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank">leet code——全球领先的在线编程学习平台</a></li></ol></div></div>    
</body>
</html>