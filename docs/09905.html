<html>
<head>
<title>Shell Quest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Shell Quest</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/shell-quest-70bce7039a4e?source=collection_archive---------2-----------------------#2021-09-29">https://levelup.gitconnected.com/shell-quest-70bce7039a4e?source=collection_archive---------2-----------------------#2021-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/773a7bb4a1ca2ec929ae8d652d8c6bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EigEh4wzUWC8WIn7LgkrJw.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="3906" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">问题1 —外壳历史101</h2></div><p id="44da" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">欢迎来到Shell Quest的第一期！</p><p id="a5d8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在Shell Quest中，通过所有计算机上都有的用户界面——Shell，探索了从计算历史到现代软件工程的广泛主题</p><p id="1e92" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Shell Quest旨在像一本80年代的计算机杂志一样阅读，这些杂志附带了包含杂志中讨论的软件的盒式磁带或软盘。这很有趣，因为你可以立即尝试你正在阅读的内容。同样，每期Shell Quest都附带一个Docker映像，其中捆绑了该期的所有软件，已经安装并准备运行。</p><p id="89ac" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这也是一件非常80年代的事情:每期Shell Quest都包含一些小的代码片段，你可以在Shell中键入(当然也可以复制，但那样你会错过通过做魔术✨学习的机会)<br/>虽然享受Shell Quest并不要求你在shell中工作或者知道如何编程。如果您以前从未使用过shell，请不要担心，所有步骤都解释得很清楚。</p><p id="9ca9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在《Shell Quest》中，读者被置于Typealot博士的位置，他是一位好奇而富有冒险精神的计算机研究人员。作为Typealot博士，你可以在一个安全的Docker环境中试验和破坏东西。每当你陷入困境，只要重新启动环境。</p><p id="c964" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你已经知道如何使用命令行，并且已经在你的电脑上安装了Docker <a class="ae lp" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">和</a>，跳到下面的第一部分。</p><p id="9078" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你没有安装Docker(例如因为你在平板电脑上阅读这篇文章)，不用担心！您也可以在浏览器中运行Shell Quest容器，要了解其工作原理，请参阅下面的第2部分。</p><h2 id="47e8" class="lq lr je bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">1.用Docker运行Shell Quest</h2><p id="2b6d" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">确保Docker已经在你的电脑上安装了。接下来，打开终端并键入:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="50b8" class="lq lr je mt b gy mx my l mz na">$ docker run -it robvanderleek/sq-i1</span></pre><p id="f883" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这将下载Docker容器的所有部分(层)，然后启动它。一旦容器启动，您将看到Shell Quest欢迎屏幕:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nb"><img src="../Images/48f169d5b6a984d7ac7a5bf063ae7a2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZsseqKJ2V6iWw9KbByL6w.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">欢迎来到Shell Quest第1期！</figcaption></figure><h2 id="1370" class="lq lr je bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">2.在浏览器中运行Shell Quest</h2><ol class=""><li id="ca40" class="ng nh je kv b kw mj kz mk lc ni lg nj lk nk lo nl nm nn no bi translated">进入<a class="ae lp" href="https://labs.play-with-docker.com/" rel="noopener ugc nofollow" target="_blank">https://labs.play-with-docker.com/</a>并点击“登录”按钮</li><li id="66d1" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo nl nm nn no bi translated">如果这是你的第一次访问，创建一个Docker帐户</li><li id="8271" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo nl nm nn no bi translated">登录后，单击“添加新实例”按钮</li><li id="cf45" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo nl nm nn no bi translated">通过按[alt + enter]使终端全屏显示，然后键入:</li></ol><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="46da" class="lq lr je mt b gy mx my l mz na">$ docker run -it robvanderleek/sq-i1</span></pre><p id="0b24" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这将下载Docker容器的所有部分(层)，然后启动它。一旦容器启动，您将看到Shell Quest欢迎屏幕:</p><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nu"><img src="../Images/e67696d12ba3b417bfa741dad5638430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EzOvUZTrGTAk1Kz9FxjwTA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">欢迎来到Shell Quest第1期！</figcaption></figure></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="99a6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">此时，您应该已经启动并运行了Shell Quest容器。</p><p id="1413" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">都准备好了吗？</p><p id="2cf6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">太好了！</p><p id="c6ff" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在第一期中，我们将探索不同的Unix shells，让旅程开始吧...</p><h1 id="0712" class="oc lr je bd ls od oe of lv og oh oi ly kk oj kl mb kn ok ko me kq ol kr mh om bi translated">1.这一切的开始:汤普森外壳</h1><p id="c777" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">启动Shell Quest会将您放入汤普森Shell中。这个shell在1971年与第一个Unix版本一起发布，并以其创建者Ken Thompson的名字命名。你现在使用的shell的源代码被修改了一点，所以它可以在现代的Linux系统上运行，但是你基本上可以获得和70年代贝尔实验室的工程师们一样的体验。</p><p id="3ed4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe on oo op mt b">%</code>表示shell正在等待您的命令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c097" class="lq lr je mt b gy mx my l mz na">%</span></pre><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/b9b780ee4b184a803b6fa92c10ce5c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*e-Rfp1jfuXJ4Z5BYP0bJKA.jpeg"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">70年代的VT100终端，用于许多用户共享一台Unix计算机</figcaption></figure><p id="5f6c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们键入第一个命令来打印“Hello world”:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ce3b" class="lq lr je mt b gy mx my l mz na">% <strong class="mt jf">echo "Hello world"<br/></strong>Hello world</span></pre><p id="5666" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Thompson shell非常简单，几乎不提供内置功能。您告诉它执行的每个命令都必须是文件系统中的二进制文件。您可以使用<code class="fe on oo op mt b">which</code>命令来检查这一点:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4842" class="lq lr je mt b gy mx my l mz na">% <strong class="mt jf">which echo<br/></strong>/usr/bin/echo<br/>% <strong class="mt jf">which cat<br/></strong>/usr/bin/cat<br/>% <strong class="mt jf">which which</strong><br/>/usr/bin/which</span></pre><p id="38ab" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">尽管shell本身没有很多特性，但它确实实现了Unix哲学的一个非常重要的方面:重定向和管道。</p><p id="9c61" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">重定向允许您将程序的输出存储到文件中(<code class="fe on oo op mt b">&gt;</code>)，并将文件的内容输入到程序中(<code class="fe on oo op mt b">&lt;</code>):</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="cc43" class="lq lr je mt b gy mx my l mz na">% <strong class="mt jf">echo "Hello world" &gt; t.txt<br/></strong>% <strong class="mt jf">ls<br/></strong>bashcrawl  lsh piu-piu-SH  t.txt  tash<br/><strong class="mt jf">% cat t.txt<br/></strong>Hello world<strong class="mt jf"><br/></strong>% <strong class="mt jf">cut -c 1-5 &lt; t.txt</strong><br/>Hello</span></pre><p id="51e6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">管道(<code class="fe on oo op mt b">|</code>)将两个程序连接在一起，不使用中间文件:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d970" class="lq lr je mt b gy mx my l mz na">% <strong class="mt jf">echo "Hello world" | cut -c 1-5<br/></strong>Hello</span></pre><p id="b32d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">管道、重定向和小程序(执行特定任务)使得直接从命令行组合新功能成为可能:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="544b" class="lq lr je mt b gy mx my l mz na">% <strong class="mt jf">echo "Hello world" | cut -c 1-5 | figlet</strong><br/> _   _      _ _<br/>| | | | ___| | | ___<br/>| |_| |/ _ \ | |/ _ \<br/>|  _  |  __/ | | (_) |<br/>|_| |_|\___|_|_|\___/</span></pre><p id="0658" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">最初的Unix shell非常简单，只有1000多行C代码。你可以在网上或者你的Shell Quest环境中的目录<code class="fe on oo op mt b">tash</code>中找到源代码<a class="ae lp" href="https://github.com/begeekmyfriend/tash" rel="noopener ugc nofollow" target="_blank">(注意这个Shell不理解<code class="fe on oo op mt b">cd</code>命令，用<code class="fe on oo op mt b">chdir</code>代替)。<br/>你可以通过键入<code class="fe on oo op mt b">make</code>来编译代码，但是对C文件进行修改是有挑战性的，因为像<code class="fe on oo op mt b">nano</code>或<code class="fe on oo op mt b">vim</code>这样的编辑器在这个shell中不能正常运行。</a></p><p id="5cd1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们逃离70年代，看看sh已经成长为什么样子。按下[ctrl + d]键，你会发现自己置身于当代的汤普森shell: Bash中</p><h1 id="9b8c" class="oc lr je bd ls od oe of lv og oh oi ly kk oj kl mb kn ok ko me kq ol kr mh om bi translated">2.无处不在的那个:巴什</h1><p id="d967" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">终止Thompson shell会让您陷入Bash:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3540" class="lq lr je mt b gy mx my l mz na">% <strong class="mt jf">^D</strong> [typealot@shell-quest ~]$ <strong class="mt jf">echo $SHELL<br/></strong>/bin/bash</span></pre><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div class="gh gi or"><img src="../Images/c6a8e97ee6f62ef585ca575f1c5a0eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*jnUAFWD0NumLZWs_pHr7vQ.png"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated"><a class="ae lp" href="https://www.slideserve.com/farrah-head/shell-scripting" rel="noopener ugc nofollow" target="_blank">贝壳的历史</a></figcaption></figure><p id="f344" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">Bash不是Thompson shell的直接后代，而是Bourne shell的开源重建版本。Bourne shell是作为Thompson shell的继任者在贝尔实验室开发的。《谍影重重》的作者史蒂文·伯恩写的手稿实际上是一本很好的读物。Bash是Bourne-again shell的缩写。</p><p id="fbce" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可以在许多Linux发行版中找到Bash作为默认shell。您将在网上找到的大多数shell脚本都依赖于这个shell的内在特性。</p><h2 id="64a1" class="lq lr je bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">使用Bashcrawl像文本冒险一样探索shell</h2><p id="cb45" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">玩<a class="ae lp" href="https://gitlab.com/slackermedia/bashcrawl" rel="noopener ugc nofollow" target="_blank"> Bashcrawl </a>是学习如何使用贝壳的一种有趣且有创意的方式。Bashcrawl不需要预先了解shell命令，因此非常适合初学者。但是经验丰富的命令行爱好者也会喜欢在Bashcrawl的地下墓穴中四处闲逛。</p><p id="f76a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">要开始游戏，请进入<code class="fe on oo op mt b">bashcrawl</code>目录，故事将从那里展开:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c34f" class="lq lr je mt b gy mx my l mz na">[typealot@shell-quest ~]$ <strong class="mt jf">cd bashcrawl/</strong><br/>[typealot@shell-quest ~/bashcrawl]$ <strong class="mt jf">ls</strong><br/>LICENSE  README.md  entrance<br/>[typealot@shell-quest ~/bashcrawl]$ <strong class="mt jf">cd entrance/</strong><br/>[typealot@shell-quest ~/bashcrawl/entrance]$ <strong class="mt jf">ls</strong><br/>cellar  scroll<br/>[typealot@shell-quest ~/bashcrawl/entrance]$ <strong class="mt jf">cat scroll</strong></span><span id="7efd" class="lq lr je mt b gy os my l mz na">It is pitch black in these catacombs.<br/>You have a magical spell that lists all items in a room.</span><span id="741a" class="lq lr je mt b gy os my l mz na">To see in the dark, type:     ls<br/>To move around, type:         cd &lt;directory&gt;</span><span id="6c54" class="lq lr je mt b gy os my l mz na">Try looking around this room.<br/>Then move into one of the next rooms.</span><span id="02be" class="lq lr je mt b gy os my l mz na">EXAMPLE:</span><span id="5609" class="lq lr je mt b gy os my l mz na">$ ls<br/>$ cd cellar</span><span id="fefe" class="lq lr je mt b gy os my l mz na">Remember to cast ``ls`` when you get into the next room!</span></pre><h2 id="58bf" class="lq lr je bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">不到20行shell代码中的水平滚动条</h2><p id="c600" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">为了感受Bash shell的多功能性，让我们编写一个简单的shell脚本，在终端中显示一个水平文本滚动条。打开一个文本编辑器(安装了<code class="fe on oo op mt b">nano</code>和<code class="fe on oo op mt b">vim</code>),键入(或者复制，但是记住，只有键入才会产生神奇的✨)下面这段代码:</p><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="54eb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这段代码的作用:</p><ul class=""><li id="787c" class="ng nh je kv b kw kx kz la lc ov lg ow lk ox lo oy nm nn no bi translated">第1行:一个所谓的<a class="ae lp" href="https://en.wikipedia.org/wiki/Shebang_(Unix)" rel="noopener ugc nofollow" target="_blank"> shebang </a>行，指示在执行脚本时将使用什么解释器</li><li id="e67d" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo oy nm nn no bi translated">第2行:设置<code class="fe on oo op mt b">IFS</code>为空值允许换行符存储在变量中</li><li id="0575" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo oy nm nn no bi translated">第3行:将完整的横幅保存在一个名为<code class="fe on oo op mt b">banner</code>的变量中</li><li id="f194" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo oy nm nn no bi translated">第4行:获取终端中的列数</li><li id="1496" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo oy nm nn no bi translated">第5行:创建一个<code class="fe on oo op mt b">spacer</code>变量，将横幅移动到终端的最右边</li><li id="abc3" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo oy nm nn no bi translated">第6行:将隔板放在横幅前面</li><li id="7bcd" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo oy nm nn no bi translated">第7行:获取横幅的总长度</li><li id="e1f6" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo oy nm nn no bi translated">第8行:初始化<code class="fe on oo op mt b">start_index</code>变量</li><li id="2e16" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo oy nm nn no bi translated">第9行和第10行:无限while循环代码块的开始</li><li id="987e" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo oy nm nn no bi translated">第11-14行:清空屏幕并打印部分横幅(<code class="fe on oo op mt b">start_index</code>至<code class="fe on oo op mt b">end_index</code>)，之后将<code class="fe on oo op mt b">start_index</code>加1。一遍又一遍地这样做，创造出动画的错觉</li><li id="3a73" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo oy nm nn no bi translated">第15–17行:滚动完整的横幅时重置</li><li id="392c" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo oy nm nn no bi translated">第18行:短时间睡眠</li><li id="a285" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo oy nm nn no bi translated">第19行:while循环代码块的结尾</li></ul><p id="5347" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">将文件另存为<code class="fe on oo op mt b">scroller.sh</code>并使其可执行:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b032" class="lq lr je mt b gy mx my l mz na">$ <strong class="mt jf">chmod 755 scroller.sh</strong></span></pre><p id="bb04" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">接下来，通过将文本字符串输入滚动条来运行它:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f629" class="lq lr je mt b gy mx my l mz na">$ <strong class="mt jf">echo "Hello from the Bash shell!" | ./scroller.sh</strong></span></pre><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/a224bf28995adf3d4d1b3f35966dd98f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cNRZlKN8MQD2-iXQVfJ87Q.gif"/></div></div></figure><p id="5fcd" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可以通过按[ctrl + c]退出滚动条</p><h2 id="cccc" class="lq lr je bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">shell脚本中的一个水平滚动条游戏:Piu Piu</h2><p id="90a7" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">众所周知，游戏会挑战硬件和软件的极限，shell脚本游戏也不例外。惊讶于《Piu Piu》，<a class="ae lp" href="https://github.com/vaniacer/piu-piu-SH" rel="noopener ugc nofollow" target="_blank">用不到1500行Bash shell脚本代码</a>编写的横版游戏。你会在<code class="fe on oo op mt b">piu-piu-SH</code>目录中找到这个游戏:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c30b" class="lq lr je mt b gy mx my l mz na">$ <strong class="mt jf">cd ~/piu-piu-SH</strong><br/>$ <strong class="mt jf">./piu-piu</strong></span></pre><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/b6902d7d78a119a896d118572e94c923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Spz19A6pA5JHxcDPvKqiGg.gif"/></div></div></figure><h1 id="e368" class="oc lr je bd ls od oe of lv og oh oi ly kk oj kl mb kn ok ko me kq ol kr mh om bi translated">3.鲜为人知的一个:tcsh</h1><p id="fadc" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">C shell是在70年代后期由加州大学伯克利分校开发的。顾名思义，shell的语法类似于C编程语言。</p><p id="d982" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您的Shell Quest环境包含一个名为<code class="fe on oo op mt b">tsch</code>的C Shell兼容Shell，从Bash启动它，如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b97f" class="lq lr je mt b gy mx my l mz na">[typealot@shell-quest ~]$ <strong class="mt jf">tcsh</strong><br/>[typealot@shell-quest ~]$ <strong class="mt jf">echo $shell</strong><br/>/bin/tcsh<br/>[typealot@shell-quest ~]$</span></pre><p id="c0c4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">尽管C shell是BSD派生的Unix系统的默认版本，但它的流行程度已经不如Bourne shell派生版本(如Bash)。为C shell编写shell脚本对<a class="ae lp" href="https://www.grymoire.com/unix/CshTop10.txt" rel="noopener ugc nofollow" target="_blank">来说是一个挑战</a>。</p><h2 id="69a5" class="lq lr je bd ls lt lu dn lv lw lx dp ly lc lz ma mb lg mc md me lk mf mg mh mi bi translated">不到20行shell代码中的水平滚动条</h2><p id="7cb8" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">为了比较C Shell和Bourne Shell的语法，让我们修改水平scroller代码，使其在<code class="fe on oo op mt b">tcsh</code>中运行。复制(或者更好，键入✨)下面的列表，当然您也可以从Bash版本开始并对其进行修改。</p><figure class="mo mp mq mr gt iv"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="2ee8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">将文件另存为<code class="fe on oo op mt b">scroller.csh</code>，并使其可执行:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ae09" class="lq lr je mt b gy mx my l mz na">$ <strong class="mt jf">chmod 755 scroller.csh</strong></span></pre><p id="a2fe" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">接下来，通过将文本字符串输入滚动条来运行它:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5616" class="lq lr je mt b gy mx my l mz na">$ <strong class="mt jf">echo "Hello from the Tcsh shell!" | ./scroller.csh</strong></span></pre><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/e0d091d87af360ea6e53aa018d90d97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DRb_Lybgo4VyxorS2NGmDQ.gif"/></div></div></figure><p id="0b2a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">下面你可以看到Bash和Tcsh版本的水平滚动条的不同之处。抛开语法差异不谈，这两个脚本之间有两个有趣的区别:</p><ol class=""><li id="16b0" class="ng nh je kv b kw kx kz la lc ov lg ow lk ox lo nl nm nn no bi translated">Tcsh不保留shell变量中的所有空白，因此需要一个临时文件</li><li id="23e1" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo nl nm nn no bi translated">Tcsh支持基本的数学表达式，因此不需要外部程序(<code class="fe on oo op mt b">bc</code>)</li></ol><figure class="mo mp mq mr gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/0a1508a9e088df7e4a37828af23bf525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLtFyGQVCvVFlWKcQAf-Sg.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">水平外壳滚动条，左边是Bash版本，右边是Tcsh版本</figcaption></figure><h1 id="5762" class="oc lr je bd ls od oe of lv og oh oi ly kk oj kl mb kn ok ko me kq ol kr mh om bi translated">4.友好的:鱼</h1><p id="4163" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">Fish代表友好的交互式shell，是为用户编写的Shell，而不是为脚本编写的。与上面的贝壳相比，鱼是一个相对年轻的贝壳，因为它是在2005年首次发布的。</p><p id="9a00" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">通过键入<code class="fe on oo op mt b">fish</code>从Bash或Tcsh启动Fish shell:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d636" class="lq lr je mt b gy mx my l mz na">[typealot@shell-quest ~]$ <strong class="mt jf">fish</strong><br/>Welcome to fish, the friendly interactive shell<br/>Type `help` for instructions on how to use fish<br/>[typealot@shell-quest /home/typealot] $</span></pre><p id="9a74" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">通过许多不同的包管理器，Fish可用于许多操作系统。</p><p id="afc6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">鱼最大的优点之一是它内置的自我暗示功能。因为Fish会自动解析已安装的手册页，所以它可以帮助您处理难以记忆的命令行程序。<br/>例如，copy ( <code class="fe on oo op mt b">cp</code>)命令有一个递归复制目录的标志，但是有时你会弄不清这个标志是<code class="fe on oo op mt b">-r</code>还是<code class="fe on oo op mt b">-R</code></p><p id="c802" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">使用Fish，您可以开始输入:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5995" class="lq lr je mt b gy mx my l mz na">[typealot@shell-quest /home/typealot] $ <strong class="mt jf">cp -</strong></span></pre><p id="6130" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然后按下[tab]。然后Fish会给你一个简短的选项列表:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6117" class="lq lr je mt b gy mx my l mz na">[typealot@shell-quest /home/typealot] $ cp -a<br/>-a  --archive        (Same as -dpR)<br/>-b  --backup         (Make backup of each existing destination file)<br/>-d                   (Same as --no-dereference --preserve=link)<br/>-f  --force          (Do not prompt before overwriting)<br/>...and 24 more rows</span></pre><p id="0248" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">再次按下[tab]键会给你一个更长的选项列表。<br/>按[ctrl + s]打开搜索栏，过滤选项列表。例如，您可以在那里键入<code class="fe on oo op mt b">recur</code>:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="87f2" class="lq lr je mt b gy mx my l mz na">[typealot@shell-quest /home/typealot] $ cp -R<br/>search: <strong class="mt jf">recur</strong><br/>-R  -r  --recursive               (Copy directories recursively)<br/>--copy-contents  (Copy contents of special files when recursive)</span></pre><p id="ac74" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">使用[向上箭头]和[向下箭头]可以遍历过滤选项列表。</p><p id="cc29" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">上面演示的功能只是冰山一角，花点时间和Fish一起，在<a class="ae lp" href="https://fishshell.com/" rel="noopener ugc nofollow" target="_blank">https://fishshell.com/</a>上读一点关于它的特性。</p><h1 id="c9ac" class="oc lr je bd ls od oe of lv og oh oi ly kk oj kl mb kn ok ko me kq ol kr mh om bi translated">5.强大的那个:zsh</h1><p id="5e9f" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">Z Shell是一款正在迅速普及的现代Shell。苹果把它作为macOS Catalina的默认登录shell，所以如果你在Macbook上阅读这篇文章，它可能已经是你日常使用的shell了。</p><p id="b385" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这个shell在高级用户中非常受欢迎，因为它有一个插件架构，允许为许多终端任务定制它。也许在读完这一期的Shell Quest后，你会想把Z shell也作为你的默认Shell，但是让我们先试一试吧。</p><p id="0295" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">通过键入<code class="fe on oo op mt b">zsh</code>启动Z shell:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ee28" class="lq lr je mt b gy mx my l mz na">[typealot@shell-quest /home/typealot] $ <strong class="mt jf">zsh</strong><br/>[typealot@shell-quest ~]$</span></pre><p id="2da7" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">起初，提示符和shell的工作方式看起来和感觉上非常类似于Bash，但是请记住，Z shell是关于插件的。为Z shell编写插件取得了如此大的进步，以至于GitHub上最受欢迎的插件项目，名为“<a class="ae lp" href="https://ohmyz.sh/" rel="noopener ugc nofollow" target="_blank">哦，我的ZSH！</a>”，有超过1800个投稿人，超过133k星(！)</p><p id="5b1e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可以使用以下命令安装oh-my-zsh软件包:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="bef8" class="lq lr je mt b gy mx my l mz na">[typealot@shell-quest ~]$ <strong class="mt jf">sh -c "$(curl -fsSL </strong><a class="ae lp" href="https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh" rel="noopener ugc nofollow" target="_blank"><strong class="mt jf">https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh</strong></a><strong class="mt jf">)"</strong></span></pre><p id="f233" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">安装过程将自动开始:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a651" class="lq lr je mt b gy mx my l mz na">Cloning Oh My Zsh...<br/>Cloning into '/home/typealot/.oh-my-zsh'...<br/>remote: Enumerating objects: 1238, done.<br/>remote: Counting objects: 100% (1238/1238), done.<br/>remote: Compressing objects: 100% (1198/1198), done.<br/>remote: Total 1238 (delta 21), reused 1221 (delta 21), pack-reused 0<br/>Receiving objects: 100% (1238/1238), 862.23 KiB | 2.36 MiB/s, done.<br/>Resolving deltas: 100% (21/21), done.</span><span id="0475" class="lq lr je mt b gy os my l mz na">Looking for an existing zsh config...<br/>Found ~/.zshrc. Backing up to /home/typealot/.zshrc.pre-oh-my-zsh<br/>Using the Oh My Zsh template file and adding it to ~/.zshrc.</span><span id="f527" class="lq lr je mt b gy os my l mz na">Time to change your default shell to zsh:<br/>Do you want to change your default shell to zsh? [Y/n] <strong class="mt jf">Y</strong><br/>Changing the shell...<br/>Password: <strong class="mt jf">joshua</strong><br/>Shell successfully changed to '/usr/bin/zsh'.</span><span id="4044" class="lq lr je mt b gy os my l mz na">__                                     __<br/>  ____  / /_     ____ ___  __  __   ____  _____/ /_<br/> / __ \/ __ \   / __ `__ \/ / / /  /_  / / ___/ __ \<br/>/ /_/ / / / /  / / / / / / /_/ /    / /_(__  ) / / /<br/>\____/_/ /_/  /_/ /_/ /_/\__, /    /___/____/_/ /_/<br/>                        /____/                       ....is now installed!</span><span id="8fe0" class="lq lr je mt b gy os my l mz na">Before you scream Oh My Zsh! please look over the ~/.zshrc file to select plugins, themes, and options.</span><span id="1b70" class="lq lr je mt b gy os my l mz na">• Follow us on Twitter: <a class="ae lp" href="https://twitter.com/ohmyzsh" rel="noopener ugc nofollow" target="_blank">https://twitter.com/ohmyzsh</a><br/>• Join our Discord server: <a class="ae lp" href="https://discord.gg/ohmyzsh" rel="noopener ugc nofollow" target="_blank">https://discord.gg/ohmyzsh</a><br/>• Get stickers, shirts, coffee mugs and other swag: <a class="ae lp" href="https://shop.planetargon.com/collections/oh-my-zsh" rel="noopener ugc nofollow" target="_blank">https://shop.planetargon.com/collections/oh-my-zsh</a></span><span id="b120" class="lq lr je mt b gy os my l mz na">➜  ~</span></pre><p id="481f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当安装完成后，你会注意到你的提示已经改变。<br/>默认情况下,<a class="ae lp" href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git" rel="noopener ugc nofollow" target="_blank"> oh-my-zsh Git插件</a>被激活，当使用Git库时，它给你的shell提供了方便的别名和有用的反馈。要了解这是如何工作的，进入<code class="fe on oo op mt b">tash</code>目录并尝试几个git命令<a class="ae lp" href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git#readme" rel="noopener ugc nofollow" target="_blank">别名</a>:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2b79" class="lq lr je mt b gy mx my l mz na">➜  ~ <strong class="mt jf">cd tash</strong><br/>➜  tash git:(master) <strong class="mt jf">gcb my-branch</strong><br/>Switched to a new branch 'my-branch'<br/>➜  tash git:(my-branch) <strong class="mt jf">echo "Hello world" &gt; t.txt</strong><br/>➜  tash git:(my-branch) ✗ <strong class="mt jf">gts<br/></strong>On branch my-branch<br/>Untracked files:<br/>  (use "git add &lt;file&gt;..." to include in what will be committed)<br/> t.txt</span><span id="3a9c" class="lq lr je mt b gy os my l mz na">nothing added to commit but untracked files present (use "git add" to track)</span></pre><p id="ab95" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">oh-my-zsh包<a class="ae lp" href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins" rel="noopener ugc nofollow" target="_blank">带有超过275个可以被激活的插件</a>。通过将它们添加到<code class="fe on oo op mt b">~/.zshrc</code>中的列表来尝试一些，然后启动一个新的<code class="fe on oo op mt b">zsh</code>实例。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9451" class="lq lr je mt b gy mx my l mz na">Which plugins would you like to load?<br/># Standard plugins can be found in $ZSH/plugins/<br/># Custom plugins may be added to $ZSH_CUSTOM/plugins/<br/># Example format: plugins=(rails git textmate ruby lighthouse)<br/># Add wisely, as too many plugins slow down shell startup.<br/>plugins=(git)</span></pre><h1 id="e339" class="oc lr je bd ls od oe of lv og oh oi ly kk oj kl mb kn ok ko me kq ol kr mh om bi translated">6.独一无二的:你自己的壳</h1><p id="108e" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">至此，您已经探索了这么多不同的shellss，您可能想编写自己的shell。<br/>尽管上面讨论的一些shell功能非常丰富，但是shell的本质可以归结为3个简单的步骤:</p><ol class=""><li id="597f" class="ng nh je kv b kw kx kz la lc ov lg ow lk ox lo nl nm nn no bi translated">读取输入</li><li id="67e7" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo nl nm nn no bi translated">解析输入</li><li id="9272" class="ng nh je kv b kw np kz nq lc nr lg ns lk nt lo nl nm nn no bi translated">执行命令</li></ol><p id="8705" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">斯蒂芬·布伦南的这篇简短教程中讨论了一个不到300行C代码的工作外壳，它实现了这些步骤。</p><p id="9d1b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">您可以在<code class="fe on oo op mt b">lsh</code>目录中找到代码，并像这样编译单个源文件:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8395" class="lq lr je mt b gy mx my l mz na">[typealot@shell-quest ~]$ <strong class="mt jf">cd lsh/</strong><br/>[typealot@shell-quest ~/lsh]$ <strong class="mt jf">gcc -o lsh src/main.c</strong><br/>[typealot@shell-quest ~/lsh]$ <strong class="mt jf">ls</strong><br/>README.md UNLICENSE lsh src<br/>[typealot@shell-quest ~/lsh]$ <strong class="mt jf">./lsh<br/></strong>&gt; <strong class="mt jf">echo "Hello from my own shell!"</strong><br/>"Hello from my own shell!"</span></pre><p id="9b32" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你懂一点C，并且想尝试一个疯狂的shell新特性:快乐编码！</p><h1 id="9093" class="oc lr je bd ls od oe of lv og oh oi ly kk oj kl mb kn ok ko me kq ol kr mh om bi translated">直到下次泰佩洛特医生！</h1><p id="c080" class="pw-post-body-paragraph kt ku je kv b kw mj kf ky kz mk ki lb lc ml le lf lg mm li lj lk mn lm ln lo im bi translated">这就是第一期Shell Quest的内容。</p><p id="6531" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你不喜欢这一期的(部分)，请在下面留下评论。我会回复所有的评论、批评、问题等。</p><p id="5a14" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果您喜欢阅读这一期，请点击👏另外，如果你喜欢交互式Docker容器，请让⭐️主演GitHub repo:</p><div class="is it gp gr iu pc"><a href="https://github.com/robvanderleek/shell-quest" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd jf gy z fp ph fr fs pi fu fw jd bi translated">GitHub-robvanderleek/shell-quest</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">Permalink无法加载最新的提交信息。没有提供描述、网站或主题。你不能表演那个…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">github.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq ja pc"/></div></div></a></div><p id="d244" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果您对下一期Shell Quest主题有任何建议，请在下面留下您的评论。当前暂定的主题列表:API(在shell中使用它们)、编辑器、版本控制系统、脚本语言、游戏。</p></div></div>    
</body>
</html>