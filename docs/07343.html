<html>
<head>
<title>Docker and .Net — Environment variables and appsettings.json</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头工人和。Net —环境变量和appsettings.json</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/docker-environment-variables-appsettings-json-net-bdac052bf3db?source=collection_archive---------0-----------------------#2021-02-11">https://levelup.gitconnected.com/docker-environment-variables-appsettings-json-net-bdac052bf3db?source=collection_archive---------0-----------------------#2021-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e9acab6fb46a701561092311333b1121.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cKbcLqpu-GkEPVWz"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">卡尔·帕夫洛维奇在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的照片</figcaption></figure><p id="699e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你已经和。网络，又名。你可能已经注意到在<em class="le"> appsetting.json </em>文件中存储一些设置是多么方便。除了使用一个<em class="le"> JSON </em>文件的灵活性之外，获取和管理这些信息的方式非常简单。</p><p id="6ee0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果您在Docker容器中运行应用程序，并且出于某种原因想要对其进行更改，这可能会有点复杂。<br/>尽管如此，使用环境变量的概念还是很有帮助的。</p><h1 id="3ecd" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">问题是</h1><p id="7b97" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">假设我们的应用程序运行在Docker容器中。但是，我们需要每个客户有一个或多个容器，每个客户有不同的设置。那么，我们能做些什么来解决这个问题呢？</p><h1 id="bc49" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">应用程序</h1><p id="d7a9" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">为了说明这个问题，我创建了一个只有一个端点的非常简单的Web API。这个端点的功能很简单，只需要从appsettings.json中读取设置并显示出来即可。如果你愿意，你可以从Github克隆完整的源代码:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3bf7" class="mr lg it mn b gy ms mt l mu mv">git clone https://github.com/lbazetto/DockerEnvironmentVariablesDotNet</span></pre><h2 id="c347" class="mr lg it bd lh mw mx dn ll my mz dp lp kr na nb lt kv nc nd lx kz ne nf mb ng bi translated">appsettings.json文件</h2><p id="06ef" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在appsettings.json中，我们保留了所有的默认值，只是增加了两个部分:<br/> - MyFirstValueCustomConfig —简单字符串<br/> - ComplexConfig —带有子对象的数组</p><p id="afc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完整文件:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="49f7" class="mr lg it bd lh mw mx dn ll my mz dp lp kr na nb lt kv nc nd lx kz ne nf mb ng bi translated">web API端点</h2><p id="33fc" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">因为端点为我们做的唯一事情是从appsettings.json文件中读取数据，所以我们的代码可以是这样的:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="95fc" class="mr lg it bd lh mw mx dn ll my mz dp lp kr na nb lt kv nc nd lx kz ne nf mb ng bi translated">文档文件</h2><p id="906a" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Dockerfile文件也非常基本:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="fa10" class="mr lg it bd lh mw mx dn ll my mz dp lp kr na nb lt kv nc nd lx kz ne nf mb ng bi translated">输出</h2><p id="3b75" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">运行应用程序，到达端点(<a class="ae kf" href="http://localhost:5000/settings" rel="noopener ugc nofollow" target="_blank">http://localhost:5000/settings</a>)我们将得到结果:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="9997" class="mr lg it mn b gy ms mt l mu mv">["I'm the first custom setting","Hi, Complex!"]</span></pre><p id="afd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，现在我们有了问题和应用，让我们探索解决方案。</p><h1 id="dd23" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">解决方法</h1><p id="2959" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我们的想法是尝试展示不同的解决方案，以及每种方案的优缺点。</p><h2 id="9aa5" class="mr lg it bd lh mw mx dn ll my mz dp lp kr na nb lt kv nc nd lx kz ne nf mb ng bi translated">解决方案1 —每个客户一个Docker图像</h2><p id="628e" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">首先，我们可以用所有默认设置创建一个基础图像。然后，为每个客户建立一个包含这些新价值的新形象。</p><p id="3e1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">优点:<br/> -每个客户的独立定义<br/> -在您想要为特定客户实现某些东西的场景中会很有帮助(这是我一直试图避免的😂)</p><p id="9cf5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">缺点:<br/> -难以维护<br/> -存储消耗高</p><h2 id="55dd" class="mr lg it bd lh mw mx dn ll my mz dp lp kr na nb lt kv nc nd lx kz ne nf mb ng bi translated">解决方案2 — Docker卷</h2><p id="2bd2" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">其次，我们可以使用卷。这是什么？遵循关于<a class="ae kf" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank">卷</a>的docker定义，我们有:</p><blockquote class="nj nk nl"><p id="6d7f" class="kg kh le ki b kj kk kl km kn ko kp kq nm ks kt ku nn kw kx ky no la lb lc ld im bi translated">卷是保存Docker容器生成和使用的数据的首选机制。</p></blockquote><p id="cfd2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我看来，这将比我们的第一个解决方案更好，因为我们可以对所有客户使用相同的基础映像，并且每个客户只有一个不同的文件。</p><p id="dcc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们在根目录中有一个名为CustomerSettings的文件夹，如下所示:</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div class="gh gi np"><img src="../Images/6ff6e42e9990547d607613f28b5c2803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*jg-IyGn-sdhO6tQeWFCVAg.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">客户设置</figcaption></figure><p id="197f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该卷的另一个优点是无需编码就能自动重命名文件/文件夹。这样，不管我们在容器外部为文件选择什么名称，在容器内部我们总是期望相同的名称(appsettings.json)。docker-compose文件可能是这样的:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">docker-用卷合成文件</figcaption></figure><p id="ad93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，这种方法的缺点是要按照您的容器编制器/云提供商的规则/要求来管理和配置数据存储。这个提案的概述是:</p><p id="9639" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">优点:<br/> -所有客户的基本形象相同</p><p id="b556" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">缺点:<br/> -存储管理</p><h2 id="8e58" class="mr lg it bd lh mw mx dn ll my mz dp lp kr na nb lt kv nc nd lx kz ne nf mb ng bi translated">解决方案3 —环境变量</h2><p id="8637" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">除此之外，还有另一种非常有用的方法，可以混合上述解决方案的优点，即<a class="ae kf" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/environments" rel="noopener ugc nofollow" target="_blank">环境变量</a>。<br/>根据维基百科<a class="ae kf" href="https://en.wikipedia.org/wiki/Environment_variable" rel="noopener ugc nofollow" target="_blank">的定义</a>:</p><blockquote class="nj nk nl"><p id="d3eb" class="kg kh le ki b kj kk kl km kn ko kp kq nm ks kt ku nn kw kx ky no la lb lc ld im bi translated">环境变量是一个动态命名的值，它可以影响计算机上正在运行的进程的行为方式。它们是流程运行环境的一部分。</p></blockquote><p id="51f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除此之外，Docker有一个很好的机制来处理这个资源。</p><p id="8722" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，解决方案2的想法是只有一个基础映像，并为每个容器设置数据。按照上面例子的相同概念，我们将使用docker-compose文件来注入信息。但是现在，我们将替换环境变量的卷:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c60b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">优点:<br/> -所有客户使用相同的基本映像<br/> -没有存储管理</p><p id="084f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">缺点:<br/> -依赖于变量/结构的数量可能很难维护</p><h1 id="3c06" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="2ed3" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在docker容器中使用环境变量可能是一个很好的匹配，因为您可以提取这种组合的优点，而无需向应用程序添加额外的代码。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="fc2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，你觉得怎么样？你喜欢用另一种方法吗？这对你有帮助吗？随时欢迎反馈！</p><p id="ff37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">非常感谢您的宝贵时间！👋</p></div></div>    
</body>
</html>