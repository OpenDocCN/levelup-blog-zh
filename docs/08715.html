<html>
<head>
<title>Event-driven architecture for dummies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向虚拟对象的事件驱动架构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/event-driven-architecture-for-dummies-222c7b930e5f?source=collection_archive---------4-----------------------#2021-05-28">https://levelup.gitconnected.com/event-driven-architecture-for-dummies-222c7b930e5f?source=collection_archive---------4-----------------------#2021-05-28</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="5caa" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用AWS和Terraform的简单示例。</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/b51a34749cb869500071cc1fc92ebb8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zs0FbsTA02Smnufh"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kz" href="https://unsplash.com/@serejaris?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sereja Ris </a>拍摄的照片</figcaption></figure><p id="9d3b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">设计软件时，有许多架构模式可供我们选择。我们有每个人都试图逃离的单块应用程序，也有每个人都努力追求的微服务。我想谈谈事件驱动架构。</p><h1 id="31b1" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated"><strong class="ak">事件驱动架构对应用程序状态的变化做出反应。</strong></h1><p id="d5cd" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">为了说明这一点，让我们制作一个简单的应用程序。该应用程序的目的是上传姓名和电子邮件的CSV文件，并模拟批量创建用户帐户的过程。插入每个用户后，我们会向他们发送一封欢迎电子邮件。</p><p id="01ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有些事情要先做。<a class="ae kz" href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses-procedure.html" rel="noopener ugc nofollow" target="_blank">如果您的SES处于沙盒模式，您应该验证至少一个电子邮件地址，以便发送和接收电子邮件。</a></p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><p id="81d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该应用程序由以下部分组成:</p><ul class=""><li id="0fdf" class="na nb iu lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated">一个S3桶上传我们的CSV文件。上传的文件将使用<a class="ae kz" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lifecycle-mgmt.html" rel="noopener ugc nofollow" target="_blank"> S3生命周期规则</a>自动删除。</li><li id="3be5" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">处理新插入的SQS队列。为了获得更可靠的解决方案，我们应该添加一个<a class="ae kz" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html" rel="noopener ugc nofollow" target="_blank"> DLQ </a>。</li><li id="63c5" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">一个DynamoDB表来存储我们的用户。<a class="ae kz" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html" rel="noopener ugc nofollow" target="_blank">流</a>将被启用。</li><li id="fd28" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">三个Lambda函数:1)处理CSV文件，2)将记录插入DynamoDB表，3)发送欢迎电子邮件</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj no"><img src="../Images/ee89a34322e06eee7367f905b20825ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*niAuDlBt7nOz3zyE6mSH1A.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">事件驱动架构图</figcaption></figure><p id="10f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">解释图表的时间到了:</p><ol class=""><li id="4c60" class="na nb iu lc b ld le lg lh lj nc ln nd lr ne lv np ng nh ni bi translated">我们上传一个CSV文件到S3桶。上传可以从前端或对S3的API调用进行。我们在S3桶上启用了通知，因此每次有上传时，我们都会触发<code class="fe nq nr ns nt b">process_csv</code> Lambda函数。</li><li id="2382" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv np ng nh ni bi translated"><code class="fe nq nr ns nt b">process_csv</code> Lambda函数将解析CSV文件，并一次向我们的<code class="fe nq nr ns nt b">buffer_queue</code> SQS队列发送10条记录。</li><li id="58f1" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv np ng nh ni bi translated">当新记录在<code class="fe nq nr ns nt b">buffer_queue</code> SQS队列中时，将执行<code class="fe nq nr ns nt b">insert_records</code> Lambda函数。它将抓取这些记录，并批量插入到我们的<code class="fe nq nr ns nt b">users</code> DynamoDB表中。我们配置了启用了<code class="fe nq nr ns nt b">streams</code>的表，因此在新插入时，它将触发<code class="fe nq nr ns nt b">send_email</code> Lambda函数。</li><li id="21e9" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv np ng nh ni bi translated">λ会给新用户发送一封电子邮件。</li></ol></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><p id="cb2b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Terraform代码来匹配和解释上述步骤:</p><p id="f895" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">1)要创建S3桶，我们可以编写以下代码。定义参数<code class="fe nq nr ns nt b">lifecycle_rule</code>将在我们上传CSV文件一天后自动删除它们。这将使我们的水桶长时间保持清洁，并避免支付存储费用。</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="d8f5" class="ny lx iu nt b gz nz oa l ob oc">resource "aws_s3_bucket" "uploads" {<br/>  bucket        = "my-custom-uploads"<br/>  acl           = "private"</span><span id="2f42" class="ny lx iu nt b gz od oa l ob oc">  lifecycle_rule {<br/>    id      = "my-custom-uploads-object-removal-rule"<br/>    enabled = true<br/>    expiration {<br/>      days = 1<br/>    }<br/>  }<br/>}</span></pre><p id="e710" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来我们定义一个Lambda函数，它将在每次上传后处理我们的CSV文件。为了触发Lambda函数，我们需要定义一个<a class="ae kz" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/NotificationHowTo.html" rel="noopener ugc nofollow" target="_blank"> S3通知</a>，并向Lambda函数添加权限，以便S3桶可以执行它。</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="da8a" class="ny lx iu nt b gz nz oa l ob oc">resource "aws_lambda_function" "process_csv" {<br/>  filename = "path/to/lambda/zip/file"<br/>  function_name = "myCustomFunction"<br/>  role = aws_iam_role.role.arn<br/>  handler = "handler"<br/>  source_code_hash = filebase64sha256("path/to/lambda/zip/file")<br/>  runtime = "nodejs14.x"<br/>  memory_size = 1024<br/>  timeout = 30<br/>}</span><span id="de17" class="ny lx iu nt b gz od oa l ob oc">resource "aws_lambda_permission" "process_csv_allow_s3" {<br/>  statement_id  = "${var.name}-process-csv-AllowExecutionFromS3"<br/>  action        = "lambda:InvokeFunction"<br/>  function_name = aws_lambda_function.process_csv.function_name<br/>  principal     = "s3.amazonaws.com"<br/>  source_arn    = aws_s3_bucket.uploads.arn<br/>}</span><span id="f31c" class="ny lx iu nt b gz od oa l ob oc">resource "aws_s3_bucket_notification" "bucket_notification" {<br/>  bucket = var.uploads_bucket_name<br/>  lambda_function {<br/>    id                  = "uploads-event-process-csv"<br/>    lambda_function_arn = aws_lambda_function.process_csv.arn<br/>    events              = ["s3:ObjectCreated:*"]<br/>  }<br/>}</span></pre><p id="e97a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">2)现在我们的Lambda函数将处理这些CSV文件，并一次向SQS队列发送10条记录。通过这样做，我们可以抑制对Lambda函数的调用，该函数会将记录插入到DynamoDB表中。</p><p id="cb7c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">3)为了保存记录，我们需要创建一个SQS队列、一个Lambda函数和一个启用了流的DynamoDB表。通过启用这个特性，我们可以自动调用我们的第三个Lambda函数，并向新用户发送电子邮件。</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="6418" class="ny lx iu nt b gz nz oa l ob oc">resource "aws_sqs_queue" "buffer_queue" {<br/>  name = "my-custom-buffer-queue"<br/>}</span><span id="14f7" class="ny lx iu nt b gz od oa l ob oc">resource "aws_lambda_function" "insert_records" {<br/>  filename = "path/to/lambda/zip/file"<br/>  function_name = "myCustomFunction"<br/>  role = aws_iam_role.role.arn<br/>  handler = "handler"<br/>  source_code_hash = filebase64sha256("path/to/lambda/zip/file")<br/>  runtime = "nodejs14.x"<br/>  memory_size = 1024<br/>  timeout = 30<br/>}</span><span id="3bb2" class="ny lx iu nt b gz od oa l ob oc">resource "aws_dynamodb_table" "users" {<br/>  name              = "my-custom-users"<br/>  billing_mode      = "PAY_PER_REQUEST"<br/>  hash_key          = "type"<br/>  stream_enabled    = true<br/>  stream_view_type  = "NEW_IMAGE"<br/>  attribute {<br/>    name = "type"<br/>    type = "S"<br/>  }<br/>}</span></pre><p id="9aa0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">需要记住的一件重要事情是，处理记录插入的Lambda函数需要从SQS队列中接收和删除消息的权限。</strong></p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="b5d4" class="ny lx iu nt b gz nz oa l ob oc">data "aws_iam_policy_document" "sqs" {<br/>  policy_id = "my-custom-lambda-sqs"<br/>  version   = "2012-10-17"</span><span id="b282" class="ny lx iu nt b gz od oa l ob oc">  statement {<br/>    effect  = "Allow"<br/>    actions = [<br/>      "sqs:ReceiveMessage",<br/>      "sqs:DeleteMessage",<br/>      "sqs:GetQueueAttributes"<br/>    ]</span><span id="5795" class="ny lx iu nt b gz od oa l ob oc">    resources = [aws_sqs_queue.buffer_queue.arn]<br/>  }<br/>}</span></pre><p id="4170" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们需要通过<code class="fe nq nr ns nt b"><a class="ae kz" href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html" rel="noopener ugc nofollow" target="_blank">event_source_mapping</a></code>将Lambda函数与SQS队列连接起来，并向Lambda函数添加权限，以便SQS队列可以执行它。</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="e222" class="ny lx iu nt b gz nz oa l ob oc">resource "aws_lambda_event_source_mapping" "buffer_queue" {<br/>  event_source_arn = aws_sqs_queue.buffer_queue.arn<br/>  function_name    = aws_lambda_function.insert_records.arn<br/>}</span><span id="2487" class="ny lx iu nt b gz od oa l ob oc">resource "aws_lambda_permission" "buffer_queue_execution" {<br/>  statement_id  = "${var.name}-buffer-queue-AllowExecutionFromSQS"<br/>  action        = "lambda:InvokeFunction"<br/>  function_name = aws_lambda_function.insert_records.function_name<br/>  principal     = "sqs.amazonaws.com"<br/>  source_arn    = aws_sqs_queue.buffer_queue.arn<br/>}</span></pre><p id="a43f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">4)我们的Lambda函数将插入新记录，但我们需要监听这些插入。我们已经在表上启用了DynamoDB流，所以我们只需要连接一个Lambda函数，就可以发送欢迎电子邮件了。</p><p id="745c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">需要记住的一件重要事情是，处理电子邮件发送的Lambda函数需要权限来接收来自DynamoDB流的数据。</strong></p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="bf0b" class="ny lx iu nt b gz nz oa l ob oc">data "aws_iam_policy_document" "dynamodb" {<br/>  policy_id = "my-custom-lambda-dynamodb"<br/>  version   = "2012-10-17"</span><span id="249f" class="ny lx iu nt b gz od oa l ob oc">statement {<br/>    effect  = "Allow"<br/>    actions = [<br/>      "dynamodb:GetRecords",<br/>      "dynamodb:GetShardIterator",<br/>      "dynamodb:DescribeStream",<br/>      "dynamodb:ListShards",<br/>      "dynamodb:ListStreams"<br/>    ]</span><span id="5b28" class="ny lx iu nt b gz od oa l ob oc">    resources = [aws_dynamodb_table.users.arn]<br/>  }<br/>}</span></pre><p id="45d1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们需要通过<code class="fe nq nr ns nt b">event_source_mapping</code>将Lambda函数与DynamoDB流连接起来，并向Lambda函数添加权限，以便DynamoDB流可以执行它。</p><p id="e9ff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们再次定义了Lambda函数，并添加了适当的权限来读取DynamoDB流并执行Lambda函数。</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="ead2" class="ny lx iu nt b gz nz oa l ob oc">resource "aws_lambda_function" "send_email" {<br/>  filename = "path/to/lambda/zip/file"<br/>  function_name = "myCustomFunction"<br/>  role = aws_iam_role.role.arn<br/>  handler = "handler"<br/>  source_code_hash = filebase64sha256("path/to/lambda/zip/file")<br/>  runtime = "nodejs14.x"<br/>  memory_size = 1024<br/>  timeout = 30<br/>}</span><span id="9a0a" class="ny lx iu nt b gz od oa l ob oc">resource "aws_lambda_event_source_mapping" "send_email" {<br/>  event_source_arn = aws_dynamodb_table.users.stream_arn<br/>  function_name    = aws_lambda_function.send_email.arn<br/>}</span><span id="e00e" class="ny lx iu nt b gz od oa l ob oc">resource "aws_lambda_permission" "send_email_execution" {<br/>  statement_id  = "send-email-AllowExecutionFromDynamoDB"<br/>  action        = "lambda:InvokeFunction"<br/>  function_name = aws_lambda_function.send_email.function_name<br/>  principal     = "sqs.amazonaws.com"<br/>  source_arn    = aws_dynamodb_table.users.stream_arn<br/>}</span></pre></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><p id="b066" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要查看完整的解决方案，您可以<a class="ae kz" href="https://github.com/jagonzalr/event-driven-architecture-example" rel="noopener ugc nofollow" target="_blank">克隆repo </a>并在您的AWS帐户上部署该解决方案。Lambda函数的实际代码可以用AWS 支持的任何l <a class="ae kz" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html" rel="noopener ugc nofollow" target="_blank">语言编写。在示例repo中，它是用Node.js编写的</a></p></div><div class="ab cl mt mu hy mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="in io ip iq ir"><p id="18a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你上传了正确格式的CSV文件，几秒钟后你会收到一封电子邮件。就这样，您刚刚构建并部署了您的第一个事件驱动的解决方案🎉</p><div class="oe of gq gs og oh"><a href="https://blog.jagonzalr.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fp"><div class="oj ab ok cl cj ol"><h2 class="bd iv gz z fq om fs ft on fv fx it bi translated">加入我的介绍链接媒体-何塞安东尼奥冈萨雷斯罗德里格斯</h2><div class="oo l"><h3 class="bd b gz z fq om fs ft on fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="op l"><p class="bd b dl z fq om fs ft on fv fx dk translated">blog.jagonzalr.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov kt oh"/></div></div></a></div></div></div>    
</body>
</html>