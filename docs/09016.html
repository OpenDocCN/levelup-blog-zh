<html>
<head>
<title>A comprehensive guide to pytest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">pytest综合指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-comprehensive-guide-to-pytest-3676f05df5a0?source=collection_archive---------1-----------------------#2021-06-29">https://levelup.gitconnected.com/a-comprehensive-guide-to-pytest-3676f05df5a0?source=collection_archive---------1-----------------------#2021-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="81d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">欢迎来到丛林，我们有乐趣和游戏！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/11506710a5ae2c65963de95853ed40f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4I24BXEASIFqjiDx"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">不可否认，测试的丛林绝不是<em class="kv">而是</em>“乐趣和游戏”—照片由<a class="ae kw" href="https://unsplash.com/@debrupas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pascal Debrunner </a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6896" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="lt">测试</em>。软件工程的一个方面引起了来自世界各地开发者的抱怨。虽然我没有万灵药，但是如果您正在使用Python，并且需要关于单元测试(使用pytest)的详尽文献，就不要再找了。</p><p id="902d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了获得这样的知识，我跌跌撞撞地穿过神秘的文档森林，深入到Stack Overflow充满敌意的水域，在谷歌无情的山脉中跨过第37页陡峭的悬崖。希望这是你在这个话题上需要的最后一篇文章。</p><h1 id="e33a" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">入门指南</h1><p id="5107" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">安装pytest和相关依赖项:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="5c7e" class="mw lv iq ms b gy mx my l mz na">pipenv install --dev pytest pytest-cov pytest-mock</span></pre><p id="9cb4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">还有更多的插件，但是在你需要任何其他东西之前，覆盖率和模拟应该还有很长的路要走。</p><p id="6252" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我还使用了一个名为<em class="lt"> pipenv </em>的包管理器，我强烈推荐这个包管理器，它可以轻松方便地管理包。Opensource.com有一篇关于为什么你应该用它而不是香草的极好的文章。</p><h1 id="7cc2" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated"><em class="kv"> pytest </em>设置</h1><p id="4ab8" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">将一个<code class="fe nb nc nd ms b">conftest.py</code>文件放在项目的根目录下。该文件:</p><ul class=""><li id="1906" class="ne nf iq kz b la lb ld le lg ng lk nh lo ni ls nj nk nl nm bi translated">包含pytest的“全局”设置，包括标记注册(稍后将详细介绍)和全局共享的fixtures(稍后也将详细介绍)</li><li id="e0b3" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">负责给pytest范围；通过将文件放入根目录，pytest将识别src模块，而不需要手动将其添加到<code class="fe nb nc nd ms b">PYTHONPATH</code></li></ul><p id="7b7f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">pytest在发现测试方面做得很好，所以实际的测试可以放在任何地方。我推荐以下文件夹结构:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="8444" class="mw lv iq ms b gy mx my l mz na">/<br/>|- &lt;project name&gt;/<br/>|- tests/<br/>   |- acceptance/<br/>   |- unit/<br/>      |- # tests go here</span></pre><p id="f270" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">开箱即用，所有pytest测试文件必须以<em class="lt">为前缀</em>或<em class="lt">为后缀</em>并带有“test<em class="lt">”</em>(单数)。例如，如果你正在测试一个叫做<code class="fe nb nc nd ms b">handler.py</code>的模块，你的测试文件应该叫做<code class="fe nb nc nd ms b">test_handler.py</code>或者<code class="fe nb nc nd ms b">handler_test.py</code>。测试文件实际上不需要共享要测试的模块的基本名称——它可以被称为<code class="fe nb nc nd ms b">test_zzyzx_the_end_of_the_world.py</code>,它仍然可以工作——但是为了保持理智，你可能不应该这样做。</p><p id="148d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">单元测试本身可以按照任何有意义的方式来组织，但是我建议反映实际代码的结构。这允许您快速找到给定代码的相关测试。<strong class="kz ir">单元测试应该只测试每个文件中包含的逻辑(换句话说:模拟任何导入)</strong>，一个显著的例外是定制的异常/错误类，它们可能会在给定的模块中被无意地测试。</p><h1 id="6aed" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">写作测试</h1><p id="81be" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">对于准系统测试，您<em class="lt">不需要</em>导入pytest模块。您可以为方法编写的最简单的pytest测试如下:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="7a67" class="mw lv iq ms b gy mx my l mz na">def hello_world():<br/>    return 'hello world'</span><span id="c44f" class="mw lv iq ms b gy ns my l mz na">def test_function():<br/>    assert hello_world() == 'hello world'</span></pre><p id="2091" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">pytest对大多数断言使用标准Python <code class="fe nb nc nd ms b">assert</code> s。pytest甚至可以检查断言对象的上下文，例如:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="52af" class="mw lv iq ms b gy mx my l mz na">def hello_worlds():<br/>    return {<br/>        'english': 'hello world',<br/>        'chinese': '你好世界'<br/>    }</span><span id="5f8a" class="mw lv iq ms b gy ns my l mz na">def test_function():<br/>    assert hello_world() == {'english': 'hello wurld',<br/>                             'japanese': 'ハロー・ワールド'}</span><span id="576e" class="mw lv iq ms b gy ns my l mz na">E   AssertionError: assert {'english': 'hello world', 'chinese': '你好世界'} == {'english': 'hello wurld', 'japanese': 'ハロー・ワールド'}<br/>E     Differing items:<br/>E     {'english': 'hello world'} != {'english': 'hello wurld'}<br/>E     Left contains 1 more item:<br/>E     {'chinese': '你好世界'}<br/>E     Right contains 1 more item:<br/>E     {'japanese': 'ハロー・ワールド'}</span></pre><p id="c9b0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这就是在不导入pytest的情况下可以做到的程度。本文档的其余部分涵盖了需要<code class="fe nb nc nd ms b">import pytest</code>的特性。</p><p id="b6ef" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">pytest还可以检查异常的存在和上下文。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="2e89" class="mw lv iq ms b gy mx my l mz na">import pytest</span><span id="9304" class="mw lv iq ms b gy ns my l mz na">def hello_error():<br/>    raise NotImplementedError</span><span id="5acf" class="mw lv iq ms b gy ns my l mz na">def test_function():<br/>    with pytest.raises(NotImplementedError):<br/>        hello_error()</span><span id="4bea" class="mw lv iq ms b gy ns my l mz na">def test_context():<br/>    with pytest.raises(NotImplementedError) as e:<br/>        hello_error()<br/>    assert e.xyz == abc<br/>    # note that the exception context object is referenced *outside* the `with` block</span></pre><p id="cc2a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在一个测试函数下可以有多个断言；是否应该这样做完全是一个语义决定。</p><h1 id="2d12" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">固定装置</h1><p id="c60a" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">fixture是可重用代码的独立部分，可以从测试和其他fixture中调用。它们通常用于安装和拆卸，但也可以用于抽象重复的动作。</p><h1 id="f159" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">夹具基础</h1><p id="c436" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">固定物用<code class="fe nb nc nd ms b">@pytest.fixture</code>装饰，并通过传递固定物的名称来请求。一种方法可以请求多个设备。夹具也可以请求其他夹具。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="d1de" class="mw lv iq ms b gy mx my l mz na">import pytest<br/><br/>@pytest.fixture<br/>def hello():<br/>    return 'hello'<br/><br/>@pytest.fixture<br/>def world():<br/>    return 'world'<br/><br/>@pytest.fixture<br/>def hello_world(hello, world):<br/>    return hello + ' ' + world<br/><br/>def test_function(hello_world, hello, world):<br/>    assert hello_world = hello + ' ' + world</span><span id="5c26" class="mw lv iq ms b gy ns my l mz na">@pytest.fixture<br/>def hello():<br/>    return 'hello'</span><span id="0eca" class="mw lv iq ms b gy ns my l mz na">@pytest.fixture<br/>def world():<br/>    return 'world'</span><span id="cf4a" class="mw lv iq ms b gy ns my l mz na">@pytest.fixture<br/>def hello_world(hello, world):<br/>    return hello + ' ' + world</span><span id="77ba" class="mw lv iq ms b gy ns my l mz na">def test_function(hello_world, hello, world):<br/>    assert hello_world = hello + ' ' + world</span></pre><p id="34c1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Fixtures有独立的执行上下文<em class="lt">，除了在一个测试中被多次调用的</em>。</p><p id="8ff6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">以下示例在不同的测试中请求相同的fixture，并为每个测试提供不同的对象。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="2a09" class="mw lv iq ms b gy mx my l mz na">import pytest<br/><br/>@pytest.fixture<br/>def a_list():<br/>    return ['a']<br/><br/>def test_str(a_list):<br/>    a_list.append('b')<br/>    assert a_list == ['a', 'b']<br/><br/>def test_int(a_list):<br/>    a_list.append(2)<br/>    assert  a_list == ['a', 2]</span></pre><p id="05c2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">另一方面，这个例子在<em class="lt">相同的</em>测试中请求了两次相同的fixture(一次是传递的，第二次是直接的)，并返回相同的对象。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="90d7" class="mw lv iq ms b gy mx my l mz na">import pytest<br/><br/>@pytest.fixture<br/>def a_list():<br/>    return ['a']<br/><br/>@pytest.fixture<br/>def append_b(a_list):<br/>    return a_list.append('b')<br/><br/>def test_int(b_list, a_list):<br/>    assert  a_list == ['a', 'b']</span></pre><h1 id="fef2" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">花式夹具(官方称为“作为夹具的工厂”)</h1><p id="2000" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">为了能够向fixture传递参数(例如，动态生成输入数据)，您需要使用工厂作为fixture范例。本质上，fixture本身返回一个函数来完成您需要的功能。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="de91" class="mw lv iq ms b gy mx my l mz na">import pytest<br/><br/>@pytest.fixture<br/>def gen_input():<br/>    def _gen_input(a: bool):<br/>        return {'a': a}<br/><br/>    return _gen_input<br/><br/>def test_input(gen_input):<br/>    assert gen_input(True) == {'a': True}</span></pre><p id="b4f7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">不幸的是，文档字符串和代码完成特性并不能很好地适应这种范式，但是这并不意味着您不应该包含文档！</p><h1 id="57c5" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">自动使用装置</h1><p id="6e59" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">您可以指定在每次测试中自动使用夹具。如果所有的测试都有一个通用的设置组件，这是很有用的。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="63cd" class="mw lv iq ms b gy mx my l mz na">import pytest<br/><br/>@pytest.fixture(autouse=True)<br/>def some_func():<br/>    # do stuff before every test</span></pre><p id="3a1a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然而，请注意，autouse fixtures将<em class="lt">而不是</em>产生任何对象，除非它们被测试函数明确请求。</p><h1 id="afec" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">共享夹具和夹具生命周期</h1><p id="bc3e" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">要跨不同模块共享夹具，将它们放在<code class="fe nb nc nd ms b">conftest.py</code>文件中。</p><p id="14f7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">默认情况下，每个函数调用和拆除一次fixtures。您可以对此进行更改，使fixture的执行上下文在以下范围内共享(无耻地从文档中窃取):</p><ul class=""><li id="0d55" class="ne nf iq kz b la lb ld le lg ng lk nh lo ni ls nj nk nl nm bi translated"><code class="fe nb nc nd ms b">function</code>(默认)—夹具在测试结束时被破坏</li><li id="e3fb" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated"><code class="fe nb nc nd ms b">class</code> —夹具在课程的最后一次测试后被销毁</li><li id="e5cb" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated"><code class="fe nb nc nd ms b">module</code> —模块中最后一次测试后，夹具被销毁</li><li id="1bde" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated"><code class="fe nb nc nd ms b">package</code> —包装内最后一次测试后，夹具被销毁</li><li id="1429" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated"><code class="fe nb nc nd ms b">session</code> —夹具在测试阶段结束时被销毁。</li></ul><p id="c3d5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">范围作为参数传递给fixture装饰器。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="11e7" class="mw lv iq ms b gy mx my l mz na">import pytest<br/><br/>@pytest.fixture(scope="session")<br/>def test_something():<br/>    # something</span></pre><h1 id="a8f5" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">生产夹具</h1><p id="9a5c" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">有时你可能有复杂的对象参与安装和拆卸。输入产量装置。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="5ecc" class="mw lv iq ms b gy mx my l mz na">import pytest<br/><br/>@pytest.fixture<br/>def read_file():<br/>    f = open('hello_world.txt', 'r')<br/>    yield f.readlines()<br/>    f.close()  # teardown after yield<br/><br/># alternatively, using `with`:<br/>@pytest.fixture<br/>def read_file():<br/>    with open('hello_world.txt', 'r') as f:<br/>        yield f.readlines()<br/><br/>def test_file(read_file):<br/>    assert read_file = ['hello world']</span></pre><p id="35a7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe nb nc nd ms b">yield</code>向请求函数提供一个对象，并“暂停”夹具的执行。当请求函数完成时，夹具以相反的顺序被拆除(“恢复”夹具的执行)。</p><p id="240b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在pytest v3之前，<code class="fe nb nc nd ms b">@pytest.yield_fixture</code>是要使用的装饰器。虽然我们现在已经过了那个时代，但是一些旧文档和堆栈溢出问题/答案可能是那个时代的。</p><h1 id="0666" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">嘲弄的</h1><p id="de37" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">单元测试应该是原子的；嘲笑能做到这一点。您希望模拟对大多数(如果不是全部)外部函数的调用，尤其是当所述函数运行缓慢时。</p><p id="66d5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">pytest中的模拟需要<code class="fe nb nc nd ms b">pytest-mock</code>，您将在上面的<em class="lt">入门</em>小节中安装它。它提供了<code class="fe nb nc nd ms b">mocker</code> fixture，可以模仿对象、方法和变量。</p><h1 id="10ab" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">模拟变量</h1><p id="27d8" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">变量模拟主要用于模拟全局变量(在函数范围之外)。假设您有以下包含Lambda处理程序的文件:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="d423" class="mw lv iq ms b gy mx my l mz na"># lambda_handler.py</span><span id="904e" class="mw lv iq ms b gy ns my l mz na">is_cold_start = True<br/>def handler():<br/>    if is_cold_start:<br/>        # do stuff<br/>        is_cold_start = False<br/>    # do more stuff<br/>    return True  # arbitrary return value for illustration</span></pre><p id="9fbd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你希望能够在<code class="fe nb nc nd ms b">is_cold_start = False</code>的时候测试<code class="fe nb nc nd ms b">handler()</code>；为此，您必须模仿<code class="fe nb nc nd ms b">is_cold_start</code>。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="bca2" class="mw lv iq ms b gy mx my l mz na"># handler_test.py</span><span id="24c0" class="mw lv iq ms b gy ns my l mz na">import pytest<br/>import lambda_handler<br/><br/>def test_handler(mocker):<br/>    mocker.patch.object(lambda_handler, 'is_cold_start', False)<br/>    assert handler()</span></pre><p id="de9a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">签名如下:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="22a7" class="mw lv iq ms b gy mx my l mz na">mocker.patch.object(<br/>    module,      # this is NOT a string<br/>    'variable',  # this IS a string<br/>    value        # this is whatever<br/>)</span></pre><p id="22fb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">模块名称跟在导入名称后面。例如，如果<code class="fe nb nc nd ms b">lambda_handler.py</code>在文件夹<code class="fe nb nc nd ms b">src/</code>中，那么模块将是<code class="fe nb nc nd ms b">src.lambda_handler</code>。</p><h1 id="234b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">模拟功能</h1><p id="d169" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">函数模拟有一些细微差别。这里有一系列的例子。</p><h2 id="c1b6" class="mw lv iq bd lw nt nu dn ma nv nw dp me lg nx ny mg lk nz oa mi lo ob oc mk od bi translated">基础</h2><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="1c12" class="mw lv iq ms b gy mx my l mz na"># hello_world.py</span><span id="a407" class="mw lv iq ms b gy ns my l mz na">import os<br/><br/>def say_passphrase():<br/>    passphrase = os.environ.get('PASSPHRASE')<br/>    return passphrase or 'I need somebody (Help!)'</span></pre><p id="ec2c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要模拟对<code class="fe nb nc nd ms b">os.environ.get()</code>的调用:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="7b6f" class="mw lv iq ms b gy mx my l mz na"># hello_world_test.py</span><span id="fca7" class="mw lv iq ms b gy ns my l mz na">import pytest<br/>from hello_world import say_passphrase<br/><br/>def test_passphrase(mocker):<br/>    mocker.patch('hello_world.os.environ.get', return_value='hello world')<br/>    assert say_passphrase() == 'hello world'</span></pre><p id="93f7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">注意，第一个参数是被模拟为字符串的方法的完全限定名<em class="lt">。</em></p><p id="43e3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因为<code class="fe nb nc nd ms b">hello_world.py</code>导入了<code class="fe nb nc nd ms b">os</code>模块，所以模拟的目标是驻留在<code class="fe nb nc nd ms b">hello_world</code>模块中的<code class="fe nb nc nd ms b">os.environ.get()</code>的实例。或者，如果在<code class="fe nb nc nd ms b">hello_world.py</code>中使用了<code class="fe nb nc nd ms b">from os import environ</code>，那么完全限定名将会是<code class="fe nb nc nd ms b">hello_world.environ.get</code>。</p><h2 id="8f08" class="mw lv iq bd lw nt nu dn ma nv nw dp me lg nx ny mg lk nz oa mi lo ob oc mk od bi translated">不同的返回值</h2><p id="ef9a" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">如果在多个测试中需要相同的模仿，您可以将模仿者放在一个fixture中并返回模仿的对象。给定与上面相同的<code class="fe nb nc nd ms b">hello_world.py</code>，下面是测试的样子:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="abd5" class="mw lv iq ms b gy mx my l mz na"># hello_world_test.py</span><span id="81d0" class="mw lv iq ms b gy ns my l mz na">import pytest<br/>from hello_world import say_passphrase<br/><br/>@pytest.fixture<br/>def mock_getenv(mocker):<br/>    return mocker.patch('hello_world.os.environ.get')<br/><br/>def test_passphrase_exists(mock_getenv):<br/>    mock_getenv.return_value = 'hello world'<br/>    assert say_passphrase() == 'hello world'<br/><br/>def test_passphrase_not_exists(mock_getenv):<br/>    mock_getenv.return_value = None<br/>    assert say_passphrase() == 'I need somebody (Help!)'</span></pre><p id="c58a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里需要注意一些事情:</p><ul class=""><li id="5675" class="ne nf iq kz b la lb ld le lg ng lk nh lo ni ls nj nk nl nm bi translated">对<code class="fe nb nc nd ms b">mocker.patch()</code> <em class="lt">的调用没有</em>包含<code class="fe nb nc nd ms b">return_value</code>参数——这创建了一个通用的模拟对象，我们稍后可以操作它，然后fixture返回它</li><li id="eef2" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">测试不直接请求<code class="fe nb nc nd ms b">mocker</code>；相反，他们请求<code class="fe nb nc nd ms b">mock_getenv</code>fixture——这为测试提供了模拟对象，因为测试不需要任何额外的模拟，所以<code class="fe nb nc nd ms b">mocker</code>不需要单独传入</li><li id="19f8" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">每个测试的<code class="fe nb nc nd ms b">return_value</code>可以是唯一的；这是由于夹具行为(见上文)</li></ul><h2 id="64a7" class="mw lv iq bd lw nt nu dn ma nv nw dp me lg nx ny mg lk nz oa mi lo ob oc mk od bi translated">动态返回值(通过side_effect)</h2><p id="7ec4" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">假设同一个方法在同一个函数中被调用了多次，使用了不同的参数。你怎么嘲笑这个？让我们来了解一下！</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="3160" class="mw lv iq ms b gy mx my l mz na"># hello_world.py</span><span id="535f" class="mw lv iq ms b gy ns my l mz na">import os<br/><br/>def say_passphrase():<br/>    greeting = os.environ.get('GREETING')<br/>    subject = os.environ.get('SUBJECT')<br/>    return greeting + ' ' + subject</span></pre><p id="fe58" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这个例子中，<code class="fe nb nc nd ms b">os.environ.get()</code>被调用了两次，每次都有不同的参数。我们需要一种方法来区分这两个电话。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="880b" class="mw lv iq ms b gy mx my l mz na"># hello_world_test.py</span><span id="2f5c" class="mw lv iq ms b gy ns my l mz na">import pytest<br/>from hello_world import say_passphrase<br/><br/>def getenv_side_effect(key, default = None):<br/>    if key == 'GREETING':<br/>        return 'hello'<br/>    elif key == 'SUBJECT':<br/>        return 'world'<br/>    else:<br/>        return default<br/><br/>@pytest.fixture<br/>def mock_getenv(mocker):<br/>    return mocker.patch('hello_world.os.environ.get', side_effect=getenv_side_effect)<br/><br/>def test_passphrase(mock_getenv):<br/>    assert say_passphrase() == 'hello world'</span></pre><p id="eeef" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe nb nc nd ms b">side_effect</code>参数允许您传递一个将被调用的函数来代替实际的函数。这允许您根据传入的参数指定不同的返回值。还要注意，副作用功能是<em class="lt">而不是</em>一个固定装置，也不是必需的。</p><h2 id="1c72" class="mw lv iq bd lw nt nu dn ma nv nw dp me lg nx ny mg lk nz oa mi lo ob oc mk od bi translated">更动态的返回值</h2><p id="83a4" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">如果您对同一个方法进行了多次调用，并且想要简洁地测试该方法的不同返回场景，那么该如何操作呢？</p><p id="f1ba" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个想法是将工厂设备与副作用功能结合起来，就像这样:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="3459" class="mw lv iq ms b gy mx my l mz na"># hello_world.py</span><span id="ed65" class="mw lv iq ms b gy ns my l mz na">import os<br/><br/>def say_passphrase():<br/>    greeting = os.environ.get('GREETING', 'hola')<br/>    subject = os.environ.get('SUBJECT', 'mundo')<br/>    return greeting + ' ' + subject</span></pre><p id="fc61" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这与前面的例子几乎相同，除了默认值现在被传递给<code class="fe nb nc nd ms b">os.environ.get()</code>。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="297b" class="mw lv iq ms b gy mx my l mz na"># hello_world_test.py</span><span id="4a2b" class="mw lv iq ms b gy ns my l mz na">import pytest<br/>from hello_world import say_passphrase<br/><br/>def getenv_side_effect(key_exists: bool):<br/>    def _getenv_side_effect(key, default = None):<br/>        if key == 'GREETING':<br/>            return 'hello' if key_exists else default<br/>        elif key == 'SUBJECT':<br/>            return 'world' if key_exists else default<br/>    <br/>    return _getenv_side_effect<br/><br/>@pytest.fixture<br/>def mock_getenv(mocker):<br/>    def _mock_getenv(key_exists):<br/>        return mocker.patch('hello_world.os.environ.get',<br/>                            side_effect=getenv_side_effect(key_exists))<br/>    <br/>    return _mock_getenv<br/><br/>def test_passphrase_exists(mock_getenv):<br/>    mock_getenv(True)<br/>    assert say_passphrase() == 'hello world'<br/><br/>def test_passphrase_not_exists(mock_getenv):<br/>    mock_getenv(False)<br/>    assert say_passphrase() == 'hola mundo'</span></pre><p id="e814" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">或者，为了获得相同的效果，您可以为不同的场景使用多个副作用函数，并且在每个测试中加载不同的副作用。</p><h1 id="90f4" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">模仿对象/类</h1><p id="6fea" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">模仿对象类似于模仿函数。这里有两个例子。</p><h2 id="b163" class="mw lv iq bd lw nt nu dn ma nv nw dp me lg nx ny mg lk nz oa mi lo ob oc mk od bi translated">隐式类嘲讽</h2><p id="4de1" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">在这个例子中，您使用<code class="fe nb nc nd ms b">requests</code>进行一些API调用。<code class="fe nb nc nd ms b">requests.get()</code>返回一个<code class="fe nb nc nd ms b">Response</code>对象，它有一些属性，其中一个是<code class="fe nb nc nd ms b">status_code</code>。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="365f" class="mw lv iq ms b gy mx my l mz na"># hello_world.py</span><span id="8607" class="mw lv iq ms b gy ns my l mz na">import requests<br/><br/>def check_status():<br/>    response = requests.get('hello.world')  # this returns a Response class<br/>    return response.status_code</span></pre><p id="e152" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在测试中，您模拟了<code class="fe nb nc nd ms b">requests.get()</code>调用，并将其存储为模拟对象(<code class="fe nb nc nd ms b">mock_response</code>)。然后，您可以链接模拟对象的属性，以便模拟对<code class="fe nb nc nd ms b">status_code</code>属性的访问，而不显式模拟<code class="fe nb nc nd ms b">Response</code>类。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="9fe3" class="mw lv iq ms b gy mx my l mz na"># hello_world_test.py</span><span id="c28e" class="mw lv iq ms b gy ns my l mz na">import pytest<br/>from hello_world import check_status<br/><br/>def test_check_status(mocker):<br/>    mock_response = mocker.patch('hello_world.requests.get')<br/>    mock_response.return_value.status_code = 200<br/>    assert check_status() == 200</span></pre><h2 id="9006" class="mw lv iq bd lw nt nu dn ma nv nw dp me lg nx ny mg lk nz oa mi lo ob oc mk od bi translated">显式类模仿</h2><p id="2c07" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">这里你传入了一个已经被实例化的对象。假设<code class="fe nb nc nd ms b">name</code>属性属于<code class="fe nb nc nd ms b">str</code>类型，并且<code class="fe nb nc nd ms b">get_employer()</code>返回一个同样具有<code class="fe nb nc nd ms b">name</code>属性的<code class="fe nb nc nd ms b">Company</code>对象。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="5605" class="mw lv iq ms b gy mx my l mz na"># hello_world.py</span><span id="63fc" class="mw lv iq ms b gy ns my l mz na">from people import Person<br/><br/>def greet(person: Person):<br/>    name = person.name<br/>    company = person.get_employer().name<br/>    return f'hello, {name} from {company}'</span></pre><p id="dfe8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在测试中，您必须显式模拟<code class="fe nb nc nd ms b">Person</code>类，但是<code class="fe nb nc nd ms b">Company</code>可以隐式模拟。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="cd96" class="mw lv iq ms b gy mx my l mz na"># hello_world_test.py</span><span id="b70c" class="mw lv iq ms b gy ns my l mz na">import pytest<br/>from hello_world import greet<br/><br/>def test_greet(mocker):<br/>    mock_person = mocker.patch('hello_world.Person')  # explicitly mocked Person<br/>    mock_person.name = 'Rich Fairbank'<br/>    mock_person.get_employer.return_value.name = 'Capital One'  # implicitly mocked Company<br/>    assert greet() == 'hello, Rich Fairbank from Capital One'</span></pre><h2 id="d4fd" class="mw lv iq bd lw nt nu dn ma nv nw dp me lg nx ny mg lk nz oa mi lo ob oc mk od bi translated">内部类嘲讽</h2><p id="7376" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">在这个场景中，你试图模仿一个在被测试方法内部的对象。比方说，<code class="fe nb nc nd ms b">greet()</code>是某个类的一部分(为了简单起见，省略了它),它创建自己的<code class="fe nb nc nd ms b">Person</code>实例来问候你。为了举例，假设为初始化<code class="fe nb nc nd ms b">Person</code>而传入的值是静态的(尽管实际上会从其他地方检索)。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="0fdf" class="mw lv iq ms b gy mx my l mz na"># hello_world.py</span><span id="bc91" class="mw lv iq ms b gy ns my l mz na">from people import Person<br/><br/>def greet():<br/>    person = Person("Dumbledore", "Hogwarts")<br/>    name = person.name<br/>    company = person.get_employer().name<br/>    return f'{name} from {company} says "Greetings."'</span></pre><p id="39dd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在测试中，您将不得不显式地模拟内部的<code class="fe nb nc nd ms b">Person</code>方法，与您将它作为参数传入时略有不同。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="3290" class="mw lv iq ms b gy mx my l mz na"># hello_world_test.py</span><span id="0107" class="mw lv iq ms b gy ns my l mz na">import pytest<br/>from hello_world import greet<br/><br/>def test_greet(mocker):<br/>    mock_person = mocker.patch('hello_world.Person')  # the overall class is mocked the same way<br/>    mock_person().name = 'Dumbledore'  # however, note the parentheses here...<br/>    mock_person().get_employer.return_value.name = 'Hogwarts'  # and here<br/>    <br/>    assert greet() == 'Dumbledore from Hogwarts says "Greetings."'</span></pre><h1 id="c34b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">标记</h1><p id="a251" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">那是用一个<em class="lt">一个</em>做标记。标记是一种标记/标注测试的方式，这样您就可以有选择地运行测试的子集(例如，您希望只运行您正在处理的测试)。</p><p id="8264" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要标记某样东西，只需用<code class="fe nb nc nd ms b">@pytest.mark.&lt;your mark&gt;</code>装饰即可，例如:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="ff66" class="mw lv iq ms b gy mx my l mz na">import pytest<br/><br/>@pytest.mark.wip<br/>def test_something():<br/>    # blah</span></pre><p id="a121" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您还必须在<code class="fe nb nc nd ms b">conftest.py</code>中向pytest注册您的标记:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="6fa8" class="mw lv iq ms b gy mx my l mz na"># conftest.py</span><span id="2432" class="mw lv iq ms b gy ns my l mz na">def pytest_configure(config):<br/>    config.addinivalue_line("markers", "wip: mark test that is in progress")</span></pre><p id="d7ae" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可以通过添加另一个<code class="fe nb nc nd ms b">config.addinivalue_line()</code>来添加额外的标记。</p><p id="23a6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要运行标记，请使用<code class="fe nb nc nd ms b">pytest -m &lt;mark1&gt; &lt;mark2&gt; ...</code></p><h1 id="d981" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">参数化</h1><p id="182a" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">有时，您希望用不同的输入集运行相同的测试。输入参数化！</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="7b09" class="mw lv iq ms b gy mx my l mz na"># hello_world.py</span><span id="c6ee" class="mw lv iq ms b gy ns my l mz na">def greet(name: str, is_casual: bool, use_exclamation: bool):<br/>    greeting = 'sup' if is_casual else 'salutations,'<br/>    ending = '!' if use_exclamation else ''<br/>    return f'{greeting} {name}{ending}'</span></pre><p id="9220" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您希望能够轻松地测试不同的布尔组合，而无需多次重写基本相同的测试。</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="c7cb" class="mw lv iq ms b gy mx my l mz na"># hello_world_test.py</span><span id="a5b2" class="mw lv iq ms b gy ns my l mz na">from hello_world import greet<br/><br/>@pytest.mark.parameterize('is_casual', 'use_exclamation',<br/>                          [(True, True), (True, False), (False, True), (False, False)])<br/>def test_greet(is_casual, use_exclamation):<br/>    greeting = 'sup' if is_casual else 'salutations,'<br/>    ending = '!' if use_exclamation else ''<br/>    assert greet('Rich', is_casual, use_exclamation) == f'{greeting} Rich{ending}'</span></pre><p id="48b0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">通过参数化，您可以提供要参数化的参数和要使用的值的列表。pytest将对提供的每组参数运行一次测试。</p><h1 id="8a5e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">那都是乡亲们！</h1><p id="914b" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">如果你已经做到了这一步，你就是一名骑警，我希望我能帮助你满足你的测试需求。如果没有，请联系或评论你想实现的目标，我会看一看的！另外，如果你注意到我提供的信息有任何问题，请告诉我。我最不想做的事就是传播错误的信息。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="5e47" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">嘿，<strong class="kz ir">理查德石</strong>在这里。我是一名软件工程师，在普渡大学学习化学工程。我热爱技术，我在那个领域写一些有趣和令人兴奋的话题。有时候我也会写一些其他的东西。你可以在<a class="ae kw" href="https://twitter.com/heyrichardshi" rel="noopener ugc nofollow" target="_blank">的Twitterverse </a>中找到我这个不懂社交媒体的自己，或者你可以在<a class="ae kw" href="https://github.com/heyrichardshi" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看我的一些项目。如果你喜欢这首曲子，请考虑给我买一份拉面来支持我！</p></div></div>    
</body>
</html>