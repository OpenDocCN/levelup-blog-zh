<html>
<head>
<title>Finding the Largest Subarray Sum in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Javascript中寻找最大的子数组和</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/finding-the-largest-subarray-sum-in-javascript-a243093c8840?source=collection_archive---------7-----------------------#2020-03-09">https://levelup.gitconnected.com/finding-the-largest-subarray-sum-in-javascript-a243093c8840?source=collection_archive---------7-----------------------#2020-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/890cf55ac9d4e7feb5be68d9fedfc983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*tH4mnXHulhyveMIj7K7wAQ.png"/></div></figure><h2 id="abeb" class="ju jv iq bd jw jx jy dn jz ka kb dp kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><a class="ae kq" href="https://github.com/noamsauerutley/largest-subarray-sum" rel="noopener ugc nofollow" target="_blank"> GitHub Repo，包含完整的解决方案代码和测试套件</a></h2></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><blockquote class="ky"><p id="0364" class="kz la iq bd lb lc ld le lf lg lh li dk translated">给定一个数字数组，找出其中累加和最大的连续子数组。</p></blockquote></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="5d6a" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi md translated"><span class="l me mf mg bm mh mi mj mk ml di"> W </span>蚂蚁要分析一些DNA吗？测序一个基因组？分析图像数据？做一些数据挖掘？或者可能只是在准备技术面试时温习算法？然后，您可能需要在一个数字数组中找到加起来最大的和的子数组。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="b994" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">这个挑战是我最喜欢的说明使用正确的工具解决问题的价值的例子之一。作为web开发人员，我们经常反复使用许多相同的设计模式来解决问题。这太好了！学习有效的模板可以让我们更快更有效地解决我们遇到的许多问题。解决问题的本能遵循一些固定的惯例是有原因的，通常以<a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration" rel="noopener ugc nofollow" target="_blank">迭代循环</a>为中心。</p><p id="b356" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">然而，这种熟悉会让我们呆在自己的舒适区，导致思维僵化，阻碍我们探索更具创造性的解决方案，这些方案可能更有效、更简单，或者只是解决不寻常或复杂问题的必要手段。</p><blockquote class="ky"><p id="89e0" class="kz la iq bd lb lc ld le lf lg lh li dk translated"><a class="ae kq" href="https://en.wikipedia.org/wiki/Law_of_the_instrument" rel="noopener ugc nofollow" target="_blank">“我想，如果你唯一的工具是一把锤子，那么把一切都当成钉子是很有诱惑力的”</a></p></blockquote><p id="d6c4" class="pw-post-body-paragraph lj lk iq ll b lm mm lo lp lq mn ls lt kd mo lv lw kh mp ly lz kl mq mb mc li ij bi translated">我们习惯于将循环视为我们做任何事情的首选工具。需要再加一个任务？只需嵌套一个循环！我们得到了我们需要的结果。我们继续前进。很多时候？挺好的。</p><p id="d4e2" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">但是，我们难免会遇到不精的情况。巨大的阵列。错综复杂的数据。将我们的“锤子”(即嵌套迭代循环和类似的直接解决问题的方法)应用于这些挑战可能会对时间和计算能力产生灾难性的要求。这些<a class="ae kq" href="https://en.wikipedia.org/wiki/Brute-force_search" rel="noopener ugc nofollow" target="_blank">蛮力</a>解决方案在技术上可能能够返回我们想要的结果。然而，给定足够大或复杂的数据集，所需的时间和计算能力可能使它们基本上无用。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/9112a7859fda4d80de2d7fb9173f58ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*QjuwyjFNtxl9wYKM96XZSw.jpeg"/></div></figure><p id="e366" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">只有通过算法才能有效解决的问题有助于我们打破常规，教会我们考虑不同类型解决方案的时间和空间成本，并在我们的编程问题解决工具箱中添加除了可靠的锤子之外的其他工具。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="d660" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">好了，锤子说够了。寻找一个数组的最大子数组和怎么样？</p><p id="e6ac" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">当然，从技术上讲，使用蛮力来解决这个挑战是可能的。然而，这正是我们的锤子显然是错误的工具的情况之一。</p><p id="a2ac" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">强力解决方案将使用嵌套循环来查找给定数组的所有子数组(即数组的一部分)，然后比较它们，看哪个相加起来最大。如果一个数组非常大，这个操作的<a class="ae kq" href="https://www.hackerearth.com/practice/basic-programming/complexity-analysis/time-and-space-complexity/tutorial/" rel="noopener ugc nofollow" target="_blank">时间复杂度</a>可能是灾难性的。</p><p id="38f2" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">当我们考虑到这一挑战的许多应用需要找到二维阵列的整个<a class="ae kq" href="https://www.geeksforgeeks.org/maximum-sum-rectangle-in-a-2d-matrix-dp-27/" rel="noopener ugc nofollow" target="_blank">矩阵的最大子阵列和时，这种解决方案的工具有多差就变得更加明显了，这将这一解决方案已经对数的时间复杂性推到了荒谬的境界。</a></p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/26471f0378251311c936f152adad5282.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*PT-aTz8QUZ2wlYAvgw2q7Q.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">呀。</figcaption></figure><p id="2dca" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">幸运的是，<a class="ae kq" href="https://en.wikipedia.org/wiki/Joseph_Born_Kadane" rel="noopener ugc nofollow" target="_blank">杰伊·卡丹</a>开发了一个可爱的<a class="ae kq" href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm" rel="noopener ugc nofollow" target="_blank">算法</a>来尽快解决这个特殊的问题。它以<a class="ae kq" href="https://en.wikipedia.org/wiki/Time_complexity#Linear_time" rel="noopener ugc nofollow" target="_blank">线性时间</a>运行！这正是我们想要的那种东西。这是一个优雅的寻找解决方案的工具，也是一个很好的提醒，有时，使用一个方便的锤子会导致比它解决的问题更多的问题。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="3018" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">让我们勾勒出我们的框架:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e49d" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">首先，我们将把我们的数字数组传递给一个我称之为<strong class="ll ir"><em class="nd">largestsubaraysum</em></strong>的函数，然后定义两个重要变量——<strong class="ll ir"><em class="nd">currentSum</em></strong>和<strong class="ll ir"> <em class="nd"> largestSum </em> </strong>。</p><p id="7d7d" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">Kadane的算法要求我们在数组中迭代一次。我们在最初的函数搭建中已经走了这么远，但是在我们准备的循环中我们到底要做什么呢？</p><p id="a28b" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">算法的逻辑要求我们给准备好的currentSum变量赋一个新值。对于我们数组中的每个<strong class="ll ir"><em class="nd"/></strong>，我们可以将<strong class="ll ir"><em class="nd">currentSum</em></strong><em class="nd"/>重新分配给<strong class="ll ir">或者是</strong>的值<strong class="ll ir">零</strong> <strong class="ll ir">或者是</strong>currentSum和<strong class="ll ir"> <em class="nd">数</em></strong><strong class="ll ir">的新总和，以较大者为准。</strong></p><p id="5bec" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">这确保了<strong class="ll ir"> <em class="nd"> currentSum </em> </strong>永远不会成为负数。</p><p id="e213" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">这个循环思想中有更多的逻辑。我们还没完呢。</p><p id="3f16" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">在移动到数组中的下一个元素之前，我们需要比较<strong class="ll ir"> <em class="nd">【当前总数】</em> </strong>和<strong class="ll ir"> <em class="nd">最大总数</em> </strong></p><p id="7098" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">如果<strong class="ll ir"><em class="nd"/></strong>当前总和大于<strong class="ll ir"> <em class="nd">最大总和</em> </strong>，那么我们需要用新的最大总和，即<strong class="ll ir"> <em class="nd">当前总和</em> </strong>替换旧的<strong class="ll ir"> <em class="nd">最大总和</em>。</strong></p><p id="8353" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">那么，这在Javascript中是什么样子的呢？</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5be7" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">遍历这段代码，它就像我们计划的那样运行。</p><p id="aeaa" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">从头到尾一行一行地写，我们可以看到我们正在给我们的<strong class="ll ir"> <em class="nd"> currentSum </em> </strong>变量赋值。该值将是我们传递给Javascript的<a class="ae kq" href="https://www.geeksforgeeks.org/math-max-javascript/" rel="noopener ugc nofollow" target="_blank"> Math.max() </a>函数所返回的任何值。在我们的例子中，我们告诉Javascript返回两者中较大的一个:零，或者是<strong class="ll ir"> <em class="nd"> currentSum </em> </strong>和<strong class="ll ir"> <em class="nd"> number </em> </strong>(当前数组元素)之和。</p><p id="3cca" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">然后，我们给<strong class="ll ir"> <em class="nd"> largestSum </em> </strong>赋一个新值——无论是<strong class="ll ir"> <em class="nd"> largestSum </em> </strong>还是<strong class="ll ir"> <em class="nd"> currentSum </em> </strong>都被确定为较大的数，并由Math.max()返回。</p><p id="8a5d" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">这两个评估将针对数组中的每个新元素进行，这意味着<strong class="ll ir"> <em class="nd"> largestSum </em> </strong>将是从最终产生最大和的子数组中保存的数字——保存到<strong class="ll ir"> <em class="nd"> currentSum </em> </strong>的任何后续子数组和不会替换<strong class="ll ir"> <em class="nd"> largestSum </em> </strong>，因为它们不是Math.max()返回的整数。</p><p id="6a3c" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">现在，如果我们正在寻找一个高性能的解决方案，你可能会质疑Javascript的<a class="ae kq" href="https://www.geeksforgeeks.org/math-max-javascript/" rel="noopener ugc nofollow" target="_blank"> Math.max() </a>函数的使用。毕竟，当传递到Math.max()中进行比较的数字太多时，它会变得笨拙。然而，我们从来不需要一次比较两个以上的数字，这使得它成为一个高效的计算工具。</p><p id="e2df" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">这一切都很好，但我们需要确保这实际上，你知道，工作。</p><p id="2fb3" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">我已经准备好了一些数字数组和它们各自的最大子数组和，所以我们可以将我们的函数直接放入控制台，看看它是否正确地找到了最大和:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5080" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">太好了！🌟我们的功能似乎是为各种具有不同特征的数字数组找到正确的子数组和。</p><p id="0a4a" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">如果你想知道更多关于上面使用的每个阵列测试什么，你可以阅读这个挑战的<a class="ae kq" href="https://github.com/noamsauerutley/largest-subarray-sum" rel="noopener ugc nofollow" target="_blank"> GitHub repo的解决方案代码</a>中包含的<a class="ae kq" href="https://github.com/noamsauerutley/largest-subarray-sum/blob/master/test/largestSubarraySum.spec.js" rel="noopener ugc nofollow" target="_blank">测试套件</a>！</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="48af" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">对我来说，这种方法比创建一大堆子阵列并比较它们要有趣得多。我认为很容易假设算法或其他开箱即用的解决方案自动比暴力解决方案更复杂或更难处理，但我认为Kadane的算法是一个很好的例证，说明情况并不总是如此。它也不太可能由于过度的时间/空间复杂性而使我们陷入运行时错误！</p><p id="6a6a" class="pw-post-body-paragraph lj lk iq ll b lm ln lo lp lq lr ls lt kd lu lv lw kh lx ly lz kl ma mb mc li ij bi translated">希望你的工具箱里有Kadane的算法能让你比这个家伙更成功地找到最大的子阵列和:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/1eb3e71e4b7790e53d3103728b15d5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/1*jLMP9AVxIN9STVTu4BAnjQ.gif"/></div></figure></div></div>    
</body>
</html>