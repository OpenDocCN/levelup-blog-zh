<html>
<head>
<title>Three ways to improve the EF Core performance in your .NET Core app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高您的EF内核性能的三种方法。网络核心应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-ways-to-improve-the-ef-core-performance-in-your-net-core-app-d9b6295188cc?source=collection_archive---------0-----------------------#2019-08-06">https://levelup.gitconnected.com/3-ways-to-improve-the-ef-core-performance-in-your-net-core-app-d9b6295188cc?source=collection_archive---------0-----------------------#2019-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4868b08ef1cf7b5142781c4d4fa7903e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJWCH0kK-Urdfm-CY-qyKA.jpeg"/></div></div></figure><p id="fc5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ORM(对象关系映射)框架真的简化了所有数据库相关任务的开发人员的生活。</p><p id="7379" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，正如通常发生的那样，这种简化是有代价的。大多数情况下，代价是灵活性和性能。</p><p id="1326" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将描述三种最直接的方法来提高您的。NET核心应用程序。</p><h1 id="47fd" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak"> 1。不要偷懒。渴望</strong></h1><p id="822d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们从最明显的建议开始，当EF核心没有被正确使用时，这些建议实际上可以给你最大的性能提升。</p><p id="5625" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，想象一下下面这种很常见的情况:</p><ul class=""><li id="7e4a" class="mc md it kd b ke kf ki kj km me kq mf ku mg ky mh mi mj mk bi translated">两个实体之间存在主-从关系。让它成为一个经典的订单-客户示例，其中每个订单实体引用一个客户。</li><li id="0a5f" class="mc md it kd b ke ml ki mm km mn kq mo ku mp ky mh mi mj mk bi translated">您需要检索指定期间(例如，从今年年初)所有订单的信息，并显示每个订单的客户名称。</li></ul><p id="ade1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">EF Core 2.1引入了一个叫做<a class="ae mq" href="https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading" rel="noopener ugc nofollow" target="_blank">“惰性加载”</a>的东西(或者更确切地说是“重新引入的”，因为这个特性在传统的Entity Framework 6.x中是可用的)，所以现在你可以用下面的代码实现所描述的任务:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4102" class="na la it mw b gy nb nc l nd ne">var thisYearFirstDay = new DateTime(DateTime.Now.Year, 1, 1);<br/>var thisYearOrders = context.Orders<br/>   .Where(o =&gt; o.OrderDate &gt; thisYearFirstDay);</span><span id="f779" class="na la it mw b gy nf nc l nd ne">foreach (var order in thisYearOrders)<br/>{<br/>    Console.WriteLine($"{order.Id} {order.OrderDate} {order.Customer.CompanyName}");<br/>}</span></pre><p id="2fc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">很简单，对吧？<br/> <strong class="kd iu">错了！</strong>其实挺懒的:)而且这段代码会给你带来巨大的性能打击。</p><p id="c140" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为什么？因为EF Core会将您的代码转换成对数据库的1+N个查询，其中N —是<code class="fe ng nh ni mw b">thisYearOrders</code>结果集中的记录数。</p><p id="a017" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您在DbContext中添加一个日志记录器，并查看日志消息，您将会看到如下查询:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="b708" class="na la it mw b gy nb nc l nd ne">SELECT [o].[OrderID], [o].[CustomerID], . . .<br/>FROM [Orders] AS [o]<br/>WHERE [o].[OrderDate] &gt; @__thisYearFirstDay_0</span></pre><p id="0761" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后是N个这样的查询:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="91d0" class="na la it mw b gy nb nc l nd ne">SELECT [e].[CustomerID], [e].[Address], . . .<br/>FROM [Customers] AS [e]<br/>WHERE [e].[CustomerID] = <a class="ae mq" href="http://twitter.com/__get_Item_0" rel="noopener ugc nofollow" target="_blank">@__get_Item_0</a></span></pre><p id="85c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">显然，如此多的查询会花费很多时间，尤其是在连接不良或数据库很大的情况下。</p><p id="d4ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了解决这个问题，我们需要使用所谓的<a class="ae mq" href="https://docs.microsoft.com/en-us/ef/core/querying/related-data#eager-loading" rel="noopener ugc nofollow" target="_blank">“急切加载”</a>，并在我们的请求中添加“Include”调用:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="b3fd" class="na la it mw b gy nb nc l nd ne">var thisYearOrders = context.Orders<br/>        .Include(o =&gt; o.Customer)<br/>        .Where(o =&gt; o.OrderDate &gt; thisYearFirstDay);</span></pre><p id="694d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如果我们查看日志，我们将只看到一个查询，而不是1+N:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3ac7" class="na la it mw b gy nb nc l nd ne">SELECT [o].[OrderID], [o].[CustomerID], . . . /* all other columns from Orders and Customers */<br/>FROM [Orders] AS [o]<br/>LEFT JOIN [Customers] AS [o.Customer] ON [o].[CustomerID] = [o.Customer].[CustomerID]<br/>WHERE [o].[OrderDate] &gt; <a class="ae mq" href="http://twitter.com/__thisYearFirstDay_0" rel="noopener ugc nofollow" target="_blank">@__thisYearFirstDay_0</a></span></pre><p id="9050" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你可能会想到的，“热切的”方法会比“懒惰的”方法执行得更快。</p><p id="9377" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在实际应用中，这种优势的价值可能是百分之几十甚至百分之几千！</p><h1 id="1e52" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak"> 2。不要太急切。只拿你要用的东西</strong></h1><p id="969a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们第一个例子中的“急切”方法的问题是，在大多数情况下，它可能太“急切”了。</p><p id="d47e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">看，我们实际上只需要三个字段(两个来自Orders表，一个来自Customers表)，但是相反，我们从两个表中获取了整组列。</p><p id="685b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解决方案很简单:只获取那些通过<code class="fe ng nh ni mw b">Select</code>调用需要的列:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="3081" class="na la it mw b gy nb nc l nd ne">var thisYearFirstDay = new DateTime(DateTime.Now.Year, 1, 1);<br/>var thisYearOrders = context.Orders<br/>        .Where(o =&gt; o.OrderDate &gt; thisYearFirstDay)<br/>                .Select(o =&gt; new { o.Id, o.OrderDate, o.Customer.CompanyName })</span><span id="fa1c" class="na la it mw b gy nf nc l nd ne">foreach (var rec in thisYearOrders)<br/>{<br/>    Console.WriteLine($"{rec.Id} {rec.OrderDate} {rec.CompanyName}");<br/>}</span></pre><p id="6619" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">产生的SQL语句将如下所示:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="081f" class="na la it mw b gy nb nc l nd ne">SELECT [o].[OrderID] AS [Id], [o].[OrderDate], [o.Customer].[CompanyName]<br/>FROM [Orders] AS [o]<br/>LEFT JOIN [Customers] AS [o.Customer] ON [o].[CustomerID] = [o.Customer].[CustomerID]<br/>WHERE [o].[OrderDate] &gt; <a class="ae mq" href="http://twitter.com/__thisYearFirstDay_0" rel="noopener ugc nofollow" target="_blank">@__thisYearFirstDay_0</a></span></pre><p id="cc85" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它肯定会有更好的性能，因为从数据库服务器传输到客户机(您的)的数据会更少。NET app，在这种情况下)。</p><p id="2722" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码中有两件事应该注意。</p><p id="11e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们不再需要一个<code class="fe ng nh ni mw b">Include</code>调用，因为实体框架从<code class="fe ng nh ni mw b">Select</code>调用中“理解”我们需要另一个表中的一个字段(<code class="fe ng nh ni mw b">Customer.CompanyName</code>)，并自动将必要的JOIN子句添加到结果SQL中。</p><p id="99f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其次，正如你所看到的，我们用<code class="fe ng nh ni mw b">new {o.Id, ...}</code>命令创建了一个动态对象(不属于任何特定类的对象)列表。</p><p id="d076" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了强调这一事实，我们在从<code class="fe ng nh ni mw b">order</code>到<code class="fe ng nh ni mw b">rec</code>的<code class="fe ng nh ni mw b">foreach</code>循环中替换了变量的名称(来自“record”)——因为它不再是一个“订单”。我们在结果中得到的动态对象只包含三个属性:<code class="fe ng nh ni mw b">Id</code>、<code class="fe ng nh ni mw b">OrderDate</code>和<code class="fe ng nh ni mw b">CompanyName</code>(这就是为什么我们现在直接访问‘company name’，而不是前面例子中的‘order . customer . company name’。</p><h1 id="2074" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak"> 3。使用AsNoTracking()。但是明智地</strong></h1><p id="23fe" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">当您对您的<code class="fe ng nh ni mw b">DbContext</code>中的一些实体运行查询时，返回的对象被上下文自动跟踪，以允许您修改它们(如果需要的话)，然后用<code class="fe ng nh ni mw b">context.SaveChanges()</code>操作保存更改。</p><p id="3f7e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，如果它是一个只读查询，并且返回的数据不应该被修改，那么就没有必要让上下文执行一些建立跟踪所需的额外工作。<code class="fe ng nh ni mw b">AsNoTracking</code>方法告诉实体框架停止额外的工作，这样就可以提高应用程序的性能。</p><p id="2d95" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，从理论上讲，带有<code class="fe ng nh ni mw b">AsNoTracking</code>的查询应该比不带<code class="fe ng nh ni mw b">AsNoTracking</code>的查询执行得更好。问题是:好多少？让我们弄清楚。</p><p id="713b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经使用BenchmarkDotNet库创建了一个小的测试应用程序。这里有两个被检查的函数:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="393d" class="na la it mw b gy nb nc l nd ne">public void GetAll_WithTracking()<br/>{<br/>   var allRecords = _dbContext.OrderDetails;<br/>   var list = allRecords.ToList();<br/>}</span><span id="c332" class="na la it mw b gy nf nc l nd ne">public void GetAll_NoTracking()<br/>{<br/>   var allRecords = _dbContext.OrderDetails.AsNoTracking();<br/>   var list = allRecords.ToList();<br/>}</span></pre><p id="6179" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我们所料,“不跟踪”方式表现更好。一般来说，它似乎比“带跟踪”快1.5倍:</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/01ce842c2bc13310fac2b20978d4b4ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2Rv1GrKK02ASfOFfd8c2Q.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">基准测试结果01</figcaption></figure><p id="0282" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们试图将AsNoTracking添加到两个表的查询中时，奇怪的事情开始了(使用JOIN):</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="479b" class="na la it mw b gy nb nc l nd ne">public void GetWithInclude_Tracking()<br/>{<br/>    var allRecords = _dbContext.OrderDetails<br/>            .Include(od =&gt; od.Product);</span><span id="a637" class="na la it mw b gy nf nc l nd ne">    var list = allRecords.ToList();<br/>}</span><span id="ba8a" class="na la it mw b gy nf nc l nd ne">public void GetWithInclude_NoTracking()<br/>{<br/>    var allRecords = _dbContext.OrderDetails<br/>            .AsNoTracking()<br/>            .Include(od =&gt; od.Product);</span><span id="d12f" class="na la it mw b gy nf nc l nd ne">    var list = allRecords.ToList();<br/>}</span></pre><p id="8538" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结果令人困惑:</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/e89333daec18c8ae5506890cb96ff81a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*joizw0ZFJmofjvpmgmvt8g.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">基准测试结果02</figcaption></figure><p id="4548" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">带跟踪的查询比不带跟踪的查询性能稍好！</p><p id="0546" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GitHub 上有一个关于这种奇怪(乍一看)行为的问题。</p><p id="1d67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，如果我们试着想象实体框架是如何在内部实现的，这种行为可能是相当符合逻辑的。连接两个表的查询需要来自两个表的记录来进行匹配，如果这些记录已经被上下文跟踪并存储在内存中，这显然会更快。</p><p id="2542" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不过，这只是我的猜测。如果你对此有其他想法，请告诉我。</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="34dd" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">收尾</strong></h1><p id="fae6" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我希望我在本文中列出的关于性能改进的建议能够帮助您编写更高效的代码。</p><p id="4eb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我只想给你一个更笼统的建议:<strong class="kd iu">用源</strong>:)</p><p id="11ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就使用EF Core而言，这意味着:查看您的代码生成的SQL语句(在调试时，您可以在VS的输出面板中看到它们)。</p><p id="a84c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它让你了解“幕后”发生了什么，在某些情况下，可能会帮助你显著提高应用程序的性能。</p><p id="88eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的阅读。祝您愉快！</p></div></div>    
</body>
</html>