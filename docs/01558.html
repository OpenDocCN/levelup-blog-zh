<html>
<head>
<title>A Practical Guide to Deploying Microservices on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在AWS上部署微服务的实用指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-practical-guide-to-deploying-microservices-on-aws-6a8ddd298f7e?source=collection_archive---------1-----------------------#2020-01-13">https://levelup.gitconnected.com/a-practical-guide-to-deploying-microservices-on-aws-6a8ddd298f7e?source=collection_archive---------1-----------------------#2020-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8e0e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过Docker、CloudFormation和Bitbucket管道在ECS Fargate平台上持续部署生产就绪型微服务</h2></div><p id="1893" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这份介绍性指南介绍了在AWS中自动提供API服务基础设施的过程。主要关注点是创建可复制的基础设施和构建管道，而不是服务实现本身。该指南附带了两个代码库，帮助您开始使用<a class="ae le" href="https://bitbucket.org/idanlupinsky/ecs-fargate-service-infra/" rel="noopener ugc nofollow" target="_blank">基础设施</a>和<a class="ae le" href="https://bitbucket.org/idanlupinsky/ecs-fargate-service-api/" rel="noopener ugc nofollow" target="_blank">服务</a>实现。建议读者具备AWS概念的基础知识。</p><h1 id="e74d" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">背景</h1><p id="9b45" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们的一个客户是房地产行业的初创企业。这家初创公司的数据团队开发了一个机器学习模型，用于根据房产位置和大小等特定特征对房地产进行估值。像许多其他团队一样，他们面临着将模型引入生产环境的挑战。他们要求我们将这个<em class="mc">价格评估模型</em>公开为他们的后端服务可以使用的内部API。此外，他们希望有一个通用的启动项目，可以进行调整，以便在本地测试新模型，并快速轻松地在生产中推出变更。</p><p id="883e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们的客户在AWS上运行其工作负载，并为其应用程序使用Docker，我们决定在<a class="ae le" href="https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank">弹性容器服务</a> (ECS)平台上运行资产评估API。在AWS中，选择ECS似乎是理所当然的，因为它已经在亚马逊和其他公司中经受了考验，但它也提供了与AWS生态系统中许多服务的无缝集成。除此之外，我们选择将ECS与<a class="ae le" href="https://aws.amazon.com/fargate/" rel="noopener ugc nofollow" target="_blank"> Fargate </a>计算引擎配合使用，因为它允许我们委派调配和扩展底层集群容量的责任。这意味着我们只需指定所需的计算资源以及服务本身应如何扩展，而无需调配和维护底层计算群集。</p><p id="638b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们的客户使用<a class="ae le" href="https://bitbucket.org/" rel="noopener ugc nofollow" target="_blank">位桶</a>作为它的版本控制库。尽管市场上有很多优秀的CI/CD产品，但是使用Bitbucket作为源存储库使得<a class="ae le" href="https://bitbucket.org/product/features/pipelines" rel="noopener ugc nofollow" target="_blank"> Bitbucket Pipelines </a>成为我们这个项目的首选CI/CD解决方案，特别是考虑到它与AWS的直接集成。</p><h1 id="4a37" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">最小的API服务</h1><p id="e92a" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">鉴于我们在本指南中的目标是关注服务的基础设施和技术需求，而不是其功能，我们已经尽可能保持<a class="ae le" href="https://bitbucket.org/idanlupinsky/ecs-fargate-service-api/" rel="noopener ugc nofollow" target="_blank">服务实现</a>简单。</p><p id="8e23" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的示例服务是用<a class="ae le" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>实现的，这是一个用于在Python 3.6和更新版本中构建API的现代web框架。该框架的一个吸引人的特性是基于OpenAPI规范的交互式文档的内置生成，以<a class="ae le" href="https://github.com/swagger-api/swagger-ui" rel="noopener ugc nofollow" target="_blank"> SwaggerUI </a>和<a class="ae le" href="https://github.com/Redocly/redoc" rel="noopener ugc nofollow" target="_blank"> Redoc </a>的形式。</p><p id="8190" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">准系统实现由一个在<code class="fe md me mf mg b">/health-check</code>暴露的端点组成，该端点返回一个以<code class="fe md me mf mg b">{"status": "healthy"}</code>作为消息体的<code class="fe md me mf mg b">HTTP 200 OK</code>响应。应用程序负载平衡器将使用此端点来监视服务。第二个端点是一个伪<code class="fe md me mf mg b">/valuation</code>端点，它在其消息体中返回一个简单的硬编码值。代码如下所示:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">最小API实现</figcaption></figure><p id="60a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建一个<a class="ae le" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Docker映像</a>，它将包含我们的API代码、它的依赖项以及将请求转发给我们的服务的<a class="ae le" href="http://www.uvicorn.org/" rel="noopener ugc nofollow" target="_blank">uvicon</a>HTTP服务器:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">服务API Dockerfile文件</figcaption></figure><p id="c1b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，让我们编写一个<a class="ae le" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>文件来轻松地支持我们的API堆栈，即使它在这一点上只包含一个容器:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">服务API Docker编写文件</figcaption></figure><p id="8504" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了在本地运行我们的API栈，我们发出一个<code class="fe md me mf mg b">docker-compose up</code>命令。Swagger UI应该在<code class="fe md me mf mg b"><a class="ae le" href="http://localhost/docs" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/docs</a></code>可用，我们可以通过浏览器轻松测试两个API端点。</p><p id="5cb7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了一个工作的——尽管是最小的——API服务容器，让我们看看它如何适合ECS和Fargate的上下文。</p><h1 id="7f02" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">ECS基础知识</h1><p id="a03e" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">ECS中最基本的构件是<em class="mc">任务</em>。每个任务运行一个或多个相关的Docker容器。一个<a class="ae le" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html" rel="noopener ugc nofollow" target="_blank">任务定义</a>通过描述哪些容器在任务中运行、对任务施加的CPU和内存限制、日志配置和几个其他属性，作为实例化任务的模板。类似于EC2实例，任务可以被分配一个IAM角色，这大大简化了凭证管理。</p><p id="9be6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然可以手动运行任务，但是我们将使用<em class="mc">服务</em>抽象来运行任务的一个或多个实例。与手动运行任务相比，<a class="ae le" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html" rel="noopener ugc nofollow" target="_blank"> ECS服务</a>调度程序提供了几个好处。首先，它允许我们定义应该并发运行的任务的期望数量。在一个任务失败的情况下，服务调度程序会自动启动一个新的任务并将其投入使用。另一个好处是能够将负载平衡器与服务关联起来。只要任务被认为是健康的，它们就是负载平衡器目标组的一部分。也可以将服务配置为自动扩展。稍后，我们将通过提供负载平衡器来利用其中的一些功能。我们将在后续文章中解决自动伸缩问题。</p><p id="b278" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了运行任务或服务，我们需要提供一个<em class="mc">集群</em>。一个<a class="ae le" href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html" rel="noopener ugc nofollow" target="_blank"> ECS集群</a>只是服务和任务的逻辑分组。在我们的设置中，我们将调配一个ECS集群来容纳我们的服务，但是当然也可以将跨VPC的多个服务分组到一个集群中。</p><h1 id="6eca" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">基础设施</h1><p id="5d3a" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">让我们深入了解并详细回顾一下服务基础架构:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/8e14b658ed1077ba176522730ee5a439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9xBI3fZxIUIknoTD0Tqdw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">API服务架构</figcaption></figure><p id="506d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的图表是一个相当标准的设置，但仍然有很多事情要做。我们来分解一下。</p><p id="5fc8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虚拟私有云(VPC)为我们的服务提供网络隔离。我们的VPC包括两个私有子网和两个公共子网，分布在两个可用性区域(az)中。在单个AZ失败的情况下，该服务仍然可用，尽管它暂时限于在单个AZ上运行的任务。AWS区域通常有两个以上的az，因此我们可以选择扩展我们的架构，以包含一个或多个附加的az。这是一种权衡，因为额外的az可能会带来额外的成本。</p><p id="1c9a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设服务是作为内部API使用的，我们实例化一个应用负载平衡器(ALB)并将其与私有子网关联。为了方便起见，我们还使用Route 53 DNS服务为我们的负载平衡器端点提供一个友好的DNS名称。如前所述，负载平衡器与ECS服务相关联，这意味着ECS调度程序将自动在负载平衡器目标组中注册新的ECS任务。</p><p id="78b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">公共子网有双重用途:它们有助于建立堡垒主机，如果需要的话，我们可以从这些主机连接到私有子网。更重要的是，我们创建了NAT网关，允许私有子网中的ECS容器从互联网上获取Docker映像。如图所示，创建NAT网关是可选的，通常取决于是否需要从Docker Hub等来源获取图像，或者是否需要将指标发送给DataDog等第三方服务提供商。</p><p id="a749" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，在我们的VPC中，我们希望使用某些服务，如S3、CloudWatch日志和弹性容器注册(ECR)。要做到这一点，同时确保流量保持在亚马逊网络内，需要设置图顶部所示的VPC端点。</p><h1 id="65e4" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">云的形成</h1><p id="11c8" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们希望将上述设计整理成文，以便我们能够安全地复制和更新环境。很重要的一点是，变更要易于审查和审计，就像常规的代码审查一样。该守则还将作为最新的文件。为了实现基础设施，我们使用AWS的本机和声明式基础设施代码解决方案CloudFormation。我们服务的基础设施代码可在<a class="ae le" href="https://bitbucket.org/idanlupinsky/ecs-fargate-service-infra" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="db3b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在CloudFormation模板中，堆栈被定义为相关资源的集合。对于我们的服务，我们定义了一个主堆栈，通过它我们能够复制整个服务基础设施。这对于确保生产环境和非生产环境之间的平等特别有用。也就是说，开发环境中通常不需要生产中调配的计算资源级别。为此，CloudFormation允许我们添加可选参数，以更好地控制堆栈资源的供应方式。</p><p id="cd19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看一个非常简单的CloudFormation模板:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">云形成ECR示例</figcaption></figure><p id="8905" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的示例创建了一个ECR存储库，并使用<code class="fe md me mf mg b">Prefix</code>参数作为所选存储库名称的一部分。</p><p id="0e4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着堆栈大小的增长，将它分成更小的堆栈是有意义的。这提高了特定部署的可读性，并有助于跨项目重用堆栈。实现堆栈重用的方法之一是定义嵌套堆栈。嵌套堆栈就是定义为另一个堆栈中的资源的堆栈。</p><p id="013f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的摘录来自我们的顶级堆栈。在本例中，我们看到两个嵌套的堆栈:一个VPC堆栈和一个VPC端点堆栈。例如，如果另一个项目只需要VPC堆栈，但不需要配置VPC端点，那么将这两者分开是很有用的:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">CloudFormation嵌套堆栈示例</figcaption></figure><p id="6c23" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于上面的例子，需要注意的一点是兄弟栈之间的依赖关系。例如，VPC端点堆栈需要知道在哪个VPC创建端点。根堆栈引用VPC堆栈提供的输出，并将它们作为参数传递给VPC端点堆栈。在实例化堆栈之前，CloudFormation会执行代码验证，以报告语法错误和循环依赖等问题。</p><p id="792c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们最终定义了一个根栈，并把下面的嵌套栈作为资源:</p><ul class=""><li id="b68c" class="mz na it kk b kl km ko kp kr nb kv nc kz nd ld ne nf ng nh bi translated"><strong class="kk iu"> VPC </strong> —提供一个VPC，包括私有和公共子网、NAT网关和一个互联网网关。</li><li id="7a7a" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu"> VPC端点</strong> —提供服务端点，以确保在VPC使用这些服务时，数据仍保留在亚马逊网络中。VPC端点是为以下AWS服务定义的:S3、云观察日志和ECR。</li><li id="0540" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu"> ECR </strong> —为我们部署的docker映像提供一个容器注册表。</li><li id="ba6d" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu">负载平衡器</strong> —提供一个与ECS服务相关联的内部应用程序负载平衡器。</li><li id="a16b" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu"> ECS </strong> —调配ECS集群和支持IAM任务角色以及部署用户。请注意，服务和任务定义资源是在单独的API堆栈中定义的，因为它们经常更新。</li><li id="7122" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu">仪表板</strong> —提供CloudWatch指标仪表板。</li><li id="1e0f" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu">主题</strong> —提供主题，如同级堆栈使用的报警主题。</li><li id="ea18" class="mz na it kk b kl ni ko nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><strong class="kk iu">安全组</strong> —提供所需的安全组，这些安全组通常相互依赖来定义进入规则。然后，安全组作为参数传递给适当的嵌套堆栈。</li></ul><h1 id="70e2" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">部署流程</h1><p id="7932" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">既然我们已经讨论了API实现和底层基础设施，那么让我们在较高层次上回顾一下部署流程:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nn"><img src="../Images/42f8bbe4baca9588ecb8aa5ca4e789e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aWBG2yOoeeYruRSyUUA7mQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">部署流程:位桶管道、ECR和ECS</figcaption></figure><p id="4bf2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上图中最重要的一个方面是为每个AWS环境使用单独的帐户，同时共享相同的位存储库和管道。如图右侧所示，每个AWS帐户都包含自己的容器注册中心和ECS基础设施。这有助于在非生产环境中进行实验，而不必担心干扰正在运行的生产设置。考虑到环境资源固有地与特定帐户相关联，使用单独的帐户也使得环境标记有些多余。</p><p id="c176" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">部署流由Bitbucket git存储库的推送触发。正如我们将在后面看到的，每个分支或标记可以与位桶管道配置中的一组单独的步骤相关联，在特定的环境中处理部署。</p><p id="333c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着管道的启动，第一步是构建我们的API容器，并将docker映像推送到相关帐户内的弹性容器注册中心(ECR)。接下来是对ECS服务和任务定义的更新，它从ECR中提取相应的映像，并对服务执行滚动更新。</p><h1 id="86f2" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">比特桶管道</h1><p id="973c" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">我们的实现使用位桶管道来实现上面的部署流程。官方的<a class="ae le" href="https://confluence.atlassian.com/bitbucket/get-started-with-bitbucket-pipelines-792298921.html" rel="noopener ugc nofollow" target="_blank">入门</a>页面是一个很好的介绍，但是简而言之，<code class="fe md me mf mg b">bitbucket-pipelines.yml</code>文件是为特定的存储库定义构建管道的地方。</p><p id="126d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的设置中，<a class="ae le" href="https://bitbucket.org/idanlupinsky/ecs-fargate-service-infra/" rel="noopener ugc nofollow" target="_blank">基础设施</a>和<a class="ae le" href="https://bitbucket.org/idanlupinsky/ecs-fargate-service-api/" rel="noopener ugc nofollow" target="_blank">服务</a>存储库都包含一个与单独的CloudFormation堆栈相关联的<code class="fe md me mf mg b">bitbucket-pipelines.yml</code>文件。</p><p id="e010" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建两个库和栈的动机是将相当静态的基础设施栈与更加动态的API栈分开，因为后者会随着每个API构建而更新。这种分离也便于操作和开发团队分别管理两个存储库。</p><p id="649c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们检查一个简化的部署管道，它在一个<em class="mc">开发</em>环境中提供基础设施堆栈:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">位桶管道—部署到开发环境</figcaption></figure><p id="6ca3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe md me mf mg b">image</code>行指出哪个Docker映像用于构建环境。<code class="fe md me mf mg b">pipelines-awscli</code>映像预装了AWS CLI工具，我们使用该工具在文件的<code class="fe md me mf mg b">script</code>部分发出<code class="fe md me mf mg b">aws cloudformation</code>命令。凭据被分配了使用位存储库设置页面配置的安全存储库变量。</p><p id="6d6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了供应堆栈，我们需要发出<code class="fe md me mf mg b">package</code>命令来准备嵌套的堆栈工件并将其上传到S3桶，然后在准备好的根CloudFormation堆栈上发出<code class="fe md me mf mg b">deploy</code>命令来创建新的堆栈或更新现有的堆栈。这个配置通过在<em class="mc">开发</em>分支上定义一个触发器来利用分支工作流。两个存储库中的默认配置还在主分支<em class="mc">上定义了一个管道，以部署到生产中。</em></p><p id="88ac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">服务存储库定义了单独的位桶管道，该管道在更新ECS服务以触发对新版本的滚动更新之前，构建更新的API docker映像并将其推送到ECR。一个名为<code class="fe md me mf mg b">BITBUCKET_COMMIT</code>的预定义位桶变量用于标记我们的API映像的最新版本。</p><p id="ca47" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于选择分离基础架构和服务堆栈，我们需要一种方法来引用或构建基础架构堆栈。为了交叉引用资源，例如VPC子网，我们使用了CloudFormation的一个特性，它允许从一个堆栈导出资源，并通过其他堆栈导入这些资源。查看更多关于交叉引用堆栈资源的<a class="ae le" href="https://aws.amazon.com/premiumsupport/knowledge-center/cloudformation-reference-resource/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="32ac" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">监控和云监控</h1><p id="0174" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">服务可观察性可以在基础设施和应用程序级别提供有价值的洞察力。为了使服务能够投入生产，需要对其进行适当的监控。</p><p id="ea3b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的设置整合了CloudWatch套件的几个组件，以提高可观察性并获得可操作的洞察力。从<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/WhatIsCloudWatchLogs.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch日志</a>开始，ECS任务将它们的容器日志发送到一个<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html" rel="noopener ugc nofollow" target="_blank">日志组</a>来聚合它们。通过为任务定义中的每个容器指定<code class="fe md me mf mg b">awslogs</code>日志驱动程序，任务被配置为发送日志。这促进了集中日志记录的最佳实践，因为日志不再存储在本地容器中，也不再被本地容器访问。使用指定的VPC端点，在服务VPC和CloudWatch Logs服务之间建立私有连接。</p><p id="fc9f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的设置还使用<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/working_with_metrics.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch Metrics </a>从AWS资源和我们自己的服务中收集指标数据。AWS资源自动向CloudWatch发送指标，以帮助监控它们的运行状况和性能。AWS资源指标的一个例子是应用负载平衡器<a class="ae le" href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-cloudwatch-metrics.html" rel="noopener ugc nofollow" target="_blank">HTTPCode _ Target _ 5XX _ Count</a>指标。此指标可用于帮助识别服务器后端问题。然而，收集我们自己的服务发送的定制指标也很重要。为此，我们的任务设置运行一个<a class="ae le" href="https://hub.docker.com/r/amazon/cloudwatch-agent" rel="noopener ugc nofollow" target="_blank"> CloudWatch代理</a>作为一个<a class="ae le" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar" rel="noopener ugc nofollow" target="_blank"> sidecar </a>容器。自定义指标从我们的服务发送到代理容器，代理容器聚合指标数据，并将其进一步发送到CloudWatch服务。</p><p id="2d36" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CloudWatch代理支持的指标收集协议之一是<a class="ae le" href="https://github.com/statsd/statsd" rel="noopener ugc nofollow" target="_blank"> statsd </a>。使用这样一个流行的协议有助于发送定制指标的过程。有相当多的statsd开源客户端可供选择。我们的服务实现使用了一个<a class="ae le" href="https://github.com/jsocol/pystatsd" rel="noopener ugc nofollow" target="_blank"> Python statsd客户端</a>，它允许修饰方法以声明的方式轻松地添加指标。以下示例演示了如何发送计时器度量，该度量跟踪评估方法运行所需的时间:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">Statsd定时器度量示例</figcaption></figure><p id="da59" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了分组和隔离指标，CloudWatch提供了<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html" rel="noopener ugc nofollow" target="_blank">名称空间</a>的概念。例如，应用程序负载平衡器服务将其指标分组到<code class="fe md me mf mg b">AWS/ApplicationELB</code>名称空间中。我们通过将代理定义为its容器配置的一部分来配置代理使用特定的名称空间。以下代码片段摘自服务API CloudFormation堆栈的任务定义:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">CloudWatch代理容器定义</figcaption></figure><h2 id="dd59" class="no lg it bd lh np nq dn ll nr ns dp lp kr nt nu lr kv nv nw lt kz nx ny lv nz bi translated">仪表板和警报</h2><p id="1141" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">收集日志和指标是最基本的，但是仅仅收集日志和指标是不够的。为了能够可视化收集的数据，我们使用了<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Dashboards.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch仪表盘</a>。仪表板是数据分析的重要工具，可以面向不同的受众。开发人员可以使用仪表板来促进性能改进，服务可靠性工程师(sre)可以参考仪表板来帮助分类生产问题，经理可以审查更高级别的业务指标。对于我们的服务，我们提供了一个简单的仪表板，主要面向开发人员和sre。该控制面板聚合了有关我们的ECS集群、服务ALB以及估价方法计时器指标的指标数据。仪表板对于审查我们服务的整体运行状况和性能非常有用。</p><p id="a370" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仪表板需要目标受众的主动监控和互动。为了自动化监控过程，<a class="ae le" href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/AlarmThatSendsEmail.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch Alarms </a>被提供来监控指标，并在警报阈值被突破时调用操作。一个<a class="ae le" href="https://docs.aws.amazon.com/sns/latest/dg/welcome.html" rel="noopener ugc nofollow" target="_blank">通知主题</a>可以被指定为一个警报动作——每当警报产生时，该主题的订阅者都会收到一个通知。在我们的设置中，我们为SNS主题提供了一个电子邮件订阅者，并将所有警报与该主题相关联。以下代码片段演示了如何提供CloudWatch警报来监控上述<a class="ae le" href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-cloudwatch-metrics.html" rel="noopener ugc nofollow" target="_blank">HTTPCode _ Target _ 5XX _ Count</a>负载平衡器指标:</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">CloudWatch警报示例</figcaption></figure><p id="701f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在1分钟内从后端返回至少一个5XX HTTP错误，就会触发上述警报。这种警报是基础设施级监控的一个例子，但是我们也可以提供监控应用级指标的警报，比如评估方法运行时。</p><h1 id="2c54" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">摘要</h1><p id="4068" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在本指南中，我们介绍了使用ECS和Fargate在AWS上构建和部署简单服务的过程。本指南旨在总结我们在部署自己的服务时学到的知识。服务架构部分基于AWS编写的<a class="ae le" href="https://github.com/awslabs/ecs-refarch-continuous-deployment" rel="noopener ugc nofollow" target="_blank">参考</a> <a class="ae le" href="https://github.com/aws-samples/ecs-refarch-cloudformation" rel="noopener ugc nofollow" target="_blank">架构</a>。希望本指南能够帮助您的团队开始在AWS上部署他们自己的服务。如果您有任何问题或改进建议，请联系我们。</p></div></div>    
</body>
</html>