<html>
<head>
<title>More JavaScript Code-Tuning Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更多JavaScript代码调优技术</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/more-javascript-code-tuning-techniques-e081bcf46122?source=collection_archive---------14-----------------------#2020-06-02">https://levelup.gitconnected.com/more-javascript-code-tuning-techniques-e081bcf46122?source=collection_archive---------14-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/77939cc63e49b3fa3b67c76971b18f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U1lBI87N9T0qCe0t"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@erinw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾琳·威尔逊</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f260" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="fb05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究JavaScript代码的一些常见代码调优技术，包括减少操作和使用资源较少的操作。</p><h1 id="7966" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">前哨值</h1><p id="cb78" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">标记值是保证终止一段代码的值。</p><p id="4a1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写以下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a6c4" class="mq lf it mm b gy mr ms l mt mu">let found = false;<br/>let i = 0;<br/>while ((!found) &amp;&amp; (i &lt; items.length)) {<br/>  if (items[i] === value) {<br/>    found = true;<br/>  } else {<br/>    i++;<br/>  }<br/>}</span></pre><p id="72d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe mv mw mx mm b">value</code>是标记值，当遇到<code class="fe mv mw mx mm b">found</code>变成<code class="fe mv mw mx mm b">true</code>时，它将停止<code class="fe mv mw mx mm b">while</code>循环。</p><p id="eff0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将减少运行循环所需的迭代次数，因为它不必一直运行到最后。</p><h1 id="a67a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将最繁忙的环路放在内部</h1><p id="dba9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该将具有更多迭代的循环放在内部，以加速我们的代码。</p><p id="9e53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bd24" class="mq lf it mm b gy mr ms l mt mu">for (let column = 0; column &lt; 100; column++) {<br/>  for (let row = 0; row &lt; 5; row++) {<br/>    //..<br/>  }<br/>}</span></pre><p id="a0cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到外部循环的100次迭代加上嵌套循环的5 x 100次迭代，总共600次迭代。</p><p id="7ff6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们把它们翻转过来:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ec52" class="mq lf it mm b gy mr ms l mt mu">for (let row = 0; row &lt; 5; row++) {<br/>  for (let column = 0; column &lt; 100; column++) {<br/>    //..<br/>  }<br/>}</span></pre><p id="2bb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们得到外部循环的5次迭代，加上嵌套循环的5 x 100次迭代，总共505次迭代。</p><p id="6256" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，这大大减少了总迭代次数。</p><h1 id="370c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">强度降低</h1><p id="4ed9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用占用较少资源的操作来替代资源更密集的操作。</p><p id="4c38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，乘法可以用重复加法代替。</p><h1 id="c3a3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用尽可能少的数组维数</h1><p id="2940" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">减少数组维数使得对它们的操作更快更容易。因此，没有理由不降低维度。</p><p id="b139" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嵌套越多，代码就越难阅读。因此我们也应该降低维度。</p><h1 id="42b6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">最小化数组引用</h1><p id="f945" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">最小化阵列访问也节省了资源。</p><p id="496f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不需要数组，那么我们就不应该使用它们。</p><h1 id="a71f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用缓存</h1><p id="140f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以缓存我们计算结果的结果，这样我们就不必再计算它们了。</p><p id="e21a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以这样做:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5a1c" class="mq lf it mm b gy mr ms l mt mu">let a = 1,<br/>  b = 2;<br/>const cache = {};<br/>const cachedSum = (a, b) =&gt; {<br/>  if (cache.hasOwnProperty([a, b])) {<br/>    return cache[[a + b]];<br/>  } else {<br/>    cache[[a + b]] = a + b;<br/>    return a + b;<br/>  }<br/>}</span></pre><p id="0b6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将结果缓存在<code class="fe mv mw mx mm b">cache</code>对象中，然后根据需要从那里返回结果。</p><h1 id="e72d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">利用代数恒等式</h1><p id="dd6b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用代数恒等式来省去一些运算。</p><p id="a74b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c8ea" class="mq lf it mm b gy mr ms l mt mu">!a &amp;&amp; !b</span></pre><p id="7e68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fc85" class="mq lf it mm b gy mr ms l mt mu">!(a || b)</span></pre><p id="3208" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a751" class="mq lf it mm b gy mr ms l mt mu">x ** 0.5 &lt; y ** 0.5</span></pre><p id="a841" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以替换为:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="45e1" class="mq lf it mm b gy mr ms l mt mu">x &lt; y</span></pre><p id="ed0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为平方根一直在增加。</p><h1 id="58b5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用强度缩减</h1><p id="c138" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用更便宜的手术来代替许多昂贵的手术。</p><p id="43ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们包括:</p><ul class=""><li id="7375" class="my mz it ki b kj kk kn ko kr na kv nb kz nc ld nd ne nf ng bi translated">用加法代替乘法</li><li id="7590" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated">用乘法代替幂运算</li><li id="0198" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated">用三角恒等式代替三角函数</li><li id="645d" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated">用移位运算代替2的乘法和2的除法</li></ul><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/56175ab201432d3bec527ed6eb793b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A8AhKH6jgBTTVese"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@wassoph?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瓦西姆·舒阿克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="b0c2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">预计算结果</h1><p id="8979" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">只要有可能，我们应该将预先计算的结果存储到它们自己的变量中，以便我们可以在以后重用该结果。</p><p id="a545" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有多次使用的表达式，那么可以将它们赋给自己的变量，这样我们就可以在任何地方使用它们。</p><p id="865e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a7eb" class="mq lf it mm b gy mr ms l mt mu">let prices = applePrice + orangePrice;<br/>//...<br/>let subtotal = prices + taxes;<br/>let discount = prices * 0.2;<br/>//...</span></pre><p id="90d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以用<code class="fe mv mw mx mm b">prices</code>代替到处重复<code class="fe mv mw mx mm b">applePrice + orangePrice</code>。</p><h1 id="f944" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="7cf4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过最小化数组引用和减少必须通过缓存完成的计算量来提高代码的性能。</p><p id="b78d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，如果我们有更多资源密集型操作，那么它们应该被使用较少资源的操作所取代。</p><p id="df71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以使用代数恒等式来保存代码中的操作。</p></div></div>    
</body>
</html>