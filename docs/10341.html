<html>
<head>
<title>Why Use gRPC and Thrift for Remote Procedure Calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么对远程过程调用使用gRPC和Thrift</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-use-grpc-and-thrift-for-remote-procedure-calls-a4627a9abe6?source=collection_archive---------5-----------------------#2021-11-24">https://levelup.gitconnected.com/why-use-grpc-and-thrift-for-remote-procedure-calls-a4627a9abe6?source=collection_archive---------5-----------------------#2021-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fa87f0ddf9d6a83d50ff4cec941028e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S4SdnZx4TPtx3Gxd"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">克里斯·克雷默在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c619" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，每当有人想要开始为他们的网站构建一个HTTP API时，他们几乎完全使用REST作为首选的架构风格。与RPC和GraphQL等替代方法相比，他们更喜欢REST。</p><p id="6b3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">REST适用于大多数情况，尤其是当您构建一个没有复杂的应用程序内通信的整体应用程序时。当您构建一个由许多定期相互通信的后端服务组成的应用程序时，问题就来了。这种架构的一个例子可以是这样的。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/d611ce5e6eef8781487c2cad49ccaf56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_crf3dsSJmyLvuBDe52cxw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片由Jimmy Soh在<a class="ae kf" href="https://medium.com/the-internal-startup/how-to-draw-useful-technical-architecture-diagrams-2d20c9fda90d" rel="noopener">https://medium . com/the-internal-startup/how-to-draw-used-technical-architecture-diagrams-2d 20 c 9f da 90d</a>上提供</figcaption></figure><h1 id="0106" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">当建筑变得复杂时</h1><p id="3504" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">快速、灵活、易于扩展和简单的架构非常重要。但是您拥有的服务、端点和业务逻辑越多，架构就可能变得越复杂。有许多设计问题。</p><p id="d477" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，每个端点都需要Swagger文档和契约测试。API端点越多，需要实现的文档和测试就越多。例如，支持面向最终用户的公共API和面向内部调用的简化API需要编写两次API。这可能是可以管理的，如果不是因为其他因素会增加开发人员的复杂性的话。</p><p id="37c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果从其他几个服务调用底层服务，每个服务使用不同的语言，我们需要为每种语言重写API SDK、数据模型和其他服务的代码。这种重写不仅包括代码本身，还包括单元测试、文档、持续集成工具和其他方面。因此，多语言支持需要非常高的准确性和开发团队的关注。</p><p id="7ee0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不仅额外的语言会增加复杂性，同一种语言的不同版本也会增加复杂性。向后兼容性问题需要密切关注，尤其是当有许多依赖项时。此外，一种语言的库中的更改可能会在另一种语言的库中丢失。因此，即使一个额外的依赖项也会增加复杂性。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mm"><img src="../Images/89dba51a271e7c991f0d952e146b786b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TwOZJ62L4FJx-_0K"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@matt_j?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Matthieu Joannon </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="3661" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于所有这些问题，进行更改需要大量的工程师时间，并且有引入错误的风险。同时，网络的开销必须是可管理的。如果一行中的几个服务为每个API调用编码和解码JSON数据，那么高负载网络很容易过载。</p><h1 id="cdaf" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">寻找解决方案</h1><p id="5164" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">虽然GraphQL是一个很好的解决方案，但它仍然不是直接微服务通信的最佳解决方案。使用一个GraphQL模式作为API网关，每次微服务契约输入和输出发生变化时，API网关端的模式都需要改变。如果每个微服务有多个GraphQL模式，GraphQL的目的就落空了。GraphQL是整个应用程序数据的模式，允许在一次往返中获得数据。</p><p id="1c67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于我们的例子，我们将考虑RPC方法。为了理解为什么RPC方法优于前面的解决方案，让我们看一下这个简单的分布式体系结构图。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/1cfeb54a9cc85e581c2ce433d8502c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G-Nv2BJqbpzsLEHI"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片作者:Oleksandr Piekhota</figcaption></figure><p id="8fd4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里，请注意一些事情。首先，在发出请求之前，客户端需要序列化数据。服务器需要在收到数据后以及发送响应时对数据进行反序列化。</p><p id="92d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于客户端和服务器之间的交互，使用正确的通信协议和数据格式非常重要。理想情况下，数据应该是紧凑的，快速编码和解码，并且它们的协议应该是优化的。</p><h2 id="a280" class="mo lk it bd ll mp mq dn lp mr ms dp lt kr mt mu lx kv mv mw mb kz mx my mf mz bi translated">数据紧密度</h2><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/3057cc4b1722067adddb0110fc9a7305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UUh6OVIlQCmKvv-f"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片作者:Oleksandr Piekhota</figcaption></figure><p id="8645" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与JSON格式相比，二进制格式显然更加紧凑。</p><h2 id="8249" class="mo lk it bd ll mp mq dn lp mr ms dp lt kr mt mu lx kv mv mw mb kz mx my mf mz bi translated">数据编码/解码时间</h2><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/a0fd4f3cb3e918edc9aa659b5e59971a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P864jxEP7yytK-M1"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片作者:Oleksandr Piekhota</figcaption></figure><p id="27d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">二进制格式显然也比JSON格式快。</p><h2 id="d3d8" class="mo lk it bd ll mp mq dn lp mr ms dp lt kr mt mu lx kv mv mw mb kz mx my mf mz bi translated">那么为什么不直接使用二进制格式呢？</h2><p id="0fd2" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">原始二进制格式实际上是否更容易使用是有争议的。为了便于使用二进制格式，我们需要为数据创建二进制规范，实现编码和解码功能，开发良好的调试工具，并编写良好的文档。</p><p id="c45b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使我们提高了API通信的性能，我们仍然需要解决多语言微服务通信的问题。这就是RPC的用武之地。一个可能的解决方案是以某种语言无关的方式描述我们的数据模型，这样我们就可以为每种语言生成相同的模型。这需要使用一个<strong class="ki iu"> IDL </strong>，或者接口定义语言。IDL中的数据模型代码可以用作RPC调用的输入。</p><p id="ed87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们还需要一个多语言的RPC框架来支持我们的数据结构。对于栈中的每种语言，都有开发IDL库和RPC框架的替代方法。</p><h1 id="6446" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">gRPC和节俭派上用场了</h1><p id="361f" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">是的，使用IDL可以解决微服务的通信问题。使用IDL，您可以创建一个模型，然后使用代码生成工具，您可以生成可以包含在您的业务逻辑中的目标语言模型。这解决了跨不同语言重用相同模型的问题。</p><p id="1da7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个好的IDL还具有足够的可读性，可以用作文档，消除了对Swagger和API规范的需求。使用RPC框架，我们解决了为几种语言复制客户端请求库的问题。我们还简化了我们的API，因为RPC比REST API简单得多。使用RPC框架，不需要编写自己的REST客户端。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/76050d870e912c159245b9b97ea85e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pHEM5EeYd5Brw_1o"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">亚历山大·辛恩在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a4a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">gRPC和Apache Thrift是两个最流行的RPC解决方案，它们都基于IDLs。它们有助于解决管理复杂微服务网络的问题。</p><p id="837d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nd">本文是与</em><a class="ae kf" href="https://www.airslate.com/?utm_source=Medium&amp;utm_medium=Articles&amp;utm_campaign=airslate_homepage&amp;utm_id=grpc_and_thrift" rel="noopener ugc nofollow" target="_blank"><em class="nd">airSlate</em></a><em class="nd">的软件工程师Oleksandr Piekhota共同撰写的，作为对air slate技术讨论的一部分。</em></p></div></div>    
</body>
</html>