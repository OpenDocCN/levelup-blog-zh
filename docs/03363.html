<html>
<head>
<title>Determining If a Linked List is a Palindrome</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">判断一个链表是否是回文</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/determining-if-a-linked-list-is-a-palindrome-899616714f5e?source=collection_archive---------28-----------------------#2020-05-04">https://levelup.gitconnected.com/determining-if-a-linked-list-is-a-palindrome-899616714f5e?source=collection_archive---------28-----------------------#2020-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3665" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">被劫持</p><div class="kl km gp gr kn ko"><a href="https://leetcode.com/problems/palindrome-linked-list/" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">回文链表- LeetCode</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">leetcode.com</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc ld ko"/></div></div></a></div><p id="9a0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Leetcode的回文链表问题(#234)是一个很大的问题，因为达成一个解决方案综合了链表算法中几种常用的模式。在这个问题中，我们要确定一个单链表是否是一个回文。类似于字符串，回文链表中的节点值等于它的逆序节点值。然而与字符串不同的是，我们不能仅仅创建一个反向版本并与原始输入进行比较，因为链表不像字符串那样是原始数据类型。对于链表，我们必须通过遍历链表并比较每次迭代的值来比较反向链表和原始链表。如果它们中的任何一个值在迭代中不相等，那么链表就不是回文。</p><p id="ddab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个解决方案。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/ba2f0cb5b8731d98d4ffa1b4253bb359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTgcj3EgNmGXbCVAmAyysQ.png"/></div></div></figure><p id="33f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的解决方案中，我们首先在reverseAndClone中创建一个链表的反向副本，使用Node类构造函数在原始列表的每次迭代中创建节点实例，并执行一个看起来有点复杂的反向操作，我将在下面详细介绍。假设我们有一个这样的链表。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lp"><img src="../Images/91d56d1a102aeff64eba4582751cdae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmhp-IwX6SANFDxBABSyVw.png"/></div></div></figure><p id="1924" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一次迭代中，我们用list1的第一个节点的值1创建一个新节点。我们的节点目前看起来是这样的:<strong class="jp ir"> copy = { val: 1，next: null } </strong>。现在，我们将副本的指针设置为head，它当前为空。然后，我们设置头部等于我们的副本。现在，head等于<strong class="jp ir"> { val: 1，next: null } </strong>。然后我们将节点设置为最后的下一个节点。在第二次迭代中，我们将copy设置为保存list1的第二个节点值2的节点。然后，我们将副本的指针设置为head，它当前等于<strong class="jp ir"> { val: 1，next: null } </strong>，随后将head设置为副本。现在，head等于<strong class="jp ir"> { val: 2，next: val: 1，next: null } </strong>。然后，将node设置为列表中的下一个节点。我希望你能明白接下来会发生什么。:)迭代运行后，我们返回head变量，它现在保存了原始链表的反向副本。</p><p id="d1c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在isPalindrome中，运行reverseAndClone函数后，我们希望在while循环中遍历原始列表和反转列表。只要原始列表的当前节点的值等于反向列表节点的值，我们就迭代，直到我们的一个链表是falsy。如果其中一个列表的节点值不等于另一个列表的节点值，我们将通过返回false来中断循环。如果一切顺利，我们将从循环的另一端出来，返回true。我们的list1示例将产生true这是一个回文！</p><p id="6776" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面是一个很好的解决方案，时间复杂度和空间复杂度都是O(N)。然而，我知道我们可以做得更好。假设我们取回文字符串，" racecar "。如果我们从开始到(包括)其中点(“race”)切割字符串，然后从其中点到结束(“ecar”)切割字符串，然后反转(“race”)，我们会注意到两者是相同的。将一个回文在其中点拆分，比较原来的前半部分和反转后的后半部分，应该是镜像吧！我们可以对链表使用相同的逻辑，并将空间复杂度降低一半！</p><p id="43d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们将这个新想法伪代码化，它看起来会像这样:</p><p id="cc54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.)找到链表的中点。</p><p id="0f14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.)在链表的中点反转链表</p><p id="6f62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.)通过查看每个值来比较从其头部开始的原始列表和从中点开始的反转列表，以查看它们是否相等</p><p id="ba45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我觉得把步骤分成不同的功能看起来最好。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lq"><img src="../Images/da13aa8b566c164d4891b7db64019f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7CMu40rW4IBEomNO6oDMkg.png"/></div></div></figure><p id="c6d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在函数中做的第一件事是找到链表的中点。在链表问题中普遍需要找到链表的中点，所以理解它是一个很大的功能。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lr"><img src="../Images/5cbc3f7e9a9625d2a609b78022ef9ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ykQeYjHKCLuUpZWNtXyFOA.png"/></div></div></figure><p id="ae10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在findMidpoint中，我们定义了两个名为fast和slow的变量，并将它们设置为head。然后我们迭代，只要fast是真的，fast的指针是真的。我们恰当命名的fast变量在每次迭代中被设置为下一个节点的下一个节点，而slow被设置为该节点的下一个值。绕了一圈后，我们慢慢返回。这一开始可能会有点混乱，所以让我们试着用旧的list1调用findMidpoint一步一步地完成它。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lp"><img src="../Images/91d56d1a102aeff64eba4582751cdae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmhp-IwX6SANFDxBABSyVw.png"/></div></div></figure><p id="4a80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先将fast和slow设置为list1。然后我们进入while循环。第一次迭代时，fast设置为fast.next.next，所以fast的头节点值为3。而slow就变成了slow .接下来，so slow的头值是2。在第二次迭代中，fast的头部值变为1，slow的头部值为3。因为没有fast .接下来我们跳出循环返回slow，slow在链表的中点:slow是<strong class="jp ir"> { val: 3，next: { val: 2，next: { val 1，next:null } }</strong>。</p><p id="6a4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的列表从中点开始，我们想要反转它。反转链表是链表问题中另一种常用的方法，所以理解其中的逻辑真的很有帮助。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ls"><img src="../Images/42ecf1830a06c97708eaa9f05cbd7817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9N0UVUhwgRtVBVFydedZ6Q.png"/></div></div></figure><p id="e6f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">反过来，我们做的第一件事就是把prep和next赋值给null。然后我们遍历我们的大脑。在迭代的第一行，我们的下一个变量被设置为head中的下一个节点。我们这样做是因为在下一步中，我们要将head指向prev，它目前为空，我们不想丢失原始列表的节点。否则我们没有什么可迭代的。然后我们将prep设置为head，然后将head设置为next，它保存head的下一个节点的原始版本。最后，我们返回prev，它保存传入列表的反向版本。</p><p id="9857" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一步中，我们想在从中间开始的反向链表长度上迭代原始列表，并比较每次迭代的值。如果它们在每次迭代中相等，就证明了链表是一个回文。让我们在isPalindrome函数中添加几个条件，进一步优化它。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi lt"><img src="../Images/9b765169d3b9987fd2e1170edc13901c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWoXEoZucGA-GTkggOSDzg.png"/></div></div></figure><p id="13df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一个if语句中，我们基本上是在检查我们是否收到了良好的输入。如果传入isPalindrome的值是假的(可能是一个空的链表)，只需返回false。在第二个if语句中，我们检查链表是否只由一个节点组成。如果是，那么我们知道它的值颠倒了将是相同的，所以只是返回真，而不是执行下面的isPalindrome的复杂逻辑。:)</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><div class="lf lg lh li gt ko"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab fo"><div class="kq ab kr cl cj ks"><h2 class="bd ir gy z fp kt fr fs ku fu fw ip bi translated">编码面试问题|熟练。开发</h2><div class="kv l"><h3 class="bd b gy z fp kt fr fs ku fu fw dk translated">一个完整的平台，在那里我教你所有你需要的东西来找到你的下一份工作和技巧…</h3></div><div class="kw l"><p class="bd b dl z fp kt fr fs ku fu fw dk translated">熟练的. dev</p></div></div><div class="kx l"><div class="mb l kz la lb kx lc ld ko"/></div></div></a></div></div></div>    
</body>
</html>