<html>
<head>
<title>Improving React Performance Using Bulk Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用批量处理提高React性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improving-react-performance-using-bulk-processing-69d1751d6a1c?source=collection_archive---------37-----------------------#2021-03-07">https://levelup.gitconnected.com/improving-react-performance-using-bulk-processing-69d1751d6a1c?source=collection_archive---------37-----------------------#2021-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/30fd3022232630e37d8e18b99fff7db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8m9q1QTTYQ_85J0hFPYTDg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我对《走鹃》中的片段做了一点修改。Meep Meep！”卡通。</figcaption></figure><p id="e69c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我敢肯定，大多数使用Redux的React开发人员在试图在短时间内调度多个动作时，都遇到过渲染性能问题和应用程序冻结问题。</p><p id="a922" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我在一个赌博项目中遇到了这个性能问题，该项目使用WebSockets接收新的赌注，然后将这些赌注存储在Redux中，并使用React在UI中显示这些赌注。大多数情况下，当用户在短时间间隔内非常活跃时，我们会在流行的体育比赛中遇到性能问题，我们会遇到每秒收到<strong class="ke ir"> 50注</strong>的情况，这大约是每<strong class="ke ir"> 20毫秒</strong>1注的情况。在这些时刻，我们的用户界面变得像北极冰川一样冻结:)由于我们的Redux商店中的多次调度和多次用户界面重新呈现。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="0074" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，当我们知道了<strong class="ke ir">问题</strong>之后，让我们来谈谈<strong class="ke ir">解决</strong>的方法。</p><blockquote class="lh"><p id="6920" class="li lj iq bd lk ll lm ln lo lp lq kz dk translated">"问题说清楚了，问题就解决了一半."</p></blockquote><p id="6c81" class="pw-post-body-paragraph kc kd iq ke b kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv lv kx ky kz ij bi translated">为了解决这个问题，我尝试了多种解决方案，但是表现最好的是批量处理<strong class="ke ir">。</strong></p><p id="060b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">批量处理</strong> —允许一次处理多个数据块的过程。批量处理比单独处理案例更节省时间，也更不容易出错。</p><p id="b8c7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">简而言之，现在不是每次我们收到新赌注时都调度Redux操作，而是在配置的时间内收集所有输入的赌注，并在Redux中一次性调度它们。例如，最终我们将有<strong class="ke ir"> 1次重新渲染/秒</strong>，而不是像以前一样<strong class="ke ir"> 50次重新渲染/秒</strong>。</p><p id="5d74" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">听起来容易</strong>😊但事实上，有很多时候<strong class="ke ir">应该被带进consideration🧐 </strong></p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="5521" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">现在让我们开始编码部分。</h1><p id="19a1" class="pw-post-body-paragraph kc kd iq ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz ij bi translated">如你所知，我们需要编写一个机制来收集新的赌注，当配置的时间到期时，它将调用一个提供的回调，该回调可以在Redux中调度所有数据。</p><p id="3acb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在JavaScript世界中，这种机制应该是这样的。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="28d8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我解释一下代码的一些部分，然后是用法。</p><p id="e63c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将使用的<code class="fe nf ng nh ni b">BulkProcessor</code>的主要函数是<code class="fe nf ng nh ni b">processData</code>，这个函数将<code class="fe nf ng nh ni b">data</code>作为参数，并将其推入<code class="fe nf ng nh ni b">collectedData</code>，这里我们使用<code class="fe nf ng nh ni b">unshift</code>是因为这个规则:</p><blockquote class="nj nk nl"><p id="0f9f" class="kc kd nm ke b kf kg kh ki kj kk kl km nn ko kp kq no ks kt ku np kw kx ky kz ij bi translated">先进先出。</p></blockquote><p id="8f19" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">同样在最后<code class="fe nf ng nh ni b">processData</code>会调用<code class="fe nf ng nh ni b">debouncedCallback</code>功能。</p><p id="04d6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你现在的问题大概是<em class="nm">“为什么我们需要一个</em> <code class="fe nf ng nh ni b"><em class="nm">debouncedCallback</em></code> <em class="nm">？为什么不用一个普通的</em> <code class="fe nf ng nh ni b"><em class="nm">setTimeout</em></code> <em class="nm">？”</em></p><p id="d4d7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们将使用<code class="fe nf ng nh ni b">setTimeout</code>，我们提供的回调将在每次调用<code class="fe nf ng nh ni b">processData</code>时被调用，这将破坏整个想法。</p><p id="f70e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一件有趣的事情是<code class="fe nf ng nh ni b">maxWait</code>参数提供给<a class="ae nq" href="https://lodash.com/docs/4.17.15#debounce" rel="noopener ugc nofollow" target="_blank"> lodash去抖util </a>。简而言之，这个参数将帮助我们在一秒钟内至少调用一次回调，如果我们有一个很长的数据队列的话。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="8086" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">用法。</h1><p id="754d" class="pw-post-body-paragraph kc kd iq ke b kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz ij bi translated">假设我们订阅了一个套接字，如下面的代码所示，它接收数据的速度非常快。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1acf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如你所看到的，我们的分派现在将被<code class="fe nf ng nh ni b">BatchProcessor</code>调用，但不是像以前一样每次都被套接字回调，我们还应该为<code class="fe nf ng nh ni b">NEW_BETS</code>动作重构我们的<code class="fe nf ng nh ni b">reducer</code>，因为现在<code class="fe nf ng nh ni b">payload</code>是一个赌注数组，而不是单个赌注(但这个小的重构我在这里不做介绍，因为它很容易做到)。</p><p id="34fc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一件事是你应该注意在哪里声明<code class="fe nf ng nh ni b">BulkProcessor</code>实例，在这种情况下应该在<code class="fe nf ng nh ni b">subscribe</code>之外声明，以避免有多个实例。</p><p id="d2f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你正确地遵循了所有的步骤和技巧，我可以祝贺你，因为现在你的应用程序可以更快地知道这种方法。</p><p id="365c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">感谢阅读。我希望这有所帮助。</p></div></div>    
</body>
</html>