# 将 Redux 重构为 React 挂钩

> 原文：<https://levelup.gitconnected.com/refactoring-redux-into-react-hooks-6273647f9378>

## Redux 很棒，你仍然可以使用它。但是你的所有特性都需要它吗？

![](img/1d26e6a387e9a6169ebbba0fb63fa560.png)

布鲁克·安德森在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

您是否为想要从后端获取的每一小部分数据编写了一个缩减器、3-5 个动作创建器和异步动作？如果您认为这是一堆臃肿的文件，其中的“业务”代码在常量、reducers、connect/dispatch/getState 中丢失了——那么您就对了，我将向您展示如何使用 pure React 在更具内聚性的代码中获得同样的好处。

本文是一个重构会议。我假设读者对 Redux 和 React 钩子都有很好的理解。

# 出发点

假设您正在使用 react-redux 构建一个常规的 web 应用程序。您可能想要的功能之一是以 Redux 状态维护会话信息，并在您的应用程序中使用它。这是一个典型的国家消费的例子:

Hello.js

如果使用细粒度选择器或 mapDispatchToProps，可能会有更多。

# 使用钩子

`react-redux`提供了 hooks API，同样的代码可以写成这样:

我们没做什么特别的事。我们只是使用了 React Hooks API，而不是同一个库中的 HOC API(`connect`是一个高阶组件)。它消除了一些与 Redux 状态消耗相关的样板文件。只要给`useSelector`打个电话就完事了。

# 组件不应该知道数据来自哪里

在第一步之后，我们最终使用了从`react-redux`引入的`useSelector`函数。如果你只是消耗 redux 状态，并且不想要任何副作用，这是相当好的。但是你真正想要的是——`session`特性的状态。Redux 只是一个实现细节，我们可以将这个实现细节隐藏到特性模块中。不仅仅是“更干净的代码”(我不喜欢在真空中清洁代码的想法)。这是重要的一步，给了我们一些重构和移动的空间。

此时，我们的视图组件(Hello.js)不再知道会话是如何加载的。它只是使用了一个由`session.js`提供的自定义钩子。但是会话模块本身仍然依赖于 redux 动作、reducer 和其他一些样板文件。还记得你不得不写`componentDidMount`来调度 fetch 动作给 redux 的情况吗？我总是希望 redux 能够神奇地理解我正在消耗状态的这一特定部分并获取它。我不会在这里写这段代码，反正我们是要把它扔掉的。

# 你不需要 Redux

组件只能通过`useSession`钩子使用会话。如果你用别的东西代替 redux，组件不在乎。所以让我们开始吧。`Hello`组件保持不变，不会再改变，所以我只发布对`session`模块的更改。我从一个简单的模块实现开始，有一些空白，并在接下来的重构迭代中改进它。

你不需要更多的东西来使它工作，就是这样。此外，它还解决了常见的 redux 问题——何时启动数据提取，谁负责这个问题？使用定制钩子方法，钩子本身负责，没有额外的样板文件。

# 不要重新计算你已经知道的东西

上面的代码片段有两个缺点:

*   每当您在新组件中使用 session 时，它都会调用`fetchSession`函数，这可能计算起来很昂贵，也就是说，它可能会执行网络请求。
*   第一次渲染新组件时，它会以“正在加载”状态(会话的初始状态)进行渲染。

让我们解决这个问题！有关解释，请参见代码中的注释

这段代码看起来有点粗糙，但无论如何，它解决了问题。该会话最多被提取一次，并且在提取会话之后不会发生额外的重新呈现。此外，代码现在高度内聚——整个会话管理只有一个文件。

# 但是等等，这不是一个过于简单化的案例吗？

嗯，确实是。一个更复杂的例子是，如果您使用`session`特性来跟踪登录/注销，而不仅仅是查找当前状态。在 redux 应用程序中，您可能希望为此分派动作，并使用某种中间件来处理异步请求(通常是 redux-saga 或 redux-thunk)。

让我们编写一个使用登录/注销功能而没有 redux 的组件。

我们现在可以使用组件代码来理解我们希望`session`公开什么 API。它应该有一个钩子`useSession`——和之前的钩子一样，但是除此之外，它应该公开`login`和`logout`函数，这是 return 的承诺。如果成功调用这两者中的任何一个，`useSession`将触发其消费者的重新招标。您可能希望使用 React 上下文来实现这一点，但是让我们首先尝试模拟上下文功能:

如您所见，您可以创建一个命令式 API，并使用 React 钩子来消耗这个 API 的副作用。不需要 Redux 或 React 上下文。登录期间的错误由初始调用者处理，并且会话在出错的情况下不会改变。

# 使用上下文将一个变更交付给多个消费者

在前一个例子中，我们使用了一组消费者。它可以工作，但是 React 在这里不能进行太多的优化，并且您可能在一个卸载的组件上有不可预测的状态变化。想象一下，一个组件的状态变化将导致其他组件的卸载。在前面的例子中，我们没有处理这种情况，但是 React Context 可以开箱即用地处理这种情况。

默认的 React 上下文行为的一个缺点是，提供者的安装和评估是独立于它是否被任何组件实际使用的。为了克服这一点，我们可以推迟数据获取，直到我们的自定义钩子被调用。

`useSession` hook 调用 Provider 传来的`setHasConsumer`回调，这是 Provider 获取数据的信号。

# 摘要

我希望我帮助你不要因为众多的小特性而用 Redux 样板膨胀你的应用。你的应用程序中可能有很多上下文——每个独立的特性有不同的上下文。

我在这里没有涉及更多的主题——当一个服务依赖于另一个服务时，如何组织服务。如果您不太关心性能，这很容易——只需在另一个服务的提供者内部使用一个服务导出的钩子。但是你会失去通过`setHasConsumer`优化获得的性能。依赖服务总是有一个消费者。如何克服这个问题是另一篇文章的主题。

**UPD:**

这是故事的第二部分，我们为状态管理构建了可重用的库，并修复了上面概述的缺点——使用 React Hooks 进行全局状态管理。