<html>
<head>
<title>Coding Problem: First Non-Repeating Character in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码问题:Go中第一个不重复的字符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/coding-problem-first-non-repeating-character-in-go-e16fcab5da40?source=collection_archive---------16-----------------------#2021-04-04">https://levelup.gitconnected.com/coding-problem-first-non-repeating-character-in-go-e16fcab5da40?source=collection_archive---------16-----------------------#2021-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="660f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高你的编码技能！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e7edad0871b00adf8ea4fbb9575af514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8EDet89zXnb_JMVo"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">从<a class="ae ky" href="https://unsplash.com/photos/W8VDpcZeeFc" rel="noopener ugc nofollow" target="_blank"> unsplash </a></figcaption></figure><p id="c98f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">这篇文章是我用最相关的语言写编码问题的个人习惯的一部分，以保持我的编程和解决问题的技能。<em class="me">第一个不重复字符</em>题是一个众所周知的初学计算机科学题。在这里我们将理解问题，编写表驱动测试，并使用Go开发两个解决方案。</p><p id="291b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来编码吧！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="2704" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">理解问题</h1><p id="e626" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">虽然标题相当自描述性，但最好通过首先浏览一些例子来理解编码问题。在我们的例子中，<em class="me">第一个非重复字符</em>问题是由一个英文字符串的输入和该字符串的第一个非重复字符的索引的输出来定义的。如果没有不重复的字符，那么函数应该返回<code class="fe nj nk nl nm b">-1</code>。</p><p id="18b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几个例子:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="cb7d" class="nr mn it nm b gy ns nt l nu nv">----- Example 1 -----<br/>Input:  abbcddeff<br/>Output: 0<br/>----- Example 2 -----<br/>Input:  abbNadNe<br/>Output: 4<br/>----- Example 3 -----<br/>Input:  ddd<br/>Output: -1</span></pre><p id="9d9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该总是试着自己解决这些例子，尤其是在编码面试中，以获得对问题的初步理解。这个问题只需举几个例子就能理解，所以现在让我们继续测试。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="7da9" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">Go中的表格驱动测试</h1><p id="134e" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我认为编码问题的下一个伟大的步骤是开发测试。在你开始写任何代码之前，它继续你完全理解问题的道路。此外，编写测试可以促进全面的软件开发技能，并鼓励您保持代码逻辑的灵活性和简洁性。</p><p id="24a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go有一个很好的方法来创建针对单个函数的多个测试，称为<em class="me">表驱动测试</em>。第一步是找出我们要测试的函数，在这种情况下，我们只需要让<code class="fe nj nk nl nm b">FirstNonRepeatingCharacter()</code>总是返回<code class="fe nj nk nl nm b">-1</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="2897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们可以添加我们的测试。Go中的表驱动测试是通过首先定义一个struct作为您的<code class="fe nj nk nl nm b">testCases</code>来构建的。在我的上一篇文章中，我只使用了一个包含<code class="fe nj nk nl nm b">name</code>字段的<code class="fe nj nk nl nm b">struct</code>。在这个例子中，我使用一个<code class="fe nj nk nl nm b">map</code>构建了<code class="fe nj nk nl nm b">testCases</code>，它将一个<code class="fe nj nk nl nm b">string</code>作为表示名称的键，对应于一个带有<code class="fe nj nk nl nm b">input</code>和<code class="fe nj nk nl nm b">expectedResult</code>字段的<code class="fe nj nk nl nm b">struct</code>。</p><p id="0752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如下所示，我们有6个不同字符串的测试用例，以及它们各自的预期结果。我鼓励你添加你自己的测试用例！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="fa97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在为每个测试定义了对象之后，我们开始一个<code class="fe nj nk nl nm b">for</code>循环(Go中唯一的循环机制),它使用<code class="fe nj nk nl nm b">range</code>关键字从每个<code class="fe nj nk nl nm b">testCases</code>条目中获取<code class="fe nj nk nl nm b">name</code>和<code class="fe nj nk nl nm b">struct</code>。您可能会注意到，我将该结构作为<code class="fe nj nk nl nm b">v</code>获取，然后在循环的第40行将其重新赋值给<code class="fe nj nk nl nm b">tc</code>。这与循环执行的Go有关。如果您没有在for循环的开始重新分配<code class="fe nj nk nl nm b">tc := v</code>，那么您实际上会得到一个与对象<code class="fe nj nk nl nm b">v</code>不一致的测试状态。我不确定这是为什么，所以如果你知道，请在下面留下评论！</p><p id="d811" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，一旦我们有了测试用例以及测试的名称，我们就可以通过嵌套调用<code class="fe nj nk nl nm b">t.Parallel()</code>来调用<code class="fe nj nk nl nm b">t.Run()</code>来并发运行我们的测试，从而提高性能。然后，我们可以通过用我们的测试用例输入<code class="fe nj nk nl nm b">tc.input</code>调用<code class="fe nj nk nl nm b">FirstNonRepeatingCharacter</code>来简单地获得<code class="fe nj nk nl nm b">actualResult</code>。然后使用<code class="fe nj nk nl nm b">tc.expectedResult</code>和<code class="fe nj nk nl nm b">actualResult</code>上的<code class="fe nj nk nl nm b">assert.Equal()</code>验证该值。在这一点上，唯一通过的测试是当我们期望<code class="fe nj nk nl nm b">-1</code>作为返回类型时，所以让我们修复它。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="f871" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">解决方案#1 — O(N)时间和O(1)空间</h1><p id="4794" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">像往常一样，让我们从一个蛮力解决方案开始。如果我们想找到在字符串中没有重复出现的字符的第一个索引，我们可以创建一个double for循环来检查字符串中每个字符的重复。</p><p id="8bdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一个for循环的开始，我们默认设置一个布尔值<code class="fe nj nk nl nm b">foundDuplicate</code>等于<code class="fe nj nk nl nm b">false</code>。然后第二个for循环将遍历字符串，看看我们当前的字符是否有重复的。我们通过检查<code class="fe nj nk nl nm b">str[i] == str[j]</code>来做到这一点，但也小心地检查我们没有将同一个字符本身与条件<code class="fe nj nk nl nm b">&amp;&amp; i != j</code>进行比较。</p><p id="a1f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设这些字符彼此相等，并且它们不在同一个索引上，那么这个字符有一个副本，我们设置<code class="fe nj nk nl nm b">foundDuplicate = true</code>。否则，如果我们在嵌套的for循环中没有找到当前字符的副本，那么<code class="fe nj nk nl nm b">foundDuplicate</code>将保持其默认值<code class="fe nj nk nl nm b">false</code>，第12行的条件将导致我们返回我们刚刚检查的唯一字符的索引值。</p><p id="0043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe nj nk nl nm b">foundDuplicate</code>在我们的双for循环中保持<code class="fe nj nk nl nm b">true</code>，那么就没有不重复的字符，我们将返回值<code class="fe nj nk nl nm b">-1</code>作为结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="c961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次运行我们的测试显示所有测试都通过了:</p><pre class="kj kk kl km gt nn nm no np aw nq bi"><span id="5c58" class="nr mn it nm b gy ns nt l nu nv">$ go test *.go<br/>ok      command-line-arguments  0.378s</span></pre><p id="95af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们嵌套了在整个字符串上循环的for循环，所以这个算法的时间复杂度是O(N)。但是我们不存储任何额外的数据类型，所以我们的空间复杂度将是常数O(1)。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="03f0" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">解决方案#2 — O(N)时间和O(1)空间</h1><p id="8fe4" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">优化时间到了。这个问题建立在一个基本原则上，那就是我们需要找到一个不会重复的角色。有没有一种方法可以让我们遍历字符串一次，并记录一个字符出现的次数，而不是一个双循环来迭代地检查每个字符的重复项？当然有，我们可以使用哈希映射来实现——这是一种非常有用的数据结构，对编程和编码采访都是如此。</p><p id="b5e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个解决方案中，我们将第一次遍历字符串，记录每个字符出现的次数。Go中的<code class="fe nj nk nl nm b">range</code>关键字首先返回一个索引，然后返回字符。我们不关心第一个循环的索引，所以用第6行的<code class="fe nj nk nl nm b">_</code>符号忽略它。然后，对于字符串<code class="fe nj nk nl nm b">str</code>中的每个字符<code class="fe nj nk nl nm b">char</code>，我们将键值对递增1。我特别喜欢Go不会对你大喊大叫，如果你还没有创建一个键，你可以简单地增加一个键值，如果它还没有被引用，它将默认为零。</p><p id="b199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一个for循环中，我们再次迭代字符串。这一次，我们从字符串<code class="fe nj nk nl nm b">str</code>中引用当前字符<code class="fe nj nk nl nm b">char</code>，并通过引用我们的哈希映射<code class="fe nj nk nl nm b">characterCounts</code>来查看它出现了多少次。如果字符出现的次数等于1，那么我们找到一个不重复的字符。因为我们想返回第一个不重复的字符，所以当这个条件满足时，我们将立即返回。</p><p id="65a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们从未找到键值为<code class="fe nj nk nl nm b">1</code>的字符，那么就没有唯一的字符，我们返回<code class="fe nj nk nl nm b">-1</code>作为结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="d5c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个算法中，我们在字符串上循环两次，导致O(2N)=O(N)的时间复杂度。我们现在存储一个散列映射，但是空间复杂度仍然是恒定的，因为我们最多只能存储字符中的字母表。即使字符是unicode的，它也是一个有限的集合。这将是你和面试官讨论的一个重要话题！</p><p id="d2d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，使用上面的解决方案也会导致我们所有的测试都通过。干得好！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="da69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢阅读这篇文章，并能够学到一些新的东西。如果您发现任何部分特别有用，或者想要任何其他编码问题的教程，我鼓励您在下面留下评论！感谢阅读。</p></div></div>    
</body>
</html>