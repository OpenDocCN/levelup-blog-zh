# 理解“关注点分离”

> 原文：<https://levelup.gitconnected.com/understanding-separation-of-concerns-47f987f040d3>

# 有效的代码是不够的。

鲁布·戈德堡的机器“工作了”。它们效率低、易碎、难以制造和维护。能正常工作的代码是一个很低的门槛。

![](img/11ac6fbff9b0f16eeb4728885cd359e8.png)

鲁贝·戈德堡机器

人们没有认识到的是，写代码非常像写一篇文章或一本书。尽管我认为写论文在“现实世界”中对我毫无用处，但我后来在大学里学到的是，论文写作不在于字数统计和遵循评分标准。

> 好的写作其实是关于清晰的思想交流。

一篇好文章的大部分特性可以转化为好的源代码。

*   好主意
*   好读(风格)
*   良好的想法组织(逻辑流程)

“关注点分离”是我们如何使代码组织良好的关键部分。然而，我将“关注点分离”放在引号中，因为这个术语在一般的对话中被误解了，或者至少理解得很差。就像遵循经验法则而不理解我们为什么有经验法则一样，大多数人都在努力评估如何做好它。

在本文中，我们将首先回顾关注点分离的实际含义。然后，我们将讨论分离如何有利于**组织**，这最终给我们提供了良好分离的原则。

# **我们关注点分离的真正含义是什么？**

虽然我们已经有了“关注点分离”这个术语，但是还有很多东西需要解开。这是因为关注点分离本身并没有好处。例如，我可以将 CSS 的每一行写在不同文件夹的不同文件中。一切都是分开的。但是任何写这种代码的人都喜欢看到世界被烧毁。

如前所述，关注点分离是编写有组织的代码的一部分:代码以可预测和易于理解的方式一部分一部分地解释应用程序的每个部分。

在看组织良好的代码是什么样子之前，让我们继续我们的写作类比，想想我们如何写组织良好的书。一本书传达复杂的思想，显然不会是一个单一的巨大段落。它需要分离，把它分成更容易管理的部分。

1.  书籍章节(高级)
2.  部分
3.  段落
4.  句子(低级)

每一层都讲述了一个故事。为了保持连贯性，这本书需要在各个层面都做到这一点。做得好的话，这本书会一句接一句，一章接一章。虽然把它分成正确的部分是很重要的一部分，但是我们必须明白组织还有更多。

不能孤立地考虑“关注点分离”的原因是，为了有条理，更重要的是你如何将想法组合成部分和流程。即使你的每个段落都很棒，很有意义，但如果你从一个点跳到另一个点，你会发现一片混乱。

那么如何创造有组织的想法呢？有几种方法:

*   从高层次开始，逐步实施
*   画出依赖树，找出创建流程和分组想法的最佳方式。
*   使用常见的模式来建模您的问题，清楚地说明您的问题如何适应该模式

最终，你的想法的最佳排序或分组很少出现在第一次。为了大规模地编写组织良好的代码，你需要写多份草稿(至少两份)！你通常会写下表达想法所需的所有元素，然后你会把它们放在一起，形成一个逻辑流程。

组织良好的代码具有以下特性:

*   在多个层面上可以理解。
*   部分大小适当
*   基于更大的想法和流程进行分组

那么大多数人说的“关注点分离”是什么意思呢？我们通常真正想要谈论的是关注点的组织(分离和分组关注点)。

# 关注点分离是如何工作的？

关注点分离的“分离”部分是通过中断实现的。休息可以通过几种方式实现。为了增加强度，你可以分解代码:分解成一个代码块(像一个段落)，分解成一个函数，分解成另一个文件，分解成另一个文件夹，分解成另一个模块，分解成一个外部库，等等。

下面是一个使用分段符来分解函数的例子。

在这个例子中，每个代码段都有一个单独的关注点，在一个更大的目标中实现一个子任务。

休息有三个好处:

*   将代码分组为易于理解的步骤(每组是一个步骤)
*   创建路标，使代码更容易找到(和遵循)
*   混淆不必要的详细代码

让我们看看不同类型的休息是如何实现这些好处的。

**代码段是**最小的断行类型。像一个真正的段落一样，它应该代表一个想法或一个过程的“步骤”。每当你意识到某项活动时，你可以把它分成一小段。

段落通过在子步骤之间设置清晰的界限打破了单独的关注点。通过总结每一段，你可以了解更大的群体是如何运作的。这有助于你在恰当的水平上讲故事。

这样做是为了***processExpression***函数你明白你:

*   获取第一因子
*   获取比较器
*   获取第二个因子
*   使用所有三个部分进行评估。

**路标:**就像这些小的摘要让你一眼就能理解一个过程一样，路标让你更容易找到你关心的代码。在这个例子中，我们在段落前面放了一个注释。我们可以使用许多其他的标志方式，比如函数、文件和文件夹名称。

类似地，**混淆代码**可以帮助代码更容易理解，因为它让我们在我们关心的深度水平上阅读故事。如果看上面的代码，可以看到它调用了****this . evaluate expression(factor one，comparitor，factorTwo)*** 。***evaluate expression***是一个必须根据输入类型(数字、字符串、布尔值等)处理许多事情的函数。*

*在故事的这个层面，(采取什么步骤)这比我们关心的更有深度。我不需要考虑这是如何发生的，只需要知道它确实发生了。*

***软中断 vs 硬中断？***

*到目前为止，我描述的两个中断是软中断。软中断是文件内的中断，而硬中断是将代码移到一个单独的文件中。这意味着您必须浏览文件系统/甚至外部库才能找到它。软中断和大中断之间的主要权衡是找到和理解您关心的代码的时间。*

*如果你知道代码在文件中的位置，在文件中搜索通常需要 2-5 秒，这听起来很棒。当你在编写代码时，一切都在你的“触手可及”的范围内是很好的。当文件变大时，麻烦就开始了。随着文件变得越来越大，你也需要花更多的时间来滚动和重新定位。如果新来了一个人，或者你已经有一段时间没有接触代码了，那么一个大文件需要很长时间才能理解。这是一个“小”但不断增加的负担。*

*当你引入一个硬中断时，你把代码变成了更小的可理解的片段。这意味着，如果你有一个好的分类/命名/放置文件的系统，找到你关心的代码就更容易了。硬中断的代价是，它意味着你必须在文件之间跳转。跳跃可能有多重成本。跳到一个已知的文件需要大约 2-10 秒(几秒钟找到文件，然后几秒钟找到你在文件中的位置)。如果您的代码编辑器中有两三列，这种情况可以得到缓解，因此切换成本会更低。然而，如果在处理单个特性时有太多的文件需要处理，那么再次浏览代码会变得更加费力。*

*例如，假设您有 3 级深度组件。一个有菜单项和工具栏的菜单。数据归菜单组件所有，组件的所有事件都会影响该父级数据。现在每个文件都有了自己的外部 CSS 文件。这是一个非常常见的复杂程度，但需要 6 个窗口的代码，不需要主动导航它。因此，当决定进行硬中断时，尽量确保它们之间的联系不要太紧密(如果你正在处理一个，你需要打开另一个)。*

*硬中断的另一个风险是很难找到单个特性的相关代码。例如，实现登录状态逻辑可以很容易地在不同文件结构的 6-7 个文件之间进行分割。在未知文件夹中的未知文件中查找未知代码可能需要几分钟到几天的时间！*

*减轻这种风险的方法是通过惯例和距离。约定意味着有一个通用的文件夹结构，告诉您特定类型的文件放在哪里(对于较大的应用程序来说，这可能变得不实用)。例如，如果你的所有组件都在一个组件文件夹中，你就知道你要找的组件肯定在那里。只是不清楚在哪里或者和什么有关。距离意味着你试图把相关的东西放在一起(在同一个文件夹里)。*

*这并不是说硬突破不好。你只需要权衡成本和收益，小心翼翼地放弃。*

# *关注点分组*

*不仅仅是分离关注点，可能更有用的是随后的事情:关注点的分组。当你简单地把事情分开时，你的代码在技术上变得更加难以理解。代码有变成意大利面条代码的趋势，这使得推理变得困难。因此，您必须将代码分成正确大小的组，或者将较小的部分组合在一起。*

*当涉及到关注点的分组时，您必须考虑两个主要因素。第一是群体规模，第二是群体离散性。团队规模决定了在该环境下工作的难度，而团队离散性决定了你跳出该环境的频率。*

***组大小调整** 组大小调整相当简单。*

*   *代码段:1-6 行*
*   *功能:推荐 5-30 行。最大:~100。*
*   *文件:建议值:100–200。最大值:~1000 行*
*   *文件夹:7-8 个子文件夹，大约 7-8 个文件。(这一大小规则的明显例外是文件夹，如基本块组件(如按钮、标题、图标等)。在这里，您可以拥有二三十个组件，而不会显得笨重。)*

*在这种规模下，代码非常容易跟踪和管理。你可以把精力集中在理解事物上，而不是试图寻找事物。*

***离散组** 离散性是指一段代码有多独立/独特。离散代码不需要您在其他上下文中进行更改或引入。这提供了几个好处:*

1.  *它几乎不需要考虑其他问题是如何解决的/系统是如何实现的。当你在系统的那个部分工作时，这就是你需要考虑的全部。*
2.  *将共同的子目标紧密结合。*
3.  *帮助您了解并确定何时进行重用设计。如果你在多个地方写同样的代码，那段逻辑就不是离散的，应该被分离出来*

*创建离散组的最佳方式是考虑您将在哪个级别使用它。这是一个明显的目标不分散的例子。布局样式、印刷样式和按钮的颜色并不是非常分散的目标。如果一个按钮的设计发生了变化，你可能需要为每一个目标而努力。把它们分开会很痛苦，因为你必须从一个文件跳到另一个文件，仅仅是为了操作这个小按钮。*

*如前所述，通常在群体规模和离散性之间有一个权衡。一个目标可能是离散的，但结果是一个巨大的文件。为了抵消这一点，你可能会将目标分解成更小但可能更分散的目标。在实践中，你很少会有一个大目标不能被分解成更合适大小的离散目标。*

# *关注点组织摘要*

*组织关注点分为两个任务:分离和分组关注点。组织关注点的目的是让你理解不同细节层次的代码。*

*分离是通过中断完成的:*

*   *代码段落*
*   *函数/类/结构等*
*   *单独的文件*
*   *单独的文件夹*
*   *外部库*

*分离有三个主要好处*

*   *将代码分组为易于理解的步骤(每组是一个步骤)*
*   *创建路标，使代码更容易找到(和遵循)*
*   *混淆不必要的详细代码*

*分组设定了你一次可能要处理的范围。有两个主要考虑因素:*

*   *分组规模*
*   *群体离散性*

*软休息和硬休息用于管理组规模。大群体很难驾驭。硬刹车可能很难操纵。*

*最终，改善关注点组织的最好方法是重构！下次你写代码的时候，考虑一下这些问题！*