<html>
<head>
<title>Monitoring Socket.IO Uptime</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">监控插座。IO正常运行时间</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/monitoring-socket-io-uptime-40006289d158?source=collection_archive---------14-----------------------#2020-07-08">https://levelup.gitconnected.com/monitoring-socket-io-uptime-40006289d158?source=collection_archive---------14-----------------------#2020-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/17d8886af243f82fab194bc906cda69f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wEOZ5OIrXox3rK0lt_D55A.png"/></div></div></figure><p id="c594" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">监控套接字的健康和可用性。IO APIs可能很复杂。随着<a class="ae kw" href="https://asserted.io" rel="noopener ugc nofollow" target="_blank">断言</a>，你可以使用套接字编写<a class="ae kw" href="https://asserted.io/features/uptime-as-code" rel="noopener ugc nofollow" target="_blank">复杂的正常运行时间测试</a>。IO客户端库。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><blockquote class="le lf lg"><p id="db29" class="jy jz lh ka b kb kc kd ke kf kg kh ki li kk kl km lj ko kp kq lk ks kt ku kv ij bi translated"><em class="iq">上的例子</em> <a class="ae kw" href="https://github.com/assertedio/socketio-uptime" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> GitHub </em> </a></p></blockquote><p id="d4f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">插座。IO是一个利用websockets和标准HTTP来实现实时双向通信的库。根据您的使用情况，插座。IO通常比原始websockets实现得更快，更不容易出错，因为它支持广播和协议后备等现成的东西。</p><p id="0ef1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将要使用的示例是这里的<a class="ae kw" href="https://github.com/socketio/socket.io/tree/master/examples/chat" rel="noopener ugc nofollow" target="_blank">提供的演示的修改版本</a>。这是一个非常简单的使用Socket.IO的聊天应用程序的例子。</p><h1 id="622e" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">示例服务器</h1><p id="8bfd" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">断言测试将运行的服务器包含两个主要文件。</p><p id="b1c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先是插座。处理新连接并响应客户端发出的消息的IO逻辑。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f9ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这允许用户加入和断开连接，以及向其他用户广播消息。</p><p id="c318" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个文件是套接字所在的位置。IO逻辑连接到服务器。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="5107" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">常规配置</h1><p id="c2d4" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">这次<strong class="ka ir"> routine.json </strong>略有不同，只是它使用了<a class="ae kw" href="https://docs.asserted.io/reference/included-dependencies#custom-dependencies" rel="noopener ugc nofollow" target="_blank">自定义依赖项</a>。付费计划中提供了自定义依赖项，这里我们使用该选项来包含套接字。我们测试中的IO客户端库。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="d269" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">例程包. json</h1><p id="516a" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">例程的<strong class="ka ir"> package.json </strong>(在。asserted directory)在这种情况下与缺省值略有不同。除了添加<strong class="ka ir"> socket.io-client </strong>之外，我们还可以删除所有其他不需要的依赖项。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="e03c" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">持续集成测试</h1><p id="adc3" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在本例中，我们创建了两个不同的客户端。一个作为新用户加入聊天并发送消息，另一个客户端观察新用户的加入和消息。</p><p id="1985" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为每个测试用例重新创建新的用户客户端。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="977b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">before和after挂钩确保事情被适当地清理，如果这在生产或登台中连续运行，这是很重要的。</p><p id="8485" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试本身检查当新用户加入时，以及当他们发送消息时，适当的事件被发送到适当的客户机。</p><figure class="mo mp mq mr gt jr"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c94e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过类似的测试，您可以持续监控生产中的SocketIO APIs，并准确跟踪正常运行时间。</p><h1 id="bcf1" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">后续步骤</h1><p id="c6ce" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">虽然这里显示的示例<a class="ae kw" href="https://github.com/assertedio/socketio-uptime" rel="noopener ugc nofollow" target="_blank">可以在没有帐户的情况下在本地克隆和运行，但是如果您想要创建自己的断言例程来在生产中集成测试您的API，您将需要执行一些额外的步骤。</a></p><ol class=""><li id="7b7c" class="mu mv iq ka b kb kc kf kg kj mw kn mx kr my kv mz na nb nc bi translated">创建一个<a class="ae kw" href="https://app.asserted.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">断言账户</strong> </a>。很洒脱。</li><li id="eeb6" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">完成2分钟的入职培训，确保您的环境准备就绪。也可以在 这里引用<a class="ae kw" href="https://docs.asserted.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">的单据。</strong></a></li><li id="270f" class="mu mv iq ka b kb nd kf ne kj nf kn ng kr nh kv mz na nb nc bi translated">开始在prod中编写和运行测试！</li></ol></div></div>    
</body>
</html>