# 我释放了蒸汽。

> 原文：<https://levelup.gitconnected.com/i-released-vaporware-c1850e6a9c5d>

![](img/abf96845764e8baa3f7368f165c49796.png)

Boitumelo Phetla 在 [Unsplash](https://unsplash.com/photos/viS6-ja0dCw) 拍摄的照片

Vaporware 是已经做了广告但还不能使用的软件或硬件。显然，发布 vaporware 并不是一件值得骄傲的事情。然而我却意外地做到了。你可以从我的错误中吸取教训，以便不犯同样的错误。所以这是它是如何发生的，我是如何解决的。

2022 年 3 月 1 日，我开始创建 [Disgo](https://github.com/switchupcb/disgo) ，一个设计灵活、高性能、安全和线程安全的 Discord API 包装器。Disgo 的目标是提供 Discord API 中的每一个特性，以及可选的速率限制、结构化日志、分片管理和缓存……然而，当时有一个问题:*我还没有提交一行代码。相反，我创建了一个自述文件，概述了我对 Disgo 的愿景。我想到了什么？*

# 设计文件

## 要求

为了使用大多数 API 包装器，您必须了解三件事情。

1.  编程语言
2.  消费者的 API(库)
3.  生产者的 API(不和谐)

这是因为大多数程序员开始使用函数来创建库:比如发送消息的函数是`ChannelMessage(…)`，而响应交互的函数是`InteractionRespond(…)`。每个函数都有自己的参数，这需要您阅读库的文档来了解如何完成每个任务。

这是对时间的巨大浪费和不必要的复杂。

Disgo 使用单个函数发送 HTTP 请求*(没有类型断言或泛型)*。

```
Send(*Client)
```

**就这样。**容易记忆，更容易使用。这个函数总是维护一个参数:发送请求的客户端。但是，您仍然需要一种方法来指定实际发送的是什么数据。如果不使用函数来做这件事，有什么替代方法？结构。

```
// Create a Create Global Application Command request.
request := disgo.CreateGlobalApplicationCommand{
  Name: "main",
  Description: "A basic command.",
  ...
}

// Send the request.
command, err := request.Send(bot)
```

每个结构维护一个人发送有效请求所需的所有数据。这包括 URL 查询字符串参数、JSON 字段和文件。这样，开发人员只需了解两件事就可以使用 Disgo。

1.  如何在 Go 中创建结构？
2.  如何使用 Discord API？

不再浪费时间学习 API 消费者的实现细节。**我是怎么做到的？在 Disgo `v0.10.0`发布之前，我没有。这就是问题所在:整个图书馆只是一个正在进行的设计。这导致了很久以后的一次事故。**

## 事件

其他 Go 库使用类型断言或泛型将来自 Discord 的 JSON 事件数据翻译成开发人员在运行时可以引用的实际 Go 对象。Disgo 没有。结果就快多了。当然，这只是在 Disgo `v0.10.0`发布之前理论上的真实情况。这个特性的实现将在本文后面讨论。

*Disgo 还维护自动意图计算；这是其他图书馆没有的功能。*

## 贮藏

决定使用可选缓存背后的文档直到后来才发布: [#39](https://github.com/switchupcb/disgo/issues/39) 。不管怎样，这个决定是在设计 Disgo 时做出的。总之，使用内置于 HTTP 库中的缓存会增加开销，往好了说是复杂，往坏了说是不正确。

## 更新

Discord API 已经发布了 6 年**,然而同样的 API 仍然以一种有些不稳定的方式持续着许多变化。具体来说，Discord 实际上并没有为其 API 提供文档。相反，社区用于确定 API 的当前状态并记录下来。此外，在历史上，人们只考虑公司的特性，当一个特性执行不力时，就会引起[争议](https://gist.github.com/Rapptz/4a2f62751b9600a31a0d3c78100287f1)。**

**Discord 已经被提示需要一个**机器可读的 API** 无数次都没有用。使得频繁地对 Discord API 进行改变，但是没有将这些改变应用于 API 消费者的有效策略。出于这些原因，Disgo 需要能够保持较高的开发速度*(在其最初创建期间和之后)。***

**静态代码分析用于维护没有已知安全问题的格式化代码。覆盖大部分 Discord API 的广泛集成测试也在计划之中。此外，Go 有一个数据竞争检测器，它允许我们检测并消除任何潜在的数据竞争或死锁问题。以便 Disgo 提供可靠的数据竞争保护，而不牺牲并发运行代码的能力。**

***最重要的是实现功能完善的目标。有几个图书馆做过，但是都没有用 Go。***

# **实施设计**

**Go 语言使用 JSON 标签将字段解组和封送到它的结构中。然而，这意味着区分“空”和“null”是很重要的。当时的主要 Go API 包装器——DiscordGo——在开发时添加了这些标签，导致 Discord API 的一些特性在没有 fork 的情况下无法实现。为了解决这个问题，我们为名为 [Dasgo](https://github.com/switchupcb/dasgo) 的 Discord API 创建了一个 Go API 类型库。这个库是按照规范构建的，并且是**而不是**特定于 Disgo 的实现；这意味着其他 Go API 包装器可以将它用于它们的类型。**

**当 Dasgo 被很多人使用的时候，Go Discord API 包装器的维护者的工作量急剧减少。这是因为对 Discord API 数据结构的新更改只需要对 Dasgo 提供的底层 Go 类型进行更改。Go 本身提供了散列版本控制，允许库指定要导入的特定版本或分支。使得人们可以维护多个版本化端点以及不和谐机器人可能使用的每个 API 版本。**

## **要求**

**设计文档指定了 Disgo API 如何处理 HTTP 请求，但是我实际上是如何实现它的呢？提醒一下，我并没有打算使用类型断言或泛型:在 Go 中，两者都有轻微的性能影响。因此，我不能在`Send(*Client)`函数中使用结构作为参数。相反，将使用接收器功能。**

```
func (r *CreateGlobalApplicationCommand) Send(bot *Client) (*ApplicationCommand, error) {
  ...
}
```

**不过，有一个问题。必须为每个请求创建一个这样的接收函数*。然而，Discord API 维护着 **176 个端点**(不包括构成路线的变化)。我们要做什么？*输入 [Copygen](https://github.com/switchupcb/copygen) ，这是一个基于类型的代码生成器，我创建它是为了创建类型到类型的复制功能。使用 Copygen，我能够使用我们在 Dasgo 中定义的类型为每个请求生成一个`Send(*Client)`函数。**

***最精彩的部分？更新就像运行一个命令一样简单。***

**在创建 Disgo 时，我还发现当前的速率限制文档具有误导性。在另一篇文章中会有更多的介绍。**

## **事件**

**Discord 网关是一个 TCP WebSocket 连接，它在有效负载中发送 JSON 或二进制数据包。这在 JavaScript 中很容易使用，因为这种语言是非类型化和解释的。相比之下，Go 是静态类型和编译的。因此，其他 Go API 包装器通过类型断言传入负载来实现事件处理。避免类型断言的唯一方法是将有效载荷直接解组到一个对象 *(struct)* 中。然而，这不是一个简单的任务，因为解组必须同时进行*(来自 WebSocket 连接)*，以免阻塞其他事件的处理。**

**更不用说，我们需要为开发者提供一种处理事件的方式。**

**在 Disgo 中，使用`Handle`和`Remove`函数添加或删除事件处理程序。然而，这又是一个代表数百个事件的单一函数。没有使用类型断言，我们是如何做到的？由于在没有事先说明的情况下，您无法确定正在处理的事件，因此需要做出妥协。具体来说，`Handle`函数不能接受一个单独的事件作为参数，因为这需要使用反射来确定要解组到哪个事件对象。**

```
// Add an event handler to the bot.
bot.Handle(disgo.FlagGatewayEventNameInteractionCreate, func(i *disgo.InteractionCreate) {
  log.Printf("main called by %s", i.User.Username)
})
```

**相反，用户传递一个字符串*(由 Dasgo 指定)*，它告诉我们哪个事件将被解组。缺点是，如果将不匹配的字符串和事件传递给函数，可能会涉及用户(开发人员)错误。因此，鼓励开发人员处理这些函数的错误，因为错误虽然不太可能发生，但还是会发生。从这一点来看，创建一个 goroutine(为开发人员)来解组事件有效负载，并为每个处理程序创建一个 goroutine 是很简单的。**

**Copygen *用于为事件处理生成所有必要的代码。***

**网关意图很难处理；尤其是在当前的 API 包装器中。每次你想处理一个新事件，你必须确保它不需要一个意图。当它出现时，您必须在 API 包装器指定的任何时间点将该意图添加到您的 bot 中。那是大量的工作。相反，为了追求无反射事件处理，Disgo 能够自动计算开发人员需要的意图。这使得开发人员可以更多地关注机器人的功能，而不是技术细节。**

# **迪斯戈的释放**

**在完成 Disgo 的过程中出现了一些复杂情况，导致它以未完成的状态发布。具体来说，Disgo `v0.10.0`支持使用 Discord API 提供的每个请求和事件。但是，诸如分片、缓存管理和全面集成测试等功能并没有实现。相比之下，Disgo 的愿景致力于主分支。这样任何人都可以阅读它，并在不知不觉中认为它的承诺已经实现。没有考虑它的解释，我做了一个`v0.10.0`测试版。**

****经过所有这些努力，我们得到了什么？****

## **电子邮件**

> **“亲爱的 SwitchUpCB:**
> 
> **你的图书馆装饰是一件艺术品…如果它是他妈的作品的话！！！该死的。我浪费了至少三分钟来进口这些垃圾！两个以上的设置示例…才意识到这实际上并没有完成？？？你他妈的 CK 是怎么了！该死的白痴。也许在事情完成之前不要发表。啊？啊？！那现在怎么办？我要怎么做才能使用这个该死的工具…什么，你是同性恋吗？你知道吗？让我吸你的蛋。让我舔你的小弟弟。让大黄蜂 7 吸你的蛋吧！让大黄蜂 7 吸你的 D*CK N****。让。大黄蜂 7。烂透了。你的。CK！**
> 
> **谢谢，**
> 
> **大黄蜂 7”**

***是啊…灵感来自*[*Filnobep*](https://youtu.be/l2cDkl_JRTo)*…而且完全是假的。***

**显然，没有什么坏事发生。有一个用户最终发现了一个阻止人们使用应用程序命令的主要错误。我提出补偿用户的时间，但他们并不生气。事实上，已经有一份声明指出了`v0.10.0`的局限性。也许，其他库应该在陷入向后兼容性承诺之前创建设计文档。其结果将是一个像迪斯戈一样伟大的图书馆。**

# **使用 Disgo**

**在 Go 中创建一个不和谐 Bot:[Disgo](https://github.com/switchupcb/disgo/releases/tag/v0.10.1)发布于**2022 年 11 月 17 日**。**