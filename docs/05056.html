<html>
<head>
<title>JavaScript Basics Series: Understanding Hoisting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础系列:理解提升</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-basics-understanding-hoisting-caa43ab2d27b?source=collection_archive---------20-----------------------#2020-07-31">https://levelup.gitconnected.com/javascript-basics-understanding-hoisting-caa43ab2d27b?source=collection_archive---------20-----------------------#2020-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5564" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用简单明了的例子解释吊装！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dbf0912da3b49fcc94681418a60bba90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuoh0FaU8c-V9nsnKdBftw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">变量和函数提升就像起重机提升的板条箱。</figcaption></figure><blockquote class="ky kz la"><p id="daf4" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">JavaScript基础是一个探索每个前端软件工程师都应该理解的一些核心概念的系列。这些概念不仅对工作面试的成功很重要，对开发人员的职业生涯也很重要。</p></blockquote><p id="bdbe" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi mb translated">JavaScript中最重要和最基本的概念之一是提升的概念。提升不仅让我们深入了解JavaScript如何运行，还让我们了解它的引擎如何解释和执行代码。让我们开始吧！</p><blockquote class="ky kz la"><p id="2ed2" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le iu">提升是一种允许在声明变量之前使用变量的机制！</strong></p></blockquote><p id="af93" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">提升是在执行之前，将变量和函数移动到它们各自的全局或局部作用域的顶部的过程。这种机制允许在它们作用域内的任何地方声明它们，并且仍然按顺序执行。简单来说，提升意味着<em class="ld">变量和函数可以在你的代码中声明</em>之前使用。</p><h2 id="b55e" class="mk ml it bd mm mn mo dn mp mq mr dp ms ly mt mu mv lz mw mx my ma mz na nb nc bi translated">提升变量</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d08a" class="mk ml it ne b gy ni nj l nk nl">hoistMe = 4; // &lt;-- Assigned here although declared below</span><span id="4a16" class="mk ml it ne b gy nm nj l nk nl">var sRoot = Math.sqrt(hoistMe)</span><span id="72ad" class="mk ml it ne b gy nm nj l nk nl">console.log(sRoot)</span><span id="9b11" class="mk ml it ne b gy nm nj l nk nl">var hoistMe; // &lt;-- Declared after hoistMe is used</span></pre><p id="bf7b" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">结果:<code class="fe nn no np ne b">2</code></p><p id="0484" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">从上面可以看到，变量<em class="ld"> hoistMe </em>在声明之前就被赋值甚至使用了，这与大多数语言中发现的变量声明顺序有很大不同。这是可能的，因为JS引擎<em class="ld">提升了</em>变量，即在代码中使用之前，通过将变量提升到顶层范围来解释变量。</p><blockquote class="ky kz la"><p id="2cc0" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le iu">当你试图访问一个未声明的变量时，会出现</strong> <code class="fe nn no np ne b"><strong class="le iu"><em class="it">ReferenceError</em></strong></code> <strong class="le iu">。</strong></p></blockquote><p id="7586" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">然而，也有例外:<code class="fe nn no np ne b">let</code>和<code class="fe nn no np ne b">const</code>。ES6引入了这两个保留字来取消<code class="fe nn no np ne b">var</code>的使用。需要注意的是，提升并不适用于这两个关键字。如果我们尝试用上面的代码来代替，我们会得到下面的错误:</p><p id="faff" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">用<code class="fe nn no np ne b">let</code>:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2c6a" class="mk ml it ne b gy ni nj l nk nl">ReferenceError: Cannot access 'hoistMe' before initialization</span></pre><p id="5c72" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">带<code class="fe nn no np ne b">const</code>:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="8eed" class="mk ml it ne b gy ni nj l nk nl">const hoistMe; // &lt;-- Declared after hoistMe is used</span></pre><p id="dcb8" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">当你试图访问一个未声明的变量时，一个<code class="fe nn no np ne b">ReferenceError</code>发生<em class="ld">。于是，下面抛出一个<code class="fe nn no np ne b">ReferenceError</code>:</em></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="4804" class="mk ml it ne b gy ni nj l nk nl">v = 4</span><span id="1862" class="mk ml it ne b gy nm nj l nk nl">let v;</span></pre><p id="a767" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated"><code class="fe nn no np ne b">ReferenceError: Cannot access ‘v’ before initialization</code></p><blockquote class="ky kz la"><p id="e67c" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le iu"> <em class="it"> JavaScript只吊声明不初始化！</em> </strong></p></blockquote><p id="786a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">需要指出的另一点是提升只适用于声明，不适用于初始化。例如:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="1d55" class="mk ml it ne b gy ni nj l nk nl">var hoistMe = 2; //Initialization</span><span id="9b86" class="mk ml it ne b gy nm nj l nk nl">console.log (hoistMe * hoistMe2);</span><span id="3fd5" class="mk ml it ne b gy nm nj l nk nl">var hoistMe2 = 2;  //<strong class="ne iu">Doesn't get hoisted because of initialization</strong></span></pre><p id="e2d4" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">结果:<code class="fe nn no np ne b">NaN</code></p><p id="06af" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">输出是NaN，因为<em class="ld"> hoistMe2 </em>是<strong class="le iu">未定义的</strong>，然而我们正在一个数(2)和一个未定义的变量之间执行运算(乘法、除法等)。为什么没有定义？<em class="ld">JavaScript中任何未声明的变量默认被赋予</em> <code class="fe nn no np ne b">undefined</code>类型。假设hoistMe2由于初始化而没有被提升，当您将它注销到控制台时，它没有任何值，因为它还没有被声明。只有当解释器到达最后一行时，它才读取声明和赋值，即初始化语句。</p><p id="cbad" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated"><strong class="le iu">提升功能</strong></p><p id="d782" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">JavaScript中的函数也是如此。可以在同一范围内调用它们之前定义它们。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="1aee" class="mk ml it ne b gy ni nj l nk nl">let str = "This string"</span><span id="e47a" class="mk ml it ne b gy nm nj l nk nl">console.log(hoistMe())</span><span id="fafe" class="mk ml it ne b gy nm nj l nk nl">function hoistMe(){ // &lt;-- Defined AFTER being called</span><span id="54fe" class="mk ml it ne b gy nm nj l nk nl">     return str + " will be hoisted!"</span><span id="976c" class="mk ml it ne b gy nm nj l nk nl">}</span></pre><p id="03b7" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">结果:<code class="fe nn no np ne b">This string will be hoisted!</code></p><p id="db6c" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">由于提升，虽然函数在定义之前被调用，但是JavaScript引擎不会抛出错误，因为函数已经被解释并提升(提升)到顶部范围，并且在执行之前可以使用。</p><h2 id="7a6f" class="mk ml it bd mm mn mo dn mp mq mr dp ms ly mt mu mv lz mw mx my ma mz na nb nc bi translated">恶作剧问题</h2><p id="fc3c" class="pw-post-body-paragraph lb lc it le b lf nq ju lh li nr jx lk ly ns ln lo lz nt lr ls ma nu lv lw lx im bi translated"><strong class="le iu">以下代码的输出是什么？</strong></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="abfd" class="mk ml it ne b gy ni nj l nk nl">var num = 1;</span><span id="df0f" class="mk ml it ne b gy nm nj l nk nl">function f(){ <br/>    console.log("The number is: " + num);<br/>    var num = 2;<br/>}</span></pre><p id="5f91" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">你可能认为结果是2，或者1，但事实上是<code class="fe nn no np ne b">undefined</code>。原因是，使用var时，只有声明会被提升，从而产生一个值尚不存在的变量。上面的代码类似于:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="f25d" class="mk ml it ne b gy ni nj l nk nl">var num = 1;</span><span id="dcb1" class="mk ml it ne b gy nm nj l nk nl">function f(){<br/>    var num;<br/>    console.log("The number is: " + num);<br/>    num = 2;<br/>}</span></pre><p id="5ec8" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">输出:<code class="fe nn no np ne b">The number is: undefined</code></p><p id="1640" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">根据我们所学，如果我们用<code class="fe nn no np ne b">let</code>而不是<code class="fe nn no np ne b">var</code>会发生什么？</p><p id="5805" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated"><strong class="le iu">外卖</strong></p><p id="d25f" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">我们可以将上述总结如下:</p><ul class=""><li id="b20c" class="nv nw it le b lf lg li lj ly nx lz ny ma nz lx oa ob oc od bi translated">提升是在声明或定义变量或函数之前使用它。</li><li id="f192" class="nv nw it le b lf oe li of ly og lz oh ma oi lx oa ob oc od bi translated">提升只适用于声明，不适用于初始化。</li><li id="5fb8" class="nv nw it le b lf oe li of ly og lz oh ma oi lx oa ob oc od bi translated"><code class="fe nn no np ne b">Let</code>和<code class="fe nn no np ne b">const</code>不能吊装(ES6+)。</li><li id="89d9" class="nv nw it le b lf oe li of ly og lz oh ma oi lx oa ob oc od bi translated">如上所述，使用<code class="fe nn no np ne b">let</code>时会出现参考误差。</li><li id="7605" class="nv nw it le b lf oe li of ly og lz oh ma oi lx oa ob oc od bi translated">当<strong class="le iu">访问</strong>未声明的变量时发生引用错误。</li><li id="4e4b" class="nv nw it le b lf oe li of ly og lz oh ma oi lx oa ob oc od bi translated">在JavaScript中，未声明的变量默认被赋予类型<code class="fe nn no np ne b">undefined</code>。</li></ul><p id="8f06" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">尽管JavaScript允许变量提升，但使用<code class="fe nn no np ne b">let</code>和<code class="fe nn no np ne b">const</code>而不是<code class="fe nn no np ne b">var</code>被认为是最佳实践，以避免错误，并养成在使用变量之前声明变量的习惯。同样的礼仪也适用于功能。</p><p id="b833" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk ly lm ln lo lz lq lr ls ma lu lv lw lx im bi translated">编码快乐！:)</p></div></div>    
</body>
</html>