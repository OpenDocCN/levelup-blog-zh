<html>
<head>
<title>Dependency Injection In Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的依赖注入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dependency-injection-in-swift-bc16d66b038b?source=collection_archive---------7-----------------------#2020-06-09">https://levelup.gitconnected.com/dependency-injection-in-swift-bc16d66b038b?source=collection_archive---------7-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0f54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将谈谈我在日常工作中使用DI的方式。在我继续之前:我应该强调，如果我把事情搞砸了，那是我的错，不是我的团队。</p><h1 id="0c48" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">摘要</h1><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="ec67" class="lv kp it lr b gy lw lx l ly lz"><strong class="lr iu">1. Why dependency injection<br/></strong>  1.1. Reduce software complexity</span><span id="de04" class="lv kp it lr b gy ma lx l ly lz"><strong class="lr iu">2. Dependency injection</strong><br/>  2.1. Type of injection<br/>  2.2. The way i use Dependency Injection<br/>  2.3. Reduce compilation time</span><span id="bc33" class="lv kp it lr b gy ma lx l ly lz"><strong class="lr iu">3. TL;DR</strong></span></pre><h1 id="94e1" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">为什么要依赖注入？</h1><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div class="ab gu cl mc"><img src="../Images/06ce0bea667ebf801d74a2511656b111.png" data-original-src="https://miro.medium.com/v2/format:webp/0*crAff3IOSqCQR-wd.jpeg"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">来源:Adobe Stock</figcaption></figure><p id="85dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">降低软件复杂性的最重要的技术之一是设计系统，这样开发者只需要面对整体复杂性的一小部分，也就是<strong class="js iu">模块化设计</strong>。</p><p id="1912" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在模块化设计中，软件系统被分解成相对独立的模块集合。从系统的角度来看，这些模块通过调用彼此的函数或方法来协同工作。这将是模块之间的依赖关系。如果你不能很好地处理依赖关系，你将会送命。例如，一个方法的参数在该方法和任何调用该方法的代码之间创建一个依赖关系。如果参数发生变化，则必须修改该方法的所有调用，以符合新的签名。模块之间的交互称为<a class="ae mj" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" rel="noopener ugc nofollow" target="_blank">耦合</a>。</p><blockquote class="mk ml mm"><p id="e239" class="jq jr mn js b jt ju jv jw jx jy jz ka mo kc kd ke mp kg kh ki mq kk kl km kn im bi translated">在<a class="ae mj" href="https://en.wikipedia.org/wiki/Software_engineering" rel="noopener ugc nofollow" target="_blank">软件工程中</a>、<strong class="js iu">耦合</strong>是软件模块之间相互依赖的程度；对两个例程或模块连接紧密程度的一种度量；<a class="ae mj" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)#cite_note-ISO_24765-1" rel="noopener ugc nofollow" target="_blank">【1】</a>模块间关系的强弱。<a class="ae mj" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)#cite_note-ISOIECTR19759_2005-2" rel="noopener ugc nofollow" target="_blank">【2】</a></p><p id="cc90" class="jq jr mn js b jt ju jv jw jx jy jz ka mo kc kd ke mp kg kh ki mq kk kl km kn im bi translated">耦合通常与<a class="ae mj" href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)" rel="noopener ugc nofollow" target="_blank">内聚</a>形成对比。<a class="ae mj" href="https://en.wikipedia.org/wiki/Loose_coupling" rel="noopener ugc nofollow" target="_blank">低耦合</a>通常与高内聚相关，反之亦然。低耦合通常是结构良好的<a class="ae mj" href="https://en.wikipedia.org/wiki/Computer_system" rel="noopener ugc nofollow" target="_blank">计算机系统</a>和良好设计的标志，当与高内聚结合时，支持高可读性和可维护性的一般目标。-来自维基</p></blockquote><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/63114c737440d02fc52525a873fc4a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DRO6--YXTtLy1uzbhGrvXQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated"><a class="ae mj" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" rel="noopener ugc nofollow" target="_blank">联轴器(计算机编程)</a></figcaption></figure><p id="5388" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出色的模块化设计，这意味着模块的不同组件可以替换为替代实施，而不会影响其他组件。这需要开发人员使用适当的抽象(抽象是一个实体的简化视图，它省略了不重要的细节，使我们更容易思考和操作复杂的事情)来使模块变得松散耦合。依赖注入的主要目标是松耦合。</p><p id="c073" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">结论:</strong></p><p id="b5f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">依赖注入使模块变得松散耦合，这有助于降低整体软件的复杂性。</p><h1 id="9c05" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">依赖注入</h1><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div class="ab gu cl mc"><img src="../Images/6e76e1c3ddaa2abf61dd871b21ea89a1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*v-DtE5uj1oyDKEuAdjj2aA.png"/></div></figure><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="662d" class="lv kp it lr b gy lw lx l ly lz"><em class="mn">“Dependency injection is really just passing in an instance variable.” - </em><a class="ae mj" href="https://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html" rel="noopener ugc nofollow" target="_blank"><em class="mn">James Shore</em></a></span></pre><h1 id="2e05" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">注射类型</strong></h1><ul class=""><li id="29ce" class="mw mx it js b jt my jx mz kb na kf nb kj nc kn nd ne nf ng bi translated">构造函数注入</li><li id="7ad7" class="mw mx it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">资产注入</li><li id="9618" class="mw mx it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">方法注入</li><li id="fb4e" class="mw mx it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">周围环境</li></ul><h2 id="8d7f" class="lv kp it bd kq nm nn dn ku no np dp ky kb nq nr lc kf ns nt lg kj nu nv lk nw bi translated"><strong class="ak">构造函数注入</strong></h2><figure class="lm ln lo lp gt mb"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="9c4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">优点:</strong></p><ul class=""><li id="f6ea" class="mw mx it js b jt ju jx jy kb nz kf oa kj ob kn nd ne nf ng bi translated">明确依赖关系</li><li id="d76f" class="mw mx it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">信息隐蔽</li></ul><p id="0e93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">缺点:</strong></p><ul class=""><li id="22fb" class="mw mx it js b jt ju jx jy kb nz kf oa kj ob kn nd ne nf ng bi translated">对象初始值设定项中的样板代码</li><li id="c9bc" class="mw mx it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">可能传递参数太多</li></ul><p id="87f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在类方法中提供默认值在swift中总是一个方便的特性，但是要小心以防UserSession不是您想要的实例。特别是，UserSession有一些前提条件。</p><figure class="lm ln lo lp gt mb"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="db5b" class="lv kp it bd kq nm nn dn ku no np dp ky kb nq nr lc kf ns nt lg kj nu nv lk nw bi translated"><strong class="ak">物业注入</strong></h2><figure class="lm ln lo lp gt mb"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="c356" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">优点:</strong></p><ul class=""><li id="0884" class="mw mx it js b jt ju jx jy kb nz kf oa kj ob kn nd ne nf ng bi translated">干净的初始化器接口，将初始化与注入分开</li><li id="bc4d" class="mw mx it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">“登机容易”</li></ul><p id="f311" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">缺点:</strong></p><ul class=""><li id="7b42" class="mw mx it js b jt ju jx jy kb nz kf oa kj ob kn nd ne nf ng bi translated">信息泄漏，暴露内部属性，初始化不完整</li><li id="e872" class="mw mx it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">使用解包选项整理代码</li><li id="3ee1" class="mw mx it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">不能将属性定义为不可变的</li><li id="d9cf" class="mw mx it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">很难定义默认值</li></ul><h2 id="eb90" class="lv kp it bd kq nm nn dn ku no np dp ky kb nq nr lc kf ns nt lg kj nu nv lk nw bi translated"><strong class="ak">方法注射</strong></h2><figure class="lm ln lo lp gt mb"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="98df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">With method注入依赖项作为参数传递给ViewController的login方法。</p><p id="9986" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">赞成者:</p><ul class=""><li id="35f7" class="mw mx it js b jt ju jx jy kb nz kf oa kj ob kn nd ne nf ng bi translated">自由组合注入方法</li><li id="2594" class="mw mx it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">不需要保留对注入方法的引用</li></ul><p id="cfde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">缺点:</strong></p><ul class=""><li id="58c3" class="mw mx it js b jt ju jx jy kb nz kf oa kj ob kn nd ne nf ng bi translated">信息泄漏，将内部逻辑暴露给使用它的类</li></ul><h2 id="a17c" class="lv kp it bd kq nm nn dn ku no np dp ky kb nq nr lc kf ns nt lg kj nu nv lk nw bi translated"><strong class="ak">周围环境</strong></h2><figure class="lm ln lo lp gt mb"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="1b1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用静态方法或静态属性实现环境上下文。iOS上常见的用法是<a class="ae mj" href="https://medium.com/@lovelydog/singleton-is-good-pathological-liars-6f0ff81e6f96" rel="noopener"> Singleton </a>，它让你的API看起来非常简单并且“没有依赖性”。至于我，我只在不影响代码执行的logger上使用singleton，doe没有任何全局状态。</p><p id="65c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">优点:</strong></p><ul class=""><li id="91bf" class="mw mx it js b jt ju jx jy kb nz kf oa kj ob kn nd ne nf ng bi translated">保持你的API简洁明了</li></ul><p id="3e88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">缺点:</strong></p><ul class=""><li id="180b" class="mw mx it js b jt ju jx jy kb nz kf oa kj ob kn nd ne nf ng bi translated">全球状态</li><li id="d041" class="mw mx it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">隐藏依赖关系</li><li id="049b" class="mw mx it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">让你的单元测试更难</li></ul><h1 id="643e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">我使用依赖注入的方式</h1><p id="19a7" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb oc kd ke kf od kh ki kj oe kl km kn im bi translated">我使用构造函数注入作为我进行依赖注入的首选方式。下图是我在自己的应用中使用的主要概念。如果你有什么建议，请告诉我。</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi of"><img src="../Images/efa774e4cdb3b6f74331c8e5ea3671b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgIPn4Ttfve4CFToTWZRKQ.png"/></div></div></figure><p id="1493" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> AppContext </strong>保存了应用运行时的依赖关系，在海量AppContext的情况下，可以将AppContext分解成子Context，并组合成AppContext。</p><p id="cee7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">协调器</strong>处理ViewController的导航、逻辑流(A/B测试)，甚至用户数据修改。它包含了在ViewControllers中使用的所有依赖项，并将它们传递给对象初始化器。</p><p id="c0e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">视图控制器</strong>将被放置在同一层。这一点很简单，但非常重要，直到你发现你有很多传递参数。</p><p id="ae28" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在示例中，AppContext依赖于SQLite和Alamofire实现的API，我的代码与具体实现紧密耦合。在面向对象设计中，这类问题可以用<a class="ae mj" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依赖倒置原则</a>来解决。遵循DIP指令以获得松散耦合的代码。</p><blockquote class="mk ml mm"><p id="5a61" class="jq jr mn js b jt ju jv jw jx jy jz ka mo kc kd ke mp kg kh ki mq kk kl km kn im bi translated">高级代码不应该依赖低级代码，它们都应该依赖抽象，而抽象不应该依赖细节。</p></blockquote><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi og"><img src="../Images/cc364c299a693a123186dc72b2108c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BqLJ1iT_e2-J3Bb9rr3Wxg.png"/></div></div></figure><p id="3fbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，把AppContext作为高层代码，SQLite作为底层代码。它们都依赖于同一个抽象，存储。(协议是我用来建模抽象的方式，但这并不意味着协议是抽象，<strong class="js iu">好的抽象是至关重要的</strong>。关于抽象，也许下一篇文章。)DIP增强了可替换性，您可以用Leveldb替换Store实现，而无需修改高层代码。DIP也会增加编译时间。让我们看看这是怎么发生的。</p><p id="9ce3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以下载<a class="ae mj" href="https://github.com/vedon/DI" rel="noopener ugc nofollow" target="_blank">演示</a>来看看发生了什么。按下CMB + B，然后按下CMB + 9(报告导航器)，确保选择最近选项卡。每次清理构建后编译时间为<strong class="js iu"> 5.9秒(</strong>指清理整个缓存<strong class="js iu"> ) </strong></p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi oh"><img src="../Images/28a2a118fe9336b5864676d882064ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKTMAiROxeAgCkc2LPp3zA.png"/></div></div></figure><p id="be64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次构建，编译时间只有:<strong class="js iu"> 0.2秒</strong>因为使用了来自内存的构建描述。</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi oi"><img src="../Images/5aedb83a8fb29f0bc883f11118bead09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2R2fFqpRgX9TSxqAJfRX5Q.png"/></div></div></figure><p id="5d1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的UML类图是演示的架构。</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi oj"><img src="../Images/77cbbb515b5fec1aa9cfb5efb1b04f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4YZTchY8K7MdHi0FWtH2qA.png"/></div></div></figure><p id="96a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以Feature1为例:在Feature1.swift上添加新结构，按CMD + B，CMD + 9</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ok"><img src="../Images/0b25df804c1a30aaf60471dfbc1edf04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YbHlY5qGDTI-GMCLbXNJQ.png"/></div></div></figure><p id="e2b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Feature2和App被重新编译(库需要重新编译以符合<a class="ae mj" href="https://en.wikipedia.org/wiki/Application_binary_interface" rel="noopener ugc nofollow" target="_blank"> ABI </a>的变化)，构建时间增加到1.1秒。虽然这对于演示应用程序来说不是太大的问题，但是大的应用程序使用这种方法会遭受巨大的性能损失，很容易达到超过20分钟的构建时间。最坏的情况是修改用户会话导致整个应用程序重新编译。</p><p id="1c9b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">减少编译时间</p><p id="5ced" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了获得尽可能好的构建时间，我们应该使依赖图尽可能水平。因此，我添加了三个组件:FeatureService、User和DIContainer。</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ol"><img src="../Images/e5d8bfb5e386be65d57f67ab5bc88b8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8KVkCnVgNZ5YIgB8zltqw.png"/></div></div></figure><p id="f61e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">功能服务</strong>包含功能1、功能2、功能3提供的服务。</p><p id="18b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">用户</strong>包含UserSession提供的服务或任何与用户相关的东西。</p><p id="c1ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> DIContainer </strong>用相应的实现注册每个服务。功能1用于功能1服务，功能3用于功能3服务。注册后，有了这个容器，你就可以随心所欲地得到任何地方的服务。</p><figure class="lm ln lo lp gt mb"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="lm ln lo lp gt mb"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b487" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以功能2为例。功能2的依赖项是功能2。包含Feature1Service和Feature3Service实现的依赖项。</p><figure class="lm ln lo lp gt mb"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="387d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要获得Feature2的实例，<strong class="js iu">只需c </strong>所有的Feature2 init方法，并传递由AnyInitializer创建的依赖关系<strong class="js iu"> </strong>以及Feature2依赖关系描述和容器。</p><figure class="lm ln lo lp gt mb"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d3ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再次修改Feature1(例如注释掉PrivateModel)，CMD+B，CMD+9，我们只能看到App和Feature1被重新编译，没有Feature2。我假设您的应用程序的构建性能将通过这种方法获得巨大的性能。</p><figure class="lm ln lo lp gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi om"><img src="../Images/b8c75453bd7a572ff6c400f39733449a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3WZBnqxP_wYkNGfYHbJtg.png"/></div></div></figure><p id="87bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了便于阅读，我简化了示例，以便进行概念性演示，从而简单地理解事物，并对如何使用DIContainer、Swift中的Type Erasure等技术有所了解。<a class="ae mj" href="https://github.com/vedon/DI/tree/DI" rel="noopener ugc nofollow" target="_blank">演示代码</a>在这里。任何建议都会有帮助。</p><h1 id="f2ac" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="9f59" class="pw-post-body-paragraph jq jr it js b jt my jv jw jx mz jz ka kb oc kd ke kf od kh ki kj oe kl km kn im bi translated">参考:</p><p id="7e72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mj" href="https://www.objc.io/issues/15-testing/dependency-injection/#ambient-context-2" rel="noopener ugc nofollow" target="_blank">依赖注入</a></p><p id="779e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mj" href="https://medium.com/better-programming/reducing-ios-build-times-by-using-interface-targets-f5c3fd15fa29" rel="noopener">使用接口目标减少构建时间</a></p><p id="6522" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae mj" href="https://stackoverflow.com/questions/2171177/what-is-an-application-binary-interface-abi" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/2171177/what-a-a-application-binary-interface-ABI</a></p></div></div>    
</body>
</html>