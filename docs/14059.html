<html>
<head>
<title>Abstract Classes and Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抽象类和方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/abstract-classes-and-methods-e40693594b01?source=collection_archive---------9-----------------------#2022-10-28">https://levelup.gitconnected.com/abstract-classes-and-methods-e40693594b01?source=collection_archive---------9-----------------------#2022-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0061cf2b88de3b3a2cabfc421cdd1d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*goaWnzBghqlA0Goi7uhZ9Q.png"/></div></div></figure><div class=""/><p id="4121" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与典型的类继承不同，抽象类将类继承强制到从基类继承的类上。基类用于创建局部蓝图，然后继承的类可以根据自己的独特需求完成它。抽象类是创建可管理和可维护代码的好方法。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="a55d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">抽象敌人类</strong></p><p id="c027" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lg">抽象敌人</em>职业将作为所有其他敌人继承的基础职业。所有敌对类型共享的属性和方法可以在抽象类中声明。正如这里看到的，所有的敌人都有<em class="lg">速度</em>和<em class="lg">生命</em>变量，以及他们掉落的<em class="lg">宝石</em>。他们也都有攻击方法。<em class="lg">基类</em>是<em class="lg">抽象</em>，将强制继承类也有相应的<em class="lg">攻击</em>方法。还要注意的是，在声明类时使用了关键字<em class="lg"> Abstract </em>。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lh"><img src="../Images/64549695f65e71d6435a69deec8b3ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESfdu1Tr61tEAOPnz4T0OA.png"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="c85f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">规则和限制</strong></p><p id="9d3d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">抽象类不能被<em class="lg">实例化</em>，所以需要注意的一点是，抽象类不能<em class="lg">而不是</em>被附加到<em class="lg">游戏对象</em>上。如下图所示，当我试图将敌方脚本拖到敌方游戏对象上时，弹出一个<em class="lg">错误</em>告诉我脚本不能是抽象的。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lm"><img src="../Images/dd2545aff8a58549e6328977661d3689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XXEnp0pnBxKqxebFaAVJ2A.gif"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="1edd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">继承</strong></p><p id="c899" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从<em class="lg">敌人</em>继承而来的一个新职业被创建并命名为<em class="lg">苔藓巨人</em>。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ln"><img src="../Images/de6b0b3bd2e67eae04f5e8bc3bf60264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-CP_iJglnCvI0D-LZ-qQyA.png"/></div></div></figure><p id="8eb5" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通常情况下，<em class="lg">摩斯巨人</em>级可以调用<em class="lg">敌人</em>级中的<em class="lg">攻击</em>方法，并且如果攻击方法是<em class="lg">虚拟</em>的话，还会有<em class="lg">覆盖</em>的能力。更多关于<em class="lg">虚方法</em>和<em class="lg">类继承</em>在这里<a class="ae lo" href="https://medium.com/@jaredamlin/classes-in-c-using-unity-4325f2080353" rel="noopener"><em class="lg">https://medium . com/@ jaredamlin/classes-in-c-using-unity-4325 f 2080353</em></a>。</p><p id="d0df" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦我将<em class="lg">抽象</em>关键字添加到攻击方法中，我会在<em class="lg">苔藓巨人</em>类中得到一个<em class="lg">错误</em>。这是因为现在方法是<em class="lg">抽象</em>，继承类<em class="lg">必须</em>实现相应的攻击方法。对于普通的类继承，继承类有<em class="lg">选项</em>来决定是否包含攻击方法。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lp"><img src="../Images/7562b35fc22c7d697ceea5ce6948a907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhBy8YBP5TgS-0bYkE8i7g.png"/></div></div></figure><p id="177b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">悬停在错误上方会告诉我，<em class="lg">“摩斯巨人没有实现继承了抽象成员</em> <strong class="kd jf"> <em class="lg">的‘敌人’。()’</em></strong><em class="lg"/></p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/31870216ebef5892cf55f94aa6da00cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ssGdZ5OjSt-QhQ7YoIqzRQ.gif"/></div></div></figure><p id="3fd0" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">给<em class="lg">苔藓巨人</em>职业增加一个<em class="lg">覆盖</em>攻击方法，会满足这个错误，但是也会在<em class="lg">抽象</em>职业的<em class="lg">攻击</em>方法中产生一个新的。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lr"><img src="../Images/dd222ab90c3c190ca6a552c8b16681f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7Ior4dl4LfUGhPxa-l1bw.png"/></div></div></figure><p id="8578" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">悬停在错误上告诉我<em class="lg">抽象方法</em>可以<em class="lg">而不是</em>声明主体。抽象方法不能使用<em class="lg">实现</em>，只能用于<em class="lg">初始化</em>方法。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ls"><img src="../Images/88fa721f36bd9bfc548cc5c2d66be0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CQmvxVX2Cgal_lwRcSOcCg.gif"/></div></div></figure><p id="e435" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦花括号从抽象方法中移除，所有的错误都会消失。<em class="lg">‘扔新系统’。NotImplementedException' </em>'被自动添加并作为一个临时占位符，直到您正确实现了<em class="lg">覆盖</em>方法的行为。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lt"><img src="../Images/20cad5b5f23f151f205d25c3f6718831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxVeoj8fO5_UvJhaGnZ71g.png"/></div></div></figure><p id="0af2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想要一个具有<em class="lg">共享行为</em>的方法用于继承类，您可以添加一个<em class="lg">虚拟</em>方法，就像这里看到的死亡方法一样。因为它不是抽象的，所以虚方法可以声明一个体。在这种情况下，它调用<em class="lg"> destroy </em>方法并引用脚本附加到的<em class="lg">游戏对象</em>。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/8e33015f94c83ab1839307325666b2d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y55zBpryaJy4P-2OU03jfg.png"/></div></div></figure><p id="d186" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为<em class="lg">摩斯巨人</em>职业和<em class="lg">敌人职业</em>在<em class="lg">相同的</em>脚本上，也就是<em class="lg">抽象</em>，我可以<em class="lg">而不是</em>把这个拖到一个<em class="lg">游戏对象</em>上。不过我可以创建一个<em class="lg">新的苔藓巨人</em>脚本，并将所需代码从<em class="lg">敌人</em>脚本移到新的<em class="lg">苔藓巨人</em>职业中。因为<em class="lg">敌人</em>继承了<em class="lg">的单声道行为</em>，而<em class="lg">青苔巨人</em>继承了<em class="lg">敌人</em>，我现在可以将<em class="lg">青苔巨人</em>脚本放到<em class="lg">游戏对象</em>上。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lv"><img src="../Images/2fe5ee5f62bb14dd1fd942f567ccf83e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EXb4gCDFgqqgyaQK4ntaw.png"/></div></div></figure><p id="baed" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，回到<em class="lg">苔藓巨人</em>剧本。给<em class="lg">摩斯巨人</em>职业增加一个<em class="lg">覆盖</em>死亡方法会调用<em class="lg">基地。死亡</em>方法来自基地<em class="lg">敌人</em>职业，<em class="lg">消灭</em>本<em class="lg">游戏对象</em>时调用。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lw"><img src="../Images/3ac7db9817cdd68239e089ae1d0c419c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t64Sx3lKG_WXuHomLM4Saw.png"/></div></div></figure><p id="63bf" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的优点是，虽然所有继承类的<em class="lg">都将从<em class="lg">基</em>方法中销毁，但是您可以在调用<em class="lg">基</em>方法之前将<em class="lg">自定义</em>行为添加到继承</em>类的<em class="lg">中。这些行为可以是任何东西，从实例化宝石到掉落，播放音频剪辑，或者在死亡粒子动画上创建自定义。</em></p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lx"><img src="../Images/87928d69b0b4c5f2c6a21bb4a52ed40b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOQ8PzbWdx83go8Hcj96yA.png"/></div></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="48c2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">挑战:</strong> <em class="lg">员工体验</em></p><p id="2dd7" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为一个挑战，我需要创建一个<em class="lg">抽象</em> <em class="lg">雇员</em>类，作为<em class="lg">兼职</em>和<em class="lg">全职</em>类的<em class="lg">基础</em>类。每个员工可以在<em class="lg">检查器</em>中输入他们的<em class="lg">公司名称</em>，以及他们自己的<em class="lg">员工名称</em>。还有一个<em class="lg">抽象</em>方法用于<em class="lg">计算月薪</em>，必须由继承类实现。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/5091d0248b35114ffe2828d9e6f9aa18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MfFrCIBzc1EHlZ7J4zmSaA.png"/></div></div></figure><p id="9980" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lg">全职</em>类继承自<em class="lg">雇员</em>，并且有一个名为<em class="lg">薪水</em>的<em class="lg"> int </em>变量来表示年薪总额。在<em class="lg">覆盖</em>计算月薪的方法中，年薪除以一年中的12个月，然后存储在一个<em class="lg">月薪</em>局部变量中。一条<em class="lg">调试</em>消息被发送到<em class="lg">控制台</em>，控制台读出员工<em class="lg">姓名</em>，然后告诉用户他们的月薪是多少。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lz"><img src="../Images/275458850b71d8329ed806707cccec34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4t9MinEZDMIw5e1ZuyR2Q.png"/></div></div></figure><p id="06aa" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="lg">兼职</em>类也继承自<em class="lg">雇员</em>，并且有两个<em class="lg"> int </em>变量，一个用于<em class="lg">工作小时数</em>，另一个用于它们的<em class="lg">小时工资率</em>。兼职员工<em class="lg">的方法是将他们的<em class="lg">小时工资</em>乘以<em class="lg">工作时间</em>，并将其存储在<em class="lg">月薪</em>变量中。另一个<em class="lg">调试</em>消息被发送到这里，告诉控制台兼职员工的计算月薪。</em></p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0061cf2b88de3b3a2cabfc421cdd1d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*goaWnzBghqlA0Goi7uhZ9Q.png"/></div></div></figure><p id="4720" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里是检验员中的<em class="lg">兼职</em>员工。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ma"><img src="../Images/815358ab378c1f769c3ce99d5c692354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BS9cDoJB0ac-yIG7eHy3fQ.png"/></div></div></figure><p id="5e34" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里是检查员中的<em class="lg">全职</em>员工。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mb"><img src="../Images/e68be796ddda4b406c0636deb2232b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35-qio1d8_FBI0h8BSIR3A.png"/></div></div></figure><p id="a611" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如图所示，蒂莫西每月总共工作40个小时，得到10000美元，而索菲娅得到6666美元。索菲娅可能想带蒂莫西出去吃饭！</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mc"><img src="../Images/8a520695b22e30d54c75c0d034647890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HTldaLSUYROKYUaFuhMftg.png"/></div></div></figure><p id="b447" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">抽象类和方法就是这样！我希望你能在我的下一篇文章中加入我，在那里我将讨论如何使用<em class="lg">接口</em>。感谢阅读！</p></div></div>    
</body>
</html>