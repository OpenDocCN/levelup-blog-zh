<html>
<head>
<title>Golang: Tracking 1% request timeouts with Sumologic complex log parsing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang:使用Sumologic复杂日志解析跟踪1%的请求超时</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/golang-tracking-1-request-timeouts-with-sumologic-complex-log-parsing-febf9e8ef59e?source=collection_archive---------13-----------------------#2020-11-16">https://levelup.gitconnected.com/golang-tracking-1-request-timeouts-with-sumologic-complex-log-parsing-febf9e8ef59e?source=collection_archive---------13-----------------------#2020-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="33bb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">简介</strong></h2></div><p id="c093" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">吸引最终用户的一个主要因素是应用程序响应用户请求的速度。当流量较低时，应用程序执行得相当好，但是一旦应用程序上的负载增加，事情就开始失败了。</p><p id="22ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在将应用程序投入生产之前，将对应用程序服务器或数据库服务器能够处理的最大负载进行严格的基准测试。基于预期的负载和波动，服务设置SLA超时(服务级别协议),表示如果处理任何请求花费的时间超过该SLA时间，上游服务必须以超过截止时间错误取消请求。</p><h2 id="5609" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">问题陈述</strong></h2><p id="010f" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">手动基准测试只是评估系统容量的初步检查，但是我们开发人员不能仅仅依赖于基准测试的结果。因此，为了监控实时交通信息，我们开始使用应用程序监控工具，如<strong class="kh ir"> NewRelic。</strong></p><p id="fa84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在实时应用程序监控、洞察、警报等方面，NewRelic是市场上最好的。但我觉得它缺少一样东西。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/1831121b6151121b78ece2308a3b3cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UgxgUq15detGL0J9u0sJzw.png"/></div></div></figure><p id="0769" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上图描述了GRPC服务，以及每个子组件所用的平均时间。我们识别服务的痛点，并为每个痛点启动一个事务，以便我们可以跟踪它们。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/3f8f895acca378f6816f80d37d7c4813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*szGZxH5VKuznARf_peNtXQ.png"/></div></div></figure><p id="0b3e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NewRelic还为我们提供了%(百分位数)的性能。基于此，我们可以说中值低于50毫秒，95 %的请求在不到500毫秒内得到服务，4%的请求花费了将近2秒。假设我的服务SLA是250 ms，如果我们仔细观察，就会发现有一些主要的东西丢失了。</p><ul class=""><li id="0bb6" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated"><strong class="kh ir">如果请求处理超过SLA，我无法跟踪我的每个子组件花费了多少时间。可能有50个子组件，调试每一个都是一场噩梦。</strong></li><li id="68f7" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated"><strong class="kh ir">该仪表板不提供100 %的请求处理报告。这意味着如果服务每分钟处理100K个请求，99%低于SLA超时，但1%的请求超过了这个时间。这意味着对于每100K个请求，我们在1K个请求上超时，我们甚至没有得到通知，也不能发出警报。</strong></li></ul><p id="0a5d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在接近150，150K RPM的规模下工作，对我们来说，跟踪所有这些指标以跟踪确切的难点并确定哪里出错是至关重要的。</p><h2 id="5aa2" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">解决方案</strong></h2><p id="f0a2" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这时，我们构建了一个定制的跟踪模块，它计算每个组件花费的时间，并将其记录到stdout中。</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9417" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们进入代码的细节。我的跟踪器几乎没有结构字段。</p><ul class=""><li id="7759" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated">trackerEnabled--&gt;这表示我是否必须跟踪请求。可以在运行时动态切换</li><li id="7dba" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">tracker Name--&gt;这类似于我们正在跟踪的API或GRPC服务名。</li><li id="0612" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">trackerStartTime--&gt;这表示请求开始的时间。</li><li id="1bec" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">componentexctrace-&gt;这是一个包含子组件名称及其执行时间的切片。</li><li id="b48d" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">slaTimeOut -&gt;如果总处理时间超过这个时间，将记录组件执行时间。</li></ul><p id="1b31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">功能</strong></p><ul class=""><li id="abd3" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated">StartTransaction -&gt;为子组件启动新的事务</li><li id="da2a" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">EndTransaction -&gt;结束已开始的事务</li><li id="c4e5" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">logcomponenteexecutiontrace-&gt;检查diff b/w当前时间，并请求以毫秒为单位的开始时间，如果diff大于SLA超时，它将记录单个组件的执行跟踪。</li><li id="e85c" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">AddCanonicalLog -&gt;如果任何特定的信息需要与相同的组件跟踪一起记录，我们可以将其添加为规范日志的一部分。</li></ul><p id="6ab2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在每个API或服务开始时，我们用trackerName &amp; slaTimeOut初始化跟踪器。(SLA超时是非强制性的，因此，如果我们需要记录所有请求组件执行跟踪，我们不需要任何额外的开发)</p><p id="33dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">用法</strong></p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9e71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在每个API请求上初始化一个tracker对象，并从中创建一个上下文。因为上下文作为第一个参数是每个函数的一部分，所以我们不需要将这个跟踪器作为一个单独的参数传递给所有的子函数。如果任何一个子函数需要获取tracker对象，它们需要做的就是:</p><pre class="ma mb mc md gt nb nc nd ne aw nf bi"><span id="4f49" class="lb lc iq nc b gy ng nh l ni nj">trackerObject = tracker.FromContext(parentContext)</span></pre><p id="ecb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是示例日志的样子。</p><pre class="ma mb mc md gt nb nc nd ne aw nf bi"><span id="33c1" class="lb lc iq nc b gy ng nh l ni nj">2020-11-16 12:30:37.869	|	WARN	|	server.RequestTimeOut	|	LogComponentExecutionTrace	|	/grpc.manthan/EarnAndBurnBest - ComponentExecutionTrace =[{componentName:userContext duration:1.4194959999999999} {componentName:firstTxnAggregate duration:24.112934} {componentName:Add-c-Entities duration:1.229218} {componentName:Add-dp-Entities duration:1.337455} {componentName:Add-pl-Entities duration:11.007331} {componentName:addPromoEntities duration:13.598098} {componentName:updateNonReferencedRules duration:0.0011409999999999999} {componentName:secondTxnAggregate duration:1.218247} {componentName:parseComplexResp duration:28.384265999999997} {componentName:processEarnTxn duration:12.904318} {componentName:processBurnTxn duration:83.656057} {componentName:formEarnBurnResponseTxn duration:0.589044} {componentName:EarnAndBurnImpls duration:150.10316200000003}]</span></pre><p id="551e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是我们解析日志的时候了，用它构建一个仪表板，并尝试找出哪个组件花费了更多的时间。</p><p id="3fc1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用的日志聚合器是<strong class="kh ir"> Sumologic </strong>。它有两种日志记录方式。</p><ul class=""><li id="eb5f" class="ml mm iq kh b ki kj kl km ko mn ks mo kw mp la mq mr ms mt bi translated">Rest Client -&gt;应用程序必须在每个日志请求上对sumo logical rest-Client进行网络调用。</li><li id="dd4e" class="ml mm iq kh b ki mu kl mv ko mw ks mx kw my la mq mr ms mt bi translated">后台监听器-&gt;在这里，我们将它直接记录到stdout，Sumologic监听器一直监听所有的更改，并在光标的帮助下，跟踪所有这些日志，并一直将它们推送到服务器。</li></ul><p id="2c93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们更喜欢方法2，因为这减少了多个应用程序与Sumologic Rest客户端的集成。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nk"><img src="../Images/ef93c069036576e1c5bf121a1592170a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OAMXOHoZx1k4wq3iiLaygA.png"/></div></div></figure><p id="a00b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打开sumologic仪表板，右键单击日志并选择<strong class="kh ir">解析所选文本。点击后会打开一个对话框。</strong></p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nl"><img src="../Images/5e94bf404a479090b0efebe529c1a86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFKcHVX7ctShwpa0R2xSuA.png"/></div></div></figure><p id="efd6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在单击组件执行时间，您将得到如下文本。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nl"><img src="../Images/5212da112a7880d810494c25db6dfaa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DR7x386zJCZoJC8aHox-xQ.png"/></div></div></figure><p id="793f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我想提取这个值作为用户上下文。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nm"><img src="../Images/927798dc7e820fab7785a7f1062ba0e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HxCxzY6e69nVCvfLpytldw.png"/></div></div></figure><p id="aa38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后的结果是这样的。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nn"><img src="../Images/51f8527c4f1f32ab2eb668b581fe348d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AFbCZm_NlApQ0Cyge19Ow.png"/></div></div></figure><p id="8a9c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我需要检查燃烧组件的最大时间。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi no"><img src="../Images/34e01f4a1322b41551588356b93632fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U68GvdnV9Vwezg25-rhusg.png"/></div></div></figure><p id="0832" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种复杂的日志解析，我们不仅可以实现排序功能，还可以实现许多聚合功能，我们可以计算出95 %的请求处理时间、99%的处理时间等。</p><p id="f667" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望我已经涵盖了我想要的。如果有任何问题或疑问，请发表在评论区，我会尽快回复。</p></div></div>    
</body>
</html>