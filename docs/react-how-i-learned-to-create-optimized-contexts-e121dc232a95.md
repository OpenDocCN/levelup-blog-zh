# 反应:我如何学会创建优化的上下文

> 原文：<https://levelup.gitconnected.com/react-how-i-learned-to-create-optimized-contexts-e121dc232a95>

## …别再担心炸弹了。

![](img/bcc7b903c432c0e427d5f385396e5793.png)

为什么大家都一直在说语境…？

# 一点…嗯，上下文🤭

**注意:如果你想直接潜水，跳过这一部分。**

[React contexts](https://reactjs.org/docs/context.html#when-to-use-context) 是一个非常酷的特性，并且*非常实用于 hooks API。你肯定遇到过一些人，而且可能会马上认出他们。*

今天我想分享我在创建自己的 React 上下文时学到的东西:**我认为什么是好的上下文**和**如何编写一个**。

我想稍后分享的另一个探索不会出现在这篇文章中:如何以及何时将一个上下文分割成 2 个或更多。

# 让我们潜水吧

![](img/9ba383e4e9d9e1b1aeeec0a7a1913a24.png)

超级跳水

让我们以一个`Theme`上下文为例，它提供了一个`mode: 'dark' or 'light'`和一个`compact`布尔值来指示 UI 是否应该减少边距和填充。

## 第一种方法

基本上，我会使用 React `createContext`创建一个上下文，然后导出它，这样就可以了。

您可以使用`useContext`钩子或消费者组件来消费这个上下文，如下所示:

```
**const** theme = useContext(ThemeContext)
// or
<ThemeContext.Consumer>
  **{**(theme) => …**}**
</ThemeContext.Consumer>
```

好吧，但是这很不安全。

您是否注意到回退值如何为`setMode`和`setCompact`提供无操作功能？这是因为我们不能确定一个提供者被声明在组件树的上层。

另外，哪个组件将负责为**提供值？**

![](img/391a626b0eb67cc7fbab8f2cbd49adc5.png)

…

## 我认为是一个好的背景

对我来说，一个好的上下文应该:

*   容易维护吗**(你通常不单独工作，是吗？即使你做了，你也是在和过去和未来的自己一起工作🤐)**
*   ****快速**失效，以防有人忘记**提供**一个值。快速失败可以防止无声的错误，这种错误很难被发现。**
*   ****嵌入其**自己的**逻辑**——不要将该逻辑留给不对其负责的组件。**
*   **仅在必要时使其消费者**重新呈现****

# **如何写好语境**

## **建筑/骨架🏚**

> **事先说明:以下是自以为是，绝对不是**只有* *可行的写作方式*反应上下文。我也很高兴听到你的。***

***我们不会直接导出不安全的上下文。相反，我们将导出 3 个包装器来保护它:***

*   ***一个**提供者**组件——T0——它将嵌入自己的逻辑，而不是把它委托给天知道的地方。***
*   ***一个**钩子**，为了消耗上下文值`useTheme()`，它将断言该上下文已经被提供了一个值。***
*   ****如果需要的话* : 一个**消费者**组件——与钩子相同，它将断言上下文已经被提供了一个值。***

## ***消费者:断言所提供的价值***

***![](img/f3c220aa8dbe0b09fbf16fc8ef66c46d.png)***

***嗯，没有。***

***为了断言上下文值，我们将在这里添加一个任意回退值`null`，但它可以是任意值，并且消费者`useTheme`和`ThemeConsumer`将*断言*上下文值*不是*回退值*。****

***控制狂消费者***

## ***提供商:避免不必要的重新渲染***

***坚持住，这是🥵.的最后一英里下面是基本但效率低下的实现:***

***效率低下的供应商效率低下。***

***你会问“为什么效率低”？很高兴你问:因为`value`！***

***当`ThemeProvider`的父级重新渲染时，`ThemeProvider`也会重新渲染，这将*重新创建值*，从而 ***改变其引用*** 。
然后，React 会检测到一个上下文值的变化，**每个消费我们主题的组件都会更新！顺便说一下，请记住这适用于任何 JavaScript 对象:数组、映射、集合等等……(我制作了一个 [codesandbox](https://codesandbox.io/s/react-context-ximn2) 来演示这个小故障)。*****

***为了解决这个问题，我们应该用`useMemo` [钩子](https://reactjs.org/docs/hooks-reference.html#usememo)来记忆这个值，以防止引用的改变，这样就可以了。***

> ***注意 1:大多数上下文将出现在你的 app⋅s 的根目录下，这意味着它们没有任何可以重新渲染的父节点。尽管如此，当编写一个上下文提供者时，提供者不能预先知道*在*树*中的*将被使用。因此，你应该**始终**优化你的提供商。***
> 
> ***注意 2:在我的实验中，有人建议我将提供者组件包装在一个`React.memo` HOC 中。那是一个好主意，不幸的是它不起作用。所以不要。自己试试[这里(codesandbox)](https://codesandbox.io/s/react-context-ximn2?file=/src/contexts/Auth.tsx:586-628) 。***
> 
> ***注 3:代替`useMemo`，你也可以使用一个分组状态，比如:
> `**const** [theme, setTheme] = useState({ mode: 'dark', compact: **false** })`***
> 
> ***注意 4:也有可能使用`useReducer`钩子来管理状态，但是我感觉这个钩子只有 redux-users 才能理解，所以我不习惯在团队项目中使用它。***

# ***包装🧐***

***![](img/cca5b89bac18f9e4d66949aa13e0ec23.png)***

***您的下一次潜水将使用 React 上下文🤓***

*   *****架构** `Provider + hook (+ Consumer)`确保了**可读性**(因此可维护性**)并且**将**逻辑嵌入到一个地方，**减少了我们的错误来源。***
*   *****钩子**(和消费者组件)实现了**快速失效策略**，以避免无声错误和绝望的调试会话。***
*   *****提供者**组件被**优化**以**避免**不必要的**重新呈现其消费者的**。***

***最后一瞥💅***

***就是这样！我希望它能对你的上下文之旅有所帮助，现在代码安全，回头见😇。***

***仅供参考:这里有一个代码沙箱，如果你想玩上下文的话，在最后🤪。***

***所以下次再见，哦。等等。我认为我们可以做得更多😏。***

# ***更进一步😤***

***![](img/eac19352985a9013c1da6c585c076d83.png)***

***🙇 🙇‍♂️ 🙇‍♀️***

***你没想到会有这一天？我们可以抽象出两种重复的逻辑:***

*   ***使用唯一且可识别的默认值创建上下文。***
*   ***创建消费者——钩子和组件——当找到默认值时抛出。***

***对于默认值，因为`null`值*可能会在某一天的上下文中使用*(并且因为我们不知道未来会发生什么🔮)，我们必须找到另一个唯一可识别的默认值。JavaScript 有完美的数据类型:`[Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)`。***

> ***编者按:我现在就像一个孩子…我知道这是一个奇怪的梦，但我认真地梦想有一天使用一个具有适当用例的 JavaScript 符号…这一天已经到来了！ *🥳🤓****

***现在我完成了。真的。不是开玩笑。***

***给你，把这个 GIF 作为走了这么远的奖励😎***

***![](img/edb50afd604dda70c1c07017280b491c.png)***

***恭喜你。***

***![](img/20e6f9ec5f980cae7380927c892294ed.png)***

***你，下一次一个上下文困扰你。***

***承诺的 codesandbox😊***

***🦄***

# ***分级编码***

***感谢您成为我们社区的一员！ [**订阅我们的 YouTube 频道**](https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1) 或者加入 [**Skilled.dev 编码面试课程**](https://skilled.dev/) 。***

***[](https://skilled.dev) [## 编写面试问题+获得开发工作

### 掌握编码面试的过程

技术开发](https://skilled.dev)***