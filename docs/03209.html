<html>
<head>
<title>JavaScript Best Practices for Writing More Robust Code — Error Prevention</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更健壮代码的JavaScript最佳实践—错误预防</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-error-prevention-78f1b371906b?source=collection_archive---------8-----------------------#2020-04-25">https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-error-prevention-78f1b371906b?source=collection_archive---------8-----------------------#2020-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/eaae6010aa5651951c1bc6eaea37d490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fvNLUE6eLhBbRUYj"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@ggiqueaux?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Geronimo Giqueaux </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c579" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="cd11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究在处理JSON时编写更健壮的代码的方法，以及在编写代码时更好地处理错误和防止错误发生的最佳实践。</p><h1 id="e3c0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用JSON.parse或JSON.stringify时使用try…catch</h1><p id="f90d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">JSON.parse</code>和<code class="fe mh mi mj mk b">JSON.stringify</code>遇到问题会抛出错误。</p><p id="fc53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当<code class="fe mh mi mj mk b">JSON.parse</code>在字符串中遇到无效的JSON，它就会抛出一个错误。<code class="fe mh mi mj mk b">JSON.stringify</code>试图将循环结构转换成JSON时抛出错误。</p><p id="60a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该使用<code class="fe mh mi mj mk b">try...catch</code>来包装<code class="fe mh mi mj mk b">JSON.stringify</code>和<code class="fe mh mi mj mk b">JSON.parse</code>，以防止错误阻止我们的程序运行。</p><p id="5d53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们应该这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="dc13" class="mt lf it mk b gy mu mv l mw mx">try {<br/>  const json = '{}';<br/>  const parsed = JSON.parse(json);<br/>} catch (ex) {<br/>  console.error(ex);<br/>}</span></pre><p id="6fb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样<code class="fe mh mi mj mk b">JSON.parse</code>就不会在解析JSON遇到问题时使我们的程序崩溃。对于使用它的代码，我们也可以用<code class="fe mh mi mj mk b">JSON.stringify</code>替换<code class="fe mh mi mj mk b">JSON.parse</code>。</p><h1 id="3cb2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用ESLint或其他Linter尽早捕捉错误</h1><p id="666b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">ESLint是JavaScript的标准linter。它检查语法错误和混乱的代码，以防止开发人员提交多种有问题的代码或潜在的bug。</p><p id="2a12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它有一个很大的规则列表，用于检查可能的错误或无用和混乱的代码。</p><p id="2f2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，它检查getters中的return语句。这是因为使用一个不返回JavaScript或类中任何内容的getter是没有意义的。一个不返回任何东西的getter是没有用的，如果它存在的话，很可能是一个错误。</p><p id="480d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他事情包括在条件表达式中不允许赋值操作符，因为我们可能想使用<code class="fe mh mi mj mk b">==</code>或<code class="fe mh mi mj mk b">===</code>来比较事物，但我们忘记了额外的等号。</p><p id="256a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在https://eslint.org/docs/rules/有更多的规则。</p><p id="256f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它很容易为任何项目设置。我们可以通过运行以下命令将<code class="fe mh mi mj mk b">eslint</code>安装到我们的项目文件夹中:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0089" class="mt lf it mk b gy mu mv l mw mx">npm install eslint --save-dev</span></pre><p id="8efa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们通过运行以下命令来创建ESLint配置文件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="991b" class="mt lf it mk b gy mu mv l mw mx">npx eslint --init</span></pre><p id="9aa2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自定义我们想要启用的规则。它非常灵活，我们不必启用对所有规则的检查。</p><p id="1ec5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它也有许多插件来添加更多的规则。流行的规则包括Airbnb和默认规则。我们还可以包括Node.js规则、Angular、React、Vue等。</p><h1 id="f3b5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要弄乱内置的对象原型</h1><p id="326d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们永远不应该弄乱内置全局对象的原型。像<code class="fe mh mi mj mk b">Object</code>、<code class="fe mh mi mj mk b">String</code>、<code class="fe mh mi mj mk b">Date</code>等对象。所有的实例、方法和变量在它们的原型中都不应该被打乱。</p><p id="d710" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们错误地改变了它们，那么我们的代码可能不会按照我们期望的方式工作，因为它们经常从这些内置对象中调用实例方法，并且在我们的代码中操纵它们可能会破坏我们的代码。</p><p id="f1ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本机对象的成员也可能与我们自己代码中的成员发生名称冲突。</p><p id="15d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也令人困惑，因为如果我们改变内置对象的原型，很多人可能会认为它实际上是标准库的一部分。</p><p id="989c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不希望人们犯这样的错误，编写更多糟糕的代码，并在以后制造更多的问题。</p><p id="bb16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们绝不应该修改内置对象及其原型。</p><p id="c387" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们需要内置本机对象没有提供的任何新功能，那么我们应该从头开始编写自己的代码，并在必要时引用内置本机项目。</p><p id="f4d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，如果我们想使用你的应用所针对的浏览器中不存在的新的本地方法，那么我们可以使用polyfills来添加该功能，而不是从头开始实现它。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/ca6208417ec2dd61cc36368fec40f740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zekwmhUp4WF0LpXQ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">肖恩·麦基在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="a254" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">总是使用严格模式</h1><p id="9370" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript曾经让人们做很多人们不应该做的事情。</p><p id="926f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们编写不应该编写的代码时，严格模式会抛出错误，比如给<code class="fe mh mi mj mk b">null</code>或<code class="fe mh mi mj mk b">undefined</code>赋值，或者通过省略<code class="fe mh mi mj mk b">var</code>、<code class="fe mh mi mj mk b">let</code>或<code class="fe mh mi mj mk b">const</code>意外创建全局变量。</p><p id="4575" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">引发错误的其他事情包括试图扩展应用了<code class="fe mh mi mj mk b">Object.freeze</code>方法的对象的新属性。</p><p id="cd38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果没有严格模式，以下内容将不起作用:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c46a" class="mt lf it mk b gy mu mv l mw mx">const foo = {};<br/>Object.preventExtensions(foo);<br/>foo.newProp = 'foo';</span></pre><p id="89c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，在严格模式下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6c25" class="mt lf it mk b gy mu mv l mw mx">'use strict'<br/>const foo = {};<br/>Object.preventExtensions(foo);<br/>foo.newProp = 'foo';</span></pre><p id="c7ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将得到一个错误“未捕获类型错误:无法添加属性newProp，对象不可扩展”。</p><p id="1e5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还禁止我们使用可能在JavaScript未来版本中使用的关键字和结构。例如，我们不能声明一个名为<code class="fe mh mi mj mk b">class</code>的变量，因为它是一个保留关键字。</p><p id="2579" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，严格模式适用于所有JavaScript模块。然而，默认情况下，旧式脚本没有严格模式。因此，我们应该通过在我们代码的顶部添加<code class="fe mh mi mj mk b">'use strict'</code>来确保它们有严格的模式。</p><p id="0b67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以在函数中添加<code class="fe mh mi mj mk b">'use strict'</code>,但是我们肯定希望严格模式无处不在，所以我们应该把它放在脚本文件的顶部。</p><p id="b1e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于严格模式防止我们犯这么多种错误，我们应该一直打开它。</p><h1 id="443a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="a488" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用ESLint和strict模式很容易防止JavaScript代码错误。它们防止我们犯各种各样的错误，这将节省我们调试糟糕代码的大量时间。</p><p id="cae6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们应该使用<code class="fe mh mi mj mk b">try...catch</code>在解析和字符串化JSON时捕捉错误。</p></div></div>    
</body>
</html>