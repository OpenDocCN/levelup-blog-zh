<html>
<head>
<title>Fixing weak crypto in OpenSSL based applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修复基于OpenSSL的应用程序中的弱加密</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/fixing-weak-crypto-in-openssl-based-applications-c12fbe7c5dcd?source=collection_archive---------13-----------------------#2020-04-13">https://levelup.gitconnected.com/fixing-weak-crypto-in-openssl-based-applications-c12fbe7c5dcd?source=collection_archive---------13-----------------------#2020-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d99b30e53a9ca82074befad50a2ff78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ykVkYfXj2AdulF8E"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">本杰明·雷曼在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="205c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">【https://pqsec.org】原载于2020年4月13日<a class="ae kc" href="https://pqsec.org/2020/04/13/fixing-weak-crypto-in-openssl-based-applications.html" rel="noopener ugc nofollow" target="_blank"><em class="lb"/></a><em class="lb">。</em></p><h1 id="076c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">为什么加密变弱了</h1><p id="6536" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">没有人会故意设计弱密码算法。嗯，几乎没有人——有时国家情报机构为了他们自己的目的试图后门加密(<a class="ae kc" href="https://en.wikipedia.org/wiki/Dual_EC_DRBG#Weakness:_a_potential_backdoor" rel="noopener ugc nofollow" target="_blank">),但希望这是一个例外，一般来说，人们都有最好的意图。</a></p><p id="bc7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，为什么有些crypto会突然变弱呢？所有实用的密码算法都是围绕一些困难的计算问题而设计的。也就是说，实际上很难(但不是不可能！)在不知道某些秘密信息(密钥)的情况下有效地执行算法。强加密的基本假设是:</p><ul class=""><li id="483b" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">不存在允许在不拥有密钥的情况下进行特定信息转换(例如，解密或签名)的有效算法</li><li id="a23d" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">允许进行上述操作的所有现有算法都需要大量资源(通常是计算时间和/或内存)，这使得它们不切实际，因为使用当前的技术，要么需要数百年或数千年来破解单个字节，要么整个世界都没有足够的内存来容纳该算法的状态</li></ul><p id="0b7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当这些假设中的一个或者甚至两个都不再成立时，特定的加密算法变得脆弱。第一个假设可能会被打破，当一些研究人员发明并公布了一种算法，使一个困难的计算问题不再困难:公布的方法可能会大大降低破解受保护信息的计算/内存需求。例如，查看为什么<a class="ae kc" href="https://www.rc4nomore.com/" rel="noopener ugc nofollow" target="_blank"> RC4密码不再用于TLS</a>。</p><p id="9d90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着时间的推移，第二个假设自然会被打破，主要是因为快速的技术进步。不仅计算机每天都变得更强大，更多的计算和内存资源可用，而且全新的技术也出现了，这些技术允许<a class="ae kc" href="https://en.wikipedia.org/wiki/Quantum_computing#Cryptography" rel="noopener ugc nofollow" target="_blank">在瞬间完全破解一些现代和最安全的非对称密码系统</a>。</p><h1 id="d55d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">假设案例研究</h1><p id="17e4" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">假设你是SaaS一家公司的安全工程师，该公司提供云文档存储。您的云运行来自某个供应商的第三方专有软件堆栈。系统中的所有文档都按其id进行索引，这些id是在文档首次上传时生成的。您的第三方软件供应商认为，为文档生成这个ID的最简单方法是计算它的<strong class="kf ir"> SHA-1值</strong>。</p><p id="e7a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一天你来到办公室，看到一片混乱:世界不再一样了，因为<a class="ae kc" href="https://shattered.io/" rel="noopener ugc nofollow" target="_blank"> SHA-1在实践中被正式宣布破</a>(这部分是真的！).您的公司联系供应商提供修补程序，但是，正如供应商经常发生的那样，他们要么说需要几个月或几年才能提供修补程序，要么说攻击“不适用于软件安全模型”。无论哪种方式，你的公司不同意，你的工作是提供一个补丁，而企业正在寻找替代方案。</p><h1 id="694f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">工具分析</h1><p id="ad51" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我们之前一致认为第三方供应商软件是专有的，但出于本练习的目的(因此您可以在家里编译并运行它)，这里是假设工具的源代码版本:</p><p id="7a33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> customhash.c: </em></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="3fe6" class="nc ld iq my b gy nd ne l nf ng"><strong class="my ir">#include &lt;stdio.h&gt;<br/>#include &lt;errno.h&gt;<br/></strong><br/><strong class="my ir">#include &lt;openssl/evp.h&gt;<br/>#include &lt;openssl/sha.h&gt;<br/></strong><br/><strong class="my ir">static</strong> <strong class="my ir">int</strong> <strong class="my ir">hash</strong>(<strong class="my ir">FILE</strong> <strong class="my ir">*</strong>f)<br/>{<br/>    <strong class="my ir">int</strong> err, i;<br/>    <strong class="my ir">unsigned</strong> <strong class="my ir">char</strong> md[SHA_DIGEST_LENGTH];<br/>    <strong class="my ir">unsigned</strong> <strong class="my ir">int</strong> md_size;<br/>    <br/>    <strong class="my ir">unsigned</strong> <strong class="my ir">char</strong> buf[4096], <strong class="my ir">*</strong>pos;<br/>    <strong class="my ir">size_t</strong> bytes_read;<br/><br/>    pos <strong class="my ir">=</strong> buf;<br/>    bytes_read <strong class="my ir">=</strong> fread(buf, 1, buf <strong class="my ir">+</strong> <strong class="my ir">sizeof</strong>(buf) <strong class="my ir">-</strong> pos, f);<br/>    <strong class="my ir">while</strong> (bytes_read <strong class="my ir">&amp;&amp;</strong> pos <strong class="my ir">&lt;</strong> (buf <strong class="my ir">+</strong> <strong class="my ir">sizeof</strong>(buf)))<br/>    {<br/>        pos <strong class="my ir">+=</strong> bytes_read;<br/>        bytes_read <strong class="my ir">=</strong> fread(buf, 1, buf <strong class="my ir">+</strong> <strong class="my ir">sizeof</strong>(buf) <strong class="my ir">-</strong> pos, f);<br/>    }<br/>    <br/>    <strong class="my ir">if</strong> (<strong class="my ir">!</strong>feof(f))<br/>    {<br/>        errno <strong class="my ir">=</strong> EIO;<br/>        <strong class="my ir">return</strong> errno;<br/>    }<br/>    <br/>    <strong class="my ir">if</strong> (<strong class="my ir">!</strong>EVP_Digest(buf, pos <strong class="my ir">-</strong> buf, md, <strong class="my ir">&amp;</strong>md_size, EVP_sha1(), NULL))<br/>    {<br/>        errno <strong class="my ir">=</strong> EFAULT;<br/>        <strong class="my ir">return</strong> errno;<br/>    }<br/><br/>    <strong class="my ir">for</strong> (i <strong class="my ir">=</strong> 0; i <strong class="my ir">&lt;</strong> md_size; i<strong class="my ir">++</strong>)<br/>        printf("%02x", md[i]);<br/>    puts("");<br/>    <br/>    <strong class="my ir">return</strong> 0;<br/>}<br/><strong class="my ir">int</strong> <strong class="my ir">main</strong>(<strong class="my ir">int</strong> argc, <strong class="my ir">char</strong> <strong class="my ir">**</strong>argv)<br/>{<br/>    <strong class="my ir">int</strong> err;<br/>    <strong class="my ir">FILE</strong> <strong class="my ir">*</strong>f <strong class="my ir">=</strong> stdin;<br/>    <strong class="my ir">if</strong> (argc <strong class="my ir">&gt;</strong> 1) {<br/>        f <strong class="my ir">=</strong> fopen(argv[1], "rb");<br/>        <strong class="my ir">if</strong> (<strong class="my ir">!</strong>f) {<br/>            perror(NULL);<br/>            <strong class="my ir">return</strong> errno;<br/>        }<br/>    }<br/>    <br/>    err <strong class="my ir">=</strong> hash(f);<br/>    <strong class="my ir">if</strong> (err)<br/>        perror(NULL);<br/><br/>    <strong class="my ir">if</strong> (argc <strong class="my ir">&gt;</strong> 1)<br/>        fclose(f);<br/><br/>    <strong class="my ir">return</strong> err;<br/>}</span></pre><p id="8a53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，简而言之，该工具只是将文件的内容读入缓冲区，并计算其SHA-1。让我们通过将其输出与众所周知的SHA-1实现进行比较来验证它的工作情况:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7e45" class="nc ld iq my b gy nd ne l nf ng">$ gcc -o customhash customhash.c -lcrypto<br/>$ echo abc | ./customhash<br/>03cfd743661f07975fa2f1220c5194cbaff48451<br/>$ echo abc | sha1sum<br/>03cfd743661f07975fa2f1220c5194cbaff48451  -</span></pre><p id="688d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确实有效。但是请记住:这个工具不是我们自己编译的——它是专有的。但是，我们可以检查该工具是静态链接还是动态链接，以及在后一种情况下它使用什么库:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="6198" class="nc ld iq my b gy nd ne l nf ng">$ ldd ./customhash<br/>	linux-vdso.so.1 (0x00007ffc26bea000)<br/>	libcrypto.so.1.1 =&gt; /lib/x86_64-linux-gnu/libcrypto.so.1.1 (0x00007f6350798000)<br/>	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f63505d7000)<br/>	libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f63505d2000)<br/>	libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f63505b1000)<br/>	/lib64/ld-linux-x86-64.so.2 (0x00007f6350a94000)</span></pre><p id="5859" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们很幸运:它是动态链接的，并且使用了<a class="ae kc" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> OpenSSL </a>。我们在这篇文章中关注OpenSSL的原因是因为OpenSSL是许多应用程序，甚至是专有应用程序中事实上的加密库，因为它的成熟性和许可性。</p><h1 id="f099" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">用LD_PRELOAD挂钩加密</h1><p id="5d6c" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">是修改动态链接应用程序行为的强大工具:通过定义一个环境变量和编写一些代码，几乎可以覆盖任何库函数。在我们的例子中，我们希望用更安全的SHA-256来替换我们玩具专有工具中的SHA-1计算。但是首先我们需要实际知道“挂钩”哪个函数(替换它):</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4ab3" class="nc ld iq my b gy nd ne l nf ng">$ nm -D ./customhash | grep 'U '<br/>                 U __errno_location<br/>                 U EVP_Digest<br/>                 U EVP_sha1<br/>                 U fclose<br/>                 U feof<br/>                 U fopen<br/>                 U fread<br/>                 U __libc_start_main<br/>                 U perror<br/>                 U printf<br/>                 U puts</span></pre><p id="1043" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的命令从链接的动态库中输出我们的<code class="fe nh ni nj my b">customhash</code>工具使用的所有函数(“U”可能代表“uses”)。大多数函数来自于<code class="fe nh ni nj my b">libc</code>，但是<code class="fe nh ni nj my b">EVP_Digest</code>和<code class="fe nh ni nj my b">EVP_sha1</code>来自于OpenSSL(如果我们用谷歌搜索这些，我们会被引导到OpenSSL在线手册页)。在这一点上，我们需要写一个小的动态库，它用相同的签名导出相同的函数，但是计算SHA-256。事实上，我们只需要替换<code class="fe nh ni nj my b">EVP_Digest</code>，因为<code class="fe nh ni nj my b">EVP_sha1</code>只返回内部的OpenSSL SHA-1算法ID。一个潜在的实现可能如下所示:</p><p id="ef92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> cryptofix.c: </em></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="dccb" class="nc ld iq my b gy nd ne l nf ng"><strong class="my ir">#define _GNU_SOURCE </strong><em class="lb">/* for RTLD_NEXT */</em><strong class="my ir"><br/>#include &lt;dlfcn.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/></strong><br/><strong class="my ir">#include &lt;openssl/evp.h&gt;<br/>#include &lt;openssl/sha.h&gt;<br/></strong><br/><strong class="my ir">int</strong> <strong class="my ir">EVP_Digest</strong>(<strong class="my ir">const</strong> <strong class="my ir">void</strong> <strong class="my ir">*</strong>data, <strong class="my ir">size_t</strong> count, <strong class="my ir">unsigned</strong> <strong class="my ir">char</strong> <strong class="my ir">*</strong>md, <strong class="my ir">unsigned</strong> <strong class="my ir">int</strong> <strong class="my ir">*</strong>size, <strong class="my ir">const</strong> EVP_MD <strong class="my ir">*</strong>type, ENGINE <strong class="my ir">*</strong>impl)<br/>{<br/>    <strong class="my ir">unsigned</strong> <strong class="my ir">char</strong> sha256_md[SHA256_DIGEST_LENGTH];<br/>    <strong class="my ir">unsigned</strong> <strong class="my ir">int</strong> sha256_md_size, err;<br/><br/>    <strong class="my ir">static</strong> <strong class="my ir">int</strong> (<strong class="my ir">*</strong>real_fn)(<strong class="my ir">const</strong> <strong class="my ir">void</strong> <strong class="my ir">*</strong>data, <strong class="my ir">size_t</strong> count, <strong class="my ir">unsigned</strong> <strong class="my ir">char</strong> <strong class="my ir">*</strong>md, <strong class="my ir">unsigned</strong> <strong class="my ir">int</strong> <strong class="my ir">*</strong>size, <strong class="my ir">const</strong> EVP_MD <strong class="my ir">*</strong>type, ENGINE <strong class="my ir">*</strong>impl) <strong class="my ir">=</strong> NULL;<br/>    <strong class="my ir">if</strong> (<strong class="my ir">!</strong>real_fn)<br/>    {<br/>        real_fn <strong class="my ir">=</strong> dlsym(RTLD_NEXT, "EVP_Digest");<br/>        <strong class="my ir">if</strong> (<strong class="my ir">!</strong>real_fn)<br/>        {<br/>            fputs("cannot find EVP_Digest", stderr);<br/>            exit(1);<br/>        }<br/>    }<br/>    <br/>    <strong class="my ir">if</strong> (type <strong class="my ir">==</strong> EVP_sha1())<br/>    {<br/>        err <strong class="my ir">=</strong> real_fn(data, count, sha256_md, <strong class="my ir">&amp;</strong>sha256_md_size, EVP_sha256(), impl);<br/>        fputs("replacing SHA1 with SHA256\n", stderr);<br/>        memcpy(md, sha256_md, SHA_DIGEST_LENGTH);<br/>        <strong class="my ir">*</strong>size <strong class="my ir">=</strong> SHA_DIGEST_LENGTH;<br/>        <strong class="my ir">return</strong> err;<br/>    }<br/>    <strong class="my ir">else</strong><br/>        <strong class="my ir">return</strong> real_fn(data, count, md, size, type, impl);<br/>}</span></pre><p id="59d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面的实现中有一些事情需要注意:首先，我们需要得到一个指向真正的OpenSSL <code class="fe nh ni nj my b">EVP_Digest</code>函数的指针，这样我们就可以转发对它的调用。我们使用<code class="fe nh ni nj my b">libdl</code>中的技巧获得地址。这是必要的，因为<code class="fe nh ni nj my b">EVP_Digest</code>是一个包装函数，它计算OpenSSL支持的任何散列算法。所以我们不能用阿沙-256实现来代替它，因为调用应用程序可能同时依赖不同的哈希算法，并对所有算法使用相同的函数。因此，在我们的实现中，我们“过滤掉”请求SHA-1计算的调用，并按原样传递其余的调用。</p><p id="7fb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，我们不想自己编写阿沙-256实现。我们已经知道应用程序正在使用OpenSSL，所以当我们的代码运行时，我们可以访问进程地址空间中的OpenSSL库。而且，我们已经有了从上面获得的OpenSSL <code class="fe nh ni nj my b">EVP_Digest</code>地址，所以我们只需要调用OpenSSL来为我们计算SHA-256。</p><p id="a101" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，SHA-1的输出只有20个字节，但是SHA-256产生了32个字节。OpenSSL将结果返回给调用者分配的缓冲区，但此时我们不能假设调用应用程序分配了足够的内存来存储完整的SHA-256结果，因为它预期的是阿沙-1哈希。为了安全起见，并且不引入缓冲区溢出，在将结果返回给调用者之前，我们将从计算的SHA-256中去掉额外的12个字节。一些安全研究可能认为截断散列结果会降低安全性，并且它们将是正确的。然而，对于这个用例，使用具有截断结果的安全散列算法比不安全散列算法更安全。</p><p id="7144" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们检查一下是否一切正常:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="9810" class="nc ld iq my b gy nd ne l nf ng">$ gcc -shared -fPIC -o cryptofix.so ;.c<br/>$ echo abc | LD_PRELOAD=./cryptofix.so ./customhash<br/>replacing SHA1 with SHA256<br/>edeaaff3f1774ad2888673770c6d64097e391bc3<br/>$ echo abc | sha256sum<br/>edeaaff3f1774ad2888673770c6d64097e391bc362d7d6fb34982ddf0efd18cb  -</span></pre><p id="2209" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">万岁！我们成功地用更强的SHA-256替换了弱SHA-1，而没有触及原始应用程序中的任何代码。</p><h1 id="3ccd" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">供应商反击了</h1><p id="b5a4" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">虽然供应商可能会找到理由拒绝修复我们不安全的算法，但他们有义务修复错误。如果我们检查我们的toy <code class="fe nh ni nj my b">customhash.c</code>工具，我们可能会注意到它有一个缺陷:它不能计算大于4096字节的文件的散列，因为在<code class="fe nh ni nj my b">hash</code>函数中有静态缓冲区:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="d1d3" class="nc ld iq my b gy nd ne l nf ng">$ printf 'a%.0s' {1..4095} | ./customhash<br/>10236568a284fb3733bd87c15280af95bd528839<br/>$ printf 'a%.0s' {1..4096} | ./customhash<br/>Input/output error</span></pre><p id="02dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以供应商修复了它，并交付了更新的工具(因为他们的代码很好地解耦了，他们保留了<code class="fe nh ni nj my b">main</code>功能，只是用相同的原型重写了<code class="fe nh ni nj my b">hash</code>功能的实现):</p><p id="cf0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> customhashv2.c: </em></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="ba8d" class="nc ld iq my b gy nd ne l nf ng">...<br/><strong class="my ir">static</strong> <strong class="my ir">int</strong> <strong class="my ir">hash</strong>(<strong class="my ir">FILE</strong> <strong class="my ir">*</strong>f)<br/>{<br/>    <strong class="my ir">int</strong> err, i;<br/>    <strong class="my ir">unsigned</strong> <strong class="my ir">char</strong> md[SHA_DIGEST_LENGTH];<br/>    <strong class="my ir">unsigned</strong> <strong class="my ir">int</strong> md_size;<br/>    <br/>    <strong class="my ir">unsigned</strong> <strong class="my ir">char</strong> buf[256];<br/>    <strong class="my ir">size_t</strong> bytes_read;<br/><br/>    EVP_MD_CTX <strong class="my ir">*</strong>ctx <strong class="my ir">=</strong> EVP_MD_CTX_new();<br/>    <strong class="my ir">if</strong> (<strong class="my ir">!</strong>ctx)<br/>    {<br/>        errno <strong class="my ir">=</strong> ENOMEM;<br/>        <strong class="my ir">return</strong> errno;<br/>    }<br/>    <br/>    <strong class="my ir">if</strong> (<strong class="my ir">!</strong>EVP_DigestInit(ctx, EVP_sha1()))<br/>    {<br/>        EVP_MD_CTX_free(ctx);<br/>        errno <strong class="my ir">=</strong> EFAULT;<br/>        <strong class="my ir">return</strong> errno;<br/>    }<br/><br/>    bytes_read <strong class="my ir">=</strong> fread(buf, 1, <strong class="my ir">sizeof</strong>(buf), f);<br/>    <strong class="my ir">while</strong> (bytes_read)<br/>    {<br/>        <strong class="my ir">if</strong> (<strong class="my ir">!</strong>EVP_DigestUpdate(ctx, buf, bytes_read))<br/>        {<br/>            EVP_MD_CTX_free(ctx);<br/>            errno <strong class="my ir">=</strong> EFAULT;<br/>            <strong class="my ir">return</strong> errno;<br/>        }<br/>        bytes_read <strong class="my ir">=</strong> fread(buf, 1, <strong class="my ir">sizeof</strong>(buf), f);<br/>    }<br/>    <br/>    <strong class="my ir">if</strong> (<strong class="my ir">!</strong>feof(f))<br/>    {<br/>        EVP_MD_CTX_free(ctx);<br/>        errno <strong class="my ir">=</strong> EIO;<br/>        <strong class="my ir">return</strong> errno;<br/>    }<br/>    <br/>    <strong class="my ir">if</strong> (<strong class="my ir">!</strong>EVP_DigestFinal(ctx, md, <strong class="my ir">&amp;</strong>md_size))<br/>    {<br/>        EVP_MD_CTX_free(ctx);<br/>        errno <strong class="my ir">=</strong> EFAULT;<br/>        <strong class="my ir">return</strong> errno;<br/>    }<br/><br/>    <strong class="my ir">for</strong> (i <strong class="my ir">=</strong> 0; i <strong class="my ir">&lt;</strong> md_size; i<strong class="my ir">++</strong>)<br/>        printf("%02x", md[i]);<br/>    puts("");<br/>    <br/>    <strong class="my ir">return</strong> 0;<br/>}<br/>...</span></pre><p id="0b2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们检查一下它是否有效:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="a3e5" class="nc ld iq my b gy nd ne l nf ng">$ gcc -o customhashv2 customhashv2.c -lcrypto<br/>$ echo abc | ./customhashv2<br/>03cfd743661f07975fa2f1220c5194cbaff48451<br/>$ echo abc | sha1sum<br/>03cfd743661f07975fa2f1220c5194cbaff48451  -<br/>$ printf 'a%.0s' {1..4096} | ./customhashv2<br/>8c51fb6a0b587ec95ca74acfa43df7539b486297<br/>$ printf 'a%.0s' {1..4096} | sha1sum<br/>8c51fb6a0b587ec95ca74acfa43df7539b486297  -</span></pre><p id="7afe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好！漏洞已经修复，但我们的黑客工作:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="72b8" class="nc ld iq my b gy nd ne l nf ng">$ echo abc | LD_PRELOAD=./cryptofix.so ./customhashv2<br/>03cfd743661f07975fa2f1220c5194cbaff48451</span></pre><p id="4e74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们再也看不到“用SHA256替换SHA1”的消息，新工具可以清楚地计算SHA-1。这是因为更新后的工具使用了不同于OpenSSL的函数来完成它的工作，我们没有挂钩这些函数:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="8d65" class="nc ld iq my b gy nd ne l nf ng">$ nm -D ./customhashv2 | grep 'U '<br/>                 U __errno_location<br/>                 U EVP_DigestFinal<br/>                 U EVP_DigestInit<br/>                 U EVP_DigestUpdate<br/>                 U EVP_MD_CTX_free<br/>                 U EVP_MD_CTX_new<br/>                 U EVP_sha1<br/>                 U fclose<br/>                 U feof<br/>                 U fopen<br/>                 U fread<br/>                 U __libc_start_main<br/>                 U perror<br/>                 U printf<br/>                 U puts</span></pre><p id="6411" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了支持任意长度的文件，该工具现在使用一个接口，迭代地处理数据。但是我们需要更新我们的挂钩库:</p><p id="7883" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> cryptofixv2.c: </em></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="9ee8" class="nc ld iq my b gy nd ne l nf ng"><strong class="my ir">#define _GNU_SOURCE </strong><em class="lb">/* for RTLD_NEXT */</em><strong class="my ir"><br/>#include &lt;dlfcn.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/></strong><br/><strong class="my ir">#include &lt;openssl/evp.h&gt;<br/>#include &lt;openssl/sha.h&gt;<br/></strong><br/><strong class="my ir">int</strong> <strong class="my ir">EVP_DigestInit</strong>(EVP_MD_CTX <strong class="my ir">*</strong>ctx, <strong class="my ir">const</strong> EVP_MD <strong class="my ir">*</strong>type)<br/>{<br/>    <strong class="my ir">static</strong> <strong class="my ir">int</strong> (<strong class="my ir">*</strong>real_fn)(EVP_MD_CTX <strong class="my ir">*</strong>ctx, <strong class="my ir">const</strong> EVP_MD <strong class="my ir">*</strong>type) <strong class="my ir">=</strong> NULL;<br/>    <strong class="my ir">if</strong> (<strong class="my ir">!</strong>real_fn)<br/>    {<br/>        real_fn <strong class="my ir">=</strong> dlsym(RTLD_NEXT, "EVP_DigestInit");<br/>        <strong class="my ir">if</strong> (<strong class="my ir">!</strong>real_fn)<br/>        {<br/>            fputs("cannot find EVP_DigestInit", stderr);<br/>            exit(1);<br/>        }<br/>    }<br/>    <br/>    <strong class="my ir">if</strong> (type <strong class="my ir">==</strong> EVP_sha1())<br/>        <strong class="my ir">return</strong> real_fn(ctx, EVP_sha256());<br/>    <strong class="my ir">else</strong><br/>        <strong class="my ir">return</strong> real_fn(ctx, type);<br/>}<br/><br/><strong class="my ir">int</strong> <strong class="my ir">EVP_DigestFinal</strong>(EVP_MD_CTX <strong class="my ir">*</strong>ctx, <strong class="my ir">unsigned</strong> <strong class="my ir">char</strong> <strong class="my ir">*</strong>md, <strong class="my ir">unsigned</strong> <strong class="my ir">int</strong> <strong class="my ir">*</strong>s)<br/>{<br/>    <strong class="my ir">static</strong> <strong class="my ir">int</strong> (<strong class="my ir">*</strong>real_fn)(EVP_MD_CTX <strong class="my ir">*</strong>ctx, <strong class="my ir">unsigned</strong> <strong class="my ir">char</strong> <strong class="my ir">*</strong>md, <strong class="my ir">unsigned</strong> <strong class="my ir">int</strong> <strong class="my ir">*</strong>s) <strong class="my ir">=</strong> NULL;<br/>    <strong class="my ir">if</strong> (<strong class="my ir">!</strong>real_fn)<br/>    {<br/>        real_fn <strong class="my ir">=</strong> dlsym(RTLD_NEXT, "EVP_DigestFinal");<br/>        <strong class="my ir">if</strong> (<strong class="my ir">!</strong>real_fn)<br/>        {<br/>            fputs("cannot find EVP_DigestFinal", stderr);<br/>            exit(1);<br/>        }<br/>    }<br/><br/>    <strong class="my ir">if</strong> (EVP_MD_CTX_md(ctx) <strong class="my ir">==</strong> EVP_sha256())<br/>    {<br/>        <strong class="my ir">unsigned</strong> <strong class="my ir">char</strong> sha256_md[SHA256_DIGEST_LENGTH];<br/>        <strong class="my ir">unsigned</strong> <strong class="my ir">int</strong> sha256_md_size, err;<br/>        <br/>        err <strong class="my ir">=</strong> real_fn(ctx, sha256_md, <strong class="my ir">&amp;</strong>sha256_md_size);<br/>        fputs("replacing SHA1 with SHA256\n", stderr);<br/>        memcpy(md, sha256_md, SHA_DIGEST_LENGTH);<br/>        <strong class="my ir">*</strong>s <strong class="my ir">=</strong> SHA_DIGEST_LENGTH;<br/>        <strong class="my ir">return</strong> err;<br/>    }<br/>    <strong class="my ir">else</strong><br/>        <strong class="my ir">return</strong> real_fn(ctx, md, s);<br/>}</span></pre><p id="66f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们挂钩两个函数:</p><ul class=""><li id="e423" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">和以前一样，在<code class="fe nh ni nj my b">EVP_DigestInit</code>中，我们检测调用者何时请求SHA-1计算，而不是从OpenSSL请求SHA-256计算</li><li id="e5e2" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">在<code class="fe nh ni nj my b">EVP_DigestFinal</code>中，我们将任何SHA-256计算的结果截断为20个字节，并将结果返回给调用者</li></ul><p id="dbc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简单起见，这个实现假设调用应用程序从不自己请求SHA-256散列计算。如果不是这样，挂钩库可能会变得更加复杂，因为我们必须以某种方式(例如，在集合中)跟踪我们在<code class="fe nh ni nj my b">EVP_DigestInit</code>中“修补”的OpenSSL上下文对象，所以我们只在<code class="fe nh ni nj my b">EVP_DigestFinal</code>中截断原始的SHA-1结果。</p><p id="c9f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查它是否工作:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="2274" class="nc ld iq my b gy nd ne l nf ng">$ gcc -shared -fPIC -o cryptofixv2.so cryptofixv2.c<br/>$ echo abc | LD_PRELOAD=./cryptofixv2.so ./customhashv2<br/>replacing SHA1 with SHA256<br/>edeaaff3f1774ad2888673770c6d64097e391bc3<br/>$ echo abc | sha256sum<br/>edeaaff3f1774ad2888673770c6d64097e391bc362d7d6fb34982ddf0efd18cb  -</span></pre><p id="3db9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，我们没事了！我们涵盖了所有可能的情况吗？这是供应商提供的另一个潜在更新:</p><p id="3475" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> customhashv3.c: </em></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="1f08" class="nc ld iq my b gy nd ne l nf ng">...<br/><strong class="my ir">static</strong> <strong class="my ir">int</strong> <strong class="my ir">hash</strong>(<strong class="my ir">FILE</strong> <strong class="my ir">*</strong>f)<br/>{<br/>    <strong class="my ir">int</strong> err, i;<br/>    <strong class="my ir">unsigned</strong> <strong class="my ir">char</strong> md[SHA_DIGEST_LENGTH];<br/>    <strong class="my ir">unsigned</strong> <strong class="my ir">int</strong> md_size <strong class="my ir">=</strong> <strong class="my ir">sizeof</strong>(md);<br/>    <br/>    <strong class="my ir">unsigned</strong> <strong class="my ir">char</strong> buf[256];<br/>    <strong class="my ir">int</strong> bytes_read;<br/>    <br/>    BIO <strong class="my ir">*</strong>filebio, <strong class="my ir">*</strong>sha1bio;<br/><br/>    filebio <strong class="my ir">=</strong> BIO_new_fp(f, BIO_NOCLOSE);<br/>    <strong class="my ir">if</strong> (<strong class="my ir">!</strong>filebio)<br/>    {<br/>        errno <strong class="my ir">=</strong> ENOMEM;<br/>        <strong class="my ir">return</strong> errno;<br/>    }<br/>    <br/>    sha1bio <strong class="my ir">=</strong> BIO_new(BIO_f_md());<br/>    <strong class="my ir">if</strong> (<strong class="my ir">!</strong>sha1bio)<br/>    {<br/>        BIO_free(filebio);<br/>        errno <strong class="my ir">=</strong> ENOMEM;<br/>        <strong class="my ir">return</strong> errno;<br/>    }<br/><br/>    BIO_set_md(sha1bio, EVP_sha1());<br/>    BIO_push(sha1bio, filebio);<br/><br/>    bytes_read <strong class="my ir">=</strong> BIO_read(sha1bio, buf, <strong class="my ir">sizeof</strong>(buf));<br/>    <strong class="my ir">while</strong> (bytes_read <strong class="my ir">&gt;</strong> 0)<br/>    {<br/>        bytes_read <strong class="my ir">=</strong> BIO_read(sha1bio, buf, <strong class="my ir">sizeof</strong>(buf));<br/>    }<br/>    <br/>    <strong class="my ir">if</strong> (bytes_read <strong class="my ir">&lt;</strong> 0)<br/>    {<br/>        BIO_free_all(sha1bio);<br/>        errno <strong class="my ir">=</strong> EIO;<br/>        <strong class="my ir">return</strong> errno;<br/>    }<br/><br/>    <strong class="my ir">if</strong> (BIO_gets(sha1bio, md, <strong class="my ir">sizeof</strong>(md)) <strong class="my ir">&lt;=</strong> 0)<br/>    {<br/>        BIO_free_all(sha1bio);<br/>        errno <strong class="my ir">=</strong> EFAULT;<br/>        <strong class="my ir">return</strong> errno;<br/>    }<br/><br/>    BIO_free_all(sha1bio);<br/><br/>    <strong class="my ir">for</strong> (i <strong class="my ir">=</strong> 0; i <strong class="my ir">&lt;</strong> md_size; i<strong class="my ir">++</strong>)<br/>        printf("%02x", md[i]);<br/>    puts("");<br/>    <br/>    <strong class="my ir">return</strong> 0;<br/>}<br/>...</span></pre><p id="1c7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的工作原理和前面的一样:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="f560" class="nc ld iq my b gy nd ne l nf ng">$ gcc -o customhashv3 customhashv3.c -lcrypto<br/>$ echo abc | ./customhashv3<br/>03cfd743661f07975fa2f1220c5194cbaff48451</span></pre><p id="21d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，我们可能已经猜到我们的挂钩库将不再工作，只需看看:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="2b42" class="nc ld iq my b gy nd ne l nf ng">$ nm -D ./customhashv3 | grep 'U '<br/>                 U BIO_ctrl<br/>                 U BIO_f_md<br/>                 U BIO_free<br/>                 U BIO_free_all<br/>                 U BIO_gets<br/>                 U BIO_new<br/>                 U BIO_new_fp<br/>                 U BIO_push<br/>                 U BIO_read<br/>                 U __errno_location<br/>                 U EVP_sha1<br/>                 U fclose<br/>                 U fopen<br/>                 U __libc_start_main<br/>                 U perror<br/>                 U printf<br/>                 U puts</span></pre><p id="b9be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用应用程序使用另一组函数调用来计算SHA-1摘要，我们必须想出一个新的解决方案:</p><p id="3c9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> cryptofixv3.c: </em></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="49b4" class="nc ld iq my b gy nd ne l nf ng"><strong class="my ir">#define _GNU_SOURCE </strong><em class="lb">/* for RTLD_NEXT */</em><strong class="my ir"><br/>#include &lt;dlfcn.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#include &lt;string.h&gt;<br/></strong><br/><strong class="my ir">#include &lt;openssl/evp.h&gt;<br/>#include &lt;openssl/sha.h&gt;<br/></strong><br/><strong class="my ir">long</strong> <strong class="my ir">BIO_ctrl</strong>(BIO <strong class="my ir">*</strong>bp, <strong class="my ir">int</strong> cmd, <strong class="my ir">long</strong> larg, <strong class="my ir">void</strong> <strong class="my ir">*</strong>parg)<br/>{<br/>    <strong class="my ir">static</strong> <strong class="my ir">long</strong> (<strong class="my ir">*</strong>real_fn)(BIO <strong class="my ir">*</strong>bp, <strong class="my ir">int</strong> cmd, <strong class="my ir">long</strong> larg, <strong class="my ir">void</strong> <strong class="my ir">*</strong>parg) <strong class="my ir">=</strong> NULL;<br/>    <strong class="my ir">if</strong> (<strong class="my ir">!</strong>real_fn)<br/>    {<br/>        real_fn <strong class="my ir">=</strong> dlsym(RTLD_NEXT, "BIO_ctrl");<br/>        <strong class="my ir">if</strong> (<strong class="my ir">!</strong>real_fn)<br/>        {<br/>            fputs("cannot find BIO_ctrl", stderr);<br/>            exit(1);<br/>        }<br/>    }<br/>    <br/>    <strong class="my ir">if</strong> (cmd <strong class="my ir">==</strong> BIO_C_SET_MD <strong class="my ir">&amp;&amp;</strong> parg <strong class="my ir">==</strong> EVP_sha1())<br/>        <strong class="my ir">return</strong> real_fn(bp, cmd, larg, (<strong class="my ir">void</strong> <strong class="my ir">*</strong>)EVP_sha256());<br/>    <strong class="my ir">else</strong><br/>        <strong class="my ir">return</strong> real_fn(bp, cmd, larg, parg);<br/>}<br/><br/><strong class="my ir">int</strong> <strong class="my ir">BIO_gets</strong>(BIO <strong class="my ir">*</strong>bp, <strong class="my ir">char</strong> <strong class="my ir">*</strong>buf, <strong class="my ir">int</strong> size)<br/>{<br/>    EVP_MD <strong class="my ir">*</strong>md <strong class="my ir">=</strong> NULL;<br/>    <strong class="my ir">static</strong> <strong class="my ir">int</strong> (<strong class="my ir">*</strong>real_fn)(BIO <strong class="my ir">*</strong>bp, <strong class="my ir">char</strong> <strong class="my ir">*</strong>buf, <strong class="my ir">int</strong> size) <strong class="my ir">=</strong> NULL;<br/>    <strong class="my ir">if</strong> (<strong class="my ir">!</strong>real_fn)<br/>    {<br/>        real_fn <strong class="my ir">=</strong> dlsym(RTLD_NEXT, "BIO_gets");<br/>        <strong class="my ir">if</strong> (<strong class="my ir">!</strong>real_fn)<br/>        {<br/>            fputs("cannot find BIO_gets", stderr);<br/>            exit(1);<br/>        }<br/>    }<br/><br/>    <strong class="my ir">if</strong> (BIO_method_type(bp) <strong class="my ir">==</strong> BIO_TYPE_MD <strong class="my ir">&amp;&amp;</strong> BIO_get_md(bp, <strong class="my ir">&amp;</strong>md))<br/>    {<br/>        <strong class="my ir">if</strong> (md <strong class="my ir">==</strong> EVP_sha256()) {<br/>            <strong class="my ir">char</strong> sha256_md[SHA256_DIGEST_LENGTH];<br/>            <strong class="my ir">int</strong> err;<br/>    <br/>            <strong class="my ir">if</strong> (size <strong class="my ir">&lt;</strong> SHA_DIGEST_LENGTH)<br/>                <strong class="my ir">return</strong> 0;<br/>        <br/>            err <strong class="my ir">=</strong> real_fn(bp, sha256_md, <strong class="my ir">sizeof</strong>(sha256_md));<br/>            fputs("replacing SHA1 with SHA256\n", stderr);<br/>            memcpy(buf, sha256_md, size);<br/>            <strong class="my ir">return</strong> err;<br/>        }<br/>    }<br/><br/>    <strong class="my ir">return</strong> real_fn(bp, buf, size);<br/>}</span></pre><p id="c754" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由读者来验证上面的代码是否有效，但值得注意的是，它受到与<code class="fe nh ni nj my b">v2</code>相同的限制和假设。</p><p id="8eca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一点上，很明显OpenSSL有一个相当多样化的API，同样的事情可以用许多不同的方式实现。这使得OpenSSL算法很难挂钩，因为几乎不可能考虑所有情况和组合。</p><h1 id="ae59" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">OpenSSL引擎拯救世界</h1><p id="f88b" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">虽然我们不能为任何加密库提供可靠的算法替换，但如果应用程序使用OpenSSL，我们可以用<a class="ae kc" href="https://github.com/openssl/openssl/blob/master/README.ENGINE" rel="noopener ugc nofollow" target="_blank"> OpenSSL引擎</a>做得比上面更好。</p><p id="0e67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">OpenSSL引擎是任何人都可以编写的第三方扩展，以提供任何加密算法的自定义实现。它们主要用于两种情况:</p><ul class=""><li id="86ac" class="mf mg iq kf b kg kh kk kl ko mh ks mi kw mj la mk ml mm mn bi translated">将不同的硬件加密设备集成到OpenSSL和基于OpenSSL的应用程序中</li><li id="bcb0" class="mf mg iq kf b kg mo kk mp ko mq ks mr kw ms la mk ml mm mn bi translated">在OpenSSL中引入新的加密算法，并通过通用OpenSSL <code class="fe nh ni nj my b">EVP_x</code> API提供这些算法</li></ul><p id="3bce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们会滥用这个框架:我们将编写一个SHA-1算法的“替代”实现，它将进行SHA-256计算(下面的代码基于OpenSSL博客中的<a class="ae kc" href="https://www.openssl.org/blog/blog/2015/11/23/engine-building-lesson-2-an-example-md5-engine/" rel="noopener ugc nofollow" target="_blank">示例):</a></p><p id="e575" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> sha1-sha256.c: </em></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="d51c" class="nc ld iq my b gy nd ne l nf ng"><strong class="my ir">#include &lt;string.h&gt;<br/></strong><br/><strong class="my ir">#include &lt;openssl/engine.h&gt;<br/>#include &lt;openssl/evp.h&gt;<br/>#include &lt;openssl/sha.h&gt;<br/></strong><br/><strong class="my ir">static</strong> <strong class="my ir">const</strong> <strong class="my ir">char</strong> <strong class="my ir">*</strong>engine_id <strong class="my ir">=</strong> "sha1-sha256";<br/><strong class="my ir">static</strong> <strong class="my ir">const</strong> <strong class="my ir">char</strong> <strong class="my ir">*</strong>engine_name <strong class="my ir">=</strong><br/>    "An engine, which converts SHA1 to SHA256 for better security";<br/><br/><strong class="my ir">static</strong> <strong class="my ir">int</strong> <strong class="my ir">digest_init</strong>(EVP_MD_CTX <strong class="my ir">*</strong>ctx) {<br/>  <strong class="my ir">return</strong> SHA256_Init(EVP_MD_CTX_md_data(ctx));<br/>}<br/><br/><strong class="my ir">static</strong> <strong class="my ir">int</strong> <strong class="my ir">digest_update</strong>(EVP_MD_CTX <strong class="my ir">*</strong>ctx, <strong class="my ir">const</strong> <strong class="my ir">void</strong> <strong class="my ir">*</strong>data, <strong class="my ir">size_t</strong> count) {<br/>  <strong class="my ir">return</strong> SHA256_Update(EVP_MD_CTX_md_data(ctx), data, count);<br/>}<br/><br/><strong class="my ir">static</strong> <strong class="my ir">int</strong> <strong class="my ir">digest_final</strong>(EVP_MD_CTX <strong class="my ir">*</strong>ctx, <strong class="my ir">unsigned</strong> <strong class="my ir">char</strong> <strong class="my ir">*</strong>md) {<br/>  <strong class="my ir">char</strong> sha256_md[SHA256_DIGEST_LENGTH];<br/>  <strong class="my ir">int</strong> err;<br/><br/>  err <strong class="my ir">=</strong> SHA256_Final(sha256_md, EVP_MD_CTX_md_data(ctx));<br/>  fputs("replacing SHA1 with SHA256\n", stderr);<br/>  memcpy(md, sha256_md, SHA_DIGEST_LENGTH);<br/>  <strong class="my ir">return</strong> err;<br/>}<br/><br/><strong class="my ir">static</strong> EVP_MD <strong class="my ir">*</strong>digest_meth <strong class="my ir">=</strong> NULL;<br/><strong class="my ir">static</strong> <strong class="my ir">int</strong> digest_nids[] <strong class="my ir">=</strong> {NID_sha1, 0};<br/><strong class="my ir">static</strong> <strong class="my ir">int</strong> <strong class="my ir">digests</strong>(ENGINE <strong class="my ir">*</strong>e, <strong class="my ir">const</strong> EVP_MD <strong class="my ir">**</strong>digest, <strong class="my ir">const</strong> <strong class="my ir">int</strong> <strong class="my ir">**</strong>nids,<br/>                   <strong class="my ir">int</strong> nid) {<br/>  <strong class="my ir">if</strong> (<strong class="my ir">!</strong>digest) {<br/>    <strong class="my ir">*</strong>nids <strong class="my ir">=</strong> digest_nids;<br/>    <strong class="my ir">return</strong> (<strong class="my ir">sizeof</strong>(digest_nids) <strong class="my ir">-</strong> 1) <strong class="my ir">/</strong> <strong class="my ir">sizeof</strong>(digest_nids[0]);<br/>  }<br/>  <strong class="my ir">switch</strong> (nid) {<br/>  <strong class="my ir">case</strong> NID_sha1:<br/>    <strong class="my ir">if</strong> (digest_meth <strong class="my ir">==</strong> NULL) {<br/>      digest_meth <strong class="my ir">=</strong> EVP_MD_meth_new(NID_sha1, NID_sha1WithRSAEncryption);<br/>      <strong class="my ir">if</strong> (<strong class="my ir">!</strong>digest_meth) {<br/>        <strong class="my ir">return</strong> 0;<br/>      }<br/>      <strong class="my ir">if</strong> (<strong class="my ir">!</strong>EVP_MD_meth_set_result_size(digest_meth, SHA_DIGEST_LENGTH) <strong class="my ir">||</strong><br/>          <strong class="my ir">!</strong>EVP_MD_meth_set_flags(digest_meth, EVP_MD_FLAG_DIGALGID_ABSENT) <strong class="my ir">||</strong><br/>          <strong class="my ir">!</strong>EVP_MD_meth_set_init(digest_meth, digest_init) <strong class="my ir">||</strong><br/>          <strong class="my ir">!</strong>EVP_MD_meth_set_update(digest_meth, digest_update) <strong class="my ir">||</strong><br/>          <strong class="my ir">!</strong>EVP_MD_meth_set_final(digest_meth, digest_final) <strong class="my ir">||</strong><br/>          <strong class="my ir">!</strong>EVP_MD_meth_set_cleanup(digest_meth, NULL) <strong class="my ir">||</strong><br/>          <strong class="my ir">!</strong>EVP_MD_meth_set_ctrl(digest_meth, NULL) <strong class="my ir">||</strong><br/>          <strong class="my ir">!</strong>EVP_MD_meth_set_input_blocksize(digest_meth, SHA_CBLOCK) <strong class="my ir">||</strong><br/>          <strong class="my ir">!</strong>EVP_MD_meth_set_app_datasize(<br/>              digest_meth, <strong class="my ir">sizeof</strong>(EVP_MD <strong class="my ir">*</strong>) <strong class="my ir">+</strong> <strong class="my ir">sizeof</strong>(SHA256_CTX)) <strong class="my ir">||</strong><br/>          <strong class="my ir">!</strong>EVP_MD_meth_set_copy(digest_meth, NULL)) {<br/><br/>        <strong class="my ir">goto</strong> err;<br/>      }<br/>    }<br/>    <strong class="my ir">*</strong>digest <strong class="my ir">=</strong> digest_meth;<br/>    <strong class="my ir">return</strong> 1;<br/>  <strong class="my ir">default:</strong><br/>    <strong class="my ir">*</strong>digest <strong class="my ir">=</strong> NULL;<br/>    <strong class="my ir">return</strong> 0;<br/>  }<br/><br/><strong class="my ir">err:</strong><br/>  <strong class="my ir">if</strong> (digest_meth) {<br/>    EVP_MD_meth_free(digest_meth);<br/>    digest_meth <strong class="my ir">=</strong> NULL;<br/>  }<br/>  <strong class="my ir">return</strong> 0;<br/>}<br/><br/><strong class="my ir">static</strong> <strong class="my ir">int</strong> <strong class="my ir">engine_init</strong>(ENGINE <strong class="my ir">*</strong>e) {<br/>  <strong class="my ir">return</strong> 1;<br/>}<br/><br/><strong class="my ir">static</strong> <strong class="my ir">int</strong> <strong class="my ir">engine_finish</strong>(ENGINE <strong class="my ir">*</strong>e) {<br/>  <strong class="my ir">if</strong> (digest_meth) {<br/>    EVP_MD_meth_free(digest_meth);<br/>    digest_meth <strong class="my ir">=</strong> NULL;<br/>  }<br/>  <strong class="my ir">return</strong> 1;<br/>}<br/><br/><strong class="my ir">static</strong> <strong class="my ir">int</strong> <strong class="my ir">bind</strong>(ENGINE <strong class="my ir">*</strong>e, <strong class="my ir">const</strong> <strong class="my ir">char</strong> <strong class="my ir">*</strong>id) {<br/>  <strong class="my ir">if</strong> (<strong class="my ir">!</strong>ENGINE_set_id(e, engine_id)) {<br/>    <strong class="my ir">goto</strong> err;<br/>  }<br/>  <strong class="my ir">if</strong> (<strong class="my ir">!</strong>ENGINE_set_name(e, engine_name)) {<br/>    <strong class="my ir">goto</strong> err;<br/>  }<br/>  <strong class="my ir">if</strong> (<strong class="my ir">!</strong>ENGINE_set_init_function(e, engine_init)) {<br/>    <strong class="my ir">goto</strong> err;<br/>  }<br/>  <strong class="my ir">if</strong> (<strong class="my ir">!</strong>ENGINE_set_finish_function(e, engine_finish)) {<br/>    <strong class="my ir">goto</strong> err;<br/>  }<br/>  <strong class="my ir">if</strong> (<strong class="my ir">!</strong>ENGINE_set_digests(e, digests)) {<br/>    <strong class="my ir">goto</strong> err;<br/>  }<br/>  <strong class="my ir">return</strong> 1;<br/><strong class="my ir">err:</strong><br/>  <strong class="my ir">return</strong> 0;<br/>}<br/><br/>IMPLEMENT_DYNAMIC_BIND_FN(bind)<br/>IMPLEMENT_DYNAMIC_CHECK_FN()</span></pre><p id="1cfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的引擎向OpenSSL声明自己是阿沙-1实现，但是重用OpenSSL本身并计算SHA-256。它还将输出截断为20个字节，以免混淆期待阿沙-1结果的应用程序。让我们来测试一下:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="510d" class="nc ld iq my b gy nd ne l nf ng">$ gcc -shared -fPIC -o cryptofix_engine.so sha1-sha256.c<br/>$ echo abc | openssl sha1<br/>(stdin)= 03cfd743661f07975fa2f1220c5194cbaff48451<br/>$ echo abc | openssl sha1 -engine ./cryptofix_engine.so<br/>engine "sha1-sha256" set.<br/>replacing SHA1 with SHA256<br/>(stdin)= edeaaff3f1774ad2888673770c6d64097e391bc3<br/>$ echo abc | sha256sum<br/>edeaaff3f1774ad2888673770c6d64097e391bc362d7d6fb34982ddf0efd18cb  -</span></pre><p id="213c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来像预期的那样工作。让我们用我们的专有工具来试试:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="9663" class="nc ld iq my b gy nd ne l nf ng">$ echo abc | LD_PRELOAD=./cryptofix_engine.so ./customhashv3<br/>03cfd743661f07975fa2f1220c5194cbaff48451</span></pre><p id="f864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯……什么都没有改变:我们没有得到我们的调试信息，结果仍然是阿沙-1。原因是:为了使引擎可用，我们还需要调用一些OpenSSL API来加载和配置它！因此，并不是所有基于OpenSSL的应用程序都是引擎感知的。显然，我们上面使用的命令行<code class="fe nh ni nj my b">openssl</code>实用程序是:当我们指定<code class="fe nh ni nj my b">-engine</code>参数时，引擎配置API被调用。还有其他的，比如NGINX和OpenVPN——它们在配置文件中有一些指令，用户可以在其中指定所需的OpenSSL引擎。但大多数都不是——开发人员只是将OpenSSL作为一个加密库，并不期望用户替换加密算法。</p><h1 id="cbb6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">在进程启动时注入代码</h1><p id="869b" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">如上所述，我们的定制工具不支持OpenSSL引擎，因此我们需要在它开始计算第一个SHA-1之前，让它调用<a class="ae kc" href="https://www.openssl.org/docs/man1.1.1/man3/ENGINE_ctrl_cmd_string.html" rel="noopener ugc nofollow" target="_blank"> OpenSSL引擎配置API </a>。我们可能会挂钩一些其他函数，甚至是来自<code class="fe nh ni nj my b">libc</code>的函数，并希望它会在OpenSSL函数之前使用，但是我们会受到上述问题的影响，供应商的更新可能会破坏我们的修复程序。</p><p id="4fdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更好的方法是在函数中实现所需的引擎配置，并将其标记为<a class="ae kc" href="https://gcc.gnu.org/onlinedocs/gccint/Initialization.html" rel="noopener ugc nofollow" target="_blank">“初始化例程”</a>:</p><p id="5ed2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">自动加载c: </em></p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="45d6" class="nc ld iq my b gy nd ne l nf ng"><strong class="my ir">#define _GNU_SOURCE </strong><em class="lb">/* for dladdr and Dl_info */</em><strong class="my ir"><br/>#include &lt;dlfcn.h&gt;<br/>#include &lt;stdio.h&gt;<br/></strong><br/><strong class="my ir">#include &lt;openssl/engine.h&gt;<br/></strong><br/><strong class="my ir">static</strong> <strong class="my ir">void</strong> <strong class="my ir">fatal</strong>(<strong class="my ir">const</strong> <strong class="my ir">char</strong> <strong class="my ir">*</strong>msg) {<br/>  fputs(msg, stderr);<br/>  exit(1);<br/>}<br/><br/><strong class="my ir">static</strong> <strong class="my ir">__attribute__</strong>((constructor)) <strong class="my ir">void</strong> engine_preload(<strong class="my ir">void</strong>) {<br/>  <em class="lb">// OpenSSL dynamic engine needs a filesystem path to the engine</em><br/>  <em class="lb">// so we determine our own filesystem path first</em><br/>  Dl_info dinfo;<br/>  <strong class="my ir">int</strong> res <strong class="my ir">=</strong> dladdr((<strong class="my ir">const</strong> <strong class="my ir">void</strong> <strong class="my ir">*</strong>)engine_preload, <strong class="my ir">&amp;</strong>dinfo);<br/>  <strong class="my ir">if</strong> (0 <strong class="my ir">==</strong> res) {<br/>    fatal("failed to query engine module info");<br/>  }<br/>  <strong class="my ir">if</strong> (NULL <strong class="my ir">==</strong> dinfo.dli_fname) {<br/>    fatal("failed to determine engine filesystem path");<br/>  }<br/>  ENGINE_load_dynamic();<br/>  ENGINE <strong class="my ir">*</strong>e <strong class="my ir">=</strong> ENGINE_by_id("dynamic");<br/>  <strong class="my ir">if</strong> (NULL <strong class="my ir">==</strong> e) {<br/>    fatal("failed to load OpenSSL dynamic engine");<br/>  }<br/><br/>  res <strong class="my ir">=</strong> ENGINE_ctrl_cmd_string(e, "SO_PATH", dinfo.dli_fname, 0);<br/>  <strong class="my ir">if</strong> (res <strong class="my ir">&lt;=</strong> 0) {<br/>    fatal("failed to set SO_PATH parameter for dynamic engine");<br/>  }<br/>  res <strong class="my ir">=</strong> ENGINE_ctrl_cmd_string(e, "ID", "sha1-sha256", 0);<br/>  <strong class="my ir">if</strong> (res <strong class="my ir">&lt;=</strong> 0) {<br/>    fatal("failed to set ID parameter for dynamic engine");<br/>  }<br/>  res <strong class="my ir">=</strong> ENGINE_ctrl_cmd_string(e, "LOAD", NULL, 0);<br/>  <strong class="my ir">if</strong> (res <strong class="my ir">&lt;=</strong> 0) {<br/>    fatal("failed to LOAD sha1-sha256 engine");<br/>  }<br/>  res <strong class="my ir">=</strong> ENGINE_set_default(e, ENGINE_METHOD_ALL);<br/>  <strong class="my ir">if</strong> (res <strong class="my ir">&lt;=</strong> 0) {<br/>    fatal("failed to set algorithms from sha1-sha256 engine as default");<br/>  }<br/>}</span></pre><p id="c764" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">OpenSSL引擎配置API需要一个指向所需引擎的文件系统路径。我们假设上面的代码将是我们的<code class="fe nh ni nj my b">cryptofix_engine.so</code>库的一部分，所以我们只需要获取当前正在执行的模块的文件系统路径，并将其传递给OpenSSL引擎配置API。但是这里的神奇之处在于函数声明:注意原型中的<code class="fe nh ni nj my b">__attribute__((constructor))</code>。它将该代码标记为“初始化例程”，因此它将在过程启动时自动执行，甚至在<code class="fe nh ni nj my b">main</code>功能之前执行。这种方法的美妙之处在于，我们不依赖于在目标应用程序中挂接任何函数。事实上，只要应用程序加载了我们的共享库，不管应用程序的逻辑是什么，这段代码都会被执行。</p><p id="d364" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们重新编译包含这个函数的<code class="fe nh ni nj my b">cryptofix_engine.so</code>并测试它:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4960" class="nc ld iq my b gy nd ne l nf ng">$ gcc -shared -fPIC -o cryptofix_engine.so autoload.c sha1-sha256.c<br/>$ echo abc | LD_PRELOAD=./cryptofix_engine.so ./customhashv3<br/>replacing SHA1 with SHA256<br/>edeaaff3f1774ad2888673770c6d64097e391bc3<br/>$ echo abc | sha256sum<br/>edeaaff3f1774ad2888673770c6d64097e391bc362d7d6fb34982ddf0efd18cb  -</span></pre><p id="4721" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">成功了！但是因为我们通过OpenSSL引擎替换了该算法，所以它也适用于该工具的每个先前版本，并且很可能适用于任何未来版本:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="95ed" class="nc ld iq my b gy nd ne l nf ng">$ echo abc | LD_PRELOAD=./cryptofix_engine.so ./customhashv2<br/>replacing SHA1 with SHA256<br/>edeaaff3f1774ad2888673770c6d64097e391bc3<br/>$ echo abc | LD_PRELOAD=./cryptofix_engine.so ./customhash<br/>replacing SHA1 with SHA256<br/>edeaaff3f1774ad2888673770c6d64097e391bc3</span></pre><p id="5487" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们的修补程序现在更加可靠，面向未来。</p><h1 id="2bf2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">正在删除LD_PRELOAD</h1><p id="9c23" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">到目前为止，我们有一个可靠的修补程序，用于我们的弱专有哈希工具，但是我们需要确保我们的代码将总是通过指定<code class="fe nh ni nj my b">LD_PRELOAD</code>环境变量来加载，当工具被执行时。这不仅容易出错(当调用工具时，我们可能会忘记定义变量)，而且<a class="ae kc" href="http://man7.org/linux/man-pages/man8/ld.so.8.html" rel="noopener ugc nofollow" target="_blank">并不是在所有情况下都有效</a>(例如，当调用设置了<code class="fe nh ni nj my b">setuid/setgid</code>位的可执行文件时，环境变量被忽略)。</p><p id="226d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以永久地修补定制工具而无需重新编译它，并添加我们的<code class="fe nh ni nj my b">cryptofix_engine.so</code>共享库作为运行时依赖项:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7f63" class="nc ld iq my b gy nd ne l nf ng">$ patchelf --add-needed ./cryptofix_engine.so ./customhashv3<br/>$ ldd ./customhashv3<br/>	linux-vdso.so.1 (0x00007ffd40977000)<br/>	./cryptofix_engine.so (0x00007faf1d1ce000)<br/>	libcrypto.so.1.1 =&gt; /lib/x86_64-linux-gnu/libcrypto.so.1.1 (0x00007faf1ced9000)<br/>	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007faf1cd18000)<br/>	libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007faf1cd13000)<br/>	libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007faf1ccf2000)<br/>	/lib64/ld-linux-x86-64.so.2 (0x00007faf1d1db000)</span></pre><p id="1a18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从现在开始，我们的<code class="fe nh ni nj my b">cryptofix_engine.so</code>将成为<code class="fe nh ni nj my b">customhashv3</code>工具的一部分，并且在执行二进制文件时，即使没有任何<code class="fe nh ni nj my b">LD_PRELOAD</code>定义，也会一直被加载:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="266e" class="nc ld iq my b gy nd ne l nf ng">$ echo abc | ./customhashv3<br/>replacing SHA1 with SHA256<br/>edeaaff3f1774ad2888673770c6d64097e391bc3<br/>$ echo abc | sha256sum<br/>edeaaff3f1774ad2888673770c6d64097e391bc362d7d6fb34982ddf0efd18cb  -</span></pre><h1 id="00d0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="04ad" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">这篇文章虽然基于想象的场景，但反映了一些真实世界的使用案例和经验。它还涵盖了一些强大的运行时代码修补方法，即使不需要替换私有代码中的弱加密也很有用，可以单独或一起采用。帖子中的所有代码都是在这里发布的<a class="ae kc" href="https://github.com/pqsec/cryptofix" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>