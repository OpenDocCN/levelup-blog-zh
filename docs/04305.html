<html>
<head>
<title>Testing a Custom React Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试自定义React挂钩</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/testing-a-custom-react-hook-21ae732228b7?source=collection_archive---------4-----------------------#2020-06-19">https://levelup.gitconnected.com/testing-a-custom-react-hook-21ae732228b7?source=collection_archive---------4-----------------------#2020-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d437" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">并对您的React测试库技能更有信心</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c727cec19923f0ad0575a99e5b098285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mh5l55_i_nc41FxU"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@battlecreekcoffeeroasters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Battlecreek咖啡烘焙师</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2306" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我写了一篇关于<a class="ae kv" href="https://medium.com/better-programming/how-to-build-a-custom-react-hook-for-fetching-data-cf942e64e9f8" rel="noopener">如何构建用于获取数据的自定义React钩子</a>的文章。<code class="fe ls lt lu lv b">useFetch</code>的实现非常简单，但是要正确测试有点棘手。</p><p id="9fc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您已经设置了测试环境，我们将使用React测试库(RTL)。</p><p id="494d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，我们就不要白说了，直接跳到代码上吧！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="94fb" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">创建useFetch</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">用于获取数据的自定义挂钩</figcaption></figure><p id="5bbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自定义挂钩是一种特殊类型的函数，您可以在其中使用React挂钩。</p><p id="d995" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们在这里从API的<code class="fe ls lt lu lv b">useEffect</code>钩子中获取数据，将它们放入状态并返回。如果在获取过程中发生错误，我们返回错误。</p><p id="73d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在做任何事情之前，用<code class="fe ls lt lu lv b">ref.current</code>我们检查当前对组件的引用是否是真的。如果不是，这意味着组件没有安装到视图中。因此，不应提取数据。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="eca5" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">测试自定义挂钩</h1><p id="563c" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">现在，我们可以通过测试以下各项来涵盖<code class="fe ls lt lu lv b">useFetch</code>的全部功能:</p><ol class=""><li id="4379" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">在成功异步调用API后，将返回数据</li><li id="aae8" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">当发生错误时，会正确处理错误</li><li id="c276" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">当<code class="fe ls lt lu lv b">current</code>引用为falsy时，对API的调用不会发生</li></ol><p id="b4c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每一点，我们可以写一个单独的测试，对吗？所以让我们开始吧！</p><h2 id="a9a8" class="nq me iq bd mf nr ns dn mj nt nu dp mn lf nv nw mp lj nx ny mr ln nz oa mt ob bi translated">设置测试文件</h2><p id="dcb4" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">假设我们创建了一个新文件<code class="fe ls lt lu lv b">useFetch.test.js</code>并准备了一个测试环境:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="3c6c" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr oc ni nj nk bi translated">我们肯定需要模拟数据，因为我们不会真的获取它们。因此我创建了一个数组<code class="fe ls lt lu lv b">stubbedCountries</code>。</li><li id="1e4f" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr oc ni nj nk bi translated">在<code class="fe ls lt lu lv b">afterEach</code>块中，我们清理fetch实现，而在<code class="fe ls lt lu lv b">afterAll</code>块中，我们恢复原始实现。这样我们可以防止测试相互影响。更多关于这个的信息请见<a class="ae kv" href="https://jestjs.io/docs/en/mock-function-api.html#mockfnmockclear" rel="noopener ugc nofollow" target="_blank"> jest doc </a> s</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="bc01" class="nq me iq bd mf nr ns dn mj nt nu dp mn lf nv nw mp lj nx ny mr ln nz oa mt ob bi translated">案例1:获取数据</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="98e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在我们一步一步来说这个:</p><ul class=""><li id="b81a" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr oc ni nj nk bi translated">和往常一样，我们首先通过用<code class="fe ls lt lu lv b">stubbedCountries</code>返回已解决的承诺来模拟异步调用。</li><li id="50c7" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr oc ni nj nk bi translated">钩子是特殊类型的函数，因为它们只能在React组件中使用。因此，我们需要在组件中模拟渲染钩子。为此，我们可以使用<code class="fe ls lt lu lv b">renderHook()</code>。</li><li id="7b60" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr oc ni nj nk bi translated"><code class="fe ls lt lu lv b">renderHook()</code>的回调是带有适当参数的钩子的执行。你可以阅读关于<a class="ae kv" href="https://react-hooks-testing-library.com/reference/api#renderhook" rel="noopener ugc nofollow" target="_blank">的更多选项</a>T2。</li><li id="eba6" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr oc ni nj nk bi translated">之后，我们调用<code class="fe ls lt lu lv b">waitForNextUpdate()</code>，它返回一个承诺，该承诺在钩子下次呈现时解决，通常是在一个状态由于异步更新而被更新时。</li><li id="d28c" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr oc ni nj nk bi translated">我们期望结果(返回的对象)应该严格等于期望的输出。</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="8202" class="nq me iq bd mf nr ns dn mj nt nu dp mn lf nv nw mp lj nx ny mr ln nz oa mt ob bi translated">案例2:错误处理</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d841" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与之前的测试非常相似:</p><ul class=""><li id="42e3" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr oc ni nj nk bi translated">同样，我们通过返回必须具有拒绝状态的承诺来模拟异步调用。这意味着出现了错误，错误应该被捕获。</li><li id="8c29" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr oc ni nj nk bi translated">同上，我们渲染我们的钩子和调用<code class="fe ls lt lu lv b">waitForNextUpdate()</code>。</li><li id="8166" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr oc ni nj nk bi translated">我们期望返回的对象应该包含<code class="fe ls lt lu lv b">error</code>并且没有数据。</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h2 id="5456" class="nq me iq bd mf nr ns dn mj nt nu dp mn lf nv nw mp lj nx ny mr ln nz oa mt ob bi translated">案例3:当前参考是falsy</h2><p id="fee0" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">useFetch</code>的React组件同时从DOM中卸载，因此不应触发抓取:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><ul class=""><li id="94ac" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr oc ni nj nk bi translated">这里我们只是用给定的参数来呈现钩子。第二个参数是<code class="fe ls lt lu lv b">ref</code>，所以一定是<code class="fe ls lt lu lv b">{ current: false }</code>。</li><li id="389b" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr oc ni nj nk bi translated">在断言中，我们期望fetch没有被调用。这意味着自定义钩子中的<code class="fe ls lt lu lv b">useEffect</code>还没有被调用。</li><li id="5d59" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr oc ni nj nk bi translated">我们还期望返回的对象不应该包含数据或错误。</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="fedf" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="f6b4" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">最终，这就是我们想要实现的目标:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/bc3738c4cb9dc40aa56c61820d646f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-RmM2aBYyMUyixSJp1lRg.png"/></div></div></figure><p id="4c89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以在GitHub repo 中查看<a class="ae kv" href="https://github.com/Dromediansk/countries-app-blog/blob/custom-hook-unit-testing/src/utils/customHook.test.js" rel="noopener ugc nofollow" target="_blank">测试文件。</a></p><p id="c6c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，重要的是，我们只用3个测试就涵盖了所有可能的情况。这意味着，覆盖率应该是100%，尽管我不认为这方面是相关的。</p><p id="4219" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最棒的是，你可以在每个React项目中使用这个钩子，因为代码已经过全面测试！</p><p id="1ad7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想了解更多关于测试的知识吗？请随意阅读我的其他故事:</p><h2 id="e4c4" class="nq me iq bd mf nr ns dn mj nt nu dp mn lf nv nw mp lj nx ny mr ln nz oa mt ob bi translated">用RTL进行单元测试</h2><div class="oe of gp gr og oh"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-write-unit-tests-with-react-testing-library-d9624fd2b707"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">如何用反应测试库编写单元测试</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">使用testing-library/react v10进行简单的隔离测试。</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov kp oh"/></div></div></a></div><h2 id="abcc" class="nq me iq bd mf nr ns dn mj nt nu dp mn lf nv nw mp lj nx ny mr ln nz oa mt ob bi translated">使用Cypress进行自动化(E2E)测试</h2><div class="oe of gp gr og oh"><a href="https://medium.com/better-programming/react-testing-get-started-with-cypress-io-a19b6eb6332a" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">React测试:Cypress.io入门</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">用最少的努力编写有意义的端到端测试</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov kp oh"/></div></div></a></div></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="f312" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>