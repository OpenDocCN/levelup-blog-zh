<html>
<head>
<title>A Guide to the JavaScript window.crypto Object</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript window.crypto对象指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introducing-the-javascript-window-object-cryptography-7316d60fd1ef?source=collection_archive---------1-----------------------#2019-12-17">https://levelup.gitconnected.com/introducing-the-javascript-window-object-cryptography-7316d60fd1ef?source=collection_archive---------1-----------------------#2019-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="04f5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何通过JavaScript在浏览器中使用加密功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/714719e2fb883cbe96f138efb24558dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lTvhivdlM4L9LzPG"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@franckinjapan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Franck V. </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="16be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">window</code>对象是一个全局对象，它提供了对DOM的JavaScript访问。它还包含一个标准函数库，我们可以在web应用程序的任何位置访问它。</p><p id="2e00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们来看一下<code class="fe lv lw lx ly b">window.cryoto</code>对象。</p><h1 id="7225" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">windows . crypto</h1><p id="749c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">window.crypto</code>属性返回一个与全局对象相关联的<code class="fe lv lw lx ly b">Crypto</code>对象。该对象允许网页在浏览器端运行各种加密操作。它有一个属性，那就是<code class="fe lv lw lx ly b">subtle</code>属性。</p><p id="61a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Crypto.subtle</code>属性返回一个<code class="fe lv lw lx ly b">SubtleCrypto</code>对象，它允许我们在客户端进行微妙的加密。<code class="fe lv lw lx ly b">SubtleCrypto</code>对象有5种方法对数据进行加密和解密。<code class="fe lv lw lx ly b">sign</code>方法用于创建数字签名。</p><p id="9c07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存在一个<code class="fe lv lw lx ly b">verify</code>方法来验证由<code class="fe lv lw lx ly b">sign</code>方法创建的数字签名。</p><p id="136c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">encrypt</code>方法用于加密数据，<code class="fe lv lw lx ly b">decrypt</code>方法用于解密由<code class="fe lv lw lx ly b">encrypt</code>方法产生的加扰数据。<code class="fe lv lw lx ly b">digest</code>方法用于创建一些数据的固定长度、抗冲突的摘要。</p><p id="0a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用<code class="fe lv lw lx ly b">SubtleCrypto</code>对象分别通过<code class="fe lv lw lx ly b">generateKey</code>和<code class="fe lv lw lx ly b">deriveKey</code>方法生成和导出密钥。</p><p id="2be1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">generateKey</code>方法在我们每次调用它的时候都会生成一个新的不同的键值，而<code class="fe lv lw lx ly b">deriveKey</code>方法从一些初始的材料中派生出一个键。如果我们向两个不同的<code class="fe lv lw lx ly b">deriveKey</code>调用提供相同的材料，我们将获得相同的潜在价值。</p><p id="7483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">deriveKey</code>方法对于导出相同的加密和解密密钥很有用。我们还可以使用<code class="fe lv lw lx ly b">importKey</code>和<code class="fe lv lw lx ly b">exportKey</code>方法分别导入和导出密钥。</p><p id="7511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一种<code class="fe lv lw lx ly b">wrapKey</code>方法，导出密钥，然后用另一个密钥加密。</p><p id="6ae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还提供了一个<code class="fe lv lw lx ly b">unwrapKey</code>方法来解密由<code class="fe lv lw lx ly b">wrapKey</code>方法完成的加密密钥，并导入解密的密钥。</p><p id="51ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以使用<code class="fe lv lw lx ly b">sign</code>方法创建一个数字签名。它需要三个参数。第一个是<code class="fe lv lw lx ly b">algorithm</code>，它是一个字符串或对象，指定用于创建数字签名的签名算法。可能的值有:</p><ul class=""><li id="2182" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">RSASSA-PKCS1-v1_5 —传入字符串<code class="fe lv lw lx ly b"> “RSASSA-PKCS1-v1_5”</code>或形式为<code class="fe lv lw lx ly b">{ “name”: “RSASSA-PKCS1-v1_5” }</code>的对象</li><li id="39be" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">RSA-PSS —传递一个<code class="fe lv lw lx ly b">RsaPssParams </code>对象。一个<code class="fe lv lw lx ly b">RsaPssParams</code>对象具有<code class="fe lv lw lx ly b">name</code>属性，它应该是<code class="fe lv lw lx ly b">RSA-PSS</code>和<code class="fe lv lw lx ly b">saltLength</code>，它是要使用的随机salt的长度，以字节为单位。<code class="fe lv lw lx ly b">saltLength</code>的最大值为<code class="fe lv lw lx ly b">Math.ceil((keySizeInBits - 1)/8) - digestSizeInBytes - 2</code></li><li id="8a60" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">ECDSA —传递一个<code class="fe lv lw lx ly b">EcdsaParams </code>对象。一个<code class="fe lv lw lx ly b">EcdsaParams</code>对象具有<code class="fe lv lw lx ly b">name</code>属性，该属性应该是字符串<code class="fe lv lw lx ly b">'ECDSA'</code>和<code class="fe lv lw lx ly b">hash</code>属性，该属性可以是具有可能值<code class="fe lv lw lx ly b">SHA-256</code>、<code class="fe lv lw lx ly b">SHA-384</code>或<code class="fe lv lw lx ly b">SHA-512</code>的字符串</li><li id="1cb9" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">HMAC —传入字符串<code class="fe lv lw lx ly b">“HMAC”</code>或形式为<code class="fe lv lw lx ly b">{ “name”: “HMAC” }</code>的对象</li></ul><p id="7712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个参数是<code class="fe lv lw lx ly b">key</code>，它是一个CryptoKey对象，拥有用于创建签名的私钥。第三个参数是<code class="fe lv lw lx ly b">data</code>，它是一个<code class="fe lv lw lx ly b">ArrayBuffer </code>或<code class="fe lv lw lx ly b">ArrayBufferView </code>对象，包含要签名的数据。</p><p id="d41e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">sign</code>方法返回一个承诺，这个承诺通过一个有签名的<code class="fe lv lw lx ly b">ArrayBuffer</code>对象来实现。</p><p id="e46e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，<code class="fe lv lw lx ly b">verify</code>方法接受与<code class="fe lv lw lx ly b">sign</code>方法相同的第一个<code class="fe lv lw lx ly b">algorithm</code>、<code class="fe lv lw lx ly b">key</code>和<code class="fe lv lw lx ly b">data</code>参数作为第一个、第二个和第四个参数。从<code class="fe lv lw lx ly b">sign</code>方法生成的<code class="fe lv lw lx ly b">signature</code>是第三个参数。它返回一个承诺，如果签名有效，则用值<code class="fe lv lw lx ly b">true</code>实现，否则用值<code class="fe lv lw lx ly b">false</code>实现。</p><p id="b0ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用<code class="fe lv lw lx ly b">sign</code>和<code class="fe lv lw lx ly b">verify</code>方法，我们可以编写类似下面的代码:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="68a1" class="no ma it ly b gy np nq l nr ns">const enc = new TextEncoder();<br/>const encodedMessage = enc.encode('hello');<br/>const keyPair = window.crypto.subtle.generateKey({<br/>    name: "RSASSA-PKCS1-v1_5",<br/>    modulusLength: 4096,<br/>    publicExponent: new Uint8Array([1, 0, 1]),<br/>    hash: "SHA-256"<br/>  },<br/>  true,<br/>  ["sign", "verify"]<br/>);</span><span id="a29d" class="no ma it ly b gy nt nq l nr ns">(async () =&gt; {<br/>  const {<br/>    privateKey,<br/>    publicKey<br/>  } = await keyPair;<br/>  const signature = await window.crypto.subtle.sign(<br/>    "RSASSA-PKCS1-v1_5",<br/>    privateKey,<br/>    encodedMessage<br/>  );<br/>  const signatureValid = await window.crypto.subtle.verify("RSASSA-PKCS1-v1_5", publicKey, signature, encodedMessage);<br/>  console.log(signatureValid);<br/>})()</span></pre><p id="0158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先用<code class="fe lv lw lx ly b">generateKey</code>生成密钥对，因为我们使用的是非对称RSA算法有一个私有和公共密钥。<code class="fe lv lw lx ly b">generateKey</code>方法将算法作为第一个参数，其中可能的值为:</p><ul class=""><li id="356d" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">为了使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#RSASSA-PKCS1-v1_5" rel="noopener ugc nofollow" target="_blank"> RSASSA-PKCS1-v1_5 </a>、<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#RSA-PSS" rel="noopener ugc nofollow" target="_blank"> RSA-PSS </a>或<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#RSA-OAEP" rel="noopener ugc nofollow" target="_blank"> RSA-OAEP </a>，我们传递一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams" rel="noopener ugc nofollow" target="_blank">RsaHashedKeyGenParams</a></code>对象。</li><li id="0703" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">为了使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#ECDSA" rel="noopener ugc nofollow" target="_blank"> ECDSA </a>或<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#ECDH" rel="noopener ugc nofollow" target="_blank"> ECDH </a>，我们传递一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/EcKeyGenParams" rel="noopener ugc nofollow" target="_blank">EcKeyGenParams</a></code>对象。</li><li id="6471" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">为了使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#HMAC" rel="noopener ugc nofollow" target="_blank"> HMAC </a>，我们传递一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/HmacKeyGenParams" rel="noopener ugc nofollow" target="_blank">HmacKeyGenParams</a></code>对象。</li><li id="892d" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">为了使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#AES-CTR" rel="noopener ugc nofollow" target="_blank"> AES-CTR </a>、<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#AES-CBC" rel="noopener ugc nofollow" target="_blank"> AES-CBC </a>、<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#AES-GCM" rel="noopener ugc nofollow" target="_blank"> AES-GCM </a>或<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#AES-KW" rel="noopener ugc nofollow" target="_blank"> AES-KW </a>，我们传递一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/AesKeyGenParams" rel="noopener ugc nofollow" target="_blank">AesKeyGenParams</a></code>对象。</li></ul><p id="9a9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个参数是布尔<code class="fe lv lw lx ly b">extractable</code>属性，它指示是否可以使用<code class="fe lv lw lx ly b">SubtleCrypto.exportKey()</code>或<code class="fe lv lw lx ly b">SubtleCrypto.wrapKey()</code>方法导出一个键。第三个参数是<code class="fe lv lw lx ly b">keyUsages</code>数组，它指示哪些方法可以与生成的密钥一起使用:</p><ul class=""><li id="259a" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">encrypt</code></li><li id="5f21" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">decrypt</code></li><li id="7fcb" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">sign</code></li><li id="dcb8" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">verify</code></li><li id="6078" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">deriveKey</code></li><li id="b0e5" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">deriveBits</code></li><li id="4f20" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">wrapKey</code></li><li id="fa85" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe lv lw lx ly b">unwrapKey</code></li></ul><p id="e6a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们用算法名、私有密钥和从<code class="fe lv lw lx ly b">TextEncoder</code>生成的编码消息调用<code class="fe lv lw lx ly b">sign</code>方法。这将生成签名。然后，我们用算法名、私有密钥、从<code class="fe lv lw lx ly b">sign</code>方法实现的生成签名和相同的编码消息调用<code class="fe lv lw lx ly b">verify</code>方法。如果我们运行上面的代码，我们应该得到<code class="fe lv lw lx ly b">console.log</code>日志<code class="fe lv lw lx ly b">true</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/b58b30aaaf01f3536a0710bedad844d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zw6ndSXcyWyRm9Zg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马修·汉密尔顿在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="52f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">encrypt</code>方法有3个参数。第一个是<code class="fe lv lw lx ly b">algorithm</code>，它是一个具有以下可能值的对象:</p><ul class=""><li id="0ed0" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">为了使用RSA-OAEP算法，我们传入一个<code class="fe lv lw lx ly b">RsaOaepParams </code>对象。该对象属性的完整详细信息位于<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/RsaOaepParams" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/rsoaepparams</a></li><li id="ea42" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">为了使用AES-CTR算法，我们传入一个<code class="fe lv lw lx ly b">AesCtrParams</code>对象。该对象属性的完整详细信息位于<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/AesCtrParams" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/aesctparams</a></li><li id="a4fb" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">为了使用AES-CBC算法，我们传入一个<code class="fe lv lw lx ly b">AesCbcParams </code>对象。该对象属性的全部细节位于<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/AesCbcParams" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/AesCbcParams</a></li><li id="a746" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">为了使用AES-GCM算法，我们传入一个<code class="fe lv lw lx ly b">AesGcmParams </code>对象。该对象属性的完整详细信息位于<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/AesGcmParams</a></li></ul><p id="ea62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个参数是我们用来加密的<code class="fe lv lw lx ly b">CryptoKey</code>对象。第三个参数是一个<code class="fe lv lw lx ly b">BufferSource</code>对象，它包含要加密的数据，也称为纯文本。它返回一个承诺，这个承诺通过一个包含加密纯文本的<code class="fe lv lw lx ly b">ArrayBuffer</code>对象来解决。</p><p id="aa6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，<code class="fe lv lw lx ly b">decrypt</code>方法采用与<code class="fe lv lw lx ly b">encrypt</code>方法相同的前两个参数，除了第三个参数是一个包含要解密的数据的<code class="fe lv lw lx ly b">BufferSource</code>。它返回一个承诺，这个承诺是用具有纯文本的<code class="fe lv lw lx ly b">ArrayBuffer</code>对象解决的。</p><p id="03a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以像下面的代码一样使用<code class="fe lv lw lx ly b">encrypt</code>和<code class="fe lv lw lx ly b">dercrypt</code>方法:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="9173" class="no ma it ly b gy np nq l nr ns">const enc = new TextEncoder();<br/>const dec = new TextDecoder();<br/>const keyPair = window.crypto.subtle.generateKey({<br/>    name: "RSA-OAEP",<br/>    modulusLength: 4096,<br/>    publicExponent: new Uint8Array([1, 0, 1]),<br/>    hash: "SHA-256"<br/>  },<br/>  true,<br/>  ["encrypt", "decrypt"]<br/>);<br/>const encodedMessage = enc.encode('hello');<br/>(async () =&gt; {<br/>  const {<br/>    privateKey,<br/>    publicKey<br/>  } = await keyPair;<br/>  const encryptedText = await window.crypto.subtle.encrypt({<br/>      name: "RSA-OAEP"<br/>    },<br/>    publicKey,<br/>    encodedMessage<br/>  )<br/>  console.log(encryptedText);</span><span id="5538" class="no ma it ly b gy nt nq l nr ns">  const decryptedText = await window.crypto.subtle.decrypt({<br/>      name: "RSA-OAEP"<br/>    },<br/>    privateKey,<br/>    encryptedText<br/>  )<br/>  console.log(decryptedText);<br/>  console.log(dec.decode(decryptedText));</span><span id="9461" class="no ma it ly b gy nt nq l nr ns">})()</span></pre><p id="42a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们首先使用<code class="fe lv lw lx ly b">generateKey</code>方法生成一个密钥或密钥对，这取决于加密算法是对称的还是非对称的，就像我们在<code class="fe lv lw lx ly b">sign</code>和<code class="fe lv lw lx ly b">verify</code>示例中所做的那样。非对称加密算法有一个公钥和一个私钥，如上例所示。RSA是一种不对称算法。</p><p id="7656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们用<code class="fe lv lw lx ly b">TextEncoder</code>对消息进行编码，将其编码成一个<code class="fe lv lw lx ly b">ArrayBuffer</code>对象，该对象可以与<code class="fe lv lw lx ly b">encrypt</code>方法一起使用。</p><p id="7123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们使用带有算法的<code class="fe lv lw lx ly b">encrypt</code>方法、公钥和带有编码文本的<code class="fe lv lw lx ly b">ArrayBuffer</code>对象(通过int传递)来加密数据。然后，为了解密加密的文本，我们使用将算法对象作为第一个参数传入的<code class="fe lv lw lx ly b">decrypt</code>方法，然后我们从密钥对传入私钥，然后我们将加密的文本作为第三个参数传入到<code class="fe lv lw lx ly b">decrypt</code>方法。</p><p id="9cac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将获得作为<code class="fe lv lw lx ly b">ArrayBuffer</code>的解密数据，我们将使用<code class="fe lv lw lx ly b">TextDecoder</code>的<code class="fe lv lw lx ly b">decode</code>方法和解密的<code class="fe lv lw lx ly b">ArrayBuffer</code>对其进行解码，以获得原始文本。这意味着最后一个<code class="fe lv lw lx ly b">console.log</code>语句让我们回到<code class="fe lv lw lx ly b">'hello'</code>。</p><p id="b416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Crypto</code>对象也有一个方法，就是<code class="fe lv lw lx ly b">getRandomValues</code>方法。给定一个类型化数组，该方法将创建一个强随机值。该方法接受一个参数。它接受一个类型化数组，可以是一个<code class="fe lv lw lx ly b">Int8Array</code>、<code class="fe lv lw lx ly b">Uint8Array</code>、<code class="fe lv lw lx ly b">Int16Array</code>、<code class="fe lv lw lx ly b">Uint16Array</code>、<code class="fe lv lw lx ly b">Int32Array</code>或<code class="fe lv lw lx ly b">Uint32Array</code>。为了提高性能，该方法不使用真正的随机数生成器来生成数字，而是使用伪随机数生成器来生成数字。传递给参数的类型化数组的条目将被该方法生成的随机数覆盖。</p><p id="5656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以像下面的例子一样使用<code class="fe lv lw lx ly b">getRandomValues</code>方法:</p><pre class="kj kk kl km gt nk ly nl nm aw nn bi"><span id="9adc" class="no ma it ly b gy np nq l nr ns">let array = new Uint32Array(10);<br/>window.crypto.getRandomValues(array);</span><span id="fb6d" class="no ma it ly b gy nt nq l nr ns">for (const num of array) {<br/>  console.log(num);<br/>}</span></pre><p id="ad66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们生成了一个新的<code class="fe lv lw lx ly b">Uint32Array</code>，并将其传递给<code class="fe lv lw lx ly b">getRandomValues</code>方法。然后在<code class="fe lv lw lx ly b">for...of</code>循环中，我们得到覆盖了原始数组中所有条目的生成值。我们应该会看到来自<code class="fe lv lw lx ly b">console.log</code>的10个随机数，每次运行上面的代码，都会得到不同的结果。</p><p id="94a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">window.cryoto</code>对象，我们可以在浏览器上使用众所周知的加密算法来加密和解密数据。它支持对称和非对称加密，让我们用不同的算法加密数据。此外，我们可以用它来生成数字签名并验证它们。我们也可以用它通过<code class="fe lv lw lx ly b">getRandomValues</code>方法得到随机数。</p></div></div>    
</body>
</html>