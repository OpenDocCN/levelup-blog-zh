<html>
<head>
<title>Principles of Database Schema Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库模式设计的原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/principles-of-database-schema-design-8e322e4fb283?source=collection_archive---------2-----------------------#2021-11-12">https://levelup.gitconnected.com/principles-of-database-schema-design-8e322e4fb283?source=collection_archive---------2-----------------------#2021-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2e11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一名软件开发人员，我和其他专业人员一起花了无数时间设计数据库模式。每次我做这样的任务，我在设计过程中更好地预测可能的问题并避免它们。我目前的知识是我自己的经验和其他人的想法的混合物，其中大部分是我从各种书籍和文章中学到的。</p><p id="a848" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天，我通过分享数据库模式设计原则的精选列表来回馈社区。我相信每个数据库模式设计者都应该知道它们。我希望他们能丰富你作为软件专业人员的经验。</p><p id="7b0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我是从一个构建分布式系统的人的角度来处理这个问题的。此外，对文章中的所有内容都要有所保留——我不知道您正在设计的系统的复杂性或需求！</p><p id="30d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于表，我指的是在SQL数据库中由行和列组织的结构，对于集合，我指的是它们在非SQL数据库中的对应物。</p><p id="8a15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了更好地理解，我将所有原则分为四组:</p><ul class=""><li id="188b" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">与流程相关的原则，</li><li id="82a8" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">数据库相关原理，</li><li id="46d6" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">查询相关的原则，</li><li id="cc84" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">实体相关原则。</li></ul><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/76be62987e441d2d682ad73b79c524d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5JSEiyTxh6-rQKvw"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">Maksym Kaharlytskyi 在<a class="ae ls" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="64c5" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">与流程相关的原则</h1><h2 id="77ab" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">理解问题</h2><p id="c5ba" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">在尝试设计任何东西之前，您应该对您正在构建的应用程序试图解决的实际问题有一个清晰而深刻的理解。要意识到维护数据库在时间和金钱上都是很昂贵的。</p><p id="28a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为这个事实，也许有一个解决方案不保证启动一个新的SQL server？也许您的解决方案需要非SQL数据库或对象存储服务？</p><p id="7d49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总的来说，把自己局限在一个想法里是不明智的！</p><h2 id="3e19" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">定义访问控制</h2><p id="9d11" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">您应该问自己系统的哪些部分将访问新的数据库。直接和间接。您会坚持老式的每个数据库一个后端的规则，还是会使用不同的策略？您应该允许人们(开发人员或产品经理)直接访问数据库吗？</p><p id="5c95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据不同的需求，您可能需要以不同的方式处理安全主题。在本文中，我创造了两个术语——主动和被动方法。</p><p id="d9c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主动方法是使用数据库引擎提供的工具来实施访问控制。对于SQL数据库，您可能希望使用具有不同特权的数据库用户，例如，对特定的表使用不同的CRUD特权。使用特定用户进行某些操作在查询和数据之间提供了一个分离层。例如，要为一个系统用户执行数据库调用，我可以利用一个数据库用户，并为该最终用户分配特权。</p><p id="a997" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">被动的方法是通过授权查询和变异的调用者来使用您的后端进行访问控制。这意味着后端使用单个数据库用户，该用户拥有对数据库中所有可能操作的巨大特权。您的架构可以包含一些日志记录信息，以告知是谁引入了哪些更改；它可以为用户审计提供相关信息。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ni"><img src="../Images/ed793dd3c82b17946184edd015f09067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*InOh-q6KnM8aTdlf"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae ls" href="https://unsplash.com/@homajob?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯科特·格雷厄姆</a>在<a class="ae ls" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h2 id="2e59" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">将模式写在纸上</h2><p id="b964" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">我认为首先在纸上写模式可以让它的设计者更早地看到明显的缺陷。使用铅笔比在现有的SQL数据库中更容易纠正错误。或者更糟，如果我们使用ORM为自己生成SQL模式。</p><p id="826e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，您可以将纸质模式转移到数字化环境中。这可能会引起其他团队成员的更多协作，尤其是在远程工作安排之后。对于喜欢使用正式结构的人来说，一些环境可能也支持UML图。</p><h2 id="92c0" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">审查设计</h2><p id="b82a" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">你应该和其他人一起检查你的设计，可能要检查很多次。您可能很容易忽略一些基本细节，更不用说完全忘记几天前介绍的一个委托功能。大多数人认为数据库本身是一个复杂的领域，他们不期望一个人在数据存储的每个方面都有专业知识。</p><h1 id="b349" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">数据库相关原理</h1><h2 id="5f79" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">不使用外键</h2><p id="97dd" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">在分布式系统的SQL数据库中，外键可能会成为障碍。我们需要以特定的顺序将更改应用到外键持有的记录中。请注意，并非所有的SQL引擎都允许延迟一致性。允许事务内的不一致更改不符合SQL标准。</p><p id="c006" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一些开发人员通过使用可空的外键来消除这种障碍。当你阅读这篇文章的时候，你会明白为什么我根本不使用可空字段。</p><p id="5854" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，如果我们没有考虑好我们的查询，使用外键可能会导致死锁！通过移除外键，我们减少了死锁的机会。</p><p id="458a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有外键，我们可以依靠正确使用的事务、隔离级别和创建适当的查询，将数据库从一种正确的状态转移到另一种状态。</p><p id="b840" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的解决方案是从外键开始工作，以从引擎一致性检查中受益，并且在我们确保了查询的质量之后，完全放弃外键。</p><h2 id="ec38" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">不使用级联</h2><p id="9062" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">SQL数据库允许用户定义外键的级联行为，以控制当有人更新或删除父表中的行时会发生什么。现在，我已经解释了为什么我不在分布式系统中使用外键，但是避开级联仍然是一个不同的话题。</p><p id="78e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使可以使用没有外键的级联，也不会这样做，因为级联隐藏了用于更新和删除的业务逻辑。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nj"><img src="../Images/6cdf73621d2759933f77d1f8b130f63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g2xpI3rDfXNANYju"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">由<a class="ae ls" href="https://unsplash.com/@agebarros?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿格巴洛斯</a>在<a class="ae ls" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="16cd" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">了解时区</h2><p id="a2fd" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">可以说，人类面临的最大时间问题是时区。时区总是给人一种含蓄的感觉，取决于地理环境，不包括臭名昭著的夏令时。</p><p id="4161" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用UTC保存时间戳，因为它是独立于位置和夏令时的全球标准。是使用专用类型还是仅使用整数定义的纪元时间取决于您。最后，所有与时间相关的操作都必须进行整数比较。</p><h2 id="148a" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">使用行时间戳</h2><p id="ff76" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">我建议您知道数据库中的每一行(文档)是何时创建、更新或删除的。您可以使用它来审计数据库和调试。此外，您可以使用这些时间戳进行排序，尤其是对于没有自然排序的实体。</p><h2 id="cbea" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">认识演员</h2><p id="be52" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">谁是<em class="nk">演员</em>？通过<em class="nk"> actor </em>，我指的是改变系统中数据的人或服务。用户可以使用提供的UI更改数据。当调度程序定期调用服务时，服务可以修改数据。</p><p id="57fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能希望在每次数据更改时都保存关于参与者的信息，至少为了日志记录和审计的目的。根据产品要求和可用资源，您需要决定报告系统的准确性。</p><h2 id="7e5d" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">使用编号枚举</h2><p id="fd21" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">当处理特定实体的状态或状况时，您可能倾向于将它们作为字符串保存在各自的数据库字段中。它可以让数据库管理员轻松地检查这些值。另一个论点是，你总是可以购买更多的磁盘空间。</p><p id="5d4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实可能介于两者之间，因为我认为使用整数类型需要精确的规划，节省空间(包括索引空间)，并允许更快的比较。此外，在恶意获取数据库数据的情况下，它对攻击者隐藏了部分业务逻辑。也就是说，我认为在产品的概念验证阶段使用基于字符的字段是合理的。</p><h2 id="e82b" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">限制列名长度</h2><p id="7dd2" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">我认为您应该尽可能缩短列名。我发现编写和阅读简洁的SQL查询更容易。如果您一直在发送大量的查询(您可能也希望使用内部存储的过程)，那么您可能会因为名称太长而导致额外的流量。</p><p id="18e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在将列名放入每个写入对象的NoSQL数据库中，如果坚持使用长字符串，可能会浪费大量磁盘空间！</p><h2 id="d83a" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">限制列值长度</h2><p id="e1c3" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">作为一个经验法则，你应该总是知道你需要多少空间来保存一个特定的值。</p><p id="1d9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据库引擎使用字节数而不是字符数来限制文本字段的长度。当使用Unicode字符串时，这可能会令人惊讶。此外，您应该检查文本列的编码和排序规则—您可能会在许多数据库级别(整个数据库、表或列)上应用这些属性。</p><p id="aa1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于实数，通常有三种类型:</p><ul class=""><li id="5138" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">使用2为基数的浮点单精度类型，</li><li id="f50c" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">浮点双精度类型(使用与前面相同的基数)，</li><li id="6eec" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">固定精度，基数为10。</li></ul><p id="573d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">存储实数可能是一个挑战，因为后端可能不支持与数据库相同的精度标准。</p><p id="45fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当使用整数时，我们需要在字段级分配足够的字节。我们应该决定是支持有符号数据还是无符号数据。同样，您的后端可能不支持与数据库相同的整数标准。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nl"><img src="../Images/1114904086b1375a761364064bf0a92f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k8_kQWb_J5tlGs2k"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae ls" href="https://unsplash.com/@3dparadise?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Braňo </a>在<a class="ae ls" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h2 id="1dc9" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">了解货币类型</h2><p id="56a2" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">数据库应该以整数、小数、字符串或特别设计的货币列来存储货币信息。对金钱使用浮点运算通常会导致灾难——一家体面的公司不会允许这种事情发生。</p><p id="b228" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主要问题是，我们的货币单位可以被10的幂整除，而不是被2的幂整除。因此，您无法使用浮点运算的大多数实现如实地表示它们，例如，使用IEEE-754标准。</p><p id="ea6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在字符串中存储金融数据有一个基本问题:<em class="nk"> locales </em>。不同的语言使用不同的分隔符来分隔数字的整数部分和小数部分。例如，英语用点，而德语用逗号。为了避免任何问题，您应该以一种格式存储所有的货币信息。</p><h1 id="ebe8" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">查询相关原则</h1><h2 id="e6a5" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">考虑读和写</h2><p id="eb20" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">在分布式系统中，后端每秒钟从数据库中读取和写入多次。这就是为什么你应该考虑数据库模式设计的关系(双关语！)来规划系统使用数据库的方式。</p><p id="93eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它每秒必须支持多少次写入？多少次阅读？能轻松分区吗？数据库支持分片吗？</p><p id="923b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该检查您的数据库引擎是否支持复制—如果您需要将读取操作重定向到读取副本并将写入保留到原始数据库，这可能会很方便。</p><h2 id="8f50" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">确保无读取的写入</h2><p id="59b9" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">如果您正在构建一个分布式系统，您可能希望确保您的写操作不依赖于您的读操作。这意味着您可以更新数据库中的表行，而无需知道它们以前的值。它形成了抛弃传统事务支持原子更新的方式之一。</p><p id="8a19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，要增加一个字段值，您可以获取前一个值，添加一个值，然后保存它，这需要两个操作。或者，您可以告诉数据库引擎一次性递增字段值。请注意，您选择的数据库可能不会公开后一种功能。</p><p id="57da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您的整个数据库都遵循这一原则，那么您应该能够通过从头开始重新构建数据库，并按顺序重放进入系统的所有命令和消息。</p><h2 id="c473" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">了解事务和隔离级别</h2><p id="76be" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">作为数据库模式的创建者，您应该完全了解所选数据库中可用的事务和隔离级别。一些数据库系统甚至可能不提供事务的功能。请注意，您不一定需要事务，因为您可以用两阶段提交或saga模式来替换它们。</p><p id="38ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您选择使用事务，您需要理解它们背后的锁定机制。如果使用外键或唯一键，锁定可能会被放大。以不同的顺序在事务中应用锁通常会导致死锁。</p><h2 id="196c" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">计划您的查询</h2><p id="843d" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">一旦准备好了模式，就应该计划应用层使用的查询。这是对您的模式可行性的又一次测试。一般来说，我会考虑分别编写和读取查询。</p><p id="2aff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编写查询通常由过滤部分和数据部分组成。在前者中，我们定义要更新的行的子集，在后者中，我们将哪些数据放入这些行。大多数过滤操作应该利用索引进行高效快速的查询。过滤应该产生我们想要更新的行的最小子集(<em class="nk">理想情况下是</em>)。每次更新都应该将一个完整的实体转换成另一个完整的实体。</p><p id="09e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以验证创建和更新对应用程序的意义是否相同，并将它们视为一个操作，在业内通常称为“<em class="nk"> upsert </em>”。至少对于数据库中的一些表来说，将所有关于写的想法替换为“<em class="nk"> upserts </em>”可以获得好处。</p><p id="af10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似的原则也适用于阅读。它由过滤部分和投影部分组成。如前所述，过滤应该使用效率指标。请考虑分页，因为您不太可能向产品的最终用户呈现不确定的行数。良好的投影确保数据库只返回我们需要的列。</p><p id="8615" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在某些数据库中，您可以将查询作为过程永久保存在数据库中。然后，您可以将部分业务逻辑从后端移开，专注于调用过程和格式化结果。</p><h2 id="13c3" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">规划你的指数</h2><p id="204a" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">当您完成了对查询的规划后，就应该规划索引了。</p><p id="5153" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一些SQL数据库强制执行聚集索引的概念。它定义了如何在磁盘上对行进行排序和存储。通常，主键是(应该是)聚集索引，但是要始终确保这一点。显而易见的结论是，主键也充当索引，这意味着使用它的读取查询应该已经过优化。</p><p id="f926" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于每个表(集合)，您可能希望收集针对它运行的所有CRUD查询，并准备所有候选索引。由于查询的复杂性和执行次数，不同的查询可能会对数据库性能产生不同的影响。此外，索引消耗磁盘空间，所以合理使用它们。</p><p id="e33c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据您的具体情况，您可能希望在以后或者当数据库引擎的性能显著下降时应用特定的索引。</p><p id="98ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在SQL数据库中，您可以使用唯一索引来强制相关主键之外的表行的唯一性。</p><p id="6342" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，一旦将适当的数据库模式编码到数据库中，就可以使用<code class="fe nm nn no np b">EXPLAIN</code>关键字(仅限SQL)来查看数据库引擎将如何执行特定的查询，尤其是在执行过程中可能会使用哪些索引。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nq"><img src="../Images/57c52b22e404eed57e558716278dda9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lc4jQVbjSyVA4gjd"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">韦斯利·廷吉在<a class="ae ls" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="2fed" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">实体相关原则</h1><h2 id="0ad0" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">使用单一来源的事实</h2><p id="e6fa" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">假设数据库由表(或集合)组成，我们应该确保每个表相对于其他表的独立性。我认为一个表应该包含一个特定模型类的数据，不多也不少——一个表应该作为这些实体的唯一来源。该规则唯一合理的例外是反规范化—用于读取优化。</p><h2 id="0c1f" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">使数据独立</h2><p id="ffef" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">随着时间的推移，产品会获得更多需要更改数据库模式的特性。这些更改通常会导致添加表(集合)和列。我将不讨论表和列的移除，因为这需要很多不同的场景。</p><p id="9ca6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当添加一个表(集合)时，我认为不应该改变现有的查询及其结果。如果您不使用外键和级联，这应该是一个微不足道的任务。</p><p id="b47d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在SQL数据库中添加列时，您应该始终确保:</p><ul class=""><li id="a43b" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">第一次迁移添加具有默认值(例如，空值或0)的列，</li><li id="3766" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">第二次迁移用适当的值填充该列，</li><li id="c30d" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">如果需要，第三次迁移会使列不可为空。</li></ul><p id="6408" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您计划使用非SQL数据库，请查看其关于添加列的文档—有时您不需要迁移，因为引擎会替您处理它。</p><p id="de53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个很好的经验法则是，强制对数据库模式的所有更改导致对应用程序中的查询、后端和视图的最小更改。</p><h2 id="db4d" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">使用单个主键</h2><p id="93e3" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">每个表(或集合)应该有一个主键。您应该避免使用复合主键，复合主键是跨越多列的键元组。复合索引比简单索引需要更多的磁盘空间；数据比较可能也需要更多的时间。我们还可以在许多列下创建一个值的<em class="nk">散列</em>，创建一个主键。</p><p id="f5f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我反对对主键使用整数序列。</p><p id="9a86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，如果您向最终用户公开这些整数，您的竞争对手可能知道您的表中有多少行！</p><p id="d54c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，序列生成器可能需要表级锁，以免两个新行以相同的主键结束。</p><p id="5448" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们不能在应用程序代码中设置主键的值。</p><p id="6663" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以使用UUID字段(或者只是一个固定长度的文本字段)来代替。它允许我们从一开始就控制主键的值。此外，我们不需要按照特定的顺序运行查询。为什么？因为我们不需要获得主键并将它传递到其他地方。</p><p id="3888" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过使用一个主键，我们可以很容易地在整个数据库中引用一个特定的行(尝试使用一个复合键)。此外，我们可以在整个系统中使用相同的值来引用它。</p><h2 id="6109" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">杠杆反规格化</h2><p id="f5bb" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">作为一名数据库模式设计者，您应该了解什么时候使用，什么时候不使用数据库规范化。在特定的情况下，例如，当我们需要提高读取的效率时，我们可能会引入受控的反规范化。</p><p id="5308" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着我们可以用额外的列来丰富特定的表，或者从存储在其他表中的数据创建表。如果我们不需要显示最新的信息，我们也可以生成物化视图。</p><h2 id="8b76" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">插入、更新和向上插入</h2><p id="14ee" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">对于那些刚刚听到“<em class="nk"> upsert </em>”这个词的人来说(我以前定义过，但是你可能已经忘记了！)—它是“更新”和“插入”的组合词。这意味着，如果数据库中已经存在某个特定条目，则更新该条目，否则创建一个新条目。</p><p id="c1a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以选择使用upsert操作系列将特定的记录写入数据库，而不管该记录以前是否存在以前的版本。如果是这样，您需要确保从系统的角度来看这是一个安全的操作。</p><p id="abb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用upsert操作代替单独的插入和更新大大简化了您的写查询。另一方面，您不再能够区分插入和更新，并且您不能编写依赖于这种区分的逻辑。</p><h2 id="6b16" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">只输入必要的空值</h2><p id="1304" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">在设计阶段，你就应该知道一个字段可能包含什么样的值。当你允许any持有一个<code class="fe nm nn no np b">NULL</code>值时，一定存在一个理由。基本原理可能来自产品需求或您选择的数据结构的内在特性。</p><p id="1c73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建和更新整个记录(文档),除非您想通过设计来保存部分信息。插入部分记录失败可能比保存不完整的数据要好。您的后端可能不会反序列化部分完成的实体，即使它们可以存在于正确设计的数据库中。</p><h2 id="6a06" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">避免使用默认值</h2><p id="95de" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">我很少依赖默认值，无论是数据库还是代码。通过在列定义中使用默认值，您分散了业务逻辑并创建了隐式行为。我写“隐式”是因为如果在写入特定字段时没有提供值，数据库会为您提供一个值。根据我的经验判断，跟踪隐性行为并不简单，我会尽可能地避免它。</p><p id="f8df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这同样适用于可空字段的缺省空值——我认为只有在添加新列和迁移特定表中已经存在的记录时才使用它们是合理的。</p><h2 id="7f52" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">保持实体独立</h2><p id="48e9" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">我相信你应该总是努力保持你的实体独立。这意味着您可以将整个表(或集合)移动到一个完全不同的数据库，而无需更改其他表。如果实现正确，当您的数据库将来需要分区时，这样的结构会给您更多的灵活性。</p><h2 id="3caf" class="mr lu it bd lv ms mt dn lz mu mv dp md kb mw mx mh kf my mz ml kj na nb mp nc bi translated">保留可恢复的实体</h2><p id="91ce" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">用户(有时是脚本)可能会错误地从数据库中删除信息。为了避免恢复此类信息时出现问题，我们可以在行级别使用特定的标记来标记要删除的行。之后，我们需要调整系统，只查找未标记的行。如果我们想恢复特定的行，我们可以翻转它们的标签。</p><h1 id="96b1" class="lt lu it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">摘要</h1><p id="c30e" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">数据库模式设计不是一个简单的话题。你建立的系统越多，基于你的成功和失败你会发现更多的结论。我发现在网上交换意见和学习他人的经验是至关重要的。</p><p id="b4b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一如既往，欢迎大家在评论区留下评论！</p></div></div>    
</body>
</html>