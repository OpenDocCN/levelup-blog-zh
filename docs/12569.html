<html>
<head>
<title>Are Web Components Dead?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件死了吗？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/are-web-components-dead-12e404e0f4b0?source=collection_archive---------3-----------------------#2022-06-20">https://levelup.gitconnected.com/are-web-components-dead-12e404e0f4b0?source=collection_archive---------3-----------------------#2022-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/29dde2e907028c10a1989eb0bde8b149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-iH_T_gw-LQ7cmxoyoONA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由来自Pexels 的克里斯·J·米切尔拍摄</figcaption></figure><p id="4892" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated"><span class="l lf lg lh bm li lj lk ll lm di"> R </span>最近，我发表了一篇关于类似主题的不同问题的文章:<a class="ae kf" href="https://medium.com/@mariusbongarts11/will-web-components-replace-frontend-frameworks-535891d779ba" rel="noopener">Web组件会取代前端框架吗？我们大多数人会说<strong class="ki iu">不</strong>。但是对于更有争议的问题，即<strong class="ki iu"> Web组件</strong>到底有没有未来，你的答案是什么？</a></p><p id="44ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们放大并探究为什么有些人说web组件已经死亡，而另一些人认为它们是Web开发的未来。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="f40f" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">介绍</h1><p id="21d8" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">2012年，当W3C发布了Web组件的第一个规范<a class="ae kf" href="https://www.w3.org/TR/2012/WD-components-intro-20120522/#decorators-vs-custom-elements" rel="noopener ugc nofollow" target="_blank">时，许多人预计Web组件将彻底改变前端开发。我们有充分的理由保持乐观。Web组件承诺了许多非凡的事情:</a></p><ul class=""><li id="177e" class="mx my it ki b kj kk kn ko kr mz kv na kz nb ld nc nd ne nf bi translated">具有普通HTML、CSS和Javascript的可重用组件</li><li id="4962" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated">基于<strong class="ki iu">官方网络标准</strong></li><li id="c104" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated"><strong class="ki iu">不需要框架</strong></li><li id="12f6" class="mx my it ki b kj ng kn nh kr ni kv nj kz nk ld nc nd ne nf bi translated">在<strong class="ki iu">所有evergreen浏览器中支持</strong></li></ul><p id="88af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，在没有任何框架的情况下，基于官方web标准创建可重用的独立HTML组件的想法听起来好得难以置信。尽管有很好的优势，Web组件仍然很难在整个行业得到采用。很多开发商说他们已经死了。</p><p id="f35e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谁是对的？Web组件的当前状态是什么？让我们详细地面对这些问题，并探索什么是web组件，在哪里可以找到它们，为什么开发人员不愿意使用它们，以及未来会如何。</p><div class="nl nm gp gr nn no"><a href="https://web-highlights.com/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">网络亮点- PDF和网络荧光笔</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Web Highlights是一个在Web上突出显示文本的工具，可以更有效地组织您的研究。提升你的…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">web-highlights.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc jz no"/></div></div></a></div></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="252b" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">什么是Web组件？</h1><p id="d29c" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">Web组件是基于官方web标准的可重用客户端组件，受所有主流浏览器支持。它们是将<strong class="ki iu">的</strong>功能<strong class="ki iu"> </strong>从我们剩余的代码中封装出来的绝佳方式。不仅如此，你还可以在每个网络应用程序和网页中重用它们。</p><p id="b6a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们的目的是编写在任何地方都可以使用的封装强大的定制元素。Web组件使我们能够完全独立于前端框架进行开发。</p><blockquote class="od oe of"><p id="f689" class="kg kh og ki b kj kk kl km kn ko kp kq oh ks kt ku oi kw kx ky oj la lb lc ld im bi translated">Web组件的主要好处是我们可以在任何地方使用它们。有任何框架，甚至没有框架。——【vuejs.org T2】</p></blockquote><p id="4bb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="og">它们是如何工作的？</em> </strong></p><p id="4d60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个如何定义<strong class="ki iu">自治web组件</strong>的例子:</p><pre class="ok ol om on gt oo op oq or aw os bi"><span id="af3f" class="ot lv it op b gy ou ov l ow ox">class MyWebComponent extends HTMLElement {...}</span><span id="e9dd" class="ot lv it op b gy oy ov l ow ox">window.customElements.define('my-web-component', MyWebComponent);</span></pre><p id="1bcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以将元素传递给任何HTML页面，如下所示:</p><p id="969c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oz pa pb op b">&lt;my-web-component value="something"&gt;&lt;/my-web-component&gt;</code></p><p id="72a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有关web组件的更多详细信息，请查看我的其他文章:</p><div class="nl nm gp gr nn no"><a href="https://medium.com/@mariusbongarts11/the-complete-web-component-guide-part-1-custom-elements-a627af805df8" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">完整的Web组件指南:自定义元素</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">成为Web开发未来的专家(第1部分)</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="pc l nz oa ob nx oc jz no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://javascript.plainenglish.io/showcase-your-medium-articles-with-web-components-part-1-basics-d2c6618e9482" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">用Web组件构建自己的博客组合:基础</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">第1部分—定制元素、阴影DOM和HTML模板</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nx l"><div class="pd l nz oa ob nx oc jz no"/></div></div></a></div></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="48ed" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak">在哪里可以找到Web组件？</strong></h1><p id="4a16" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">web开发世界无疑被前端框架/库所统治，如<strong class="ki iu"> React、Angular和vue . js。</strong></p><figure class="ok ol om on gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi pe"><img src="../Images/0d5ad5404ba2f0cf1330bcfe2126c672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Be5H-zZxsDXFhWt_U3AXHA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://2021.stateofjs.com/en-US/libraries/front-end-frameworks/" rel="noopener ugc nofollow" target="_blank">Js 2021的状态</a></figcaption></figure><p id="b133" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2021年JavaScript现状调查显示，80 %的受访者使用过<strong class="ki iu"> React </strong>，其次是<strong class="ki iu"> Angular </strong> (54 %)和<strong class="ki iu"> Vue.js </strong> (51 %)。还有，<strong class="ki iu">苗条</strong>上升很快，用户越来越多。现在，<strong class="ki iu"> Web组件</strong>在这个排名中出现在哪里？Web组件完全基于web标准，所以我们不希望在这里列出它们。尽管如此，还是有像Lit这样的库支持我们构建它们。毕竟至少有7 %的受访者用过。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h2 id="d6a5" class="ot lv it bd lw pf pg dn ma ph pi dp me kr pj pk mi kv pl pm mm kz pn po mq pp bi translated"><strong class="ak">前端框架适应Web组件</strong></h2><p id="fd02" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">然而，这只是事实的一半。最常用的前端框架最近已经被大量采用。它们都支持构建官方的基于标准的Web组件。</p><p id="8c9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们以<strong class="ki iu"> Angular </strong>为例，它提供了<code class="fe oz pa pb op b">@angular/elements</code>包，使开发人员能够快速地将组件转换成Web组件。</p><blockquote class="pq"><p id="e874" class="pr ps it bd pt pu pv pw px py pz ld dk translated">“角度元素是打包为定制元素的角度组件[…]”—<a class="ae kf" href="https://angular.io/guide/elements" rel="noopener ugc nofollow" target="_blank">Angular . io</a></p></blockquote><p id="e2d8" class="pw-post-body-paragraph kg kh it ki b kj qa kl km kn qb kp kq kr qc kt ku kv qd kx ky kz qe lb lc ld im bi translated">Angular Elements是Angular框架的一个最小的独立版本。它作为服务注入，以支持组件的变更检测和数据绑定功能。如果你对Angular Elements如何详细工作感兴趣，这里有一个由Rob Wormald 制作的有趣的<a class="ae kf" href="https://www.youtube.com/watch?v=Z1gLFPLVJjY&amp;t=4s" rel="noopener ugc nofollow" target="_blank"> Youtube视频。</a></p><p id="1c89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，<strong class="ki iu"> Vue.js </strong>支持通过<code class="fe oz pa pb op b">defineCustomElement</code>方法创建Web组件。</p><blockquote class="pq"><p id="6aa2" class="pr ps it bd pt pu pv pw px py pz ld dk translated"><em class="qf">“Vue支持使用完全相同的Vue组件API创建定制元素[…]”——</em><a class="ae kf" href="https://v3.vuejs.org/guide/web-components.html#passing-dom-properties" rel="noopener ugc nofollow" target="_blank"><em class="qf">vuejs.org</em></a></p></blockquote><p id="8b56" class="pw-post-body-paragraph kg kh it ki b kj qa kl km kn qb kp kq kr qc kt ku kv qd kx ky kz qe lb lc ld im bi translated">让最流行和最常用的框架适应Web组件表明它们的创造者对Web组件的未来下了赌注。</p><div class="nl nm gp gr nn no"><a href="https://medium.com/@mariusbongarts/react-vs-web-components-80d754f74811" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">React与Web组件</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">将它们结合起来是成功的真正秘诀。</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="qg l nz oa ob nx oc jz no"/></div></div></a></div></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h2 id="5ab6" class="ot lv it bd lw pf pg dn ma ph pi dp me kr pj pk mi kv pl pm mm kz pn po mq pp bi translated">Web组件的使用</h2><p id="47c9" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">正如我们所见，Web组件比我们想象的更加普遍。然而，有时仍然使用框架来创建它们。但是，我们如何衡量Web组件的实际使用情况呢？一种方法是查看网站通过调用<code class="fe oz pa pb op b">customElements.define</code>注册至少一个<a class="ae kf" href="https://medium.com/@mariusbongarts11/the-complete-web-component-guide-part-1-custom-elements-a627af805df8" rel="noopener"> <strong class="ki iu">自定义元素</strong> </a> <strong class="ki iu"> </strong>的频率。</p><p id="8bda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提醒一下，下面是定义自定义元素的方法:</p><pre class="ok ol om on gt oo op oq or aw os bi"><span id="e3fc" class="ot lv it op b gy ou ov l ow ox">class MyWebComponent extends HTMLElement {...}</span><span id="7453" class="ot lv it op b gy oy ov l ow ox">window.customElements.define('my-web-component', MyWebComponent);</span></pre><p id="1c9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于Chrome，我们可以通过检查<a class="ae kf" href="https://chromestatus.com/metrics/feature/timeline/popularity/1689" rel="noopener ugc nofollow" target="_blank">chromestatus.com</a>上的CustomElementRegistryDefine功能使用情况来实现:</p><figure class="ok ol om on gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi qh"><img src="../Images/92a49a60398c745301e69e30a550a206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A0s5Wn4N8mCtKHbBkXZoRA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用CustomElementRegistryDefine的页面加载百分比(Chrome)</figcaption></figure><p id="615a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以看到在所有网站的<strong class="ki iu"> 17 % </strong>左右，在Chrome浏览器中查看，至少注册了一个<a class="ae kf" href="https://medium.com/@mariusbongarts11/the-complete-web-component-guide-part-1-custom-elements-a627af805df8" rel="noopener"> <strong class="ki iu">自定义元素</strong> </a>。对我来说，Web组件的急剧增长令人震惊。相比之下，根据<a class="ae kf" href="https://w3techs.com/technologies/comparison/js-angularjs,js-react" rel="noopener ugc nofollow" target="_blank">w3techs.com</a>的数据，所有网站中只有<strong class="ki iu"> 2.9 % </strong>(状态:2022年6月)使用React。</p><p id="c475" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来Web组件的使用率比我们大多数人预期的要高(至少，我是这么认为的)。但是，大公司呢？在查看职位描述时，大多数都要求至少有一个最常用的前端框架的经验——React、Angular和Vue.js。那么，有公司要求了解Web组件吗？有没有大公司认为Web组件是实现前端的最佳方式？</p><p id="f6ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最著名的例子之一就是<strong class="ki iu"> Github </strong>。当Github在十多年前推出时，它有一个主要使用jQuery的前端代码库。多年来，他们的GitHub monolith规模越来越大，他们发现有必要在前端变得难以管理之前实现更好的封装。他们选择使用Web组件，因为他们的代码库已经被结构化为类似组件的行为。此外，他们可以在现有的前端基础设施上试验Web组件，因为这不会产生任何前期成本或“买入”特定的框架。</p><blockquote class="pq"><p id="7440" class="pr ps it bd pt pu pv pw px py pz ld dk translated">“我们在GitHub大量使用Web组件”——<a class="ae kf" href="https://github.blog/2021-05-04-how-we-use-web-components-at-github/" rel="noopener ugc nofollow" target="_blank">GitHub . blog</a></p></blockquote><p id="fa6d" class="pw-post-body-paragraph kg kh it ki b kj qa kl km kn qb kp kq kr qc kt ku kv qd kx ky kz qe lb lc ld im bi translated">但是，当使用Web组件导航到前端基础设施时，Github也面临许多问题。对于Web组件的当前状态，所有开发人员都有一些共同的<strong class="ki iu">痛点</strong>。这引出了我们的下一个问题。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="66c5" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">为什么开发者不愿意使用web组件？</h1><p id="49f1" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">正如开头提到的，有很多理由相信Web组件可以取代现代前端框架。现在，很多开发人员仍然不愿意使用Web组件。这是为什么呢？是因为他们觉得Web组件会淘汰前端框架的想法威胁到了他们吗？正如我在以前的文章中分析的那样，Web组件会取代前端框架吗？’—没有理由放弃你的前端框架。恰恰相反，将前端框架与Web组件相结合才是成功的真正秘诀。</p><blockquote class="pq"><p id="47ef" class="pr ps it bd pt pu pv pw px py pz ld dk translated"><em class="qf">作为开发人员，您可以自由地在您的Web组件中使用React，或者在React中使用Web组件，或者两者都使用。— </em> <a class="ae kf" href="https://reactjs.org/docs/web-components.html" rel="noopener ugc nofollow" target="_blank"> <em class="qf"> reactjs .或</em> </a> g</p></blockquote><p id="caa3" class="pw-post-body-paragraph kg kh it ki b kj qa kl km kn qb kp kq kr qc kt ku kv qd kx ky kz qe lb lc ld im bi translated">然而，不可回避的事实是，Web组件还没有完全开发出来，面临着许多问题和痛点。</p><h2 id="715d" class="ot lv it bd lw pf pg dn ma ph pi dp me kr pj pk mi kv pl pm mm kz pn po mq pp bi translated"><strong class="ak">Web组件的问题</strong></h2><p id="bc91" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">让我们看看Web组件在当前状态下面临的困难。以下是开发人员在工作中最常见的一些问题。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="16a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">阴影DOM </strong></p><p id="2236" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Web组件的一个痛点是<a class="ae kf" href="https://medium.com/@mariusbongarts11/the-complete-web-component-guide-shadow-dom-2e40921eb77" rel="noopener">影子DOM </a>。虽然完全封装组件的标记和样式的想法很好，但是仍然有许多挑战和未解决的问题。例如，如何将<strong class="ki iu">全局样式</strong>应用于带有影子根的Web组件？事实上，阴影DOM允许我们通过使用<strong class="ki iu">阴影部分</strong>和<strong class="ki iu"> CSS变量</strong>在它们的根中修改样式。此外，有许多方法和变通办法来应用全局样式，但我还没有看到最终的解决方案。</p><div class="nl nm gp gr nn no"><a href="https://medium.com/@mariusbongarts/the-complete-web-component-guide-shadow-dom-2e40921eb77" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">完整的Web组件指南:影子DOM</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">成为Web开发未来的专家(第3部分)</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="pc l nz oa ob nx oc jz no"/></div></div></a></div><p id="a8fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Github 在使用影子DOM时也面临问题，并且支持一个针对<a class="ae kf" href="https://github.com/whatwg/dom/issues/831" rel="noopener ugc nofollow" target="_blank">声明性影子DOM</a>的开放Github提议。这可以解决开发人员在使用影子根时面临的一些常见问题。</p><blockquote class="od oe of"><p id="45e3" class="kg kh og ki b kj kk kl km kn ko kp kq oh ks kt ku oi kw kx ky oj la lb lc ld im bi translated">这些提议将使工程师更容易发布Web组件，并将解决我们在Web组件的当前状态下遇到的一些常见的棘手问题。— <a class="ae kf" href="https://github.blog/2021-05-04-how-we-use-web-components-at-github/" rel="noopener ugc nofollow" target="_blank"> github.blog </a></p></blockquote><p id="4d43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，这个提议的主要动机是支持Web组件的服务器端呈现(SSR)。这就引出了下一个问题。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="0f58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">服务器端渲染</strong></p><p id="12b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有现代框架都提供了一种在服务器端呈现组件的方式。比如Angular提供<strong class="ki iu">角度通用</strong>，React a <strong class="ki iu"> ReactDOMServer </strong>，Vue.js提供<code class="fe oz pa pb op b">renderToString</code>功能。</p><p id="7ed3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将<strong class="ki iu"> SSR </strong>与Web组件结合使用实际上<strong class="ki iu">很难</strong>或<strong class="ki iu">不可能</strong>使用。Web组件依赖于服务器上不可用的浏览器特定的DOM APIs。至少在您使用像Puppeteer这样的无头浏览器来预渲染组件并向浏览器发送初始字符串之前不会。但是，即使在预渲染组件时，我们也不能使用影子DOM，因为我们还不能声明性地表示它们。所以不可能用HTML的初始字符串发过去。简而言之:<strong class="ki iu">要使用影子DOM，我们需要JavaScript </strong>。</p><p id="f7f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，像Lit或Stencil这样的库可以帮助我们构建Web组件。Stencil已经提供了他们的<a class="ae kf" href="https://stenciljs.com/docs/hydrate-app" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">水合物App-Bundle </strong> </a>来完成SSR，并且<a class="ae kf" href="https://medium.com/@mariusbongarts/build-your-own-blog-portfolio-with-web-components-lit-library-2701dffc735f" rel="noopener"><strong class="ki iu"/></a>也正在为服务器端渲染制作一个<code class="fe oz pa pb op b">@lit-lab/ssr</code>包。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="a862" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">无障碍</strong></p><p id="f148" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Web组件时，我们需要记住的另一个问题是可访问性。<strong class="ki iu">可访问性</strong>旨在为每个人提供一个普遍可访问的全球信息系统。这样，我们可以确保残障人士可以使用所有网站工具和技术。</p><div class="nl nm gp gr nn no"><a href="https://medium.com/@mariusbongarts/4-simple-steps-to-make-your-website-accessible-a29ec305da1e" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">让你的网站易于访问的4个简单步骤</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">“网络的力量在于它的普遍性。无论是否残疾，每个人都能获得是一个重要方面。”—…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="qi l nz oa ob nx oc jz no"/></div></div></a></div><p id="72d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个问题还可以追溯到<a class="ae kf" href="https://medium.com/@mariusbongarts/the-complete-web-component-guide-shadow-dom-2e40921eb77" rel="noopener"> <strong class="ki iu">暗影DOM </strong> </a>。通常，您创建DOM节点并将它们作为另一个元素的子元素追加。使用Shadow DOM，您可以创建一个作用域DOM树，它附加到元素上，但与其实际的子元素分开。这个限定了作用域的子树被称为<strong class="ki iu">影子树</strong>，本质上是一个独立的文档。拥有一个新文档意味着如果在影子DOM中设置了一个id，那么它在定制元素中必须是惟一的。</p><blockquote class="pq"><p id="594c" class="pr ps it bd pt pu pv pw px py pz ld dk translated">Web组件被迫使用ARIA来声明它们的默认语义。— <a class="ae kf" href="https://wicg.github.io/aom/explainer.html" rel="noopener ugc nofollow" target="_blank"> wicg.github.io </a></p></blockquote><p id="dea5" class="pw-post-body-paragraph kg kh it ki b kj qa kl km kn qb kp kq kr qc kt ku kv qd kx ky kz qe lb lc ld im bi translated">希望您知道，通过使用正确的<a class="ae kf" href="https://javascript.plainenglish.io/stop-using-divs-for-buttons-87a0b3d7945e" rel="noopener ugc nofollow" target="_blank">语义元素</a>，您可以直接为像<strong class="ki iu">按钮</strong>或<strong class="ki iu">表单</strong>这样的元素提供内置的可访问性特性。不幸的是，在创建定制元素时，我们必须自己添加所有这些属性来提供相同的可访问性特性。理想情况下，定制元素应该像本地元素一样具有默认的隐式语义。幸运的是，有一个<a class="ae kf" href="https://wicg.github.io/aom/explainer.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">可访问性对象模型(AOM) </strong> </a>的提议，旨在使用<code class="fe oz pa pb op b">ElementInternals</code>来包含这个。</p><blockquote class="od oe of"><p id="217e" class="kg kh og ki b kj kk kl km kn ko kp kq oh ks kt ku oi kw kx ky oj la lb lc ld im bi translated"><strong class="ki iu">可访问性对象模型</strong>项目旨在改善用户和开发者在网页和辅助技术交互方面的体验。— <a class="ae kf" href="https://wicg.github.io/aom/spec/" rel="noopener ugc nofollow" target="_blank"> wicg.github.io </a></p></blockquote><p id="b829" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目前，我们被迫在我们的Web组件中使用所谓的<strong class="ki iu"> ARIA属性</strong>来表达对于本地元素来说是隐含的语义。例如，如果我们像这样在元素上使用<code class="fe oz pa pb op b">selected</code>属性:</p><p id="b3e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oz pa pb op b">&lt;custom-option selected&gt;&lt;/custom-option&gt;</code></p><p id="9f0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还需要给它添加一个<strong class="ki iu"> ARIA </strong> <strong class="ki iu">属性</strong>，以提供内置的辅助功能:</p><p id="818c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oz pa pb op b">&lt;custom-option selected aria-selected="true"&gt;&lt;/custom-option&gt;</code></p><p id="343b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> AOM </strong>现在建议使用<code class="fe oz pa pb op b">ElementInternals</code>来设置默认语义，以避免需要额外的属性，并且避免在开发人员忘记添加<strong class="ki iu"> ARIA属性</strong>时丢失其语义。</p><p id="2f4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe oz pa pb op b">ElementInternals</code>会是这样的:</p><pre class="ok ol om on gt oo op oq or aw os bi"><span id="1cc3" class="ot lv it op b gy ou ov l ow ox"><strong class="op iu">class</strong> CustomOption <strong class="op iu">extends</strong> HTMLElement {<br/>  <strong class="op iu">constructor</strong>() {<br/>    <strong class="op iu">super</strong>();<br/>    <strong class="op iu">this</strong>._internals <strong class="op iu">=</strong> customElements.createInternals(<strong class="op iu">this</strong>);<br/>  }<br/>  // ...</span><span id="a595" class="ot lv it op b gy oy ov l ow ox">}</span></pre><p id="b2cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">毕竟，我们可以说为我们的Web组件提供可访问性是可能的。但是，目前它仍然需要一些额外的努力。</p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="727c" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">未来会怎样？</h1><p id="1207" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">事实上，所有现代前端框架都依赖于Web组件，这表明它们的创建者正在用它们进行长期规划。但是，正如我们所看到的，目前，使用Web组件仍然会遇到一些不小的问题。这就是为什么大多数决定走Web组件路线的公司使用库来使他们的生活更容易。比如Github就在用<a class="ae kf" href="https://github.com/github/catalyst" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">催化剂</strong> </a>。就我个人而言，我喜欢使用Catalyst从中获得灵感的<a class="ae kf" href="https://medium.com/@mariusbongarts/build-your-own-blog-portfolio-with-web-components-lit-library-2701dffc735f" rel="noopener"> <strong class="ki iu"> Lit </strong> </a>库。</p><blockquote class="pq"><p id="31a8" class="pr ps it bd pt pu pv pw px py pz ld dk translated">Catalyst，我们的开源库，让编写web组件变得更加容易— <a class="ae kf" href="https://github.blog/2021-05-04-how-we-use-web-components-at-github/" rel="noopener ugc nofollow" target="_blank"> github.blog </a></p></blockquote><p id="ff95" class="pw-post-body-paragraph kg kh it ki b kj qa kl km kn qb kp kq kr qc kt ku kv qd kx ky kz qe lb lc ld im bi translated">不光Github打Web组件的路子。像<strong class="ki iu"> Youtube </strong>、<strong class="ki iu"> SAP </strong>、<strong class="ki iu"> Salesforce、</strong>等更多的公司已经意识到将Web组件与他们当前的前端架构相结合是封装他们的应用程序的一个很好的方式。</p><blockquote class="pq"><p id="53b7" class="pr ps it bd pt pu pv pw px py pz ld dk translated">YouTube正在用网络组件重建-<a class="ae kf" href="https://react-etc.net/entry/youtube-is-being-rebuilt-on-web-components-and-polymer" rel="noopener ugc nofollow" target="_blank">react-etc.net</a></p></blockquote><p id="77f2" class="pw-post-body-paragraph kg kh it ki b kj qa kl km kn qb kp kq kr qc kt ku kv qd kx ky kz qe lb lc ld im bi translated">有这么大的公司依赖Web组件支持了我的个人观点，没有<strong class="ki iu"> Web组件</strong>就没有未来。但是，没有<strong class="ki iu">前端框架</strong>也没有不远的将来。Web组件的目标从来不是取代它们，而是增强它们。</p><p id="7c4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">没必要讨厌Web组件。</strong></p></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="d23c" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">最后的想法</h1><p id="34b9" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">总之，对每个开发人员来说，至少听说过Web组件，甚至知道如何使用它们是有益的。现有的提议有望解决Web组件的许多问题。我们可以使用Lit、Stencil或Catalyst等库来避免它们。所有现代前端框架和许多大公司都依赖Web组件，这清楚地表明<strong class="ki iu"> Web组件并没有消亡</strong>。</p><p id="3d8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="og">感谢阅读！如果你喜欢这样的科技故事，想支持我永远坚持写作，可以考虑</em> <a class="ae kf" href="https://medium.com/@mariusbongarts/membership" rel="noopener"> <em class="og">报名成为中等会员</em> </a> <em class="og">。每月5美元，你可以无限制地阅读媒体上的故事。如果你</em> <a class="ae kf" href="https://medium.com/@mariusbongarts/membership" rel="noopener"> <em class="og">用我的链接</em> </a> <em class="og">注册，我会赚一小笔佣金。</em></p><p id="33d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="og">你也可以关注我的</em> <a class="ae kf" href="https://medium.com/@mariusbongarts" rel="noopener"> <em class="og">中</em></a><a class="ae kf" href="https://twitter.com/MariusBongarts" rel="noopener ugc nofollow" target="_blank"><em class="og">推特</em></a><a class="ae kf" href="https://www.linkedin.com/in/marius-bongarts-6b3638171/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><em class="og">。或者</em> <a class="ae kf" href="https://medium.com/subscribe/@mariusbongarts" rel="noopener"> <em class="og">订阅</em> </a> <em class="og">通过邮件获取我的故事。</em></p><div class="nl nm gp gr nn no"><a href="https://medium.com/@mariusbongarts/membership" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">通过我的推荐链接加入Medium-Marius bong arts</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="qj l nz oa ob nx oc jz no"/></div></div></a></div></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="4bee" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">关于作者</h1><p id="206e" class="pw-post-body-paragraph kg kh it ki b kj ms kl km kn mt kp kq kr mu kt ku kv mv kx ky kz mw lb lc ld im bi translated">我是埃森哲软件工程分析师宋。最驱动我的是我想创造一些可能对他人有帮助并改变他人生活的东西的冲动。比如你是否厌倦了浏览自己的历史来寻找前几天看到的信息？我的<a class="ae kf" href="https://chrome.google.com/webstore/detail/web-highlights-%20-bookmark/hldjnlbobkdkghfidgoecgmklcemanhm" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">网站重点介绍Chrome扩展</strong> </a>覆盖了你，并将通过以结构化和高效的方式组织你的研究来提高你的生产力。就像你在书和文章上做的那样，突出显示任何网页或PDF上的文本。你的精彩片段会直接同步到web-highlights.com<a class="ae kf" href="https://web-highlights.com/" rel="noopener ugc nofollow" target="_blank">的网络应用上，你可以在任何地方找到它们。</a></p><div class="nl nm gp gr nn no"><a href="https://chrome.google.com/webstore/detail/web-highlights-pdf-web-hi/hldjnlbobkdkghfidgoecgmklcemanhm" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">Web亮点— PDF和Web荧光笔</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">在每个网站或PDF上创建亮点、书签、标签和文件夹。以结构化的方式组织您的想法和研究…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">chrome.google.com</p></div></div><div class="nx l"><div class="qk l nz oa ob nx oc jz no"/></div></div></a></div></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="d206" class="lu lv it bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">进一步阅读</h1><div class="nl nm gp gr nn no"><a href="https://medium.com/@mariusbongarts/will-web-components-replace-frontend-frameworks-535891d779ba" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">Web组件会取代前端框架吗？</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">它们是为解决不同的问题而构建的。</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="ql l nz oa ob nx oc jz no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://medium.com/@mariusbongarts11/my-journey-to-the-first-9-99-with-my-side-project-3edc13dd1f2d" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">我的第一个9.99美元之旅与我的副业</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Chrome扩展带来的被动收入</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="qm l nz oa ob nx oc jz no"/></div></div></a></div></div></div>    
</body>
</html>