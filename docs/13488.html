<html>
<head>
<title>TypeScript Destructuring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本析构</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-destructuring-1ec4c747b5e2?source=collection_archive---------9-----------------------#2022-09-08">https://levelup.gitconnected.com/typescript-destructuring-1ec4c747b5e2?source=collection_archive---------9-----------------------#2022-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3db8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过使用析构赋值语法来简化代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5eda5a893bdd3817f8b0dcb1bc5e7704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vz7xIGy8rn_Bh9Fh"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">沃洛季米尔·赫里先科在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="2cf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文试图总结析构在TypeScript中的使用，并以最常见的用例为例，供您进行交互和体验。</p><p id="ed70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Mozzila对析构有一个很好的正式定义:</p><blockquote class="lv lw lx"><p id="0af4" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">析构赋值语法是一个JavaScript表达式，它可以将数组中的值或对象中的属性解包到不同的变量中。<br/> <strong class="lb iu">来源:</strong> Mozzila网络文档</p></blockquote><p id="c12f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法避免了在解包数组元素或对象属性时的重复，并使代码更整洁、更易读。</p><p id="98b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">析构赋值允许我们定义什么值(在数组的情况下)或属性(在对象的情况下)要从源变量解包到赋值的左边。</p><p id="8c95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于对象和数组的析构，有两种析构模式:<em class="ly">绑定模式</em>和<em class="ly">赋值模式</em>。</p><p id="aa73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看每个图案的含义。</p><h2 id="3eb1" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><em class="mv">装订模式</em></h2><p id="94a4" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">当使用绑定模式时，这意味着我们从声明一个变量(赋值的左边)开始，这个变量将被绑定到源变量(赋值的右边)中存在的值。下面一个简单的例子使用了一个对象。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="b75e" class="mc md it nc b gy ng nh l ni nj">const person: Person = { name: 'John', age: 28 };<br/>const { name, age } = person;</span><span id="9b6d" class="mc md it nc b gy nk nh l ni nj">console.log(name, age); // John 28</span></pre><h2 id="a5af" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated"><em class="mv">分配模式</em></h2><p id="de87" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在赋值模式中，我们不是从声明一个变量开始，而是使用一个已经存在的变量或另一个对象的属性(赋值的左侧)，它们的工作方式类似于被析构的源变量的目标(赋值的右侧)。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="8f2a" class="mc md it nc b gy ng nh l ni nj">const order = { priceBeforeVAT: 10, priceAfterVAT: 12.3 };<br/>const prices = [];</span><span id="f469" class="mc md it nc b gy nk nh l ni nj">({ <!-- -->priceBeforeVAT:prices<!-- -->[0]<!-- --> <!-- -->, <!-- -->priceAfterVAT<!-- -->: <!-- -->prices<!-- -->[1] } = <!-- -->order<!-- -->)</span><span id="0999" class="mc md it nc b gy nk nh l ni nj">console.log(prices) // [10, 12.3]</span></pre><p id="80d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面几节展示了如何在不同的场景中使用析构，并包含了每个示例的背景。</p><h1 id="ac6c" class="nl md it bd me nm nn no mh np nq nr mk jz ns ka mn kc nt kd mq kf nu kg mt nv bi translated">破坏场景</h1><p id="e00f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在这一部分，我收集了一些我经常遇到的例子。我们将使用投标模式。</p><p id="cb45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一看。</p><h2 id="cc42" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">对象析构</h2><p id="33b9" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">这可能是析构最常见的用例。</p><div class="nw nx gp gr ny nz"><a href="https://replit.com/@NunoBrites/objectdestructuring" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">object _ destructing-TypeScript Repl</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">跳转到我的加密货币上为智能合约制作的内容进行中的编程语言。还没有…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">replit.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div><p id="8969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码被分成多个例子来演示对象析构的不同用法。</p><p id="7396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">属性解包:</strong>允许使用赋值左边的<code class="fe oo op oq nc b">{}</code>将一个属性从一个对象中解包并赋给一个变量(见<strong class="lb iu">例1 </strong>)。</p><p id="31c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">属性重命名:</strong>一个非常有用的选项是在析构时重命名属性；当析构两个相同类型的对象时，这可以避免名称冲突(见<strong class="lb iu">例2 </strong>)。</p><p id="794f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">属性默认值:</strong>可以设置一个属性的默认值，但是只有当该属性在对象实例中不存在，或者该属性的值为<code class="fe oo op oq nc b">undefined</code>，<code class="fe oo op oq nc b">null</code>值不回退到默认值时，才会使用默认值(参见<strong class="lb iu">示例3)。</strong></p><p id="19d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">剩余属性:</strong>也可以从一个对象中排除几个属性，并析构原始对象属性的子集(见<strong class="lb iu">例4 </strong>)。</p><p id="5628" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">📝<strong class="lb iu"> <em class="ly">例4 </em> </strong> <em class="ly">关于剩余属性也可以应用于数组但是它将包含数组的剩余值而不是对象的剩余属性。</em></p><p id="1aa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以组合属性解包、重命名、默认值和剩余属性(参见<strong class="lb iu">示例5 </strong>)。</p><h2 id="1bbe" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">数组析构</h2><p id="55cd" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">类似于我们在上面看到的对象析构，但是这次我们将解包值而不是属性。</p><div class="nw nx gp gr ny nz"><a href="https://replit.com/@NunoBrites/arraydestructuring" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">array _ destructing-TypeScript Repl</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">跳转到我的加密货币上为智能合约制作的内容进行中的编程语言。还没有…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">replit.com</p></div></div><div class="oi l"><div class="or l ok ol om oi on ks nz"/></div></div></a></div><p id="cc02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们有一个订单数组，其中每个元素都是一个对象。解包数组值的语法略有不同，因为它在赋值的左边使用了<code class="fe oo op oq nc b">[]</code>而不是<code class="fe oo op oq nc b">{}</code>，就像我们看到的对象一样。</p><h2 id="47ac" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">函数声明析构</h2><p id="a2a3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">最后一个示例显示了一个函数，该函数接收一个对象作为参数，解包对象属性，并在函数体中使用它们。</p><div class="nw nx gp gr ny nz"><a href="https://replit.com/@NunoBrites/functiondestructuring" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">function _ destructing-TypeScript Repl</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">类型脚本中的函数析构</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">replit.com</p></div></div><div class="oi l"><div class="os l ok ol om oi on ks nz"/></div></div></a></div><h1 id="8f55" class="nl md it bd me nm nn no mh np nq nr mk jz ns ka mn kc nt kd mq kf nu kg mt nv bi translated">包扎</h1><p id="d3ca" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">除了上面的例子，还有其他地方可以使用析构，比如元组、<code class="fe oo op oq nc b">for...in</code>和<code class="fe oo op oq nc b">for...of</code>循环的循环变量或者在<code class="fe oo op oq nc b">catch</code>子句绑定变量中使用析构。</p><p id="904e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于析构的更多细节，请看Mozzila的Web文档，你会发现上面的例子和更多的细节。</p><p id="8b1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章以简单而有帮助的方式总结了TypeScript中的析构。</p><p id="b670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何建议或贡献，欢迎在下面评论。感谢您的阅读和快乐编码！</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><h1 id="6c66" class="nl md it bd me nm pa no mh np pb nr mk jz pc ka mn kc pd kd mq kf pe kg mt nv bi translated">分级编码</h1><p id="8018" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="96fc" class="pf pg it lb b lc ld lf lg li ph lm pi lq pj lu pk pl pm pn bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="3081" class="pf pg it lb b lc po lf pp li pq lm pr lq ps lu pk pl pm pn bi translated">📰查看<a class="ae ky" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="1b82" class="pf pg it lb b lc po lf pp li pq lm pr lq ps lu pk pl pm pn bi translated">🔔关注我们:<a class="ae ky" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae ky" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae ky" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="d276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🚀👉<a class="ae ky" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>