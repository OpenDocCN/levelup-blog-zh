<html>
<head>
<title>It’s OK to Panic in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋里慌是可以的</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/its-ok-to-panic-in-go-8169e4e3ce6c?source=collection_archive---------3-----------------------#2020-05-06">https://levelup.gitconnected.com/its-ok-to-panic-in-go-8169e4e3ce6c?source=collection_archive---------3-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/23c2b33d98ac245360cfabd2a2608c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qq-zOnj_b4MVVugC"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@moino007?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> DDP </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="26e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Go的错误处理非常明确。与其他语言相比，它也可能非常冗长。我想谈谈我们如何通过将<em class="le">预期的</em>和<em class="le">非预期的</em>错误分开，来最小化对显式错误处理的需求。</p><h2 id="ceb0" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">预期误差</h2><p id="e8f2" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">预期错误通常是您可以提前测试/检查/验证的，或者不会对系统产生不利影响的。预期错误的一些例子有:</p><ol class=""><li id="9a1e" class="md me it ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated">从输入中验证电子邮件地址。</li><li id="7762" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">验证用户有权访问系统的某个部分。</li><li id="dd59" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">在已知的易损坏或缓慢的API端点上重试。</li></ol><p id="065d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">预期的错误应该总是返回一个错误。这让呼叫者决定在这种情况下做什么。它可能希望消除错误，或者选择退出当前操作。</p><p id="cc71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是显式错误处理代码真正出彩的地方(与隐式错误处理如异常相比)，因为您必须决定在这种情况下做什么。</p><h2 id="6825" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">意外错误</h2><p id="ebc8" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">意外错误是指会将系统置于不合理的状态，或者在没有明确处理该情况的情况下无法恢复的错误。</p><p id="e1f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">意外错误的一些示例如下:</p><ol class=""><li id="86bb" class="md me it ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated"><strong class="ki iu">除以零。</strong>在围棋中这将引起恐慌。有时候我们知道要提前检查(比如<code class="fe mr ms mt mu b">len(myslice) == 0</code>)并做出相应的处理，但并不总是这样。</li><li id="b2a3" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated"><strong class="ki iu">数据库不可用或变得不可用。</strong>当然，假设你使用的是数据库。申请可能无法继续。</li><li id="0d13" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated"><strong class="ki iu">不可能或无效的状态。</strong>例如，如果您的应用程序依赖于一个用户会话，而该会话在某个时候变得为零，那么当<code class="fe mr ms mt mu b">nil</code>会话被取消引用时，您几乎肯定会遇到麻烦。我们不需要在每次函数调用时检查<code class="fe mr ms mt mu b">nil</code>会话，因为我们期望<em class="le">它在应用程序正常运行时总是有效的。</em></li></ol><p id="9253" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数意想不到的错误(比如取消引用一个<code class="fe mr ms mt mu b">nil</code>指针或者被零除)都被认为是理所当然的。我们不会编写代码来检查这些情况，除非我们认为它们是潜在的情况。那么它就变成了一个预期误差。否则，我们将生成大量的错误检查代码。其中大部分可能无法测试。</p><h2 id="837a" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">运用这种区分</h2><p id="3ea9" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">希望到目前为止，这似乎是合理的。请注意，您可能显式处理的一些错误实际上可能是意外的错误。恐慌是可以的。否则，现在每个返回意外错误的函数都必须由调用它的其他函数来处理。一路向上。嘘！</p><p id="6f48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于一般的意外错误，调用者通常不会做任何明智的事情。死机的堆栈跟踪在这里通常也更有用。我们应该避免产生更多的复制/粘贴代码，这些代码只是将意外的错误向上传递到堆栈中。</p><p id="e3e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一个从数据库中获取一些行的函数示例:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="417f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数对于它要做的事情来说实在是太冗长了。有几个地方我们必须返回一个错误。但是，上述所有错误情况都是意外错误，因为它们发生在系统处于不良或不可恢复状态时。查询无效，或者数据库在试图检索结果时已经离开。这些是我们不应该返回的意外错误。这并不意味着我们忽视他们！</p><p id="587a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们将所有意外错误替换为死机时，我们注意到根本不需要返回错误:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e724" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对<code class="fe mr ms mt mu b">getUsersWithFavouriteColor</code>的所有呼叫者都更好。尽管如此，仍然存在一些问题。接下来我们需要处理函数仍然有多冗长。</p><p id="b50d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很可能你会有几个或更多这样的函数，在内部检查所有这些错误是一件痛苦的事情。此外，通过单元测试只对现实(预期)的情况进行单元测试是合理的，因此所有这些恐慌都不会被涵盖。</p><p id="f2e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们把它分成更多可重用的代码:</p><figure class="mv mw mx my gt ju"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="99bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mr ms mt mu b">getUsersWithFavouriteColor</code>现在看起来简洁多了。它只关注它需要的逻辑，不会浪费代码去处理意外的错误。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="55df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章发布后，出现了一些关于死机如何影响正在运行的服务的评论。需要说明的是，恐慌不会影响你的整体服务。事实上，它甚至不会影响同时发生的请求。这是因为在请求/工作单元本身的顶层会有一个<code class="fe mr ms mt mu b">recover()</code>。如果你正在使用一个框架(比如<code class="fe mr ms mt mu b">http</code>包),你将免费得到这个。</p></div></div>    
</body>
</html>