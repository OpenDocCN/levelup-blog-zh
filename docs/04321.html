<html>
<head>
<title>How to build a JavaScript Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建一个JavaScript库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-javascript-library-6b7161315f3d?source=collection_archive---------1-----------------------#2020-06-21">https://levelup.gitconnected.com/how-to-build-a-javascript-library-6b7161315f3d?source=collection_archive---------1-----------------------#2020-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1e17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">最初发布于</em><a class="ae kp" href="https://faisalrashid.tech/blogs/How-to-build-a-JavaScript-Library" rel="noopener ugc nofollow" target="_blank"><em class="ko">https://faisalrashid . tech/blogs/How-to-build-a-JavaScript-Library</em></a></p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="9fa7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你是一名开发人员，几乎可以肯定你使用过代码库。简而言之，代码库是您可以在程序中使用的可重用代码的集合。</p><p id="582d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">像我们大多数人一样，我知道如何将库插入到我的程序中并使用它们，但每次我浏览那个特定库的实际源代码时，我都会感到害怕。然后我开始学习香草JS，这一切看起来不再那么可怕。Vanilla JS是不使用任何外部库编写的普通JavaScript代码。</p><p id="71aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在构建用于创建网站的JavaScript库时，在尝试实际构建之前，学习使用普通JS进行DOM操作是很重要的。它之所以重要，是因为你不会有任何依赖，你的库对你的用户来说就是一个简单的即插即用。您可能熟悉使用jQuery的DOM操作，但是这将创建对jQuery的依赖，并且您的库将无法在不包含对jQuery库的引用的网页上运行。</p><p id="db52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你熟悉jQuery，并且想学习更多关于使用Vanilla JS的DOM操作，你可以在这里阅读更多相关内容。</p><p id="e5fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">说了这么多，让我们从头开始创建一个JavaScript库。</p><p id="9be6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将建立一个图像灯箱。lightbox是一个库，用于通过用图像填充页面和削弱背景来查看网页上的图像。这是我们要建造的。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/6a78b09002865fabea88cb73c72b7d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/0*BeHnQ3FcPOPkCBhb.gif"/></div></figure><p id="ade5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想跳到前面去看代码，你可以在这里找到GitHub库<a class="ae kp" href="https://github.com/FaisalST32/fs-lightbox" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b824" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当构建一个JavaScript库时，你需要记住一些事情。<br/>你的代码不应该干扰用户编写的现有代码。为此，我们将把所有代码封装在一个函数对象中。</p><pre class="ky kz la lb gt lf lg lh li aw lj bi"><span id="8233" class="lk ll it lg b gy lm ln l lo lp">function FsLightbox() {<br/>   // all the code goes here <br/>}</span></pre><p id="086b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在本教程中编写的所有代码都将在那个函数体中编写。这将负责封装。</p><p id="8696" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在必须创建一个列表，列出用户可以访问并且对用户有用的所有方法。在这个库中，我们有四个这样的方法</p><p id="6728" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">。呈现()</strong>，<strong class="js iu">。接下来()</strong>，<strong class="js iu">。prev() </strong>和<strong class="js iu">。hideLightbox() </strong></p><p id="971e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，<strong class="js iu"> FsLightbox </strong>对象将拥有这四个公共成员。所谓公共成员，我们指的是所有那些带有<strong class="js iu"> this </strong>关键字的方法和属性。</p><p id="db48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们将存储一个对对象上下文的引用，因为使用<strong class="js iu">这个</strong>关键字在JavaScript中会变得混乱。</p><pre class="ky kz la lb gt lf lg lh li aw lj bi"><span id="89d4" class="lk ll it lg b gy lm ln l lo lp">let _this = this;</span></pre><p id="48c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将消除所有的混乱，让我们毫无顾虑地使用对象上下文。</p><p id="1bb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">解决了这个问题，让我们回顾一下让lightbox工作的策略。</p><ul class=""><li id="8e2a" class="lq lr it js b jt ju jx jy kb ls kf lt kj lu kn lv lw lx ly bi translated">用户将通过向那些<strong class="js iu"> img </strong>标签添加特定的类来指定将使用lightbox的图像。因此，每次DOM加载时，我们将能够捕获这些图像并将它们的引用保存在一个数组中。</li><li id="651a" class="lq lr it js b jt lz jx ma kb mb kf mc kj md kn lv lw lx ly bi translated">之后，我们将为每个图像添加一个click listener，以确保每次用户单击该图像时，它都会显示在lightbox中。我们将利用JavaScript和CSS来实现这一点。</li><li id="87af" class="lq lr it js b jt lz jx ma kb mb kf mc kj md kn lv lw lx ly bi translated">我们还需要为<strong class="js iu">前一个图像，下一个图像</strong>和一个按钮<strong class="js iu">关闭</strong>灯箱的导航控件。我们将这些控件与它们各自的点击监听器连接起来。</li><li id="a638" class="lq lr it js b jt lz jx ma kb mb kf mc kj md kn lv lw lx ly bi translated">我们还将显示一些元信息，如<strong class="js iu">图像计数器</strong>和<strong class="js iu">标题</strong>(我们将从<strong class="js iu"> Alt文本</strong>中获取)</li></ul><p id="f175" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你可能已经意识到的，我们将要创建的JavaScript库将使用大量的CSS，因此，我们也将包含一个CSS文件。</p><p id="ab58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">说够了，我们来写点代码吧。首先，我们需要跟踪一些数据，因此，我们将声明一些变量，这些变量在我们的小函数中是可用的。这些将是:</p><pre class="ky kz la lb gt lf lg lh li aw lj bi"><span id="e42e" class="lk ll it lg b gy lm ln l lo lp">let imagesArray = []; // Array containing the reference of all the images that have the specified class (fs-lightbox)<br/>    let currentImage; // Image being displayed currently in the lightbox<br/>    let isLightbox = false; // Boolean to tell you whether the image is being displayed in the lightbox or not</span></pre><p id="f1f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这之后，我们将编写我们的第一个公共方法，<strong class="js iu">。渲染()。</strong>在这里我们将初始化的是“全局”变量，并得到一个存储在数组中的所有图像的引用。需要运行这个方法来实际初始化我们的Lightbox。代码如下:</p><pre class="ky kz la lb gt lf lg lh li aw lj bi"><span id="e3dd" class="lk ll it lg b gy lm ln l lo lp">this.render= () =&gt; {<br/>            imagesArray= [];<br/>            currentImage=null;<br/>            isLightbox=false;</span><span id="ccc1" class="lk ll it lg b gy me ln l lo lp">document.querySelectorAll('img.fs-lightbox').forEach((img_el, index) =&gt; {<br/>                imagesArray.push(img_el);<br/>                img_el.setAttribute("data-lightbox-index", index);<br/>                img_el.addEventListener('click', () =&gt; {<br/>                    _this.lightbox(img_el);<br/>                });<br/>             });</span><span id="88dd" class="lk ll it lg b gy me ln l lo lp">             addKeyListeners();<br/>        }</span></pre><p id="8f89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如所见，我们在这里使用了函数<strong class="js iu"> addKeyListeners() </strong>。该方法用于挂接<strong class="js iu"> Next、Prev </strong>和<strong class="js iu"> Close Lightbox的所有键盘动作。</strong>我们稍后再谈。我们在这里添加的事件监听器是<strong class="js iu"> _this.lightbox() </strong>。这个方法将负责在lightbox中实际显示图像。这是它的实现。</p><pre class="ky kz la lb gt lf lg lh li aw lj bi"><span id="ef7a" class="lk ll it lg b gy lm ln l lo lp">this.lightbox = _el =&gt; {<br/>       this.hideLightbox();<br/>       currentImage = _el;<br/>       isLightbox = true;<br/>       var overlay = document.createElement('div');<br/>       overlay.classList.add('lightbox-overlay');<br/>       var imageContainer = document.createElement('div');<br/>       imageContainer.classList.add('lightbox-image');<br/>       var image = document.createElement('img');<br/>       image.src = _el.src;<br/>       imageContainer.appendChild(image);<br/>       document.querySelector('body').appendChild(overlay);<br/>       document.querySelector('body').appendChild(imageContainer);<br/>       prepareControls(_el);<br/>   }</span></pre><p id="b63b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如<strong class="js iu"> render() </strong>方法所示，该方法期望图像元素<strong class="js iu"> _el </strong>作为方法参数。这将是对需要在lightbox中显示的<strong class="js iu"> img </strong>元素的引用。如果我们进一步分析这个方法，我们会发现，如果它已经显示了其他图像，我们首先<strong class="js iu"> hideLightbox() </strong>。然后，我们将图像的引用保存在全局变量<strong class="js iu"> currentImage </strong>中，并将<strong class="js iu"> isLightbox </strong>变量更改为true。然后真正的DOM操作就开始了。</p><p id="f2c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用<strong class="js iu"> createElement </strong>方法创建覆盖div <strong class="js iu">覆盖</strong>，并添加类<strong class="js iu"> lightbox-image </strong>到其中。我们创建的CSS文件将包含覆盖所需的所有CSS，如位置和背景色。我不会深入研究这些代码，因为这不是本文的重点。话虽如此，这里有一个片段详细说明了这一点:</p><pre class="ky kz la lb gt lf lg lh li aw lj bi"><span id="83d2" class="lk ll it lg b gy lm ln l lo lp">.lightbox-overlay {<br/>   position: fixed;<br/>   top: 0;<br/>   left: 0;<br/>   width: 100vw;<br/>   height: 100vh;<br/>   background-color: rgba(0,0,0,0.7);<br/>   z-index: 10000;<br/>}</span></pre><p id="7edf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我们创建了覆盖，我们需要为实际的图像创建一个容器。<strong class="js iu"> imageContainer </strong>变量将包含相同的内容。该变量将是对我们创建的div的引用，然后我们将创建一个img元素<strong class="js iu"> image </strong>并将其附加到同一个div。使用提供的<strong class="js iu"> _el </strong>函数参数，我们将获得点击图像的<strong class="js iu"> src </strong>，并将<strong class="js iu">图像</strong>元素的<strong class="js iu"> src </strong>设置为相同的值。然后，我们将这些新创建的元素，<strong class="js iu">覆盖图</strong>和<strong class="js iu">图像容器</strong>添加到DOM中。就是这样！现在，每当用户单击添加了<strong class="js iu"> fs-lightbox </strong>类的图像时，就会触发<strong class="js iu"> lightbox() </strong>方法，图像就会显示在lightbox中。</p><p id="3a2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是大部分的艰苦工作。现在轮到波兰人了。这只是我们让我们的图书馆更加方便用户。这在创建库时非常重要。永远站在用户的角度思考问题。对用户来说越方便，接收效果就越好。</p><p id="d146" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，让我们开始吧。记住，在这篇文章的前面，我提到了用户可以使用的所有四个公共方法。我们刚刚实现了这四种方法之一— <strong class="js iu"> render() </strong>。我们需要实现其余的— <strong class="js iu"> next()、prev() </strong>和<strong class="js iu"> hideLightbox() </strong>。</p><p id="3032" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将在<strong class="js iu"> prepareControls() </strong>方法中完成。你可以在<strong class="js iu"> lightbox() </strong>方法中看到我们正在调用这个方法。该方法将负责呈现UI元素，即用于上述操作的按钮，以及为它们附加click listeners。下面是实现。</p><pre class="ky kz la lb gt lf lg lh li aw lj bi"><span id="38b9" class="lk ll it lg b gy lm ln l lo lp">function prepareControls(imgElement) {<br/>       let controls = document.createElement('div');<br/>       controls.innerHTML += controlsHtml;<br/>       document.querySelector('body').appendChild(controls.querySelector('.lightbox-controls'));<br/>       let imgIndex = getCurrentImageIndex();<br/>       if (imgIndex &gt; 0) {<br/>           document.querySelector(".lb-prev").addEventListener('click', () =&gt; {<br/>               _this.prev();<br/>           })<br/>       }<br/>       else {<br/>           document.querySelector(".lb-prev").classList.add(['lb-disabled'])<br/>       }<br/>       if (imgIndex &lt; _this.imagesArray.length - 1)<br/>             document.querySelector(".lb-next").addEventListener('click', () =&gt; {<br/>               _this.next();<br/>           })<br/>       }<br/>       else {<br/>           document.querySelector(".lb-next").classList.add(['lb-disabled'])<br/>       }<br/>       document.querySelector('.lb-close').addEventListener('click', () =&gt; {<br/>           _this.hideLightbox();<br/>       })<br/>       showCounter();<br/>   }</span></pre><p id="2a5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我所说的，创建控件并用click listeners将它们连接起来就是这里所做的一切。处理程序<strong class="js iu"> this.next() </strong>和<strong class="js iu"> this.prev() </strong>实现如下:</p><pre class="ky kz la lb gt lf lg lh li aw lj bi"><span id="43a0" class="lk ll it lg b gy lm ln l lo lp">this.next = () =&gt; {<br/>       let imgIndex = getCurrentImageIndex();<br/>       if (imgIndex === _this.imagesArray.length - 1)<br/>           return;<br/>       _this.lightbox(_this.imagesArray[getCurrentImageIndex() + 1]);<br/>   }</span><span id="ece9" class="lk ll it lg b gy me ln l lo lp">this.prev = () =&gt; {<br/>       let imgIndex = getCurrentImageIndex();<br/>       if (imgIndex === 0)<br/>           return;<br/>       _this.lightbox(_this.imagesArray[getCurrentImageIndex() - 1]);<br/>   }</span><span id="4fa7" class="lk ll it lg b gy me ln l lo lp">this.hideLightbox = () =&gt; {<br/>       let overlay = document.querySelector('.lightbox-overlay');<br/>       let image = document.querySelector('.lightbox-image');<br/>       let controls = document.querySelector('.lightbox-controls');<br/>       if (overlay)<br/>           document.querySelector('body').removeChild(overlay);<br/>       if (image)<br/>           document.querySelector('body').removeChild(image);<br/>       if (controls)<br/>           document.querySelector('body').removeChild(controls);<br/>       this.isLightbox = false;<br/>   };</span></pre><p id="0130" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">。next() </strong>从数组<strong class="js iu"> imagesArray </strong>中获取下一幅图像，并将其传递给<strong class="js iu">。lightbox() </strong>方法与<strong class="js iu">类似。prev() </strong>方法。<strong class="js iu"> hideLightbox() </strong>从DOM中移除显示的图像。</p><p id="a354" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还剩下两个东西——<strong class="js iu">显示元信息</strong>和<strong class="js iu">绑定键盘快捷键。</strong></p><p id="762c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们会为此写两个方法，<strong class="js iu"> addKeyListeners() </strong>和<strong class="js iu"> showCounter() </strong>(名字选择不好，应该是<strong class="js iu"> showMetaInformation) </strong>，下面是实现。一旦你经历过，就很容易理解了。</p><pre class="ky kz la lb gt lf lg lh li aw lj bi"><span id="af59" class="lk ll it lg b gy lm ln l lo lp">function showCounter() {<br/>       let imgIndex = getCurrentImageIndex();<br/>       let counter = document.createElement("span");<br/>       let counter_Html = `&lt;br/&gt;${imgIndex + 1} of ${_this.imagesArray.length}`;<br/>       if(_this.currentImage.alt){<br/>           counter_Html += ` - ${_this.currentImage.alt}`;<br/>       }<br/>       counter.innerHTML = counter_Html;<br/>       document.querySelector('.lightbox-image').appendChild(counter);<br/>   }</span><span id="91b0" class="lk ll it lg b gy me ln l lo lp">function addKeyListeners() {<br/>       document.removeEventListener('keydown', bindKeys);<br/>       document.addEventListener('keydown', bindKeys);<br/>   }</span><span id="3ed4" class="lk ll it lg b gy me ln l lo lp">function bindKeys(e) {<br/>       // left arrow key<br/>       if (e.keyCode === 37 &amp;&amp; _this.isLightbox) {<br/>           _this.prev();<br/>           return;<br/>       }<br/>       // right arrow key<br/>       else if (e.keyCode === 39 &amp;&amp; _this.isLightbox) {<br/>           _this.next();<br/>           return;<br/>       }<br/>       // escape key<br/>       else if (e.keyCode === 27 &amp;&amp; _this.isLightbox) {<br/>           _this.hideLightbox();<br/>           return;<br/>       }<br/>   }<br/>}</span></pre><p id="ba13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我们要在函数体中写的所有代码。我们现在需要初始化它。这将通过调用<strong class="js iu">来完成。我们创建的render() </strong>方法。记住，它是负责初始化所有东西的方法。我们可以在函数体之外这样做:</p><pre class="ky kz la lb gt lf lg lh li aw lj bi"><span id="b549" class="lk ll it lg b gy lm ln l lo lp">var fsLightbox = new FsLightbox;<br/>fsLightbox.render();</span></pre><p id="20fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在用户必须参考<strong class="js iu">。js </strong>以及<strong class="js iu">。css </strong>文件，他们将使用该库启动并运行。</p><p id="9a1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大概就是这样。还有一些更小的函数我在这里没有提到，比如<strong class="js iu"> getCurrentImageIndex() </strong>等，因为这些对于理解工作流并不重要。你仍然可以在<a class="ae kp" href="https://github.com/FaisalST32/fs-lightbox" rel="noopener ugc nofollow" target="_blank"> Github Repo中查看这些。</a></p><p id="53ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然我们已经完成了库的构建，我们需要了解如何发布它以便其他用户可以使用它。对此我们有很多选择。我们可以使用<strong class="js iu"> GitHub </strong>、<strong class="js iu"> npm </strong>等来托管我们的库。永远记住要包含一个小的自述文件，详细说明库的用法。您可以在相同的Github Repo中找到示例。要了解更多关于发布库的信息，请继续关注这个博客。我很快会写一篇关于它的文章。</p><p id="f480" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">TL；DR；要创建一个JavaScript库，你需要记住封装代码，使它不会干扰用户代码，使它简单易用，并尽量确保它没有任何依赖性。你照着这些做，你会没事的。</em></p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><div class="ky kz la lb gt mf"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">编写面试问题</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">掌握编码面试的过程</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">技术开发</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt ld mf"/></div></div></a></div></div></div>    
</body>
</html>