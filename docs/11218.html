<html>
<head>
<title>Building a Flutter Computer Vision App Using Dart:ffi, OpenCV, and Tensorflow (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dart构建颤振计算机视觉应用程序:ffi、OpenCV和Tensorflow(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-flutter-computer-vision-app-using-dart-ffi-opencv-and-tensorflow-part-2-81472b4ac380?source=collection_archive---------4-----------------------#2022-02-27">https://levelup.gitconnected.com/building-a-flutter-computer-vision-app-using-dart-ffi-opencv-and-tensorflow-part-2-81472b4ac380?source=collection_archive---------4-----------------------#2022-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="589c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这是解释如何使用dart:ffi、OpenCV和Tensorflow在Flutter中编写计算机视觉应用程序的三部分系列的第二部分。</h2></div><p id="b5f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://medium.com/@jeffrey.wolberg/building-a-flutter-computer-vision-app-using-dart-ffi-opencv-and-tensorflow-part-1-513dac9325ab" rel="noopener"> <strong class="kh ir">第一部分</strong> </a> <strong class="kh ir">讨论了如何正确配置OpenCV库和我们的自定义C++文件以在Flutter应用程序中工作，以及如何通过dart:ffi从Dart访问这些C++文件。</strong></p><p id="423b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二部分讨论了如何使用dart:ffi库通过指针在Dart和C++之间传递数据。这对于将图像数据传输到C++来说尤其重要，这样它就可以被OpenCV操作并返回到Dart。</p><p id="8fb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://medium.com/@jeffrey.wolberg/building-a-flutter-computer-vision-app-using-dart-ffi-opencv-and-tensorflow-part-3-8e3a1182250b" rel="noopener"> <strong class="kh ir">第三部分</strong> </a> <strong class="kh ir">讨论如何使用tflite_flutter插件在Flutter应用程序中使用tensorflow。我们将通过适当的配置，常见的错误，以及如何在我们的设备上运行推理。</strong></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/f6021a5355d99ea7a8abf5a7ff3af46d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-ao-EkG3iq5e2M1eZ0SHw.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">Sudoku Cam，一个用C++实现的使用OpenCV的计算机视觉颤振app</figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="9d84" class="lz ma iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated">在C++之间传递图像数据</h2><p id="ce9d" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">有两种主要方法可以做到这一点:</p><ol class=""><li id="c9f5" class="mx my iq kh b ki kj kl km ko mz ks na kw nb la nc nd ne nf bi translated">使用OpenCV的<strong class="kh ir"> imwrite </strong>和<strong class="kh ir"> imread </strong>函数读写图像数据。</li><li id="eb4e" class="mx my iq kh b ki ng kl nh ko ni ks nj kw nk la nc nd ne nf bi translated">在我们的Dart和C++文件之间传递一个指针，直接从内存中访问我们的字节。</li></ol><p id="72f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们复习一下如何做到这两点！</p><h2 id="dc0e" class="lz ma iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated">使用OpenCV的imwrite和imread函数</h2><p id="a7c3" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">使用这种方法相当简单，也很容易实现。我们将把图像路径传递给C++并使用OpenCV的<strong class="kh ir"> imread </strong>函数将它读入图像。</p><p id="61fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Flutter中，我们可以访问用户照片库中的图像，在这种情况下，我们可以使用图像路径，或者我们只能访问图像的像素数据。在后一种情况下，我们必须将图像保存到一个临时位置，以便在C++中访问它。让我们展示一个如何做到这一点的快速示例。</p><pre class="ld le lf lg gt nl nm nn no aw np bi"><span id="2c39" class="lz ma iq nm b gy nq nr l ns nt">import ‘package:path_provider/path_provider.dart’;</span><span id="e3f9" class="lz ma iq nm b gy nu nr l ns nt">Uint8List imgBytes = YOUR_IMAGE_BYTES; // pixel data<br/>XFile img = XFile.fromData(imgBytes); <br/>Directory dir = await getApplicationDocumentsDirectory();<br/>String dirName = dir.path;<br/>String imgPath = dirName + "/tempImg.jpg";<br/>img.saveTo(imgPath);</span></pre><p id="093f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过<strong class="kh ir"> path_provider </strong>包提供的<strong class="kh ir">getApplicationDocumentsDirectory</strong>，<strong class="kh ir"> </strong>方法获取保存文件的目录。XFile 提供了一种使用<strong class="kh ir"> saveTo </strong>方法将图像写入文件的便捷方式，因此我将把我的图像像素转换成一个XFile，尽管还有其他方式将图像保存到文件中。</p><p id="0fab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:我假设你的像素数据由无符号的8位整数表示，这相当于C++中的数据类型<strong class="kh ir">无符号字符</strong>。我将在整个教程中继续做这个假设。如果您的图像以不同的格式保存，请相应地修改我的示例代码。</p><p id="96e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们调用C++函数时，我们将传入imgPath作为参数，并使用OpenCV的<strong class="kh ir"> imread </strong>函数。</p><pre class="ld le lf lg gt nl nm nn no aw np bi"><span id="59af" class="lz ma iq nm b gy nq nr l ns nt">returnType func(char *path, ...) {<br/>    cv::Mat image = cv::imread(path);</span></pre><p id="ec02" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们的图像可以在C++中访问，我们可以将OpenCV用于我们的计算机视觉逻辑。</p><p id="9628" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在用OpenCV操作之后，我们经常想要在Dart中访问结果图像。我们可以传入另一个参数outputImgPath，它将是保存输出图像的路径，或者我们可以覆盖原始图像路径。无论哪种方式，这都很容易做到:</p><pre class="ld le lf lg gt nl nm nn no aw np bi"><span id="1a6e" class="lz ma iq nm b gy nq nr l ns nt">cv::imwrite(outputImgPath, outputImg);</span></pre><p id="dfbf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到我们的颤振代码，我们可以通过线访问图像</p><pre class="ld le lf lg gt nl nm nn no aw np bi"><span id="2d6a" class="lz ma iq nm b gy nq nr l ns nt">Image img = Image.file(outputImgPath);</span></pre><p id="639b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">非常容易！</p><p id="36c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> cv::imwrite </strong>将我们正在写入磁盘的图像编码成outputImgPath中指定的格式(例如。jpg，。png)。在大多数情况下，这是预期的行为，但是如果我们想要访问原始和未压缩的像素数据，我们不能以这种方式保存图像。这就是我们必须通过dart:ffi使用指针指向原始像素数据的地方。</p><h2 id="4690" class="lz ma iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated">使用dart:ffi和指针在C++之间传递数据</h2><p id="7eff" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">我们将利用dart:ffi库调用本机C APIs来读/写和分配/释放本机内存。具体来说，在我们的dart代码中，我们将在堆上分配特定数量的字节，然后将这个指针传递给C++。在C++中，我们要么访问由Dart填充的输入图像像素数据，要么用输出图像像素数据填充这些值。</p><p id="115c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们知道图像的尺寸，这就容易多了。如果图像大小是可变的，这仍然是可能的，但是稍微复杂一些。处理可变大小的图像将在本教程的后面部分讨论。现在，让我们假设我们知道输入和输出图像的尺寸，它是500x500。为了简单起见，我们还假设它是灰度图像。因此，输入字节总数为500 x 500 x 1 = 250，000。如果我们有一个RGB图像，我们将分配三倍的内存。</p><p id="ff95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的dart文件中，确保<code class="fe nv nw nx nm b">import dart:ffi;</code></p><p id="3a2d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须在本机堆上分配内存。在Dart中，我们必须写</p><pre class="ld le lf lg gt nl nm nn no aw np bi"><span id="1889" class="lz ma iq nm b gy nq nr l ns nt">Pointer&lt;Uint8&gt; imgPtr = malloc.allocate&lt;Uint8&gt;(500*500*1);</span></pre><p id="c4ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Uint8 </strong>是dart:ffi在C++中写<strong class="kh ir"> unsigned char </strong>的方式。</p><p id="d489" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住，在我们使用完imgPtr指向的数据后，我们必须使用以下方法释放内存:</p><pre class="ld le lf lg gt nl nm nn no aw np bi"><span id="fdf3" class="lz ma iq nm b gy nq nr l ns nt">malloc.free(imgPtr);</span></pre><p id="9981" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们计划将我们的图像像素数据传递到我们的C++函数中，我们可以编写以下代码行，将我们的图像数据复制到我们刚刚分配的内存中，然后这些数据将被传递到C++中:</p><pre class="ld le lf lg gt nl nm nn no aw np bi"><span id="37d4" class="lz ma iq nm b gy nq nr l ns nt">Uint8List imgBytes = YOUR_IMAGE_BYTES; // pixel data<br/>imgPtr.asTypedList(imgBytes.length).setAll(0, imgBytes);</span></pre><p id="e364" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<strong class="kh ir"> imgPtr </strong> <em class="ny"> </em>通过如下签名传递给我们的C++函数:</p><pre class="ld le lf lg gt nl nm nn no aw np bi"><span id="71b0" class="lz ma iq nm b gy nq nr l ns nt">returnType func(..., unsigned char *imagePtr, ...) { </span></pre><p id="0160" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们用实际的像素值填充imagePtr，我们现在可以通过解引用这个imagePtr来访问它们。或者，如果我们只是在Dart中分配内存，以便在C++中填充它，我们可以执行以下操作:</p><pre class="ld le lf lg gt nl nm nn no aw np bi"><span id="2fee" class="lz ma iq nm b gy nq nr l ns nt">for (int i=0; i &lt; 500*500*1; i++) </span><span id="deac" class="lz ma iq nm b gy nu nr l ns nt">    imagePtr[i] = img.data[i];     // img is of type cv::Mat</span></pre><p id="da74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> img.data </strong>是指向输出图像像素数据的指针，我们只是将它所指向的值复制到我们分配的内存块中。</p><p id="b783" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的Dart代码中，在我们的图像处理完成后，我们可以创建一个由该内存支持的列表。</p><pre class="ld le lf lg gt nl nm nn no aw np bi"><span id="f1cc" class="lz ma iq nm b gy nq nr l ns nt">Uint8List imgPixels = imgPtr.asTypedList(500*500*1);</span></pre><p id="ba66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在imgPixels让我们可以访问从C++中保存的所有像素数据。我们可以展示它，将它输入到机器学习模型中，等等！</p><p id="f4a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:使用<strong class="kh ir"> Image.memory(byteData) </strong>从内存中显示图像的标准Flutter方法期望传入的参数保存表示。jpg或者。图像的png格式。如果你给它原始输入像素数据，它将无法显示你的图像。如果是这种情况，尝试使用OpenCV的<strong class="kh ir"> imencode </strong>方法将原始像素数据编码成编码字节，然后可以在Flutter中成功传入<strong class="kh ir"> Image.memory </strong>。</p><h2 id="f30b" class="lz ma iq bd mb mc md dn me mf mg dp mh ko mi mj mk ks ml mm mn kw mo mp mq mr bi translated">我们写点代码吧！</h2><p id="5f5f" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">我们可以用一个例子来演示如何做到这一点:在一个C++函数中对原始图像数据进行编码，该函数将使用一个指针读入我们的RGB输入数据，并通过另一个指针保存我们的编码输出数据。</p><p id="5284" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在C++中，我们可以编写函数<strong class="kh ir"> encodeIm </strong>，返回编码图像的长度(总像素数):</p><pre class="ld le lf lg gt nl nm nn no aw np bi"><span id="c853" class="lz ma iq nm b gy nq nr l ns nt">// uchar is a typedef provided by OpenCV for 'unsigned char'</span><span id="5702" class="lz ma iq nm b gy nu nr l ns nt">int encodeIm(int h, int w, uchar *rawBytes, uchar **encodedOutput) {<br/>    cv::Mat img = cv::Mat(h, w, CV_8UC3, rawBytes);<br/>    vector&lt;uchar&gt; buf;<br/>    cv:imencode(".jpg", img, buf); // save output into buf<br/>    *encodedOutput = (unsigned char *) malloc(buf.size());<br/>    for (int i=0; i &lt; buf.size(); i++)<br/>        (*encodedOutput)[i] = buf[i];<br/>    return (int) buf.size();</span></pre><p id="ed5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意encodedOutput是一个uchar**(指向uchar的指针的指针)。因为我们无法在Dart中预先知道编码输出将占用的字节数，所以我们在Dart中分配了8个字节，并保存在C++中动态分配的指针。这个C++指针指向一个可变的内存量，这取决于我们的原始图像由于编码而缩小了多少。这样我们就不会给程序分配任何不必要的内存。</p><p id="6304" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的Dart代码中:</p><pre class="ld le lf lg gt nl nm nn no aw np bi"><span id="7698" class="lz ma iq nm b gy nq nr l ns nt">Uint8List bytes = YOUR_RAW_IMAGE_BYTES; // raw pixel data;</span><span id="cfba" class="lz ma iq nm b gy nu nr l ns nt">// allocate memory on the heap for our input data<br/>Pointer&lt;Uint8&gt; bytesPtr = malloc.allocate(bytes.length);</span><span id="3313" class="lz ma iq nm b gy nu nr l ns nt">// Allocate just 8 bytes to store a pointer that will be malloced in C++ that points to our variably sized encoded image<br/>Pointer&lt;Pointer&lt;Uint8&gt;&gt; encodedImPtr = malloc.allocate(8);</span><span id="a9e2" class="lz ma iq nm b gy nu nr l ns nt">// copy our input data onto the heap<br/>bytesPtr.asTypedList(bytes.length).setAll(0, bytes); </span><span id="49c5" class="lz ma iq nm b gy nu nr l ns nt">// Encode our input image and access the outputted pixel data<br/>int encodedImgLen = <strong class="nm ir">_encodeIm</strong>(h, w, bytesPtr, encodedImPtr);</span><span id="c7f1" class="lz ma iq nm b gy nu nr l ns nt">// Access the ptr malloced in C++ and save the data that it is     // pointing to<br/>Pointer&lt;Uint8&gt; cppPointer = encodedOutputPtr.elementAt(0).value;<br/>Uint8List encodedImBytes = cppPointer.asTypedList(encodedImgLen);</span><span id="de04" class="lz ma iq nm b gy nu nr l ns nt">Image myImg = Image.memory(encodedImBytes);</span><span id="ea9b" class="lz ma iq nm b gy nu nr l ns nt">// Free the memory that we allocated after we are finished with it<br/>malloc.free(bytesPtr);<br/>malloc.free(cppPointer);<br/>malloc.free(encodedImPtr); // always frees 8 bytes</span></pre><p id="7cdb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:上面加粗的函数<strong class="kh ir"> _encodeIm </strong>是使用本教程第1部分末尾描述的方法加载到Dart中的。</p><p id="6360" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于如何做到这一点的复习，下面是以下代码:</p><pre class="ld le lf lg gt nl nm nn no aw np bi"><span id="e476" class="lz ma iq nm b gy nq nr l ns nt">// declare _encodeIm for initialization later<br/>late int Function(int height, int width, Pointer&lt;Uint8&gt; bytes, Pointer&lt;Pointer&lt;Uint8&gt;&gt; encodedOutput) _encodeIm;</span><span id="2d0a" class="lz ma iq nm b gy nu nr l ns nt">final DynamicLibrary _dylib = Platform.isAndroid ? DynamicLibrary.open(‘libnative_add.so’) : DynamicLibrary.process();</span><span id="340d" class="lz ma iq nm b gy nu nr l ns nt">_encodeIm = _dylib.lookup&lt;NativeFunction&lt;Int32 Function(Int32 height, Int32 width, Pointer&lt;Uint8&gt; bytes, Pointer&lt;Pointer&lt;Uint8&gt;&gt; encodedOutput)&gt;&gt;(‘encodeIm’).asFunction();</span></pre><p id="09df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了！我们已经学会了如何将包含我们的计算机视觉逻辑的C++函数与我们的Dart代码连接起来，从而允许我们将我们的计算机视觉逻辑(C++)与我们的用户界面逻辑(Dart)分隔开来。我们已经学习了如何使用OpenCV的imread和imwrite方法以及通过指针来传入和检索图像数据。</p><p id="e52d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae lb" href="https://medium.com/@jeffrey.wolberg/building-a-flutter-computer-vision-app-using-dart-ffi-opencv-and-tensorflow-part-3-8e3a1182250b" rel="noopener">下一部分</a>中，我们将学习如何使用Flutter包<strong class="kh ir"> tflite_flutter将C++返回的数据馈入机器学习模型。</strong>我们将讨论正确的配置、常见的错误和其他有趣的细节。留下来。</p></div></div>    
</body>
</html>