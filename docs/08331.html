<html>
<head>
<title>Fallback Objects and Responses in Django — Optimizing Django, Part 7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django中的回退对象和响应——优化Django，第7部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/fallback-objects-and-responses-a-few-ways-to-implement-them-optimising-django-part-7-6741f75557fd?source=collection_archive---------14-----------------------#2021-04-21">https://levelup.gitconnected.com/fallback-objects-and-responses-a-few-ways-to-implement-them-optimising-django-part-7-6741f75557fd?source=collection_archive---------14-----------------------#2021-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="5c3d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Django中的回退对象和响应——实现它们的几种方法——优化Django，第7部分</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7d0d768e613a0f7367d2d2c8d32459af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ii89QKBeSfY5B8hofOU0rA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">姜戈太棒了。</figcaption></figure><p id="7e8a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当您在Django中提供对象时，有时您希望在对象不存在的情况下提供某种默认数据。这可能有多种原因:也许您只需要在处理函数的其余部分时模拟下游客户端的响应，或者您需要根据一些查询用户的配置文件为他们提供数据，但是在您构建配置文件时需要一些通用的东西来为新用户提供服务。</p><p id="b3c6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在本文中，我将介绍使用Django实现这一点的几种方法，提供不同程度的复杂性和功能。</p><h1 id="5e40" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">第一个:空响应！</h1><p id="4c5c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这是其中最简单的一个。</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="8c57" class="mj jo iq mf b gy mk ml l mm mn">class MyTodoView(APIView):<br/>    def get(self, request, *args, **kwargs):<br/>        # Just show the endpoint exists.<br/>        return Response(status=200, data={})</span><span id="4c5d" class="mj jo iq mf b gy mo ml l mm mn">        """  work on the rest of your code here  """</span></pre><p id="855d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">大多数Django开发人员可能都熟悉这种快速的方法，在他们让视图的其余部分工作的同时，向客户端提供200+的响应状态。</p><p id="ab5e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果你真的需要提供一些东西，比如API期望提供的数据格式的例子，那么更进一步就是提供一个样本JSON，就像这样:</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="e9ad" class="mj jo iq mf b gy mk ml l mm mn">class MyTodoView(APIView):<br/>    def get(self, request, *args, **kwargs):<br/>        # Just show the endpoint is reachable plus some sample data.<br/>        return Response(status=200, data={'title': 'A todo.',<br/>                                          'description': 'blah.'})</span><span id="f8c1" class="mj jo iq mf b gy mo ml l mm mn">"""  work on the rest of your code here  """</span></pre><p id="441c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">尽管如此，这只是一个静态的反应；这里所有东西都是硬编码的。如果你想改变数据，你不能通过Django admin来改变它；你必须改变代码。</p><p id="0a0f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">接下来，让我们看看如何提供一个可以在后端更改的默认响应。</p><h1 id="0b4b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">第二个:默认对象！</h1><p id="f826" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这一次，我们要做一个up并实际创建要服务的对象。这将是一个多一点的工作，因为预计你已经有了整个视图和序列化工作。</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="3107" class="mj jo iq mf b gy mk ml l mm mn">class MyTodoView(APIView):<br/>    def get(self, request, *args, **kwargs):<br/>        obj = self.get_object()<br/>        if not obj:<br/>            # Get your default object.<br/>            obj = self.get_queryset().filter(is_default=True).first()<br/>    return self.get_serializer(obj).data</span></pre><p id="a5c4" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这很好，因为现在您可以在Django admin中更改数据。</p><p id="20a7" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">请注意，您决定哪个对象是默认对象的逻辑是由您自由决定的。您可以使用数据库中的第一个对象，或者采用第一个包含null或空字段的对象。例如，如果您提供翻译对象，默认情况下您可以提供英语对象:</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="750f" class="mj jo iq mf b gy mk ml l mm mn">from .models import Translation</span><span id="0678" class="mj jo iq mf b gy mo ml l mm mn">class MyTodoView(APIView):<br/>  def get(self, request, *args, **kwargs):<br/>    language = kwargs['language']<br/>    id = kwargs['id']</span><span id="ec01" class="mj jo iq mf b gy mo ml l mm mn">    obj = Translation.objects.filter(id=id,<br/>                                     language=language).first()<br/>    if not obj:<br/>      obj = Translation.objects.filter(id=id,<br/>                                       language='en').first()</span><span id="6858" class="mj jo iq mf b gy mo ml l mm mn">    return self.get_serializer(obj).data</span></pre><p id="717b" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这很好，但是有一个问题:无论何时需要fallback对象，都必须进行第二次DB查询。幸运的是，有一种方法可以自动获得回退对象，而不需要第二次数据库命中！</p><h1 id="4ae5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">还有优化！</h1><p id="a2ba" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">先快速看一下代码:</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="972d" class="mj jo iq mf b gy mk ml l mm mn">from .models import Translation<br/>from django.db.models import Case, When, Q, IntegerField</span><span id="6ab4" class="mj jo iq mf b gy mo ml l mm mn">class MyTodoView(APIView):<br/>  def get(self, request, *args, **kwargs):<br/>    language = kwargs['language']<br/>    id = kwargs['id']</span><span id="4107" class="mj jo iq mf b gy mo ml l mm mn">    qs = Translation.objects.filter(id=id)</span><span id="9fe6" class="mj jo iq mf b gy mo ml l mm mn">    # This annotation is key to the optimization.<br/>    qs = qs.annotate(order=Case(When(Q(language=language),then=2),<br/>                                When(Q(language='en'), then=1),<br/>                                default=0,<br/>                                output_field=IntegerField()))</span><span id="e3c6" class="mj jo iq mf b gy mo ml l mm mn">    # Filter out other languages which are set to 0 by default.<br/>    qs = qs.filter(order__gt=0).order_by('-order')</span><span id="fcbf" class="mj jo iq mf b gy mo ml l mm mn">    # And serve the intended obj, or if it's missing, the fallback.<br/>    obj = qs.first()</span><span id="3685" class="mj jo iq mf b gy mo ml l mm mn">    return self.get_serializer(obj).data</span></pre><p id="7272" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">好了，让我们来看看到底是怎么回事！</p><p id="ed5b" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一切都是典型的注释。这就是棘手的事情发生的地方。基本上，我们使用注释来决定我们首先提供哪个翻译。Case和When用于确定排序顺序，具体的逻辑是根据具体情况注入的。结果可能看起来很笨拙，但是在需要非常具体的逻辑来排序查询集的情况下，这可能是一个非常强大的工具。</p><p id="baf6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当然，这一招不仅限于服务回退对象！您可以使用它按照特定的逻辑对整个QuerySet结果进行排序。例如，如果您想首先显示用户自己的对象列表，然后显示他们团队成员的对象，这是一个很好的QuerySet驱动的解决方案。</p><p id="7d9e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我目前能想到的唯一警告是，由于增加了逻辑，产生的单个查询会更昂贵。然而，我相信总的来说，从性能角度来看，这仍然比进行两个单独的查询要便宜。</p><h1 id="ad08" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">感谢您通读！</h1><p id="13b8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果您想知道在Django中使用序列化程序时如何<a class="ae mp" rel="noopener ugc nofollow" target="_blank" href="/dealing-with-the-n-1-problem-optimising-django-part-4-f02010c7931d?source=friends_link&amp;sk=34dfcc4f324f48a9e6e4b234d7e7635e">解决</a> <code class="fe mq mr ms mf b"><a class="ae mp" rel="noopener ugc nofollow" target="_blank" href="/dealing-with-the-n-1-problem-optimising-django-part-4-f02010c7931d?source=friends_link&amp;sk=34dfcc4f324f48a9e6e4b234d7e7635e">n+1</a></code> <a class="ae mp" rel="noopener ugc nofollow" target="_blank" href="/dealing-with-the-n-1-problem-optimising-django-part-4-f02010c7931d?source=friends_link&amp;sk=34dfcc4f324f48a9e6e4b234d7e7635e">问题的解决方案，请不要再找了！</a>或者如果你想通过Django中的控制台日志调试你的SQL，<a class="ae mp" rel="noopener ugc nofollow" target="_blank" href="/django-sql-debugging-with-an-sql-log-middleware-optimising-django-part-1-ca3b5c20d892?sk=263f4d36dde6377b91df0acf4e5208aa">看看这个快速指南吧！</a></p></div></div>    
</body>
</html>