<html>
<head>
<title>Python Code Profilers: Optimize your Code’s Bottlenecks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python代码分析器:优化代码的瓶颈</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/code-profilers-how-to-save-time-and-your-sanity-3ee5bb0787cb?source=collection_archive---------22-----------------------#2022-03-14">https://levelup.gitconnected.com/code-profilers-how-to-save-time-and-your-sanity-3ee5bb0787cb?source=collection_archive---------22-----------------------#2022-03-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="078b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何节省时间和你的理智</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ecedbb29d95099ff51093b321a943eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*it3UZsjk6kP4wxs3"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="92cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我看着屏幕，猛地呼出一口气，不知道该把精力放在哪里。我浏览了一遍代码行，摇着头想知道哪部分代码会导致程序变慢。许多数据开发人员在解决这些障碍或瓶颈时不知道去哪里。在本文中，我想展示python分析器并展示优化代码的实现。</p><h1 id="211b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">目录</h1><ol class=""><li id="63a0" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu mu mv mw mx bi translated"><a class="ae ky" href="#db6d" rel="noopener ugc nofollow">什么是代码分析器？</a></li><li id="3c76" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">如果我不是工程师，我应该在意吗？</li><li id="00d3" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="#7407" rel="noopener ugc nofollow">对于Python开发者来说，最好的免费代码剖析器有哪些？</a></li><li id="c0be" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="#a705" rel="noopener ugc nofollow">如何使用代码分析器发现应用程序中的问题区域</a></li><li id="ef2f" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="#ea9b" rel="noopener ugc nofollow">我可以在我的jupyter笔记本中实现profilers吗？</a></li></ol></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="a40a" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">什么是代码分析器？</h1><p id="d979" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">代码概要分析对于开发人员来说是一个非常有价值的工具，有助于识别和修复代码中的性能问题。它可以用来确定代码的哪些部分占用了最多的时间，或者哪些部分占用了过多的内存。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="1ea9" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated"><strong class="ak">我不是工程师应该在意吗？</strong></h1><p id="72dd" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">是的，你应该。代码分析器对于数据科学项目来说是必不可少的，因为它们可以帮助您了解代码的每个部分执行需要多少时间。这有助于理解瓶颈，并对代码进行优化，从而缩短执行时间。</p><p id="7a27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们拥有的数据越多，我们的代码就需要越高效。数据是一种有价值的资源，为了能够有效地利用它，我们需要确保代码不仅能处理数据，还能发挥其潜力。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="33b3" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">Python开发者最好的免费代码剖析器有哪些？</h1><p id="e73f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><strong class="lb iu">时间</strong></p><p id="d65d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间模块包括perf计数器函数，它从操作系统的高分辨率计时器中获取任意时间戳。</p><p id="3013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Timeit </strong></p><p id="d487" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">timeit.timeit模块旨在测量Python代码片段的运行时性能。它通过多次运行代码片段来实现这一点，然后获得所有这些迭代的总运行时间。这可以用来测量一个特定的操作或函数调用在一个紧循环中的执行情况，但更常用于比较做同样事情的不同方法的性能。</p><p id="a247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> cProfile </strong></p><p id="bcec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">cProfile模块可用于跟踪运行代码时每个单独步骤所用的时间，并提供整个代码总运行时间的最终汇总。它还可以用来查看某些函数被调用的次数，让您发现哪些函数降低了应用程序的速度。</p><p id="039f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">间谍间谍</strong></p><p id="765f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">py-spy是一个用于Python程序的开源采样分析器。Py-spy有助于在不中断程序或以任何方式修改代码的情况下可视化程序的大部分时间。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="a705" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">如何使用代码分析器找到应用程序中有问题的地方</h1><p id="af30" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">让我们从简单的开始，然后我们可以进入更多的细节。</p><p id="0424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将以timeit和time为例开始。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="4b9c" class="nx lw it nt b gy ny nz l oa ob">python -m timeit [-n N] [-r N] [-s S] [-t] [-c] [-h] [code statement ...]</span></pre><p id="807f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">命令行参数:</p><ul class=""><li id="d426" class="mn mo it lb b lc ld lf lg li oc lm od lq oe lu of mv mw mx bi translated">-n N:希望代码执行的次数。</li><li id="eb08" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated">-r N:希望timeit()函数重复的次数</li><li id="a473" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated">-s S:这将具有在代码执行之前执行的设置细节。</li><li id="6e92" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated">为此，你可以利用time.time()</li><li id="b5d4" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated">为此，您可以使用time.clock()</li><li id="9df1" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated">-h:求助</li></ul><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="9d51" class="nx lw it nt b gy ny nz l oa ob">C:\pythontest&gt;python -m timeit -s 'text="hello world"'<br/>20000000 loops, best of 5: 13.1 nsec per loop</span></pre><p id="f9ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们真的不知道太多细节，只知道运行它所花的时间。</p><p id="2aa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将查看cProfile。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="b142" class="nx lw it nt b gy ny nz l oa ob">import hashlib<br/>import cProfile<br/>cProfile.run("hashlib.md5('abcdefghijkl'.encode()).digest()")</span></pre><p id="ad03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果呢？</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="8dca" class="nx lw it nt b gy ny nz l oa ob">6 function calls in 0.000 seconds<br/>Ordered by: standard name<br/>ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>1    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;module&gt;)<br/>1    0.000    0.000    0.000    0.000 {built-in method _hashlib.openssl_md5}<br/>1    0.000    0.000    0.000    0.000 {built-in method builtins.exec}<br/>1    0.000    0.000    0.000    0.000 {method 'digest' of '_hashlib.HASH' objects}<br/>1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}<br/>1    0.000    0.000    0.000    0.000 {method 'encode' of 'str' objects}</span></pre><ul class=""><li id="3791" class="mn mo it lb b lc ld lf lg li oc lm od lq oe lu of mv mw mx bi translated"><strong class="lb iu"> ncalls </strong>是打电话的次数。</li><li id="fa64" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated"><strong class="lb iu"> tottime </strong>是在给定函数中花费的总时间。</li><li id="1bab" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated"><strong class="lb iu"> percall </strong>指总时间除以ncalls的商</li><li id="616a" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated"><strong class="lb iu">累计时间</strong>是在该功能和所有子功能中花费的累计时间。甚至对递归函数也很准确！</li><li id="388f" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated">第二个<strong class="lb iu"> percall列</strong>是累计时间除以原始调用的商</li><li id="f210" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated"><strong class="lb iu">filename:line no(function)</strong>提供各功能的数据</li></ul><p id="ccc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在<a class="ae ky" href="https://www.programiz.com/python-programming/online-compiler/" rel="noopener ugc nofollow" target="_blank"> programiz </a>上运行该示例时，您可以得到相同的结果。</p><p id="8b88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道这不太好，但是让我们一行一行地努力吧。</p><p id="cb31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，字符串被编码。结果的最后一行表明了这一点。任何带有_hashlib的东西都是hashlib库的一部分。最后，任何带有“Profiler”的东西都是cProfile的一部分。</p><p id="25c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我想看看py-spy。py-spy很好，因为用户可以可视化他们的结果，并自动找出与其他文件和函数相比哪个文件和函数占用的时间最多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/391abe9f7eeb2b810f26b18f1c8393f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_V5PfjNLiLlCN8l_tl5LhQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自github 的py-spy的图片</figcaption></figure><p id="69e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，这个特殊的程序在执行时是平等的。然而，如果有一个区域比其他区域大得多，那将是你需要关注的区域。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="ea9b" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated"><strong class="ak">我可以在我的jupyter笔记本中实现profilers吗？</strong></h1><p id="33d2" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">是的，你可以！在jupyter笔记本中实现这些分析器实际上只有两个步骤。</p><p id="41f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，您需要将库加载到一个单元格中，例如，</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="46ce" class="nx lw it nt b gy ny nz l oa ob">%load_ext line_profiler</span></pre><p id="ffc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，您可以按如下方式使用它:</p><ul class=""><li id="f5ea" class="mn mo it lb b lc ld lf lg li oc lm od lq oe lu of mv mw mx bi translated"><code class="fe oh oi oj nt b">%time</code>:计时单个语句的执行时间</li><li id="dd93" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated"><code class="fe oh oi oj nt b">%timeit</code>:定时重复执行一条语句，以提高准确性</li><li id="0225" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated"><code class="fe oh oi oj nt b">%prun</code>:用概要分析器运行代码</li><li id="333e" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated"><code class="fe oh oi oj nt b">%lprun</code>:用逐行分析器运行代码</li><li id="4221" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated"><code class="fe oh oi oj nt b">%memit</code>:测量单个语句的内存使用情况</li><li id="9b01" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu of mv mw mx bi translated"><code class="fe oh oi oj nt b">%mprun</code>:使用逐行内存分析器运行代码</li></ul><p id="1f23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://shop.oreilly.com/product/0636920034919.do" rel="noopener ugc nofollow" target="_blank"> <em class="ok"> Python数据科学手册</em> </a> <em class="ok"> </em>中的Jake VanderPlas有一个很棒的笔记本，你可以自己浏览并执行。这是<a class="ae ky" href="https://colab.research.google.com/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/01.07-Timing-and-Profiling.ipynb#scrollTo=FIl4Dr46XRVK" rel="noopener ugc nofollow" target="_blank">笔记本</a>。⁴</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><p id="cd6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码剖析是一个非常有价值的工具，但在数据领域却没有得到充分利用。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="b3f8" class="nx lw it nt b gy ny nz l oa ob">References</span><span id="5e31" class="nx lw it nt b gy ol nz l oa ob">1. <a class="ae ky" href="https://www.machinelearningplus.com/python/cprofile-how-to-profile-your-python-code/" rel="noopener ugc nofollow" target="_blank">https://www.machinelearningplus.com/python/cprofile-how-to-profile-your-python-code/</a><br/>2. <a class="ae ky" href="https://github.com/benfred/py-spy" rel="noopener ugc nofollow" target="_blank">https://github.com/benfred/py-spy</a><br/>3. <a class="ae ky" href="https://www.blog.pythonlibrary.org/2014/03/20/python-102-how-to-profile-your-code/" rel="noopener ugc nofollow" target="_blank">https://www.blog.pythonlibrary.org/2014/03/20/python-102-how-to-profile-your-code/</a><br/>4.<a class="ae ky" href="https://colab.research.google.com/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/01.07-Timing-and-Profiling.ipynb#scrollTo=FIl4Dr46XRVK" rel="noopener ugc nofollow" target="_blank">https://colab.research.google.com/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/01.07-Timing-and-Profiling.ipynb#scrollTo=FIl4Dr46XRVK</a></span></pre></div></div>    
</body>
</html>