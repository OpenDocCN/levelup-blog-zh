<html>
<head>
<title>3 Web Observers Every Web Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个Web开发人员都应该知道的3个Web观察者</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-web-observers-every-web-developer-should-know-c2f65302b5df?source=collection_archive---------1-----------------------#2022-04-21">https://levelup.gitconnected.com/3-web-observers-every-web-developer-should-know-c2f65302b5df?source=collection_archive---------1-----------------------#2022-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2acc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你可能知道变异观测者，但你知道其他人吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8ede6d877d2bece73d5cfe66dfe9af00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6UoPbuelvJNH5mqkcCCsw.png"/></div></div></figure><p id="75d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在浏览器中，我们可以使用<code class="fe lq lr ls lt b">addEventListener</code>来监听用户事件，但是如果我想监听DOM的变化或者监听一些浏览器行为呢？</p><p id="d5b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">浏览器为我们提供了几个观察者来满足这些需求。你知道有哪些吗？它们的具体用途是什么？本文将为您揭晓。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="b78f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">突变观察者</h1><p id="e818" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">MutationObserver接口可以监视DOM树中的变化，并且是DOM3事件规范的一部分。它可以监视当前节点的属性变化、子节点的变化等等。这里有一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a104" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">点击按钮，可以看到MutationObserver监听到了变化，可以清楚的知道是<code class="fe lq lr ls lt b">attributes</code>变了还是<code class="fe lq lr ls lt b">childList</code>变了。</p><p id="3491" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">特别重要的是，所有观察者事件回调都是<strong class="kw iu">微任务</strong>，这有两个好处。</p><ol class=""><li id="7d84" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">它是异步的。这不像<a class="ae nj" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationEvent" rel="noopener ugc nofollow" target="_blank">突变事件</a>每次DOM改变时都会触发同步回调。相反，它会在触发异步回调之前等待多次DOM更改。</li><li id="b38a" class="na nb it kw b kx nk la nl ld nm lh nn ll no lp nf ng nh ni bi translated">它能保证实时性，在下一个宏任务开始之前肯定会被调用。</li></ol><p id="af43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个使用突变事件和突变观测器的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="190e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用默认的数字3，当点击<code class="fe lq lr ls lt b">Add Multiple Child</code>时，可以看到<code class="fe lq lr ls lt b">insertCallback</code>被调用三次，而<code class="fe lq lr ls lt b">observerCallback</code>只被调用一次。并且在<code class="fe lq lr ls lt b">mutationsList</code>中可以得到这三次变化的记录。你也可以改变其他数字来测试。</p><p id="71df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是表演截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/a691290f4f7b890049ddbdbba1c29907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YcG2w-hJPNsih4xhSMUXg.png"/></div></div></figure><p id="b0b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用户单击事件是一个宏任务。点击按钮后，可以看到<code class="fe lq lr ls lt b">DOMNodeInserted</code>事件被调用三次，微任务中<code class="fe lq lr ls lt b">observerCallback</code>被调用一次。下一步是浏览器呈现一个新的框架。如果用户再次单击，将启动一个新的宏任务。</p><p id="f575" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">所以它巧妙地利用了事件循环的机制，在不影响性能的情况下解决了实时性问题。</strong></p><h1 id="fc51" class="mb mc it bd md me nq mg mh mi nr mk ml jz ns ka mn kc nt kd mp kf nu kg mr ms bi translated">resize观察者</h1><p id="3747" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">要监听浏览器窗口大小的变化，我们可以使用<code class="fe lq lr ls lt b">addEventListener</code>来监听<code class="fe lq lr ls lt b">resize</code>事件，要监听单个元素，可以使用<code class="fe lq lr ls lt b">ResizeObserver</code>。</p><p id="b85e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ResizeObserver接口报告元素内容或边框的尺寸变化，或者SVGElement的边界框的尺寸变化。</p><p id="bfaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e610" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意<code class="fe lq lr ls lt b">ResizeObserver</code>在初始化时也会触发一个回调。拖动上面的滑块可以看到回调是按顺序触发的，你不会感觉到任何滞后，这也是由于上面提到的微任务。</p><p id="5401" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">resizeObserver</code>在进行可视化图表适配时会很有用。</p><h1 id="ca5f" class="mb mc it bd md me nq mg mh mi nr mk ml jz ns ka mn kc nt kd mp kf nu kg mr ms bi translated">交叉观测器</h1><p id="7a2e" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">IntersectionObserver接口可以观察目标元素与祖先元素或<code class="fe lq lr ls lt b">document</code>视口的交集的变化。创建时，可以指定交叉点可见比例的阈值等。</p><p id="7975" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e4f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">滚动<code class="fe lq lr ls lt b">container</code>区域的滚动条查看控制台输出。其中<code class="fe lq lr ls lt b">intersectionRatio</code>表示当前交叉点的比率。我们指定输出为0.5和1。</p><p id="d5c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该API对于图像的延迟加载或数据收集非常有用，<em class="nv">和Medium的延迟加载可能使用该</em>😃</p><h1 id="cc6d" class="mb mc it bd md me nq mg mh mi nr mk ml jz ns ka mn kc nt kd mp kf nu kg mr ms bi translated">额外的</h1><p id="a66a" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">除了上述三种监控元素的观测器，还有另外两种类型的观测器，分别是<code class="fe lq lr ls lt b">PerformanceObserver</code>和<code class="fe lq lr ls lt b">ReportingObserver</code>。</p><p id="f035" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">PerformanceObserver</code>用于监控绩效测量事件。一旦有测量事件(<a class="ae nj" href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/entryType#performance_entry_type_names" rel="noopener ugc nofollow" target="_blank">性能条目</a>)就会触发回调功能，然后您可以选择报告它进行性能分析。</p><p id="82b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">ReportingObserver</code>允许收集和访问报告。例如，当使用浏览器的废弃API时，它会触发一个回调函数。既然这不是错误，那就只能用<code class="fe lq lr ls lt b">ReportingObserver</code>来听了。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="ed57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nv">今天就到这里。我是Zachary，我将继续输出与web开发相关的故事。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae nj" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nv">中等会员</em> </a> <em class="nv">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae nj" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nv">我的链接</em> </a> <em class="nv">报名，我会得到一点佣金。</em></p><p id="df41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你的支持对我来说很重要——谢谢。</p></div></div>    
</body>
</html>