<html>
<head>
<title>How to Write an Unbeatable Tic-Tac-Toe in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript写出无与伦比的井字游戏</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-an-unbeatable-tic-tac-toe-in-javascript-77b9e3176d4a?source=collection_archive---------7-----------------------#2020-06-21">https://levelup.gitconnected.com/how-to-write-an-unbeatable-tic-tac-toe-in-javascript-77b9e3176d4a?source=collection_archive---------7-----------------------#2020-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fa9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">原载于</em><a class="ae km" href="https://faisalrashid.tech/blogs/How-to-Write-an-Unbeatable-Tic-Tac-Toe-in-JavaScript" rel="noopener ugc nofollow" target="_blank"><em class="kl">https://faisalrashid . tech/blogs/How-to-Write-a-un make-Tic-Tac-Toe-in-JavaScript</em></a></p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><p id="90cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编写小型益智游戏是提高编程技能的好方法，因为这些游戏往往会给你带来一个又一个挑战，迫使你在编写代码时投入大量精力。</p><p id="27b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经典的井字游戏<strong class="jp ir">就是这样一种游戏。</strong></p><p id="32e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个关于编写无与伦比的井字游戏的小演练(阅读时间长且描述性的)中，我将使用普通的JavaScript实现逻辑，使用HTML/CSS实现UI。我不会太关注它的UI部分，因为，咄！</p><p id="1e93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个小小的免责声明——我们将主要关注逻辑，代码将排在第二位。同样，如果你想跳过“走一遍”，直接跳到代码，我在https://github.com/FaisalST32/tic-tac-toe的GitHub上有一个公共库。我在http://games.faisalrashid.tech/tictactoe/也有游戏的现场版本</p><p id="642b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，让我们开始吧。</p><p id="b60a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，你需要创建用户界面。只需使用简单的HTML创建9个输入框，甚至div来保存你的X和O。这些输入框的id很重要，因为它们将是我们对X和O的引用。为了与我们的框的位置保持一致，我给了输入框从“0–0”到“2–2”的id。可视化:</p><p id="e256" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">0–0 0–1 0–2<br/>1–0 1–1 1–2<br/>2–0 2–1 2–2</p><p id="feee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将给我们一个易于使用的3×3矩阵。你可以随心所欲地设计你的UI。它应该简单地使用这种形式的可查询HTML元素。</p><p id="6cdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我的UI截图。简单的盒子加上一点CSS的光泽。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/4cc0f30e85bb765eb93b6541484ddefc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*3td8gBA9UZJiffXu.png"/></div></figure><p id="e7c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，逻辑！首先，每当一个用户，或者在这种情况下的一个参与者，点击或者轻击一个空的盒子，这个盒子的值应该改变为X或者O，这取决于轮到谁了。</p><p id="6e22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现起来很简单。我使用一个全局变量来保存“<strong class="jp ir"> currentPlayer </strong>”。这个变量的值不是X就是o。然后我简单地写了一个方法来切换当前的玩家，只要一个盒子被点击。我调用方法<strong class="jp ir"> changePlayer </strong>。</p><p id="51a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这一切都是从轻点一个盒子开始的。所以，我们需要一个函数来开始。我们编写一个函数，用X或O标记盒子，并改变播放器。我们在复选框上调用函数<strong class="jp ir">。到目前为止，函数<strong class="jp ir">检查一个盒子</strong>，然后<strong class="jp ir">改变玩家。</strong></strong></p><p id="4ecf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当盒子被点击时，我们需要跟踪选中的盒子。使用数组应该有助于我们完成这项工作。简单地持有所有盒子的id是有用的，但是还不够。我们肯定需要持有id(在这种情况下是坐标)以及勾选方块的玩家。因此，我们的<strong class="jp ir">checked box</strong>数组将是以下形式的对象数组:</p><pre class="kv kw kx ky gt lc ld le lf aw lg bi"><span id="ea67" class="lh li iq ld b gy lj lk l ll lm">[{box: '0-1', player: 'X'}, {box: '2-1', player: 'O'}, ...]</span></pre><p id="010c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在有两个全局变量——一个用来保存<strong class="jp ir">当前播放器</strong>，另一个用来保存<strong class="jp ir">选中的盒子</strong>。</p><p id="6702" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢记录的另一件事是<strong class="jp ir">转数</strong>。我可以从<strong class="jp ir">checked boxes</strong>数组中得到它，但是如果我在操作<strong class="jp ir"> checkedBoxes </strong>数组，这种方式会更简单，也非常有用。</p><p id="6391" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们将只编写播放器vs CPU模式(github repo包含1p和2p模式)，这些都是我们将需要的全局变量—<strong class="jp ir">checked box</strong>、<strong class="jp ir"> currentPlayer </strong>和<strong class="jp ir"> turnCount </strong>。</p><p id="907d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:将全局变量保持在最低限度，以避免函数中的依赖性和意外行为，这始终是一个好的做法。</p><p id="79ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我相信我们的<strong class="jp ir"> onCheckBox </strong>方法现在已经准备好了。这是它看起来的样子</p><pre class="kv kw kx ky gt lc ld le lf aw lg bi"><span id="2867" class="lh li iq ld b gy lj lk l ll lm"><em class="kl">function </em>onCheckBox(<em class="kl">element</em>) {<br/>   checkedBoxes.push({ box: element.id, player: currentPlayer });<br/>   checkElement(element);<br/>   turnCount++;<em class="kl">    </em><br/><em class="kl">   var </em>gameStatus =checkWinner();//Will come to this method in a bit<br/>    switchPlayer();<br/>}</span><span id="7462" class="lh li iq ld b gy ln lk l ll lm"><em class="kl">function </em>checkElement(<em class="kl">element</em>){<br/>     element.value = currentPlayer;     <br/>     element.disabled ="disabled";<br/>}</span><span id="dae4" class="lh li iq ld b gy ln lk l ll lm"><em class="kl">function </em>switchPlayer() {<br/>    currentPlayer = currentPlayer =="X"?"O":"X";<br/>    document.querySelector('.current-player').textContent = currentPlayer;<br/>}</span></pre><p id="c957" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将被点击的Html元素作为参数之一传递给该方法，以访问它的id坐标。每次我们检查一个盒子时，我们需要检查是否有一个赢家或者游戏是否平局。</p><p id="4c7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这给我们带来了<strong class="jp ir"> checkWinner </strong>方法。这种方法只是检查X或O是否在一条线上(井字游戏的规则)，以确定是否有赢家。建立这样的逻辑并不困难。我们查询<strong class="jp ir">checked box</strong>数组并找到玩家x的所有坐标。如果坐标遵循(a-0，a-1，a-2)或(0-a，1-a，2-a)的模式，其中a = 0或1或2，那么我们检查一条水平线或垂直线。嗯，对角线有点棘手。对于从右到左的对角线，我们使用(a-a，b-b，c-c ),对于从左到右的对角线，我们使用(0–2，1–1，2–0)。如果我们在<strong class="jp ir"> checkedBox </strong>矩阵中找到这些图案中的任何一个，那么拥有该图案的“玩家”就是赢家。如果这些模式都不匹配，那么我们只需检查两个玩家中是否有一个勾选了5个方格，以确定这是一个平局。</p><pre class="kv kw kx ky gt lc ld le lf aw lg bi"><span id="fc62" class="lh li iq ld b gy lj lk l ll lm"><em class="kl">function </em>checkWinner(<em class="kl">isCheckOnly</em>=false) {<br/>if (currentPlayer =="X") {<br/>//Get all the boxes marked by Player X<br/><em class="kl">   var</em>  xs = checkedBoxes.filter(<em class="kl">item=&gt;</em> item.player =="X").map(<em class="kl">value=&gt;</em> {<br/>     return { x: <em class="kl">Number</em>(value.box.split("-")[0]), y: <em class="kl">Number</em>(value.box.split("-")[1]) }<br/>});<br/>returncalculateScore(xs);<br/>}<br/>else if (currentPlayer =="O") {<br/>//Get all the boxes marked by Player O<br/><em class="kl">   var</em>  os = checkedBoxes.filter(<em class="kl">item=&gt;</em> item.player =="O").map(<em class="kl">value=&gt;</em> {<br/>     return { x: <em class="kl">Number</em>(value.box.split("-")[0]), y: <em class="kl">Number</em>(value.box.split("-")[1]) }<br/>});<br/>returncalculateScore(os);<br/>}<br/>}</span><span id="da55" class="lh li iq ld b gy ln lk l ll lm"><em class="kl">function </em>calculateScore(<em class="kl">positions</em>) {<br/>//Check right diagonalif (positions.filter(<em class="kl">i=&gt;</em> { return i.x == i.y }).length ==3) {<br/>              return'game over';<br/>}</span><span id="b1fe" class="lh li iq ld b gy ln lk l ll lm">//Check Left diagonal<br/>if (positions.filter(<em class="kl">i=&gt;</em> { return (i.x ==0&amp;&amp; i.y ==2) <br/>                                    || (i.x ==1&amp;&amp; i.y ==1)<br/>                                    || (i.x ==2&amp;&amp; i.y ==0) }).length ==3) {<br/>                return'game over';<br/>}<br/>//check horizontal match<br/>for (<em class="kl">var</em> i =0; i &lt;3; i++) {<br/><em class="kl">  var</em>  consecutiveHorizontal = positions.filter(<em class="kl">p=&gt;</em> p.x == i);<br/>  if (consecutiveHorizontal.length ==3) {<br/>       return'game over';<br/>}<br/>//check vertical match<br/><em class="kl">  var</em>  consecutiveVertical = positions.filter(<em class="kl">p=&gt;</em> p.y == i);<br/>  if (consecutiveVertical.length ==3) {<br/>        return'game over';<br/>}<br/>}<br/>//check draw<br/>if (positions.length ==5) {<br/>  return'game drawn';<br/>}<br/>//if none of the conditions match 'game on'<br/>return'game on';<br/>}</span></pre><p id="e888" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我将查找结果的责任委托给<strong class="jp ir"> calculateScore </strong>方法。这两种方法本质上是将我们上面所说的内容翻译成JavaScript代码。这里没什么特别的。</p><p id="6165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们现在尝试一些东西。我们走吧。我相信我们的游戏现在已经准备好处理所有井字游戏的逻辑了。剩下的就是让它不可战胜。为了让游戏无与伦比，我想设置一些基本规则，以避免这篇帖子太长(你在开玩笑，对吧)。CPU将总是第二个出场，并且主要关注不让对手获胜。因此，我们的<strong class="jp ir"> onCheckBox </strong>方法将会看到方法<strong class="jp ir"> computerPlays </strong>为CPU的轮次增加。</p><pre class="kv kw kx ky gt lc ld le lf aw lg bi"><span id="d7fd" class="lh li iq ld b gy lj lk l ll lm"><em class="kl">function </em>onCheckBox(<em class="kl">element</em>) {<br/>checkedBoxes.push({ box: element.id, player:<br/>    currentPlayer });<br/>  checkElement(element);<br/>turnCount++;<br/><em class="kl">  var</em><br/>     gameStatus =checkWinner();<br/>  switchPlayer();<br/>  if (turnCount %2==1&amp;&amp;<br/>    gameStatus =='game on'){<br/>    computerPlays();<br/>}<br/>}</span></pre><p id="b535" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，<strong class="jp ir"> computerPlays </strong>方法只有在回合数为奇数时才会被调用，即第2、第4、第6或第8回合，并且如果<strong class="jp ir"> checkWinner </strong>方法返回的<strong class="jp ir"> gameStatus </strong>为“游戏进行中”,因为如果游戏已经结束，则没有必要继续游戏。为了理解如何对抗人类的移动，我想出了5个例子。这五个案例按其优先顺序排列如下:</p><ol class=""><li id="9047" class="lo lp iq jp b jq jr ju jv jy lq kc lr kg ls kk lt lu lv lw bi translated">先走</li><li id="cb2d" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">让CPU赢得游戏的最后一步棋。</li><li id="8677" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">允许CPU保存游戏的保存动作。</li><li id="1ad4" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">预测会困住CPU的移动并避免它。</li><li id="4e6f" class="lo lp iq jp b jq lx ju ly jy lz kc ma kg mb kk lt lu lv lw bi translated">如果这些都不符合，那就随机行动。</li></ol><p id="acc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是我们的电脑游戏方法的预览。</p><pre class="kv kw kx ky gt lc ld le lf aw lg bi"><span id="5d9d" class="lh li iq ld b gy lj lk l ll lm"><em class="kl">function </em>computerPlays() {<br/><em class="kl">  var </em> nextBoxCoords;<br/>  if(turnCount ==1){<br/>nextBoxCoords =computeFirstMove();<br/>}<br/>  if (!nextBoxCoords){<br/>nextBoxCoords =computeFinishingMove();<br/>}</span><span id="9801" class="lh li iq ld b gy ln lk l ll lm">if (!nextBoxCoords) {<br/>nextBoxCoords =computeSavingMove();<br/>}<br/>  if (!nextBoxCoords)<br/>nextBoxCoords =predictTrappingMove();<br/>  if (!nextBoxCoords) {<br/>nextBoxCoords =computeRandomMove();<br/>}<br/><em class="kl">  var</em>  nextBox = document.querySelector(`[id='${nextBoxCoords}']`);<br/>  onCheckBox(nextBox);<br/>}</span></pre><h1 id="04f4" class="mc li iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">1.先走</h1><p id="06c0" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">计算第一步是出于经验，虽然，我可以为它写一个算法。但是为了避免复杂，我只是根据过去的经验。如果是CPU的第一步棋，我们需要找到对手下的棋。如果是<strong class="jp ir">中心框</strong>，我们返回一个<strong class="jp ir">角框</strong>。类似地，如果他打了一个<strong class="jp ir">角框</strong>，我们返回一个与其相邻的<strong class="jp ir">边缘框</strong>，最后如果他打了一个<strong class="jp ir">边缘框</strong>，我们返回<strong class="jp ir">中心框</strong>。顺便说一下，1–1是中心框，0–1，1–0，1–2，2–1是边缘框，你猜对了，0–0，0–2，2–0，2–2是角框。</p><p id="10f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，</p><pre class="kv kw kx ky gt lc ld le lf aw lg bi"><span id="105c" class="lh li iq ld b gy lj lk l ll lm"><em class="kl">function </em>computeFirstMove(){<br/><em class="kl">  var</em>  playedMove = checkedBoxes.map(<em class="kl">b=&gt;</em> b.box)[0];<br/><em class="kl">  var </em> edgeMoves = ['0-1', '1-0', '1-2', '2-1'];<br/><em class="kl">  var </em> cornerMoves = ['0-0', '0-2', '2-0', '2-2'];<br/><em class="kl">  var </em> centerMove = ['1-1'];<br/>  if(edgeMoves.find(<em class="kl">m=&gt;</em> m == playedMove))<br/>    returnedgeMoveResponse(playedMove);<br/>  else if(cornerMoves.find(<em class="kl">m=&gt;</em> m == playedMove))<br/>    return'1-1';<br/>  else if(centerMove.find(<em class="kl">m=&gt;</em> m == playedMove))<br/>    return cornerMoves[Math.floor(Math.random()*cornerMoves.length)];<br/>}</span><span id="d592" class="lh li iq ld b gy ln lk l ll lm"><em class="kl">function </em>edgeMoveResponse(<em class="kl">playedMove</em>){<br/>  if(playedMove =='1-2') <br/>    return'0-2';<br/>  else if (playedMove =="0-1") <br/>    return"0-0";<br/>  else if (playedMove =="1-0") <br/>   return"2-0";<br/>  else if(playedMove =='2-1') <br/>    return'2-0';<br/>}</span></pre><p id="3a7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了避免塞满<strong class="jp ir"> computeFirstMove </strong>方法，我移出了<strong class="jp ir"> edgeMoveResponse </strong>方法。现在，我们已经完成了第一步，让我们进入下一步——<strong class="jp ir">computeFinishingMove</strong>。</p><h1 id="064a" class="mc li iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">2.让CPU赢得游戏的最后一步棋。</h1><p id="8872" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">如果对手在那里等着我们，我们会优先考虑拿下他。假设我们有以下情况:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/d8895a5af4a987113dead3acb5e1e8a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*5-DD82k2dHNj3pPT.png"/></div></figure><p id="433c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为，轮到CPU)了，我们肯定要检查右下角的框。这就是我们的<strong class="jp ir"> computeFinishingMove </strong>方法的用武之地。它简单地遍历所有剩余的框，并逐个检查它们。然后在每次迭代中调用<strong class="jp ir"> checkWinner </strong>方法，如果有赢家，就将该迭代的盒子作为“<strong class="jp ir"> nextBoxCoords </strong>”返回给<strong class="jp ir"> computerPlays </strong>方法。代码如下:</p><pre class="kv kw kx ky gt lc ld le lf aw lg bi"><span id="9385" class="lh li iq ld b gy lj lk l ll lm"><em class="kl">function </em>computeFinishingMove() {<br/><em class="kl">  var </em> remainingMoves =getRemainingMoves();<br/><em class="kl">  var </em> finishingMoveCoords;<br/>  for (<em class="kl">var</em> move of remainingMoves) {<br/>    checkedBoxes.push({ box: move, player: currentPlayer });<br/><em class="kl">    var</em>  nextBox = document.querySelector(`[id='${move}']`)<br/>    if (checkWinner() =='game over') {<br/>finishingMoveCoords = move;<br/>      onUncheckBox(nextBox, true);<br/>      break;<br/>}<br/>    onUncheckBox(nextBox, true);<br/>}<br/>  if(finishingMoveCoords){<br/><em class="kl">    console</em>.log('Playing Finishing Move')<br/>    return finishingMoveCoords;<br/>}<br/>  else{<br/>    return'';<br/>}<br/>}</span><span id="9df6" class="lh li iq ld b gy ln lk l ll lm"><em class="kl">function </em>getRemainingMoves() {<br/><em class="kl">  var</em>  allMoves = ['0-0', '0-1', '0-2',<br/>                  '1-0', '1-1', '1-2',<br/>                  '2-0', '2-1', '2-2',]<br/><em class="kl">  var</em>  playedMoves = checkedBoxes.map(<em class="kl">b=&gt;</em> b.box);<br/>  return allMoves.filter(<em class="kl">m=&gt;</em>!playedMoves.find(<em class="kl">move=&gt;</em> move == m));<br/>}<br/><em class="kl">function </em>onUncheckBox(<em class="kl">element</em>, <em class="kl">isImplicit</em>=false) {<br/>checkedBoxes = checkedBoxes.filter(<em class="kl">b=&gt;</em> b.box != element.id);<br/>  if (!isImplicit) {<br/>element.value ='';<br/>element.removeAttribute("disabled");<br/>turnCount--;<br/>     switchPlayer();<br/>}<br/>}</span></pre><p id="a785" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当选中一个框来检查获胜者时，我们必须确保在迭代完成后取消选中该框，以避免checkedBoxes数组中的坏数据。就此而言，我们采用上面的<strong class="jp ir"> onUncheckBox </strong>方法。如果没有“结束移动”可用，我们检查下一个条件— computeSavingMove。</p><h1 id="21ab" class="mc li iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">3.允许CPU保存游戏的保存动作。</h1><p id="9d05" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">考虑以下场景:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/48aa21d70e2ff79b5a2d83e6879e53f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*IEVz86ywLPh26ZB7.png"/></div></figure><p id="6e0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里轮到CPU)上场了。很明显，在除了中框顶部以外的地方玩会导致游戏在下一回合结束。因此，我们必须明确选中该框。为此，我们编写了一个类似于前面方法的方法，这次我们迭代所有剩余的盒子，在每次迭代中用对手的标记填充它们，然后调用<strong class="jp ir"> checkWinner </strong>方法。如果它在任何迭代中返回‘游戏结束’,那么这就是我们想要的盒子。这在JavaScript中解释为。</p><pre class="kv kw kx ky gt lc ld le lf aw lg bi"><span id="8ef0" class="lh li iq ld b gy lj lk l ll lm"><em class="kl">function </em>computeSavingMove() {<br/><em class="kl">  var </em> remainingMoves =getRemainingMoves();<br/>  switchPlayer();<br/><em class="kl">  var </em> savingMoveCoords;<br/>  for (<em class="kl">var</em>  move of remainingMoves) {<br/>          checkedBoxes.push({ box: move, player: currentPlayer });<br/>     <em class="kl">    var</em> nextBox = document.querySelector(`[id='${move}']`)<br/>         if (checkWinner() =='game over') {<br/>                         savingMoveCoords = move;<br/>                         onUncheckBox(nextBox, true);<br/>                         break;<br/>}<br/>    onUncheckBox(nextBox, true);<br/>}<br/>    switchPlayer();<br/>   if(savingMoveCoords){<br/><em class="kl">      console</em>.log('Playing Saving Move')<br/>      return savingMoveCoords;<br/>}<br/>}</span></pre><p id="3da9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会说这明显违反了DRY(不要重复自己)原则。但是，有时，为了保持代码的可读性并避免复杂性，您可能希望以后再看。为了确保我在迭代对手的移动并注意CPU的，我在迭代<strong class="jp ir"> remainingMoves </strong>之前调用了<strong class="jp ir"> switchPlayer </strong>方法。如果剩下的棋都不是拯救棋，那么我们将注意力转向最棘手的情况— <strong class="jp ir">预测陷阱棋</strong>。</p><h1 id="b28d" class="mc li iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">4.预测会困住CPU的移动并避免它。</h1><p id="f33f" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">我喜欢称之为“陷阱移动”，当对手检查一个盒子，让你有两个完成盒子要填，最终导致你输掉游戏。这里有一个截图可以准确地说明这一点:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/269e10dadf422697d488057173074b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*PWvO3jx13Z2KnDBY.png"/></div></figure><p id="6c77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在图像中，轮到玩家O，他处于双输局面。如果他过牌0–0，玩家X会过牌2–2以赢得游戏，反之亦然。所以，摆脱这种情况的唯一方法就是避免它。这就是我们下一个方法<strong class="jp ir"> predictTrappingMove </strong>的用武之地。</p><p id="4026" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就执行而言，这种方法并不复杂，但计划需要准确无误。所以，我们要做的是，每当对手下一步棋时，我们就检查下一次他下一步棋的可能性。要做到这一点，我们将不得不一个接一个地检查每一个箱子与我们的举动。在每一个回合，我们都必须检查对手移动的剩余方格。然后，我们检查是否因此产生了不止一个获胜的棋步。我知道，我知道，管他呢，对吧？好的，让我们来分析一下。假设我们处于这种情况:</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/287cf5b04531ee18a9733b6c6175678c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*Lbw8dgYvimSygo0v.png"/></div></figure><p id="9fde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对手在为O而战。例如，如果我下1–0，对手可以很容易地下0–2，然后像这样困住我。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi ku"><img src="../Images/786da19a58de6f440362b326cb1efa34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*AFXD9LnMw8mFz3hV.png"/></div></figure><p id="db10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为，没有完成或保存移动可用，我不能检测到这一点。为了检测这个，我必须检查每一个箱子，直到我找到一个安全的。我可以通过首先选中复选框来完成。然后我会在剩下的每一个盒子上玩对手回合。</p><p id="50c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我就可以判断他的任何一步棋是否会导致陷阱。我的任何一个回合，如果我在任何地方都找不到陷阱移动，将是我的下一个移动。在某些回合中，对手不可能打出所有可用的牌盒，例如，在一个回合中，他必须进行一次豁免。在这种情况下，我不会重复他所有可能的走法，而只是那些挽救的走法。我会假设如果我出一招迫使对手自救，他会尝试自救。好了，这就是如何翻译成JavaScript的。</p><pre class="kv kw kx ky gt lc ld le lf aw lg bi"><span id="4edf" class="lh li iq ld b gy lj lk l ll lm"><em class="kl">function </em>predictTrappingMove() {<br/><em class="kl">  var </em> checkedBoxesBackup = checkedBoxes.slice();<br/><em class="kl">  var </em> remainingMoves =getRemainingMoves();<br/><em class="kl">  var</em>  nextMove;<br/><em class="kl">  var</em>  moveFound;<br/>  for(<em class="kl">var</em> move of remainingMoves){<br/>checkedBoxes.push({box: move, player: currentPlayer})<br/>    switchPlayer();<br/>//Check if the opponent needs to play a saving move<br/><em class="kl">    var</em> savingMove =  computeSavingMove();<br/>    if(savingMove){<br/>checkedBoxes.push({box: savingMove, player: currentPlayer});<br/>      if(checkTrap() =='no trap'){<br/>checkedBoxes.pop();<br/>        switchPlayer();<br/>nextMove = move;<br/>        break;<br/>}<br/>checkedBoxes.pop();<br/>      switchPlayer();<br/>     continue;<br/>}<br/>//If no saving move is required, check each position  <br/> else{<br/>     switchPlayer();<br/>     for(<em class="kl">var</em> opponentMove ofgetRemainingMoves()){<br/>       switchPlayer();<br/>       moveFound =true;<br/>       checkedBoxes.push({box: opponentMove, player: currentPlayer});<br/>       if(checkTrap() =='trapped'){<br/>         moveFound =false;<br/>         checkedBoxes.pop();<br/>         switchPlayer();<br/>         break;<br/>       }<br/>         checkedBoxes.pop();<br/>         switchPlayer();<br/>}<br/>}<br/>checkedBoxes.pop();<br/>    if(moveFound){<br/>nextMove = move;<br/>      break;<br/>}<br/>}</span><span id="f4d0" class="lh li iq ld b gy ln lk l ll lm">checkedBoxes = checkedBoxesBackup;<br/>  return nextMove;<br/>}<br/><em class="kl">function </em>checkTrap(){<br/><em class="kl">  var</em>  boxes =getRemainingMoves();<br/><em class="kl">  var </em> winningMoveCount =0;<br/>  for(<em class="kl">var </em> freeMove of boxes){<br/>checkedBoxes.push({box: freeMove, player: currentPlayer});<br/><em class="kl">    var</em> result = checkWinner(true);<br/>    if(result =='game over')<br/>winningMoveCount++<br/>checkedBoxes.pop();<br/>}<br/>  if(winningMoveCount &gt;1){<br/>    return 'trapped';<br/>}<br/>  else{<br/>    return 'no trap';<br/>}<br/>}</span></pre><p id="0916" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，<strong class="jp ir"> predictTrappingMove </strong>首先代表我选中一个框。然后，它会检查对手是否需要进行一次豁免来反击。如果是，它将调用<strong class="jp ir"> checkTrap </strong>方法来查看对手移动时是否创建了多个豁免条件。</p><p id="8248" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不是，那就是将被返回并使用的移动。然而，如果不是这样，对手的豁免移动给我们制造了一个陷阱，我们需要向前移动并为自己检查剩余的盒子，然后每次代表对手检查剩余的盒子并每次调用<strong class="jp ir"> checkTrap </strong>方法。如果任何一个盒子产生了一个“陷阱移动”，我们就避免这个移动，并继续迭代剩余的移动，直到我们找到一个安全的移动。</p><p id="0b05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可能还是有点令人困惑，但是如果你仔细阅读几遍代码，就会明白了。</p><h1 id="7535" class="mc li iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">5.随机移动</h1><p id="ff96" class="pw-post-body-paragraph jn jo iq jp b jq mz js jt ju na jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">我在游戏的第一个版本中编写了<strong class="jp ir">computer and move</strong>来计算如果所有的检查都没有返回一个走法时的走法。然而，现在这并不相关，因为<strong class="jp ir"> checkTrappingMove </strong>将总是返回一个移动，而不管一切。如果你需要的话，这里还有代码。</p><pre class="kv kw kx ky gt lc ld le lf aw lg bi"><span id="2959" class="lh li iq ld b gy lj lk l ll lm"><em class="kl">function </em>computeRandomMove() {<br/><em class="kl">  var</em>  remainingMoves =getRemainingMoves();<br/>  return remainingMoves[Math.floor(Math.random()*remainingMoves.length)]<br/>}</span></pre><p id="5d2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它只是利用JavaScript的<strong class="jp ir"> Math.random() </strong>方法，并基于来自<strong class="jp ir"> remainingMoves </strong>的方法返回一个盒子。所以，就这样了。你已经准备好创造无与伦比的井字游戏了。你可以继续用同样的原则写你自己的，或者甚至改进这些原则。</p><p id="00b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你甚至可以试着写一个方法，让<strong class="jp ir">强迫对手移动</strong>，让你的玩家变得更有侵略性。如果你走到这一步，感谢你的耐心。下次见！</p><p id="a880" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">TL；DR编写代码来创建无与伦比的井字游戏很简单，但重要的是提出逻辑。</em></p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><div class="kv kw kx ky gt ne"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">编写面试问题</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">掌握编码面试的过程</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">技术开发</p></div></div><div class="nn l"><div class="no l np nq nr nn ns la ne"/></div></div></a></div></div></div>    
</body>
</html>