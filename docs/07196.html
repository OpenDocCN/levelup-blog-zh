<html>
<head>
<title>Diving into Scala Cats — Functors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入Scala猫——函子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/diving-into-scala-cats-functors-c957285d7009?source=collection_archive---------8-----------------------#2021-01-31">https://levelup.gitconnected.com/diving-into-scala-cats-functors-c957285d7009?source=collection_archive---------8-----------------------#2021-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e99ea2ae39b7c18da1c2d9575d55576b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yZ3-Bl9fnHdUQJ-P"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@kstonematheson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯特·斯通·马西森</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="a622" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不熟悉类型类的概念，我建议你阅读我的另一篇文章来解释它们。Cats库广泛使用了类型类，对其有基本的理解是本文的前提。</p><p id="b43d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在以前的文章中，我们谈到了<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/diving-into-scala-cats-semigroups-732ef2432042">半群</a>和<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/diving-into-scala-cats-monoids-82e744b9e518">幺半群</a>，它们是让我们将相同类型的值组合在一起的抽象。</p><p id="29d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看<strong class="kf ir">函子</strong>，它允许我们在不知道容器本身的任何实现细节的情况下操作容器内部的值。</p><h1 id="4b34" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是函子？</h1><p id="96d0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">就函数式编程而言，<em class="me">函子</em>就是可以被映射的东西，或者我们可以称之为<em class="me">可映射</em>。</p><p id="06cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它基本上是<em class="me"> </em>一种抽象，允许我们<br/>在一个上下文中表示操作序列，例如集合、期货和期权。</p><p id="bccf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Cats的类型类为可映射类型提供了一个基类，允许我们为期货、期权、列表等编写通用代码。</p><p id="c049" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">标准Scala没有基本类型/特征来代表以下内容:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="9980" class="mr lc iq mi b gy ms mt l mu mv">def calcBudget(orders: List[LineItem]) = orders.map(...)<br/>def calcBudget(maybeOrder: Option[LineItem]) = maybeOrder.map(...)<br/>def calcBudget(eventualOrder: Future[LineItem]) = eventualOrder.map(...)</span></pre><p id="211c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，使用cats的<code class="fe mf mg mh mi b">Functor<em class="me"> </em></code>类型类，我们可以编写一个通用方法，如下所示:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="6f73" class="mr lc iq mi b gy ms mt l mu mv">def calcBudget(order: Functor[LineItem]) = order.map(...)</span></pre><h1 id="9b84" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函子的定义</h1><p id="03c8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个<code class="fe mf mg mh mi b">Functor </code>是一个<code class="fe mf mg mh mi b">F[A]</code>型带地图操作<code class="fe mf mg mh mi b"> (A =&gt; B) =&gt; F[B]</code>:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="9876" class="mr lc iq mi b gy ms mt l mu mv">package cats</span><span id="a76c" class="mr lc iq mi b gy mw mt l mu mv">trait Functor[F[_]] {<br/>  def map[A, B](fa: F[A])(f: A =&gt; B): F[B]<br/>}</span></pre><p id="826a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它接受初始的<code class="fe mf mg mh mi b">F[A]</code>作为转换函数的参数。</p><p id="3984" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们用<code class="fe mf mg mh mi b">Functor</code>重写<code class="fe mf mg mh mi b">calcBudget</code>:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="932e" class="mr lc iq mi b gy ms mt l mu mv">import cats.Functor</span><span id="1420" class="mr lc iq mi b gy mw mt l mu mv">case class LineItem(price: Double)</span><span id="4e41" class="mr lc iq mi b gy mw mt l mu mv">def calcBudget[F[_]](order: F[LineItem])(implicit ev: Functor[F]): F[LineItem] = {<br/>  Functor[F].map(order)(o =&gt; o.copy(price = o.price * 1.2))<br/>}</span></pre><p id="d9b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mf mg mh mi b">Functor[F].map(...)</code>方法基于<code class="fe mf mg mh mi b">F[_]</code>的类型进行参数化。这里的<code class="fe mf mg mh mi b">F[_]</code>是指任何一个<em class="me">类型构造器</em>(一个类型包装另一个类型)都有一个<code class="fe mf mg mh mi b">map</code>方法，比如<code class="fe mf mg mh mi b">Option</code>、<code class="fe mf mg mh mi b">List</code>、<code class="fe mf mg mh mi b">Future</code>等。</p><p id="5e61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">隐式参数<code class="fe mf mg mh mi b">ev: Functor[F]</code>意味着我们必须有一个<em class="me">类型的类实现</em>，它允许我们把<code class="fe mf mg mh mi b">F</code>当作一只猫<code class="fe mf mg mh mi b">Functor</code>。</p><h1 id="145e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函子定律</h1><p id="13e3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们正在创建自己的函子，那么<code class="fe mf mg mh mi b">Functor </code>必须遵循这些定律。</p><ul class=""><li id="0f99" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated"><em class="me">身份</em>:如果我们传递一个<code class="fe mf mg mh mi b">identity</code>函数给<code class="fe mf mg mh mi b">Functor map</code>方法，那么<code class="fe mf mg mh mi b">Functor </code>必须取回原来的<code class="fe mf mg mh mi b">Functor</code>。</li><li id="b7df" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><em class="me">合成</em>:如果两个函数像<code class="fe mf mg mh mi b">(f andThen g</code> ) <code class="fe mf mg mh mi b">(x)</code>或<code class="fe mf mg mh mi b">map(f).map(g)</code> <strong class="kf ir"> </strong>一样顺序执行，那么输出必须等于<strong class="kf ir"> </strong> <code class="fe mf mg mh mi b">g(f(x))</code>。</li></ul><h1 id="b3b5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">仿函数类型类和实例</h1><p id="cdca" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">函子类型类是<code class="fe mf mg mh mi b">cats.Functor</code>。Cats库为我们提供了内置的函子和预定义类型的实现，如<code class="fe mf mg mh mi b">Option</code>、<code class="fe mf mg mh mi b">List</code>、<code class="fe mf mg mh mi b">Future</code>等。</p><p id="8478" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止一切顺利，让我们尝试使用类型类实现<code class="fe mf mg mh mi b">Functor</code>的<code class="fe mf mg mh mi b">List</code>:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="6414" class="mr lc iq mi b gy ms mt l mu mv">import cats.Functor</span><span id="3684" class="mr lc iq mi b gy mw mt l mu mv">object ListFunctor {<br/>  def transformList(list: List[Int]): List[Int] = {<br/>    Functor[List].map(list)(_ * 2)<br/>  }<br/>}</span><span id="c833" class="mr lc iq mi b gy mw mt l mu mv">val list: List[Int] = List(1, 2, 3, 4, 5)<br/>val transformedList = List(2, 4, 6, 8, 10)<br/>assert(ListFunctor.transformList(list) == transformedList)</span></pre><p id="bf3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们尝试使用<code class="fe mf mg mh mi b">Option</code>的类型类实现<code class="fe mf mg mh mi b">Functor</code>:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="6a35" class="mr lc iq mi b gy ms mt l mu mv">import cats.Functor</span><span id="4c02" class="mr lc iq mi b gy mw mt l mu mv">object OptionFunctor {<br/>  def transformOption(option: Option[Int]): Option[String] = {<br/>    Functor[Option].map(option)(_.toString)<br/>  }<br/>}</span><span id="e9e8" class="mr lc iq mi b gy mw mt l mu mv">val option: Option[Int] = Some(10)<br/>val transformedOption = Some("10")<br/>assert(OptionFunctor.transformOption(option) == transformedOption)</span></pre><p id="f138" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们尝试使用类型类实现<code class="fe mf mg mh mi b">Functor</code>中的<code class="fe mf mg mh mi b">Future</code>:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="10d0" class="mr lc iq mi b gy ms mt l mu mv">import cats.Functor</span><span id="0d9c" class="mr lc iq mi b gy mw mt l mu mv">object FutureFunctor {<br/>  def transformFuture(future: Future[Int]): Future[Int] = {<br/>    Functor[Future].map(future)(_ + 1)<br/>  }<br/>}</span><span id="bfc1" class="mr lc iq mi b gy mw mt l mu mv">val future: Future[Int] = Future{10}<br/>val transformedFutureResult = 11<br/>FutureFunctor.transformFuture(future).map(result =&gt; assert(result == transformedFutureResult))</span></pre><p id="8f4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当我们为<code class="fe mf mg mh mi b">Future</code>调用一个<code class="fe mf mg mh mi b">Functor </code>时，编译器将<br/>通过隐式解析定位<code class="fe mf mg mh mi b">futureFunctor </code>，并在调用位置递归搜索一个<br/> <code class="fe mf mg mh mi b">ExecutionContext </code>。这是资料片看起来的样子:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="d836" class="mr lc iq mi b gy ms mt l mu mv">// We write this:<br/>Functor[Future]</span><span id="2109" class="mr lc iq mi b gy mw mt l mu mv">// The compiler expands to this first:<br/>Functor[Future](futureFunctor)</span><span id="a7b5" class="mr lc iq mi b gy mw mt l mu mv">// And then to this:<br/>Functor[Future](futureFunctor(executionContext))</span></pre><h1 id="8c36" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">仿函数语法</h1><p id="511d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通过使用<code class="fe mf mg mh mi b">Functor </code>类型类，我们可以抽象出任何可以映射的东西。我们不局限于标准库中的类型，我们可以向我们自己的类型添加一个map方法。</p><p id="775e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Cats允许我们通过使用<em class="me">语法</em>或<em class="me">扩展</em>方法的概念来做到这一点。</p><p id="ea1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个概念是使用隐式类实现的，并允许我们编写<code class="fe mf mg mh mi b">order.map(...)</code>而不是<code class="fe mf mg mh mi b">Functor[F].map(order)(...)</code>。我们也可以通过指定类型<code class="fe mf mg mh mi b">F[_]</code>为<code class="fe mf mg mh mi b">Functor</code>来删除隐式参数:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="f75f" class="mr lc iq mi b gy ms mt l mu mv">import cats.syntax.functor._ //for map</span><span id="4544" class="mr lc iq mi b gy mw mt l mu mv">def calcBudget[F[_]: Functor](order: F[LineItem]): F[LineItem] = {<br/>  order.map(o =&gt; o.copy(price = o.price * 1.2))<br/>}</span></pre><p id="1e20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们也可以构建一个高阶函数，它可以处理任何类型并执行任何映射操作:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="87c9" class="mr lc iq mi b gy ms mt l mu mv">def withFunctor[A, B, F[_]](item: F[A], op: A =&gt; B)(implicit ev: Functor[F]): F[_] = Functor[F].map(item)(op)</span><span id="a576" class="mr lc iq mi b gy mw mt l mu mv">val lineItemsList = List(LineItem(10.0), LineItem(20.0))<br/>val result = FunctorSyntax.withFunctor(lineItemsList, calcBudget)<br/>assert(result == List(LineItem(10.0), LineItem(20.0)))</span></pre><p id="d2c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，这是一个人为的例子，因为<code class="fe mf mg mh mi b">withFunctor</code>在简单的内联调用中没有增加任何值，但是它说明了一点，即<code class="fe mf mg mh mi b">A, B &amp; F</code>可以是任何东西，只要方法的调用者:</p><ul class=""><li id="3cbb" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated">提供证据证明<code class="fe mf mg mh mi b">F </code>是一个<code class="fe mf mg mh mi b">Functor </code>(一个实现)</li><li id="9c81" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">知道如何从<code class="fe mf mg mh mi b">A </code>映射到<code class="fe mf mg mh mi b">B</code></li></ul><h1 id="464c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="0505" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在本文中，我们已经了解了Scala Cats库提供的<em class="me">函子</em>。<em class="me">函子</em>代表排序行为。我们讨论了为什么我们需要<em class="me">函子</em>以及如何定义它们。对于一个要成为<em class="me">仿函数</em>的类型类，它必须遵守两个<em class="me">法则</em>:首先，它应该能够组合两个<em class="me">映射</em>调用。其次，使用<em class="me">标识</em>函数进行映射应该没有影响。我们看到，我们可以为Scala生态系统<em class="me">中的所有<em class="me">可映射</em>类型编写<em class="me">仿函数</em>类型类实现，如</em> <em class="me">期货</em>、<em class="me">选项</em>、<em class="me">列表等</em>。我们不局限于标准库中的类型，我们还可以通过使用<em class="me">语法</em>或<em class="me">扩展</em>方法的概念，将<em class="me">映射</em>方法添加到我们自己的类型中。</p><p id="9c5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在接下来的文章中，我们将了解更多关于猫的核心概念。<br/>敬请期待！！！</p><h1 id="60ce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考</h1><p id="9803" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我所知道的最好的两个Scala Cats资源在这里:</p><ul class=""><li id="3da1" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated">猫库可以在<a class="ae kc" href="https://github.com/typelevel/cats" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获得</li><li id="5c40" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">本书，<a class="ae kc" href="https://underscore.io/books/advanced-scala/" rel="noopener ugc nofollow" target="_blank"> <em class="me">高级Scala与猫</em> </a></li></ul></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="0fce" class="lb lc iq bd ld le ns lg lh li nt lk ll lm nu lo lp lq nv ls lt lu nw lw lx ly bi translated">类似文章-</h1><p id="e811" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你也可以看看我在<em class="me"> Scala Cats </em>系列上的其他文章</p><ul class=""><li id="ec48" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated">【Scala猫入门</li><li id="79c9" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/diving-into-scala-cats-semigroups-732ef2432042">潜入标量猫—半群</a></li><li id="2b01" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/diving-into-scala-cats-monoids-82e744b9e518">潜入斯卡拉猫——幺半群</a></li><li id="1c19" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/functors-in-functional-programming-dfaba4cfb2ed">函数式编程中的函子</a></li></ul></div></div>    
</body>
</html>