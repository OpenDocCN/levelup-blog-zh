<html>
<head>
<title>FastAPI: How to Process Incoming Requests in Batches</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">FastAPI:如何成批处理传入的请求</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/fastapi-how-to-process-incoming-requests-in-batches-b384a1406ec?source=collection_archive---------1-----------------------#2020-11-17">https://levelup.gitconnected.com/fastapi-how-to-process-incoming-requests-in-batches-b384a1406ec?source=collection_archive---------1-----------------------#2020-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5dd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在FastAPI中利用WebSockets、Queue和APScheduler进行批处理</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/2334e95bafbee016ba08d0333975f1ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9xZufQwaWOZHoaocGYiEDA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@mihaly_koles?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米赫利·克勒斯</a>在<a class="ae le" href="https://unsplash.com/s/photos/queue?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="60cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本教程中，我将分享一个我在周末进行的简单实验。基本思想是将所有传入的请求排队，每次以一定的时间间隔分批处理。为此，我们将</p><ol class=""><li id="3440" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">通过WebSockets在客户端和我们的服务器之间建立双向连接。</li><li id="10d5" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">将传入的请求存储在队列中</li><li id="c5c3" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">运行调度程序并成批处理请求</li><li id="d80a" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">通过WebSockets将响应返回给用户</li></ol><p id="3c44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该架构相当简单，对于我们的案例研究来说已经足够好了。请注意，如果您正在寻找生产就绪的解决方案，您应该根据您的用例使用RabbitMQ(消息代理)或Celery(分布式任务队列)。</p><p id="3e0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们继续下一部分，开始安装必要的模块</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="efe3" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">设置</h1><h2 id="8d67" class="my mb it bd mc mz na dn mg nb nc dp mk kb nd ne mo kf nf ng ms kj nh ni mw nj bi translated">安装FastAPI</h2><p id="2e9a" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">强烈建议您在继续之前创建一个虚拟环境。激活您的虚拟环境并运行以下命令来安装FastAPI。</p><pre class="kp kq kr ks gt np nq nr ns aw nt bi"><span id="3b48" class="my mb it nq b gy nu nv l nw nx">pip install fastapi</span></pre><h2 id="b124" class="my mb it bd mc mz na dn mg nb nc dp mk kb nd ne mo kf nf ng ms kj nh ni mw nj bi translated">安装Uvicorn</h2><p id="d05b" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">为了运行FastAPI，您需要有一个ASGI服务器。我将使用Uvicorn，因为它是推荐的ASGI服务器。</p><p id="e14d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以选择最小安装或标准安装。对于标准安装，运行以下命令</p><pre class="kp kq kr ks gt np nq nr ns aw nt bi"><span id="5cd6" class="my mb it nq b gy nu nv l nw nx">pip install uvicorn[standard]</span></pre><p id="3f8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于最小依赖性，您可以如下安装:</p><pre class="kp kq kr ks gt np nq nr ns aw nt bi"><span id="63e2" class="my mb it nq b gy nu nv l nw nx">pip install uvicorn</span></pre><p id="6209" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，最小软件包没有基于Cython的依赖项和其他额外选项，如WebSockets。让我们按如下方式手动安装它:</p><pre class="kp kq kr ks gt np nq nr ns aw nt bi"><span id="58b8" class="my mb it nq b gy nu nv l nw nx">pip install websockets</span></pre><h2 id="cda0" class="my mb it bd mc mz na dn mg nb nc dp mk kb nd ne mo kf nf ng ms kj nh ni mw nj bi translated">安装日程安排器</h2><p id="09dc" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">接下来，运行下面的命令来安装apscheduler，这是一个进程内任务调度器，具有类似Cron的Python功能。</p><pre class="kp kq kr ks gt np nq nr ns aw nt bi"><span id="46d6" class="my mb it nq b gy nu nv l nw nx">pip install apscheduler</span></pre><p id="8b49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之前我写过一篇关于它的教程，名为<a class="ae le" href="https://medium.com/better-programming/introduction-to-apscheduler-86337f3bb4a6" rel="noopener">APS cheduler</a>介绍。请随意查看。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="3fe4" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">履行</h1><p id="f55c" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">在本节中，我们将实现我们的FastAPI服务器。实现基于FastAPI <a class="ae le" href="https://fastapi.tiangolo.com/advanced/websockets/?h=+webs#handling-disconnections-and-multiple-clients" rel="noopener ugc nofollow" target="_blank">官方文档</a>中提供的WebSockets教程。创建一个名为<code class="fe ny nz oa nq b">myapp.py</code>的新Python文件。你可以随意给它取任何你喜欢的名字。</p><h2 id="cf69" class="my mb it bd mc mz na dn mg nb nc dp mk kb nd ne mo kf nf ng ms kj nh ni mw nj bi translated">添加导入</h2><p id="f2eb" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">在Python文件的顶部添加以下导入语句</p><pre class="kp kq kr ks gt np nq nr ns aw nt bi"><span id="81e9" class="my mb it nq b gy nu nv l nw nx">from typing import List<br/>import queue<br/>from fastapi import FastAPI, WebSocket, WebSocketDisconnect<br/>from fastapi.responses import HTMLResponse<br/>from apscheduler.schedulers.asyncio import AsyncIOScheduler</span></pre><p id="4e7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ny nz oa nq b">AsyncIOScheduler</code>用于运行基于本机协同程序(异步定义)的作业。</p><h2 id="f858" class="my mb it bd mc mz na dn mg nb nc dp mk kb nd ne mo kf nf ng ms kj nh ni mw nj bi translated">初始化变量</h2><p id="17e6" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">初始化下列变量。</p><pre class="kp kq kr ks gt np nq nr ns aw nt bi"><span id="4176" class="my mb it nq b gy nu nv l nw nx">app = FastAPI()<br/>app.queue_system = queue.Queue()<br/>app.queue_limit = 5</span></pre><ul class=""><li id="c4b9" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn ob ll lm ln bi translated"><code class="fe ny nz oa nq b">queue_system</code> —应用级队列对象。我们将把所有数据存储在里面，以便以后处理。</li><li id="e929" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn ob ll lm ln bi translated"><code class="fe ny nz oa nq b">queue_limit</code> —单个批次中要处理的项目数量。在这种情况下，它将在每个调度期间处理队列中的5个传入请求。</li></ul><p id="e635" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们为HTML文档创建一个长字符串。它包含调用我们的FastAPI服务器所需的HTML元素和JavaScript代码。我们将把它作为前端网页，以获得用户的输入。或者，您可以使用Jinja2模板引擎为其提供服务，或者使用React/Angular/Vue构建前端应用程序。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="e626" class="my mb it bd mc mz na dn mg nb nc dp mk kb nd ne mo kf nf ng ms kj nh ni mw nj bi translated">正在创建ConnectionManager类</h2><p id="51b4" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">让我们创建一个新的Python类来处理<code class="fe ny nz oa nq b">websocket</code>连接。初始化一个新实例，并将其赋给一个变量。我们以后会用到它。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="fe8b" class="my mb it bd mc mz na dn mg nb nc dp mk kb nd ne mo kf nf ng ms kj nh ni mw nj bi translated">创建任务计划程序</h2><p id="e62e" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">为我们的调度程序创建一个新的<code class="fe ny nz oa nq b">async</code>函数。你可以给它起任何你喜欢的名字。在这个函数中，我们将根据之前设置的<code class="fe ny nz oa nq b">queue_limit</code>循环执行我们的流程。</p><p id="71a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">检查队列是否为空以及相应的websocket是否仍处于活动状态非常重要。这可以确保我们的服务器可以正常运行，如果用户在您完成执行之前关闭浏览器并断开与您的服务器的连接。</p><p id="f306" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，实现您自己的自定义执行，并通过我们在<code class="fe ny nz oa nq b">ConnectionManager</code>类中定义的<code class="fe ny nz oa nq b">send_personal_message</code>函数将结果发送回用户。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="c5fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是设置我们的调度函数。初始化一个新的<code class="fe ny nz oa nq b">AsyncIOScheduler </code>实例，并通过<code class="fe ny nz oa nq b">add_job</code>功能向其添加一个新任务。我把它设置成每5秒钟运行一次。通过调用<code class="fe ny nz oa nq b">start</code>函数正常启动。</p><p id="ee71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正确的做法是，一旦使用完调度程序实例，就应该优雅地关闭它。您可以通过使用<a class="ae le" href="https://medium.com/better-programming/create-exit-handlers-for-your-python-appl-bc279e796b6b" rel="noopener"> atexit模块</a>或<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/4-useful-advanced-features-in-fastapi-f08e4db59637"> FastAPI事件处理程序</a>轻松实现它。</p><h2 id="ac1c" class="my mb it bd mc mz na dn mg nb nc dp mk kb nd ne mo kf nf ng ms kj nh ni mw nj bi translated">实现FastAPI路由</h2><p id="561a" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">最后，让我们实现两条FastAPI路线:</p><ul class=""><li id="76ff" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn ob ll lm ln bi translated"><code class="fe ny nz oa nq b">main</code> —将我们的HTML长字符串作为HTMLResponse提供给用户的路径</li><li id="6b8e" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn ob ll lm ln bi translated"><code class="fe ny nz oa nq b">websocket_endpoint </code> —用于处理来自用户的传入websocket请求的路由。它将所有传入的请求作为字典存储在<code class="fe ny nz oa nq b">queue_system</code>变量中。</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="136b" class="my mb it bd mc mz na dn mg nb nc dp mk kb nd ne mo kf nf ng ms kj nh ni mw nj bi translated">正在启动FastAPI服务器</h2><p id="4436" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">保存文件并运行以下命令来启动它。相应地修改名称。</p><pre class="kp kq kr ks gt np nq nr ns aw nt bi"><span id="4845" class="my mb it nq b gy nu nv l nw nx">uvicorn myapp:app</span></pre><p id="c89c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该在控制台上看到以下输出</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/0c4cab7b0cb9e429fe376c2f3f327708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NWwGtAGnXfITSNYDNzvV9Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</figcaption></figure><p id="1029" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在浏览器中打开以下URL</p><pre class="kp kq kr ks gt np nq nr ns aw nt bi"><span id="724e" class="my mb it nq b gy nu nv l nw nx"><a class="ae le" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/</a></span></pre><p id="77c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用户界面看起来像这样。请注意，ID会有所不同，因为它是基于当前时间戳的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi of"><img src="../Images/c403ddfb7d18ab1fdaee34f14e7d7872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*052agMrX8M3PTxhwaQB5Qg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</figcaption></figure><p id="f590" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们向我们的服务器发送几条消息。我将发送一个从1到18的数字。通过这样做，我们将知道响应是否</p><ul class=""><li id="06f0" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn ob ll lm ln bi translated">按顺序(应该返回1，2，3，4，5，… 17，18)</li><li id="8fee" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn ob ll lm ln bi translated">每5秒钟分批处理5个请求</li></ul><p id="4a1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你必须尽快去验证它。如果有问题，请尝试以下方法:</p><ul class=""><li id="8a45" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn ob ll lm ln bi translated">减少<code class="fe ny nz oa nq b">queue_limit</code>的值</li><li id="4810" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn ob ll lm ln bi translated">增加调度程序的间隔时间</li></ul><p id="78f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在一天结束时，您应该从FastAPI服务器得到以下响应，表明这些响应实际上是有序的，并且是成批处理的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/8787a244cc16f84691fdde07c1fe93b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*2zgdbqTLZtffmEu5f-13kA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</figcaption></figure><p id="dd97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在下面的<a class="ae le" href="https://gist.github.com/wfng92/f7a125808ea3b2f9ee0ee84976da694b" rel="noopener ugc nofollow" target="_blank"> Github gist </a>找到完整的代码。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="26c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">强烈建议查看以下文章，了解有关FastAPI的更多信息:</p><ul class=""><li id="e4a9" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn ob ll lm ln bi translated"><a class="ae le" href="https://medium.com/better-programming/migrate-from-flask-to-fastapi-smoothly-cc4c6c255397" rel="noopener">从烧瓶顺利迁移到FastAPI】</a></li><li id="282a" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn ob ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/4-useful-advanced-features-in-fastapi-f08e4db59637">FastAPI中4个有用的高级特性</a></li><li id="2f27" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn ob ll lm ln bi translated"><a class="ae le" href="https://medium.com/better-programming/metadata-and-additional-responses-in-fastapi-ea90a321d477" rel="noopener">FastAPI中的元数据和附加响应</a></li><li id="37c2" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn ob ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/how-to-save-uploaded-files-in-fastapi-90786851f1d3">如何在FastAPI中保存上传的文件</a></li><li id="c558" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn ob ll lm ln bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/how-to-restart-fastapi-server-with-bash-script-f05a5bfcec5c">如何用Bash脚本重启FastAPI服务器</a></li></ul></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="789f" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">结论</h1><p id="fa15" class="pw-post-body-paragraph jq jr it js b jt nk jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj no kl km kn im bi translated">祝贺您完成本教程。让我们回顾一下今天所学的内容。</p><p id="60f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先简要介绍了案例研究的概况和架构。基本要点是成批处理传入的请求，并将响应发送回用户。</p><p id="adfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们通过<code class="fe ny nz oa nq b">pip install</code>为我们的项目安装必要的模块。</p><p id="2ece" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们继续实现并编写了一个简单的FastAPI服务器文件，总共不到100行。最后，我们在浏览器上对它进行了测试，以确保它能够正常工作。</p><p id="8662" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢你阅读这篇文章。希望在下一篇文章中再见到你！</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="1bf3" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">参考</h1><ol class=""><li id="1fe1" class="lf lg it js b jt nk jx nl kb oh kf oi kj oj kn lk ll lm ln bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications" rel="noopener ugc nofollow" target="_blank"> Mozilla编写Websocket客户端应用</a></li><li id="583c" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated"><a class="ae le" href="https://fastapi.tiangolo.com/advanced/websockets/?h=+webs#handling-disconnections-and-multiple-clients" rel="noopener ugc nofollow" target="_blank"> FastAPI WebSockets </a></li></ol></div></div>    
</body>
</html>