# 提高 Python 性能的指南

> 原文：<https://levelup.gitconnected.com/guide-to-improve-python-performance-d1d1a10d7a4d>

![](img/a24579bd5854b4c299b9b10944fcb279.png)

Python 是一种令人惊叹的编程语言，但是与编译语言相比，它有两个巨大的缺陷。

*   第一个是 GIL 或全局解释器锁。GIL 是一个真正的进程锁，它迫使 Python 解释器在单个进程上工作，并且只使用 CPU 中的一个内核。由于这种锁定，Python 既简单又稳定，但与 C 或 Java 等其他编程语言相比，速度非常慢。
*   第二个障碍对于非静态类型也就是动态类型编程语言来说是相当普遍的。简而言之，当您没有指定将要使用的变量的数据类型并依赖于动态类型赋值时，您最终会获得非常慢的执行性能。

幸运的是，有几种方法可以提高 Python 代码的速度。

# 绕过 GIL(并发性/GIL 持久性)

在这种方法中，目标代码的执行是以并行或同时处理数据的方式进行的。本质上，它仅仅意味着将一个任务分成多个独立的子任务，并在不同的线程或进程中处理每个子任务。这也被称为多线程或多重处理。这种方法非常有效，前提是你的任务可以分成不同的任务。

在继续之前，区分线程和进程是很重要的。线程和进程是两个不同的东西，它们可以以相似的方式使用，但是目的不同。单个进程可以创建多个线程，这受到操作系统的限制。任何单个进程的所有线程都共享同一个内存堆。然而，在 Python 中，新线程并不意味着新的 CPU 核心；因此，线程不会给你带来实际的性能提升，而是帮助你同时关注几个任务。因此，创建线程的成本很低，并且主要应用于 I/O 操作。相反，当你创建一个新的进程时，原始的内存堆被复制，一个新的被创建。两个进程看不到彼此的内存堆，但是在不同的 CPU 内核上工作。创建一个新的进程是很昂贵的，而且最终会占用更多的内存。但是，新的进程为您提供了额外的 CPU 核心(达到最大值),并且可以在本地或集群中的不同计算机上创建。[3,4]

以下是一些例子:

*   假设您的磁盘上有一个非常大的文件，或者内存中有一个列表/数组需要处理。你可以将你的目标/数据分解成更小的任务/块，而不是在一个循环中处理所有的数据，并在你的 CPU 上使用一个内核。最后，您可以在不同的线程或进程中分别处理每个块。
*   类似地，您可以在单线程中运行一些 Python 代码，这些代码将监听网络套接字，以获取可能从 TCP 连接收到的包。
*   并发的另一个流行应用可以在数据分析问题中看到。假设您想要在一个计算机/服务器集群中在短时间内对大量数据执行计算开销很大的操作。在这种情况下，每个进程可以在不同的计算机中运行，数据可以通过网络接口共享。

Python 为并发处理提供了几个内置包。

*   这个模块非常容易使用，但是缺乏高级控制。
*   如果你想用线程做更复杂的事情，比如锁定线程或者在队列中运行任务，这很有用。
*   `**multiprocessing**` -如果你想做更复杂的事情，比如共享内存或者在队列中运行任务，这很有用。

> ***并发 vs 真正的并行*** *:基于并发的并行不是真正的并行。当所有 CPU 内核同时处理同一项任务时，一段代码就会以真正并行的方式执行。真正的并行性基于实际的硬件，通常比并发性更复杂。Python 的 GIL 阻止了代码的真正并行执行。然而，幸运的是，有一些方法可以释放 GIL，实现真正的并行处理。[1]*

# 无 GIL(真正的并行)+可选的静态类型

为了发布 GIL 并提升你的 Python 代码，你至少需要做一点点手脚。Python 是很棒的高级编程语言，其他低级编程语言也是这么写的。原始的和最流行的 Python 实际上是用 C 实现的，这个参考实现叫做 CPython。然而，Python 的其他实现也有其自身的优点和问题。每一个都是由不同的社区开发的；因此，每个 Python 实现都和它的社区一样强大。[5]

> ***Python 包呢？*** *此时，你可能会问自己一个问题。我目前使用的 Python 包在其他 Python 实现中也可用吗？不幸的是，答案是模糊的，因为它实际上取决于实现。肯定会有一些不兼容的地方。为了确保这一点，请务必检查文档资料。*

下面是一些流行的 Python 替代实现。

*   **IronPython** —是。用 C#语言编写的基于. NET 框架的 Python 实现。如果您喜欢编写 Python 代码并且需要使用。NET 框架。
*   **Jython** —是用 Java 编写的基于 JVM 的 Python 实现。如果您喜欢编写 Python 代码，并且需要将它与您的纯 Java 后端紧密集成，这是一个很好的选择。
*   PyPy——是 Python 的另一种实现，带有实时(JIT)编译器。与 Python 的参考实现(CPython)相比，PyPy 利用 JIT 提供了比在 CPython 中实现的原始字节码编译器更好的性能。所以 PyPy/Python 比 CPython/Python 有更好的性能。另外，根据 PyPy 文档，PyPy 支持几乎所有的 Python 包，所以这是 PyPy 的一大优势。但是，PyPy 只支持 32 位架构，更新不像 Python 那么频繁。

以下不是 Python 实现

*   **NumPy/Pandas/Dask**——“正确”使用这些数据分析包中实现的许多方法几乎总是会给你带来显著的性能提升。
*   **Cython** —不是 Python 的实现。它是编译成 C 的 Python 的超集。它的语法几乎与 Python 的语法相同，但更像 C，因为它可以理解静态类型。几乎任何 Python 代码都可以使用 Cython 编译，以生成具有相同功能但执行时间更快的模块。同样，大多数情况下，将 C 代码重写为 Cython 代码是很容易的。此外，许多内置模块和方法都针对 Cython 进行了优化，以便在编译之前生成最少的 C 代码。而且，Cython 还支持 NumPy，使用`numpy.ndarray`时运行非常高效。[2]
*   Numba 是一个支持 NumPy 的 Python JIT 编译器。Numba 是非常用户友好的，可以很容易地应用到你想要加速的 Python 代码的特定部分。

> ***重要提示:*** *本节描述的每种方法都有可比较的优点和缺点、最佳使用应用、最佳实践、学习曲线。然而，如果您想从任何方法中获得最佳性能，您将需要亲自动手。*

# 无 GIL(真正的并行)+强制静态类型

下面的方法不同于上面的所有方法，因为它们需要对第二种低级编程语言(如 C/C++)有足够的了解。本节描述的是在 Python 和用低级编程语言编写的扩展之间充当“桥梁”的工具/方法。因此，性能只受低级编程语言和桥的限制。此时，在我们继续之前，必须说明两个重要的问题。[5]

*   如果像 C 这样的编译语言，需要源代码的编译和链接，有没有可能在包分发过程中自动编译？
*   由于编译 C 代码可能因操作系统而异，这是否意味着您的扩展代码将不再是跨操作系统的？
*   如何将 Python 数据类型转换成 C 类型，反之亦然？

这些问题没有单一的答案，因为这取决于你想做什么。编译器配置和自动化都可以使用一个名为`distutils`的内置 Python 模块来管理，这个模块非常容易使用。然而，如果你想跨操作系统使用它，这真的取决于你如何设计你的扩展。然而，就数据类型而言，有三种逻辑方法。

*让 C 端处理数据类型:*

*   **Python API(CPython)**—CPython 是 Python 编程语言的参考实现。换句话说，CPython 本质上是主要的 C 代码，编译时会生成 Python 解释器及其字节码编译器。幸运的是，CPython/Python 开发人员通过`Python.h` include 文件为 C/C++程序员提供了对核心 Python API 的访问。使用这种方法编写的扩展可以使用`distutils`轻松分发。还可以使用 CPython 将 Python 功能嵌入到 C 程序中。[5]

*让 Python 端处理数据类型*

*   `**cffi**`(Python 的 C 外来函数接口)——一个拥有自己世界的非常强大的工具。CFFI 为用 C 扩展来扩展 Python 和在 C 程序中嵌入 Python 提供了几种模式。此外，除了 API 模式，CFFI 还提供了 ABI 模式，可用于访问任何编译库中可用的函数，如 Windows 的`.dll`或 Linux/macOS 的`.so`。
*   `**ctypes**` -这是一个内置的 Python 包，为 Python-C 提供了一个外来的函数接口，然而这个包只提供了 ABI 访问类似 CFFI 的库。

*让桥处理数据类型。*

*   SWIG**SWIG**(简化的包装器和接口生成器)——这是一个古老但流行的工具，它可以让你连接不同的编程语言，包括 Python 和 C。SWIG 是最古老的工具之一，它可以连接不同的编程语言，但与其他较新的连接 Python 和 C 的工具相比，它似乎失去了它的流行性。
*   **Cython** — Cython 值得再次出现在这里，因为它的灵活性。Cython 扩展还允许通过`Python.h`使用 Python API，甚至可以作为纯 C 扩展的接口。Cython 非常擅长理解 C 和 Python。[2]

# 结论

总结一下，我们来做一个非常粗略的概括。绕过 GIL 非常容易实现，并且可以显著提高整体性能。此外，多线程允许同步 I/O，而不会阻塞您的主代码。然而，并发并不意味着真正的并行，只能应用于特定的任务。然而，在第二部分中，我们学习了不同的方法来释放 GIL 并保持它的 Python 性。

替代的 Python 实现可以通过释放 GIL 来实现真正的并行，而不会失去 Python 的灵活性。另一方面，Cython 可能需要一些经验来充分利用它。同样，像 Pandas 这样的数据分析包，如果使用正确，可以产生闪电般的性能，但其应用取决于任务的性质。最后，对于那些不怕弄脏手的人来说，GIL 可以通过 C 扩展来发布。c 扩展可以提供对代码的完全控制和最佳的执行速度。但是，C 知识是必须的，因为过多的控制意味着过多的责任。

# 参考

1.  “并发性与并行性”，HowToDoInJava。【在线】。可用:[https://howtodoinjava . com/Java/多线程/并发-并行/](https://howtodoinjava.com/java/multi-threading/concurrency-vs-parallelism/) 。[访问日期:2020 年 3 月 18 日]。
2.  K.cy thon:python 程序员指南，第一版。北京剑桥法纳姆科隆塞瓦斯托波尔东京:奥莱利，2015。
3.  A.J. J. Davis，“Grok the GIL:编写快速且线程安全的 Python”【在线】。可用:[https://emptysqua . re/blog/grok-the-Gil-fast-thread-safe-python/](https://emptysqua.re/blog/grok-the-gil-fast-thread-safe-python/)。[访问日期:2020 年 3 月 18 日]。
4.  “Java 多线程教程”。【在线】。可用:【https://howtodoinjava.com/java/multi-threading/】T4。[访问日期:2020 年 3 月 18 日]。
5.  米（meter 的缩写））实践中的 Python:使用并发性、库和模式创建更好的程序。艾迪森-韦斯利，2013 年。

*原文:*[*https://mmtechslv.github.io/2020/03/python-boost/*](https://mmtechslv.github.io/2020/03/python-boost/)