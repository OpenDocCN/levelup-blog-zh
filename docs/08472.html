<html>
<head>
<title>Practical Algorithms Tier 0: Binary Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用算法第0层:二分搜索法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-algorithms-tier-0-binary-search-99508cc62fe4?source=collection_archive---------4-----------------------#2021-05-05">https://levelup.gitconnected.com/practical-algorithms-tier-0-binary-search-99508cc62fe4?source=collection_archive---------4-----------------------#2021-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="174e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">二分搜索法是一个基本的，但功能强大，经常使用的算法。它有几个有趣的变体，通常在大学计算机科学课上被跳过或者“留给读者做练习”。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/0dca32aa2c7e5d477b24bcc2edb0d67e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XXBMcJNzNUarK6oT"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@felipepelaquim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> @felipepelaquim </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3a09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一次编码竞赛中，我意识到花时间拥有二分搜索法的全部能力和所有漂亮的变化是值得的，同时是“实用的”而没有正式的数学证明(以及数学证明中一些可怕的1索引数组，或与二叉树相关的不必要的抽象)。</p><p id="daf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">1.基本格式</p><p id="4f8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给定一个由<strong class="jp ir">唯一</strong>整数和一个<strong class="jp ir">目标</strong>整数组成的<strong class="jp ir">排序</strong>数组，如果在数组中找到目标，则返回索引，如果没有找到，则返回-1。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="384e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个简单的例子对于检查一个目标值是否在一个有序数组中非常有用，例如<a class="ae lb" href="http://www.cplusplus.com/reference/algorithm/binary_search/" rel="noopener ugc nofollow" target="_blank">c++标准库中的binary_search函数</a>。</p><p id="fa94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在下面的测试用例中，结果应该是<strong class="jp ir"> 2 </strong>:</p><pre class="km kn ko kp gt lf lg lh li aw lj bi"><span id="61db" class="lk ll iq lg b gy lm ln l lo lp">arr = [5, 6, 7, 9]<br/>target = 7</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/f7dbf4b2e2f02c3ca245c45b7d595c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*2-CTbK95XtbbyWg_xUqfYQ.png"/></div></figure><p id="3ead" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<a class="ae lb" href="https://docs.python.org/3/library/bisect.html" rel="noopener ugc nofollow" target="_blank">平分_左</a></p><p id="4e0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给定一个<strong class="jp ir">排序的</strong>整数数组和一个<strong class="jp ir">目标</strong>整数，返回第一个元素的索引<strong class="jp ir">等于目标的</strong>，或者如果没有相等的元素存在，返回目标的<strong class="jp ir">插入位置</strong>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="284d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与基本格式相比，该算法有两个宽松的条件:</p><ul class=""><li id="6018" class="lr ls iq jp b jq jr ju jv jy lt kc lu kg lv kk lw lx ly lz bi translated">在数组中允许重复，而不是唯一</li><li id="5de9" class="lr ls iq jp b jq ma ju mb jy mc kc md kg me kk lw lx ly lz bi translated">如果目标不存在，则返回插入位置，而不是sentinel值-1</li></ul><p id="0ebd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在下面的测试用例中，结果应该是<strong class="jp ir"> 2 </strong>:</p><pre class="km kn ko kp gt lf lg lh li aw lj bi"><span id="b819" class="lk ll iq lg b gy lm ln l lo lp">arr = [5,6,7,7,9]<br/>target = 7</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/65943f6003ea9774c637f213bd19896a.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*FcGnpD8zqgv7Ek6qd7YzaQ.png"/></div></figure><p id="911a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">平分_left的诀窍是循环不变量<code class="fe mg mh mi lg b">low</code>。<code class="fe mg mh mi lg b">low</code>左侧的所有元素严格小于<code class="fe mg mh mi lg b">target</code>。所以当循环退出时，<code class="fe mg mh mi lg b">low</code>处的元素是第一个大于或等于<code class="fe mg mh mi lg b">target</code>的元素。<code class="fe mg mh mi lg b">low</code>也是数组中目标的<code class="fe mg mh mi lg b">rank</code>。</p><p id="d6c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是最常用的二进制搜索算法。</p><p id="dede" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<a class="ae lb" href="https://docs.python.org/3/library/bisect.html" rel="noopener ugc nofollow" target="_blank">对分_右</a></p><p id="a2ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给定一个<strong class="jp ir">排序的</strong>整数数组和一个<strong class="jp ir">目标</strong>整数，返回目标<strong class="jp ir">最后一个</strong>插入位置<strong class="jp ir">的索引。</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="f34f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该算法本质上返回第一个严格大于target的元素的索引。例如，在下面的测试用例中，结果应该是<strong class="jp ir"> 4 </strong>:</p><pre class="km kn ko kp gt lf lg lh li aw lj bi"><span id="71b8" class="lk ll iq lg b gy lm ln l lo lp">arr = [5,6,7,7,9]<br/>target = 7</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/57d450359e87fda87fecac7e53cf0a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*XQxV0HzgBkkZjrMDNxb-5w.png"/></div></figure><p id="d68c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">平分_right的诀窍是循环不变量<code class="fe mg mh mi lg b">high</code>。位于<code class="fe mg mh mi lg b">high</code>右侧的元素严格大于<code class="fe mg mh mi lg b">target</code>。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="6772" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于二分搜索法的迭代实现，时间复杂度为O(lgN)，空间为O(1)，其中<code class="fe mg mh mi lg b">N</code>是阵列的长度。</p><p id="4c9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于递归实现，留给读者作为练习，时间复杂度是O(lgN ),但是由于函数调用的堆栈，空间是O(lgN)。</p><p id="a596" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">神盾局。</p><p id="cfff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参考资料:</p><p id="a1e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Binary_search_algorithm</a>T18】https://docs.python.org/3/library/bisect.htmlT20】http://www.cplusplus.com/reference/algorithm/binary_search/</p></div></div>    
</body>
</html>