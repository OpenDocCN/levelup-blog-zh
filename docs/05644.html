<html>
<head>
<title>Understanding JavaScript Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript承诺</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-javascript-promises-5040a634c474?source=collection_archive---------8-----------------------#2020-09-17">https://levelup.gitconnected.com/understanding-javascript-promises-5040a634c474?source=collection_archive---------8-----------------------#2020-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fad5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个将带你从新手到忍者的指南。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/528ea0e2678f337faef47cb9831e93b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-NMKhx-gbsoU793e3neWNQ.png"/></div></div></figure><h1 id="b479" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">什么是承诺？</h1><p id="1cfe" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Promise表示异步操作的结果。你可以把它看作是你最终会得到的结果的占位符。</p><h1 id="9160" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">为什么要答应？</h1><p id="b760" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">解决<strong class="lo iu">回调地狱</strong>的问题。</p><p id="bbb3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">回调地狱是任何在异步代码中使用函数回调变得难以理解的代码。每当我们加载嵌套回调时，代码就变得难以阅读、测试和调试。这也导致了末日金字塔。</p><p id="5d7e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里有一个回调地狱的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="f29c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">承诺的三种状态</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/60753ec6dfbb2c0bdca4bccc8e04ea5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qfysZLfJiR-HrN2-EBnPOg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">承诺的三种状态</figcaption></figure><p id="25ad" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">待定</strong> →在结果准备好之前，一个承诺处于待定状态。</p><p id="5f4b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">满足→ </strong>如果结果是可用的，它就变成满足</p><p id="354a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">拒绝</strong> →如果出现错误，承诺被拒绝。</p><p id="975f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果一个承诺不是悬而未决的，也就是说，它要么被履行，要么被拒绝，我们说它已经<strong class="lo iu">解决</strong>，这意味着它不能改变它的状态。这意味着一个已经确定的承诺将永远保持这种状态。</p><h2 id="64ea" class="mu kv it bd kw mv mw dn la mx my dp le lv mz na lg lz nb nc li md nd ne lk nf bi translated">例子</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="3105" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><em class="ng"> axios </em>类似于<em class="ng"> fetch </em> API，它返回HTTP响应作为承诺。</p><p id="dbfd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在第3行，我们看到承诺是待定的，因为承诺是异步的，因此需要时间来解决。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/845441a077e66a092b9989a239013c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qeEA5uIXWd5XtPg06dSUuQ.png"/></div></div></figure><h1 id="69c7" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">然后()</h1><p id="7067" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">承诺有一个<strong class="lo iu"> then </strong>方法，当承诺完成时执行该方法。它接收一个回调。</p><p id="dc28" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当我们打印响应时，我们看到它是一个对象。因为响应的状态代码为200，这意味着我们的请求是成功的。它具有数据属性，可以访问该属性以提取所需的信息。在这种情况下是用户数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/dc33bba3ee6c0b96a62efbad3c33723f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qiDz2MaubrDki-WMGUWizg.png"/></div></div></figure><h1 id="3d76" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">操纵响应</h1><p id="485c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">通常我们想要操纵传入的响应，所以我们使用<em class="ng">承诺链。</em></p><p id="ef15" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">链接</strong>:一个接一个地组合方法，其中一个方法的结果依赖于另一个方法。</p><p id="729f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在我们将链接then()方法来操作我们的响应。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="e431" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的示例中，第一个then的结果作为参数传递给第二个then，类似地，第二个then的结果传递给第三个then，依此类推。</p><p id="9923" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在生产代码中，我们并不真正使用变量来通过axios/fetch获得响应。因此，从现在开始我们将使用axios(API_URL)。然后(…)</p><h1 id="6188" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">catch()</h1><p id="ddd5" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">假设我们有一个错误(无效的url、不存在的端点、服务器连接超时等)。)发出请求，然后我们可以使用catch()来捕捉这些错误。像then()一样，它也接收回调。</p><h2 id="6644" class="mu kv it bd kw mv mw dn la mx my dp le lv mz na lg lz nb nc li md nd ne lk nf bi translated">例子</h2><p id="9370" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">假设我们在URL中犯了一个错误</p><p id="4c93" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们只是在上面的例子API_URL中添加了“-”。并将其命名为incorrect_API。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a323" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在控制台中，我们得到一个网络错误和自定义错误消息以及一个get错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/edc99226e0a4ea8037ed7dde148a5e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXGE0IgiUpzELUx9kIBjBg.png"/></div></div></figure><h1 id="f14a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">最后()</h1><p id="164e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">finally()方法在我们希望在承诺已经确定的情况下做某事时使用(即承诺要么实现，要么被拒绝)。它还接受回调。</p><p id="61fc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">假设我们希望在承诺完成后停止加载网页。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4097" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的例子中，我们看到我们甚至可以做更多的事情，甚至在我们最终到达之后。在上面的例子中，我们只是记录了正在加载变量的<em class="ng">的值。</em></p><p id="7c56" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">还有一点需要注意的是，我们的“外部装载…first“先打印。<strong class="lo iu">为什么是</strong>？因为使用承诺的网络请求是异步的，因此是非阻塞的。</p><p id="bc99" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">promise之外的语句正在阻塞。深入阅读更多<em class="ng">阻塞/非阻塞</em>语句<em class="ng"> </em>。参考我的setTimeout()文章<a class="ae nk" rel="noopener ugc nofollow" target="_blank" href="/understanding-settimeout-15c7de9e5fd6"> <em class="ng">这里</em> </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/303e2e473721c022abbfd09df8e9dd4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ao98pFfpBhpih2d2gLfyEw.png"/></div></div></figure><h2 id="7a39" class="mu kv it bd kw mv mw dn la mx my dp le lv mz na lg lz nb nc li md nd ne lk nf bi translated">HTTP拦截器</h2><p id="30f8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这一部分与承诺关系不大，但却是一个方便的axios功能。当您需要检查或更改从应用程序到服务器的HTTP请求时，HTTP拦截器就派上了用场，反之亦然(例如，日志记录、身份验证等)。)</p><p id="aa16" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">拦截器在您通过axios发出HTTP请求之前运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h1 id="5b79" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">解决()和拒绝()</h1><p id="9a9d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们可以使用Promise.resolve()做出一个处于履行状态的承诺</p><h2 id="432e" class="mu kv it bd kw mv mw dn la mx my dp le lv mz na lg lz nb nc li md nd ne lk nf bi translated">示例1:</h2><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="5c4f" class="mu kv it nm b gy nq nr l ns nt">const resolvedPromise = Promise.resolve(‘I am fulfilled’);</span><span id="6888" class="mu kv it nm b gy nu nr l ns nt">console.log(resolvedPromise);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/387c3b20589bacb1caeaec9d1acdb23e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AX7ETBQeyd5hC2MoKQQIbg.png"/></div></div></figure><p id="2504" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">还有一点需要注意:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="c08f" class="mu kv it nm b gy nq nr l ns nt">console.log(Promise.resolve(resolvedPromise) === resolvedPromise); <em class="ng">//=&gt;true</em></span></pre><h2 id="5f4c" class="mu kv it bd kw mv mw dn la mx my dp le lv mz na lg lz nb nc li md nd ne lk nf bi translated">示例2:</h2><p id="6004" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们可以使用Promise.reject()做出处于拒绝状态的承诺</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="84cc" class="mu kv it nm b gy nq nr l ns nt">const rejectedPromise = Promise.reject(new Error(‘I am rejected’));</span><span id="0589" class="mu kv it nm b gy nu nr l ns nt">console.log(rejectedPromise);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/5dac0776920b76c9b5b9ae17954ba966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fepUzbItLImsvGh2QhpjAg.png"/></div></div></figure><p id="77fd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">还有一点需要注意:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="5d11" class="mu kv it nm b gy nq nr l ns nt">console.log(Promise.resolve(rejectedPromise) === rejectedPromise); <em class="ng">//true</em></span></pre><p id="0354" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在控制台中，您可能会看到一条错误消息，因为错误未被捕获。我们可以放心地忽略它，因为它仅用于演示目的。在生产代码中，我们像前面一样使用catch()处理错误。</p><h2 id="5af3" class="mu kv it bd kw mv mw dn la mx my dp le lv mz na lg lz nb nc li md nd ne lk nf bi translated">示例3:</h2><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="8e9b" class="mu kv it nm b gy nq nr l ns nt">const resolvedPromise2 = Promise.resolve(new Error(‘I am fulfilled’));</span><span id="3328" class="mu kv it nm b gy nu nr l ns nt">console.log(resolvedPromise2);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/bdd49363b12b25cc0a153315c7de483b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JwIhhuaEsSOjZXfYPg_WiA.png"/></div></div></figure><p id="e0bc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这里我们看到，即使我们把错误转化为决心，我们的承诺仍然实现。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="a402" class="mu kv it nm b gy nq nr l ns nt">console.log(Promise.resolve(resolvedPromise2) === resolvedPromise2); <em class="ng">//true</em></span></pre><h1 id="22f4" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">转换类似承诺的对象</h1><p id="71de" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Promise.resolve()也可以转换promise like对象。下面的语句将发出Ajax请求的jQuery转换为承诺。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="d3bc" class="mu kv it nm b gy nq nr l ns nt">Promise.resolve($.getJSON(API_URL)).then().catch().finally();</span></pre><h1 id="97e9" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建自定义承诺</h1><p id="9b85" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">事实上，我们可以使用<code class="fe nx ny nz nm b">Promise</code>构造函数创建我们赢得的自定义承诺。</p><p id="e1dd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">构造函数接受带有两个参数的回调:resolve和reject。</p><p id="7b1c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们通常在承诺中编写异步操作，根据结果，我们可以解决或拒绝承诺。</p><p id="eb53" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是一个1秒钟后自动完成的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="0376" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">类似地，我们可以通过用reject()替换resolve()(第3行)来自动拒绝我们的客户承诺。</p><p id="84a2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">更好的方法是将承诺包装在函数中，使其可重用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="95c8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果一个错误发生了，或者我们从我们的自定义承诺中抛出了一个错误，那么我们的承诺将像下面这样被拒绝。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="8f9b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们还可以处理像下面这样的决定和拒绝。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b0a6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">记住</strong>:每当resolve为真时，promise执行then()，否则执行catch()</p><h1 id="0b79" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">将回访转化为承诺</h1><p id="1651" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Node.js非常依赖回调，我们可以很容易地将它们转换成承诺。但在此之前，让我们创建一个名为log.txt的文件，其中包含一些文本。对我来说，它是“我是某种文本”。让我们尝试使用node来读取文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/db2660cae09fdb35bf0d98e6ae32a16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B9JzQ-dlGpoqBU_KcW_ESA.png"/></div></div></figure><p id="430a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">但是如果我们要读取一个不存在的文件，我们会得到一个错误。</p><p id="b58b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">要将我们的回调转换为承诺，我们只需将承诺包装在一个函数中，添加resolve()和reject()，然后返回它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/900c003babc931c451a0b0481f06248c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*It4G1r6H9UK75QzeeK-Zgw.png"/></div></div></figure><p id="1cc5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">从上面的例子中我们可以看到，我们可以用相同的样板文件将任何回调转换为承诺。因此，node有一个名为<strong class="lo iu"> promisify </strong>的便利实用程序，可以让我们轻松地进行转换。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/181534fc41fe00770fd9b1a8b3b47378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u16H2P2pq4MrQc9Fmh9EBw.png"/></div></div></figure><h1 id="60d2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">Promise.all()</h1><p id="9436" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们回到最初的API_URL示例，发出两个HTTP请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/b677ea3c0e2a755a959e8c62635157d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qg_ZLQ-wtdvy1TafJWT_jg.png"/></div></div></figure><p id="1da4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，如果我们查看开发人员工具中的“网络”选项卡，我们会发现我们的请求是一个接一个提出的，即交错提出的，因此需要更多时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/147f9fdc9192512db1eb0730fbbeb9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tb08FpdClaqne0-gH4d1Ig.png"/></div></div></figure><p id="1331" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">因为我们的请求并不相互依赖，所以我们可以使用Promise.all()。</p><p id="e748" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">Promise.all()在一个数组中接受多个承诺，同时执行它们，并返回一个响应数组作为承诺。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/790e5347bc8c231ffa1a5473ab585cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N9N95Cw_kMJ-7-vUznwXuA.png"/></div></div></figure><p id="00a6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当我们在开发人员工具中查看我们的网络选项卡时，我们会看到两个请求都是并行进行的，因此节省了时间并提高了性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/9de83a1b955c9674247a17f8894c8c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UnSO8GayW1Vukdr44xM6ug.png"/></div></div></figure><h1 id="9dea" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">异步和等待</h1><p id="7922" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">函数前的<strong class="lo iu"> async </strong>关键字<strong class="lo iu"> </strong>表示函数总是返回一个承诺。关键字<strong class="lo iu"> await </strong>让JavaScript一直等到承诺完成并返回结果。使用async和await，我们可以编写更简洁的异步代码。</p><p id="c9f5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们看看下面的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/6a03f5fd5298246536b16d8d059383a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fpA5UbJRJ-mAw6qJwmWjMQ.png"/></div></div></figure><p id="f1fb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">上面的代码抛出了一个错误“<em class="ng"> promise不可迭代</em>”。<strong class="lo iu">为什么是</strong>？因为记住Promise.all()是一个异步操作，即非阻塞的，但是后面的代码是阻塞的。所以我们的阻塞代码首先运行。记住Promise.all()只在所有的承诺都实现时产生一个响应承诺数组。但是，在我们的例子中，承诺是待定的，因此我们的承诺是不可重复的。</p><p id="8b72" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">因此，为了解决这个问题，我们使用异步等待。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/bd091acc0b1acb158907407565d845b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_BYYFGYTLh1aavQhaA3j6w.png"/></div></div></figure><p id="63f0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在我们得到了我们想要的输出。但是我们仍然有一个问题，我们需要捕捉任何错误，也可能在承诺完成时打印一些东西。</p><p id="d4ad" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一个解决方案是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="ba65" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的代码中，我们看到我们复制代码来改变isLoading <em class="ng"> </em>并打印它。更好的解决方案是使用try-catch语句并用finally()处理isLoading，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc mo l"/></div></figure></div></div>    
</body>
</html>