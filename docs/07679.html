<html>
<head>
<title>Commonly Used Sorting Algorithms for Better Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于更好编程的常用排序算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/commonly-used-sorting-algorithms-for-better-programming-a3667af12e50?source=collection_archive---------10-----------------------#2021-03-04">https://levelup.gitconnected.com/commonly-used-sorting-algorithms-for-better-programming-a3667af12e50?source=collection_archive---------10-----------------------#2021-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/984fe919aaeb5f60dcf56cbb74ff7f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kvqDVF0bQDVoR1_S"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">索菲·埃尔维斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="bd7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">为什么对算法的深刻理解如此重要？因为当我们为一个问题编写解决方案时，我们必须在短时间内实现最高效、最可靠、最快速的代码。如果我们没有很好地掌握算法，那么我们将会在代码中挣扎。</strong></p><p id="6193" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将讨论两种常用的减少时间复杂度的排序算法技术。</p><ol class=""><li id="6a52" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">快速排序</li><li id="fa54" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">气泡排序</li></ol></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="76e5" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">1.快速排序</h1><p id="2cc1" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">这是一个非常高效的算法，对于最坏的情况使用O(n log n)的时间复杂度，对于一般情况使用n的时间复杂度。这是基于将数据数组划分成更小的数组。</p><ul class=""><li id="523c" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld nd ll lm ln bi translated">大数组分为两个数组，一个保存比特定值大的值，另一个保存比特定值小的值。<em class="le">(具体数值有个专门的名字叫'</em><strong class="ki iu"><em class="le">pivot</em></strong><em class="le">')</em></li><li id="483f" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld nd ll lm ln bi translated">分离大数组后，递归调用子数组两次进行排序。</li></ul><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/8da18dda4c8a059b6325ae5e7345537a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/0*yMjQ94V_YL2rrKo9.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">礼貌:<a class="ae kf" href="https://www.techiedelight.com/quicksort/" rel="noopener ugc nofollow" target="_blank">www.techiedelight.com</a></figcaption></figure><p id="faf0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">pivot值将数组分为两部分。递归地，我们为每个子列表寻找支点，直到所有列表只包含一个元素。</p><h1 id="34f4" class="ma mb it bd mc md nj mf mg mh nk mj mk ml nl mn mo mp nm mr ms mt nn mv mw mx bi translated">透视算法:</h1><pre class="nf ng nh ni gt no np nq nr aw ns bi"><span id="0b04" class="nt mb it np b gy nu nv l nw nx"><strong class="np iu">Step 1</strong> − Choose the highest index value has pivot<br/><strong class="np iu">Step 2</strong> − Take two variables to point left and right of the list excluding pivot<br/><strong class="np iu">Step 3</strong> − left points to the low index<br/><strong class="np iu">Step 4</strong> − right points to the high<br/><strong class="np iu">Step 5</strong> − while value at left is less than pivot move right<br/><strong class="np iu">Step 6</strong> − while value at right is grater than pivot move left<br/><strong class="np iu">Step 7</strong> − if both step 5 and step 6 does not match swap left and right<br/><strong class="np iu">Step 8</strong> − if left ≥ right, the point where they met is new pivot</span></pre><p id="2596" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">递归使用pivot算法后，我们必须按照下面的算法对每个分区进行快速排序。</p><h1 id="cf5a" class="ma mb it bd mc md nj mf mg mh nk mj mk ml nl mn mo mp nm mr ms mt nn mv mw mx bi translated">快速排序算法</h1><pre class="nf ng nh ni gt no np nq nr aw ns bi"><span id="1ee6" class="nt mb it np b gy nu nv l nw nx"><strong class="np iu">Step 1</strong> − Make the right-most index value pivot<br/><strong class="np iu">Step 2</strong> − partition the array using pivot value<br/><strong class="np iu">Step 3</strong> − quicksort left partition recursively<br/><strong class="np iu">Step 4</strong> − quicksort right partition recursively</span></pre><h1 id="605a" class="ma mb it bd mc md nj mf mg mh nk mj mk ml nl mn mo mp nm mr ms mt nn mv mw mx bi translated">使用java编写代码</h1><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3cb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快速排序在大型数据集中非常有效。虽然有些难以理解，但在程序中使用这种算法是非常有效的。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="e313" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">2.气泡排序</h1><p id="99cc" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">对于较小的数据集，这种算法比快速排序更容易。这是基于数组中相邻元素的比较，如果它们没有按顺序排列，就进行交换。这对于较大的数据集是无效的，因为平均和最坏情况的时间复杂度都是O(n ),其中n是项目的数量。</p><figure class="nf ng nh ni gt ju gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/5f64936f3160e1d4c0bc9f8deae103a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/0*gGE0v26Eq_kjjPKn.jpeg"/></div></figure><h1 id="fc03" class="ma mb it bd mc md nj mf mg mh nk mj mk ml nl mn mo mp nm mr ms mt nn mv mw mx bi translated">算法</h1><pre class="nf ng nh ni gt no np nq nr aw ns bi"><span id="0f8b" class="nt mb it np b gy nu nv l nw nx"><strong class="np iu">Step 1 - </strong>Start with the first element of the array, compare the   current element with the next element.<br/><strong class="np iu">Step 2 -</strong>If the current element is greater than the next element of the array, swap them.<strong class="np iu"><br/>Step 1 -</strong>If the current element is less than the next element, move to the next element. <strong class="np iu">Repeat Step 1</strong>.</span></pre><h1 id="3f02" class="ma mb it bd mc md nj mf mg mh nk mj mk ml nl mn mo mp nm mr ms mt nn mv mw mx bi translated">使用java代码</h1><figure class="nf ng nh ni gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3c82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管冒泡排序是一种简单得多的算法，但它不适合较大的数据集。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><p id="22c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这有助于您更好地了解这些排序算法。我期待着在未来分享更多的文章。🎊</p><p id="c55e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意安全伙计们🙌</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><p id="098d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">参考文献</strong></p><p id="b0df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.tutorialspoint.com/" rel="noopener ugc nofollow" target="_blank">www.tutorialspoint.com</a></p><p id="8f91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://www.geeksforgeeks.org/" rel="noopener ugc nofollow" target="_blank">www.geeksforgeeks.org</a></p></div></div>    
</body>
</html>