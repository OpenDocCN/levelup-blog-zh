<html>
<head>
<title>Data fetching in React and Next.js with useSWR to impress your friends at parties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React和Next.js中的数据获取使用SWR在聚会上给朋友留下深刻印象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/data-fetching-in-react-and-next-js-with-useswr-to-impress-your-friends-at-parties-ec2db732ca6b?source=collection_archive---------1-----------------------#2020-06-30">https://levelup.gitconnected.com/data-fetching-in-react-and-next-js-with-useswr-to-impress-your-friends-at-parties-ec2db732ca6b?source=collection_archive---------1-----------------------#2020-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/80c006f9e7cbb93b2a195987f72512cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L0ywyewGFwZCtuBh"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">弗兰基·查马基在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0e19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di">我们</span>都同意:在<a class="ae kc" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a> app中取数据的方法有很多种。正因为如此，参加聚会的人不容易被你的组件有数据这一事实所打动。因此，我们最好开始讨论一些方法来改善用户体验，渲染时间，并可能在此过程中节省一些API请求。</p><p id="9a2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将讨论:</p><ol class=""><li id="931e" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">客户端数据提取。</li><li id="bdaf" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated"><code class="fe ly lz ma mb b">useWR</code>的好处、用例以及方法。</li><li id="d61d" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">下一次用<code class="fe ly lz ma mb b">getInitialProps</code>取数据</li><li id="722c" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">接下来<code class="fe ly lz ma mb b">getServerSideProps</code>的好处和坏处。</li><li id="aaec" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">下一个<code class="fe ly lz ma mb b">getStaticProps</code></li></ol></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="43cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">但首先要做的是——在Next.js之前，在React中我们使用了<code class="fe ly lz ma mb b">fetch</code>、<code class="fe ly lz ma mb b">axios</code>或类似的库来发出API请求。这允许我们跟踪加载或错误状态，获取数据，然后保存到组件的状态、redux存储或上下文中。这种方法简单明了，效果很好，但也有缺点。</strong></p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/a26e6bcc044e1b6e0c543aec858420d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtCa2RdT7olmbJ70U5O7Xw.png"/></div></div></figure><p id="88e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用户每次导航到页面，页面都没有准备好；应用程序发出一个API请求，用户查看装载微调器等待数据。与任何React应用程序一样，页面是空的，直到JavaScript在客户端运行并创建HTML。这对SEO不好；这使得页面的索引更加困难，因为没有页面，只有JS来创建页面。</p><p id="5462" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设应用程序维护一些项目列表，如待办事项或星舰。在等待更新的同时，用稍微旧一点的数据呈现页面，用户体验会好得多。一旦有新数据从服务器传来，页面就会更新。</p><p id="50b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这正是<code class="fe ly lz ma mb b"><a class="ae kc" href="https://swr.now.sh/" rel="noopener ugc nofollow" target="_blank">useSWR</a></code> <a class="ae kc" href="https://swr.now.sh/" rel="noopener ugc nofollow" target="_blank"> hook背后的想法，</a>来自为我们带来Next.js的同一个优秀团队。然后，继续呈现页面，同时在后台向服务器请求新数据。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/08094abdb521aa9dc269ec5426a1aeb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qk2BU6ZWHaG9g9x4yWQXig.png"/></div></div></figure><p id="5863" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个基本用例的一个小变化:第一个参数有两个目的。首先，它将被用作useSWR维护其缓存的键；其次，它将被传递给一个fetcher函数。我们可以传递给fetcher函数的不仅仅是一个URL。通常我们可能需要其他东西—例如，身份验证令牌或查询参数。</p><p id="6aac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于是后端不可知的，useSWR要求我们传递给它一个fetcher函数；它可以是任何返回承诺的函数。这也能很好地工作。</p><pre class="mk ml mm mn gt mp mb mq mr aw ms bi"><span id="e9dd" class="mt mu iq mb b gy mv mw l mx my">async function promiseFetcher() {</span><span id="42f4" class="mt mu iq mb b gy mz mw l mx my">return Promise.resolve({name: 'Heisenberg'})</span><span id="7dfd" class="mt mu iq mb b gy mz mw l mx my">}</span></pre><p id="10a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过传递一个适当的fetcher函数和一个GraphQL查询(作为第一个参数)来使用SWR和graphQL。</p><p id="8819" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">SWR是一座伟大的图书馆，它让复杂的事情变得简单。它允许我们删除或避免自己编写全部代码。它维护外部缓存，当调用发生时，SWR首先通过键检查缓存(<code class="fe ly lz ma mb b">useSWR</code>的第一个参数)以立即获取数据；然后，它对服务器进行重新验证，以确保我们拥有最新的数据。useSWR附带了许多很酷的功能，例如标签焦点跟踪、间隔重取、重复数据删除间隔、节流、错误跟踪和许多其他功能。</p><p id="f0e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">请注意，</strong>即使我们只是在谈论React应用程序和客户端获取，为了获得这里讨论的好处，仍然值得花时间去了解useSWR。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h2 id="e595" class="mt mu iq bd na nb nc dn nd ne nf dp ng ko nh ni nj ks nk nl nm kw nn no np nq bi translated">一些使用我们的功能</h2><p id="f030" class="pw-post-body-paragraph kd ke iq kf b kg nr ki kj kk ns km kn ko nt kq kr ks nu ku kv kw nv ky kz la ij bi translated">在每个组件中一遍又一遍地传递fetcher函数和其他可能的选项会变得重复。因此，useSWR带有全局配置组件。它的工作原理类似于对上下文的反应。我们所需要的就是将我们的应用程序包装在<code class="fe ly lz ma mb b">SWRConfig</code>中，并传递给它一个包含所有所需选项的对象。之后，useSWR hook只需要第一个参数—密钥。如有必要，我们可以根据个人使用情况覆盖这些设置。</p><pre class="mk ml mm mn gt mp mb mq mr aw ms bi"><span id="b1a7" class="mt mu iq mb b gy mv mw l mx my">&lt;SWRConfig</span><span id="2534" class="mt mu iq mb b gy mz mw l mx my">    value={{</span><span id="e1e7" class="mt mu iq mb b gy mz mw l mx my">        fetcher: fetcherFunc,</span><span id="2499" class="mt mu iq mb b gy mz mw l mx my">        dedupingInterval: 1000,</span><span id="1bb3" class="mt mu iq mb b gy mz mw l mx my">        onSuccess: onSuccessFunc,</span><span id="6a67" class="mt mu iq mb b gy mz mw l mx my">        refreshInterval: 1000,</span><span id="4524" class="mt mu iq mb b gy mz mw l mx my">        revalidateOnFocus: false</span><span id="c57b" class="mt mu iq mb b gy mz mw l mx my">}}</span><span id="4d41" class="mt mu iq mb b gy mz mw l mx my">&gt;</span><span id="9cd8" class="mt mu iq mb b gy mz mw l mx my">    &lt;Component {...pageProps} /&gt;</span><span id="670c" class="mt mu iq mb b gy mz mw l mx my">&lt;/SWRConfig&gt;</span></pre><p id="09d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">useSWR最大的威力来自缓存和缓存管理。我们可以直接在缓存中存储和更新数据，而不是获取数据并将其存储在状态中。这就是变异和触发函数发挥作用的地方。有两种方法可以得到它们:我们可以直接从<code class="fe ly lz ma mb b">swr</code>包中导入或者从单个<code class="fe ly lz ma mb b">useSWR</code>钩子中导入。在第一种情况下，我们每次都需要提供一个密钥；在后者中，函数将被“绑定”到返回它们的useSWR的键上。</p><pre class="mk ml mm mn gt mp mb mq mr aw ms bi"><span id="e43d" class="mt mu iq mb b gy mv mw l mx my">import useSWR, { mutate, trigger } from 'swr';</span><span id="ee0f" class="mt mu iq mb b gy mz mw l mx my">OR</span><span id="6153" class="mt mu iq mb b gy mz mw l mx my">const {data: robotData, mutate: mutateRobot, trigger: triggerRobot } = useSWR(key, fetcher, { initialData });</span></pre><p id="2c96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你从名字中可以猜到的，<code class="fe ly lz ma mb b">mutate</code>用于直接改变所提供的键的缓存，这将导致UI的立即改变，并允许我们构建一个乐观的UI。<code class="fe ly lz ma mb b">trigger</code>用于数据的重新验证(重新获取)。useSWR不允许我们发送POST请求，因此，如果我们需要添加一个新元素，比如一个to-do，典型的流程如下所示。</p><pre class="mk ml mm mn gt mp mb mq mr aw ms bi"><span id="c061" class="mt mu iq mb b gy mv mw l mx my">await mutate(key, {...data, todo: newTodo});<br/>await fetch(key, {method: 'POST',body: JSON.stringify({ todo: newTodo })})</span></pre><p id="c1de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，SWR将立即更新用户界面。然后，<code class="fe ly lz ma mb b">fetch</code>将向服务器发送数据，SWR将使用新请求自动重新验证数据。如果我们想推迟重新验证并在以后手动触发它，我们可以将一个<code class="fe ly lz ma mb b">false</code>作为第三个参数传递给<code class="fe ly lz ma mb b">mutate</code>，并在需要时使用<code class="fe ly lz ma mb b">trigger</code>。</p><pre class="mk ml mm mn gt mp mb mq mr aw ms bi"><span id="e046" class="mt mu iq mb b gy mv mw l mx my">mutate(key, {...data, todo: newTodo}, false);<br/>await fetch(key, {method: 'POST',body: JSON.stringify({ todo: newTodo })});<br/>// ... some other actions<br/>trigger(key)</span></pre><p id="bfad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们甚至可以使用当前缓存的数据，并通过向<code class="fe ly lz ma mb b">mutate</code>传递一个函数来更新它，如下所示:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/7b8d172fd4ca4abc94966fe1acd147e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7kpZHW80LU3UP71EYQrJuw.png"/></div></div></figure><p id="f03a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们使用服务器的响应来更新我们的缓存。虽然这种方法通常允许很大的灵活性，但我认为这个特殊的例子可能不是最好的方法。使用该示例的方法，我们可以保存一个潜在的API请求，代价是由于网络故障或服务器错误而与服务器失去同步。这就是为什么“改变UI -&gt;获取‘POST’-&gt;触发”这三个步骤对我来说是更好的选择。</p><p id="3946" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">请注意，</strong>由于缓存<code class="fe ly lz ma mb b">data</code>很容易获得，并且有<code class="fe ly lz ma mb b">mutate</code>和<code class="fe ly lz ma mb b">trigger</code>函数供我们使用，我们很可能在大多数时候不需要React.useState来保存和操作我们的数据。</p><p id="ceaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe ly lz ma mb b">mutate</code>的另一个有趣的用例是数据预取。简而言之，我们甚至可以在用户导航到特定页面之前就开始加载数据——比如说，当用户将鼠标悬停在指向所需页面的链接上时。这可以很容易地给我们额外的200毫秒-400毫秒的加载时间。查看Sergio Xalambrí的文章中的<a class="ae kc" href="https://sergiodxa.com/articles/next-swr-prefetch/" rel="noopener ugc nofollow" target="_blank">以获得有关数据预取的示例和更多详细信息。</a></p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h2 id="9cd5" class="mt mu iq bd na nb nc dn nd ne nf dp ng ko nh ni nj ks nk nl nm kw nn no np nq bi translated">Next.js的更多选项</h2><p id="d129" class="pw-post-body-paragraph kd ke iq kf b kg nr ki kj kk ns km kn ko nt kq kr ks nu ku kv kw nv ky kz la ij bi translated">我们在React中所能做的就是在运行时从客户端获取数据，但是使用Next.js会变得更有趣，它允许在服务器或客户端以及在构建或请求时运行代码<em class="nw">。在Next.js中，我们应该始终以静态生成的页面为目标，只有在别无选择的情况下，我们才能实现服务器端呈现的页面。静态页面超快有两个主要原因。它们是在构建时生成的，可以被CDN缓存。这意味着我们的页面很可能来自同一个城市或者潜在用户所在的街道，而不是来自同一个大陆。</em></p><p id="48fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本节中，我们将讨论Next.js的关键异步函数<code class="fe ly lz ma mb b">getInitialProps</code>、<code class="fe ly lz ma mb b">getStaticProps</code>、<code class="fe ly lz ma mb b">getServerSideProps</code>、客户端数据获取，以及所有这些如何与<code class="fe ly lz ma mb b">useSWR</code>相结合。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h2 id="aa02" class="mt mu iq bd na nb nc dn nd ne nf dp ng ko nh ni nj ks nk nl nm kw nn no np nq bi translated"><a class="ae kc" href="https://nextjs.org/docs/api-reference/data-fetching/getInitialProps" rel="noopener ugc nofollow" target="_blank"> getInitialProps </a></h2><p id="21e9" class="pw-post-body-paragraph kd ke iq kf b kg nr ki kj kk ns km kn ko nt kq kr ks nu ku kv kw nv ky kz la ij bi translated"><code class="fe ly lz ma mb b">getInitialProps</code>从这份名单中脱颖而出，那就让它滚蛋吧。如果你有Next.js及更高版本，不建议使用<em class="nw">。<code class="fe ly lz ma mb b">getInitialProps</code>将禁用<a class="ae kc" href="https://nextjs.org/docs/advanced-features/automatic-static-optimization" rel="noopener ugc nofollow" target="_blank">自动静态优化</a>并启用<a class="ae kc" href="https://nextjs.org/docs/basic-features/pages#server-side-rendering" rel="noopener ugc nofollow" target="_blank">服务器端渲染</a>。这个函数有一个棘手的行为。根据Next.js文档:</em></p><blockquote class="nx ny nz"><p id="0fce" class="kd ke nw kf b kg kh ki kj kk kl km kn oa kp kq kr ob kt ku kv oc kx ky kz la ij bi translated">对于初始页面加载，<code class="fe ly lz ma mb b">getInitialProps</code>将只在服务器上运行。当通过<code class="fe ly lz ma mb b"><a class="ae kc" href="https://nextjs.org/docs/api-reference/next/link" rel="noopener ugc nofollow" target="_blank">next/link</a></code>组件或使用<code class="fe ly lz ma mb b"><a class="ae kc" href="https://nextjs.org/docs/api-reference/next/router" rel="noopener ugc nofollow" target="_blank">next/router</a></code>导航到不同的路线时，<code class="fe ly lz ma mb b">getInitialProps</code>将在客户端上运行。</p></blockquote><p id="0807" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着，如果用户通过直接链接导航到页面，例如浏览器自动建议的链接，这将导致getInitialProps在服务器上运行，而不是在客户端上运行。因此，我们应该不断地意识到这一点，并仔细选择我们放在那里的代码。我们并不经常有一段代码到处运行，所以不要忘记从像<code class="fe ly lz ma mb b">isomorphic-unfetch</code>这样的包中导入<code class="fe ly lz ma mb b">fetch</code>，否则你将无法在服务器上找到它。如果您console.log了什么东西，一定要查看正确的控制台。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/95c3246085db0cee79951b09963092e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vFUs72Q2cTNFghh-E4_IKA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">getInitialProps的要点是进行初始数据填充。</figcaption></figure><p id="271b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对SEO有好处，因为它从一开始就让页面充满了实际内容。此外，它关闭了很酷的优化部分，总而言之，有时调用比我们需要的更多。那么，我们能有更精细的控制吗？</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h2 id="4d49" class="mt mu iq bd na nb nc dn nd ne nf dp ng ko nh ni nj ks nk nl nm kw nn no np nq bi translated"><a class="ae kc" href="https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering" rel="noopener ugc nofollow" target="_blank"> getServerSideProps </a></h2><p id="3c3d" class="pw-post-body-paragraph kd ke iq kf b kg nr ki kj kk ns km kn ko nt kq kr ks nu ku kv kw nv ky kz la ij bi translated">如果你用的是Next.js 9.3及以上版本，那么答案是肯定的！我们肯定可以。</p><p id="8266" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有<code class="fe ly lz ma mb b">getServerSideProps</code>把页面从静态生成变成服务器端呈现。这意味着这个函数将在每个请求时被调用<em class="nw">，然后结果将被服务器用来在运行时呈现一个HTML。之后，页面将被发送到客户端。实际上，Next.js将第一次只计算整个页面一次；之后，如果用户导航到带有<code class="fe ly lz ma mb b">next/link</code>或<code class="fe ly lz ma mb b">next/router</code>的页面，getServerSideProps将被调用——其结果将作为JSON发送到客户端并用于更新页面。</em></p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/cf07ef97779ef8dc223273118a527561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N94-DsNo8ESSAhZ1VI-Oxg.png"/></div></div></figure><p id="07c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意<code class="fe ly lz ma mb b">getServerSideProps</code>和<code class="fe ly lz ma mb b">getStaticProps</code>的几件事</strong>:</p><ol class=""><li id="f152" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la lp lq lr ls bi translated">我们需要导出一个异步函数，而不是将其定义为页面对象属性。</li><li id="ae28" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">此功能只允许在页面上使用，不能用于单个组件。</li><li id="e22a" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la lp lq lr ls bi translated">返回对象的形状与<code class="fe ly lz ma mb b">getInitialProps</code>相比略有不同。</li></ol><pre class="mk ml mm mn gt mp mb mq mr aw ms bi"><span id="fcd9" class="mt mu iq mb b gy mv mw l mx my">// getServerSideProps and getStaticProps return<br/>return {<br/>   props: {<br/>     stars: 33, <br/>     upVotes: 54, <br/>     type: 'repo'<br/>   }<br/>}</span><span id="f0c2" class="mt mu iq mb b gy mz mw l mx my">// getInitialProps return<br/>return {<br/>     stars: 33, <br/>     upVotes: 54, <br/>     type: 'repo'<br/>   }</span></pre><p id="3457" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与静态页面相比，使用服务器端渲染会更慢，因为页面不能被CDN缓存，但预渲染的页面将始终是最新的。第一字节时间(TTFB)将比<code class="fe ly lz ma mb b">getStaticProp</code>慢，因为服务器必须计算每个请求的结果，如果没有额外的配置，CDN无法缓存结果。</p><p id="a61c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">加上SWR，这将是我们最有活力的选择。该页面将在请求时间从服务器获得最新数据，之后将保持最新状态，SWR更新选项卡焦点重新获得，间隔或任何其他我们想要的用户交互。这种类型的页面将包含最新的数据，而不管用户如何导航到它。</p><p id="3d0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，<code class="fe ly lz ma mb b">getServerSideProps</code>与<code class="fe ly lz ma mb b">getStaticProps</code>相似。不同之处在于<code class="fe ly lz ma mb b">getServerSideProps</code>在每次请求时运行，而不是在构建时运行。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h2 id="75c6" class="mt mu iq bd na nb nc dn nd ne nf dp ng ko nh ni nj ks nk nl nm kw nn no np nq bi translated"><a class="ae kc" href="https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation" rel="noopener ugc nofollow" target="_blank"> getStaticProps </a></h2><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/de902dff3dd812496a8ae4b4afb5ddb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8QgLPHpMih3SDw3B9Cysfg.png"/></div></div></figure><p id="96f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们想象一个场景:我们有一个页面，显示标签/类别列表；我们希望用户能够订阅这些标签来过滤播放列表。在这种情况下，标签和与其相关联的播放列表都是动态的，并且依赖于外部数据。</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/10e1c1afb3d03a5d5d65d89cf909f3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fm1p86XDh9kzeiHgKFmiqQ.png"/></div></div></figure><p id="e010" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，可能的标签列表不会像仪表板统计数据、instagram赞或股票交易平台上的图表那样频繁变化。因此，我们可以说我们在用户请求之前就知道了可能的标签<em class="nw">。可能的标签列表可以公开缓存(不是特定于用户的),页面将快速加载，因为HTML和JSON都将在构建时生成，而CDN可以缓存它们。之后，我们使用SWR来确保页面的交互性和最新的内容，就像我们之前讨论的一样。</em></p><p id="3a2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你的网站内容不断变化，比如博客、产品网站、电子商务、营销网站、帮助和文档网站，这种情况也很好，因为网站无论如何都会重新构建新的内容。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="8a1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至此，我们完成了一个完整的循环，回到了客户端数据获取。有了Next.js，使用getStaticProps真的没有坏处。一点陈旧或不完整的数据仍然可以更好地理解页面内容，而不是没有数据。我能想到的下一步退回到仅客户端数据获取的唯一原因是<em class="nw">，如果数据是用户特定的或私有的，并且SEO是不相关的</em>。用户配置文件和仪表板是一个很好的用例。</p><p id="a111" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是这样工作的:</p><blockquote class="nx ny nz"><p id="5e4b" class="kd ke nw kf b kg kh ki kj kk kl km kn oa kp kq kr ob kt ku kv oc kx ky kz la ij bi translated">首先，立即显示没有数据的页面。可以使用静态生成预先呈现页面的各个部分。您可以显示缺失数据的加载状态。与等待服务器首先加载数据，然后计算并发送页面相比，用户将更快地看到页面的加载状态。这种策略更适合细节经常更新的仪表板，而不是内容丰富但更新频率较低的页面。然后，在客户端获取数据，并在准备就绪时显示出来。</p></blockquote></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="f1f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上总结了我在React和Next中获取数据的一些方法和用例。在本文中，我们讨论了:</p><ul class=""><li id="ff41" class="lk ll iq kf b kg kh kk kl ko lm ks ln kw lo la oe lq lr ls bi translated">useSWR以及它如何通过使网站速度更快、内容更丰富、互动性更强来改善SEO和用户体验</li><li id="5934" class="lk ll iq kf b kg lt kk lu ko lv ks lw kw lx la oe lq lr ls bi translated">使用Next.js异步方法预取数据的利弊</li></ul><p id="fec6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读，我希望这篇文章扩展了您对Next.js应用程序中数据获取选项的理解。</p><p id="ed7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继续向用户提供出色的体验和快乐的编码！</p></div></div>    
</body>
</html>