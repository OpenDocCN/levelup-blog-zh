<html>
<head>
<title>Unit Test SQL in Golang, Without Mocking, Using Docker (Go, Postgres, Docker)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker (Go，Postgres，Docker)在Golang中单元测试SQL，没有嘲讽</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-test-sql-in-golang-without-mocking-using-docker-go-postgres-docker-50e99b9d38a7?source=collection_archive---------0-----------------------#2020-12-07">https://levelup.gitconnected.com/unit-test-sql-in-golang-without-mocking-using-docker-go-postgres-docker-50e99b9d38a7?source=collection_archive---------0-----------------------#2020-12-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/49c71a8c5a0315f91225bec5684fc064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RBrfYO9wbJ6Qkn2mJhtcPw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片来自测试专家(https://tinyurl.com/y2k27j33<strong class="bd kf">)</strong></figcaption></figure><blockquote class="kg kh ki"><p id="e9c7" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km iu">更新</strong>:我已经用TestContainers写了一篇配套文章，基于一个评论说我应该研究一下那个包。它实现了同样的目标，测试数据库代码而没有模仿。可以在这里阅读:<a class="ae li" href="https://atkinsonbg.medium.com/unit-test-sql-in-golang-without-mocking-using-testcontainers-go-postgres-docker-4f61574b1989" rel="noopener">https://atkinsonbg . medium . com/unit-test-SQL-in-golang-without-mocking-using-test containers-go-postgres-docker-4f 61574 b 1989</a></p></blockquote><p id="8e8f" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">最近，在开发一个与数据库接口的API时，我错误地将我们的ORM包更新到了最新版本。代码编译得很好，所有测试都顺利通过。然而，在现实中，最新版本的软件包带来了突破性的变化，这是非常微妙的。我的代码以前工作得很好，现在可以很好地连接数据库，没有任何问题地运行它的查询，但是总是返回一个空的数据集！这个问题直到代码被推送到QA时才被发现，在QA中很快就发现有问题。这是一个很难捕捉的问题，因为没有抛出错误，只是没有返回数据。</p><p id="860d" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">那么这个问题是如何通过测试的呢？像大多数Go工程师一样，我们模拟了所有用于单元测试的数据库代码和交互。在这个特定的场景中，我们的模拟不需要为更新的包而改变，所以一切都很好，直到我们遇到一个真正的数据库。这让我知道了如何在真实的数据库上运行我的测试，并完全消除对模拟的需求。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="6f53" class="lt lu it bd kf lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">为什么要去掉仿制品，它们很棒？！</h1><p id="0445" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lj ms kx ky lk mt lb lc ll mu lf lg lh im bi translated">首先，我想说，我并不主张完全摆脱模仿。它们绝对在测试中占有一席之地，并且在很多事情上派上用场。对我来说，对于你无法控制的资源，模仿是至关重要的。例如，以Twilio这样的服务为例。如果您需要调用Twilio并处理来自它们的API的响应，这是一个很好的例子，说明了模仿的重要性。您无法控制它们的API，您只是简单地发出一个调用并处理响应。通常，如果您在CI/CD管道中运行，您可能无法进行这些调用，也可能不只是想进行这些调用。这里模仿是完美的，因为您并不真正关心对API的调用，只是为了确保您的代码能够处理响应。</p><p id="f1c8" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">说到在Golang代码中嘲笑数据库交互，老实说，在我看来这是一次悲惨的经历。通常，您最终会为这些代码编写大量的接口，然后可以在您的测试中模拟出来。您的测试以大量样板代码和跨多个文件重复的SQL查询而告终。有一些软件包可以帮助解决这个问题，甚至消除了对接口的需求，但是你仍然要写很多样板代码，现在需要训练人们如何使用另一个软件包。以下是一些例子:</p><ul class=""><li id="985a" class="mv mw it km b kn ko kr ks lj mx lk my ll mz lh na nb nc nd bi translated"><a class="ae li" href="https://medium.com/easyread/unit-test-sql-in-golang-5af19075e68e" rel="noopener">https://medium . com/easy read/unit-test-SQL-in-golang-5af 19075 e68e</a></li><li id="d534" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">【https://dev.to/pieohpah/mocking-database-in-go-55bo T4】</li><li id="6fc5" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated"><a class="ae li" href="https://github.com/DATA-DOG/go-sqlmock" rel="noopener ugc nofollow" target="_blank">https://github.com/DATA-DOG/go-sqlmock</a></li></ul><p id="6d0b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">我想要的是在真实的数据库上运行我的测试，完全消除对模拟的需求。目标是提供以下内容:</p><ul class=""><li id="1492" class="mv mw it km b kn ko kr ks lj mx lk my ll mz lh na nb nc nd bi translated">编写没有接口、没有模仿、没有附加包的常规测试</li><li id="8966" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">针对实际数据库进行测试，该数据库应用了最新的模式并植入了测试数据</li><li id="012d" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">不仅要测试我的数据库代码，还要测试任何公开该数据的API处理程序</li><li id="7477" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">使它通用于任何GitHub repo，以用于其单元测试</li><li id="21e5" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">能够在真实的CI/CD管道中使用该流程</li></ul><p id="631d" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">这篇文章将涵盖我提出的解决方案。虽然这不是一个完美的解决方案，但它确实符合我的所有要求。我将不断调整这个解决方案，以平滑边缘，因为我认为它在我的个人和专业工作中有很大的潜力。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="4a68" class="lt lu it bd kf lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">设置</h1><p id="3e6c" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lj ms kx ky lk mt lb lc ll mu lf lg lh im bi translated">我创建了一个非常简单的<a class="ae li" href="https://github.com/atkinsonbg/go-gmux-unit-testing" rel="noopener ugc nofollow" target="_blank"> Go API </a>，它可以处理包含时区信息的数据库。这里没有什么过于复杂的，只有两个get和一个POST用于插入。数据库同样简单，一个存储了时区信息的表。让我们先来看看数据库的表模式。我有一个非常简单的<code class="fe nj nk nl nm b">./scripts/init.sql</code>脚本，它创建了一个表并用一些数据作为种子:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="e06e" class="nv lu it nm b gy nw nx l ny nz">-- SCHEMA</span><span id="157b" class="nv lu it nm b gy oa nx l ny nz">CREATE TABLE timezones</span><span id="285f" class="nv lu it nm b gy oa nx l ny nz">(</span><span id="ce4c" class="nv lu it nm b gy oa nx l ny nz">id serial PRIMARY KEY,</span><span id="b9d4" class="nv lu it nm b gy oa nx l ny nz">created timestamptz DEFAULT now() NOT NULL,</span><span id="071c" class="nv lu it nm b gy oa nx l ny nz">modified timestamptz DEFAULT now() NOT NULL,</span><span id="76cb" class="nv lu it nm b gy oa nx l ny nz">name text NOT NULL,</span><span id="1834" class="nv lu it nm b gy oa nx l ny nz">timeoffset smallint NOT NULL,</span><span id="99cd" class="nv lu it nm b gy oa nx l ny nz">identifier text NOT NULL</span><span id="bad9" class="nv lu it nm b gy oa nx l ny nz">);</span><span id="e4c3" class="nv lu it nm b gy oa nx l ny nz">-- SEED</span><span id="7290" class="nv lu it nm b gy oa nx l ny nz">INSERT INTO timezones</span><span id="3a58" class="nv lu it nm b gy oa nx l ny nz">(id, name, timeoffset, identifier)</span><span id="376d" class="nv lu it nm b gy oa nx l ny nz">VALUES</span><span id="2eb2" class="nv lu it nm b gy oa nx l ny nz">(1, 'eastern', '-5', 'est');</span><span id="8e08" class="nv lu it nm b gy oa nx l ny nz">INSERT INTO timezones</span><span id="6996" class="nv lu it nm b gy oa nx l ny nz">(id, name, timeoffset, identifier)</span><span id="8805" class="nv lu it nm b gy oa nx l ny nz">VALUES</span><span id="b9f8" class="nv lu it nm b gy oa nx l ny nz">(2, 'central', '-6', 'cst');</span><span id="fc18" class="nv lu it nm b gy oa nx l ny nz">INSERT INTO timezones</span><span id="f9b2" class="nv lu it nm b gy oa nx l ny nz">(id, name, timeoffset, identifier)</span><span id="0460" class="nv lu it nm b gy oa nx l ny nz">VALUES</span><span id="924e" class="nv lu it nm b gy oa nx l ny nz">(3, 'mountain', '-7', 'mst');</span><span id="a0d8" class="nv lu it nm b gy oa nx l ny nz">INSERT INTO timezones</span><span id="4447" class="nv lu it nm b gy oa nx l ny nz">(id, name, timeoffset, identifier)</span><span id="c9a9" class="nv lu it nm b gy oa nx l ny nz">VALUES</span><span id="f399" class="nv lu it nm b gy oa nx l ny nz">(4, 'pacific', '-8', 'pst');</span><span id="dc43" class="nv lu it nm b gy oa nx l ny nz">INSERT INTO timezones</span><span id="c3c7" class="nv lu it nm b gy oa nx l ny nz">(id, name, timeoffset, identifier)</span><span id="76d2" class="nv lu it nm b gy oa nx l ny nz">VALUES</span><span id="daa6" class="nv lu it nm b gy oa nx l ny nz">(5, 'alaska', '-9', 'ast');</span><span id="0903" class="nv lu it nm b gy oa nx l ny nz">ALTER SEQUENCE timezones_id_seq RESTART WITH 6;</span></pre><p id="0fa4" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">在我的Go API中，我在我的<code class="fe nj nk nl nm b">main.go</code>文件中定义了四条路线:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="5ca1" class="nv lu it nm b gy nw nx l ny nz">func main() { <br/>  database.InitDB() </span><span id="a5fb" class="nv lu it nm b gy oa nx l ny nz">  r := mux.NewRouter()          </span><span id="fde4" class="nv lu it nm b gy oa nx l ny nz">  r.HandleFunc("/healthcheck", handlers.HealthHandler).Methods("GET") </span><span id="ce20" class="nv lu it nm b gy oa nx l ny nz">  r.HandleFunc("/timezones", handlers.ListTimezonesHandler).Methods("GET") </span><span id="a78c" class="nv lu it nm b gy oa nx l ny nz">  r.HandleFunc("/timezones/{identifier}", handlers.GetTimezoneHandler).Methods("GET") </span><span id="afb7" class="nv lu it nm b gy oa nx l ny nz">  r.HandleFunc("/timezones", handlers.InsertTimezoneHandler).Methods("POST") </span><span id="ec52" class="nv lu it nm b gy oa nx l ny nz">  log.Fatal(http.ListenAndServe(":80", r))<br/>}</span></pre><p id="67e5" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">让我们快速分析一下这些路由，以了解数据库交互的水平设置:</p><ul class=""><li id="e838" class="mv mw it km b kn ko kr ks lj mx lk my ll mz lh na nb nc nd bi translated">/healthcheck:简单的健康检查，以确保我的容器正在运行</li><li id="15e3" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">/timezones: GET返回数据库中的所有时区</li><li id="a736" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">/timezones/{identifier}: GET根据标识符从数据库中返回单个时区。在这种情况下:东部时间、中部时间、太平洋标准时间等。</li><li id="6156" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">/timezones: POST以插入新时区</li></ul><p id="7628" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">我将我的处理程序和数据库代码分开，以便于测试，这就是你对这样一个简单实现的期望。</p><p id="62cd" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated"><strong class="km iu">处理程序(时区获取)</strong></p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="012a" class="nv lu it nm b gy nw nx l ny nz">// ListTimezonesHandler lists all the timezones in the databasefunc ListTimezonesHandler(w http.ResponseWriter, r *http.Request) <br/>{ <br/>  timezones, err := database.GetAllTimezones() <br/>  if err != nil {  <br/>      w.WriteHeader(http.StatusInternalServerError)  <br/>      return <br/>  }  <br/>  results, _ := json.Marshal(timezones)  <br/>  w.WriteHeader(http.StatusOK) <br/>  w.Write(results)<br/>}</span></pre><p id="cf65" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated"><strong class="km iu">数据库(时区获取)</strong></p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="281f" class="nv lu it nm b gy nw nx l ny nz">// GetAllTimezones returns all timezones from the DB</span><span id="1449" class="nv lu it nm b gy oa nx l ny nz">func GetAllTimezones() ([]Timezone, error) {</span><span id="a06d" class="nv lu it nm b gy oa nx l ny nz">  rows, err := db.Query("SELECT * FROM timezones")</span><span id="ad5a" class="nv lu it nm b gy oa nx l ny nz">  if err != nil {</span><span id="53ae" class="nv lu it nm b gy oa nx l ny nz">    log.Fatal(err)</span><span id="3f7e" class="nv lu it nm b gy oa nx l ny nz">    return nil, err</span><span id="5b4a" class="nv lu it nm b gy oa nx l ny nz">  }</span><span id="7820" class="nv lu it nm b gy oa nx l ny nz">  var timezones []Timezone</span><span id="59b8" class="nv lu it nm b gy oa nx l ny nz">  defer rows.Close()</span><span id="2d03" class="nv lu it nm b gy oa nx l ny nz">  for rows.Next() {</span><span id="7445" class="nv lu it nm b gy oa nx l ny nz">    var timezone Timezone</span><span id="19c0" class="nv lu it nm b gy oa nx l ny nz">    err := rows.Scan(&amp;timezone.ID, &amp;timezone.Created,        &amp;timezone.Modified, &amp;timezone.Name, &amp;timezone.Timeoffset, &amp;timezone.Identifier)</span><span id="50e0" class="nv lu it nm b gy oa nx l ny nz">    if err != nil {</span><span id="3af5" class="nv lu it nm b gy oa nx l ny nz">      log.Print(err)</span><span id="cf68" class="nv lu it nm b gy oa nx l ny nz">    }</span><span id="64a0" class="nv lu it nm b gy oa nx l ny nz">    timezones = append(timezones, timezone)</span><span id="5f5e" class="nv lu it nm b gy oa nx l ny nz">  }</span><span id="c7b1" class="nv lu it nm b gy oa nx l ny nz">  return timezones, nil</span><span id="4b29" class="nv lu it nm b gy oa nx l ny nz">}</span></pre><p id="9dd4" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">在本地运行时，我通过Docker Compose将所有这些连接起来，这样我就可以将我的API和本地Postgres容器一起运行，并通过Postman调用轻松测试我的代码:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="d886" class="nv lu it nm b gy nw nx l ny nz">version: "3.7"</span><span id="c50a" class="nv lu it nm b gy oa nx l ny nz">services:</span><span id="3823" class="nv lu it nm b gy oa nx l ny nz">  api:</span><span id="d084" class="nv lu it nm b gy oa nx l ny nz">    container_name: go-mux-api</span><span id="4ec7" class="nv lu it nm b gy oa nx l ny nz">    image: <br/>      github.com/atkinsonbg/go-gmux-proper-unit-testing/api:latest</span><span id="b640" class="nv lu it nm b gy oa nx l ny nz">    environment:</span><span id="b4e4" class="nv lu it nm b gy oa nx l ny nz">      DBHOST: go-mux-db</span><span id="7cb9" class="nv lu it nm b gy oa nx l ny nz">      DBNAME: go-mux-db</span><span id="b0ec" class="nv lu it nm b gy oa nx l ny nz">      DBUSER: postgres</span><span id="6fd6" class="nv lu it nm b gy oa nx l ny nz">    ports:</span><span id="9f22" class="nv lu it nm b gy oa nx l ny nz">      - 80:80</span><span id="d6be" class="nv lu it nm b gy oa nx l ny nz">  database:</span><span id="e70c" class="nv lu it nm b gy oa nx l ny nz">    container_name: go-mux-db</span><span id="0eaf" class="nv lu it nm b gy oa nx l ny nz">    image: postgres:11.6-alpine</span><span id="6274" class="nv lu it nm b gy oa nx l ny nz">    environment:</span><span id="04c1" class="nv lu it nm b gy oa nx l ny nz">      POSTGRES_DB: go-mux-db</span><span id="54eb" class="nv lu it nm b gy oa nx l ny nz">      volumes:</span><span id="043b" class="nv lu it nm b gy oa nx l ny nz">        - ./scripts/init.sql:/docker-entrypoint-initdb.d/init.sql</span><span id="f20d" class="nv lu it nm b gy oa nx l ny nz">      ports:</span><span id="12dc" class="nv lu it nm b gy oa nx l ny nz">        - 5432:5432</span></pre><p id="3058" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">Docker Compose在这种情况下非常有用，因为我可以快速旋转一个配置为满足我的需求的DB，将其拆下，然后再旋转回来。如果我需要更复杂的测试，我总是可以分别启动数据库和API，并使用<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/debugging-go-inside-docker-using-visual-studio-code-and-remote-containers-5c3724fe87b9">远程容器</a>进行测试。Docker在这里是一个救星，因为它对于我的测试用例非常灵活。更重要的是，当我们用真实的数据库进行测试时。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="d33b" class="lt lu it bd kf lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">测试</h1><p id="9f06" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lj ms kx ky lk mt lb lc ll mu lf lg lh im bi translated">正如我之前所说的，我不想嘲笑我的测试。同样，我也不想引入任何外部包。我想针对我的数据库代码和处理程序编写普通的Golang测试。下面的代码展示了它的样子。</p><p id="9d75" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated"><strong class="km iu">处理程序测试(时区获取)</strong></p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="86d4" class="nv lu it nm b gy nw nx l ny nz">func TestListTimezonesHandler(t *testing.T) {</span><span id="202a" class="nv lu it nm b gy oa nx l ny nz">  req, err := http.NewRequest("GET", "/timezones", nil)</span><span id="4ac6" class="nv lu it nm b gy oa nx l ny nz">  if err != nil {</span><span id="7ad9" class="nv lu it nm b gy oa nx l ny nz">    t.Fatal(err)</span><span id="3b05" class="nv lu it nm b gy oa nx l ny nz">  }</span><span id="114d" class="nv lu it nm b gy oa nx l ny nz">  rr := httptest.NewRecorder()</span><span id="fd4a" class="nv lu it nm b gy oa nx l ny nz">  handler := http.HandlerFunc(ListTimezonesHandler)</span><span id="0fe0" class="nv lu it nm b gy oa nx l ny nz">  handler.ServeHTTP(rr, req)</span><span id="8ba4" class="nv lu it nm b gy oa nx l ny nz">  if rr.Code != http.StatusOK {</span><span id="04c2" class="nv lu it nm b gy oa nx l ny nz">    t.Errorf("handler returned wrong status code: got %v want %v",</span><span id="8319" class="nv lu it nm b gy oa nx l ny nz">    rr.Code, http.StatusOK)</span><span id="f3be" class="nv lu it nm b gy oa nx l ny nz">  }</span><span id="863e" class="nv lu it nm b gy oa nx l ny nz">  var timezones []db.Timezone</span><span id="10a6" class="nv lu it nm b gy oa nx l ny nz">  err = json.NewDecoder(rr.Body).Decode(&amp;timezones)</span><span id="a3ae" class="nv lu it nm b gy oa nx l ny nz">  if err != nil {</span><span id="02be" class="nv lu it nm b gy oa nx l ny nz">    t.Error(err.Error())</span><span id="95ba" class="nv lu it nm b gy oa nx l ny nz">    t.Error("Error retreiving list of timezones.")</span><span id="68d1" class="nv lu it nm b gy oa nx l ny nz">  }</span><span id="008d" class="nv lu it nm b gy oa nx l ny nz">  if len(timezones) == 0 {</span><span id="38e9" class="nv lu it nm b gy oa nx l ny nz">    t.Error("Error retreiving list of timezones.")</span><span id="dae6" class="nv lu it nm b gy oa nx l ny nz">  }</span><span id="8b69" class="nv lu it nm b gy oa nx l ny nz">}</span></pre><p id="dd4b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">这段代码利用了Go中的<code class="fe nj nk nl nm b"><a class="ae li" href="https://golang.org/pkg/net/http/httptest/" rel="noopener ugc nofollow" target="_blank">net/http/httptest</a></code>包，它允许我从测试中轻松地调用我的API端点。</p><p id="1300" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated"><strong class="km iu">数据库测试(时区获取)</strong></p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="d3f4" class="nv lu it nm b gy nw nx l ny nz">func TestGetAllTimezones(t *testing.T) {</span><span id="14c5" class="nv lu it nm b gy oa nx l ny nz">  tzones, err := GetAllTimezones()</span><span id="5e6c" class="nv lu it nm b gy oa nx l ny nz">  if err != nil {</span><span id="9b0c" class="nv lu it nm b gy oa nx l ny nz">    t.Error("Get All Timezones failed.")</span><span id="d0f3" class="nv lu it nm b gy oa nx l ny nz">  }</span><span id="cefd" class="nv lu it nm b gy oa nx l ny nz">  if len(tzones) == 0 {</span><span id="4e96" class="nv lu it nm b gy oa nx l ny nz">    t.Error("Timezones did not return any values.")</span><span id="2b4a" class="nv lu it nm b gy oa nx l ny nz">  }</span><span id="fb47" class="nv lu it nm b gy oa nx l ny nz">}</span></pre><p id="049c" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">在这一点上，你可以看到，我没有使用任何模拟，也没有特殊的软件包。这是我所能得到的最普通的测试代码，非常棒。它简明扼要。任何曾经编写过Go代码的人都可以阅读这段代码并理解它在做什么。没什么特别的，只是测试一下。然而，在博客文章的这一点上，如果你简单地发出一个<code class="fe nj nk nl nm b">go test</code>命令，这个测试将绝对100%失败。这个测试试图访问一个正在运行的数据库，但它还没有。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="9a8f" class="lt lu it bd kf lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">测试数据库</h1><p id="d301" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lj ms kx ky lk mt lb lc ll mu lf lg lh im bi translated">我们已经看到Docker Compose在我们的API旁边运行了一个测试数据库。它超级简单，非常管用。然而，Compose并不能帮助我实现我的最终目标。不过，我肯定可以使用Compose来实现这一点。我可以创建一个特殊的组合文件来旋转这两个容器，并简单地从API容器中运行我的测试命令。假设我的代码复制正确，这将是好的。然而，我想要一个可以在其中运行测试的通用容器，所以Compose被淘汰了。</p><p id="8751" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">我最终采用的解决方案有两个要求:</p><ul class=""><li id="0069" class="mv mw it km b kn ko kr ks lj mx lk my ll mz lh na nb nc nd bi translated">一个Postgres基础Docker镜像，已经安装了Go，加上一些不那么秘密的sauce代码来启动一切</li><li id="0d77" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">一些必要的文件和目录结构在您的回购，使这一切工作。</li></ul><p id="1671" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">让我们从探索代码运行所需的目录结构开始。这没什么大不了的，但仍然至关重要。不管你如何构建你的代码，docker文件会假设两件事:</p><ul class=""><li id="4988" class="mv mw it km b kn ko kr ks lj mx lk my ll mz lh na nb nc nd bi translated">首先，有一个名为<code class="fe nj nk nl nm b">scripts</code>的根级目录，它将包含以下内容:</li><li id="cd7c" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">-创建和播种数据库所需的所有SQL脚本</li><li id="0abc" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">-一个名为<code class="fe nj nk nl nm b">docker-test-commands.sh</code>的shell脚本，它包含了您想要运行来测试您的应用程序的所有定制代码。最终，这个脚本将控制数据库的创建、模式的创建和表的播种。它也负责启动你的<code class="fe nj nk nl nm b">go test</code>命令。它是测试应用程序所需的一切的核心。</li><li id="b6ff" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">我们还需要已经创建了测试结果文件，在我们的例子中，它的<code class="fe nj nk nl nm b">cover.out</code>的原因是，我们需要在Docker中挂载一个卷来获取测试结果。我不想挂载到一个目录，而是一个文件，因为这是我唯一关心的。如果这个文件不存在，那么Docker会在挂载时创建一个名为<code class="fe nj nk nl nm b">/cover.out</code>的新目录，这显然不是我们想要的。</li></ul><p id="81bb" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">该结构看起来像这样:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="e45e" class="nv lu it nm b gy nw nx l ny nz">/scripts<br/>    init.sql<br/>    docker-test-commands.sh<br/>cover.out<br/>go.mod<br/>go.sum<br/>main.go</span></pre><p id="9ea9" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">上面我们已经看到了我的<code class="fe nj nk nl nm b">init.sql</code>的样子。现在让我们看看我的<code class="fe nj nk nl nm b">docker-test-commands.sh</code>文件中有什么:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="3610" class="nv lu it nm b gy nw nx l ny nz">#!/bin/bash</span><span id="a19a" class="nv lu it nm b gy oa nx l ny nz">set -e</span><span id="b7c2" class="nv lu it nm b gy oa nx l ny nz">echo "Printing environment variables:"</span><span id="180a" class="nv lu it nm b gy oa nx l ny nz">echo "DB USER: ${DBUSER}"</span><span id="c26c" class="nv lu it nm b gy oa nx l ny nz">echo "DB NAME: ${DBNAME}"</span><span id="38e0" class="nv lu it nm b gy oa nx l ny nz">echo "DB HOST: ${DBHOST}"</span><span id="37f7" class="nv lu it nm b gy oa nx l ny nz">echo "POSTGRES USER: ${POSTGRESUSER}"</span><span id="3834" class="nv lu it nm b gy oa nx l ny nz">echo "Done printing environment variables:"</span><span id="8bbb" class="nv lu it nm b gy oa nx l ny nz">echo "Wait for Postgres to start"</span><span id="117b" class="nv lu it nm b gy oa nx l ny nz">until pg_isready -h ${DBHOST} -p 5432 -U ${POSTGRESUSER}</span><span id="f817" class="nv lu it nm b gy oa nx l ny nz">  do</span><span id="7ee6" class="nv lu it nm b gy oa nx l ny nz">  echo "Waiting for postgres to start at ${DBHOST}..."</span><span id="1b75" class="nv lu it nm b gy oa nx l ny nz">  sleep 2;</span><span id="90c7" class="nv lu it nm b gy oa nx l ny nz">done</span><span id="ca3a" class="nv lu it nm b gy oa nx l ny nz">echo "Postgres has started"</span><span id="ae12" class="nv lu it nm b gy oa nx l ny nz">echo "Setting up the Postgres user"</span><span id="f609" class="nv lu it nm b gy oa nx l ny nz">POSTGRES="psql --username ${POSTGRESUSER}"</span><span id="9c56" class="nv lu it nm b gy oa nx l ny nz">echo "Creating database: ${DBNAME}"</span><span id="8840" class="nv lu it nm b gy oa nx l ny nz">$POSTGRES &lt;&lt;EOSQL</span><span id="71c9" class="nv lu it nm b gy oa nx l ny nz">CREATE DATABASE "${DBNAME}" OWNER ${POSTGRESUSER};</span><span id="ac69" class="nv lu it nm b gy oa nx l ny nz">EOSQL</span><span id="6c69" class="nv lu it nm b gy oa nx l ny nz">echo "Initializing database..."</span><span id="2176" class="nv lu it nm b gy oa nx l ny nz">psql -d ${DBNAME} -a -U${POSTGRESUSER} -f ./scripts/init.sql &amp;</span><span id="a740" class="nv lu it nm b gy oa nx l ny nz">SQL_PID=$!</span><span id="c134" class="nv lu it nm b gy oa nx l ny nz">wait $SQL_PID</span><span id="8a27" class="nv lu it nm b gy oa nx l ny nz">echo "Finished initializing database"</span><span id="850e" class="nv lu it nm b gy oa nx l ny nz">echo "Running Go Tests"</span><span id="48dc" class="nv lu it nm b gy oa nx l ny nz">go test -v ./... -coverpkg ./... -coverprofile cover.out &amp;</span><span id="d01c" class="nv lu it nm b gy oa nx l ny nz">GO_PID=$!</span><span id="25d5" class="nv lu it nm b gy oa nx l ny nz">wait $GO_PID</span><span id="c434" class="nv lu it nm b gy oa nx l ny nz">echo "Finished with go tests"</span></pre><p id="805e" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">让我们解开这个脚本:</p><ul class=""><li id="cf12" class="mv mw it km b kn ko kr ks lj mx lk my ll mz lh na nb nc nd bi translated">首先，我们进行健全性检查，并打印出存在的环境变量。如果您喜欢覆盖内置变量，这很方便。</li><li id="c4a5" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">接下来，我们等待Postgres完全初始化，然后再做其他事情。在尝试创建表并对其运行测试之前，我们需要确保一切都已启动并运行。</li><li id="e333" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">一旦Postgres准备就绪，我们就设置我们的Postgres用户并创建我们的数据库。</li><li id="e8c2" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">接下来，我们运行我们的init脚本来创建这个表，并为它植入数据。我们将它作为后台进程运行，并捕获进程ID，等待它完成后再继续。这样做的原因是，在发出任何测试命令之前，我们需要等待SQL命令运行。</li><li id="53a7" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">最后，我们运行我们的<code class="fe nj nk nl nm b">go test</code>命令，将结果输出到将在Docker run命令期间挂载的<code class="fe nj nk nl nm b">cover.out</code>文件。</li></ul><p id="762f" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">这个文件做了很多工作，但是你应该已经看到了你对测试的控制。如果你需要一些非标准的Postgres用户或配置，你可以在这里做。需要运行Flyway迁移，没问题，在这里发出命令。假设您的迁移在另一个GitHub repo中，不用担心，从这里克隆它，并运行它们。这是一个非常灵活的入口点。</p><p id="5a22" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">现在让我们看看docker文件:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="2b6e" class="nv lu it nm b gy nw nx l ny nz">FROM postgres:11.6-alpine</span><span id="9c84" class="nv lu it nm b gy oa nx l ny nz">RUN apk add --no-cache git make musl-dev go busybox-suid</span><span id="f27c" class="nv lu it nm b gy oa nx l ny nz"># Set environment variables for the database</span><span id="3f19" class="nv lu it nm b gy oa nx l ny nz">ENV POSTGRESUSER postgres</span><span id="2336" class="nv lu it nm b gy oa nx l ny nz">ENV DBUSER postgres</span><span id="ae27" class="nv lu it nm b gy oa nx l ny nz">ENV DBNAME testdb</span><span id="bf5d" class="nv lu it nm b gy oa nx l ny nz">ENV DBHOST localhost</span><span id="ab8d" class="nv lu it nm b gy oa nx l ny nz"># Configure Go</span><span id="12ce" class="nv lu it nm b gy oa nx l ny nz">ENV GOROOT /usr/lib/go</span><span id="25cf" class="nv lu it nm b gy oa nx l ny nz">ENV GOPATH /go</span><span id="6203" class="nv lu it nm b gy oa nx l ny nz">ENV PATH /go/bin:$PATH</span><span id="c219" class="nv lu it nm b gy oa nx l ny nz">RUN mkdir -p ${GOPATH}/src ${GOPATH}/bin</span><span id="1d22" class="nv lu it nm b gy oa nx l ny nz"># Give postgres user full access to Go path, needed to install dependencies</span><span id="096a" class="nv lu it nm b gy oa nx l ny nz">RUN chown -R postgres /go</span><span id="8374" class="nv lu it nm b gy oa nx l ny nz"># Create a workdir, this is needed to properly install Go dependencies</span><span id="023e" class="nv lu it nm b gy oa nx l ny nz"># chown on the postgres user so it can clone the repo here</span><span id="9e0d" class="nv lu it nm b gy oa nx l ny nz">WORKDIR testdir</span><span id="855c" class="nv lu it nm b gy oa nx l ny nz">RUN chown -R postgres /testdir</span><span id="7f8b" class="nv lu it nm b gy oa nx l ny nz">RUN mkdir /tmpdir</span><span id="7f4f" class="nv lu it nm b gy oa nx l ny nz"># used for local testing ONLY</span><span id="4f27" class="nv lu it nm b gy oa nx l ny nz"># COPY . .</span><span id="3198" class="nv lu it nm b gy oa nx l ny nz"># create the entrypoint db script</span><span id="358b" class="nv lu it nm b gy oa nx l ny nz">RUN echo -e "\</span><span id="ac52" class="nv lu it nm b gy oa nx l ny nz">#!/bin/bash \n \</span><span id="2952" class="nv lu it nm b gy oa nx l ny nz">git clone \${GIT_URL} ../testdir/tmpdir/ \n \</span><span id="7462" class="nv lu it nm b gy oa nx l ny nz">cp -R ../testdir/tmpdir/* ../testdir/ \n \</span><span id="e9d4" class="nv lu it nm b gy oa nx l ny nz">/bin/sh ../testdir/scripts/docker-test-commands.sh &amp; \n \</span><span id="6257" class="nv lu it nm b gy oa nx l ny nz">COMMANDS_PID=\$! \n \</span><span id="a6b6" class="nv lu it nm b gy oa nx l ny nz">(while kill -0 \$COMMANDS_PID; do sleep 1; done) &amp;&amp; pg_ctl stop &amp; \</span><span id="a86a" class="nv lu it nm b gy oa nx l ny nz">" &gt;&gt; /docker-entrypoint-initdb.d/entrypoint.sh</span><span id="0e07" class="nv lu it nm b gy oa nx l ny nz"># chmod the entrypoint db script</span><span id="1d90" class="nv lu it nm b gy oa nx l ny nz">RUN chmod +x /docker-entrypoint-initdb.d/entrypoint.sh</span></pre><p id="dbb2" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">这里有很多东西要打开，所以让我们把它放下来:</p><ul class=""><li id="98c6" class="mv mw it km b kn ko kr ks lj mx lk my ll mz lh na nb nc nd bi translated">首先，我们将我们的图像基于Postgres Alpine图像。我们从Postgres开始，因为他们的形象是野兽！不是不好，只是有很多，所以从这里开始安装Go比反过来更容易。</li><li id="ce88" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">接下来，我们安装一些我们需要的依赖项，其中之一是Go。我们需要Git来运行并稍后克隆我们的repo，所以我们在这方面做得很好。</li><li id="9699" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">我们为数据库配置了一些环境变量。这里的目标是为数据库名称、用户等嵌入变量，如果您愿意，可以覆盖这些变量。然而，由于这是一个测试容器，意味着可以快速地创建和销毁，所以让它们保持原样可能更容易，谁在乎呢。</li><li id="e4e2" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">接下来，我们用标准设置配置Go，这里没有什么疯狂的。</li><li id="220d" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">然后我们必须给<code class="fe nj nk nl nm b">postgres</code>用户对<code class="fe nj nk nl nm b">/go</code>目录的所有权。当Postgres容器启动时，这是用户发出的所有命令。我们将运行一个<code class="fe nj nk nl nm b">go test</code>命令，该命令需要安装依赖项，因此<code class="fe nj nk nl nm b">postgres</code>用户在这里需要权限。</li><li id="3785" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">接下来，我们创建一个WORKDIR，因为我的代码使用Go Mods，我需要在GOPATH之外才能工作。我们也给了<code class="fe nj nk nl nm b">postgres</code>用户这个文件夹的所有权，因为这是我们的测试命令所在的地方，通常你想要写测试结果，代码覆盖率等等。</li><li id="7578" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">我们在工作目录下创建了一个<code class="fe nj nk nl nm b">tmpdir</code>,稍后用于Git克隆命令。</li><li id="a75a" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">我们有一个被注释掉的复制命令。稍后我会详细解释这一点。</li><li id="961c" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">现在我们来看容器启动时将被执行的文件，它是运行测试的“入口点”。我们运行一个ECHO命令，将所有内容传输到一个新文件<code class="fe nj nk nl nm b">/docker-entrypoint-initdb.d/entrypoint.sh</code>中，如果您不熟悉Postgres容器，有一个名为<code class="fe nj nk nl nm b">docker-entrypoint-initdb.d</code>的特殊文件夹，您可以在其中放置容器启动时自动运行的脚本。让我们来分析一下这个脚本的内容:</li><li id="f016" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">-首先我们<code class="fe nj nk nl nm b">git clone</code>通过<code class="fe nj nk nl nm b">GIT_URL</code>变量设置的回购。我们克隆到<code class="fe nj nk nl nm b">tmpdir</code>中，然后发出<code class="fe nj nk nl nm b">cp</code>命令，将所有内容复制到上一级。这样做有特定的原因，因为<code class="fe nj nk nl nm b">/testdir</code>不会为空。我们需要提前安装我们的测试输出文件，它就在这个目录中。Git不允许克隆到包含文件的目录中。简单的解决方法是复制下一层，然后复制上一层。</li><li id="c93c" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">-接下来，我们从上面发出运行<code class="fe nj nk nl nm b">docker-test-commands.sh</code>文件的命令。此时，我们已经将我们的repo克隆到了<code class="fe nj nk nl nm b">/testdir</code>中，这样，我们的代码、SQL脚本和命令就在这里，可以开始运行了。</li><li id="15d4" class="mv mw it km b kn ne kr nf lj ng lk nh ll ni lh na nb nc nd bi translated">-我们在后台运行这个脚本并捕获它的进程id。接下来，我们循环并等待它结束，最后调用<code class="fe nj nk nl nm b">pg_ctrl stop</code>来停止Postgres并杀死容器。这很关键，因为我们需要知道何时停止容器，否则，它将永远运行下去。</li></ul><p id="e9e4" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">我承认，这里发生了很多事。在这一点上，你可能在想，“我本可以现在就把它嘲笑出来！”你并没有完全错，但是，你也将回到工作与模拟，而不是一个真正的数据库。在这一点上，我们可以看到这个Dockerfile是通用的，只需向它传递一个GitHub repo，它就会提取它并启动您的shell脚本。一个shell脚本，你可以控制它，并且可以放入任何你想要的东西。现在，您有了一个针对真实数据库运行测试的可重复过程。让我们来看看实际情况。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="e8b9" class="lt lu it bd kf lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">运行容器</h1><p id="b41c" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lj ms kx ky lk mt lb lc ll mu lf lg lh im bi translated">在我的repo中，我有一个Makefile，它带有以下命令来启动这个容器:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="c566" class="nv lu it nm b gy nw nx l ny nz">docker run -v ${PWD}/cover.out:/testdir/cover.out -e GIT_URL='https://github.com/atkinsonbg/go-gmux-unit-testing.git' atkinsonbg/go-postgres-test:latest</span></pre><p id="6b1a" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">这会产生以下输出:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="1c32" class="nv lu it nm b gy nw nx l ny nz">...<br/>waiting for server to start....2020-12-06 20:03:58.674 UTC [35] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"<br/>2020-12-06 20:03:58.696 UTC [36] LOG:  database system was shut down at 2020-12-06 20:03:58 UTC<br/>2020-12-06 20:03:58.701 UTC [35] LOG:  database system is ready to accept connections<br/> done<br/>server started</span><span id="5f51" class="nv lu it nm b gy oa nx l ny nz">/usr/local/bin/docker-entrypoint.sh: running /docker-entrypoint-initdb.d/entrypoint.sh<br/>Cloning into '../testdir/tmpdir'...<br/>Printing environment variables:</span><span id="ebb6" class="nv lu it nm b gy oa nx l ny nz">DB USER: postgres<br/>DB NAME: testdb<br/>DB HOST: localhost<br/>POSTGRES USER: postgres<br/>Done printing environment variables:<br/>Wait for Postgres to start<br/>waiting for server to shut down....2020-12-06 20:03:59.076 UTC [35] LOG:  received fast shutdown request<br/>localhost:5432 - no response<br/>Waiting for postgres to start at localhost...<br/>2020-12-06 20:03:59.081 UTC [35] LOG:  aborting any active transactions<br/>2020-12-06 20:03:59.082 UTC [35] LOG:  background worker "logical replication launcher" (PID 42) exited with exit code 1<br/>2020-12-06 20:03:59.083 UTC [37] LOG:  shutting down<br/>2020-12-06 20:03:59.104 UTC [35] LOG:  database system is shut down<br/> done<br/>server stopped</span><span id="7543" class="nv lu it nm b gy oa nx l ny nz">PostgreSQL init process complete; ready for start up.</span><span id="b9d1" class="nv lu it nm b gy oa nx l ny nz">2020-12-06 20:03:59.192 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432<br/>2020-12-06 20:03:59.192 UTC [1] LOG:  listening on IPv6 address "::", port 5432<br/>2020-12-06 20:03:59.199 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"<br/>2020-12-06 20:03:59.221 UTC [62] LOG:  database system was shut down at 2020-12-06 20:03:59 UTC<br/>2020-12-06 20:03:59.227 UTC [1] LOG:  database system is ready to accept connections<br/>localhost:5432 - accepting connections<br/>Postgres has started<br/>Setting up the Postgres user<br/>Creating database: testdb<br/>CREATE DATABASE<br/>Initializing database...<br/>-- SCHEMA<br/>CREATE TABLE timezones<br/>(<br/>    id serial PRIMARY KEY,<br/>    created timestamptz DEFAULT now() NOT NULL,<br/>    modified timestamptz DEFAULT now() NOT NULL,<br/>    name text NOT NULL,<br/>    timeoffset smallint NOT NULL,<br/>    identifier text NOT NULL<br/>);<br/>CREATE TABLE<br/>-- SEED<br/>INSERT INTO timezones<br/>    (id, name, timeoffset, identifier)<br/>VALUES<br/>    (1, 'eastern', '-5', 'est');<br/>INSERT 0 1<br/>INSERT INTO timezones<br/>    (id, name, timeoffset, identifier)<br/>VALUES<br/>    (2, 'central', '-6', 'cst');<br/>INSERT 0 1<br/>INSERT INTO timezones<br/>    (id, name, timeoffset, identifier)<br/>VALUES<br/>    (3, 'mountain', '-7', 'mst');<br/>INSERT 0 1<br/>INSERT INTO timezones<br/>    (id, name, timeoffset, identifier)<br/>VALUES<br/>    (4, 'pacific', '-8', 'pst');<br/>INSERT 0 1<br/>INSERT INTO timezones<br/>    (id, name, timeoffset, identifier)<br/>VALUES<br/>    (5, 'alaska', '-9', 'ast');<br/>INSERT 0 1<br/>ALTER SEQUENCE timezones_id_seq RESTART WITH 6;<br/>ALTER SEQUENCE<br/>Finished initializing database<br/>Running Go Tests<br/>go: downloading github.com/kelseyhightower/envconfig v1.4.0<br/>go: downloading github.com/gorilla/mux v1.7.4<br/>go: downloading github.com/cenkalti/backoff/v4 v4.0.2<br/>go: downloading github.com/lib/pq v1.7.0<br/>go: extracting github.com/kelseyhightower/envconfig v1.4.0<br/>go: extracting github.com/cenkalti/backoff/v4 v4.0.2<br/>go: extracting github.com/gorilla/mux v1.7.4<br/>go: extracting github.com/lib/pq v1.7.0<br/>go: finding github.com/gorilla/mux v1.7.4<br/>go: finding github.com/cenkalti/backoff/v4 v4.0.2<br/>go: finding github.com/kelseyhightower/envconfig v1.4.0<br/>go: finding github.com/lib/pq v1.7.0<br/>?       github.com/atkinsonbg/go-gmux-proper-unit-testing       [no test files]<br/>2020/12/06 20:04:06 DB is ready!<br/>=== RUN   TestConfig<br/>--- PASS: TestConfig (0.00s)<br/>=== RUN   TestGetAllTimezones<br/>--- PASS: TestGetAllTimezones (0.00s)<br/>=== RUN   TestGetTimezone<br/>--- PASS: TestGetTimezone (0.00s)<br/>=== RUN   TestInsertTimezone<br/>--- PASS: TestInsertTimezone (0.00s)<br/>PASS<br/>coverage: 43.0% of statements in ./...<br/>ok      github.com/atkinsonbg/go-gmux-proper-unit-testing/database      0.019s  coverage: 43.0% of statements in ./...<br/>2020/12/06 20:04:06 DB is ready!<br/>=== RUN   TestHealthHandler<br/>--- PASS: TestHealthHandler (0.00s)<br/>=== RUN   TestListTimezonesHandler<br/>--- PASS: TestListTimezonesHandler (0.00s)<br/>=== RUN   TestGetTimezoneHandler<br/>--- PASS: TestGetTimezoneHandler (0.00s)<br/>=== RUN   TestInsertTimezoneHandler<br/>--- PASS: TestInsertTimezoneHandler (0.00s)<br/>PASS<br/>coverage: 65.8% of statements in ./...<br/>ok      github.com/atkinsonbg/go-gmux-proper-unit-testing/handlers      0.022s  coverage: 65.8% of statements in ./...<br/>Finished with go tests<br/>/docker-entrypoint-initdb.d/entrypoint.sh: line 6: kill: (55) - No such process<br/>waiting for server to shut down....2020-12-06 20:04:07.112 UTC [1] LOG:  received fast shutdown request<br/>2020-12-06 20:04:07.120 UTC [1] LOG:  aborting any active transactions<br/>2020-12-06 20:04:07.122 UTC [1] LOG:  background worker "logical replication launcher" (PID 68) exited with exit code 1<br/>2020-12-06 20:04:07.123 UTC [63] LOG:  shutting down<br/>2020-12-06 20:04:07.168 UTC [1] LOG:  database system is shut down</span></pre><p id="a188" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">瞧啊。现在，我已经成功地在一个运行的数据库上测试了我所有的API代码，并且我的<code class="fe nj nk nl nm b">cover.out</code>文件中填充了覆盖率指标！我现在有了一个通用的Postgres + Go容器，我可以在任何需要测试数据库代码的回购中使用它。没有嘲讽，也没有外包装。我正在测试实际的数据库交互代码以及一整套处理程序测试。</p><p id="166f" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">我现在也可以在运行CI/CD时使用它。大多数现代管道都允许您指定一个容器来运行您的测试，这个通用选项完全可以用于这个任务。</p><p id="de88" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated"><strong class="km iu">本地运行</strong></p><p id="7e5e" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">还记得在docker文件中，有一个复制命令被注释掉了。这样做的原因是，如果您愿意，可以轻松地在本地运行这个容器。您可能希望在代码被推送到GitHub之前对其进行测试。因此，您可以下拉docker文件，取消对<code class="fe nj nk nl nm b">COPY . .</code>行的注释，这样就可以在本地运行它了。您首先需要构建容器:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="63da" class="nv lu it nm b gy nw nx l ny nz">docker build -f Dockerfile.test -t atkinsonbg/go-postgres-test:local .</span></pre><p id="af2f" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">然后，您可以运行它:</p><pre class="nn no np nq gt nr nm ns nt aw nu bi"><span id="ea14" class="nv lu it nm b gy nw nx l ny nz">docker run -v ${PWD}/cover.out:/testdir/cover.out -e GIT_URL='' atkinsonbg/go-postgres-test:local</span></pre><p id="6e4f" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated">我们仍然传递<code class="fe nj nk nl nm b">GIT_URL</code>环境变量，但将其留空。因此，<code class="fe nj nk nl nm b">COPY</code>命令会将所有代码拉入，而<code class="fe nj nk nl nm b">git clone</code>会失败，这对于本地运行来说不是问题。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="d1a3" class="lt lu it bd kf lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">包扎</h1><p id="c4b0" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lj ms kx ky lk mt lb lc ll mu lf lg lh im bi translated">这篇文章中提出的解决方案并不适合所有人。在Go中模仿数据库代码有很多好处，但也有很多令人头疼的问题。由您甚至您的团队来决定测试代码的最佳方式。对我来说，我更喜欢一种类似于这里概述的方法，并用一个真实的数据库进行测试。与此同时，我在下面贴了GitHub repo和所有代码的链接，以及Docker Hub，在那里你可以找到一个预建的图像。尽情享受吧！</p><p id="f0d7" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated"><strong class="km iu">GitHub</strong>:【https://github.com/atkinsonbg/go-gmux-unit-testing T2】T3】</p><p id="d1ed" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lj kw kx ky lk la lb lc ll le lf lg lh im bi translated"><strong class="km iu">Docker Hub</strong>:<a class="ae li" href="https://hub.docker.com/repository/docker/atkinsonbg/go-postgres-test" rel="noopener ugc nofollow" target="_blank">https://Hub . Docker . com/repository/Docker/atkinsonbg/go-postgres-test</a></p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><figure class="nn no np nq gt ju gh gi paragraph-image"><a href="https://ko-fi.com/O5O63ENS7"><div class="gh gi ob"><img src="../Images/3515ab52cb6fb5e74c27c7a2e06d3811.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*5imNjCtY48Wh3owQyPv6Cw.png"/></div></a></figure></div></div>    
</body>
</html>