<html>
<head>
<title>Optimal Tree Splitting and Greedy Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最优树分裂和贪婪算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optimal-tree-splitting-and-greedy-algorithms-b66772d65e9a?source=collection_archive---------14-----------------------#2021-07-12">https://levelup.gitconnected.com/optimal-tree-splitting-and-greedy-algorithms-b66772d65e9a?source=collection_archive---------14-----------------------#2021-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/7362184fefd3891c0f9f951ccbf155bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZFFBSSRf8OrSbA_F"/></div></div></figure><div class=""/><p id="787e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章将解决一个最优分割一棵树的问题(或者从树上移除边)，并且将讨论贪婪算法如何简单地解决这个问题。整个解决方案适合大约40行代码。</p><p id="72e8" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">随意阅读一篇</em> <a class="ae la" href="https://cppcodingzen.com/?p=2450" rel="noopener ugc nofollow" target="_blank"> <em class="kz">几篇老帖子</em> </a> <em class="kz">阅读更多关于贪婪算法的内容。</em></p><h1 id="39fa" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">问题:</h1><p id="86e8" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">给你一个偶数节点的树。将父节点和子节点之间的每个连接视为一条“边”。您可能希望删除其中的一些边，这样剩下的断开连接的子树每个都有偶数个节点。</p><p id="efc3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，假设您的输入是下面的树:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7dde" class="mn lc je mj b gy mo mp l mq mr">  1 <br/> / \ <br/>2   3 <br/>   / \ <br/>  4   5 <br/>/ | \ <br/>6 7 8</span></pre><p id="a472" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，移除边(3，4)满足我们的要求。</p><p id="48de" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">编写一个函数，返回您可以移除的最大<em class="kz">边数，同时仍然满足此要求。</em></p><h1 id="3202" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解决方案:</h1><p id="1691" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">像许多涉及树木的问题一样，解决方案包括局部思考</p><ol class=""><li id="55f8" class="ms mt je kd b ke kf ki kj km mu kq mv ku mw ky mx my mz na bi translated">寻找在给定节点<em class="kz">及其所有子节点上执行的公共操作。</em></li><li id="fe55" class="ms mt je kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">以及组合对孩子的解决方案以形成问题的解决方案。</li></ol><p id="69c9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用整数的简单属性——特别是奇数整数和偶数整数来帮助我们开发这些局部解决方案。</p><ol class=""><li id="2203" class="ms mt je kd b ke kf ki kj km mu kq mv ku mw ky mx my mz na bi translated">两个奇数之和是偶数。</li><li id="b1d0" class="ms mt je kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">两个偶数之和是偶数</li><li id="8ebe" class="ms mt je kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">奇数和偶数之和是奇数。</li></ol><p id="0523" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这三个基本属性将如何帮助我们？</p><p id="d8bb" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">再来看一下问题陈述:给你一棵节点数为偶数的树。树的<em class="kz">根</em>算作一个节点。因此，<em class="kz">树中剩余节点总数为奇数！并且通过使用上面的属性(3 ),至少存在一个具有奇数个节点的根的子树。这个属性非常重要，我们将在下面重点介绍:</em></p><blockquote class="ng nh ni"><p id="ea12" class="kb kc kz kd b ke kf kg kh ki kj kk kl nj kn ko kp nk kr ks kt nl kv kw kx ky im bi translated">树中的节点数(根之外)是奇数。根的至少一个子树具有奇数个节点。</p></blockquote><p id="86c2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，这个属性如何帮助我们开发一个贪婪的算法？</p><p id="9df6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">再次考虑包含奇数个节点的子树——在我们的问题示例中，它是一个标记为“2”的单节点子树。我们能去掉连接这个子树和根的边吗？<strong class="kd jf"> <em class="kz">号</em> </strong>因为那会导致两个不相连的子树，都是奇数个节点。无论我们进一步做什么，我们都不会再从它们那里得到<em class="kz">甚至</em>数量的节点了！</p><p id="2abd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类似地，考虑包含<em class="kz">甚至</em>个节点的子树——在我们的问题示例中，它是一个以‘3’为根的六节点子树。我们能去掉连接这个子树和根的边吗？<strong class="kd jf"> <em class="kz">是的！</em> </strong>，而事实上，这个方案是最优的！(我们可以通过一个矛盾来证明:假设最优解不包含这条边，然后证明我们总是可以进一步去掉这条边，从而得出一个更好的解！).</p><p id="a219" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个局部属性为我们提供了一个简单的局部解决方案:</p><ol class=""><li id="0e63" class="ms mt je kd b ke kf ki kj km mu kq mv ku mw ky mx my mz na bi translated">迭代给定<em class="kz">节点的所有子节点。</em>持续<em class="kz">计数</em>要移除的边的总数。</li><li id="a8b0" class="ms mt je kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">如果一个子树有奇数个节点，什么都不做。</li><li id="2e44" class="ms mt je kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">如果子子树有偶数个节点，则count增加1。</li><li id="911b" class="ms mt je kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">最后，在每个<em class="kz">子节点</em>上递归调用相同的函数，递归更新<em class="kz">计数。</em></li></ol><p id="c60f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是算法的实现。让我们从一个简单的<em class="kz">节点的递归定义开始:</em></p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">用于表示树的节点的简单定义</figcaption></figure><p id="8615" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们从一个简单的递归助手方法开始，该方法计算<em class="kz">大小、</em>或以一个节点为根的子树中的节点数。请注意，我们使用了<em class="kz">记忆</em>将之前计算的值保存在哈希表中，以便于查找，并避免重复计算。</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">查找给定节点的子树大小(即子树中的节点数)的辅助方法</figcaption></figure><p id="0d10" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在准备开发递归方法，使用上面的递归函数和两个简单规则来计算给定节点的最大切割数:</p><ol class=""><li id="3dfa" class="ms mt je kd b ke kf ki kj km mu kq mv ku mw ky mx my mz na bi translated">对于节点的每个<em class="kz">子节点</em></li></ol><ul class=""><li id="fc32" class="ms mt je kd b ke kf ki kj km mu kq mv ku mw ky ns my mz na bi translated">递归计算孩子的最大切割数。姑且称之为<em class="kz"> max_cuts。</em></li><li id="4ccc" class="ms mt je kd b ke nb ki nc km nd kq ne ku nf ky ns my mz na bi translated">如果以该子树为根的子树有一个<em class="kz">偶数大小</em>，则给<em class="kz"> max_cuts </em>加1。</li></ul><ol class=""><li id="8382" class="ms mt je kd b ke kf ki kj km mu kq mv ku mw ky mx my mz na bi translated">将所有子节点的所有<em class="kz"> max_cut </em>值相加，计算出父节点的<em class="kz"> max_cut </em>值。</li></ol><p id="3503" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，我们将使用内存化来存储先前为一个节点计算的<em class="kz"> max_cut </em>。</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">基于记忆化的递归max_cuts实现</figcaption></figure><h1 id="6245" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">复杂性</h1><p id="1f8e" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">因为记忆化，</p><ol class=""><li id="9d39" class="ms mt je kd b ke kf ki kj km mu kq mv ku mw ky mx my mz na bi translated">我们恰好访问树的每个节点一次。为该节点获得的所有结果计数都被插入到哈希表中，并在O(1)时间内立即返回..</li><li id="0584" class="ms mt je kd b ke nb ki nc km nd kq ne ku nf ky mx my mz na bi translated">对于每个节点，我们执行恒定量的工作。</li></ol><p id="5de9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">结果，算法的总复杂度是O(N ),其中N是树的节点总数。</p><h1 id="e306" class="lb lc je bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试</h1><p id="f1be" class="pw-post-body-paragraph kb kc je kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">测试是这个问题中最有趣的部分之一。为了测试复杂的树结构，我们应该能够快速构建复杂的树。这里有一个使用节点大小的数组构建复杂树的简单方法。数组中的每个元素对应于树中的一个节点。数组中的元素表示该节点的子节点数。</p><p id="7aee" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，上面示例图中的根节点有两个子节点(分别标记为“2”和“3”)。因此，数组的第一个元素的值为2。一旦我们耗尽了根，我们就按顺序进入它的子节点。第一个孩子没有孩子，第二个孩子有两个孩子(分别标记为“4”和“5”)。因此，数组接下来的两个元素分别是0和2。完整的数组看起来像<code class="fe nt nu nv mj b">[2, 0, 2, 3, 0, 0, 0, 0]</code></p><p id="7b64" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个类似BFS的函数，它使用一个数组来构造树。</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">简单的助手功能来建立树。</figcaption></figure><p id="e991" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这个方便的助手函数，我们终于准备好使用<em class="kz"> GUnit测试</em>来测试几个简单的树案例了。</p><figure class="me mf mg mh gt iv"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">测试max_cuts的单元测试</figcaption></figure></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="fa2d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">原载于</em><a class="ae la" href="https://cppcodingzen.com/?p=3001" rel="noopener ugc nofollow" target="_blank"><em class="kz"/></a><em class="kz">。</em></p></div></div>    
</body>
</html>