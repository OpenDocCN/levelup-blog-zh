<html>
<head>
<title>JavaScript Problem Solvers: Minimum Subsequence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript问题解决程序:最小子序列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-problem-solvers-minimum-subsequence-71216e07dd2f?source=collection_archive---------3-----------------------#2020-08-30">https://levelup.gitconnected.com/javascript-problem-solvers-minimum-subsequence-71216e07dd2f?source=collection_archive---------3-----------------------#2020-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4872" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">案例013:你就这么整理？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6a65b32cb494da2d24516a370d075c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4qw5tvs1Pk8vyZjB5TA3Q.png"/></div></div></figure><p id="eb5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">子序列一直是一个让我有点困惑的概念。我不知道为什么。但是和任何事情一样，我花在后续工作上的时间越多，我就越能慢慢地学习和适应它们。</p><p id="4aff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论哪种方式，我们今天要解决的问题乍看起来可能很复杂，并将为我们的批判性思维技能提供一个很好的挑战(希望如此)。</p><p id="cd6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，让我们开始解决。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="cec1" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">问题是</h2><p id="47c6" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><a class="ae mv" href="https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">这里是LeetCode </strong> </a>上问题的链接</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="6663" class="lx ly it mx b gy nb nc l nd ne">Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence.</span><span id="7419" class="lx ly it mx b gy nf nc l nd ne">If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.</span><span id="d687" class="lx ly it mx b gy nf nc l nd ne">Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order.</span></pre></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="162f" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">制约因素</h2><p id="101a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">所提供的约束并没有真正产生任何值得注意的信息，但是像往常一样，让我们仔细检查每个约束，看看我们是否能发现任何解决方案的线索:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="920a" class="lx ly it mx b gy nb nc l nd ne">1 &lt;= nums.length &lt;= 500</span></pre><p id="c667" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个约束给了我们在<code class="fe ng nh ni mx b">nums</code>数组中应该期望的数字范围。有了<code class="fe ng nh ni mx b">1 &lt;= nums.length</code>的下限，我们就不用担心<code class="fe ng nh ni mx b">nums</code>是空的或者没有任何元素了。除了我们需要迭代的最大元素数量之外，<code class="fe ng nh ni mx b">nums.length &lt;= 500</code>的上限也没有给我们任何特殊的信息。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="1dbf" class="lx ly it mx b gy nb nc l nd ne">1 &lt;= nums[i] &lt;= 100</span></pre><p id="c995" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二个约束是<code class="fe ng nh ni mx b">nums</code>中元素的范围。我们了解到我们不必处理任何负数，或者如果<code class="fe ng nh ni mx b">nums</code>中的元素是0，因为<code class="fe ng nh ni mx b">nums</code>中元素的下限是<code class="fe ng nh ni mx b">1 &lt;= nums[i]</code>。有了<code class="fe ng nh ni mx b">nums[i] &lt;= 100</code>的上限，我们也不用担心什么真正大的数字了。相对来说，100的上限是相当小的。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="f7b9" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">测试</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="ce40" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">崩溃了</h2><p id="edac" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这个问题有很多小部分，如前所述，可能会使<code class="fe ng nh ni mx b">minSubsequences</code>看起来很复杂。但是，像往常一样，如果我们仔细阅读提供给我们的每一条信息，我认为我们可以简化和组织事情，使一切更容易理解:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="908d" class="lx ly it mx b gy nb nc l nd ne">Given the array nums</span></pre><p id="02eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的参数<code class="fe ng nh ni mx b">minSubsequences</code>总是一个数组，它的元素总是整数。很简单。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="4570" class="lx ly it mx b gy nb nc l nd ne">obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence.</span></pre><p id="a16b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是事情开始变得有点棘手的地方。</p><p id="aef7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我们的任务。我们需要在<code class="fe ng nh ni mx b">nums</code>中找到一组数字，如果我们将该组中的所有数字加在一起，总和将大于<code class="fe ng nh ni mx b">nums</code>中未包含在该组中的其余数字。</p><p id="0f8a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这告诉我的第一件事是，我们必须保存我们正在构建的子序列的运行总和，并从<code class="fe ng nh ni mx b">nums</code>中的元素总和中减去该运行总和。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="edab" class="lx ly it mx b gy nb nc l nd ne">If there are multiple solutions, return the subsequence with minimum size</span></pre><p id="82ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可能会有这样的场景，其中<code class="fe ng nh ni mx b">nums</code>将有多个不同大小的子序列。这可能意味着我们必须跟踪我们找到的每个子序列，并将每个子序列放入一个数组中以便进行比较。也就是说，如果我们想跟踪每个子序列。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="0c69" class="lx ly it mx b gy nb nc l nd ne">...if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements.</span></pre><p id="067f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这给了我一个惊人的线索。如果我们按照非降序(或者从低到高)对<code class="fe ng nh ni mx b">nums</code>进行排序，我们可以避免跟踪我们找到的每个子序列。然后我们可以从最后一个元素到第一个元素(或者向后)遍历排序后的<code class="fe ng nh ni mx b">nums</code>。</p><p id="a0ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将允许我们找到nums中任何子序列的最小大小和最大总和的子序列。</p><p id="ec09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果我们看一下测试用例1:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="95db" class="lx ly it mx b gy nb nc l nd ne">[4,3,10,9,8]</span></pre><p id="5456" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并以非递减顺序对测试用例#1进行排序:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="403c" class="lx ly it mx b gy nb nc l nd ne">[3,4,8,9,10]</span></pre><p id="cffa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以从最后一个元素10开始遍历<code class="fe ng nh ni mx b">nums</code>,并向后工作:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="c754" class="lx ly it mx b gy nb nc l nd ne">1st iteration:<br/>subsequence : [10]<br/>subsequence sum: 10<br/>nums sum: 34<br/>elements in nums not included in subsequence: [3,4,8,9]<br/>nums sum excluding subsequence sum: 24</span></pre><p id="adf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi">~</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="0d0e" class="lx ly it mx b gy nb nc l nd ne">2nd iteration:<br/>subsequence : [10, 9]<br/>subsequence sum: 19<br/>nums sum: 34<br/>elements in nums not included in subsequence: [3,4,8]<br/>nums sum excluding subsequence sum: 15</span></pre><p id="631f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第二次迭代中，我们已经找到了一个子序列，它的和大于<code class="fe ng nh ni mx b">nums</code> : <code class="fe ng nh ni mx b">[10, 9]</code>中其余元素的和</p><p id="1deb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们已经按非降序对<code class="fe ng nh ni mx b">nums</code>进行了排序，<code class="fe ng nh ni mx b">[10,9]</code>是这样一个子序列，当一个子序列的总和严格大于未包含元素的总和时，它的长度等于所有可能子序列的最小可能大小。我们知道这一点，因为任何其他子序列都需要至少2个元素。</p><p id="0132" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并且由于排序后的<code class="fe ng nh ni mx b">nums</code>数组是按非降序排序的，<code class="fe ng nh ni mx b">[10,9]</code>也是最小的子序列，当一个子序列的和严格大于未包含元素的和时，其和是所有可能子序列的最大和。</p><p id="d6cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有其他可能的子序列必须至少有2个元素，即使它们有，它们的总和也不可能大于<code class="fe ng nh ni mx b">[10,9]</code>，因为<code class="fe ng nh ni mx b">[10,9]</code>是<code class="fe ng nh ni mx b">nums</code>中最大的两个数字。</p><p id="9933" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想我们已经有所发现了。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="e591" class="lx ly it mx b gy nb nc l nd ne">A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.</span></pre><p id="2adb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我会忽略这条信息。这对于替代解决方案可能是有用的，但是对于我上面开始概述的潜在解决方案来说，它仍然是不相关的。请记住，这是我第一次传递提供给我们的信息。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="b8b5" class="lx ly it mx b gy nb nc l nd ne">Note that the solution with the given constraints is guaranteed to be unique.</span></pre><p id="973a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这告诉我，我们将永远只返回一个子序列。<code class="fe ng nh ni mx b">nums</code>的每个实例只会有1个答案。这有助于加强我之前解释的内容，因为上面的排序和向后遍历排序后的<code class="fe ng nh ni mx b">nums</code>的解决方案只会构建1个子序列。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="0a93" class="lx ly it mx b gy nb nc l nd ne">Also return the answer sorted in non-increasing order.</span></pre><p id="9d4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是问题所在。如果我们按非降序对<code class="fe ng nh ni mx b">nums</code>进行排序，然后从最后一个元素到第一个元素(或向后)遍历排序后的<code class="fe ng nh ni mx b">nums</code>，我们可以通过将每个数字推入一个空数组来构建最小大小、最大总和的子序列。这将自然地把它们按非递增顺序排序。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="e112" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">嫌疑犯</h2><p id="36a7" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们通过<code class="fe ng nh ni mx b">nums</code>在每次迭代中执行各种操作的顺序将会很重要。可能使<code class="fe ng nh ni mx b">minSubsequences</code>看起来更令人困惑的是，问题的解释给了我们很多信息，这些信息与我们需要如何执行每个部分有关，都是无序的。</p><p id="b26e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正因为如此，我将按照我们必须做的顺序列出我们迭代<code class="fe ng nh ni mx b">nums</code>时必须做的每一件事，并为每一部分提供一些解释。然后，我们可以通过一些伪代码来更好地了解我们的解决方案需要如何工作:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="84d8" class="lx ly it mx b gy nb nc l nd ne">1.) Find the total sum of nums, store it as a variable named sum</span></pre><p id="c8b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们需要一个起点。在我们做任何事情之前，我们需要找到<code class="fe ng nh ni mx b">nums</code>的总数<code class="fe ng nh ni mx b">sum</code>。因为我们需要从总数<code class="fe ng nh ni mx b">sum</code>中减去我们正在构建的子序列的总和，所以我们需要将<code class="fe ng nh ni mx b">sum</code>存储为一个变量。</p><p id="2092" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们做任何事情之前，有几种不同的方法可以找到<code class="fe ng nh ni mx b">nums</code>的总和，但是我将使用<code class="fe ng nh ni mx b">.reduce()</code>。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="e8b0" class="lx ly it mx b gy nb nc l nd ne">2.) Create 2 extra variables: sub (an empty array), and subSum (an integer)</span></pre><p id="d784" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要一个空数组来构建我们的子序列，我们可以称它为<code class="fe ng nh ni mx b">sub</code>。我们还将在解决方案的最后返回<code class="fe ng nh ni mx b">sub</code>。</p><p id="62b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们遍历排序后的<code class="fe ng nh ni mx b">nums</code>时，我们希望将<code class="fe ng nh ni mx b">nums</code>中的元素推送到<code class="fe ng nh ni mx b">sub</code>中，它将被初始化为一个空数组。</p><p id="e51d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要另一个名为<code class="fe ng nh ni mx b">subSum</code>的变量来跟踪我们构建到<code class="fe ng nh ni mx b">sub</code>中的子序列的总和。在每一次迭代中，我们都希望将<code class="fe ng nh ni mx b">nums[i]</code>(或每个元素)推入<code class="fe ng nh ni mx b">sub</code>，并将<code class="fe ng nh ni mx b">nums[i]</code>添加到<code class="fe ng nh ni mx b">subSum</code>。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="2527" class="lx ly it mx b gy nb nc l nd ne">3.) Sort nums in non-decreasing order</span></pre><p id="c6f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要将<code class="fe ng nh ni mx b">nums</code>中的元素从最少到最多排序。我们不需要把它保存到一个变量中，因为<code class="fe ng nh ni mx b">.sort()</code>会改变它所调用的数组。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="cb09" class="lx ly it mx b gy nb nc l nd ne">4.) Iterate through nums (which is now sorted) backwards</span></pre><p id="b945" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了找到最小的、最大总和的子序列，我们可以向后遍历排序的<code class="fe ng nh ni mx b">nums</code>，从数组中的最后一个元素(现在是最大的数字)开始到第一个元素(现在是最小的数字)。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="6e0f" class="lx ly it mx b gy nb nc l nd ne">5.) On each iteration, check to see if sum is greater than or equal to subSum</span></pre><p id="d8de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在每次迭代中，我们将检查<code class="fe ng nh ni mx b">sum &gt;= subSum</code>是否。如果不是，那么我们必须继续寻找一个<code class="fe ng nh ni mx b">nums</code>的子序列，它的和大于<code class="fe ng nh ni mx b">nums</code>中未包含元素的和。</p><p id="1b1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着我们将不得不做很多事情:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="26f8" class="lx ly it mx b gy nb nc l nd ne">5a.) Add nums[i] to subSum</span></pre><p id="6e85" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将基于排序后的<code class="fe ng nh ni mx b">nums</code>中的每个元素增加<code class="fe ng nh ni mx b">subSum</code>。在每次迭代中，如果<code class="fe ng nh ni mx b">subSum</code>小于<code class="fe ng nh ni mx b">sub</code>，我们希望将<code class="fe ng nh ni mx b">nums[i]</code>推入<code class="fe ng nh ni mx b">sub</code>，直到我们找到一个数字集合，其总和大于<code class="fe ng nh ni mx b">nums</code>中未包含元素的总和。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="fd13" class="lx ly it mx b gy nb nc l nd ne">5b.) Subract nums[i] from Sum</span></pre><p id="e77b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<code class="fe ng nh ni mx b">subSum</code>小于<code class="fe ng nh ni mx b">sum</code>时，我们还想从<code class="fe ng nh ni mx b">sum</code>中减去<code class="fe ng nh ni mx b">nums[i]</code>。这将跟踪我们继续从构建的子序列中排除的数字的总和。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="5f5a" class="lx ly it mx b gy nb nc l nd ne">5c.) Push nums[i] into sub</span></pre><p id="d006" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这建立了我们的子序列。我们想在<code class="fe ng nh ni mx b">subSum</code>小于<code class="fe ng nh ni mx b">sum</code>的时候继续建造<code class="fe ng nh ni mx b">sub</code>。一旦<code class="fe ng nh ni mx b">subSum</code>大于<code class="fe ng nh ni mx b">sum</code>，我们就发现一个子序列，它的元素之和大于未包含元素之和。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="3c53" class="lx ly it mx b gy nb nc l nd ne">6.) Break out of the iteration once sum is less than subSum</span></pre><p id="8e93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们发现子序列的元素之和大于未包含元素之和，我们就不再需要继续遍历排序后的<code class="fe ng nh ni mx b">nums</code>。这意味着我们可以打破<code class="fe ng nh ni mx b">for</code>循环。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="8182" class="lx ly it mx b gy nb nc l nd ne">7.) Return sub</span></pre><p id="79e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们已经按非降序对<code class="fe ng nh ni mx b">nums</code>进行了排序，并且因为我们正在对排序后的<code class="fe ng nh ni mx b">nums</code>进行反向迭代，所以一旦我们找到了元素之和大于未包含元素之和的子序列，我们也就找到了最小/最大和子序列。</p><p id="7a27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将代表子序列，所以我们可以返回它。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="3003" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">这个计划</h2><p id="6b7c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在我们编写任何代码之前，让我们编写一些伪代码来更好地可视化我们的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="9855" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">代码</h2><p id="8ff7" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">好吧，让我们试着将我们的解决方案付诸实践，看看是否可行:</p><p id="83e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们首先定义我们将需要的3个变量:<code class="fe ng nh ni mx b">sum</code>、<code class="fe ng nh ni mx b">sub</code>和<code class="fe ng nh ni mx b">subSum</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e31a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们也来排序一下<code class="fe ng nh ni mx b">nums</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="ffa5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们设置将向后遍历<code class="fe ng nh ni mx b">nums</code>的<code class="fe ng nh ni mx b">for</code>循环:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4a8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们可以添加<code class="fe ng nh ni mx b">if</code>语句来检查<code class="fe ng nh ni mx b">sum</code>是否大于或等于<code class="fe ng nh ni mx b">subSum</code>。如果不是，则退出迭代:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f16b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们可以添加我们的三个操作:将<code class="fe ng nh ni mx b">nums[i]</code>添加到<code class="fe ng nh ni mx b">subSum</code>，从<code class="fe ng nh ni mx b">sum</code>中减去<code class="fe ng nh ni mx b">nums[i]</code>，并将<code class="fe ng nh ni mx b"> nums[i]</code>推送到<code class="fe ng nh ni mx b">sub</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9e6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们可以添加我们的返回值<code class="fe ng nh ni mx b">sub</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="5b90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看它是否有效:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/bfebf24f8823b3e949f8e28f7399c039.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*o3bZ6bSlD6h41g9dEHvouw.png"/></div></figure><p id="63f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="3713" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">最终解决方案</h2><p id="7141" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">让我们最后看一下不带注释的解决方案，并清理一些语法:</p><p id="9650" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae mv" href="https://leetcode.com/submissions/detail/382295671/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> LeetCode提交明细</strong> </a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="fce7" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">任务完成</h2><p id="b160" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我真的很喜欢这个问题，因为它迫使我走出了我的舒适区。我觉得这个解决方案是我写过的最有效的解决方案之一，这无疑促使我在写解决方案之前先将它可视化。</p><p id="57c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我当然明白我的解决方案不会是最好的或最有效的，但不管怎样，我希望它们能帮助你或其他人找到一种方法来解决你在这个旅程中遇到的问题，我们称之为JavaScript。</p><p id="3bf2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管怎样，我希望你得到了一些有用的信息，希望你所有的函数都返回true，所有的请求都用200来响应。</p><p id="abe4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">保持安全…保持健康…继续为正义而战。</p></div></div>    
</body>
</html>