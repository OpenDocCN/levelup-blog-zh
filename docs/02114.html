<html>
<head>
<title>Asynchronous Javascript Part 1: Single-Threaded Programming and the Call Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步Javascript第1部分:单线程编程和调用堆栈</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asynchronous-javascript-part-1-b87f263a353a?source=collection_archive---------6-----------------------#2020-02-19">https://levelup.gitconnected.com/asynchronous-javascript-part-1-b87f263a353a?source=collection_archive---------6-----------------------#2020-02-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bbbab6fc99628470add15052bb51d73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-25KB7EbSHjv70HXrdl6w.png"/></div></div></figure><p id="e5f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，Javascript是一种同步语言。这意味着所有的语句和函数都按照预先定义的顺序一个接一个地执行。Javascript之所以如此，是因为它只有一个执行线程。像Java这样的其他语言提供了一个多线程的执行环境，其中有主线程和其他线程，可以在运行时创建这些线程来并行运行任务。因此，在这些语言中实现异步非常简单直接。</p><p id="15aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，由于Javascript只为我们提供了单线程的执行，我们需要理解某些看似异步的函数，比如<code class="fe kw kx ky kz b">setTimeout</code>函数，是如何运行的。但在此之前，我们先来看看<strong class="ka ir">单线程执行</strong>流程是如何工作的。</p><h1 id="20df" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">单线程执行</h1><p id="b954" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">以这个简单的程序为例</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="b03f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出:</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="b28f" class="mn lb iq kz b gy mo mp l mq mr">1<br/>2</span></pre><p id="55a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第1行，程序将函数声明保存到变量'<em class="ms"> sayOne </em>'中。请注意，它只保存了函数声明，但还没有调用它。因此，在这一点上，它的代码实际上都没有运行，因此第2行还没有执行。在第5行，它将另一个函数定义保存到一个变量'<em class="ms"> sayTwo </em>'(但还没有调用它)。在第9行，它调用函数<em class="ms"> sayOne </em>。此时，执行保存的<em class="ms"> sayOne </em>的函数定义，导致程序的第2行被执行，数值“1”被打印到控制台上。类似地，在第10行，程序调用函数<em class="ms"> sayTwo </em>，这导致第6行被执行，它将值“2”打印到控制台上。</p><p id="9f1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的执行流程看起来非常简单易懂。Javascript逐行执行程序，并按顺序执行。然而，正如你可能已经看到的，程序并没有真正的一行一行的执行，由于函数调用，在执行行的顺序上有一些跳跃。我们将在本文的后面看到它。这里要注意的另一件好事是，Javascript不会移动到下一行执行，直到上一行被执行。</p><p id="7309" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，让我们假设<em class="ms"> sayOne </em>函数有一个复杂的代码，需要很长时间来执行(例如，一秒钟)。在这种情况下，当在第9行时，程序将等待直到<em class="ms"> sayOne </em>功能被完全执行，然后移动到第10行以在那里执行<em class="ms"> sayTwo </em>功能。这是因为，正如我们前面指出的，Javascript运行在所有函数共享的单个执行线程上。因此，程序会等到当前函数完全执行完毕后再继续运行。</p><p id="18fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们稍微修改一下上面的代码，试着理解接下来会发生什么。让我们添加第三个名为'<em class="ms"> sayThree </em>'的函数。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="ccfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们在代码中调用这个函数</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="117f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们在函数<em class="ms"> sayOne </em>的主体中调用了<em class="ms"> sayThree </em>函数(它将“3”打印到控制台上)。因此，在执行上述程序时，当调用函数<em class="ms"> sayOne </em>时，您认为第14行会发生什么？控制台会先记录“1”，然后继续执行<em class="ms"> sayThree </em>的代码，还是会暂停自己的执行，调用<em class="ms"> sayThree </em>函数，等待它完成，然后继续最终将“1”打印到控制台上？</p><p id="6674" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，上面程序的输出将是</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="b055" class="mn lb iq kz b gy mo mp l mq mr">3<br/>1<br/>2</span></pre><p id="b65c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了理解这一点，我们需要理解Javascript如何在内部维护函数的顺序。</p><h1 id="0f54" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">调用栈</h1><p id="2abb" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">Javascript有一个叫做<strong class="ka ir">调用栈</strong>的东西，用来跟踪要执行的函数的顺序。调用栈，顾名思义，就是一个栈。因此，添加到此堆栈的项目将按照“<a class="ae mt" href="https://www.geeksforgeeks.org/lifo-last-in-first-out-approach-in-programming/" rel="noopener ugc nofollow" target="_blank">后进先出</a>”的顺序退出堆栈。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="26e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的程序中，当程序到达第14行时，Javascript程序看到函数<em class="ms"> sayOne </em>将被调用。发生这种情况时，它会将函数SayOne添加到调用堆栈中。因此，堆栈目前看起来像这样</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="c5d0" class="mn lb iq kz b gy mo mp l mq mr">|            |<br/>|            |<br/>|            |<br/>|            |<br/>|  sayOne()  |<br/>|____________|<br/>   <br/>  Call stack</span></pre><p id="4ef7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数保留在调用堆栈中，只有在执行完成后才会弹出。Javascript的工作方式是，它总是首先执行堆栈顶部的函数，然后将它弹出堆栈，然后移动到堆栈中的下一个函数。因此，程序现在“跳转”到执行栈顶的函数，即<em class="ms"> sayOne </em>函数。<em class="ms"> sayOne </em>的执行从第2行开始，程序看到<em class="ms"> sayThree </em>函数将被调用。因此，Javascript也将这个函数添加到调用堆栈中。更新后的调用堆栈现在看起来像这样</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="311b" class="mn lb iq kz b gy mo mp l mq mr">|             |<br/>|             |<br/>|             |<br/>|  sayThree() |<br/>|  sayOne()   |<br/>|_____________|<br/>   <br/>  Call stack</span></pre><p id="36e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后程序跳转到执行栈顶的函数，也就是sayThree函数。现在运行<em class="ms"> sayThree </em>函数的代码，其中第11行将“3”打印到控制台上。然后程序看到它已经到达了<em class="ms"> sayThree </em>函数的末尾，因此将它弹出堆栈。现在堆栈看起来像这样</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="04db" class="mn lb iq kz b gy mo mp l mq mr">|             |<br/>|             |<br/>|             |<br/>|             |<br/>|  sayOne()   |<br/>|_____________|<br/>   <br/>  Call stack</span></pre><p id="fa5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Javascript然后看到<em class="ms"> sayOne </em>函数在栈顶，因此跳回到它在执行中停止的地方。第3行将“1”打印到控制台上。再一次，在到达<em class="ms"> sayOne </em>函数的末尾时，Javascript将它弹出堆栈，如下所示</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="0c4c" class="mn lb iq kz b gy mo mp l mq mr">|             |<br/>|             |<br/>|             |<br/>|             |<br/>|             |<br/>|_____________|<br/>   <br/>  Call stack</span></pre><p id="9bbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在看到堆栈为空后，Javascript程序跳回到最初执行时停止的地方，也就是第15行，在那里看到调用了<em class="ms"> sayTwo </em>函数。你可能已经猜到了，sayTwo被添加到堆栈中</p><pre class="md me mf mg gt mj kz mk ml aw mm bi"><span id="2296" class="mn lb iq kz b gy mo mp l mq mr">|             |<br/>|             |<br/>|             |<br/>|             |<br/>|  sayTwo()   |<br/>|_____________|<br/>   <br/>  Call stack</span></pre><p id="f2d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于它是堆栈中最顶层的函数，程序的执行跳转到<em class="ms"> sayTwo </em>的执行，在第7行，值“2”被打印到控制台上。到达函数末尾时，它会弹出堆栈，调用堆栈现在为空。没有更多的行要运行，因此程序终止。</p><p id="f8f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们讨论调用堆栈时，您可能对Javascript在执行过程中如何“跳转”到调用堆栈顶部的函数感到有些困惑。Javascript如何知道一个新函数何时被添加到堆栈中，或者一个函数何时被从堆栈中移除，因此它需要继续执行堆栈中的下一个函数？</p><p id="deb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将在这个系列的<a class="ae mt" href="https://medium.com/@kabir4691/asynchronous-javascript-part-2-26ac20fc5ad7" rel="noopener">第二部分</a>中讨论这个问题以及更多内容。</p></div></div>    
</body>
</html>