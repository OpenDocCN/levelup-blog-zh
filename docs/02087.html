<html>
<head>
<title>Cracking the Combination Recursive Riddle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解组合递归之谜</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cracking-the-combination-recursive-riddle-64b92d99c6f5?source=collection_archive---------18-----------------------#2020-02-17">https://levelup.gitconnected.com/cracking-the-combination-recursive-riddle-64b92d99c6f5?source=collection_archive---------18-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/277b553391d315f1bbca2412fee35388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xU7sPEn_OXFovLX7"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="kf">原载于【https://edward-huang.com】<a class="ae kg" href="https://edward-huang.com/functional-programming/programming/scala/algorithm/jobs/2020/02/14/cracking-the-combination-recursive-riddle/" rel="noopener ugc nofollow" target="_blank"><em class="kf"/></a><em class="kf">。</em></em></figcaption></figure><p id="7ed9" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在19世纪后期，数学家使用归纳法定义函数的原理。阿砣·戴德金德(1889年)使用归纳法定义并证明了他的关于正整数的第五公理。后来，他的正整数的第五个原理被称为原始递归。从那以后，递归的概念在数学的基础中起了重要的作用。</p><p id="5060" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">归纳法证明是一种通过证明计算的每一步来证明概念、理论或算法有效的方法。事情是这样的——你可以证明一个任意的陈述n，首先证明当n为1时该陈述为真，然后假设当n = k时它也为真，并证明它对n = k+1有效。</p><p id="1ff3" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">递归源于归纳的概念。递归函数的工作原理是通过调用自身将问题分解成更小的部分。然后，是基本情况，即n = 1时。</p><p id="64aa" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">因此，通过将更重要的问题语句分解为更小的问题，可以推导出很多算法逻辑。而组合就是其中之一。</p><p id="e6e1" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">当我学习Scala编程语言和函数式编程时，我意识到函数的每个调用都是递归的。你想循环遍历一个列表并得到列表的最后两个元素，你必须使用模式匹配并不断调用你自己，直到它遇到列表的最后一个元素，并将最后一个元素返回到先前的调用堆栈。</p><p id="f635" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">组合问题是我们在软件工程师面试问题中经常遇到的经典递归问题。当受访者屏住呼吸，绞尽脑汁思考如何着手解决问题时，问题就来了。因此，对于一个采访者来说，这是一个正确的问题，通过他们的受访者的大脑，看看他们如何解决一个复杂的问题。</p><p id="9a51" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">让我们来做一个例子——创建一个组合函数，返回整数列表的所有可能组合。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="184e" class="lo lp it lk b gy lq lr l ls lt">val lst = List(1,2,3)</span></pre><p id="d5bb" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果我们将列表分解为只有1个元素' List (1 ' ',它可能有哪些组合？</p><h1 id="dbba" class="lu lp it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">选择还是不选择</h1><p id="2264" class="pw-post-body-paragraph kh ki it kj b kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la mv lc ld le im bi translated">答案是2。为什么？因为你可以选择其中一个元素，或者不选择。</p><p id="b6c2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">根据这一观察，我们现在可以开始弄清楚这个概念如何转化为代码。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="c64e" class="lo lp it lk b gy lq lr l ls lt">def combination(len:Int, i:Int lst:List[Int]):List[List[Int]] = {<br/>  <em class="mz">// here you either choose the value or you didn't<br/></em>  val includedList = lst.head :: combination(len, i+1, lst.tail) <em class="mz"><br/></em>  val notIncludedList = combination(len, i+1, lst.tail) <em class="mz">// skip the current head<br/></em>}</span></pre><p id="3346" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">注意，在上面的代码中，不管发生了什么，index <code class="fe mw mx my lk b">i</code>的值总是递增，将指针移动到列表中的下一个元素。在一次递归调用中，我们包含了选择的值<code class="fe mw mx my lk b">lst.head</code>。另一方面，我们不包括<code class="fe mw mx my lk b">lst.head</code>，跳过当前值。</p><p id="f276" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">每个递归函数都需要有一个基本用例。当我考虑基本情况时，首先想到的是当列表为空时会发生什么？我应该返回什么样的值？</p><p id="d2d0" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在这种情况下，如果列表为空，函数应该返回一个空列表，因为我们没有什么可选择的。</p><p id="999e" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">函数变成了这样:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="7ca3" class="lo lp it lk b gy lq lr l ls lt">def combination(len:Int, i:Int, lst:List[Int]):List[List[Int]] = {<br/>  if(len == i) {<br/>    List(Nil)<br/>  }<br/>  else {<br/>      val includedList = combination(len, i+1, lst.tail).map(lst.head :: _) <em class="mz">// choose the current head<br/></em>      val notIncludedList = combination(len, i+1, lst.tail) <em class="mz">// skip the current head<br/></em>      includedList ::: notIncludedList<br/>  }<br/>}</span></pre><p id="fa5c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">上面的代码在技术上是可行的，因为它产生了正确的输出。然而，在Scala中，我们可以省略<code class="fe mw mx my lk b">i</code>值，通过遍历列表的<code class="fe mw mx my lk b">tail</code>来遍历列表。让我们更简洁地重构上面的工作解决方案。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="e54b" class="lo lp it lk b gy lq lr l ls lt">def combination(lst:List[Int]): List[List[Int]] = {<br/>  if(lst == Nil) {<br/>    List(Nil)<br/>  } else {<br/>    val includedList = combination(lst.tail).map(lst.head :: _)<br/>    val notIncludedList = combination(lst.tail)<br/>    includedList ::: notIncludedList<br/>  }<br/>}</span></pre><p id="911c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">并将其与模式匹配相结合:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="f9c0" class="lo lp it lk b gy lq lr l ls lt">def combination(lst:List[Int]) : List[List[Int]] = lst match {<br/>  case Nil =&gt; List(Nil)<br/>  case h:rest =&gt; combination(rest).map(h :: _) ::: combination(rest)<br/>}</span></pre><p id="28ae" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">这将是查找列表中所有子集的最简单形式。所以<code class="fe mw mx my lk b">List(1,2,3)</code>才会有<code class="fe mw mx my lk b">List(List(1), List(2), List(3), List(1,2), List(1,3), List(2,3), List(1,2,3), List())</code>。</p><p id="7f6c" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">就是这样！这是组合的基本结构。大多数其他组合问题在进一步计算算法时涉及一些约束。大多数动态规划算法都可以从组合算法中派生出来。</p><p id="7119" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">例如，流行的<a class="ae kg" href="https://en.wikipedia.org/wiki/Knapsack_problem" rel="noopener ugc nofollow" target="_blank">背包问题</a>，如果袋子没有装满，你要么选择这个当前值包含在一个集合中，要么跳过它。一旦你找到了所有的组合，你就从你选择的组合中计算出了最大的价值。我们可以通过创建一个迭代方法来进一步导出所有的模式，或者用<code class="fe mw mx my lk b">LazyList</code>来记忆计算。</p><h1 id="8fb6" class="lu lp it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">外卖:</h1><ul class=""><li id="7778" class="na nb it kj b kk mr ko ms ks nc kw nd la ne le nf ng nh ni bi translated">用归纳法从证明中推导出一个递归算法。</li><li id="79e3" class="na nb it kj b kk nj ko nk ks nl kw nm la nn le nf ng nh ni bi translated">所有迭代计算解都可以从递归函数中导出。</li><li id="aa26" class="na nb it kj b kk nj ko nk ks nl kw nm la nn le nf ng nh ni bi translated">组合的两个主要活动是选择或不选择。</li></ul><h1 id="a9df" class="lu lp it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">引人深思的事</h1><p id="9b70" class="pw-post-body-paragraph kh ki it kj b kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la mv lc ld le im bi translated">在观察阶段，<code class="fe mw mx my lk b">lst.head</code>与组合的其余部分一起前置。然而，在解决方案的最后，我使用了<code class="fe mw mx my lk b">map</code>函数在结果中添加头部。有区别吗？</p><p id="f6a2" class="pw-post-body-paragraph kh ki it kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">本教程所有的源代码都是<a class="ae kg" href="https://github.com/edwardGunawan/Blog-Tutorial/tree/master/ScalaTutorial/combinationTutorial" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h2 id="dca5" class="lo lp it bd lv nv nw dn lz nx ny dp md ks nz oa mh kw ob oc ml la od oe mp of bi translated">感谢阅读！如果你喜欢这篇文章，请随意<a class="ae kg" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank">订阅</a>我的时事通讯，接收关于科技职业的每周文章、有趣的链接和内容！</h2><p id="0a76" class="pw-post-body-paragraph kh ki it kj b kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la mv lc ld le im bi translated">你可以关注我，也可以关注我在<a class="ae kg" href="https://medium.com/@edwardgunawan880" rel="noopener">媒体</a>上的更多帖子。</p></div></div>    
</body>
</html>