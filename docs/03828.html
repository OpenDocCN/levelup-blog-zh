<html>
<head>
<title>React Tips — Basic Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应提示—基本挂钩</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-tips-basic-hooks-140293672b28?source=collection_archive---------15-----------------------#2020-05-28">https://levelup.gitconnected.com/react-tips-basic-hooks-140293672b28?source=collection_archive---------15-----------------------#2020-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c5a4050e61eb149d374f343d50e5e322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I4bu1rHRcGykoJA4"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@accrualbowtie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瑞恩·华莱士</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="5985" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React是创建前端应用程序最流行的库之一。它还可以用来创建带有React Native的移动应用程序。</p><p id="299b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看React内置的一些基本挂钩，它们使我们的功能组件变得智能。</p><h1 id="3226" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">状态和使用状态</h1><p id="e094" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">useState</code>钩子来存储应用程序的状态。因此，它是智能反应功能组件的基本构建块。</p><p id="1dd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使用它，我们编写以下代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="34e3" class="mt lf it mk b gy mu mv l mw mx">import React from "react";</span><span id="6c3f" class="mt lf it mk b gy my mv l mw mx">export default function App() {<br/>  const [count, setCount] = React.useState(0);</span><span id="4c15" class="mt lf it mk b gy my mv l mw mx">  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={() =&gt; setCount(count =&gt; count - 1)}&gt;decrement&lt;/button&gt;<br/>      &lt;p&gt;{count}&lt;/p&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="a985" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们将<code class="fe mh mi mj mk b">count</code>状态作为由<code class="fe mh mi mj mk b">useState</code>钩子返回的数组的第一个元素返回。</p><p id="0940" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们定义了一个<code class="fe mh mi mj mk b">onClick</code>处理程序，它调用作为由<code class="fe mh mi mj mk b">useState</code>返回的数组中的第二个元素返回的<code class="fe mh mi mj mk b">setCount</code>函数。</p><p id="d0c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在那里，我们通过返回现有的<code class="fe mh mi mj mk b">count</code>值减1来更新<code class="fe mh mi mj mk b">count</code>。</p><p id="33d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这让我们可以基于状态的前一个值来修改它的值。我们也可以直接传入我们想要设置的任何东西，如果它不依赖于状态的前一个值的话。</p><p id="8028" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">传入回调将保证更新是基于先前的状态值完成的。</p><p id="370e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以将一个值直接传入状态更改函数，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b2a5" class="mt lf it mk b gy mu mv l mw mx">import React from "react";</span><span id="050d" class="mt lf it mk b gy my mv l mw mx">export default function App() {<br/>  const [text, setText] = React.useState("foo");</span><span id="9707" class="mt lf it mk b gy my mv l mw mx">  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={() =&gt; setText("foo")}&gt;foo&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setText("bar")}&gt;bar&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setText("baz")}&gt;baz&lt;/button&gt;<br/>      &lt;p&gt;{text}&lt;/p&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="13f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有3个按钮，这些按钮具有调用<code class="fe mh mi mj mk b">setText</code>来设置<code class="fe mh mi mj mk b">text</code>状态值的点击处理程序。</p><p id="f313" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们设置的值不依赖于之前的值，我们可以通过传入我们想要设置<code class="fe mh mi mj mk b">text</code>的值来直接设置它。</p><p id="7331" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从前面的例子可以看出，状态改变函数可以多次使用。</p><p id="68ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可以接受任何类型的值，包括原始值和对象。</p><h1 id="183c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">副作用和使用效果</h1><p id="8d17" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">React <code class="fe mh mi mj mk b">useEffect</code>钩子是另一个我们不能忽视的重要钩子。</p><p id="e3e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它用于提交副作用，比如从API异步更新数据或使用DOM。</p><p id="94ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">副作用是能够以不可预知的方式改变我们身体组成部分的行为。</p><p id="146d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它接受在每次渲染时运行的回调函数。为了将回调限制为仅在指定值发生更改时运行，我们传入了第二个参数，该参数包含我们希望监视的值的数组，并在值发生更改时运行回调。</p><p id="aadb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们传入一个空数组作为第二个参数，那么回调只在第一次渲染时运行。</p><p id="0a05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b394" class="mt lf it mk b gy mu mv l mw mx">import React, { useEffect } from "react";</span><span id="eea5" class="mt lf it mk b gy my mv l mw mx">export default function App() {<br/>  const [name, setName] = React.useState("");<br/>  const [data, setData] = React.useState({});</span><span id="a8ba" class="mt lf it mk b gy my mv l mw mx">  const getData = async () =&gt; {<br/>    const res = await fetch(`https://api.agify.io/?name=${name}`);<br/>    const d = await res.json();<br/>    setData(d);<br/>  };</span><span id="5825" class="mt lf it mk b gy my mv l mw mx">  useEffect(() =&gt; {<br/>    getData();<br/>  }, [name]);</span><span id="23e8" class="mt lf it mk b gy my mv l mw mx">  return (<br/>    &lt;&gt;<br/>      &lt;input value={name} onChange={e =&gt; setName(e.target.value)} /&gt;<br/>      &lt;p&gt;<br/>        {data.name} {data.age}<br/>      &lt;/p&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="28d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个输入，当我们在其中键入一些内容时，它会改变<code class="fe mh mi mj mk b">name</code>状态的值。</p><p id="4450" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后用<code class="fe mh mi mj mk b">useEffect</code>钩子，我们观察<code class="fe mh mi mj mk b">name</code>的变化，这样当<code class="fe mh mi mj mk b">name</code>值变化时<code class="fe mh mi mj mk b">getData</code>被调用。</p><p id="bcf2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">getData</code>函数中，我们调用<code class="fe mh mi mj mk b">setData</code>来设置数据并显示从API调用中获得的数据。</p><p id="b9af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该总是传入一个数组作为第二个参数，这样回调就不会在每次渲染时意外运行。</p><p id="eaea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们需要进行清理，我们应该在<code class="fe mh mi mj mk b">useEffect</code>回调函数中返回一个函数，并在需要时运行回调函数中的任何清理代码。</p><p id="76d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下使用添加清理代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cfb4" class="mt lf it mk b gy mu mv l mw mx">import React, { useEffect } from "react";</span><span id="a31f" class="mt lf it mk b gy my mv l mw mx">export default function App() {<br/>  const [mousePosition, setMousePosition] = React.useState({});<br/>  const { x, y } = mousePosition;</span><span id="dadc" class="mt lf it mk b gy my mv l mw mx">  const handleMouseMove = event =&gt; {<br/>    const { pageX, pageY } = event;<br/>    setMousePosition({<br/>      x: pageX,<br/>      y: pageY<br/>    });<br/>  };</span><span id="5754" class="mt lf it mk b gy my mv l mw mx">  useEffect(() =&gt; {<br/>    window.addEventListener("mousemove", handleMouseMove);</span><span id="c5a6" class="mt lf it mk b gy my mv l mw mx">    return () =&gt; window.removeEventListener("mousemove", handleMouseMove);<br/>  });</span><span id="1d6b" class="mt lf it mk b gy my mv l mw mx">  return (<br/>    &lt;&gt;<br/>      &lt;p&gt;<br/>        ({x}, {y})<br/>      &lt;/p&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="b445" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们为名为<code class="fe mh mi mj mk b">handleMousemove</code>的<code class="fe mh mi mj mk b">mousemove</code>事件添加了一个事件处理程序，它获取鼠标位置并调用<code class="fe mh mi mj mk b">setMousePosition </code>来设置<code class="fe mh mi mj mk b">mousePosition</code>状态。</p><p id="07ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们通过书写来观察鼠标位置:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="280a" class="mt lf it mk b gy mu mv l mw mx">window.addEventListener("mousemove", handleMouseMove);</span></pre><p id="ad07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">useEffect</code>回调中。在它下面，我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a5db" class="mt lf it mk b gy mu mv l mw mx">return () =&gt; window.removeEventListener("mousemove", handleMouseMove);</span></pre><p id="6c42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当不再呈现<code class="fe mh mi mj mk b">App</code>组件时，删除<code class="fe mh mi mj mk b">mousemove</code>事件监听器。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/1834ba296a4c4bf7a9f8fa4ce1280966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zquwINXMtjulMsBB"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">多鲁克·耶梅尼西在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="c396" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="7c92" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">useState</code>和<code class="fe mh mi mj mk b">useEffect</code>钩子是React标准库中最有用和最基本的两个钩子。</p><p id="b7f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们分别让我们更新状态和提交副作用。</p></div></div>    
</body>
</html>