<html>
<head>
<title>Creating A Python Chatbot That Learns As You Speak To It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个Python聊天机器人，当你对它说话时，它会学习</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-python-chatbot-that-learns-as-you-speak-to-it-60b305d8f68f?source=collection_archive---------4-----------------------#2022-10-28">https://levelup.gitconnected.com/creating-a-python-chatbot-that-learns-as-you-speak-to-it-60b305d8f68f?source=collection_archive---------4-----------------------#2022-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/179dceea28429f911f5ced98144e1f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2F7EBp0SXHF2xFypsUXwTA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">与聊天机器人托马斯的对话</figcaption></figure><p id="b9e6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在过去的两周里，我一直在开发一个名为Thomas的开源聊天机器人。正如托马斯在上面的图片中所承认的，这不是“最好”的方法，而是我自己想出来的方法。</p><p id="b5c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在这里 找到Github库<a class="ae la" href="https://github.com/principle105/thomasthechatbot" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">。</strong></a></p><p id="f545" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">大约两年前，我就有了这个想法。我的目标是创建一个聊天机器人，与我的<a class="ae la" href="https://discord.gg/BehbQbPPzD" rel="noopener ugc nofollow" target="_blank"> Discord服务器</a>的成员进行交互。几天后，我能够拼凑出一个半功能的聊天机器人，可以回复信息——尽管不是很准确。它通过查询类似于从提示到答案的映射中输入的提示来做到这一点。这个系统的主要限制是它只能对类似于映射中的提示做出响应。我不能从词汇上解释或推导句子的意思——两个同义词被视为完全不同的词。</p><p id="064e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那么，新托马斯是如何工作的？</p><h1 id="74d1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数据存储</h1><p id="14a8" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">托马斯没有硬编码的回应，他被设计成从他的对话中“学习”。因此，他只有他所看到的那么多独特的反应。</p><h2 id="68b0" class="me lc iq bd ld mf mg dn lh mh mi dp ll kn mj mk lp kr ml mm lt kv mn mo lx mp bi translated">反应</h2><p id="3629" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">如前所述，托马斯从他以前看到的反应中学习。以前的响应存储在一个JSON文件(<code class="fe mq mr ms mt b">resps.json</code>)中，作为一个字典，其中的键是一个惟一的<a class="ae la" href="https://docs.python.org/3/library/uuid.html" rel="noopener ugc nofollow" target="_blank"> UUID </a>，值是标记化的响应(稍后将详细介绍)。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/0f961cc555dba7a7a76a0d692f476b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-khSTgfYHBgC6Pvy6e0dBg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd ld">“你好吗”</strong>的响应存储</figcaption></figure><h2 id="1698" class="me lc iq bd ld mf mg dn lh mh mi dp ll kn mj mk lp kr ml mm lt kv mn mo lx mp bi translated">网状物</h2><p id="9c63" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">那么，这和我以前的方法有什么不同呢？好吧，不同于从提示到答案的直接映射的查询，单词模式通过一个“网格”与响应相关联。</p><p id="9c73" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我解释一下:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/75ad319a1b4d0dd43d69863d5607b6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*XUg32wr1-bsdaFWDKI3Rmw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">响应和网格的一般结构</figcaption></figure><p id="116f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">网格由一个字典组成，其中的键是提示的UUID，值是一个“链接”。链接仅用于将提示的单词模式与一组响应相关联，它具有以下属性:</p><blockquote class="na nb nc"><p id="19a4" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><code class="fe mq mr ms mt b"><em class="iq">stop_words: set</em></code> <em class="iq">提示的停止字<br/> </em> <code class="fe mq mr ms mt b"><em class="iq">keywords: set</em></code> <em class="iq">提示的关键字<br/> </em> <code class="fe mq mr ms mt b"><em class="iq">resps: dict[str, set]</em></code> <em class="iq">对提示的响应，其中关键字是响应UUID，值是来自前一个提示的一组网格ID。</em></p></blockquote><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/6669d2ebc9f0d13b021b2c488c767b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w5MA4AM9LeaAwHrX2OIgWA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">网目提示<strong class="bd ld"> <em class="ni">【太好了】</em> </strong></figcaption></figure><h2 id="c142" class="me lc iq bd ld mf mg dn lh mh mi dp ll kn mj mk lp kr ml mm lt kv mn mo lx mp bi translated">标记和停用词</h2><p id="6f40" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">在标记化之前，文本被小写，缩写被扩展，标点被删除。这个过程有助于提高查询的一致性和准确性，因为减少了不必要的信息。</p><p id="da2a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">提示由word标记，可以分为两部分:</p><p id="9bcb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">停用词</strong>:英语中的常用词<br/> <strong class="ke ir">关键词</strong>:所有其他词按其词性进行词条化</p><p id="6151" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">响应存储为令牌列表，而不是拆分为停止和关键字。</p><h2 id="84e9" class="me lc iq bd ld mf mg dn lh mh mi dp ll kn mj mk lp kr ml mm lt kv mn mo lx mp bi translated">词汇化</h2><p id="634d" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">词汇化用于根据单词的含义和上下文来规范化单词。这一过程有助于消除句子中单词含义的任何歧义，从而提高聊天机器人的准确性。</p><p id="2e41" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如:</p><p id="2373" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">单词<strong class="ke ir"> "car" </strong>和<strong class="ke ir"> "cars" </strong>将被归入同一个基本单词，而<strong class="ke ir"> "studies" </strong>和<strong class="ke ir">" studies "</strong>将被转换为不同的基本单词，因为它们具有不同的含义。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/5cad167823ccba46b379eec2db10f832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uz-7wX1DmWLBk-5E7hXggQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">处理词汇化的代码</figcaption></figure><h1 id="be46" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">查询响应</h1><h2 id="984a" class="me lc iq bd ld mf mg dn lh mh mi dp ll kn mj mk lp kr ml mm lt kv mn mo lx mp bi translated">忽略响应</h2><p id="9dcd" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">用户的提示和聊天机器人之前的响应将被忽略，作为防止聊天机器人出现重复的响应。</p><h2 id="c837" class="me lc iq bd ld mf mg dn lh mh mi dp ll kn mj mk lp kr ml mm lt kv mn mo lx mp bi translated">初始查询</h2><p id="bd9b" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">网格最初通过其分数从提示中查询，分数可以通过以下公式计算:</p><blockquote class="na nb nc"><p id="30a9" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><code class="fe mq mr ms mt b"><em class="iq">(ss / 2 + sk) / (ts / 2 + tk - ss / 2 - sk + 1)</em></code></p><p id="3ed1" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><code class="fe mq mr ms mt b"><em class="iq">ss</em></code> <em class="iq"> =共享停用词<br/> </em> <code class="fe mq mr ms mt b"><em class="iq">sk</em></code> <em class="iq"> =共享关键词<br/> </em> <code class="fe mq mr ms mt b"><em class="iq">ts</em></code> <em class="iq"> =总停用词<br/> </em> <code class="fe mq mr ms mt b"><em class="iq">tk</em></code> <em class="iq"> =总关键词</em></p></blockquote><p id="0dea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过将<code class="fe mq mr ms mt b">ss</code>和<code class="fe mq mr ms mt b">sk</code>除以2，该公式对共享关键词的权重是停用词的2倍。它还考虑了单词的总数，从而得到更精确的网格。</p><h2 id="68b6" class="me lc iq bd ld mf mg dn lh mh mi dp ll kn mj mk lp kr ml mm lt kv mn mo lx mp bi translated">丢弃</h2><blockquote class="na nb nc"><p id="f6da" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="iq">首先丢弃<br/> </em> </strong> <em class="iq">得分低于阈值的网格(</em> <code class="fe mq mr ms mt b"><em class="iq">min_score</em></code> <em class="iq">)被丢弃。</em></p><p id="5f76" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="iq">无结果查询<br/> </em> </strong> <em class="iq">如果无结果剩余，网格改为按共享停止字的数量查询。使用共享停用字词的数量来重新计算分数。</em></p><p id="9731" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="iq">第二次丢弃<br/> </em> </strong> <em class="iq">对剩余网格进行排序，丢弃低于最佳分数的百分比阈值(</em> <code class="fe mq mr ms mt b"><em class="iq">score_threshold</em></code> <em class="iq">)的网格。考虑多个网格增加了响应的多样性。</em></p><p id="0f5e" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated"><em class="iq">如果没有剩余的网格，随机选择一个。</em></p></blockquote><h2 id="ca68" class="me lc iq bd ld mf mg dn lh mh mi dp ll kn mj mk lp kr ml mm lt kv mn mo lx mp bi translated">网格关联</h2><p id="db04" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">网格通过共享响应的百分比彼此关联(<code class="fe mq mr ms mt b">mesh_association</code>)。找到每个查询网格的关联网格，并将其添加到列表中。该过程防止训练较少的提示具有较小的响应池。</p><h2 id="3467" class="me lc iq bd ld mf mg dn lh mh mi dp ll kn mj mk lp kr ml mm lt kv mn mo lx mp bi translated">选择回应</h2><p id="4b1c" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">如果发现响应共享与提示相同的先前消息<a class="ae la" href="https://docs.python.org/3/library/uuid.html" rel="noopener ugc nofollow" target="_blank"> UUID </a>，则所有非共享响应将被忽略。通过这样做，在查询响应时会考虑之前的提示。这使得聊天机器人更加精确，因为它可以解释这样一个事实，即根据上下文的不同，相同的提示可能会引起不同的响应。</p><blockquote class="na nb nc"><p id="a903" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated">托马斯:你好吗？<br/> <strong class="ke ir">你:</strong>好。T21托马斯:我很高兴你过得很好</p></blockquote><p id="bcd5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从上面和下面的例子中可以看出，Thomas根据他之前的问题对提示“Good”的回答是不同的。</p><blockquote class="na nb nc"><p id="79e0" class="kc kd nd ke b kf kg kh ki kj kk kl km ne ko kp kq nf ks kt ku ng kw kx ky kz ij bi translated">托马斯:你今天的足球比赛怎么样？<br/> <strong class="ke ir">你:</strong>好。<br/> <strong class="ke ir">托马斯:</strong>赢了吗？</p></blockquote><p id="aefc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从剩余的回答中随机选择回答。随机选择使聊天机器人不可预测。</p><h1 id="ed9c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9475" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">正如我之前所说，这远不是创建对话聊天机器人的“完美”方法。尽管如此，我相信这种方法在开发精确的功能聊天机器人方面是有效的，而不需要大量的数据集——仅从对话中学习。</p><p id="89de" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://github.com/principle105/thomasthechatbot" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> Github库</strong> </a></p></div></div>    
</body>
</html>