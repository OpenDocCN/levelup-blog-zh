<html>
<head>
<title>How to Add Medium Articles to React and Avoid CORS Errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何添加中等文章反应和避免CORS错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-add-medium-articles-to-react-and-avoid-cors-errors-25e687a26e63?source=collection_archive---------2-----------------------#2022-11-30">https://levelup.gitconnected.com/how-to-add-medium-articles-to-react-and-avoid-cors-errors-25e687a26e63?source=collection_archive---------2-----------------------#2022-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/22dc59c9f7952ba9b9196ab4d1ab4451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fl0ZJJ8EKM3F6uSK4xb1Vg.png"/></div></div></figure></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="ee08" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">目录:</p><p id="abf5" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><a class="ae ld" href="#c6e8" rel="noopener ugc nofollow">避免CORS错误</a> <br/> ∘ <a class="ae ld" href="#6040" rel="noopener ugc nofollow">使用外部API</a><br/>∘<a class="ae ld" href="#95fa" rel="noopener ugc nofollow">使用代理</a> <br/> <a class="ae ld" href="#9b62" rel="noopener ugc nofollow">显示中等帖子</a> <br/> ∘ <a class="ae ld" href="#ebd9" rel="noopener ugc nofollow">定义路径</a><br/>∘<a class="ae ld" href="#15ac" rel="noopener ugc nofollow">article card . tsx</a><br/>∘<a class="ae ld" href="#e047" rel="noopener ugc nofollow">article card skeleton . tsx</a><br/>∘<a class="ae ld" href="#67d4" rel="noopener ugc nofollow">bloglist . tsx</a><br/>∘<a class="ae ld" href="#45af" rel="noopener ugc nofollow">blog . tst</a></p></div><div class="ab cl jy jz hu ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ij ik il im in"><p id="4e5c" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我的目标是:</p><ul class=""><li id="82b9" class="le lf iq kh b ki kj km kn kq lg ku lh ky li lc lj lk ll lm bi translated">在React应用程序中显示我的中等帖子</li><li id="37ac" class="le lf iq kh b ki ln km lo kq lp ku lq ky lr lc lj lk ll lm bi translated">避免CORS错误</li></ul><h1 id="c6e8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">避免CORS错误</h1><p id="027b" class="pw-post-body-paragraph kf kg iq kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ij bi translated">如果您尝试像这样直接从React应用程序中获取介质数据:</p><pre class="mv mw mx my gt mz na nb bn nc nd bi"><span id="f6e8" class="ne lt iq na b be nf ng l nh ni">useEffect(() =&gt; {<br/>    const fetchStuff = async () =&gt; {<br/>      const resp = await fetch("https://medium.com/@fedor.selenskiy");<br/>      console.log(resp);<br/>    }<br/><br/>    fetchStuff();<br/>  });</span></pre><p id="1569" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">您可能会遇到以下错误:</p><pre class="mv mw mx my gt mz na nb bn nc nd bi"><span id="d1c4" class="ne lt iq na b be nf ng l nj ni">Access to fetch at 'https://medium.com/@fedor.selenskiy' from origin<br/>'http://localhost:3000' has been blocked by CORS policy: <br/>No 'Access-Control-Allow-Origin' header is present on the requested resource. <br/>If an opaque response serves your needs, set the request's <br/>mode to 'no-cors' to fetch the resource with CORS disabled.</span></pre><p id="8b4b" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">对于为什么会发生这种情况，互联网上有许多奇妙的解释，比如在<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSMissingAllowOrigin" rel="noopener ugc nofollow" target="_blank"> MDN Web Docs </a>和<a class="ae ld" href="https://stackoverflow.com/a/20035319" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>上。StackOverflow用户<a class="ae ld" href="https://stackoverflow.com/users/1426743/md-sahib-bin-mahboob" rel="noopener ugc nofollow" target="_blank"> MD. Sahib Bin马布卜</a>非常简洁地解释道:</p><blockquote class="nk"><p id="6350" class="nl nm iq bd nn no np nq nr ns nt lc dk translated">“…[您的请求]与您的页面所在的域不同。所以浏览器屏蔽了……”</p></blockquote><h2 id="6040" class="nu lt iq bd lu nv nw dn ly nx ny dp mc kq nz oa mg ku ob oc mk ky od oe mo of bi translated">使用外部API</h2><p id="084c" class="pw-post-body-paragraph kf kg iq kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ij bi translated">如果你赶时间，不想麻烦手动做事，NoCodeAPI 是一个很好的工具。你也可以使用<a class="ae ld" href="https://rss2json.com/" rel="noopener ugc nofollow" target="_blank"> RSS2JSON </a>，就像Marius Bongarts在他的文章中解释的那样。然而，我喜欢挑战，我更喜欢构建内部解决方案，而不依赖任何外部API！</p><h2 id="95fa" class="nu lt iq bd lu nv og dn ly nx oh dp mc kq oi oa mg ku oj oc mk ky ok oe mo of bi translated">使用代理</h2><p id="8848" class="pw-post-body-paragraph kf kg iq kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ij bi translated">create-react-app文档描述了如何<a class="ae ld" href="https://create-react-app.dev/docs/proxying-api-requests-in-development/" rel="noopener ugc nofollow" target="_blank">设置代理服务器</a>，这正是我们想要的！在这种情况下，我所要做的就是将以下内容添加到<code class="fe ol om on na b">package.json</code>:</p><pre class="mv mw mx my gt mz na nb bn nc nd bi"><span id="c4df" class="ne lt iq na b be nf ng l nh ni">"proxy": "https://medium.com",</span></pre><p id="64b8" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">现在，如果我再次运行前面的<code class="fe ol om on na b">useEffect</code>，它将成功获取数据并将其记录在控制台中:</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/be1dfe6bf75a04b24da30810809c9310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*3cnYERR1Bx6HejzCcuMINg.png"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">使用代理成功地从介质中获取数据</figcaption></figure><h1 id="9b62" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">显示中等帖子</h1><p id="eccd" class="pw-post-body-paragraph kf kg iq kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ij bi translated">在之前的一篇文章中，我描述了在React中获取数据的容器模式是多么有用。在这里，我选择使用它。</p><h2 id="ebd9" class="nu lt iq bd lu nv og dn ly nx oh dp mc kq oi oa mg ku oj oc mk ky ok oe mo of bi translated">定义路径</h2><p id="25b1" class="pw-post-body-paragraph kf kg iq kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ij bi translated">首先，我开始在项目的根目录下定义一个<code class="fe ol om on na b">.env</code>文件中的路径。<strong class="kh ir">请注意</strong>中的<code class="fe ol om on na b">/feed/</code>部分，这将为我们获取文档中描述的<a class="ae ld" href="https://help.medium.com/hc/en-us/articles/214874118-Using-RSS-feeds-of-profiles-publications-and-topics" rel="noopener">给定用户的RSS提要。</a></p><pre class="mv mw mx my gt mz na nb bn nc nd bi"><span id="2a1e" class="ne lt iq na b be nf ng l nj ni">REACT_APP_MEDIUM_PATH="/feed/@fedor.selenskiy"</span></pre><p id="9834" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我这样做的原因是因为路径可能会在未来发生变化，例如，如果我想创建一个不同的媒体博客，而不是当前的博客，或者如果我为它创建一个定制的URL。</p><h2 id="15ac" class="nu lt iq bd lu nv og dn ly nx oh dp mc kq oi oa mg ku oj oc mk ky ok oe mo of bi translated">ArticleCard.tsx</h2><p id="109b" class="pw-post-body-paragraph kf kg iq kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ij bi translated">我从定义<code class="fe ol om on na b">ArticleCard.tsx</code>开始，这是一个用于显示一篇文章的表示组件。</p><pre class="mv mw mx my gt mz na nb bn nc nd bi"><span id="4459" class="ne lt iq na b be nf ng l nh ni">//ArticleCard.tsx<br/>import React from 'react';<br/><br/>import Card from "@mui/material/Card";<br/>import CardContent from "@mui/material/CardContent";<br/>import CardMedia from "@mui/material/CardMedia";<br/>import Typography from "@mui/material/Typography";<br/>import { CardActionArea } from "@mui/material";<br/>import { styled } from "@mui/material/styles";<br/><br/>export type Article = {<br/>  imgUrl?: string;<br/>  title: string;<br/>  readMoreUrl: string;<br/>};<br/><br/>export interface ArticleCardProps {<br/>  article: Article;<br/>}<br/><br/>const ResponsiveCard = styled(Card)(({ theme }) =&gt; ({<br/>  background: "red",<br/>  [theme.breakpoints.up("sm")]: {<br/>    width: 600,<br/>  },<br/>  [theme.breakpoints.down("sm")]: {<br/>    width: "100%",<br/>    minWidth: 300,<br/>    borderRadius: 0,<br/>  },<br/>}));<br/><br/>const ArticleCard = ({ article }: ArticleCardProps) =&gt; (<br/>  &lt;ResponsiveCard&gt;<br/>    &lt;a href={article.readMoreUrl} target="_blank" rel="noreferrer" style={{ textDecoration: "none" }}&gt;<br/>      &lt;CardActionArea style={{ background: "white" }}&gt;<br/>        {article.imgUrl &amp;&amp;<br/>          &lt;CardMedia<br/>            component="img"<br/>            height="160"<br/>            image={article.imgUrl}<br/>            alt="card image"<br/>          /&gt;}<br/>        &lt;CardContent&gt;<br/>          &lt;Typography<br/>            gutterBottom<br/>            variant="h5"<br/>            component="div"<br/>            color="black"<br/>            textAlign="center"<br/>            fontWeight="bold"<br/>          &gt;<br/>            {article.title}<br/>          &lt;/Typography&gt;<br/>        &lt;/CardContent&gt;<br/>      &lt;/CardActionArea&gt;<br/>    &lt;/a&gt;<br/>  &lt;/ResponsiveCard&gt;<br/>);<br/><br/>export default ArticleCard;</span></pre><p id="8e9e" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe ol om on na b">Article</code>类型只包含图片URL(如果有的话)、标题和文章链接。</p><p id="20f7" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe ol om on na b">ArticleCard</code>组件接受一个<code class="fe ol om on na b">Article</code>对象，并在一个<code class="fe ol om on na b">ResponsiveCard</code>中显示图像和标题，这是一个响应型<code class="fe ol om on na b"><a class="ae ld" href="https://mui.com/joy-ui/react-card/#main-content" rel="noopener ugc nofollow" target="_blank">Card</a></code>的<a class="ae ld" href="https://mui.com/" rel="noopener ugc nofollow" target="_blank"> MUI </a>组件。</p><p id="1366" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">为了使整个<code class="fe ol om on na b">Card</code>可点击，我在指向文章的<code class="fe ol om on na b">Card</code>中嵌套了一个<code class="fe ol om on na b">a</code>标签。</p><h2 id="e047" class="nu lt iq bd lu nv og dn ly nx oh dp mc kq oi oa mg ku oj oc mk ky ok oe mo of bi translated">ArticleCardSkeleton.tsx</h2><p id="306f" class="pw-post-body-paragraph kf kg iq kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ij bi translated">为了使UI看起来平滑，并且在文章加载时不会跳跃，我定义了一个<a class="ae ld" href="https://mui.com/material-ui/react-skeleton/#main-content" rel="noopener ugc nofollow" target="_blank">骨架</a>组件，当文章在<code class="fe ol om on na b">ArticleCardSkeleton.tsx</code>中加载时，它将代替文章:</p><pre class="mv mw mx my gt mz na nb bn nc nd bi"><span id="cba2" class="ne lt iq na b be nf ng l nh ni">//ArticleCardSkeleton.tsx<br/>import { styled } from "@mui/material/styles";<br/><br/>import Skeleton, { SkeletonProps } from "@mui/material/Skeleton";<br/><br/>const ResponsiveCardSkeleton = styled(Skeleton)&lt;SkeletonProps&gt;(({ theme }) =&gt; ({<br/>  background: theme.palette.primary.main,<br/>  [theme.breakpoints.up("md")]: {<br/>    height: 320,<br/>    width: 700,<br/>  },<br/>  [theme.breakpoints.down("sm")]: {<br/>    height: 320,<br/>    width: 350,<br/>  },<br/>}));<br/><br/>const ArticleCardSkeleton = () =&gt; (<br/>  &lt;ResponsiveCardSkeleton variant="rectangular" /&gt;<br/>);<br/><br/>export default ArticleCardSkeleton;</span></pre><h2 id="67d4" class="nu lt iq bd lu nv og dn ly nx oh dp mc kq oi oa mg ku oj oc mk ky ok oe mo of bi translated">博客列表</h2><p id="b773" class="pw-post-body-paragraph kf kg iq kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ij bi translated">然后我定义了一个组件，该组件将循环遍历一列<code class="fe ol om on na b">Article</code>组件，并在<code class="fe ol om on na b">BlogList</code>组件中显示它们:</p><pre class="mv mw mx my gt mz na nb bn nc nd bi"><span id="2ae1" class="ne lt iq na b be nf ng l nh ni">//BlogList.tsx<br/>import React, { FC } from "react";<br/><br/>import { Container } from "@mui/material";<br/>import { styled } from "@mui/material/styles";<br/><br/>import { ArticleCard, ArticleCardSkeleton } from "../../components";<br/>import { Article } from "components/article-card/ArticleCard";<br/><br/>const ArticleColumn = styled("div")({<br/>  width: "100%",<br/>  display: "flex",<br/>  flexDirection: "column",<br/>  alignItems: "center",<br/>  "&amp; &gt; :first-child": {<br/>    marginTop: 80,<br/>  },<br/>  "&amp; &gt; *:not(:last-child)": {<br/>    marginBottom: 40,<br/>  },<br/>});<br/><br/>interface BlogListProps {<br/>  articles: Article[];<br/>}<br/><br/>const BlogList: FC&lt;BlogListProps&gt; = ({ articles }) =&gt; {<br/>  return (<br/>    &lt;Container<br/>      sx={{<br/>        display: "flex",<br/>        flexDirection: "column",<br/>        justifyContent: "center",<br/>        width: '100%',<br/>        padding: 0,<br/>      }}<br/>    &gt;<br/>      &lt;ArticleColumn&gt;<br/>        {articles.length === 0 ? (<br/>            &lt;&gt;<br/>              &lt;ArticleCardSkeleton /&gt;<br/>              &lt;ArticleCardSkeleton /&gt;<br/>              &lt;ArticleCardSkeleton /&gt;<br/>              &lt;ArticleCardSkeleton /&gt;<br/>            &lt;/&gt;<br/>          ) : (<br/>            articles.map((article) =&gt; (<br/>              &lt;ArticleCard<br/>                key={article.title}<br/>                article={article}<br/>              /&gt;<br/>            ))<br/>          )<br/>        }<br/>      &lt;/ArticleColumn&gt;<br/>    &lt;/Container&gt;<br/>  );<br/>};<br/><br/>export default BlogList;</span></pre><p id="d771" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">如果商品数组为空，我们显示4个<code class="fe ol om on na b">ArticleCardSkeleton</code>组件。如果数组不为空，我们遍历数组，显示一个<code class="fe ol om on na b">ArticleCard</code>组件，并传递给它<code class="fe ol om on na b">Article</code>对象。</p><p id="d77a" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><code class="fe ol om on na b">ArticleColumn</code> <a class="ae ld" href="https://emotion.sh/docs/styled" rel="noopener ugc nofollow" target="_blank">样式组件</a>仅仅是为了美观，并不是严格必要的。</p><h2 id="45af" class="nu lt iq bd lu nv og dn ly nx oh dp mc kq oi oa mg ku oj oc mk ky ok oe mo of bi translated">Blog.tsx</h2><p id="cc45" class="pw-post-body-paragraph kf kg iq kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ij bi translated">最后但同样重要的是，我们有<code class="fe ol om on na b">Blog</code>组件。所有之前的组件都是表示性组件，仅用于显示数据。这个<code class="fe ol om on na b">Blog</code>组件是容器组件，用于实际获取数据。</p><pre class="mv mw mx my gt mz na nb bn nc nd bi"><span id="c67c" class="ne lt iq na b be nf ng l nh ni">//Blog.tsx<br/>import { useEffect, FC, useState } from "react";<br/><br/>import BlogList from "./BlogList";<br/>import { Article } from "components/article-card/ArticleCard";<br/><br/>const Blog: FC = () =&gt; {<br/>  const [articles, setArticles] = useState&lt;Article[]&gt;([]);<br/><br/>  const mediumUrl = process.env.REACT_APP_MEDIUM_PATH;<br/><br/>  useEffect(() =&gt; {<br/>    const doFetch = async () =&gt; {<br/>      if (!mediumUrl) {<br/>        return<br/>      }<br/><br/>      try {<br/>        const res = await fetch(mediumUrl);<br/>        const xml = await res.text();<br/>        var node = new DOMParser().parseFromString(<br/>          xml,<br/>          "text/xml"<br/>        ).documentElement;<br/>        const articles = node.querySelectorAll("item");<br/><br/>        const loadedArticles: Article[] = [];<br/><br/>        for (let i = 0; i &lt; articles.length; i++) {<br/>          const titleElement = articles[i].querySelector("title");<br/>          if (!titleElement || !titleElement.textContent) {<br/>            continue;<br/>          }<br/><br/>          const title = titleElement.textContent;<br/><br/>          const linkElement = articles[i].querySelector("link");<br/>          if (!linkElement || !linkElement.textContent) {<br/>            continue;<br/>          }<br/><br/>          const readMoreUrl = linkElement.textContent;<br/><br/>          const article: Article = {<br/>            title,<br/>            readMoreUrl: readMoreUrl<br/>          };<br/><br/>          loadedArticles.push(article);<br/><br/>          var encodedContent = articles[i].getElementsByTagNameNS(<br/>            "*",<br/>            "encoded"<br/>          );<br/><br/>          if (!encodedContent || !encodedContent.item(0)) {<br/>            continue;<br/>          }<br/><br/>          var content = encodedContent.item(0);<br/>          if (!content || !content.textContent) {<br/>            continue;<br/>          }<br/><br/>          const parser = new DOMParser();<br/>          const parsedContent = parser.parseFromString(<br/>            content.textContent,<br/>            "text/html"<br/>          );<br/><br/>          const img = parsedContent.querySelector("img");<br/>          if (!img) {<br/>            console.log("no img");<br/>            continue;<br/>          }<br/><br/>          const imgUrl = img.getAttribute("src");<br/>          if (!imgUrl) {<br/>            console.log("no src");<br/>            continue;<br/>          }<br/><br/>          article.imgUrl = imgUrl;<br/>        }<br/><br/>        setArticles(loadedArticles);<br/>      } catch (error) { }<br/>    };<br/><br/>    doFetch();<br/>  }, [mediumUrl]);<br/><br/>  return &lt;BlogList articles={articles} /&gt;;<br/>};<br/><br/>export default Blog;</span></pre><p id="feb6" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">在<code class="fe ol om on na b">Blog</code>组件中，我们只是做了一点网页抓取。</p><p id="8020" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">首先我们定义<code class="fe ol om on na b">articles</code>并将其设置为state。这个变量将保存提取的文章。</p><p id="354d" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">接下来，我们通过调用<code class="fe ol om on na b">process.env.REACT_APP_MEDIUM_PATH</code>从<code class="fe ol om on na b">.env</code>文件中获取<code class="fe ol om on na b">mediumUrl</code>。</p><p id="f694" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">然后我们定义一个<code class="fe ol om on na b">useEffect</code>，所有的魔法都在这里发生。async <code class="fe ol om on na b">doFetch</code>函数检索RSS提要，然后我们可以将其解析为XML(这是因为路径中有前缀<code class="fe ol om on na b">/feed/</code>，它返回XML)。文章都在<code class="fe ol om on na b">item</code>标签中，所以我们可以查询<code class="fe ol om on na b">item</code>标签并遍历它们。</p><p id="e517" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">对于每篇文章，我们可以通过查询<code class="fe ol om on na b">title</code>和<code class="fe ol om on na b">link</code>标签来获得标题和链接，或者如果这些标签不存在，则跳过文章(这是必要的，因为在<code class="fe ol om on na b">Article</code>类型的定义中，<code class="fe ol om on na b">title</code>和<code class="fe ol om on na b">readMoreUrl</code>是必需的)。然后我们创建一个新的<code class="fe ol om on na b">Article</code>，设置它的<code class="fe ol om on na b">title</code>和<code class="fe ol om on na b">readMoreUrl</code>，并把它推到名为<code class="fe ol om on na b">loadedArticles</code>的获取文章列表中。</p><p id="f6dc" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">获取图像有点棘手。我们必须检索编码的内容并将其放入<code class="fe ol om on na b">encodedContent</code>变量中，获取列表中的第一项，并将其解析为HTML。</p><p id="4f01" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">一旦我们得到了<code class="fe ol om on na b">parsedContent</code>变量，那么就只需要查询<code class="fe ol om on na b">img</code>标签，并获得它的<code class="fe ol om on na b">src</code>属性。如果一切顺利，我们就可以更新<code class="fe ol om on na b">article</code> <code class="fe ol om on na b">imgUrl</code>属性了。但是，如果没有图像，它将不会被更新。</p><p id="0f71" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">最后，一旦循环结束，通过调用<code class="fe ol om on na b">setArticles(loadedArticles)</code>设置<code class="fe ol om on na b">articles</code>变量，然后传递给<code class="fe ol om on na b">BlogList</code>组件进行显示。</p><h1 id="2b91" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">演示</h1><p id="43ff" class="pw-post-body-paragraph kf kg iq kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ij bi translated">这是最终产品的简短演示。我降低了网速，这样你就可以看到骨架了。</p><figure class="mv mw mx my gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/306a0d8cf8de82f8df7a0ffc4e01fb57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*-Y-zV8HhjcinuzwciD7KeA.gif"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">演示</figcaption></figure><h1 id="0923" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="e9c9" class="pw-post-body-paragraph kf kg iq kh b ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky mu la lb lc ij bi translated">在本文中，我描述了一种在React项目中集成中型文章的方法，以及如何使用代理来克服CORS错误。</p><p id="4cc3" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">我真的很喜欢这个挑战，我真的希望它能在某个时候帮助到一些人！</p><p id="5f26" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated">来源:</p><p id="05be" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir"> [1]原因:CORS标头“访问控制允许来源”丢失。</strong>【在线】可从以下网址获得:<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSMissingAllowOrigin" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/HTTP/CORS/Errors/CORSMissingAllowOrigin</a></p><p id="2ee8" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir"> [2]“不存在‘访问控制允许来源’”标题—由本·马布卜博士回答。StackOverflow。[在线]可在:<a class="ae ld" href="https://stackoverflow.com/a/20035319" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/20035319</a></strong></p><p id="1064" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">[3]本·马布卜博士。</strong>【在线】见:<a class="ae ld" href="https://stackoverflow.com/users/1426743/md-sahib-bin-mahboob" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/users/1426743/MD-sa Hib-bin-mah boob</a></p><p id="b6b7" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">【4】用React展示你的媒介文章。马里乌斯·邦加茨。[在线]可从以下网址获得:<a class="ae ld" href="https://javascript.plainenglish.io/showcase-your-medium-articles-with-react-20a2a4151091" rel="noopener ugc nofollow" target="_blank">https://JavaScript . plain English . io/showcase-your-medium-articles-with-react-20a2a 4151091</a></strong></p><p id="3127" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">【5】马里乌斯·邦加尔茨。</strong>【在线】可在:<a class="ae ld" href="https://medium.com/@mariusbongarts" rel="noopener">https://medium.com/@mariusbongarts</a></p><p id="38b7" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir"> [6]代理开发中的API请求。</strong>【在线】位于:<a class="ae ld" href="https://create-react-app.dev/docs/proxying-api-requests-in-development/" rel="noopener ugc nofollow" target="_blank">https://create-react-app . dev/docs/proxy ing-API-requests-in-development/</a></p><p id="146f" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir"> [7] React useEffect数据获取模式我希望我能早点知道。</strong>费多尔·塞伦斯基。【在线】可在:<a class="ae ld" rel="noopener ugc nofollow" target="_blank" href="/react-pattern-i-wish-i-knew-sooner-7dbccb3a8b62">https://level up . git connected . com/react-pattern-I-wish-I-know-faster-7 dbccb 3 A8 b 62</a></p><p id="897d" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir"> [8]使用个人资料、出版物和主题的RSS源。</strong>中等。[在线]可从以下网址获得:<a class="ae ld" href="https://help.medium.com/hc/en-us/articles/214874118-Using-RSS-feeds-of-profiles-publications-and-topics" rel="noopener">https://help . medium . com/HC/en-us/articles/214874118-Using-RSS-feeds-of-profiles-publications-and-topics</a></p><p id="acc3" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">【9】梅姐。</strong>【在线】可在:<a class="ae ld" href="https://mui.com/" rel="noopener ugc nofollow" target="_blank">https://mui.com/</a></p><p id="5bfb" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">【10】MUI卡文档。</strong>【在线】可在:<a class="ae ld" href="https://mui.com/joy-ui/react-card/#main-content" rel="noopener ugc nofollow" target="_blank">https://mui.com/joy-ui/react-card/#main-content</a></p><p id="553e" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir"> [11] MUI框架文档。</strong>【在线】可在:<a class="ae ld" href="https://mui.com/material-ui/react-skeleton/#main-content" rel="noopener ugc nofollow" target="_blank">https://mui.com/joy-ui/react-card/#main-content</a></p><p id="1994" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">【12】情感。</strong>风格化的组件。[在线]可在:<a class="ae ld" href="https://emotion.sh/docs/styled" rel="noopener ugc nofollow" target="_blank">https://emotion.sh/docs/styled</a>找到</p><p id="b74f" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">【13】RSS 2 JSON。</strong>【在线】可在:<a class="ae ld" href="https://rss2json.com/" rel="noopener ugc nofollow" target="_blank">https://rss2json.com/</a></p><p id="a575" class="pw-post-body-paragraph kf kg iq kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ij bi translated"><strong class="kh ir">【14】NoCodeAPI。</strong>【在线】可在:<a class="ae ld" href="https://nocodeapi.com/" rel="noopener ugc nofollow" target="_blank">https://nocodeapi.com/</a></p></div></div>    
</body>
</html>