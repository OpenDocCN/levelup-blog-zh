<html>
<head>
<title>Speeding up Linux disk encryption</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速Linux磁盘加密</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/speeding-up-linux-disk-encryption-5c56491201b2?source=collection_archive---------16-----------------------#2020-04-17">https://levelup.gitconnected.com/speeding-up-linux-disk-encryption-5c56491201b2?source=collection_archive---------16-----------------------#2020-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5a75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">原载于2020年3月25日https://blog.cloudflare.com</em><a class="ae km" href="https://blog.cloudflare.com/speeding-up-linux-disk-encryption/" rel="noopener ugc nofollow" target="_blank"><em class="kl"/></a><em class="kl">。</em></p><p id="d526" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">静态数据加密是任何现代互联网公司的必备工具。然而，许多公司不加密他们的磁盘，因为他们担心加密开销会导致潜在的性能损失。</p><p id="3c8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">加密静态数据对于Cloudflare至关重要，因为cloud flare在全球有<a class="ae km" href="https://www.cloudflare.com/network/" rel="noopener ugc nofollow" target="_blank">200多个数据中心</a>。在本帖中，我们将调查Linux上磁盘加密的性能，并解释我们如何为我们自己和我们的客户使它至少快两倍！</p><h2 id="e0fa" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">加密静态数据</h2><p id="b81c" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">说到加密静态数据，有几种方法可以在现代操作系统(OS)上实施。可用的技术与典型的操作系统存储堆栈紧密结合。存储堆栈和加密解决方案的简化版本可以在下图中找到:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/ae0d022d51561547ec0e812e4c7166a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*osyHJmJ-JJ49OhaL.png"/></div></div></figure><p id="9e05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">栈顶是应用程序，它在文件(或流)中读写数据。OS内核中的文件系统跟踪底层块设备的哪些块属于哪些文件，并将这些文件读取和写入转换成块读取和写入，然而底层存储设备的硬件细节从文件系统中抽象出来。最后，数据块子系统实际上使用适当的设备驱动程序将数据块读写传递给底层硬件。</p><p id="442d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">存储堆栈的概念实际上类似于<a class="ae km" href="https://www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi/" rel="noopener ugc nofollow" target="_blank">众所周知的网络OSI模型</a>，其中每一层都有一个更高层次的信息视图，较低层的实施细节从较高层中抽象出来。而且，类似于OSI模型，人们可以在不同的层应用加密(想想<a class="ae km" href="https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/" rel="noopener ugc nofollow" target="_blank"> TLS </a> vs <a class="ae km" href="https://en.wikipedia.org/wiki/IPsec" rel="noopener ugc nofollow" target="_blank"> IPsec </a>或<a class="ae km" href="https://www.cloudflare.com/learning/access-management/what-is-a-vpn/" rel="noopener ugc nofollow" target="_blank">VPN</a>)。</p><p id="e9a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于静态数据，我们可以在数据块层(硬件或软件)或文件级(直接在应用程序或文件系统中)应用加密。</p><h2 id="cdf0" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">块与文件加密</h2><p id="c8e6" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">一般来说，我们应用加密的级别越高，我们拥有的灵活性就越大。有了应用程序级加密，应用程序维护人员可以将他们喜欢的任何加密代码应用于他们需要的任何特定数据。这种方法的缺点是他们实际上必须自己实现它，并且加密通常对开发人员来说不是很友好:人们必须知道特定加密算法的详细情况，正确地生成密钥、随机数、iv等。此外，应用级加密没有利用操作系统级缓存，尤其是<a class="ae km" href="https://en.wikipedia.org/wiki/Page_cache" rel="noopener ugc nofollow" target="_blank"> Linux页面缓存</a>:每次应用需要使用数据时，它必须再次解密数据，浪费CPU周期，或者实现自己的解密“缓存”,这给代码带来了更多的复杂性。</p><p id="7b28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文件系统级加密使数据加密对应用程序透明，因为文件系统本身会在将数据传递给数据块子系统之前对数据进行加密，因此无论应用程序是否支持加密，文件都会被加密。此外，可以将文件系统配置为只加密特定的目录，或者为不同的文件使用不同的密钥。然而，这种灵活性是以更复杂的配置为代价的。文件系统加密也被认为不如块设备加密安全，因为只有文件的内容被加密。文件也有相关的元数据，如文件大小、文件数量、目录树布局等。这对于潜在的对手仍然是可见的。</p><p id="8c0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据块层的加密(通常称为<a class="ae km" href="https://en.wikipedia.org/wiki/Disk_encryption" rel="noopener ugc nofollow" target="_blank">磁盘加密</a>或全磁盘加密)也使数据加密对应用程序甚至整个文件系统透明。与文件系统级加密不同，它加密磁盘上的所有数据，包括文件元数据甚至可用空间。但是它的灵活性较差——一个人只能用一个密钥加密整个磁盘，因此没有针对每个目录、每个文件或每个用户的配置。从加密的角度来看，并不是所有的加密算法都可以使用，因为数据块层不再具有数据的高级概览，因此它需要独立处理每个数据块。大多数<a class="ae km" href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Common_modes" rel="noopener ugc nofollow" target="_blank">通用算法需要某种块链接</a>来保证安全，所以不适用于磁盘加密。相反，<a class="ae km" href="https://en.wikipedia.org/wiki/Disk_encryption_theory#Block_cipher-based_modes" rel="noopener ugc nofollow" target="_blank">专门为这一特定用例开发了特殊模式</a>。</p><p id="5dd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么选择哪一层呢？一如既往，视情况而定…由于灵活性，应用程序和文件系统级加密通常是客户端系统的首选。例如，多用户桌面上的每个用户可能希望用他们自己的密钥加密他们的主目录，而不加密某些共享目录。相反，在由SaaS/PaaS/IaaS公司(包括Cloudflare)管理的服务器系统上，首选是配置简单性和安全性—通过启用全磁盘加密，来自任何应用程序的任何数据都会自动加密，没有例外或覆盖。我们认为，所有数据都需要得到保护，而不需要将其分类到“重要”或“不重要”的存储桶中，因此不需要上层提供的选择性灵活性。</p><h2 id="3a2f" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">硬件与软件磁盘加密</h2><p id="e23b" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">在块层加密数据时，如果硬件<a class="ae km" href="https://en.wikipedia.org/wiki/Hardware-based_full_disk_encryption" rel="noopener ugc nofollow" target="_blank">支持</a>，可以直接在存储硬件中加密。这样做通常会提供更好的读/写性能，并消耗更少的主机资源。然而，由于大多数硬件固件都是专有的，因此它没有受到安全社区的关注和审查。在过去，这导致了硬盘加密的一些实现中的<a class="ae km" href="https://www.us-cert.gov/ncas/current-activity/2018/11/06/Self-Encrypting-Solid-State-Drive-Vulnerabilities" rel="noopener ugc nofollow" target="_blank">缺陷</a>，这使得整个安全模型变得无用。例如，微软<a class="ae km" href="https://support.microsoft.com/en-us/help/4516071/windows-10-update-kb4516071" rel="noopener ugc nofollow" target="_blank">从那时起开始偏爱基于软件的磁盘加密</a>。</p><p id="cfcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不想让我们的数据和客户的数据面临使用潜在不安全解决方案的风险，我们<a class="ae km" href="https://blog.cloudflare.com/helping-to-build-cloudflare-part-4/" rel="noopener ugc nofollow" target="_blank">坚信开源</a>。这就是为什么我们只依赖Linux内核中的软件磁盘加密，它是开放的，并且已经过世界各地许多安全专家的审核。</p><h2 id="3871" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">Linux磁盘加密性能</h2><p id="00a0" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">我们的目标不仅是为我们的客户节省带宽成本，而且尽可能快地向互联网用户提供内容。</p><p id="22ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一次，我们注意到我们的磁盘没有我们希望的那么快。一些分析和快速A/B测试指向了Linux磁盘加密。因为不加密数据(即使它应该是一个公共的互联网缓存)不是一个可持续的选择，我们决定进一步研究Linux磁盘加密性能。</p><h2 id="0851" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">设备映射和dm-crypt</h2><p id="0aaa" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">Linux通过一个<a class="ae km" href="https://en.wikipedia.org/wiki/Dm-crypt" rel="noopener ugc nofollow" target="_blank"> dm-crypt模块</a>实现透明磁盘加密，而<code class="fe lx ly lz ma b">dm-crypt</code>本身是<a class="ae km" href="https://en.wikipedia.org/wiki/Device_mapper" rel="noopener ugc nofollow" target="_blank">设备映射器</a>内核框架的一部分。简而言之，当IO请求在文件系统和底层块设备之间传输时，设备映射器允许预处理/后处理IO请求。</p><p id="3d00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz ma b">dm-crypt</code>特别是在将“写”IO请求进一步发送到实际的块设备之前对其进行加密，在将“读”IO请求发送到文件系统驱动程序之前对其进行解密。简单易行！或者是？</p><h2 id="1946" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">基准设置</h2><p id="e0b6" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">根据记录，本文中的数字是通过在停产的闲置<a class="ae km" href="https://blog.cloudflare.com/a-tour-inside-cloudflares-g9-servers/" rel="noopener ugc nofollow" target="_blank"> Cloudflare G9服务器</a>上运行指定命令获得的。但是，该设置应该可以在任何现代x86笔记本电脑上轻松重现。</p><p id="3cdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，由于存储硬件本身引入的噪声，围绕存储堆栈的任何基准测试都很困难。不是所有的磁盘都是一样的，所以在这篇文章中，我们将使用最快的磁盘，也就是没有磁盘。</p><p id="a050" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，Linux有一个选项可以直接在RAM中模拟一个磁盘。由于RAM比任何持久存储快得多，它应该不会给我们的结果带来什么偏差。</p><p id="8ac8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下命令创建4GB内存磁盘:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="426a" class="kn ko iq ma b gy mf mg l mh mi">$ sudo modprobe brd rd_nr=1 rd_size=4194304<br/>$ ls /dev/ram0</span></pre><p id="bc76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以在它的基础上建立一个<code class="fe lx ly lz ma b">dm-crypt</code>实例，从而为磁盘启用加密。首先，我们需要生成磁盘加密密钥，“格式化”磁盘并指定一个密码来解锁新生成的密钥。</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="a062" class="kn ko iq ma b gy mf mg l mh mi">$ fallocate -l 2M crypthdr.img<br/>$ sudo cryptsetup luksFormat /dev/ram0 --header crypthdr.img<br/><br/>WARNING!<br/>========<br/>This will overwrite data on crypthdr.img irrevocably.<br/><br/>Are you sure? (Type uppercase yes): YES<br/>Enter passphrase:<br/>Verify passphrase:</span></pre><p id="6075" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">熟悉<code class="fe lx ly lz ma b">LUKS/dm-crypt</code>的人可能已经注意到我们在这里使用了一个<a class="ae km" href="http://man7.org/linux/man-pages/man8/cryptsetup.8.html" rel="noopener ugc nofollow" target="_blank"> LUKS分离式头球</a>。通常，LUKS将密码加密的磁盘加密密钥与数据存储在同一个磁盘上，但是由于我们想要比较加密和未加密设备之间的读/写性能，我们可能会在稍后的基准测试中意外覆盖加密的密钥。出于本文的目的，将加密密钥保存在单独的文件中可以避免这个问题。</p><p id="a149" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们实际上可以“解锁”加密设备以进行测试:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="0cf0" class="kn ko iq ma b gy mf mg l mh mi">$ sudo cryptsetup open --header crypthdr.img /dev/ram0 encrypted-ram0<br/>Enter passphrase for /dev/ram0:<br/>$ ls /dev/mapper/encrypted-ram0<br/>/dev/mapper/encrypted-ram0</span></pre><p id="4355" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们现在可以比较加密和未加密ramdisk的性能:如果我们向<code class="fe lx ly lz ma b">/dev/ram0</code>读取/写入数据，它将存储在<a class="ae km" href="https://en.wikipedia.org/wiki/Plaintext" rel="noopener ugc nofollow" target="_blank">明文</a>中。同样，如果我们向<code class="fe lx ly lz ma b">/dev/mapper/encrypted-ram0</code>读/写数据，它会在途中被<code class="fe lx ly lz ma b">dm-crypt</code>解密/加密，并存储在<a class="ae km" href="https://en.wikipedia.org/wiki/Ciphertext" rel="noopener ugc nofollow" target="_blank">密文</a>中。</p><p id="7532" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，我们没有在数据块设备上创建任何文件系统，以避免因文件系统开销而导致结果偏差。</p><h2 id="e2a7" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">测量吞吐量</h2><p id="5233" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">说到存储测试/基准测试<a class="ae km" href="https://fio.readthedocs.io/en/latest/fio_doc.html" rel="noopener ugc nofollow" target="_blank">灵活的I/O测试器</a>是常用的解决方案。让我们在未加密的ramdisk上用4K块大小模拟简单的顺序读/写负载:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="41d4" class="kn ko iq ma b gy mf mg l mh mi">$ sudo fio --filename=/dev/ram0 --readwrite=readwrite --bs=4k --direct=1 --loops=1000000 --name=plain<br/>plain: (g=0): rw=rw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1<br/>fio-2.16<br/>Starting 1 process<br/>...<br/>Run status group 0 (all jobs):<br/>   READ: io=21013MB, aggrb=1126.5MB/s, minb=1126.5MB/s, maxb=1126.5MB/s, mint=18655msec, maxt=18655msec<br/>  WRITE: io=21023MB, aggrb=1126.1MB/s, minb=1126.1MB/s, maxb=1126.1MB/s, mint=18655msec, maxt=18655msec<br/><br/>Disk stats (read/write):<br/>  ram0: ios=0/0, merge=0/0, ticks=0/0, in_queue=0, util=0.00%</span></pre><p id="d346" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的命令会运行很长时间，所以我们过一会儿就停止它。正如我们从统计数据中看到的，我们能够在大约<code class="fe lx ly lz ma b">1126 MB/s</code>的时候以大致相同的吞吐量进行读写。让我们用加密的ramdisk重复测试:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="a542" class="kn ko iq ma b gy mf mg l mh mi">$ sudo fio --filename=/dev/mapper/encrypted-ram0 --readwrite=readwrite --bs=4k --direct=1 --loops=1000000 --name=crypt<br/>crypt: (g=0): rw=rw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1<br/>fio-2.16<br/>Starting 1 process<br/>...<br/>Run status group 0 (all jobs):<br/>   READ: io=1693.7MB, aggrb=150874KB/s, minb=150874KB/s, maxb=150874KB/s, mint=11491msec, maxt=11491msec<br/>  WRITE: io=1696.4MB, aggrb=151170KB/s, minb=151170KB/s, maxb=151170KB/s, mint=11491msec, maxt=11491msec</span></pre><p id="ffff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哇，那是一滴！我们现在只得到<code class="fe lx ly lz ma b">~147 MB/s</code>，慢了7倍多！这是在一台完全闲置的机器上！</p><h2 id="3b74" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">也许，加密就是慢</h2><p id="eed3" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">我们首先考虑的是确保我们使用最快的密码。<code class="fe lx ly lz ma b">cryptsetup</code>允许我们对系统上所有可用的加密实施进行基准测试，以选择最佳实施:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="6e7e" class="kn ko iq ma b gy mf mg l mh mi">$ sudo cryptsetup benchmark<br/># Tests are approximate using memory only (no storage IO).<br/>PBKDF2-sha1      1340890 iterations per second for 256-bit key<br/>PBKDF2-sha256    1539759 iterations per second for 256-bit key<br/>PBKDF2-sha512    1205259 iterations per second for 256-bit key<br/>PBKDF2-ripemd160  967321 iterations per second for 256-bit key<br/>PBKDF2-whirlpool  720175 iterations per second for 256-bit key<br/>#  Algorithm | Key |  Encryption |  Decryption<br/>     aes-cbc   128b   969.7 MiB/s  3110.0 MiB/s<br/> serpent-cbc   128b           N/A           N/A<br/> twofish-cbc   128b           N/A           N/A<br/>     aes-cbc   256b   756.1 MiB/s  2474.7 MiB/s<br/> serpent-cbc   256b           N/A           N/A<br/> twofish-cbc   256b           N/A           N/A<br/>     aes-xts   256b  1823.1 MiB/s  1900.3 MiB/s<br/> serpent-xts   256b           N/A           N/A<br/> twofish-xts   256b           N/A           N/A<br/>     aes-xts   512b  1724.4 MiB/s  1765.8 MiB/s<br/> serpent-xts   512b           N/A           N/A<br/> twofish-xts   512b           N/A           N/A</span></pre><p id="821e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看来<code class="fe lx ly lz ma b">aes-xts</code>用256位数据加密密钥是这里最快的。但是我们实际上是用哪一个来加密ramdisk呢？</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="ee2a" class="kn ko iq ma b gy mf mg l mh mi">$ sudo dmsetup table /dev/mapper/encrypted-ram0<br/>0 8388608 crypt aes-xts-plain64 0000000000000000000000000000000000000000000000000000000000000000 0 1:0 0</span></pre><p id="5203" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用带有256位数据加密密钥的<code class="fe lx ly lz ma b">aes-xts</code>(计算所有被<code class="fe lx ly lz ma b">dmsetup</code>工具方便地屏蔽的零——如果你想看到实际的字节，在上面的命令中添加<code class="fe lx ly lz ma b">--showkeys</code>选项)。然而，这些数字并没有加起来:<code class="fe lx ly lz ma b">cryptsetup benchmark</code>告诉我们不要依赖上面的结果，因为“仅使用内存(没有存储IO)的测试是近似的”，但这正是我们如何使用ramdisk设置我们的实验。在某种程度上更糟糕的情况下(假设我们读取所有数据，然后在没有并行性的情况下顺序加密/解密)，进行<a class="ae km" href="https://en.wikipedia.org/wiki/Back-of-the-envelope_calculation" rel="noopener ugc nofollow" target="_blank">粗略计算</a>时，我们应该避开<code class="fe lx ly lz ma b">(1126 * 1823) / (1126 + 1823) =~696 MB/s</code>，这仍然与实际的<code class="fe lx ly lz ma b">147 * 2 = 294 MB/s</code>(读写总数)相差甚远。</p><h2 id="658f" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">DM-加密性能标志</h2><p id="b270" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">在阅读<a class="ae km" href="http://man7.org/linux/man-pages/man8/cryptsetup.8.html" rel="noopener ugc nofollow" target="_blank"> cryptsetup手册页</a>时，我们注意到它有两个前缀为<code class="fe lx ly lz ma b">--perf-</code>的选项，这可能与性能调优有关。第一个是<code class="fe lx ly lz ma b">--perf-same_cpu_crypt</code>，描述相当隐晦:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="ad0c" class="kn ko iq ma b gy mf mg l mh mi">Perform encryption using the same cpu that IO was submitted on.  The default is to use an unbound workqueue so that encryption work is automatically balanced between available CPUs.  This option is only relevant for open action.</span></pre><p id="49d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们启用了这个选项</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="98d5" class="kn ko iq ma b gy mf mg l mh mi">$ sudo cryptsetup close encrypted-ram0<br/>$ sudo cryptsetup open --header crypthdr.img --perf-same_cpu_crypt /dev/ram0 encrypted-ram0</span></pre><p id="0d1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注:根据<a class="ae km" href="http://man7.org/linux/man-pages/man8/cryptsetup.8.html" rel="noopener ugc nofollow" target="_blank">最新手册页</a>，还有一个<code class="fe lx ly lz ma b">cryptsetup refresh</code>命令，可用于启用这些选项，而不必“关闭”和“重新打开”加密设备。然而我们的<code class="fe lx ly lz ma b">cryptsetup</code>还不支持它。</p><p id="b227" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">验证选项是否已真正启用:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="47c3" class="kn ko iq ma b gy mf mg l mh mi">$ sudo dmsetup table encrypted-ram0<br/>0 8388608 crypt aes-xts-plain64 0000000000000000000000000000000000000000000000000000000000000000 0 1:0 0 1 same_cpu_crypt</span></pre><p id="055f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，我们现在可以在输出中看到<code class="fe lx ly lz ma b">same_cpu_crypt</code>，这正是我们想要的。让我们重新运行基准测试:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="6bb3" class="kn ko iq ma b gy mf mg l mh mi">$ sudo fio --filename=/dev/mapper/encrypted-ram0 --readwrite=readwrite --bs=4k --direct=1 --loops=1000000 --name=crypt<br/>crypt: (g=0): rw=rw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1<br/>fio-2.16<br/>Starting 1 process<br/>...<br/>Run status group 0 (all jobs):<br/>   READ: io=1596.6MB, aggrb=139811KB/s, minb=139811KB/s, maxb=139811KB/s, mint=11693msec, maxt=11693msec<br/>  WRITE: io=1600.9MB, aggrb=140192KB/s, minb=140192KB/s, maxb=140192KB/s, mint=11693msec, maxt=11693msec</span></pre><p id="56c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，现在是<code class="fe lx ly lz ma b">~136 MB/s</code>比以前稍微差一点，所以不行。第二个选项<code class="fe lx ly lz ma b">--perf-submit_from_crypt_cpus</code>怎么样:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="3a53" class="kn ko iq ma b gy mf mg l mh mi">Disable offloading writes to a separate thread after encryption.  There are some situations where offloading write bios from the encryption threads to a single thread degrades performance significantly.  The default is to offload write bios to the same thread.  This option is only relevant for open action.</span></pre><p id="41bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也许，我们正处于这里的“某种情况”,所以让我们试一试:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="9ed3" class="kn ko iq ma b gy mf mg l mh mi">$ sudo cryptsetup close encrypted-ram0<br/>$ sudo cryptsetup open --header crypthdr.img --perf-submit_from_crypt_cpus /dev/ram0 encrypted-ram0<br/>Enter passphrase for /dev/ram0:<br/>$ sudo dmsetup table encrypted-ram0<br/>0 8388608 crypt aes-xts-plain64 0000000000000000000000000000000000000000000000000000000000000000 0 1:0 0 1 submit_from_crypt_cpus</span></pre><p id="01ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是基准测试:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="cc1b" class="kn ko iq ma b gy mf mg l mh mi">$ sudo fio --filename=/dev/mapper/encrypted-ram0 --readwrite=readwrite --bs=4k --direct=1 --loops=1000000 --name=crypt<br/>crypt: (g=0): rw=rw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1<br/>fio-2.16<br/>Starting 1 process<br/>...<br/>Run status group 0 (all jobs):<br/>   READ: io=2066.6MB, aggrb=169835KB/s, minb=169835KB/s, maxb=169835KB/s, mint=12457msec, maxt=12457msec<br/>  WRITE: io=2067.7MB, aggrb=169965KB/s, minb=169965KB/s, maxb=169965KB/s, mint=12457msec, maxt=12457msec</span></pre><p id="a821" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz ma b">~166 MB/s</code>，好一点了，但还是不好...</p><h2 id="70e4" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">询问社区</h2><p id="32a7" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">绝望的我们决定从互联网上寻求支持，<a class="ae km" href="https://www.spinics.net/lists/dm-crypt/msg07516.html" rel="noopener ugc nofollow" target="_blank">将我们的发现发布到了</a> <code class="fe lx ly lz ma b"><a class="ae km" href="https://www.spinics.net/lists/dm-crypt/msg07516.html" rel="noopener ugc nofollow" target="_blank">dm-crypt</a></code> <a class="ae km" href="https://www.spinics.net/lists/dm-crypt/msg07516.html" rel="noopener ugc nofollow" target="_blank">邮件列表</a>，但是我们得到的回应并不令人鼓舞:</p><blockquote class="mj mk ml"><p id="57e9" class="jn jo kl jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">如果这些数字让你感到不安，那么这是因为你缺乏理解。您可能没有意识到加密是一项繁重的操作…</p></blockquote><p id="a36c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们决定通过在谷歌搜索中键入“加密昂贵吗”来对此主题进行科学研究，其中一个顶级结果(实际上包含有意义的测量)是… <a class="ae km" href="https://blog.cloudflare.com/how-expensive-is-crypto-anyway/" rel="noopener ugc nofollow" target="_blank">我们自己关于加密成本</a>的帖子，但在<a class="ae km" href="https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/" rel="noopener ugc nofollow" target="_blank"> TLS </a>的上下文中！这本身就是一个引人入胜的阅读，但要点是:现代硬件上的现代加密即使在Cloudflare规模上也非常便宜(每秒处理数百万个加密的HTTP请求)。事实上，它非常便宜，以至于Cloudflare是第一个为每个人提供免费SSL/TLS的提供商。</p><h2 id="fc73" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">深入研究源代码</h2><p id="bef1" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">当试图使用上面描述的自定义<code class="fe lx ly lz ma b">dm-crypt</code>选项时，我们很好奇为什么它们会首先存在，以及“卸载”是什么意思。最初我们期望<code class="fe lx ly lz ma b">dm-crypt</code>是一个简单的“代理”,它只是在数据流经堆栈时对数据进行加密/解密。原来<code class="fe lx ly lz ma b">dm-crypt</code>不仅仅是加密内存缓冲区，下面给出了一个(简化的)IO遍历路径图:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mp"><img src="../Images/b9e2ab36888ed09cd6b844e1a5154676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XW6IFlIb56lbLO0z.png"/></div></div></figure><p id="c977" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当文件系统发出一个写请求时，<code class="fe lx ly lz ma b">dm-crypt</code>并不立即处理它——而是把它放到一个名为“kcryptd”的<a class="ae km" href="https://www.kernel.org/doc/html/v4.19/core-api/workqueue.html" rel="noopener ugc nofollow" target="_blank">工作队列</a> <a class="ae km" href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L3124" rel="noopener ugc nofollow" target="_blank">中。简而言之，内核工作队列只是安排一些工作(在本例中是加密)在以后更方便的时候执行。当“时机”到来时，<code class="fe lx ly lz ma b">dm-crypt</code> </a><a class="ae km" href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1940" rel="noopener ugc nofollow" target="_blank">向</a><a class="ae km" href="https://www.kernel.org/doc/html/v4.19/crypto/index.html" rel="noopener ugc nofollow" target="_blank"> Linux Crypto API </a>发送请求进行实际加密。然而，现代Linux Crypto API <a class="ae km" href="https://www.kernel.org/doc/html/v4.19/crypto/api-skcipher.html#symmetric-key-cipher-api" rel="noopener ugc nofollow" target="_blank">也是异步的</a>，所以根据您的系统将使用的特定实现，很可能不会立即处理它，而是再次排队等待“以后的时间”。当Linux Crypto API最终<a class="ae km" href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1980" rel="noopener ugc nofollow" target="_blank">进行加密</a>时，<code class="fe lx ly lz ma b">dm-crypt</code>可能会尝试<a class="ae km" href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1909-L1910" rel="noopener ugc nofollow" target="_blank">通过将每个请求</a>放入<a class="ae km" href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree" rel="noopener ugc nofollow" target="_blank">红黑树</a>来对未决的写请求进行排序。然后一个<a class="ae km" href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1819" rel="noopener ugc nofollow" target="_blank">单独的内核线程</a>再次在“一段时间后”实际上获取树中的所有IO请求，并且<a class="ae km" href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1864" rel="noopener ugc nofollow" target="_blank">将它们发送到堆栈</a>。</p><p id="28bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在对于读取请求:这一次我们需要首先从硬件获取加密的数据，但是<code class="fe lx ly lz ma b">dm-crypt</code>并不只是向驱动程序请求数据，而是将请求排队到另一个名为“kcryptd _ io”的<a class="ae km" href="https://www.kernel.org/doc/html/v4.19/core-api/workqueue.html" rel="noopener ugc nofollow" target="_blank">工作队列</a> <a class="ae km" href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L3122" rel="noopener ugc nofollow" target="_blank">中。在稍后的某个时刻，当我们实际拥有加密的数据时，我们</a><a class="ae km" href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1742" rel="noopener ugc nofollow" target="_blank">使用现在熟悉的“kcryptd”工作队列来调度它进行解密</a>。“kcryptd”<a class="ae km" href="https://github.com/torvalds/linux/blob/0d81a3f29c0afb18ba2b1275dcccf21e0dd4da38/drivers/md/dm-crypt.c#L1970" rel="noopener ugc nofollow" target="_blank">将请求</a>发送到Linux Crypto API，它也可以异步解密数据。</p><p id="5b14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">公平地说，请求并不总是遍历所有这些队列，但这里重要的一点是，写请求在<code class="fe lx ly lz ma b">dm-crypt</code>中最多可以排队4次，读请求最多可以排队3次。此时，我们想知道所有这些额外的排队是否会导致任何性能问题。例如，Google 有一个关于排队和尾部延迟之间关系的<a class="ae km" href="https://www.usenix.org/conference/srecon19asia/presentation/plenz" rel="noopener ugc nofollow" target="_blank">不错的演示。本演示的一个关键要点是:</a></p><blockquote class="mj mk ml"><p id="a4ab" class="jn jo kl jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">大量的尾部延迟是由排队效应引起的</p></blockquote><p id="f667" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，为什么会有这些队列，我们能消除它们吗？</p><h2 id="a68d" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">Git考古学</h2><p id="f3b1" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">没有人会为了好玩而编写更复杂的代码，尤其是对于操作系统内核。所以所有这些队列放在那里肯定是有原因的。幸运的是，Linux内核源代码是由<a class="ae km" href="https://en.wikipedia.org/wiki/Git" rel="noopener ugc nofollow" target="_blank"> git </a>管理的，所以我们可以试着追溯变化和围绕它们的决策。</p><p id="9546" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“kcryptd”工作队列从可用历史开始就在源<a class="ae km" href="https://github.com/torvalds/linux/blob/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2/drivers/md/dm-crypt.c" rel="noopener ugc nofollow" target="_blank">中，并带有以下注释:</a></p><blockquote class="mj mk ml"><p id="c916" class="jn jo kl jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">之所以需要，是因为在中断上下文中进行解密是非常不明智的，所以从读取请求返回的bios会在这里排队。</p></blockquote><p id="07fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以它只用于读取，但即使如此，如果Linux Crypto API无论如何都可能使用专用的线程/队列进行加密，我们为什么还要关心它是否是中断上下文呢？好吧，回到2005年，Crypto API <a class="ae km" href="https://github.com/torvalds/linux/blob/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2/Documentation/crypto/api-intro.txt" rel="noopener ugc nofollow" target="_blank">不是异步的</a>，所以这很有意义。</p><p id="7494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2006年<code class="fe lx ly lz ma b">dm-crypt</code> <a class="ae km" href="https://github.com/torvalds/linux/commit/23541d2d288cdb54f417ba1001dacc7f3ea10a97" rel="noopener ugc nofollow" target="_blank">开始使用</a>的“kcryptd”工作队列，不仅用于加密，还用于提交IO请求:</p><blockquote class="mj mk ml"><p id="6a15" class="jn jo kl jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">此修补程序旨在帮助dm-crypt遵守以下修补程序在-mm中施加的新约束:MD-DM-reduce-stack-usage-with-stacked-block-devices . patch</p></blockquote><p id="4797" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的目标似乎不是增加更多的并发性，而是减少内核堆栈的使用，这也是有意义的，因为内核在所有代码中都有一个公共的堆栈，所以这是一个非常有限的资源。然而，值得注意的是，<a class="ae km" href="https://github.com/torvalds/linux/commit/6538b8ea886e472f4431db8ca1d60478f838d14b" rel="noopener ugc nofollow" target="_blank"> Linux内核堆栈已经在2014年针对x86平台进行了扩展</a>，因此这可能不再是一个问题。</p><p id="7e8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“kcryptd_io”工作队列的第一个版本是在2007年添加的<a class="ae km" href="https://github.com/torvalds/linux/commit/cabf08e4d3d1181d7c408edae97fb4d1c31518af" rel="noopener ugc nofollow" target="_blank">，目的是避免:</a></p><blockquote class="mj mk ml"><p id="e3e3" class="jn jo kl jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">等待内存分配的许多请求导致的饥饿…</p></blockquote><p id="4dee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请求处理在单个工作队列上遇到瓶颈，因此解决方案是添加另一个工作队列。有道理。</p><p id="1b71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们肯定不是第一个因为大量排队而经历性能下降的人:2011年引入了一个变化，即<a class="ae km" href="https://github.com/torvalds/linux/commit/20c82538e4f5ede51bc2b4795bc6e5cae772796d" rel="noopener ugc nofollow" target="_blank">有条件地恢复一些读取请求的排队</a>:</p><blockquote class="mj mk ml"><p id="98c8" class="jn jo kl jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">如果有足够的内存，代码可以直接提交bio，而不是在单独的线程中排队该操作。</p></blockquote><p id="bd18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，那时的Linux内核提交消息不像现在这样详细，所以没有可用的性能数据。</p><p id="87bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在2015年<a class="ae km" href="https://github.com/torvalds/linux/commit/dc2676210c425ee8e5cb1bec5bc84d004ddf4179" rel="noopener ugc nofollow" target="_blank"> dm-crypt开始在单独的“dmcrypt_write”线程中对写操作</a>进行排序，然后将它们发送到堆栈中:</p><blockquote class="mj mk ml"><p id="08e2" class="jn jo kl jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">在多处理器计算机上，加密请求的完成顺序与提交顺序不同。因此，写请求将以不同的顺序提交，这可能会导致严重的性能下降。</p></blockquote><p id="53d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这确实有意义，因为顺序磁盘访问曾经比随机磁盘访问快得多，而<code class="fe lx ly lz ma b">dm-crypt</code>正在打破这种模式。但这主要适用于2015年仍占主导地位的<a class="ae km" href="https://en.wikipedia.org/wiki/Hard_disk_drive" rel="noopener ugc nofollow" target="_blank">旋转圆盘</a>。它可能没有现代的快速固态硬盘<a class="ae km" href="https://en.wikipedia.org/wiki/Solid-state_drive" rel="noopener ugc nofollow" target="_blank">(包括NVME固态硬盘)</a>重要。</p><p id="f0b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提交消息的另一部分值得一提:</p><blockquote class="mj mk ml"><p id="8008" class="jn jo kl jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">…特别是它使像CFQ这样的IO调度程序能够更有效地排序…</p></blockquote><p id="8b78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它提到了<a class="ae km" href="https://www.kernel.org/doc/Documentation/block/cfq-iosched.txt" rel="noopener ugc nofollow" target="_blank"> CFQ IO调度器</a>的性能优势，但Linux调度器从那时起已经有所改进，到2018年<a class="ae km" href="https://github.com/torvalds/linux/commit/f382fb0bcef4c37dc049e9f6963e3baf204d815c" rel="noopener ugc nofollow" target="_blank"> CFQ调度器已经从内核中移除</a>。</p><p id="8e5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同一个补丁集<a class="ae km" href="https://github.com/torvalds/linux/commit/b3c5fd3052492f1b8d060799d4f18be5a5438" rel="noopener ugc nofollow" target="_blank">用红黑树</a>替换排序列表:</p><blockquote class="mj mk ml"><p id="d205" class="jn jo kl jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">理论上，排序应该由底层磁盘调度程序来执行，然而，实际上磁盘调度程序只接受和排序有限数量的请求。为了允许对所有请求进行排序，dm-crypt需要实现自己的排序。</p><p id="42c4" class="jn jo kl jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">与基于rbtree的排序相关联的开销被认为是可以忽略的，因此它没有被有条件地使用。</p></blockquote><p id="b504" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些都有道理，但如果有一些支持数据就更好了。</p><p id="4a73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的是，在同一个补丁集中，我们看到<a class="ae km" href="https://github.com/torvalds/linux/commit/0f5d8e6ee758f7023e4353cca75d785b2d4f6abe" rel="noopener ugc nofollow" target="_blank">引入了我们熟悉的“submit _ from _ crypt _ cpus”选项</a>:</p><blockquote class="mj mk ml"><p id="401d" class="jn jo kl jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">在某些情况下，将写bios从加密线程卸载到单个线程会显著降低性能</p></blockquote><p id="04de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，我们可以看到每一个变化都是合理的和必要的，但是从那以后事情发生了变化:</p><ul class=""><li id="5f58" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">硬件变得更快更智能</li><li id="e992" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">重新审视了Linux资源分配</li><li id="b2f8" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">耦合的Linux子系统被重新构建</li></ul><p id="ade3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的许多设计选择可能不适用于现代Linux。</p><h2 id="47ab" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">“大扫除”</h2><p id="431a" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">基于上面的研究，我们决定尝试移除所有额外的排队和异步行为，并将<code class="fe lx ly lz ma b">dm-crypt</code>恢复到其最初的目的:简单地在IO请求通过时对其进行加密/解密。但是为了稳定性和进一步的基准测试，我们最终没有删除实际的代码，而是添加了另一个<code class="fe lx ly lz ma b">dm-crypt</code>选项，如果启用的话，它会绕过所有的队列/线程。该标志允许我们在满负荷运行时在当前行为和新行为之间切换，因此如果我们看到任何副作用，我们可以很容易地恢复我们的更改。生成的补丁可以在<a class="ae km" href="https://github.com/cloudflare/linux/blob/master/patches/0023-Add-DM_CRYPT_FORCE_INLINE-flag-to-dm-crypt-target.patch" rel="noopener ugc nofollow" target="_blank"> Cloudflare GitHub Linux存储库</a>上找到。</p><h2 id="a97a" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">同步Linux加密API</h2><p id="3904" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">从上图中我们可以看出，并不是所有的排队都在<code class="fe lx ly lz ma b">dm-crypt</code>中实现。现代Linux Crypto API也可能是异步的，为了这个实验，我们也想消除队列。“可能”是什么意思呢？操作系统可能包含同一算法的不同实现(例如，x86平台上的<a class="ae km" href="https://en.wikipedia.org/wiki/AES_instruction_set" rel="noopener ugc nofollow" target="_blank">硬件加速AES-NI</a>和通用C代码AES实现)。默认情况下，系统根据<a class="ae km" href="https://www.kernel.org/doc/html/v4.19/crypto/architecture.html#crypto-api-cipher-references-and-priority" rel="noopener ugc nofollow" target="_blank">配置的算法优先级</a>选择“最佳”算法。<code class="fe lx ly lz ma b">dm-crypt</code>允许覆盖这种行为，并且<a class="ae km" href="https://gitlab.com/cryptsetup/cryptsetup/-/wikis/DMCrypt#mapping-table-for-crypt-target" rel="noopener ugc nofollow" target="_blank">使用<code class="fe lx ly lz ma b">capi:</code>前缀请求特定的密码实现</a>。但是，有一个问题。让我们实际检查可用的AES-XTS(这是我们的磁盘加密密码，还记得吗？)在我们系统上的实现:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="fc2f" class="kn ko iq ma b gy mf mg l mh mi">$ grep -A 11 'xts(aes)' /proc/crypto<br/>name         : xts(aes)<br/>driver       : xts(ecb(aes-generic))<br/>module       : kernel<br/>priority     : 100<br/>refcnt       : 7<br/>selftest     : passed<br/>internal     : no<br/>type         : skcipher<br/>async        : no<br/>blocksize    : 16<br/>min keysize  : 32<br/>max keysize  : 64<br/>--<br/>name         : __xts(aes)<br/>driver       : cryptd(__xts-aes-aesni)<br/>module       : cryptd<br/>priority     : 451<br/>refcnt       : 1<br/>selftest     : passed<br/>internal     : yes<br/>type         : skcipher<br/>async        : yes<br/>blocksize    : 16<br/>min keysize  : 32<br/>max keysize  : 64<br/>--<br/>name         : xts(aes)<br/>driver       : xts-aes-aesni<br/>module       : aesni_intel<br/>priority     : 401<br/>refcnt       : 1<br/>selftest     : passed<br/>internal     : no<br/>type         : skcipher<br/>async        : yes<br/>blocksize    : 16<br/>min keysize  : 32<br/>max keysize  : 64<br/>--<br/>name         : __xts(aes)<br/>driver       : __xts-aes-aesni<br/>module       : aesni_intel<br/>priority     : 401<br/>refcnt       : 7<br/>selftest     : passed<br/>internal     : yes<br/>type         : skcipher<br/>async        : no<br/>blocksize    : 16<br/>min keysize  : 32<br/>max keysize  : 64</span></pre><p id="00e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们想从上面的列表中显式地选择一个同步密码，以避免线程中的排队效应，但是只支持两个密码<code class="fe lx ly lz ma b">xts(ecb(aes-generic))</code>(通用C实现)和<code class="fe lx ly lz ma b">__xts-aes-aesni</code>(x86硬件加速实现)。我们肯定想要后者，因为它更快(我们的目标是这里的性能)，但它被可疑地标记为内部(见<code class="fe lx ly lz ma b">internal: yes</code>)。如果我们<a class="ae km" href="https://github.com/torvalds/linux/blob/fb33c6510d5595144d585aa194d377cf74d31911/include/linux/crypto.h#L91" rel="noopener ugc nofollow" target="_blank">检查源代码</a>:</p><blockquote class="mj mk ml"><p id="1e40" class="jn jo kl jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">将一个密码标记为只能由另一个密码使用的服务实现，而不能由内核加密API的普通用户使用</p></blockquote><p id="b4a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这个密码只能由Crypto API中的其他包装器代码使用，而不能在它之外使用。在实践中，这意味着当请求一个特定的密码实现时，Crypto API的调用者需要显式地指定这个标志，但是<code class="fe lx ly lz ma b">dm-crypt</code>没有这样做，因为根据设计，它不是Linux Crypto API的一部分，而是一个“外部”用户。我们已经修补了<code class="fe lx ly lz ma b">dm-crypt</code>模块，所以我们也可以只添加相关的标志。但是<a class="ae km" href="https://en.wikipedia.org/wiki/AES_instruction_set" rel="noopener ugc nofollow" target="_blank"> AES-NI </a>还有一个特别的问题:<a class="ae km" href="https://en.wikipedia.org/wiki/X87" rel="noopener ugc nofollow" target="_blank"> x86 FPU </a>。你说“浮点”？为什么我们需要浮点数学来做对称加密，而对称加密应该只涉及位移和异或运算？我们不需要数学，但AES-NI指令使用一些CPU寄存器，这些寄存器专用于FPU。不幸的是，由于性能原因，Linux内核<a class="ae km" href="https://github.com/torvalds/linux/blob/fb33c6510d5595144d585aa194d377cf74d31911/arch/x86/kernel/fpu/core.c#L77" rel="noopener ugc nofollow" target="_blank">并不总是在中断上下文</a>中保留这些寄存器(保存/恢复FPU是昂贵的)。但是<code class="fe lx ly lz ma b">dm-crypt</code>可能在中断上下文中执行代码，所以我们冒着破坏一些其他进程数据的风险，并且我们回到原始代码中的“在中断上下文中进行解密是非常不明智的”语句。</p><p id="6c25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们解决上述问题的方案是创建另一个有点“智能”的加密API模块。该模块是同步的，不包含自己的加密，只是加密请求的“路由器”:</p><ul class=""><li id="fc67" class="mq mr iq jp b jq jr ju jv jy ms kc mt kg mu kk mv mw mx my bi translated">如果我们可以在当前执行上下文中使用FPU(以及AES-NI ),我们只需将加密请求转发给更快的“内部”<code class="fe lx ly lz ma b">__xts-aes-aesni</code>实现(我们可以在这里使用它，因为现在我们是Crypto API的一部分)</li><li id="7886" class="mq mr iq jp b jq mz ju na jy nb kc nc kg nd kk mv mw mx my bi translated">否则，我们只是将加密请求转发给更慢的、通用的基于C的<code class="fe lx ly lz ma b">xts(ecb(aes-generic))</code>实现</li></ul><h2 id="39fb" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">使用全部</h2><p id="3209" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">让我们一起来看一下使用它的过程。第一步是<a class="ae km" href="https://github.com/cloudflare/linux/blob/master/patches/" rel="noopener ugc nofollow" target="_blank">获取补丁</a>并重新编译内核(或者只是编译<code class="fe lx ly lz ma b">dm-crypt</code>和我们的<code class="fe lx ly lz ma b">xtsproxy</code>模块)。</p><p id="2b45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们在一个单独的终端中重新启动我们的IO工作负载，这样我们可以确保我们可以在运行时根据负载重新配置内核:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="bbb6" class="kn ko iq ma b gy mf mg l mh mi">$ sudo fio --filename=/dev/mapper/encrypted-ram0 --readwrite=readwrite --bs=4k --direct=1 --loops=1000000 --name=crypt<br/>crypt: (g=0): rw=rw, bs=4K-4K/4K-4K/4K-4K, ioengine=psync, iodepth=1<br/>fio-2.16<br/>Starting 1 process<br/>...</span></pre><p id="efcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在主终端中，确保我们的新加密API模块已加载并可用:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="c2ac" class="kn ko iq ma b gy mf mg l mh mi">$ sudo modprobe xtsproxy<br/>$ grep -A 11 'xtsproxy' /proc/crypto<br/>driver       : xts-aes-xtsproxy<br/>module       : xtsproxy<br/>priority     : 0<br/>refcnt       : 0<br/>selftest     : passed<br/>internal     : no<br/>type         : skcipher<br/>async        : no<br/>blocksize    : 16<br/>min keysize  : 32<br/>max keysize  : 64<br/>ivsize       : 16<br/>chunksize    : 16</span></pre><p id="2631" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">重新配置加密的磁盘，以使用我们新加载的模块，并启用我们打了补丁的<code class="fe lx ly lz ma b">dm-crypt</code>标志(我们必须使用低级的<code class="fe lx ly lz ma b">dmsetup</code>工具，因为<code class="fe lx ly lz ma b">cryptsetup</code>显然不知道我们的修改):</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="583d" class="kn ko iq ma b gy mf mg l mh mi">$ sudo dmsetup table encrypted-ram0 --showkeys | sed 's/aes-xts-plain64/capi:xts-aes-xtsproxy-plain64/' | sed 's/$/ 1 force_inline/' | sudo dmsetup reload encrypted-ram0</span></pre><p id="cbcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们刚刚“加载”了新配置，但为了使其生效，我们需要暂停/恢复加密设备:</p><pre class="lm ln lo lp gt mb ma mc md aw me bi"><span id="b3e6" class="kn ko iq ma b gy mf mg l mh mi">$ sudo dmsetup suspend encrypted-ram0 &amp;&amp; sudo dmsetup resume encrypted-ram0</span></pre><p id="a852" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在观察结果。我们可以回到运行<code class="fe lx ly lz ma b">fio</code>作业的另一个终端，查看输出，但是为了让事情更好，这里有一个在<a class="ae km" href="https://grafana.com/" rel="noopener ugc nofollow" target="_blank"> Grafana </a>中观察到的读/写吞吐量的快照:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ne"><img src="../Images/d096c178d033e8ddd31332ea05517fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RcnQjtgcO0OZY6rP.png"/></div></div></figure><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nf"><img src="../Images/e497d3e36cbc5fdd26986aa2c9ee4674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hA8xGwLGZvDLNVW8.png"/></div></div></figure><p id="948b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哇，我们的吞吐量增加了一倍多！有了<code class="fe lx ly lz ma b">~640 MB/s</code>的总吞吐量，我们现在离上面预期的<code class="fe lx ly lz ma b">~696 MB/s</code>更近了。IO延迟呢？(来自<a class="ae km" href="http://man7.org/linux/man-pages/man1/iostat.1.html" rel="noopener ugc nofollow" target="_blank"> iostat报告工具</a>的<code class="fe lx ly lz ma b">await</code>统计数据):</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ng"><img src="../Images/f31375178cf0c6cdf535fc5ca031f854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ouuZzjw1nwHa_ZW_.png"/></div></div></figure><p id="e711" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">延迟也减少了一半！</p><h2 id="b97a" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">到生产</h2><p id="9cd4" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">到目前为止，我们一直在使用合成设置，缺少完整生产堆栈的某些部分，如文件系统、实际硬件以及最重要的生产工作负载。为了确保我们没有对想象中的事情进行优化，下面是这些变化给我们堆栈的缓存部分带来的生产影响的快照:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nh"><img src="../Images/0927f95202c6b740ba4340a72e8ce19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IH5wAOil9KQjytmz.png"/></div></div></figure><p id="d6a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此图显示了我们的一台服务器中<a class="ae km" href="https://blog.cloudflare.com/how-we-scaled-nginx-and-saved-the-world-54-years-every-day/" rel="noopener ugc nofollow" target="_blank">缓存命中的最坏情况响应时间(第99个百分点)的三种比较。绿线来自具有未加密磁盘的服务器，我们将使用它作为基线。红线来自使用默认Linux磁盘加密实现的加密磁盘的服务器，蓝线来自使用加密磁盘并启用了我们的优化的服务器。正如我们所看到的，在最坏的情况下，默认的Linux磁盘加密实现对我们的缓存延迟有很大的影响，而打补丁的实现与完全不使用加密没有什么区别。换句话说，改进的加密实现对我们的缓存响应速度没有任何影响，所以我们基本上是免费的！这是一个胜利！</a></p><h2 id="d396" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">我们才刚刚开始</h2><p id="7e09" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">这篇文章展示了架构审查是如何让系统性能翻倍的。此外，我们<a class="ae km" href="https://blog.cloudflare.com/how-expensive-is-crypto-anyway/" rel="noopener ugc nofollow" target="_blank">再次确认现代加密技术并不昂贵</a>，而且通常没有借口不保护您的数据。</p><p id="8d57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将把这项工作提交到主内核源代码树中，但很可能不是当前的形式。尽管结果看起来令人鼓舞，但我们必须记住，Linux是一个高度可移植的操作系统:它运行在强大的服务器以及资源受限的小型物联网设备上，也运行在<a class="ae km" href="https://blog.cloudflare.com/arm-takes-wing/" rel="noopener ugc nofollow" target="_blank">许多其他CPU架构</a>上。当前版本的补丁只是针对特定架构上的特定工作负载优化了磁盘加密，但Linux需要一个在任何地方都能流畅运行的解决方案。</p><p id="7c46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，如果你认为你的情况是相似的，并且你想利用现在的性能改进，你可以<a class="ae km" href="https://github.com/cloudflare/linux/blob/master/patches/" rel="noopener ugc nofollow" target="_blank">获取补丁</a>并且希望提供反馈。运行时标志使得动态切换功能变得容易，并且可以执行简单的A/B测试来查看它是否有益于任何特定的情况或设置。这些补丁已经在我们的<a class="ae km" href="https://www.cloudflare.com/network/" rel="noopener ugc nofollow" target="_blank">超过200个数据中心</a>的广泛网络上运行了五代硬件，因此可以合理地认为是稳定的。让所有人享受Cloudflare的性能和安全性！</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ni"><img src="../Images/f253e8f57aa400e638ed85e327ab6b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DKao_1HmGH8EfQaV.png"/></div></div></figure><h2 id="d98b" class="kn ko iq bd kp kq kr dn ks kt ku dp kv jy kw kx ky kc kz la lb kg lc ld le lf bi translated">更新(2020年10月11日)</h2><p id="ae27" class="pw-post-body-paragraph jn jo iq jp b jq lg js jt ju lh jw jx jy li ka kb kc lj ke kf kg lk ki kj kk ij bi translated">这个博客的主要补丁(以稍微更新的形式)已经被<a class="ae km" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/md/dm-crypt.c?id=39d42fa96ba1b7d2544db3f8ed5da8fb0d5cb877" rel="noopener ugc nofollow" target="_blank">合并</a>到主线Linux内核中，并且从5.9版本开始可用。主要的区别是主线版本公开了两个标志，而不是一个，这提供了绕过dm-crypt工作队列进行独立读写的能力。详情见<a class="ae km" href="https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/dm-crypt.html" rel="noopener ugc nofollow" target="_blank">官方dm-crypt文档</a>。</p></div></div>    
</body>
</html>