<html>
<head>
<title>Git Stash and Git Rebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git Stash和Git Rebase</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/git-stash-and-git-rebase-535811a3cb84?source=collection_archive---------7-----------------------#2021-05-16">https://levelup.gitconnected.com/git-stash-and-git-rebase-535811a3cb84?source=collection_archive---------7-----------------------#2021-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b7eb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">何时使用它们以及如何处理将代码合并到master</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f5869f729b60d6d3e7bf9c0ab39d7eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCZkmZR1_YzDZy22Vn4uUw.png"/></div></div></figure><p id="1041" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我第一次学习编码时，我是唯一一个开发应用程序的工程师。每隔一段时间，我会有一个项目，我会与另一名工程师一起工作，但很多进展都是在结对编程会议期间取得的，我们只是将所有的更改直接推给master。</p><p id="3a3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我转向更大的应用程序，并开始在一家有十几名工程师的公司工作时，我开始学习如何使用分支，以及如何使用拉请求将我的更改合并到代码库中，而不影响其他工程师的代码。我发现的两个最有用的命令是‘git rebase’和‘git stash’。与git pull、git merge等其他命令一起使用。您开始真正意识到git是一个多么强大的工具。</p><h2 id="3045" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">Git贮藏</h2><p id="86bb" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">当你开始在一个更大的团队中工作时，尤其是当你的产品正在运行时，有时你可能会开始在一个分支上工作，但是为了解决一些更紧急的问题，你不得不突然停止工作。</p><p id="2fc6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您只是使用git checkout切换到分支，git将尝试将您在当前分支(分支A)上的所有更改转移到您要切换到的分支(分支B)。有时，如果没有冲突，它会无问题地切换，但有时它会警告您需要在签出新分支之前提交您的更改。</p><p id="b632" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">无论哪种方式，很多时候你都不想把你在分支A上工作的新代码带到分支B上。你想做的是保存你添加的代码，但是当你切换到分支B时，你想让它恢复到你创建分支A之前的状态。这正是<code class="fe ml mm mn mo b">git stash</code>的设计目的。</p><p id="d321" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">命令<code class="fe ml mm mn mo b">git stash</code>帮助你<em class="mp">保存</em>你的工作并清空你的工作目录。那么当你签出的时候，它就不会带着新代码了。</p><p id="4438" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，假设您修复了分支B中的紧急错误，并且您决定导入您在分支a上所做的这些更改。您可以使用命令<code class="fe ml mm mn mo b">git stash list</code>来查看您已经存储在<em class="mp">存储库</em>中的所有更改的列表。从那里，您可以使用命令<code class="fe ml mm mn mo b">git stash apply &lt;stash_name&gt;</code>应用这些更改，其中stash_name是list命令给出的名称(看起来有点像stash@{0}:)</p><p id="2b1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，你可以使用命令<code class="fe ml mm mn mo b">git stash drop &lt;stash_name&gt;</code>从你的列表中删除一个旧的或者不想要的东西。</p><h2 id="47a1" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">Git Rebase</h2><p id="2592" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">命令<code class="fe ml mm mn mo b">git rebase</code>将您的提交应用到另一个分支的顶部。下面是我在网上找到的一个有效的图解来解释。</p><p id="69ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">比方说，你从master中分支出来，开始在你的应用程序中添加一个新功能。当你工作时，你的应用程序代码的一部分，你的新功能依赖于什么改变来修复一个bug。您现在的代码在新特性和一些其他bug修复方面都不同于master，因此您在master之后和之前都有几次提交。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/7240d4ce197665e911ce0f87cc7520d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1NUrB9WYTAQGLalEgpBrWQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">蓝色代表修复bug的提交，绿色代表新特性的提交。</figcaption></figure><p id="1744" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你合并你的代码时，会有很多合并冲突，你不知道如何解决。如果有一种方法可以将master上的bug修复程序放到您的分支中，然后将您的新特性的提交添加到修复后的代码中就好了。</p><p id="1195" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你很幸运，这正是<code class="fe ml mm mn mo b">git rebase</code>所做的！它会将您的新特性移动到master上新提交的末尾，创建一个连续的提交流，应该是无冲突的，并且取代了合并的需要。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/9950c2a4905d6bf3326250d29ea7f83c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OuHM7kCHrJw-NFwnNYITw.png"/></div></div></figure><p id="6af4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这两个命令将真正增强您避免冲突的能力，并在更大的团队中从一个分支转移到另一个分支！</p></div></div>    
</body>
</html>