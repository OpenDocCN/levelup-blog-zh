<html>
<head>
<title>Delivering with Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Haskell一起交付</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/delivering-with-haskell-a347d8359597?source=collection_archive---------0-----------------------#2020-10-11">https://levelup.gitconnected.com/delivering-with-haskell-a347d8359597?source=collection_archive---------0-----------------------#2020-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7499" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我对第一次有兴趣使用Haskell来发布项目的团队的建议。我的建议是基于两年的Haskell经验，结合朋友的战争故事。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/3b9173e207cf3e4f98dd4b46eef9c2bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QocHsYZWXoucvAxl.jpg"/></div></div></figure><p id="e94a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，我听到越来越多的轶事证据表明Haskell项目比其他语言有更高的失败几率。通过在失败的项目中寻找模式，并与成功的项目进行比较，我想帮助新团队远离危险。TL；DR是<strong class="jp ir">你已经用Haskell花光了你所有的新奇预算；所以不要对类型系统做任何花哨的事情。</strong></p><p id="ec68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不打算鼓吹为什么任何人都应该使用Haskell，我不是一个语言传播者，尽管我确实相信它是共享代码库的最佳通用编程语言，并且拥有一流的开发人员工具。如果你发现了Haskell的巨大用途，并说服管理层让你使用它，那么希望你能从我的建议中学到一些东西。</p><p id="8f44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还假设团队中至少有一个人有Haskell经验(商业或业余爱好),并且团队的所有核心成员都选择了加入。试图用一种没有经验和/或不情愿的团队成员的语言开始一个项目(每次事情不顺利就质问)肯定会失败，不管你选择什么语言。</p><h1 id="17f0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">教育</h1><p id="eb05" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">即使核心团队以前都使用过Haskell，也会有外围人员找借口抱怨你的项目是如何不可访问的。确保你有一个简单的入职流程，让他们可以自由进出，并随时准备配对和提供帮助</p><p id="5327" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保您的自述文件链接到优秀的学习材料。我推荐格雷厄姆·赫顿的书《用Haskell编程》，同时反对《向你学习一个Haskell》(它缺乏相关性)和《Haskell书》(它针对的是非程序员，不是你)。</p><p id="1704" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Haskell项目之所以失败，是因为核心团队消失在一个筒仓中，把其他所有人都抛在了后面。这被认为是精英主义，是对Haskell采用的普遍抱怨。从过去的错误中吸取教训，保持平易近人，渴望教导和分享。</p><h1 id="aeb4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">工具作业</h1><p id="b921" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">大多数新的Haskell开发人员都使用VSCode作为他们的文本编辑器，它有很多相关的扩展。对于小项目来说，<a class="ae ma" href="https://github.com/haskell/haskell-language-server" rel="noopener ugc nofollow" target="_blank"> Haskell语言服务器</a>非常好用。对于Emacs和Vim狂热者来说，他们会找到一套成熟的惯用插件。我个人一直在使用名为<code class="fe mb mc md me b"><a class="ae ma" href="https://gitlab.com/tseenshe/haskell-tng.el" rel="noopener ugc nofollow" target="_blank">haskell-tng</a></code>的实验性Emacs模式，它提供了许多IDE特性，使用起来非常愉快。</p><p id="5dac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Haskell有两个主要的构建工具。<a class="ae ma" href="https://medium.com/@fommil/why-not-both-8adadb71a5ed" rel="noopener">我在两年前写了关于它们的文章</a>:它们是兼容的，如果你使用<code class="fe mb mc md me b">stack.yaml</code>作为事实的来源，使用<code class="fe mb mc md me b">stack2cabal</code>产生提交给回购的秘密文件，团队成员可以选择他们喜欢的一个。然而，我建议在CI中使用<code class="fe mb mc md me b">cabal</code>,因为我发现它和它对话的服务器更容易维护、更可靠、更容易安装、更容易缓存。</p><p id="4438" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要使用Nix。没有人理解Nix，除非他们有时间，Nix几乎从不工作，使用NixOS的人永远不能得到任何工作，Nix会扼杀你的项目。让NixOS的人为了自己的利益保持nix文件的更新，如果他真的必须这样做的话，但是不要让它听起来像是一个要求。</p><p id="3505" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请确保在您的自述文件中记录如何为您工作中使用的所有平台设置文本编辑器和构建工具，这样就没有人会声称他们不知道从哪里开始。从Haskell安装工具开始，确保非常显著地记录<a class="ae ma" href="https://hoogle.haskell.org/" rel="noopener ugc nofollow" target="_blank"> Hoogle </a>，因为这是一个真正的瑰宝和巨大的生产力助推器。</p><p id="a34a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Haskell有无数的linters和formatters。我建议添加<code class="fe mb mc md me b"><a class="ae ma" href="http://hackage.haskell.org/package/ormolu" rel="noopener ugc nofollow" target="_blank">ormolu</a></code>作为<code class="fe mb mc md me b">build-tool-depends</code>(即由构建工具管理，不需要用户设置)并在CI中强制执行。它将从项目一开始就停止许多骑自行车的讨论。这一点很重要，因为公司的其他人都在看着你，如果你浪费时间谈论空白，那会很糟糕:这会延续Haskellers住在象牙塔里的神话。选择一个工具，让它为你做决定，专注于运输。</p><h1 id="a703" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">语言扩展</h1><p id="7d8a" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Haskell最大的文化冲击之一是没有人真正编写Haskell；几乎可以肯定，他们正在编写Haskell和一些语言扩展。</p><p id="0702" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有超过120种语言扩展，其中许多需要读者理解一篇研究论文。我认为每一个扩展背后都有这种水平的文档和考虑是令人惊讶的，我也认为这证明了Glasgow Haskell编译器作为学术研究的工具是成功的。然而，作为一名工业开发人员，我意识到每一种语言扩展都会给每一位读者和代码维护者带来教育和概念上的开销、不同级别的工具支持、不明显的功能交互以及令人困惑的编译器错误消息。我之前在<a class="ae ma" href="https://medium.com/@fommil/simple-haskell-is-best-haskell-6a1ea59c73b" rel="noopener">简单的Haskell是最好的Haskell </a>中写过一些这样的问题。</p><p id="0c7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于第一次采用Haskell的团队来说，我的建议比那些<a class="ae ma" href="https://www.simplehaskell.org/" rel="noopener ugc nofollow" target="_blank"> Simple Haskell </a>项目要严格得多。哈斯克尔生态系统就像一把没有安全夹的上膛的枪；按照1998年报告(2010年更新)中的定义，坚持股票Haskell ，你就没事了。除此之外，我认为<strong class="jp ir">有一个选择加入特定语言扩展的过程</strong>，并且在选择小组中包括团队的外围成员以保持名单的合理性是非常重要的。</p><p id="6f9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我建议，至少在第一年，您的小组应该考虑接受以下语言扩展。一旦你交付了，如果每个人都同意Haskell在你的公司被正式采用，那么你可以考虑进一步开放它。值得注意的是，我所知道的所有工具都完全支持以下所有扩展。</p><ul class=""><li id="2ceb" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mb mc md me b">ScopedTypeVariables</code>、<code class="fe mb mc md me b">ExplicitForAll</code>、<code class="fe mb mc md me b">InstanceSigs</code>、<code class="fe mb mc md me b">KindSignatures</code>——这些使得在<code class="fe mb mc md me b">Haskell2010</code>忽略需要的地方添加类型签名成为可能，产生更好的错误信息和自我文档。</li><li id="e437" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><code class="fe mb mc md me b">LambdaCase</code> -纯粹是语法上的，省去了重复打字。</li><li id="f3a5" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><code class="fe mb mc md me b">NamedFieldPuns</code> -是一种与记录字段交互的显式方式，节省了重复输入。</li><li id="a769" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><code class="fe mb mc md me b">OverloadedStrings</code> -将文本输入与数字输入对齐，使得使用内置<code class="fe mb mc md me b">String</code>类型的替代方式更加容易。</li><li id="a238" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><code class="fe mb mc md me b">BangPatterns</code> -允许将特定值评估为标准形式，这是避免偶尔内存泄漏或优化性能所必需的。不要和<code class="fe mb mc md me b">NFData</code>混淆，后者是用来强制评估的。</li><li id="2b56" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><code class="fe mb mc md me b">ViewPatterns</code> -是一种强大的模式守卫，因此节省重复打字。</li><li id="9c8f" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><code class="fe mb mc md me b">TupleSections</code>——“照我的意思做”语法糖处理元组的时候，省去了重复打字。</li><li id="5e26" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><code class="fe mb mc md me b">GeneralizedNewtypeDeriving</code>——“照我的意思做”为<code class="fe mb mc md me b">newtype</code>事物生成实例的语法糖。</li></ul><p id="e7b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一个荣誉奖项颁给了</p><ul class=""><li id="eba2" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><code class="fe mb mc md me b">CPP</code> -允许使用C预处理器，这对于处理多个版本的第三方库或跨平台与本地代码交互是绝对必要的。</li></ul><p id="471c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这只是一种荣誉，因为<code class="fe mb mc md me b">CPP</code>不被<code class="fe mb mc md me b">ormolu</code>代码格式化程序支持。<code class="fe mb mc md me b">ormolu</code>的作者认为<a class="ae ma" href="https://www.tweag.io/blog/2019-06-27-cpp-considered-harmful/" rel="noopener ugc nofollow" target="_blank"> CPP是有害的</a>，坦率地说我不同意他们的观点。不支持<code class="fe mb mc md me b">cpp</code>的语言最终会非常想念它，也没有人提出过向后兼容的替代方案。</p><p id="ae5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Haskell的老员工会问“就这些？！?"此时此刻。而且，不，我没有忘记<code class="fe mb mc md me b">RecordWildcard</code>或<code class="fe mb mc md me b">RecordDotSyntax</code>(它们隐式地将神奇的符号带入范围)；<code class="fe mb mc md me b">Derive*</code>和<code class="fe mb mc md me b">Deriving*</code>(它们鼓励使用花哨的类型)；<code class="fe mb mc md me b">DuplicateRecordFields</code>(sum类型不应该有字段，因为它产生部分函数)；<code class="fe mb mc md me b">NoImplicitPrelude</code>(自定义前奏是炒作)；<code class="fe mb mc md me b">TypeFamilies</code>；<code class="fe mb mc md me b">GADTs</code>，或者任何与依赖类型有关的东西(极其花哨的类型)。如果你觉得你正在接近<code class="fe mb mc md me b">TypeApplications</code>，这是一个很好的迹象，表明你正在做一件过于花哨的事情，因为这意味着推理中断了，你需要告诉编译器该做什么。</p><p id="658e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也反对一些传统上“安全”的扩展名，如<code class="fe mb mc md me b">FunctionalDependencies</code>和<code class="fe mb mc md me b">MultiParamTypeClasses</code>，它们本身是无害的，但却是通向更多扩展名的门户，如<code class="fe mb mc md me b">FlexibleContexts</code>、<code class="fe mb mc md me b">OverlappingInstances</code>和<code class="fe mb mc md me b">IncoherentInstances</code>。它们的主要用例是启用<code class="fe mb mc md me b">MonadReader</code>和<code class="fe mb mc md me b">MonadState</code>的创建，它们并不像人们预期的那样有用(你会在<code class="fe mb mc md me b"><a class="ae ma" href="https://hackage.haskell.org/package/multistate-0.8.0.3/docs/Control-Monad-Trans-MultiReader.html" rel="noopener ugc nofollow" target="_blank">MultiReader</a></code>兔子洞里结束),而且无论如何都可以通过编码显式的<code class="fe mb mc md me b">ExceptT</code>和<code class="fe mb mc md me b">StateT</code>来替换。</p><p id="1968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一句，我认为<code class="fe mb mc md me b">-fno-warn-orphans</code>是一种语言扩展，我强烈反对。我认为它攻击了类型类机制的基本原理。使用一个<code class="fe mb mc md me b">newtype</code>，或者将包含类或数据类型的包分支到您的代码库中(Haskell build tooling使这变得非常容易)，您可以通过将它返回到标记后面的社区来成为一个好公民，这样人们就可以选择加入来获得实例。如果在你的代码库中有冲突的孤立实例，这将会破坏你对每个测试中使用的东西进行推理的能力，并且会使你暴露于罕见的(但是非常耗时的)增量编译错误。与此相关:使用<code class="fe mb mc md me b">QuickCheck</code>但不要使用<code class="fe mb mc md me b">Arbitrary</code>。相反，为每件事编写显式的<code class="fe mb mc md me b">Gen</code>生成器，并在每次测试的基础上选择您想要使用的生成器。一开始做这些只是小菜一碟，但从长远来看，当你开始编写更复杂的测试时，你会感谢我。</p><h1 id="7309" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">没有花哨的类型</h1><p id="7e56" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">如果你把依赖类型作为降低缺陷率的一种方法来推销你的管理，那么我不认为Haskell是正确的工具；请改用Idris或Agda。</p><p id="502a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Haskell类型系统已经被推向诸如类型家族和泛型/类型级编程的方向。我认为每个Haskell开发者都应该阅读<a class="ae ma" href="https://leanpub.com/thinking-with-types" rel="noopener ugc nofollow" target="_blank">用类型思考</a>来理解什么是可能的，但是也不要在试图赢得Haskell采用的代码库中做任何类似的事情。</p><p id="b414" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">据我所知，每一个失败的Haskell项目都有一个共同的主题，那就是他们试图对类型系统做太多的事情，结果代码变得不可维护，错误消息也无法解释。我知道一些项目在大量使用<code class="fe mb mc md me b">TypeFamilies</code>和泛型编程的情况下取得了成功，但是我注意到那些团队是专门作为高级Haskell团队建立的，并且只雇佣有2年以上商业经验的人。因此，花式类型是有价值的，但这只是比你的第一个项目要远得多。</p><p id="aef4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">避免“效果系统”。最近几年有一股热潮，试图让Haskell类型系统在类型级别上跟踪个人与现实世界的交互，而不是让一切都在单个<code class="fe mb mc md me b">IO</code>单子中消耗掉。我个人不明白为什么人们想要在类型级别上跟踪这个问题，并且弹出来解决这个问题的效果系统对程序的架构有着巨大的影响，这对于一个实验系统来说是一个相当危险的举动。我参与了一个使用效果系统的项目的分解，我认为公平地说，如果我们没有这样做，这个项目就会失败，并且分解的成本非常高；不是每个项目都有犯这种昂贵错误的奢侈。同样值得注意的是<a class="ae ma" href="https://reasonablypolymorphic.com/blog/mea-culpa/index.html" rel="noopener ugc nofollow" target="_blank">效果系统表现不佳</a>。</p><p id="ea97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只使用<code class="fe mb mc md me b">mtl</code>风格，或者更好的是，不使用typeclass编码(你可能永远不需要定义一个<code class="fe mb mc md me b">class</code>)而只使用函数的记录。我在<a class="ae ma" href="https://discourse.haskell.org/t/local-capabilities-with-mtl/231" rel="noopener ugc nofollow" target="_blank">MTL的本地能力</a>和<a class="ae ma" href="https://discourse.haskell.org/t/some-limits-of-mtl-with-records-of-functions/576" rel="noopener ugc nofollow" target="_blank">MTL的一些限制与函数记录</a>中详细描述了这一点。</p><p id="6587" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">许多库假设您将使用<code class="fe mb mc md me b">DeriveGeneric</code>语言扩展，然后使用泛型编程和记录语法来创建序列化器和反序列化器。这有点像用导弹消灭一只苍蝇，因为间接的层次很多，虽然它对简单的例子有效，但当你有不符合模型的东西时，它就变成了一个兔子洞。与其这样做，我建议只手动编写样板文件，或者更好……用一个名为<code class="fe mb mc md me b"><a class="ae ma" href="http://hackage.haskell.org/package/boilerplate" rel="noopener ugc nofollow" target="_blank">boilerplate</a></code>的工具(恰当地说)自动生成样板文件，通过指出它“就像ide为Java、C++和Go等语言所做的那样”,它扫除了许多花哨类型的理由。我的结论是,“扔掉你的样板文件”的整个论点实际上是错误的，它解决了一个非问题。</p><p id="165d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">避免花哨的类型对您可能想要使用的库有一些影响。例如，流行的webframework <a class="ae ma" href="https://www.servant.dev/" rel="noopener ugc nofollow" target="_blank">服务</a>将要求用户使用<code class="fe mb mc md me b">TypeFamilies</code>来启用几种语言扩展。对用户的影响是错误消息无法理解。我建议用一些更基本的东西，甚至不惜写更多的样板文件，比如<a class="ae ma" href="http://hackage.haskell.org/package/scotty" rel="noopener ugc nofollow" target="_blank"> Scotty </a>。我见过一个项目失败(部分原因)是因为它使用了Servant，而外围开发人员无法为他们的(非Haskell)服务维护HTTP端点定义。该项目也长期没有Swagger定义，消费者抱怨他们无法理解Haskell服务公开的HTTP API。不要忘记在你的系统边界使用一种通用语言。</p><p id="baa6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与“花式类型”有点相关的是避免任何事情的出血边缘的一般建议。如果有一个新的图书馆声称比一个已经存在了十多年的图书馆做得更好，也许只要坚持使用更保守的老图书馆就行了。记住，你已经通过选择Haskell花费了你的新奇预算。</p><h1 id="4c54" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">重构</h1><p id="7b0b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">Haskell使得重构代码变得非常容易。太容易了。<strong class="jp ir">是bug，不是特性</strong>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/b3960baa860aef5138a16ac61f395436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVHLDvIoOrivvsk4ipgRyQ.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated"><a class="ae ma" href="https://twitter.com/rickasaurus/status/1313471620351229958/" rel="noopener ugc nofollow" target="_blank">https://twitter.com/rickasaurus/status/1313471620351229958/</a></figcaption></figure><p id="9604" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对抗过度重构的唯一方法是好的过程和强有力的领导。对代码库的每一次重构都会在中断正在进行的工作方面产生成本，并且对于其他必须审查代码并重新理解他们曾经熟悉的代码的开发人员来说，会产生概念性的开销。从长远来看，回报可能是更易维护的代码库。Haskell使人们更容易相信重构是正确的，但不要忘记真正的人力和项目管理成本，以及类型系统无法捕捉的错误，这些错误可能会被自动生成serialisers等内容的花哨类型所混合。</p><p id="8305" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个话题上，艾米丽给了我们一些睿智的建议:</p><blockquote class="my mz na"><p id="8d91" class="jn jo nb jp b jq jr js jt ju jv jw jx nc jz ka kb nd kd ke kf ne kh ki kj kk ij bi translated">问“我的代码是必要的吗，或者就我个人对代码的理解而言，它是更有意义的方便的重构吗？”答案很少是“是”。</p><p id="f007" class="jn jo nb jp b jq jr js jt ju jv jw jx nc jz ka kb nd kd ke kf ne kh ki kj kk ij bi translated">—MLE<a class="ae ma" href="https://twitter.com/pitopos/status/1312098569382359040" rel="noopener ugc nofollow" target="_blank">https://twitter.com/pitopos/status/1312098569382359040</a></p></blockquote><h1 id="2053" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">一般建议</h1><p id="1f84" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我不知道有任何项目因为下面列出的事情而失败，这更像是我浪费时间做的事情的一个垃圾场。Haskell真的很稳定，但这只是意味着bug是众所周知的，不容易修复。对我来说最大的问题是:</p><ul class=""><li id="51e7" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">创建一个类型别名到一个单一的，全局的，monad的堆栈，并且只需要显式的编码而不是使用<code class="fe mb mc md me b">Monad*</code>约束。对于更一般的代码，你可以只使用一个<code class="fe mb mc md me b">Monad</code>约束。</li><li id="4c2b" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">不要使用<code class="fe mb mc md me b">String</code>，这是低效的，将需要你使用语言扩展来实现实例。用<code class="fe mb mc md me b">Text</code>代替。</li><li id="6a80" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">不要使用异常。你认为你理解了它们，因为你已经在其他语言中很好地使用了它们，但是在懒惰的语言中你并不理解它们。如果你真的必须使用它们，那么只使用<code class="fe mb mc md me b"><a class="ae ma" href="http://hackage.haskell.org/package/safe-exceptions" rel="noopener ugc nofollow" target="_blank">safe-exceptions</a></code>包中的<code class="fe mb mc md me b">*Deep</code>函数和大量的<code class="fe mb mc md me b">NFData</code>实例。</li><li id="4c8a" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">在用户请求/响应级别，投资编写一个真正好的基于模型的测试框架，使用QuickCheck生成用户动作，并使用特定于领域的收缩器。</li></ul></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="088e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我给你的所有建议！我希望你玩得开心，我真的希望你能帮助增加Haskell的采用。我喜欢这种语言，我认为它已经错过了由于误解。我希望你成功，无论如何请让我知道。</p></div></div>    
</body>
</html>