<html>
<head>
<title>Printing PDF in Node.js with Electron (ElectronForge + pdf-to-printer + webpack)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用电子在Node.js中打印PDF(电子锻造+ pdf-to-printer + webpack)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/printing-pdf-in-node-js-with-electron-electronforge-pdf-to-printer-webpack-b5c18209cf88?source=collection_archive---------9-----------------------#2022-06-05">https://levelup.gitconnected.com/printing-pdf-in-node-js-with-electron-electronforge-pdf-to-printer-webpack-b5c18209cf88?source=collection_archive---------9-----------------------#2022-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f129b2a9c6c0e3cab8125895b0f67880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FawhoCdirFhhg9Yy"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">杰拉尔丁·莱瓦在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f40a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以你有一个电子应用程序，并要求打印pdf的功能？跟我来</p><p id="3933" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一点上，您可能已经做了一些研究，并发现静默模式下pdf打印的节点库数量并不多。</p><p id="dcb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">跨越这个障碍，electron有一些依赖于库和打印方式(通过文件或原始内容)的警告。因此，我们将看到一个例子，它包含了所有可能的注意事项，因此它在某种程度上对您有用。</p><h2 id="a44f" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">这个例子</h2><p id="891a" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">有了一个<a class="ae kc" href="https://www.electronforge.io/templates/webpack-template" rel="noopener ugc nofollow" target="_blank"> ElectronForge webpack模板</a>，我们将在我们的项目中安装<a class="ae kc" href="https://www.npmjs.com/package/pdf-to-printer" rel="noopener ugc nofollow" target="_blank"> pdf-to-printer </a>，这是一个非常简单的库，它使用SumatraPDF.exe来打印pdf文件。</p><p id="6a76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，这不是一个必需的步骤，但对于这个例子，我们将接收一个pdf的base64字符串，并将其保存到一个临时文件中，以进行打印，然后将其排除。如果您已经有了pdf文件，只需将它放在项目文件夹中，您将提前知道如何在生产中找到该文件。</p><p id="eb55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在pdf文件生成之后，您将需要类似这样的东西:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="1ed8" class="lb lc iq me b gy mi mj l mk ml">import fs from 'fs/promises';</span><span id="0356" class="lb lc iq me b gy mm mj l mk ml">await <em class="mn">fs</em>.writeFile(tmpPdfPath, Buffer.from(<em class="mn">base64String</em>, 'base64'), 'binary');</span><span id="ab52" class="lb lc iq me b gy mm mj l mk ml">await printPdf(tmpPdfPath, {<br/>  printer: <em class="mn">nativePrinter</em>.name,<br/>}).finally(() =&gt; <em class="mn">fs</em>.unlink(tmpPdfPath));</span></pre><p id="570d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您运行您的启动脚本，您应该会得到一个错误，类似于“SumatraPDF.exe could ”,这是因为pdf-to-printer所依赖的exe没有插入到最终的构建文件夹(。webpack)，所以我们这样做:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7a3b" class="lb lc iq me b gy mi mj l mk ml">// in main.webpack.js</span><span id="6f2c" class="lb lc iq me b gy mm mj l mk ml">const CopyPlugin = require('copy-webpack-plugin');</span><span id="ea05" class="lb lc iq me b gy mm mj l mk ml"><em class="mn">module</em>.<em class="mn">exports</em> = {<br/>  ...<br/>  plugins: [<br/>    <strong class="me ir">new</strong> CopyPlugin({<br/>      patterns: [<br/>        {<br/>          from: 'node_modules/pdf-to-printer/dist/SumatraPDF.exe',<br/>          to: './',<br/>        },<br/>      ]<br/>    )}<br/>  ],<br/>  ...<br/>}</span></pre><h2 id="f2ce" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">在生产中工作</h2><p id="8814" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在它可以工作了。不过，仅限于开发人员。当您运行make脚本并执行您的应用程序时，会出现相同的错误，如果您将asar配置为true，它会给您带来更多的错误。首先让我们修复SumatraPDF.exe未找到错误，我们的webpack配置不工作的原因是我们正在处理一个. exe文件，它不能被编译，所以我们必须把它作为一个<a class="ae kc" href="https://electron.github.io/electron-packager/main/interfaces/electronpackager.options.html#extraresource" rel="noopener ugc nofollow" target="_blank">额外资源</a></p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9ebf" class="lb lc iq me b gy mi mj l mk ml">// in forge.config.js</span><span id="3e99" class="lb lc iq me b gy mm mj l mk ml"><em class="mn">module</em>.<em class="mn">exports</em> = {<br/>  packagerConfig: {<br/>    ...<br/>    extraResource: ['node_modules/pdf-to-printer/dist/SumatraPDF.exe'],<br/>    ...<br/>  },<br/>  ...<br/>}</span></pre><p id="9441" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并在生产中更改我们的代码以指向新的路径(在开发模式下不会加载额外的资源)</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f2cc" class="lb lc iq me b gy mi mj l mk ml">const basePath = process.env.NODE_ENV === 'development' ? __dirname : process.resourcesPath;</span><span id="ffe8" class="lb lc iq me b gy mm mj l mk ml">const tmpPath = './tmp';</span><span id="c257" class="lb lc iq me b gy mm mj l mk ml">// eslint-disable-next-line @typescript-eslint/no-empty-function<br/><em class="mn">fs</em>.mkdir(tmpPath).catch(() =&gt; {});</span><span id="fff7" class="lb lc iq me b gy mm mj l mk ml">const tmpPdfPath = path.join(tmpPath, `${uuid()}.pdf`);</span><span id="cb96" class="lb lc iq me b gy mm mj l mk ml">await <em class="mn">fs</em>.writeFile(tmpPdfPath, Buffer.from(<em class="mn">base64String</em>, 'base64'), 'binary');</span><span id="cf00" class="lb lc iq me b gy mm mj l mk ml">await printPdf(tmpPdfPath, {<br/>  printer: <em class="mn">nativePrinter</em>.name,<br/>  sumatraPdfPath: path.join(basePath, 'SumatraPDF.exe'), // &lt;- here is the change<br/>}).finally(() =&gt; <em class="mn">fs</em>.unlink(tmpPdfPath));</span></pre><h2 id="899b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">在生产中工作(使用asar)</h2><p id="3c7c" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">只有当您使用我们的从base64生成pdf文件的方法时，才需要该步骤。以asar模式编译的电子应用程序非常常见，这阻碍了我们直接在项目文件夹中创建文件，因此再次增加了额外的资源。在您的项目根目录中创建一个tmp文件夹(记得在其中放入一个. gitkeep，这样在您要推送的更改中将会考虑到它),然后将它添加到您的packagerConfig中:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="3f4e" class="lb lc iq me b gy mi mj l mk ml">// in forge.config.js</span><span id="7e69" class="lb lc iq me b gy mm mj l mk ml"><em class="mn">module</em>.<em class="mn">exports</em> = {<br/>  packagerConfig: {<br/>    ...<br/>    extraResource: ['node_modules/pdf-to-printer/dist/SumatraPDF.exe', 'tmp'],<br/>    ...<br/>  },<br/>  ...<br/>}</span></pre><p id="22c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们更新我们的逻辑来生成de临时文件:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="89c7" class="lb lc iq me b gy mi mj l mk ml">const basePath = process.env.NODE_ENV === 'development' ? __dirname : process.resourcesPath;</span><span id="31ba" class="lb lc iq me b gy mm mj l mk ml">const tmpPath = path.join(basePath, 'tmp'); // &lt;- here is the change </span><span id="92d7" class="lb lc iq me b gy mm mj l mk ml">// eslint-disable-next-line @typescript-eslint/no-empty-function<br/><em class="mn">fs</em>.mkdir(tmpPath).catch(() =&gt; {});</span><span id="757b" class="lb lc iq me b gy mm mj l mk ml">const tmpPdfPath = path.join(tmpPath, `${uuid()}.pdf`);</span><span id="5ecf" class="lb lc iq me b gy mm mj l mk ml">await <em class="mn">fs</em>.writeFile(tmpPdfPath, Buffer.from(<em class="mn">base64String</em>, 'base64'), 'binary');</span><span id="2292" class="lb lc iq me b gy mm mj l mk ml">await printPdf(tmpPdfPath, {<br/>  printer: <em class="mn">nativePrinter</em>.name,<br/>  sumatraPdfPath: path.join(basePath, 'SumatraPDF.exe'),<br/>}).finally(() =&gt; <em class="mn">fs</em>.unlink(tmpPdfPath));</span></pre><h2 id="c17e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">关于pdf转打印机的警告</h2><p id="5bec" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在我写这篇文章的时候，pdf-to-printer在打印到名称中有空格或横杠的打印机时有一个小问题，请注意，在调用cli进行打印时，可能需要在打印机名称周围加一个""</p><p id="5207" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢你给了我生命中的一些时间，如果我以任何方式提供了一些帮助，请告诉我。</p></div></div>    
</body>
</html>