<html>
<head>
<title>Just keep scrolling, scrolling, scrolling…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">继续滚动，滚动，滚动…</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/just-keep-scrolling-scrolling-scrolling-47c3863fe653?source=collection_archive---------3-----------------------#2021-03-22">https://levelup.gitconnected.com/just-keep-scrolling-scrolling-scrolling-47c3863fe653?source=collection_archive---------3-----------------------#2021-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1a4b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">我如何用React Redux实现无限滚动功能</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/0ade4b17c9ef785c92b3bfb99dcedff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S0lZu6T_KGNy0Ng8PCPclQ.jpeg"/></div></div></figure><p id="c246" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">对于我与熨斗学校的最后一个项目，我开发了Osiris，一个用户可以注册并发布他们想要重新安家而不是处理掉的旧物清单的应用程序。</p><p id="aa53" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我用React和Redux构建了这个项目的前端，用Ruby on Rails构建了后端。</p><p id="eb69" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">作为这个项目的一部分，我想挑战自己，编写自己的无限滚动组件，在用户滚动列表索引页面时呈现新的列表。</p><p id="fba8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">通过向您介绍所需的变量和函数，我将介绍我是如何做到这一点的；以及如何自己复制这个特征。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="d2ef" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">从哪里开始？</h2><p id="7695" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">当使用无限滚动特性时，你将需要一个无限(不完全是无限)的条目集合来滚动。网上有很多API可供选择，但是对于这个项目，我使用了我自己在Rails服务器上运行的API。</p><p id="3147" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一个重要的注意事项是，所使用的API必须能够根据提供给它的页码返回数据“页”中的信息。</p><p id="ad98" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有了API源，我们现在必须考虑在哪里存储返回的信息。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="d7c5" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">如何储存？</h2><p id="244c" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">用于确定何时加载更多项目的逻辑将需要使用某些变量。通过合并Redux，我将它们存储在全局可用的存储中。</p><p id="79d5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这些变量如下:</p><ul class=""><li id="db6c" class="mt mu iq ku b kv kw ky kz lb mv lf mw lj mx ln my mz na nb bi translated"><code class="fe nc nd ne nf b">allLoaded</code> -一个布尔变量，当从API中检索到所有项目时返回true</li><li id="464a" class="mt mu iq ku b kv ng ky nh lb ni lf nj lj nk ln my mz na nb bi translated"><code class="fe nc nd ne nf b">pageNumber</code> -一个整数，用于跟踪要加载的项目的下一“页”</li><li id="dc67" class="mt mu iq ku b kv ng ky nh lb ni lf nj lj nk ln my mz na nb bi translated"><code class="fe nc nd ne nf b">loading</code> -一个布尔变量，当等待获取请求来检索项目时返回true</li><li id="f13c" class="mt mu iq ku b kv ng ky nh lb ni lf nj lj nk ln my mz na nb bi translated"><code class="fe nc nd ne nf b">listings</code> -已经检索到的所有列表的数组</li></ul></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="e5c5" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">行动</h2><p id="00ef" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">为了根据需要操纵这些变量，特定类型的动作被分派给Redux reducer。</p><p id="4728" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为了能够处理异步操作，使用了Thunk节点，并在创建存储时将其合并到Redux的中间件中:</p><pre class="kh ki kj kk gt nl nf nm nn aw no bi"><span id="0795" class="lv lw iq nf b gy np nq l nr ns">const store = createStore(rootReducer, applyMiddleware(thunk))</span></pre><p id="dc54" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nc nd ne nf b">addListings</code>负责将获取的列表添加到Redux store中。在reducer中，可以看到当返回少于21个清单的响应时,<code class="fe nc nd ne nf b">allLoaded</code>变量被设置为true。这个数字必须反映每页返回的项目数。</p><pre class="kh ki kj kk gt nl nf nm nn aw no bi"><span id="91ef" class="lv lw iq nf b gy np nq l nr ns">// action<br/>export const addListings = listings =&gt; {<br/>    return ({<br/>        type: "ADD_LISTINGS",<br/>        listings<br/>    })<br/>}</span><span id="7da9" class="lv lw iq nf b gy nt nq l nr ns">// reducer case<br/>case "ADD_LISTINGS":<br/>    return {<br/>        ...state,<br/>        pageNumber: state.pageNumber + 1,<br/>        listings: [...state.listings, ...action.listings],<br/>        allLoaded: action.listings.length &lt; 21 ? true : false,<br/>        loading: false,<br/>        show: {}<br/>    }</span></pre><p id="c403" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nc nd ne nf b">loadingListings</code>负责将loading变量设置为<em class="nu"> true </em>，稍后将用于防止向API发送多余的请求。</p><pre class="kh ki kj kk gt nl nf nm nn aw no bi"><span id="852b" class="lv lw iq nf b gy np nq l nr ns">// action<br/>export const loadingListings = () =&gt; {<br/>    return ({<br/>        type: "LOADING_LISTINGS"<br/>    })<br/>}</span><span id="289c" class="lv lw iq nf b gy nt nq l nr ns">// reducer case<br/>case "LOADING_LISTINGS":<br/>    return {...state, loading: true}</span></pre><p id="7328" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><code class="fe nc nd ne nf b">fetchListings</code>操作不同，因为它返回一个接受dispatch作为参数的函数，然后利用thunk中间件异步操作；必要时调度前面的操作。</p><pre class="kh ki kj kk gt nl nf nm nn aw no bi"><span id="0432" class="lv lw iq nf b gy np nq l nr ns">// action<br/>export const fetchListings = (pageNumber) =&gt; {<br/>    return (dispatch) =&gt; {<br/>        dispatch(loadingListings())</span><span id="49fd" class="lv lw iq nf b gy nt nq l nr ns">        fetch(listingURL + '?q=' + pageNumber)<br/>            .then(res=&gt;res.json())<br/>            .then(listings =&gt; dispatch(addListings(listings)))<br/>    }<br/>}</span></pre><p id="8c7b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">最后，<code class="fe nc nd ne nf b">resetAllLoaded</code>用于重置<code class="fe nc nd ne nf b">allLoaded</code>变量，以防更多的列表被呈现。</p><pre class="kh ki kj kk gt nl nf nm nn aw no bi"><span id="4207" class="lv lw iq nf b gy np nq l nr ns">// action<br/>export const resetAllLoaded = () =&gt; {<br/>    return ({<br/>        type: "RESET_ALL_LOADED"<br/>    })<br/>}</span><span id="c2ad" class="lv lw iq nf b gy nt nq l nr ns">// reducer case<br/>case "RESET_ALL_LOADED":<br/>    return {...state, allLoaded: false}</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="3e61" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">成分</h2><p id="06ff" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">有必要具备:</p><ul class=""><li id="87ec" class="mt mu iq ku b kv kw ky kz lb mv lf mw lj mx ln my mz na nb bi translated">一个项目组件，</li><li id="9d6f" class="mt mu iq ku b kv ng ky nh lb ni lf nj lj nk ln my mz na nb bi translated">提取项目时呈现的可选加载组件，以及</li><li id="80a1" class="mt mu iq ku b kv ng ky nh lb ni lf nj lj nk ln my mz na nb bi translated">一个容纳这些项目的容器——这是我们将要构建无限滚动特性的组件。</li></ul></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="c584" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">钩住</h2><p id="4aa5" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">在函数容器组件中，我选择利用React-Redux的钩子函数。</p><p id="c4bc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个方法也可以在扩展React组件时实现，但是需要使用<code class="fe nc nd ne nf b">componentDidMount</code>生命周期事件(如果您想一起探索这个问题，请随时与我联系)。</p><p id="9be5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我用的钩子是:</p><ul class=""><li id="8b78" class="mt mu iq ku b kv kw ky kz lb mv lf mw lj mx ln my mz na nb bi translated"><code class="fe nc nd ne nf b">useSelector</code> -从Redux存储中检索上述变量</li><li id="67f8" class="mt mu iq ku b kv ng ky nh lb ni lf nj lj nk ln my mz na nb bi translated"><code class="fe nc nd ne nf b">useDispatch</code> -利用商场的配送方式</li><li id="a01d" class="mt mu iq ku b kv ng ky nh lb ni lf nj lj nk ln my mz na nb bi translated"><code class="fe nc nd ne nf b">useCallback</code> -编写将在useEffect函数中使用的函数，这些函数将根据其因变量进行更新</li><li id="bb06" class="mt mu iq ku b kv ng ky nh lb ni lf nj lj nk ln my mz na nb bi translated"><code class="fe nc nd ne nf b">useEffect</code> -允许组件在重新渲染时执行动作</li></ul><p id="ff31" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">将这些放在一起，使用了以下函数…</p><p id="12f3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">第一个通过比较输入元素的边界客户矩形来检查输入元素是否完全呈现在用户屏幕上。</p><pre class="kh ki kj kk gt nl nf nm nn aw no bi"><span id="2221" class="lv lw iq nf b gy np nq l nr ns">const isBottom = (el) =&gt; {<br/>    return el.getBoundingClientRect().bottom &lt;= window.innerHeight;<br/>}</span></pre><p id="32cb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这在跟踪滚动回调函数中使用，以检查容器组件是否完全在屏幕上，并且当前没有加载其他项目。它通过id来查找元素，所以您必须确保为您的容器提供一个id。</p><p id="354b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">重要的是将useCallback函数传递给第二个参数<code class="fe nc nd ne nf b">loading</code>和<code class="fe nc nd ne nf b">pageNumber</code>，以便获取的页面是正确的，并且它将包含正确的<code class="fe nc nd ne nf b">loading</code>值。</p><pre class="kh ki kj kk gt nl nf nm nn aw no bi"><span id="4b05" class="lv lw iq nf b gy np nq l nr ns">const trackScrolling = useCallback(() =&gt; {<br/>    const el = document.getElementById('listing-container');<br/>    if (isBottom(el) &amp;&amp; !loading ) {<br/>        fetchListings(pageNumber)(dispatch)<br/>    }<br/>},[pageNumber, dispatch, loading]);</span></pre><p id="bf2b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">需要一个useEffect函数来向文档添加trackScrolling函数，因为这是被滚动的元素。</p><p id="fef7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">它还应该返回一个函数来删除事件侦听器，这将在卸载组件时执行，或者如果传递给该函数的变量数组在两次呈现之间发生了变化。</p><p id="0f25" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">与前面的函数类似，需要将<code class="fe nc nd ne nf b">allLoaded</code>传递到这个变量数组中，以便在没有更多项目要加载的情况下不会附加事件侦听器。</p><pre class="kh ki kj kk gt nl nf nm nn aw no bi"><span id="cec7" class="lv lw iq nf b gy np nq l nr ns">useEffect(() =&gt; {<br/>    if (!allLoaded) document.addEventListener('scroll', trackScrolling);<br/>    return () =&gt; {<br/>        document.removeEventListener('scroll', trackScrolling)<br/>    };<br/>},[trackScrolling, allLoaded, dispatch])</span></pre><p id="464d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">最后，可以添加一个额外的useEffect来重置<code class="fe nc nd ne nf b">allLoaded</code>的值。</p><pre class="kh ki kj kk gt nl nf nm nn aw no bi"><span id="6ae5" class="lv lw iq nf b gy np nq l nr ns">useEffect(() =&gt; {<br/>    return () =&gt; dispatch(resetAllLoaded())<br/>}, [dispatch])</span></pre></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="9298" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">所以为了呈现</h2><p id="8078" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">由于对已经介绍过的函数进行了大量的改进，我选择将我的组件部分呈现如下:</p><pre class="kh ki kj kk gt nl nf nm nn aw no bi"><span id="3402" class="lv lw iq nf b gy np nq l nr ns">&lt;&gt;<br/>    &lt;div id="listing-container" &gt;<br/>        &lt;div className="row row-cols-1 row-cols-md-3 gx-3"&gt;<br/>            {listings.map(listing=&gt;&lt;Listing listing={listing} /&gt;)}<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    {loading &amp;&amp; &lt;LoadingListing /&gt;}<br/>&lt;/&gt;</span></pre><p id="8817" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这里，来自商店的列表被映射以呈现它们各自的元素。</p><p id="ad7f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果loading变量为true，将呈现一个加载组件，如下所示。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nv"><img src="../Images/04cbb06219c10d7830ad64e419528d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9VL9abeDvdnbAAeGBM-upQ.jpeg"/></div></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="0534" class="lv lw iq bd lx ly lz dn ma mb mc dp md lb me mf mg lf mh mi mj lj mk ml mm mn bi translated">到无限和更远的地方…</h2><p id="4457" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">实现这个功能并使用React-Redux的钩子函数编写它的挑战已经非常令人满意了。有了这些，我期待着进一步探索React的功能，并欢迎您的任何建议！</p><p id="39cb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">所有的源代码可以在我的GitHub <a class="ae nw" href="https://github.com/Shilcof/osiris-frontend" rel="noopener ugc nofollow" target="_blank">前端</a>和<a class="ae nw" href="https://github.com/Shilcof/osiris-backend" rel="noopener ugc nofollow" target="_blank">后端</a>找到。</p><p id="888b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一定要让我知道你是如何在你的项目中使用这种技术的——我很想看到任何最终的结果！</p></div></div>    
</body>
</html>