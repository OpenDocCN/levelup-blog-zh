<html>
<head>
<title>Guide to the Express Application Object — Middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速应用对象指南—中间件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/guide-to-the-express-application-object-middleware-241468c3f708?source=collection_archive---------14-----------------------#2020-02-09">https://levelup.gitconnected.com/guide-to-the-express-application-object-middleware-241468c3f708?source=collection_archive---------14-----------------------#2020-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0608d927e938ca766bce610579cf38e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R_TSAmOuD6ig9CgF"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@thiendanga9?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">天当</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2c2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快速应用程序的核心部分是应用程序对象。是应用本身。</p><p id="06a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看<code class="fe le lf lg lh b">app</code>对象的方法以及我们可以用它做什么，包括使用<code class="fe le lf lg lh b">app.use</code>来设置中间件。</p><h1 id="01ef" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">app . use([路径，]回调[，回调…])</h1><p id="962e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">app.use</code>方法来安装在应用程序范围内运行的中间件。</p><p id="81eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们可以在请求特定路径或所有路径时运行。</p><p id="3b9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它采用以下参数:</p><ul class=""><li id="f4e8" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">path</code> —可以是表示路径或路径模式的字符串或正则表达式。默认是<code class="fe le lf lg lh b">/</code>。</li><li id="9d38" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">callback</code> —处理请求的功能。它可以是一个中间件功能、一系列中间件功能、一系列中间件功能或以上所有功能的组合</li></ul><p id="637d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以提供多个回调，它们的行为就像中间件一样，但是它们调用<code class="fe le lf lg lh b">next('route')</code>来跳过剩余的中间件功能。</p><p id="7033" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不需要调用剩余的中间件，我们可以使用这些来对一些路由施加先决条件，并将控制传递给路由。</p><p id="8831" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<code class="fe le lf lg lh b">router</code>和<code class="fe le lf lg lh b">app</code>实现了中间件接口，我们可以像使用任何其他中间件功能一样使用它们。</p><p id="56e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="4878" class="nh lj it lh b gy ni nj l nk nl">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="d149" class="nh lj it lh b gy nm nj l nk nl">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>app.use((req, res, next) =&gt; {<br/>  console.log(`Request made at ${Date.now()}`)<br/>  next();<br/>})</span><span id="eacd" class="nh lj it lh b gy nm nj l nk nl">app.get('/', (req, res) =&gt; {<br/>  res.send('hi');<br/>})</span><span id="fcbb" class="nh lj it lh b gy nm nj l nk nl">app.listen(3000);</span></pre><p id="fa3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们记录每个请求的请求时间。</p><p id="30e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用<code class="fe le lf lg lh b">next</code>来调用路由处理器。</p><p id="8af0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">中间件是按顺序运行的，所以它们在代码中的顺序很重要。</p><p id="0161" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="cd1b" class="nh lj it lh b gy ni nj l nk nl">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="20b3" class="nh lj it lh b gy nm nj l nk nl">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>app.use((req, res, next) =&gt; {<br/>  res.send('End with middleware');<br/>})</span><span id="b6e0" class="nh lj it lh b gy nm nj l nk nl">app.get('/', (req, res) =&gt; {<br/>  res.send('hi');<br/>})</span><span id="8cfe" class="nh lj it lh b gy nm nj l nk nl">app.listen(3000);</span></pre><p id="034f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe le lf lg lh b">End with middleware</code>而不是<code class="fe le lf lg lh b">hi</code>,因为我们用中间件发送了我们的响应，这是我们首先包含的。</p><h2 id="ac96" class="nh lj it bd lk nn no dn lo np nq dp ls kr nr ns lw kv nt nu ma kz nv nw me nx bi translated"><strong class="ak">错误处理中间件</strong></h2><p id="f5f0" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以创建自己的中间件来处理错误，而不是使用Express的默认错误处理程序。</p><p id="f500" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">错误处理程序有4个参数，分别是错误对象、请求对象、响应对象和下一个函数。</p><p id="7744" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以定义如下:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="1d10" class="nh lj it lh b gy ni nj l nk nl">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="da9d" class="nh lj it lh b gy nm nj l nk nl">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="cd1d" class="nh lj it lh b gy nm nj l nk nl">app.get('/', (req, res, next) =&gt; {<br/>  try {<br/>    throw new Error('foo');<br/>  }<br/>  catch (ex) {<br/>    next(ex);<br/>  }<br/>})</span><span id="8006" class="nh lj it lh b gy nm nj l nk nl">app.use((err, req, res, next) =&gt; {<br/>  res.status(500).send('error');<br/>})</span><span id="3fb9" class="nh lj it lh b gy nm nj l nk nl">app.listen(3000);</span></pre><p id="c083" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">应该会显示<code class="fe le lf lg lh b">error</code>,因为我们在GET请求处理程序之后包含了错误处理程序。</p><h2 id="b23c" class="nh lj it bd lk nn no dn lo np nq dp ls kr nr ns lw kv nt nu ma kz nv nw me nx bi translated">小路</h2><p id="48bc" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以用字符串或正则表达式路径或路径模式作为<code class="fe le lf lg lh b">use</code>方法的第一个参数。这样，只有当路由匹配string或regex中指定的路由时，中间件才会被调用。</p><p id="2432" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了匹配一个常量路径，我们可以写如下:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="3ec4" class="nh lj it lh b gy ni nj l nk nl">app.use('/abc', (err, req, res, next) =&gt; {<br/>  res.status(500).send('error');<br/>})</span></pre><p id="4fe9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下匹配模式。一个<code class="fe le lf lg lh b">?</code>将使它前面的字符可选:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="04ed" class="nh lj it lh b gy ni nj l nk nl">app.use('/abc?d', (err, req, res, next) =&gt; {<br/>  res.status(500).send('error');<br/>})</span></pre><p id="6b5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当对<code class="fe le lf lg lh b">/abcd</code>或<code class="fe le lf lg lh b">/abd</code>的请求出错时，上面的中间件将被调用。</p><p id="8f14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">+</code>符号意味着它前面的一个或多个字符将被匹配。例如，如果我们有:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="4cc5" class="nh lj it lh b gy ni nj l nk nl">app.use('/abc+d', (err, req, res, next) =&gt; {<br/>  res.status(500).send('error');<br/>})</span></pre><p id="415a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当向<code class="fe le lf lg lh b">/abccd</code>、<code class="fe le lf lg lh b">/abcccd</code>等发出请求时。有一个错误，上面的中间件将被调用。</p><p id="2cd8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">*</code>是通配符。我们可以如下使用它:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="f8ed" class="nh lj it lh b gy ni nj l nk nl">app.use('/ab*cd', (err, req, res, next) =&gt; {<br/>  res.status(500).send('error');<br/>})</span></pre><p id="fed6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们向<code class="fe le lf lg lh b">/abcccd</code>、<code class="fe le lf lg lh b">/abFoocd</code>发出请求时，我们得到<code class="fe le lf lg lh b">error</code>，等等，如果有错误的话。</p><p id="f206" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了匹配一组可选字符，我们可以在它后面使用括号和一个问号。</p><p id="7f7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="f2eb" class="nh lj it lh b gy ni nj l nk nl">app.use('/a(bcd)?e', (err, req, res, next) =&gt; {<br/>  res.status(500).send('error');<br/>})</span></pre><p id="16c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们向有错误的<code class="fe le lf lg lh b">/abcde</code>或<code class="fe le lf lg lh b">/ae</code>发出请求时，我们得到<code class="fe le lf lg lh b">error</code>。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/efca0fce9e45e7c857a6f35c3a6e1903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0PrgtoXbgxQT2D6_"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Patrick Reichboth 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="ee1a" class="nh lj it bd lk nn no dn lo np nq dp ls kr nr ns lw kv nt nu ma kz nv nw me nx bi translated">传入中间件</h2><p id="9141" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">除了一个中间件之外，我们还可以传入不同的中间件组合。</p><p id="ba1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以传入一个<code class="fe le lf lg lh b">router</code>对象作为中间件，如下所示:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="94cc" class="nh lj it lh b gy ni nj l nk nl">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="705b" class="nh lj it lh b gy nm nj l nk nl">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="e8e4" class="nh lj it lh b gy nm nj l nk nl">const router = express.Router();<br/>router.get('/', (req, res, next) =&gt; {<br/>  res.send();<br/>});</span><span id="e368" class="nh lj it lh b gy nm nj l nk nl">app.use(router);</span><span id="4cff" class="nh lj it lh b gy nm nj l nk nl">app.listen(3000);</span></pre><p id="23bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快速应用程序也是有效的中间件:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="40e4" class="nh lj it lh b gy ni nj l nk nl">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="fb15" class="nh lj it lh b gy nm nj l nk nl">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="1eed" class="nh lj it lh b gy nm nj l nk nl">const subApp = express();</span><span id="9cbf" class="nh lj it lh b gy nm nj l nk nl">subApp.get('/', (req, res, next) =&gt; {<br/>  res.send();<br/>});</span><span id="5f1c" class="nh lj it lh b gy nm nj l nk nl">app.use(subApp);</span><span id="0233" class="nh lj it lh b gy nm nj l nk nl">app.listen(3000);</span></pre><p id="7cab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以传入一系列中间件作为参数:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="9589" class="nh lj it lh b gy ni nj l nk nl">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="661f" class="nh lj it lh b gy nm nj l nk nl">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>const r1 = express.Router();<br/>r1.get('/', (req, res, next) =&gt; {<br/>  console.log('r1 called');<br/>  next();<br/>});</span><span id="5fa7" class="nh lj it lh b gy nm nj l nk nl">const r2 = express.Router();<br/>r2.get('/', (req, res, next) =&gt; {<br/>  console.log('r2 called');<br/>  next();<br/>});<br/>app.use(r1, r2);</span><span id="ee6f" class="nh lj it lh b gy nm nj l nk nl">app.listen(3000);</span></pre><p id="4df9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后它们将按顺序被调用，所以我们得到:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="f544" class="nh lj it lh b gy ni nj l nk nl">r1 called<br/>r2 called</span></pre><p id="a9cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在控制台里。</p><p id="c0ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以传入一组中间件，如下所示:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="577b" class="nh lj it lh b gy ni nj l nk nl">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="bd32" class="nh lj it lh b gy nm nj l nk nl">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>const r1 = express.Router();<br/>r1.get('/', (req, res, next) =&gt; {<br/>  console.log('r1 called');<br/>  next();<br/>});</span><span id="3b83" class="nh lj it lh b gy nm nj l nk nl">const r2 = express.Router();<br/>r2.get('/', (req, res, next) =&gt; {<br/>  console.log('r2 called');<br/>  next();<br/>});<br/>app.use([r1, r2]);</span><span id="df16" class="nh lj it lh b gy nm nj l nk nl">app.listen(3000);</span></pre><p id="4433" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到相同的输出，因为它们是按照列出的顺序被调用的。</p><p id="ca3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们的组合也是有效的:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="70e6" class="nh lj it lh b gy ni nj l nk nl">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();</span><span id="94ab" class="nh lj it lh b gy nm nj l nk nl">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>const foo = (req, res, next) =&gt; {<br/>  console.log('foo called');<br/>  next();<br/>}</span><span id="62af" class="nh lj it lh b gy nm nj l nk nl">const r1 = express.Router();<br/>r1.get('/', (req, res, next) =&gt; {<br/>  console.log('r1 called');<br/>  next();<br/>});</span><span id="e730" class="nh lj it lh b gy nm nj l nk nl">const r2 = express.Router();<br/>r2.get('/', (req, res, next) =&gt; {<br/>  console.log('r2 called');<br/>  next();<br/>});</span><span id="7324" class="nh lj it lh b gy nm nj l nk nl">const subApp = express();<br/>subApp.get('/', (req, res, next) =&gt; {<br/>  console.log('subApp called');<br/>  next();<br/>})</span><span id="fae3" class="nh lj it lh b gy nm nj l nk nl">app.use(foo, [r1, r2], subApp);</span><span id="28d1" class="nh lj it lh b gy nm nj l nk nl">app.listen(3000);</span></pre><p id="1a43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="0bc7" class="nh lj it lh b gy ni nj l nk nl">foo called<br/>r1 called<br/>r2 called<br/>subApp called</span></pre><p id="84cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从控制台。它们仍然按照列出的顺序被调用。</p><h2 id="3164" class="nh lj it bd lk nn no dn lo np nq dp ls kr nr ns lw kv nt nu ma kz nv nw me nx bi translated">静态文件</h2><p id="0b8d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以用<code class="fe le lf lg lh b">express.static</code>中间件公开静态文件夹。例如，如果我们想在项目文件夹中公开<code class="fe le lf lg lh b">public</code>文件夹，我们可以写:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="b04c" class="nh lj it lh b gy ni nj l nk nl">app.use(express.static(path.join(__dirname, 'public')));</span></pre><h1 id="f8e8" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="2539" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">app.use</code>可用于多种组合的一个或多个中间件，包括单个中间件、中间件阵列、中间件逗号分隔列表或它们的组合。</p><p id="f026" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们按照被包含的顺序被调用，下一个可以通过调用<code class="fe le lf lg lh b">next</code>来调用。</p><p id="766f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">错误处理器也是中间件功能。唯一的区别是它们在请求和响应参数之前有一个<code class="fe le lf lg lh b">error</code>参数。</p><p id="83b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以用<code class="fe le lf lg lh b">express.static</code>中间件公开静态文件夹。</p></div></div>    
</body>
</html>