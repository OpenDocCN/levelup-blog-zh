<html>
<head>
<title>An Introduction to Deterministic Builds with C/C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C/C++确定性构建简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-introduction-to-deterministic-builds-with-c-c-ab03cda36499?source=collection_archive---------24-----------------------#2020-06-05">https://levelup.gitconnected.com/an-introduction-to-deterministic-builds-with-c-c-ab03cda36499?source=collection_archive---------24-----------------------#2020-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="c8db" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">什么是确定性构建？</h1><p id="f29e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">确定性构建是用相同的构建环境和构建指令构建相同的源代码的过程，在两个构建中生成相同的二进制文件，即使它们是在不同的机器上、构建目录下以不同的名称构建的。如果即使从不同的文件夹编译也能保证产生相同的二进制文件，那么它们有时也被称为可复制的或密封的构建。</p><p id="9e11" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">确定性构建不是自然发生的事情。正常的项目不会产生确定性的构建，并且对于每个操作系统和编译器，不产生确定性构建的原因可能是不同的。</p><p id="6101" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">对于给定的<em class="lr">构建环境</em>，应该保证确定性的构建。这意味着某些变量，如<em class="lr">操作系统</em>、<em class="lr">构建系统版本</em>和<em class="lr">目标架构</em>在不同的构建之间保持不变。</p><p id="aa70" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在过去的几年里，不同的组织做出了很多努力来实现确定性的构建，比如<a class="ae ls" href="https://www.chromium.org/developers/testing/isolated-testing/deterministic-builds" rel="noopener ugc nofollow" target="_blank"> Chromium </a>、<a class="ae ls" href="https://reproducible-builds.org/" rel="noopener ugc nofollow" target="_blank">可重现的构建</a>或者<a class="ae ls" href="https://wiki.yoctoproject.org/wiki/Reproducible_Builds" rel="noopener ugc nofollow" target="_blank"> Yocto </a>。</p><h1 id="0200" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">确定性构建的重要性</h1><p id="9af1" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">确定性构建之所以重要，有两个主要原因:</p><ul class=""><li id="e2b3" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated"><strong class="kq iu">安全</strong>。修改二进制文件而不是上游源代码会使原始作者看不到更改。这在医疗、航空和汽车等安全关键环境中可能是致命的。承诺给定输入的相同结果允许第三方就正确的<em class="lr">结果达成共识。</em></li><li id="c4cc" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><strong class="kq iu">可追溯性和二进制管理</strong>。如果您希望有一个存储库来存储您的二进制文件，那么您不希望从相同版本的源代码中生成带有随机校验和的二进制文件。这可能导致存储库系统将不同的二进制文件存储为不同的版本，而它们应该是相同的。例如，如果您在Windows或MacOs上工作，最简单的库将导致具有不同校验和的二进制文件，因为这些操作系统的库格式中包含时间戳。</li></ul><h1 id="92fb" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">C/C++构建过程中涉及的二进制文件</h1><p id="980d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">根据操作系统的不同，在C/C++的构建过程中会创建不同类型的二进制文件。</p><ul class=""><li id="60cc" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated"><strong class="kq iu">微软视窗</strong>。最重要的文件是扩展名为<code class="fe mh mi mj mk b">.obj</code>、<code class="fe mh mi mj mk b">.lib</code>、<code class="fe mh mi mj mk b">.dll</code>和<code class="fe mh mi mj mk b">.exe</code>的文件。它们都遵循可移植可执行格式(PE)的规范。这些文件可以用<a class="ae ls" href="https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-reference?view=vs-2019" rel="noopener ugc nofollow" target="_blank"> dumpbin </a>等工具进行分析。</li><li id="06d7" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><strong class="kq iu"> Linux </strong>。扩展名为<code class="fe mh mi mj mk b">.o</code>、<code class="fe mh mi mj mk b">.a</code>、<code class="fe mh mi mj mk b">.so</code>和<code class="fe mh mi mj mk b">none</code>(用于可执行二进制文件)的文件遵循可执行可链接格式(ELF)。ELF文件的内容可以通过<a class="ae ls" href="https://sourceware.org/binutils/docs/binutils/readelf.html" rel="noopener ugc nofollow" target="_blank"> readelf </a>进行分析。</li><li id="3c05" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><strong class="kq iu"> Mac OS </strong>。扩展名为<code class="fe mh mi mj mk b">.o</code>、<code class="fe mh mi mj mk b">.a</code>、<code class="fe mh mi mj mk b">.dylib</code>和<code class="fe mh mi mj mk b">none</code>(用于可执行二进制文件)的文件遵循Mach-O格式规范。这些文件可以通过MacOs中XCode工具链中的<a class="ae ls" href="https://opensource.apple.com/source/cctools/cctools-921/otool/" rel="noopener ugc nofollow" target="_blank"> otool </a>应用程序进行检查。</li></ul><h1 id="2af2" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">变异的来源</h1><p id="6aae" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">许多不同的因素会使你的构建<em class="lr">不确定</em>。不同的操作系统和编译器会有不同的因素。每个编译器都有特定的选项来修复不确定性的来源。到目前为止，<code class="fe mh mi mj mk b">gcc</code>和<code class="fe mh mi mj mk b">clang</code>是合并了更多选项来修复变异源的版本。对于<code class="fe mh mi mj mk b">msvc</code>,您可以尝试一些未记录的选项，但最终，您可能需要修补二进制文件以获得确定性版本。</p><h1 id="1660" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">编译器/链接器引入的时间戳</h1><p id="f89c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们的二进制文件最终可能包含时间信息，这将使它们不可再现，这有两个主要原因:</p><ul class=""><li id="fd28" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated">在源代码中使用<code class="fe mh mi mj mk b">__DATE__</code>或<code class="fe mh mi mj mk b">__TIME__</code>宏。</li><li id="bea4" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated">当文件格式的定义强制在目标文件中存储时间信息时。Windows中的<em class="lr">可移植可执行文件</em>格式和MacOs中的<code class="fe mh mi mj mk b">Mach-O</code>就是这种情况。在Linux中，<code class="fe mh mi mj mk b">ELF</code>文件不编码任何类型的时间戳。</li></ul><p id="cdcc" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">让我们举一个例子，用一个链接MacOs中静态库的基本hello world项目来说明这些信息在哪里结束。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1a70" class="mt jr it mk b gy mu mv l mw mx"><em class="lr">.<br/></em>├── CMakeLists.txt<br/>├── hello_world.cpp<br/>├── hello_world.hpp<br/>├── main.cpp<br/>└── run_build.sh</span></pre><p id="e311" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">库在终端中打印一条消息:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ee70" class="mt jr it mk b gy mu mv l mw mx"><strong class="mk iu">#include "hello_world.hpp"<br/>#include &lt;iostream&gt;<br/>void</strong> HelloWorld<strong class="mk iu">::</strong>PrintMessage(<strong class="mk iu">const</strong> std<strong class="mk iu">::</strong>string <strong class="mk iu">&amp;</strong> message)<br/>{<br/>    std<strong class="mk iu">::</strong>cout <strong class="mk iu">&lt;&lt;</strong> message <strong class="mk iu">&lt;&lt;</strong> std<strong class="mk iu">::</strong>endl;<br/>}</span></pre><p id="a9c2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">应用程序将使用它来打印“Hello World！”消息:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8bca" class="mt jr it mk b gy mu mv l mw mx"><strong class="mk iu">#include &lt;iostream&gt;<br/>#include "hello_world.hpp"<br/>int</strong> <strong class="mk iu">main</strong>(<strong class="mk iu">int</strong> argc, <strong class="mk iu">char**</strong> argv)<br/>{<br/>    HelloWorld hello;<br/>    hello.PrintMessage("Hello World!");<br/>    <strong class="mk iu">return</strong> 0;<br/>}</span></pre><p id="52de" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们将使用CMake来构建项目:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f9b2" class="mt jr it mk b gy mu mv l mw mx">cmake_minimum_required(VERSION 3.0)<br/>project(HelloWorld)<br/>set(CMAKE_CXX_STANDARD 11)<br/>set(CMAKE_CXX_STANDARD_REQUIRED ON)<br/>add_library(HelloLibA hello_world.cpp)<br/>add_library(HelloLibB hello_world.cpp)<br/>add_executable(helloA main.cpp)<br/>add_executable(helloB main.cpp)<br/>target_link_libraries(helloA HelloLibA)<br/>target_link_libraries(helloB HelloLibB)</span></pre><p id="b651" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们用完全相同的源代码构建了两个不同的库，并用相同的源代码构建了两个二进制文件。如果我们构建项目并执行md5sum来显示所有二进制文件的校验和:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9899" class="mt jr it mk b gy mu mv l mw mx">mkdir build &amp;&amp; cd build<br/>cmake ..<br/>make<br/>md5sum helloA<br/>md5sum helloB<br/>md5sum CMakeFiles/HelloLibA.dir/hello_world.cpp.o<br/>md5sum CMakeFiles/HelloLibB.dir/hello_world.cpp.o<br/>md5sum libHelloLibA.a<br/>md5sum libHelloLibB.a</span></pre><p id="6056" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们得到这样的输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fc4a" class="mt jr it mk b gy mu mv l mw mx">b5dce09c593658ee348fd0f7fae22c94  helloA<br/>b5dce09c593658ee348fd0f7fae22c94  helloB<br/>0a4a0de3df8cc7f053f2fcb6d8b75e6d  CMakeFiles/HelloLibA.dir/hello_world.cpp.o<br/>0a4a0de3df8cc7f053f2fcb6d8b75e6d  CMakeFiles/HelloLibB.dir/hello_world.cpp.o<br/>adb80234a61bb66bdc5a3b4b7191eac7  libHelloLibA.a<br/>5ac3c70d28d9fdd9c6571e077131545e  libHelloLibB.a</span></pre><p id="00f2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这很有趣，因为可执行文件<code class="fe mh mi mj mk b">helloA</code>和<code class="fe mh mi mj mk b">helloB</code>以及中间Mach-O对象文件<code class="fe mh mi mj mk b">hello_world.cpp.o</code>具有相同的校验和，但<code class="fe mh mi mj mk b">.a</code>文件却不是这样。这是因为它们将中间对象文件的信息存储在<code class="fe mh mi mj mk b">archive format</code>中。这种格式的头定义包括一个名为<code class="fe mh mi mj mk b">st_time</code>的字段，由一个<code class="fe mh mi mj mk b">stat</code>系统调用设置。如果我们使用<code class="fe mh mi mj mk b">otool</code>显示接头来检查<code class="fe mh mi mj mk b">libHelloLibA.a</code>和<code class="fe mh mi mj mk b">libHelloLibB.a</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b62d" class="mt jr it mk b gy mu mv l mw mx">&gt; otool -a libHelloLibA.a   <br/>Archive : libHelloLibA.a<br/>0100644 503/20    612 1566927276 #1/20<br/>0100644 503/20  13036 1566927271 #1/28<br/>&gt; otool -a libHelloLibB.a   <br/>Archive : libHelloLibB.a<br/>0100644 503/20    612 1566927277 #1/20<br/>0100644 503/20  13036 1566927272 #1/28</span></pre><p id="bafd" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们可以看到，该文件包括几个时间字段，这将使我们的构建不确定。请注意，这些字段没有传播到最终的可执行文件，因为它们具有相同的校验和。如果用Visual Studio在Windows中构建，但用的是<code class="fe mh mi mj mk b">Portable Executable</code>而不是<code class="fe mh mi mj mk b">Mach-O</code>，也会出现这个问题。</p><p id="160d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在这一点上，我们可以试着让事情变得更糟，并强迫我们的二进制文件也是非确定性的。如果我们改变<code class="fe mh mi mj mk b">main.cpp</code>文件以包含<code class="fe mh mi mj mk b">__TIME__</code>宏:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f116" class="mt jr it mk b gy mu mv l mw mx"><strong class="mk iu">#include &lt;iostream&gt;<br/>#include "hello_world.hpp"<br/>int</strong> <strong class="mk iu">main</strong>(<strong class="mk iu">int</strong> argc, <strong class="mk iu">char**</strong> argv)<br/>{<br/>    HelloWorld hello;<br/>    hello.PrintMessage("Hello World!");<br/>    std<strong class="mk iu">::</strong>cout <strong class="mk iu">&lt;&lt;</strong> "At time: " <strong class="mk iu">&lt;&lt;</strong> __TIME__ <strong class="mk iu">&lt;&lt;</strong> std<strong class="mk iu">::</strong>endl;<br/>    <strong class="mk iu">return</strong> 0;<br/>}</span></pre><p id="f88d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">再次获取文件的校验和:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9a78" class="mt jr it mk b gy mu mv l mw mx">625ecc7296e15d41e292f67b57b04f15  helloA<br/>20f92d2771a7d2f9866c002de918c4da  helloB<br/>0a4a0de3df8cc7f053f2fcb6d8b75e6d  CMakeFiles/HelloLibA.dir/hello_world.cpp.o<br/>0a4a0de3df8cc7f053f2fcb6d8b75e6d  CMakeFiles/HelloLibB.dir/hello_world.cpp.o<br/>b7801c60d3bc4f83640cadc1183f43b3  libHelloLibA.a<br/>4ef6cae3657f2a13ed77830953b0aee8  libHelloLibB.a</span></pre><p id="a124" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们看到现在我们也有不同的二进制文件。我们可以使用诸如<a class="ae ls" href="https://diffoscope.org/" rel="noopener ugc nofollow" target="_blank"> diffoscope </a>这样的工具来分析可执行文件，向我们展示两个二进制文件之间的区别:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d168" class="mt jr it mk b gy mu mv l mw mx">&gt; diffoscope helloA helloB<br/>--- helloA<br/>+++ helloB<br/>├── otool -arch x86_64 -tdvV {}<br/>│┄ Code for architecture x86_64<br/>│ @@ -16,15 +16,15 @@<br/>│  00000001000018da	jmp	0x1000018df<br/>│  00000001000018df	leaq	-0x30(%rbp), %rdi<br/>│  00000001000018e3	callq	0x100002d54 #<em class="lr"># symbol stub for: __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED1Ev</em><br/>│  00000001000018e8	movq	0x1721(%rip), %rdi #<em class="lr"># literal pool symbol address: __ZNSt3__14coutE</em><br/>│  00000001000018ef	leaq	0x162f(%rip), %rsi #<em class="lr"># literal pool for: "At time: "</em><br/>│  00000001000018f6	callq	0x100002d8a #<em class="lr"># symbol stub for: __ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc</em><br/>│  00000001000018fb	movq	%rax, %rdi<br/>│ -00000001000018fe	leaq	0x162a(%rip), %rsi #<em class="lr"># literal pool for: "19:40:47"</em><br/>│ +00000001000018fe	leaq	0x162a(%rip), %rsi #<em class="lr"># literal pool for: "19:40:48"</em><br/>│  0000000100001905	callq	0x100002d8a #<em class="lr"># symbol stub for: __ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc</em><br/>│  000000010000190a	movq	%rax, %rdi<br/>│  000000010000190d	leaq	__ZNSt3__1L4endlIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_(%rip), %rsi #</span></pre><p id="4085" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这表明<code class="fe mh mi mj mk b">__TIME__</code>信息被插入到二进制文件中，使其具有不确定性。让我们看看我们能做些什么来避免这种情况。</p><h2 id="0076" class="mt jr it bd js my mz dn jw na nb dp ka kz nc nd ke ld ne nf ki lh ng nh km ni bi translated">Microsoft Visual Studio的可能解决方案</h2><p id="6bc4" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Microsoft Visual Studio有一个链接器标志<code class="fe mh mi mj mk b">/Brepro</code>，这是Microsoft没有记录的。该标志将时间戳从<code class="fe mh mi mj mk b">Portable Executable</code>格式设置为<code class="fe mh mi mj mk b">-1</code>值，如下图所示。</p><figure class="ml mm mn mo gt nk gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nj"><img src="../Images/8fae47593de6e8a932102a8458166b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZGjq0apnnw8e_Q0a.png"/></div></div></figure><p id="0fcd" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">要使用CMake激活该标志，如果创建一个<code class="fe mh mi mj mk b">.exe</code>，我们必须添加这些行:</p><p id="12a0" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><code class="fe mh mi mj mk b"><strong class="kq iu">add_link_options</strong>("/Brepro")</code></p><p id="069a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">还是这个为<code class="fe mh mi mj mk b">.lib</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d8e9" class="mt jr it mk b gy mu mv l mw mx">set_target_properties(<br/>    TARGET<br/>    PROPERTIES STATIC_LIBRARY_OPTIONS "/Brepro"<br/>)</span></pre><p id="dd02" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">问题是，这个标志使得二进制文件是可复制的(关于文件格式中的时间戳),在我们的最终二进制文件中是一个<code class="fe mh mi mj mk b">.exe</code>,但不会从<code class="fe mh mi mj mk b">.lib</code>中删除所有时间戳(与我们在上面讨论的Mach-O对象文件的问题相同)。<code class="fe mh mi mj mk b">.lib</code>文件的<a class="ae ls" href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#file-headers" rel="noopener ugc nofollow" target="_blank"> COFF文件头</a>中的<code class="fe mh mi mj mk b">TimeDateStamp</code>字段将保留。从<code class="fe mh mi mj mk b">.lib</code>二进制文件中删除该信息的唯一方法是用任何已知值替换对应于<code class="fe mh mi mj mk b">TimeDateStamp</code>字段的字节来修补<code class="fe mh mi mj mk b">.lib</code>。</p><h2 id="b0a2" class="mt jr it bd js my mz dn jw na nb dp ka kz nc nd ke ld ne nf ki lh ng nh km ni bi translated">GCC和CLANG的可能解决方案</h2><ul class=""><li id="fd51" class="lt lu it kq b kr ks kv kw kz nr ld ns lh nt ll ly lz ma mb bi translated"><code class="fe mh mi mj mk b">gcc</code>检测<code class="fe mh mi mj mk b">SOURCE_DATE_EPOCH</code>环境变量的存在。如果设置了该变量，其值指定了一个UNIX时间戳，用于替换<code class="fe mh mi mj mk b">__DATE__</code>和<code class="fe mh mi mj mk b">__TIME__</code>宏中的当前日期和时间，以便嵌入的时间戳可重复。该值可以设置为已知的时间戳，例如源或包的最后修改时间。</li><li id="b75c" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><code class="fe mh mi mj mk b">clang</code>利用<code class="fe mh mi mj mk b">ZERO_AR_DATE</code>，如果设置则重置<code class="fe mh mi mj mk b">archive files</code>中引入的时间戳，将其设置为<code class="fe mh mi mj mk b">epoch 0</code>。考虑到这不会修复<code class="fe mh mi mj mk b">__DATE__</code>或<code class="fe mh mi mj mk b">__TIME__</code>宏。如果我们想修复这些宏的影响，我们应该要么修补二进制文件，要么伪造系统时间。</li></ul><p id="aae7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">让我们继续我们的MacOs示例项目，看看设置<code class="fe mh mi mj mk b">ZERO_AR_DATE</code>环境变量时的结果。</p><p id="32dc" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><code class="fe mh mi mj mk b">export ZERO_AR_DATE=1</code></p><p id="8c20" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在，如果我们构建我们的可执行文件和库(省略源代码中的<code class="fe mh mi mj mk b">__DATE__</code>宏)，我们会得到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5b1c" class="mt jr it mk b gy mu mv l mw mx">b5dce09c593658ee348fd0f7fae22c94  helloA<br/>b5dce09c593658ee348fd0f7fae22c94  helloB<br/>0a4a0de3df8cc7f053f2fcb6d8b75e6d  CMakeFiles/HelloLibA.dir/hello_world.cpp.o<br/>0a4a0de3df8cc7f053f2fcb6d8b75e6d  CMakeFiles/HelloLibB.dir/hello_world.cpp.o<br/>9f9a9af4bb3e220e7a22fb58d708e1e5  libHelloLibA.a<br/>9f9a9af4bb3e220e7a22fb58d708e1e5  libHelloLibB.a</span></pre><p id="5172" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">所有校验和现在都是一样的。并分析<code class="fe mh mi mj mk b">.a</code>文件头:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c321" class="mt jr it mk b gy mu mv l mw mx">&gt; otool -a libHelloLibA.a<br/>Archive : libHelloLibA.a<br/>0100644 503/20    612 0 #1/20<br/>0100644 503/20  13036 0 #1/28<br/>&gt; otool -a libHelloLibB.a<br/>Archive : libHelloLibB.a<br/>0100644 503/20    612 0 #1/20<br/>0100644 503/20  13036 0 #1/28</span></pre><p id="c22b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们可以看到库头的时间戳字段被设置为零值。</p><h1 id="b372" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">传播到二进制文件的构建文件夹信息</h1><p id="a7a1" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果相同的源代码在不同的文件夹中编译，有时文件夹信息会传播到二进制文件中。发生这种情况主要有两个原因:</p><ul class=""><li id="daaa" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated">使用包含当前文件信息的宏，如<code class="fe mh mi mj mk b">__FILE__</code>宏。</li><li id="49c3" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated">创建存储源代码位置信息的调试二进制文件。</li></ul><p id="6389" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">继续我们的hello world MacOs示例，让我们分离源代码，这样我们可以显示最终二进制文件的效果。项目结构如下所示。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cc23" class="mt jr it mk b gy mu mv l mw mx"><em class="lr">.<br/></em>├── run_build.sh<br/>├── srcA<br/>│   ├── CMakeLists.txt<br/>│   ├── hello_world.cpp<br/>│   ├── hello_world.hpp<br/>│   └── main.cpp<br/>└── srcB<br/>    ├── CMakeLists.txt<br/>    ├── hello_world.cpp<br/>    ├── hello_world.hpp<br/>    └── main.cpp</span></pre><p id="618b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果我们以<code class="fe mh mi mj mk b">Debug</code>模式构建我们的二进制文件。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b719" class="mt jr it mk b gy mu mv l mw mx">cd srcA/build<br/>cmake -DCMAKE_BUILD_TYPE=Debug ..<br/>make<br/>cd .. &amp;&amp; cd ..<br/>cd srcB/build<br/>cmake -DCMAKE_BUILD_TYPE=Debug ..<br/>make<br/>cd .. &amp;&amp; cd ..<br/>md5sum srcA/build/hello<br/>md5sum srcB/build/hello<br/>md5sum srcA/build/CMakeFiles/HelloLib.dir/hello_world.cpp.o<br/>md5sum srcB/build/CMakeFiles/HelloLib.dir/hello_world.cpp.o<br/>md5sum srcA/build/libHelloLib.a<br/>md5sum srcB/build/libHelloLib.a</span></pre><p id="c756" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们得到以下校验和:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7a00" class="mt jr it mk b gy mu mv l mw mx">3572a95a8699f71803f3e967f92a5040  srcA/build/hello<br/>7ca693295e62de03a1bba14853efa28c  srcB/build/hello<br/>76e0ae7c4ef79ec3be821ccf5752730f  srcA/build/CMakeFiles/HelloLib.dir/hello_world.cpp.o<br/>5ef044e6dcb73359f46d48f29f566ae5  srcB/build/CMakeFiles/HelloLib.dir/hello_world.cpp.o<br/>dc941156608b578c91e38f8ecebfef6d  srcA/build/libHelloLib.a<br/>1f9697ef23bf70b41b39ef3469845f76  srcB/build/libHelloLib.a</span></pre><p id="5d07" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">文件夹信息从目标文件传播到最终的可执行文件，使得我们的构建不可复制。我们可以使用diffoscope显示二进制文件之间的差异，以查看文件夹信息嵌入的位置。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="122e" class="mt jr it mk b gy mu mv l mw mx">&gt; diffoscope helloA helloB<br/>--- srcA/build/hello<br/>+++ srcB/build/hello<br/>@@ -1282,20 +1282,20 @@<br/><em class="lr">...<br/></em> 00005070: 5f77 6f72 6c64 5f64 6562 7567 2f73 7263  _world_debug/src<br/>-00005080: 412f 006d 6169 6e2e 6370 7000 2f55 7365  A/.main.cpp./Use<br/>+00005080: 422f 006d 6169 6e2e 6370 7000 2f55 7365  B/.main.cpp./Use<br/> 00005090: 7273 2f63 6172 6c6f 732f 446f 6375 6d65  rs/carlos/Docume<br/> 000050a0: 6e74 732f 6465 7665 6c6f 7065 722f 7265  nts/developer/re<br/> 000050b0: 7072 6f64 7563 6962 6c65 2d62 7569 6c64  producible-build<br/> 000050c0: 732f 7361 6e64 626f 782f 6865 6c6c 6f5f  s/sandbox/hello_<br/>-000050d0: 776f 726c 645f 6465 6275 672f 7372 6341  world_debug/srcA<br/>+000050d0: 776f 726c 645f 6465 6275 672f 7372 6342  world_debug/srcB<br/> 000050e0: 2f62 7569 6c64 2f43 4d61 6b65 4669 6c65  /build/CMakeFile<br/> 000050f0: 732f 6865 6c6c 6f2e 6469 722f 6d61 696e  s/hello.dir/main<br/> 00005100: 2e63 7070 2e6f 005f 6d61 696e 005f 5f5a  .cpp.o._main.__Z<br/><em class="lr">...<br/></em>@@ -1336,15 +1336,15 @@<br/><em class="lr">...<br/></em> 000053c0: 6962 6c65 2d62 7569 6c64 732f 7361 6e64  ible-builds/sand<br/> 000053d0: 626f 782f 6865 6c6c 6f5f 776f 726c 645f  box/hello_world_<br/>-000053e0: 6465 6275 672f 7372 6341 2f62 7569 6c64  debug/srcA/build<br/>+000053e0: 6465 6275 672f 7372 6342 2f62 7569 6c64  debug/srcB/build<br/> 000053f0: 2f6c 6962 4865 6c6c 6f4c 6962 2e61 2868  /libHelloLib.a(h<br/> 00005400: 656c 6c6f 5f77 6f72 6c64 2e63 7070 2e6f  ello_world.cpp.o<br/> 00005410: 2900 5f5f 5a4e 3130 4865 6c6c 6f57 6f72  ).__ZN10HelloWor<br/><em class="lr">...</em></span></pre><h2 id="3761" class="mt jr it bd js my mz dn jw na nb dp ka kz nc nd ke ld ne nf ki lh ng nh km ni bi translated">可能的解决方案</h2><p id="c0b0" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">同样，解决方案取决于所使用的编译器:</p><ul class=""><li id="7c9e" class="lt lu it kq b kr lm kv ln kz lv ld lw lh lx ll ly lz ma mb bi translated"><code class="fe mh mi mj mk b">msvc</code>无法设置选项以避免此信息传播到二进制文件。获得可再现的二进制文件的唯一方法是在构建步骤中再次使用修补工具来去除这些信息。请注意，当我们修补二进制文件以获得可复制的二进制文件时，用于不同构建的文件夹应该具有相同的字符长度。</li><li id="2985" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><code class="fe mh mi mj mk b">gcc</code>有三个编译器标志来解决这个问题:</li><li id="c6b2" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><code class="fe mh mi mj mk b">-fdebug-prefix-map=OLD=NEW</code>可以从调试信息中去除目录前缀。</li><li id="749e" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><code class="fe mh mi mj mk b">-fmacro-prefix-map=OLD=NEW</code>从<code class="fe mh mi mj mk b">gcc 8</code>开始可用，解决了因使用<code class="fe mh mi mj mk b">__FILE__</code>宏而导致的不可再现性。</li><li id="d037" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><code class="fe mh mi mj mk b">-ffile-prefix-map=OLD=NEW</code>从<code class="fe mh mi mj mk b">gcc 8</code>开始可用，是<code class="fe mh mi mj mk b">-fdebug-prefix-map</code>和<code class="fe mh mi mj mk b">-fmacro-prefix-map</code>的联合</li><li id="a01b" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><code class="fe mh mi mj mk b">clang</code>从3.8版本开始支持<code class="fe mh mi mj mk b">-fdebug-prefix-map=OLD=NEW</code>，并且正在为将来的版本支持另外两个标志。</li></ul><p id="4655" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">解决这个问题的最好方法是在编译器选项中添加标志。如果我们使用<code class="fe mh mi mj mk b">CMake</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4f92" class="mt jr it mk b gy mu mv l mw mx">target_compile_options(target PUBLIC "-ffile-prefix-map=${CMAKE_SOURCE_DIR}=.")</span></pre><h1 id="e497" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">向构建系统提供文件顺序</h1><p id="ac74" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果通过读取目录来列出它们的文件，文件排序可能会有问题。例如，Unix没有确定的顺序，即<code class="fe mh mi mj mk b">readdir()</code>和<code class="fe mh mi mj mk b">listdir()</code>应该返回目录的内容，因此信任这些函数来提供构建系统可能会产生不确定的构建。</p><p id="e3c8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">例如，如果您的构建系统将链接器的文件存储在一个可以以不确定的顺序返回元素的容器(如常规python字典)中，也会出现同样的问题。这将使得每次文件以不同的顺序链接，并产生不同的二进制文件。</p><p id="d624" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们可以通过改变CMake中文件的顺序来模拟这个问题。如果我们修改前面的示例，使库有不止一个源文件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="79e3" class="mt jr it mk b gy mu mv l mw mx"><em class="lr">.<br/></em>├── CMakeLists.txt<br/>├── CMakeListsA.txt<br/>├── CMakeListsB.txt<br/>├── hello_world.cpp<br/>├── hello_world.hpp<br/>├── main.cpp<br/>├── sources0.cpp<br/>├── sources0.hpp<br/>├── sources1.cpp<br/>├── sources1.hpp<br/>├── sources2.cpp<br/>└── sources2.hpp</span></pre><p id="29a9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们可以看到，如果我们改变<code class="fe mh mi mj mk b">CMakeLists.txt</code>中文件的顺序，编译的结果是不同的:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="21fb" class="mt jr it mk b gy mu mv l mw mx">cmake_minimum_required(VERSION 3.0)<br/>project(HelloWorld)<br/>set(CMAKE_CXX_STANDARD 11)<br/>set(CMAKE_CXX_STANDARD_REQUIRED ON)<br/>add_library(HelloLib hello_world.cpp <br/>                     sources0.cpp <br/>                     sources1.cpp <br/>                     sources2.cpp)<br/>add_executable(hello main.cpp)<br/>target_link_libraries(hello HelloLib)</span></pre><p id="d5bc" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果我们在文件列表中创建两个名为<code class="fe mh mi mj mk b">A</code>和<code class="fe mh mi mj mk b">B</code>的连续构建，交换<code class="fe mh mi mj mk b">sources0.cpp</code>和<code class="fe mh mi mj mk b">sources1.cpp</code>，那么结果校验和将是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="28b4" class="mt jr it mk b gy mu mv l mw mx">30ab264d6f8e1784282cd1a415c067f2  helloA<br/>cdf3c9dd968f7363dc9e8b40918d83af  helloB<br/>707c71bc2a8def6885b96fb67b84d79c  hello_worldA.cpp.o<br/>707c71bc2a8def6885b96fb67b84d79c  hello_worldB.cpp.o<br/>694ff3765b688e6faeebf283052629a3  sources0A.cpp.o<br/>694ff3765b688e6faeebf283052629a3  sources0B.cpp.o<br/>0db24dc6a94da1d167c68b96ff319e56  sources1A.cpp.o<br/>0db24dc6a94da1d167c68b96ff319e56  sources1B.cpp.o<br/>fd0754d9a4a44b0fcc4e4f3c66ad187c  sources2A.cpp.o<br/>fd0754d9a4a44b0fcc4e4f3c66ad187c  sources2B.cpp.o<br/>baba9709d69c9e5fd51ad985ee328172  libHelloLibA.a<br/>72641dc6fc4f4db04166255f62803353  libHelloLibB.a</span></pre><p id="d1d4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">目标文件<code class="fe mh mi mj mk b">.o</code>是相同的，但是<code class="fe mh mi mj mk b">.a</code>库和可执行文件不是。这是因为库中的插入顺序取决于文件列出的顺序。</p><h1 id="6044" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">编译器产生的随机性</h1><p id="5085" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">例如，在<code class="fe mh mi mj mk b">gcc</code>中，当<a class="ae ls" href="https://gcc.gnu.org/wiki/LinkTimeOptimization" rel="noopener ugc nofollow" target="_blank">链接时间优化</a>被激活(带有<code class="fe mh mi mj mk b">-flto</code>标志)时，这个问题就会出现。该选项在二进制文件中引入随机生成的名称。避免这个问题的唯一方法是使用<code class="fe mh mi mj mk b">-frandom-seed</code>标志。该选项提供了一个种子，供<code class="fe mh mi mj mk b">gcc</code>在使用随机数时使用。它用于生成某些符号名，这些符号名在每个编译后的文件中必须是不同的。它还用于在覆盖率数据文件和生成它们的对象文件中放置唯一的戳记。对于每个源文件，该设置必须不同。一种选择是将它设置为文件的校验和，这样冲突的可能性非常低。例如，在CMake中，可以使用如下函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a220" class="mt jr it mk b gy mu mv l mw mx">set(LIB_SOURCES<br/>    ./src/source1.cpp<br/>    ./src/source2.cpp<br/>    ./src/source3.cpp)<br/><br/>foreach(_file ${LIB_SOURCES})<br/>    file(SHA1 ${_file} checksum)<br/>    string(SUBSTRING ${checksum} 0 8 checksum)<br/>    set_property(SOURCE ${_file} APPEND_STRING PROPERTY COMPILE_FLAGS "-frandom-seed=0x${checksum}")<br/>endforeach()</span></pre><h1 id="ae88" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用柯南的一些技巧</h1><p id="c563" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">柯南<a class="ae ls" href="https://docs.conan.io/en/latest/extending/hooks.html" rel="noopener ugc nofollow" target="_blank">钩子</a>可以在使我们的构建可复制的过程中帮助我们。这个特性使得在确定的点上定制客户端的行为成为可能。</p><p id="43d2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">钩子的一个用途是在<code class="fe mh mi mj mk b">pre_build</code>步骤中设置环境变量。下面的例子是调用一个函数<code class="fe mh mi mj mk b">set_environment</code>，然后用<code class="fe mh mi mj mk b">reset_environment</code>恢复<code class="fe mh mi mj mk b">post_build</code>步骤中的环境。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1db6" class="mt jr it mk b gy mu mv l mw mx"><strong class="mk iu">def</strong> <strong class="mk iu">set_environment</strong>(self):<br/>    <strong class="mk iu">if</strong> self<strong class="mk iu">.</strong>_os <strong class="mk iu">==</strong> "Linux":<br/>        self<strong class="mk iu">.</strong>_old_source_date_epoch <strong class="mk iu">=</strong> os<strong class="mk iu">.</strong>environ<strong class="mk iu">.</strong>get("SOURCE_DATE_EPOCH")<br/>        timestamp <strong class="mk iu">=</strong> "1564483496"<br/>        os<strong class="mk iu">.</strong>environ["SOURCE_DATE_EPOCH"] <strong class="mk iu">=</strong> timestamp<br/>        self<strong class="mk iu">.</strong>_output<strong class="mk iu">.</strong>info(<br/>            "set SOURCE_DATE_EPOCH: {}"<strong class="mk iu">.</strong>format(timestamp))<br/>    <strong class="mk iu">elif</strong> self<strong class="mk iu">.</strong>_os <strong class="mk iu">==</strong> "Macos":<br/>        os<strong class="mk iu">.</strong>environ["ZERO_AR_DATE"] <strong class="mk iu">=</strong> "1"<br/>        self<strong class="mk iu">.</strong>_output<strong class="mk iu">.</strong>info(<br/>            "set ZERO_AR_DATE: {}"<strong class="mk iu">.</strong>format(timestamp))<br/><br/><strong class="mk iu">def</strong> <strong class="mk iu">reset_environment</strong>(self):<br/>    <strong class="mk iu">if</strong> self<strong class="mk iu">.</strong>_os <strong class="mk iu">==</strong> "Linux":<br/>        <strong class="mk iu">if</strong> self<strong class="mk iu">.</strong>_old_source_date_epoch <strong class="mk iu">is</strong> None:<br/>            <strong class="mk iu">del</strong> os<strong class="mk iu">.</strong>environ["SOURCE_DATE_EPOCH"]<br/>        <strong class="mk iu">else</strong>:<br/>            os<strong class="mk iu">.</strong>environ["SOURCE_DATE_EPOCH"] <strong class="mk iu">=</strong> self<strong class="mk iu">.</strong>_old_source_date_epoch<br/>    <strong class="mk iu">elif</strong> self<strong class="mk iu">.</strong>_os <strong class="mk iu">==</strong> "Macos":<br/>        <strong class="mk iu">del</strong> os<strong class="mk iu">.</strong>environ["ZERO_AR_DATE"]</span></pre><p id="7387" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">钩子对于在<code class="fe mh mi mj mk b">post_build</code>步骤中修补二进制文件也很有用。有不同的二进制文件分析和修补工具，如<a class="ae ls" href="https://github.com/jasonwhite/ducible" rel="noopener ugc nofollow" target="_blank"> ducible </a>、<a class="ae ls" href="https://github.com/erocarrera/pefile" rel="noopener ugc nofollow" target="_blank"> pefile </a>、<a class="ae ls" href="https://github.com/trailofbits/pe-parse" rel="noopener ugc nofollow" target="_blank"> pe-parse </a>或<a class="ae ls" href="https://salsa.debian.org/reproducible-builds/strip-nondeterminism" rel="noopener ugc nofollow" target="_blank">strip-non-determinism</a>。使用<em class="lr"> ducible </em>为<code class="fe mh mi mj mk b">PE</code>二进制文件打补丁的挂钩示例如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4a6d" class="mt jr it mk b gy mu mv l mw mx"><strong class="mk iu">class</strong> <strong class="mk iu">Patcher</strong>(object):<br/><strong class="mk iu">...</strong><br/>    <strong class="mk iu">def</strong> <strong class="mk iu">patch</strong>(self):<br/>        <strong class="mk iu">if</strong> self<strong class="mk iu">.</strong>_os <strong class="mk iu">==</strong> "Windows" <strong class="mk iu">and</strong> self<strong class="mk iu">.</strong>_compiler <strong class="mk iu">==</strong> "Visual Studio":<br/>            <strong class="mk iu">for</strong> root, _, filenames <strong class="mk iu">in</strong> os<strong class="mk iu">.</strong>walk(self<strong class="mk iu">.</strong>_conanfile<strong class="mk iu">.</strong>build_folder):<br/>                <strong class="mk iu">for</strong> filename <strong class="mk iu">in</strong> filenames:<br/>                    filename <strong class="mk iu">=</strong> os<strong class="mk iu">.</strong>path<strong class="mk iu">.</strong>join(root, filename)<br/>                    <strong class="mk iu">if</strong> ".exe" <strong class="mk iu">in</strong> filename <strong class="mk iu">or</strong> ".dll" <strong class="mk iu">in</strong> filename:<br/>                        self<strong class="mk iu">.</strong>_patch_pe(filename)<br/><br/>    <strong class="mk iu">def</strong> <strong class="mk iu">_patch_pe</strong>(self, filename):<br/>        patch_tool_location <strong class="mk iu">=</strong> "C:/ducible/ducible.exe"<br/>        <strong class="mk iu">if</strong> os<strong class="mk iu">.</strong>path<strong class="mk iu">.</strong>isfile(patch_tool_location):<br/>            self<strong class="mk iu">.</strong>_output<strong class="mk iu">.</strong>info("Patching {} with md5sum: {}"<strong class="mk iu">.</strong>format(filename,md5sum(filename)))<br/>            self<strong class="mk iu">.</strong>_conanfile<strong class="mk iu">.</strong>run("{} {}"<strong class="mk iu">.</strong>format(patch_tool_location, filename))<br/>            self<strong class="mk iu">.</strong>_output<strong class="mk iu">.</strong>info("Patched file: {} with md5sum: {}"<strong class="mk iu">.</strong>format(filename,md5sum(filename)))<br/><strong class="mk iu">...</strong><br/><br/><strong class="mk iu">def</strong> <strong class="mk iu">pre_build</strong>(output, conanfile, <strong class="mk iu">**</strong>kwargs):<br/>    lib_patcher<strong class="mk iu">.</strong>init(output, conanfile)<br/>    lib_patcher<strong class="mk iu">.</strong>set_environment()<br/><br/><strong class="mk iu">def</strong> <strong class="mk iu">post_build</strong>(output, conanfile, <strong class="mk iu">**</strong>kwargs):<br/>    lib_patcher<strong class="mk iu">.</strong>patch()<br/>    lib_patcher<strong class="mk iu">.</strong>reset_environment()</span></pre><h1 id="e9f5" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="0082" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">确定性构建是一个复杂的问题，与所使用的操作系统和工具链高度相关。这个介绍应该有助于理解不确定性最常见的原因以及如何避免它们。更多C++博客文章，请访问<a class="ae ls" href="https://blog.conan.io" rel="noopener ugc nofollow" target="_blank"> Conan.io博客</a>或了解更多关于C++的<a class="ae ls" href="https://conan.io" rel="noopener ugc nofollow" target="_blank"> Conan包管理器</a>。</p><h1 id="c57e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">参考</h1><h1 id="886e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">一般信息</h1><ul class=""><li id="b977" class="lt lu it kq b kr ks kv kw kz nr ld ns lh nt ll ly lz ma mb bi translated"><a class="ae ls" href="https://www.chromium.org/developers/testing/isolated-testing/deterministic-builds" rel="noopener ugc nofollow" target="_blank">https://www . chromium . org/developers/testing/isolated-testing/deterministic-builds</a></li><li id="3a46" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://reproducible-builds.org/" rel="noopener ugc nofollow" target="_blank">https://reproducible-builds.org/</a></li><li id="bc2f" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://wiki.yoctoproject.org/wiki/Reproducible_Builds" rel="noopener ugc nofollow" target="_blank">https://wiki.yoctoproject.org/wiki/Reproducible_Builds</a></li><li id="fe2b" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://stackoverflow.com/questions/1180852/deterministic-builds-under-windows" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/1180852/deterministic-builds-under-windows</a></li><li id="5535" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#archive-library-file-format" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/windows/win32/debug/PE-format # archive-library-file-format</a></li><li id="7982" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://devblogs.microsoft.com/oldnewthing/20180103-00/?p=97705" rel="noopener ugc nofollow" target="_blank">https://devblogs.microsoft.com/oldnewthing/20180103-00/?p=97705 </a></li><li id="bd3f" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://www.geoffchappell.com/studies/msvc/link/link/options/brepro.htm?tx=37&amp;ts=0,267" rel="noopener ugc nofollow" target="_blank">https://www . geoffchappell . com/studies/msvc/link/link/options/bre pro . htm？tx=37 &amp; ts=0，267 </a></li></ul><h1 id="5040" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">工具</h1><h2 id="e642" class="mt jr it bd js my mz dn jw na nb dp ka kz nc nd ke ld ne nf ki lh ng nh km ni bi translated">比较二进制文件的工具</h2><ul class=""><li id="3062" class="lt lu it kq b kr ks kv kw kz nr ld ns lh nt ll ly lz ma mb bi translated"><a class="ae ls" href="https://diffoscope.org/" rel="noopener ugc nofollow" target="_blank">https://diffoscope.org/</a></li><li id="87ba" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/fc" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/windows-server/administration/windows-commands/fc</a></li></ul><h2 id="25c3" class="mt jr it bd js my mz dn jw na nb dp ka kz nc nd ke ld ne nf ki lh ng nh km ni bi translated">修补文件的工具</h2><ul class=""><li id="113e" class="lt lu it kq b kr ks kv kw kz nr ld ns lh nt ll ly lz ma mb bi translated"><a class="ae ls" href="https://salsa.debian.org/reproducible-builds/strip-nondeterminism" rel="noopener ugc nofollow" target="_blank">https://salsa . debian . org/reproducible-builds/strip-non determinism</a></li><li id="54bf" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://github.com/erocarrera/pefile" rel="noopener ugc nofollow" target="_blank">https://github.com/erocarrera/pefile</a></li><li id="e930" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://github.com/trailofbits/pe-parse" rel="noopener ugc nofollow" target="_blank">https://github.com/trailofbits/pe-parse</a></li><li id="268f" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://github.com/smarttechnologies/peparser" rel="noopener ugc nofollow" target="_blank">https://github.com/smarttechnologies/peparser</a></li><li id="16ef" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://github.com/google/syzygy" rel="noopener ugc nofollow" target="_blank">https://github.com/google/syzygy</a></li><li id="16a4" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://github.com/nh2/ar-timestamp-wiper" rel="noopener ugc nofollow" target="_blank">https://github.com/nh2/ar-timestamp-wiper</a></li></ul><h2 id="1860" class="mt jr it bd js my mz dn jw na nb dp ka kz nc nd ke ld ne nf ki lh ng nh km ni bi translated">用于分析文件的工具</h2><ul class=""><li id="349b" class="lt lu it kq b kr ks kv kw kz nr ld ns lh nt ll ly lz ma mb bi translated"><a class="ae ls" href="https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-reference?view=vs-2019" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/CPP/build/reference/dumpbin-reference？view=vs-2019 </a></li><li id="4218" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://sourceware.org/binutils/docs/binutils/readelf.html" rel="noopener ugc nofollow" target="_blank">https://sourceware.org/binutils/docs/binutils/readelf.html</a></li><li id="b77e" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://github.com/llvm-mirror/llvm/tree/master/tools" rel="noopener ugc nofollow" target="_blank">https://github.com/llvm-mirror/llvm/tree/master/tools</a></li><li id="333d" class="lt lu it kq b kr mc kv md kz me ld mf lh mg ll ly lz ma mb bi translated"><a class="ae ls" href="https://github.com/lief-project/LIEF" rel="noopener ugc nofollow" target="_blank">https://github.com/lief-project/LIEF</a></li></ul><p id="1b41" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><em class="lr">最初发布于</em><a class="ae ls" href="https://blog.conan.io/2019/09/02/Deterministic-builds-with-C-C++.html" rel="noopener ugc nofollow" target="_blank">https://blog . Conan . io/2019/09/02/Deterministic-builds-with-C-c++。html </a></p></div></div>    
</body>
</html>