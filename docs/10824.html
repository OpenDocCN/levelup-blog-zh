<html>
<head>
<title>From vue-class-component to Composition API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从vue类组件到组合API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/from-vue-class-component-to-composition-api-ef3c3dd5fdda?source=collection_archive---------0-----------------------#2022-01-15">https://levelup.gitconnected.com/from-vue-class-component-to-composition-api-ef3c3dd5fdda?source=collection_archive---------0-----------------------#2022-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ebc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Vue 3现在上市有一段时间了。是时候抛弃Vue 2类组件，转而使用全新的组合API了。以下是方法。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/1b651d1a99e4b7954df0f9719caa395c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zCTDy101LNoNigYr"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@xavier_von_erlach?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Xavier von Erlach </a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="140c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vue 3给人留下了深刻的印象，因为它背后的团队引入了一种全新的方式来设计Vue组件:组合API，在这里你基本上为组件编写<code class="fe lk ll lm ln b">setup</code>函数，然后从其他几个函数中组合<em class="kl">它们。在此之前，很多项目使用了包<em class="kl"> vue-class-component </em>和<em class="kl"> vue-property-decorator </em>来绕过普通的Vue 2语法，并能够以类型脚本<code class="fe lk ll lm ln b">class</code>的形式编写组件。如果您从事其中的一个项目，并且需要一条红线来将您的组件转换为组合API，下面是这条红线:</em></p><h1 id="6e59" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">先决条件</h1><p id="7989" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">如果你想直接进入Vue 3，有一个完整的迁移指南，你必须遵循。如果你只是想使用组合API，有一个有用的npm包<code class="fe lk ll lm ln b">@vue/composition-api</code>，它可以为现有的Vue 2应用程序启用API。只需安装并将其导入到您的应用程序中即可使用:</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="968e" class="mv lp iq ln b gy mw mx l my mz">// terminal<br/>npm install @vue<!-- -->/composition-api</span><span id="7766" class="mv lp iq ln b gy na mx l my mz">// main.ts<br/>import <strong class="ln ir"><em class="kl">VueCompositionApi </em></strong>from "@vue/composition-api";<br/>Vue.use(<strong class="ln ir"><em class="kl">VueCompositionApi</em></strong>);</span></pre><h1 id="a6c7" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">组件定义</h1><p id="5ed3" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">首先，我们要转换组件。你当前代码库中的每个Vue组件可能都是一个类，标有<code class="fe lk ll lm ln b">@Component</code>。在CompositionAPI中，我们使用函数<code class="fe lk ll lm ln b">defineComponent</code>来..嗯，定义一个组件。用于导入组件依赖关系的选项可以1:1应用。还要定义一个设置函数，我们稍后会用到它。</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="eb52" class="mv lp iq ln b gy mw mx l my mz">// OLD:<br/>@Component({<br/>  components: {DependencyComponent1,DependencyComponent2},<br/>})<br/>export default class MyComponent extends Vue {</span><span id="e2b8" class="mv lp iq ln b gy na mx l my mz">}</span><span id="9005" class="mv lp iq ln b gy na mx l my mz">// NEW:<br/>export default defineComponent({<br/>  name: "MyComponent",<br/>  components: {DependencyComponent1,DependencyComponent2},<br/>  setup(props, context) {<br/>  },<br/>});</span></pre><h1 id="4628" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">简单的道具</h1><p id="7ba0" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">如果你以前使用过<code class="fe lk ll lm ln b">vue-class-component</code>，我打赌你也使用过<code class="fe lk ll lm ln b">vue-property-decorator</code>的注释来定义组件类中的道具和其他东西。您当前应用程序中的一个道具将如下所示:</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="aa60" class="mv lp iq ln b gy mw mx l my mz">@Prop({<br/>  type: Boolean,<br/>  required: true,<br/>  default: false,<br/>})<br/>myProp!: boolean;</span></pre><p id="d371" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像<code class="fe lk ll lm ln b">Boolean</code>这种类型简单的道具，几乎可以不加改动的复制到Composition API风格中。在给<code class="fe lk ll lm ln b">defineComponent</code>的选项中，定义一个属性<code class="fe lk ll lm ln b">props</code>:</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="2ff9" class="mv lp iq ln b gy mw mx l my mz">export default defineComponent({<br/>  // .....<br/>  props: {<br/>    myProp: {<br/>      type: Boolean,<br/>      required: true,<br/>      default: false,<br/>    },<br/>  }<br/>});</span></pre><p id="811a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您使用的只是定义一个类型的属性的简写，您也可以转移它们:</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="a2db" class="mv lp iq ln b gy mw mx l my mz">// OLD:<br/>@Prop(String)<br/>myProp!: string;</span><span id="1842" class="mv lp iq ln b gy na mx l my mz">// NEW:<br/>props: {<br/>  myProp: String,<br/>}</span></pre><h1 id="17fd" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">定制类型道具</h1><p id="79b1" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">因为我们在这里使用像<code class="fe lk ll lm ln b">Boolean</code>这样的内置包装器类型作为值(我们用属性和值定义一个对象，而不是一个接口！)，不能只把自己的接口类型当道具类型。</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="1bc3" class="mv lp iq ln b gy mw mx l my mz">interface MyProp {<br/>  foo: boolean;<br/>  bar: number;<br/>}</span><span id="0e5e" class="mv lp iq ln b gy na mx l my mz">props: {<br/>  myProp: {<br/>    type: MyProp, // Won't work!<br/>    required: true,<br/>    default: false,<br/>  },<br/>}</span></pre><p id="1417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，使用Vue提供的通用<code class="fe lk ll lm ln b">PropType</code>适配器接口为您的道具提供定制类型:</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="71b7" class="mv lp iq ln b gy mw mx l my mz">interface MyProp {<br/>  foo: boolean;<br/>  bar: number;<br/>}</span><span id="3c58" class="mv lp iq ln b gy na mx l my mz">props: {<br/>  myProp: {<br/>    type: Object as PropType&lt;MyProp&gt;, // Typed!<br/>    required: true,<br/>    default: false,<br/>  },<br/>}</span></pre><p id="9a4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是你要做的道具。所有的道具都会自动出现在组件的模板部分。如果你想在<code class="fe lk ll lm ln b">setup</code>方法中使用它们，它们作为它的第一个参数:</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="ee53" class="mv lp iq ln b gy mw mx l my mz">setup(props, context) {<br/>   console.log(props.myProp.value);<br/>}</span></pre><p id="37c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们稍后会谈到<code class="fe lk ll lm ln b">value</code>的事情。</p><h1 id="63f6" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">组件数据</h1><p id="0ad5" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">组件中最重要的东西是它的数据。当使用<code class="fe lk ll lm ln b">vue-class-component</code>时，数据由组件<code class="fe lk ll lm ln b">class</code>的属性表示。在Composition API中，我们可以在setup函数中将数据定义为<code class="fe lk ll lm ln b">Ref</code>常量:</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="4890" class="mv lp iq ln b gy mw mx l my mz">// OLD:<br/>export default class MyComponent extends Vue {<br/>   myDataValue: string = "";<br/>}</span><span id="e5bc" class="mv lp iq ln b gy na mx l my mz">// NEW:<br/>setup(props, context) {<br/>  const myDataValue: Ref&lt;string&gt; = ref("");<br/>}</span></pre><p id="c213" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当数据真的需要反应时，注意只使用<code class="fe lk ll lm ln b">Ref</code>。如果它是一个静态值，或者在<code class="fe lk ll lm ln b">setup</code>方法完成之前您只需要它，那么就使用一个普通的<code class="fe lk ll lm ln b">const</code>。</p><p id="c669" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使数据在你的组件的模板部分中可用，你需要在<code class="fe lk ll lm ln b">setup</code>函数的末尾<code class="fe lk ll lm ln b">return</code>它。最简单的方法是使用属性简写:</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="bf90" class="mv lp iq ln b gy mw mx l my mz">// NEW:<br/>setup(props, context) {<br/>  const myDataValue: Ref&lt;string&gt; = ref("");</span><span id="e15e" class="mv lp iq ln b gy na mx l my mz">  return {<br/>    myDataValue,<br/>  };<br/>}</span></pre><p id="afcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住最后的这个<code class="fe lk ll lm ln b">return</code>,因为我们将在接下来的所有工作中用到它。</p><h2 id="94c2" class="mv lp iq bd lq nb nc dn lu nd ne dp ly jy nf ng mc kc nh ni mg kg nj nk mk nl bi translated">访问数据</h2><p id="decb" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">您会注意到，<code class="fe lk ll lm ln b">myDataValue</code>现在是一个对象，尽管我们只是想要一个字符串。这是Vue确保变量不会被重新赋值而失去其值的方法。要读取或设置代码中的实际字符串值，可以使用<code class="fe lk ll lm ln b">myDataValue.value</code>。这同样适用于道具，正如我们在上一节中已经了解的那样。</p><h1 id="bf12" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">计算属性</h1><p id="3089" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">作为一个老手，你可能会有很多被定义为类getters的计算属性。要将这些转换成组合API语法，我们可以使用<code class="fe lk ll lm ln b">computed</code>函数:</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="a58e" class="mv lp iq ln b gy mw mx l my mz">// OLD:<br/>export default class MyComponent extends Vue {<br/>  get myLowerDataValue(): string {<br/>    return this.myDataValue.toLowerCase();<br/>  }<br/>}</span><span id="0470" class="mv lp iq ln b gy na mx l my mz">// NEW:<br/>setup(props, context) {<br/>  // Not using arrow function shorthand here for readability.<br/>  const myLowerDataValue: ComputedRef&lt;string&gt; = computed(() =&gt; {<br/>    return myDataValue.value.toLowerCase();<br/>  });<br/>}</span></pre><p id="21b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们在这里使用<code class="fe lk ll lm ln b">.value</code>来访问上面定义的数据的实际值。</p><p id="6417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还为您的计算属性定义了一个setter，那么您可以使用<code class="fe lk ll lm ln b">computed</code>函数的其他符号:</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="3334" class="mv lp iq ln b gy mw mx l my mz">// OLD:<br/>export default class MyComponent extends Vue {<br/>  <br/>  get myModel(): string {<br/>    return this.myDataValue;<br/>  }<br/>  <br/>  set myModel(newValue: string) {<br/>    this.myDataValue = newValue;<br/>  }</span><span id="8fb3" class="mv lp iq ln b gy na mx l my mz">// NEW:<br/>setup(props, context) {<br/>  const myLowerDataValue: ComputedRef&lt;string&gt; = computed({<br/>    get: () =&gt; myDataValue.value,<br/>    set: (newValue: string) =&gt; myDataValue.value = newValue<br/>  });<br/>}</span></pre><h1 id="96e5" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">方法</h1><p id="33b4" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">方法是函数。对于JavaScript来说是正确的，对于组合API来说也是正确的。只需将您的<code class="fe lk ll lm ln b">class</code>方法移动到<code class="fe lk ll lm ln b">setup</code>函数中，并在它们前面加上<code class="fe lk ll lm ln b">function</code>关键字。不要忘记在你的<code class="fe lk ll lm ln b">setup</code>函数的末尾<code class="fe lk ll lm ln b">return</code>这个函数，使它可以被模板访问:</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="bf9f" class="mv lp iq ln b gy mw mx l my mz">// OLD:<br/>export default class MyComponent extends Vue {<br/>  doStuff(withThis: string): boolean {<br/>    return true;<br/>  }<br/>}</span><span id="c4c3" class="mv lp iq ln b gy na mx l my mz">// NEW:<br/>setup(props, context) {<br/>  function doStuff(withThis: string): boolean {<br/>    return true;<br/>  }</span><span id="6376" class="mv lp iq ln b gy na mx l my mz">  return {<br/>    doStuff,<br/>  }<br/>}</span></pre><h1 id="12f5" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">发射事件</h1><p id="dd3e" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">这是一个简单的问题。你从老版Vue 2中了解到的<code class="fe lk ll lm ln b">$emit</code>函数现在隐藏在<code class="fe lk ll lm ln b">context</code>中，它是作为第二个参数提供给设置函数的。如果对上下文参数使用对象析构，甚至只需要去掉$就可以了。</p><p id="f5a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">但是</strong> <strong class="jp ir">注意:</strong>如果你直接在组件的模板中使用<code class="fe lk ll lm ln b">$emit</code>，你也需要返回新的<code class="fe lk ll lm ln b">emit</code>函数！</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="7a90" class="mv lp iq ln b gy mw mx l my mz">// OLD:<br/>export default class MyComponent extends Vue {<br/>  emitStuff(withThis: string): boolean {<br/>    this.$emit("loaded", withThis);<br/>    return true;<br/>  }<br/>}</span><span id="8f9c" class="mv lp iq ln b gy na mx l my mz">// NEW:<br/>setup(props, { emit }) {<br/>  function doStuff(withThis: string): boolean {<br/>    emit("loaded", withThis);<br/>    return true;<br/>  }</span><span id="441e" class="mv lp iq ln b gy na mx l my mz">return {<br/>    doStuff,<br/>    emit,<br/>  }<br/>}</span></pre><h1 id="df61" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">钩住</h1><p id="84ed" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">最后但同样重要的是，组件生命周期挂钩(如created和mounted)也需要翻译。对于其中的每一个，您都用一个特殊的关键字作为名称定义了一个方法，Vue会自动将它们识别为生命周期挂钩(尽管我从来没有真正喜欢过这个概念，因为当您扫描代码时，它不是非常明确)。</p><p id="7f97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，对于每个生命周期钩子，都有一个由前缀为<code class="fe lk ll lm ln b">on</code>的组合API提供的函数，比如<code class="fe lk ll lm ln b">onMounted</code>或<code class="fe lk ll lm ln b">onCreated</code>。只需使用这些函数，并将您之前的方法作为箭头函数传入:</p><pre class="kn ko kp kq gt mr ln ms mt aw mu bi"><span id="6a77" class="mv lp iq ln b gy mw mx l my mz">// OLD:<br/>export default class MyComponent extends Vue {<br/>  mounted(): void {<br/>    console.log("is mounted.");<br/>  }<br/>}</span><span id="b425" class="mv lp iq ln b gy na mx l my mz">// NEW:<br/>setup(props, { emit }) {<br/>  onMounted(() =&gt; {<br/>    console.log("is mounted.");<br/>  }<br/>}</span></pre><h1 id="53ad" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">最后的话</h1><p id="4057" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">我希望本文提供了将Vue 2应用程序转移到Composition API的快速而简单的概述。从这里开始，您可以随时免费升级到<br/> Vue 3，但是您已经为这一变化准备好了所有组件！请记住，你可以一个一个地翻译你的组件，同时仍然有一个工作的应用程序，因为新旧语法可以并存。</p></div></div>    
</body>
</html>