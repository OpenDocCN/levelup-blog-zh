<html>
<head>
<title>Go: The moment when CPU Context switching blindfolded us</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">go:CPU上下文切换蒙住我们眼睛的时刻</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-the-moment-when-cpu-context-switching-blindfolded-us-a7a6eabb2bc1?source=collection_archive---------1-----------------------#2020-12-05">https://levelup.gitconnected.com/go-the-moment-when-cpu-context-switching-blindfolded-us-a7a6eabb2bc1?source=collection_archive---------1-----------------------#2020-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5eb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为一家拥有庞大客户群的电子商务公司工作，我们在编码时始终牢记的首要事情是保持它足够高的性能，以服务于巨大的流量。</p><p id="f61f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一名开发人员，我们用10万个请求对应用程序进行基准测试，并试图找出一个断点，确定应用程序或数据库服务器在任何给定时间点可以处理的最大负载。我们称之为SLA(服务水平协议),它规定了系统可以处理的最大请求数、99%的响应时间、正常运行时间以及其他一些统计数据。</p><p id="5aaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论我们对服务器进行了多好的基准测试，还是会有很多这样或那样的依赖服务被阻塞的情况，这会导致整个系统的SLA违约。这就是监控工具发挥作用的地方，它可以提供单个API和组件级别的实时统计数据。<strong class="jp ir"> NewRelic </strong>就是这样一个监控工具，我们在<strong class="jp ir"> GoIbibo </strong>使用它来测量应用程序性能，并在系统违反任何SLA协议时发出警报。</p><p id="fa6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">监控工具对我们来说工作得很好，直到我们在监控工具中发现了一个由CPU上下文切换引起的基本漏洞。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="902d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">语境</strong></p><p id="8fb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您有一个Post API，它获取请求、转换数据并将转换后的数据存储到数据库中。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/cf5462958dc360aacbe13bf2b0bd5b04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wRb8EaKEHevIsOseOFpbVw.png"/></div></div></figure><p id="ff33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对上述场景中的难点进行分析，我们可以得出结论，处理是应用程序级别的事情，不存在任何瓶颈。唯一的瓶颈在数据库层。数据库可能会因为多种原因而变慢，我们需要一些真实的统计数据以防出错。</p><p id="f454" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了用代码描述这个场景，我将展示一小段代码</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="5ba6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了说明获得大量并发调用的post API，我用1000个并发请求开始了主进程，每个请求都试图进行一次数据库调用。</p><p id="77e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了说明数据库调用被恒定时间延迟，我设置了一个3秒钟的休眠，这意味着当数据库模拟在3秒钟的恒定时间内返回数据时，在数据库调用之前创建一个事务，并且在数据库调用结束时立即结束，我的假设是，当我查看我的监控工具时，数据库事务花费的时间应该是3秒钟。</p><p id="8d8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这正是我的假设出错的地方。随着并发请求的数量不断增加，数据库的事务时间开始激增，这时我才知道，无论监控工具显示什么，都不仅仅是执行一段代码所花费的时间，而是遵循下面的等式。</p><pre class="kt ku kv kw gt lg lh li lj aw lk bi"><span id="6e7b" class="ll lm iq lh b gy ln lo l lp lq">Transaction Time = Time taken to make DB Call + Time taken by CPU Context Switching</span></pre><p id="8cdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">迷茫？？？</p><p id="e8ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，让我进一步解释一下引擎盖下发生了什么。在上面提到的代码中，第24行</p><pre class="kt ku kv kw gt lg lh li lj aw lk bi"><span id="95c8" class="ll lm iq lh b gy ln lo l lp lq">runtime.GOMAXPROCS(1)</span></pre><p id="53fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在一个内核上运行代码，这意味着CPU在任何给定的时间点只能运行一条指令。但是我们有成千上万的并发调用，CPU不能先处理一个请求，然后再处理下一个。它必须确保空闲时间以这样一种方式减少，它可以100%的效率工作。</p><p id="17bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这样的过程中，每当它看到任何数据库调用或系统调用或任何文件I/O操作时，它就将这个特定的goroutine放在等待队列中，并开始处理其他请求。放在等待队列中的goroutine什么时候被服务完全取决于等待队列中已经有多少go routine准备被服务？</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi lr"><img src="../Images/776a474c7a6adf7aa292a025dfc9ea56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRuYF8d33dody-ocdb74nA.png"/></div></div></figure><p id="c993" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在处理第一个请求时，我们收到了5个其他请求，因为只有一个内核为所有请求提供服务，所以其余的内核继续在队列中等待。一旦第一个goroutine遇到一个DB或I/O调用，它就会被放置在等待队列中。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi lr"><img src="../Images/bbd61e593252e5f5a39b012e72fbee7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZkTDub4gnbN993mf6KYS2w.png"/></div></div></figure><p id="135f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着Go routine 1一直等待数据库调用在后台完成，在我们的例子中是3秒钟。</p><p id="09e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设队列中有更多的Goroutine在等待，处理所有这些需要4秒钟，然后返回到Goroutine 1，之后执行下面的语句。</p><pre class="kt ku kv kw gt lg lh li lj aw lk bi"><span id="f8c2" class="ll lm iq lh b gy ln lo l lp lq">nrTxn.End()</span></pre><p id="cc03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成数据库调用的实际时间只有3秒，但是当我们登录到Newrelic时，根据等待另一个CPU周期所花费的时间，我们记录了4秒或更长的时间。</p><p id="fa38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们就知道在任何监控工具中显示的每个事务的时间是执行指令所用的总时间+如果指令不能在1个CPU周期内执行，等待获得CPU周期的指令所用的总时间。</p><p id="bdf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，下一次无论何时您看到任何事务中的峰值，一定要检查系统中的CPU峰值。</p></div></div>    
</body>
</html>