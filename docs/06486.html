<html>
<head>
<title>Embedded Database in Go Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋测试中的嵌入式数据库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/embedded-database-in-go-testing-10d29a8e454a?source=collection_archive---------5-----------------------#2020-11-30">https://levelup.gitconnected.com/embedded-database-in-go-testing-10d29a8e454a?source=collection_archive---------5-----------------------#2020-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4946922f1719243cdad78e91864e89e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*miD-VbCviEdMMuqI"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">切斯特·阿尔瓦雷斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2145" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想这个场景对很多开发者来说都是熟悉的。一个有数据库需求的项目进展很快，这给测试带来了压力。测试持久性的策略没有事先达成一致，出现了三种<a class="ae kf" href="https://en.wikipedia.org/wiki/Anti-pattern" rel="noopener ugc nofollow" target="_blank"> <em class="le">反模式</em> </a>。对于简单的测试，人们会模拟数据。其他人，没有数据库，将持久性测试推迟到集成测试。最后，有人在某处构建了一个“测试”数据库实例，并开始使用它。这些<em class="le">解决方案</em>很快变得根深蒂固，并增加了技术债务。</p><p id="fa13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不打算讨论“数据库访问和持久性是集成测试的定义的一部分”这一基本观点。我不同意，所以这篇文章坚持这样的观点，即使是单元测试也涉及到持久性测试。</p><p id="897d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">解决这个问题的方法是使用一个嵌入式数据库，它可以在测试中旋转起来并扔掉。大多数数据库框架都支持嵌入式数据库，如H2或SQLite，但是如果您使用特定数据库的专有特性，这些选项只是权宜之计。</p><h2 id="46b8" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">在围棋测试中嵌入Postgres</h2><p id="4e69" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">虽然我将在这里专门讨论Postgres，但这种模式适用于大多数数据库和语言。它可以在您的IDE、命令行和CI/CD中工作。它是彻底的，并且允许测试中的并行性。</p><p id="54b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在您的代码中，策略是在一个测试或一组测试开始时，运行一个docker容器，其中包含允许Docker分配地址和端口的数据库。让您代码连接到数据库，运行您的计划迁移，运行您的测试，并在测试结束时，终止容器。</p><ul class=""><li id="127a" class="md me it ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated">优点:您获得了所需数据库的合法版本，可以运行全功能测试，数据库是干净的，没有交叉污染，并且您还测试了您的方案迁移！</li><li id="b60d" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">缺点:这将增加几秒钟的测试时间，并且像认证和集群这样的特性可能与其他环境中的不一样。</li></ul><p id="0b46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">利大于弊，相信我。</p><h2 id="8b4e" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">实施</h2><p id="6a6e" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">对于Go和Postgres，我们将采用以下方法:</p><ul class=""><li id="db7f" class="md me it ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated">标准的“测试”和“证明”模块</li><li id="045f" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">github.com/testcontainers/testcontainers-go模块</li><li id="0bf9" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">基于阿尔卑斯山的Postgres docker图像</li><li id="e86a" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">用于持久性测试的<a class="ae kf" href="https://gorm.io/index.html" rel="noopener ugc nofollow" target="_blank"> GORM </a>和<a class="ae kf" href="https://github.com/go-pg/pg" rel="noopener ugc nofollow" target="_blank"> go-pg </a>模块</li><li id="4f1e" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">一点代码就可以很好地整合这些内容</li><li id="1240" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">Github用CI展示了这一点</li></ul><p id="71a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的示例代码可以在<a class="ae kf" href="https://github.com/nwillc/testdb" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到，但是我将在这里提供一些亮点。首先，让我们编写一个配置类:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="0841" class="lf lg it mw b gy na nb l nc nd">package dbutil<br/><br/>import (<br/>   "fmt"<br/>   "net/url"<br/>)<br/><br/>//DbConf holds the database configuration information.<br/>type DbConf struct {<br/>   Username   string<br/>   Password   string<br/>   Scheme     string<br/>   Port       int<br/>   Database   string<br/>   mappedHost string<br/>   mappedPort int<br/>   flags      map[string][]string<br/>}<br/><br/>//NewDbConf creates a new DbConf with the prerequisite information.<br/>func NewDbConf(username string, password string, scheme string, port int, database string) *DbConf {<br/>   return &amp;DbConf{<br/>      Username: username,<br/>      Password: password,<br/>      Scheme:   scheme,<br/>      Port:     port,<br/>      Database: database,<br/>      flags:    make(map[string][]string),<br/>   }<br/>}<br/><br/>//Flag adds a configuration flag to the DbConf<br/>func (c *DbConf) Flag(name string, value ...string) *DbConf {<br/>   c.flags[name] = value<br/>   return c<br/>}<br/><br/>//Mapped adds the host and port mapped by a container.<br/>func (c *DbConf) Mapped(mappedHost string, mappedPort int) *DbConf {<br/>   c.mappedHost = mappedHost<br/>   c.mappedPort = mappedPort<br/>   return c<br/>}<br/><br/>//String implements fmt.Stringer and produces a DSN format string.<br/>func (c *DbConf) String() string {<br/>   dsn := url.URL{<br/>      User:     url.UserPassword(c.Username, c.Password),<br/>      Scheme:   c.Scheme,<br/>      Host:     fmt.Sprintf("%s:%d", c.mappedHost, c.mappedPort),<br/>      Path:     c.Database,<br/>      RawQuery: url.Values(c.flags).Encode(),<br/>   }<br/>   return dsn.String()<br/>}</span></pre><p id="3f1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将收集配置数据库所需的信息，稍后将使用我们启动的容器的一些配置进行更新。它包括生成数据库连接字符串的代码。</p><p id="cf19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将创建一个测试助手函数来启动容器，将它的终止添加到测试清理中，并使用容器信息更新配置。这里我们使用<a class="ae kf" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank">官方Postgres镜像</a>、<a class="ae kf" href="https://github.com/testcontainers/testcontainers-go" rel="noopener ugc nofollow" target="_blank"> testcontainers-go模块</a>并集成到<a class="ae kf" href="https://golang.org/pkg/testing/" rel="noopener ugc nofollow" target="_blank">测试模块</a>:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e7f2" class="lf lg it mw b gy na nb l nc nd">package model<br/><br/>import (<br/>   "context"<br/>   "fmt"<br/>   "github.com/docker/go-connections/nat"<br/>   "github.com/testcontainers/testcontainers-go"<br/>   "github.com/testcontainers/testcontainers-go/wait"<br/>   "godb/dbutil"<br/>   "testing"<br/>   "time"<br/>)<br/><br/>const (<br/>   image    = "postgres:12.4-alpine"<br/>   logMsg   = "database system is ready to accept connections"<br/>)<br/><br/>//EmbeddedPostgres spins up a postgres container.<br/>func EmbeddedPostgres(t *testing.T, conf *dbutil.DbConf) {<br/>   t.Helper()<br/>   ctx := context.Background()<br/>   natPort := fmt.Sprintf("%d/tcp", conf.Port)</span><span id="b0a7" class="lf lg it mw b gy ne nb l nc nd">   // Setup and startup container<br/>   req := testcontainers.ContainerRequest{<br/>      Image:        image,<br/>      ExposedPorts: []string{ natPort },<br/>      Env: map[string]string{<br/>         "POSTGRES_PASSWORD": conf.Password,<br/>         "POSTGRES_USER":     conf.Username,<br/>         "POSTGRES_DATABASE": conf.Database,<br/>      },<br/>      WaitingFor: wait.ForLog(logMsg).<br/>         WithPollInterval(100 * time.Millisecond).<br/>         WithOccurrence(2),<br/>   }<br/>   pg, err := testcontainers.GenericContainer(<br/>      ctx,<br/>      testcontainers.GenericContainerRequest{<br/>      ContainerRequest: req,<br/>      Started:          true,<br/>   },<br/>   )<br/>   if err != nil {<br/>      t.Error(err)<br/>   }</span><span id="62ac" class="lf lg it mw b gy ne nb l nc nd">   // Even after log message found Postgres needs a touch more...<br/>   time.Sleep(200 * time.Millisecond)</span><span id="1b41" class="lf lg it mw b gy ne nb l nc nd">   // When test is done terminate container<br/>   t.Cleanup(func() {<br/>      _ = pg.Terminate(ctx)<br/>   })</span><span id="295c" class="lf lg it mw b gy ne nb l nc nd">   // Get the container info needed<br/>   mp, err := pg.MappedPort(ctx, nat.Port(natPort))<br/>   if err != nil {<br/>      t.Error(err)<br/>   }<br/>   ma, err := pg.Host(ctx)<br/>   if err != nil {<br/>      t.Error(err)<br/>   }<br/><br/>   // Note the containers mapped host and port<br/>   conf.Mapped(ma, mp.Int())<br/>}</span></pre><p id="76f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">跟随代码注释，看看那里发生了什么。</p><h2 id="23db" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">在测试中使用</h2><p id="b593" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">让我们在测试中使用这些。下面使用一个测试套件作为例子，来设置在多个测试中使用的数据库。我们将为<a class="ae kf" href="https://gorm.io/index.html" rel="noopener ugc nofollow" target="_blank"> GORM </a>使用一个简单的Person结构来保持测试:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="87b7" class="lf lg it mw b gy na nb l nc nd">package model<br/><br/>type Person struct {<br/>   ID        uint   `json:"id"`<br/>   FirstName string `json:"firstname"`<br/>   LastName  string `json:"lastname"`<br/>}</span></pre><p id="da51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是使用内嵌Postgres和GORM的测试套件:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="59e9" class="lf lg it mw b gy na nb l nc nd">package model<br/><br/>import (<br/>   "github.com/stretchr/testify/assert"<br/>   "github.com/stretchr/testify/suite"<br/>   "godb/dbutil"<br/>   "gorm.io/driver/postgres"<br/>   "gorm.io/gorm"<br/>   "testing"<br/>)</span><span id="1efd" class="lf lg it mw b gy ne nb l nc nd">// The test Suite fixture<br/>type PersonDbTestSuite struct {<br/>   suite.Suite<br/>   db *gorm.DB<br/>}</span><span id="e655" class="lf lg it mw b gy ne nb l nc nd">// Setup the test suite fixture<br/>func (suite *PersonDbTestSuite) SetupTest() {<br/>   conf := dbutil.NewDbConf(<br/>      "postgres",<br/>      "admin",<br/>      "postgres",<br/>      5432,<br/>      "postgres",<br/>   )<br/>   // Fire up the embedded Postgres<br/>   EmbeddedPostgres(suite.T(), conf)<br/>   // Open the GORM connection to it<br/>   db, err := gorm.Open(<br/>      postgres.Open(conf.String()),<br/>      &amp;gorm.Config{},<br/>   )<br/>   if err != nil {<br/>      suite.T().Error(err)<br/>   }<br/>   // Explicitly clean up GORM after the test<br/>   suite.T().Cleanup(func() {<br/>      sqlDb, _ := db.DB()<br/>      _ = sqlDb.Close()<br/>   })<br/>   suite.db = db<br/>   // Use gorm's migration to set up our table<br/>   if err := suite.db.AutoMigrate(&amp;Person{}); err != nil {<br/>      suite.T().Error(err)<br/>   }<br/>}</span><span id="e702" class="lf lg it mw b gy ne nb l nc nd">// Run tests in the suite<br/>func TestPersonDbTestSuite(t *testing.T) {<br/>   suite.Run(t, new(PersonDbTestSuite))<br/>}</span><span id="7b0f" class="lf lg it mw b gy ne nb l nc nd">// This suite's single test<br/>func (suite *PersonDbTestSuite) TestWrite() {<br/><br/><br/>   // Create a person<br/>   p1 := Person{FirstName: "John", LastName: "Doe"}<br/><br/>   // Persist it to database<br/>   suite.db.Create(&amp;p1)<br/>   var p2 Person<br/><br/>   // Find the last Person in the database<br/>   suite.db.Last(&amp;p2)<br/><br/>   // Compare...<br/>   assert.Equal(suite.T(), p1.ID, p2.ID)<br/>   assert.Equal(suite.T(), p1.FirstName, p2.FirstName)<br/>   assert.Equal(suite.T(), p1.LastName, p2.LastName)<br/>}</span></pre><p id="63fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，按照代码注释来查看发生了什么。repo包含并行go-pg示例。</p><p id="d696" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从冷启动开始，上面的代码运行了大约14秒，在冷启动时，它需要提取Postgres映像，在冷启动后，一旦映像是本地的，大约需要3秒。对于一个新的一次性数据库来说，每次都不错。</p><h2 id="69a0" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated">问题</h2><p id="0da8" class="pw-post-body-paragraph kg kh it ki b kj ly kl km kn lz kp kq kr ma kt ku kv mb kx ky kz mc lb lc ld im bi translated">这里有一些问题:</p><ul class=""><li id="207d" class="md me it ki b kj kk kn ko kr mf kv mg kz mh ld mi mj mk ml bi translated">如前所述，您不会测试完全认证的数据库连接。只要对图像和证书之类的东西做一点工作，就可以解决这个问题。</li><li id="1914" class="md me it ki b kj mm kn mn kr mo kv mp kz mq ld mi mj mk ml bi translated">Postgres映像的不同版本支持不同的、部分功能性的支持，比如设置不同的用户、设置不同的数据库、多个数据库。我使用了默认值，但是在过去，我使用了自己的Postgres docker映像来支持其他配置。</li></ul></div></div>    
</body>
</html>