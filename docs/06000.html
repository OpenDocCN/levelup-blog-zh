<html>
<head>
<title>Authorization in GraphQL — Schema Directive vs GraphQL Shield</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL中的授权—模式指令与GraphQL屏蔽</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/authorization-in-graphql-schema-directive-vs-graphql-shield-17085f346488?source=collection_archive---------1-----------------------#2020-10-18">https://levelup.gitconnected.com/authorization-in-graphql-schema-directive-vs-graphql-shield-17085f346488?source=collection_archive---------1-----------------------#2020-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="5baf" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">这篇博客还假设您熟悉GraphQL模式指令。如果没有，我推荐阅读这个关于模式指令的<a class="ae kp" href="https://www.apollographql.com/docs/apollo-server/schema/directives/" rel="noopener ugc nofollow" target="_blank"> Apollo文档</a>。</p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/f707bfbfaa60a718cd83cfa31af184b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*mhMF50PSG7XY9YWqlp-Wuw.png"/></div></figure><p id="4e87" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">假设我们有一个基本的<strong class="jt ir">博客</strong>应用程序，其中一个<code class="fe lb lc ld le b">User</code>有许多<code class="fe lb lc ld le b">Posts</code>，每个<code class="fe lb lc ld le b">Post</code>又有许多<code class="fe lb lc ld le b">Comments</code>。</p><p id="2615" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">下面是包含这个应用程序的基本GraphQL模式的要点。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lf lg l"/></div></figure></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="789f" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">问题陈述</h1><p id="68e4" class="pw-post-body-paragraph jq jr iq jt b ju mm jw jx jy mn ka kb ky mo ke kf kz mp ki kj la mq km kn ko ij bi translated">假设我们只希望拥有<code class="fe lb lc ld le b">USER</code>角色的登录用户能够访问评论。我们如何实现这一点？</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="4a70" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">方法1 —使用模式指令</h1><p id="f13e" class="pw-post-body-paragraph jq jr iq jt b ju mm jw jx jy mn ka kb ky mo ke kf kz mp ki kj la mq km kn ko ij bi translated">查询、突变和类型的授权可以使用模式指令来实现。事实上，Apollo文档的这一节带我们看了一个使用指令实现授权的例子。</p><p id="ca0e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">让我们以阿波罗文档中描述的相同方式实现一个<code class="fe lb lc ld le b">auth</code>指令。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="a59f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">在上面的代码中，注意已经检查了<code class="fe lb lc ld le b">requiredRole</code>的存在。无论我们在哪里使用<code class="fe lb lc ld le b">auth</code>指令，都必须将<code class="fe lb lc ld le b">requiredRole</code>作为参数传递。</p><blockquote class="jn jo jp"><p id="3c87" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">另外，已经完成了对<code class="fe lb lc ld le b">isUser</code>文本的记录，这样我们就可以准确地知道这个函数被执行了多少次。</p></blockquote><p id="5410" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">对<code class="fe lb lc ld le b">baseTypeDefs.js</code>的更改如下:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="2874" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">注意@auth指令在<code class="fe lb lc ld le b">CommentType</code>中的用法。完整的工作示例，你可以参考<a class="ae kp" href="https://github.com/shrirambalakrishnan/blog-graphql-optimizations/tree/auth-using-directive" rel="noopener ugc nofollow" target="_blank">这个库</a>。</p><p id="814f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">这里是运行<code class="fe lb lc ld le b">users</code>查询时的服务器日志截图。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/1270036cebdd12ca10c28413f4637bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4LKGCYGYM0_lUaq_Ov7r9A.png"/></div></div></figure><p id="7af6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">现在，如您所见，<strong class="jt ir"> @auth </strong>指令对每条<code class="fe lb lc ld le b">CommentType</code>记录执行一次。</p><p id="497e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">这种重复执行甚至是必要的吗？这怎么优化？</p><h1 id="1715" class="lo lp iq bd lq lr mw lt lu lv mx lx ly lz my mb mc md mz mf mg mh na mj mk ml bi translated">方法2:graph QL-shield——更好的选择</h1><p id="0a16" class="pw-post-body-paragraph jq jr iq jt b ju mm jw jx jy mn ka kb ky mo ke kf kz mp ki kj la mq km kn ko ij bi translated">使用<a class="ae kp" href="https://github.com/maticzav/graphql-shield" rel="noopener ugc nofollow" target="_blank"> GraphQL Shield </a>可以非常直观地创建授权规则。</p><p id="ea05" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">在下面给出的代码中，我为<code class="fe lb lc ld le b">CommentType</code>创建了一个<code class="fe lb lc ld le b">isUser</code>权限</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="f339" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">在<code class="fe lb lc ld le b">isUser</code>规则中，请注意<code class="fe lb lc ld le b"><strong class="jt ir">contextual cache</strong></code>的使用，它确保该规则的结果被缓存用于这个特定的上下文和<strong class="jt ir">，从而防止不必要的数据加载</strong>。</p><p id="e7be" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">完整的实现你可以参考<a class="ae kp" href="https://github.com/shrirambalakrishnan/blog-graphql-optimizations/tree/auth-using-shield" rel="noopener ugc nofollow" target="_blank">这个库</a>。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/39dd21243da6a336b905e394d7dd80d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xNzfQsOYWGoPk1trTZqKgQ.png"/></div></div></figure><p id="42bc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">在执行相同的查询时，您可以看到‘I user’只被执行了一次。</p><p id="0e62" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb ky kd ke kf kz kh ki kj la kl km kn ko ij bi translated">这里有几个资源可以阅读更多关于这个主题的内容。<br/> 1。GraphQL Summit 2020 Talk— <a class="ae kp" href="https://youtu.be/dBuU61ABEDs" rel="noopener ugc nofollow" target="_blank">如何认证</a> <br/> 2。阿波罗官方<a class="ae kp" href="https://www.apollographql.com/blog/setting-up-authentication-and-authorization-with-apollo-federation/" rel="noopener ugc nofollow" target="_blank">博客</a></p></div></div>    
</body>
</html>