<html>
<head>
<title>The White-Grey-Black Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">白灰色黑色的树</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-white-grey-black-tree-b9a96f12e9e9?source=collection_archive---------1-----------------------#2020-05-02">https://levelup.gitconnected.com/the-white-grey-black-tree-b9a96f12e9e9?source=collection_archive---------1-----------------------#2020-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4177" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">B+树的替代方案</h2></div><h2 id="33e9" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h2><p id="a2b8" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">回到2018年11月，我对不同的<a class="ae lx" href="https://en.wikipedia.org/wiki/Database#Database_management_system" rel="noopener ugc nofollow" target="_blank"> DBMS </a>系统有点着迷，比如MSSQL、MySQL、Oracle。在我研究这个课题的过程中，我遇到了<a class="ae lx" href="https://en.wikipedia.org/wiki/Online_analytical_processing" rel="noopener ugc nofollow" target="_blank"> OLAP </a>数据处理和<a class="ae lx" href="https://en.wikipedia.org/wiki/Data_warehouse" rel="noopener ugc nofollow" target="_blank">数据仓库</a>。这个主题引起了我足够的兴趣，我开始着手我的项目，将数据库管理系统提升到另一个层次。我的想法是通过混合关系数据库和数据仓库来改变系统的内部架构，这将使程序员能够在利用数据仓库提供的搜索查询速度的同时保持关系数据库的结构。</p><p id="0e9c" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">我开始使用C++编程语言开发一个原型。为了将数据从关系数据库“翻译”到数据仓库，我需要索引数据库。为了让原型工作，我实现了一个定制的<a class="ae lx" href="https://en.wikipedia.org/wiki/AVL_tree" rel="noopener ugc nofollow" target="_blank"> AVL </a>树来完成工作。由于这是该软件的第一个版本，我唯一的关注点是让系统启动并运行，所以我并不太担心速度。我打算在某个时候用一棵<a class="ae lx" href="https://en.wikipedia.org/wiki/B%2B_tree" rel="noopener ugc nofollow" target="_blank"> B+树</a>代替AVL树(当时我对B+树还不熟悉)。在一切顺利运行后，我将注意力转移到执行速度和索引系统的改进上。从那时起，我开始研究B+树及其实现和性能。由于对自己的发现不满意，我决定开始创建自己的数据结构，这种数据结构仍然很快，但内部碎片更少，因此有更大的缓存价值信息。</p><h2 id="430b" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">原始树</h2><p id="e921" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">因此，我已经开始设计一个数据结构，这是一个堆树。每个节点包含<em class="md"> p </em>个子节点。子节点的数量随着深度增加下一个质数。根节点有两个子节点。每个节点内的键可以比子树内的键小(最小原始树)或大(最大原始树)。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi me"><img src="../Images/210f719c3c5a6788b7cc324aad78fe53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5dfKxI_VIc-PiM-ujeVQkQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">图一。最小原始树</figcaption></figure><p id="7481" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">由于节点位置是由质因数分解决定的，所以这棵树不能被平衡。例如，值18由三个操作定位:</p><ol class=""><li id="79a0" class="mu mv it lg b lh ly lk lz kr mw kv mx kz my lw mz na nb nc bi translated">18 &gt; 1和18 mod 2 = 0 -&gt;插入到索引为0的子树中。</li><li id="4a20" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw mz na nb nc bi translated">18 &gt; 2和18 mod 3 = 0 -&gt;插入到索引为0的子树中。</li><li id="7e94" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw mz na nb nc bi translated">18 &gt; 6和18 mod 5 = 3 -&gt;插入到索引为3的子树中。</li></ol><p id="e436" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">如果原始树是完全平衡的，那么数据的数量会增加一个原始的深度。<a class="ae lx" href="https://en.wikipedia.org/wiki/Primorial" rel="noopener ugc nofollow" target="_blank">primaryal</a>，用“#”表示，是一个从自然数到自然数的函数，类似于阶乘函数，但该函数不是连续地乘以正整数，而是只乘以质数。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ni"><img src="../Images/9389433552eb4f5e47b94acd6d86544c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*XQIcctj8a-NaLilmCO-KFw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">原始定义</figcaption></figure><p id="684c" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">由于原始函数比阶乘函数增长更快，原始树的大O符号是一个比对数函数增长更小的渐近函数。但是这种树有一些缺点:</p><ol class=""><li id="b03f" class="mu mv it lg b lh ly lk lz kr mw kv mx kz my lw mz na nb nc bi translated">在所需范围内过滤关键字时，没有有效的算法</li><li id="dcdb" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw mz na nb nc bi translated">当分别为最大原始树或最小原始树寻找最小或最大关键字时，没有有效的算法</li><li id="9ebd" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw mz na nb nc bi translated">树不平衡</li><li id="2e1b" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw mz na nb nc bi translated">不平衡时，树包含的叶子可能比关键点多。对于一般大小的数据库，这可能会导致内存耗尽。</li></ol><p id="7493" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">我的结论是，这棵树存储数据不可靠。因此，我需要找到一种方法来设计一个类似的树来解决这些问题。一天早上，我喝着咖啡，盯着白板，白板上画着原始树，后面是数学公式和微积分。我不想擦黑板，因为我懒得擦。与此同时，下面的电视屏幕上出现了歌曲《压力之下》的音乐视频中的一个场景。我看到了弗兰肯斯坦博士怪物。然后另一个想法来了:“我需要混合Primorial树和AVL树”。那是白灰黑树诞生的时刻。</p><h2 id="15c7" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">白-灰-黑树</h2><p id="bf39" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">白-灰-黑树(WGB树)是一种自我平衡和有序的树。它是AVL树和Primorial树的组合。除了key之外，每个节点都包含解释为一种颜色的额外信息:白色、灰色或黑色。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nj"><img src="../Images/ce1b82747e0812d8c0f22e0da4920e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vKLBOc6ozVa05lD8hT9IIA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">图二。平衡的白-灰-黑树</figcaption></figure><p id="78d9" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">从上图可以看出，节点颜色是按深度级别切换的。所有奇数层都包含灰色节点。其他级别包含白色和黑色节点。</p><p id="0607" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated"><strong class="lg iu"> <em class="md">灰色节点</em> </strong></p><p id="a740" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">灰色节点用于确保树在插入和删除期间保持大致平衡。灰色节点有两个子节点:</p><ul class=""><li id="4aae" class="mu mv it lg b lh ly lk lz kr mw kv mx kz my lw nk na nb nc bi translated">白色节点作为左子节点</li><li id="11f6" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw nk na nb nc bi translated">黑色节点作为右子节点</li></ul><p id="ac27" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">灰色节点中的键比左子树中的键大，比右子树中的键小。左右子树之间的高度差由平衡系数定义:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/eaa43b10c887d512ec0ae1a32101a5a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*829qqjA8QprgF7I_yPlpqA.png"/></div></figure><p id="8376" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">如果平衡系数超出范围，则树不平衡。如果右边的子树比左边的子树高，则执行以下三个操作:</p><ul class=""><li id="7922" class="mu mv it lg b lh ly lk lz kr mw kv mx kz my lw nk na nb nc bi translated">从右边的子树弹出最小键</li><li id="48d1" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw nk na nb nc bi translated">用最小键替换灰色节点中的键</li><li id="10ee" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw nk na nb nc bi translated">从灰色节点向左侧子树插入一个键</li></ul><p id="397d" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">否则，如果左子树的高度大于右子树，则执行以下三个操作:</p><ul class=""><li id="1f69" class="mu mv it lg b lh ly lk lz kr mw kv mx kz my lw nk na nb nc bi translated">从左子树弹出最大键</li><li id="1cf2" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw nk na nb nc bi translated">用最大键替换灰色节点中的键</li><li id="11e6" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw nk na nb nc bi translated">从灰色节点向右侧子树插入一个键</li></ul><p id="2d0e" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated"><strong class="lg iu"> <em class="md">黑白节点</em> </strong></p><p id="3246" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">白色或黑色节点的行为类似于原始树中的节点。此外，他们指向一组灰色节点。子节点的数量随着深度增加下一个质数。白色节点和黑色节点之间的区别在于，白色节点包含的键比其子树中的所有键都小，而黑色节点包含的键比其子树中的所有键都大。在基本情况下，第一个质数是2。</p><p id="ed42" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated"><strong class="lg iu"> <em class="md">算法找到一个密钥</em> </strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nm"><img src="../Images/89ac56fe55adea66b28532462ce78ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hSdHKkWjMv0wjVtdh90QMw.gif"/></div></div></figure><p id="8c2f" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated"><strong class="lg iu">插入密钥的算法</strong></p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nn"><img src="../Images/854f3ebc900c1dc86639bf43dcbb2284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-HhXmDa3U2W924IDzpwfcw.gif"/></div></div></figure><p id="4a44" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated"><strong class="lg iu"> <em class="md">性能</em> </strong></p><p id="8b80" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">白-灰-黑树的性能可以通过开始用大于2的质数划分白色和黑色节点来提高，这降低了树的高度。以质数<em class="md"> p </em>开始的树由<strong class="lg iu"> WGB(p) </strong>表示。下图给出了根据第一质数<em class="md"> p </em>的深度比较。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi no"><img src="../Images/67508a40e2f6da7fdf60d16cff4bc080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0SayTzf4wanaVnWJ97BGzA.png"/></div></div></figure><p id="2996" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">该图显示，当从WGB(p(n))到WGB(p(n+1))降低树高时，略有改善。这是WGB树的四个假设:</p><ul class=""><li id="3fd7" class="mu mv it lg b lh ly lk lz kr mw kv mx kz my lw nk na nb nc bi translated"><strong class="lg iu">第一个假设</strong>是内部树碎片随着<em class="md"> p. </em>增加</li><li id="c08e" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw nk na nb nc bi translated"><strong class="lg iu">第二个假设</strong>是一棵树的内部碎片百分比按照键的数量循环增减。</li><li id="974a" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw nk na nb nc bi translated"><strong class="lg iu">第三个假设</strong>是基于范围的搜索具有很好的性能，因为对于每个灰色节点，最大和最小键由O(1)确定。这将避免在子树中进行不必要的基于范围的搜索。</li><li id="bb49" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw nk na nb nc bi translated"><strong class="lg iu">第四个假设<em class="md"> </em> </strong>是WGB(p)树的一个<a class="ae lx" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">大O </a>比分裂成p个子树的B+树的一个大O更渐近。此外，B+树的障碍是每个节点内部的关键字正在被一个<a class="ae lx" href="https://cs.stackexchange.com/questions/59453/why-is-b-tree-search-olog-n" rel="noopener ugc nofollow" target="_blank">二分搜索法算法</a>搜索。</li></ul><p id="8cea" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated"><strong class="lg iu"> <em class="md">计算WGB②树的高度</em> </strong></p><p id="798f" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">节点的数量并没有随着深度的增加而持续增长。键的数量通过将前一行中的键的数量乘以2或者乘以下一个<em class="md"> p </em>来增加。例如，WGB(2)树中的键的数量按深度增长，顺序如下:1、3、7、15、39、87、327等等。</p><p id="d944" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">设WGB(2)树内的键的数量表示为<em class="md"> n </em>，树的高度表示为<em class="md">d</em>因此，设<em class="md"> n </em>和<em class="md"> d </em>之间的关系为:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/c464406d4bdfb7b2216446e60d2e5926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*cty8pHkkf0JfB8lTqkE4UA.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">等式1。根据树深度/高度的数据数量</figcaption></figure><p id="6188" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">原始函数的近似:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/3af2344dceba5c2063cecba4e0b9a992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*bVIfe7nRGijmm-ONJwEZtw.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">等式2。原始的近似值</figcaption></figure><p id="c880" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">原始函数可以用近似值代替。因此，等式1。可以写成:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4ce9b5c3fea425fb13aa8a54322570c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*JV0qpFdBRI2v7KvsYkfqYw.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">等式3。根据树深度/高度的数据数量</figcaption></figure><p id="b85d" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">方程式3的逆运算。是:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/da6b2a00b6cd518e69524db3feabd273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*PsMAPiB0upLjF-LD3RCxwg.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">等式4。树的高度取决于数据的数量</figcaption></figure><p id="234b" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated"><em class="md"> d </em>与白-灰-黑树的大O符号中的时间复杂度相同:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/6e25d2253c10dce2e69d4aa97ad2fc2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*dupMOIC_FV5A9za_cklw_w.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">等式5。白-灰-黑树的大O符号</figcaption></figure><p id="36b0" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">平均相对误差约为4.59%，如对数刻度的图表所示:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nq"><img src="../Images/24326afa14f6cf2858b3368ae0bcec07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uuAYHgyyGj5vSmJclkXUoA.png"/></div></div></figure><p id="ad4d" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated"><strong class="lg iu">指标</strong></p><p id="bcaf" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">以下指标显示了与红黑树相比，WGB(2)树的时间性能。实现是用Java写的。因此，红黑树使用TreeMap数据结构。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e8ab31ffb50b34d8205dfc6be32d240c.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*I5-srUX_LfbbdPiCGUxPRQ.png"/></div></figure><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/4adb2bd0cd4d088c148bff22bc2118d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*SKlvq8DtN0w2UTz9ki4slg.png"/></div></figure><p id="c188" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">键插入图显示大量的CPU时间被用来平衡树。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6e833d7b2a227afa3e18647b3c50e700.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*zQqLyD7-AgIpw3Zo32Q7rg.png"/></div></figure><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/cd5a3ae4f5e42c8e01870ae628228c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*1GX3T38KcZpdCnSMmGDBiQ.png"/></div></figure><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/a651140c7b4704d2217139f0ce6de328.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*aMlUrPLg-kjhVvZVujby1w.png"/></div></figure><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/85ec932fc0d6558674891ca86dd9b2c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*AsPa8m0yfxWhQed3p4jk_g.png"/></div></figure><p id="9dfb" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">通过计算叶子的数量来确定树的内部碎片。接下来的两个图表显示了内部树碎片比较。</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/4b591f757a5b6c0d3ced88bb62e5baec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*YX4bkXwJ6dFLQppdj781Lw.png"/></div></figure><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/52a2a72e1ab2f9004ef51042ebf043ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*ctFz5Lv1mD1_jhMCI7rKCQ.png"/></div></figure><p id="2949" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">最终指标显示了根据B+树(100键拆分)和AVL/RB树的深度比较:</p><figure class="mf mg mh mi gt mj gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi nv"><img src="../Images/f54cc19535f573ca82fbcaefbe51f7e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vl_9IICdIgf9I9VQZ0BvkQ.png"/></div></div></figure><p id="e49b" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated"><strong class="lg iu">优化</strong></p><p id="d337" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">WGB树的实现目前存在于我的DBMS原型中，它有助于提高它的性能。此外，为了在节点叶不存在时不分配节点叶，对实现进行了优化。数学优化用于在以下情况下减少CPU时间:</p><ul class=""><li id="378b" class="mu mv it lg b lh ly lk lz kr mw kv mx kz my lw nk na nb nc bi translated">计算下一个质数</li><li id="e29b" class="mu mv it lg b lh nd lk ne kr nf kv ng kz nh lw nk na nb nc bi translated">通过素数2、3、5和7执行模运算</li></ul><p id="402f" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated"><strong class="lg iu">结论&amp;下一步</strong></p><p id="5d33" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">乍看之下，树形指标表现良好，但这只是研究的开始，这些指标<strong class="lg iu">不应该被认真对待</strong>。所以这棵树以后会有更多的测试和分析。</p><p id="e8ce" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">也许将来采油树的结构或行为会改变，比如从原始采油树到WGB采油树。</p><p id="bc98" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">如果您有任何问题，可以通过邮件联系我:</p><p id="4e96" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">dsenta00@fesb.hr</p><p id="7df2" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">或者您可以将我添加为LinkedIn联系人</p><div class="nw nx gp gr ny nz"><a href="https://www.linkedin.com/in/dsenta/" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">Duje Senta —克罗地亚|职业简介| LinkedIn</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">查看Duje Senta在LinkedIn上的职业简介。LinkedIn是世界上最大的商业网络，帮助…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">www.linkedin.com</p></div></div></div></a></div><p id="86b5" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">感谢您阅读这篇文章，</p><p id="aaaf" class="pw-post-body-paragraph le lf it lg b lh ly ju lj lk lz jx lm kr ma lo lp kv mb lr ls kz mc lu lv lw im bi translated">杜杰森塔</p></div></div>    
</body>
</html>