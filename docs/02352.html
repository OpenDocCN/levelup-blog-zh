<html>
<head>
<title>Metaprogramming in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby中的元编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/metaprogramming-in-ruby-df797b2f784f?source=collection_archive---------4-----------------------#2020-03-08">https://levelup.gitconnected.com/metaprogramming-in-ruby-df797b2f784f?source=collection_archive---------4-----------------------#2020-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ed5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Ruby令人印象深刻的动态特性赋予了您在运行时定义方法和类的自由，这就是所谓的元编程。通过使用Ruby进行元编程，您可以在运行时询问自己的代码问题，这使得您可以在用另一种语言完成相同任务所需时间的一小部分内完成任务。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/3cd8d370dfe6100b29661d7b6d2e8686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mafuGZdfKl_GGYne.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">红宝石，<a class="ae le" href="https://morioh.com/p/0116c0dcd0fe" rel="noopener ugc nofollow" target="_blank">https://morioh.com/p/0116c0dcd0fe</a></figcaption></figure><h1 id="865f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是元编程？</h1><p id="2971" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">根据维基百科:</p><blockquote class="mi mj mk"><p id="805a" class="jq jr ml js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated">元编程是编写计算机程序，这些程序将其他程序(或它们自己)作为它们的数据来编写或操作，或者在编译时完成原本要在运行时完成的部分工作。在许多情况下，这允许程序员在与他们手动编写所有代码相同的时间内完成更多的工作，或者它给程序更大的灵活性，以有效地处理新的情况，而无需重新编译。或者，更简单地说:元编程是编写在运行时编写代码的<strong class="js iu">代码，以使您的生活更加轻松。</strong></p></blockquote><p id="8a22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将会看到一些不同的Ruby元编程的例子，特别是在使用Sinatra和Rails框架时。</p><h1 id="affe" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Rails中的元编程</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mp"><img src="../Images/76118e7becd6e3f0015abc7bf53cdc2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PNNo29JSC0kHvL2d.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Ruby on Rails，<a class="ae le" href="https://en.wikipedia.org/wiki/Ruby_on_Rails" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Ruby_on_Rails</a></figcaption></figure><p id="eab8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从<a class="ae le" href="https://rubyonrails.org/" rel="noopener ugc nofollow" target="_blank"> Rails框架</a>中一个非常基本的例子开始。假设您有一个针对<code class="fe mq mr ms mt b">users</code>的数据库表，其中包含针对<code class="fe mq mr ms mt b">name</code>和<code class="fe mq mr ms mt b">email</code>的列。Rails不知道数据库中每个<code class="fe mq mr ms mt b">user</code>都有哪些列，但是下面的查询工作得很好。</p><pre class="kp kq kr ks gt mu mt mv mw aw mx bi"><span id="fb2e" class="my lg it mt b gy mz na l nb nc"><strong class="mt iu">User</strong>.find_by_email('harry@potter.com')<br/># =&gt; &lt;user id: 123, email: 'harry@potter.com', name: 'Harry Potter'&gt;</span></pre><p id="dd0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从未定义过<code class="fe mq mr ms mt b">find_by_email</code>方法，但它对我们来说就像预期的那样有效。这是因为Rails框架基于数据库中的列名动态创建了一个新方法。这是元编程的一个简单例子，因为该方法从未被定义，而是在运行时生成。</p><p id="e1cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在研究Ruby的元编程时，您可能会遇到一个常见的术语，即monkey patch。monkey补丁是程序在面向对象语言中本地扩展或修改系统类的一种方式。</p><pre class="kp kq kr ks gt mu mt mv mw aw mx bi"><span id="f727" class="my lg it mt b gy mz na l nb nc">[1, 2, 3].to_s<br/>=&gt; "[1, 2, 3, 4]" </span><span id="7fe9" class="my lg it mt b gy nd na l nb nc"><strong class="mt iu">class</strong> Array  <br/>  <strong class="mt iu">def</strong> to_s    <br/>    '[]'  <br/>  <strong class="mt iu">end</strong><br/><strong class="mt iu">end</strong></span><span id="9b20" class="my lg it mt b gy nd na l nb nc">[1, 2, 3].to_s<br/>=&gt; "[]"</span></pre><p id="0e01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的例子是一个基本的方法，它展示了我们可以进入任何类，甚至是像Array这样的核心类，并且动态地修改它。</p><h1 id="d058" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Sinatra中的元编程</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/7d9a2c3a104722c54817c09abb7ee9c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*lT7hvmmOLpGScUoR"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">鲁比·辛纳特拉，<a class="ae le" href="http://woodiwiss.me/the-awesome-of-sinatra/" rel="noopener ugc nofollow" target="_blank">http://woodiwiss.me/the-awesome-of-sinatra/</a></figcaption></figure><p id="1e0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae le" href="http://sinatrarb.com/" rel="noopener ugc nofollow" target="_blank"> Sinatra </a>框架有一个<code class="fe mq mr ms mt b">Sinatra::Delegator</code>模块，用于将方法调用委托或分配给指定的<code class="fe mq mr ms mt b">target</code>。目标默认设置为<code class="fe mq mr ms mt b">Sinatra::Application</code>。</p><p id="1ada" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的例子中，我们首先为<code class="fe mq mr ms mt b">Module</code> <em class="ml"> </em>类定义了一个名为<code class="fe mq mr ms mt b">delegar</code>的新方法，这样我们就可以说，当你调用某个方法时，你是在不同的对象上调用该方法，而不是在使用它的当前对象上。这是在<code class="fe mq mr ms mt b">Sinatra::Delegator</code>中定义的<code class="fe mq mr ms mt b">delegate</code>类方法的简化版本。</p><pre class="kp kq kr ks gt mu mt mv mw aw mx bi"><span id="32c5" class="my lg it mt b gy mz na l nb nc"><strong class="mt iu">class Module</strong><br/>  <strong class="mt iu">def delegar</strong>(method, to:)<br/>    define_method(method) do |*args, &amp;block|<br/>      send(to).send(method, *args, &amp;block)<br/><strong class="mt iu">    end<br/>  end<br/>end</strong></span></pre><p id="2bfb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当这个方法被调用时，它将定义一个新方法，该方法的工作是将工作委托给另一个对象。</p><pre class="kp kq kr ks gt mu mt mv mw aw mx bi"><span id="794a" class="my lg it mt b gy mz na l nb nc"><strong class="mt iu">class Receptionist</strong><br/>  <strong class="mt iu">def phone</strong>(name)<br/>    puts "Hello #{name}, I've answered your call."<br/><strong class="mt iu">  end<br/>end</strong></span><span id="f9f2" class="my lg it mt b gy nd na l nb nc"><strong class="mt iu">class Company</strong><br/>  attr_reader :receptionist<br/>  delegar :phone, to: :receptionist </span><span id="ed16" class="my lg it mt b gy nd na l nb nc"><strong class="mt iu">  def initialize</strong><br/>    @receptionist = Receptionist.new<br/><strong class="mt iu">  end<br/>end</strong></span><span id="d04d" class="my lg it mt b gy nd na l nb nc">company = Company.new<br/>company.phone 'Quinton'<br/># =&gt; "Hello Quinton, I've answered your call."</span></pre><p id="91b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，我们调用了<code class="fe mq mr ms mt b">Company</code> <em class="ml"> </em>类上的<code class="fe mq mr ms mt b">phone</code>方法，但是实际上是<code class="fe mq mr ms mt b">Receptionist</code>类处理调用，因为我们已经将<code class="fe mq mr ms mt b">phone</code>调用委托给了<code class="fe mq mr ms mt b">Receptionist</code> <em class="ml">。</em></p><p id="3a1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看另一个例子，看看如何动态定义一个缺失的方法。当你在一个对象上调用一个方法时，Ruby进入这个类并试图找到这个方法，如果找不到，它继续沿着祖先的链向上搜索。如果仍未找到该方法，则调用<code class="fe mq mr ms mt b">method_missing</code>方法。如果发生这种情况，我们可以使用<code class="fe mq mr ms mt b">define_method</code>动态创建一个新方法。这与使用通常的<code class="fe mq mr ms mt b">def</code>来创建方法没有太大的不同，但是它允许我们保持代码干燥。</p><pre class="kp kq kr ks gt mu mt mv mw aw mx bi"><span id="6d6c" class="my lg it mt b gy mz na l nb nc"><strong class="mt iu">class</strong> <strong class="mt iu">Developer</strong><br/>  <strong class="mt iu">def</strong> <strong class="mt iu">method_missing</strong> <strong class="mt iu">method</strong>, <strong class="mt iu">*args</strong>, <strong class="mt iu">&amp;block</strong><br/>    <strong class="mt iu">return</strong> <strong class="mt iu">super</strong> method, *args, &amp;block <br/>           <strong class="mt iu">unless</strong> method.to_s =~ /^newApp_\w+/<br/>    <strong class="mt iu">self</strong>.<strong class="mt iu">class</strong>.send(:define_method, method) <strong class="mt iu">do</strong><br/>      p "writing " + method.to_s.gsub(/^newApp_/, '').to_s<br/>    <strong class="mt iu">end</strong><br/>    <strong class="mt iu">self</strong>.send method, *args, &amp;block<br/>  <strong class="mt iu">end</strong><br/><br/><strong class="mt iu">end</strong><br/><br/>developer = Developer.new<br/><br/>developer.newApp_frontend<!-- --> <br/># =&gt; "writing newApp_frontend"<br/>developer.newApp_backend<br/># =&gt; "writing newApp_backend"<br/>developer.newApp_debug<br/># =&gt; "writing newApp_debug"</span></pre><p id="e0cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码中，调用一个不存在的方法会触发<code class="fe mq mr ms mt b">method_missing</code>。在这种情况下，我们只想在方法名以<code class="fe mq mr ms mt b">"newApp_"</code>开头时创建一个新方法。通过使用这段代码，我们可以在<code class="fe mq mr ms mt b">define_method</code>的帮助下从<code class="fe mq mr ms mt b">"newApp_"</code>开始创建数以千计的新方法。</p><p id="e7c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文只是触及了Ruby元编程的皮毛，它是一项非常强大的技术，但只有在正确和谨慎使用的情况下。它可以帮助你保持代码<a class="ae le" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干燥</a>并且有助于调试，但是如果过度使用也会增加混乱。希望这篇元编程介绍已经激发了您学习更多相关知识的好奇心！</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><div class="kp kq kr ks gt nm"><a href="https://www.toptal.com/ruby/ruby-metaprogramming-cooler-than-it-sounds" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">Ruby元编程比听起来更酷</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">Ruby元编程是Ruby最有趣的一个方面，它使编程语言能够实现一个更好的编程环境。</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">www.toptal.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa ky nm"/></div></div></a></div><div class="ob oc gp gr od nm"><a href="https://blog.codeship.com/metaprogramming-in-ruby/" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">Ruby中的元编程——via @ codeship</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">在本文中，我们将探讨Ruby元编程的几个不同方面。首先，什么是…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">blog.codeship.com</p></div></div><div class="nv l"><div class="oe l nx ny nz nv oa ky nm"/></div></div></a></div><div class="ob oc gp gr od nm"><a href="http://rubylearning.com/blog/2010/11/23/dont-know-metaprogramming-in-ruby/" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">不知道Ruby的元编程？</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">这篇客座博文由加文·莫里斯(Gavin Morrice)撰写，他是位于爱丁堡的软件精品店Katana Code Ltd .的董事总经理</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">rubylearning.com</p></div></div><div class="nv l"><div class="of l nx ny nz nv oa ky nm"/></div></div></a></div><div class="ob oc gp gr od nm"><a href="https://www.rubyguides.com/2016/04/metaprogramming-in-the-wild/" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">Ruby元编程:真实世界的例子</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">你可能以前读过Ruby元编程。但是...如果你没有几个具体的…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">www.rubyguides.com</p></div></div><div class="nv l"><div class="og l nx ny nz nv oa ky nm"/></div></div></a></div><div class="ob oc gp gr od nm"><a href="https://en.wikipedia.org/wiki/Metaprogramming" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">元编程</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">元编程是一种编程技术，在这种技术中，计算机程序有能力将其他程序视为自己的程序</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">en.wikipedia.org</p></div></div><div class="nv l"><div class="oh l nx ny nz nv oa ky nm"/></div></div></a></div><div class="ob oc gp gr od nm"><a href="https://www.crondose.com/2016/08/examples-metaprogramming-guide-beginners/" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd iu gy z fp nr fr fs ns fu fw is bi translated">元编程示例——初学者指南</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">今天我将介绍元编程的例子。等等，别跑！元编程是更多…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">www.crondose.com</p></div></div><div class="nv l"><div class="oi l nx ny nz nv oa ky nm"/></div></div></a></div></div></div>    
</body>
</html>