<html>
<head>
<title>Functional React. Is it possible? Exploring functional programming techniques in React using Higher Order Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">功能反应。可能吗？使用高阶组件探索React中的函数式编程技术</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-react-is-it-possible-ceaf5ed91bfd?source=collection_archive---------0-----------------------#2018-10-24">https://levelup.gitconnected.com/functional-react-is-it-possible-ceaf5ed91bfd?source=collection_archive---------0-----------------------#2018-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/68ce9abc8711abf7f5b08d688dee3b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tI12lTja7v6HnWbW7fuhEg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">布雷登·安德森在Unsplash<a class="ae kc" href="https://unsplash.com/search/photos/puppy-with-glasses?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></figcaption></figure><p id="d70f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">警告</strong> —这篇帖子包含大量<strong class="kf ir">代码</strong>。如果你看到了大量的javascript代码，请在继续之前咨询你所爱的人、宗教领袖或者一只舒适的小狗。</p><p id="436e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">目录</strong></p><ul class=""><li id="6ceb" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">介绍</li><li id="8f76" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">定义</li><li id="25bd" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">双向编写的相同组件</li><li id="2a21" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">重写</li><li id="6066" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">滚动您自己的高阶组件</li><li id="9f79" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">真实世界的例子</li><li id="91fc" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">优势</li><li id="f2f2" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">反应自然</li><li id="1161" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">潜在的不利因素</li><li id="6980" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">可供选择的事物</li><li id="d9ad" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">结论</li><li id="ec0d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">资源</li></ul></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="84b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">抱歉，这个标题很吸引人。让我更坦率地告诉你。</p><p id="3302" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">是的。是的，它是。</strong></p><p id="a7b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">我将向您展示如何</strong>。但首先，介绍一下背景。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="8787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2017年下半年开始用React。我对web开发相当生疏，但是React的一些东西让我印象深刻——比任何其他框架都深刻。</p><p id="ebb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在以前的工作中学习了React的一点一滴，但这只是概念的证明和新的代码库，不会很快发布。</p><p id="b864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我非常渴望全职和React一起工作。幸运的是，我找到了<a class="ae kc" href="https://drawboard.com.au" rel="noopener ugc nofollow" target="_blank">画板</a>，剩下的就是历史了。</p><p id="9c71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在开始之前的几个星期，我和我未来的一个同事——另一个前端开发人员——发了一封电子邮件，他给了我一份正在web应用上使用的技术/框架的列表。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/76d3b3a471481b52e3dae66d36efc3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECgKXCzYp0L59cnUnuIN2w.png"/></div></div></figure><p id="0dcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初，我从未听说过<a class="ae kc" href="https://github.com/acdlite/recompose" rel="noopener ugc nofollow" target="_blank"> <em class="mb">改编</em> </a>。我只是模糊地知道什么是特设——<em class="mb">高阶组件</em>——是什么。函数式编程是在黑暗的走廊里悄悄流传的东西，是上帝提出的——一个我一无所知的高不可攀的范例。</p><p id="7245" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在我开始使用Drawboard之前，我正在编写非常典型的React代码。它看起来有点像这样。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mc"><img src="../Images/96b03c532fbbe0b3bb87f203a0ee7187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6Ble7fCLuV2vY2jY"/></div></div></figure><p id="c799" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从那以后，一切都变了。我很少使用关键字<code class="fe md me mf mg b">class</code>。我们的大多数视图逻辑是由高阶组件和效用函数组成的。孤立地看很容易理解的小积木，但是组合起来却非常强大。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="00da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们深入编写functional React的宏伟的兔子洞之前，让我们从一些解释/定义开始。</p><p id="64ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">高阶</strong></p><p id="158c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个函数的<em class="mb">阶</em>是指它有多深。你的典型功能是下单。在执行时——通过一些东西(参数)或其他——它做一件事，然后完成执行(通过返回一些东西或什么都不返回)。</p><p id="c433" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">高阶函数在<strong class="kf ir">更大的</strong> <strong class="kf ir">标度</strong>上运行。它有更远大的抱负。</p><blockquote class="mj"><p id="19cd" class="mk ml iq bd mm mn mo mp mq mr ms la dk translated">高阶函数要么接受函数作为参数，要么返回函数。或者两者都有。</p></blockquote><figure class="mu mv mw mx my jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/8f88051772b9aea00baf2ed23f65bc01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcF5Gxc4dL5fr1F805rXrQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">高阶函数</figcaption></figure><p id="e250" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但这太笼统了。我们在说反应！</p><p id="cdbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">稍等一下。组件不就是对功能的抽象吗？</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/82328bf617dc5ef8592fbf15a0506e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/0*j_DEmqeVIoJABZXr"/></div></figure><p id="54a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这自然使我们得出以下结论:</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/865cd49642c5114b0f1bcdb70bb15581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qaYUEoAFwUGl-MIVJI8nyw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">hoc或更高阶组件</figcaption></figure><p id="b49b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi na translated">如果这还不十分清楚，那也没关系。但是坚持下去，我向你保证，一旦你掌握了它们的<strong class="kf ir">能力</strong>，你将会在任何地方使用更高阶的功能和组件。</p><p id="48e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你在过去几年中的任何时候都赶上了React/Redux潮流，你可能已经使用了更高阶的元件，甚至没有意识到这一点。</p><p id="f901" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个常见的:</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mc"><img src="../Images/895073465b35ebb7d2d5e7f8053506c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UbNxUSiQrqBPTLPH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">react-redux连接</figcaption></figure><p id="b282" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe md me mf mg b">connect</code>接受一些参数——<code class="fe md me mf mg b">mapState</code>和<code class="fe md me mf mg b">mapDispatch</code>——并吐出一个高阶分量。这个HOC获取你的TodoList组件，并吐出一个新的，<em class="mb">增强的</em>组件。从这个意义上说，<code class="fe md me mf mg b">connect</code>的行为就像一个特设工厂。</p><p id="f467" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只是为了真正把它送回家:</p><blockquote class="mj"><p id="5d31" class="mk ml iq bd mm mn mo mp mq mr ms la dk translated">一般我们说的高阶分量<strong class="ak"> (HOC) </strong>，就是一个<strong class="ak">的东西</strong>拿一个<strong class="ak">分量</strong>吐出<strong class="ak">另一个分量</strong>。一个新的，<strong class="ak">增强组件</strong>。</p></blockquote><p id="628e" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">说够了！让我们来看看用两种不同风格编写的同一个组件。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="no mi l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">敬代码！</figcaption></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="8559" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是我们的<em class="mb"> Farm </em>组件，写成一个类。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="np mi l"/></div></figure><p id="f870" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我夸大了一点来证明一个观点——你<em class="mb">实际上</em>实现<code class="fe md me mf mg b">shouldComponentUpdate</code>的频率有多高？但除此之外，它是一个非常典型的组件。</p><p id="9f5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是同一个组件，从功能上来说。注意，我使用了前面提到的库中的一些助手，重新组合。稍后我会详细解释<code class="fe md me mf mg b">recompose</code>是如何工作的。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="np mi l"/></div></figure><p id="edfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者更好，使用<code class="fe md me mf mg b">recompose/compose:</code></p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="np mi l"/></div></figure><p id="cf39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">乍一看，这两种不同的风格可能看起来非常不同，但它们实际上做的是同一件事。</p><p id="7856" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设你有一个<code class="fe md me mf mg b">Workshop</code>组件。它可以在一个单独的视图中使用，甚至可以在一个完全不同的应用程序中使用。你将能够从<code class="fe md me mf mg b">Farm</code>组件中“窃取”所有的业务逻辑——你可以挑选较小的HOC或抓取组合的<code class="fe md me mf mg b">enhance</code>HOC——甚至不费吹灰之力。</p><p id="1cf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在典型的基于类的组件中，你会怎么做呢？你不能。这就是为什么写作对HOCs的功能反应如此令人敬畏。</p><p id="da81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">介绍重组:</strong></p><blockquote class="mj"><p id="040d" class="mk ml iq bd mm mn mo mp mq mr ms la dk translated">“Recompose是用于函数组件和高阶组件的react实用工具带。就像lodash代表React一样。”</p></blockquote><p id="6d7a" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">那是直接取自<code class="fe md me mf mg b">README</code>。简而言之，这是一个有用的hoc和助手集合，为您编写高质量的功能性React代码开辟了道路。</p><p id="7cc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们深入研究一些<code class="fe md me mf mg b">recompose</code>代码。我保证它非常平易近人——它在引擎盖下没有做任何超级时髦的事情。</p><p id="6eba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">重新组合/mapProps(为简洁起见进行了编辑。</strong> <a class="ae kc" href="https://github.com/acdlite/recompose/blob/master/src/packages/recompose/mapProps.js" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">原文</strong> </a> <strong class="kf ir"> ) </strong></p><pre class="lx ly lz ma gt nq mg nr ns aw nt bi"><span id="ade0" class="nu nv iq mg b gy nw nx l ny nz">import { createFactory } from "react"</span><span id="81d6" class="nu nv iq mg b gy oa nx l ny nz">const mapProps = propsMapper =&gt; BaseComponent =&gt; {</span><span id="890c" class="nu nv iq mg b gy oa nx l ny nz">    const factory = createFactory(BaseComponent)</span><span id="617f" class="nu nv iq mg b gy oa nx l ny nz">    return props =&gt; factory(propsMapper(props))</span><span id="6fdd" class="nu nv iq mg b gy oa nx l ny nz">}</span></pre><p id="85b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在道具到达你的组件之前使用<code class="fe md me mf mg b">mapProps</code>来映射它们。假设我们的道具最初是这样的:</p><pre class="lx ly lz ma gt nq mg nr ns aw nt bi"><span id="af68" class="nu nv iq mg b gy nw nx l ny nz">{routerProps: {location, query, hash}, tools, ...props}</span></pre><p id="908a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是您的组件并不关心routerProps来自哪里——它只需要它们的原样。一个例子<code class="fe md me mf mg b">propsMapper</code>可以是:</p><pre class="lx ly lz ma gt nq mg nr ns aw nt bi"><span id="21af" class="nu nv iq mg b gy nw nx l ny nz">const propsMapper = <br/>   ({routerProps, ...props}) =&gt; ({...routerProps, ...props})</span></pre><p id="c44f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没什么疯狂的，只是传播了<code class="fe md me mf mg b">routerProps</code>。</p><p id="b4b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以要使用mapProps，你需要做这样的事情:</p><pre class="lx ly lz ma gt nq mg nr ns aw nt bi"><span id="e6cd" class="nu nv iq mg b gy nw nx l ny nz">const myMapProps = mapProps(propsMapper)</span><span id="ccb9" class="nu nv iq mg b gy oa nx l ny nz">const myEnhancedComponent = mapProps(myBaseComponent)</span><span id="2544" class="nu nv iq mg b gy oa nx l ny nz">// alternatively, all in one go:</span><span id="2148" class="nu nv iq mg b gy oa nx l ny nz">const myEnhancedComponent = mapProps(propsMapper)(myBaseComponent)</span></pre><p id="fbcd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想你开始掌握整个<em class="mb">高阶</em>的事情了。</p><p id="63d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在——recompose有一些非常有用的技巧。但是它们是基本的、通用的，并不能解决您的应用程序的所有具体问题。不用担心——你可以也应该<strong class="kf ir"> </strong>推出你自己的高阶元件来满足你的需求。我们的代码库中有数百个。</p><p id="e304" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我写的一个叫做<code class="fe md me mf mg b">withStateOfTypeSet</code>的例子。</p><p id="7412" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这有助于避免在许多必须存储某个属于某个集合的本地状态的组件之间重复实现相同的逻辑。对于那些不熟悉JS中集合行为的人——查看一下<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>。</p><p id="5c1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> withStateOfTypeSet </strong></p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="np mi l"/></div></figure><p id="6ccf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望代码是非常自文档化的。这是一个<em class="mb">漂亮的</em> HOC，它抽象出一些你在初始化或者添加/删除<code class="fe md me mf mg b">Set</code>时必须做的奇怪事情。这里我唯一需要解释的是<code class="fe md me mf mg b">recompose/withHandlers</code>向你的组件添加了一些函数，这些函数是用最新的道具调用的。<a class="ae kc" href="https://github.com/acdlite/recompose/blob/master/src/packages/recompose/withHandlers.js" rel="noopener ugc nofollow" target="_blank">看看吧。</a></p><blockquote class="mj"><p id="2546" class="mk ml iq bd mm mn mo mp mq mr ms la dk translated">你能创作HOCs的范围是无限的。这些是构建应用程序的构件。</p></blockquote><p id="688d" class="pw-post-body-paragraph kd ke iq kf b kg nj ki kj kk nk km kn ko nl kq kr ks nm ku kv kw nn ky kz la ij bi translated">到目前为止，我只展示了学习示例。虽然很酷——但它们并没有真正展示functional React在极端情况下会是什么样子。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="ob mi l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">极端反应</figcaption></figure><p id="ed29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我们最大的组件之一的默认导出。它有很多行为，是这一群中最丑陋的一个。但是它的所有功能都是由许多小积木组成的。所有的<code class="fe md me mf mg b">handlers</code>都是微小的功能。视图逻辑是一个无状态的功能组件，除了声明组件应该是什么样子之外，它什么也不做。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/ea52fce9405d193061a544d369fd0fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E9k2c0B7MU7VQA2H"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">你可以带着这些想法深入研究</figcaption></figure><p id="a662" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi na translated">现在，我已经写了一大堆关于什么的文章。但是，让我们跳到广泛的和绝对积极的<em class="mb">为什么</em>。</p><p id="c970" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不会从总体上讲述编写函数式代码的好处——函数式代码有很多——因为这篇文章会变成一篇说教。但是探索一些特定于React的优点肯定在范围之内。</p><p id="b904" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">组件内代码重用更加可行</strong></p><p id="d890" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您现在可以在组件之间共享代码，而无需复制粘贴。这可能是最大的胜利。您的代码库将更加简洁，您只需在一个地方而不是10个地方更改业务逻辑，代码的可读性将大大提高。另外，对于新开发人员来说，开发更小的功能和组件比尝试开发500行的怪物要容易得多。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mc"><img src="../Images/8675540a11ec02a0be7159ac5d8026cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rR_i5KSRKqis1gVa.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">对不起500线类组件先生。去远足吧！</figcaption></figure><p id="d3ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦您的整个代码库遵循相同的模式，效果就会越来越复杂。因为随着时间的推移——这是不可避免的——你会发现你已经完成了你试图建立的新事物。你已经写了90%你需要的hoc！所以这只是即插即用，然后你可以发货！🚢(开玩笑，但抛开乐观的妄想，有时候其实就是那样的感觉。)</p><p id="3b6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，您最终制作的组件是由一个或多个hoc组成的，这些hoc包装了一些通用组件，比如一个模型、一个按钮或一个链接。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="f97a" class="od nv iq bd oe of og oh oi oj ok ol om on oo op oq or os ot ou ov ow ox oy oz bi translated"><strong class="ak">利益如何延伸到本土反应</strong></h1><p id="7507" class="pw-post-body-paragraph kd ke iq kf b kg pa ki kj kk pb km kn ko pc kq kr ks pd ku kv kw pe ky kz la ij bi translated">今年早些时候，我谈到了我在T4将React Native集成到现有iOS应用程序中的经历。我也在<a class="ae kc" href="http://melbjs.com" rel="noopener ugc nofollow" target="_blank"> MelbJS </a>上讲过——幻灯片在我的<a class="ae kc" href="https://james.now.sh/" rel="noopener ugc nofollow" target="_blank">网站</a>上。这是我真正感到兴奋的事情。有一点对我来说是革命性的，那就是在两个应用程序之间共享代码的能力。</p><p id="06f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经将web repo设置为iOS项目中的一个子模块，因此我们为web编写的任何代码都可以很容易地在iOS应用程序中使用。这有很多很酷的部分iOS应用程序甚至“复制”了与web相同的数据层！—如果您像我们一样编写自己的React，那么您可以跨平台共享组件业务逻辑。</p><p id="e829" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们举一个真实世界的例子。几个月前，我们在web应用程序中构建了问题管理。可以把它想象成建筑师/工程师提出图纸问题的吉拉。</p><p id="c2c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">难道没有一些规则表明，每一个发展到足够大的软件项目最终都会构建自己的吉拉实现吗？🤔</p><p id="d735" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，核心组件之一<code class="fe md me mf mg b">Issue</code>的导出看起来有点像这样:</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pf"><img src="../Images/4dd1648236265d516dce338c1581cfda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mog6vSk0TJdJhI7U"/></div></div></figure><p id="6a41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意红色。当我开始在React Native的iOS应用程序中构建相同的功能集时，我们需要同样的逻辑。因此，一个自然的重构随之而来:</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pg"><img src="../Images/60f4aaf55fc32df852ca014dfbeefc88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u_39dZy2GWjxasPM"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">重构…</figcaption></figure><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/36e07b877274072c8334ec737ed40d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/0*fpmxiDWItRfZIjRj"/></div></figure><p id="5975" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我可以使用这个HOC来连接React Native <code class="fe md me mf mg b">Issue</code>组件！</p><p id="fb61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，这不是一个疯狂复杂的例子，但我希望你能看到这些想法如何扩展到整个功能，代码库，甚至像在这个例子中的交叉项目。我甚至不用去找这个例子！当我发表这篇文章的时候，我刚刚完成了这个特性的构建——仅仅从我的日常工作中，就可以很容易地找到React中的函数式编程为什么如此棒的例子，这真是太棒了。</p><p id="0c91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们能够如此成功/快速地用React Native进行实验，完全是因为我们的web代码库是以这种方式构建的。</p><p id="dfec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你实际上可以更进一步，使用<code class="fe md me mf mg b"><a class="ae kc" href="https://github.com/necolas/react-native-web" rel="noopener ugc nofollow" target="_blank">react-native-web</a></code>或<code class="fe md me mf mg b"><a class="ae kc" href="https://github.com/lelandrichardson/react-primitives" rel="noopener ugc nofollow" target="_blank">react-primitives</a></code>共享视图逻辑，但是我还没有把这些想法带到我们的应用程序中。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="1f3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">潜在的不利因素</strong></p><p id="1b69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不是一个狂热地推销某种方法，同时完全忽略任何陷阱的狂热爱好者。</p><p id="0a53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们探讨一下像这样编写所有代码的一些缺点。</p><ul class=""><li id="b992" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">性能特征是一个灰色地带。我把这部分标为<em class="mb">潜在的</em>缺点，因为我真的不确定这一点。我并不是说功能相同的“传统”React视图逻辑比功能相同的React代码的性能差<em class="mb"/>——但是我从未见过任何实验，我还没有深入研究它。这是因为到目前为止，jank在Bullclip web应用程序上还没有出现任何问题。我很想知道是否有人研究过这个问题——特别是使用新的<a class="ae kc" href="https://reactjs.org/docs/optimizing-performance.html#profiling-components-with-the-devtools-profiler" rel="noopener ugc nofollow" target="_blank"> React dev tools profiler </a>的分析功能——所以如果你有兴趣，请联系我们！</li><li id="74b9" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">有时候，有些事情你要么不能做，要么使用这种模式会变得更加困难。使用引用是可行的，但是不够直观。如果你正在进入生命周期并做非常复杂的事情——你可能会发现使用一个类更容易。但是你可以像对待一个以功能为主的代码库中不纯的、有副作用的代码一样对待这些事情。隔离它，承认你正在使用一些不纯的代码，使用它，然后继续前进。</li><li id="1db1" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">React开发工具深入人心。探索组件树要困难得多(但并非不可能),因为每个HOC都会向树中添加另一个组件。有趣的是，我并不经常需要这样做，因为像这样写代码的好处之一就是我通常可以很快找到问题所在。</li></ul><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mc"><img src="../Images/1b3aabd459eb28d098ab13904cc574d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XRnrdSEgQgpeaIz7"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">你的反应开发工具很厚</figcaption></figure><p id="722a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，你可以看到这是一个加分，如果你欣赏的能力，看到哪个特设添加到链中的道具。</p><p id="973e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">探索替代方案</strong></p><ul class=""><li id="f13b" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">渲染道具。如果我没有HOCs(切到一个启示录，反乌托邦的未来，功能在单个订单上最大化)——我最喜欢这种模式。这超出了本文的范围，但是可以查看官方的react <a class="ae kc" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</li><li id="f01c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">从类组件中挂接的纯函数集合。(有点难看但仍然允许代码重用。不过，与<code class="fe md me mf mg b">this</code>打交道可能会有点麻烦。)</li><li id="d605" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">到处都是基于原型/类的(<em class="mb">扩展</em>)继承？<strong class="kf ir"> <em class="mb">请</em> </strong> <em class="mb">不要这样。</em></li><li id="4a27" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">到处复制/粘贴代码？(我开玩笑的。斯塔普，请。)……(我开玩笑的。斯塔普，请。)</li></ul></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="cff0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望在编写函数式反应时，我已经给出了足够多的选择。也许还能对我过去一年左右的经历有一点了解。</p><p id="71b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我非常喜欢将我的作品公之于众。这可以为某人节省很多时间——或者给另一个人一个机会向我解释为什么我的观点是错误的。如果你有任何问题/想告诉我为什么你认为这不好，为什么我错了或者我有味道，请联系我。我保证不会对你大喊函数式编程术语。</p><p id="9f31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我会把所有的焦虑都放进一个<a class="ae kc" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank"> <em class="mb">库里</em> </a> <em class="mb">。</em></p><p id="a69c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以在<a class="ae kc" href="https://james.now.sh" rel="noopener ugc nofollow" target="_blank"> https://james.now.sh </a>找到更多关于我的信息。或者通过跟踪我的GitHub <a class="ae kc" href="https://github.com/james-E-Adams" rel="noopener ugc nofollow" target="_blank"> @James-E-Adams </a>。或者推特我<a class="ae kc" href="https://twitter.com/jamesadams0" rel="noopener ugc nofollow" target="_blank"> @jamesadams0 </a>！</p><p id="ee05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">资源:</p><ul class=""><li id="2ffc" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae kc" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/higher-order-components.html</a></li><li id="4e63" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/" rel="noopener ugc nofollow" target="_blank">https://dr boolean . git books . io/mosely-sufficient-guide-old/content/</a></li></ul><p id="1f51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章的内容来源于我在8月墨尔本React会议上的一次演讲。你可以在<a class="ae kc" href="https://james.now.sh" rel="noopener ugc nofollow" target="_blank"> https://james.now.sh </a>找到幻灯片。</p></div></div>    
</body>
</html>