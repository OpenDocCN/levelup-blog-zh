<html>
<head>
<title>Answering Your App’s Questions with Redux Selectors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redux选择器回答应用程序的问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/redux-selectors-logic-9d0335d1c0f1?source=collection_archive---------16-----------------------#2020-04-24">https://levelup.gitconnected.com/redux-selectors-logic-9d0335d1c0f1?source=collection_archive---------16-----------------------#2020-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/52e310c07a32ef1fa8818756c77dcea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UjGejODagMtEsRwrwxzxrA.jpeg"/></div></div></figure><p id="de5c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<a class="ae kz" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>的所有概念中，<em class="la">选择器</em>是最被低估的。最近，由于引入了<a class="ae kz" href="https://react-redux.js.org/next/api/hooks" rel="noopener ugc nofollow" target="_blank"> React Redux挂钩</a>，它们变得越来越重要，这使得它们成为将Redux中的数据导入React组件的主要手段。但是，我注意到，选择器通常只被视为隐藏Redux状态形状的“状态获取器”,或者是防止不必要地重新计算状态派生值的性能优化。</p><p id="f531" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我将展示选择器远不止这些。具体来说，我将展示它们不仅是访问Redux状态的好工具，也是以一种易于推理、扩展、重用和测试的方式封装应用程序逻辑的好工具。正如我们将要看到的，所需要的只是观念的转变。</p><h1 id="1679" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关于选择器</h1><p id="cbdd" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">在Redux中，<strong class="kd iu">选择器</strong>是一个函数，它获取存储的当前状态，并返回从中提取或导出的值。例如，考虑一个货币转换器应用程序，其Redux状态如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="aa59" class="mn lc it mj b gy mo mp l mq mr">{<br/>  sourceAmount: 123.45,  // the amount of money to convert<br/>  sourceCurrency: 'EUR', // The currency of the source amount<br/>  targetCurrency: 'USD'  // the currency to convert to<br/>}</span></pre><p id="38c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">给定这种状态形状，我们可以编写以下简单的“状态获取器”选择器，分别用于访问源金额、源货币和目标货币:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7c04" class="mn lc it mj b gy mo mp l mq mr">function selectSourceAmount(state) {<br/>  return state.sourceAmount;<br/>}</span><span id="42c9" class="mn lc it mj b gy ms mp l mq mr">function selectSourceCurrency(state) {<br/>  return state.sourceCurrency;<br/>}</span><span id="6774" class="mn lc it mj b gy ms mp l mq mr">function selectTargetCurrency(state) {<br/>  return state.targetCurrency;<br/>}</span></pre><p id="b5c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="la">(在这篇文章中，我在每个选择者的名字前加上</em> <code class="fe mt mu mv mj b"><em class="la">select</em></code> <em class="la">)。其他流行的约定是以</em> <code class="fe mt mu mv mj b"><em class="la">get</em></code> <em class="la">开头的名字或者以</em> <code class="fe mt mu mv mj b"><em class="la">Selector</em></code> <em class="la">结尾的名字。)</em></p><p id="c889" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于选择器是函数，它们不必局限于直接从状态返回值。例如，我们可以编写一个选择器，返回货币转换后的金额，构建在我们之前定义的基本选择器之上:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7dc6" class="mn lc it mj b gy mo mp l mq mr">const conversionRates = {<br/>  'EUR': { 'US': 1.09, /* ... */ },<br/>  // ...<br/>}</span><span id="e7da" class="mn lc it mj b gy ms mp l mq mr">function selectConvertedAmount(state) {<br/>  const sourceCurrency = selectSourceCurrency(state);<br/>  const targetCurrency = selectTargetCurrency(state);<br/>  const rate = conversionRates[sourceCurrency][targetCurrency];<br/>  return getSourceAmount(state) * rate;<br/>}</span></pre><p id="c36d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设这是一个React应用程序，我们现在可以使用React Redux组件中的这些选择器:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bb8a" class="mn lc it mj b gy mo mp l mq mr">import React from 'react';<br/>import { useSelector } from 'react-redux';</span><span id="6b3f" class="mn lc it mj b gy ms mp l mq mr">const ConversionResultView = () =&gt; {<br/>  const sourceAmount = useSelector(selectSourceAmount);<br/>  const sourceCurrency = useSelector(selectSourceCurrency);<br/>  const targetCurrency = useSelector(selectTargetCurrency);<br/>  const convertedAmount = useSelector(selectConvertedAmount);</span><span id="f34e" class="mn lc it mj b gy ms mp l mq mr">  return (<br/>    &lt;p&gt;<br/>      {sourceAmount} {sourceCurrency} is<br/>      {convertedAmount} {targetCurrency}<br/>    &lt;/p&gt;<br/>  );<br/>}</span></pre><p id="da1d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以将所有的状态访问和货币转换代码直接放入<code class="fe mt mu mv mj b">ConversionResultView</code>中。然而，将它提取到独立的选择器中有几个好处。</p><h1 id="ad22" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">包装</h1><p id="31f6" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">使用选择器时，调用者不需要知道Redux状态是如何形成的，也不需要知道选择器需要它的哪些数据；它只是将状态作为一个整体传递，并返回所需的值。不管这个值是直接来自状态还是动态计算的，调用都是一样的。这意味着如果状态的结构发生变化，只需要更新选择器本身；他们的呼叫者不受影响。换句话说，选择器最小化了Redux商店和它的消费者之间的耦合。</p><h1 id="34ae" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">复用性</h1><p id="a767" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">一旦编写完成，就可以从任何一段代码中调用选择器来访问Redux状态。这不仅包括UI组件，还包括其他选择器:因为每个选择器都接收Redux状态作为参数，所以根据定义，它拥有调用任何其他选择器所需的全部内容。因此很容易重用现有的选择器来组成新的选择器。</p><h1 id="91c2" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">纯度、可测试性和记忆性</h1><p id="191c" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">选择器应该是<a class="ae kz" href="https://medium.com/@jamesjefferyuk/javascript-what-are-pure-functions-4d4d5392d49c" rel="noopener">纯函数</a>:给定相同的输入，它们总是返回相同的结果，没有副作用。这使得他们很容易孤立地进行推理。这也使得单元测试变得容易:我们只需要准备一个输入状态，调用选择器，并将返回值与我们所不希望的进行比较，就像下面的例子一样(使用<a class="ae kz" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>):</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8959" class="mn lc it mj b gy mo mp l mq mr">test('selectConvertedAmount()', () =&gt; {<br/>  const state = {<br/>    sourceAmount: 100,<br/>    sourceCurrency: 'EUR',<br/>    targetCurrency: 'USD'<br/>  };<br/>  const result = selectConvertedAmount(state);<br/>  const expectedConversionRate = conversionRates['EUR']['USD'];<br/>  expect(result).toBeCloseTo(100 * expectedConversionRate);<br/>})</span></pre><p id="786b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Purity还支持<em class="la">记忆化</em>:因为我们知道只有当选择器的输入——也就是Redux状态——改变时，它的返回值才会改变，所以我们可以通过缓存来避免重新计算相同的值，只有当传递的状态与之前的状态不同时才进行新的计算。</p><p id="8c32" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank"> Reselect </a>库是这种思想的一个众所周知的实现。使用它，我们可以编写如下的<code class="fe mt mu mv mj b">selectConvertedAmount</code>选择器:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1eca" class="mn lc it mj b gy mo mp l mq mr">import { createSelector } from 'reselect';</span><span id="ccf6" class="mn lc it mj b gy ms mp l mq mr">const selectConvertedAmount = createSelector(<br/>  // The first argument(s) of createSelector() define the<br/>  // selector's *dependencies*, that is, the other selectors<br/>  // whose values are needed for this one.<br/>  selectSourceAmount,<br/>  selectSourceCurrency,<br/>  selectTargetCurrency,</span><span id="8ae1" class="mn lc it mj b gy ms mp l mq mr">  // The last argument is the selector's *implementation*,<br/>  // which receives the return values of its dependencies<br/>  // in the order given above. When the selector is first<br/>  // called, its return value is cached, and the implementation<br/>  // function is not re-run until the passed-in state AND at<br/>  // least one of the dependencies' return values changes<br/>  // (at which point the cache is updated).<br/>  (amount, currency, targetCurrency) =&gt; {<br/>    const rate = conversionRates[currency][targetCurrency];<br/>    return amount * rate;<br/>  }<br/>);</span></pre><p id="33db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="la">(尽管我建议对除了最基本的选择器之外的所有选择器使用Reselect，但为了简单起见，我不会在本文的其余部分使用它。)</em></p><h1 id="bb10" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">作为小领域专家的选择器</h1><p id="9b94" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">到目前为止，我们已经看到Redux选择器可以抽象出状态的形状并避免多余的计算。但是还有更多。</p><p id="a44b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了看到选择器的全部潜力，思考调用一个选择器意味着什么是有帮助的。直觉上，我们可能认为它只是从状态中获取或计算一个值。然而，我意识到把它看作是<em class="la">问一个问题</em>，由选择器根据应用程序世界的“事实”(状态和规则)来回答，会更有帮助。</p><p id="d039" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，在上面的例子中，当<code class="fe mt mu mv mj b">ConversionResultView</code>使用<code class="fe mt mu mv mj b">selectConvertedAmount</code>时，它基本上是在问:“货币转换的当前结果是什么(给定用户的输入)？”请注意，调用者甚至不需要知道回答问题需要哪些信息——所有的知识都在选择器中，它只是从应用程序状态本身获取所需的信息，或者直接查找，或者询问其他选择器。</p><p id="eff1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从这个角度来看，选择器就像你的应用程序的<em class="la">小领域专家，专门回答关于你的应用程序世界的单个问题，并根据需要与其他选择器合作。</em></p><p id="983d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这意味着，每当我们可以将一个应用程序逻辑框定为一个状态相关的问题时，我们就可以将答案表达为一个选择器，从而为我们带来所有提到的封装、可重用性、测试和优化优势。下面几节重点介绍一些说明这一点的示例用例。</p><h1 id="fdc0" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">确认</h1><p id="5f48" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">基本上，验证用户输入是这样的行为:“用户的输入有意义吗(根据应用程序的规则)？”这使得验证逻辑非常适合选择器，只要您在Redux状态下保存要验证的数据。</p><p id="2a47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，想象一个从餐馆点餐的应用程序。用户只能在订单金额高于特定最小金额时下订单。如果我们将当前选择的订单项存储在Redux中，我们可以很容易地为这个规则编写一个选择器:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9aa5" class="mn lc it mj b gy mo mp l mq mr">const minimumOrderAmount = 10;</span><span id="668b" class="mn lc it mj b gy ms mp l mq mr">function selectOrderItems(state) {<br/>  return state.order.items;<br/>}</span><span id="a22b" class="mn lc it mj b gy ms mp l mq mr">function selectIsOrderValid(state) {<br/>  const items = selectOrderItems(state);<br/>  const price = items.reduce((x, item) =&gt; x + item.price, 0);<br/>  return price &gt;= minimumOrderAmount;<br/>}</span></pre><p id="f777" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着逻辑变得更加复杂，这种方法可以很好地伸缩。例如，如果后来决定饮料和甜点不计入最小数量，我们可以在选择器中进行局部更改，而不会影响任何用户。</p><h1 id="2df2" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">过滤、排序和聚合</h1><p id="c1db" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">选择器非常适合使用任意复杂的规则处理项目集合。例如，要回答问题“哪些任务包含用户选择的所有标签？”，我们可以编写一个选择器，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2543" class="mn lc it mj b gy mo mp l mq mr">function selectAllTasks(state) {<br/> return state.tasks;<br/>}</span><span id="ce4e" class="mn lc it mj b gy ms mp l mq mr">function selectSelectedTags(state) {<br/>  return state.filter.tags;<br/>}</span><span id="83e1" class="mn lc it mj b gy ms mp l mq mr">function selectFilteredTasks(state) {<br/>  const tasks = selectAllTasks(state);<br/>  const tags = selectSelectedTags(state);</span><span id="49bb" class="mn lc it mj b gy ms mp l mq mr">  return tasks.filter((task) =&gt;<br/>    tags.every((tag) =&gt; task.tags.includes(tag));<br/>  );<br/>}</span></pre><p id="3314" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着新的过滤器种类的增加，<code class="fe mt mu mv mj b">selectFilteredTasks</code>也可以被扩展来考虑这些，保持代码库的其余部分不变。排序可以用同样的方式处理。</p><p id="43f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还可以使用选择器进行其他类型的聚合。例如，在编写在线测验应用程序时，用于计算用户当前分数的选择器可能如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0cce" class="mn lc it mj b gy mo mp l mq mr">function selectCorrectAnswers(state) {<br/>  return state.quiz.answers;<br/>}</span><span id="9f7c" class="mn lc it mj b gy ms mp l mq mr">function selectGivenAnswers(state) {<br/>    return state.round.answers;<br/>}</span><span id="0554" class="mn lc it mj b gy ms mp l mq mr">function selectScore(state) {<br/>  const correctAnswers = selectCorrectAnswers(state);<br/>  const givenAnswers = selectGivenAnswers(state);</span><span id="410d" class="mn lc it mj b gy ms mp l mq mr">  return givenAnswers.reduce((answer, score, index) =&gt; {<br/>    const isCorrect = answer == correctAnswers[index];<br/>    return score + (isCorrect ? 1 : 0);<br/>  }, 0);<br/>}</span></pre><h1 id="b255" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将逻辑与副作用分开</h1><p id="8a52" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">许多应用程序使用<a class="ae kz" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> thunks </a>、<a class="ae kz" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> sagas </a>、<a class="ae kz" href="https://redux-observable.js.org/" rel="noopener ugc nofollow" target="_blank"> epics </a>或类似的抽象将副作用集成到Redux流中。在某些情况下，尤其是复杂的情况下，它们需要参考应用程序状态来确定要执行哪些操作，或者要向它们传递哪些参数。</p><p id="2d61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以将这种逻辑提取到选择器中，使实际的副作用代码尽可能精简，而不是将这种逻辑与副作用混合在一起(测试通常很乏味，因为它们需要模仿实际的效果)。所有流行的副作用库都有一个简单的方法来做到这一点；例如，Redux Saga提供了<code class="fe mt mu mv mj b"><a class="ae kz" href="https://redux-saga.js.org/docs/api/#selectselector-args" rel="noopener ugc nofollow" target="_blank">select</a></code> <a class="ae kz" href="https://redux-saga.js.org/docs/api/#selectselector-args" rel="noopener ugc nofollow" target="_blank">效果</a>，这有助于我们简化Saga，如下例所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2b26" class="mn lc it mj b gy mo mp l mq mr">function selectCurrentStep(state) {<br/>  return state.checkout.currentStep;<br/>}</span><span id="25e3" class="mn lc it mj b gy ms mp l mq mr">function selectIsNewUser(state) {<br/>  return state.checkout.isNewUser;<br/>}</span><span id="dcff" class="mn lc it mj b gy ms mp l mq mr">function selectNextStep(state) {<br/>  switch (selectCurrentStep(state)) {<br/>    case 'shoppingCart':<br/>      return 'login';<br/>    case 'login':<br/>      return selectIsNewUser(state) ? 'address' : 'summary';<br/>   // ...<br/>  }<br/>}</span><span id="6143" class="mn lc it mj b gy ms mp l mq mr">function* nextStepSaga() {<br/>  const nextStep = yield select(selectNextStep);<br/>  yield call(navigateToStep, nextStep);<br/>}</span></pre><p id="02aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这使得独立于传奇测试大多数逻辑变得容易，为此我们只需要检查由<code class="fe mt mu mv mj b">select</code>返回的值是否被正确地转发到<code class="fe mt mu mv mj b">navigateToStep</code>效果:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2321" class="mn lc it mj b gy mo mp l mq mr">test('nextStepSaga()', () =&gt; {<br/>  const generator = nextStepSaga();<br/>  let effect;</span><span id="b557" class="mn lc it mj b gy ms mp l mq mr">  // Run until `yield select()`<br/>  effect = generator.next();<br/>  expect(effect).toEqual(select(selectNextStep));</span><span id="4955" class="mn lc it mj b gy ms mp l mq mr">  // Continue as if the selector returned 'login'<br/>  effect = generator.next('login');<br/>  expect(effect).toEqual(call(navigateToStep, 'login'));<br/>});</span></pre><h1 id="012d" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">选择器的限制</h1><p id="9e20" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">虽然Redux选择器可以做很多事情，但是它们不能做所有的事情。</p><p id="e2c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，选择器只能访问Redux存储中的状态，因此它们的能力受到Redux中保存了多少应用程序状态的限制。对于只对少量状态使用Redux的应用程序来说，它们就没那么有用了，例如，因为大多数数据都是使用一个<a class="ae kz" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>库获取和管理的。缓解这个问题的一种方法是向选择器添加额外的参数，允许传递非冗余状态，但这降低了一致性(使选择器组合更加困难)并使记忆更加困难。另一种方法是编写<em class="la">选择器工厂</em>，它获取所有必需的非冗余数据并返回一个选择器作为结果:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9da8" class="mn lc it mj b gy mo mp l mq mr">function makeSelectTask(taskId) {<br/>  return (state) =&gt; state.tasks[taskId];<br/>}</span><span id="bc9f" class="mn lc it mj b gy ms mp l mq mr">function TaskItem({ taskId }) {<br/>  const selectTask = useMemo(<br/>    () =&gt; makeSelectTask(taskId),<br/>    [taskId]<br/>  );<br/>  const task = useSelector(selectTask);<br/>  return &lt;li&gt;{task.title}&lt;/li&gt;;<br/>}</span></pre><p id="8fc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其次，选择器是纯同步的，所以不能咨询后端API等外部资源。对于需要这样做的情况，像sagas这样的Redux副作用抽象是更好的选择。即使这样，您仍然可以选择将逻辑的纯部分提取到选择器中，就像我们之前看到的那样。</p><p id="e4f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，使用选择器，我们只能表达“静态”逻辑，它只依赖于当前的应用程序状态。对于基于<em class="la">事件</em> — <a class="ae kz" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank">状态机</a>的“动态”逻辑，例如— Redux提供<a class="ae kz" href="https://redux.js.org/basics/reducers/" rel="noopener ugc nofollow" target="_blank">减速器</a>。</p><h1 id="10de" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4b97" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">将Redux选择器视为“小领域专家”，通过咨询应用程序的状态来回答应用程序的问题，可以发现它们不仅仅可以隐藏状态的形状或缓存值。我们可以使用它们来过滤和聚集数据、验证用户输入、针对副作用做出控制流决策，以及许多其他类型的应用程序逻辑。因为选择器在调用方式上是纯粹和统一的，所以它们使得应用程序逻辑易于推理、组合、重用和测试。</p><p id="87f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="la">本帖原载</em> <a class="ae kz" href="https://www.denisw.de/posts/redux-selectors-logic/" rel="noopener ugc nofollow" target="_blank"> <em class="la">于我的个人博客</em> </a> <em class="la">。</em></p><h1 id="7ae8" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">资源</h1><ul class=""><li id="e1ba" class="mw mx it kd b ke lz ki ma km my kq mz ku na ky nb nc nd ne bi translated"><a class="ae kz" href="https://redux.js.org/recipes/computing-derived-data" rel="noopener ugc nofollow" target="_blank">“计算派生数据”(Redux docs) </a></li><li id="6674" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated"><a class="ae kz" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a></li></ul></div></div>    
</body>
</html>