<html>
<head>
<title>Angular Interview Question: Dependency Injection for Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度面试问题:服务的依赖注入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-interview-question-dependency-injection-3da676906ef9?source=collection_archive---------6-----------------------#2020-03-10">https://levelup.gitconnected.com/angular-interview-question-dependency-injection-3da676906ef9?source=collection_archive---------6-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/80393a9635fcb9c67204a231aa638d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSOsuc2LwCnZBK3_dU2Xpw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@daoud_absml?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">达乌德·阿比斯梅尔</a>在<a class="ae kf" href="https://unsplash.com/s/photos/technical-interview?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d1cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">角度组件只是用户界面，仅此而已。它们显示数据并支持用户交互，对用户点击和输入做出反应。应用程序逻辑应该在服务中完成。当您需要一个组件中的服务时，您通常不会使用<code class="fe le lf lg lh b">new</code>自己创建一个实例。您将服务标记为<code class="fe le lf lg lh b">injectable</code> <em class="li"> </em>和<em class="li"> </em>您将它作为参数添加到组件的构造函数中。角度依赖注入(DI)将负责创建一个实例，并为您注入它。</p><p id="3d77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般不会过多考虑这个过程。当您创建一个从服务器获取数据的服务时，您只需要它的一个实例，它在哪里并不重要。但是有时您需要服务只能在一个模块中可用，甚至是一个组件及其子组件。您可能需要在不同的组件中注入不同的服务实例。这就是为什么对Angular DI如何工作的良好理解对于Angular开发者来说是一个重要的素质。</p><h1 id="f84f" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">注射器</h1><p id="be31" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">注入器负责创建服务类的实例，并将它们注入到请求它们的组件中。服务是注入器范围内的单例，一个服务最多只能有一个实例。</p><p id="9ac9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">喷射器由角度创建。在引导过程中创建了一个<em class="li">根</em>注入器。Angular还将为组件、管道或指令创建注入器，但是它们保持为空，除非您在它们的decorators中声明一个<em class="li"> providers </em>数组。每个延迟加载的模块也有自己的注入器。</p><p id="e62a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注射器是遗传的。当你在一个组件中请求一个服务时，Angular会在组件的注入器中查找，然后在它的父组件的注入器中查找，然后在它的父组件的父组件的注入器中查找，等等，直到它找到它或者用完祖先。如果它没有在元素注入器中找到它，Angular开始在模块注入器中寻找，直到它找到一个提供者(或者耗尽注入器)。</p><h1 id="9804" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">提供者</h1><p id="d020" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">注入器创建实例并注入它们，但是您需要告诉它们<strong class="ki iu">如何</strong>创建这些实例。当您在组件中注入服务时，您给最近的注入器一个<em class="li"> DI令牌</em>。默认情况下，令牌是服务类，在下面的示例中是TestService。注入器有一个地图<em class="li">令牌提供者</em>，令牌就是密钥。服务的提供者通常是类本身:</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e253" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，服务只在TestComponent中提供，我们告诉Angular在注入TestService时使用TestService类来创建一个实例。这是一种非常常见的行为，Angular为您提供了一种快捷方式:</p><pre class="mm mn mo mp gt ms lh mt mu aw mv bi"><span id="3c3b" class="mw lk it lh b gy mx my l mz na">providers: [TestService]</span></pre><p id="9b7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也意味着我们可以告诉注入器在注入TestService时使用其他类。在下面的例子中，当请求TestService时，我们告诉注入器返回HelloWorldService的一个实例。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8d4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果将是:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f63fb7bdeb84adc619ac63666e1f9fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*H61iml5ZGmOmjPjUF0KkIg.png"/></div></figure><h1 id="1bd2" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">注射器等级</h1><h2 id="34f8" class="mw lk it bd ll nc nd dn lp ne nf dp lt kr ng nh lx kv ni nj mb kz nk nl mf nm bi translated">根部注射器</h2><p id="293c" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">您可能不会定期在组件中提供服务。默认情况下，当您使用Angular cli创建服务时，服务是在<em class="li">根</em>注入器中提供的。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="a6f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们不需要在组件的注入器中提供服务。服务的实例将在<em class="li">根</em>注入器中创建，并注入到我们的组件中。该实例在应用程序中随处可见。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5a37aa2ade99fa06fc94045ee9db6376.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*3rdXC4T-Vbl13QgsRuq87g.png"/></div></figure><p id="988e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不需要在其他地方提供服务，但是我们可以。</p><h2 id="b6d2" class="mw lk it bd ll nc nd dn lp ne nf dp lt kr ng nh lx kv ni nj mb kz nk nl mf nm bi translated">元素喷射器</h2><p id="6b11" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">尽管服务可以由根注入器注入，但这并不是必须的。我们可以决定为这个组件(及其子组件)创建一个服务实例。为此，我们需要像前面一样定义一个提供者。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="abc4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在TestComponent中提供了服务TestService。为组件创建了一个注入器，当服务被注入时，它将创建TestService的一个实例。</p><p id="6a31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在AppComponent中，我们也注入了服务。我们没有在这个组件中声明任何提供者，所以实例将由<em class="li">根</em>注入器创建和注入。因此，我们在应用程序中有两个服务实例。在示例中，我们创建了一个静态变量来存储实例的数量:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi no"><img src="../Images/12fc71288bbd5c2e3775002ee88094e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*GyZxuIIhIW7ZpXqaw7HlZw.png"/></div></figure><p id="87b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注射器层次结构的一个结果是，如果您在父组件中提供服务，那么相同的实例将在每个子组件中使用。</p><figure class="mm mn mo mp gt ju"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="350d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我们将再次看到:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f63fb7bdeb84adc619ac63666e1f9fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*H61iml5ZGmOmjPjUF0KkIg.png"/></div></figure><p id="4414" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一件需要注意的重要事情是，服务实例的寿命并不比创建它们的注入器长。这意味着，如果您在一个组件中提供服务，该组件正在使用的服务实例将随该组件一起消亡。当数据需要持久化时，您可能需要考虑这一点。</p><h2 id="1ecf" class="mw lk it bd ll nc nd dn lp ne nf dp lt kr ng nh lx kv ni nj mb kz nk nl mf nm bi translated">模块注射器</h2><p id="4574" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">应用程序通常被组织在不同的模块中。由于默认情况下服务是在<em class="li">根</em>注入器中提供的，因此可以从应用程序中的任何地方访问它们，甚至是在其他模块中。例如，如果您在模块1中定义了一个在<em class="li">根</em>中提供的服务TestService，那么您可以在模块2中使用这个服务。因为服务是由<em class="li">根</em>注入器注入的，所以只有一个实例。</p><p id="6f93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您在模块Module1中而不是在<em class="li">根</em>中提供服务，那么该服务在模块2中仍然可用。这可能令人惊讶，但是如果Module1是预先加载的，它将被导入到AppModule中。模块注入器展平了所有导入的提供者，因此TestService将在AppModule中提供。</p><p id="ae0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果Module1是延迟加载的，则它不会被导入到AppModule中。在模块中提供服务将使它只在内部可用。</p><p id="27c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果只在Module1中的组件中提供服务，那么该服务将只在组件的注入器中提供，既不在Module1中，也不在<em class="li">根</em>中。在最后两种情况下，试图在Module2的组件中注入服务将导致<em class="li"> No provider </em>错误:</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/588e355c33c8e2f97e3835d3d55d6857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5T-t0F3ZAD-gK23x8mxUQ.png"/></div></div></figure><p id="8872" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您必须显式地提供服务，无论是在模块2中，还是在您试图注入它的组件中，或者直接在<em class="li">根</em>注入器中。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="805a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Angular DI通常允许您保留少量的服务实例，而不必过多关注它。在大多数情况下，你不必担心。但是，当您使用许多模块(延迟加载的模块)时，或者当您需要组件中服务的不同实例时，有必要更深入地理解这种机制。</p><p id="0552" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Angular为更大的灵活性提供了更多的工具。您可能需要检查修饰符(@Optional、@SkipSelf、@Self。…)了解更多信息。</p><p id="cf32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们只讨论了服务案例。DI能做的不止这些。例如，您可以提供值而不是类。您还可以创建自己的DI令牌，并使用@Inject注释手动注入元素。关于这些或者依赖注入的更多细节，我建议您阅读Angular文档。</p></div></div>    
</body>
</html>