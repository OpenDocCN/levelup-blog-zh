<html>
<head>
<title>How to Add Internationalization (Translations) in Angular — Backend Integration and Lazy-loaded Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Angular中添加国际化(翻译)——后端集成和延迟加载模块</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-add-internationalization-translations-in-angular-backend-integration-and-lazy-loaded-bd394262727?source=collection_archive---------2-----------------------#2022-10-16">https://levelup.gitconnected.com/how-to-add-internationalization-translations-in-angular-backend-integration-and-lazy-loaded-bd394262727?source=collection_archive---------2-----------------------#2022-10-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从实践教程中了解翻译服务的更多高级设置</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5992c87f162e63568c751079f4801b2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-aLaPlaRZn_ov1Kj.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://pixabay.com/illustrations/globe-world-languages-translate-110775/" rel="noopener ugc nofollow" target="_blank">图片由杰勒特拍摄于Pixabay </a></figcaption></figure><p id="452c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/geekculture/how-to-add-internationalization-translations-in-angular-basics-d9fed161d572" rel="noopener">之前的一篇文章</a>中，我们介绍了如何建立<em class="lv"> ngx-translate </em>库并在一个简单的Angular项目中使用它的基础知识。翻译是从静态JSON文件中获得的。然而，在生产中，翻译通常需要从数据库中动态获取。此外，为了获得更好的性能，在更大的项目中会有延迟加载的模块，需要为它们单独设置翻译服务。在本帖中，我们将通过实践教程介绍这两个使用翻译服务的高级主题。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="2c4e" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">设置一个模拟REST API服务器</h2><p id="5118" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">由于这是一个前端教程，这里就不搭建后端服务器了。相反，我们将使用前端开发中常用的模拟服务器。它让我们不依赖于后端开发，尤其是在web开发实践的早期阶段。</p><p id="9346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用<a class="ae ky" href="https://github.com/typicode/json-server#add-custom-routes" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> json-server </em> </a>库来启动一个模拟REST API服务器，它可以通过以下方式安装:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="7989" class="md me it nc b gy ng nh l ni nj">$ npm install --save-dev json-server</span></pre><p id="9235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将<code class="fe nk nl nm nc b">assets/i18n/en.json</code>和<code class="fe nk nl nm nc b">asses/i18n/sv.json</code>合并到一个公共的JSON文件<code class="fe nk nl nm nc b">translations.json</code>中，该文件将被放入新的<code class="fe nk nl nm nc b">assets/mock-data</code>文件夹中。请注意，语言代码是顶级键，相应的翻译是值。正如我们将在后面看到的，顶级键将充当模拟服务器的路由。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">assets/mock-data/translations . JSON</figcaption></figure><p id="4084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以启动JSON服务器来模拟REST API请求:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="c150" class="md me it nc b gy ng nh l ni nj">$ npx json-server --watch src/assets/mock-data/translations.json</span></pre><p id="b305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以转到<a class="ae ky" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>来发出API请求。注意，JSON文件的顶层键是默认路由。因此，您可以在<a class="ae ky" href="http://localhost:3000/en" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/en</a>获得英文翻译，在<a class="ae ky" href="http://localhost:3000/sv." rel="noopener ugc nofollow" target="_blank">http://localhost:3000/SV</a>获得瑞典语翻译。</p><p id="01e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加一些自定义路线，使它们看起来更类似于我们在实际项目中看到的路线。自定义路线也在JSON文件中定义，以<em class="lv">期望的</em>路线为关键字，以<em class="lv">现有的</em>路线为值。规则是从上到下评估的，因此您可以在稍后定义的规则中引用以前的自定义路线。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">assets/mock-data/routes . JSON</figcaption></figure><p id="587e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，JSON服务器使用特殊指示符“<code class="fe nk nl nm nc b">$1</code>”来指定根路径“/”之后的任何内容。在这种情况下，可以通过在实际路线前添加<code class="fe nk nl nm nc b">/api/translations</code>来访问<code class="fe nk nl nm nc b">translations.json</code>中定义的所有现有路线。我们还添加了一个规则来传递语言代码作为查询参数，而不是路径参数。</p><p id="59cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个定义，我们可以有以下有效的路由:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7661" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用自定义路由启动JSON服务器:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5d72" class="md me it nc b gy ng nh l ni nj">$ npx json-server --watch src/assets/mock-data/translations.json \<br/>                  --routes src/assets/mock-data/routes.json</span></pre><p id="1121" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在浏览器中打开<a class="ae ky" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>并设置上面演示的路线进行试验。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="b294" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">从服务器获取翻译</h2><p id="d45b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">现在让我们更新我们的Angular项目，从这个假的REST API服务器获取翻译。</p><p id="5357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要在<code class="fe nk nl nm nc b">environment.ts</code>中添加API主机，使其在存储库中的任何地方都可以访问:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">环境. ts</figcaption></figure><p id="8c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们需要创建自己的加载器来从外部API服务器加载翻译。定制加载器需要实现<code class="fe nk nl nm nc b">TranslateLoader</code>接口，该接口有一个返回<code class="fe nk nl nm nc b">Observable</code>的必需方法<code class="fe nk nl nm nc b">getTranslation()</code>。我们将把自定义加载器类放在一个新文件<code class="fe nk nl nm nc b">translate-loader.ts</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">translate-loader.ts</figcaption></figure><p id="6ce5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要更新<code class="fe nk nl nm nc b">app.module.ts</code>来使用这个定制的加载器。我们现在不需要创建一个神奇的工厂函数，可以直接使用自定义的loader类。但是，注意必须提供对<code class="fe nk nl nm nc b">HttpClient</code>的依赖，否则，它将无法正常工作，因为我们需要在自定义加载器中注入<code class="fe nk nl nm nc b">HttpClient</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序模块</figcaption></figure><p id="1739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当您使用<code class="fe nk nl nm nc b">ng serve</code>启动服务器并转到<a class="ae ky" href="http://localhost:4200," rel="noopener ugc nofollow" target="_blank"> http://localhost:4200，</a>时，您应该会看到与<a class="ae ky" href="https://lynn-kwong.medium.com/how-to-add-internationalization-translations-in-angular-basics-d9fed161d572" rel="noopener">上一篇文章</a>中所示相同的效果，其中的翻译是从本地JSON文件中获取的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/f050258793aa9a6baedbea8885df5783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/1*E0tWxBK_lpn0E0nR4APk3g.gif"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="8074" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">向根模块添加路由</h2><p id="7d3e" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我们需要有一个路由模块，然后才能创建一个惰性加载模块，我们将演示如何配置<code class="fe nk nl nm nc b">TranslateModule</code>。我们需要为一个延迟加载的模块显式地单独配置<code class="fe nk nl nm nc b">TranslateModule</code>，否则，翻译服务将无法在其中使用。</p><p id="0879" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们在设置应用程序时没有指定<code class="fe nk nl nm nc b">--routing</code>选项，所以我们需要手动创建根路由模块文件<code class="fe nk nl nm nc b">app-routing.module.ts</code>。</p><p id="c703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在根文件夹中创建<code class="fe nk nl nm nc b">app-routing.module.ts</code>,并添加以下内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="34cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它现在没有路由，但是稍后创建延迟加载模块时会有一些新内容。如果你迷路了，你可以查看<a class="ae ky" href="https://github.com/lynnkwong/angular-translations-advanced" rel="noopener ugc nofollow" target="_blank">这个GitHub Repo </a>中这篇文章中创建或更新的所有文件。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="2c09" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">创建一个延迟加载的模块</h2><p id="f422" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">现在让我们用这个命令创建一个延迟加载的模块:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="1ba0" class="md me it nc b gy ng nh l ni nj">$ ng generate module lazy --route lazy --module app.module</span></pre><p id="d136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根路由模块<code class="fe nk nl nm nc b">app-routing.module.ts</code>将自动更新如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">app-routing.module.ts</figcaption></figure><p id="5769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们还需要将<code class="fe nk nl nm nc b">router-outlet</code>添加到<code class="fe nk nl nm nc b">app.component.html</code>中，以便可以访问懒惰模块的新路线。</p><p id="9927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">lazy组件和模板有如下简单的内容，它显示了选择哪种语言并相应地使用翻译:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">lazy.component.ts</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">lazy.component.html</figcaption></figure><p id="28e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不在<code class="fe nk nl nm nc b">lazy.module.ts</code>中添加<code class="fe nk nl nm nc b">TranslateModule</code>，你的应用会中断，你会看到<code class="fe nk nl nm nc b">error NG8004: No pipe found with name 'translate'</code>，这意味着翻译服务在lazy模块中不可用。让我们把它放在那里。更新<code class="fe nk nl nm nc b">lazy.module.ts</code>如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">lazy.module.ts</figcaption></figure><p id="8c4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，使用<code class="fe nk nl nm nc b">extend: true</code>，懒惰加载模块将从父模块扩展翻译，并且还将使用来自其父模块的翻译。</p><p id="5d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您转到<a class="ae ky" href="http://localhost:4200/lazy," rel="noopener ugc nofollow" target="_blank"> http://localhost:4200/lazy，</a>您将看到根组件和lazy组件都工作正常:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/e21d53f801edc3bee30eb618077ac0ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/1*vb0KOA9OpS6qWKsI99JStg.gif"/></div></div></figure><p id="efe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">懒加载的模块还有一些更高级的设置，比如使用不同的自定义加载器或者隔离服务，这些在我看来很少使用。如有需要，您可以查看此处的<a class="ae ky" href="https://github.com/ngx-translate/core#lazy-loaded-modules" rel="noopener ugc nofollow" target="_blank">了解详情。</a></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="801e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们介绍了使用翻译服务的两个高级主题，即从后端服务器获取翻译和为延迟加载的模块设置翻译服务。加上<a class="ae ky" href="https://lynn-kwong.medium.com/how-to-add-internationalization-translations-in-angular-basics-d9fed161d572" rel="noopener">之前的基础教程</a>，你现在应该可以在你的项目中自由使用翻译服务了。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="9511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相关文章:</p><ul class=""><li id="1955" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated"><a class="ae ky" href="https://lynn-kwong.medium.com/how-to-add-internationalization-translations-in-angular-basics-d9fed161d572" rel="noopener">如何在Angular-Basics中添加国际化(翻译)</a></li></ul></div></div>    
</body>
</html>