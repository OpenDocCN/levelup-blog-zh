<html>
<head>
<title>HTTP, WebSocket, gRPC or WebRTC: Which Communication Protocol is Best For Your App?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP、WebSocket、gRPC或WebRTC:哪种通信协议最适合你的App？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/http-websocket-grpc-or-webrtc-which-communication-protocol-is-best-for-your-app-1cc5a0786c86?source=collection_archive---------9-----------------------#2022-09-27">https://levelup.gitconnected.com/http-websocket-grpc-or-webrtc-which-communication-protocol-is-best-for-your-app-1cc5a0786c86?source=collection_archive---------9-----------------------#2022-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7de9826a4037763cf49d43baca906a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WSwPCqrLABJey-SrKKdyKQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">HTTP vs WebSocket vs gRPC vs WebRTC:应该使用哪种通信协议</figcaption></figure><p id="6834" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为应用选择通信协议时，有许多不同的选项。在本帖中，我们将看看四种流行的解决方案:<strong class="ke ir"> HTTP </strong>、<strong class="ke ir"> WebSocket </strong>、<strong class="ke ir"> gRPC </strong>和<strong class="ke ir"> WebRTC </strong>。我们将通过研究每种协议背后的技术、它的最佳用途以及它的优缺点来探究每种协议</p><p id="e5b2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的交流方式在不断改进:变得更快、更方便、更可靠。我们的交流已经从使用信鸽发送信息发展到邮政邮件，到座机的发明，再到通过一个可以放在我们口袋里的小设备发送电子邮件和短信。</p><p id="b897" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">未来我们甚至可能会把会议和生日聚会过渡到VR上(希望这只是个玩笑！).但是最好的交流方式总是取决于具体情况。</p><p id="efe5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一条简短的短信有时比一封长邮件更好。其他时候，与团队进行视频通话是交流信息的最佳方式。相比之下，重要的保险文件必须通过普通邮件发送，并交付硬拷贝。</p><p id="c9f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们使用的网络技术和协议也是如此。不同的应用程序有不同的通信需求。</p><h1 id="8299" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">概观</h1><p id="fb04" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在本文中，我们将介绍一些开发人员可以使用的流行的<strong class="ke ir">通信协议</strong>，并探讨不同选项的优缺点。没有一个解决方案比另一个更好，只有一些解决方案更适合特定的应用或问题。</p><p id="4ec3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一些应用程序需要一个<a class="ae md" href="https://getstream.io/blog/peer-to-peer-video-conferencing/" rel="noopener ugc nofollow" target="_blank">点对点</a>连接，具有低延迟和高数据传输，并且可以接受一些数据包(信息)丢失。其他应用程序可以根据需要轮询服务器，而不需要接收来自不同对等方的通信。其他应用要求实时通信和数据可靠性。</p><p id="5cc3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在线多人游戏、消息应用程序、博客网站、媒体画廊应用程序和<a class="ae md" href="https://getstream.io/blog/best-video-calling-apis/" rel="noopener ugc nofollow" target="_blank">视频会议软件</a>都有不同级别的通信和数据需求。</p><p id="0a8c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您正在构建一个视频流解决方案，那么还有其他考虑因素，请参见我们关于<a class="ae md" href="https://getstream.io/blog/streaming-protocols/" rel="noopener ugc nofollow" target="_blank">视频流协议</a>的文章，了解关于选择正确协议的更多信息。</p><h1 id="9ccd" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是通信协议？</h1><p id="bd1f" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在计算机网络中，协议是控制设备之间如何交换数据的一组规则。该协议定义了通信的规则、语法、语义和同步以及可能的错误恢复方法。</p><p id="b85f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本文中讨论的协议定义了应用层软件如何相互交互。不同的协议遵循不同的规则，了解每种协议的优势和局限性是非常重要的。在本文中，您将了解以下协议:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9a588e2adcef09e6ed027aaac9b7798a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XvHR-CE9uL6-uE5M3VP4Tg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">通信协议时间线</figcaption></figure><p id="1d02" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">HTTP(超文本传输协议)是一种用于分布式、协作式和超媒体信息系统的应用协议。HTTP是万维网数据通信的基础。超文本是在包含文本的节点之间使用逻辑链接(超链接)的结构化文本。HTTP是交换或传输超文本的协议。</p><p id="2643" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> HTTP/2 </strong>旨在解决原始HTTP协议的缺点并提高性能。HTTP/2比HTTP/1.1更快更有效，它支持多路复用，允许多个请求和响应在单个连接上进行<a class="ae md" href="https://en.wikipedia.org/wiki/Multiplexing" rel="noopener ugc nofollow" target="_blank">多路复用</a>。其他值得注意的功能包括头压缩和服务器推送。它逐渐成为网络流量的默认协议。</p><p id="5bc1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">WebSocket是一种允许客户端和服务器之间双向通信的协议。这是处理实时数据的应用程序的流行选择，如聊天应用程序、<a class="ae md" href="https://getstream.io/blog/womens-online-gaming-community/" rel="noopener ugc nofollow" target="_blank">在线游戏</a>和<a class="ae md" href="https://getstream.io/blog/how-to-live-stream/" rel="noopener ugc nofollow" target="_blank">实时数据流</a>。</p><p id="0a75" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">gRPC是一个现代的开源RPC框架，使用HTTP/2进行传输。对于需要进行大量小型快速API调用的应用程序来说，这是一个很好的选择。gRPC为许多语言生成跨平台的客户机和服务器绑定，使得客户机应用程序可以直接调用不同机器上的服务器应用程序上的方法，就像它是一个本地对象一样。</p><p id="3ed1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> WebRTC </strong>是一种允许客户端之间进行实时通信的技术，可以建立直接的点对点连接。它用于视频、聊天、文件共享和实时视频流应用。</p><h1 id="e430" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">了解TCP和UDP</h1><p id="3d54" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在深入研究上面提到的<a class="ae md" href="https://en.wikipedia.org/wiki/Application_layer" rel="noopener ugc nofollow" target="_blank">应用层</a>之前，有必要对TCP和UDP有一个基本的了解，这两个底层<a class="ae md" href="https://en.wikipedia.org/wiki/Transport_layer" rel="noopener ugc nofollow" target="_blank">传输层</a>以完全不同的方式促进数据传输。</p><p id="e8b9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> TCP(传输控制协议)</strong>是定义如何通过互联网建立和维持网络会话的标准。TCP是互联网和任何面向连接的网络中最常用的协议。当您浏览web时，您的计算机将TCP数据包发送到web服务器。web服务器通过将TCP数据包发送回您的计算机来做出响应。在交换任何数据之前，首先在两个设备之间建立连接，TCP使用纠错来确保所有数据包都被成功传送。如果数据包丢失或损坏，TCP会尝试重新发送。</p><p id="00a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> UDP(用户数据报协议)</strong>是一种无连接、不可靠的传输层协议。它不需要建立或维护连接，也不保证消息会按顺序传递。这意味着如果一个包没有被发送或者被损坏，可能会有一些数据丢失。UDP通常用于流媒体或实时应用程序，在这些应用程序中，丢包比确保传输更容易。</p><h1 id="2c3a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">HTTP/1</h1><p id="814c" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">重要的是要对所有基于互联网的通信和应用层数据传输的基础有一个基本的了解——HTTP(超文本传输协议)<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/HTTP" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b6db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">理解HTTP/1及其局限性也很重要，在此之前，我们可以更详细地研究其他协议，并充分理解它们所提供的功能。</p><p id="9157" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用HTTP，客户端和服务器通过交换单独的消息进行通信。客户端发送的消息称为请求，服务器发送的消息称为响应。这些消息通过TCP连接作为常规文本消息发送。它们也可以使用<a class="ae md" href="https://www.cloudflare.com/en-gb/learning/ssl/transport-layer-security-tls/" rel="noopener ugc nofollow" target="_blank"> TLS </a>加密，并使用HTTPS协议发送。</p><p id="cf6b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">客户端通常是运行在用户手机或电脑上的网页浏览器或应用程序，但从技术上讲，它也可以是任何东西，例如，一个抓取网站的脚本。</p><p id="4385" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">HTTP请求只能单向流动，从客户端到服务器。服务器无法启动与客户端的通信；它只能响应请求。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/300b65f2eaf4aa3a2720a4f66e709fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYs1hoze6ZvGXfptHVv7cQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">HTTP —请求/响应示例</figcaption></figure><p id="f5ec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">HTTP非常适合传统的web和客户端应用程序，在这些应用程序中，信息是根据需要获取的。例如，您刷新一个页面，然后请求服务器获取最新的信息。</p><p id="1d27" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，这个协议以一种出乎意料的方式扩展了。在下面几节中，我们将探索HTTP/1的一些限制。</p><h1 id="8015" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">HTTP/1实时</h1><p id="33ba" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">当消息需要从客户机实时发送到服务器时，HTTP/1效率很低，反之亦然。例如，如果服务器上有需要与客户端共享的新信息，则只有当客户端发起请求时，该事务才会发生。</p><p id="769c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有解决这个问题的方法，使用称为HTTP短期和长期轮询的技术，以及服务器发送的事件。</p><h2 id="96ac" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">短期投票</h2><p id="210a" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">HTTP短轮询是一种技术，在这种技术中，客户机反复向服务器发送请求，直到它用新数据作出响应。一旦接收到数据，它就再次开始这个过程，并反复询问，直到有其他可用的数据。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/448355cb71f5848d2ae24b93d5b11e59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0U1BjjPOJxVtzO-ZTCSiA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">HTTP短轮询示例</figcaption></figure><p id="06a0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一种低效的实时通信策略，因为它通过连续传输和解析HTTP请求/响应来浪费大量资源。</p><h2 id="6db0" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">长轮询</h2><p id="8c50" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">使用HTTP长轮询，客户端发出一个请求，然后服务器保持连接打开，直到有新的数据可用并可以发送响应。客户端收到响应后，会立即再次建立新的连接。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1ff0195a08d8a7a06ae79218207e3195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMJ1Vr5IRa3RPvfEBRC2RA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">HTTP长轮询示例</figcaption></figure><p id="ddd8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">长轮询比短轮询更有效，但不是实时通信的最佳解决方案。</p><h2 id="b040" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">服务器发送的事件(SSE)</h2><p id="a0ef" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated"><a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events" rel="noopener ugc nofollow" target="_blank">服务器发送的事件</a>允许客户端保持连接打开并实时接收来自服务器的更新(推送消息),而无需不断轮询服务器以获取新数据。这是一个单向连接，所以您不能从客户端向服务器发送事件。</p><p id="fe91" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">SSE是一种标准，描述一旦建立了初始客户端连接，服务器如何向客户端发起数据传输。</p><h1 id="5699" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">HTTP/1的性能问题</h1><blockquote class="mv mw mx"><p id="fbb7" class="kc kd my ke b kf kg kh ki kj kk kl km mz ko kp kq na ks kt ku nb kw kx ky kz ij bi translated"><em class="iq">大多数HTTP数据流由小的、突发的数据传输组成，而TCP针对长期连接和批量数据传输进行了优化。在大多数情况下，网络往返时间是TCP吞吐量和性能的限制因素。因此，延迟是性能瓶颈，大多数web应用程序都克服了这个瓶颈。</em></p></blockquote><p id="2588" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上面的意思是，HTTP使用的TCP是为了处理长期连接和传输大量数据而构建的。另一方面，HTTP/1会打开一堆短命的TCP连接，通常只发送小块数据。</p><h2 id="8a47" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">行首阻塞</h2><p id="448e" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">HTTP/1.0的一个性能问题是您必须为每个请求/响应打开一个新的TCP连接。这对于最初发明HTTP的目的来说不是问题——获取超文本文档。文档部分很重要，因为HTTP不是为“超媒体”设计的。</p><p id="06d8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随着web的发展，为每个请求打开一个新的TCP连接成了一个问题。我们开始构建完整的应用程序，而不是简单的网页，浏览器需要检索的媒体和文件变得越来越多。假设一个典型的web应用程序需要一个HTML、CSS和JavaScript文件，以及各种图像和其他资产。对于每个文件，必须建立一个新的连接。</p><p id="c51b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随之而来的是HTTP/1.1，它具有持久连接，这定义了我们可以在同一个TCP连接上有多个请求或响应。</p><p id="ae53" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种解决方案无疑是一种改进，但是它不允许服务器同时响应多个响应。这是一个序列化的协议，您必须发送一个请求并等待响应，然后发送第二个请求，依此类推。这就是所谓的<a class="ae md" href="https://en.wikipedia.org/wiki/Head-of-line_blocking" rel="noopener ugc nofollow" target="_blank">线头阻塞</a>。</p><p id="e61f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，实现一些并行是可能的，因为浏览器可以打开多达六个到同一来源的TCP连接——其中“来源”被定义为<strong class="ke ir">主机</strong>和<strong class="ke ir">端口号</strong>的唯一组合。</p><p id="2543" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，如果您有一个需要加载12幅图像的照片库应用程序，那么将发出六个请求来加载前六幅图像，每个请求将打开一个新的TCP连接。其他六个图像将被阻塞，直到收到响应，其中一个打开的连接可用于加载下一个图像。到同一来源的最初六个打开的TCP连接在变得可用时将被重用，但是您被限制为六个活动连接。</p><p id="e56d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">自然地，程序员找到了一个简单的解决方法——改变原点。不是在同一个原点上托管所有资源，而是在一个原点上托管六个图像，而在另一个原点上托管其余的图像。现在，您可以同时拥有12个请求(或打开TCP连接)。这被称为“分片”。</p><ul class=""><li id="efba" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">图像<strong class="ke ir">1–6</strong>托管在<code class="fe nl nm nn no b">1.images.com</code>上</li><li id="c70e" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">图像<strong class="ke ir">7–12</strong>托管在<code class="fe nl nm nn no b">2.images.com</code>上</li></ul><p id="c444" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，您可以这样做的次数是有限制的，并且很难确定最佳的碎片数量。在某种程度上，添加更多的碎片会增加复杂性，增加开销，并可能导致链路拥塞和数据包丢失。</p><p id="f7b8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还存在其他问题，因为每个TCP连接都会给服务器增加不必要的开销。连接会相互竞争，每次TCP和TLS握手都会增加不必要的成本，并且必须使用其他服务器/代理资源来维护活动连接。HTTP/1使用底层TCP连接的方式有一个明显的限制。</p><h2 id="2df9" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">标题和Cookies膨胀</h2><p id="335c" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">另一个问题是，随着HTTP规范的发展，规范中增加了更多的报头。开发人员还可以选择将cookiess添加到标题中，这些cookie可以任意大。这增加了很多麻烦，因为每个请求和响应都需要传输所有这些文本信息，而且HTTP/1.1不包括压缩头和元数据的机制。</p><p id="3af3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您需要高性能的RPC协议，这种开销会迅速增加，HTTP不再是最佳解决方案。</p><h2 id="f595" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">优化</h2><p id="fcfc" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在HTTP/1.1中，浏览器通过在客户机上保持一个优先级队列并对如何最好地利用可用的TCP连接进行有根据的猜测来“区分”资源的优先级。浏览器嵌入了判断哪些资源比其他资源更有价值的启发式方法。</p><p id="d3f8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，加载CSS将比加载图像具有更高的优先级。</p><p id="572d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">问题是，作为开发人员，您没有办法区分一个请求的优先级，或者改变正在进行的消息的优先级。首先加载什么内容是由浏览器决定的，并且您对优先级方案没有发言权。</p><h1 id="5cf3" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">HTTP/2</h1><p id="14ad" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated"><a class="ae md" href="https://web.dev/performance-http2/" rel="noopener ugc nofollow" target="_blank"> HTTP/2 </a>是HTTP协议的改进版本，解决了HTTP/1的所有性能问题，并在不改变任何语义(动词、标题等)的情况下增加了其他增强功能。</p><p id="f7f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">HTTP/2中最显著的变化是使用多路复用通过一个<strong class="ke ir">单一TCP连接</strong>同时发送和接收多个HTTP请求和响应。所有HTTP/2连接都是持久的，每个源只需要一个连接。这样可以更有效地利用网络资源，并显著提高应用程序的性能。</p><p id="4aa8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">HTTP/2的一些其他好处:</p><ul class=""><li id="1ecc" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">使用标头压缩来减小标头的大小，这样可以避免反复发送相同的纯文本标头。这大大减少了请求/响应的开销和发送的数据量。</li><li id="0f96" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">启用优先级，允许客户端(开发人员)指定其所需资源的优先级。还可以更新正在进行的请求的优先级——例如，在滚动时，如果图像不再可见，优先级可以改变。</li><li id="9d34" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">在客户端请求数据之前，使用服务器推送向客户端发送数据。这可以通过消除客户端发出多个请求的需要来缩短加载时间。</li></ul><h1 id="5451" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">HTTP/2是如何工作的？</h1><p id="1810" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">HTTP/2中的基本协议单元是一个<strong class="ke ir">帧</strong>。这种新的二进制成帧机制改变了客户机和服务器之间的数据交换方式。</p><p id="04f8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该标准定义了十种不同的帧类型，每一种都有不同的用途。例如，报头和数据帧构成了HTTP请求和响应的基础:</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/13607f6dbfdb158de59de635eb76871b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2AowiserA6JgCmcssUMs9A.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">HTTP/1.1与HTTP/2消息</figcaption></figure><p id="7c6d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个<strong class="ke ir">帧</strong>是携带特定类型数据的最小通信单位。</p><p id="1243" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">其他一些框架示例包括:</p><ul class=""><li id="e578" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">设置:在连接开始时或连接过程中交换设置信息。</li><li id="09b1" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">优先级:重新分配消息的优先级。</li><li id="31ed" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">PUSH_PROMISE:允许服务器向您推送数据——这相当于对服务器将发送的内容的承诺。例如，如果您请求<code class="fe nl nm nn no b">index.html</code>，服务器可以创建一个PUSH_PROMISE，承诺推送<code class="fe nl nm nn no b">app.js</code>和<code class="fe nl nm nn no b">styles.css</code>，这意味着客户端不需要请求这些资源。</li></ul><p id="109a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">帧组合成一个<strong class="ke ir">消息</strong>，例如上图中的报头和数据帧。这等同于正常的请求或响应。</p><p id="27f6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，一系列<strong class="ke ir">消息</strong>可以是<strong class="ke ir">流</strong>的一部分。这允许客户机和服务器之间的双向数据流以及完全的请求和响应多路复用。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f55f66da89f6a4969c9be0e0459c2940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9FSn-EaYHUQ4rHnZgEAHiQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">HTTP/2多个流</figcaption></figure><p id="0b39" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上图有点误导，给人的印象是客户端和服务器之间有多个连接打开。但这是一个单一的TCP连接，数据以非阻塞的方式在客户机和服务器之间自由流动。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b70df85e06911243b1f3d52696bbbb84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czUGEd7pUUUCRpt8vf4zAw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">HTTP/2多路复用流</figcaption></figure><p id="9908" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">新的二进制成帧层允许客户机和服务器将HTTP消息分解成独立的帧，交织它们，然后在另一端重新组合它们。</p><p id="94f0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这只是对HTTP/2.0工作原理的总结。如果您想了解更多并探索优先级、服务器推送和头压缩，请参见<a class="ae md" href="https://web.dev/performance-http2/" rel="noopener ugc nofollow" target="_blank">深度文章</a>中的内容。要了解HTTP/1问题的历史以及HTTP/2如何解决这些问题，请观看这个<a class="ae md" href="https://www.youtube.com/watch?v=ouIK1S0KdJE" rel="noopener ugc nofollow" target="_blank">视频</a>。</p><h1 id="c0dd" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">HTTP/2双向数据流</h1><p id="8800" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">来自<a class="ae md" href="https://datatracker.ietf.org/doc/html/rfc7540#section-5" rel="noopener ugc nofollow" target="_blank"> HTTP/2规范</a>:</p><blockquote class="mv mw mx"><p id="b1d8" class="kc kd my ke b kf kg kh ki kj kk kl km mz ko kp kq na ks kt ku nb kw kx ky kz ij bi translated"><em class="iq">“流”是在HTTP/2连接中在客户端和服务器之间交换的独立的双向帧序列。溪流有几个重要的特征:</em></p><p id="ba19" class="kc kd my ke b kf kg kh ki kj kk kl km mz ko kp kq na ks kt ku nb kw kx ky kz ij bi translated">-单个HTTP/2连接可以包含多个并发打开的流，任一端点可以从多个流中交错帧。</p><p id="808c" class="kc kd my ke b kf kg kh ki kj kk kl km mz ko kp kq na ks kt ku nb kw kx ky kz ij bi translated">-流可以单方面建立和使用，也可以由客户端或服务器共享。</p><p id="cf8f" class="kc kd my ke b kf kg kh ki kj kk kl km mz ko kp kq na ks kt ku nb kw kx ky kz ij bi translated">-流可以由任一端点关闭。</p></blockquote><p id="46da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关于<a class="ae md" href="https://en.wikipedia.org/wiki/HTTP/2_Server_Push" rel="noopener ugc nofollow" target="_blank">服务器推送</a>功能有很多误解，它允许服务器通过HTTP/2主动发送它认为你可能需要的资源，例如<code class="fe nl nm nn no b">.js</code>和<code class="fe nl nm nn no b">.css</code>文件，而无需客户端请求。这与双向流无关，只是一种针对可缓存资源的web优化技术。</p><p id="2073" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">真实的情况是，使用HTTP/2，服务器无法启动<strong class="ke ir">流</strong>。但是一旦客户端通过发送请求打开了一个流，双方都可以在任何时候通过持久套接字发送数据帧。gRPC就是一个很好的例子，我们将在后面讨论。</p><p id="fbec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有了HTTP/2，就有可能实现双向数据流，你可以<a class="ae md" href="https://stackoverflow.com/questions/28582935/does-http-2-make-websockets-obsolete" rel="noopener ugc nofollow" target="_blank">认为</a>它是比WebSockets更好的解决方案，或者你可以认为它不是。我们将在WebSocket部分对此进行更详细的讨论。</p><h1 id="54df" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">WebSockets</h1><p id="e07e" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">来自<a class="ae md" href="https://www.rfc-editor.org/rfc/rfc6455" rel="noopener ugc nofollow" target="_blank"> WebSocket协议规范</a>:</p><blockquote class="mv mw mx"><p id="2ca8" class="kc kd my ke b kf kg kh ki kj kk kl km mz ko kp kq na ks kt ku nb kw kx ky kz ij bi translated"><em class="iq">该技术的目标是为基于浏览器的应用程序提供一种机制，该应用程序需要与不依赖于打开多个HTTP连接的服务器进行双向通信(例如，使用XMLHttpRequest或iframes和长轮询)。</em></p></blockquote><p id="b02a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">发明WebSockets是为了实现客户端和服务器之间的全双工通信，这允许数据通过一个开放的连接立即双向传输。</p><p id="c542" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦建立了WebSocket连接，客户端就不需要向服务器轮询更新。相反，交流是双向的。与HTTP/1最初的长轮询和短轮询相比，这提高了速度和实时能力。WebSocket没有符合的格式。您可以发送任何数据、文本或字节——这种灵活性是WebSockets流行的原因之一。</p><p id="7184" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于我们在HTTP/2一节中讨论的内容，其中一些可能听起来很熟悉，但重要的是要注意，WebSockets早在HTTP/2之前就被发明了。稍后我们将对它们进行更多的比较。</p><h1 id="afc9" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">WebSockets如何工作</h1><p id="6de9" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">WebSockets有效地作为TCP上的传输层运行。</p><p id="c8a0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要建立WebSocket连接，客户端和服务器首先需要通过正常的HTTP/1.1连接执行握手。这种握手是从HTTP到WebSockets的桥梁。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7db37f4b1f9b9bfbe215611ebdb89678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kf_Nupj8i4iQt8Yu5mijJw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">WebSocket升级请求</figcaption></figure><p id="5d11" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是一个客户端握手请求的例子。客户端可以使用称为升级头的HTTP/1.1机制将它们的连接从HTTP切换到WebSockets:</p><pre class="me mf mg mh gt nu no nv nw aw nx bi"><span id="9a98" class="mj lb iq no b gy ny nz l oa ob">GET /chat HTTP/1.1<br/>Host: example.com:8000<br/>Upgrade: websocket<br/>Connection: Upgrade<br/>Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==<br/>Sec-WebSocket-Version: 13</span></pre><p id="39cb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，服务器将通过一个特殊的响应来结束握手，该响应指示协议将从HTTP更改为WebSocket:</p><pre class="me mf mg mh gt nu no nv nw aw nx bi"><span id="a9f7" class="mj lb iq no b gy ny nz l oa ob">HTTP/1.1 101 Switching Protocols<br/>Upgrade: websocket<br/>Connection: Upgrade<br/>Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span></pre><p id="8391" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">WebSockets需要一个具有<code class="fe nl nm nn no b">ws://</code>或<code class="fe nl nm nn no b">wss://</code>方案的统一资源标识符(URI)。<code class="fe nl nm nn no b">ws://</code>方案用于未加密的连接，<code class="fe nl nm nn no b">wss://</code>方案用于加密的连接，类似于HTTP URLs如何使用<code class="fe nl nm nn no b">http://</code>或<code class="fe nl nm nn no b">https://</code>方案。</p><p id="eeef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦建立了双向通信通道，客户端和服务器就可以来回发送消息。这些消息可以是从二进制数据到文本的任何内容。WebSocket连接将保持打开状态，直到客户端或服务器断开连接。</p><h1 id="b405" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">WebSocket多路复用</h1><p id="a576" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在撰写本文时，WebSocket协议不支持内置多路复用。我们在HTTP/2一节中讨论了多路复用，我们了解到这是HTTP/2的一个内置特性，在同一个连接上多路复用多个流是可能的。每个流都有一个唯一的标识符，所有发送的帧都有一个与相应流相关联的ID。</p><p id="b283" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">不支持多路复用意味着WebSocket协议要求每个WebSocket连接都有一个新的传输连接。例如，在同一浏览器的不同选项卡中运行的多个客户端将导致单独的连接。要在WebSockets上实现多路复用，通常需要开发人员来实现，或者依赖第三方插件或库。</p><h1 id="b30a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">WebSocket vs HTTP/2</h1><p id="9093" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">那么，HTTP/2已经取代WebSockets了吗？简短的回答是否定的。更长的回答是HTTP/2使双向流成为可能，因此，WebSockets不是唯一/最好的选择。与WebSockets相比，HTTP/2作为一个规范为您做了更多的工作。它有内置的多路复用，在大多数情况下，会导致到源的开放TCP连接减少。另一方面，WebSockets提供了很大的自由度，一旦建立了连接，就不会限制客户机和服务器之间如何发送数据。然而，您将需要自己管理重新连接(或者依靠库为您做这件事)。</p><p id="3d55" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">哪一个最终更好，哪一个会起作用，哪一个不会，这是有待讨论的问题，本文并没有提供一个固执己见的答案。WebSockets提供了很大的灵活性，并且作为一个已建立的标准，它完全受所有现代浏览器的支持，围绕客户端和服务器库的生态系统是健壮的。</p><p id="1abb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有关更详细、更有见解的讨论，请参见以下堆栈溢出问题:</p><ul class=""><li id="be71" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated"><a class="ae md" href="https://stackoverflow.com/questions/28582935/does-http-2-make-websockets-obsolete" rel="noopener ugc nofollow" target="_blank">HTTP/2会让WebSocket过时吗</a></li><li id="7d03" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated"><a class="ae md" href="https://stackoverflow.com/questions/50956757/http-2-or-websockets-for-low-latency-client-to-server-messages/59690386#59690386" rel="noopener ugc nofollow" target="_blank">用于低延迟客户端到服务器消息的HTTP/2或Websockets】</a></li><li id="fb96" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated"><a class="ae md" href="https://stackoverflow.com/questions/59867473/http-2-vs-web-sockets-for-bidirectional-message-streaming" rel="noopener ugc nofollow" target="_blank">用于双向消息流的HTTP/2 vs web-sockets</a></li></ul><p id="41c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还有一个<a class="ae md" href="https://www.rfc-editor.org/rfc/rfc8441" rel="noopener ugc nofollow" target="_blank"> RFC </a>允许在HTTP/2连接的单个流上运行WebSocket协议的机制。</p><blockquote class="mv mw mx"><p id="d894" class="kc kd my ke b kf kg kh ki kj kk kl km mz ko kp kq na ks kt ku nb kw kx ky kz ij bi translated">能够从HTTP/2引导WebSockets允许两个协议共享一个TCP连接，并将HTTP/2对网络的更有效使用扩展到WebSockets。</p></blockquote><p id="765d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这已经在<a class="ae md" href="https://chromestatus.com/feature/6251293127475200" rel="noopener ugc nofollow" target="_blank"> Chrome </a>和<a class="ae md" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1434137" rel="noopener ugc nofollow" target="_blank"> Firefox </a>中实现。你可以在这里阅读Chrome的设计文档和动机<a class="ae md" href="https://docs.google.com/document/d/1ZxaHz4j2BDMa1aI5CQHMjtFI3UxGT459pjYv4To9rFY/edit" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="a4bb" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么时候应该使用WebSockets？</h1><p id="a548" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">Websockets最适合需要实时双向通信的应用程序，以及需要快速传输小块数据的应用程序，例如:</p><ul class=""><li id="08a8" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">聊天应用程序</li><li id="5926" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">多人游戏</li><li id="932f" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">协作编辑应用程序</li><li id="d0ae" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">直播体育节目</li><li id="59ca" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">股票交易申请</li><li id="3600" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">实时活动订阅源</li></ul><p id="faab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">巧合的是，这是我们团队有丰富经验的领域。我们广泛使用WebSockets为我们的<a class="ae md" href="https://getstream.io/chat/" rel="noopener ugc nofollow" target="_blank">聊天</a>和<a class="ae md" href="https://getstream.io/activity-feeds/" rel="noopener ugc nofollow" target="_blank">活动提要</a>基础设施提供动力。</p><p id="363f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对WebSockets的支持很好，长期以来一直得到各大浏览器和客户端的支持，而且也是有据可查，易于使用。但是，不应过度使用WebSockets取决于你想要什么，可能有更好的选择。</p><p id="0d29" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#event_stream_format" rel="noopener ugc nofollow" target="_blank">服务器发送事件(SSE) </a>比HTTP/2效率高，使用简单。SSE不是双向通信系统；服务器单方将数据推送到客户端。但是，如果您需要的只是一种让服务器向客户机发送数据的方法，这可能是比增加WebSockets开销更好的选择。当HTTP/2不可用时，SSE也回退到HTTP/1.1。此外，客户端(或浏览器)为您管理连接，并支持自动重新连接。</p><p id="de83" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果WebSockets上的连接丢失，则没有包含负载平衡或重新连接的机制。这必须手动实现或由第三方库实现。</p><h1 id="0a06" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">gRPC</h1><blockquote class="mv mw mx"><p id="33b3" class="kc kd my ke b kf kg kh ki kj kk kl km mz ko kp kq na ks kt ku nb kw kx ky kz ij bi translated"><a class="ae md" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> gRPC </em> </a> <em class="iq">是一个现代开源的高性能远程过程调用(RPC)框架，可以在任何环境下运行。它可以通过对负载平衡、跟踪、运行状况检查和身份验证的可插拔支持，高效地连接数据中心内和跨数据中心的服务。它也适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。</em></p></blockquote><p id="b249" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">gRPC是一个开源的、基于合同的RPC系统，最初由Google开发。gRPC使应用程序能够透明地通信，并简化连接系统的构建。</p><p id="779a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它为许多语言生成跨平台的客户端和服务器绑定，使客户端应用程序能够直接调用不同机器上的服务器应用程序上的方法，就像它是本地对象一样。</p><p id="3a7d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">gRPC构建于HTTP/2之上，利用了双向流和内置传输层安全性(TLS)等特性。</p><h1 id="121d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">gRPC动机</h1><p id="84f7" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">深入了解gRPC背后的动机以及为什么要发明它来理解它的好处是很重要的。为什么不使用我们已经拥有的现有技术:例如HTTP/2和WebSockets？为什么我们需要在现有的基础上再增加一个抽象层呢？</p><p id="1c16" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有多种方式可以在互联网上构建和发送数据。一些流行的例子是SOAP、REST和GraphQL。如果愿意，您甚至可以创建自己的协议，通过原始TCP发送数据，并自己处理实现。</p><p id="ec76" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是无论您选择什么作为您的通信协议，问题是您需要确保客户端和服务器在协议上达成一致。例如，如果您正在构建一个REST API，那么您需要用来发送REST数据的客户端库就是HTTP库。默认情况下，HTTP库内置于浏览器中，浏览器会为您处理一切:</p><ul class=""><li id="53ea" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">它与服务器建立通信。</li><li id="e205" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">它处理HTTP/2并回退到HTTP/1。并且将来需要支持HTTP/3。</li><li id="bbbe" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">它处理TLS并协商协议。</li><li id="4427" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">它处理头、流和其他所有东西。</li></ul><p id="bf98" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是如果你不在浏览器上呢？如果你是一个运行在某个服务器上的Python应用程序，一个GoLang CLI，或者一个运行在iOS上的Flutter应用程序呢？所有这些客户端都需要自己的HTTP库，该库理解您正在与之通信的协议。</p><p id="522b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">幸运的是，许多专注的人正在为所有这些语言和框架开发各种HTTP库。有些语言甚至有多个不同特性的HTTP库。然而，所有这些都是有代价的，那就是维护。</p><p id="9beb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如，如果您使用的GoLang库支持HTTP/2，那么这个成本可能会影响您将服务器升级到HTTP/2。但是，在您的前端Python客户机上，对等的HTTP库还没有实现HTTP/2，或者可能不再被维护。其他语言的不同HTTP库不能1:1比较。</p><p id="43aa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随着HTTP规范的发展，这些库必须跟上技术进步、安全问题、新特性和其他补丁。HTTP只是一个例子，对于WebSocket协议或任何其他协议也是如此。有些东西可能在主流浏览器中实现得很好，但是这些功能必须移植到多种不同的语言和框架中。</p><h2 id="d7be" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">gRPC有什么不同？</h2><p id="4138" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">gRPC试图通过维护<a class="ae md" href="https://grpc.io/docs/languages/" rel="noopener ugc nofollow" target="_blank">流行语言</a>本身的库来解决这个问题，这意味着所有这些语言都将支持添加的新特性。</p><p id="ab7d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在幕后，gRPC使用HTTP/2作为它的协议，但是，这个实现对您是隐藏的。将来，gRPC的维护者可以很容易地用HTTP/3替换HTTP/2，您将立即从这一变化中受益。</p><p id="2416" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">gRPC还使用协议缓冲区作为接口定义语言(IDL)及其底层的消息交换格式。这种格式是语言中立的，使得不同编程语言之间的交流变得容易。我们将在下一节更深入地探讨这个概念。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/e80d097f111aed5aa1fd9e3c279dc3d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qPRkv_5tm5F6xsqlDIcWvw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">gRPC服务器/客户端通信</figcaption></figure><h1 id="75c2" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是协议缓冲区？</h1><blockquote class="mv mw mx"><p id="66d4" class="kc kd my ke b kf kg kh ki kj kk kl km mz ko kp kq na ks kt ku nb kw kx ky kz ij bi translated"><em class="iq">协议缓冲区是Google的语言中立、平台中立、可扩展的机制，用于序列化结构化数据——想想XML，但是更小、更快、更简单。您只需定义一次数据的结构化方式。然后，您可以使用特殊生成的源代码，使用各种语言轻松地将结构化数据写入各种数据流，并从这些数据流中读取结构化数据。</em></p></blockquote><p id="0d6e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">传统上，对于API，您没有由协议本身定义的契约。例如，如果您正在使用REST，那么您通常只是发送带有键/值对的JSON消息，直到消息到达接收端才进行检查。该消息通常可以是任何内容，由您来确保定义了正确的结构。</p><p id="5f68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">看看下面的JSON有效负载:</p><pre class="me mf mg mh gt nu no nv nw aw nx bi"><span id="5294" class="mj lb iq no b gy ny nz l oa ob">'id': 123,<br/>'name': 'Gordon',<br/>'email': 'gordon@somewhere.io'</span></pre><p id="09f5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦在客户机/服务器上接收到该数据，就可以将其反序列化为一个对象，例如:</p><pre class="me mf mg mh gt nu no nv nw aw nx bi"><span id="4c47" class="mj lb iq no b gy ny nz l oa ob">class Person { <br/>    int id;<br/>    String name;<br/>    String email<br/>}</span></pre><p id="4151" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，作为开发人员，实现上述有效负载的正确序列化和反序列化逻辑取决于您——这可能涉及手动编写<code class="fe nl nm nn no b">toJson</code>和<code class="fe nl nm nn no b">fromJson</code>方法，依赖于代码生成，或者它可能是您正在使用的语言的内置特性。</p><p id="73d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">无论您如何序列化这些数据，在模式发生变化的情况下，潜在地在多个环境中，底层代码都需要手动更新。</p><p id="5018" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用协议缓冲区，您可以创建一个模式来定义字段的对象类型，并指定哪些是必需的，哪些是可选的:</p><pre class="me mf mg mh gt nu no nv nw aw nx bi"><span id="1bd1" class="mj lb iq no b gy ny nz l oa ob">// The request message containing the person’s information<br/>Message Person {<br/>    optional int32 id = 1;<br/>    required string name = 2;<br/>    optional string email = 3;<br/>}<br/><br/>// The response message containing the greetings<br/>message HelloReply {<br/>  string message = 1;<br/>}</span></pre><p id="e1a0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，您可以指定要公开的过程。</p><pre class="me mf mg mh gt nu no nv nw aw nx bi"><span id="3484" class="mj lb iq no b gy ny nz l oa ob">// The greeting service definition.<br/>service Greeter {<br/>  // Sends a greeting<br/>  rpc SayHello (Person) returns (HelloReply) {}<br/>}</span></pre><p id="988e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦指定了数据结构和模式，就可以使用协议缓冲编译器<code class="fe nl nm nn no b">protoc</code>从原型定义中以您喜欢的语言生成数据访问类。</p><p id="0336" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些将是描述proto文件中概述的对象的接口，带有每个字段的访问器，以及将整个结构序列化/解析为原始字节的方法。</p><h1 id="c10c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">gRPC模式</h1><p id="91e3" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">gRPC上有四种运输方式。这四种模式复制了我们之前讨论的行为，例如，普通的请求/响应、SSE和WebSockets。</p><h2 id="4ac0" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">一元RPC</h2><p id="8cc9" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">一元RPC是一个简单的请求和响应，类似于调用函数。客户端请求一些数据，服务器进行一些处理并返回这些数据。</p><h2 id="4392" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">服务器流RPC</h2><p id="4208" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">服务器流RPC，其中客户端向服务器发送单个请求，并期望多个或一个响应流。客户端从返回的流中读取，直到不再有消息。</p><p id="3f95" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">视频流就是一个例子，你请求加载一个视频，服务器用视频流来响应。</p><h2 id="632f" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">客户端流RPC</h2><p id="97a2" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">客户端流RPC，其中客户端编写一系列消息并将其发送到服务器，同样使用提供的流。一旦客户端写完消息，它就等待服务器读取消息并返回响应。</p><p id="b71d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个例子是将一个大文件上传到服务器，一旦所有的数据都被发送，客户端可以发送一个最终消息来表明上传完成，服务器可以选择响应。</p><h2 id="48ba" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">双向流RPC</h2><p id="49b4" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">客户端和服务器流的组合。聊天应用程序或多人视频游戏就是一个例子，其中数据需要在客户机和服务器之间自由流动。</p><blockquote class="mv mw mx"><p id="6b5e" class="kc kd my ke b kf kg kh ki kj kk kl km mz ko kp kq na ks kt ku nb kw kx ky kz ij bi translated"><em class="iq">双向流RPC，其中双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照他们喜欢的任何顺序进行读写。</em></p></blockquote><p id="33e9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在双向流RPC中，调用由调用方法的客户端发起。客户端和服务器端的流处理是特定于应用的。因为这两个流是独立的，所以客户端和服务器可以以任何顺序读取和写入消息。</p><h1 id="8aba" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">微服务</h1><p id="ed1a" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">gRPC强大之处的一个很好的例子是在微服务领域。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/bb1c2fcee224f0924372678af3c15c6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKfaNzvipKVcs0LT80RSIA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">gRPC微服务通信</figcaption></figure><p id="3013" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个例子中，我们有用Python、Java和GoLang编写的微服务。这些需要在它们之间发送数据。</p><p id="291c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用HTTP/1.1和JSON将需要您为每种语言实现HTTP连接和序列化。您还需要确保针对每种语言正确实现模式，如果API发生变化，所有服务都需要手动更新。</p><p id="a3c0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一方面，gRPC为我们处理HTTP/2.0协议的实现。只需编写一个模式，就可以为所有使用的语言生成相应的代码。这种模式可以被视为所有语言都需要遵守的契约，使得这些服务之间的通信更加容易和可靠。</p><h1 id="6b65" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">gRPC性能</h1><p id="0ff5" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">gRPC速度更快，并且通常比REST等效物的性能高得多:</p><ul class=""><li id="5ef6" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">协议缓冲区被序列化，并通过线路作为<strong class="ke ir">二进制文件发送，这比普通的JSON消息要小得多。</strong></li><li id="ab6a" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">gRPC使用HTTP/2.0来提供进一步的改进</li></ul><p id="0f5f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">gRPC有效压缩发送的数据具有显著的优势，因为传输的数据负载越小，所需的TCP往返次数就越少。<a class="ae md" href="https://www.cloudflare.com/en-gb/learning/network-layer/what-is-mtu/" rel="noopener ugc nofollow" target="_blank">最大传输单位(MTU) </a>是一个度量单位，代表联网设备可以接受的最大数据包，为1500字节。</p><p id="49bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">压缩是为您处理的，您只需使用gRPC即可受益。作为替代，在通过常规HTTP发送之前，可以使用类似GZIP的东西来压缩JSON消息。然而，这可能是不方便的，并且增加了复杂性。不同的语言和环境对GZIP和其他等效压缩工具的支持程度也可能不同。对于您使用的每种语言，您都需要自己重新实现正确的压缩和通信逻辑。这是一个类似于我们讨论的HTTP库的问题。</p><h1 id="5325" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么时候应该使用gRPC？</h1><p id="53da" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">如果您正在使用多种不同的编程语言，这些语言需要彼此紧密集成，并且需要快速和频繁的通信来发送大量数据，那么gRPC将是完美的选择。</p><p id="274d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">优点:</p><ul class=""><li id="4981" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">借助gRPC流，可以轻松确定上传/下载进度，而无需发出任何不必要的更新请求。</li><li id="7179" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">可以取消请求。</li><li id="b37d" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">HTTP/2的所有好处。</li><li id="dc57" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">如果gRPC支持你的语言，你就不用担心外部库了。</li></ul><p id="18cf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">缺点:</p><ul class=""><li id="0233" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">gRPC不支持所有语言。</li><li id="14db" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">该模式可能会让人觉得有限制性和繁琐。</li><li id="1267" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">与WebSockets相比，它的设置可能比较复杂。</li><li id="36fa" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">仍然年轻，错误可能难以调试。</li><li id="36bb" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">与gRPC的通信不能在web浏览器中开箱即用。你需要使用<a class="ae md" href="https://github.com/grpc/grpc-web" rel="noopener ugc nofollow" target="_blank"> gRPC-Web库</a>。</li></ul><h1 id="36fb" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">WebRTC</h1><p id="74a6" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated"><a class="ae md" href="https://webrtc.org/" rel="noopener ugc nofollow" target="_blank"> WebRTC </a>是一个免费的开源项目，为基于开放标准的应用程序提供实时通信(RTC)功能。它支持对等体之间发送的视频、语音和通用数据。</p><p id="1325" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这项技术可以作为一组适用于所有主流浏览器的JavaScript APIs和一个适用于Android和iOS应用程序等本地客户端的库来使用。</p><p id="39b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">WebRTC与WebSockets和gRPC有一个根本的区别，那就是一旦建立了连接，数据就可以(在某些情况下)直接在浏览器和设备之间实时传输，而无需接触服务器。</p><p id="4409" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这减少了延迟，并使WebRTC非常适合音频、视频或屏幕共享——在这种情况下，低延迟非常重要，并且需要发送大量数据。</p><h1 id="7982" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">WebRTC动机</h1><p id="0a77" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">WebRTC旨在标准化媒体(如音频和视频)在网络上的通信方式，并通过一个简单易用的API方便地实现这一点。</p><p id="1f87" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">其他解决方案，如WebSockets，确实使得在两个对等体之间传输任何数据成为可能；但是，这些数据需要通过代理或服务器传输。依赖另一台服务器会增加延迟，因为通过它发送的所有内容都需要被查看、处理和解密。两个贵族之间有一个中间人。对于视频流甚至实时聊天，这种延迟是不可取的。</p><p id="62ef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在的浏览器也比几年前更强大了。浏览器可以访问网络摄像头和麦克风，这需要一个内置的API和一种简单的方式来传输这些丰富的信息。WebRTC旨在简化整个过程，并提供一个易于使用的浏览器自带的API。</p><h2 id="9008" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">WebRTC的问题是</h2><p id="17de" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">动机是明确的，看起来WebRTC是一个神奇的解决方案，允许两个对等体之间更快的通信。但不幸的是有几个问题。</p><p id="5737" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">第一个问题是建立点对点连接并不简单——互联网很复杂，在加利福尼亚的Alice和南非的Ben之间有大量的路由器、代理和防火墙。并且在某些情况下，在两个对等体之间不可能有直接的线路。两个对等体之间的连接可能需要绕过阻止开放连接的防火墙，您可能没有公共IP地址，或者路由器可能不允许对等体之间的直接连接。</p><p id="fa3c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">第二个问题是，需要有一种方法让两个对等体发现彼此，并确定可以进行通信的最佳路由。这需要在两个客户端之间共享某些信息，然后它们才能知道如何最好地相互通信——共享这些信息的常见方式是使用WebSockets。</p><p id="df8f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这有点好笑。一个<strong class="ke ir"> HTTP </strong>连接升级为一个<strong class="ke ir"> WebSocket </strong>连接，只是为了共享信息建立一个<strong class="ke ir"> WebRTC </strong>连接。</p><p id="0592" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您真的想了解WebRTC的功能及其复杂性，您将需要熟悉一些可能不熟悉的术语:NAT、STUN、TURN、ICE、SDP和信令。</p><h1 id="bb5d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">WebRTC是如何工作的？</h1><p id="c178" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在上面的概述中，我们描述了WebRTC的动机，它描述了它如何工作的基本思想。这一节将深入一些您需要理解的底层主题，以便完全掌握WebRTC。</p><h2 id="3f5f" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">网络地址转换(NAT)</h2><p id="655c" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">理解什么是NAT以及它是如何工作的，对于理解WebRTC是必不可少的。</p><p id="5daf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">NAT用于为您的设备(笔记本电脑或手机)提供一个公共IP地址；这很重要，因为我们希望在两个可能都位于路由器后面的对等体之间建立连接。路由器有一个公共IP地址，连接到路由器的每台设备都有一个私有IP地址。</p><p id="646f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些设备不会直接暴露在互联网上。相反，所有流量都通过路由器，路由器与外界通信。当您从远程服务器请求资源时，路由器负责将请求从您的本地机器“路由”到该服务器，并将响应从服务器路由回您的本地机器。</p><p id="4ba9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些请求从设备的私有IP地址转换为路由器的公共IP地址，并带有唯一的端口，然后存储在NAT表中。这样，本地网络中的每台设备就没有必要拥有唯一的公共IP。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/d9c86b805bf9d9cb40f4de75b6acf1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSFv7t9AL9HdCmyCZu2DRQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">NAT表示例</figcaption></figure><p id="57b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上图是一个简单的NAT表的例子。假设本地设备的私有IP为<strong class="ke ir"> 192.168.1.50 </strong>，它向公共地址<strong class="ke ir">82.88.31.26:80</strong>请求一些数据。</p><p id="4fb0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是通过本地设备首先向路由器发送请求来实现的，路由器将请求路由到远程设备。然后，路由器告诉远程设备使用唯一的端口将响应发送到其外部IP地址，在本例中是<strong class="ke ir">86.88.71.25:8830</strong>。</p><p id="945a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个唯一的端口非常重要，因为它允许路由器确定是哪个本地设备发出的请求。所有这些信息都存储在NAT表中。一旦路由器收到响应，它就可以执行查找并决定将响应转发到哪个本地设备。</p><p id="60e7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我们有一个普通的请求/响应对——一个设备和一个服务器时，这很容易理解。但是，如果另一台具有完全不同IP地址的外部设备决定在之前使用的同一端口上向路由器的外部IP地址发送数据包，会发生什么情况呢？路由器是否应该将其转发到映射到该端口号的本地设备？</p><p id="57de" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该决定取决于路由器使用的NAT转换，并最终决定是否可以建立对等连接。根据您使用的路由器，它将实现不同的NAT转换。有四种不同的NAT转换方法:</p><ul class=""><li id="ef3e" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">一对一NAT</li><li id="38ca" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">地址受限NAT</li><li id="ba04" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">端口受限NAT</li><li id="dbba" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">对称NAT</li></ul><p id="22fb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">一对一NAT </strong>:将一个外部IP地址和端口(通常是公有的)映射到一个内部IP地址和端口(通常是私有的)。在上面的例子中，如果路由器在端口<strong class="ke ir"> 8830 </strong>和外部IP<strong class="ke ir">86.88.71.25</strong>上收到响应，它会将其转发到本地设备<strong class="ke ir"> 192.168.1.50 </strong>，因为这是发出请求的本地设备(从NAT表中检索的信息)。路由器不关心目的IP或响应的来源。如果它在一个特定的外部端口上，它就会转到那个本地设备。</p><p id="47c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">地址受限NAT </strong>:只有本地设备之前已经向远程IP地址发送了数据包，远程设备才能向本地设备发送数据包。综上所述，我们只允许在之前与该主机进行过沟通的情况下使用。在上面的例子中，只允许来自86.88.71.25的数据包。</p><p id="55a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">端口受限NAT </strong>:同地址受限NAT，但限制也包括端口号。如果内部设备之前已经向IP地址X和端口p发送了数据包，则远程设备只能向内部设备发送数据包。在上述示例中，仅允许来自<strong class="ke ir">86.88.71.25</strong>和端口<strong class="ke ir"> 80 </strong>的数据包。</p><p id="fcd3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">对称NAT </strong>:限制性最强。为此，<strong class="ke ir">外部IP </strong>、<strong class="ke ir">外部端口</strong>、<strong class="ke ir">目的IP </strong>和<strong class="ke ir">目的端口</strong>都必须与NAT表中的内容相匹配。这意味着，如果本地设备是请求目的IP和端口的设备，则数据包只能发送到该设备的特定端口。</p><p id="1ae1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">WebRTC不能在对称NAT上工作，为了理解为什么我们需要理解什么是STUN服务器。</p><h2 id="237f" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">NAT的会话遍历实用程序(STUN)</h2><p id="7073" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">STUN是一种协议，它通过NAT告诉您您的公共IP地址/端口，并确定您的路由器中会阻止与对等方直接连接的任何限制。STUN服务器是一种机制，让客户端发现NAT的存在以及NAT的类型，并确定NAT的外部IP地址和端口映射。</p><p id="6ed3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">STUN请求的目的是确定您的公共存在，以便该公共存在可以与其他人进行交流，以便他们可以与您联系—这种交流被称为信号，我们将在稍后进行更多讨论。</p><p id="6378" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">适用于<strong class="ke ir">一对一</strong>、<strong class="ke ir">地址受限</strong>、<strong class="ke ir">端口受限NAT </strong>。但是对于<strong class="ke ir">对称NAT </strong>无效。因为当您向STUN服务器请求您的公共信息时，这个通信对是专门为发出请求的客户机创建的。使用对称NAT不可能涉及另一个对等体——本地设备端口上的通信仅限于STUN服务器。</p><p id="f9d7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">STUN服务器是轻量级的，维护起来也很便宜。有公共的STUN服务器可以免费查询。</p><p id="6e5c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下图说明了STUN何时工作以及何时可以建立对等连接。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6800dab994ae331f347ca5e77d49e2d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T1UHWNbtEv56Cfx31DYeow.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">眩晕服务器:当它工作的时候</figcaption></figure><p id="4c6e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一方面，如果无法建立对等连接，例如，当对等体位于对称NAT之后时，那么第三步中的最后一个连接将不被允许。因为初始连接是与STUN服务器建立的，没有其他对等体可以使用该连接信息。</p><p id="6d0f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这种无法建立直接连接的情况下，我们需要使用TURN服务器。</p><h2 id="a95c" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">使用中继绕过NAT (TURN)</h2><p id="f54b" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">TURN是一种协议，用于在两个对等体之间无法建立直接连接时中继网络流量。例如，如果一个对等体位于对称NAT之后，则需要一个专用服务器来中继对等体之间的流量。在这种情况下，您将创建一个与TURN服务器的连接，并告诉所有对等方向服务器发送数据包，然后这些数据包将被转发给您。</p><p id="ee52" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这带来了开销，维护和运行TURN服务器的成本会很高。</p><p id="2680" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下图说明了如何使用TURN服务器在两个或多个对等方之间中继消息。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/307cbaa0eeebd1e599d1d4f2f72c2810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o74d0BKrUH5wumVcGU_GxQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">转向服务器示例</figcaption></figure><h2 id="30e5" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">交互式连接建立</h2><p id="f794" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">ICE结合使用STUN和TURN协议，为主机发现彼此的公共IP地址并建立直接连接提供了一种机制。如果无法直接连接，ICE将使用TURN在两台主机之间建立中继连接。</p><p id="5084" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所有这些潜在建立连接的可能方式被称为ICE候选。所有收集到的地址都通过SDP发送到远程对等体，我们将在接下来探讨这一点。WebRTC在每个客户机上使用这些信息来确定连接到另一个对等点的最佳方式。可能是两个对等体都在同一个NAT上，可以建立本地连接，也可能是两个对等体都在对称NAT之后，需要使用TURN服务器进行中继。</p><h2 id="40d1" class="mj lb iq bd lc mk ml dn lg mm mn dp lk kn mo mp lo kr mq mr ls kv ms mt lw mu bi translated">会话描述协议(SDP)</h2><p id="8fe9" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">SDP本质上是一种数据格式，用于描述会话公告、会话邀请和其他形式的会话发起的媒体会话。它是描述连接的多媒体内容的标准，如分辨率、格式、编解码器和加密。</p><p id="70fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">重要的是，它还被用来描述ICE候选人和其他网络选项。当对等体A想要连接到对等体B时，它们需要共享SDP信息来进行连接。如何共享SDP完全取决于——这被称为信令，我们将在接下来探讨。</p><h1 id="ea09" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">信令—建立连接</h1><blockquote class="mv mw mx"><p id="10e8" class="kc kd my ke b kf kg kh ki kj kk kl km mz ko kp kq na ks kt ku nb kw kx ky kz ij bi translated"><em class="iq">信令是在两个设备之间发送控制信息的过程，以确定通信协议、信道、媒体编解码器和格式、数据传输方法以及任何所需的路由信息。关于WebRTC的信令过程，需要知道的最重要的事情是:它没有在规范中定义。</em></p></blockquote><p id="325d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对等连接处理不同计算机上的两个应用程序的连接。连接是通过称为信令的发现和协商过程建立的。</p><p id="94d1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个重要的警告是，WebRTC没有将信令作为规范的一部分内置，因为两个设备不可能直接相互联系，这一点我们在前面已经详细探讨过了。对于使用WebRTC连接的两个对等体，它们需要彼此的SDP数据。</p><p id="c5da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，作为开发人员，您有责任为两个设备建立一种共享这些信息的方式。一个流行的选择是WebSockets，或者信令信息可以通过电子邮件来回发送，或者步行传递，然后手动输入以建立连接。</p><p id="2b1e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦共享了这些信息，您就拥有了两个对等体建立WebRTC连接所需的一切，它可能是直接连接，也可能是通过TURN服务器。</p><h1 id="420d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么时候应该使用WebRTC？</h1><p id="00c0" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">你甚至可能会问:我为什么要用WebRTC？理解起来似乎很复杂，设置起来更复杂。</p><p id="bfde" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">设置起来很复杂，但是有很多好处:</p><ul class=""><li id="b9c1" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">该API易于使用，可以直接在您的浏览器中获得。</li><li id="2b07" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">它具有良好的性能，可以传输高带宽内容，如视频或音频。</li><li id="e935" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">更高级的功能，如屏幕共享和文件共享可以很容易地实现。</li><li id="6f14" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">支持对等连接，减少了延迟。</li><li id="bf21" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">免费开源。</li></ul><p id="62a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">缺点:</p><ul class=""><li id="c016" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">没有内置信号。</li><li id="8e9c" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">你需要维护眩晕和转身服务器。</li><li id="db43" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">对于群组连接(例如群组视频通话)，可能需要一个<a class="ae md" href="https://getstream.io/blog/what-is-a-selective-forwarding-unit-in-webrtc/" rel="noopener ugc nofollow" target="_blank"> SFU </a>。</li><li id="034d" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">设置和理解起来很复杂。</li></ul><h1 id="9bac" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">你应该选择哪个？</h1><p id="e677" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">您选择的协议将取决于您的具体需求。</p><p id="ab8a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> HTTP </strong>:通过HTTP/2，现在可以在客户机和服务器之间进行双向通信。根据您的应用，您可能不需要全双工通信，像SSE这样的东西就足够了。我们在本文中还发现，WebSockets和gRPC依赖于HTTP，而WebRTC需要一些其他的信号通道。在深入研究这些其他协议之前，首先探索一下HTTP是否能解决您的应用程序需求是值得的。</p><p id="03af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> WebSockets </strong>最适合需要双向通信的实时应用，比如聊天应用。它们也相对容易设置和使用。但是，WebSockets的效率不如gRPC或WebRTC，不太适合需要发送大量数据的应用程序。</p><p id="7320" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">gRPC是一个比WebSockets更高效的协议，它更适合需要发送大量数据的应用程序。然而，gRPC的设置和使用比WebSockets更复杂。如果需要进行很多小的API调用，gRPC是一个不错的选择。或者说，当你用各种编程语言实现需要通信的微服务时，那么gRPC的序列化结构化数据和代码生成会为你节省很多时间。同样值得注意的是，你不能轻易地从浏览器使用gRPC。为此，您需要在后端使用一个专门的代理来翻译调用——参见<a class="ae md" href="https://github.com/grpc/grpc-web" rel="noopener ugc nofollow" target="_blank"> grpc-web </a>。</p><p id="38e8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> WebRTC </strong>是浏览器和设备之间低延迟实时通信最高效的协议，非常适合需要发送大量数据的应用。WebRTC还提供了一个易于使用的API，可以直接在浏览器中使用，从而可以轻松地共享您的相机、音频、屏幕或其他文件。然而，WebRTC的设置和使用可能会很复杂，因为它需要您执行信令和维护TURN和STUN服务器。</p><h1 id="bb6c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="ab70" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">未来将会看到更多的协议、变化和进一步的改进。HTTP/3已经发布，还有一个新的通信协议叫做<a class="ae md" href="https://web.dev/webtransport/" rel="noopener ugc nofollow" target="_blank"> WebTransport </a>，有可能取代WebSockets。</p><p id="5422" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们希望这篇文章对你有用，并能帮助你做出明智的决定。如果你想继续讨论，请通过<a class="ae md" href="https://twitter.com/getstream_io" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae md" href="https://www.linkedin.com/company/getstream" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我们。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="50df" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="my">最初发布于</em><a class="ae md" href="https://getstream.io/blog/communication-protocols/" rel="noopener ugc nofollow" target="_blank"><em class="my">https://getstream . io</em></a><em class="my">。</em></p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="c441" class="la lb iq bd lc ld oj lf lg lh ok lj lk ll ol ln lo lp om lr ls lt on lv lw lx bi translated">分级编码</h1><p id="f600" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="20c8" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="0b03" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">📰查看<a class="ae md" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="a46f" class="nc nd iq ke b kf np kj nq kn nr kr ns kv nt kz nh ni nj nk bi translated">🔔关注我们:<a class="ae md" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae md" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae md" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="7d2b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">🚀👉<a class="ae md" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">将像你这样的开发人员安置在顶级初创公司和科技公司</strong> </a></p></div></div>    
</body>
</html>