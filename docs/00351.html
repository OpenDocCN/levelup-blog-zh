<html>
<head>
<title>Code-splitting for libraries—bundling for npm with Rollup 1.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库的代码拆分npm与汇总1.0的捆绑</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/code-splitting-for-libraries-bundling-for-npm-with-rollup-1-0-2522c7437697?source=collection_archive---------0-----------------------#2019-01-21">https://levelup.gitconnected.com/code-splitting-for-libraries-bundling-for-npm-with-rollup-1-0-2522c7437697?source=collection_archive---------0-----------------------#2019-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8a49c8b50d2801d3e30fdde2a3a67582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZ4p60HENosEjyZfQgjsRQ.jpeg"/></div></div></figure><div class=""/><p id="b656" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着最近Rollup的<a class="ae kw" href="https://github.com/rollup/rollup/releases/tag/v1.0.0" rel="noopener ugc nofollow" target="_blank"> 1.0发布</a>，代码分割已经成为臭名昭著的JavaScript模块捆绑器的一个一流特性。在这里，我想说明为什么这不仅是前端的游戏规则改变者，也是图书馆的游戏规则改变者。在本文中，您将了解到:</p><ul class=""><li id="7572" class="kx ky jb ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">如何将库与Rollup捆绑在一起(以及为什么需要这样做)，包括一些最佳实践，但最重要的是</li><li id="5a1d" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">汇总代码分割是如何工作的，何时以及如何对库使用它</li></ul><h1 id="80f5" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">我们的图书馆项目</h1><p id="a7a5" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">对于这个例子，我们将构建一个强大的实用程序集合，将字符串转换为大写和小写，我们希望以名称<code class="fe mo mp mq mr b">fancy-case</code>发布到npm(注意:在撰写本文时，还没有这个名称的库)。</p><blockquote class="ms mt mu"><p id="ccd0" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">将您的源代码写成es模块</p></blockquote><p id="d730" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我强烈推荐使用<a class="ae kw" href="http://exploringjs.com/es6/ch_modules.html" rel="noopener ugc nofollow" target="_blank"> ECMAScript模块</a>来编写一个库:</p><ul class=""><li id="6584" class="kx ky jb ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">现代捆绑器，包括但不限于Rollup本身，在包含您的库时会产生更高效的代码</li><li id="8f91" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">ES模块可以很容易地转换成Node的CommonJS格式。另一方面，将CJS转换成ES模块更加困难，不提供完整的功能奇偶校验，导致代码效率更低。</li></ul><p id="1027" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在下面看到如何使用Rollup将我们的项目转换为CJS。现在，以下是项目文件:</p><figure class="mz na nb nc gt is"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f691" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">遵循良好的编程实践，我们编写包含“只做一件事”的函数的小模块。</p><blockquote class="ms mt mu"><p id="8d8c" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">瞄准小模块</p></blockquote><p id="b5ec" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">小模块不仅让我们一眼就能看出一个模块是什么，而且还会让我们以后的代码拆分构建更加高效，因为Rollup在如何将文件分组为块方面有更多的选择。不可否认，我们在这里有点走极端了。</p><p id="fe75" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们的项目到目前为止包含的内容:</p><ul class=""><li id="a470" class="kx ky jb ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><code class="fe mo mp mq mr b">main.js</code>是主入口模块，它导出了三个实用函数<code class="fe mo mp mq mr b">upper</code>、<code class="fe mo mp mq mr b">lower</code>和<code class="fe mo mp mq mr b">upperFirst</code>，这三个函数代表了我们库的公共API。</li><li id="cadf" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">效用函数本身是在同名的独立模块中定义的。</li><li id="7f50" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">其余模块包含在实用程序函数之间共享的代码。</li></ul></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/7839c3cfb9c6d34b709bf36456f700b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5cDM2smeIZsmt7X_D5BVjw.jpeg"/></div></div></figure><h1 id="59a7" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">不同的分发格式</h1><p id="21f4" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">一旦我们决定通过npm向其他人开放我们的库，我们应该花点时间考虑如何导入它。如今确实有相当多的选择:</p><h2 id="7e64" class="nn lm jb bd ln no np dn lr nq nr dp lv kj ns nt lz kn nu nv md kr nw nx mh ny bi translated">节点的CommonJS模块</h2><p id="74e0" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">这可能是最重要的目标。这允许节点用户和遗留捆绑器通过以下方式将您的库作为<a class="ae kw" href="http://wiki.commonjs.org/wiki/Modules/1.1.1" rel="noopener ugc nofollow" target="_blank"> CommonJS模块</a>导入</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="6f66" class="nn lm jb mr b gy od oe l of og"><strong class="mr jc">const fancyCase = require('fancy-case');</strong><br/>console.log(fancyCase.upper('some Text'));</span></pre><h2 id="36f4" class="nn lm jb bd ln no np dn lr nq nr dp lv kj ns nt lz kn nu nv md kr nw nx mh ny bi translated">要在脚本标记中使用的单个包</h2><p id="460a" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">发布JavaScript的“传统方式”对于那些只需简单设置的手工制作的小网站来说仍然很有意思。这个包创建了一个全局变量，通过这个变量可以访问它的导出。</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="6fa8" class="nn lm jb mr b gy od oe l of og"><strong class="mr jc">&lt;script src="fancy-case.js"&gt;&lt;/script&gt;<br/></strong>&lt;script&gt;<br/>    console.log(fancyCase.upper('some Text'));<br/>&lt;/script&gt;</span></pre><h2 id="b12b" class="nn lm jb bd ln no np dn lr nq nr dp lv kj ns nt lz kn nu nv md kr nw nx mh ny bi translated">与AMD加载程序一起使用的AMD模块</h2><p id="da47" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">仍然有相当多的基于AMD/RequireJS的项目。我们可以分发一个文件，它本身可以作为AMD模块的依赖项。</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="d961" class="nn lm jb mr b gy od oe l of og"><strong class="mr jc">define(['fancy-case.js'], function (fancyCase) {</strong><br/>    console.log(fancyCase.upper('some Text'));<br/><strong class="mr jc">});</strong></span></pre><h2 id="6a0e" class="nn lm jb bd ln no np dn lr nq nr dp lv kj ns nt lz kn nu nv md kr nw nx mh ny bi translated">现代捆包机的ES模块</h2><p id="14b0" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated"><a class="ae kw" href="http://exploringjs.com/es6/ch_modules.html" rel="noopener ugc nofollow" target="_blank"> ECMAScript模块</a>现在是官方的、标准化的JavaScript模块格式。</p><blockquote class="ms mt mu"><p id="15b6" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">为优化的浏览器包提供一个ES模块版本</p></blockquote><p id="29e8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ES模块支持卓越的静态分析，这反过来使捆绑器能够使用诸如<a class="ae kw" href="https://medium.com/adobetech/optimizing-javascript-through-scope-hoisting-2259ef7f5994" rel="noopener">范围提升</a>和<a class="ae kw" href="https://medium.com/@Rich_Harris/tree-shaking-versus-dead-code-elimination-d3765df85c80" rel="noopener">树摇动</a>等技术更好地优化生成的代码。为此，它们是现代捆扎机的首选格式。我们的模块可以通过以下方式使用</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="e01c" class="nn lm jb mr b gy od oe l of og"><strong class="mr jc">import {upper} from 'fancy-case';</strong><br/>console.log(upper('some Text'));</span></pre><h2 id="d933" class="nn lm jb bd ln no np dn lr nq nr dp lv kj ns nt lz kn nu nv md kr nw nx mh ny bi translated">面向CJS或无害环境管理消费者的直接进口</h2><p id="dc6f" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">一种新兴的模式，特别是对于具有许多独立实用功能的库，允许用户从单独的文件中导入库的独立部分。节点用户可以写</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="8f08" class="nn lm jb mr b gy od oe l of og">const upper = require(<strong class="mr jc">'fancy-case/cjs/upper'</strong>);<br/>console.log(upper('some Text'));</span></pre><p id="f162" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管ESM消费者可以写</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="4f72" class="nn lm jb mr b gy od oe l of og">import upper from <strong class="mr jc">'fancy-case/esm/upper'</strong>;<br/>console.log(upper('some Text'));</span></pre><blockquote class="ms mt mu"><p id="d03d" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">提供一种直接导入库的独立部分的方法</p></blockquote><p id="aa45" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">直接进口有几个优点:</p><ul class=""><li id="5230" class="kx ky jb ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">Node需要加载和解析更少的代码，这导致更快的启动时间和更少的内存消耗。</li><li id="20ac" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">捆绑器需要分析的代码更少，这使得捆绑速度更快。</li><li id="37a0" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">为了避免死代码，在捆绑器中不需要很好的树摇动支持。通常，实用程序库对它们的输出应用奇特的变换，这使得树摇动算法变得无用；使用这种技术可以很容易地避免这种情况。</li></ul><p id="0271" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是请注意，如果一些模块导入整个库，而其他模块直接导入一些函数，这也会导致更多的捆绑代码。下面我们将展示如何使用Rollup的新代码分割以优雅的方式避免这种情况。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c4d993105d000418143b06c54eed5f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWo7rmh2nS6Nj7QsQMR84Q.jpeg"/></div></div></figure><h1 id="4c9a" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">发布整体捆绑包</h1><p id="e48e" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">目前，我们将专注于前四个发布目标，即CJS、脚本标签、AMD和ESM。为此，让我们准备好要发布的项目:</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="df01" class="nn lm jb mr b gy od oe l of og">mkdir fancy-case</span><span id="0d26" class="nn lm jb mr b gy oh oe l of og">cd fancy-case</span><span id="7010" class="nn lm jb mr b gy oh oe l of og">npm init --yes</span><span id="b901" class="nn lm jb mr b gy oh oe l of og">git clone https://gist.github.com/lukastaegert/e9c6c04b8f96adc562a70c096c3e7705 src</span><span id="0b85" class="nn lm jb mr b gy oh oe l of og">npm install --save-dev rollup</span></pre><p id="cc25" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将为我们的项目创建一个<code class="fe mo mp mq mr b">package.json</code>文件，将我们的示例文件放到一个<code class="fe mo mp mq mr b">src</code>文件夹中并安装Rollup。Rollup支持一种称为<a class="ae kw" href="https://github.com/umdjs/umd" rel="noopener ugc nofollow" target="_blank">“通用模块定义”</a>的特殊输出格式，它同时支持CJS、脚本标签和ESM用例。要创建它，添加一个名为<code class="fe mo mp mq mr b">rollup.config.js</code>的新文件到你的项目的根目录:</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="c08c" class="nn lm jb mr b gy od oe l of og"><strong class="mr jc">export default {<br/>    input: 'src/main.js',<br/>    output: {<br/>        file: 'umd/fancy-case.js',<br/>        format: 'umd',<br/>        name: 'fancyCase'<br/>    }<br/>};</strong></span></pre><p id="8d16" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这指示Rollup从<code class="fe mo mp mq mr b">src/main.js</code>开始，并将其与所有依赖项一起捆绑到<code class="fe mo mp mq mr b">umd/fancy-case.js</code>中的UMD包中。<code class="fe mo mp mq mr b">name</code>选项告诉Rollup在脚本标签中使用包时创建哪个全局变量，在本例中为<code class="fe mo mp mq mr b">fancyCase</code>。如果这个包没有在节点或AMD上下文中使用，这个变量将只被创建。</p><p id="1e81" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你跑了</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="690b" class="nn lm jb mr b gy od oe l of og">npx rollup --config</span></pre><p id="6605" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从您的项目的根目录，这将获得我们的配置文件，并创建一个名为“umd”的新文件夹，其中包含我们的UMD包。你可以在Rollup的网站上查看结果:<a class="ae kw" href="https://rollupjs.org/repl?gist=e9c6c04b8f96adc562a70c096c3e7705" rel="noopener ugc nofollow" target="_blank">https://rollupjs.org/repl?gist = e 9 c 6 c 04 b 8 f 96 ADC 562 a 70 c 096 C3 e 7705</a></p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/5208b1ae2ba59e58cd86ed1f6e84ad4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NwvhYnDktuJJZ942e3UEhA.png"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated">一个整体包将所有模块合并在一起</figcaption></figure><p id="ab88" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你切换到网站输出部分的UMD标签，并输入正确的<code class="fe mo mp mq mr b">global</code>变量名，你会看到你所有的文件被压缩在一起，被这样的包装器包围着</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="c227" class="nn lm jb mr b gy od oe l of og"><strong class="mr jc">(function (global, factory) {<br/>  typeof exports === 'object' &amp;&amp; typeof module !== 'undefined' ? factory(exports) :<br/>  typeof define === 'function' &amp;&amp; define.amd ? define(['exports'], factory) :<br/>  (global = global || self, factory(global.fancyCase = {}));<br/>}(this, function (exports) { 'use strict';</strong><br/>    <br/>  // ... all your bundled code</span><span id="5c07" class="nn lm jb mr b gy oh oe l of og">  <strong class="mr jc">Object.defineProperty(exports, '__esModule', { value: true });<br/>}));</strong></span></pre><p id="a337" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个包装器将分析当前的运行时环境，并以一种方便的方式提供模块的导出。注意这一行:</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="67a6" class="nn lm jb mr b gy od oe l of og">Object.defineProperty(exports, '__esModule', { value: true });</span></pre><p id="7ea4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当试图在ESM环境中<code class="fe mo mp mq mr b">import default</code>我们的UMD捆绑包时，现代捆绑器会添加互操作性代码，检查是否存在<code class="fe mo mp mq mr b">__esModule</code>属性。如果它存在，那么默认导入将不会提供整个导出对象，而只提供该对象的<code class="fe mo mp mq mr b">default</code>属性。</p><p id="771c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们无论如何都要创建一个应该在这些情况下使用的专用ESM包，所以我们可以考虑通过将<code class="fe mo mp mq mr b">esModule: false</code>添加到配置文件的<code class="fe mo mp mq mr b">output</code>部分来跳过这一行。您还可以通过为“cjs”(节点)、“amd”或“iife”(脚本标签)格式创建专用构建来获得更优化的包装器，请查看网站上的相应选项卡。</p><p id="4dc8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，与大多数其他打包器不同，除了包装器代码之外，没有添加专用的运行时环境来解析导入。除了它的可配置性之外，这也是为什么Rollup很受库创建者欢迎的另一个原因，这些库创建者努力以最小的开销创建高效的包。</p><blockquote class="ms mt mu"><p id="c008" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">UMD束应该缩小</p></blockquote><p id="8f25" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">特别是对于AMD和script标签的使用，这个包意味着可以在浏览器中不加修改地运行，我们应该把它缩小。为此，我推荐使用<a class="ae kw" href="https://github.com/terser-js/terser" rel="noopener ugc nofollow" target="_blank"> TerserJS </a>，它是更广为人知的<a class="ae kw" href="http://lisperator.net/uglifyjs/" rel="noopener ugc nofollow" target="_blank"> UglifyJS </a>的一个分支，支持现代ES2015+ JavaScript代码。安装必要的依赖项后</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="c67b" class="nn lm jb mr b gy od oe l of og">npm install --save-dev rollup-plugin-terser</span></pre><p id="d328" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你应该这样修改你的<code class="fe mo mp mq mr b">rollup.config.js</code>:</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="2072" class="nn lm jb mr b gy od oe l of og"><strong class="mr jc">import {terser} from 'rollup-plugin-terser';</strong></span><span id="87e8" class="nn lm jb mr b gy oh oe l of og">export default {<br/>    input: 'src/main.js',<br/>    <strong class="mr jc">plugins: [terser()],</strong><br/>    output: {<br/>        file: 'umd/fancy-case.js',<br/>        format: 'umd',<br/>        name: 'fancyCase',<br/>        <strong class="mr jc">esModule: false</strong><br/>    }<br/>};</span></pre><p id="29fd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上所述，我们还希望提供专用的ESM捆绑包。这可以通过在我们的配置中添加第二个<code class="fe mo mp mq mr b">output</code>来实现，但是由于这个包意味着无论如何都要被其他捆绑器使用，并且不会从缩小中获利(事实上这将使寻找bug变得更加困难)，我更建议放弃这个，导出两个单独的配置:</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="ce67" class="nn lm jb mr b gy od oe l of og">import {terser} from 'rollup-plugin-terser';</span><span id="2e25" class="nn lm jb mr b gy oh oe l of og">export default <strong class="mr jc">[</strong><br/>    {<br/>        input: 'src/main.js',<br/>        plugins: [terser()],<br/>        output: {<br/>            file: 'umd/fancy-case.js',<br/>            format: 'umd',<br/>            name: 'fancyCase',<br/>            esModule: false<br/>        }<br/>    },<br/>    <strong class="mr jc">{<br/>        input: 'src/main.js',<br/>        output: {<br/>            file: 'esm/index.js',<br/>            format: 'esm'<br/>        }<br/>    }</strong><br/><strong class="mr jc">]</strong>;</span></pre><p id="057c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了发布我们的模块，我们需要确保我们库的导入者收到正确的文件，并且这个文件是在发布时从最新的资源构建的。为此，修改我们的<code class="fe mo mp mq mr b">packjage.json</code>文件如下:</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="2900" class="nn lm jb mr b gy od oe l of og">{<br/>  "name": "fancy-case",<br/>  "version": "1.0.0",<br/>  <strong class="mr jc">"main": "umd/fancy-case.js",<br/>  "module": "esm/index.js",</strong><br/>  <strong class="mr jc">"scripts": {<br/>    "prepare": "rollup --config"<br/>  },</strong><br/>  <strong class="mr jc">"files": [<br/>    "esm/*",<br/>    "umd/*"<br/>  ],</strong><br/>  "devDependencies": {<br/>    "rollup": "^1.1.0",<br/>    "rollup-plugin-terser": "^4.0.2"<br/>  }<br/>}</span></pre><blockquote class="ms mt mu"><p id="4fb1" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">添加“主”和“模块”字段</p></blockquote><p id="9f6f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b">main</code>字段确保使用<code class="fe mo mp mq mr b">require</code>的节点用户将得到UMD版本的服务。<code class="fe mo mp mq mr b">module</code>字段不是一个正式的npm特性，而是bundlers之间的一个常见约定，用于指定如何导入我们库的ESM版本。</p><blockquote class="ms mt mu"><p id="ba8a" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">使用“文件”来包含您的包</p></blockquote><p id="fd65" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b">files</code>字段确保除了一些默认文件之外，只有我们指定的包通过npm分发，不包括源代码、测试文件等。这将保持你的用户的<code class="fe mo mp mq mr b">node_modules</code>文件夹较小，并使<code class="fe mo mp mq mr b">npm install</code>更快。您也可以创建一个<code class="fe mo mp mq mr b">.npmignore</code>文件来获得类似的效果，但是使用“拒绝列表”而不是“允许列表”的方法。根据我的经验，“文件”更容易维护。</p><blockquote class="ms mt mu"><p id="078c" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">创建一个“准备”脚本</p></blockquote><p id="b3b6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b">prepare</code>脚本是一个特殊的脚本，它将在我们每次运行<code class="fe mo mp mq mr b">npm install</code>或<code class="fe mo mp mq mr b">npm publish</code>时由npm运行。它还可以直接从Github安装分支，通过</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="3c7e" class="nn lm jb mr b gy od oe l of og">npm install &lt;user&gt;/&lt;repository&gt;#&lt;branch&gt;</span></pre><p id="45b5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们只需运行<code class="fe mo mp mq mr b">npm publish</code>，我们库的第一个版本将通过<code class="fe mo mp mq mr b">npm install fancy-case</code>对每个人开放！</p><blockquote class="ms mt mu"><p id="f455" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">使用“npm包”进行发布演习</p></blockquote><p id="055f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您不确定您是否正确地配置了所有的东西，您可以首先运行<code class="fe mo mp mq mr b">npm pack</code>来获得一个tarball，其中包含了发布时将发送给npm的所有东西，并对其进行检查。如果你有点偏执，你甚至可以用这个tarball进行自动化测试。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/53df460f87edd1590489a71944f8ec56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*667OLYdQJcTkKWJkKir89g.jpeg"/></div></div></figure><h1 id="5157" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">发布优化的区块</h1><p id="3413" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">如上所述，如果我们为我们库的独立部分提供直接导入，这对我们的用户是非常有益的。一种方法是将源文件和我们的库一起分发，并指示我们的用户从那里导入。</p><p id="e849" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果用户代码的不同部分以不同的方式导入我们的库，这会导致令人讨厌的问题。想象一个模块从<code class="fe mo mp mq mr b">"fancy-case"</code>导入<code class="fe mo mp mq mr b">upper</code>函数，而另一个模块从<code class="fe mo mp mq mr b">"fancy-case/src/upper"</code>导入。尽管从技术上来说是相同的代码，但现在这是两个非常不同的函数，并且<code class="fe mo mp mq mr b">upper</code>将在用户代码中出现两次。</p><p id="e741" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这听起来问题不大，但是想象一下，如果我们在<code class="fe mo mp mq mr b">upper</code>函数旁边的一个变量中存储一些持久状态(绝对不是推荐的做法，但是这种情况确实发生了)，或者如果用户依赖于比较对我们的<code class="fe mo mp mq mr b">upper</code>函数的引用，会发生什么。突然间，我们面临着无数奇怪的、难以追踪的错误。此外，未触及的源代码没有受益于任何优化，如范围提升或树摇动，或通过插件如<a class="ae kw" href="https://github.com/rollup/rollup-plugin-babel" rel="noopener ugc nofollow" target="_blank"> rollup-plugin-babel </a>应用于代码的任何转换。</p><blockquote class="ms mt mu"><p id="e047" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">将库中的独立部分标记为附加条目模块</p></blockquote><p id="8d51" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Rollup 1.0提供了一个简单但强大的解决方案:您可以将库的独立部分指定为额外的入口点。在我们改变我们的项目之前，看看https://rollupjs.org/repl? REPL的结果:<a class="ae kw" href="https://rollupjs.org/repl?gist=e9c6c04b8f96adc562a70c096c3e7705&amp;entry=lower.js,upper.js,upperFirst.js" rel="noopener ugc nofollow" target="_blank">gist = e 9 c 6 c 04 b 8 f 96 ADC 562 a 70 c 096 c3e 7705&amp;entry = lower . js，upper.js，upperFirst.js </a></p><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/1e8dc38203977e3fa4a4cf5a4c5d50a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L9HG9XhB6vVU13x0lyH0OQ.png"/></div></div><figcaption class="oj ok gj gh gi ol om bd b be z dk translated">代码分割包将模块分组为块</figcaption></figure><p id="e032" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到，我们最初的八个模块已经减少到五个块，每个入口模块一个，另外一个块由其他几个块导入。根据您所看到的格式，这些块只是简单地相互<code class="fe mo mp mq mr b">import</code>或<code class="fe mo mp mq mr b">require</code>而没有添加任何额外的管理代码或任何代码复制。</p><p id="c86c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了避免重复，从而避免上面提到的重复状态或引用的潜在问题，Rollup应用一种“着色”算法，该算法为每个入口模块分配一种单独的颜色，然后遍历模块图，为每个模块分配依赖于它的所有入口点的“混合”颜色。</p><p id="cc08" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，红色入口模块<code class="fe mo mp mq mr b">upper.js</code>和蓝色入口模块<code class="fe mo mp mq mr b">lower.js</code>都依赖于<code class="fe mo mp mq mr b">constants.js</code>和<code class="fe mo mp mq mr b">shiftChar.js</code>，所以它们被分配给一个新的紫色块。<code class="fe mo mp mq mr b">main.js</code>和<code class="fe mo mp mq mr b">upperFirst.js</code>仅依赖于其他入口模块，因此不会进一步改变颜色。</p><p id="b560" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是你如何改变你的<code class="fe mo mp mq mr b">rollup.config.js</code>来为CJS和ESM用户产生代码分割版本:</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="97e3" class="nn lm jb mr b gy od oe l of og">import {terser} from 'rollup-plugin-terser';</span><span id="7a5d" class="nn lm jb mr b gy oh oe l of og">export default [<br/>    {<br/>        input: 'src/main.js',<br/>        plugins: [terser()],<br/>        output: {<br/>            file: 'umd/fancy-case.js',<br/>            format: 'umd',<br/>            name: 'fancyCase',<br/>            esModule: false<br/>        }<br/>    },<br/>    {<br/>        <strong class="mr jc">input: {<br/>            index: 'src/main.js',<br/>            upper: 'src/upper.js',<br/>            lower: 'src/lower.js',<br/>            upperFirst: 'src/upperFirst.js'<br/>        },</strong><br/>        output: [<br/>            {<br/>                <strong class="mr jc">dir: 'esm',</strong><br/>                format: 'esm'<br/>            },<br/>            {<br/>                <strong class="mr jc">dir: 'cjs',</strong><br/>                format: 'cjs'<br/>            }<br/>        ]<br/>    }<br/>];</span></pre><p id="baed" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们现在提供了一个对象作为<code class="fe mo mp mq mr b">input</code>，其中属性对应于生成的入口块，而值对应于它们的入口模块。此外，我们现在定义一个输出<code class="fe mo mp mq mr b">dir</code>来放置所有的块，而不是指定<code class="fe mo mp mq mr b">file</code>。如果你想调整命名方案和块的位置，看看<code class="fe mo mp mq mr b"><a class="ae kw" href="https://rollupjs.org/guide/en#output-entryfilenames" rel="noopener ugc nofollow" target="_blank">entryFileNames</a></code>和<code class="fe mo mp mq mr b"><a class="ae kw" href="https://rollupjs.org/guide/en#output-chunkfilenames" rel="noopener ugc nofollow" target="_blank">chunkFileNames</a></code>输出选项。要检查结果，只需运行</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="025b" class="nn lm jb mr b gy od oe l of og">npm run prepare</span></pre><blockquote class="ms mt mu"><p id="ee33" class="jy jz mv ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">为高级配置在配置文件中编写JavaScript代码</p></blockquote><p id="8b9c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您有很多入口点，而不是单独指定它们，请注意您的配置文件是一个JavaScript文件，可以从<code class="fe mo mp mq mr b">node_modules</code>以及内置节点库中导入任何东西。因此，你可以用<code class="fe mo mp mq mr b">import fs from 'fs'</code>然后用<code class="fe mo mp mq mr b">fs.readDirSync</code>从一个目录中构建一个入口模块的对象。</p><p id="0132" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在剩下要做的事情就是调整您的<code class="fe mo mp mq mr b">package.json</code>文件以包含新文件和导入目标，然后发布结果:</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="34cd" class="nn lm jb mr b gy od oe l of og">{<br/>  "name": "fancy-case",<br/>  "version": "1.0.0",<br/>  <strong class="mr jc">"main": "cjs/index.js",</strong><br/>  "module": "esm/index.js",<br/>  "scripts": {<br/>    "prepare": "rollup --config"<br/>  },<br/>  "files": [<br/>    <strong class="mr jc">"cjs/*",</strong><br/>    "esm/*",<br/>    "umd/*"<br/>  ],<br/>  "devDependencies": {<br/>    "rollup": "^1.1.0",<br/>    "rollup-plugin-terser": "^4.0.2"<br/>  }<br/>}</span></pre><h2 id="2752" class="nn lm jb bd ln no np dn lr nq nr dp lv kj ns nt lz kn nu nv md kr nw nx mh ny bi translated">使用。mjs</h2><p id="b8d0" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">另一种新兴模式是构建双模式包，其中CJS和es模块相邻放置，CJS文件带有<code class="fe mo mp mq mr b">.js</code>扩展名，而ESM文件带有<code class="fe mo mp mq mr b">.mjs</code>扩展名。这可以通过在加法时对两个输出使用相同的<code class="fe mo mp mq mr b">dir</code>来容易地实现</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="2e6b" class="nn lm jb mr b gy od oe l of og">entryFileNames: [name].mjs</span></pre><p id="b46a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ESM输出选项。但是请注意，在使用外部依赖关系时，这可能会改变某些捆绑器中的捆绑行为，因此您应该自担风险。</p><h2 id="5a36" class="nn lm jb bd ln no np dn lr nq nr dp lv kj ns nt lz kn nu nv md kr nw nx mh ny bi translated">避开瀑布</h2><p id="278e" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">您可能会注意到，Rollup似乎向一些块添加了额外的“空”导入。例如，这是您的<code class="fe mo mp mq mr b">main.js</code>块在ESM版本中的外观:</p><pre class="mz na nb nc gt nz mr oa ob aw oc bi"><span id="379c" class="nn lm jb mr b gy od oe l of og">import '../chunk-59d826da.js';<br/>export { default as upper } from '../upper.js';<br/>export { default as lower } from '../lower.js';<br/>export { default as upperFirst } from '../upperFirst.js';</span></pre><p id="aab2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，为什么我们的共享块在顶部有一个额外的导入？让我们看看当我们想要运行<code class="fe mo mp mq mr b">main.js</code>而不添加这个时会发生什么:</p><ol class=""><li id="426e" class="kx ky jb ka b kb kc kf kg kj kz kn la kr lb kv on ld le lf bi translated">加载并解析<code class="fe mo mp mq mr b">main.js</code></li><li id="839e" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv on ld le lf bi translated">解析之后，我们知道我们还需要<code class="fe mo mp mq mr b">upper.js</code>、<code class="fe mo mp mq mr b">lower.js</code>和<code class="fe mo mp mq mr b">upperFirst.js</code>，所以我们加载并解析它们</li><li id="d1b7" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv on ld le lf bi translated">在解析它们中的任何一个之后，我们知道我们还需要我们的共享块，所以我们也加载并解析那个共享块</li><li id="5406" class="kx ky jb ka b kb lg kf lh kj li kn lj kr lk kv on ld le lf bi translated">运行一切</li></ol><p id="d0a0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了添加的导入，步骤3不再需要等待步骤2，因为一旦条目块被解析，所有的依赖关系都是已知的。因此，节点用户将能够更快地加载您的库，而绑定器将从减少的模块发现时间中受益。</p><h2 id="b193" class="nn lm jb bd ln no np dn lr nq nr dp lv kj ns nt lz kn nu nv md kr nw nx mh ny bi translated">外部依赖性</h2><p id="224b" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">即使我们的库是自给自足的，也很容易添加外部依赖项。但是请注意，在这种情况下，您应该添加<code class="fe mo mp mq mr b"><a class="ae kw" href="https://rollupjs.org/guide/en#external" rel="noopener ugc nofollow" target="_blank">external</a></code>选项来提供所有外部依赖项的数组，否则您将收到来自Rollup的警告。要在UMD或生命构建中拥有外部依赖，当通过<code class="fe mo mp mq mr b"><a class="ae kw" href="https://rollupjs.org/guide/en#output-globals" rel="noopener ugc nofollow" target="_blank">globals</a></code>输出选项在脚本标签中使用库时，您还需要指定在哪些全局变量名下可以找到外部依赖。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><figure class="mz na nb nc gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/664d3a2c65c4b49b547ba225ba4412ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*--1_ljO0X8BOFZFuARfcfw.jpeg"/></div></div></figure><h1 id="4ea6" class="ll lm jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="883e" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">通过一个单一的中央配置文件，Rollup可以同时提供许多不同的包格式。</p><p id="bc78" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用Rollup进行代码分割提供了一种捆绑库的新方法，可以防止向用户公开多个导入目标的许多缺陷，同时为您提供了完全的可配置性和灵活性。期待Rollup在未来提供更多的代码优化，代码分割和整体捆绑包都将从中受益。</p><p id="8e6f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，你也可以使用Rollup来捆绑web应用程序。)，但这并不是本文的重点。</p><p id="1c82" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这提供了一个很好的主题介绍，非常欢迎反馈！</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><figure class="mz na nb nc gt is gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi oo"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="ip iq gp gr ir op"><a href="https://gitconnected.com/learn/node-js" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd jc gy z fp ou fr fs ov fu fw ja bi translated">学习Node.js -最佳Node.js教程(2019) | gitconnected</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">前31个Node.js教程-免费学习Node.js。课程由开发人员提交和投票，使您能够…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">gitconnected.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ix op"/></div></div></a></div></div></div>    
</body>
</html>