<html>
<head>
<title>Big O Time Complexity: What it is and Why it Matters For Your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大时间复杂度:它是什么，为什么它对你的代码很重要</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/big-o-time-complexity-what-it-is-and-why-it-matters-for-your-code-6c08dd97ad59?source=collection_archive---------7-----------------------#2020-05-26">https://levelup.gitconnected.com/big-o-time-complexity-what-it-is-and-why-it-matters-for-your-code-6c08dd97ad59?source=collection_archive---------7-----------------------#2020-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d2a01748853fa5fd19aedacff8af0e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yiyfZodqXNwMouC0-B0Wlg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图1:大O时间复杂度图。鸣谢:黄d(2018年1月1日)。Javascript —算法</figcaption></figure><p id="6218" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">警告:这里面有一些数学。但是不要被吓跑了！没有听起来那么痛苦。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="ec6d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你几年前告诉我，有一天我会写一篇涉及任何数学的文章，我会告诉你你绝对是疯了。许多阅读这篇文章的人可能会有同样的感觉。但是事情是这样的，<strong class="ke ir">我们需要特定的方式来将我们在职业中处理的事情具体化</strong>。也就是说，无论我们在做什么，我们都应该有某种方式来说:“这正是使这个(在这里插入你需要测量的任何东西)比这个(在这里插入其他不太有效的东西)更好的东西。”</p><p id="3690" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我在体育界工作的时间教会了我这第一手知识。一个简单的例子:如果一名运动员比另一名运动员跑得更快，那么在特定的环境下，这名运动员比另一名运动员更快。即使只差0.1秒，那个运动员在这种情况下还是更快。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="f16a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">我们编写的代码需要有某种客观的方法来衡量它的性能，或者效率</strong>。我们需要某种方法来衡量:“这一行或这一块代码比这一行好，这就是原因。”但这提出了一个显而易见的问题:到底是什么让一段代码比另一段好？难道是代码更短了？更容易让别人读懂？重构得好？运行时是最重要的吗？它消耗的内存量呢？不用说，就像两个运动员在炎热或寒冷的天气里跑10米短跑和20米短跑一样，环境很重要。简单来说，<strong class="ke ir">这正是大O符号为我们做的。它允许我们在给定某些参数的情况下测量代码的效率，这些参数对于当前的情况是最重要的。</strong></p><blockquote class="lh"><p id="c872" class="li lj iq bd lk ll lm ln lo lp lq kz dk translated">我们编写的代码需要某种客观的方法来衡量其效率。</p></blockquote><p id="6dfe" class="pw-post-body-paragraph kc kd iq ke b kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv lv kx ky kz ij bi translated"><strong class="ke ir">在本文中，我们将探索如何通过大O符号来评估“时间复杂度”。</strong>别担心，我们也会讨论这意味着什么。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="549b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在深入研究之前，我想对<a class="ae lw" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass" rel="noopener ugc nofollow" target="_blank">柯尔特·斯蒂尔的算法和数据结构课程</a>中的许多例子和概念给予一点肯定。</p><h1 id="fe26" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><strong class="ak">时间复杂度的大O符号</strong></h1><p id="2abf" class="pw-post-body-paragraph kc kd iq ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">我们来谈谈速度。</p><p id="f2fb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们很多人都知道可以使用计时器来测试代码的速度。但这引发了一些问题。一个是记录的时间会因机器而异。事实上，同一台机器内的时间甚至会有所不同。另一个主要问题是，这仍然没有给我们一个客观的方法来讨论两个代码块之间的区别。我们如何传达这一点，我们从较慢的时间中减去较快的时间吗？我们接受百分比差异吗？换句话说，这里的界限会变得有点模糊。</p><p id="1451" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这正是大O符号发挥作用的地方。它为我们提供了一种以一致和清晰的方式交流代码效率的方法。</p><blockquote class="lh"><p id="69a3" class="li lj iq bd lk ll lm ln lo lp lq kz dk translated">大O符号为我们提供了一种以一致和清晰的方式交流代码效率的方法。</p></blockquote><p id="9ff9" class="pw-post-body-paragraph kc kd iq ke b kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv lv kx ky kz ij bi translated">那么，如果不是时间，我们还能用什么呢？简单的答案是<strong class="ke ir">计数操作。</strong>让我们看一些例子来说明这意味着什么。</p><p id="4b02" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">标题中的图表引用了最常见的“大O表达式”类型。因为它们是你会遇到的最常见的表达方式，所以这些是我们将在本文中讨论的。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h1 id="eba6" class="lx ly iq bd lz ma na mc md me nb mg mh mi nc mk ml mm nd mo mp mq ne ms mt mu bi translated"><strong class="ak">大O表情的主要类型:</strong></h1><p id="201c" class="pw-post-body-paragraph kc kd iq ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">大O表达式都涉及到算法O(f(n))。简而言之，这意味着随着计算机通过<strong class="ke ir"> n </strong>进一步工作，计算机必须做的简单操作的数量会减少(这一点稍后会更有意义)。</p><h2 id="1bc1" class="nf ly iq bd lz ng nh dn md ni nj dp mh kn nk nl ml kr nm nn mp kv no np mt nq bi translated"><strong class="ak">常见的</strong> <strong class="ak">大O表情#1: O(n) </strong></h2><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/d22d7e8148d3497d753db792c86c78d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*z_GjT7UHF1MeE__PnQictQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图2: O(n)图，信用:101computing.net(2018年1月21日)。大O符号线性算法。</figcaption></figure><p id="d966" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">O(n)和O(1)是最容易理解的表达式(我们接下来会讨论后者)。如果一个操作有一个O(n)(读作‘O of N’)，这意味着，<strong class="ke ir">随着‘N’的增加，完成问题所需的操作量也增加。</strong>这很容易理解，因为这是一个完全线性的关系。</p><blockquote class="lh"><p id="5018" class="li lj iq bd lk ll lm ln lo lp lq kz dk translated"><strong class="ak">如果一个算法有一个O(n ),随着‘n’的增加，完成问题所需的运算量也会增加</strong></p></blockquote><p id="fd34" class="pw-post-body-paragraph kc kd iq ke b kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv lv kx ky kz ij bi translated">让我们探索一个例子，我们将在下一点中使用O(n)和O(1)。</p><h2 id="3367" class="nf ly iq bd lz ng nh dn md ni nj dp mh kn nk nl ml kr nm nn mp kv no np mt nq bi translated"><strong class="ak">编写一个函数，计算从1到n(包括1和n)的所有数字的和</strong></h2><p id="a146" class="pw-post-body-paragraph kc kd iq ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated"><strong class="ke ir">例子:如果n = 3，那么函数应该运行1 + 2 + 3，返回和:6。</strong></p><p id="8065" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">解决这个问题的第一个(也是最明显的)方法是使用“for”循环。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="290c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这种情况下，这里的大O应该是O(n)。这是因为，随着n的增加，迭代“for”循环所需的操作量也会增加。计算机每次经过‘for’循环，都需要赋值多个变量，进行比较，并添加多个变量。它必须一遍又一遍地重复这个过程n次。简单来说，这相当慢。</p><p id="bc62" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设n是5。这意味着计算机需要循环5次函数才能得出答案。假设n是1000。在这种情况下，计算机将需要通过函数循环1000次来计算我们的解。</p><p id="8acc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从技术上讲，在第一种情况下，我们将处理O(5n)(或者，如果你想得到技术上的，O(5n +2)，因为在' for '循环之外有两个赋值)，在第二种情况下，我们将处理O(1000n)(或者，如果你想再次得到技术上的，O(1000n + 2))。但是请记住，大O符号的目标是尽可能地简化事情，以便我们与其他程序员交流。因此，就术语而言，n前面是什么并不重要。<strong class="ke ir">这两个表达式都将简化为O(n)。因为无论如何，随着n的增加，运算量大致与n成正比增长。</strong></p><p id="980c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">还和我在一起吗？好吧，我们继续。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h2 id="caad" class="nf ly iq bd lz ng nh dn md ni nj dp mh kn nk nl ml kr nm nn mp kv no np mt nq bi translated"><strong class="ak">常见的大O表情#2: O(1) </strong></h2><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/12380389096e8f59286e8931055cfbf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*AJ09oN6ANIz_5XUPv6cmgg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图3: O(1)图，信用:101computing.net(2018年1月21日)。大O符号。</figcaption></figure><p id="bee5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个有O(1)的算法更容易理解。<strong class="ke ir">如果一个算法有一个O(1)，这意味着无论n的值是多少，解决问题所需的运算量保持不变。</strong></p><blockquote class="lh"><p id="43db" class="li lj iq bd lk ll lm ln lo lp lq kz dk translated"><strong class="ak">如果一个算法有O(1)，那么它的时间复杂度将保持不变，不管n的值是多少，它是最有效的算法类型。</strong></p></blockquote><p id="b594" class="pw-post-body-paragraph kc kd iq ke b kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv lv kx ky kz ij bi translated">让我们来看一个例子，通过解决与上面<strong class="ke ir">(写一个计算从1到(包括)n的所有数字之和的函数)</strong>相同的问题，但是通过使用一个更有效的解决方案。O(1)的解。</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="aa0b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个解决方案是可行的，会给我们同样的结果。<strong class="ke ir">在这种情况下，总是有3个操作被调用。</strong>无论n = 1或n = 1，000，无论n的大小如何，都只会有3次运算(此处为加法、乘法和除法)。因此，从技术上讲，我们会有一个O(3)。但是请记住，作为程序员，我们喜欢让事情尽可能简单。因此，无论我们有O(3)还是O(10)，我们都会说<strong class="ke ir">这是O(1)，因为无论n </strong>的值是多少，运算都保持一致。这不同于我们上面的“for”循环，在那里操作的数量继续与n大致成比例地增加。</p><p id="3007" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可能注意到的第一件事是这段代码比上一段代码短，但这并不一定会使一行代码比另一行代码好，这也不是本文的重点。此外，这个解决方案是如何工作的以及它来自哪里现在并不重要，所以如果你不明白它是如何工作的，那也没关系。</p><p id="85ad" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要理解的一点是为什么这比前面列出的O(n)函数更有效。原因是，不管n等于多少，完成函数所需的运算量保持不变。因此，如果我们在谈论时间复杂度，这个函数优于先验。</p><p id="4d32" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">总之，<strong class="ke ir">一个O(1)的算法是最可取的，并且总是比O(n)的算法更有效。</strong></p><p id="90f9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">哇哦。已经很多了，但我们还没完。让我们继续前进！</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><h2 id="4e67" class="nf ly iq bd lz ng nh dn md ni nj dp mh kn nk nl ml kr nm nn mp kv no np mt nq bi translated"><strong class="ak">常见的大O表情#3: O(n </strong></h2><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/6255448f9efdf72972875ff1d155a770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kLelWVP6t2YjoVoyAyDgdQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图4: O(n)图，信用:Arzzen。(2019年2月10日)。大O符号简单指南。</figcaption></figure><p id="63e3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">O(n)运算中的O(n)运算是O(n * n)运算。换句话说，O(n)。</strong>这是最慢和效率最低的，因此在考虑时间复杂度时是最不理想的大O表达式。</p><blockquote class="lh"><p id="453f" class="li lj iq bd lk ll lm ln lo lp lq kz dk translated"><strong class="ak">具有O(n)的算法随n呈指数增长，它是最慢、效率最低的算法类型。</strong></p></blockquote><p id="b3a3" class="pw-post-body-paragraph kc kd iq ke b kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv lv kx ky kz ij bi translated">让我们探索一个具有O(n)的函数的例子</p><h2 id="9abe" class="nf ly iq bd lz ng nh dn md ni nj dp mh kn nk nl ml kr nm nn mp kv no np mt nq bi translated"><strong class="ak">编写一个函数，返回成对的数字，从0，0开始，一直到n，n之前</strong></h2><p id="e6ee" class="pw-post-body-paragraph kc kd iq ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated"><strong class="ke ir">例:如果n=2，函数应该返回“0，0 0，1 1，0 1，1”(每次在2之前停止)。</strong></p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="d6b8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是可行的，并且有一个O(n)。<strong class="ke ir">如果n等于3，我们将得到9对，如果n等于4，我们将得到16对。所以这里的运算量随着n呈指数增长</strong></p><p id="8ba5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">重要的是要注意:这个函数是O(n)的原因不是因为有两个“for”循环。事实上，你可以有多个“for”循环，只要它们没有嵌套，仍然以O(n)结束。<strong class="ke ir">结果为O(n)的原因是，由于函数中有一个嵌套循环，解决问题所需的运算量将随n呈指数增长。</strong></p><h2 id="ec04" class="nf ly iq bd lz ng nh dn md ni nj dp mh kn nk nl ml kr nm nn mp kv no np mt nq bi translated"><strong class="ak">常见的大O表达式#4: O(log n) </strong></h2><figure class="ns nt nu nv gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c862d443f73ba5c680cf17cf31df9fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*4MN1PhTNpluNK62Fj4OREg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图5: O(log n)图，信用:101computing.net(2018年1月21日)。大O符号。</figcaption></figure><p id="fce1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们开始之前，<strong class="ke ir">让我们快速定义一下什么是“日志”</strong>(请耐心听我说，我会让它变得快速而没有痛苦！).就像加法有逆运算(减法)和乘法有逆运算(除法)一样，指数运算也是如此。<strong class="ke ir">取幂的倒数是对数(log)。</strong></p><p id="c9d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个例子:对数₂(8) = 3。我们可以简单地理解为，“2的8次方等于多少？”。嗯，2 * 2 * 2 = 8。所以我们的答案是3。</p><p id="20ce" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你会看到的最常见的“对数”是对数₂(读作“以二为底的对数”)和对数₁₀.但是根据我们通常的简化目的，我们将把它简化为“log”。这是因为不管我们处理的是什么样的“日志”,我们图表的总体趋势最终看起来总是一样的。好了，现在够了！编码上。</p><p id="ecf4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个经典的O对数的例子(log <em class="nz"> n </em>):</p><figure class="ns nt nu nv gt jr"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="03bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一个具有O(log <em class="nz"> n) </em>的算法的常见例子是搜索算法，其中答案空间不断分裂。这可能是一个<a class="ae lw" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>，你一次又一次地将一个有序数组分成两半，直到你找到答案。</p><blockquote class="lh"><p id="c69c" class="li lj iq bd lk ll lm ln lo lp lq kz dk translated"><strong class="ak">一个O(log <em class="oa"> n) </em>算法的时间复杂度随着n的增加而增加，但最终趋于平稳。O(log <em class="oa"> n)是仅次于O(1)的</em>。</strong></p></blockquote><p id="56e5" class="pw-post-body-paragraph kc kd iq ke b kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv lv kx ky kz ij bi translated"><strong class="ke ir">具有O(log <em class="nz"> n) </em>的算法在时间复杂度上随着n而上升，但最终趋于平稳。</strong>如果你的代码有一个O(log <em class="nz"> n)，</em>这太棒了！<strong class="ke ir"> O(log <em class="nz"> n)是仅次于O(1)的</em>。</strong></p><p id="328a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">数组与对象</strong></p><p id="7f6f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们长话短说吧。<strong class="ke ir">由于时间复杂性，处理对象(键:值对)几乎总是比数组(有序列表)更有效</strong>，因为它们没有特定的顺序。</p><blockquote class="lh"><p id="5238" class="li lj iq bd lk ll lm ln lo lp lq kz dk translated">从时间复杂性来看，使用对象几乎总是比数组更有效。</p></blockquote><p id="0dc8" class="pw-post-body-paragraph kc kd iq ke b kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv lv kx ky kz ij bi translated"><strong class="ke ir">物体的大O</strong></p><ul class=""><li id="a18a" class="ob oc iq ke b kf kg kj kk kn od kr oe kv of kz og oh oi oj bi translated"><strong class="ke ir">插入— </strong> O(1)</li><li id="1974" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir">清除- </strong> O(1)</li><li id="5536" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir">搜索— </strong> O(n)注意:搜索不同于访问。在这种情况下，搜索意味着以任何方式遍历对象。一个例子是迭代查找对象中是否存在某个值。</li><li id="90df" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir">访问— </strong> O(1)</li></ul><p id="3b7e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对象非常快，因为它们通常不用于排序！</p><p id="c9a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">对象方法的大O</strong></p><ul class=""><li id="3348" class="ob oc iq ke b kf kg kj kk kn od kr oe kv of kz og oh oi oj bi translated"><strong class="ke ir"> Object.keys — </strong> O(n)</li><li id="d96d" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir"> Object.values — </strong> O(n)</li><li id="8dae" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir"> Object.entries — </strong> O(n)</li><li id="4fc3" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir"> hasOwnProperty — </strong> O(1)</li></ul><p id="d332" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为什么前三点等于O(n)是有道理的。这些方法用于创建数组。例如:对于Object.keys，对象中的键越多，创建数组的时间就越长。</p><p id="673e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">数组的大O</strong></p><ul class=""><li id="9a74" class="ob oc iq ke b kf kg kj kk kn od kr oe kv of kz og oh oi oj bi translated"><strong class="ke ir">插入— </strong>变化</li><li id="aca6" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir">移除— </strong>各不相同</li><li id="4730" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir">搜索— </strong> O(n)</li><li id="6761" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir">访问— </strong> O(1)</li></ul><p id="e076" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">数组中有不同的插入和移除方法，当涉及到它们给表带来的时间复杂度时，它们会产生很大的不同。让我们来探讨一下这意味着什么。</p><p id="935c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">大魔神阵的阵法</strong></p><ul class=""><li id="6d72" class="ob oc iq ke b kf kg kj kk kn od kr oe kv of kz og oh oi oj bi translated"><strong class="ke ir">推送— </strong> O(1)</li><li id="26af" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir">流行— </strong> O(1)</li><li id="3422" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir"> shift — </strong> O(n)</li><li id="b799" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir">未移位— </strong> O(n)</li><li id="882e" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir"> concat — </strong> O(n)</li><li id="c8a0" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir">切片— </strong> O(n)</li><li id="f912" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir">拼接— </strong> O(n)</li><li id="b0e8" class="ob oc iq ke b kf ok kj ol kn om kr on kv oo kz og oh oi oj bi translated"><strong class="ke ir">地图— </strong> O(n)</li></ul><p id="fcf9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">不用担心背这个单子！<strong class="ke ir">关键的一点是，任何需要改变/移动数组中的索引的方法都有一个很大的O(n)。想想看，如果我在一个有1000个元素的数组上使用“unshift”(在数组的开头添加一个元素)，计算机现在需要遍历整个数组，并将每个元素的索引移动1。</strong></p><p id="eacb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一方面，使用“pop”(从数组中移除最后一个元素)根本不需要计算机修改任何东西的索引，因为我们所做的只是移除最后一个索引。</p><p id="8367" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">总结:如果你不在乎顺序，使用对象通常是明智的选择。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><p id="cf16" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">总之，<strong class="ke ir">大的时间复杂度允许我们分析解决问题所需的操作数量，并以简单、一致和可理解的方式向其他开发人员传达其效率</strong>。它是理解算法和数据结构的基础，因此熟悉它非常重要。</p></div><div class="ab cl la lb hu lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ij ik il im in"><div class="ns nt nu nv gt op"><a href="https://skilled.dev/course/big-o-time-and-space-complexity" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd ir gy z fp ou fr fs ov fu fw ip bi translated">编码面试的大O时间和空间复杂度</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">我们将完全理解大O，但在我们深入之前，让我们先不用所有的数学来定义它。我们测量…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">技术开发</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd jw op"/></div></div></a></div></div></div>    
</body>
</html>