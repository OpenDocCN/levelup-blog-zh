<html>
<head>
<title>Converting a Kubernetes Fullstack Application to Heroku Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Kubernetes Fullstack应用程序转换为Heroku容器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/converting-a-kubernetes-fullstack-application-to-heroku-containers-f8de25e2ac09?source=collection_archive---------19-----------------------#2020-09-17">https://levelup.gitconnected.com/converting-a-kubernetes-fullstack-application-to-heroku-containers-f8de25e2ac09?source=collection_archive---------19-----------------------#2020-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="53bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在过去的几年里，谷歌的Kubernetes项目引起了巨大的轰动。该项目已经发展成为云基础设施领域的巨头。</p><p id="e8ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这是一个伟大的项目，并为许多目的服务，它仍然是一个复杂的野兽。即使有来自主要云提供商的托管服务，团队也必须使用不断扩展的插件和范式转换来维护复杂、交织的架构。由于其灵活性所固有的复杂性，Kubernetes需要自己的一套技能来实现、维护、升级和操作这个多样化的编排生态系统。</p><h1 id="b353" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">PaaS的简单性</h1><p id="6118" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">这些密集的、基于技能的需求可能适合一些商业模式。然而，如果你想把时间花在构建应用程序上，而不是管理服务器和安全，那么你可能想考虑平台即服务(PaaS)而不是Kubernetes。这些提供商维护环境的基础架构、安全性、可观察性和整体状况，因此您可以专注于业务关键型应用程序。</p><p id="504e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Kubernetes的吸引力之一是它能够提供统一的环境体验。为适应Kubernetes而构建的应用程序在设计上应该是可移植的，本质上是短暂的，能够在任何容器驱动的世界中生存，与基础设施无关(查看<a class="ae ko" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank">十二因素应用程序</a>以获得关于构建应用程序的更多指导)。因此，如果一个应用程序团队想要摆脱Kubernetes托管基础架构的复杂性，转而支持管理型PaaS，那会是什么样子呢？</p><p id="8a8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天我们来看看这个简单的<a class="ae ko" href="https://github.com/Tokugero/kubernetes-hello-world/tree/heroku" rel="noopener ugc nofollow" target="_blank"> Kubernetes驱动烧瓶应用</a>。我们将看看它是如何运行的，了解它的需求，并探索如何将它转换成Heroku。</p><h1 id="9ef4" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">应用程序设计</h1><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/0ad66976d64c40166b27ef96ac020612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/0*_p6rK4kq-ieEDuR0.png"/></div></figure><p id="52f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个应用程序是一个简单的Flask前端，它从Postgres数据库中提取一个演员列表，然后将他们显示在一个网站上。如您所见，监控、记录、服务和提供正常运行时间的基础设施比应用程序本身组成了更多的组件。</p><p id="36df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要在Kubernetes中部署应用程序，我们需要先决条件的基础设施组件、应用程序本身的几个YAMLs和数据库的导航图。</p><ul class=""><li id="9a5e" class="ma mb it js b jt ju jx jy kb mc kf md kj me kn mf mg mh mi bi translated"><a class="ae ko" href="https://docs.gitlab.com/charts/" rel="noopener ugc nofollow" target="_blank"> GitLab CI/CD </a></li><li id="4192" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><a class="ae ko" href="https://www.getambassador.io/docs/latest/tutorials/getting-started/" rel="noopener ugc nofollow" target="_blank">大使缘栈</a></li><li id="2273" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><a class="ae ko" href="https://linkerd.io/2/tasks/install-helm/" rel="noopener ugc nofollow" target="_blank"> LinkerD服务网格</a></li><li id="65de" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><a class="ae ko" href="https://github.com/fluent/fluentd-kubernetes-daemonset/blob/master/fluentd-daemonset-elasticsearch.yaml" rel="noopener ugc nofollow" target="_blank">流动日志收集器</a></li><li id="c09f" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><a class="ae ko" href="https://github.com/elastic/helm-charts/tree/master/elasticsearch" rel="noopener ugc nofollow" target="_blank">弹性搜索文档数据库</a></li><li id="34bd" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><a class="ae ko" href="https://github.com/Tokugero/kubernetes-hello-world/blob/heroku/spec/TLS.yaml" rel="noopener ugc nofollow" target="_blank">证书生成</a></li><li id="82f2" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><a class="ae ko" href="https://github.com/Tokugero/kubernetes-hello-world/blob/heroku/spec/Mapping.yaml" rel="noopener ugc nofollow" target="_blank">入口定义</a></li><li id="b8ea" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><a class="ae ko" href="https://github.com/Tokugero/kubernetes-hello-world/blob/heroku/spec/Deployment.yaml" rel="noopener ugc nofollow" target="_blank">暴露端口&amp;应用部署</a></li><li id="58d3" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><a class="ae ko" href="https://github.com/Tokugero/kubernetes-hello-world/blob/heroku/spec/postgres/values.yaml" rel="noopener ugc nofollow" target="_blank"> PostgreSQL头盔定制</a></li><li id="14bc" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><a class="ae ko" href="https://github.com/Tokugero/kubernetes-hello-world/tree/heroku/app" rel="noopener ugc nofollow" target="_blank">最后是应用程序本身</a></li></ul><p id="88a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要使应用程序可用，需要很多必要的步骤。让我们看看赫罗库的类似的必需品。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/fbd8cfb609187ddb9fcfc19d9b534f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/0*sI0PKvBFQTsps70c.png"/></div></figure><p id="eb82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为PaaS供应商已经为您做出了技术决策，所以您必须遵守该供应商的决策和意见。但是，作为回报，您可以获得开箱即用的紧密集成的服务产品。以前需要数周时间来研究和实现服务网格和日志导出器，现在只需要几分钟和几个命令。</p><p id="3732" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要在Heroku中部署相同的应用程序，我们只需要两步:启动数据库和应用程序。</p><p id="8585" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在让我们看看如何将这个应用程序从Kubernetes转换到Heroku。我们来看四个步骤:</p><ol class=""><li id="5004" class="ma mb it js b jt ju jx jy kb mc kf md kj me kn mo mg mh mi bi translated">建立基础设施</li><li id="ee8c" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mo mg mh mi bi translated">转换应用程序</li><li id="4968" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mo mg mh mi bi translated">部署应用程序</li><li id="eeaa" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mo mg mh mi bi translated">更新应用程序</li></ol><h1 id="033b" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">1.建立基础设施</h1><p id="e3e7" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">我们看到了Kubernetes的许多组件，它们对于确保产品的可操作性是必要的。每一个都有安装指南和建议，但模式通常非常相似:</p><ol class=""><li id="82e5" class="ma mb it js b jt ju jx jy kb mc kf md kj me kn mo mg mh mi bi translated">下载控件二进制文件。</li><li id="22db" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mo mg mh mi bi translated">验证kubectl可以到达适当的集群。</li><li id="345c" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mo mg mh mi bi translated">ku bectl apply-f<a class="ae ko" href="https://dependency/spec.yaml" rel="noopener ugc nofollow" target="_blank">https://dependency/spec . YAML</a>或者使用二进制来创建资源。</li><li id="f1fd" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mo mg mh mi bi translated">验证部署是否在适当的安全环境中完成，是否按预期运行。</li></ol><p id="be41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Heroku的要求更简单:创建一个帐户，下载heroku cli，然后就完成了！请记住，PaaS的一大优势是验证和安装(所有这些您必须自己用Kubernetes完成的步骤)已经为您完成了。</p><p id="d91e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些步骤为您的应用在任一环境中提供核心基础设施服务，例如TLS和流量管理、可扩展性、可观察性和可重复性。</p><h1 id="9221" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">2.转换应用程序</h1><p id="3cf1" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">既然我们已经确定了每个环境如何寻找我们的示例应用程序，我们可以看看我们需要如何调整应用程序以在新的PaaS环境中工作。因为许多组件是以我们的名义实现的，所以在我们部署应用程序之前需要进行一些必要的转换。</p><p id="d1dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些步骤将确保我们可以将应用程序部署为一个容器，在stdout中查看应用程序日志，在运行时远程登录到容器，并从基础设施中为应用程序定制参数。</p><p id="67f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们必须更改Dockerfile文件。对于在初始化时定义我们的应用程序的Kubernetes Dockerfile，我们很大程度上可以随心所欲地设计它:</p><pre class="lt lu lv lw gt mp mq mr ms aw mt bi"><span id="f767" class="mu kq it mq b gy mv mw l mx my">FROM python:3</span><span id="4402" class="mu kq it mq b gy mz mw l mx my">WORKDIR /usr/src/app</span><span id="bd4f" class="mu kq it mq b gy mz mw l mx my">COPY requirements.txt ./</span><span id="3759" class="mu kq it mq b gy mz mw l mx my">RUN pip install — no-cache-dir -r requirements.txt</span><span id="7972" class="mu kq it mq b gy mz mw l mx my">RUN touch /tmp/healthy &amp;&amp; echo “healthy” &gt;&gt; /tmp/healthy &amp;&amp; cat /tmp/healthy</span><span id="6034" class="mu kq it mq b gy mz mw l mx my">ENV FLASK_ENV=development</span><span id="9bb9" class="mu kq it mq b gy mz mw l mx my">ENV FLASK_APP=myapp.py</span><span id="d9bf" class="mu kq it mq b gy mz mw l mx my">COPY myapp.py .</span><span id="fdcf" class="mu kq it mq b gy mz mw l mx my">CMD [ “flask”, “run”, “ — host=0.0.0.0” ]</span></pre><p id="1a89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个映像很简单:使用一个维护的基本映像，设置一个工作目录，添加python需求，设置一些默认的环境变量，添加应用程序代码，然后启动服务器。</p><p id="f4c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在后面的步骤中，我们将使用这个Docker文件来构建我们的应用程序，将它推送到Docker注册表，并让Kubernetes将图像拉至其本地服务器来启动应用程序。</p><p id="3f30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Heroku中，由于我们希望使用特定于Python的基本映像，我们必须为Heroku的容器管理接口添加一些包。我们的新docker文件如下所示:</p><pre class="lt lu lv lw gt mp mq mr ms aw mt bi"><span id="2249" class="mu kq it mq b gy mv mw l mx my">FROM python:3</span><span id="69bb" class="mu kq it mq b gy mz mw l mx my">WORKDIR /usr/src/app</span><span id="76d1" class="mu kq it mq b gy mz mw l mx my">COPY requirements.txt ./</span><span id="c1db" class="mu kq it mq b gy mz mw l mx my">RUN pip install — no-cache-dir -r requirements.txt</span><span id="ddaa" class="mu kq it mq b gy mz mw l mx my">RUN apt-get update &amp;&amp; \</span><span id="f4c9" class="mu kq it mq b gy mz mw l mx my">   apt-get install -y \</span><span id="1ff4" class="mu kq it mq b gy mz mw l mx my">   curl \</span><span id="03c9" class="mu kq it mq b gy mz mw l mx my">   openssh-server</span><span id="b053" class="mu kq it mq b gy mz mw l mx my">ADD ./.profile.d /app/.profile.d</span><span id="fecf" class="mu kq it mq b gy mz mw l mx my">RUN rm /bin/sh &amp;&amp; ln -s /bin/bash /bin/sh</span><span id="07f8" class="mu kq it mq b gy mz mw l mx my">RUN echo “healthy” &gt;&gt; /tmp/healthy &amp;&amp; \</span><span id="2626" class="mu kq it mq b gy mz mw l mx my">   cat /tmp/healthy</span><span id="b681" class="mu kq it mq b gy mz mw l mx my">ENV FLASK_ENV=development</span><span id="6f74" class="mu kq it mq b gy mz mw l mx my">ENV FLASK_APP=myapp.py</span><span id="4a6c" class="mu kq it mq b gy mz mw l mx my">COPY myapp.py .</span><span id="007c" class="mu kq it mq b gy mz mw l mx my">CMD python3 myapp.py</span></pre><p id="ee69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们定义了和以前一样的图像，但是做了一些调整。</p><ul class=""><li id="640b" class="ma mb it js b jt ju jx jy kb mc kf md kj me kn mf mg mh mi bi translated">首先，我们有了一个新的apt-get安装系列，将curl和ssh添加到我们的映像中。我们还添加了一个脚本(heroku-exec.sh)来定义ssh环境:</li></ul><p id="1003" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe na nb nc mq b">[ -z "$SSH_CLIENT" ] &amp;&amp; source &lt;(curl --fail --retry 3 -sSL "$HEROKU_EXEC_URL")</code></p><ul class=""><li id="a942" class="ma mb it js b jt ju jx jy kb mc kf md kj me kn mf mg mh mi bi translated">然后，我们必须通过将/bin/bash链接到/bin/sh来显式声明我们的默认shell。</li><li id="deff" class="ma mb it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">接下来，我们必须通过在myapp.py文件中指定flask运行时参数来更改映像的实例化方式，以便我们可以使用Heroku定义的环境变量来允许应用程序在部署后接受流量。</li></ul><pre class="lt lu lv lw gt mp mq mr ms aw mt bi"><span id="8ff5" class="mu kq it mq b gy mv mw l mx my">if __name__ == “__main__”:</span><span id="2cf8" class="mu kq it mq b gy mz mw l mx my">   port = int(os.getenv(“PORT”, 5000))</span><span id="c2ab" class="mu kq it mq b gy mz mw l mx my">   app.run(debug=True, host=’0.0.0.0', port=port)</span></pre><p id="fdc6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后要考虑的是数据库。有了Kubernetes，我们可以利用其可替换的容量来托管<a class="ae ko" href="https://wiki.postgresql.org/wiki/Replication,_Clustering,_and_Connection_Pooling" rel="noopener ugc nofollow" target="_blank">集群或复制数据库</a>，以防止损坏或节点故障。我们必须使用<a class="ae ko" href="https://hub.helm.sh/charts/bitnami/postgresql" rel="noopener ugc nofollow" target="_blank">掌舵图</a>，从头开始设计数据库架构，或者为我们的数据库使用外部托管解决方案。</p><p id="c932" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，在使用托管服务时，这不是必需的。有了Heroku，我们只需通过我们的仪表板添加托管数据库。复制和弹性成为提供商需要管理的问题。</p><p id="4886" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(请记住，在这两种数据库实施中，复制和恢复能力都不能替代经过测试的备份！始终备份和验证您的核心数据。)</p><p id="9565" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，我们就有了可以部署的应用程序容器映像和数据库。</p><h1 id="4802" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">3.运行应用程序</h1><p id="0115" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">假设我们已经安装了核心基础设施、为我们的集群配置了数据库，以及与我们的服务帐户相关联的适当的基于角色的访问控制(RBAC)配置，我们现在可以专注于应用程序部署了。</p><p id="836b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的示例中，我们没有明确定义CI/CD管道。因此，要将我们的应用程序手动部署到Kubernetes，我们必须使用kubectl二进制文件执行以下操作:</p><pre class="lt lu lv lw gt mp mq mr ms aw mt bi"><span id="dbe6" class="mu kq it mq b gy mv mw l mx my">docker login</span><span id="3966" class="mu kq it mq b gy mz mw l mx my">docker build -t myorg/myapp:0.0.1 -t myorg/myapp:latest .</span><span id="b52f" class="mu kq it mq b gy mz mw l mx my">docker push myorg/myapp:0.0.1; docker push myorg/myapp:latest</span><span id="fe6c" class="mu kq it mq b gy mz mw l mx my">kubectl apply -f ./spec/</span></pre><p id="697b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所看到的，一旦我们部署了核心基础设施并验证了YAMLs，手动将代码滚动到我们的Kubernetes集群并不困难。</p><p id="35bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过查看Heroku的部署方案，我们有了他们自己的定制二进制文件，我们可以用它与他们的API进行交互。</p><pre class="lt lu lv lw gt mp mq mr ms aw mt bi"><span id="cbe6" class="mu kq it mq b gy mv mw l mx my">heroku login</span><span id="873b" class="mu kq it mq b gy mz mw l mx my">heroku container:login</span><span id="c0db" class="mu kq it mq b gy mz mw l mx my">heroku container:push web -a myapp</span><span id="f0d4" class="mu kq it mq b gy mz mw l mx my">heroku container:release web -a myapp</span></pre><p id="5548" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们相信Heroku对我们的应用程序的标记和部署，而不是使用我们自己的标记和发布功能——尽管它在很大程度上与手动发布的严格程度相同。</p><p id="a760" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">公平地说，构建在任一平台中的部署和发布管道可能会完全混淆所有这些工作；然而，这也必须在任一环境中进行设计、构建和维护。</p><p id="34cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，我们已经定义了在两种环境中部署应用程序的流程。</p><h1 id="3733" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">4.更新应用程序</h1><p id="4e66" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">当将一个已经存在的应用程序部署到Kubernetes中时，您将使用不同的命令而不是<code class="fe na nb nc mq b">apply</code>:</p><pre class="lt lu lv lw gt mp mq mr ms aw mt bi"><span id="0978" class="mu kq it mq b gy mv mw l mx my">docker build -t myorg/myapp:0.0.2 -t myorg/myapp:latest .</span><span id="9a8d" class="mu kq it mq b gy mz mw l mx my">kubectl rollout deployment/myapp -n myapp --record --image=myapp:0.0.2</span></pre><p id="37c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于Heroku，我们只需再次遵循相同的流程:</p><pre class="lt lu lv lw gt mp mq mr ms aw mt bi"><span id="99eb" class="mu kq it mq b gy mv mw l mx my">heroku container:push web -a myapp</span><span id="792a" class="mu kq it mq b gy mz mw l mx my">heroku container:release web -a myapp</span></pre><p id="ace3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过这最后一步，我们有了一个将应用程序迭代部署到环境中的过程。</p><h1 id="d94d" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h1><p id="0428" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">莎士比亚写道:“玫瑰无论叫什么名字，闻起来都一样香。”同样，我们的应用程序在任何容器化的环境中都是一样的，无论是Capulet还是Montague，因为不是应用程序本身需要符合，而是它的环境需要符合。</p><p id="5ea8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了我们拙劣的类比，我们还探索了在复杂且高度可定制的Kubernetes环境中运行一个简单的应用程序需要什么，以及从我们的托管基础架构提供商Heroku获得相同级别的功能需要什么。最后，两者都很容易部署和运行，但Heroku在入门的先决条件方面被证明要简单得多。</p></div></div>    
</body>
</html>