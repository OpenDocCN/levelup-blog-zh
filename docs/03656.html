<html>
<head>
<title>How to Create a Threaded Web Scanner in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python创建线程化Web扫描器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-threaded-web-scanner-in-python-de954d31b042?source=collection_archive---------8-----------------------#2020-05-21">https://levelup.gitconnected.com/how-to-create-a-threaded-web-scanner-in-python-de954d31b042?source=collection_archive---------8-----------------------#2020-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d042" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个简单的项目，大约100行代码就可以完成。</h2></div><p id="0703" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python的伟大之处在于，它让开发人员的生活变得简单——导入几个库来为您完成困难的工作，然后您就可以开始比赛了。这适用于创建能够进行多个并发请求的线程化web扫描器——使用Python很容易在很短的开发时间内完成。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/d0983e50002ceb276a909e43c0e0d420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5WZSjV65XXUrmP1X90GMnw.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">在<a class="ae lr" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae lr" href="https://unsplash.com/@amir_v_ali?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> amirali mirhashemian </a>拍摄的照片</figcaption></figure><p id="4137" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将解释如何用Python创建一个使用<a class="ae lr" href="https://urllib3.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> urllib3 </a>的线程web扫描器，这是一个强大的线程安全HTTP客户端，可以通过pip安装。在这里，我将主要关注这个库的用法以及如何实现线程。像参数解析和IO这样普通的方面可以在我将在底部分享的完整脚本中看到。所有这些都可以在大约100行内完成，这使得它成为一个快速完成的项目。</p><p id="a97b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该脚本将接受一个参数或主机列表，加上一个要搜索的路径列表，然后输出基于目标<a class="ae lr" href="https://www.restapitutorial.com/httpstatuscodes.html" rel="noopener ugc nofollow" target="_blank"> HTTP状态代码</a>找到匹配的结果。这使得查看给定站点上存在(HTTP 200)或缺少(HTTP 404)什么文件和文件夹变得容易。这有助于在迁移网站后或作为日常维护的一部分来检测断开的链接和丢失的资源。</p><p id="0984" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Web扫描也有安全应用程序，其中扫描器可用于检测公众不应访问的资源，执行应用程序指纹识别，甚至通过向端点发出多个带参数的请求来检测像<a class="ae lr" href="https://www.w3schools.com/sql/sql_injection.asp" rel="noopener ugc nofollow" target="_blank"> SQL注入</a>这样的事情，直到抛出HTTP 500，通过触发错误来指示成功的注入。</p><p id="11cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，如果您想要一种自动化且高效的方式来对web服务器执行操作，这就是您的起点。</p><h1 id="bbfc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">管理连接</h1><p id="2077" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">在urllib3中，到单个主机的连接由一个<a class="ae lr" href="https://urllib3.readthedocs.io/en/1.5/pools.html" rel="noopener ugc nofollow" target="_blank">连接池</a>管理。多个池由一个<a class="ae lr" href="https://urllib3.readthedocs.io/en/1.5/managers.html" rel="noopener ugc nofollow" target="_blank">池管理器</a>管理。这些较高级别的抽象让您可以提供传递给较低级别的kwargs，从而使整个堆栈易于从PoolManager级别进行实例化。控制并发性、超时、标头、代理配置等的参数。都可以在一个地方完成。如果您想深入了解可以配置的内容或了解特定参数的作用，请参考<a class="ae lr" href="https://urllib3.readthedocs.io/en/latest/reference/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="e5e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将使用一个名为<code class="fe mp mq mr ms b">THREADS</code>的常量来指定可以同时活动的池<code class="fe mp mq mr ms b">num_pools</code>和同时连接<code class="fe mp mq mr ms b">maxsize</code>的(最大)数量。我还设置了<code class="fe mp mq mr ms b">block=True</code>，这将导致这些限制在线程场景中被全局强制执行。这样做可以有效地定义可以同时处于活动状态的最大并发连接数。这将使我们的扫描器高效，无论它是向十台主机发出一个请求，还是向一台主机发出十个请求，或者是两者的大倍数(不会导致泛滥)。</p><p id="59bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看到目前为止我们在代码中讨论了什么:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="faaf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经配置了我们的<code class="fe mp mq mr ms b">http</code>池管理器，这样它将自我管理到多个主机的并发连接，我们还设置了超时，允许每次尝试连接重试一次，并指定我们不希望它跟随重定向。我们将通过这个池开始我们所有的连接。</p><h1 id="b534" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">提出请求</h1><p id="cc2c" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">提出请求相当简单。我将把逻辑放在一个简单的函数中，该函数接受一个URL并返回URL的元组和结果状态代码。我们将在线程化时调用这个函数:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3ee6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我对异常处理非常宽容。请求可能会因为主机关闭、TLS错误*、超时等而失败。随意实现urllib3拥有的许多异常类型。您还可以采用一种更通用的方法<a class="ae lr" href="https://stackoverflow.com/questions/9823936/python-how-do-i-know-what-type-of-exception-occurred" rel="noopener ugc nofollow" target="_blank">,这种方法仍然可以提供一个健壮的错误输出。在开始扫描以忽略任何无法到达的主机之前，检查所有目标主机是否都已启动也是有意义的。您也可以在出现一定数量的错误后放弃扫描主机——只要确保您以</a><a class="ae lr" href="http://effbot.org/pyfaq/what-kinds-of-global-value-mutation-are-thread-safe.htm" rel="noopener ugc nofollow" target="_blank">线程安全的方式</a>实现这一点。</p><p id="e898" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其次，请注意，我正在使用<code class="fe mp mq mr ms b">functools</code>将<code class="fe mp mq mr ms b">flush=True</code>参数分配给脚本中所有的<code class="fe mp mq mr ms b">print()</code>调用。这是为了有效地关闭输出缓冲，以便我们在线程化环境中看到扫描的实时进度。</p><p id="d6ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总而言之，一个简单的函数——使用<code class="fe mp mq mr ms b">http</code> PoolManager来处理我们的连接，捕捉一些错误，然后返回结果。现在是并行运行的时候了。</p><p id="9ed7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mv">*如果您特别想忽略证书错误，请查看</em><a class="ae lr" href="https://stackoverflow.com/questions/18061640/ignore-certificate-validation-with-urllib3" rel="noopener ugc nofollow" target="_blank"><em class="mv"/></a><em class="mv"/><code class="fe mp mq mr ms b"><em class="mv">urllib3.disable_warnings()</em></code><em class="mv">，并注意，由于urllib3处理kwargs的方式，您可能需要将HTTP和HTTPS连接分成两个不同的池。</em></p><h1 id="fed8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">穿线</h1><p id="d7f3" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">让我们直接进入代码:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f516" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我喜欢Python。那不是很容易吗？一次导入，三行代码，我们从上面并行运行我们的<code class="fe mp mq mr ms b">request()</code>函数。幸运的是，urllib3足够智能，可以根据我们初始化它的方式来控制和管理来自线程的web请求。注意，上面的<code class="fe mp mq mr ms b">THREADS</code>常量在这里再次被用来设置工人计数。<code class="fe mp mq mr ms b">executor.map</code>有效地为<code class="fe mp mq mr ms b">urls</code>列表中的每个条目调用<code class="fe mp mq mr ms b">request()</code>，并产生一个生成器，该生成器将输出保留调用顺序的结果。最后一行将导致我们的脚本等待线程完成后再继续。</p><p id="ff03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应该注意的是，如果试图通过ctrl+c提前中止扫描，脚本将有效地挂起，直到完成和/或您终止相关的进程。这个<a class="ae lr" href="https://stackoverflow.com/questions/29177490/how-do-you-kill-futures-once-they-have-started" rel="noopener ugc nofollow" target="_blank">可以搞定</a>，但是TL；它的缺点是有点尴尬，并且会涉及一些重构——我选择不麻烦。</p><h1 id="1aac" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">将它投入使用</h1><p id="3c44" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">首先，你如何知道这是否正常工作。它实际上是在并行运行<code class="fe mp mq mr ms b">THREADS</code>个连接吗？我做的是启动一个简单的PHP服务器，上面有一个<code class="fe mp mq mr ms b">sleep.php</code>文件，它会休眠5秒钟然后返回。给定<code class="fe mp mq mr ms b">request()</code>中的<code class="fe mp mq mr ms b">print()</code>调试语句，很容易在扫描运行时跟踪进度，调整一些变量，并实时查看发生了什么。您可以通过为<code class="fe mp mq mr ms b">example0.com, example1.com… example9.com</code>创建本地DNS条目来模拟多个主机，所有条目都指向一个本地主机服务器，这样您就不会以调试流量淹没一个活动站点而告终。您还可以通过多次请求同一个睡眠文件，在单个示例主机上测试线程。</p><p id="587e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个完整的脚本扫描10个“主机”的例子，每个主机扫描两个文件，一个不存在，另一个休眠5秒。它被设置为只报告找到的文件(即HTTP 200，省略HTTP 404):</p><pre class="lc ld le lf gt mw ms mx my aw mz bi"><span id="0377" class="na lt iq ms b gy nb nc l nd ne">$ time python pywebscan.py hosts.txt paths.txt<br/>Scanning 10 host(s) for 2 path(s) - 20 requests total...</span><span id="fbcd" class="na lt iq ms b gy nf nc l nd ne">------ REQUESTS ------</span><span id="488a" class="na lt iq ms b gy nf nc l nd ne"><a class="ae lr" href="http://example0.com/pywebscan-test/does_not_exist.txt" rel="noopener ugc nofollow" target="_blank">http://example0.com/pywebscan-test/does_not_exist.txt</a> 404<br/><a class="ae lr" href="http://example2.com/pywebscan-test/does_not_exist.txt" rel="noopener ugc nofollow" target="_blank">http://example2.com/pywebscan-test/does_not_exist.txt</a> 404<br/>...<br/><a class="ae lr" href="http://example0.com/pywebscan-test/sleep.php" rel="noopener ugc nofollow" target="_blank">http://example0.com/pywebscan-test/sleep.php</a> 200<br/><a class="ae lr" href="http://example3.com/pywebscan-test/sleep.php" rel="noopener ugc nofollow" target="_blank">http://example3.com/pywebscan-test/sleep.php</a> 200<br/>...</span><span id="e2d2" class="na lt iq ms b gy nf nc l nd ne">------ RESULTS ------</span><span id="b782" class="na lt iq ms b gy nf nc l nd ne"><a class="ae lr" href="http://example0.com/pywebscan-test/" rel="noopener ugc nofollow" target="_blank">http://example0.com/pywebscan-test/</a><br/>---<br/><a class="ae lr" href="http://example0.com/pywebscan-test/sleep.php" rel="noopener ugc nofollow" target="_blank">http://example0.com/pywebscan-test/sleep.php</a> 200</span><span id="eace" class="na lt iq ms b gy nf nc l nd ne">...</span><span id="8c8d" class="na lt iq ms b gy nf nc l nd ne"><a class="ae lr" href="http://example9.com/pywebscan-test/" rel="noopener ugc nofollow" target="_blank">http://example9.com/pywebscan-test/</a><br/>---<br/><a class="ae lr" href="http://example9.com/pywebscan-test/sleep.php" rel="noopener ugc nofollow" target="_blank">http://example9.com/pywebscan-test/sleep.php</a> 200</span><span id="82d4" class="na lt iq ms b gy nf nc l nd ne">------ SCAN COMPLETE ------</span><span id="ef76" class="na lt iq ms b gy nf nc l nd ne">real    0m5.193s<br/>user    0m0.000s<br/>sys     0m0.000s</span></pre><p id="30e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整个过程只用了5秒多一点的时间就完成了，您会注意到请求响应并不是基于主机名的顺序响应，所以线程正在工作。由于睡眠，如果连续进行，可能需要50多秒。将我们的<code class="fe mp mq mr ms b">THREADS</code> const设置为1证实了这一点:</p><pre class="lc ld le lf gt mw ms mx my aw mz bi"><span id="d7e7" class="na lt iq ms b gy nb nc l nd ne">$ time python pywebscan.py hosts.txt paths.txt<br/>Scanning 10 host(s) for 2 path(s) - 20 requests total...</span><span id="ef33" class="na lt iq ms b gy nf nc l nd ne">...</span><span id="c251" class="na lt iq ms b gy nf nc l nd ne">------ SCAN COMPLETE ------</span><span id="e2e0" class="na lt iq ms b gy nf nc l nd ne">real    0m50.309s<br/>user    0m0.000s<br/>sys     0m0.015s</span></pre><p id="904a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">概念得到验证。请随意测试其他场景(如大量请求和各种请求组合)，以确保您的实现一切正常。</p><h1 id="81ca" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">完整的脚本</h1><p id="5848" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这里可以找到<a class="ae lr" href="https://github.com/kld87/pywebscan/blob/master/pywebscan.py" rel="noopener ugc nofollow" target="_blank">。它很简单，只有两个参数——主机或主机文件，外加一个路径文件。线程计数、超时等参数。只是硬编码到脚本中——很容易根据需要转换成CLI参数。有一些逻辑来处理主机和路径解析、输出格式化，并没有涉及太多其他内容。根据需要精简和适应。</a></p><h1 id="1572" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">后续步骤和高级用法</h1><p id="1a64" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">到目前为止，我已经提到了几个可以改进的地方:更好的错误处理，优雅的中止行为，以及更多通过参数定制的功能。以下是需要考虑的其他几点:</p><ol class=""><li id="0625" class="ng nh iq kh b ki kj kl km ko ni ks nj kw nk la nl nm nn no bi translated">处理和跟踪重定向——为了简单起见，我已经把它们关掉了。许多水疗应用程序可能会使用。htaccess将所有“未找到”的请求通过管道传输到单个入口点，这在扫描期间允许重定向时会导致一些奇怪的结果。重定向也可以用于将HTTP流量发送到HTTPS，并且有多种类型的重定向和重写类型可以使用。对于您的用例，请记住这一点。</li><li id="ba72" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">Python使得反向dns查找<a class="ae lr" href="http://searchsignals.com/tutorials/reverse-dns-lookup/#pythonic-reverse-ip-lookups" rel="noopener ugc nofollow" target="_blank">变得相当容易。将IP转换成主机名。如果您使用IP列表，尤其是涉及虚拟主机和/或HTTPS时，这可能会很有用。</a></li><li id="0c83" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated"><code class="fe mp mq mr ms b">request()</code>函数获得整个响应，而不仅仅是状态代码。你可以解析它，搜索内容，提取链接等等。</li><li id="d028" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">您可以将urllib3配置为<a class="ae lr" href="https://urllib3.readthedocs.io/en/latest/advanced-usage.html#proxies" rel="noopener ugc nofollow" target="_blank">使用代理</a>，如果需要，还可以指定用户代理。</li><li id="2904" class="ng nh iq kh b ki np kl nq ko nr ks ns kw nt la nl nm nn no bi translated">您可以调整<code class="fe mp mq mr ms b">THREADS</code>参数来增加并发连接的数量——只是在这样做的时候要注意套接字/资源的使用——并且尽量不要一次将太多的连接发送到一台主机。</li></ol><h1 id="066f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">包扎</h1><p id="6f18" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在你有了它——一个线程化的Python web扫描器，大约有100行代码，其中大部分是用来处理执行流的。无论您的使用情形是什么，它都是通用的并且易于扩展。我们已经看到<a class="ae lr" href="https://urllib3.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> urllib3 </a>非常强大而且易于使用，Python的<a class="ae lr" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" rel="noopener ugc nofollow" target="_blank"> ThreadPoolExecutor </a>使线程化变得轻而易举。如果你对Python中的并行性感兴趣，我推荐你阅读这篇文章，这篇文章从较高的层面对理论和不同的方法进行了分解。</p><p id="36d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢这篇文章，我最近写了一篇类似的文章，关于如何<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/how-to-build-a-diy-web-scraper-in-any-language-1104ac0713cd">创建一个DIY的web scraper </a>来抓取和提取你可能会发现有用的网站信息。</p></div></div>    
</body>
</html>