<html>
<head>
<title>Tips for Mocking Code in Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试中模仿代码的技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/some-tips-for-mocking-code-in-tests-f46bc9499767?source=collection_archive---------8-----------------------#2019-12-19">https://levelup.gitconnected.com/some-tips-for-mocking-code-in-tests-f46bc9499767?source=collection_archive---------8-----------------------#2019-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e5b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">模仿很棒。直到他们不再是。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0a69e3772f389644d2a094a6e9448b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zE9Ynlg1Pb9yx2cschuFYA.png"/></div></div></figure><p id="0cad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你第一次学习如何测试你的代码时，<a class="ae lq" href="https://www.telerik.com/products/mocking/unit-testing.aspx" rel="noopener ugc nofollow" target="_blank">嘲讽看起来很神奇</a>。但是它是如此强大的一个特性，以至于不管使用什么语言，它都有被滥用的趋势。作为一名初级开发人员，我不得不修正许多模糊且无用的测试，这里是我在这个过程中获得的一些智慧。</p><h1 id="1ec5" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">尽量减少模拟功能</h1><p id="6e54" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">“我没有测试<code class="fe mo mp mq mr b">function X</code>，所以当我在<code class="fe mo mp mq mr b">function Y</code>中调用<code class="fe mo mp mq mr b">X</code>时，我可以只模拟返回值！”这是一个常见的场景，但可能不是一个好主意。假设<code class="fe mo mp mq mr b">function X</code>在别处得到严格的单元测试可能是一个错误。我在<strong class="kw iu"> </strong> <code class="fe mo mp mq mr b">function Y</code>看到bug弹出的次数是因为<strong class="kw iu"> </strong>在<strong class="kw iu"> </strong> <code class="fe mo mp mq mr b">function X</code> <strong class="kw iu"> </strong>没有被抓到是<em class="ms">虚幻</em>。</p><p id="3a75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">测试应该让你相信改变不会破坏现有的架构。它们就像一个免费的迷你问答环节。但是，如果你过度使用嘲笑，那么你就不会那么自信；您实际上忽略了大量代码。即使一切都测试得很好，也永远不会是完美的。而且太多的模仿会在你的代码中引入漏洞，而这些漏洞是bug乐于安家的。只有在必要的时候才模仿，并确保你模仿的函数在别处测试过。</p><h1 id="4302" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">对函数的模拟调用</h1><p id="4088" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">假设我们正在测试一个内部有API调用的函数:</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="46e1" class="mx ls it mr b gy my mz l na nb">// makes an API request and returns result<br/>const <strong class="mr iu">getUsers </strong>= () =&gt; {<br/>   ...<br/>}</span><span id="c2fc" class="mx ls it mr b gy nc mz l na nb">// returns array of user names or 'nobody here'<br/>const<em class="ms"> </em><strong class="mr iu">displayNames </strong>=<strong class="mr iu"> </strong>() =&gt; {<br/>  const <strong class="mr iu">users</strong> = <strong class="mr iu">getUsers</strong>();<br/>  if (<strong class="mr iu">users.</strong>length) {<br/>    return <strong class="mr iu">users</strong>.map(<strong class="mr iu">user</strong> =&gt; <strong class="mr iu">user</strong>.name);   <br/>  } <br/>  return ["<em class="ms">Nobody here</em>"];<br/>}</span></pre><p id="0b16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">给定这个伪代码，我们有两个主要选择:模仿<code class="fe mo mp mq mr b">getUsers</code>返回值或其中的API请求。嘲笑<code class="fe mo mp mq mr b">getUsers</code>很有诱惑力，大多数测试套件都很容易做到这一点。然而，这意味着对<code class="fe mo mp mq mr b">getUsers</code> <strong class="kw iu">的任何实际代码更改都不会影响这个测试。</strong></p><h2 id="89d0" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">在请求级别嘲笑</h2><p id="e91f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">如果您模拟网络响应本身，就没有必要担心被跳过的更改。<code class="fe mo mp mq mr b">getUsers</code>将进行常规的API调用并接收响应，而不知道它得到了一个模仿。如果你使用类似于<a class="ae lq" href="https://developer.mozilla.org/en/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> fetch API </a>的东西进行异步调用，有一些库可以让<a class="ae lq" href="https://www.npmjs.com/package/fetch-mock" rel="noopener ugc nofollow" target="_blank">轻松地模仿</a>。</p><p id="3b06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">主要的缺点是，通常需要更长的时间来建立测试套件，以有效地模拟服务器调用。如果你有时间，努力是值得的。然而，情况可能并不总是如此。所以，如果你有来模仿函数，那么至少:</p><h1 id="9234" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">使用“真实的”模拟数据</h1><p id="230e" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><strong class="kw iu"> <em class="ms">模拟数据应该总是与真实世界数据</em> </strong>相匹配。无论模拟值是什么，都不要弄乱数据的形状:</p><pre class="kj kk kl km gt mt mr mu mv aw mw bi"><span id="6509" class="mx ls it mr b gy my mz l na nb">// real data always sent by API: <br/>{<br/>  id: 1,<br/>  name: "Tom",<br/>  age: 23,<br/>  height: 75,<br/>  bio: "I'm a nice person."<br/>}</span><span id="a79a" class="mx ls it mr b gy nc mz l na nb">// "Test" version<br/>{<br/>  id: 0,<br/>  name: "Tom",<br/>  age: "some age"<br/>}</span></pre><p id="42eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">测试版本可能会导致问题。有一个奇怪的id 0，一个在现实世界中是数字<strong class="kw iu">的年龄</strong>，一个在测试中是字符串<strong class="kw iu">的年龄</strong>，它完全没有属性。</p><h2 id="9575" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">错误的数据意味着假阴性</h2><p id="3f83" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">当测试仓促进行时，不完整的模拟值是常见的。当有人通过检查一些属性的存在来“证明”一个函数有效时，它们就会弹出来，就是这样。然而，如果有一个未来的测试来检查<code class="fe mo mp mq mr b">bio</code>的长度，例如，它会失败，因为<em class="ms">生物错误地不存在。</em>这破坏了新的测试，因为我们依赖的真实世界数据<strong class="kw iu">在测试中不存在。如果数据<em class="ms">总是以某种方式返回</em>，测试应该反映这一点。</strong></p><h2 id="62db" class="mx ls it bd lt nd ne dn lx nf ng dp mb ld nh ni md lh nj nk mf ll nl nm mh nn bi translated">没有免费文档</h2><p id="9994" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">如果代码<a class="ae lq" href="https://itnext.io/tips-for-writing-self-documenting-code-e54a15e9de2" rel="noopener ugc nofollow" target="_blank">使用了错误的数据，那么它就不是自文档化的</a>,坦白地说，它对其他开发人员没有太大的帮助。如果您是代码新手，并且不确定函数应该返回什么，那么检查模拟数据是一个很好的起点。当你修改代码的时候，需要花费更多的精力来维护，但是自信的提升和知识共享带来的好处远远超过了弥补。相信我。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><p id="9f04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">别误会，嘲讽很棒！没有它，测试会运行得更慢，更不可预测。像你腰带上的任何工具一样，当你负责任地使用它时，你会得到最好的结果。</p><p id="0b5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大家编码快乐，</p><p id="396b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">麦克风</p></div></div>    
</body>
</html>