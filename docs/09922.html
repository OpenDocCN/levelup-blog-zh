<html>
<head>
<title>Array Metaprogramming in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的数组元编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/array-metaprogramming-in-typescript-2fe5d5f5c48a?source=collection_archive---------1-----------------------#2021-10-03">https://levelup.gitconnected.com/array-metaprogramming-in-typescript-2fe5d5f5c48a?source=collection_archive---------1-----------------------#2021-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="84f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数TypeScript开发人员很容易注意到他们可以使用泛型类型对数组进行类型化。有没有想过能不能推断出<em class="ko">一个阵</em>的<em class="ko">阵型</em>？或者说，如何根据类型得到<em class="ko">所有数组元素</em>？</p><p id="b305" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你不知道如何做，请继续阅读！</p><p id="3be4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您是更高级的TypeScript开发人员，我也为您准备了一些值得花时间的东西！</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/7c7ba0b6bd04ad6c0a1501018569baf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4-_0KcbRuh0SFk0S"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">照片由<a class="ae lf" href="https://unsplash.com/@noah_negishi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">诺亚根岸</a>在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="b569" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">数组中的数组类型</h1><p id="77f7" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">推断特定数组的数组类型是更高级元编程的基础。如果你是初学者(这没什么不好，大家都是从头开始！)，你可能会尝试以下列方式:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="afcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是可行的，因为<code class="fe ml mm mn mo b">array1</code>的类型是<code class="fe ml mm mn mo b">string[]</code>。由于在获得元素的类型后，仍然将元素推送到<code class="fe ml mm mn mo b">array1</code>，因此TypeScript必须推断它是一个可变数组。从它的初始元素来看，这是一个可变的字符串数组。</p><p id="b0c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想要一个更精确的类型呢？我们需要在不使用<code class="fe ml mm mn mo b">ReadonlyArray&lt;T&gt;</code>类型的情况下使所讨论的数组不可变——否则，我们需要指定数组类型，这没有任何意义。我们应该使用<code class="fe ml mm mn mo b">as const</code>的表达方式:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5cbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ml mm mn mo b">array2</code>的类型是<code class="fe ml mm mn mo b">readonly ['a' | 'b' | 'c']</code>。我们得到了我们想要的，然而，TypeScript也允许我们提取数组元素类型！这需要以下列方式使用<code class="fe ml mm mn mo b">infer</code>关键字:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="25c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ml mm mn mo b">InferRAET</code>(“推断只读数组元素类型”)是一个条件泛型类型。它接受类型<code class="fe ml mm mn mo b">A</code>只是为了检查它是否是<code class="fe ml mm mn mo b">ReadonlyArray</code>类型。</p><p id="307e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用<code class="fe ml mm mn mo b">infer I</code>来标记元素类型以便推断。如果<code class="fe ml mm mn mo b">A</code>是一个<code class="fe ml mm mn mo b">ReadonlyArray</code>类型，则返回推断的元素类型。否则，我们返回<code class="fe ml mm mn mo b">never</code>类型。</p><p id="11c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe ml mm mn mo b">InferREAT</code>后，<code class="fe ml mm mn mo b">ET</code>(元素类型)等于<code class="fe ml mm mn mo b">'a' | 'b' | 'c'</code>，为联合类型。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="29b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你认为使用<code class="fe ml mm mn mo b">InferRAET</code>太复杂，我有个好消息。有一个更简洁的解决方案，它使用索引访问类型:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="803c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ml mm mn mo b">ET</code>等于<code class="fe ml mm mn mo b">ET2</code>，因为数组使用数字进行索引。</p><h1 id="9ca6" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">条件类型的分配性</h1><p id="7400" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">如果我们想把只读数组类型改成可写数组类型呢？这种转换似乎可以通过一行代码实现，如下所示:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="b2a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ml mm mn mo b">TransformRA2WA</code>类型将只读数组转换为可写数组。如您所见，类型<code class="fe ml mm mn mo b">RA1</code>和<code class="fe ml mm mn mo b">RA2</code>是不同的，它们的转换类型<code class="fe ml mm mn mo b">WA1</code>和<code class="fe ml mm mn mo b">WA2</code>也是不同的。</p><p id="6030" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了检查类型的相等性，我使用了来自<code class="fe ml mm mn mo b">ts-essentials</code>库中的<code class="fe ml mm mn mo b">Exact</code>类型。<code class="fe ml mm mn mo b">E1</code>和<code class="fe ml mm mn mo b">E2</code>都等于<code class="fe ml mm mn mo b">never</code>，表示测试的类型不准确。</p><p id="652f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当处理条件类型时，TypeScript对泛型联合类型应用分布。这就是前面代码片段中缺少类型相等的原因。这个语言特性在这里有很好的描述<a class="ae lf" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="eacc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们想在示例中禁用分发，我们需要执行以下操作:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a3e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，<code class="fe ml mm mn mo b">TransformRA2WAND</code>(“将只读数组转换为可写数组，无分布”的简化名称)与<code class="fe ml mm mn mo b">TransformRA2WA</code>的不同之处仅在于extends表达式的左右两边都有<code class="fe ml mm mn mo b">[]</code>(方括号)。如前所述，<code class="fe ml mm mn mo b">WA3</code>在类型方面等于<code class="fe ml mm mn mo b">WA4</code>。</p><h1 id="a41f" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">数组类型中的所有数组元素</h1><p id="b665" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">如果你曾经尝试过这种转换，你就会知道这不是一件容易的事情。这可以归结为将联合类型转换为元组类型——不幸的是，不存在支持这种转换的TypeScript操作符。如果你想深入了解这个话题，你可以访问这个<a class="ae lf" href="https://github.com/microsoft/TypeScript/issues/13298" rel="noopener ugc nofollow" target="_blank"> GitHub问题</a>。</p><p id="0adb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同时，我将描述以下三种解决这个问题的方法。</p><h2 id="d87f" class="mw lh it bd li mx my dn lm mz na dp lq kb nb nc lu kf nd ne ly kj nf ng mc nh bi translated">解决方案1</h2><p id="fc6c" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">由于联合类型到元组类型的转换仍然很复杂，我们可以将联合作为对象的属性来析构。这是joaopaulobdac在他们的评论中发现的，虽然我不知道他们是否是第一个发现这种方法的人。我们可以很容易地在TypeScript中键入这样一个对象，如下面的代码片段所示:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="34bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会问为什么<code class="fe ml mm mn mo b">ET3KeyToOneDictionary</code>中的值总是设置为<code class="fe ml mm mn mo b">1</code>。它可以被设置为几乎任何值，但是我希望有一个单一的字符值，以节省打字。正如您可能看到的，所提出的方法有两个问题:</p><ul class=""><li id="5880" class="ni nj it js b jt ju jx jy kb nk kf nl kj nm kn nn no np nq bi translated">建造<code class="fe ml mm mn mo b">et3KeyToOneDictionary</code>可能会令人厌倦，</li><li id="5233" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated"><code class="fe ml mm mn mo b">allElements</code>是<code class="fe ml mm mn mo b">string[]</code>型，不是<code class="fe ml mm mn mo b">ET3[]</code>型。</li></ul><h2 id="fd4e" class="mw lh it bd li mx my dn lm mz na dp lq kb nb nc lu kf nd ne ly kj nf ng mc nh bi translated">解决方案2</h2><p id="1677" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">由于第一个解决方案不够简洁，我们需要另一个解决方案。自从<strong class="js iu"> vojtechhabarta </strong>发现我们可以在这里利用枚举<a class="ae lf" href="https://github.com/Microsoft/TypeScript/issues/13298#issuecomment-823206565" rel="noopener ugc nofollow" target="_blank">，我相应地修改了第一个解决方案。以下代码片段提供了结果:</a></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4093" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该代码绝对值得解释。名为<code class="fe ml mm mn mo b">ET4KeyToNumberDictionary</code>的字典类型将联合类型的键映射成数字。我这样做是为了确保<code class="fe ml mm mn mo b">ET4KeyToNumberDictionary</code>匹配下面的<code class="fe ml mm mn mo b">Enum4</code>类型。提取所有枚举键并不容易(您可能想自己检查一下为什么我必须过滤这些键)。</p><p id="5f22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于TypeScript中的枚举不能显式扩展类型，我需要自己确保类型安全。为此，我编写了一个只有两种状态的类型守卫— <code class="fe ml mm mn mo b">0</code>或<code class="fe ml mm mn mo b">1</code>。后者仅在<code class="fe ml mm mn mo b">Enum4</code>在类型级别上扩展<code class="fe ml mm mn mo b">ET4KeyToNumberDictionary</code>时发生。之后，我设置<code class="fe ml mm mn mo b">typeGuard</code>来保存<code class="fe ml mm mn mo b">1</code>作为一个值。</p><p id="e23a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只要类型正确，代码就会编译。你可能想知道我为什么在它的定义后调用<code class="fe ml mm mn mo b">typeGuard</code>。我这样做是为了确保编译器对未使用常量的遵从。</p><h2 id="8f43" class="mw lh it bd li mx my dn lm mz na dp lq kb nb nc lu kf nd ne ly kj nf ng mc nh bi translated">解决方案3</h2><p id="2b95" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated"><strong class="js iu"> karol-majewski </strong>在这里提出了我目前为止看到的最好的解决方案<a class="ae lf" href="https://github.com/Microsoft/TypeScript/issues/13298#issuecomment-654906323" rel="noopener ugc nofollow" target="_blank">。尽管这是一个非常高级的片段，我还是会一步一步地向您介绍。</a></p><p id="5a5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">类型的值</strong></p><p id="fcee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们需要讨论一下<code class="fe ml mm mn mo b">ValueOf</code>泛型类型。由于许多TypeScript开发人员使用它，一些库已经包含了它，<code class="fe ml mm mn mo b">ts-essentials</code>是最显著的例子。正式定义如下:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8ef7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们在一个数组类型上使用<code class="fe ml mm mn mo b">ValueOf</code>会发生什么？</p><p id="e7a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为数组是对象，所以我们得到该对象中所有值的联合类型，尤其是数组方法和所有数组元素类型。</p><p id="f8cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">value of Type和Extends关键字</strong></p><p id="fe42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，我必须解释在<code class="fe ml mm mn mo b">MustInclude</code>型的引擎盖下发生了什么，在我们正在讨论的例子中有详细说明。我将使用下面的片段来解构那里发生的事情:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="37cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ml mm mn mo b">T1</code>是一个比tuple类型更多类型的union类型，称为<code class="fe ml mm mn mo b">U1</code>。因此，<code class="fe ml mm mn mo b">U1</code>扩展<code class="fe ml mm mn mo b">T1[]</code>，同样的方式<code class="fe ml mm mn mo b">'a'</code>扩展<code class="fe ml mm mn mo b">string</code>。起初听起来可能有些违反直觉，但是只有当<code class="fe ml mm mn mo b">a</code>可以被赋值给<code class="fe ml mm mn mo b">string</code>时，<code class="fe ml mm mn mo b">extends</code>关键字才会让编译器进行检查。你可以在这里阅读更多关于它的<a class="ae lf" href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1ae6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上一段解释了为什么<code class="fe ml mm mn mo b">C1</code>等于<code class="fe ml mm mn mo b">1</code>。那<code class="fe ml mm mn mo b">C2</code>呢？<code class="fe ml mm mn mo b">C2</code>也等于<code class="fe ml mm mn mo b">1</code>吗？</p><p id="5522" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它没有！</p><p id="7b75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe ml mm mn mo b">U1</code>是一组字符串，那么<code class="fe ml mm mn mo b">ValueOf&lt;U1&gt;</code>是什么？对于这个表达式，我们可以将<code class="fe ml mm mn mo b">U1</code>视为字符串文字的数组类型。这样的数组在JavaScript中始终是一个对象。</p><p id="d829" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如前所述，应用于对象类型的<code class="fe ml mm mn mo b">ValueOf</code>类型导致所有属性值类型的联合。对于数组类型，这归结为以下内容的联合:</p><ul class=""><li id="ac94" class="ni nj it js b jt ju jx jy kb nk kf nl kj nm kn nn no np nq bi translated">过多的函数类型，</li><li id="f340" class="ni nj it js b jt nr jx ns kb nt kf nu kj nv kn nn no np nq bi translated">数组元素类型。</li></ul><p id="3ad0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ml mm mn mo b">U1</code>的数组元素类型有哪些？必须是<code class="fe ml mm mn mo b">'a'</code>、<code class="fe ml mm mn mo b">'b'</code>和<code class="fe ml mm mn mo b">'c'</code>。我们能至少将<code class="fe ml mm mn mo b">T1</code>赋值给这些元素类型的并集吗？显然不是，因为它们不包含<code class="fe ml mm mn mo b">'d'</code>字符串文字类型。</p><p id="1a3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这证明了为什么<code class="fe ml mm mn mo b">T1</code>没有扩展<code class="fe ml mm mn mo b">ValueOf&lt;U1&gt;</code>，因此<code class="fe ml mm mn mo b">C2</code>等于<code class="fe ml mm mn mo b">0</code>。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="34de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为练习，您可以从<code class="fe ml mm mn mo b">T1</code>中删除<code class="fe ml mm mn mo b">'c' | 'd'</code>，并重新思考之前概述的推理。</p><p id="4dcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">必须包括类型和分布</strong></p><p id="6314" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第三，一个热心的读者一定已经意识到我已经解释了几乎所有关于由<strong class="js iu"> karol-majewski </strong>提供的解决方案的事情。几乎所有的事情，因为<code class="fe ml mm mn mo b">MustInclude</code>类型使用非分配条件类型，由包围在<code class="fe ml mm mn mo b">extends</code>表达式两边的方括号表示。</p><p id="aea4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您可能意识到的，这不是错误，分发必须被禁用。</p><p id="e197" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ml mm mn mo b">MustInclude</code>有两个泛型类型，但只有第一个(<code class="fe ml mm mn mo b">T</code>)是联合类型。这意味着使用distribution，将为每个union元素调用<code class="fe ml mm mn mo b">T extends ValueOf&lt;U&gt;</code>表达式，end类型将是所有这些表达式结果的并集。</p><p id="c046" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以应用这种思想来编写一个模仿这种行为的代码片段:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8ff7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管根据我们从前面的代码片段中了解到的情况，<code class="fe ml mm mn mo b">T1</code>没有扩展<code class="fe ml mm mn mo b">ValueOf&lt;U1&gt;</code>，但是所有<code class="fe ml mm mn mo b">extends</code>表达式的并集(<code class="fe ml mm mn mo b">C</code>)等于<code class="fe ml mm mn mo b">U1</code>。这种情况只发生在应用于任何联合类型的<code class="fe ml mm mn mo b">never</code>类型不会改变它的时候。</p><h1 id="8b77" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">数组类型和数组元素的所有元组元素</h1><p id="bb68" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">由于在某些情况下元组可以用数组来近似，所以我们可以很容易地从元组类型中获取所有元素，并将它们转换为数组类型。请看看下面的片段:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="dab9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过复制元组定义并将其设置为一个值来提取所有元组元素。为了推断tuple中元素的联合类型，我们需要使用之前定义的泛型类型<code class="fe ml mm mn mo b">InferREAT</code>。这是TypeScript将元组转换为(只读)数组以进行推断的时刻。在我们提取了元素类型<code class="fe ml mm mn mo b">ETT1[]</code>之后，我们可以定义数组类型。</p><h1 id="e4c6" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">使用io-ts进行元编程</h1><p id="0cf4" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated"><code class="fe ml mm mn mo b">io-ts</code>库允许软件开发人员为JSON对象的反序列化创建编解码器，还有许多其他用途。它支持许多元编程模式，尤其是在处理数组类型时。我编写了下面的代码片段来展示它的功能示例:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="db98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ml mm mn mo b">codec</code>结构在自身内部编码(无意双关)类型数据，我们可以使用<code class="fe ml mm mn mo b">TypeOf</code>类型提取它们——我建议更高级的TypeScript开发人员阅读控制这种类型提取的代码。完全掌握它并可能在自己的项目中使用相同的模式绝对值得您花费时间。</p><p id="6528" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还可以使用提供的编解码器接口获得所有数组元素(<code class="fe ml mm mn mo b">allElementsFromCodec</code>)。通过定义一个编解码器，我们可以自动获得数组类型及其所有元素。</p><h1 id="3999" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">摘要</h1><p id="7429" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">数组元编程仍然是TypeScript中的一个广泛话题。到目前为止，我们可以很容易地将数组类型与数组元素联系起来，并执行相互推断的操作，反之亦然。我们还观察到，在特定的场景中，数组可以与元组互换使用。</p></div></div>    
</body>
</html>