<html>
<head>
<title>How to specify test order in JUnit 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JUnit 5中指定测试顺序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-specify-test-order-in-junit-5-d3ad597d3036?source=collection_archive---------11-----------------------#2021-06-09">https://levelup.gitconnected.com/how-to-specify-test-order-in-junit-5-d3ad597d3036?source=collection_archive---------11-----------------------#2021-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/52c5bcba3c1dda82fa1d723197ff6ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3WVzZ26RZHrsV-fP"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Nguyen Dang Hoang Nhu 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="11ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当JUnit运行一组测试时，测试通常以看似随机的顺序运行。例如，如果你的测试是A、B、C、D和E，它们可能按照C、A、B、E、D的顺序运行。</p><p id="2233" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于绝大多数项目来说，这样就可以了。毕竟在现实生活中，你并不能总是预测事件会以什么顺序发生。</p><p id="fd8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果您确实需要以特定的顺序运行测试，该怎么办呢？JUnit 5为此提供了一种机制，JUnit 4也是如此(JUnit 3可能也是如此)。在本文中，我将向您展示JUnit 5是如何做到这一点的。</p><p id="4f46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，仍然有很多人在使用JUnit 4，包括我自己(为了我的NetBeans项目)。但是最新版本的Eclipse和IntelliJ IDEA都来自JUnit 5。</p><p id="82b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望您能在自己的计算机上使用您最喜欢的集成开发环境(IDE)。在三个主要的ide中，只有IntelliJ IDEA提供了随需应变的单一测试运行，但是在这种情况下测试顺序并不重要。</p><p id="5e2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将用一个玩具例子来说明这一点。我们测试的类将是一个不必要的计算器。大概是这样的:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="1ad0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将编写一个测试类。没有什么太复杂的，只是对每个函数进行一次测试，只涉及小正整数的简单算术运算。</p><p id="1360" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个玩具示例中，除了说明如何完成之外，没有什么好的理由指定测试顺序。</p><p id="43fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将需要<code class="fe lk ll lm ln b">TestMethodOrder</code>注释，它位于类声明之前。该注释接受一个参数，即一个<code class="fe lk ll lm ln b">MethodOrderer</code>实现的类。</p><p id="0a90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我相信你可以自己写一个，但是<code class="fe lk ll lm ln b">MethodOrderer</code>接口附带了三个嵌套类的实现，对于大多数目的来说已经足够好了。</p><p id="047d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">按字母顺序，三个中的第一个是<code class="fe lk ll lm ln b">Alphanumeric</code>，它使用了测试名称。例如，<code class="fe lk ll lm ln b">testDivide()</code>会在<code class="fe lk ll lm ln b">testMultiply()</code>之前运行。我知道我命名这些测试的方式是JUnit 3的延续，但是我更喜欢这种命名测试的清晰方式。</p><p id="e42b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用<code class="fe lk ll lm ln b">Alphanumeric</code>，我们可能会这样开始我们的测试类:</p><pre class="le lf lg lh gt lo ln lp lq aw lr bi"><span id="df7c" class="ls lt it ln b gy lu lv l lw lx">package calculators;</span><span id="d76e" class="ls lt it ln b gy ly lv l lw lx">import org.junit.jupiter.api.MethodOrderer;<br/>import org.junit.jupiter.api.TestMethodOrder;</span><span id="2f3d" class="ls lt it ln b gy ly lv l lw lx"><strong class="ln iu">@TestMethodOrder(MethodOrderer.Alphanumeric.class)</strong><br/>class UnnecessaryCalculatorTest <strong class="ln iu">{</strong></span><span id="70b8" class="ls lt it ln b gy ly lv l lw lx">    // TODO: Write tests</span><span id="6f73" class="ls lt it ln b gy ly lv l lw lx"><strong class="ln iu">}</strong></span></pre><p id="7467" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我希望它按照源代码的顺序进行，而不必笨拙地命名(例如，<code class="fe lk ll lm ln b">test1Add()</code>、<code class="fe lk ll lm ln b">test2Subtract()</code>等)。).</p><p id="690e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们应该使用<code class="fe lk ll lm ln b">OrderAnnotation</code>，这将要求每个测试除了<code class="fe lk ll lm ln b">Test</code>注释之外还有一个<code class="fe lk ll lm ln b">Order</code>注释。该注释采用单个整数参数，最好是一个小正整数。测试可能是这样的:</p><pre class="le lf lg lh gt lo ln lp lq aw lr bi"><span id="d10b" class="ls lt it ln b gy lu lv l lw lx">    @Test <strong class="ln iu">@Order(1)</strong><br/>    void <strong class="ln iu">testZ()</strong> {<br/>        fail("Just for the sake of example");<br/>    }</span></pre><p id="6be2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果所有其他测试都有参数大于1的<code class="fe lk ll lm ln b">Order</code>注释，<code class="fe lk ll lm ln b">testZ()</code>应该在所有其他测试之前运行，然而它可能是最后一个使用<code class="fe lk ll lm ln b">Alphanumeric</code>的测试。</p><p id="47d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">综上所述，我们有:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="dd1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些应该按以下顺序运行:加、减、乘、除。他们都失败了，但这不是重点。</p><p id="dc91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我提到过,<code class="fe lk ll lm ln b">MethodOrderer</code>接口有三个嵌套类的实现。我还没有提到的是<code class="fe lk ll lm ln b">Random</code>，它可能看起来和平常没什么区别。</p><p id="a760" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它确实在一个重要方面有所不同。如果我们没有指定测试顺序，一组测试运行的顺序似乎是随机的。在我们的计算器例子中，可能是除、加、乘、减。</p><p id="aeee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在不添加或删除测试的情况下重新运行，它们可能会再次以相同的顺序运行。如果我们添加一个测试，新的测试可能会先运行，可能会最后运行，也可能会在中间运行。但是，除了新的测试，测试顺序没有改变。</p><p id="b515" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lk ll lm ln b">Random</code>与通常的不同之处在于，顺序几乎肯定会在运行之间发生变化。更准确地说，它被称为“伪随机”，但在我看来，它足够随机。</p><p id="869b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将上面引用的测试类改为使用<code class="fe lk ll lm ln b">Random</code>而不是<code class="fe lk ll lm ln b">OrderAnnotation</code>，并且移除了<code class="fe lk ll lm ln b">Order</code>注释。如果您在自己的IDE中跟随，我希望您也这样做。</p><p id="4e09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我让JUnit运行测试，它们按照加、乘、除、减的顺序运行。又运行了两次，它们都是加、乘、减、除(真正的随机性意味着有时，但不是很经常，相同的值会连续出现两次)。</p><p id="d881" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一次运行的顺序是乘、除、减、加。最后，乘、加、减、除。好了，说够了，你明白了。</p><p id="5239" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在您知道了如何在JUnit 5中指定测试顺序。</p><p id="058f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我用了一个玩具的例子来演示这个概念，因为我想不出一个现实的例子。如果你能想到一个现实的例子，请告诉我。</p><p id="64bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了玩具的例子，我从来没有需要在我的任何项目中指定测试顺序。</p><p id="3fea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您正在编写可变类，测试可能应该在新的实例上操作。或者，如果您正在编写不可变的类，实例“新鲜度”不是很相关。而且对于只有静态函数的实用程序类来说肯定是不相关的。</p><p id="c6f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一次，当我还是单元测试的新手时，我遇到了一种情况，我认为我需要控制测试顺序。但是，当我想了更多，我意识到我只是需要测试设置和拆除。</p><p id="1478" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JUnit 4提供了<code class="fe lk ll lm ln b">BeforeClass</code>、<code class="fe lk ll lm ln b">Before</code>、<code class="fe lk ll lm ln b">After</code>和<code class="fe lk ll lm ln b">AfterClass</code>注释。JUnit 5也有类似的注释。</p><p id="d0b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我把<code class="fe lk ll lm ln b">TestMethodOrder</code>放在“很高兴知道”下面，即使我不知道我是否真的需要它。</p><p id="c8e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑测试顺序是否与特定的测试类相关是绝对值得的，即使您认为通常的JUnit顺序是合适的。</p></div></div>    
</body>
</html>