<html>
<head>
<title>Exploring the Different Methods of Garbage Collection in Programming Languages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索编程语言中不同的垃圾收集方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/garbage-collectors-6ea8f00153f0?source=collection_archive---------11-----------------------#2022-12-27">https://levelup.gitconnected.com/garbage-collectors-6ea8f00153f0?source=collection_archive---------11-----------------------#2022-12-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/72ba8f46670cfaf263eee4fc16f8f9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5OshXzkPQeC5MwgA"/></div></div><figcaption class="kc kd gk gi gj ke kf bd b be z dk translated">洛伦·比瑟在<a class="ae kg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="dc29" class="kh ki iu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">介绍</h1><p id="d5ed" class="pw-post-body-paragraph lf lg iu lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc in bi translated">垃圾收集器是一个自动释放程序不再需要的内存的程序。许多编程语言都使用垃圾收集器来自动管理内存，这可以简化编写代码的过程，并有助于防止常见的编程错误。</p><p id="f3a9" class="pw-post-body-paragraph lf lg iu lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc in bi translated">垃圾收集器是这样工作的:</p><ol class=""><li id="40bb" class="mi mj iu lh b li md lm me lq mk lu ml ly mm mc mn mo mp mq bi translated">垃圾收集器跟踪程序正在使用的内存位置。</li><li id="a25e" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated">当程序不再需要一块内存时，垃圾收集器会将它标记为可供重用。</li><li id="7089" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated">垃圾收集器定期扫描程序的内存，寻找不再使用的内存块。</li><li id="9c5c" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated">当垃圾收集器发现不再使用的内存块时，它会释放它以供重用。</li></ol><p id="b320" class="pw-post-body-paragraph lf lg iu lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc in bi translated">垃圾收集器可以是引用计数，也可以是标记-清除。引用计数垃圾收集器跟踪每个内存块的引用数量，当引用计数达到零时，它们释放内存。标记和清除垃圾收集器定期扫描程序的内存，寻找不再使用的内存块，并释放这些内存块。</p><h1 id="3b6c" class="kh ki iu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">垃圾收集器的发展</h1><p id="9771" class="pw-post-body-paragraph lf lg iu lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc in bi translated">随着编程语言和计算环境的变化，垃圾收集器已经有了很大的发展。下面是垃圾收集器发展的简要概述:</p><ol class=""><li id="0ae6" class="mi mj iu lh b li md lm me lq mk lu ml ly mm mc mn mo mp mq bi translated"><strong class="lh iv">早期的垃圾收集器</strong>:第一个垃圾收集器是在20世纪60年代为Lisp编程语言开发的。这些垃圾收集器是简单的引用计数收集器，跟踪对每块内存的引用数量，当引用计数达到零时，它们释放内存。</li><li id="3f1c" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated">标记并清除垃圾收集器:在20世纪70年代，标记并清除垃圾收集器是为Smalltalk编程语言开发的。这些垃圾收集器定期扫描程序的内存，寻找不再使用的内存块，并释放这些内存块。</li><li id="2d4c" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated">分代垃圾收集器:在20世纪80年代，分代垃圾收集器是为自编程语言开发的。这些垃圾收集器根据对象的年龄将程序的内存分成不同的代，他们分别收集每代中的垃圾。</li><li id="18f6" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">并发垃圾收集器</strong>:20世纪90年代，并发垃圾收集器是为Java编程语言开发的。这些垃圾收集器与程序同时运行，允许程序在收集垃圾的同时继续运行。</li><li id="d33e" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">实时垃圾收集器</strong>:在21世纪初，实时垃圾收集器是为Eiffel编程语言开发的。这些垃圾收集器被设计成满足实时性能约束，允许程序运行而不被垃圾收集器中断。</li></ol><h1 id="7c9d" class="kh ki iu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">垃圾收集方法</h1><p id="f644" class="pw-post-body-paragraph lf lg iu lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc in bi translated">让我们更深入地了解随着时间的推移而发展起来的不同方法:</p><h2 id="bf49" class="mw ki iu bd kj mx my dn kn mz na dp kr lq nb nc kv lu nd ne kz ly nf ng ld nh bi translated">引用计数</h2><p id="c0fe" class="pw-post-body-paragraph lf lg iu lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc in bi translated">引用计数:在引用计数垃圾收集中，垃圾收集器跟踪每个内存块的引用数量，当引用计数达到零时，它释放内存。这种方法简单而有效，但它可能会遇到一个称为“引用循环”的问题，在这个问题中，两个对象相互引用，并且这两个对象的引用计数永远不会达到零。</p><p id="a021" class="pw-post-body-paragraph lf lg iu lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc in bi translated">在Python中，当不再有对对象的引用时，对象的引用计数变为零。这可能以几种不同的方式发生:</p><ol class=""><li id="86ba" class="mi mj iu lh b li md lm me lq mk lu ml ly mm mc mn mo mp mq bi translated"><strong class="lh iv">当引用一个对象的变量超出作用域</strong>:当一个变量超出作用域时，程序就不能再访问它了，变量所引用的对象的引用计数减一。如果对象的引用计数达到零，垃圾收集器将释放该对象占用的内存。</li><li id="c06f" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">当一个变量被重新分配</strong>:如果一个变量被重新分配来引用一个不同的对象，那么原始对象的引用计数会减一。如果原始对象的引用计数达到零，垃圾收集器将释放该对象占用的内存。</li><li id="1f3f" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">当一个对象被显式删除</strong>:您可以使用<code class="fe ni nj nk nl b">del</code>语句显式删除一个变量或对象，这将使对象的引用计数减一。如果对象的引用计数达到零，垃圾收集器将释放该对象占用的内存。</li></ol><h2 id="eb38" class="mw ki iu bd kj mx my dn kn mz na dp kr lq nb nc kv lu nd ne kz ly nf ng ld nh bi translated">标记和清扫</h2><p id="bafd" class="pw-post-body-paragraph lf lg iu lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc in bi translated">在标记-清除垃圾收集中，垃圾收集器定期扫描程序的内存，寻找不再使用的内存块，并释放这些内存块。这种方法比引用计数更彻底，但是在垃圾收集时会导致程序执行暂停。</p><p id="14cc" class="pw-post-body-paragraph lf lg iu lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc in bi translated">下面是标记和清除垃圾收集的工作原理:</p><ol class=""><li id="a946" class="mi mj iu lh b li md lm me lq mk lu ml ly mm mc mn mo mp mq bi translated"><strong class="lh iv">标记阶段</strong>:垃圾收集器从标记程序内存中所有仍在使用的对象开始。为了标记一个对象，垃圾收集器在对象的头中设置一个特殊的标志，表示该对象仍在使用中。</li><li id="c1ce" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">清扫阶段</strong>:当所有仍在使用的对象都被标记后，垃圾收集器开始清扫阶段。在扫描阶段，垃圾收集器扫描程序的内存，寻找没有标记的内存块。这些内存块被认为是垃圾，它们被释放出来供重用。</li><li id="e8fb" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">压缩</strong>:在清扫阶段完成后，垃圾收集器可以执行压缩，以更有效的方式重新安排程序的内存。在压缩过程中，垃圾收集器将仍在使用的对象移动到连续的内存块中，这可以提高程序的性能。</li></ol><h2 id="3f46" class="mw ki iu bd kj mx my dn kn mz na dp kr lq nb nc kv lu nd ne kz ly nf ng ld nh bi translated">生育的</h2><p id="989e" class="pw-post-body-paragraph lf lg iu lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc in bi translated">在分代垃圾收集中，垃圾收集器根据对象的年龄将程序的内存分成不同的代，并分别收集每代中的垃圾。这种方法比标记-清除法更有效，因为它专注于收集年轻一代中的垃圾，年轻一代更有可能是垃圾。</p><h2 id="0981" class="mw ki iu bd kj mx my dn kn mz na dp kr lq nb nc kv lu nd ne kz ly nf ng ld nh bi translated">同时发生的</h2><p id="6761" class="pw-post-body-paragraph lf lg iu lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc in bi translated">在并发垃圾收集中，垃圾收集器与程序并发运行，允许程序在收集垃圾的同时继续运行。这种方法比标记-清除方法更有效，因为它不会导致程序执行暂停，但它需要更复杂的实现。</p><p id="43af" class="pw-post-body-paragraph lf lg iu lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc in bi translated">下面是并发垃圾收集的工作原理:</p><ol class=""><li id="0e55" class="mi mj iu lh b li md lm me lq mk lu ml ly mm mc mn mo mp mq bi translated"><strong class="lh iv">并发收集</strong>:垃圾收集器从与程序并发运行开始，扫描程序内存中不再使用的内存块。当垃圾收集器找到不再使用的内存块时，它会释放这些内存块以供重用。</li><li id="483c" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">停止世界</strong>:当垃圾收集器需要执行某些需要程序停止的任务时，它会暂时停止程序并执行任务。这就是所谓的“停止世界”。例如，垃圾收集器可能需要停止程序来更新指向在压缩期间被移动的对象的指针，或者更新与其他线程共享的对象的引用计数。</li><li id="df67" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">并发压缩</strong>:一些并发垃圾收集器也支持并发压缩，它允许垃圾收集器在程序运行时以更有效的方式重新安排程序的内存。这可以提高程序的性能，但需要更复杂的实现。</li></ol><h2 id="a2b2" class="mw ki iu bd kj mx my dn kn mz na dp kr lq nb nc kv lu nd ne kz ly nf ng ld nh bi translated">实时</h2><p id="fcf0" class="pw-post-body-paragraph lf lg iu lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc in bi translated">在实时垃圾收集中，垃圾收集器被设计成满足实时性能约束，允许程序运行而不被垃圾收集器中断。这种方法对于需要可预测性能的程序很有用，但是实现起来可能更困难。</p><p id="b80d" class="pw-post-body-paragraph lf lg iu lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc in bi translated">以下是实时垃圾收集的工作原理:</p><ol class=""><li id="0e23" class="mi mj iu lh b li md lm me lq mk lu ml ly mm mc mn mo mp mq bi translated"><strong class="lh iv">可预测的收集时间</strong>:垃圾收集器被设计成在可预测的时间执行垃圾收集，这样程序就可以满足它的实时性能约束。例如，垃圾收集器可以被设计成以固定的时间间隔执行垃圾收集，或者它可以被设计成在程序空闲时执行垃圾收集。</li><li id="56e6" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">最小化停止世界</strong>:实时垃圾收集器被设计成在垃圾收集期间最小化程序必须停止的时间。这就是所谓的“停止世界”。例如，垃圾收集器可以被设计成执行增量收集，其中它在一段时间内以小增量收集垃圾，而不是一次全部收集。</li><li id="7b9f" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">可预测的暂停时间</strong>:实时垃圾收集器也被设计成最小化由于停止运行而导致的暂停时间。这有助于确保程序满足其实时性能约束。</li></ol><p id="f402" class="pw-post-body-paragraph lf lg iu lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc in bi translated">总的来说，在编程语言中有几种不同的垃圾收集方法。每种方法都有自己的优缺点，合适的方法取决于程序的要求。</p><h1 id="a437" class="kh ki iu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">Python中的垃圾收集</h1><p id="f79a" class="pw-post-body-paragraph lf lg iu lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc in bi translated">在Python中，垃圾收集是由<code class="fe ni nj nk nl b">gc</code>(垃圾收集器)模块执行的，它是一个内置模块，是Python标准库的一部分。<code class="fe ni nj nk nl b">gc</code>模块提供控制垃圾收集器和访问垃圾收集器信息的功能。</p><p id="394b" class="pw-post-body-paragraph lf lg iu lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc in bi translated">下面是Python如何使用垃圾收集器的:</p><ol class=""><li id="16ab" class="mi mj iu lh b li md lm me lq mk lu ml ly mm mc mn mo mp mq bi translated">Python使用引用计数垃圾收集器来自动管理内存。这意味着Python会跟踪对每个内存块的引用数量，当引用计数达到零时，它会释放内存。</li><li id="f333" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated">当对象的引用计数达到零时，Python的垃圾收集器会自动触发。当这种情况发生时，垃圾收集器会释放该对象占用的内存，并使其可供重用。</li><li id="c644" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated">Python的垃圾收集器也有一个标记-清除阶段，它会定期触发，或者在垃圾收集器认为有必要时触发。在标记和清除阶段，垃圾收集器扫描程序的内存，寻找不再使用的内存块，并释放这些内存块。</li><li id="4668" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated">Python的垃圾收集器可以使用<code class="fe ni nj nk nl b">gc</code>模块来控制。例如，您可以使用<code class="fe ni nj nk nl b">gc.enable()</code>和<code class="fe ni nj nk nl b">gc.disable()</code>函数来启用或禁用垃圾收集器。您还可以使用<code class="fe ni nj nk nl b">gc.collect()</code>函数来强制垃圾收集器立即运行。</li></ol><p id="f53b" class="pw-post-body-paragraph lf lg iu lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc in bi translated">总的来说，Python使用引用计数垃圾收集器来自动管理内存，确保代码的效率和可靠性。<code class="fe ni nj nk nl b">gc</code>模块提供了控制垃圾收集器和访问垃圾收集器信息的功能。</p><h1 id="dbb8" class="kh ki iu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">编程语言设计中垃圾收集的未来方向</h1><p id="dd04" class="pw-post-body-paragraph lf lg iu lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc in bi translated">以下是编程语言设计中垃圾收集的一些潜在未来方向:</p><ol class=""><li id="7276" class="mi mj iu lh b li md lm me lq mk lu ml ly mm mc mn mo mp mq bi translated"><strong class="lh iv">连续垃圾收集</strong>:一些编程语言正在探索使用连续垃圾收集，垃圾收集器在后台连续运行，而不是周期性运行。这可以让垃圾收集器更高效，更快地释放内存。</li><li id="b95a" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">增量垃圾收集</strong>:垃圾收集的另一个方向是使用增量垃圾收集，垃圾收集器在一段时间内以小增量收集垃圾，而不是一次全部收集。这有助于最小化垃圾收集对程序性能的影响。</li><li id="4fa9" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">并行垃圾收集</strong>:一些编程语言正在探索使用并行垃圾收集，其中垃圾收集器使用多个线程或内核并发执行垃圾收集。这可以让垃圾收集器更高效，更快地释放内存。</li><li id="85e0" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">可预测的垃圾收集</strong>:垃圾收集的另一个方向是使用可预测的垃圾收集，其中垃圾收集器被设计成满足特定的性能约束或者在可预测的时间执行垃圾收集。这对于需要可预测性能的程序很有用，例如控制关键系统或与用户实时交互的程序。</li><li id="abca" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc mn mo mp mq bi translated"><strong class="lh iv">混合垃圾收集</strong>:一些编程语言正在探索混合垃圾收集的使用，其中垃圾收集器结合了多种垃圾收集技术，以达到最佳性能。这可以让垃圾收集器更高效，更快地释放内存。</li></ol></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><p id="e37e" class="pw-post-body-paragraph lf lg iu lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc in bi translated">我希望你喜欢读这篇文章。如果你愿意支持我成为一名作家，考虑注册<a class="ae kg" href="https://medium.com/@smohajer85/membership" rel="noopener">成为一名媒体成员</a>。每月只需5美元，你就可以无限制地使用Medium。</p></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h1 id="b3b3" class="kh ki iu bd kj kk nt km kn ko nu kq kr ks nv ku kv kw nw ky kz la nx lc ld le bi translated">分级编码</h1><p id="cd85" class="pw-post-body-paragraph lf lg iu lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc in bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="648d" class="mi mj iu lh b li md lm me lq mk lu ml ly mm mc ny mo mp mq bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="6bef" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc ny mo mp mq bi translated">📰更多内容请查看<a class="ae kg" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="f425" class="mi mj iu lh b li mr lm ms lq mt lu mu ly mv mc ny mo mp mq bi translated">🔔关注我们:<a class="ae kg" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae kg" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae kg" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="8565" class="pw-post-body-paragraph lf lg iu lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc in bi translated">🚀👉<a class="ae kg" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lh iv">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>