<html>
<head>
<title>Build a Multi-Container Docker Application with Docker Compose with a React, Node, and Postgres App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Docker构建一个多容器Docker应用程序，Docker由React、Node和Postgres应用程序组成</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-multi-container-application-with-docker-compose-460f6199ef3c?source=collection_archive---------1-----------------------#2019-12-04">https://levelup.gitconnected.com/build-a-multi-container-application-with-docker-compose-460f6199ef3c?source=collection_archive---------1-----------------------#2019-12-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/930b6f7cbecb1dfd68f2cfebae6ac002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWH_BbBIrqpsAxYbLpvpdA.png"/></div></div></figure><p id="6e7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我之前写了一篇关于<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/wrapping-your-head-around-docker-27b94deadfc8">用头脑思考Docker </a>的文章，我认为用一个实际动手的例子来跟进是个好主意。我们将进行一点跳跃，直接用<a class="ae kz" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>运行多个容器。我在上一篇Docker文章中没有提到这一点，所以我将从概述它是什么以及它如何帮助我们实现运行多个容器的目标开始。</p><p id="17e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你不是一个读者📖类型的人，或者如果你对Docker有足够的经验，只是想看看编码的例子，请随时到这里的<a class="ae kz" href="https://github.com/LukeMwila/react-express-postgres" rel="noopener ugc nofollow" target="_blank">回购</a>。否则，再逗留几分钟，看看如何构建这个多容器应用程序，它有一个客户机(React)、一个服务器(Node.js)和一个数据库实例(Postgres)。我们的应用程序是做什么的？你猜对了，这是一个待办事项应用程序😐。</p><p id="d425" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我应该马上说，这篇文章的目的不是深入研究示例应用程序中的三种技术，而是展示Docker Compose在本地(在您的机器上)轻松运行多个容器的用法。下一次，我们将着眼于将我们的多容器应用程序部署到云中。</p><p id="497e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢这篇文章，请在这里给我买杯咖啡<a class="ae kz" href="https://www.buymeacoffee.com/lukemwila" rel="noopener ugc nofollow" target="_blank">☕️</a>😃。</p><h1 id="155e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Docker撰写</h1><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/e5823fc0987030ec2fc55bea62632987.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*YE-fApWn9PXN9B3k7DY4FA.png"/></div></figure><p id="f77c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Docker Compose是一个独立的工具，随Docker一起安装。它是一个单独的CLI。Docker Compose使我们可以非常简单直接地同时启动多个Docker容器，并通过某种形式的网络自动将它们连接在一起。docker-compose的主要用途是充当docker CLI，但允许您快速发出更多命令。</p><p id="da0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当使用docker compose创建容器时，我们不需要设置任何端口声明，因为我们希望本地机器能够将流量发送到容器中。</p><p id="1d62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们开始破解我们的应用程序之前，创建以下文件夹结构:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7765" class="mi lb it me b gy mj mk l ml mm">├── client<br/>├── server<br/>└── docker-compose.yml</span></pre><h1 id="55f6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">客户端(React应用程序)</h1><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mn"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div></figure><p id="634f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像往常一样，我使用<a class="ae kz" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>和TypeScript。您不必为TypeScript配置费心，因为我们不会对应用程序进行太多充实。一旦我们启动并运行了React应用程序，我们将创建一个docker文件，用于构建图像。Docker文件是一个纯文本文件，其中包含多行配置。这个配置将定义我们的容器的行为，更具体地说，它将包含什么程序，当它启动一个容器时它做什么。</p><p id="754a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建Dockerfile文件遵循以下步骤:</p><ul class=""><li id="a990" class="mo mp it kd b ke kf ki kj km mq kq mr ku ms ky mt mu mv mw bi translated">指定基础图像</li><li id="2a54" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated">运行一些命令来安装附加程序和依赖项</li><li id="a784" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated">指定容器启动时运行的命令</li></ul><p id="7338" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为开发环境配置一个容器，为生产环境配置一个容器，这是很好的做法。因此，我们将有一个Dockerfile，它将在dev (Dockerfile.dev)中运行我们的应用程序。在客户端文件夹中，创建<strong class="kd iu"> Dockerfile.dev </strong>文件，并用以下内容填充它:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5a94" class="mi lb it me b gy mj mk l ml mm">FROM node:10-alpine AS alpine</span><span id="09bf" class="mi lb it me b gy nc mk l ml mm">WORKDIR /app</span><span id="bd04" class="mi lb it me b gy nc mk l ml mm"># A wildcard is used to ensure both package.json AND package-lock.json are copied<br/>COPY package*.json .</span><span id="3df7" class="mi lb it me b gy nc mk l ml mm">## install only the packages defined in the package-lock.json (faster than the normal npm install)<br/>RUN npm install<br/># Copy the contents of the project to the image<br/>COPY . .<br/># Run 'npm start' when the container starts.<br/>CMD ["npm", "run", "start"]</span></pre><p id="8dd6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经完成了，让我们创建一个<code class="fe nd ne nf me b">.env</code>文件来定义一个带有to-do API路径的环境变量。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7616" class="mi lb it me b gy mj mk l ml mm">REACT_APP_TO_DO_ITEMS_API=http://localhost:3001/v1</span></pre><p id="d46d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望React应用程序做的只是列出需要完成的项目。因此，您可以从<strong class="kd iu"> App.tsx </strong>(或<strong class="kd iu"> App.js </strong>)文件中删除样板代码，并用以下代码更新它:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f175" class="mi lb it me b gy mj mk l ml mm">import React from 'react';<br/>import './App.css';</span><span id="92b2" class="mi lb it me b gy nc mk l ml mm">function App() {<br/>  const [toDoItems, updateToDoItems] = React.useState([]);</span><span id="c66e" class="mi lb it me b gy nc mk l ml mm">  React.useEffect(() =&gt; {<br/>    const getToDoItems = async () =&gt; {<br/>      const response = await fetch(<br/>        `${process.env.REACT_APP_TO_DO_ITEMS_API}/items`<br/>      );</span><span id="1ae4" class="mi lb it me b gy nc mk l ml mm">    const items = await response.json();<br/>      if (items &amp;&amp; Array.isArray(items) &amp;&amp; items.length) {<br/>        // <a class="ae kz" href="http://twitter.com/ts" rel="noopener ugc nofollow" target="_blank">@ts</a>-ignore<br/>        updateToDoItems(items);<br/>      }<br/>    };<br/>    getToDoItems();<br/>  }, []);</span><span id="7442" class="mi lb it me b gy nc mk l ml mm">return (<br/>    &lt;div&gt;<br/>      {toDoItems &amp;&amp; toDoItems.length<br/>        ? toDoItems.map((item: any, i: number) =&gt; {<br/>            return (<br/>              &lt;div key={i}&gt;<br/>                {`${item.item_name}`}<br/>                &lt;br /&gt;<br/>              &lt;/div&gt;<br/>            );<br/>          })<br/>        : 'No items to be done'}<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="8c15" class="mi lb it me b gy nc mk l ml mm">export default App;</span></pre><p id="8d7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们把注意力转向服务器应用程序。</p><h1 id="bc10" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">服务器(Node.js应用程序)</h1><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/bd11fd62b2446279edd51e2ca1d9a835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_i_nCqMpR3KpjX0OTAuEIw.png"/></div></div></figure><p id="386a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的服务器文件夹中，让我们继续运行以下初始化命令:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f7c8" class="mi lb it me b gy mj mk l ml mm">$ npm init -y</span></pre><p id="325b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦我们的<strong class="kd iu"> package.json </strong>文件被创建，我们就可以安装一些依赖项了。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f813" class="mi lb it me b gy mj mk l ml mm">$ npm i --save express cors body-parser dotenv pg uuid</span></pre><p id="fbab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们也安装nodemon。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="a8e0" class="mi lb it me b gy mj mk l ml mm">$ npm i -D nodemon</span></pre><p id="6d12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦你完成了这些，你的<strong class="kd iu"> package.json </strong>文件应该看起来像这样:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="b0be" class="mi lb it me b gy mj mk l ml mm">{<br/>  "name": "server",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "start": "node src/index.js",<br/>    "dev": "nodemon src/index.js",<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "keywords": [],<br/>  "author": "<strong class="me iu">your name</strong>",<br/>  "license": "ISC",<br/>  "dependencies": {<br/>    "body-parser": "^1.19.0",<br/>    "cors": "^2.8.5",<br/>    "dotenv": "^8.2.0",<br/>    "express": "^4.17.1",<br/>    "pg": "^7.14.0",<br/>    "uuid": "^3.3.3"<br/>  },<br/>  "devDependencies": {<br/>    "nodemon": "^2.0.0"<br/>  }<br/>}</span></pre><p id="05d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的服务器目录中，创建一个具有以下结构的<strong class="kd iu"> src </strong>文件夹:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="3cbb" class="mi lb it me b gy mj mk l ml mm">├── config<br/>└── index.js</span></pre><p id="7e39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">config文件夹将有一个<strong class="kd iu"> index.js </strong>文件，其中包含连接到Postgres数据库所需的配置。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8efe" class="mi lb it me b gy mj mk l ml mm">const config = {<br/>  pgUser: process.env.PGUSER,<br/>  pgHost: process.env.PGHOST,<br/>  pgDatabase: process.env.PGDATABASE,<br/>  pgPassword: process.env.PGPASSWORD,<br/>  pgPort: process.env.PGPORT<br/>};</span><span id="a78b" class="mi lb it me b gy nc mk l ml mm">module.exports = config;</span></pre><p id="d202" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们可以将这个对象导入到<strong class="kd iu"> src/index.js </strong>文件中来配置Postgres客户端连接。我还为要在out-to-do应用程序中执行的每个CRUD操作添加了一条路径。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d863" class="mi lb it me b gy mj mk l ml mm">require('dotenv').config();</span><span id="a23b" class="mi lb it me b gy nc mk l ml mm"><strong class="me iu">// Express App Setup</strong><br/>const express = require('express');<br/>const http = require('http');<br/>const bodyParser = require('body-parser');<br/>const cors = require('cors');<br/>const uuid = require('uuid/v4');</span><span id="3645" class="mi lb it me b gy nc mk l ml mm"><strong class="me iu">// Config</strong><br/>const config = require('./config');</span><span id="0ed1" class="mi lb it me b gy nc mk l ml mm"><strong class="me iu">// Initialization</strong><br/>const app = express();<br/>app.use(cors());<br/>app.use(bodyParser.json());</span><span id="17fa" class="mi lb it me b gy nc mk l ml mm"><strong class="me iu">// Postgres client</strong><br/>const { Pool } = require('pg');<br/>const pgClient = new Pool({<br/>  user: config.pgUser,<br/>  host: config.pgHost,<br/>  database: config.pgDatabase,<br/>  password: config.pgPassword,<br/>  port: config.pgPort<br/>});<br/>pgClient.on('error', () =&gt; console.log('Lost Postgres connection'));</span><span id="8e05" class="mi lb it me b gy nc mk l ml mm">pgClient<br/>  .query(<br/>    `<br/>  CREATE TABLE IF NOT EXISTS items (<br/>    id uuid,<br/>    item_name TEXT NOT NUll,<br/>    complete BOOLEAN DEFAULT false,<br/>    PRIMARY KEY (id)<br/>  )<br/>`<br/>  )<br/>  .catch(err =&gt; console.log(err));</span><span id="e6fb" class="mi lb it me b gy nc mk l ml mm"><strong class="me iu">// Express route handlers</strong><br/>app.get('/test', (req, res) =&gt; {<br/>  res.send('Working!');<br/>});</span><span id="6dae" class="mi lb it me b gy nc mk l ml mm"><strong class="me iu">// Get all to do list items</strong><br/>app.get('/v1/items', async (req, res) =&gt; {<br/>  const items = await pgClient.query('SELECT * FROM items');<br/>  res.status(200).send(items.rows);<br/>});</span><span id="28d6" class="mi lb it me b gy nc mk l ml mm"><strong class="me iu">// Get a single todo item</strong><br/>app.get('/v1/items', async (req, res) =&gt; {<br/>  const id = req.params.id;</span><span id="f1cb" class="mi lb it me b gy nc mk l ml mm">const items = await pgClient<br/>    .query('SELECT * FROM items WHERE id = $1', [id])<br/>    .catch(e =&gt; {<br/>      res<br/>        .status(500)<br/>        .send(`Encountered an internal error when fetching item with ID ${id}`);<br/>    });</span><span id="cfef" class="mi lb it me b gy nc mk l ml mm">res.status(200).send(items.rows);<br/>});</span><span id="661e" class="mi lb it me b gy nc mk l ml mm"><strong class="me iu">// Create a todo item</strong><br/>app.post('/v1/items', async (req, res) =&gt; {<br/>  const { item_name } = req.body;<br/>  const id = uuid();<br/>  const item = await pgClient<br/>    .query(<br/>      `INSERT INTO items (id, item_name, complete) VALUES <br/>    ($1, $2, $3)`,<br/>      [id, item_name, false]<br/>    )<br/>    .catch(e =&gt; {<br/>      res<br/>        .status(500)<br/>        .send('Encountered an internal error when creating an item');<br/>    });</span><span id="c059" class="mi lb it me b gy nc mk l ml mm">res.status(201).send(`Item created with ID: ${id}`);<br/>});</span><span id="ef03" class="mi lb it me b gy nc mk l ml mm"><strong class="me iu">// Update a todo item</strong><br/>app.put('/v1/items/:id', async (req, res) =&gt; {<br/>  const id = req.params.id;<br/>  const { item_name, complete } = req.body;</span><span id="4942" class="mi lb it me b gy nc mk l ml mm">await pgClient<br/>    .query(<br/>      `<br/>    UPDATE items SET item_name = $1, complete = $2 WHERE id = $3<br/>  `,<br/>      [item_name, complete, id]<br/>    )<br/>    .catch(e =&gt; {<br/>      res<br/>        .status(500)<br/>        .send('Encountered an internal error when updating an item');<br/>    });</span><span id="4369" class="mi lb it me b gy nc mk l ml mm">res.status(200).send(`Item updated with ID: ${id}`);<br/>});</span><span id="a234" class="mi lb it me b gy nc mk l ml mm"><strong class="me iu">// Delete a todo item</strong><br/>app.delete('/v1/items/:id', async (req, res) =&gt; {<br/>  const id = req.params.id;</span><span id="8d88" class="mi lb it me b gy nc mk l ml mm">await pgClient.query('DELETE FROM items WHERE id = $1', [id]).catch(e =&gt; {<br/>    res.status(500).send('Encountered an internal error when deleting an item');<br/>  });</span><span id="10d0" class="mi lb it me b gy nc mk l ml mm">res.status(200).send(`Item deleted with ID: ${id}`);<br/>});</span><span id="45d8" class="mi lb it me b gy nc mk l ml mm"><strong class="me iu">// Server</strong><br/>const port = process.env.PORT || 3001;<br/>const server = http.createServer(app);<br/>server.listen(port, () =&gt; console.log(`Server running on port ${port}`));</span></pre><p id="6758" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">既然我们已经把Node.js应用程序整理好了，我们可以继续为它创建一个<strong class="kd iu"> Dockerfile.dev </strong>文件。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d292" class="mi lb it me b gy mj mk l ml mm"># Specify a base image<br/>FROM node:12.13.0-alpine AS alpine</span><span id="a29b" class="mi lb it me b gy nc mk l ml mm">WORKDIR /app</span><span id="e086" class="mi lb it me b gy nc mk l ml mm"># Install dependencies<br/>COPY package.json .<br/>RUN npm install <br/>COPY . .</span><span id="d896" class="mi lb it me b gy nc mk l ml mm"># Default command<br/>CMD ["npm", "run", "dev"]</span></pre><h1 id="5f73" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">数据库(Postgres)</h1><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/46c4d9545d8382f219262d58bf3baefb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*7hmOBD_0bgGrriXL1yqFpQ.png"/></div></figure><p id="428e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能已经注意到，我们没有为我们的数据库创建单独的文件夹，那么Postgres Dockerfile文件将存放在哪里呢？实际上我们不需要。我们可以从<a class="ae kz" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>中提取Postgres图像，我们将使用它来启动我们的容器。</p><h1 id="5870" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">将这一切结合在一起</h1><p id="529a" class="pw-post-body-paragraph kb kc it kd b ke ni kg kh ki nj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky im bi translated">现在我们将注意力转向我们在项目开始时创建的<strong class="kd iu"> docker-compose.yml </strong>文件。这个文件将允许我们定义和配置不同的服务，以便它们可以在一个隔离的环境中一起运行。服务定义包含应用于为该服务启动的每个容器的配置，非常类似于将命令行参数传递给<code class="fe nd ne nf me b">docker container create</code>。同样，网络和卷的定义类似于<code class="fe nd ne nf me b">docker network create</code>和<code class="fe nd ne nf me b">docker volume create</code>。</p><p id="dfae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们为Postgres数据库定义服务容器时，我们需要做的就是从Dockerhub中指定我们将使用的映像，在本例中是hub上可用的最新版本的Postgres。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f4b7" class="mi lb it me b gy mj mk l ml mm">postgres:<br/>  image: postgres:latest</span></pre><p id="bb82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">至于客户机和服务器，因为我们在各自的目录中都有<strong class="kd iu"> Dockerfile.dev </strong>文件，所以我们可以通过指定容器(文件夹或目录)的上下文来配置服务的构建细节，因为我们都将Dockerfile用于构建基本映像。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="1f4c" class="mi lb it me b gy mj mk l ml mm">web-app:<br/>  build:<br/>    context: ./client<br/>    dockerfile: Dockerfile.dev<br/>  volumes:<br/>    - /app/node_modules<br/>    - ./client:/app<br/>  ports:<br/>    - '3000:3000'<br/>  restart: on-failure<br/>  container_name: web-app<br/>to-do-api:<br/>  build:<br/>    context: ./server<br/>    dockerfile: Dockerfile.dev<br/>  ports:<br/>    - '3001:3001'<br/>  restart: on-failure<br/>  container_name: to-do-api<br/>  volumes:<br/>    - /app/node_modules <br/># Inside the container, don't try to override this folder, just leave as is<br/>    - ./server:/app <br/># Look at the server directory and copy everything into the app folder in the container</span></pre><p id="bcf2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能已经注意到为<strong class="kd iu"> web-app </strong>和<strong class="kd iu"> to-do-api </strong>服务定义的卷。请记住，当我们创建一个映像时，我们实际上是在获取目录中所有源代码的快照。docker卷有一个指向创建映像的本地目录的引用。这基本上就是如何将docker容器中的文件和文件夹连接到本地目录中的文件和文件夹。</p><p id="4ff3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以使用<a class="ae kz" href="https://docs.docker.com/compose/compose-file/#environment" rel="noopener ugc nofollow" target="_blank">‘environment’键</a>在服务的容器中设置环境变量。您可能还记得，我们在<strong class="kd iu">server/src/config/index . js</strong>文件中使用环境变量设置Postgres连接值。我们可以在<strong class="kd iu"> docker-compose.yml </strong>文件中为要传递给容器的<strong class="kd iu"> to-do-api </strong>服务定义这些变量的值。</p><p id="f596" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最终产品应该是这样的:</p><p id="f065" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> docker-compose.yml </strong></p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c920" class="mi lb it me b gy mj mk l ml mm">version: '3'<br/>services:<br/>  postgres:<br/>    image: postgres:latest<br/>  web-app:<br/>    build:<br/>      context: ./client<br/>      dockerfile: Dockerfile.dev<br/>    volumes:<br/>      - /app/node_modules<br/>      - ./client:/app<br/>    ports:<br/>      - '3000:3000'<br/>    restart: on-failure<br/>    container_name: web-app<br/>  to-do-api:<br/>    build:<br/>      context: ./server<br/>      dockerfile: Dockerfile.dev<br/>    ports:<br/>      - '3001:3001'<br/>    restart: on-failure<br/>    container_name: to-do-api<br/>    volumes:<br/>      - /app/node_modules # Inside the container, don't try to override this folder, just leave as is<br/>      - ./server:/app # Look at the server directory and copy everything into the app folder in the container<br/>    environment:<br/>      - PGUSER=postgres<br/>      - PGHOST=postgres<br/>      - PGDATABASE=postgres<br/>      - PGPASSWORD=<br/>      - PGPORT=5432</span></pre><h1 id="d192" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">运行容器</h1><p id="3dd5" class="pw-post-body-paragraph kb kc it kd b ke ni kg kh ki nj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky im bi translated">要启动并运行容器，我们可以运行以下命令:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="5cd3" class="mi lb it me b gy mj mk l ml mm">$ docker-compose up -d</span></pre><p id="5fb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经添加了<code class="fe nd ne nf me b">-d</code> (detach)标志，以便容器在后台启动。</p><p id="d228" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当集装箱启动时，我们可以用<code class="fe nd ne nf me b">docker container ls</code>或<code class="fe nd ne nf me b">docker ps</code>来检查正在运行的集装箱。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/5a23f9a70a5b308ca0a63695c3799ef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NXGY7iGzusnuG6PACu293g.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">运行容器</figcaption></figure><p id="6393" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们继续使用Postman创建一些待办事项。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/27b3564552d7e809a003f99efb8d7c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i1SZfV0tZJmVjPR6Q0GXiQ.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">使用邮递员创建项目</figcaption></figure><p id="6687" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据我得到的响应，我的数据库中应该有项目。我们可以通过简单地向相关端点运行GET请求来测试这一点，或者我们可以SSH到我们正在运行的数据库容器中。让我们双管齐下😄。第一个简单的事情是在Postman上打开一个新标签，并运行GET请求到<code class="fe nd ne nf me b"><a class="ae kz" href="http://localhost:3001/v1/items." rel="noopener ugc nofollow" target="_blank">http://localhost:3001/v1/items</a></code> <a class="ae kz" href="http://localhost:3001/v1/items." rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/421bad56387499af60bcd3235f707005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_q3sP1LOfgo6T2wIQWxMDw.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">使用邮递员获取项目</figcaption></figure><p id="d32d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们采取第二种方法。要在容器中获得bash shell，运行下面的<code class="fe nd ne nf me b">docker exec -it &lt;container id&gt; &lt;command&gt;</code>命令。<code class="fe nd ne nf me b">-it</code>标志用于综合终端。所以我要跑<code class="fe nd ne nf me b">docker exec -it ad947a6b302 bash</code>。一旦我进入，我就可以使用默认凭证通过<code class="fe nd ne nf me b">psql -U postgres</code>连接到<code class="fe nd ne nf me b">postgres</code>数据库。然后，我可以通过运行<code class="fe nd ne nf me b">\dt</code>命令来检查items表是否存在。如果我得到了预期的结果，那么我可以运行一个基本的SQL查询来获得items表中带有<code class="fe nd ne nf me b">SELECT * FROM items;</code>的所有条目。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nu"><img src="../Images/24870b308068552c673f06ac58c7f05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukQWEuubs-BbDSgGISaDlw.png"/></div></div></figure><p id="5a46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，让我们测试我们的客户机应用程序，以确保我们从数据库中获得了项目列表。只需打开一个浏览器，进入相关端口上的本地主机，在我的例子中，React应用程序运行在端口3000上。</p><p id="6a0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">鼓声…</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/8c057c8f74f1cf93564097ecad89d9dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*3npQifaLIQ-ovOvdK_X6gA.png"/></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">反应应用程序结果</figcaption></figure><p id="bc7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，我得到了预期的输出。组成我们应用程序的每个容器都在正常运行🙌 😃。</p><p id="e5d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如开始提到的，这个应用程序的所有源代码都可以在这里找到:<a class="ae kz" href="https://github.com/LukeMwila/react-express-postgres" rel="noopener ugc nofollow" target="_blank">https://github.com/LukeMwila/react-express-postgres</a></p></div></div>    
</body>
</html>