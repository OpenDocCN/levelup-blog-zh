<html>
<head>
<title>Ticket to Kotlin — using Dukat to bridge Kotlin with the JS world</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin的门票——使用Dukat连接Kotlin和JS世界</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ticket-to-kotlin-using-dukat-to-bridge-kotlin-with-the-js-world-431a2458b95c?source=collection_archive---------12-----------------------#2020-06-09">https://levelup.gitconnected.com/ticket-to-kotlin-using-dukat-to-bridge-kotlin-with-the-js-world-431a2458b95c?source=collection_archive---------12-----------------------#2020-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8e65109583c830ba1dc309c4c4881964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vmzxotuHlU961aIx"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@sergec?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">塞尔吉奥·卡西利亚斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="c278" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kotlin是由动态类型JavaScript语言主导的web开发生态系统中的新人。这个生态系统不会在一两年内神奇地获得静态类型，所以web开发人员必须面对这个事实，将两个世界连接起来。科特林站在巨人的肩膀上，获得他们的好处，弥补他们的弱点，我们可以看到同样的模式也适用于这里。TypeScript定义现在是JavaScript世界中静态类型的事实上的标准。这些定义要么与npm模块一起发布，要么发布到社区支持的<a class="ae kc" href="http://definitelytyped.org/" rel="noopener ugc nofollow" target="_blank">明确类型化的</a>项目中。有一个叫做<a class="ae kc" href="https://github.com/Kotlin/dukat" rel="noopener ugc nofollow" target="_blank"> Dukat </a>的工具可以将TypeScript定义文件转换成Kotlin外部声明文件。因此，任何Kotlin JS项目都可以重用任何JavaScript库的TypeScript定义，以静态类型的方式使用它。</p><h1 id="9250" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">奔跑的杜凯特</h1><p id="fd41" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有关Kotlin外部声明语法的详细信息，请参考<a class="ae kc" href="https://kotlinlang.org/docs/reference/js-interop.html" rel="noopener ugc nofollow" target="_blank"> Kotlin文档</a>，这里我将重点介绍我使用Dukat的经验。TypeScript和Kotlin是不同的，在很多情况下，TypeScript声明不能逐字映射到Kotlin。所以在使用生成的Kotlin外部声明时有一些问题。Dukat工具现在正在积极开发中，文档很少，事情进展很快。我使用了<a class="ae kc" href="https://github.com/Kotlin/dukat/releases/tag/v0.5.0" rel="noopener ugc nofollow" target="_blank"> Dukat 0.5.0 </a>来为<a class="ae kc" href="https://github.com/google-map-react/google-map-react" rel="noopener ugc nofollow" target="_blank"> google-map-react </a>库和<a class="ae kc" href="https://developers.google.com/maps/documentation/javascript/tutorial" rel="noopener ugc nofollow" target="_blank"> Google Maps API </a>本身生成Kotlin外部声明(有关在web应用程序中使用Google Maps的更多细节，请参见本系列的<a class="ae kc" href="https://medium.com/@kiryushin.andrey/ticket-to-kotlin-using-google-maps-in-react-web-application-745d8fb0ab08" rel="noopener">上一篇文章</a>)。使用Dukat的工作流程如下:</p><ul class=""><li id="0151" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">本地安装Dukat。它作为npm模块发布，所以安装它最简单的方法是运行<code class="fe mn mo mp mq b">npm install -g dukat</code>。</li><li id="6542" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated">下载TypeScript定义以从中生成Kotlin声明。你可以安装npm包，克隆一个GitHub repo，或者只是下载<code class="fe mn mo mp mq b">.d.ts</code>文件——这都没关系。我安装了来自<code class="fe mn mo mp mq b"><a class="ae kc" href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/google-map-react/index.d.ts" rel="noopener ugc nofollow" target="_blank">@types/google-map-react</a></code>和<code class="fe mn mo mp mq b"><a class="ae kc" href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/googlemaps" rel="noopener ugc nofollow" target="_blank">@types/googlemaps</a></code> npm包的类型定义，然后在各自的<code class="fe mn mo mp mq b">npm_modules</code>子文件夹中运行Dukat。</li><li id="49b3" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated">运行Dukat，指定一个或多个<code class="fe mn mo mp mq b">d.ts</code>文件作为输入；</li><li id="647a" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated">将生成的Kotlin文件复制到您的项目中；</li><li id="3297" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated">去掉不必要的东西，调整生成的外部声明，以便它们可以编译并满足您的需要。</li></ul><h1 id="81b7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">这些生成的文件是什么？</h1><p id="a77e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Google Maps API的TypeScript定义由一堆用于API不同部分的<code class="fe mn mo mp mq b">d.ts</code>文件组成，一个简短的<code class="fe mn mo mp mq b">index.d.ts</code>文件引用了所有这些文件。Dukat识别并遵循那些<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html" rel="noopener ugc nofollow" target="_blank">引用指令</a>，所以我能够通过运行<code class="fe mn mo mp mq b">dukat index.d.ts</code>获得所有的外部声明。我得到了一堆与原始TypeScript定义文件不一一匹配的文件，并对此感到有点困惑。结果文件的名称也有点不同——它们都以前缀<code class="fe mn mo mp mq b">style-reference</code>开头。所以让我们弄清楚Dukat生成什么文件。</p><p id="9269" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，Dukat为一些<a class="ae kc" href="https://mariusschulz.com/blog/built-in-type-declarations-in-typescript" rel="noopener ugc nofollow" target="_blank"> TypeScript标准库声明</a>生成一堆<code class="fe mn mo mp mq b">lib.*.kt</code>文件。如果您需要这些模块中包含的一些内置类型，这些是有用的；然而，这些声明文件相当大，我建议清除其中不必要的内容，甚至完全删除它们，这样这些文件就不会降低项目的编译速度。所有这些<code class="fe mn mo mp mq b">lib.*.kt</code>文件都包含了对<code class="fe mn mo mp mq b">tsstdlib</code>包的声明，并且没有被任何为Google Maps API本身生成的声明所引用。我想几乎所有库的TypeScript定义都会是这种情况，我想知道为什么Dukat总是在每次运行时输出这些标准库声明，而不是按需输出。</p><p id="bab0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">标准库已经过时了，让我们看看Dukat生成的其他文件。Dukat不仅为输入定义文件生成Kotlin声明，还为以<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/modules.html#import" rel="noopener ugc nofollow" target="_blank"> import </a>语句或<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html" rel="noopener ugc nofollow" target="_blank"> reference </a>指令的形式指定的所有依赖项生成kot Lin声明(阅读<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html#pitfalls-of-namespaces-and-modules" rel="noopener ugc nofollow" target="_blank"> this </a>以了解两者之间的区别)。依赖关系路径是相对于当前目录解析的。Dukat还会从当前目录开始在目录树中搜索一个<code class="fe mn mo mp mq b">tsconfig.json</code>文件，如果找到了，就会考虑进行依赖关系解析——这就是为什么在不同的文件夹中用相同的输入运行Dukat会得到不同的结果。</p><p id="ed5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Dukat为每个Kotlin包生成一个文件，它对应于TypeScript中的一个名称空间。如果所有这些文件都包含对单个命名空间的声明，则可以为多个TypeScript定义文件获取单个Kotlin文件；如果一个TypeScript定义文件包含几个不同的命名空间，则可以为该文件获取多个Kotlin文件。生成的Kotlin文件的名称构造如下:</p><ul class=""><li id="feea" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">首先是没有扩展名<code class="fe mn mo mp mq b">d.ts</code>的原始TypeScript定义文件的名称。单个Kotlin包(TypeScript命名空间)的声明可能驻留在多个TypeScript定义文件中；在这种情况下，使用Dukat遇到的第一个文件的名称。这就是为什么为Google Maps API生成的所有Kotlin文件都以前缀<code class="fe mn mo mp mq b">style-reference</code>开始——<code class="fe mn mo mp mq b">index.d.ts</code>中的第一个引用指令指向<code class="fe mn mo mp mq b">style-reference.d.ts</code>文件，而这个文件又声明了<code class="fe mn mo mp mq b">google.maps</code>名称空间，最终包含了API所有部分的所有声明和嵌套名称空间。我从生成文件的名称中去掉了这个前缀，因为它在这种情况下没有多大意义。</li><li id="2d8f" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated">生成的文件名的第二部分是TypeScript命名空间本身。这与该文件顶部声明的包名相同。如果原始的TypeScript定义文件在一个全局名称空间中导出它的所有定义，那么这一部分将被省略(在这种情况下，Kotlin文件也没有<code class="fe mn mo mp mq b">package</code>指令)。</li><li id="1c5a" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated">第三部分是从库的<code class="fe mn mo mp mq b">package.json</code>文件中提取的扁平模块名，并以<code class="fe mn mo mp mq b">module_</code>为前缀，如<code class="fe mn mo mp mq b">module_googlemaps</code>。只有当<code class="fe mn mo mp mq b">package.json</code>出现在当前目录或目录树中的某个位置时，该部分才会出现。</li></ul><p id="4ab5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，您可能会找到一个或多个名为<code class="fe mn mo mp mq b">nonDeclarations.&lt;package name&gt;.nonDeclarations.kt</code>的文件。这类文件包含<a class="ae kc" href="https://kotlinlang.org/docs/reference/type-aliases.html" rel="noopener ugc nofollow" target="_blank">类型别名</a>，中间的包名对应于TypeScript名称空间，在这里可以找到相应的TypeScript定义。Dukat将生成的类型别名提取到一个单独的Kotlin文件中，因为类型别名不是一个外部声明，因此它不能驻留在标有<code class="fe mn mo mp mq b"><a class="ae kc" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.js/-js-qualifier/" rel="noopener ugc nofollow" target="_blank">JsQualifier</a></code>注释的文件中。如果生成的Kotlin文件包含一个<code class="fe mn mo mp mq b">package</code>指令(也就是说，如果它包含某个TypeScript名称空间的声明)，那么这个注释就会出现在该文件中。</p><p id="19cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这些知识，我们现在可以理解为Google Maps JS API生成的所有这些文件:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="5b1f" class="ne lc iq mq b gy nf ng l nh ni">nonDeclarations.google.maps.nonDeclarations.kt                                                                                                                style-reference.google.maps.module_googlemaps.kt                                                                                                              style-reference.google.maps.event.module_googlemaps.kt                                                                                                        style-reference.google.maps.geometry.encoding.module_googlemaps.kt                                                                                            style-reference.google.maps.geometry.spherical.module_googlemaps.kt                                                                                           style-reference.google.maps.geometry.poly.module_googlemaps.kt                                                                                                style-reference.google.maps.drawing.module_googlemaps.kt                                                                                                      style-reference.google.maps.visualization.module_googlemaps.kt                                                                                                style-reference.google.maps.places.module_googlemaps.kt                                                                                                       style-reference.google.maps.adsense.module_googlemaps.kt                                                                                                      lib.dom.kt                                                                                                                                                    lib.es2015.iterable.kt                                                                                                                                        lib.es5.kt                                                                                                                                                    lib.es5.Intl.module_dukat.kt                                                                                                                                  lib.scripthost.kt                                                                                                                                             lib.es2015.collection.kt</span></pre><p id="9bb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个是<code class="fe mn mo mp mq b">nonDeclarations.google.maps.nonDeclarations.kt</code>，它包含一组来自<code class="fe mn mo mp mq b">google.maps</code> TypeScript名称空间的类型别名。然后是一堆文件名都以<code class="fe mn mo mp mq b">style-reference</code>前缀开始，以<code class="fe mn mo mp mq b">module_googlemaps</code>后缀结束的文件。我们知道这个前缀是由于Dukat找到的第一个声明<code class="fe mn mo mp mq b">google.maps</code>名称空间的文件，也就是<code class="fe mn mo mp mq b">style-reference.d.ts</code>。而<code class="fe mn mo mp mq b">module_googlemaps</code>后缀是因为<code class="fe mn mo mp mq b">package.json</code>文件中指定的<code class="fe mn mo mp mq b">@types/googlemaps</code>包名(Dukat从包名中去掉了<code class="fe mn mo mp mq b">@types</code>)。后缀和前缀之间的所有内容都是实际的Kotlin包名，我只保留了名称的这一部分，以便在将生成的文件复制到我的游戏项目时减少混乱。最后，我们有一堆标准库定义文件，我也把它们去掉了。在将生成的声明复制到我的项目结构中之后，我还清理了那些我不需要的Google Maps API部分的文件——并没有过分热衷于此，只是浏览了一下文件列表及其内容，并删除了我在游戏中明显不需要的东西，如AdSense或数据可视化支持。</p><p id="0ce6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为google-map-react生成的文件更有趣一些，因为这个库有一些外部依赖项，包括react本身:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="d803" class="ne lc iq mq b gy nf ng l nh ni">nonDeclarations.React.nonDeclarations.kt                                                                                                                      index.module_google-map-react.kt                                                                                                                              lib.dom.kt                                                                                                                                                    lib.es2015.iterable.kt                                                                                                                                        lib.es5.kt                                                                                                                                                    lib.es5.Intl.module_dukat.kt                                                                                                                                  lib.scripthost.kt                                                                                                                                             lib.es2015.collection.kt                                                                                                                                      index.module_react.kt                                                                                                                                         index.React.module_react.kt                                                                                                                                   index.module_prop-types.kt                                                                                                                                    index.module_csstype.kt</span></pre><p id="810d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mn mo mp mq b">index.module_google-map-react.kt</code>包含库本身的外部声明，并且是我们需要的唯一文件。我们可以看到它的名字由原始的TypeScript文件名(<code class="fe mn mo mp mq b">index.d.ts</code>)和取自<code class="fe mn mo mp mq b">package.json</code>的模块名<code class="fe mn mo mp mq b">google-map-react</code>组成。因此，我们可以得出结论，这个库的所有声明都包含在一个全局名称空间中，实际上，<code class="fe mn mo mp mq b">index.d.ts</code>中没有名称空间声明，生成的Kotlin文件中也没有<code class="fe mn mo mp mq b">package</code>语句。</p><p id="5ea6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原始的TypeScript定义文件导入了<code class="fe mn mo mp mq b">React</code>模块，所以Dukat通过在兄弟<code class="fe mn mo mp mq b">node_modules</code>子文件夹中发现<code class="fe mn mo mp mq b">@types/react</code>模块并为其生成Kotlin外部声明来遵循这个引用。这产生了<code class="fe mn mo mp mq b">index.module_React.kt</code>和<code class="fe mn mo mp mq b">index.React.module_react.kt</code>文件——前者用于全局名称空间声明，后者用于来自<code class="fe mn mo mp mq b">React</code>类型脚本名称空间的声明。但杜凯特并没有就此止步。React的TypeScript定义导入了<code class="fe mn mo mp mq b">csstype</code>和<code class="fe mn mo mp mq b">prop-types</code>模块，我们可以看到Dukat已经发现了它们的类型定义，并将它们也转换成了Kotlin。</p><h1 id="3d1e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Kotlin基于React的库</h1><p id="844e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">到目前为止，Dukat已经为我们提供了库的完整Kotlin外部声明集，包括它能够发现的所有库的外部依赖项。但是在Kotlin中使用React有一个比依赖Dukat生成的外部声明更好的选择。React 库有一个<a class="ae kc" href="https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-react" rel="noopener ugc nofollow" target="_blank"> Kotlin包装器，为React库提供了一个方便的接口，因为它是用Kotlin手写的。当然，我希望为google-map-react生成的绑定使用react包装器库，而不是自动生成的React外部声明。为此，我必须手工更新声明。幸运的是，这并不难——我只需像这样更新React组件类声明</a></p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="fedb" class="ne lc iq mq b gy nf ng l nh ni">@JsName("default"<strong class="mq ir">)</strong><br/><strong class="mq ir">external open class</strong> GoogleMapReact : Component&lt;Props, RState&gt; <strong class="mq ir">{</strong><br/>    <strong class="mq ir">override fun </strong>render(): ReactElement?<br/><strong class="mq ir">}</strong></span></pre><p id="18cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且还从Kotlin-react库中声明的<code class="fe mn mo mp mq b"><a class="ae kc" href="https://github.com/JetBrains/kotlin-wrappers/blob/master/kotlin-react/src/main/kotlin/react/ReactComponent.kt#L7" rel="noopener ugc nofollow" target="_blank">react.RProps</a></code>接口继承生成的<code class="fe mn mo mp mq b">Props</code>接口。这样做之后，我删除了所有生成的文件，只留下了我重命名并复制到我的项目结构中的<code class="fe mn mo mp mq b">index.module_google-map-react.kt</code>。</p><h1 id="c780" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">几个陷阱</h1><h2 id="261e" class="ne lc iq bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated">带点的名称空间</h2><p id="9e89" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我必须修改一些类和接口引用，以便生成的声明可以编译。当驻留在<code class="fe mn mo mp mq b">google.maps</code>包的子包中的某个声明引用了父包中的某个类型时，出于某种原因，Dukat生成了带有<code class="fe mn mo mp mq b">maps.</code>限定符的引用，如下所示:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="694f" class="ne lc iq mq b gy nf ng l nh ni"><strong class="mq ir">package </strong>google.maps.event<br/>...<br/>// MapsEventListener is defined in google.maps namespace<strong class="mq ir"><br/>external fun</strong> removeListener(listener: maps.MapsEventListener)</span></pre><p id="dda6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个没有编译。我不得不完全限定引用名，比如<code class="fe mn mo mp mq b">google.maps.MapsEventListener</code>，或者移除限定符并引入一个合适的类型导入。我选择了后者，并向Dukat repo提交了一个<a class="ae kc" href="https://github.com/Kotlin/dukat/issues/304" rel="noopener ugc nofollow" target="_blank"> bug </a>。</p><h2 id="e494" class="ne lc iq bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated">名称与嵌套在类中的接口冲突</h2><p id="ad9c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我还必须修复<code class="fe mn mo mp mq b">google.maps.Data</code>类中的<code class="fe mn mo mp mq b">MouseEvent</code>接口定义。生成的Kotlin文件中的以下代码片段说明了这个问题:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="581e" class="ne lc iq mq b gy nf ng l nh ni"><strong class="mq ir">namespace </strong>google.maps <strong class="mq ir">{</strong></span><span id="bc8b" class="ne lc iq mq b gy nu ng l nh ni"><strong class="mq ir">    interface </strong>MouseEvent <strong class="mq ir">{</strong> ... <strong class="mq ir">}</strong></span><span id="1c98" class="ne lc iq mq b gy nu ng l nh ni"><strong class="mq ir">    class </strong>Data <strong class="mq ir">{</strong> ... <strong class="mq ir">}</strong><br/>    <strong class="mq ir">namespace </strong>Data <strong class="mq ir">{</strong><br/>        <strong class="mq ir">interface </strong>MouseEvent : MouseEvent <strong class="mq ir">{ ... }<br/>    }<br/>}</strong></span></pre><p id="2f6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样的<code class="fe mn mo mp mq b">MouseEvent</code>接口定义显然导致编译器抱怨继承层次中的循环。在深入研究了原始的TypeScript定义一段时间后，我发现继承的接口嵌套在<code class="fe mn mo mp mq b">google.maps.Data</code>类中，而基接口直接在<code class="fe mn mo mp mq b">google.maps</code>命名空间中声明。所以这两个接口之间存在名称冲突，Dukat没有正确解决，导致了不可编译的Kotlin代码。我以完全限定的方式通过引用基础<code class="fe mn mo mp mq b">MouseEvent</code>接口修复了它，这里是提交给Dukat repo的<a class="ae kc" href="https://github.com/Kotlin/dukat/issues/303" rel="noopener ugc nofollow" target="_blank"> bug </a>。</p><h2 id="1282" class="ne lc iq bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated">“this”作为TypeScript中的泛型类型参数</h2><p id="86a4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">另一个编译错误是由于Kotlin和TypeScript泛型本质上是不同的。让我们来谈谈代码:</p><figure class="mw mx my mz gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="aaa1" class="ne lc iq bd ld nj nk dn lh nl nm dp ll ko nn no lp ks np nq lt kw nr ns lx nt bi translated">省略了类型变量的泛型类型引用</h2><p id="fb25" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我在生成的Kotlin声明中修复的最后一个东西是一个名字奇怪的类<code class="fe mn mo mp mq b">Map__0</code>。它充当泛型<code class="fe mn mo mp mq b">Map</code>类的非泛型别名:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="88c9" class="ne lc iq mq b gy nf ng l nh ni"><strong class="mq ir">external open class</strong> Map&lt;E : Element&gt;<br/>...<br/><strong class="mq ir">external open class</strong> Map__0 : Map&lt;Element&gt;</span></pre><p id="b735" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">初始TypeScript定义文件中不存在此别名。TypeScript允许在引用泛型类型时省略类型参数，让编译器来推断。另一方面，Kotlin不允许在引用泛型类时省略类型参数。Dukat生成这样一个别名类，并在TypeScript中相应的类型引用省略了类型参数时引用它而不是原始的泛型类型。因此，生成的Kotlin声明在原始TypeScript定义包含对不带任何类型参数的泛型<code class="fe mn mo mp mq b">Map</code>类型的引用的所有地方都使用了<code class="fe mn mo mp mq b">Map__0</code>。严格来说，这并不需要修复；不过，<code class="fe mn mo mp mq b">Map__0</code>这个名字看起来有点怪，所以我把它的所有用法都换成了<code class="fe mn mo mp mq b">Map&lt;Element&gt;</code>，然后把<code class="fe mn mo mp mq b">Map__0</code>这个类也掉了。我不确定为什么Dukat不遵循同样的方法，而是生成一个合成类；也许我遗漏了一些东西，但这并不是在所有情况下都是可能的。</p><h1 id="6c8a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关于使用Dukat，我学到了什么</h1><p id="5e58" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这些都是我必须对Dukat生成的Kotlin外部声明进行的修改，以使它们能够工作。有一些问题，但总的来说，这个过程相当简单明了。只需查看原始的TypeScript定义，并在需要时咨询TypeScript文档以决定如何修复声明，以防您对它们不满意。还要注意，只要Dukat不能合理地表示Kotlin中的某些类型脚本类型，它就会向生成的文件中写入注释，如果您在处理生成的声明时遇到困难，这些注释会非常有用。这些注释包含TypeScript中使用的原始类型引用或声明。我见过这样的评论出现在Dukat</p><ul class=""><li id="2048" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">放入一个特定的类型，而不是用作类型参数值的“this”(见上述<code class="fe mn mo mp mq b">addListener</code>案例)；</li><li id="34f7" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated">放入<code class="fe mn mo mp mq b">dynamic</code>(用于TypeScript <code class="fe mn mo mp mq b">any</code>的Kotlin模拟)来代替TypeScript <a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple" rel="noopener ugc nofollow" target="_blank">元组</a>类型(您将在Kotlin的注释中看到<code class="fe mn mo mp mq b">JsTuple&lt;A, B, C&gt;</code>)；</li><li id="78d0" class="me mf iq kf b kg mr kk ms ko mt ks mu kw mv la mj mk ml mm bi translated">放入<code class="fe mn mo mp mq b">dynamic</code>或一些基本类型来代替TypeScript <a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions" rel="noopener ugc nofollow" target="_blank">区别联合</a>(注释列出了所有区别联合选项，用竖线隔开)</li></ul><p id="1a1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您发现自己在处理来自生成的外部声明的<code class="fe mn mo mp mq b">dynamic</code>类型，您可能会希望转到声明文件，用某个特定的类型替换<code class="fe mn mo mp mq b">dynamic</code>——这很容易实现，因为这些注释给了您一些提示。例如，如果属性在原始TypeScript定义中有一个可区分的联合类型，那么只需选择您想要使用的选项并更新Kotlin声明来使用它，而不是使用<code class="fe mn mo mp mq b">dynamic</code>。</p><p id="4d81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我也看到过在Google Maps API类型定义中枚举被表示为不同的联合。Dukat不会为这种情况生成enum相反，它推断出基类型并使用它来替换有区别的联合:</p><pre class="mw mx my mz gt na mq nb nc aw nd bi"><span id="f1c9" class="ne lc iq mq b gy nf ng l nh ni">// TYPESCRIPT<br/><strong class="mq ir">type </strong>GestureHandlingOptions = 'cooperative' | 'greedy' | 'none' | 'auto';</span><span id="cc61" class="ne lc iq mq b gy nu ng l nh ni">// KOTLIN<br/><strong class="mq ir">var</strong> gestureHandling: String? <em class="nx">/* 'cooperative' | 'greedy' | 'none' | 'auto' */</em></span></pre><p id="f684" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，您可能希望创建enum来为代码增加更多的编译时安全性。</p><p id="9936" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在更多的情况下，您可能希望调整生成的Kotlin定义，以使它们可以编译，或者增加更多的类型安全性。在开始使用这个库之前，先熟悉这个库的TypeScript定义和生成的Kotlin声明。您将在这上面花费一些时间，但是作为回报，您将获得一个更加稳定和可预测的静态类型库接口。</p><h1 id="4034" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论——我对Kotlin vs TypeScript的两点看法</h1><p id="22b2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript定义不是原始JavaScript实现的组成部分，因此它们可能不准确或不完整。将TypeScript声明转换为Kotlin是另一个需要考虑的步骤，增加了复杂性，在某些情况下甚至会使生成的Kotlin声明不如原始的TypeScript定义严格。因此，一个问题可能会自然出现——即使您更喜欢静态类型，为什么不用TypeScript编写您的web应用程序呢？为什么要处理所有这些额外的复杂性？这当然取决于具体情况，没有唯一正确的答案，但我在下面提出了我的一些考虑。</p><p id="a87b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript是JavaScript的超集，允许向JavaScript代码添加类型。它支持逐步采用，并声明JavaScript代码也是有效的类型脚本代码。这种逐渐的采用肯定会让TypeScript传播开来并获得势头。不幸的是，我也看到这种“部分”类型被来自JavaScript背景的开发人员大量滥用，他们在编写类型脚本代码时只摘容易摘到的果实。当需要一些重构来向现有的代码库引入强类型时，或者当他们手头的任务只有一个动态类型的解决方案而不想为类型而烦恼时，他们会迅速求助于<code class="fe mn mo mp mq b">any</code>。类型推断和由此导致的<code class="fe mn mo mp mq b">any</code>类型在整个代码库中的病毒式传播进一步加剧了这个问题。在Kotlin中，采用动态类型也是可能的，但是不太常见，而且肯定不符合习惯。最终结果是，我见过的任何类型脚本代码库都更容易失去类型严格性，并且意外地无法提供编译类型检查。与使用TypeScript代码相比，使用Kotlin JS代码库时，我感觉更有信心。</p><p id="b3b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kotlin语言的另一个重大胜利是多平台倡议。如果您的应用程序既有后端又有前端需要通信，那么公共语言证明非常方便。至少，你可以共享API模型的代码，但是一旦你习惯了用一种语言写所有的东西，你会发现好处不仅仅是API模型。一些将被重用的逻辑(例如验证)将会弹出，整个应用程序代码库将会更容易导航、推理和维护。我并不否认后端和前端开发人员之间的专门化，但是为两者提供一种单一的强大的语言，并让开发人员的专业知识在某种程度上重叠，会有所帮助。</p></div></div>    
</body>
</html>