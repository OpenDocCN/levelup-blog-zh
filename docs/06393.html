<html>
<head>
<title>Persistent Data Structures for Gophers: Persistent Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">地鼠的持久数据结构:持久堆栈</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/persistent-data-structures-for-gophers-persistent-stack-70aa012d3bfa?source=collection_archive---------2-----------------------#2020-11-21">https://levelup.gitconnected.com/persistent-data-structures-for-gophers-persistent-stack-70aa012d3bfa?source=collection_archive---------2-----------------------#2020-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5bd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一系列的博客文章中，我想探索不可变持久数据结构的世界，它们与可变数据结构相比的优缺点，涵盖我们希望在哪些场景中使用它们，并提供一些理论背景。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/6c2d5419551831dfcc4d50dc6d387659.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*Oe1TwZiF1PHYSHlm.jpg"/></div></figure><p id="45d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们来定义一下什么是不可变数据结构。根据维基百科:</p><blockquote class="kt ku kv"><p id="2a79" class="jn jo kw jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated">在计算中，持久数据结构是一种在被修改时总是保留其自身的先前版本的数据结构。这种数据结构实际上是不可变的，因为它们的操作不会(明显地)就地更新结构，而是总是产生新的更新结构。</p></blockquote><p id="4332" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与可变对应物相比，我们可以立即看到几个好处:</p><ol class=""><li id="8048" class="la lb iq jp b jq jr ju jv jy lc kc ld kg le kk lf lg lh li bi translated">因为我们没有可变状态，所以我们不必担心我们调用的方法会意外地改变我们的变量</li><li id="1eb9" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated">我们不必使用锁之类的同步，理论上，当锁争用较高时，这应该会提高性能</li><li id="682c" class="la lb iq jp b jq lj ju lk jy ll kc lm kg ln kk lf lg lh li bi translated">我们有我们的结构的所有版本，如果我们想做撤销-重做这样的事情，这将非常方便。</li></ol><p id="8308" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过构建不可变堆栈来看看这在实践中意味着什么。Stack是一种抽象数据类型，支持以下操作:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="27ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们创建一个可变堆栈，看看实现是什么样子，并提供一个参考点:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="0fea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用可变切片来存储元素，并且我们必须使用锁来避免竞争情况。渐近复杂性方面，所有运算的成本为O(1)。</p><p id="3626" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看持久堆栈的实现是什么样子的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="49d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切都很简单:我们使用单独的类型来表示空堆栈，以减少代码混乱。我们还使用空堆栈的静态实例来减少内存开销，因为它没有状态，因此可以共享。Push创建一个新版本的stack并返回它，而pop只是返回一个tail，它为我们提供了我们讨论过的变更的完整历史。请注意，我们从不改变状态，因此我们从不需要使用锁。</p><p id="491f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">持久堆栈是一种非常好的数据结构，因为所有的操作都具有与可变实现完全相同的渐近复杂性，但是提供了可变实现所没有的巨大优势。当我们探索其他持久数据结构时，我们会发现情况并不总是这样。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/d5e79c986c4e8997603ea0d8983b22f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*4FaWtICEv3vctnif.jpg"/></div></figure><p id="90d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们做一些基准测试，看看不可变实现与可变实现相比如何。我设计了一个很小的用例，在这个用例中stack非常方便:假设我们正在用矢量图形构建一个绘图应用程序。所有绘制的点都表示为向量，向量本身表示为成对的点。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="2f9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以及两个保存用户编辑历史的数据结构:可变堆栈和不可变堆栈</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="692b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并不是说在不可变版本中我们必须将堆栈存储在不安全的地方。指针，因为我们需要保存堆栈的当前版本，为了做到这一点，我们必须能够自动更新当前版本的指针，这可以使用atomic.CompareAndSwapPointer来完成。</p><p id="07d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从比较推送性能的基准测试开始:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="f044" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到以下结果:</p><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="cfda" class="md me iq lz b gy mf mg l mh mi">BenchmarkMutableStackPush/push_with_1_g-6  9494250 115 ns/op<br/>BenchmarkMutableStackPush/push_with_5_g-6  9068743 131 ns/op<br/>BenchmarkMutableStackPush/push_with_100_g-6 5516866 221 ns/op<br/>BenchmarkMutableStackPush/push_with_1000_g-6 5231342 227 ns/op<br/>BenchmarkMutableStackPush/push_with_5000_g-6 5698480 243 ns/op</span></pre><p id="5d95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速提醒一下RunParallel是如何工作的:它在SetParallelism定义的多个goroutines之间分配b.N次迭代。因此，在理想情况下，如果我们将goroutines的数量增加到N，其中CPUs的数量，我们应该会看到性能提高N倍。然而，事实完全不是这样，正如我们在基准测试中看到的:从1个goroutine增加到5个并没有提高性能，反而运行得更慢了！为了理解为什么，让我们用profiler运行基准测试，看看什么占用了我们基准测试的大部分时间。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/b48797783e781a5268db127f3c065563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-a5jUaRu2nc-2abGB4bEQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">分析结果</figcaption></figure><p id="1644" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所见，74%的时间花在锁定/解锁互斥体上，这意味着我们只有26%的并行空间。</p><p id="a57b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看在push benchmark中不可变栈和可变栈的比较。推送基准代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="b7b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，我们必须进行循环，直到compareandswappoint返回true，这仅在当前oldVal等于h.history中的值时发生。我们需要这样做，因为在我们通过调用Push创建新版本的stack的时间和我们调用compareandswappoint的时间之间，其他goroutine可能已经更新了值h.history，所以我们的更新变得无效。</p><p id="9a7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果:</p><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="8bce" class="md me iq lz b gy mf mg l mh mi">BenchmarkImmutableStackPush/push_with_1_g-6 3585588 433 ns/op<br/>BenchmarkImmutableStackPush/push_with_5_g-6 4179456 339 ns/op<br/>BenchmarkImmutableStackPush/push_with_100_g-6 2486130 493 ns/op<br/>BenchmarkImmutableStackPush/push_with_1000_g-6 3969709 394 ns/op<br/>BenchmarkImmutableStackPush/push_with_5000_g-6 6096267 341 ns/op</span></pre><p id="802d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，我们被可变堆栈超越了。这是为什么呢？让我们用profiler运行代码，看看什么花费了大部分时间:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="e124" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，大部分时间都花在分配新对象和收集垃圾上。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi ms"><img src="../Images/362b4585758d827e9943088742c25d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bWbC88ESeNQ7Wk_PB85aEA.png"/></div></div></figure><p id="74e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以尝试解决这个问题的一个方法是使用sync预分配一个对象池。池并从中返回实例，而不是分配新的实例。就这么办吧。</p><p id="24dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="e4a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基准测试结果:</p><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="75e0" class="md me iq lz b gy mf mg l mh mi">ImmutableStackPushWithPool/push_with_1_g-6 5884106 229 ns/op<br/>ImmutableStackPushWithPool/push_with_5_g-6 5945172 208 ns/op<br/>ImmutableStackPushWithPool/push_with_100_g-6 6525007 273 ns/op<br/>ImmutableStackPushWithPool/push_with_1000_g-6 6722889 203 ns/op<br/>ImmutableStackPushWithPool/push_with_5000_g-6  7014976 203 ns/op</span></pre><p id="e20f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">的确，使用sync。Pool的性能与可变版本不相上下，因为我们减轻了实现中最弱的一点——垃圾收集器的压力。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="2739" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们来看看当Push和Top混合使用时，性能是如何变化的。让我们编写一个基准，在偶数迭代时调用Top，在奇数迭代时推送。可变堆栈的代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="7a5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果:</p><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="fcfb" class="md me iq lz b gy mf mg l mh mi">BenchmarkMutableStackPushAndTop/push_with_1_g-6 10864327 233.0 ns/op<br/>BenchmarkMutableStackPushAndTop/push_with_5_g-6 11345487 212 ns/op<br/>BenchmarkMutableStackPushAndTop/push_with_100_g-6 5179686 227 ns/op<br/>BenchmarkMutableStackPushAndTop/push_with_1000_g-6 5018956 202 ns/op<br/>BenchmarkMutableStackPushAndTop/push_with_5000_g-6 7064036 204 ns/op</span></pre><p id="0ee8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不可变堆栈的代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="05d4" class="md me iq lz b gy mf mg l mh mi">ImmutableStackPushAndTop/push_with_1_g-6  11457074 261 ns/op<br/>ImmutableStackPushAndTop/push_with_5_g-6 12009836 301 ns/op<br/>ImmutableStackPushAndTop/push_with_100_g-6 11332501 262 ns/op<br/>ImmutableStackPushAndTop/push_with_1000_g-6 10732173 264 ns/op<br/>ImmutableStackPushAndTop/push_with_5000_g-6 11492300 256 ns/op</span></pre><p id="1a6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，这次的结果与可变堆栈相当。这是因为我们不需要做太多的分配，因此我们在GC上花费的时间更少，而且，与可变堆栈不同，当我们调用Top时，我们不需要在锁中花费时间。但是如果我们用池运行不可变的版本呢？</p><pre class="km kn ko kp gt ly lz ma mb aw mc bi"><span id="25bd" class="md me iq lz b gy mf mg l mh mi">ImmutablePooledStackPushAndTop/push_with_1_g-6 11825787 127 ns/op<br/>ImmutablePooledStackPushAndTop/push_with_5_g-6 11818896 119 ns/op<br/>ImmutablePooledStackPushAndTop/push_with_100_g-6 12145059 129 ns/op<br/>ImmutablePooledStackPushAndTop/push_with_1000_g-6 11344802 120 ns/op<br/>ImmutablePooledStackPushAndTop/push_with_5000_g-6 11398592 127 ns/op</span></pre><p id="31c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们能够以两倍的速度击败可变堆栈！这是因为池化的不可变堆栈具有两个世界的优点:由于是不可变的，所以没有锁；由于使用了sync.Pool，所以GC开销更小。</p><p id="ad41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以表格形式显示基准测试结果:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lo lp l"/></div></figure></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><p id="489b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，结果并不那么明显。然而，根据Push/Top调用的具体比例，当我们需要获得最后的性能百分比时，不可变堆栈可能是我们工具箱中的一个很好的工具。在本系列的下一篇文章中，我将研究更多不可变的数据结构，解释它们的用例，并探索它们的性能。所有的代码都可以在github的<a class="ae mt" href="https://github.com/OlegStotsky/go-persistent" rel="noopener ugc nofollow" target="_blank">资源库</a>中找到。请随意投稿。</p><p id="a118" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读，敬请关注新帖子！</p></div></div>    
</body>
</html>