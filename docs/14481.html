<html>
<head>
<title>Grokking the Coding Interview: Pattern Island</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索编码面试:模式岛</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/grokking-the-coding-interview-pattern-island-dc9c7def6b54?source=collection_archive---------6-----------------------#2022-12-01">https://levelup.gitconnected.com/grokking-the-coding-interview-pattern-island-dc9c7def6b54?source=collection_archive---------6-----------------------#2022-12-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1325" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编码模式增强了我们“将新问题映射到已知问题的能力”</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/687009f297ea68f9244d5540dff88aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*Ft36JW2Hxta20FSfwOE9Og.jpeg"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">照片由<a class="ae kx" href="https://unsplash.com/es/@seefromthesky?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊山@seefromthesky </a>在<a class="ae kx" href="https://unsplash.com/s/photos/island?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="6090" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说，学习使用算法模式解决问题真的是一种更安全的生活。</p><p id="fa6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些模式背后的想法是，一旦你熟悉了一个模式，你就能够用它解决许多问题。</p><p id="4681" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过这样做，我节省了大量的时间，否则我会花在准备编码面试上。</p><p id="4f3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天，我们来讨论一种最常用的算法模式，叫做<strong class="jp ir">孤岛模式</strong>。</p><h1 id="d0c7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">背景</h1><p id="ee99" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">许多编码面试问题涉及遍历2D阵列(又名矩阵或网格)。<strong class="jp ir">岛模式</strong>描述了一种遍历矩阵的有效方式。该模式帮助我们理解使用<strong class="jp ir">深度优先搜索(DFS) </strong>和<strong class="jp ir">宽度优先搜索(BFS) </strong>方法及其变体的矩阵遍历。</p><p id="1fdb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们跳到一个问题上来理解这个模式。</p><h1 id="80ba" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">岛屿数量(简易)</strong></h1><h2 id="b066" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated"><strong class="ak">问题陈述</strong></h2><p id="4390" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">给定一个只包含<code class="fe mn mo mp mq b">1</code> s(陆地)和<code class="fe mn mo mp mq b">0</code> s(水)的2D数组(即矩阵)，计算其中岛屿的数量。</p><p id="b4d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<strong class="jp ir">岛</strong>是一组<code class="fe mn mo mp mq b">1</code> s(陆地)的连接，并且被一条边或者<code class="fe mn mo mp mq b">0</code> s(水)包围。每个像元都被视为水平或垂直(非对角)连接到其他像元。</p><p id="6954" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例1 </strong></p><p id="62fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入</strong>:矩阵=</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/f24764d218f4d44df7744febf983e81b.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*GawFWwKWe16VDKDxO-roRQ.png"/></div></figure><p id="3f17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出</strong>:1<br/>T29】说明:矩阵只有一个岛。请参见下面突出显示的单元格。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/4220ed75c535f3cb69d3f707a9ae3378.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*5cR1E7Ofuq7co4m6o5Jz8w.png"/></div></figure><p id="e422" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例2 </strong></p><p id="da5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输入</strong>:矩阵=</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/46cbc4632411e00894bb5634346aa250.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*bqdOOifYUAroh-a4UEZ5yA.png"/></div></figure><p id="74de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出</strong> : 3 <br/> <strong class="jp ir">说明</strong>:矩阵有三个岛。请参见下面突出显示的单元格。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/938b0d22cf56baea2dfb257ff45c8c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*tsj4MFJHBTLSqRIHm0ywYQ.png"/></div></figure><h1 id="c92f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">解决办法</h1><p id="2310" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我们可以线性遍历矩阵来寻找岛。</p><p id="4588" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当我们找到一个值为‘1’的单元(即陆地)，我们就找到了一个岛。使用该单元作为根节点，我们将执行<strong class="jp ir">深度优先搜索(DFS) </strong>或<strong class="jp ir">宽度优先搜索(BFS) </strong>来找到其所有连接的陆地单元。在我们的DFS或BFS遍历期间，我们将找到并标记所有水平和垂直连接的陆地单元。</p><p id="4990" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要一种机制来标记每个陆地单元，以确保每个陆地单元只被访问一次。要标记已访问的单元格，我们有两个选项:</p><ol class=""><li id="8a89" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">我们可以更新给定的输入矩阵。每当我们看到一个‘1’，我们就会把它变成‘0’。</li><li id="b588" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">可以使用单独的布尔矩阵来记录每个单元是否被访问过。</li></ol><p id="899c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是上述示例2的DFS或BFS遍历:</p><p id="d643" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过遵循上面的算法，每次DFS或BFS被触发时，我们确信我们已经找到了一个岛。我们将保持连续计数来计算岛屿的总数。</p><p id="d827" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面，我们将看到三种基于以下内容的解决方案:</p><ol class=""><li id="334e" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">深度优先搜索</li><li id="ae8b" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">BFS</li><li id="8cf0" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">带访问矩阵的BFS</li></ol><blockquote class="nh ni nj"><p id="d7b0" class="jn jo nk jp b jq jr js jt ju jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj kk ij bi translated"><em class="iq">关于这些模式的详细讨论以及相关问题的解决方案，请看一下</em> <a class="ae kx" href="https://www.designgurus.org/course/grokking-the-coding-interview" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="iq">钻研编码面试</em> </strong> </a> <em class="iq">。</em></p></blockquote><h1 id="3e73" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">代码(DFS)</h1><p id="d9de" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这是我们的DFS算法的样子。我们将更新输入矩阵以标记访问过的单元。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/afe64b46e9d62526b192f64d77a12524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UlkX4bRLtaWdCWJMuZOl7w.png"/></div></div></figure><h2 id="d9d8" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">时间复杂度</h2><p id="5fe5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">上述算法的时间复杂度将为<em class="nk"> O </em> (M <em class="nk"> *N </em>)，其中‘M’为输入矩阵的行数，‘N’为输入矩阵的列数。这是因为我们必须遍历整个矩阵才能找到岛。</p><h2 id="c147" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">空间复杂性</h2><p id="7334" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">当整个矩阵填满“1”时，DFS递归堆栈可以达到M*N深度。因此，空间复杂度将是<em class="nk"> O </em> (M <em class="nk"> *N </em>)，其中“M”是输入矩阵的行数，“N”是输入矩阵的列数。</p><h1 id="fdd9" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">代码(BFS)</h1><p id="df25" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这是我们的BFS算法的样子。我们将更新输入矩阵以标记访问过的单元。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nt"><img src="../Images/eefff1d47b27c6af88821d85a56eb8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hojeqkIuusqLZedbuJYB1Q.png"/></div></div></figure><h2 id="b831" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">时间复杂度</h2><p id="c138" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">上述算法的时间复杂度将为<em class="nk"> O </em> (M <em class="nk"> *N </em>)，其中“M”为行数，“N”为列数。</p><h2 id="8d04" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">空间复杂性</h2><p id="5511" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">上述算法的空间复杂度为O(min(M，N)。在最坏的情况下，当矩阵完全被陆地单元填满时，队列的大小可以增长到min(M，N)。</p><h1 id="c404" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">代码(带访问矩阵的BFS)</h1><p id="9113" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">这是我们的DFS算法的样子。我们将保留一个单独的布尔矩阵来记录每个单元格是否被访问过。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nu"><img src="../Images/d4b7f4210706afff169c81e1dcd909a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41Dqx4f8Q00HFZqrfNzf2w.png"/></div></div></figure><h2 id="9ee2" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">时间复杂度</h2><p id="c36b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">上述算法的时间复杂度将为<em class="nk"> O </em> (M <em class="nk"> *N </em>)，其中“M”为行数，“N”为列数。</p><h2 id="8c5f" class="mb kz iq bd la mc md dn le me mf dp li jy mg mh lm kc mi mj lq kg mk ml lu mm bi translated">空间复杂性</h2><p id="3846" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">由于被访问的数组和队列的最大尺寸，空间复杂度将是O(M*N)，其中‘M’是输入矩阵的行数，而‘N’是输入矩阵的列数。</p><h1 id="ded1" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">基于岛模式的其他问题</h1><p id="08c4" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">以下是使用孤岛模式可以解决的几个问题:</p><ol class=""><li id="0bd2" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated"><a class="ae kx" href="https://designgurus.org/path-player?courseid=grokking-the-coding-interview&amp;unit=grokking-the-coding-interview_62d53be009288Unit" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">【最大岛(易)】</strong> </a></li><li id="4eda" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><a class="ae kx" href="https://designgurus.org/path-player?courseid=grokking-the-coding-interview&amp;unit=grokking-the-coding-interview_62d52d75d7964Unit" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">【洪水补易】</strong> </a></li><li id="f765" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><a class="ae kx" href="https://designgurus.org/path-player?courseid=grokking-the-coding-interview&amp;unit=grokking-the-coding-interview_62d6145eebddeUnit" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">【封闭岛屿数量(容易)</strong> </a> <a class="ae kx" href="https://designgurus.org/path-player?courseid=grokking-the-coding-interview&amp;unit=grokking-the-coding-interview_62d679f549f28Unit" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">【岛屿周长(容易)</strong> </a></li><li id="c618" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><a class="ae kx" href="https://designgurus.org/path-player?courseid=grokking-the-coding-interview&amp;unit=grokking-the-coding-interview_62d679f3bf35bUnit" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">不同岛屿的数量(中等)</strong> </a></li><li id="c6f8" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated"><a class="ae kx" href="https://designgurus.org/path-player?courseid=grokking-the-coding-interview&amp;unit=grokking-the-coding-interview_62d679f1e93e0Unit" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">循环矩阵(中)</strong> </a></li></ol><h1 id="ad67" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="a532" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">不管喜欢与否，LeetCode类型的问题几乎是每个编程面试的一部分，所以每个软件开发人员都应该在面试前练习一下。他们唯一的选择是聪明地准备，通过关注潜在的问题模式来学习解决问题。在<a class="ae kx" href="https://www.designgurus.org/course/grokking-the-coding-interview" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">寻找编码面试</strong> </a>和<a class="ae kx" href="https://designgurus.org/course/grokking-dynamic-programming" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">寻找编码面试的动态编程</strong> </a>中了解更多关于这些模式和样本问题的信息。</p><p id="da06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看<a class="ae kx" href="http://www.designgurus.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">设计大师</strong> </a>关于编码和系统设计面试的一些有趣课程。</p><div class="nv nw gp gr nx ny"><a href="https://designgurus.org/blog/dont-just-leetcode" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">不要只是LeetCode请遵循编码模式</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">编码面试越来越难通过了。为了准备编码面试，你需要几周甚至几个月的时间…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">designgurus.org</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kr ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/grokking-the-coding-interview-pattern-sliding-window-20ef83ae5872"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">探索编码面试:模式滑动窗口</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">聪明行事，学习编码模式，以便更快、更有效地准备编码面试。</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oh l"><div class="on l oj ok ol oh om kr ny"/></div></div></a></div><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/system-design-interview-survival-guide-2023-preparation-strategies-and-practical-tips-ba9314e6b9e3"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">系统设计面试生存指南(2023):准备策略和实用技巧</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">2023年系统设计面试剧本。</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oh l"><div class="oo l oj ok ol oh om kr ny"/></div></div></a></div></div></div>    
</body>
</html>