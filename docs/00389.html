<html>
<head>
<title>Performing Async Actions using Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用挂钩执行异步操作</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/performing-async-actions-using-hooks-e4da47293d8e?source=collection_archive---------0-----------------------#2019-02-03">https://levelup.gitconnected.com/performing-async-actions-using-hooks-e4da47293d8e?source=collection_archive---------0-----------------------#2019-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/36e5c6132699bee8c3fc27440a353630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sdTURhdP_W9-s79RCiEdbw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/photos/gTQbZXL417Q?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布鲁克·安德森</a>在<a class="ae kc" href="https://unsplash.com/search/photos/rock-climbing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b889" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，我写了关于使用<a class="ae kc" href="https://medium.com/front-end-weekly/data-fetcher-component-using-hooks-and-render-props-aacf3162dfc2" rel="noopener">钩子和渲染道具</a>获取数据的文章。这篇文章的目的是获取和显示数据。在这篇文章中，我想重温一下那篇文章，并用例子来扩展它，展示如何使用相同的概念来执行其他类型的操作(例如发布数据)。</p><h2 id="9d93" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">我们如何抽象出数据动作？</h2><p id="3f54" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">无论您是获取、更新、添加、删除还是执行自定义操作，所有这些操作都有一个共同点。它们都要经历三个阶段——加载、成功/数据和错误。这三个阶段是UI开发的组成部分。我们做的任何操作(甚至不需要是API动作)，都会有这三种状态。</p><p id="380e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们考虑一下界面。我们的接口接受一个异步动作(在我们的例子中，它是一个函数),并返回三个状态以及执行该动作的方法。</p><p id="6f61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想提一下，仅仅用一个钩子或者一个组件是不够的。操作必须遵循提供的接口；这样，我们的逻辑才能正常工作。当抽象任何一种逻辑时，这是需要记住的重要事情之一。我们应该建立抽象概念的所有部分都同意的接口/契约。</p><h2 id="fc76" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">使用钩子构建异步操作功能</h2><p id="f298" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">钩子提供了一种将定制的、可重用的<strong class="kf ir">功能</strong>集成到我们的组件中的方法。我们曾经为视图逻辑重用组件，现在我们也可以使用钩子重用业务逻辑。在编写实现之前，让我们展示一下我们将如何使用它:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="6779" class="lb lc iq me b gy mi mj l mk ml">import React from 'react';<br/>import { useAction } from './hooks';<br/>import { saveProfile } from './api';</span><span id="4b04" class="lb lc iq me b gy mm mj l mk ml">function App() {<br/>  // The second element "perform" is just a variable using array destructor<br/>  <strong class="me ir">const [state, perform] = useAction(saveProfile);</strong></span><span id="d3bd" class="lb lc iq me b gy mm mj l mk ml">  // We send the data as an argument into the perform function,<br/>  // which in our case === "updateProfile"<br/>  <strong class="me ir">async function handleSuccess(e) {<br/>    e.preventDefault();<br/>    await perform({ age: "12456" });<br/>  }</strong></span><span id="1bc5" class="lb lc iq me b gy mm mj l mk ml"><strong class="me ir">  async function handleError(e) {<br/>    e.preventDefault();<br/>    await perform({ age: "test" });<br/>  }</strong></span><span id="d7a3" class="lb lc iq me b gy mm mj l mk ml">  // Helper function to action result coming from the hook<br/>  // The tested values in this function are the<br/>  // values returned from hook function<br/>  <strong class="me ir">function renderStatus() {<br/>    if (state.loading) return "Loading...";</strong></span><span id="ef70" class="lb lc iq me b gy mm mj l mk ml"><strong class="me ir">    if (state.error) return `Error: ${state.error.message}`;</strong></span><span id="c38b" class="lb lc iq me b gy mm mj l mk ml"><strong class="me ir">    return `Data: ${JSON.stringify(state.data)}`;<br/>  }</strong></span><span id="8c68" class="lb lc iq me b gy mm mj l mk ml">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;button onClick={<strong class="me ir">handleSuccess</strong>}&gt;Success!&lt;/button&gt;<br/>      &lt;button onClick={<strong class="me ir">handleError</strong>}&gt;Error!&lt;/button&gt;<br/>      &lt;div className="status"&gt;{<strong class="me ir">renderStatus()</strong>}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="f926" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在开始实施:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0d93" class="lb lc iq me b gy mi mj l mk ml">// hooks.js</span><span id="dcf7" class="lb lc iq me b gy mm mj l mk ml">import { useState } from 'react';</span><span id="de60" class="lb lc iq me b gy mm mj l mk ml">export const useAction = (action) =&gt; {<br/>  const [loading, setLoading] = useState(false);<br/>  const [data, setData] = useState(null);<br/>  const [error, setError] = useState(null);</span><span id="14ae" class="lb lc iq me b gy mm mj l mk ml">  // The incoming "action" argument to the hook is NOT performed.<br/>  // It is only stored in the function scope; so that, we can use it when<br/>  // performing the action using the following function<br/>  // This function is returned as the second element in the returned array<br/>  <strong class="me ir">const performAction = async (body = null) =&gt; {<br/>    try {<br/>      setLoading(true);<br/>      setData(null);<br/>      setError(null);<br/>      const data = await action(body);<br/>      setData(data);<br/>    } catch (e) {<br/>      setError(e);<br/>    } finally {<br/>      setLoading(false);<br/>    }<br/>  }</strong></span><span id="3eb4" class="lb lc iq me b gy mm mj l mk ml">  return [{ loading, data, error }, performAction];<br/>}</span></pre><p id="9fa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个简单的钩子给了我们要执行的当前状态动作和执行动作的函数。body参数在<code class="fe mn mo mp me b">performAction</code>函数中，因为非GET请求通常有一个请求体。在上面的例子中，如果我们调用<code class="fe mn mo mp me b">perform</code>函数，加载、数据和错误状态将被“钩子”设置。然后，我们可以轻松地使用这些状态来执行我们的视图逻辑(显示加载栏、显示错误或显示操作成功)。</p><p id="a7e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，我们使用<code class="fe mn mo mp me b">try/catch/finally</code>块来决定我们是收到错误还是成功。这些块中使用的try catch不是我们从编程中了解的“真正的”try catch。它们是伪装在异步块中的承诺解决/拒绝方法。我前面提到过，动作必须在钩子提供的接口上达成一致，以统一和简化开发人员的体验。在我们的例子中，接口是必须返回成功数据，必须抛出错误。下面是一个API调用代码示例:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d771" class="lb lc iq me b gy mi mj l mk ml">// api.js</span><span id="8ceb" class="lb lc iq me b gy mm mj l mk ml">export const updateProfile = async (body) =&gt; {<br/>  const response = await fetch(SOME_URL_HERE, {<br/>    method: 'PUT',<br/>    body,<br/>    headers: {<br/>      'Content-Type': 'application/json'<br/>    }<br/>  }</span><span id="7980" class="lb lc iq me b gy mm mj l mk ml">  const data = await response.json();<br/>  if (!response.ok) {<br/>    throw new Error(data);<br/>  }</span><span id="8a1c" class="lb lc iq me b gy mm mj l mk ml">  return data;<br/>}</span></pre><p id="6c64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，fetch会抛出与API无关的错误(网络中断、JSON验证错误等)。然而，我们也为我们的API逻辑抛出了错误(错误的请求，REST 404等)。这允许我们以类似的方式显示来自API的所有错误的处理错误(将其存储在状态中),并使我们更容易考虑我们的操作逻辑。如果你想区分获取错误和API错误，你可以创建一个单独的错误类(例如<code class="fe mn mo mp me b">ApiError</code>)并抛出它，而不是一般的JS <code class="fe mn mo mp me b">Error</code>。</p><p id="bad9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。现在，多亏了钩子，你可以使用一个简单而强大的接口来执行异步数据相关的操作！</p><h1 id="9a0c" class="mq lc iq bd ld mr ms mt lg mu mv mw lj mx my mz lm na nb nc lp nd ne nf ls ng bi translated">演示</h1><p id="bb17" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我添加了一个简单的演示来展示它是如何工作的。演示和代码样本之间唯一的区别是，我没有做真正的<code class="fe mn mo mp me b">fetch</code>请求，而是模仿了一个API请求。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="nh ni l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">CodeSandbox演示</figcaption></figure><h1 id="edc9" class="mq lc iq bd ld mr ms mt lg mu mv mw lj mx my mz lm na nb nc lp nd ne nf ls ng bi translated">结论</h1><p id="c61b" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这篇文章的重点是概括数据获取，以允许执行任何类型的异步操作。定制挂钩使得构建可附加到任何组件的定制和可重用功能变得非常容易。无冲突行为为我们提供了一种安全的方法来将业务逻辑从视图逻辑中分离出来，而不需要创建组件。</p><p id="d61f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nj">编辑:改写了帖子中的代码示例；所以，很清楚是怎么回事。添加了CodeSandbox演示。修正了一些语法问题。澄清了一些文字。</em></p><p id="1104" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编辑2:修正了钩子逻辑，错误不会在每个执行函数中被清除。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><figure class="lz ma mb mc gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nr"><img src="../Images/b62413b7c7ec47e9b1212d1f624904d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*szVYYV-196U4G4zx0_1gUg.png"/></div></a></figure><div class="ns nt gp gr nu nv"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">排名前49的React教程-免费学习React。课程由开发人员提交并投票，使您能够…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">gitconnected.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj jw nv"/></div></div></a></div></div></div>    
</body>
</html>