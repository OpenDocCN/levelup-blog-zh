<html>
<head>
<title>The impact of cache locality on performance in C through matrix multiplication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过矩阵乘法研究高速缓存局部性对C语言性能的影响</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/c-programming-hacks-4-matrix-multiplication-are-we-doing-it-right-21a9f1cbf53?source=collection_archive---------5-----------------------#2020-07-29">https://levelup.gitconnected.com/c-programming-hacks-4-matrix-multiplication-are-we-doing-it-right-21a9f1cbf53?source=collection_archive---------5-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b78d1b080d4362fb9123d4c38c622614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oKe6BiIfwkM5EkOO"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@sctgrhm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯科特·格雷厄姆</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="80cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">矩阵乘法对计算机科学领域的任何人来说都是小菜一碟。<em class="le">能有多难</em>😏<em class="le">？这只是创建2D数组，用数据填充它，最后是一个嵌套循环的问题。您可能会惊讶地听到，如何实现矩阵乘法会对运行时间产生重大影响。</em></p><h2 id="747b" class="lf lg it bd lh li lj dn lk ll lm dp ln kr lo lp lq kv lr ls lt kz lu lv lw lx bi translated"><strong class="ak"> <em class="ly"> C代码为矩阵乘法</em> </strong></h2><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e02c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用以下命令编译并运行它。</p><pre class="lz ma mb mc gt mf mg mh mi aw mj bi"><span id="9cd9" class="lf lg it mg b gy mk ml l mm mn">gcc -o matrix MatrixMultiplication.c<br/>./martix</span></pre></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="70c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们大多数人实现矩阵乘法的方式。<em class="le">我们可以做出哪些改变？</em>我们可以改变嵌套循环的顺序吗？当然可以！没有规则规定循环的顺序应该是i → j → k(尽管我们大部分时间都是这样做的😄).您可以按如下方式编写一个循环，并且仍然会得到正确的输出(顺序无关紧要)。</p><pre class="lz ma mb mc gt mf mg mh mi aw mj bi"><span id="6e2f" class="lf lg it mg b gy mk ml l mm mn"><strong class="mg iu">for </strong>(<strong class="mg iu">int </strong>k = 0; k &lt; n; k++) {<br/>    <strong class="mg iu">for </strong>(<strong class="mg iu">int </strong>j = 0; j &lt; n; j++) {<br/>        <strong class="mg iu">for </strong>(<strong class="mg iu">int </strong>i = 0; i &lt; n; i++) {<br/>            C[i][j] += A[i][k] * B[k][j];<br/>        }<br/>    }<br/>}</span></pre><blockquote class="mv"><p id="bb97" class="mw mx it bd my mz na nb nc nd ne ld dk translated">有趣的问题是，这会对表演产生影响吗？</p></blockquote><p id="a2bd" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">让我们来了解一下！</p><h1 id="8b21" class="nk lg it bd lh nl nm nn lk no np nq ln nr ns nt lq nu nv nw lt nx ny nz lw oa bi translated">实验</h1><p id="9510" class="pw-post-body-paragraph kg kh it ki b kj ob kl km kn oc kp kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">我改变了嵌套循环的顺序，并对每个组合执行了三次迭代。结果如下。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/c1ee541b9f7c6a53b34558540e517f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JT43Fp4UY1Ina4CHyVOZ0w.png"/></div></div></figure><p id="ff9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是不是很神奇？仅仅通过改变嵌套循环的顺序，就可以将运行时间从279.78秒(最差)减少到34.78秒(最好)。顺序为[i，k，j]的嵌套循环比[k，j，i]快8倍T14。<strong class="ki iu"> <em class="le">但是为什么呢？</em>T19】</strong></p><h1 id="acd6" class="nk lg it bd lh nl nm nn lk no np nq ln nr ns nt lq nu nv nw lt nx ny nz lw oa bi translated">缓存位置</h1><p id="e568" class="pw-post-body-paragraph kg kh it ki b kj ob kl km kn oc kp kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">为了理解我们的结果，我们需要知道数据实际上是如何存储和访问的。在C语言中，二维数组按行优先顺序存储在RAM中(与Fortran相反，Fortran中二维数组按列优先顺序存储)。行优先顺序仅仅意味着一行的连续元素在存储器中彼此相邻，而在列优先顺序中，一列的连续元素在存储器中彼此相邻。下图将有助于更好的理解。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/79d7ff1a2b834735c72488693740f698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vG9VbcG7M00xa1ZOtPELyA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</figcaption></figure><p id="2e28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要处理的数据从RAM加载到缓存中。高速缓冲存储器从RAM中一次读取相当于一个高速缓存行的数据。假设高速缓存行的大小是64字节，即使我们需要访问一个只有4字节的整数类型变量，高速缓存也必须加载整个64字节。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/10abfc80ecea2af72d96bf8358315839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HA-0AvOYRVFTBbsX6Ctyw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</figcaption></figure><p id="01b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">先前访问的高速缓存线存储在高速缓存存储器中。当CPU需要访问一些数据时，系统首先检查该特定数据在缓存中是否可用。如果可用，我们称之为缓存命中。如果不是，则称为缓存未命中，需要从RAM中加载数据。缓存命中允许更快的数据访问(这是微不足道的，因为从RAM加载数据需要更多时间)。</p><p id="8c1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以很容易地分析我们的结果。让我们考虑顺序I，j，k。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oj"><img src="../Images/a01bd86fa4729ae0dad7f4afc8db5a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6_9TJ5bDknR_5k79eMyX0w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</figcaption></figure><p id="11ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设i=1，j=2，k = 0..n，我们需要访问矩阵A 的整个第2行和矩阵B 的整个第3列。如果你看一下图中的内存布局，很明显，访问矩阵A 的第2行<em class="le">提供了良好的空间局部性，因为我们需要的所有数据都在一个缓存行中。然而，在<em class="le">矩阵B </em>中，我们需要为每个列值访问不同的缓存行，这将导致<strong class="ki iu">更高的缓存未命中率</strong>。</em></p><p id="be0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似地，如果我们考虑顺序I，k，j(假设i=1，k = 2，j = 0..n)</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/a43dff5c6a8c42ab9cdc57bb90eadad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HjHvhHUbTpzpHnrLOHRkgA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</figcaption></figure><p id="de75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这三种情况下，我们都获得了良好的空间局部性，这将降低缓存未命中率。</p><p id="dd6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用以下命令来计算缓存未命中率。</p><pre class="lz ma mb mc gt mf mg mh mi aw mj bi"><span id="3229" class="lf lg it mg b gy mk ml l mm mn">valgrind --tool=cachegrind ./matrix</span></pre><p id="df29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">【根据您的系统硬件和矩阵大小，处理可能需要一些时间，请耐心等待</em>😄<em class="le">】</em></p><p id="ca97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下表显示了末级缓存未命中率。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/187e08f9dda36db89d4fa2c2d7c9c37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*un6CAwf2K97E9znhyFrxrg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">作者图片</figcaption></figure><p id="1c20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从该表中可以明显看出，末级缓存未命中率和经过的时间之间有很强的相关性。缓存未命中率最高为3.6%的[j，k，i]和[k，j，i]的运行时间也最长，约为279秒。同样，缓存未命中率最小为0.2%的[i，k，j]和[k，I，j]的运行时间也最少，为~35秒。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="2c82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能想知道，如果我们使用编译器优化标志会发生什么。它会自己处理缓存局部性吗？下面是用-O3优化标志编译得到的结果。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi om"><img src="../Images/b40aea30dd8ba2199b961691a52fcbe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*QlLzZTxSrD8EVE0OBTCfag.png"/></div></figure><p id="0cd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，很明显，您不能依赖编译器，而必须在编码时考虑缓存空间局部性。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="ceeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">本文的灵感来源于查尔斯·莱瑟森教授关于性能工程的讲座</em><a class="ae kf" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-172-performance-engineering-of-software-systems-fall-2018/lecture-videos/lecture-1-intro-and-matrix-multiplication/" rel="noopener ugc nofollow" target="_blank"><em class="le"/></a></p></div></div>    
</body>
</html>