<html>
<head>
<title>JavaScript Best Practice — Replacing Old with New</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践——以新换旧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practice-replacing-old-with-new-dd7a6c8228fb?source=collection_archive---------5-----------------------#2020-02-18">https://levelup.gitconnected.com/javascript-best-practice-replacing-old-with-new-dd7a6c8228fb?source=collection_archive---------5-----------------------#2020-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/14a944276d00fe29e0aa4b574506ece2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ys02aMMt29fPMLIN"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@b620?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">巴西托普诺</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8a8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何其他编程语言一样，JavaScript有自己的最佳实践列表，使程序更容易阅读和维护。JavaScript有很多棘手的部分，我们可以遵循一些最佳实践来改进我们的代码。</p><p id="b7f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自从ES6被引入以来，新的结构取代旧的结构是有原因的。它更短、更清晰、更容易理解。</p><p id="adab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看哪些旧的构造可以被新的替换，包括用<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>替换<code class="fe le lf lg lh b">then</code>，用<code class="fe le lf lg lh b">Map</code> s替换字典对象，用扩展操作符替换<code class="fe le lf lg lh b">apply</code>，以及用类语法替换函数构造器。</p><h1 id="4437" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用Async / Await替换Then</h1><p id="c4fd" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">当我们链接承诺时，我们通常使用<code class="fe le lf lg lh b">then</code>方法，然后在传递给<code class="fe le lf lg lh b">then</code>的回调函数中返回另一个承诺。</p><p id="2f7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们有类似这样的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a4af" class="mt lj it lh b gy mu mv l mw mx">Promise.resolve(1)<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>    return Promise.resolve(2);<br/>  })<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>    return Promise.resolve(3);<br/>  })<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>  })</span></pre><p id="ce19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">引入了<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>语法，这只是重复调用<code class="fe le lf lg lh b">then</code>方法的一种速记。我们可以这样写上面的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6447" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  const val1 = await Promise.resolve(1);<br/>  console.log(val1);<br/>  const val2 = await Promise.resolve(2);<br/>  console.log(val2);<br/>  const val3 = await Promise.resolve(3);<br/>  console.log(val3);<br/>})();</span></pre><p id="e093" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们都输出1、2和3，但是第二段代码要短得多。它是如此清晰，以至于没有理由回到旧的语法。</p><p id="3a97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以通过使用<code class="fe le lf lg lh b">for-await-of</code>循环来循环遍历承诺并一个接一个地运行它们。我们可以通过重写如下代码来循环执行上面的承诺:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="69c0" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  const promises = [<br/>    Promise.resolve(1),<br/>    Promise.resolve(2),<br/>    Promise.resolve(3),<br/>  ]</span><span id="0b15" class="mt lj it lh b gy my mv l mw mx">  for await (let p of promises) {<br/>    const val = await p;<br/>    console.log(val);<br/>  }<br/>})();</span></pre><p id="6a82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像上面这样的代码可以非常方便地循环遍历许多承诺或即时创建的承诺，这在前面的例子中是做不到的。</p><h1 id="7283" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用地图替换字典对象</h1><p id="f7e4" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">ES6还引入了<code class="fe le lf lg lh b">Map</code>构造函数，它让我们无需使用带有字符串键的JavaScript对象就可以创建散列图或字典。</p><p id="8f67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也更好，因为它们有自己的方法来获取和操作条目。</p><p id="7bd9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7a07" class="mt lj it lh b gy mu mv l mw mx">const dict = {<br/>  'foo': 1,<br/>  'bar': 2<br/>}</span></pre><p id="8464" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="cbe4" class="mt lj it lh b gy mu mv l mw mx">const dict = new Map([<br/>  ['foo', 1],<br/>  ['bar', 2]<br/>])</span></pre><p id="e794" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过使用<code class="fe le lf lg lh b">get</code>方法得到一个条目，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0f12" class="mt lj it lh b gy mu mv l mw mx">console.log(dict.get('foo'));</span></pre><p id="5c7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">set</code>方法通过条目的键来设置现有条目的值:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="fb94" class="mt lj it lh b gy mu mv l mw mx">dict.set('foo', 2);</span></pre><p id="e47a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以用<code class="fe le lf lg lh b">has</code>方法检查给定键的条目是否存在:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c7bd" class="mt lj it lh b gy mu mv l mw mx">dict.has('baz');</span></pre><p id="6087" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有<code class="fe le lf lg lh b">keys</code>和<code class="fe le lf lg lh b">entries</code>方法分别获取地图的所有键和所有条目。</p><p id="a2c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c838" class="mt lj it lh b gy mu mv l mw mx">console.log(dict.keys());</span></pre><p id="3265" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用<code class="fe le lf lg lh b">Map</code>的键获得一个迭代器对象。这意味着我们可以用<code class="fe le lf lg lh b">for...of</code>循环遍历它们，或者用spread操作符将其转换成一个数组。</p><p id="276f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似地，<code class="fe le lf lg lh b">entries</code>方法返回一个迭代器对象，其中包含了<code class="fe le lf lg lh b">Map</code>中的所有条目，每个条目都是一个<code class="fe le lf lg lh b">[key, value]</code>数组。</p><p id="ac1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个<code class="fe le lf lg lh b">value</code>方法，用<code class="fe le lf lg lh b">Map</code>中的所有值获取一个迭代器对象。</p><p id="cb2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用其他原始值作为键。如果我们使用对象，当我们查找它们时，我们不能取回值，因为查找是用返回<code class="fe le lf lg lh b">false</code>的<code class="fe le lf lg lh b">===</code>操作符完成的，这是两个没有相同引用的对象，即使它们有相同的内容。</p><p id="a499" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些方法在常规对象中不可用。此外，如果我们使用<code class="fe le lf lg lh b">for...in</code>循环，我们可能会意外地获得或修改对象原型的属性，而不是它自己的属性。</p><p id="be70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，不再有很多理由使用常规对象作为字典。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/188847940ffc66fd35c117f2afbe8be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*obmkxAe9AD2xZAxd"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> David Clode </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="7eae" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用跨页替换应用</h1><p id="dc65" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">如果我们不想在函数中改变<code class="fe le lf lg lh b">this</code>的值，就没有理由在函数中使用<code class="fe le lf lg lh b">apply</code>方法。</p><p id="301c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们只想调用一个有许多参数的函数，我们可以在为我们的参数传入数组时使用spread运算符，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8c38" class="mt lj it lh b gy mu mv l mw mx">const arr = [1, 2, 3, 4, 5];<br/>const add = (...args) =&gt; args.reduce((a, b) =&gt; a + b, 0);<br/>console.log(add(...arr));</span></pre><p id="a4c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所要做的就是在我们的数组上使用spread操作符，也就是最后一行中的3点操作符，然后数组将被分隔成一个逗号分隔的参数列表。</p><h1 id="ef6a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用类替换构造函数</h1><p id="c692" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">ES6的另一个伟大特性是构造函数的类语法。简单的语法糖使得构造函数看起来像一个类。</p><p id="bd28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的好处是让继承变得容易。</p><p id="4dbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想从一个构造函数中继承，我们必须像这样写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="1481" class="mt lj it lh b gy mu mv l mw mx">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="f0a9" class="mt lj it lh b gy my mv l mw mx">function Employee(name, employeeCode) {<br/>  Person.call(this, name);<br/>  Employee.prototype.constructor = Person;<br/>  this.employeeCode = employeeCode;<br/>}</span><span id="f3a5" class="mt lj it lh b gy my mv l mw mx">const employee = new Employee('Joe', 1);<br/>console.log(employee)</span></pre><p id="a3e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种语法来自基于类的面向对象语言，如Java，看起来很奇怪。</p><p id="196d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，对于使用其他语言多于JavaScript的开发人员来说，类语法使事情看起来更加熟悉。我们可以将上面的代码改写为:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7f1d" class="mt lj it lh b gy mu mv l mw mx">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="e2b6" class="mt lj it lh b gy my mv l mw mx">class Employee extends Person {<br/>  constructor(name, employeecode) {<br/>    super(name);<br/>    this.employeecode = employeecode;<br/>  }<br/>}</span><span id="8b2a" class="mt lj it lh b gy my mv l mw mx">const employee = new Employee('Joe', 1);<br/>console.log(employee)</span></pre><p id="4114" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">代码做的事情和上面的一样。然而，更清楚的是我们从哪里继承，因为我们有<code class="fe le lf lg lh b">extends</code>关键字来指示我们从哪里继承。</p><p id="1e8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了构造函数，我们就要担心在<code class="fe le lf lg lh b">call</code>方法的第一个参数中<code class="fe le lf lg lh b">this</code>的值，以及我们传递给后续参数<code class="fe le lf lg lh b">call</code>的内容。</p><p id="a635" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了类语法，我们就不用担心这个了。如果我们忘记像下面这样调用<code class="fe le lf lg lh b">super</code>:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9775" class="mt lj it lh b gy mu mv l mw mx">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="2ad7" class="mt lj it lh b gy my mv l mw mx">class Employee extends Person {<br/>  constructor(name, employeecode) {   <br/>    this.employeecode = employeecode;<br/>  }<br/>}</span><span id="104b" class="mt lj it lh b gy my mv l mw mx">const employee = new Employee('Joe', 1);<br/>console.log(employee)</span></pre><p id="fd75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将得到错误“未捕获的引用错误:在访问“this”或从派生构造函数返回之前，必须调用派生类中的<code class="fe le lf lg lh b">super</code>构造函数。”</p><p id="4b3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">少了一个犯错的机会。</p><p id="4b97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们像在<code class="fe le lf lg lh b">Employee</code>构造函数中一样省略<code class="fe le lf lg lh b">Person.call</code>，我们不会得到任何错误，因为浏览器不知道我们想要<code class="fe le lf lg lh b">Employee</code>从<code class="fe le lf lg lh b">Person</code>继承。</p><p id="b4f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，当我们记录<code class="fe le lf lg lh b">employee</code>的原型时，我们得到<code class="fe le lf lg lh b">employee</code>的原型是<code class="fe le lf lg lh b">Person</code>，正如类语法所预期的。</p><p id="5974" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，除非我们把容易忘记的<code class="fe le lf lg lh b">Employee.prototype.constructor = Person;</code>放进去，否则我们不会得到那个。</p><h1 id="3812" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="6368" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>和<code class="fe le lf lg lh b">for-await-of</code>是新的构造，使得链接承诺更加清晰。因为它，用它们比用<code class="fe le lf lg lh b">then</code>好得多。</p><p id="c91d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">for-await-of</code>还让我们循环通过动态生成的承诺，这是我们单独用<code class="fe le lf lg lh b">then</code>或<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>无法做到的。</p><p id="f48d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于散列和字典来说，s比普通对象好得多，因为它有自己的方法来操作和获取条目。此外，我们可能会意外地访问普通对象的原型的属性。</p><p id="f3f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不想改变函数内部的<code class="fe le lf lg lh b">this</code>的值，我们可以用spread操作符替换调用带有参数数组的函数的<code class="fe le lf lg lh b">apply</code>方法，它做同样的事情。</p><p id="f1e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，构造函数的类语法比原始函数语法好得多，因为我们可以从父类继承，这比设置构造函数的原型构造函数更容易。</p></div></div>    
</body>
</html>