<html>
<head>
<title>Handling errors in Mongoose/Express to display in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在mongose/Express中处理错误以在React中显示</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handling-errors-in-mongoose-express-for-display-in-react-d966287f573b?source=collection_archive---------0-----------------------#2020-11-10">https://levelup.gitconnected.com/handling-errors-in-mongoose-express-for-display-in-react-d966287f573b?source=collection_archive---------0-----------------------#2020-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c505469c40493019a9f49b1a0237ae36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eh8YYo0xlH-NVEACFqcXpQ.png"/></div></div></figure><p id="aaef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">犯错是人之常情，创建错误处理中间件是神圣的。本文将探讨如何使用Mongoose捕获和处理Express中的错误，然后使用React向最终用户显示这些错误。</p><p id="78a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文中使用的所有代码都在这个<a class="ae kw" href="https://github.com/jawblia/errors" rel="noopener ugc nofollow" target="_blank"> repo </a>中。</p><p id="df4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个图表显示了我们将在文章中讨论的模块。此应用程序正在使用MERN堆栈。服务器通过Express应用程序运行，并连接到MongoDB数据库。前端是一个React app。这些是我们将用于错误验证的文件:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/63cc51fc3ae7adeee10405ccba914aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXVRQ7y5eOCqTkQKRHxQZQ.png"/></div></div></figure><p id="1ca1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">描述的步骤:</p><ol class=""><li id="025e" class="lc ld iq ka b kb kc kf kg kj le kn lf kr lg kv lh li lj lk bi translated"><strong class="ka ir">设置错误处理中间件。</strong></li><li id="517e" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated"><strong class="ka ir">处理不同的错误。</strong></li><li id="505c" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated"><strong class="ka ir">向浏览器发送错误。</strong></li><li id="4e03" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated"><strong class="ka ir">在前端显示错误信息。</strong></li><li id="6e54" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated"><strong class="ka ir">高亮显示</strong> <strong class="ka ir">前端</strong>有错误的字段。</li></ol><p id="f53d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，这篇文章有几个步骤。假设您对Express、MongoDB/mongose、身份验证、React/React路由器和React挂钩有所了解。</p><p id="e246" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> //如果已经设置了基本的错误处理中间件和验证，请跳到第2步。</strong></p><h1 id="3480" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">1.设置错误处理中间件</h1><p id="703c" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">Express附带了错误处理中间件，它应用于中间件堆栈的末端。它们还允许您定义自己的错误处理中间件。与其他中间件不同，它需要四个参数。第一个参数总是存储<a class="ae kw" href="https://nodejs.org/api/errors.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">错误</strong> </a> <strong class="ka ir">对象</strong>，这是一个内置的节点类，存储关于错误的信息。</p><p id="bb2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">&gt;<strong class="ka ir"> app.js </strong></p><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="4a3c" class="my lr iq mu b gy mz na l nb nc">app.use((err, req, res, next) =&gt; {</span><span id="4a0e" class="my lr iq mu b gy nd na l nb nc">     console.log('congrats you hit the error middleware');<br/>     console.log(err);</span><span id="f683" class="my lr iq mu b gy nd na l nb nc">}</span></pre><p id="f564" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的错误处理中间件将会很长，所以我将把函数保存在一个单独的文件中。错误处理中间件位于应用程序堆栈的末端，因此它可以“捕捉”整个应用程序中的错误。我将它们安装在我的主app.js文件中——这是该文件的简化版本:</p><p id="8a2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">&gt;<strong class="ka ir"> app.js </strong></p><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="95bd" class="my lr iq mu b gy mz na l nb nc">const express = require('express');</span><span id="1b1a" class="my lr iq mu b gy nd na l nb nc">const cors = require('cors');</span><span id="fad9" class="my lr iq mu b gy nd na l nb nc">const authRouter = require('./routers/authRouter');</span><span id="b5a8" class="my lr iq mu b gy nd na l nb nc">const errorController = require('./controllers/errorController');</span><span id="5bff" class="my lr iq mu b gy nd na l nb nc"><br/>   const app = express();</span><span id="de94" class="my lr iq mu b gy nd na l nb nc">   app.use(cors());</span><span id="c3c8" class="my lr iq mu b gy nd na l nb nc">   app.use(express.json());<br/>   app.use(express.urlencoded({extended: true}));</span><span id="6108" class="my lr iq mu b gy nd na l nb nc">   app.use('/auth/', authRouter);</span><span id="971f" class="my lr iq mu b gy nd na l nb nc"><strong class="mu ir">   app.use(errorController);</strong></span><span id="f031" class="my lr iq mu b gy nd na l nb nc">   module.exports = app;</span></pre><p id="dbe5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在errorController文件中，我们定义了当Express检测到错误时将发生的行为。上面，我们只是控制台记录了一个字符串，但是当我们与前端通信时，我们将需要实际发送一个响应对象。</p><p id="6f01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">错误的HTTP状态代码在400和500之间。(所有状态代码可在<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" rel="noopener ugc nofollow" target="_blank">这里</a>找到。)我们将在用户注册时处理错误，所以我们的大多数状态代码将是<code class="fe ne nf ng mu b"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400" rel="noopener ugc nofollow" target="_blank">400 Bad Request</a>: Invalid syntax</code>。但并不是所有的错误都是验证错误——我们应该为一些我们无法预测的错误做好准备。一个错误总括是<code class="fe ne nf ng mu b"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500" rel="noopener ugc nofollow" target="_blank">500 Internal Server error</a>: Situation the server doesn't know how to handle</code>。当出现错误时，这总是最后一道防线。</p><p id="7826" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">T10】error controller . js</strong></p><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="eb6c" class="my lr iq mu b gy mz na l nb nc">module.exports = (err, req, res, next) =&gt; {<br/></span><span id="c979" class="my lr iq mu b gy nd na l nb nc">     res.status(500).send('An unknown error occurred.');</span><span id="8f38" class="my lr iq mu b gy nd na l nb nc">}</span></pre><p id="c2eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望定制我们的错误，以便最终用户理解他们为什么会看到错误消息。我们如何做到这一点？我将对所有这些示例使用身份验证，因为这种情况有许多不同的错误，需要不同的处理。</p><p id="b5e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">抛出的错误是由我在这里应用于用户模型的验证定义的。在这个用户模型中，我们有以下可能的错误:</p><ol class=""><li id="2bf8" class="lc ld iq ka b kb kc kf kg kj le kn lf kr lg kv lh li lj lk bi translated">电子邮件或用户名已被占用。</li><li id="0cc7" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">用户名包含非字母/数字字符。</li><li id="7781" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">密码不够长。</li><li id="6d99" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">密码不匹配(用户必须确认他们的密码)。</li><li id="e8f1" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">一个或多个字段为空。</li></ol><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="084d" class="my lr iq mu b gy mz na l nb nc">const mongoose = require('mongoose');</span><span id="5c22" class="my lr iq mu b gy nd na l nb nc">const bcrypt = require('bcrypt');</span><span id="4b8d" class="my lr iq mu b gy nd na l nb nc">const validator = require('validator');</span><span id="c7e0" class="my lr iq mu b gy nd na l nb nc">const Schema = mongoose.Schema;</span><span id="2f50" class="my lr iq mu b gy nd na l nb nc">const userSchema = new Schema({</span><span id="b56e" class="my lr iq mu b gy nd na l nb nc">   username: {</span><span id="4e6f" class="my lr iq mu b gy nd na l nb nc">       type: String,</span><span id="df2c" class="my lr iq mu b gy nd na l nb nc">       required: [true, 'Enter a username.'],</span><span id="0a98" class="my lr iq mu b gy nd na l nb nc">       unique: [true, 'That username is taken.'],</span><span id="fd2e" class="my lr iq mu b gy nd na l nb nc">       lowercase: true,</span><span id="8296" class="my lr iq mu b gy nd na l nb nc">       validate: [validator.isAlphanumeric, 'Usernames may only have letters and numbers.']</span><span id="e70b" class="my lr iq mu b gy nd na l nb nc">},</span><span id="9bbc" class="my lr iq mu b gy nd na l nb nc">    email: {</span><span id="3138" class="my lr iq mu b gy nd na l nb nc">          type: String,</span><span id="f6ab" class="my lr iq mu b gy nd na l nb nc">          require: [true, 'Enter an email address.'],</span><span id="c696" class="my lr iq mu b gy nd na l nb nc">          unique: [true, 'That email address is taken.'],</span><span id="8d4d" class="my lr iq mu b gy nd na l nb nc">          lowercase: true,</span><span id="edbd" class="my lr iq mu b gy nd na l nb nc">          validate: [validator.isEmail, 'Enter a valid email address.']</span><span id="4f78" class="my lr iq mu b gy nd na l nb nc">},</span><span id="2b11" class="my lr iq mu b gy nd na l nb nc">     password: {</span><span id="f4b1" class="my lr iq mu b gy nd na l nb nc">        type: String,</span><span id="db4b" class="my lr iq mu b gy nd na l nb nc">        required: [true, 'Enter a password.'],</span><span id="bd4c" class="my lr iq mu b gy nd na l nb nc">        minLength: [4, 'Password should be at least four characters']</span><span id="19aa" class="my lr iq mu b gy nd na l nb nc">},</span><span id="91a6" class="my lr iq mu b gy nd na l nb nc">    passwordConfirm: {</span><span id="4141" class="my lr iq mu b gy nd na l nb nc">        type: String,</span><span id="035d" class="my lr iq mu b gy nd na l nb nc">        required: [true, 'Retype your password.'],</span><span id="a38b" class="my lr iq mu b gy nd na l nb nc">        validate: {</span><span id="089f" class="my lr iq mu b gy nd na l nb nc">            validator: function(el) {</span><span id="8d5f" class="my lr iq mu b gy nd na l nb nc">            return el === this.password;</span><span id="2126" class="my lr iq mu b gy nd na l nb nc">        }, message: 'Passwords don\'t match.'</span><span id="f055" class="my lr iq mu b gy nd na l nb nc">    }</span><span id="72c4" class="my lr iq mu b gy nd na l nb nc">  }</span><span id="49eb" class="my lr iq mu b gy nd na l nb nc">});</span><span id="e68c" class="my lr iq mu b gy nd na l nb nc">//schema middleware to apply before saving<br/>userSchema.pre('save', async function(next) {<br/>    this.password = await bcrypt.hash(this.password, 12);<br/>    this.passwordConfirm = undefined;</span><span id="f4a3" class="my lr iq mu b gy nd na l nb nc">      next();</span><span id="5667" class="my lr iq mu b gy nd na l nb nc">});</span><span id="760b" class="my lr iq mu b gy nd na l nb nc">const User = mongoose.model('User', userSchema);</span><span id="c272" class="my lr iq mu b gy nd na l nb nc">module.exports = User;</span></pre><p id="c3ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面，我概述了注册时可能出现的五个错误。对于MongoDB，有一个内部的错误分类系统。MongoDB为控制台记录的错误分配不同的名称和代码。通过控制台记录错误，您可以看到错误堆栈跟踪(错误元数据以及它在应用程序中出现的位置)的样子。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/486d2bffbb0f2d2355eee61430467f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fd_UbC60oitkIaixnu2Kvg.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">MongoDB中重复键错误的堆栈跟踪</figcaption></figure><p id="e930" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面，我概述了注册验证可能出现的五个错误。通过使用MongoDB的分类，我可以标记那些特定的错误何时发生。在我提到的五个错误中，它们都属于两个不同的错误类别:</p><ol class=""><li id="5535" class="lc ld iq ka b kb kc kf kg kj le kn lf kr lg kv lh li lj lk bi translated"><strong class="ka ir">现有用户名/电子邮件的重复键错误</strong>。通过查看stacktrace，我知道这个错误的代码是E11000。</li><li id="16f7" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated"><strong class="ka ir">空字段或格式错误字段的验证错误</strong>。通过查看stacktrace，我看到这个错误的名称是ValidationError。</li></ol><h1 id="0d3e" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">2.处理不同的错误</h1><p id="39bf" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">我们知道我们正在处理两种不同的错误，并且我们有它们的代码/名称。因为MongoDB将error类存储在错误处理中间件的第一个参数中，所以我们可以从该参数中访问Error对象的属性。</p><p id="4946" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的错误处理中间件现在可以区分两种错误类型，如果错误没有被标记，它将求助于无所不包的错误。</p><p id="fcdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> &gt; errorController.js </strong></p><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="f039" class="my lr iq mu b gy mz na l nb nc">module.exports = (err, req, res, next) =&gt; {</span><span id="4f7a" class="my lr iq mu b gy nd na l nb nc">     try {</span><span id="e088" class="my lr iq mu b gy nd na l nb nc">        console.log('congrats you hit the error middleware');<br/>        if(err.name === 'ValidationError') return err = handleValidationError(err, res);<br/>        if(err.code &amp;&amp; err.code == 11000) return err = handleDuplicateKeyError(err, res);</span><span id="1f40" class="my lr iq mu b gy nd na l nb nc">} catch(err) {<br/>       res.status(500).send('An unknown error occurred.');</span><span id="3420" class="my lr iq mu b gy nd na l nb nc">    }</span><span id="5eff" class="my lr iq mu b gy nd na l nb nc">}</span></pre><p id="5125" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将重复键错误和验证错误的错误处理分解到单独的函数中。重复键错误的函数如下所示:</p><p id="a780" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">T15】error controller . js</strong></p><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="696a" class="my lr iq mu b gy mz na l nb nc">//handle email or username duplicates</span><span id="7cce" class="my lr iq mu b gy nd na l nb nc">const handleDuplicateKeyError = (err, res) =&gt; {</span><span id="cbae" class="my lr iq mu b gy nd na l nb nc">   const field = Object.keys(err.keyValue);</span><span id="8444" class="my lr iq mu b gy nd na l nb nc">   const code = 409;</span><span id="720f" class="my lr iq mu b gy nd na l nb nc">res.status(code).send(`An account with that ${field} already exists.`);</span><span id="1eab" class="my lr iq mu b gy nd na l nb nc">}</span></pre><p id="a0fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是怎么回事:</p><ol class=""><li id="33c1" class="lc ld iq ka b kb kc kf kg kj le kn lf kr lg kv lh li lj lk bi translated">我们可以通过对error对象应用vanilla JS来提取发生错误的字段，该对象有一个内置的<code class="fe ne nf ng mu b">keyValue</code>属性。</li><li id="2298" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">使用HTTP代码列表，我们可以确定409中重复条目的正确代码(与服务器中现有数据冲突的请求)。</li><li id="6997" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">我们将代码和消息附加到带有<code class="fe ne nf ng mu b">status</code>和<code class="fe ne nf ng mu b">send</code>的响应对象上。<strong class="ka ir">需要使用send向前端显示错误信息。</strong> <code class="fe ne nf ng mu b">Send</code>可以推送可以立即在React中使用的JavaScript(字符串、对象、数组)，与<code class="fe ne nf ng mu b">json</code>方法相反。</li></ol><p id="9e39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不仅要在前端显示一条错误消息，还要突出显示需要纠正的字段。因此，除了推送消息之外，我们还将发送数组中抛出错误的字段(用户名或电子邮件字段)。</p><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="0e2c" class="my lr iq mu b gy mz na l nb nc">//handle email or username duplicates</span><span id="b238" class="my lr iq mu b gy nd na l nb nc">const handleDuplicateKeyError = (err, res) =&gt; {</span><span id="13f1" class="my lr iq mu b gy nd na l nb nc">   const field = Object.keys(err.keyValue);</span><span id="335f" class="my lr iq mu b gy nd na l nb nc">   const code = 409;</span><span id="685c" class="my lr iq mu b gy nd na l nb nc">   const error = `An account with that ${field} already exists.`;</span><span id="41b4" class="my lr iq mu b gy nd na l nb nc">   res.status(code).send({messages: error, fields: field});</span><span id="eaea" class="my lr iq mu b gy nd na l nb nc">}</span></pre><p id="edf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这相当简单。但是注意，我们没有做两件事:1。使用我们添加到用户模型中的错误消息，或者2。创建一次处理多个错误的能力。我们将在验证函数中完成这两项工作:</p><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="aed7" class="my lr iq mu b gy mz na l nb nc">//handle field formatting, empty fields, and mismatched passwords</span><span id="9384" class="my lr iq mu b gy nd na l nb nc">const handleValidationError = (err, res) =&gt; {</span><span id="a841" class="my lr iq mu b gy nd na l nb nc">   let errors = Object.values(err.errors).map(el =&gt; el.message);</span><span id="59d2" class="my lr iq mu b gy nd na l nb nc">   let fields = Object.values(err.errors).map(el =&gt; el.path);</span><span id="29cc" class="my lr iq mu b gy nd na l nb nc">   let code = 400;</span><span id="3e64" class="my lr iq mu b gy nd na l nb nc">   if(errors.length &gt; 1) {</span><span id="a05b" class="my lr iq mu b gy nd na l nb nc">      const formattedErrors = errors.join(' ');</span><span id="dc43" class="my lr iq mu b gy nd na l nb nc">      res.status(code).send({messages: formattedErrors, fields:     fields});</span><span id="5157" class="my lr iq mu b gy nd na l nb nc">    } else {</span><span id="bcfe" class="my lr iq mu b gy nd na l nb nc">       res.status(code).send({messages: errors, fields: fields})</span><span id="76a6" class="my lr iq mu b gy nd na l nb nc">    }</span><span id="dfd8" class="my lr iq mu b gy nd na l nb nc">}</span></pre><p id="00db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个函数中，我们在上面所做的基础上又增加了:</p><ol class=""><li id="28f6" class="lc ld iq ka b kb kc kf kg kj le kn lf kr lg kv lh li lj lk bi translated">使用<code class="fe ne nf ng mu b">el.message</code>获取我们添加到用户模型中的错误消息。</li><li id="657a" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">循环遍历error对象以存储多个错误(如果有多个错误)。</li><li id="b29c" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">检测错误是否大于1，并用空格将所有消息连接在一起，使它们成为一个字符串。</li></ol><p id="e3cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么我们需要用空格来连接消息？没有它，它们将是一组消息。为了在前端显示它，<strong class="ka ir">错误信息需要是一个单独的字符串</strong>。为了测试这一点，我从一个API客户端发出了一个请求(我使用的是Google的高级RESTful客户端)，并故意留下了两个错误:电子邮件字段为空和密码不匹配。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/e7750b6597407bf9dbec27f7b96d8f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1WvfR2QdDTAiMDPIkYWvRw.png"/></div></div></figure><p id="8b50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的响应中，您可以看到“messages”值现在是一个字符串，而“fields”值仍然是一个数组。</p><p id="1c03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在准备向浏览器发送错误消息，我们的错误控制器如下所示:</p><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="019f" class="my lr iq mu b gy mz na l nb nc">//handle email or usename duplicates</span><span id="bda6" class="my lr iq mu b gy nd na l nb nc">const handleDuplicateKeyError = (err, res) =&gt; {<br/>   const field = Object.keys(err.keyValue);<br/>   const code = 409;<br/>   const error = `An account with that ${field} already exists.`;<br/>   res.status(code).send({messages: error, fields: field});</span><span id="d901" class="my lr iq mu b gy nd na l nb nc">}</span><span id="5172" class="my lr iq mu b gy nd na l nb nc">//handle field formatting, empty fields, and mismatched passwords</span><span id="51c0" class="my lr iq mu b gy nd na l nb nc">const handleValidationError = (err, res) =&gt; {<br/>   let errors = Object.values(err.errors).map(el =&gt; el.message);<br/>   let fields = Object.values(err.errors).map(el =&gt; el.path);<br/>   let code = 400;</span><span id="e954" class="my lr iq mu b gy nd na l nb nc">   if(errors.length &gt; 1) {<br/>     const formattedErrors = errors.join('')res<br/>         .status(code)<br/>         .send({messages: formattedErrors, fields: fields});</span><span id="6e75" class="my lr iq mu b gy nd na l nb nc">     } else {</span><span id="b01a" class="my lr iq mu b gy nd na l nb nc">          res<br/>            .status(code)<br/>            .send({messages: errors, fields: fields}<br/>     }<br/>}</span><span id="1c9e" class="my lr iq mu b gy nd na l nb nc">//error controller function</span><span id="1393" class="my lr iq mu b gy nd na l nb nc">module.exports = (err, req, res, next) =&gt; {</span><span id="6de8" class="my lr iq mu b gy nd na l nb nc">try {</span><span id="d327" class="my lr iq mu b gy nd na l nb nc">    if(err.name === 'ValidationError') return err = handleValidationError(err, res);<br/>    if(err.code &amp;&amp; err.code == 11000) return err = handleDuplicateKeyError(err, res);<br/>    } catch(err) {<br/>        res<br/>          .status(500)<br/>          .send('An unknown error occurred.');<br/>}<br/>}</span></pre><h1 id="c5b0" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">3.向浏览器发送错误</h1><p id="afbf" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">如何从Express → React得到这些错误？我们需要从像Google的REST客户端或Postman这样的程序调用API，转移到浏览器中。</p><p id="3839" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的登记表是这样的。它在名为Register.js的React组件中。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/89ca220c08ce48bfa43e2b6881d3b80b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWZCiDccsJDVrh4QfAX2qg.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">Register.js中的注册表</figcaption></figure><p id="0fe7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将使用一个名为useForm.js的定制钩子使这个表单有状态，在这个钩子中，我将跟踪和存储表单值，并处理提交事件。</p><p id="9b15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">错误处理将出现在提交事件之后，在对服务器的POST请求中。</p><p id="579d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">&gt; useForm.js</p><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="92f8" class="my lr iq mu b gy mz na l nb nc">import { useState } from 'react';<br/>import { useHistory } from 'react-router-dom';<br/>import axios from 'axios';</span><span id="0b96" class="my lr iq mu b gy nd na l nb nc">export default function useForm({ initialValues }) {</span><span id="80f8" class="my lr iq mu b gy nd na l nb nc">    let history = useHistory();<br/>    const [values, setValues] = useState(initialValues || {});<br/>    <strong class="mu ir">const [error, setError] = useState(null);</strong></span><span id="7add" class="my lr iq mu b gy nd na l nb nc">//track form values<br/>const handleChange = event =&gt; {<br/>    const value = event.target.value;<br/>    const name = event.target.name;<br/>       setValues({<br/>          ...values,<br/>          [name]: value<br/>        });<br/>     };</span><span id="d39a" class="my lr iq mu b gy nd na l nb nc">//submit form when enter key is pressed<br/>const handleKeyDown = event =&gt; {<br/>     const enter = 13;<br/>     if(event.keyCode === enter) {<br/>       handleSubmit(event);<br/>     }<br/>   }</span><span id="550c" class="my lr iq mu b gy nd na l nb nc">//submit form when submit button is clicked<br/>const handleSubmit = event =&gt; {<br/>     event.preventDefault();<br/>     submitData({ values });<br/>};</span><span id="ea78" class="my lr iq mu b gy nd na l nb nc">//send data to database<br/>const submitData = async (formValues) =&gt; {<br/>     const url = 'http://127.0.0.1:5000/';<br/>     const dataObject = formValues.values;<br/>     const { username, email, password, passwordConfirm } = dataObject;</span><span id="1f7f" class="my lr iq mu b gy nd na l nb nc">try {<br/>await axios ({<br/>method: 'POST',<br/>url: `${url}auth/register`,<br/>data: {<br/>   username: username,<br/>   email: email,<br/>   password: password,<br/>   passwordConfirm: passwordConfirm<br/>},<br/>headers: new Headers({ 'Content-Type': 'application/json' })<br/>}).then(res =&gt; {<br/>     history.push('/home');<br/>})<br/>} catch(err) {<br/>     <strong class="mu ir">setError(err.response.data);</strong><br/>   }<br/>};</span><span id="aff0" class="my lr iq mu b gy nd na l nb nc">return {</span><span id="99d8" class="my lr iq mu b gy nd na l nb nc">   handleChange,<br/>   handleKeyDown,<br/>   values,<br/>   handleSubmit,<br/>   <strong class="mu ir">error</strong><br/>  }<br/>}</span></pre><p id="f215" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当POST请求抛出一个错误时，我们在<code class="fe ne nf ng mu b">err.response.data</code>中捕获该错误，并将其存储在上面的状态中。然后我们从钩子返回它，所以我们可以在我们的注册表中使用它。</p><h1 id="cb92" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">4.在前端显示错误信息。</h1><p id="6e2a" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">我们返回的值是一个带有字段数组和消息字符串的对象。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/6a454705f9e7942f108e3b1b52dd73f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgOaQ54ZOYM-qfQmPqCIlw.png"/></div></div></figure><p id="fece" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们想要显示的消息在<code class="fe ne nf ng mu b">messages</code>值中。</p><p id="a21f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了在注册表单中显示它，我们可以创建一个错误组件，在出现错误时有条件地出现。错误的初始状态是<code class="fe ne nf ng mu b">null</code>，所以错误将评估为假，直到状态被更新为消息。</p><p id="0c84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">&gt;注册. js</p><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="99a0" class="my lr iq mu b gy mz na l nb nc">import React from 'react';<br/>import FormInput from './../components/FormInput';<br/>import CTA from './../components/CTA';<br/>import Prompt from './../components/Prompt';<br/>import ConfirmPasswordInput from './../components/ConfirmPasswordInput';<br/>import useForm from './../hooks/useForm';<br/>import Error from './../components/Error';</span><span id="feac" class="my lr iq mu b gy nd na l nb nc">export default function Register() {</span><span id="afa2" class="my lr iq mu b gy nd na l nb nc">const { values, handleChange, handleKeyDown, handleSubmit, error } = useForm({</span><span id="2d08" class="my lr iq mu b gy nd na l nb nc">initialValues: {<br/>   email: '',<br/>   username: '',<br/>   password: '',<br/>   passwordConfirm: ''<br/>}<br/>});</span><span id="b410" class="my lr iq mu b gy nd na l nb nc">return(<br/>  &lt;div className="page"&gt;<br/>     &lt;div className="inlineForm"&gt;<br/>        &lt;h3&gt;Register&lt;/h3&gt;<br/>     &lt;div className="inlineForm__notif"&gt;<br/>       <strong class="mu ir"> {error &amp;&amp; &lt;Error error={error.messages}/&gt; }</strong><br/>    &lt;/div&gt;</span><span id="82a8" class="my lr iq mu b gy nd na l nb nc"> &lt;FormInput type={"email"} placeholder={"Email"} name={"email"} value={values.email} handleChange={handleChange} handleKeyDown={handleKeyDown} /&gt;</span><span id="e4d0" class="my lr iq mu b gy nd na l nb nc">///rest of the form fields</span></pre><p id="c386" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，如果有错误，就会出现错误组件，它会以<code class="fe ne nf ng mu b">error.messages</code>为道具。误差分量本身非常简单:</p><p id="9653" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Error.js</p><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="ef35" class="my lr iq mu b gy mz na l nb nc">import React from 'react';</span><span id="1335" class="my lr iq mu b gy nd na l nb nc">export default function Error(props) {</span><span id="9bc9" class="my lr iq mu b gy nd na l nb nc">return(<br/>  &lt;div className="notifError"&gt;<br/>     &lt;h5&gt;{props.error}&lt;/h5&gt;<br/>  &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="e482" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当出现错误时，通知会出现在表单的顶部:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/623acb792af4b7d0f19fa4cc0b1feed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JafGJWvI4hzYmZvYU2hvHA.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">该通知将持续到发出另一个请求，但是可以很容易地通过超时功能自动取消。</figcaption></figure><p id="8ac9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，最后一部分是如何让抛出错误的字段有一个红色的高亮显示，这样最终用户就可以修复它们了。</p><h1 id="797c" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">5.突出显示前端有错误的字段。</h1><p id="2bce" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">我们的字段存储在<code class="fe ne nf ng mu b">error.fields</code>键中。如何在我们的表单中动态反映字段数组的错误状态，大概是这样的，<code class="fe ne nf ng mu b">error.fields = ["username", "password"]</code>？</p><p id="4fa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这又是登记表。</p><p id="7e57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">&gt;注册. js</p><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="70d5" class="my lr iq mu b gy mz na l nb nc">export default function Register() {</span><span id="0b0f" class="my lr iq mu b gy nd na l nb nc">const { values, handleChange, handleKeyDown, handleSubmit, error } = useForm({</span><span id="6d4b" class="my lr iq mu b gy nd na l nb nc">initialValues: {<br/>   email: '',<br/>   username: '',<br/>   password: '',<br/>   passwordConfirm: ''<br/>}<br/>});</span><span id="a4ab" class="my lr iq mu b gy nd na l nb nc"><strong class="mu ir">let invalidFields;<br/>error ? invalidFields = error.fields : invalidFields = [];</strong></span><span id="34f6" class="my lr iq mu b gy nd na l nb nc">return(<br/>  &lt;div className="page"&gt;<br/>     &lt;div className="inlineForm"&gt;<br/>        &lt;h3&gt;Register&lt;/h3&gt;<br/>     &lt;div className="inlineForm__notif"&gt;<br/>        {error &amp;&amp; &lt;Error error={error.messages}/&gt; }<br/>    &lt;/div&gt;</span><span id="ccfd" class="my lr iq mu b gy nd na l nb nc">&lt;FormInput type={"email"} placeholder={"Email"} name={"email"} value={values.email} handleChange={handleChange} handleKeyDown={handleKeyDown} <strong class="mu ir">fail={invalidFields.includes("email")}</strong>/&gt;</span><span id="441e" class="my lr iq mu b gy nd na l nb nc">///rest of the form fields</span></pre><ol class=""><li id="58ba" class="lc ld iq ka b kb kc kf kg kj le kn lf kr lg kv lh li lj lk bi translated">初始化一个名为invalidFields的变量。如果有错误(错误！== null)，invalidFields等于误用字段的数组。如果没有错误，就等于空数组。</li><li id="aea2" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv lh li lj lk bi translated">在表单字段组件中创建一个名为<code class="fe ne nf ng mu b">fail</code>的属性，它将决定字段是否无效。道具中值也应该评估为<code class="fe ne nf ng mu b">true</code>或<code class="fe ne nf ng mu b">false</code>。如果<code class="fe ne nf ng mu b">invalidFields.includes('email')</code>为真，该字段将无效。</li></ol><p id="ccae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在field组件中，我们必须根据<code class="fe ne nf ng mu b">fail</code>是真还是假来改变它的样式。如果是假的，样式将保持不变。如果是真的，我们将向它添加一个应用红色边框的错误类。</p><p id="7930" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是我的FormInput组件的代码</p><p id="2d5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">&gt; FormInput.js</p><pre class="ky kz la lb gt mt mu mv mw aw mx bi"><span id="83e1" class="my lr iq mu b gy mz na l nb nc">import React from 'react';</span><span id="6cf4" class="my lr iq mu b gy nd na l nb nc">export default function FormInput(props) {<br/>    let fail = props.fail;</span><span id="57db" class="my lr iq mu b gy nd na l nb nc">return(<br/>   &lt;&gt;</span><span id="f8ad" class="my lr iq mu b gy nd na l nb nc">      &lt;input type={props.type} name="input"<br/>            <strong class="mu ir"> className={`input ${fail ? "input--fail" : null} `}</strong><br/>             placeholder={props.placeholder} name={props.name}<br/>             value={props.value} onChange={props.handleChange}<br/>             onKeyDown={props.handleKeyDown}<br/>       /&gt;<br/>   &lt;/&gt;<br/>  )<br/>}</span></pre><p id="5daa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在SCSS。输入-失败类在应用了该类的字段周围添加红色边框。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/f77fea2799cbf09c9043efec4a32202c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lnskebSMp96fSmzX7rnUkQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">提交一个空表单会突出显示每个字段。</figcaption></figure><p id="c828" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是在Express/mongose中显示错误的全部内容。在这方面可以做的还有很多。如果你想看这个演示的所有代码，回购链接是<a class="ae kw" href="https://github.com/jawblia/errors" rel="noopener ugc nofollow" target="_blank">这里</a>。可以在那里找到整个表单和服务器代码。</p><h2 id="d1de" class="my lr iq bd ls nr ns dn lw nt nu dp ma kj nv nw me kn nx ny mi kr nz oa mm ob bi translated">关于错误处理的进一步阅读:</h2><ul class=""><li id="db64" class="lc ld iq ka b kb mo kf mp kj oc kn od kr oe kv of li lj lk bi translated">默认快递出错中间件:【https://expressjs.com/en/guide/error-handling.html T2】</li><li id="dba6" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv of li lj lk bi translated">快递处理错误:【https://www.robinwieruch.de/node-express-error-handling/ T4】</li><li id="155d" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv of li lj lk bi translated">Express to React错误处理:<a class="ae kw" href="https://itnext.io/javascript-error-handling-from-express-js-to-react-810deb5e5e28" rel="noopener ugc nofollow" target="_blank">https://it next . io/JavaScript-error-handling-from-express-js-to-React-810 de b5 e 2e 28</a></li><li id="9df6" class="lc ld iq ka b kb ll kf lm kj ln kn lo kr lp kv of li lj lk bi translated">HTTP状态码:<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</a></li></ul></div></div>    
</body>
</html>