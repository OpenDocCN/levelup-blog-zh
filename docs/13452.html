<html>
<head>
<title>unglitch — Ultra-Simple State Management for React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">un glitch——React的超简单状态管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unglitch-ultra-simple-react-state-management-11470282b6f5?source=collection_archive---------5-----------------------#2022-09-05">https://levelup.gitconnected.com/unglitch-ultra-simple-react-state-management-11470282b6f5?source=collection_archive---------5-----------------------#2022-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d55b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">停止考虑副作用，用锁定功能解决它们</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/983ca067e1c43618e773a4898390cb90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6JBk3HwIuiD2RwUjAr7f8w.png"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="6a78" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">想象一下:</h1><p id="8333" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">您创建了React或Next.js设置，并且需要一个存储来跨组件无缝共享您的数据。这很可能包括一些向存储提供数据的数据获取逻辑。</p><p id="fa8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去，每个人都会尖叫<code class="fe mh mi mj mk b">Redux</code>,你会用某种状态属性检查获取数据是否已经完成或者当前正在完成。如今，我们有了<code class="fe mh mi mj mk b">Redux</code> +一堆其他选择——相同的目标，不同的架构。</p><p id="9255" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现有的商店是可怕的，部分该死的容易(如<code class="fe mh mi mj mk b">zustand</code>)和工作很好。</p><h1 id="19d4" class="le lf iq bd lg lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb bi translated">但是(！)商店不解决副作用问题</h1><p id="fd4d" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">问题是，在React生命周期中，您可能会遇到以下情况:3个组件需要数据，因此3个组件使用您的定制钩子<code class="fe mh mi mj mk b">useData</code>，钩子检查存储中的数据是否已经可用，例如</p><pre class="km kn ko kp gt mq mk mr ms aw mt bi"><span id="541c" class="mu lf iq mk b gy mv mw l mx my">// my custom hook<br/>function useData() {<br/> const data = useZustand(state =&gt; state.data);<br/> <br/> useEffect(() =&gt; {<br/>   if (!data) {<br/>    fetchData().then(/** some fetching logic **/);<br/>   }<br/> }, [data]);</span><span id="1032" class="mu lf iq mk b gy mz mw l mx my">  return data;<br/>}</span></pre><p id="ce69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这很麻烦——不幸的是，我在网站上越来越多地看到这种情况:数据被多次提取，多个请求被发送。通过在下图中提供一些视觉帮助，可以更容易地解释原因:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/0a1d68168c7eb8c4815e25b9c0857c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_iXz_AmsxFAqsg9KyX53Q.png"/></div></div></figure><p id="e895" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有组件都使用了<code class="fe mh mi mj mk b">useData()</code>钩子。和<code class="fe mh mi mj mk b">useData</code>将具有空的状态数据。<code class="fe mh mi mj mk b">useData()</code>的<code class="fe mh mi mj mk b">useEffect()</code>仍然会被调用3次，因为我们有3个组件在使用它——提醒:重用的钩子不是【单线】(<a class="ae nb" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Singleton_pattern</a>)。问题还在继续:你不能真正检查<em class="nc">提供的</em>状态数据，因为你得到了<strong class="jp ir">这个</strong>生命周期的状态，所以另一个组件可能已经调用了获取函数，但是其他组件将在下一个生命周期运行时得到通知，因此也触发获取数据。</p><h1 id="c00b" class="le lf iq bd lg lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb bi translated">这不是一个反应问题</h1><p id="075f" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">现在听起来可能像是“按照架构来说，这不是很糟糕吗？”。不，你在你的组件的每个生命周期都有一个状态，这样所有的组件都有相同的同步状态，这是你的组件行为正常的必要条件。</p><h1 id="77e7" class="le lf iq bd lg lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb bi translated">这是你的问题:你需要协调</h1><p id="f7e3" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">最终，您必须避免在React生命周期之外运行的函数(比如数据获取方法)被多次运行。这对于所有主要的状态管理库都是可能的，因为它们在组件得到通知之前更新状态。</p><p id="9209" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在Redux(带<code class="fe mh mi mj mk b">redux-thunk</code>)中，您会看到这样的内容:</p><pre class="km kn ko kp gt mq mk mr ms aw mt bi"><span id="32f2" class="mu lf iq mk b gy mv mw l mx my">dispatch((dispatch, getState) =&gt; {<br/> if (getState().isFetchingData === false) {<br/>   fetchData().then(data =&gt; dispatch({<br/>    action: ‘UPDATE_DATA’, payload: data<br/>   }));<br/> }<br/>});</span></pre><p id="595d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者在<code class="fe mh mi mj mk b">zustand</code>中，你可以这样构建它:</p><pre class="km kn ko kp gt mq mk mr ms aw mt bi"><span id="302f" class="mu lf iq mk b gy mv mw l mx my">const store = create((set, get) =&gt; ({<br/> isFetchingData: false,<br/> fetchData: () =&gt; {<br/>  if (get().isFetchingData === false) {<br/>   fetchData().then(data =&gt; set({data}));<br/>  }<br/> }<br/>}));</span></pre><p id="3629" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工作，但也是额外的开销，你必须记住这样做。</p><h1 id="4532" class="le lf iq bd lg lh ml lj lk ll mm ln lo lp mn lr ls lt mo lv lw lx mp lz ma mb bi translated"><code class="fe mh mi mj mk b">unglitch</code>提供锁定或离开呼叫</h1><p id="8866" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我想要一个简单的状态管理来解决这个问题。我本可以改编<code class="fe mh mi mj mk b">zustand</code>，但之后我继续挖掘构建一个更简单的系统:<code class="fe mh mi mj mk b">unglitch</code>。</p><div class="nd ne gp gr nf ng"><a href="https://github.com/activenode/unglitch" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">GitHub - activenode/unglitch:一个简单的、避免副作用的React存储库</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">是的。只对18+作出反应，不打算移植到其他任何东西。更新你的简历。不需要上下文提供者…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">github.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu kv ng"/></div></div></a></div><p id="1891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mh mi mj mk b">unglitch</code>和<code class="fe mh mi mj mk b">zustand</code>非常相似，它<em class="nc">和</em>使用相同的技术。然而，内置的状态管理确实会带来锁定调用。</p><p id="7e57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最简单的解释就是下面的代码片段:</p><pre class="km kn ko kp gt mq mk mr ms aw mt bi"><span id="c485" class="mu lf iq mk b gy mv mw l mx my">import { useStore, update } from ‘./my-store’;</span><span id="ed80" class="mu lf iq mk b gy mz mw l mx my">const fetchData(releaseLock: () =&gt; void, realtimeData) {<br/> // we can check the live data outside of the lifecycle <br/> if (realtimeData === null) {<br/>   // ..fetch some data…<br/>   // …then update it:<br/>   update({ data: [/** your data here */]});<br/> <br/>   // release the lock so it can be called again<br/>   releaseLock();<br/> }<br/>}<br/>fetchData.LOCK_TOKEN = “FETCH_DATA”;</span><span id="4c4b" class="mu lf iq mk b gy mz mw l mx my">const useData = () =&gt; {<br/> const [data, lockedCall] = useStore(state =&gt; state.data); </span><span id="f90c" class="mu lf iq mk b gy mz mw l mx my"> useEffect(() =&gt; {<br/>  lockedCall(fetchData);<br/> }, []);</span><span id="7ae9" class="mu lf iq mk b gy mz mw l mx my"> return data;<br/>}</span></pre><p id="a1cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行<code class="fe mh mi mj mk b">lockedCall</code>时会自动抓取<code class="fe mh mi mj mk b">LOCK_TOKEN</code>。如果<code class="fe mh mi mj mk b">LOCK_TOKEN</code>不存在，你将面临一个错误，所以不要担心忘记它。当然，你仍然可以手动调用这个函数，但是只要你运行<code class="fe mh mi mj mk b">lockedCall</code>，它将只运行一次。</p><p id="71b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">被调用的函数总是接收一个函数作为第一个参数，这将再次释放锁，第二个参数正是在<code class="fe mh mi mj mk b">useStore</code>中提供的状态数据，所以这里是<code class="fe mh mi mj mk b">state.data</code>。<br/>不同之处在于:被调用的函数接收的是<code class="fe mh mi mj mk b">realtimeData</code>，而不是生命周期中当前可用的数据。这允许您检查是否需要获取数据。</p><p id="04bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了这个锁机制，商店的工作方式与<code class="fe mh mi mj mk b">zustand</code>非常相似。看看这个。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="ce87" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">分级编码</h1><p id="9127" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="fb8d" class="nv nw iq jp b jq jr ju jv jy nx kc ny kg nz kk oa ob oc od bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="71c5" class="nv nw iq jp b jq oe ju of jy og kc oh kg oi kk oa ob oc od bi translated">📰查看<a class="ae nb" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="e576" class="nv nw iq jp b jq oe ju of jy og kc oh kg oi kk oa ob oc od bi translated">🔔关注我们:<a class="ae nb" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae nb" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nb" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="7e60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae nb" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>