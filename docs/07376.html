<html>
<head>
<title>Just One Index in Django Makes your App 15x faster!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django中的一个索引就能让您的应用速度提高15倍！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/just-one-index-in-django-makes-your-app-15x-faster-742e2f13108e?source=collection_archive---------1-----------------------#2021-02-13">https://levelup.gitconnected.com/just-one-index-in-django-makes-your-app-15x-faster-742e2f13108e?source=collection_archive---------1-----------------------#2021-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e389" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你的应用有了索引会快多少？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9f7d0957716f71b6d5ffa0e78c5b598b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*mJ5Z5JDWbugBWKuI.jpg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">数据库索引就像一本电话簿</figcaption></figure><p id="ec04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使是“高级”开发人员也经常忘记在Django中使用索引。您无法想象，如果您只需在模型中添加两行代码，速度会有多快！</p><p id="3fcf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我们将一起进行测量:有索引和没有索引。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="f01d" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">设置</h2><p id="309c" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们的病人将是一个只有7个字段的小Django应用程序。</p><p id="64d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将在这里展示这个模型:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="8ff8" class="lx ly it mw b gy na nb l nc nd"><strong class="mw iu">class </strong>Student(models.Model):<br/>    first_name = models.CharField(max_length=100)<br/>    last_name = models.CharField(max_length=100)<br/>    code0 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/>    code1 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/>    code2 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/>    code3 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/>    code4 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)</span></pre><p id="31eb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有很多CharFields。没有索引。</p><p id="d984" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将用100K行进行测试，如下所示:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a483" class="lx ly it mw b gy na nb l nc nd"><strong class="mw iu">from </strong>django.test <strong class="mw iu">import </strong>TestCase<br/><strong class="mw iu">from </strong>student.models <strong class="mw iu">import </strong>Student<br/><strong class="mw iu">import </strong>datetime<br/><br/><br/><strong class="mw iu">class </strong>StudentTestCase(TestCase):<br/>    <strong class="mw iu">def </strong>setUp(self):<br/>        start_time = datetime.datetime.now()<br/>        students = []<br/>        batch_size = 500<br/>        <strong class="mw iu">for </strong>i <strong class="mw iu">in </strong>range(100000):<br/>            student = Student()<br/>            student.first_name = str(i)<br/>            student.last_name = str(i)<br/>            student.code0 = <strong class="mw iu">f"code{</strong>i<strong class="mw iu">}"<br/>            </strong>students.append(student)<br/>        Student.objects.bulk_create(students, batch_size)<br/><br/>        end_time = datetime.datetime.now()<br/>        print(<strong class="mw iu">f" Created in {</strong>end_time - start_time<strong class="mw iu">}"</strong>)<br/><br/>    <strong class="mw iu">def </strong>test_lookup(self):<br/>        start_time = datetime.datetime.now()<br/>        <strong class="mw iu">for </strong>i <strong class="mw iu">in </strong>range(50000, 51000):<br/>            Student.objects.get(code0=<strong class="mw iu">f"code{</strong>i<strong class="mw iu">}"</strong>)<br/><br/>        end_time = datetime.datetime.now()<br/>        print(<strong class="mw iu">f"Looked up in {</strong>end_time - start_time<strong class="mw iu">}"</strong>)</span></pre><p id="fa12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们首先创建100K个元素。然后，就在数据库的中间，我们将寻找其中的1000个。</p><p id="61df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们迁移并运行测试。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="9b83" class="lx ly it mw b gy na nb l nc nd">Creating test database for alias 'default'...<br/>System check identified no issues (0 silenced).<br/>Created in 0:00:03.429665<br/>Looked up in 0:00:05.001903<br/>----------------------------<br/>Ran 1 test in 8.504s</span><span id="1746" class="lx ly it mw b gy ne nb l nc nd">OK</span></pre><p id="e63b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查找1000个元素花了5.1秒。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="662b" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">我们的第一个指数</h2><p id="b9b0" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我们现在将引入一个只有一个字段的简单索引。确定这个字段是<code class="fe nf ng nh mw b">code0</code>:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="5ee7" class="lx ly it mw b gy na nb l nc nd"><strong class="mw iu">class </strong>Student(models.Model):<br/>    first_name = models.CharField(max_length=100)<br/>    last_name = models.CharField(max_length=100)<br/>    code0 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/>    code1 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/>    code2 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/>    code3 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/>    code4 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/><br/>    <strong class="mw iu">class </strong>Meta:<br/>        indexes = [models.Index(fields=[<strong class="mw iu">'code0'</strong>, ]), ]</span></pre><p id="90b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以看到为我们的模型添加了一些元数据。</p><p id="116d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">进行迁移，迁移，运行测试:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="c848" class="lx ly it mw b gy na nb l nc nd">Creating test database for alias 'default'...<br/>System check identified no issues (0 silenced).<br/>Created in 0:00:03.473439<br/><strong class="mw iu">Looked up in 0:00:00.3344573 &lt;---</strong><br/>-------------------<br/>Ran 1 test in 3.840s</span><span id="8fb1" class="lx ly it mw b gy ne nb l nc nd">OK</span></pre><p id="b880" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在数据库中查找1000个元素的时间是0.3秒，而不是5.1秒！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/e25a8ccebc49ab6588fb76833b80f589.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*DyDyEqBPVthtL0d3cADc-g.png"/></div></figure><p id="3e1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">整整快了15倍！如约而至。老实说，我首先测量，然后创建了这篇文章的标题。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="de4e" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">复杂索引</h2><p id="9ff4" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">通常情况下，您需要搜索2个字段。</p><p id="6fe5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，我们稍微改变一下我们的测试。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="4019" class="lx ly it mw b gy na nb l nc nd"><strong class="mw iu">class </strong>StudentTestCase(TestCase):<br/>    <strong class="mw iu">def </strong>setUp(self):<br/>        start_time = datetime.datetime.now()<br/>        students = []<br/>        batch_size = 500<br/>        <strong class="mw iu">for </strong>i <strong class="mw iu">in </strong>range(100000):<br/>            student = Student()<br/>            student.first_name = str(i)<br/>            student.last_name = str(i)<br/>            student.code0 = <strong class="mw iu">f"code0{</strong>i%2<strong class="mw iu">}"<br/>            </strong>student.code1 = <strong class="mw iu">f"code1{</strong>i<strong class="mw iu">}"<br/>            </strong>students.append(student)<br/>        Student.objects.bulk_create(students, batch_size)<br/><br/>        end_time = datetime.datetime.now()<br/>        print(<strong class="mw iu">f" Created in {</strong>end_time - start_time<strong class="mw iu">}"</strong>)<br/><br/>    <strong class="mw iu">def </strong>test_lookup(self):<br/>        start_time = datetime.datetime.now()<br/>        <strong class="mw iu">for </strong>i <strong class="mw iu">in </strong>range(50000, 51000):<br/>            Student.objects.filter(code0=<strong class="mw iu">f"code0{</strong>i%2<strong class="mw iu">}"</strong>).get(code1=<strong class="mw iu">f"code1{</strong>i<strong class="mw iu">}"</strong>)<br/><br/>        end_time = datetime.datetime.now()<br/>        print(<strong class="mw iu">f"Looked up in {</strong>end_time - start_time<strong class="mw iu">}"</strong>)</span></pre><p id="e170" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也就是说，我们现在查询两个字段— <code class="fe nf ng nh mw b">code0</code>和<code class="fe nf ng nh mw b">code1</code>。</p><p id="40db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这对于数据库来说要复杂得多。它花了</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="e77e" class="lx ly it mw b gy na nb l nc nd">Looked up in 0:00:12.380889</span></pre><p id="a033" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">12.3秒来处理。虽然我们有一个<code class="fe nf ng nh mw b">code0</code>的索引。</p><p id="68c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要不要加个指数？让我们先试试错误的版本:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="af35" class="lx ly it mw b gy na nb l nc nd"><strong class="mw iu">class </strong>Student(models.Model):<br/>    first_name = models.CharField(max_length=100)<br/>    last_name = models.CharField(max_length=100)<br/>    code0 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/>    code1 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/>    code2 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/>    code3 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/>    code4 = models.CharField(max_length=100, blank=<strong class="mw iu">True</strong>)<br/><br/>    <strong class="mw iu">class </strong>Meta:<br/>        indexes = [models.Index(fields=[<strong class="mw iu">'code0'</strong>, ]),<br/>                   models.Index(fields=[<strong class="mw iu">'code1'</strong>, ])]</span></pre><p id="3548" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">进行迁移，迁移并运行测试:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="8ed6" class="lx ly it mw b gy na nb l nc nd">Looked up in 0:00:00.450037</span></pre><p id="fbcf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">已经很不错了。快了27倍！</p><p id="9583" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是在这种情况下，创建索引的正确方法如下:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="36a5" class="lx ly it mw b gy na nb l nc nd"><strong class="mw iu">class </strong>Meta:<br/>    indexes = [models.Index(fields=[<strong class="mw iu">'code0'</strong>, <strong class="mw iu">'code1'</strong>]),]</span></pre><p id="26a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于我们的简单测试，它快不了多少，只有0.42秒。相对于0.45秒。但是对于庞大且更复杂的数据库来说，这真的很重要。</p><p id="b04b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您经常在一个查询中使用两个字段，就像我们在这里做的那样，您最好在一个索引中添加两个字段。</p><blockquote class="nj"><p id="894a" class="nk nl it bd nm nn no np nq nr ns lp dk translated">有趣的事实:如果你只有一个字段被索引，比如说，<code class="fe nf ng nh mw b">code0</code>，首先通过<code class="fe nf ng nh mw b">code0</code>然后通过<code class="fe nf ng nh mw b">code1</code>过滤和通过<code class="fe nf ng nh mw b">code1</code>然后通过<code class="fe nf ng nh mw b">code0</code>过滤一样快</p></blockquote><p id="16ce" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">这里有一个例子:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="ee3c" class="lx ly it mw b gy na nb l nc nd">Student.objects.filter(code0=<strong class="mw iu">f"code0{</strong>i%2<strong class="mw iu">}"</strong>).get(code1=<strong class="mw iu">f"code1{</strong>i<strong class="mw iu">}"</strong>)</span></pre><p id="c980" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">和...一样快</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="c0a8" class="lx ly it mw b gy na nb l nc nd">Student.objects.filter(code0=<strong class="mw iu">f"code1{</strong>i<strong class="mw iu">}"</strong>).get(code1=<strong class="mw iu">f"code0{</strong>i%2<strong class="mw iu">}"</strong>)</span></pre><p id="d7f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使只有一个字段被索引。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="d714" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">为什么使用索引会更快？</h2><p id="0645" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">当您进行查询时，数据库管理系统(DBMS)必须按照保存的顺序遍历包含所有字段的完整数据库。如果你的数据库有100万条记录，它必须遍历100万行并检查你的查询。</p><p id="1d34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们如何避免这种情况？我们应该对感兴趣的列进行排序和分离。</p><p id="96da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，当您创建索引时，DBMS会创建另一个只包含所需字段的表。所以，这个表要小得多，搜索起来已经很方便了。但没有那么多。</p><blockquote class="nj"><p id="860e" class="nk nl it bd nm nn no np nq nr ns lp dk translated">DBMS对那个特殊表中的行进行排序！</p></blockquote><p id="bca2" class="pw-post-body-paragraph ku kv it kw b kx nt ju kz la nu jx lc ld nv lf lg lh nw lj lk ll nx ln lo lp im bi translated">这样，它可以使用，例如，二分搜索法，使它更快。如果一个列表是按字母顺序排列的，即使是人也能在几秒钟内找到所需的数据。</p><p id="fa17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是指数。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h2 id="8beb" class="lx ly it bd lz ma mb dn mc md me dp mf ld mg mh mi lh mj mk ml ll mm mn mo mp bi translated">为什么Django中默认没有索引？</h2><p id="46dc" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">如果索引这么好，为什么默认情况下没有为所有列创建索引？这很合理，不是吗？</p><blockquote class="ny nz oa"><p id="b260" class="ku kv ob kw b kx ky ju kz la lb jx lc oc le lf lg od li lj lk oe lm ln lo lp im bi translated">因为每次更改数据库时，所有索引都必须更新。所以，你需要创造100K的记录？如果你只有一个索引，它必须为你创建20万条记录。如果你有两张，那就30万张唱片。因为我们现在有了更多的表格，所有的表格都应该在同一个页面上。</p></blockquote><p id="a20d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不仅如此，它还会消耗你的硬盘空间。</p><p id="0fcf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不仅如此，DBMS不知道您将在查询中使用什么组合。你会同时查询姓和名吗？有时候，即使是程序员，事先也不知道这一点。</p><p id="3d81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，但是插入数据库会变得更慢？</p><p id="2812" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是的，可能会慢一些，但通常这不是问题。通常，记录不是成批插入的，而是一个一个插入的。或者一次多达10条记录(是的，在ERP系统中，一个操作可能导致插入10个表，每个表100行，有时甚至更多)。所以，当你创建一个新用户时，可能会慢十分之一秒。谁在乎呢。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="2a60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">参见我关于Django优化的另一篇文章:</p><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/optimizing-django-queries-28e96ad204de"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">如何编写快35倍的Django查询</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">使用批量查询、预加载外键等。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ko oi"/></div></div></a></div></div></div>    
</body>
</html>