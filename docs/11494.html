<html>
<head>
<title>Forbid creating objects outside a factory in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">禁止在PHP工厂外创建对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/forbidding-of-creating-objects-outside-factory-in-php-7173d7be6cb4?source=collection_archive---------4-----------------------#2022-03-21">https://levelup.gitconnected.com/forbidding-of-creating-objects-outside-factory-in-php-7173d7be6cb4?source=collection_archive---------4-----------------------#2022-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9560" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">领域驱动设计建议在工厂中创建集合和其他复杂的对象。在PHP中，我们可以将构造函数定义为private或protected，然后只能在类本身的工厂方法中创建对象。但它违反了单一责任原则。还有别的办法吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/81da9faf80c76199be536cc28822e1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vtteH45PJIDu1H5lDQMebw.jpeg"/></div></div></figure><p id="96e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想在类之外创建对象，这个类的构造函数必须是公共的。这是否意味着我们需要相信其他开发人员不会在工厂之外创建对象？不，不是的。构造函数可以控制对象的创建位置。函数<a class="ae ln" href="https://www.php.net/manual/en/function.debug-backtrace.php" rel="noopener ugc nofollow" target="_blank"> debug_backtrace </a>将帮助我们解决这个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="216a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们不想在每个类中添加方法checkFactory，这个方法不足以成为创建抽象超类的理由。所以这里是使用trait的好地方。</p><p id="d15e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它可以工作，但是classA仍然有额外的责任——验证它是在哪里创建的。所以我们返回私有/受保护的构造函数。有没有方法在类本身的静态方法之外用私有/受保护的构造函数创建类的实例？这可以通过PHP核心的模块反射来实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="ab00" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ClassA中的常量FRIEND_CLASSES用于定义可以创建类实例的类列表。</p><p id="8279" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在ClassA没有额外的职责，我们只能在friend类中创建类的实例。但是性能怎么样呢？所以，我们来测试一下。</p><p id="2f51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为起点，我们将使用未经任何验证的工厂:</p><pre class="kg kh ki kj gt lq lr ls lt aw lu bi"><span id="c69d" class="lv lw iq lr b gy lx ly l lz ma">test.php</span><span id="9ade" class="lv lw iq lr b gy mb ly l lz ma">&lt;?php</span><span id="3807" class="lv lw iq lr b gy mb ly l lz ma">class ClassA<br/>{<br/>    public function __construct() {}<br/>}</span><span id="aab1" class="lv lw iq lr b gy mb ly l lz ma">class Factory<br/>{<br/>    public function create(): ClassA<br/>    {<br/>        return new ClassA();<br/>    }<br/>}</span><span id="e3de" class="lv lw iq lr b gy mb ly l lz ma">$start = microtime(true);<br/>$factory  = new Factory();<br/>for ($i = 0; $i &lt; 100000; $i++) {<br/>    $object = $factory-&gt;create();<br/>}<br/>echo microtime(true) - $start;</span><span id="e8ee" class="lv lw iq lr b gy mb ly l lz ma">&gt; php test.php<br/>0.12572288513184</span></pre><p id="8a3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后用debug_backtrace做同样的事情:</p><pre class="kg kh ki kj gt lq lr ls lt aw lu bi"><span id="594f" class="lv lw iq lr b gy lx ly l lz ma">&gt; php backtrace.php<br/>0.26334500312805</span></pre><p id="6990" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过思考:</p><pre class="kg kh ki kj gt lq lr ls lt aw lu bi"><span id="0c4e" class="lv lw iq lr b gy lx ly l lz ma">&gt; php reflect.php<br/>0.52497291564941</span></pre><p id="55d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，使用debug_backtrace验证创建对象比不使用验证慢2倍，使用反射慢4倍。但是我们需要明白classA的构造函数和我们的工厂什么都不做。我们只测量PHP创建空对象的时间。在实际情况下，差异会更小。</p><p id="d95b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们对这个想法有什么看法？你使用任何方法来避免在其工厂之外创建对象吗？</p></div></div>    
</body>
</html>