<html>
<head>
<title>Let's "Go" and build an Application with gRPC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们开始用gRPC构建一个应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lets-go-and-build-an-application-with-grpc-c5b754400f64?source=collection_archive---------0-----------------------#2021-10-08">https://levelup.gitconnected.com/lets-go-and-build-an-application-with-grpc-c5b754400f64?source=collection_archive---------0-----------------------#2021-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c6510484c11d2dfecd23c5bcedcb4a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQxwD2b29FmNGvz749cEZQ.png"/></div></div></figure><p id="53f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">REST(表述性状态转移)架构已经成为构建web应用、微服务等应用的首选方法。REST provide提供了一套关于如何创建API的指南。REST架构一般依赖<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" rel="noopener ugc nofollow" target="_blank"> HTTP协议</a>。当一个API完全满足以下条件时，它将被视为“RESTful”。</p><ul class=""><li id="1a5f" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><strong class="kd iu">统一的界面</strong></li><li id="b629" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">客户端-服务器独立性</strong></li><li id="f286" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">无状态</strong></li><li id="96cb" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">可缓存</strong></li><li id="f062" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">分层</strong></li></ul><p id="13ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然REST的引入是为了解决<a class="ae kz" href="https://en.wikipedia.org/wiki/SOAP" rel="noopener ugc nofollow" target="_blank"> SOAP </a>(它使用了<a class="ae kz" href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener ugc nofollow" target="_blank"> RPC </a>)的缺点，但REST返回了大量元数据，这是它无法取代<strong class="kd iu">轻量级RPC的主要原因，</strong>这导致了新的或改进的技术的引入，如<a class="ae kz" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>和<a class="ae kz" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>。</p><p id="afff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">gRPC (Google Remote Procedure Call)是Google为实现微服务之间的高速通信而开发的高性能、开源的通用<a class="ae kz" href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener ugc nofollow" target="_blank"> RPC </a>框架。默认情况下，gRPC有Protobuf(协议缓冲区),它会将消息格式化或序列化为特定的格式，这将是高度打包的高效数据。所以很明显，像gRPC 这样的轻量级RPC 对于某些用例来说是理想的。在本文中，让我们深入了解使用gRPC和使用Go构建应用程序的好处，Go是构建微服务最著名的语言之一。</p><h1 id="bea3" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><strong class="ak">什么是RPC？</strong></h1><p id="c68f" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">RPC(远程过程调用)是最古老的可用体系结构之一。RPC允许您以特定的格式调用远程服务器上的函数，并以相同的格式接收响应。在某种程度上，RPC API的概念类似于REST API的概念。RPC APIs定义了客户端可以与之交互的规则和方法。然后，客户端提交带有一些参数的调用来调用这些方法。您可以在查询字符串中找到这些参数。一个RPC调用<strong class="kd iu">POST</strong>/<strong class="kd iu">DELETE pokemon</strong>会有一个类似于<strong class="kd iu"> {"id": 2 } </strong>的查询字符串，一个典型的REST会有<strong class="kd iu">DELETE</strong>/pokemon/DELETE/<strong class="kd iu">2。</strong></p><h1 id="d300" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">探索gRPC</h1><p id="8ffb" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">gRPC可以被认为是RPC的后继者，它是轻量级的。谷歌开发它是为了在微服务和其他需要交互的系统之间进行通信。使用gRPC有几个好处。</p><ul class=""><li id="0416" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><strong class="kd iu">使用协议缓冲区(Protobuf)代替JSON </strong></li><li id="5e48" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">基于HTTP 2而非HTTP 1.1构建</strong></li><li id="cf6d" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">内置代码生成</strong></li><li id="cbc9" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">高性能</strong></li><li id="5971" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu"> SSL安全</strong></li></ul><p id="11a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了上面提到的主要优点，gRPC还能在您的应用中促进更好的设计。gRPC是面向API的，而不是像REST那样面向资源的。gRPC的另一个特性是，默认情况下它是异步的，这意味着它不会根据请求阻塞线程，并且它可以并行处理数百万个请求，这确保了高可伸缩性。gRPC中有四种类型的API。</p><ul class=""><li id="66b0" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><strong class="kd iu">一元<br/> </strong>看起来很像传统的API (REST API ),客户端发出请求，服务器发送响应。</li></ul><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/80c2be1f86e069f4d4cf1591060925f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*pT3pN1_QFtvRU0xtX18x7w.png"/></div></figure><ul class=""><li id="4bad" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><strong class="kd iu">服务器流<br/> </strong>这里客户端会发出一个请求，服务器会发送多个或者一个数据流。</li></ul><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/67d65891b43afc78fb30c97c1cb63c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*r9bVxiKWG0fOJrSo-CuYWA.png"/></div></figure><ul class=""><li id="7c93" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><strong class="kd iu">客户端流<br/> </strong>这类似于服务器流，但方式相反，客户端将发送一个数据流，而服务器将发送一个响应。</li></ul><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/14dd8428beaf69f068d9f7cd3446fabc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*UdRBigJQwEsBlLjK79e-Vw.png"/></div></figure><ul class=""><li id="2e28" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><strong class="kd iu">双向流<br/> </strong>在双向流中，客户机和服务器都将发送数据流。</li></ul><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/2087e792e86cf99f816749cfe70f1531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*IbINZqRmzB_e9sgYGmLPSQ.png"/></div></figure><h2 id="71b8" class="mw lp it bd lq mx my dn lu mz na dp ly km nb nc mc kq nd ne mg ku nf ng mk nh bi translated"><strong class="ak">协议缓冲区有什么特别之处？</strong></h2><p id="2e72" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">Protocol Buffers是一种开源、独立于语言且可扩展的数据序列化机制。协议缓冲区用于接口定义语言和消息交换格式。与<strong class="kd iu"> JSON </strong> (JavaScript对象符号)不同，协议缓冲区<strong class="kd iu"> </strong>是语言不可知的，更小(有效载荷大小)，更快，更简单，高性能。gRPC使用协议缓冲区来定义</p><ul class=""><li id="07a2" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><strong class="kd iu">消息</strong>(数据、请求和响应)</li><li id="a6b4" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><strong class="kd iu">服务</strong>(服务名和RPC端点)</li></ul><p id="019a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了协议缓冲区，你所需要的就是定义你的结构化数据，名为<strong class="kd iu">protocol</strong>的协议缓冲编译器会根据你选择的语言生成<strong class="kd iu"> </strong>代码。最新的协议(版本3)支持C#、C++、Dart、Go、Java、Kotlin、Node、Objective-C、PHP、Python、Ruby等语言。</p><h1 id="7d30" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">什么时候应该使用gRPC</h1><p id="d284" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">有了上面提到的好处，你应该认识到gRPC将是选定的内部应用的理想选择。</p><ul class=""><li id="0861" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">微服务连接</li><li id="7af7" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">实时流</li><li id="8c9f" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">多语言系统</li></ul><p id="0599" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以看到为什么gRPC会成为具有上述特性的微服务API和移动服务器API的未来。gRPC是<a class="ae kz" href="https://www.cncf.io/" rel="noopener ugc nofollow" target="_blank">云本地计算基金会(CNCF) </a>和几大科技巨头如谷歌、网飞、Square、CoackroachDB的一部分。</p><h1 id="6da9" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">【gRPC入门</h1><p id="4c38" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">让我们通过使用Golang构建一个小型<strong class="kd iu">服务器流</strong> gRPC <strong class="kd iu"> </strong>应用程序来深入了解gRPC。使用gRPC，我们将不得不使用协议缓冲区来定义消息和服务。gRPC/protocol(proto buff编译器)将为它们生成接口，我们应该实现更多的功能，比如为数据库层添加<a class="ae kz" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>来持久化数据。</p><h2 id="890c" class="mw lp it bd lq mx my dn lu mz na dp ly km nb nc mc kq nd ne mg ku nf ng mk nh bi translated">先决条件</h2><ul class=""><li id="3d59" class="la lb it kd b ke mm ki mn km ni kq nj ku nk ky lf lg lh li bi translated">Go的最新版本(1.0或更高版本)</li><li id="d9ff" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">最新版本的<strong class="kd iu">协议</strong>(协议3)</li></ul><p id="8f88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在开始使用gRPC之前，我们需要安装<strong class="kd iu">protocol</strong>编译器，并将其添加为从整个操作系统中的任何地方访问它的路径。你可以通过这个<a class="ae kz" href="https://grpc.io/docs/protoc-installation/" rel="noopener ugc nofollow" target="_blank">链接</a>找到你的操作系统的相关安装过程。</p><p id="2429" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">安装协议后，让我们初始化项目。让我们创建一个目录并运行以下命令。</p><pre class="ms mt mu mv gt nl nm nn no aw np bi"><span id="c1c0" class="mw lp it nm b gy nq nr l ns nt">go mod init github.com/username/grpc-pokemon</span><span id="df12" class="mw lp it nm b gy nu nr l ns nt">go get -u google.golang.org/<strong class="nm iu">grpc</strong><br/>go get -u google.golang.org/<strong class="nm iu">protobuf/protoc-gen-go</strong></span></pre><p id="7ea8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个命令创建一个<a class="ae kz" href="https://golang.org/ref/mod" rel="noopener ugc nofollow" target="_blank"> go.mod </a>文件来跟踪代码的依赖关系。接下来，让我们进入最激动人心的部分，那就是<strong class="kd iu"> <em class="nv">的创造。proto</em>T25】文件。在这<strong class="kd iu">中<em class="nv">。proto </em> </strong>文件，我们要定义服务和各自的函数/消息，通过protoc编译器，它会生成必要的protobuf文件。接下来的两个命令将为golang的<strong class="kd iu"> grpc </strong>和<strong class="kd iu">protocol-gen-go、</strong>安装依赖项。我们文件的原型文件<strong class="kd iu">。现在让我们在名为<strong class="kd iu">口袋妖怪</strong>的目录下创建这个原型文件。</strong></strong></p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="5114" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在定义了消息和服务之后，让我们来编译一下，看看<strong class="kd iu">protocol</strong>编译器如何为golang生成相应的代码。为此，让我们从项目的根目录执行下面的命令。</p><pre class="ms mt mu mv gt nl nm nn no aw np bi"><span id="0bcf" class="mw lp it nm b gy nq nr l ns nt"><strong class="nm iu">protoc</strong> — go_out=<strong class="nm iu">.</strong> — go_opt=paths=<strong class="nm iu">source_relative</strong> — go-grpc_out=<strong class="nm iu">.<br/></strong> — go-grpc_opt=paths=<strong class="nm iu">source_relative</strong> <strong class="nm iu">pokemon/pokemon.proto</strong></span></pre><p id="a6b0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，我们使用了相对路径，并设置了要编译的<strong class="kd iu"> <em class="nv"> pokemon.proto </em> </strong>文件的路径。上面的命令将生成两个文件(<a class="ae kz" href="https://gist.github.com/TRomesh/d9d0f4e74fbb91dc1c61ffc78b8836a0" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> pokemon.pb.go </strong> </a>)，用于使用protobuf序列化消息，另一个文件(<a class="ae kz" href="https://gist.github.com/TRomesh/cc4e414e139ce47ba19a3a2482b37faa" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">pokemon _ grpc . Pb . go</strong></a>)由grpc客户端的一些代码和服务器代码组成，我们将在稍后实现它们。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/521bcad6e407d46a42841cb259611f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*3YiH8Buvy4Xp3U2kZFfmjg.png"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">由协议生成的go文件</figcaption></figure><p id="76f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你仔细观察文件<a class="ae kz" href="https://gist.github.com/TRomesh/cc4e414e139ce47ba19a3a2482b37faa" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">pokemon _ grpc . Pb . go</strong></a><strong class="kd iu"/><strong class="kd iu">，</strong>你会注意到golang是为客户端和服务器实现生成的<strong class="kd iu">结构</strong>和<strong class="kd iu">接口</strong>。</p><p id="4600" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们开始为这个应用程序构建服务器和客户机，通过创建一个<strong class="kd iu"> server.go </strong>文件来开始服务器实现。因为我们要持久化数据，所以我们将安装MongoDB的golang依赖项。</p><pre class="ms mt mu mv gt nl nm nn no aw np bi"><span id="fdfd" class="mw lp it nm b gy nq nr l ns nt">go get go.mongodb.org/mongo-driver/mongo</span></pre><p id="d0b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">安装MongoDB之后，让我们创建服务器以及MongoDB连接，并实现由protoc编译器生成的功能。首先，让我们导入生成的protobuff定义，并使用协议生成的<strong class="kd iu"> PokemonServiceServer </strong>创建一个结构。接下来，我们可以实现。proto文件:createPokemon，ReadPokemon等。</p><pre class="ms mt mu mv gt nl nm nn no aw np bi"><span id="a12d" class="mw lp it nm b gy nq nr l ns nt">import (<br/>"context"<br/>"fmt"<br/>"log"<br/>"net"<br/>"os"<br/>"os/signal"</span><span id="a63a" class="mw lp it nm b gy nu nr l ns nt"><strong class="nm iu">pokemonpc</strong> "github.com/TRomesh/grpc-pokemon/pokemon"<br/>"github.com/joho/godotenv"<br/>"go.mongodb.org/mongo-driver/bson"<br/>"go.mongodb.org/mongo-driver/bson/primitive"<br/>"go.mongodb.org/mongo-driver/mongo"<br/>"go.mongodb.org/mongo-driver/mongo/options"<br/>"google.golang.org/grpc"<br/>"google.golang.org/grpc/codes"<br/>"google.golang.org/grpc/reflection"<br/>"google.golang.org/grpc/status"<br/>)</span><span id="3a10" class="mw lp it nm b gy nu nr l ns nt">var collection *mongo.Collection</span><span id="1344" class="mw lp it nm b gy nu nr l ns nt">type <strong class="nm iu">server </strong>struct {<br/>  <strong class="nm iu">pokemonpc</strong>.<strong class="nm iu">PokemonServiceServer</strong><br/>}</span><span id="b84e" class="mw lp it nm b gy nu nr l ns nt">type <strong class="nm iu">pokemonItem </strong>struct {<br/> ID          primitive.ObjectID `bson:"_id,omitempty"`<br/> Pid         string             `bson:"pid"`<br/> Name        string             `bson:"name"`<br/> Power       string             `bson:"power"`<br/> Description string             `bson:"description"`<br/>}</span><span id="ffd3" class="mw lp it nm b gy nu nr l ns nt">func getPokemonData(data *pokemonItem) *pokemonpc.Pokemon {<br/> return &amp;pokemonpc.Pokemon{<br/>  Id:          data.ID.Hex(),<br/>  Pid:         data.Pid,<br/>  Name:        data.Name,<br/>  Power:       data.Power,<br/>  Description: data.Description,<br/> }<br/>}</span><span id="8200" class="mw lp it nm b gy nu nr l ns nt">func (*server) <strong class="nm iu">CreatePokemon</strong>(ctx context.Context, req *pokemonpc.<strong class="nm iu">CreatePokemonRequest</strong>) (*pokemonpc.<strong class="nm iu">CreatePokemonResponse</strong>, error) {</span><span id="31b7" class="mw lp it nm b gy nu nr l ns nt">fmt.Println("Create Pokemon")<br/>pokemon := req.GetPokemon()<br/>data := pokemonItem{<br/> Pid:         pokemon.GetPid(),<br/> Name:        pokemon.GetName(),<br/> Power:       pokemon.GetPower(),<br/> Description: pokemon.GetDescription(),<br/>}</span><span id="e3ea" class="mw lp it nm b gy nu nr l ns nt">res, err := collection.InsertOne(ctx, data)</span><span id="9cb2" class="mw lp it nm b gy nu nr l ns nt">if err != nil {<br/> return nil, status.Errorf(<br/>  codes.Internal,<br/>  fmt.Sprintf("Internal error: %v", err),<br/> )<br/>}</span><span id="5acd" class="mw lp it nm b gy nu nr l ns nt">oid, ok := res.InsertedID.(primitive.ObjectID)<br/>  if !ok {<br/>   return nil, status.Errorf(<br/>    codes.Internal,<br/>    fmt.Sprintf("Cannot convert to OID"),<br/>  )<br/>}</span><span id="6ac4" class="mw lp it nm b gy nu nr l ns nt">return &amp;pokemonpc.<strong class="nm iu">CreatePokemonResponse</strong>{<br/>  Pokemon: &amp;pokemonpc.Pokemon{<br/>  Id:          oid.Hex(),<br/>  Pid:         pokemon.GetPid(),<br/>  Name:        pokemon.GetName(),<br/>  Power:       pokemon.GetPower(),<br/>  Description: pokemon.GetDescription(),<br/>  },<br/>}, nil</span><span id="a87c" class="mw lp it nm b gy nu nr l ns nt">}</span></pre><p id="13d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，我们使用了为每个请求生成的结构(*pokemonpc。<strong class="kd iu"> CreatePokemonRequest </strong>)和response (*pokemonpc。<strong class="kd iu">按协议创建口袋妖怪响应</strong>)。以这种方式，我们可以实现所有其他的功能，读取，更新，删除口袋妖怪。</p><p id="7dba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们转向应用程序的客户端。由于它是一个CLI应用程序，我们将在一次尝试中执行每个函数，如(createPokemon，ReadPokemon，UpdatePokemon等。).</p><figure class="ms mt mu mv gt ju"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0792" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们已经使用协议生成的接口和结构创建了客户机和服务器。让我们通过执行以下命令来启动服务器。</p><pre class="ms mt mu mv gt nl nm nn no aw np bi"><span id="19aa" class="mw lp it nm b gy nq nr l ns nt">$ go run server/server.go</span></pre><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/0282a74c7679d76a9bfa6a7df95e358b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*OHuRkOBsvm4HguLCk2Hz1A.png"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">启动口袋妖怪服务器</figcaption></figure><p id="5ce6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在是运行客户端应用程序的时候了，它将调用服务器中为Pokemon CRUD操作定义的方法。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/7f5fd814fa5b7b32f0acbd8f417abc9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6O346KMEt8EvjYW9QJX8MQ.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">客户端执行</figcaption></figure><p id="4b01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当客户端调用Pokemon CRUD操作时，您可以从服务器端注意到以下日志。</p><figure class="ms mt mu mv gt ju gh gi paragraph-image"><div class="gh gi of"><img src="../Images/837b4c2d8e3a81835c1da321139838c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*ZecL3F_nIbfjSxcNF1JPiw.png"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">执行客户端后的服务器日志</figcaption></figure><p id="0ab5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以通过这个<a class="ae kz" href="https://github.com/TRomesh/grpc-pokemon" rel="noopener ugc nofollow" target="_blank">链接</a>找到上面例子的完整代码。</p><h1 id="b7ae" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated"><strong class="ak">结论</strong></h1><p id="09d0" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">总之，gRPC是构建微服务和实时流服务的最佳方法之一。像<strong class="kd iu"> protobuf </strong>、<strong class="kd iu"> HTTP2 make和SSL Security </strong>这样的特性使得<strong class="kd iu"> </strong> gRPC比REST架构更健壮、更安全、性能更好。gRPC还支持所有最著名的语言，这样你就可以用你最喜欢的语言开始使用gRPC。要了解更多信息，请务必通读gRPC 的<a class="ae kz" href="https://grpc.io/docs/" rel="noopener ugc nofollow" target="_blank">文档。最后，感谢您花时间阅读本文。我想看看你下面的问题和评论。</a></p><p id="698c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有最后一件事！如果你喜欢我的内容，请帮我一个忙，为你和我弄杯咖啡<a class="ae kz" href="https://www.buymeacoffee.com/tromesh" rel="noopener ugc nofollow" target="_blank">！</a></p><p id="6faa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">干杯！</p><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/lets-go-and-build-graphql-api-with-gqlgen-bfea2f346ea1"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">让我们开始用gqlgen构建Graphql API</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">Golang是过去十年中最受欢迎的编程语言之一，主要是因为它的快速…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox jz oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/urql-the-highly-customizable-and-versatile-graphql-client-69e4e3406904"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">高度可定制和多功能的GraphQL客户端</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">在过去的十年里，REST架构已经成为web应用程序的行业标准，因为REST提供了一个…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox jz oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/build-your-own-self-hosted-ci-cd-workflow-with-github-actions-ec9ee1dcd800"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">使用GitHub操作构建您自己的自托管CI/CD工作流</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">GitHub引入了GitHub Actions，使开发人员能够直接从他们的GitHub库自动化工作流…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="oz l ou ov ow os ox jz oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/valtio-the-proxy-based-state-management-6f3304b53968"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">基于代理的状态管理</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">在开发web应用程序之前，决定正确的状态管理工具是最重要的决定之一…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="pa l ou ov ow os ox jz oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/jotai-atom-based-state-management-for-react-1ce8fd380296"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">jotai:React的基于原子的状态管理</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">在过去的几年里，国家管理有了很大的发展。有很多库和方法可以让你…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="pb l ou ov ow os ox jz oj"/></div></div></a></div></div></div>    
</body>
</html>