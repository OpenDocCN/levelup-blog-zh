<html>
<head>
<title>Maximize Code Security in Your NestJS Applications (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最大化NestJS应用程序中的代码安全性(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/maximize-code-security-in-your-nestjs-applications-part-2-be707466b7ea?source=collection_archive---------5-----------------------#2022-12-28">https://levelup.gitconnected.com/maximize-code-security-in-your-nestjs-applications-part-2-be707466b7ea?source=collection_archive---------5-----------------------#2022-12-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e14f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过真实世界的例子来保护代码的最佳实践</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/342daa883626f29ba48fab927159081b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BD1EN9VfbpySrTqv-ZwECw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由DALL-E生成</figcaption></figure><p id="494e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文第1部分中，我们介绍了NestJS环境中的4种常见安全风险及其防范措施。值得注意的是，尽管这里使用了NestJS(作为我最喜欢的API框架之一)，但是那些最佳实践是框架不可知的。</p><p id="f5e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们继续深入研究其他常见的安全漏洞。</p><ul class=""><li id="1f5b" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><a class="ae lu" href="#5dcf" rel="noopener ugc nofollow">注射</a></li><li id="e5d3" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="#dc35" rel="noopener ugc nofollow">缺乏资源和速率限制</a></li><li id="5963" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="#035f" rel="noopener ugc nofollow">识别和认证失败</a></li><li id="e848" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="#1fa9" rel="noopener ugc nofollow">缺少对象级访问控制</a></li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="5dcf" class="mq mr it bd ms mt mu dn mv mw mx dp my lh mz na nb ll nc nd ne lp nf ng nh ni bi translated">注射</h2><p id="122c" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">作为最广为人知的漏洞之一，当攻击者通过将任意代码或命令注入到应用程序中来执行它们时，就会发生注入。注入攻击可以采取多种形式，如SQL注入、命令注入和表达式注入。</p><p id="243c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然注射是一个众所周知的风险，但它仍然频繁发生。最近的一些事件包括<a class="ae lu" href="https://en.wikipedia.org/wiki/2017_Equifax_data_breach" rel="noopener ugc nofollow" target="_blank"> 2017年Equifax数据泄露</a>影响1.47亿用户，2018年英国航空公司数据泄露泄露38万信用卡信息，以及<a class="ae lu" href="https://www.capitalone.com/digital/facts2019/#:~:text=When%20did%20this%20occur%3F,4." rel="noopener ugc nofollow" target="_blank"> 2019年Capital One </a>泄露1亿用户个人信息，这都是SQL注入造成的。</p><p id="d985" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是SQL注入的一个例子</p><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="6f28" class="nt mr it np b be nu nv l nw nx">import { Injectable } from '@nestjs/common';<br/>import { Connection } from 'typeorm';<br/><br/>@Injectable()<br/>export class ClientService {<br/>  constructor(private connection: Connection) {}<br/><br/>  async getClients(name: string) {<br/>    const query = `SELECT * FROM client WHERE name = '${name}'`;<br/>    return await this.connection.query(query);<br/>  }<br/>}<br/>// Client Controller<br/>@Controller('users')<br/>export class ClientController {<br/>  constructor(private clientService: ClientService) {}<br/><br/>  @Get('search')<br/>  async searchClient(name: string) {<br/>    return this.clientService.getClients(name);<br/>  }<br/>}</span></pre><p id="13cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，<code class="fe ny nz oa np b">ClientService </code>类使用<code class="fe ny nz oa np b">name</code>参数构建一个针对数据库执行的SQL查询。如果没有对<code class="fe ny nz oa np b">name </code>参数进行适当的清理，攻击者可以通过包含特殊字符将恶意代码注入到查询中。例如，攻击者可以发送一个带有<code class="fe ny nz oa np b">name</code>参数的请求，比如<code class="fe ny nz oa np b">'; DROP TABLE client; --</code>，这将删除<code class="fe ny nz oa np b">client </code>表。</p><p id="5148" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可以通过净化用户输入并尽可能使用预处理语句或参数化查询来防止SQL注入。这是上一个例子的改进版本。</p><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="c295" class="nt mr it np b be nu nv l nw nx">import { Injectable } from '@nestjs/common';<br/>import { Connection } from 'typeorm';<br/><br/>@Injectable()<br/>export class ClientService {<br/>  constructor(private connection: Connection) {}<br/><br/>  async getClients(name: string) {<br/>    const query = 'SELECT * FROM client WHERE name = $1';<br/>    const params = [name];<br/>    return await this.connection.query(query, params);<br/>  }<br/>}</span></pre><p id="7e04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">修订后的<code class="fe ny nz oa np b">ClientService </code>使用参数化查询，这有助于确保用户输入被视为数据，而不是可执行代码。</p><p id="dfe3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一种常见的注入攻击是操作系统命令注入。当攻击者注入并执行任意操作系统命令时，就会发生这种情况，注入可以通过请求头或参数等完成。这里有一个例子。</p><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="d9a7" class="nt mr it np b be nu nv l nw nx">@Injectable()<br/>export class ClientService {<br/>  public executeCommand(command: string): void {<br/>    const commandArray = command.split(' ');<br/>    spawn(commandArray[0], commandArray.slice(1));<br/>  }<br/>}</span></pre><p id="fccf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果没有对<code class="fe ny nz oa np b">command </code>输入进行适当的消毒或验证，上面的代码就会为类似于<code class="fe ny nz oa np b">rm rf /var/www</code>的恶意命令打开大门。</p><p id="133a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了防止操作系统命令注入，最好的方法是用特定于框架的API替换应用程序中的操作系统命令。或者，我们应该转义并验证用户输入，以确保只有预期的输入会通过验证。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="dc35" class="mq mr it bd ms mt mu dn mv mw mx dp my lh mz na nb ll nc nd ne lp nf ng nh ni bi translated">缺乏资源和速率限制</h2><p id="472c" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">许多客户端可以同时调用一个API。如果并发请求的数量超过限制，API将变得没有响应，甚至崩溃。</p><p id="45b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">高峰时段合法请求的突然激增或恶意DDoS攻击都会触发此漏洞。最近的DDoS攻击之一是<a class="ae lu" href="https://www.a10networks.com/blog/aws-hit-by-largest-reported-ddos-attack-of-2-3-tbps/" rel="noopener ugc nofollow" target="_blank"> 2020 AWS web服务攻击</a>。</p><p id="3f5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当攻击者在短时间内发送大量请求时，任何没有速率限制的API端点都容易受到攻击。为了防止它，我们可以在NestJS中使用一个限速中间件。你有几个选择，如<code class="fe ny nz oa np b"><a class="ae lu" href="https://github.com/nestjs/throttler" rel="noopener ugc nofollow" target="_blank">nestjs/throttler</a> </code>或<code class="fe ny nz oa np b">e<a class="ae lu" href="https://github.com/express-rate-limit/express-rate-limit" rel="noopener ugc nofollow" target="_blank">xpress-rate-limit</a>.</code></p><p id="fab0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的例子中，我们使用<code class="fe ny nz oa np b">nestjs/throttler</code>来限制在1分钟内最多可以从同一个IP向一个端点发出10个请求。它适用于应用程序的所有传入请求。</p><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="5ef0" class="nt mr it np b be nu nv l nw nx">@Module({<br/>  imports: [<br/>    ThrottlerModule.forRoot({<br/>      ttl: 60,<br/>      limit: 10,<br/>    }),<br/>  ],<br/>})<br/>export class AppModule {}</span></pre><p id="5c3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有其他选项可用于自定义限制。例如，您可以使用<code class="fe ny nz oa np b">@SkipThrottle</code> decorator来禁用端点的速率限制，或者使用<code class="fe ny nz oa np b">@Throttle()</code> decorator来覆盖全局模块中设置的<code class="fe ny nz oa np b">limit</code>和<code class="fe ny nz oa np b">ttl</code>。</p><p id="63df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了请求数量之外，还应考虑以下限制</p><ul class=""><li id="b7d8" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">执行超时:如果一个请求需要很长时间才能完成，那么它应该被终止。</li><li id="56af" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">有效负载大小/响应的最大数据量，如果请求返回潜在的大量数据</li><li id="8596" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">最大可分配内存:过多的内存使用会导致应用程序崩溃。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="035f" class="mq mr it bd ms mt mu dn mv mw mx dp my lh mz na nb ll nc nd ne lp nf ng nh ni bi translated">识别和认证失败</h2><p id="0676" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">识别和身份验证失败是与应用程序的身份验证过程和识别过程相关的漏洞。</p><p id="e2e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当系统或应用程序没有可靠的方法来验证用户身份时，或者当身份验证过程很容易被绕过或操纵时，就会发生这种情况。</p><p id="87c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种漏洞有多种不同的形式。最常见的一种被称为会话劫持。下面是一个在NestJS应用程序中发生这种情况的例子:</p><ul class=""><li id="d7a7" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">攻击者拦截普通用户的会话cookies。这些cookies可能包含用户ID或角色等信息以及其他识别信息。</li></ul><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="0206" class="nt mr it np b be nu nv l nw nx">// Cookies content<br/>eyJ1c2VySWQiOjEyMzQ1LCJ1c2VyUm9sZSI6Im5vcm1hbCJ9<br/>// JSON<br/>{"userId":12345,"userRole":"normal"}</span></pre><ul class=""><li id="7c37" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">攻击者修改会话cookies来更改用户角色和其他标识信息，以匹配管理帐户。</li><li id="90f0" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">攻击者伪装成管理员，将修改后的cookies发送回服务器。服务器接收修改后的cookies，并授予攻击者以管理权限访问应用程序。</li></ul><p id="a5af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的例子很明显是服务器端认证不充分造成的。为了在NestJS中防止这种类型的攻击，一种方法是使用JWT (JSON Web token)实现身份验证。NestJS提供了一个<a class="ae lu" href="https://github.com/nestjs/jwt" rel="noopener ugc nofollow" target="_blank"> </a> <code class="fe ny nz oa np b"><a class="ae lu" href="https://github.com/nestjs/jwt" rel="noopener ugc nofollow" target="_blank">@nestjs/jwt </a></code>包供JWT操纵。你可以在你的NestJS应用<a class="ae lu" href="https://docs.nestjs.com/security/authentication#jwt-functionality" rel="noopener ugc nofollow" target="_blank">这里</a>找到更多关于JWT实现的细节。</p><p id="9145" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了进一步加强身份验证，您可以考虑实现MFA(多因素身份验证)。最流行的MFA形式是OTP(一次性密码)。</p><p id="6399" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以创建自己的OTP服务来存储一次性密码并管理通过电话或电子邮件的发送。如果你不想重新发明轮子，我们可以使用现有的库，比如<a class="ae lu" href="https://github.com/yeojz/otplib" rel="noopener ugc nofollow" target="_blank"> otplib </a>。</p><p id="30ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是在NestJS中使用otplib的基本步骤</p><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="a207" class="nt mr it np b be nu nv l nw nx">// install Otplib<br/>npm install otplib<br/>// import it<br/>import * as OTPLib from 'otplib';<br/><br/>// generate a secrete<br/>const secret = OTPLib.authenticator.generateSecret();<br/>// then, we can gerenate a QRCode url to show a QRCode in your app<br/>// we should save the generated secret in database for later use<br/>const otpUrl = OTPLib.authenticator.keyuri('user', 'The App name', secret);<br/><br/>// Now user scan the QRCode and sent it to the NestJS endpoint<br/>// we can use the built in authenticator.verify to validate the otp token<br/>import { authenticator } from 'otplib';<br/><br/>authenticator.verify({<br/>      token: token // Sent from Client,<br/>      secret: secrete // previously saved secrete<br/>    })</span></pre><p id="dd8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果无法实现MFA，可以考虑的其他额外安全性选项包括:</p><ul class=""><li id="8dc3" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">安全问题</li><li id="362d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">验证码</li><li id="c8cb" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">需要强密码</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="1fa9" class="mq mr it bd ms mt mu dn mv mw mx dp my lh mz na nb ll nc nd ne lp nf ng nh ni bi translated">缺少对象级访问控制</h2><p id="0875" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">对象级访问控制是一种安全机制，它可以根据请求访问的用户的权限或角色来控制对特定对象或资源的访问。</p><p id="30d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个在NestJS应用程序中风险可能发生的例子:</p><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="6daa" class="nt mr it np b be nu nv l nw nx">import { Injectable } from '@nestjs/common';<br/>import { ClientService } from './client.service';<br/><br/>@Injectable()<br/>export class AttachmentController {<br/>  constructor(private clientService: ClientService) {}<br/><br/>  @Get('/document/:id')<br/>  public async getFile(id: string): Promise&lt;any&gt; {<br/>    return await this.clientService.getAttachmentById(id);<br/>  }<br/>}</span></pre><p id="42e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，<code class="fe ny nz oa np b">AttachmentController</code>中的<code class="fe ny nz oa np b">getFile</code>方法没有适当的对象级访问控制，以确保只有附件的所有者或有权限的用户才能访问它。攻击者可能通过猜测附件id来访问系统中的任何文件。</p><p id="158c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了防止这种风险，我们可以验证用户是所有者或者拥有访问对象或资源的权限。</p><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="bb80" class="nt mr it np b be nu nv l nw nx">@Injectable()<br/>export class AttachmentController {<br/>  constructor(private clientService: ClientService) {}<br/><br/>  @Get('/document/:id')<br/>  public async getFile(id: string): Promise&lt;any&gt; {<br/>    const currentUser = getCurrentUser();<br/>    const document = await this.clientService.getAttachmentById(id);<br/>    if (currentUser.id !== document.ownerId) {<br/>      throw new ForbiddenException();<br/>    }<br/>    return document;<br/>  }<br/>}</span></pre><p id="f20d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，上面是一个虚构的例子，假设只有附件文件的所有者才能访问它。</p><p id="ce2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了进一步降低风险，我们还可以使用难以预测的随机值作为记录id。这有助于防止攻击者猜测或枚举记录id。下面是一个使用<code class="fe ny nz oa np b">uuid </code>模块为文档id生成随机唯一值的例子。</p><pre class="kj kk kl km gt no np nq bn nr ns bi"><span id="4c6f" class="nt mr it np b be nu nv l nw nx">import { v4 as uuid } from 'uuid';<br/>const document = {<br/>  id: uuid(),<br/>  ownerId: currentUser.id,<br/></span></pre><p id="71cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最佳实践是确保在您的NestJS应用程序中使用基于角色的授权<a class="ae lu" href="https://docs.nestjs.com/guards" rel="noopener ugc nofollow" target="_blank">保护</a>来保护服务器端功能。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="164a" class="mq mr it bd ms mt mu dn mv mw mx dp my lh mz na nb ll nc nd ne lp nf ng nh ni bi translated">最后的想法</h2><p id="f2b0" class="pw-post-body-paragraph ky kz it la b lb nj ju ld le nk jx lg lh nl lj lk ll nm ln lo lp nn lr ls lt im bi translated">人们普遍认为安全性是软件开发周期中的最后一步，无论是以渗透测试的形式还是通过使用静态扫描工具。然而，这种方法是不够的。</p><p id="4a30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，安全性应该集成到开发过程的每一步，从设计到编码和测试。安全考虑应该是软件应用程序规划和开发的关键部分，而不是事后的想法。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="b904" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们讨论了几种可能影响NestJS应用程序的常见安全风险，还有许多其他的需要考虑。我希望这篇文章对你构建一个安全且有弹性的应用有所帮助。</p></div></div>    
</body>
</html>