<html>
<head>
<title>How to build a rich Chrome extension quickly with Create React App and Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Create React App和Redux快速构建富Chrome扩展</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-rich-chrome-extension-quickly-with-create-react-app-and-redux-d9b64cf64832?source=collection_archive---------2-----------------------#2020-08-13">https://levelup.gitconnected.com/how-to-build-a-rich-chrome-extension-quickly-with-create-react-app-and-redux-d9b64cf64832?source=collection_archive---------2-----------------------#2020-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/67e9c77deefe541bf5c73a3ff93aa0d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*02q6Cpoa_tEHa2FqjEZqMA.gif"/></div></div></figure><p id="6c0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本教程中，你将学习如何使用Create React App和Redux以一种方便且(相对)快速的方式构建一个具有丰富UI的成熟Chrome扩展。它假设了<a class="ae kz" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae kz" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>以及<a class="ae kz" href="https://create-react-app.dev/docs/supported-browsers-features#supported-language-features" rel="noopener ugc nofollow" target="_blank"> ES 6+语法</a>的基础知识。</p><h1 id="93f1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">规格</h1><p id="8bde" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在本教程中，我们将构建一个扩展，通过颜色和一些可选的样式来标记(突出显示)页面上的特定关键字。它将使用所有可能的扩展组件(背景和内容脚本、弹出页面和其他UI元素)以及一些最常用的Chrome APIs。</p><p id="4e58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">提到的<em class="md">关键字</em>将在扩展之外指定——在某个远程web服务器上，该服务器通过API提供带有某种认证的数据。该扩展将允许用户登录到这个远程服务器，并获取与他或她的帐户相关的关键字(以及公共名称)，这些关键字必须显示在适当的UI块中。一旦关键字被加载，用户应该可以选择通过打开相应UI块中的某个开关来标记它们在活动页面(选项卡)上的出现。当关键字的出现被标记时，扩展应该在相应的UI块中显示每个关键字的出现计数。</p><p id="299b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了缩小扩展的范围，让这样的“标记”操作(以及下面描述的“取消标记”)只应用于特定的站点，让它们成为StackOverflow/StackExchange网络站点。然后，如果“标记”开关被打开并且活动标签被改变，扩展应该自动标记关键字在新页面上的出现，而无需用户交互。当开关关闭时，扩展应该“取消标记”关键字，即放弃由最后的“标记”操作在页面上做出的改变，如果有的话，并且这必须在所有打开的标签上完成，而不仅仅是活动的标签。用户必须能够通过弹出页面访问所描述的功能。</p><p id="89c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该扩展还将通过浏览器工具栏中的一些专用图标和徽章来指示其当前状态。工具栏图标将指示用户是登录还是注销。用户身份验证的这些状态必须由两个独立的图像来表示。工具栏徽章将显示关键字在活动页面上出现的总次数(如果有)。只有当用户登录并且“标记”开关打开时，它才必须显示(在工具栏图标的顶部)。</p><p id="333c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，该扩展将允许用户自定义关键字搜索和标记风格的专用设置(选项)页面可通过提到的弹出页面访问。关键字搜索必须由两个参数定制:全词匹配和大小写匹配。关键字标记样式将包括:背景和前景颜色以及可选的大胆和下划线。</p><figure class="mf mg mh mi gt ju gh gi paragraph-image"><div class="gh gi me"><img src="../Images/b9c282c8ca465e4c85249996cadb0391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*pe5Mc0i7WBhIG-SeMSZUrg.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">设置页面外观</figcaption></figure><p id="88d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们扩展的规格。我知道，看起来做作，毫无意义)。人们可能希望这个扩展做更多(真正)有用的事情，比如按标签/用户过滤内容等。但这种扩展将被绑定到当前网站的布局，并停止工作，一旦它得到关键的变化。相比之下，指定的扩展不依赖于布局，可能总是适用于任何站点。因此，不必维护它)。</p><h1 id="7089" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">必备设置</h1><p id="1247" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><strong class="kd iu"> <em class="md">注意</em> </strong>:下面的说明假设您的本地机器上安装了带有NPM的Node v8.10+。</p><h2 id="c6b8" class="mn lb it bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated">创建React应用</h2><p id="a40e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">首先，我们必须<a class="ae kz" href="https://create-react-app.dev/docs/getting-started/#creating-an-app" rel="noopener ugc nofollow" target="_blank">创建</a>一个新的Create React App项目，我们将其命名为<code class="fe mz na nb nc b">my-ext</code>，并应用自定义模板<code class="fe mz na nb nc b"><a class="ae kz" href="https://www.npmjs.com/package/cra-template-complex-browserext" rel="noopener ugc nofollow" target="_blank">complex-browserext</a></code>。这可以通过以下命令来完成:</p><pre class="mf mg mh mi gt nd nc ne nf aw ng bi"><span id="565a" class="mn lb it nc b gy nh ni l nj nk">npx create-react-app my-ext --template complex-browserext</span></pre><p id="e8b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">安装后，我们的项目应该具有以下文件夹结构:</p><pre class="mf mg mh mi gt nd nc ne nf aw ng bi"><span id="55d7" class="mn lb it nc b gy nh ni l nj nk">my-ext/<br/>  README.md<br/>  package.json<br/>  public/<br/>    index.html<br/>    options.html<br/>    manifest.json<br/>  src/<br/>    background.js<br/>    content.js<br/>    index.js<br/>    options.js<br/>    views/<br/>      Popup/<br/>        App.css<br/>        App.js<br/>        App.test.js<br/>      Options/<br/>        App.css<br/>        App.js<br/>        App.test.js</span></pre><p id="d3ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">public/index.html</code>和<code class="fe mz na nb nc b">public/options.html</code>文件分别包含弹出和设置(选项)页面的HTML模板，而<code class="fe mz na nb nc b">src/index.js</code>和<code class="fe mz na nb nc b">src/options.js</code>文件代表各自的JS入口点。<code class="fe mz na nb nc b">src/background.js</code>和<code class="fe mz na nb nc b">src/content.js</code>文件分别代表后台和内容脚本的入口点。所有这些路径/文件名都是在Create React App config中硬编码的，因此不能更改。</p><p id="eb3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/views/Popup</code>和<code class="fe mz na nb nc b">src/views/Options</code>文件夹应该分别保存弹出页面和设置页面的React组件和CSS样式。创建React应用程序已经为弹出页面和设置页面创建了React组件及其CSS样式的样板文件。这些文件夹里默认还有Create React App创建的测试文件<code class="fe mz na nb nc b">*.test.js</code>。由于编写单元测试超出了本教程的范围，我们可以删除所有的测试文件。</p><h2 id="51f3" class="mn lb it bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated">其他必要条件</h2><p id="67ff" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">除了创建React应用程序设置，我们还需要在我们的项目中安装一些库/包。首先，如题所示，我们需要<a class="ae kz" href="https://www.github.com/reduxjs/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>以及它与React的联系——<a class="ae kz" href="https://github.com/reduxjs/react-redux" rel="noopener ugc nofollow" target="_blank">React Redux</a>。此外，由于Redux不应该在复杂的Chrome扩展中工作(比如我们的扩展)，我们需要一种方法来使它适应我们的环境。为此，我们将使用<a class="ae kz" href="https://github.com/hindmost/reduxed-chrome-storage" rel="noopener ugc nofollow" target="_blank">redux Chrome Storage</a>库。最后，我们需要一些UI设计的框架，这样我们就不必从头开始构建扩展的UI。我们将使用语义UI，或者更准确地说是它的React集成— <a class="ae kz" href="https://github.com/Semantic-Org/Semantic-UI-React" rel="noopener ugc nofollow" target="_blank">语义UI React </a>，以及它的<a class="ae kz" href="https://github.com/Semantic-Org/Semantic-UI-CSS" rel="noopener ugc nofollow" target="_blank">默认CSS主题</a>。</p><p id="f74b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是在一行中安装这些软件包的命令:</p><pre class="mf mg mh mi gt nd nc ne nf aw ng bi"><span id="abb6" class="mn lb it nc b gy nh ni l nj nk">npm install redux react-redux reduxed-chrome-storage semantic-ui-react semantic-ui-css</span></pre><h1 id="7a50" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">显示</h1><p id="4d2b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">每个扩展都以其清单<a class="ae kz" href="https://developer.chrome.com/extensions/extensions/manifest" rel="noopener ugc nofollow" target="_blank">开始。Create React App已经为我们创建了一个清单文件:<code class="fe mz na nb nc b">public/manifest.json</code>。但是它只能满足扩展样板的最低需求。由于我们的扩展不仅仅是一个样板文件，我们需要在清单中进行一些添加/修改。</a></p><p id="aece" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们必须为我们的扩展声明权限。它将使用<code class="fe mz na nb nc b"><a class="ae kz" href="https://developer.chrome.com/extensions/storage" rel="noopener ugc nofollow" target="_blank">chrome.storage</a></code> API来存储/管理状态，使用<code class="fe mz na nb nc b"><a class="ae kz" href="https://developer.chrome.com/extensions/tabs" rel="noopener ugc nofollow" target="_blank">chrome.tabs</a></code> API来显示工具栏图标和徽章。为了使用<code class="fe mz na nb nc b">chrome.storage</code>，我们需要<code class="fe mz na nb nc b">storage</code>的许可。在我们的例子中，使用<code class="fe mz na nb nc b">chrome.tabs</code> API不需要任何许可(因为我们不需要访问标签url和其他敏感数据)。所以我们只需要在清单中声明<code class="fe mz na nb nc b">storage</code>权限。</p><p id="cddb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我们的扩展不会使用<code class="fe mz na nb nc b"><a class="ae kz" href="https://developer.chrome.com/extensions/webRequest" rel="noopener ugc nofollow" target="_blank">webRequest</a></code> API，我们必须声明(注册)我们的后台脚本为非持久的。虽然这不是一个要求，但是官方文件强烈建议这样做<a class="ae kz" href="https://developer.chrome.com/extensions/background_pages" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3204" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们的扩展应该只对StackOverflow/StackExchange站点有效，所以我们必须在<code class="fe mz na nb nc b">“content_scripts”</code>字段中为已经存在的(由Create React App准备的)条目指定适当的<a class="ae kz" href="https://developer.chrome.com/extensions/content_scripts#declaratively" rel="noopener ugc nofollow" target="_blank">匹配模式</a>。</p><p id="cc86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，我们必须指定扩展的图标以及默认的工具栏图标。扩展的图标代表扩展本身，例如显示在扩展管理页面中。当扩展不能控制它的外观时，默认工具栏图标默认显示在浏览器的工具栏中。</p><p id="66ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如规范所建议的，我们扩展中的工具栏图标将显示对应于“注销”和“登录”状态的两个图像之一。我们可以使用第一个(“注销”)作为默认的工具栏图标，第二个作为扩展的图标。所以最终我们只需要两张图片。然而，我们必须为扩展的图标和默认工具栏图标提供每个图像的多种尺寸变量。<a class="ae kz" href="https://developer.chrome.com/extensions/manifest/icons" rel="noopener ugc nofollow" target="_blank">扩展图标</a>的尺寸变量登记在清单的<code class="fe mz na nb nc b">“icons”</code>字段下。<a class="ae kz" href="https://developer.chrome.com/extensions/user_interface#icons" rel="noopener ugc nofollow" target="_blank">默认工具栏图标</a>的尺寸变量注册在清单中<code class="fe mz na nb nc b">”browser_action”</code>或<code class="fe mz na nb nc b">”page_action”</code>字段下的<code class="fe mz na nb nc b">“default_icon”</code>属性中。因为我们的扩展应该也有一个工具栏徽章，我们将使用<code class="fe mz na nb nc b">”browser_action”</code>字段。官方文档建议为扩展的图标提供至少16x16、32x32、48x48和128x128的尺寸，为默认工具栏图标提供至少16x16和32x32的尺寸。图标图像的设计超出了本教程的范围。所以这里我只参考自己做的一套现成的图片:<code class="fe mz na nb nc b">icon-outlined-16.png</code>、<code class="fe mz na nb nc b">icon-outlined-32.png</code>、<code class="fe mz na nb nc b">icon-filled-16.png</code>、<code class="fe mz na nb nc b">icon-filled-32.png</code>、<code class="fe mz na nb nc b">icon-filled-48.png</code>、<code class="fe mz na nb nc b">icon-filled-128.png</code>。前两个代表“注销”状态，将用于默认的工具栏图标，剩下的代表“登录”状态，用于扩展的图标。</p><p id="3c92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们需要指定扩展的名称(让它成为“关键字标记”)以及对它的一些描述。</p><p id="0dd0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是生成的清单文件:</p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="98c7" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">API(模拟)</h1><p id="c1d9" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">正如规范所建议的，扩展将向远程API发出HTTP请求，即两种类型的请求:身份验证(登录)和获取与登录用户帐户相关联的名称和关键字。让第一个(身份验证)请求接收带有用户名/密码参数的JSON，并返回JSON，其中<code class="fe mz na nb nc b">“token”</code>字段设置为某个令牌字符串，布尔<code class="fe mz na nb nc b">“ok”</code>字段设置为<code class="fe mz na nb nc b">true</code> —如果成功(例如<code class="fe mz na nb nc b">{“ok”: true, “token”: “token”}</code>)，如果失败— JSON的<code class="fe mz na nb nc b">“ok”</code>字段设置为<code class="fe mz na nb nc b">false</code>，而<code class="fe mz na nb nc b">“message”</code>字段设置为某个消息文本(例如<code class="fe mz na nb nc b">{“ok”: false, “message”: “message”}</code>)。并让第二个(fetch)请求接收认证令牌作为参数，并返回JSON，其中将<code class="fe mz na nb nc b">“ok”</code>字段设置为<code class="fe mz na nb nc b">true</code>并将包含所请求的名称和关键字的<code class="fe mz na nb nc b">“data”</code>字段作为子字段(例如<code class="fe mz na nb nc b">{ “ok”: true, “data”: { “name”: “name”, “keywords”: “keywords”} }</code> ) —在成功的情况下，以及在失败的情况下—与失败的认证请求中相同的JSON。</p><p id="1ea7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">API后端开发超出了本教程的范围。所以这里我们将使用一个API的模拟——一组模拟API工作的函数。我们的API mock将有两个对应于上述API请求的函数:<code class="fe mz na nb nc b">auth</code>和<code class="fe mz na nb nc b">fetchProfile</code>。下面是它们使用Promises、<code class="fe mz na nb nc b">setTimeout</code>和一些预定义的数据数组的实现:</p><p id="265e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/api/index.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7076" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="md">注</em> </strong>:以上代码仅用于原型制作或调试/测试目的。不要在生产中使用这样的代码！</p><h1 id="692c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">状态管理</h1><p id="7d5e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们的扩展的状态必须使用Redux来管理。但是在处理Redux之前，让我们先定义在状态中存储什么数据。正如规范所建议的，我们需要将以下数据(属性)分为三类:</p><ol class=""><li id="cd25" class="nn no it kd b ke kf ki kj km np kq nq ku nr ky ns nt nu nv bi translated">身份验证和帐户相关数据:身份验证令牌和帐户的名称和关键字。让我们命名各自的状态属性<code class="fe mz na nb nc b">token</code>、<code class="fe mz na nb nc b">name</code>和<code class="fe mz na nb nc b">keywords</code>。<code class="fe mz na nb nc b">token</code>必须用于API请求，同时用作“已登录”布尔标志:当它被设置为某个字符串值时，表示“已登录”状态，否则，如果它被设置为假值，则表示“已注销”状态。</li><li id="ef71" class="nn no it kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated">标记状态数据:“标记”开关布尔标志和关键字出现计数数组。让我们将各自的状态属性命名为<code class="fe mz na nb nc b">enabled</code>和<code class="fe mz na nb nc b">stats</code>。<code class="fe mz na nb nc b">stats</code>数组的内容必须显示在弹出页面中适当的UI块中。此外，它将用于显示关键字出现的总次数(可从<code class="fe mz na nb nc b">stats</code>数组中减少)。</li><li id="c175" class="nn no it kd b ke nw ki nx km ny kq nz ku oa ky ns nt nu nv bi translated">设置数据:全字匹配、大小写匹配、标记的背景和前景色以及粗体和下划线。让我们为各自的状态属性命名为<code class="fe mz na nb nc b">matchWhole</code>、<code class="fe mz na nb nc b">matchCase</code>、<code class="fe mz na nb nc b">color</code>、<code class="fe mz na nb nc b">colorBg</code>、<code class="fe mz na nb nc b">bold</code>和<code class="fe mz na nb nc b">underline</code>。</li></ol><p id="cf6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们国家的结构应该是什么样子:</p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="09e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以通过编写动作创建者和减少者来为我们的扩展建立一个Redux存储。</p><h2 id="7b50" class="mn lb it bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated">动作创建者</h2><p id="8b9c" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><code class="fe mz na nb nc b">src/actions/account.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c715" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/actions/marker.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8fec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/actions/settings.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="85fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/actions/index.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="e4ab" class="mn lb it bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated">还原剂</h2><p id="76eb" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><code class="fe mz na nb nc b">src/reducers/account.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d5c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">src/reducers/marker.js</p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="deaf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/reducers/settings.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="aa8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/reducers/index.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="d9b0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置(选项)页面</h1><p id="5be7" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">让我们从设置页面开始制作UI页面，因为它应该比弹出页面简单。</p><p id="4f38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Create React App已经为我们的设置(选项)页面创建了必要的样板文件:<code class="fe mz na nb nc b">src/options.js</code> (JS入口点)<code class="fe mz na nb nc b">src/views/Options/App.js</code>(根React组件)和<code class="fe mz na nb nc b">src/views/Options/App.css</code> (CSS样式)。</p><p id="a0b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们必须修改根React组件及其CSS样式，使它们适合我们的设计。我们将为设置页面使用以下语义UI组件:<code class="fe mz na nb nc b">Form</code>、<code class="fe mz na nb nc b">Checkbox</code>、<code class="fe mz na nb nc b">Button</code>和<code class="fe mz na nb nc b">Divider</code>。我们还必须将这个React组件与适当的状态属性和Redux动作创建者连接起来。我们需要<code class="fe mz na nb nc b">settings</code>类别的所有属性以及所有与设置相关的动作创建者:<code class="fe mz na nb nc b">setMatchWhole</code>、<code class="fe mz na nb nc b">setMatchCase</code>、<code class="fe mz na nb nc b">setColor</code>、<code class="fe mz na nb nc b">setColorBg</code>、<code class="fe mz na nb nc b">setBold</code>、<code class="fe mz na nb nc b">setUnderline</code>。</p><p id="7ce8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是生成的根React组件及其CSS文件:</p><p id="5c8b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/views/Options/App.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7fcb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/views/Options/App.css</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1dea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们必须为设置页面设置入口点。由Create React App创建的样板文件<code class="fe mz na nb nc b">src/options.js</code>，仅将React渲染设置为DOM。除此之外，我们必须使用提到的Reduxed Chrome存储库获得Redux store的工作本地实例。我们将使用它的<a class="ae kz" href="https://github.com/hindmost/reduxed-chrome-storage#advanced-way-asyncawait" rel="noopener ugc nofollow" target="_blank">异步/等待用法</a>语法。然后，我们必须通过用React Redux提供的特殊<code class="fe mz na nb nc b">&lt;Provider&gt;</code>组件包装React组件，使实例化的Redux存储对上述React组件可用/可见。此外，我们必须导入语义UI的默认CSS主题。</p><p id="c639" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是设置页面的结果入口点:</p><p id="24c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/options.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="cf94" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">弹出页面</h1><p id="f34d" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">与设置页面类似，首先我们必须对根React组件及其CSS样式进行更改，以使它们适合弹出页面的设计。与设置页面不同，弹出页面应该使用更复杂的条件渲染。具体来说，我们必须根据用户是否经过身份验证(登录)来呈现不同的视图。这意味着除了根React组件之外，我们还需要两个子组件，分别与经过身份验证和未经身份验证的用户相关联，让我们分别将它们命名为<code class="fe mz na nb nc b">Authed</code>和<code class="fe mz na nb nc b">Unauthed</code>。</p><p id="742f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">弹出页面的根React组件将只使用一个语义UI组件— <code class="fe mz na nb nc b">Header</code>。此外，我们必须将这个根React组件与适当的状态属性和Redux动作创建者连接起来。我们需要<code class="fe mz na nb nc b">account</code>和<code class="fe mz na nb nc b">marker</code>类别的所有属性，以及所有与账户和标记相关的动作创建者:<code class="fe mz na nb nc b">accountAuth</code>、<code class="fe mz na nb nc b">accountProfile</code>、<code class="fe mz na nb nc b">accountLogout</code>、<code class="fe mz na nb nc b">setEnabled</code>、<code class="fe mz na nb nc b">setStats</code>。</p><p id="8d08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是生成的根React组件及其CSS文件:</p><p id="fb30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/views/Popup/App.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="03ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/views/Popup/App.css</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="24f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，除了根和子组件的样式，我们还为<code class="fe mz na nb nc b">&lt;body&gt;</code>元素设置了固定的大小。这是必要的，因为我们的弹出窗口将有不同高度的动态内容。</p><p id="2034" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们必须指定所需的子组件— <code class="fe mz na nb nc b">Authed</code>和<code class="fe mz na nb nc b">Unauthed</code>。</p><h2 id="37ff" class="mn lb it bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated">未经验证的用户视图</h2><p id="de26" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">先说<code class="fe mz na nb nc b">Unauthed</code>的成分。它将显示一个带有<code class="fe mz na nb nc b">username</code>和<code class="fe mz na nb nc b">password</code>字段的登录表单。我们将只在其中使用<code class="fe mz na nb nc b">Form</code>和<code class="fe mz na nb nc b">Message </code>语义UI组件。当提交表单时，它应该用提供的<code class="fe mz na nb nc b">username</code>和<code class="fe mz na nb nc b">password</code>调用上面的<code class="fe mz na nb nc b">auth</code> API函数。在<code class="fe mz na nb nc b">auth()</code>成功后，它应该分派<code class="fe mz na nb nc b">accountAuth</code>动作，然后调用<code class="fe mz na nb nc b">fetchProfile</code> API函数，请求与帐户相关的名称和关键字。在<code class="fe mz na nb nc b">fetchProfile</code>成功后，它应该分派<code class="fe mz na nb nc b">accountProfile</code>动作，传递提取的数据。除了正面结果之外，我们还必须通过显示返回的错误消息来处理请求失败，以及在API请求正在进行时显示一些负载指示器。这意味着我们需要在某个地方存储与当前请求相关的错误消息和加载状态标志。为此，我们将使用一个本地反应状态。错误信息将显示在表单底部的<code class="fe mz na nb nc b">Message</code>组件内，并通过<code class="fe mz na nb nc b">Form</code>组件的专用属性显示加载指示器。</p><p id="151c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是产生的<code class="fe mz na nb nc b">Unauthed</code>组件:</p><p id="0583" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/views/Popup/Unauthed.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="f7a3" class="mn lb it bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated">经过验证的用户视图</h2><p id="5666" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">组件将显示与帐户相关的名称(作为标题)和关键字(作为标签列表)，以及顶部的三个按钮——“标记”开关(作为中间的复选框),“注销”动作调用程序和设置页面打开程序。我们将在该组件中使用以下语义UI组件:<code class="fe mz na nb nc b">Container</code>、<code class="fe mz na nb nc b">Segment</code>、<code class="fe mz na nb nc b">Button</code>、<code class="fe mz na nb nc b">Checkbox</code>、<code class="fe mz na nb nc b">Header</code>、<code class="fe mz na nb nc b">Icon</code>、<code class="fe mz na nb nc b">Label</code>、<code class="fe mz na nb nc b">Placeholder</code>。当“标记”开关状态改变时，应调度<code class="fe mz na nb nc b">setEnabled</code>动作，并传递相应的布尔值；然后，如果“标记”开关状态为off，则该状态的<code class="fe mz na nb nc b">stats</code>属性应通过调度<code class="fe mz na nb nc b">setStats</code>动作并传递<code class="fe mz na nb nc b">false</code>来重置。当点击“退出”按钮时，应调度<code class="fe mz na nb nc b">accountLogout</code>动作。而当点击“设置”按钮时，我们要调用专用的Chrome API方法— <a class="ae kz" href="https://developer.chrome.com/extensions/runtime#method-openOptionsPage" rel="noopener ugc nofollow" target="_blank"> openOptionsPage </a>。</p><p id="adad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以下面是产生的<code class="fe mz na nb nc b">Authed</code>组件:</p><p id="2a46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/views/Popup/Authed.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="91d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们只需要设置弹出页面的入口点。我们可以使用已经创建的设置页面的入口点作为模板。我们唯一需要改变的是到根React组件的路径(<code class="fe mz na nb nc b">App</code>)。</p><p id="2794" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是弹出页面的结果入口点:</p><p id="98f6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/index.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="7bc0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">内容脚本和标记/取消标记呈现</h1><p id="2b81" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们扩展中的内容脚本将直接处理网页，它的职责将包括在必要时在活动页面(tab)上标记和取消标记特定于用户的关键字。我们已经有了Create React App为我们创建的内容脚本文件的样板文件:<code class="fe mz na nb nc b">src/content.js</code>。目前它是空的，我们必须在这里添加我们的自定义代码。</p><p id="a2be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“标记”和“取消标记”操作的实现意味着直接的DOM操作，这超出了本教程的范围。所以我在这里发布了一个现成的<code class="fe mz na nb nc b">mark</code>和<code class="fe mz na nb nc b">unmark</code>函数的实现，放在一个单独的文件<code class="fe mz na nb nc b">src/mark/index.js</code>中。它使用的是<code class="fe mz na nb nc b">NodeIterator</code>接口，所以如果你对细节感兴趣，可以查看相应的<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/NodeIterator" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="b84b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/mark/index.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0b7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以看出，<code class="fe mz na nb nc b">mark()</code>函数接收<code class="fe mz na nb nc b">keywords</code>、<code class="fe mz na nb nc b">matchWhole</code>、<code class="fe mz na nb nc b">matchCase</code>和<code class="fe mz na nb nc b">style</code>参数(在一个对象内)，如果成功则返回每个关键字出现次数的数组，否则返回<code class="fe mz na nb nc b">false</code>。<code class="fe mz na nb nc b">unmark()</code>不接收也不返回任何东西。这些函数必须在我们的内容脚本中由某个函数使用，我们称之为<code class="fe mz na nb nc b">render</code>，它将根据扩展的当前状态应用标记和取消标记操作。它假设我们必须获得Redux store的本地实例。我们可以用和上面UI页面一样的方法来做。</p><p id="3283" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦Redux store实例可用，我们必须调用<code class="fe mz na nb nc b">render</code>函数，以便在页面加载时应用标记"/"取消标记"操作(如果有)。此外，每当状态改变时，必须调用<code class="fe mz na nb nc b">render</code>函数。所以我们必须添加一个调用<code class="fe mz na nb nc b">render()</code>的状态改变监听器。然而，如果给定的页面/标签(内容脚本在其中运行)现在是非活动的(隐藏的),则在状态改变时应用标记“/”取消标记操作是不必要的/不想要的。这意味着<code class="fe mz na nb nc b">render()</code>不仅要检查当前状态，还要检查给定的页面/选项卡是否处于活动状态。内容脚本可以通过访问特殊的<code class="fe mz na nb nc b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/hidden" rel="noopener ugc nofollow" target="_blank">document.hidden</a></code>属性来检查这种情况。由于我们的内容脚本将有两次对<code class="fe mz na nb nc b">render()</code>的调用，所以最好在<code class="fe mz na nb nc b">render()</code>之外评估这个条件，并将其结果作为参数传递。</p><p id="18a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们的内容脚本应该是什么样子:</p><p id="cfee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/content.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="75d5" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">背景脚本和对工具栏图标和徽章的控制</h1><p id="9d4c" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们扩展中的背景脚本将控制工具栏图标和徽章的外观。我们将使用<code class="fe mz na nb nc b">chrome.browserAction</code> API方法— <code class="fe mz na nb nc b"><a class="ae kz" href="https://developer.chrome.com/extensions/browserAction#method-setIcon" rel="noopener ugc nofollow" target="_blank">setIcon</a></code>和<code class="fe mz na nb nc b"><a class="ae kz" href="https://developer.chrome.com/extensions/browserAction#method-setBadgeText" rel="noopener ugc nofollow" target="_blank">setBadgeText</a></code>分别设置工具栏图标和徽章。然而，为了控制它们的外观，我们需要知道扩展的当前状态。它仍然假设我们必须获得Redux store的本地实例。这可以通过与上面的内容脚本和UI页面类似的方式来完成。一旦Redux store实例可用，我们必须添加一个状态更改监听器，以便在状态更改时调用某个函数。这个函数，姑且称之为<code class="fe mz na nb nc b">displayIcon</code>，将根据扩展的当前状态显示工具栏图标和徽章。状态的<code class="fe mz na nb nc b">account.token</code>属性将决定两个图像中的哪一个必须显示在工具栏图标中，而<code class="fe mz na nb nc b">marker.stats</code>属性(减少到一个总值)——工具栏徽章中显示的数字。</p><p id="2c83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为这里我们只使用状态的两个属性，所以每当状态改变时调用Chrome API方法是低效的，因为这样的改变可能不会对所需的属性产生影响。所以最好存储上述两个属性的某种唯一标识组合(“hash”)，以便在状态改变时将它们的当前值与这种“hash”的最后存储值进行比较。我们可以像在内容脚本中一样使用一个容器对象(<code class="fe mz na nb nc b">{token:…, stats:…}</code>)来实现这个目的，但是在这种情况下，最好使用一个简单的字符串连接，将<code class="fe mz na nb nc b">account.token</code>和<code class="fe mz na nb nc b">marker.stats</code>的总值用冒号(<code class="fe mz na nb nc b">:</code>)隔开。由于我们的后台脚本是非持久的，所以我们不能将这样的“散列”存储在变量中(因为后者以及所有后台脚本都可能随时从内存中卸载)。所以我们必须将这个“散列”存储在状态中，这意味着我们需要在状态中分配一个额外的属性。姑且称之为<code class="fe mz na nb nc b">iconHash</code>，暂且归入<code class="fe mz na nb nc b">marker</code>范畴。</p><p id="45c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是<code class="fe mz na nb nc b">marker</code>类别中动作创建者和缩减者文件的最终版本。</p><p id="b14a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/actions/marker.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="49a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/reducers/marker.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="91f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">后台脚本中的<code class="fe mz na nb nc b">displayIcon</code>函数将基于<code class="fe mz na nb nc b">account.token</code>和<code class="fe mz na nb nc b">marker.stats</code>属性评估一个哈希，并将其与状态中存储的哈希进行比较，如果它们不相等，它将在状态中存储新的哈希并调用上面的Chrome API方法。</p><p id="570b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为我们的后台脚本是非持久的，所以它的执行没有像持久脚本那样的“启动”点。这意味着我们不能像上面在内容脚本中那样对函数进行“初始”调用。相反，我们必须监听特殊的Chrome API事件— <code class="fe mz na nb nc b"><a class="ae kz" href="https://developer.chrome.com/extensions/runtime#event-onStartup" rel="noopener ugc nofollow" target="_blank">onStartup</a></code>，它在扩展首次启动时触发(在浏览器的会话中)。在它的监听器回调中，我们必须调用我们的<code class="fe mz na nb nc b">displayIcon</code>函数。这个事件似乎也是初始化/重置我们的“图标散列”(通过分派<code class="fe mz na nb nc b">setIconHash</code>动作)，以及重置用户认证会话(通过分派<code class="fe mz na nb nc b">accountLogout</code>动作)的适当时刻(地点)。</p><p id="4009" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对非持久后台脚本的另一个限制是，Chrome API事件监听器只能以同步方式注册，即在任何异步上下文之外注册。这意味着我们不能在添加状态改变监听器的同一个上下文(异步函数)中注册<code class="fe mz na nb nc b">onStartup</code>监听器。所以我们必须在顶层注册<code class="fe mz na nb nc b">onStartup</code>监听器。这也意味着我们要么也在顶层移动Redux store实例的声明(并在两个侦听器之间共享它)，要么在<code class="fe mz na nb nc b">onStartup</code>侦听器的回调中使用另一个本地Redux store实例。我推荐使用一种组合的方法，在顶层使用一些共享变量(对于Redux store实例)以及一些帮助函数，我们把它命名为<code class="fe mz na nb nc b">getStore</code>。如果共享变量未设置，此函数应该只实例化一个Redux store，否则它应该提前返回后者的值(这是一个Redux store实例)。这种方法确保Redux store实例在从helper函数返回时可用。</p><p id="85f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们的后台脚本应该是什么样子:</p><p id="f2ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/background.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="c595" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">跟踪选项卡切换并保持工具栏徽章最新</h1><p id="bdf7" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我们的扩建快完成了。至少现在可以构建并运行它而不出错。然而，如果我们尝试检查它的功能，我们可能会注意到工具栏标记并不总是反映活动页面/选项卡上的实际“标记”统计数据:只有当我们直接在相关页面上启用/禁用“标记”时，标记的内容才会更新，然后当我们切换到其他选项卡时，它会保持不变。这种行为显然不符合我们的规范，必须得到解决。解决此问题意味着后台脚本应该跟踪任何选项卡切换，并从新的活动选项卡(更准确地说，是在此选项卡中运行的内容脚本)请求实际的“标记”统计信息(如果“标记”已启用并适用)。</p><p id="fe7b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了跟踪标签切换，我们必须在后台脚本中监听<code class="fe mz na nb nc b"><a class="ae kz" href="https://developer.chrome.com/extensions/tabs#event-onActivated" rel="noopener ugc nofollow" target="_blank">tabs.onActivated</a></code>事件。每当它触发时，如果此时“标记”被启用，后台脚本必须要求活动选项卡的内容脚本用其本地“标记”统计信息(存储在本地<code class="fe mz na nb nc b">stats</code>变量中)更新状态中的<code class="fe mz na nb nc b">stats</code>属性。一旦<code class="fe mz na nb nc b">stats</code>属性将被更新，后台脚本将通过它的状态改变监听器(已经编写好了)获取它的值，并通过<code class="fe mz na nb nc b">displayIcon</code>函数(同样，已经编写好了)将它显示在工具栏标记中。由于当前活动的选项卡可能为空或包含扩展范围之外的页面，因此可能没有相关的内容脚本，后台脚本必须在请求实际的“标记”统计信息之前重置<code class="fe mz na nb nc b">stats</code>属性。</p><p id="2043" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请求“标记”统计意味着向内容脚本发送简单的通知。我们可以通过在那里分配另一个属性并在后台脚本中更改它来再次使用状态。由于我们已经在内容脚本中设置了一个状态更改监听器，它应该能够接收状态中的任何更改，这就是通知它的方式。但关键是所有相关的选项卡都会收到这样的通知，而不仅仅是活动的选项卡(这是我们需要的)。这意味着内容脚本必须验证它的选项卡是预期的目的地，这反过来意味着在内容脚本中要做额外的工作，例如请求关于它的选项卡的信息。</p><p id="4e24" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">IMO为了向特定的选项卡发送通知，最好使用专用的<code class="fe mz na nb nc b">chrome.tabs</code> API方法— <code class="fe mz na nb nc b"><a class="ae kz" href="https://developer.chrome.com/extensions/tabs#method-sendMessage" rel="noopener ugc nofollow" target="_blank">sendMessage</a></code>。它需要两个强制参数:目标选项卡的ID和要发送的消息。标签页的ID可以从<code class="fe mz na nb nc b">onActivated</code>事件回调(其中<code class="fe mz na nb nc b">sendMessage</code>必须被调用)的单个参数中获取，该事件回调是一个在<code class="fe mz na nb nc b">“tabId”</code>键下包含所需ID的对象。关于消息参数，它可以是任何JSON-ifiable对象。由于我们只需要通知destination选项卡，我们可以使用一个简单的单键容器对象，如下所示:<code class="fe mz na nb nc b">{id: ‘tabFocusPass’}</code>。</p><p id="9721" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以后台脚本中的<code class="fe mz na nb nc b">onActivated</code>事件监听器应该首先检查“标记”开关是否打开，如果打开，它应该通过用<code class="fe mz na nb nc b">false</code>值调度<code class="fe mz na nb nc b">setStats</code>动作来重置“标记”统计，然后将上述消息发送到活动选项卡。</p><p id="3a9a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是后台脚本中要做的最后修改:</p><p id="7fda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/background.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f5de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">向选项卡发送消息还假设监听内容脚本中的<code class="fe mz na nb nc b"><a class="ae kz" href="https://developer.chrome.com/extensions/runtime#event-onMessage" rel="noopener ugc nofollow" target="_blank">runtime.onMessage</a></code>事件。每当它触发时，它通过其回调的第一个参数提供接收到的消息。所以在<code class="fe mz na nb nc b">onMessage</code>回调中，我们必须检查第一个参数，以使<code class="fe mz na nb nc b">id</code>具有属性<code class="fe mz na nb nc b">= ‘tabFocusPass’</code>。如果是这样，我们必须通过调用<code class="fe mz na nb nc b">render</code>函数来应用“标记”/“取消标记”操作(如果有的话)，然后调用<code class="fe mz na nb nc b">updateStats</code>函数，该函数应该用本地<code class="fe mz na nb nc b">stats</code>变量的值来更新状态中的<code class="fe mz na nb nc b">stats</code>属性。最后一件事只有在没有“标记”操作的情况下才应该做，否则<code class="fe mz na nb nc b">render()</code>应该调用<code class="fe mz na nb nc b">updateStats()</code>本身。</p><p id="9ae2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是对内容脚本进行的最后修改:</p><p id="4360" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">src/content.js</code></p><figure class="mf mg mh mi gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="5950" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">成就</h1><p id="b528" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">现在我们的扩建终于完成了。您可以通过运行<code class="fe mz na nb nc b">npm run build</code>命令来构建(编译)它。在<code class="fe mz na nb nc b">/build</code>文件夹中的结果已经可以在Chrome浏览器中以<a class="ae kz" href="https://developer.chrome.com/extensions/getstarted" rel="noopener ugc nofollow" target="_blank">开发者模式</a>安装和运行了。</p><p id="259b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://github.com/hindmost/cra-rich-chrome-ext-example" rel="noopener ugc nofollow" target="_blank">源代码库</a>。</p><p id="51fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读。</p><h2 id="b893" class="mn lb it bd lc mo mp dn lg mq mr dp lk km ms mt lo kq mu mv ls ku mw mx lw my bi translated">相关文章:</h2><ul class=""><li id="1f02" class="nn no it kd b ke ly ki lz km ob kq oc ku od ky oe nt nu nv bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/using-redux-in-event-driven-chrome-extensions-problem-solution-30eed1207a42">在事件驱动的Chrome扩展中使用Redux:问题/解决方案</a></li><li id="95b4" class="nn no it kd b ke nw ki nx km ny kq nz ku oa ky oe nt nu nv bi translated"><a class="ae kz" href="https://medium.com/swlh/bootstrapping-complex-chrome-firefox-edge-extensions-with-create-react-app-667be8df35d7" rel="noopener">使用Create React应用引导复杂的Chrome/Firefox/Edge扩展</a></li></ul></div></div>    
</body>
</html>