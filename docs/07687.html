<html>
<head>
<title>Nitpicks from a triggered senior developer in a code review</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一位资深开发人员在代码评审中吹毛求疵</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nitpicks-from-a-triggered-senior-developer-in-a-code-review-8b914211a9d0?source=collection_archive---------5-----------------------#2021-03-05">https://levelup.gitconnected.com/nitpicks-from-a-triggered-senior-developer-in-a-code-review-8b914211a9d0?source=collection_archive---------5-----------------------#2021-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cbf7f3888098a1ac576391957cad7b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SbkgG7gIerSGVC5a.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">礼貌:【https://bit.ly/38cWpbZ】T2</figcaption></figure><p id="7f02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都经历过。对于我们的拉取请求(PRs)，有这样的。</p><p id="35c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">希望</strong>他们安全地通过一个高级开发人员野蛮的眼睛。希望我们不会被一个学究在一些“代码”方面吹毛求疵。<br/> <strong class="kf ir">希望</strong>我们只被任务的功能完整性所评判。<strong class="kf ir">希望</strong>我们的100行差异不会获得超过1-2的评论。</p><p id="8937" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如意算盘终于到此为止。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/700611f3eb48ae62832551464fece425.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*fC_ESj1WC9MvN7vjt-jSJg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">什么？</figcaption></figure><h1 id="aa4c" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">怎么回事？</h1><p id="69bd" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">在这篇文章中，我们试图把重点放在触发高级开发人员进行代码评审的小事情上。虽然这些例子更适合Java，但我尽可能做到语言不可知。我们不会关注语言语义或声纳气味，而是可读性和可维护性的软方面。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="176b" class="lg lh iq bd li lj mq ll lm ln mr lp lq lr ms lt lu lv mt lx ly lz mu mb mc md bi translated">#1:记录公共API</h1><p id="6950" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">小界面。大界面。只有一个实现的接口。抽象类只在一个流、两个流中使用。等等。<strong class="kf ir">没关系。</strong></p><p id="649b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mv">始终记录公共API。</em>这意味着，记录你在界面中展示的行为。用抽象类记录为<code class="fe mw mx my mz b">@Override</code>设计的方法。</p><p id="9c3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">为什么？</strong></p><p id="e630" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有这一点，就无法知道实现应该做什么，以及为什么要这样设计。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/b4fab2982b1742ea715b877eb3fac174.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*BqnuXW1gjF30IX_VUub08w.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">以这个接口为例</figcaption></figure><ul class=""><li id="6f01" class="nb nc iq kf b kg kh kk kl ko nd ks ne kw nf la ng nh ni nj bi translated">通过阅读这个接口，我假设它是一个纯函数，因为在throws子句中没有声明异常。这是否意味着如果出现异常，客户端应该处理/接受异常？什么样的例外。</li><li id="6eab" class="nb nc iq kf b kg nk kk nl ko nm ks nn kw no la ng nh ni nj bi translated">实现应该是什么样的？他们可以假设/不假设什么？什么都是未定义的行为？</li><li id="50e2" class="nb nc iq kf b kg nk kk nl ko nm ks nn kw no la ng nh ni nj bi translated"><code class="fe mw mx my mz b">enrich()</code>绝对可能是一个有副作用的函数。完全依赖方法签名的客户机将会大有作为。</li></ul><blockquote class="np nq nr"><p id="0efb" class="kd ke mv kf b kg kh ki kj kk kl km kn ns kp kq kr nt kt ku kv nu kx ky kz la ij bi translated">相反，要像下面这样消除歧义。</p></blockquote><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/533faccc0711f4b0043018a82f1c7ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yqfkPS9PE1MFQsf1psHYGw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">清晰、简洁、有记录的行为。</figcaption></figure><blockquote class="np nq nr"><p id="f119" class="kd ke mv kf b kg kh ki kj kk kl km kn ns kp kq kr nt kt ku kv nu kx ky kz la ij bi translated">公共API经常被使用。接口将来会被你的同行扩展。不要这样对他们。不要让这种行为成为一个谜。</p></blockquote></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="355b" class="lg lh iq bd li lj mq ll lm ln mr lp lq lr ms lt lu lv mt lx ly lz mu mb mc md bi translated">#2:方法签名中的参数排序</h1><p id="9464" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">只要我的方法收到了完成工作所需的所有参数，我就没事了，对吗？不总是这样。</p><p id="3dee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不是在讨论在方法调用中传递少量的参数。那不是新闻。我们说的是<strong class="kf ir">订单</strong>。</p><p id="767e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下面的方法为例。它试图在运行<code class="fe mw mx my mz b">filterFunction</code>之后，使用从<code class="fe mw mx my mz b">keyFunction</code>获得的密钥在<code class="fe mw mx my mz b">collection</code>上创建一个<code class="fe mw mx my mz b">map</code></p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/58b490e90528ef39175b63bd30732204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0lJ1uEXoCpOrkE1sLORZHQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">看看论点的顺序。你注意到什么了吗？</figcaption></figure><p id="cecd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法参数看起来完全是随机的。要获得一个<code class="fe mw mx my mz b">map</code>，必须首先通过一个<code class="fe mw mx my mz b">filter</code>函数。这是为什么呢？</p><p id="2cf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于空过滤器，使用该API的客户端将具有以下工作流<strong class="kf ir">。</strong></p><pre class="lc ld le lf gt nx mz ny nz aw oa bi"><span id="e75a" class="ob lh iq mz b gy oc od l oe of">collection c;<br/>keyFunction k;</span><span id="9b0b" class="ob lh iq mz b gy og od l oe of">class.identityMap(..? should I pass null? I don't have a filter...)</span></pre><p id="c074" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，您应该已经意识到，通过传递一个<code class="fe mw mx my mz b">collection</code>(数据源)、一个分组函数<code class="fe mw mx my mz b">(keyFunction)</code>，然后是过滤器<code class="fe mw mx my mz b">(filterFunction)</code>，可以最直观地调用该方法</p><blockquote class="np nq nr"><p id="705d" class="kd ke mv kf b kg kh ki kj kk kl km kn ns kp kq kr nt kt ku kv nu kx ky kz la ij bi translated">所以，选这个。</p></blockquote><p id="e60b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先传递<code class="fe mw mx my mz b">collection</code>，然后传递对集合进行操作的<strong class="kf ir">必要参数</strong>。像这样的小事可以提高可读性</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/dd3436ed2ee2efe89ed161190c79aba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLYotGf3BbcZALnc3qQVIA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">可读性源于这样一个事实，即键函数和过滤器“作用于”首先传递的集合</figcaption></figure><p id="1b3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">为什么？</strong></p><ul class=""><li id="ade7" class="nb nc iq kf b kg kh kk kl ko nd ks ne kw nf la ng nh ni nj bi translated">遵循这一点，可以得到可读性更好的API，使用起来也很愉快。对于API的消费者来说，调用参数以直观的顺序进行也很容易。</li><li id="5327" class="nb nc iq kf b kg nk kk nl ko nm ks nn kw no la ng nh ni nj bi translated">违反这一点，每个开发人员都必须承担一个小的缓存缺失(在订单上)。相反，争论应该像溪流汇入河流一样流动。</li></ul><blockquote class="np nq nr"><p id="83ba" class="kd ke mv kf b kg kh ki kj kk kl km kn ns kp kq kr nt kt ku kv nu kx ky kz la ij bi translated">发现这种微妙之处需要经验。对于未经训练的人来说，顺序没有什么不同。为了体现这一点，请考虑客户端的API使用情况。</p></blockquote></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="8b7a" class="lg lh iq bd li lj mq ll lm ln mr lp lq lr ms lt lu lv mt lx ly lz mu mb mc md bi translated">#3根据减少认知负荷的罕见性对注释进行排序</h1><p id="2a28" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">到目前为止，这是我最喜欢的挑剔之一。我也很惊讶有多少开发人员完全忽略了这一点，或者没有意识到它的严重性。</p><p id="7e08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mv">成员上的稀有注释应该比普通注释更紧密。</em> <br/>如果一个注释向它所隶属的成员传达了一个特殊的含义，那么这个注释就是<code class="fe mw mx my mz b"><strong class="kf ir">rare</strong></code> <strong class="kf ir"> </strong>。如果同一个注释被附加到多个成员上，根据定义，这种情况很少发生。</p><p id="a5fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑一个API，它需要一个非空的整数列表，但是它们必须在范围内，并且数字必须是质数。在一个<code class="fe mw mx my mz b">JSR-303</code>规范中，我们会像这样注释成员。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/cb394380f51995eb38701d5ae1026493.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*8Dl5Bv0l_dp6OqxlzoezVg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这个管用。但是..？</figcaption></figure><p id="8551" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">你是否发现了一点小问题？</strong>如果是，恭喜你。</p><p id="a54f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mw mx my mz b">NotNull</code>和<code class="fe mw mx my mz b">Getter</code>常见。但是有一些关于<code class="fe mw mx my mz b">PrimeNumbersOnly</code>和<code class="fe mw mx my mz b">Range</code>验证的问题。将一个数保持在一个范围内比确保它是素数(自定义代码)更容易检查。</p><p id="e547" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，根据定义，<code class="fe mw mx my mz b">PrimeNumbersOnly</code>是比<code class="fe mw mx my mz b">Range</code>更稀有的注释，需要更接近成员。<code class="fe mw mx my mz b">NotNull</code>比<code class="fe mw mx my mz b">Getter</code>更稀有。</p><blockquote class="np nq nr"><p id="07c4" class="kd ke mv kf b kg kh ki kj kk kl km kn ns kp kq kr nt kt ku kv nu kx ky kz la ij bi translated">相反，看下面，</p></blockquote><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/13a8298e5fc9a0524eb12a598e890699.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*UhE_01fabmgzlmFXTE7p3g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">注释的正确排序。</figcaption></figure><p id="ee94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我阅读上面的代码时，我的思维会自动转换，将注意力更多地放在服务于业务用例的重要注释上。</p><p id="ef7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">为什么？</strong></p><ul class=""><li id="16a8" class="nb nc iq kf b kg kh kk kl ko nd ks ne kw nf la ng nh ni nj bi translated">这是一个惯例，你可以遵循它来确保你的代码库对开发者来说更好阅读。通过练习，你会自动开始关注最重要的注释。</li><li id="e093" class="nb nc iq kf b kg nk kk nl ko nm ks nn kw no la ng nh ni nj bi translated">更容易阅读代码库和检测拉请求中的差异。你的眼睛会自动优先考虑较罕见的注释中的变化。</li></ul></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="d3c8" class="lg lh iq bd li lj mq ll lm ln mr lp lq lr ms lt lu lv mt lx ly lz mu mb mc md bi translated">#4正确记录异常。记录假设。日志上下文</h1><p id="542c" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">违反这一点也是司空见惯的。<em class="mv">这是围绕伐木。</em></p><ul class=""><li id="64a1" class="nb nc iq kf b kg kh kk kl ko nd ks ne kw nf la ng nh ni nj bi translated">考虑围绕原始上下文记录额外的有用信息，以帮助查明问题。这有助于凌晨3点的随叫随到。比如，首先传递的是什么输入(如果为空)。这也有助于更容易地复习。</li></ul><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/462ea07ea6ef7988f0b8e9b9b1f2872f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGjU_xUMI-tNzLGoF7xWnQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我怎么知道没有注册解析器的“实体类型”是什么？</figcaption></figure><ul class=""><li id="4b2a" class="nb nc iq kf b kg kh kk kl ko nd ks ne kw nf la ng nh ni nj bi translated">另一个是关于对<code class="fe mw mx my mz b">log.error</code>的无意使用，开发人员没有将堆栈跟踪信息作为方法参数传递，而是在日志字符串中传递。当日志被触发，但没有堆栈跟踪可以调试时，这种情况就会发生。</li></ul><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/c85dfce464f0229b2221ee5f7924b2c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tDRbIP6SsBCPws__9K4bBA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">这是无意的。但是，一个资深开发者会抓住它。</figcaption></figure><ul class=""><li id="6057" class="nb nc iq kf b kg kh kk kl ko nd ks ne kw nf la ng nh ni nj bi translated"><strong class="kf ir">开发者承担的日志假设。</strong>这有助于调试行为不当的流，其中某个被假定为真的上下文不再成立。考虑一个<code class="fe mw mx my mz b">sessionFactory</code>，它被静默初始化为默认值，没有任何记录。</li></ul><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/587a9d92522cd3a4900adc09ee8423a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJj2L8GUuYNx9qR1KyMtpw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">如果工厂开始生产不当，我们会知道我们在使用“默认”吗</figcaption></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><h1 id="588f" class="lg lh iq bd li lj mq ll lm ln mr lp lq lr ms lt lu lv mt lx ly lz mu mb mc md bi translated">#5添加冗余依赖项</h1><p id="bfec" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">我承认，我对过去的所作所为感到内疚。依赖于<code class="fe mw mx my mz b">javafx</code>库只是为了能够拥有一个<code class="fe mw mx my mz b">Pair&lt;K, V&gt;</code>或一个<code class="fe mw mx my mz b">Tuple&lt;A, B, C&gt;</code>只是为了以后发现<code class="fe mw mx my mz b">javafx</code>类没有包含在OpenJDK中并且在CI上构建失败。</p><p id="2bb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要这样。<strong class="kf ir">推出自己的</strong>。写一个不增加任何不必要依赖的不可变类有多难？</p><pre class="lc ld le lf gt nx mz ny nz aw oa bi"><span id="d22f" class="ob lh iq mz b gy oc od l oe of">@AllArgsConstructor<br/>@Getter<br/>public static class Pair&lt;K, V&gt;{<br/>        private final K key;<br/>        private final V value;<br/>}</span></pre><p id="b866" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NodeJS等同于依赖整个<strong class="kf ir"> Lodash </strong>库来完成<code class="fe mw mx my mz b">_.sum(array)</code></p><p id="73b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除非你确信依赖提供了一个显著的优势，否则不要费心添加它。这是审查期间的一个危险信号。</p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="4cd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章到此为止。上面提到的几点，虽然有些挑剔，但对代码库的健康发展是很重要的。有了经验，你会自动开始喜欢可读性。希望这一块增值。</p></div></div>    
</body>
</html>