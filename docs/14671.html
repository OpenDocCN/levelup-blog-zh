<html>
<head>
<title>Simple Example of a Binary Search Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉查找树的简单例子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simple-example-of-a-binary-search-tree-426c2dfda24?source=collection_archive---------7-----------------------#2022-12-15">https://levelup.gitconnected.com/simple-example-of-a-binary-search-tree-426c2dfda24?source=collection_archive---------7-----------------------#2022-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="ecf5" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">实际Python代码的解释和示例！</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/24963dcc1dd2cb8a20f8f1a15daaf3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9zBBkFBR6Rv_ejikvH9ZA.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">照片由<a class="ae lf" href="https://www.freepik.com/author/benzoix" rel="noopener ugc nofollow" target="_blank"> benzoix </a>拍摄</figcaption></figure><p id="c420" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><strong class="jt ir">什么是二叉查找树？</strong></p><p id="b7ee" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">二叉查找树是一种用于以分层方式存储数据的数据结构。每条数据称为一个<strong class="jt ir"> <em class="js">节点</em> </strong>，每个<strong class="jt ir"> <em class="js">节点</em> </strong>有一个<strong class="jt ir">左</strong>和<strong class="jt ir">右</strong>。</p><p id="6c54" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">通过以这种方式组织数据，可以很容易地快速搜索树中的特定数据，因为您只需要将每个节点上的数据与您正在寻找的数据进行比较。这就是数据结构被称为“二分搜索法”树的原因。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/9d15874a6821d427eabf81529da10c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*mm4_JCS7sGRCjg_Z2MV14Q.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图片作者Timothy Kozaki</figcaption></figure><p id="2c20" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><strong class="jt ir"> <em class="js">左子</em> </strong>包含小于父节点的数据，而<strong class="jt ir"> <em class="js">右子</em> </strong>包含大于父节点的数据。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lr"><img src="../Images/0dc11bad4f301dcbe97d08ce5a7aeb73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iWj5t0dextmD8yfqFTpA2g.jpeg"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">照片由<a class="ae lf" href="https://www.freepik.com/author/starline" rel="noopener ugc nofollow" target="_blank"> starline </a>拍摄</figcaption></figure><p id="5f6d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">为什么我应该使用二叉查找树？</p><p id="d1d6" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">有几个原因可以解释你为什么想使用二叉查找树。其中一个主要原因是它们在搜索数据时<strong class="jt ir"><em class="js"/></strong>非常高效。因为树中的数据是以分层方式组织的，所以您可以通过将每个节点的数据与您要查找的数据进行比较来快速缩小搜索空间。这使得在二叉查找树中搜索数据比在其他数据结构(如数组或链表)中搜索数据要快得多。</p><blockquote class="jn jo jp"><p id="cd60" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">“在搜索数据方面非常高效。”</p></blockquote><p id="089c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">二分搜索法树的另一个优点是它们是<strong class="jt ir"> <em class="js">易于实现和使用</em> </strong>。插入和搜索数据等基本操作可以使用简单的递归算法来实现。这使得编写使用二分搜索法树的代码变得容易，并且使得代码易于理解和维护。</p><blockquote class="jn jo jp"><p id="ddd6" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">“易于实施和使用”</p></blockquote><p id="f7cb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">最后，二分搜索法树还具有<strong class="jt ir"> <em class="js">的灵活性，可用于多种应用</em> </strong>。例如，您可以使用它们来存储需要快速访问的数据，例如在数据库索引中。您还可以使用它们来实现其他数据结构，例如集合和映射，这在许多不同的上下文中都很有用。总的来说，二分搜索法树是组织和搜索数据的一个有用和强大的工具。</p><blockquote class="jn jo jp"><p id="2581" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">"灵活，可用于各种应用."</p></blockquote></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="4896" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">下面是一个用Python实现二叉查找树的例子。这段代码定义了一个<code class="fe ls lt lu lv b">BinarySearchTree</code>类，该类具有在树中插入和搜索数据的方法；输出<strong class="jt ir"> <em class="js">真</em> </strong>或<strong class="jt ir"> <em class="js">假。</em>T15】</strong></p><pre class="kq kr ks kt gt lw lv lx bn ly lz bi"><span id="a02a" class="ma mb iq lv b be mc md l me mf">class BinarySearchTree:<br/>    def __init__(self, data):<br/>        self.data = data<br/>        self.left = None<br/>        self.right = None<br/><br/>    def insert(self, data):<br/>        if data &lt; self.data:<br/>            if self.left is None:<br/>                self.left = BinarySearchTree(data)<br/>            else:<br/>                self.left.insert(data)<br/>        else:<br/>            if self.right is None:<br/>                self.right = BinarySearchTree(data)<br/>            else:<br/>                self.right.insert(data)<br/><br/>    def search(self, data):<br/>        if data &lt; self.data:<br/>            if self.left is None:<br/>                return False<br/>            else:<br/>                return self.left.search(data)<br/>        elif data &gt; self.data:<br/>            if self.right is None:<br/>                return False<br/>            else:<br/>                return self.right.search(data)<br/>        else:<br/>            return True</span></pre><p id="2205" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">要使用这个类，首先要创建一个<code class="fe ls lt lu lv b">BinarySearchTree</code>对象，并使用<code class="fe ls lt lu lv b">insert</code>方法将一些数据插入其中。然后，您可以使用<code class="fe ls lt lu lv b">search</code>方法在树中搜索特定的数据。</p><p id="054c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">例如:</p><pre class="kq kr ks kt gt lw lv lx bn ly lz bi"><span id="c33e" class="ma mb iq lv b be mc md l me mf">tree = BinarySearchTree(10)<br/>tree.insert(5)<br/>tree.insert(15)<br/><br/>if tree.search(5):<br/>    print("5 is in the tree")<br/>else:<br/>    print("5 is not in the tree")</span></pre><p id="6366" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">这段代码创建了一个<code class="fe ls lt lu lv b">BinarySearchTree</code>对象，它有一个包含值10的节点。然后，它会再插入两个包含值5和15的节点。最后，它将搜索值5，并输出一条消息，表明是否在树中找到了它。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="b063" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">以下是如何将二叉查找树用于数据集的示例。假设您有一个想要存储在二叉查找树中的数字列表。您可以这样做:</p><pre class="kq kr ks kt gt lw lv lx bn ly lz bi"><span id="a0da" class="ma mb iq lv b be mc md l me mf">data = [10, 5, 15, 3, 7, 12, 18]<br/>tree = BinarySearchTree(data[0])<br/><br/>for i in range(1, len(data)):<br/>    tree.insert(data[i])<br/><br/>if tree.search(12):<br/>    print("12 is in the tree")<br/>else:<br/>    print("12 is not in the tree")</span></pre><p id="5828" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">这段代码创建一个<code class="fe ls lt lu lv b">BinarySearchTree</code>对象，将<code class="fe ls lt lu lv b">data</code>列表(10)中的第一个元素作为根节点。然后，它使用<code class="fe ls lt lu lv b">insert</code>方法将列表中剩余的元素插入到树中。最后，它在树中搜索值12，并输出一条消息，表明是否找到了它。</p><p id="ebf7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">如果您要在插入所有数据后可视化二叉查找树，它看起来会像这样:</p><pre class="kq kr ks kt gt lw lv lx bn ly lz bi"><span id="a525" class="ma mb iq lv b be mc md l me mf">        10<br/>       /  \<br/>      5    15<br/>     / \   / \<br/>    3   7 12  18</span></pre><p id="919e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">如您所见，数据在树中的组织方式是，每个节点的<strong class="jt ir"> <em class="js">左子节点</em> </strong>包含的数据比<strong class="jt ir"> <em class="js">父节点</em> </strong>小，而<strong class="jt ir"> <em class="js">右子节点</em> </strong>包含的数据大。这使得快速搜索树中的特定数据变得容易。</p><p id="6de3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">很酷吧！？</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="3e34" class="mg mb iq bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">第二个示例—搜索和提取数据</h1><p id="086e" class="pw-post-body-paragraph jq jr iq jt b ju nd jw jx jy ne ka kb lg nf ke kf lh ng ki kj li nh km kn ko ij bi translated">在本例中，我们将搜索与我们的搜索相匹配的数据行。为此，概念是相似的，但是搜索功能被调整为输出结果。</p><pre class="kq kr ks kt gt lw lv lx bn ly lz bi"><span id="f601" class="ma mb iq lv b be mc md l me mf">class Node:<br/>    def __init__(self, val, data):<br/>        self.left = None<br/>        self.right = None<br/>        self.val = val<br/>        self.data = data<br/><br/>class BinarySearchTree:<br/>    def __init__(self):<br/>        self.root = None<br/>    <br/>    def insert(self, val, data):<br/>        new_node = Node(val, data)<br/>        if self.root is None:<br/>            self.root = new_node<br/>            return<br/>        <br/>        current_node = self.root<br/>        while True:<br/>            if val &lt; current_node.val:<br/>                if current_node.left is None:<br/>                    current_node.left = new_node<br/>                    break<br/>                else:<br/>                    current_node = current_node.left<br/>            else:<br/>                if current_node.right is None:<br/>                    current_node.right = new_node<br/>                    break<br/>                else:<br/>                    current_node = current_node.right<br/>    <br/>    def search(self, val):<br/>        current_node = self.root<br/>        while current_node is not None:<br/>            if val == current_node.val:<br/>                return current_node.data<br/>            elif val &lt; current_node.val:<br/>                current_node = current_node.left<br/>            else:<br/>                current_node = current_node.right<br/>        return None</span></pre><p id="5d71" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">在这个修改后的实现中，每个<code class="fe ls lt lu lv b">Node</code>对象都包含一个<code class="fe ls lt lu lv b">data</code>属性，用于存储与节点值相关的数据。<code class="fe ls lt lu lv b">insert</code>方法现在接受一个额外的<code class="fe ls lt lu lv b">data</code>参数，它存储在新节点的<code class="fe ls lt lu lv b">data</code>属性中。<code class="fe ls lt lu lv b">search</code>方法返回它找到的节点的<code class="fe ls lt lu lv b">data</code>属性，而不仅仅是<code class="fe ls lt lu lv b">True</code>。</p><p id="580a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">要使用这个修改过的<code class="fe ls lt lu lv b">BinarySearchTree</code>类从数据帧中搜索和检索特定的行数据，您可以这样做:</p><pre class="kq kr ks kt gt lw lv lx bn ly lz bi"><span id="20ba" class="ma mb iq lv b be mc md l me mf">import pandas as pd<br/><br/># Create a sample dataframe<br/>df = pd.DataFrame({'id': [1, 2, 3, 4, 5], <br/>                   'name': ['Alice', 'Bob', 'Charlie', 'Dave', 'Eve']})</span></pre><p id="448d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">在这个例子中，我们创建了一个带有一个<code class="fe ls lt lu lv b">'id'</code>列和一个<code class="fe ls lt lu lv b">'name'</code>列的dataframe。</p><pre class="kq kr ks kt gt lw lv lx bn ly lz bi"><span id="2563" class="ma mb iq lv b be mc md l me mf"># Create a binary search tree using the 'id' column as the values, and storing the entire row as the data<br/>bst = BinarySearchTree()<br/>for _, row in df.iterrows():<br/>    bst.insert(row['id'], row)</span></pre><p id="ece4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">然后，我们创建一个二叉查找树，使用<code class="fe ls lt lu lv b">'id'</code>列作为要存储在树中的值，并将整行存储为与每个值相关联的数据。</p><pre class="kq kr ks kt gt lw lv lx bn ly lz bi"><span id="eed3" class="ma mb iq lv b be mc md l me mf"># Search for a value in the tree and retrieve the associated data<br/>result = bst.search(3)<br/>print(result)  <br/><br/># Output<br/># 'id': 3, <br/># 'name': 'Charlie'</span></pre><p id="0dc5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">最后，我们使用<code class="fe ls lt lu lv b">search</code>方法来搜索值3和6。</p><pre class="kq kr ks kt gt lw lv lx bn ly lz bi"><span id="2025" class="ma mb iq lv b be mc md l me mf">result = bst.search(6)<br/>print(result)  <br/><br/># Output<br/># None</span></pre><h1 id="68a4" class="mg mb iq bd mh mi ni mk ml mm nj mo mp mq nk ms mt mu nl mw mx my nm na nb nc bi translated">跟我来。</h1><p id="7546" class="pw-post-body-paragraph jq jr iq jt b ju nd jw jx jy ne ka kb lg nf ke kf lh ng ki kj li nh km kn ko ij bi translated">我希望这篇文章对你有帮助！</p><p id="3937" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">我正在深入研究Python、SQL、机器学习、AR、VR和可视化，目标是确定最佳实践、提高效率并不断提升！</p><p id="3039" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">在这里整理我的想法/笔记，希望它能让媒体社区的每个人受益！</p><p id="0dd3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">请关注我，这样我就知道我的故事正在帮助人们，如果您有任何问题，请随时与我联系！感激不尽！</p></div></div>    
</body>
</html>