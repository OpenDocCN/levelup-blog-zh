<html>
<head>
<title>Understand HTTP/1.1 Persistent Connection: A Hands-on Approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解HTTP/1.1持久连接:实践方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understand-http-1-1-persistent-connection-a-hands-on-approach-b030f44228b?source=collection_archive---------8-----------------------#2022-05-10">https://levelup.gitconnected.com/understand-http-1-1-persistent-connection-a-hands-on-approach-b030f44228b?source=collection_archive---------8-----------------------#2022-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7a42" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基于Golang应用程序</h2></div><h1 id="4d12" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">背景</h1><p id="e6e8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最初，<code class="fe lt lu lv lw b">HTTP</code>是一个单一的请求-响应模型。一个<code class="fe lt lu lv lw b">HTTP</code>客户端打开<code class="fe lt lu lv lw b">TCP</code>连接，请求一个资源，得到响应，然后连接关闭。而建立和终止每一个<code class="fe lt lu lv lw b">TCP</code>连接都是一个消耗资源的操作(详细可以参考我之前的<a class="ae lx" href="https://baoqger.github.io/2019/07/14/why-tcp-four-way-handshake/" rel="noopener ugc nofollow" target="_blank">文章</a>)。随着web应用变得越来越复杂，显示一个页面可能需要多个HTTP请求，过多的TCP连接操作会对性能产生不良影响。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/84d89e715adaf4cf148958757cb7cf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/0*riYCORzYEMdtVjoz.png"/></div></figure><p id="b94b" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">因此在<code class="fe lt lu lv lw b">HTTP/1.1</code>协议中创建了<code class="fe lt lu lv lw b">persistent-connection</code>(也称为<code class="fe lt lu lv lw b">keep-alive</code>)模型。在这个模型中，TCP连接在几个连续的请求之间保持打开，这样，打开新连接所需的时间就会减少。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/a9964c4c249a057929bcfe5fc138cc47.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/0*YlkIIHy7WlVxHHvp.png"/></div></figure><p id="a4fc" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">在本文中，我将向您展示<code class="fe lt lu lv lw b">persistent connection</code>如何基于Golang应用程序工作。我们将基于demo app做一些实验，用一些流行的网络包分析工具验证TCP连接行为。简而言之，读完这篇文章，你会学到:</p><ul class=""><li id="ea04" class="ml mm iq kz b la mg ld mh lg mn lk mo lo mp ls mq mr ms mt bi translated">Golang <code class="fe lt lu lv lw b">http.Client</code>用法(还有一点源代码分析)</li><li id="b642" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated">用<code class="fe lt lu lv lw b">netstat</code>和<code class="fe lt lu lv lw b">tcpdump</code>进行网络分析</li></ul><p id="1736" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">你可以在这个Github <a class="ae lx" href="https://github.com/baoqger/http-persistent-connection-golang" rel="noopener ugc nofollow" target="_blank"> repo </a>中找到Golang应用的演示。</p><div class="mz na gp gr nb nc"><a href="https://github.com/baoqger/http-persistent-connection-golang" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">GitHub-baoqger/http-persistent-connection-golang:研究持久连接行为基于…</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">github.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq me nc"/></div></div></a></div><h1 id="7cca" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">顺序请求</h1><p id="2ac1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们从客户端不断向服务器发送<code class="fe lt lu lv lw b">sequential</code>请求的简单情况开始。<a class="ae lx" href="https://github.com/baoqger/http-persistent-connection-golang/blob/master/sequence/non-persistent-connection/non-persistent-connection.go" rel="noopener ugc nofollow" target="_blank">代码</a>如下所示:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7cb4" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">我们在一个Goroutine中启动一个HTTP服务器，并不断向它发送十个连续的请求。对吗？让我们运行应用程序并检查TCP连接的数量和状态。</p><p id="edde" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">运行上述代码后，您可以看到以下输出:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/5e6a593b0f4982f65e0fca09dcda751a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NrukJNqhxbNN5_qt.png"/></div></div></figure><p id="b35c" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">当应用程序停止运行时，我们可以运行下面的<code class="fe lt lu lv lw b">netstat</code>命令:</p><pre class="lz ma mb mc gt ny lw nz oa aw ob bi"><span id="1f06" class="oc kg iq lw b gy od oe l of og">netstat -n  | grep 8080</span></pre><p id="312e" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">TCP连接如下所示:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi oh"><img src="../Images/960d645e1d2eaabb8c7ab0a8bd0455b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JDFGn9aWqTVi4JJs.png"/></div></div></figure><p id="240f" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">显然，这10个HTTP请求不是持久的，因为10个TCP连接是打开的。</p><p id="80c0" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated"><strong class="kz ir">注</strong>:<code class="fe lt lu lv lw b">netstat</code>的最后一列显示了TCP连接的状态。TCP连接终止过程的状态可以用下图来解释:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi oi"><img src="../Images/72148eb519fd75423d8937968ff70e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TKsn8p_e7E759SVH.png"/></div></div></figure><p id="9def" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">我不会在这篇文章中涉及细节。但是我们需要理解<code class="fe lt lu lv lw b">TIME-WAIT</code>的含义。</p><p id="fa23" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">在<code class="fe lt lu lv lw b">four-way handshake</code>过程中，客户端会发送<code class="fe lt lu lv lw b">ACK</code>数据包终止连接，但是TCP的状态并不能马上转到<code class="fe lt lu lv lw b">CLOSED</code>。客户端需要等待一段时间，这个等待过程中的状态称为<code class="fe lt lu lv lw b">TIME-WAIT</code>。TCP连接需要这个<code class="fe lt lu lv lw b">TIME-WAIT</code>状态有两个主要原因。</p><ul class=""><li id="efe5" class="ml mm iq kz b la mg ld mh lg mn lk mo lo mp ls mq mr ms mt bi translated">第一是提供足够的时间让对方接收到<code class="fe lt lu lv lw b">ACK</code>。</li><li id="d58a" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated">第二是在当前连接结束和任何后续连接结束之间提供一个缓冲期。如果不是这段时间，来自不同连接的数据包可能会混合在一起。详细可以参考这本<a class="ae lx" href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-3.htm" rel="noopener ugc nofollow" target="_blank">书</a>。</li></ul><p id="e243" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">在我们的演示应用程序中，如果您在程序停止后等待一段时间，然后再次运行<code class="fe lt lu lv lw b">netstat</code>命令，那么输出中将不会列出任何TCP连接，因为它们都是关闭的。</p><p id="17b4" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">另一个验证TCP连接的工具是<code class="fe lt lu lv lw b">tcpdump</code>，它可以捕获发送到你机器的每个网络数据包。在我们的例子中，您可以运行下面的<code class="fe lt lu lv lw b">tcpdump</code>命令:</p><pre class="lz ma mb mc gt ny lw nz oa aw ob bi"><span id="e87a" class="oc kg iq lw b gy od oe l of og">sudo tcpdump -i any -n host localhost</span></pre><p id="405e" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">它将捕获从本地主机发送或发送到本地主机的所有网络数据包(我们在本地主机中运行服务器，对吗？).<code class="fe lt lu lv lw b">tcpdump</code>是帮助你了解网络的一个很棒的工具，你可以参考它的<a class="ae lx" href="https://www.tcpdump.org/" rel="noopener ugc nofollow" target="_blank">文档</a>获得更多帮助。</p><p id="9504" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated"><strong class="kz ir">注意</strong>:在我们上面的演示代码中，我们按顺序发送了10个HTTP请求，这会使<code class="fe lt lu lv lw b">tcpdump</code>的捕获结果太长。所以我修改了for循环，只发送2个顺序请求，这足以验证<code class="fe lt lu lv lw b">persistent connection</code>的行为。结果如下所示:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi oj"><img src="../Images/826261006a395dea0ee174b452935d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8WTQvmdt9-vlkQGN.png"/></div></div></figure><p id="c114" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">在<code class="fe lt lu lv lw b">tcpdump</code>输出中，<code class="fe lt lu lv lw b">Flag [S]</code>代表<code class="fe lt lu lv lw b">SYN</code>标志，用于建立TCP连接。上面的快照包含两个<code class="fe lt lu lv lw b">Flag [S]</code>包。第一个<code class="fe lt lu lv lw b">Flag [S]</code>是由第一个HTTP调用触发的，后面的包是HTTP请求和响应。然后你可以看到第二个<code class="fe lt lu lv lw b">Flag [S]</code>包打开一个新的TCP连接，这意味着第二个HTTP请求并不是我们希望的<code class="fe lt lu lv lw b">persistent connection</code>。</p><p id="3018" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">下一步，让我们看看如何在Golang中让HTTP作为一个持久连接工作。</p><p id="60e4" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">事实上，这是Golang生态系统中众所周知的问题，您可以在<a class="ae lx" href="https://pkg.go.dev/net/http#Client" rel="noopener ugc nofollow" target="_blank">官方文件</a>中找到相关信息:</p><ul class=""><li id="acb4" class="ml mm iq kz b la mg ld mh lg mn lk mo lo mp ls mq mr ms mt bi translated">如果返回的错误是nil，那么响应将包含一个非nil的主体，用户需要关闭这个主体。如果主体没有同时读取到EOF和closed，客户端的底层往返(通常是传输)可能无法为后续的“保持活动”请求重用到服务器的持久TCP连接。</li></ul><p id="9b62" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">修复很简单，只需添加两行代码，如下所示:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="80bc" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">让我们通过运行<code class="fe lt lu lv lw b">netstat</code>命令进行验证，结果如下:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ok"><img src="../Images/dd25ad07c5c248a92bcd9ca1ed0d7aec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jHNvSvv-wXdHtzXH.png"/></div></div></figure><p id="73ff" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">这一次，10个连续的HTTP请求只建立了一个TCP连接。这种行为正是我们所希望的:<code class="fe lt lu lv lw b">persistent connection</code>。</p><p id="9a99" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">我们可以通过与上面相同的实验进行双重验证:依次运行两个HTTP请求，并用<code class="fe lt lu lv lw b">tcpdump</code>捕获数据包:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi oj"><img src="../Images/9d6e33853268754faa62d59f7e98a14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5tIhyj5WlMhoXsHm.png"/></div></div></figure><p id="b7cd" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">这次只有一个<code class="fe lt lu lv lw b">Flag [S]</code>包在那里！这两个连续的HTTP请求重用相同的底层TCP连接。</p><p id="b786" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">在下一节中，我将修改演示应用程序，让它发送并发请求。这样，我们可以对HTTP/1.1的持久连接有更多的了解。</p><h1 id="8f8d" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">并发请求</h1><p id="31c8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><a class="ae lx" href="https://github.com/baoqger/http-persistent-connection-golang/blob/master/concurrent/non-persistent-connection/non-persistent-connection-concurrent.go" rel="noopener ugc nofollow" target="_blank">演示代码</a>如下所示:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2e4f" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated"><strong class="kz ir">注意</strong>:在HTTP/1.1协议中，并发请求会建立多个TCP连接。这是HTTP/1.1的限制，增强它的方法是使用<code class="fe lt lu lv lw b">HTTP/2</code>，它可以为多个并行HTTP连接复用一个TCP连接。<code class="fe lt lu lv lw b">HTTP/2</code>不在本帖讨论范围内。我会在另一篇文章中谈到它。</p><p id="8af2" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">请注意，在上面的演示中，我们已经完整地阅读了响应体并关闭了它，根据<a class="ae lx" href="https://baoqger.github.io/2021/10/25/understand-http1-1-persistent-connection-golang/" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中的讨论，HTTP请求应该在持久连接模型中工作。</p><p id="ef87" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">在使用网络工具分析行为之前，让我们想象一下将会建立多少个TCP连接。因为有10个并发的goroutines，所以应该建立10个TCP连接，所有的HTTP请求都应该重用这10个TCP连接，对吗？这是我们的期望。</p><p id="e159" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">接下来，让我们用<code class="fe lt lu lv lw b">netstat</code>验证我们的期望，如下所示:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ol"><img src="../Images/3c9e94baef3f611ad6b4eac50e83404e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*123n81hD9YkupHR2.png"/></div></div></figure><p id="2cf7" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">它显示TCP连接的数量远远超过10。持续连接没有像我们预期的那样工作。</p><p id="dc5e" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">看完<code class="fe lt lu lv lw b">net/http</code>包的源代码，我发现以下提示:</p><p id="4275" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated"><code class="fe lt lu lv lw b">Client</code>在<a class="ae lx" href="https://golang.org/src/net/http/client.go" rel="noopener ugc nofollow" target="_blank"> client.go </a>中定义，是HTTP客户端的类型，<code class="fe lt lu lv lw b">Transport</code>是属性之一:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0468" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated"><code class="fe lt lu lv lw b">Transport</code>在<a class="ae lx" href="https://golang.org/src/net/http/transport.go" rel="noopener ugc nofollow" target="_blank"> transport.go </a>中是这样定义的:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="782e" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">注意<code class="fe lt lu lv lw b">Transport</code>有两个参数:</p><ul class=""><li id="3377" class="ml mm iq kz b la mg ld mh lg mn lk mo lo mp ls mq mr ms mt bi translated"><strong class="kz ir"> MaxIdleConns </strong>:控制所有主机上空闲(保持活动)连接的最大数量。</li><li id="d752" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated"><strong class="kz ir">maxidleconsperhost</strong>:控制每个主机保持的最大空闲(保持活动)连接数。如果为零，则使用DefaultMaxIdleConnsPerHost。</li></ul><p id="aa01" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">默认情况下，MaxIdleConns为<strong class="kz ir"> 100 </strong>，MaxIdleConnsPerHost为<strong class="kz ir"> 2 </strong>。</p><p id="03f6" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">在我们的演示案例中，十个goroutines向同一个主机(localhost:8080)发送请求。虽然MaxIdleConns是100，但是对于这个主机来说，<strong class="kz ir">只能缓存2个空闲连接</strong>，因为MaxIdleConnsPerHost是2。这就是为什么你看到更多的TCP连接被建立。</p><p id="8d9b" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">基于这一分析，让我们按如下方式重构代码:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="43ef" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">这一次我们不使用默认的httpClient，而是创建一个定制的客户机，将MaxIdleConnsPerHost设置为<strong class="kz ir"> 10 </strong>。这意味着连接池的大小更改为10，这可以为每个主机缓存10个空闲TCP连接。</p><p id="ff6c" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">再次用<code class="fe lt lu lv lw b">netstat</code>验证行为:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi om"><img src="../Images/621f6f737f617acf942448dbadd4099b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/0*LLk4-0OyYiZ-X0ei.png"/></div></figure><p id="f653" class="pw-post-body-paragraph kx ky iq kz b la mg jr lc ld mh ju lf lg mi li lj lk mj lm ln lo mk lq lr ls ij bi translated">现在的结果是我们所期待的。</p><h1 id="12ff" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">摘要</h1><p id="3686" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本文中，我们讨论了如何通过调整连接池的参数，使HTTP/1.1持久连接在顺序和并发情况下都能工作。在下一篇文章中，我们来回顾一下源代码，研究一下如何实现HTTP客户端。</p></div></div>    
</body>
</html>