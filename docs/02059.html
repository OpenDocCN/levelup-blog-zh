<html>
<head>
<title>Getting to know and love TypeScript’s “meta” types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解并爱上TypeScript的“元”类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-to-know-and-love-typescripts-meta-types-5e17a8856b17?source=collection_archive---------6-----------------------#2020-02-16">https://levelup.gitconnected.com/getting-to-know-and-love-typescripts-meta-types-5e17a8856b17?source=collection_archive---------6-----------------------#2020-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d53eb29f0aa69288a9dae8989013fc7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yxIBQ03Q6sWDpghv"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">奇怪的现象向事物本质的边界显现。宇宙也是如此。打字稿也是如此。由<a class="ae kf" href="https://unsplash.com/@kvedula?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kamesh Vedula </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="278b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着您在TypeScript中编写更多代码或使用更多具有TypeScript类型的库，您可能会意识到一些类型的含义可能相当令人费解。让我给你讲几个:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e425" class="ln lo it lj b gy lp lq l lr ls">any<br/>void<br/>undefined<br/>unknown<br/>never</span></pre><p id="cd2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的头脑中，我称这些类型为“元”类型，因为它们经常超越描述具体的、真实世界的“事物”。相反，它们要么表现为语言技术性的一部分，要么可以传达一个抽象的概念，一个打字稿程序员应该注意这一点。</p><p id="aab8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果看到这些类型让你焦虑不安，请继续读下去！在这篇文章中，我将尽我所能让你与这些类型的人和平相处，他们将成为你的盟友！</p><p id="f7b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lt">免责声明:请注意“meta”名称完全是个人的，因此您可能在别处找不到它。其中两种类型——</em><code class="fe lu lv lw lj b"><em class="lt">unknown</em></code><em class="lt">和</em><code class="fe lu lv lw lj b"><em class="lt">never</em></code><em class="lt">——在类型理论中也被正式称为“顶”和“底”类型。</em></p><h1 id="1612" class="lx lo it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">第一对:“任何”和“未知”类型</h1><blockquote class="mu"><p id="315a" class="mv mw it bd mx my mz na nb nc nd ld dk translated"><strong class="ak">TL；博士:如果可以的话，避免使用T2，但是如果必须的话，使用它。</strong></p></blockquote><p id="f989" class="pw-post-body-paragraph kg kh it ki b kj ne kl km kn nf kp kq kr ng kt ku kv nh kx ky kz ni lb lc ld im bi translated">乍看之下，<code class="fe lu lv lw lj b">any</code>和<code class="fe lu lv lw lj b">unknown</code>类型有相似的实际用途:在某种程度上，这两种类型都允许你“含糊”地打字。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5a05" class="ln lo it lj b gy lp lq l lr ls">const a: any = "foo";<br/>const b: unknown = "bar";</span></pre><p id="fe08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以用任何东西代替上面的<code class="fe lu lv lw lj b">"foo"</code>和<code class="fe lu lv lw lj b">"bar"</code>。我指的是任何事情。类型为<code class="fe lu lv lw lj b">any</code>和<code class="fe lu lv lw lj b">unknown</code>的变量的所有赋值都是有效的，作为<code class="fe lu lv lw lj b">any</code>或<code class="fe lu lv lw lj b">unknown</code>类型的参数提供的所有函数参数值也是有效的。以这种方式，两种类型的行为是相同的。</p><p id="3984" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们的第一个区别在于相反的方向。如果您试图将<em class="lt">的</em>的<code class="fe lu lv lw lj b">any</code>或<code class="fe lu lv lw lj b">unknown</code>类型的值赋给一个变量(或作为函数参数提供)，该怎么办？</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="e598" class="ln lo it lj b gy lp lq l lr ls">const a1: any = "foo";<br/>const a2: string = a1;<br/>const a3: boolean = a1; // sure! (!!!)<br/>const a4: any = a1;<br/>const a5: unknown = a1;</span><span id="d3f3" class="ln lo it lj b gy nj lq l lr ls">const b1: unknown = "bar";<br/>const b2: string = b1; // nope! (!!!)<br/>const b3: boolean = b1; // nope!<br/>const b4: unknown = b1;<br/>const b5: any = b1;</span></pre><p id="744e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(<a class="ae kf" href="http://www.typescriptlang.org/play/index.html?ssl=1&amp;ssc=1&amp;pln=11&amp;pc=20#code/MYewdgzgLgBAhgRgFzzATxgXhgIgGYgg4DcAUKJLHAEwrQBOAlmAOZbwJkXTwDMKAI0IAbAKZww7RF3A84AFhQSM2aeVlUArCgCuYANZgQAd0mrOpdZRgDkMPYZNncAuPRJWeA2jAbM22LYy1gL8NiLizkGesAKK9gZGpuzR3LHaqCo2nEA" rel="noopener ugc nofollow" target="_blank">游乐场链接此处</a>)</p><p id="1193" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如你在操场上看到的，<code class="fe lu lv lw lj b">any</code>值可以被赋给任何东西，即使根据经验它看起来是一个“错误”类型的值(注意<code class="fe lu lv lw lj b">a3</code>)。在这方面，<code class="fe lu lv lw lj b">unknown</code>类型展示了一种“相反”的行为:除了期望<code class="fe lu lv lw lj b">unknown</code>和<code class="fe lu lv lw lj b">any</code>之外，它不能赋给任何东西，即使对于经验上看起来是“正确”类型的值(注<code class="fe lu lv lw lj b">b2</code>)。</p><p id="0720" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们做一件让TypeScript令人敬畏的事情:让我们看看这两种类型在受到<a class="ae kf" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types" rel="noopener ugc nofollow" target="_blank">类型保护</a>时的表现。注意，下面的条件块都不会在运行时执行，这没问题。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="21b4" class="ln lo it lj b gy lp lq l lr ls">const a1: any = "foo";<br/>if (typeof a1 === "boolean") {<br/>  const a2: string = a1; // nope!<br/>  const a3: boolean = a1;<br/>}</span><span id="479e" class="ln lo it lj b gy nj lq l lr ls">const b1: unknown = "bar";<br/>if (typeof b1 === "boolean") {<br/>  const b2: string = b1; // nope!<br/>  const b3: boolean = b1;<br/>}</span></pre><p id="24f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(<a class="ae kf" href="http://www.typescriptlang.org/play/index.html?ssl=11&amp;ssc=2&amp;pln=1&amp;pc=1#code/MYewdgzgLgBAhgRgFzzATxgXhgIgGYgg4DcAUAJZ4wAUUaADgKYhWJabY4BGhANo3DA4AlDADepGDFCRYcAEwpoAJ3JgA5lngIyUmdHgBmFDxD9BWxGQC+pUvthdkMAK5gA1mBAB3MFu5wyiQUVLQMzFRO7Jym5kKiEnrgBlyKMCpqmthOutLJjsYwsQJ+2Tqk1kA" rel="noopener ugc nofollow" target="_blank">游乐场链接此处</a>)</p><p id="7fd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，这两种类型的行为又变得一样了。在每个条件块中，我们的“模糊”类型被保护为布尔型，因此它们变成了<code class="fe lu lv lw lj b">boolean</code>类型。</p><p id="1f8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，<code class="fe lu lv lw lj b">unknown</code>类型是一种安全的、假设永远不变的类型。从这个意义上说，你可以含糊地声明某个东西<code class="fe lu lv lw lj b">unknown</code>，但是如果你希望有意义地使用这个值，你<em class="lt">必须</em>使用类型保护或者类型转换。</p><p id="28fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面,<code class="fe lu lv lw lj b">any</code>类型本质上等同于完全关闭该值的输入。只要值不受守卫，那就是“<code class="fe lu lv lw lj b">any</code>的事”(geddit？😅).使用<code class="fe lu lv lw lj b">any</code>实际上是告诉TypeScript后退。</p><p id="c2cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是为什么您希望TypeScript后退呢？嗯，如果你正在将一个庞大的代码库转换成TypeScript，那么<code class="fe lu lv lw lj b">any</code>类型是一个救星:它允许一个渐进的转换。首先，在遵守其他约束的情况下，尽可能正确地输入所有内容，并保留其他值<code class="fe lu lv lw lj b">any</code>。然后，随着你的打字模式变得更加清晰，你放弃了<code class="fe lu lv lw lj b">any</code>而倾向于更具体的类型。最后，您打开<code class="fe lu lv lw lj b">tsconfig.json</code>的<code class="fe lu lv lw lj b"><a class="ae kf" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" rel="noopener ugc nofollow" target="_blank">compilerOptions</a></code>中的<code class="fe lu lv lw lj b">noImplicitAny</code>选项，这将阻止TypeScript假定<code class="fe lu lv lw lj b">any</code>类型的东西，如果没有您的帮助，它无法推断出这些东西的类型。</p><h2 id="0a73" class="ln lo it bd ly nk nl dn mc nm nn dp mg kr no np mk kv nq nr mo kz ns nt ms nu bi translated">尽快远离“任何”</h2><blockquote class="nv nw nx"><p id="b644" class="kg kh lt ki b kj kk kl km kn ko kp kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi">“ไปไหนมา สามวาสองศอก”</p><p id="b782" class="kg kh lt ki b kj kk kl km kn ko kp kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">翻译:</p><p id="a7d4" class="kg kh lt ki b kj kk kl km kn ko kp kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">“你去哪儿了？”</p><p id="0097" class="kg kh lt ki b kj kk kl km kn ko kp kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">[另一个回答:]“七米。”</p><p id="c5cc" class="kg kh lt ki b kj kk kl km kn ko kp kq ny ks kt ku nz kw kx ky oa la lb lc ld im bi translated">—泰国谚语</p></blockquote><p id="4022" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你已经在你的代码库中建立了一个严格的类型系统，使用<code class="fe lu lv lw lj b">unknown</code>作为一种模糊的方式，并通过guards断言你想要的类型。更好的是，看看你的模糊性是否实际上是一种可以用<a class="ae kf" href="https://medium.com/@tar.viturawong/the-true-power-of-typescript-generics-1303d78a1c9a" rel="noopener">泛型</a>表达的类型多态形式。值得再次重复的是,<code class="fe lu lv lw lj b">any</code>表示一种<em class="lt">非类型化的</em>情况，并且您本质上是在处理关于该值的普通JavaScript。</p><h1 id="21d6" class="lx lo it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">第二对:“无效”和“未定义”类型</h1><blockquote class="mu"><p id="b94b" class="mv mw it bd mx my mz na nb nc nd ld dk translated">TL；DR:使用“void”忽略函数返回值，使用“undefined”有意返回undefined。</p></blockquote><p id="0de4" class="pw-post-body-paragraph kg kh it ki b kj ne kl km kn nf kp kq kr ng kt ku kv nh kx ky kz ni lb lc ld im bi translated">在JavaScript中，<code class="fe lu lv lw lj b">void</code>和<code class="fe lu lv lw lj b">undefined</code>都代表相同的概念，即未定义值的概念。一个“returns void”的函数不返回值，如果你试图保存那个不存在的返回值，它将是<code class="fe lu lv lw lj b">undefined</code>。在JavaScript中，“不返回”的函数与显式返回<code class="fe lu lv lw lj b">undefined</code>的函数在行为上没有什么不同:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="b9bf" class="ln lo it lj b gy lp lq l lr ls">const a = () =&gt; {};<br/>const b = () =&gt; undefined;<br/>console.log(a());  // undefined<br/>console.log(b());  // undefined</span></pre><p id="3f2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这有什么大不了的？</p><p id="3257" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯，在TypeScript中，有一个<code class="fe lu lv lw lj b">void</code>类型与<code class="fe lu lv lw lj b">undefined</code>类型不同。看看这个:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="fe3c" class="ln lo it lj b gy lp lq l lr ls">const void1: void = undefined;<br/>const undefined1: undefined = undefined;</span><span id="4156" class="ln lo it lj b gy nj lq l lr ls">const void2: void = undefined1;<br/>const undefined2: undefined = void1; // nope!</span></pre><p id="e8ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(<a class="ae kf" href="http://www.typescriptlang.org/play/index.html?ssl=1&amp;ssc=1&amp;pln=6&amp;pc=1#code/MYewdgzgLgBAbiAlgEwIwwLwwK5mQUwDNEx9kBuAKFEllwONLUxzyJLKuvGniWQBMALj4oW9dk1RUavCYzLDWDDshYIU0ykA" rel="noopener ugc nofollow" target="_blank">游乐场链接此处</a>)</p><p id="de3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，您可以将一个<code class="fe lu lv lw lj b">undefined</code>类型分配给一个<code class="fe lu lv lw lj b">void</code>类型，但不能反过来。</p><p id="8f9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么为什么在JavaScript中不存在的情况下，TypeScript会有这种区分呢？为了开始理解这一点，我们应该看看TypeScript声明什么是没有任何类型注释的以下表达式的类型:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2569" class="ln lo it lj b gy lp lq l lr ls">const foo = void 0;<br/>const bar = function(){};<br/>const baz = bar();</span></pre><p id="b3df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(<a class="ae kf" href="http://www.typescriptlang.org/play/index.html?ssl=1&amp;ssc=1&amp;pln=3&amp;pc=19#code/MYewdgzgLgBAZiEMC8MBuICWATGAGAbgChRJYAjAQwCcV4BXMYKTcACgEoBvAX2NOgwqALzpVqnAkA" rel="noopener ugc nofollow" target="_blank">游乐场链接此处</a>)</p><p id="7dd4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lt">(对于相对不熟悉的人来说，</em> <a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void" rel="noopener ugc nofollow" target="_blank"> <em class="lt">表达式</em> </a> <code class="fe lu lv lw lj b"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void" rel="noopener ugc nofollow" target="_blank"><em class="lt">void 0</em></a></code> <a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void" rel="noopener ugc nofollow" target="_blank"> <em class="lt">产生了</em> </a> <code class="fe lu lv lw lj b"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void" rel="noopener ugc nofollow" target="_blank"><em class="lt">undefined</em></a></code> <a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void" rel="noopener ugc nofollow" target="_blank"> <em class="lt">值</em> </a> <em class="lt">，这是一个pre-ES5遗留的问题，其中的</em> <code class="fe lu lv lw lj b"><em class="lt">undefined</em></code> <em class="lt">全局变量在某些浏览器中可能会被覆盖；那是一段狂野而美好的时光！)</em></p><p id="e215" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你检查操场，你会看到<code class="fe lu lv lw lj b">foo</code>有类型<code class="fe lu lv lw lj b">undefined</code>，而<code class="fe lu lv lw lj b">baz</code>有类型<code class="fe lu lv lw lj b">void</code>。区别就在于此:在TypeScript中，不显式返回值的函数返回<code class="fe lu lv lw lj b">void</code>。</p><p id="0d5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">"但是<code class="fe lu lv lw lj b">void</code> <em class="lt">就是</em> <code class="fe lu lv lw lj b">undefined</code>，为什么要在这个问题上斤斤计较呢？"你问。</p><p id="e238" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯，在打字的世界里，这是有区别的！在它们身上尝试<a class="ae kf" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing" rel="noopener ugc nofollow" target="_blank">无效聚结操作符</a>:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="65b0" class="ln lo it lj b gy lp lq l lr ls">declare const a: void;<br/>declare const b: undefined;<br/>const aOr42 = a ?? 42; // nope!<br/>const bOr42 = b ?? 42;</span></pre><p id="4c0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(<a class="ae kf" href="https://www.typescriptlang.org/play/?ts=3.8-Beta&amp;ssl=1&amp;ssc=1&amp;pln=14&amp;pc=13#code/CYUwxgNghgTiAEYD2A7AzgF3lAXPAbkgJbADcAUKJLAsulgEZ4CuKoAZkSiGeXZtgDyMACwAmeAF5s8APyz44iv0bDxU+AzkKlQA" rel="noopener ugc nofollow" target="_blank">游乐场链接此处</a>)</p><p id="f6be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您会发现<code class="fe lu lv lw lj b">void</code>值不能像<code class="fe lu lv lw lj b">undefined</code>那样被合并。这里你会被警告<code class="fe lu lv lw lj b">a</code>不能在这个上下文中使用:<em class="lt">“一个‘void’类型的表达式不能被测试真值”。很快，你会发现这种行为与<code class="fe lu lv lw lj b">void</code>和<code class="fe lu lv lw lj b">undefined</code>的其他区别是一致的。</em></p><p id="cc4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们试图定义一个函数来适应某种类型时，另一个实际的区别就来了。</p><p id="dac3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们假设你必须定义一个回调函数，比方说，一个定时器。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="fbc8" class="ln lo it lj b gy lp lq l lr ls">function delay(callback: () =&gt; void){<br/>  setTimeout(callback, 1000);<br/>}</span></pre><p id="05c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们看看TypeScript将允许什么作为<code class="fe lu lv lw lj b">callback</code>的参数:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d26c" class="ln lo it lj b gy lp lq l lr ls">delay(() =&gt; alert("hi!"));<br/>delay(() =&gt; prompt("what's your name?"));<br/>delay(function(){<br/>  prompt("what's your name?");<br/>});<br/>delay(function(){<br/>  return prompt("what's your name?");<br/>});<br/>delay(function(){<br/>  return alert("hi!");<br/>});<br/>delay(function(){<br/>  return undefined;<br/>});</span></pre><p id="e04e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(<a class="ae kf" href="http://www.typescriptlang.org/play/index.html?ssl=1&amp;ssc=1&amp;pln=18&amp;pc=4#code/GYVwdgxgLglg9mABAEwKYBsCGBPAFBTddAI0wgGsAuRXASkQF4A+RANzhmVoG8AoRRAGdUUACowAtqjggo+QiTLkANIgCMABi20A3LwC+vXmix46jFoVQAnOQCIAFjACEd2ruMYcuc80QAHazgJf3sAdwdMKAByQURsGWtEMEwpAH43DxNvUEhYBDo+AUDg0Nw7CKjY+MTk1NQMj30srzxc6HgwQv5EaxEQayQSkPDImLiEgbr0tz1mvWy28A6Cnh6+qAGkK1typ1cmltNcdvyutYENrcRwNGAYMFRkOd0gA" rel="noopener ugc nofollow" target="_blank">游乐场链接此处</a>)</p><p id="8922" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的一切都是允许的，甚至是那些返回非<code class="fe lu lv lw lj b">undefined</code>值的函数，比如那些调用<code class="fe lu lv lw lj b">prompt</code>的函数。现在让我们对比一下同一个实验，此时我们的<code class="fe lu lv lw lj b">callback</code>预期返回<code class="fe lu lv lw lj b">undefined</code>:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7a2f" class="ln lo it lj b gy lp lq l lr ls">function delay(callback: () =&gt; undefined){<br/>  setTimeout(callback, 1000);<br/>}</span></pre><p id="c35d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(<a class="ae kf" href="http://www.typescriptlang.org/play/index.html?ssl=1&amp;ssc=1&amp;pln=20&amp;pc=4#code/GYVwdgxgLglg9mABAEwKYBsCGBPAFBTddAI0wgGsAuRXASkQF4A+RcNYGMVZWgbwChEiAM6ooAFRgBbVHBBR8hEmXIAaRAEYADDtoBufgF9+-NFjx1GLQqgBOCgEQALGAEIHtfaYw5cl5ogADrZwUoGOAO5OmFAA5MKI2HK2iGCYMgD8Hl5mvqCQsAh0AkLBoeG4DlEx8YnJqemoWV6GOT54+dDwYMWCiLZiILZIZWGR0XEJSUMNmR4GrQa5HeBdRXx9A1BDSDb2lS7uLW3muJ2FPRtCWzusYOyc3AsneasXvYtAA" rel="noopener ugc nofollow" target="_blank">游乐场链接此处</a>)</p><p id="7dc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，除了一个显式返回<code class="fe lu lv lw lj b">undefined</code>值的函数之外，几乎所有的函数都中断了。这实际上就是两种类型的<em class="lt">语义</em>区别。作为返回类型，<code class="fe lu lv lw lj b">undefined</code>类型要求函数显式返回<code class="fe lu lv lw lj b">undefined</code>。另一方面，<code class="fe lu lv lw lj b">void</code>返回类型仅仅意味着函数的返回值<em class="lt">没有意义，应该被简单地忽略</em>。这对于arrow函数表达式尤其重要，因为它们能够隐式返回唯一表达式的值。将<code class="fe lu lv lw lj b">void</code>作为返回类型让TypeScript忽略这样的隐式返回值。</p><p id="4bb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了以另一种方式演示这一点，让我们看看这些自行定义并直接调用的回调:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="4ed6" class="ln lo it lj b gy lp lq l lr ls">type Callback = () =&gt; void;</span><span id="3d3f" class="ln lo it lj b gy nj lq l lr ls">const a: Callback = () =&gt; alert("hi!");<br/>const b: Callback = () =&gt; prompt("what's your name?");<br/>const c: Callback = function(){<br/>  prompt("what's your name?");<br/>};<br/>const d: Callback = function(){<br/>  return prompt("what's your name?");<br/>};<br/>const e: Callback = function(){<br/>  return alert("hi!");<br/>};<br/>const f: Callback = function(){<br/>  return undefined;<br/>};<br/>const g: Callback = function(){};</span><span id="2406" class="ln lo it lj b gy nj lq l lr ls">const returnA = a();<br/>const returnB = b();<br/>const returnC = c();<br/>const returnD = d();<br/>const returnE = e();<br/>const returnF = f();<br/>const returnG = g();</span></pre><p id="58c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(<a class="ae kf" href="http://www.typescriptlang.org/play/index.html?ssl=1&amp;ssc=1&amp;pln=26&amp;pc=21#code/C4TwDgpgBAwghgGwQIzgYwNZQLxQBQCUOAfFAG4D2AlgCYDcAUA2hQHYDOwUcAXLIinRZchEtwQQATsDwAiABZUAhLIKMWHLsj7wkqTDnxFspMJIoBbMDNkB3eXGABydlBAUArpKis4FiAD8qupsnFBoOgL6wlAAZh6saMBUbIQA3gxQUGaW1nL2ji5unt6+-kFqDAC+IZpQNJF6QobxicmpBBlZkhDAXqzZ5lY2Bc6u7l4+foHB1bVhEI2CBritSSms6ZlQPX2SA4hSNooqlTXMoVyxS9EtCesdXTu9-VAJNBCxVKwQ9HMXdQA5jdmqt7u1Np1-gCwrt+gBBQxwQjzLhw-YAIUMyBRMLRL32MEMaFxGlhBNYABFDDRSZdnntWABRQwQOl1dGsABiLXZ5MZAHFDICUUA" rel="noopener ugc nofollow" target="_blank">游乐场链接此处</a>)</p><p id="4e7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，不管函数实现返回什么，当我们实际评估这些函数时，TypeScript将忽略它们的返回值，并且我们在所有情况下都以<code class="fe lu lv lw lj b">void</code>结束。</p><p id="c42d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过请注意，在TypeScript最终转换到的JavaScript-land中，返回值是完整的(因此上面的<code class="fe lu lv lw lj b">returnB</code>和<code class="fe lu lv lw lj b">returnD</code>可能有一个具体的值)。TypeScript只是阻止您在编译时使用它。其效果是，您可以“草率地”返回一个值，而不打算使它有意义(再次，箭头函数！)，而TypeScript将有助于使消耗这样的值变得更加困难。</p><h2 id="13a3" class="ln lo it bd ly nk nl dn mc nm nn dp mg kr no np mk kv nq nr mo kz ns nt ms nu bi translated">你是回归空虚，还是不回归？</h2><p id="8539" class="pw-post-body-paragraph kg kh it ki b kj ob kl km kn oc kp kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">如果没有内置的ES6特性，比如Map和WeakMap，它们的getters可以返回<code class="fe lu lv lw lj b">undefined</code>，我会认为应该将<code class="fe lu lv lw lj b">undefined</code>和<code class="fe lu lv lw lj b">null</code>等同地表示一个缺失的值，而不是有细微的不同程度的空。然而，对此进行辩论有引发宗教战争的风险，因此我将谦恭地接受不同意见，因为这与此无关。</p><p id="a9be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里<em class="lt">与</em>相关的是，如果你使用<code class="fe lu lv lw lj b">undefined</code>作为返回值，使用<code class="fe lu lv lw lj b">undefined</code>类型并使用<code class="fe lu lv lw lj b">void</code>来注释返回值<em class="lt">没有意义</em>的函数。如果您的函数有条件地返回<code class="fe lu lv lw lj b">undefined</code> <em class="lt">或</em> <em class="lt">或者</em>某个具体值，这种区别就特别重要，ES6 Map getter就是这种情况。实际的好处是，您将受到保护，不会意外消费不应消费的返回值。</p><h1 id="3c71" class="lx lo it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">“从不”型</h1><p id="80f8" class="pw-post-body-paragraph kg kh it ki b kj ob kl km kn oc kp kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">在所有的元类型中，<code class="fe lu lv lw lj b">never</code>类型可能是最令人好奇的；它也是一个有用的概念，在许多情况下都有用途——尽管看起来是不相关的。</p><p id="890f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lu lv lw lj b">never</code>类型是类型理论称之为“底层”类型的一个例子，这种类型不包含任何可能的实例(这是我有限的理解，我不是类型理论家！).在打字稿中，它表示不可能或不适用的意思。让我们看看发生这种情况的一些情况:</p><h2 id="3c34" class="ln lo it bd ly nk nl dn mc nm nn dp mg kr no np mk kv nq nr mo kz ns nt ms nu bi translated">控制阻止返回/产出的流程</h2><p id="97de" class="pw-post-body-paragraph kg kh it ki b kj ob kl km kn oc kp kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">考虑这些功能:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7d32" class="ln lo it lj b gy lp lq l lr ls">function gameLoop(): never { <br/>  while (true) {}<br/>}</span><span id="c1a2" class="ln lo it lj b gy nj lq l lr ls">function die(): never { <br/>  throw Error("boo hoo"); <br/>}</span></pre><p id="6ba0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<code class="fe lu lv lw lj b">gameLoop</code>根本不返回，因为它内部有一个无限循环。这个函数可以将其返回类型声明为<code class="fe lu lv lw lj b">never</code>。(请注意，虽然这在典型的JavaScript领域中不太可能是一个现实的函数，但请参见我在本文末尾的脚注。)</p><p id="6700" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<code class="fe lu lv lw lj b">die</code>没有以正常方式返回，而是抛出一个异常。同样，这个函数可以将其返回类型声明为<code class="fe lu lv lw lj b">never</code>。这里，<code class="fe lu lv lw lj b">never</code>是控制流使得返回动作不可能的结果，从而使得返回值不适用。</p><p id="8b0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下,<code class="fe lu lv lw lj b">never</code>类型注释非常有用，因为它可以间接地提醒您无法到达的地方。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="215c" class="ln lo it lj b gy lp lq l lr ls">const afterlife = die(); // type never<br/>// because its assignment is unreachable</span></pre><p id="ee73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与此类似的是永远不会产生的<a class="ae kf" href="http://www.typescriptlang.org/play/index.html#code/GYVwdgxgLglg9mAVAAjAUwG5oE4E0ZoA2AJgM4AUAlMgN4C+QA" rel="noopener ugc nofollow" target="_blank">发生器。</a></p><blockquote class="mu"><p id="5b03" class="mv mw it bd mx my mz na nb nc nd ld dk translated">这里有一个谜:一个<code class="fe lu lv lw lj b">async</code>函数的返回类型可以是“<code class="fe lu lv lw lj b">never”</code>吗？</p></blockquote><h2 id="dfb9" class="ln lo it bd ly nk og dn mc nm oh dp mg kr oi np mk kv oj nr mo kz ok nt ms nu bi translated">缩小到不可能</h2><p id="e4ad" class="pw-post-body-paragraph kg kh it ki b kj ob kl km kn oc kp kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">我对一种叫做<a class="ae kf" href="https://en.wikipedia.org/wiki/Catu%E1%B9%A3ko%E1%B9%ADi" rel="noopener ugc nofollow" target="_blank"> Chatuskoti </a>的古印度逻辑形式着迷。在佛教的<em class="lt">佛经中，</em>经常看到一个命题被分成四部分，比如:<a class="ae kf" href="https://www.accesstoinsight.org/tipitaka/mn/mn.063.than.html" rel="noopener ugc nofollow" target="_blank">“宇宙是有限的吗？是无限的吗？是既有限又无限吗？它既不是有限的，也不是无限的吗？”对这些古代人来说，一个二元问题似乎可以扩展成四倍的真值。如果你对所有这些可能性都回答“不”,你就会陷入一个不可能的境地。</a></p><p id="e2c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以像在TypeScript中一样对这样的逻辑建模:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="dac9" class="ln lo it lj b gy lp lq l lr ls">enum FourFoldTruthValue {<br/>  Yes,<br/>  No,<br/>  Both,<br/>  Neither<br/>}</span><span id="77e5" class="ln lo it lj b gy nj lq l lr ls">function answerQuestion(answer: FourFoldTruthValue)<br/>{<br/>  if (answer === FourFoldTruthValue.Yes){ /* ... */ }<br/>  else if (answer === FourFoldTruthValue.No){ /* ... */ }<br/>  else if (answer === FourFoldTruthValue.Both){ /* ... */ }<br/>  else if (answer === FourFoldTruthValue.Both){ /* ... */ }<br/>  else if (answer === FourFoldTruthValue.Neither){ /* ... */ }<br/>  else {<br/>    // what is the type of `answer` here?<br/>  }<br/>}</span></pre><p id="97a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(<a class="ae kf" href="http://www.typescriptlang.org/play/index.html#code/KYOwrgtgBAYg9mATvANgEwCqLAFwBYBqAhimMAN4BQUUAmsAM4A01UAcnCzQEJz5ftgAS3zBElAL6VKAMzAgAxjiFwQUIiAYB3MQEUyDZaoAUG7WIBcsBMjjosuQiTIBKSlRpCZUU5p2IoAF5g6yRUTGx8YlJgADp6BhdyKAB6ACooWKyoNJSoKRpgFAZgKC8fM38gkPgwuwjHaLJYjiTUjKzYnLyCqCKSsu9fcwDgwNDbe0inGNjefDb0zOzc-NZ+0vLhqrGJ8Ico5zi2YVFERY6VnvXi0o8aVLytPCIcMoYoUU+ATwAHUrg3gABpUxECoHgxMAAPysGig8Q0KQSIA" rel="noopener ugc nofollow" target="_blank">游乐场链接此处</a>)</p><p id="8349" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最终<code class="fe lu lv lw lj b">else</code>分支的<code class="fe lu lv lw lj b">answer</code>类型为<code class="fe lu lv lw lj b">never</code>。为什么？<code class="fe lu lv lw lj b">answer</code>必须是四个可能的枚举值中的一个，由于每个<code class="fe lu lv lw lj b">if</code>子句相继排除了每个剩余的可能性，所以在我们最后的<code class="fe lu lv lw lj b">else</code>子句中，我们没有剩余的可能性。因此类型为<code class="fe lu lv lw lj b">never</code>。</p><p id="ff0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你需要完全处理不同的可能性时，缩小到不可能是常见的。你能想到我们如何利用TypeScript来确保我们的函数的完整性，是否应该向它添加更多的可能性(例如，如果我们去一个假设的五倍真值？)，我们应该警告未处理的情况吗？</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="9228" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用这个漂亮的小函数来实现这一点，您可以根据自己的需要进行调整:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c0da" class="ln lo it lj b gy lp lq l lr ls">function unreachable(neverValue: never){<br/>  return Error("Never get here");<br/>}</span></pre><p id="e713" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在我们需要处理所有情况的函数中，我们在底部调用这个函数:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c0ec" class="ln lo it lj b gy lp lq l lr ls">function answerQuestion(answer: FourFoldTruthValue)<br/>{<br/>  if (answer === FourFoldTruthValue.Yes){ /* ... */ }<br/>  else if (answer === FourFoldTruthValue.No){ /* ... */ }<br/>  else if (answer === FourFoldTruthValue.Both){ /* ... */ }<br/>  else if (answer === FourFoldTruthValue.Both){ /* ... */ }<br/>  else if (answer === FourFoldTruthValue.Neither){ /* ... */ }<br/>  else {<br/>    throw unreachable(answer);<br/>  }<br/>}</span></pre><p id="cd31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有当<code class="fe lu lv lw lj b">answer</code>在调用上下文中具有类型<code class="fe lu lv lw lj b">never</code>时，TypeScript才会允许这样做。<code class="fe lu lv lw lj b">never</code>只能分配给自身。一旦你添加了一个尚未处理的新的可能性，你的<code class="fe lu lv lw lj b">answer</code>类型将不再被缩小为<code class="fe lu lv lw lj b">never</code>，并且那个对<code class="fe lu lv lw lj b">unreachable</code>的调用将无效。编译时发现错误！(参见示例<a class="ae kf" href="http://www.typescriptlang.org/play/index.html?ssl=1&amp;ssc=1&amp;pln=31&amp;pc=2#code/KYOwrgtgBAYg9mATvANgEwCqLAFwBYBqAhimMAN4BQUUAmsAM4A01UAcnCzQEJz5ftgAS3zBElAL6VKAMzAgAxjiFwQUIiAYB3MQEUyDZaoCMACg3axALlgJkcdFlyESZAJSUqNITKjnNOohQALyhtkiomNj4xKTAAHT0DG7kUAD0AFRQ8TlQGWlQUjTAKAzAUD5+FoEhYfARDlHOsWTxHCnpWTnxeQVFUCVlFb7+lkGhweH2jtEucfG8+B2Z2bn5hayD5ZWjNRNTkU4xrglswqKIy11rfZul5V40UPiIcFpQ8ojARAp4RABGKGAuzEbgA3KwpFJZPIlCo1NU9AYjCAAEwgxA2erTJrHOIeR47RHjOp2Q6zFoJJJXVY9db9LbDKoBMS1SbY8nNE5tOA07q9DbFe5MjFsg6NI5zVqLPB8m6CgbCx40F5vD4gL4-P6A4HE8GQyTSOSKFHqzW-AFA0wgYAANzElJsNvtlygjy+OCQagAoohXohTAAiM4uqAAc2AOCgeDEwEDHgkQA" rel="noopener ugc nofollow" target="_blank">此处</a>)</p><h2 id="b2fe" class="ln lo it bd ly nk nl dn mc nm nn dp mg kr no np mk kv nq nr mo kz ns nt ms nu bi translated">组合互斥类型</h2><p id="4d2b" class="pw-post-body-paragraph kg kh it ki b kj ob kl km kn oc kp kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">TypeScript有<a class="ae kf" href="https://medium.com/@tar.viturawong/a-note-on-typescript-non-null-assertion-operator-bad8fbe62bba" rel="noopener">非空断言操作符</a>，它让您忽略可能为空或具体的值的<code class="fe lu lv lw lj b">null</code>方面。例如:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="c592" class="ln lo it lj b gy lp lq l lr ls">declare const foo: string|null;<br/>const concreteFoo = foo!; // concreteFoo is type string</span></pre><p id="c0ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我在链接文章中提到的，有一个奇怪的表达式，即<code class="fe lu lv lw lj b">null!</code>，它的类型是<code class="fe lu lv lw lj b">never</code>。</p><p id="a58c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，你为什么要写这种荒谬的废话？！这里反复出现的一个主题是，虽然某样东西本身看起来没什么用，但它可以成为有用作品的一部分。考虑这种情况:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="892f" class="ln lo it lj b gy lp lq l lr ls">someArray<br/>  .map(item =&gt; {<br/>    const something = /* ... something to do with item */<br/>    return something.x ? something.y : null!<br/>  })<br/>  .filter(Boolean)</span></pre><p id="834e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果将是一个元素类型与<code class="fe lu lv lw lj b">something.y</code>相同的数组。这是因为<code class="fe lu lv lw lj b">null!</code>是类型<code class="fe lu lv lw lj b">never</code>，而<code class="fe lu lv lw lj b">never</code>类型在与另一个具体类型结合时消失。(就像这样:说有两种可能性，其中一种是不可能的，就是说有一种<em class="lt">的可能性。)假设<code class="fe lu lv lw lj b">something.y</code>可以被truthiness过滤，这个贴图过滤器就相当好用了！</em></p><p id="e550" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上可能因为我们使用了<code class="fe lu lv lw lj b">null!</code>而被认为是“脏”的。事实上,“类型正确”的替代方法是:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1c3e" class="ln lo it lj b gy lp lq l lr ls">someArray<br/>  .map(item =&gt; {<br/>    const something = /* ... something to do with item */<br/>    return something.x ? something.y : null!<br/>  })<br/>  .filter((item): item is /* ... insert type */ =&gt; Boolean(item));</span><span id="1d53" class="ln lo it lj b gy nj lq l lr ls">// or alternatively<br/>  .filter(Boolean as (item): item is /* ... insert type */);</span></pre><p id="6906" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">问题是，<code class="fe lu lv lw lj b">filter</code>中的所有东西本质上都是将<code class="fe lu lv lw lj b">Boolean</code>函数正式扩充为类型保护。哪种类型的守卫？嗯……<code class="fe lu lv lw lj b">/* ... insert type */</code>型。试图以“适当”的方式做这件事的不便之处就在于此:您必须引用<code class="fe lu lv lw lj b">something.y</code>的类型。通常，当你“在事情当中”时，这样的类型可能是一个相当麻烦的表达。</p><p id="d9ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以使用<code class="fe lu lv lw lj b">null!</code>加上<code class="fe lu lv lw lj b">Boolean</code>过滤器，我们可以以一种类型安全的方式映射过滤一个数组，代码看起来简洁，TypeScript可以推断类型而不需要很多提示，<code class="fe lu lv lw lj b">null!</code>的“破坏范围”非常有限。</p><h2 id="c345" class="ln lo it bd ly nk nl dn mc nm nn dp mg kr no np mk kv nq nr mo kz ns nt ms nu bi translated">空数组</h2><p id="f277" class="pw-post-body-paragraph kg kh it ki b kj ob kl km kn oc kp kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">我要提到的<code class="fe lu lv lw lj b">never</code>最后一个奇怪的常见事件是:TypeScript将类型<code class="fe lu lv lw lj b">never[]</code>指定为空数组文字<code class="fe lu lv lw lj b">[]</code>。</p><p id="7968" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很有意义，因为一个空数组没有元素，所以元素的类型是没有意义的。</p><p id="5190" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是它可能会在临时阵列扁平化模式中给您带来惊喜。你不能用任何东西<code class="fe lu lv lw lj b">concat</code>一个<code class="fe lu lv lw lj b">never</code>的数组！</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="d1c6" class="ln lo it lj b gy lp lq l lr ls">[].concat(...arrayOfArrays); // nope!</span></pre><p id="2e44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，您需要为初始数组指定一个元素类型，以匹配您要传播的内容。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="83ec" class="ln lo it lj b gy lp lq l lr ls">new Array&lt;number&gt;().concat(...arrayOfArrays);</span></pre><p id="c085" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(<a class="ae kf" href="http://www.typescriptlang.org/play/index.html#code/CYUwxgNghgTiAEYD2A7AzgF3rGUCeA8gGYCCMueaAXPCgK4C2ARiDANoC6nA3AFC+cAdMhRgoGABSDpOfMTIU0ASn4oQAd3gL8AHnrNWAPglLhqMZOmDZhUuXzLuQA" rel="noopener ugc nofollow" target="_blank">游乐场链接此处</a>)</p><h1 id="12c1" class="lx lo it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">空接口类型{}</h1><p id="c963" class="pw-post-body-paragraph kg kh it ki b kj ob kl km kn oc kp kq kr od kt ku kv oe kx ky kz of lb lc ld im bi translated">有一种类型，有时你会看到。它没有原始名称，但可以用以下形式表示:<code class="fe lu lv lw lj b">{}</code>。</p><p id="b1f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要让一个空对象字面上的外观欺骗了你，这个类型确实<em class="lt">而不是</em>代表一个对象类型。相反，它代表了一种“空接口”类型。不是<code class="fe lu lv lw lj b">null</code>或<code class="fe lu lv lw lj b">undefined</code>的任何东西都可以分配给它。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9f5e" class="ln lo it lj b gy lp lq l lr ls">const a: {} = 2;<br/>const b: {} = false;<br/>const c: {} = {}<br/>const d: {} = Symbol();<br/>const e: {} = () =&gt; 42;<br/>const f: {} = null; // nope<br/>const g: {} = void 0; // nope</span></pre><p id="1867" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将类型为<code class="fe lu lv lw lj b">{}</code>的值赋给除了期望<code class="fe lu lv lw lj b">{}</code>、<code class="fe lu lv lw lj b">unknown</code>和<code class="fe lu lv lw lj b">any</code>的位置以外的任何位置都会失败。您不能访问它的属性(作为对象原型一部分的属性除外)，也不能调用它。本质上，作为一个界面，它完全缺乏功能。</p><p id="4942" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我第一次看到这种行为时，我得出了一个结论，即<code class="fe lu lv lw lj b">{}</code>可以用作<code class="fe lu lv lw lj b">unknown</code>的非空、非未定义的子类型——一种我们一直随意称为“具体”值的值。</p><p id="f258" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我遇到了一个问题。</p><p id="6145" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你使用<code class="fe lu lv lw lj b">{}</code>作为一个泛型约束，意图限制无效类型，当另一个泛型应用一个类型时，它将<em class="lt">而不是</em>被检查。查看以下示例:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="ca9b" class="ln lo it lj b gy lp lq l lr ls">interface WithConcreteProp&lt;T extends {}&gt;{<br/>  concrete: T;<br/>}<br/>interface WithNullableProp&lt;T&gt; extends WithConcreteProp&lt;T&gt; { }</span><span id="3c6c" class="ln lo it lj b gy nj lq l lr ls">const foo: WithConcreteProp&lt;null&gt; = {<br/>  concrete: null // nope<br/>};</span><span id="3b6b" class="ln lo it lj b gy nj lq l lr ls">const bar: WithNullableProp&lt;null&gt; = {<br/>  concrete: null // okay! ... wait... really?!<br/>};</span></pre><p id="ab54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(<a class="ae kf" href="https://www.typescriptlang.org/play/?ts=3.6.3&amp;ssl=1&amp;ssc=1&amp;pln=15&amp;pc=2#code/JYOwLgpgTgZghgYwgAgOrDACwMIHsQJQSQAKUuADgDwAqyEAHpCACYDOyA3gL4B8nAKGTIE+QsQgAuZDQDcA7gNCRYiFOiwA5AK4AbXXABGuiGUq1e9JhFYcNOMUVLlqNS52SKBokGzDIYXFxpezwCJ1MXKhA9XUsAXi4hEUcJaRj9BXkfP2RDOCgQjEwdfSMTM2oMuOREwWEfcUh02KyBARhtAjBgfDy4AC8LAApA4LRisKbI8zcASi5kZLGAOkaIlYUgA" rel="noopener ugc nofollow" target="_blank">游乐场链接此处</a>)</p><p id="1614" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意上面的<code class="fe lu lv lw lj b">WithNullableProp</code>是如何被允许扩展<code class="fe lu lv lw lj b">WithConcreteProp </code>的，即使没有<code class="fe lu lv lw lj b">{}</code>约束。<a class="ae kf" href="https://github.com/microsoft/TypeScript/issues/36124#issuecomment-573145332" rel="noopener ugc nofollow" target="_blank">证明了</a>在通用上下文中，围绕<code class="fe lu lv lw lj b">{}</code>、默认约束和<code class="fe lu lv lw lj b">null</code>的行为有点不一致。TypeScript团队似乎倾向于不管它，我明白这一点，因为弄乱<code class="fe lu lv lw lj b">null</code>会把你带到非常危险的地方。正如赫敏·格兰杰在<em class="lt">哈利·波特与阿兹卡班的囚徒</em>中所说:</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi os"><img src="../Images/2c4c12e17efdf8879369f2a8bd12e252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*YWgLdGEMLo-8EiEoi9Zsqg.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">向J.K .罗琳道歉</figcaption></figure><p id="ac02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，你不能使用<code class="fe lu lv lw lj b">{}</code>来表示“任何具体类型”作为通用约束。请注意这一点。</p><h1 id="02cd" class="lx lo it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">包扎</h1><ul class=""><li id="be32" class="ot ou it ki b kj ob kn oc kr ov kv ow kz ox ld oy oz pa pb bi translated">当您有意不确定数据类型时，请使用<code class="fe lu lv lw lj b">unknown</code>类型，并断言您的方式进入更合适的类型。这很安全。</li><li id="00af" class="ot ou it ki b kj pc kn pd kr pe kv pf kz pg ld oy oz pa pb bi translated">注意<code class="fe lu lv lw lj b">any</code>类型关闭类型检查。无论你在哪里做这件事，你都只能靠自己，但是反过来<code class="fe lu lv lw lj b">any</code>可以帮助你逐渐地将项目转换到TypeScript。</li><li id="0873" class="ot ou it ki b kj pc kn pd kr pe kv pf kz pg ld oy oz pa pb bi translated">使用<code class="fe lu lv lw lj b">undefined</code>类型表示一个<em class="lt">有意义的</em> <code class="fe lu lv lw lj b">undefined</code>值，使用<code class="fe lu lv lw lj b">void</code>类型表示缺少一个有意义的值——这是某人说“答案是……没什么”和“我对你无话可说”之间的区别。</li><li id="97ca" class="ot ou it ki b kj pc kn pd kr pe kv pf kz pg ld oy oz pa pb bi translated">当你遇到<code class="fe lu lv lw lj b">never</code>时，要明白你正在处理一个不可能的案子。当你想确保每一种可能性都被考虑在内时，你可能希望利用它来增加额外的安全性。</li><li id="2079" class="ot ou it ki b kj pc kn pd kr pe kv pf kz pg ld oy oz pa pb bi translated"><code class="fe lu lv lw lj b">{}</code>型可以认为是排除了<code class="fe lu lv lw lj b">null</code>和<code class="fe lu lv lw lj b">undefined</code>的<code class="fe lu lv lw lj b">unknown</code>。然而，这只是我的经验观察，它至少不会像一般约束那样工作。</li></ul><p id="bf03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript应用了许多有用的概念，这些概念既来自良好的理论基础，如top和bottom类型，也来自改善开发人员体验的实用动机。我们已经介绍了元类型是如何体现这些概念的，希望你现在也能够很好地理解和使用它们。</p><p id="49ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">祝大家打字愉快！</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><p id="aa0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lt">解决</em> <code class="fe lu lv lw lj b"><em class="lt">async</em></code> <em class="lt">函数之谜:一个</em> <code class="fe lu lv lw lj b"><em class="lt">async</em></code> <em class="lt">函数即使注定抛出异常，也总是返回一个</em> <code class="fe lu lv lw lj b"><em class="lt">Promise</em></code> <em class="lt">。</em> <a class="ae kf" href="https://www.typescriptlang.org/play/?ts=3.6.3#code/IYZwngdgxgBAZgV2gFwJYHsIwCbvQWwAoBKGAbwCgYYpMR0AbAUwDoH0BzQgIgEkYA7qgYMYTAB4AHdtibdiAbioxkACwBO6ATACi6zep64C8pQF8KtCPWZtOPUJFiIUGLOqbIE669wA0OHhExIqWdIys7Fx8AOT4MCBoIjDADKgAbkwA-ACEpkA" rel="noopener ugc nofollow" target="_blank">见此处<em class="lt"/></a><em class="lt">。如果你想知道为什么会这样，“JavaScript事件循环”是你的谷歌搜索查询。又是一个自己的大话题！</em></p><p id="0143" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也就是说，<em class="lt">运行到</em>同步<em class="lt">无限循环中的</em> <code class="fe lu lv lw lj b"><em class="lt">async</em></code> <em class="lt">函数当然不会返回。但是任何同步无限循环都违背了JavaScript事件循环的基本原则。所以TypeScript，在我看来，做了明智的事情，打折了这样一个实例，反而坚持所有的</em> <code class="fe lu lv lw lj b"><em class="lt">async</em></code> <em class="lt">函数都返回一个</em> <code class="fe lu lv lw lj b"><em class="lt">Promise</em></code> <em class="lt">。</em></p></div></div>    
</body>
</html>