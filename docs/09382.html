<html>
<head>
<title>Guide to PostgreSQL Cursors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL游标指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/guide-to-postgresql-cursors-e3524fef8f16?source=collection_archive---------7-----------------------#2021-08-03">https://levelup.gitconnected.com/guide-to-postgresql-cursors-e3524fef8f16?source=collection_archive---------7-----------------------#2021-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d284" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探究游标在PostgreSQL中的工作方式。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ec94490434905a0f086716e9cf150302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zv6f86_WQHIQNE3wU7TfSw.png"/></div></div></figure><p id="4254" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">数据库游标是一个指针，它允许用户以基于行的顺序迭代查询结果。通常，游标可以定义为不同的属性:“只读”与“可更新”，“只进”与“可滚动”，以及“敏感”与“不敏感”。我们将讨论与PostgreSQL相关的这些属性以及它们如何在内部工作。</p><p id="de4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以使用具有以下语法的<code class="fe lo lp lq lr b">DECLARE</code>子句来定义<a class="ae ln" href="https://www.postgresql.org/docs/13/sql-declare.html" rel="noopener ugc nofollow" target="_blank">游标</a>:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="98b7" class="lw lx iq lr b gy ly lz l ma mb">DECLARE <strong class="lr ir"><em class="mc">name</em></strong> [ BINARY ] [ ASENSITIVE | INSENSITIVE ] [ [ NO ] SCROLL ]<br/>    CURSOR [ { WITH | WITHOUT } HOLD ] FOR <strong class="lr ir"><em class="mc">query</em></strong></span></pre><p id="0213" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mc">查询</em>首先被规划器/优化器解析成查询树。然后，执行器将处理查询树并逐步返回结果，如这里的<a class="ae ln" href="https://www.postgresql.org/docs/13/executor.html" rel="noopener ugc nofollow" target="_blank">和</a>所述。</p><p id="c1a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每次发出一个<code class="fe lo lp lq lr b">FETCH</code>命令，执行器都会运行一次查询树的顶层节点。它将递归地运行它的后代，最终，顶部节点将返回结果集的下一行。这个过程可以迭代地进行，直到查询结果用尽并且顶部节点返回NULL。(注意:该过程由源文件“execMain.c”中定义的<code class="fe lo lp lq lr b">ExecutionRun()</code>过程处理。)</p><h2 id="d916" class="lw lx iq bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms mt bi translated">灵敏度</h2><p id="1746" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">SQL:2016标准中定义的光标敏感度:</p><blockquote class="mz na nb"><p id="fa14" class="kr ks mc kt b ku kv jr kw kx ky ju kz nc lb lc ld nd lf lg lh ne lj lk ll lm ij bi translated">如果游标是打开的，并且打开游标<br/>的SQL-transaction对SQL-data进行了重大更改，那么<br/>在游标关闭之前是否可以通过该游标看到该更改由下面的<br/>确定:</p><p id="6edf" class="kr ks mc kt b ku kv jr kw kx ky ju kz nc lb lc ld nd lf lg lh ne lj lk ll lm ij bi translated">—如果光标不敏感，则重大变化<br/>不可见。<br/> —如果光标敏感，则明显变化<br/>可见。<br/> —如果光标是敏感的，那么显著的<br/>变化的可见性是依赖于实现的。</p></blockquote><p id="4eec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在撰写本文时，PostgreSQL仅支持不敏感游标。这意味着在声明游标之后，在同一事务中对原始表所做的更改将不可见。因此，指定<code class="fe lo lp lq lr b">ASENSITIVE</code>或<code class="fe lo lp lq lr b">INSENSITIVE</code>没有任何作用。</p><p id="79b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事实上，当游标打开时(即声明游标时)，将创建表的快照。在<code class="fe lo lp lq lr b">Fetch</code>期间，每次调用executor之前，cursor portal都会加载快照。它只会在执行器完成处理后弹出快照。(注:这个可以从<code class="fe lo lp lq lr b">SPI_cursor_open_internal()</code>和<code class="fe lo lp lq lr b">PortalRunSelect()</code>看出来。)</p><h2 id="7bef" class="lw lx iq bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms mt bi translated">可更新性</h2><p id="3d34" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">通过在<em class="mc">查询</em>的末尾添加一个<code class="fe lo lp lq lr b">FOR UPDATE</code>或<code class="fe lo lp lq lr b">FOR SHARE</code>，可以使游标可更新。这将在更新/读取一行时，分别给<code class="fe lo lp lq lr b">SELECT</code>语句一个来自其他并发事务的排他锁或共享锁。当我们想要使用<code class="fe lo lp lq lr b">{UPDATE | DELETE} … WHERE CURRENT OF &lt;cursor_name&gt;</code>通过游标更新或删除原始表中的行时，它们非常有用。</p><p id="a71a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请记住，游标可更新性与SQL:2014标准略有不同。在PostgreSQL中，对原始表的任何更新/删除，甚至那些使用<code class="fe lo lp lq lr b">{UPDATE | DELETE} … WHERE CURRENT OF &lt;cursor_name&gt;</code>语句生成的<em class="mc">到</em>不敏感游标，在同一游标中都是不可见的。这是因为快照是在游标打开时创建的，如上所述，远在更改发生之前。</p><h2 id="2ad0" class="lw lx iq bd md me mf dn mg mh mi dp mj la mk ml mm le mn mo mp li mq mr ms mt bi translated">可滚动性</h2><p id="ddc1" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">如果光标用<code class="fe lo lp lq lr b">SCROLL</code>指定，则可以用于向前(即下一行)和向后(即上一行)检索行。</p><p id="7eef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着执行器必须能够反向获取行。根据查询计划，可能需要在查询树的顶部附加一个物化节点来支持向后提取。Materialize节点将所有提取的行存储到一个名为tuplestore的临时存储中，这允许以后再次访问前面的行。</p><p id="0830" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果提取的行的总大小低于指定值，tuplestore会将它们存储到内存数组中。否则，它会将行存储到磁盘上的一个临时文件中。除了支持向后获取，它还允许在查询结果中进行有效的随机访问，因为它避免了执行程序扫描大量行以到达所需行的需要。</p><p id="10df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当指定了<code class="fe lo lp lq lr b">WITH HOLD</code>时，在创建游标的事务成功提交后，可以继续引用和使用游标。在声明holdable游标时，查询将运行到完成，并将行转储到tuplestore中。每当在下一个事务中发出一个<code class="fe lo lp lq lr b">FETCH</code>命令时，它将从tuplestore中检索一行。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="18b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在内部，每当通过<code class="fe lo lp lq lr b">DECLARE</code>打开光标时，就会创建一个新的门户。门户只是对光标执行状态的抽象，将根据<em class="mc">查询</em>采取不同的执行策略。一些相关的例子是:</p><ol class=""><li id="5462" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">如果<em class="mc">查询</em>包含一个单独的<code class="fe lo lp lq lr b">SELECT</code>语句，那么执行程序将会运行，并且每次发出<code class="fe lo lp lq lr b">FETCH</code>命令都会返回一个新行。</li><li id="690f" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">如果<em class="mc">查询</em>包含一个带有<code class="fe lo lp lq lr b">RETURNING</code>子句的<code class="fe lo lp lq lr b">INSERT</code> / <code class="fe lo lp lq lr b">UPDATE</code> / <code class="fe lo lp lq lr b">DELETE</code>查询，执行程序将执行更新/插入/删除操作直到完成，并将查询结果转储到tuplestore中。当发出<code class="fe lo lp lq lr b">FETCH</code>命令时，将从tuplestore中读取该行。</li><li id="7eae" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">如果<em class="mc">查询</em>包含实用程序语句(例如<code class="fe lo lp lq lr b">EXPLAIN</code>或<code class="fe lo lp lq lr b">SHOW</code>)，它将运行该语句直到完成，并将查询结果转储到tuplestore中。类似地，当发出<code class="fe lo lp lq lr b">FETCH</code>时，将从tuplestore中读取row。</li></ol></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="e93b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">引用的源代码文件:</strong></p><ul class=""><li id="d6ca" class="nm nn iq kt b ku kv kx ky la no le np li nq lm oa ns nt nu bi translated"><a class="ae ln" href="https://doxygen.postgresql.org/execMain_8c_source.html" rel="noopener ugc nofollow" target="_blank"> PostgreSQL源代码:src/back end/executor/execmain . c源文件</a></li><li id="8cc5" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm oa ns nt nu bi translated"><a class="ae ln" href="https://doxygen.postgresql.org/spi_8c_source.html" rel="noopener ugc nofollow" target="_blank"> PostgreSQL源代码:src/backend/executor/spi.c源文件</a></li><li id="c5ad" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm oa ns nt nu bi translated"><a class="ae ln" href="https://doxygen.postgresql.org/portal_8h_source.html" rel="noopener ugc nofollow" target="_blank"> PostgreSQL源代码:src/include/utils/portal.h源文件</a></li><li id="d0d0" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm oa ns nt nu bi translated"><a class="ae ln" href="https://doxygen.postgresql.org/pquery_8c_source.html#l00430" rel="noopener ugc nofollow" target="_blank"> PostgreSQL源代码:src/backend/tcop/pquery.c源文件</a></li><li id="6a0f" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm oa ns nt nu bi translated"><a class="ae ln" href="https://doxygen.postgresql.org/tuplestore_8c_source.html#l01233" rel="noopener ugc nofollow" target="_blank"> PostgreSQL源代码:src/back end/utils/sort/tuple store . c源文件</a></li></ul></div></div>    
</body>
</html>