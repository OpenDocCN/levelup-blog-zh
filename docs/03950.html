<html>
<head>
<title>Integrating Native C/C++ libraries with Unity as Plugins (A step by step guide)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将本机C/C++库与Unity集成为插件(逐步指南)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/integrating-native-c-c-libraries-with-unity-as-plugins-a-step-by-step-guide-17ad70c2e3b4?source=collection_archive---------2-----------------------#2020-06-03">https://levelup.gitconnected.com/integrating-native-c-c-libraries-with-unity-as-plugins-a-step-by-step-guide-17ad70c2e3b4?source=collection_archive---------2-----------------------#2020-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6c3d1d9fa5bb80f8283c68cfb6085a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XfzsQB7B971RR1TlFQ2CTA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我的开发设置(R.I.P Dad)</figcaption></figure><p id="60dd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi la translated"><span class="l lb lc ld bm le lf lg lh li di">作为中央阿肯色大学计算机科学系<a class="ae lj" href="https://uca.edu/computerscience/" rel="noopener ugc nofollow" target="_blank">的<strong class="ke ir"> </strong> </a><a class="ae lj" href="http://sun0.cs.uca.edu/~thalic/virasim.html" rel="noopener ugc nofollow" target="_blank">虚拟现实、模拟、成像和建模(ViRaSIM)实验室</a>的研究生研究助理，我正与软件工程师和分别来自<a class="ae lj" href="https://www.kitware.com/" rel="noopener ugc nofollow" target="_blank"> Kitware </a>和<a class="ae lj" href="https://www.rpi.edu/" rel="noopener ugc nofollow" target="_blank"> Rensselaer理工学院(RPI) </a>的研究人员一起开发一个虚拟肩袖关节镜技能训练器(ViRCAST ),以使用<a class="ae lj" href="https://www.imstk.org/" rel="noopener ugc nofollow" target="_blank">交互式医学模拟来虚拟模拟关节镜肩袖修复手术</a></span></p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lk"><img src="../Images/36e415b5925d0730bbdc3c4097a70d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7j16k-1odVUrjFm9ICWksA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">手术模拟概述</figcaption></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><blockquote class="lw lx ly"><p id="e841" class="kc kd lz ke b kf kg kh ki kj kk kl km ma ko kp kq mb ks kt ku mc kw kx ky kz ij bi translated"><a class="ae lj" href="https://www.imstk.org/" rel="noopener ugc nofollow" target="_blank">交互式医疗模拟工具包(iMSTK) </a>是一个免费的&amp;开源软件工具包，用C++编写，有助于交互式多模式手术模拟的快速原型制作。</p></blockquote><p id="7f1f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了开发虚拟肩袖关节镜技能训练器(ViRCAST)，我们决定编写插件，以允许手术模拟社区使用<a class="ae lj" href="https://www.imstk.org/" rel="noopener ugc nofollow" target="_blank">交互式医疗模拟工具包(iMSTK) </a>和<a class="ae lj" href="https://unity.com/" rel="noopener ugc nofollow" target="_blank"> Unity </a>。</p><p id="2ce0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我的职责是为<a class="ae lj" href="https://www.3dsystems.com/haptics-devices/touch" rel="noopener ugc nofollow" target="_blank">触觉设备</a>开发动态链接库(dll ),以便通过<a class="ae lj" href="https://unity.com/" rel="noopener ugc nofollow" target="_blank"> Unity </a>与<a class="ae lj" href="https://www.imstk.org/" rel="noopener ugc nofollow" target="_blank">交互式医疗模拟工具包(iMSTK) </a>进行通信。</p><p id="e176" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，我不得不学习什么是dll，如何创建和使用它们。</p><p id="f715" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi la translated"><span class="l lb lc ld bm le lf lg lh li di"> T </span>这篇文章是为了展示我在编写触觉设备dll与<a class="ae lj" href="https://www.imstk.org/" rel="noopener ugc nofollow" target="_blank">交互式医疗模拟工具包(iMSTK) </a>到<a class="ae lj" href="https://unity.com/" rel="noopener ugc nofollow" target="_blank"> Unity </a>通信之前，在Unity中开发和使用dll的步骤。</p><blockquote class="lw lx ly"><p id="291d" class="kc kd lz ke b kf kg kh ki kj kk kl km ma ko kp kq mb ks kt ku mc kw kx ky kz ij bi translated">触觉设备(或触觉接口)是在用户和计算机之间传递信息的机械设备。触觉设备允许用户在虚拟环境和远程操作系统中触摸、感觉和操纵三维物体。</p></blockquote><h1 id="02b7" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated"><em class="nb">总结</em></h1><p id="80f8" class="pw-post-body-paragraph kc kd iq ke b kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz ij bi translated">在本文中，我将讨论如何使用dll来运行Unity中的C/C++代码。插件用于包含在Unity平台之外创建的代码。这背后的目的是将C/C++代码与Unity集成，以便我们能够从Unity C#脚本中调用C/C++编写的函数。除了插件，我还会讲解动态链接库(DLL)的使用。这些库包含Unity等第三方应用程序可以使用的代码和数据。使用DLL可以促进代码重用和有效的内存使用。这种技术也允许将Unity程序模块化成独立的组件，每个组件都可以根据需要使用。本文还介绍了一种简单的方法，使用外部编译器编译我的原生C/C++代码，然后将生成的DLL添加到Unity项目中。</p><h1 id="39b6" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">介绍</h1><p id="60a4" class="pw-post-body-paragraph kc kd iq ke b kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz ij bi translated">Unity <em class="lz"> </em>是一款游戏引擎和集成开发工具，用于开发模拟、实时3D动画和视频游戏等程序和应用。Unity <em class="lz"> </em>提供多种功能来支持所有类型的游戏开发需求，例如着色器、网络、地图和地形处理、物理引擎和视频/音频。虽然Unity基于C#脚本开发应用程序，但它也提供了两种插件，允许用户包含外部创建的代码和使用不同编程语言编写的代码。Unity提供了两种类型的插件:<em class="lz">托管插件</em>和<em class="lz">原生插件。</em></p><p id="9b1f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="lz">托管插件</em>被托管。使用第三方工具创建的. NET程序集，通常包含。只能访问. NET代码。NET支持的库。</p><p id="dda6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="lz">原生插件</em>是特定于平台的原生代码库。它们用于访问第三方代码库，否则Unity通常无法访问这些库。</p><p id="3fa6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本文主要关注本机插件。我将解释一种简单的方法，使用本地插件来允许我们的Unity代码(C#)从现有的C/C++代码中调用函数。Unity用户将能够应用这种技术来使用C#与他们的C/C++函数进行交互。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/cce3c4223877dcd1194c2915b4cec24e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*neH6j4UKKuuIDLYu9ZizhA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb">使用插件链接本机C/C++库和unity的架构</em></figcaption></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="802a" class="md me iq bd mf mg ni mi mj mk nj mm mn mo nk mq mr ms nl mu mv mw nm my mz na bi translated">动态链接库</h1><p id="9c0d" class="pw-post-body-paragraph kc kd iq ke b kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz ij bi translated">DLL文件(<em class="lz">动态链接库)</em>是一种包含其他程序使用的数据和指令的文件，可以在需要时调用。DLL文件允许多个程序同时共享函数和类。与可执行程序不同，DLL文件不能直接运行，而是必须由其他程序调用。</p><p id="db32" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">单词“<em class="lz"> dynamic </em>”用于解释数据并不总是存在于内存中，它只是在程序主动调用它时才被使用。DLL文件允许将程序分成多个独特的组件，然后可以添加或删除这些组件以包含或排除某些功能。这非常有用，因为它降低了内存的使用，因为程序不需要一次加载所有的东西。</p><p id="ea2b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">C和C++</p><p id="54fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Microsoft Visual C++为标准C++提供了多种扩展，允许在C++代码中将函数和类指定为直接导入或导出。这些扩展在函数或类声明前使用属性<em class="lz"> __declspec </em>。</p><p id="5d4f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，当从C++访问C函数或类时，函数必须在C++代码中声明为extern“C ”,以通知编译器不要<em class="lz">篡改</em>函数或类名，而是使用“C”链接。</p><p id="a04e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为C++支持函数重载，我们可以用相同的名字和不同的参数声明多个函数。然后，我们需要向编译器提供关于函数名的附加信息，以避免未定义的引用错误或链接错误(因为C不支持<em class="lz">函数重载</em>)。</p><p id="6af6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里的解决方案是在我们的C++程序中指定extern“C”。当编译器找到一个extern“C”块时，它确保函数名不会被破坏——编译器会发出一个名称不变的二进制文件，就像“C”编译器会做的那样。这些额外的信息允许我们避免二进制代码中的链接问题和冲突。</p><h1 id="76f0" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">创建dll</h1><p id="eb10" class="pw-post-body-paragraph kc kd iq ke b kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz ij bi translated">下面的例子是使用Visual Studio 2019创建和构建一个简单的DLL。</p><ul class=""><li id="9b53" class="nn no iq ke b kf kg kj kk kn np kr nq kv nr kz ns nt nu nv bi translated">打开Visual Studio并创建一个新项目。要指定这是一个DLL，我们需要选择“带有导出的动态链接库(DLL)”</li></ul><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/bc3f62c28d6381033434ec19d7eaf43b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Luynb2qs9fmpRCI9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb">微软Visual Studio 2019 —新项目</em></figcaption></figure><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/75d53a47e638d1208006e77de141dee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OAtsSM7MCgd5Y_Le"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb">微软Visual Studio 2019 — DLL项目</em></figcaption></figure><ul class=""><li id="d682" class="nn no iq ke b kf kg kj kk kn np kr nq kv nr kz ns nt nu nv bi translated">在为我们的项目选择了一个名称和一个保存位置之后。我们继续打开生成的“头文件”文件夹([ProjectName])。h文件):</li></ul><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c3768c6b5659fb4733ec4e41d3c03743.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/0*MSBQC6kuhObC4NtL"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb">微软Visual Studio 2019 —解决方案资源管理器</em></figcaption></figure><pre class="ll lm ln lo gt nz oa ob oc aw od bi"><span id="0ea0" class="oe me iq oa b gy of og l oh oi">NativeCppLibrary.h:</span><span id="62b0" class="oe me iq oa b gy oj og l oh oi">/* The following ifdef block is the standard way of creating macros which make exporting from a DLL simpler. All files within this DLL are compiled with the NATIVECPPLIBRARY_EXPORTS symbol defined on the command line. This symbol should not be defined on any project that uses this DLL. This way any other project whose source files include this file see NATIVECPPLIBRARY_API functions as being imported from a DLL, whereas this DLL sees symbols defined with this macro as being exported.<br/>*/</span><span id="ff59" class="oe me iq oa b gy oj og l oh oi">#ifdef NATIVECPPLIBRARY_EXPORTS<br/>#define NATIVECPPLIBRARY_API __declspec(dllexport)<br/>#else<br/>#define NATIVECPPLIBRARY_API __declspec(dllimport)# endif</span><span id="2111" class="oe me iq oa b gy oj og l oh oi">// This class is exported from the dll</span><span id="148b" class="oe me iq oa b gy oj og l oh oi">class NATIVECPPLIBRARY_API CNativeCppLibrary {</span><span id="4cc1" class="oe me iq oa b gy oj og l oh oi">   public: CNativeCppLibrary(void);</span><span id="3796" class="oe me iq oa b gy oj og l oh oi">// TODO: add your methods here.</span><span id="8a74" class="oe me iq oa b gy oj og l oh oi">};</span><span id="bb15" class="oe me iq oa b gy oj og l oh oi">extern NATIVECPPLIBRARY_API int nNativeCppLibrary;</span><span id="74f6" class="oe me iq oa b gy oj og l oh oi">       NATIVECPPLIBRARY_API int fnNativeCppLibrary(void);</span></pre><p id="38f6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">头文件(<em class="lz">nativecplibrary . h)</em>将用于声明我们所有的类和函数。</p><p id="7a25" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们定义一个C++宏，它为第三方应用程序(Unity)导出函数，这些应用程序将使用DLL来访问函数和类。这个块被称为条件组。</p><p id="1e57" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以删除类和函数的例子，因为我们将为测试编写自己的函数。</p><p id="a5af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以将这些功能定义为一行或一个块。</p><pre class="ll lm ln lo gt nz oa ob oc aw od bi"><span id="0a60" class="oe me iq oa b gy of og l oh oi">// Single line function declarations</span><span id="12ea" class="oe me iq oa b gy oj og l oh oi">extern “C” NATIVECPPLIBRARY_API int displayNumber();</span><span id="df38" class="oe me iq oa b gy oj og l oh oi">extern “C” NATIVECPPLIBRARY_API int getRandom();</span><span id="cbbc" class="oe me iq oa b gy oj og l oh oi">extern “C” NATIVECPPLIBRARY_API int displaySum();<br/></span><span id="011f" class="oe me iq oa b gy oj og l oh oi">// Block declarations</span><span id="7944" class="oe me iq oa b gy oj og l oh oi">extern “C” {</span><span id="5ce7" class="oe me iq oa b gy oj og l oh oi">NATIVECPPLIBRARY_API int displayNumber();</span><span id="150d" class="oe me iq oa b gy oj og l oh oi">NATIVECPPLIBRARY_API int getRandom();</span><span id="3856" class="oe me iq oa b gy oj og l oh oi">NATIVECPPLIBRARY_API int displaySum();</span><span id="77ae" class="oe me iq oa b gy oj og l oh oi">}</span></pre><p id="faaa" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们创建了三个简单的函数。第一个显示一个数字，第二个显示一个随机数，第三个将两个数字相加。</p><p id="8cca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，我们使用extern“C”来避免上面讨论的名称混淆。</p><p id="4f3d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在解决方案资源管理器中，打开[ProjectName.cpp]文件:</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/337c2c920e0efbdcb14a2ee94da38d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/0*u2IITVfbXUWreUMB"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb">微软Visual Studio 2019 —解决方案浏览器</em></figcaption></figure><pre class="ll lm ln lo gt nz oa ob oc aw od bi"><span id="ba5a" class="oe me iq oa b gy of og l oh oi">NativeCppLibrary.cpp:</span><span id="a436" class="oe me iq oa b gy oj og l oh oi">/* NativeCppLibrary.cpp : Defines the exported functions for the DLL.</span><span id="dfd1" class="oe me iq oa b gy oj og l oh oi">*/</span><span id="6228" class="oe me iq oa b gy oj og l oh oi">#include “pch.h”</span><span id="b1e9" class="oe me iq oa b gy oj og l oh oi">#include “framework.h”</span><span id="e143" class="oe me iq oa b gy oj og l oh oi">#include “NativeCppLibrary.h”<br/></span><span id="284f" class="oe me iq oa b gy oj og l oh oi">// This is an example of an exported variable</span><span id="367f" class="oe me iq oa b gy oj og l oh oi">NATIVECPPLIBRARY_API int nNativeCppLibrary = 0;<br/></span><span id="1061" class="oe me iq oa b gy oj og l oh oi">// This is an example of an exported function.</span><span id="6b0d" class="oe me iq oa b gy oj og l oh oi">NATIVECPPLIBRARY_API int fnNativeCppLibrary(void) {</span><span id="32ef" class="oe me iq oa b gy oj og l oh oi">    return 0;</span><span id="8dfb" class="oe me iq oa b gy oj og l oh oi">}</span><span id="c9e0" class="oe me iq oa b gy oj og l oh oi">// This is the constructor of a class that has been exported.</span><span id="a1dc" class="oe me iq oa b gy oj og l oh oi">CNativeCppLibrary::CNativeCppLibrary() {}</span></pre><ul class=""><li id="df49" class="nn no iq ke b kf kg kj kk kn np kr nq kv nr kz ns nt nu nv bi translated">让我们删除示例函数，并基于头文件创建我们自己的函数。</li></ul><pre class="ll lm ln lo gt nz oa ob oc aw od bi"><span id="0e58" class="oe me iq oa b gy of og l oh oi">/* NativeCppLibrary.cpp : Defines the exported functions for the DLL.</span><span id="5cb6" class="oe me iq oa b gy oj og l oh oi">*/<br/></span><span id="871b" class="oe me iq oa b gy oj og l oh oi">#include “pch.h”</span><span id="973e" class="oe me iq oa b gy oj og l oh oi">#include “framework.h”</span><span id="410a" class="oe me iq oa b gy oj og l oh oi">#include “NativeCppLibrary.h”<br/></span><span id="17dd" class="oe me iq oa b gy oj og l oh oi">// Standard Library imports</span><span id="c762" class="oe me iq oa b gy oj og l oh oi">#include &lt;iostream&gt;<br/></span><span id="5ad7" class="oe me iq oa b gy oj og l oh oi">int displayNumber() {</span><span id="2f0b" class="oe me iq oa b gy oj og l oh oi">  return 1;</span><span id="18dc" class="oe me iq oa b gy oj og l oh oi">}</span><span id="c8a0" class="oe me iq oa b gy oj og l oh oi">int getRandom() {</span><span id="425a" class="oe me iq oa b gy oj og l oh oi">  return rand();</span><span id="2b2e" class="oe me iq oa b gy oj og l oh oi">}</span><span id="f4c5" class="oe me iq oa b gy oj og l oh oi">int displaySum() {</span><span id="10f3" class="oe me iq oa b gy oj og l oh oi">   int first_number = 7;</span><span id="c962" class="oe me iq oa b gy oj og l oh oi">   int second_number = 7;</span><span id="c230" class="oe me iq oa b gy oj og l oh oi">   int total = first_number + second_number;</span><span id="5466" class="oe me iq oa b gy oj og l oh oi">}</span></pre><p id="5306" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们有了测试函数。让我们构建我们的解决方案，但在此之前，我们需要确保我们构建的是正确的预期64位架构。我们需要为x64平台(64位)编译我们的库。</p><p id="a584" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要在Visual Studio中更改这一点，我们可以转到配置管理器，然后在“平台”下选择x64，或者只需从顶部的下拉菜单中选择x64。</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/6b461437aaf334f27d2eeeec129e9c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ic09cUnAS3g57LY5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb">微软Visual Studio 2019 —选择正确的架构</em></figcaption></figure><ul class=""><li id="9b3a" class="nn no iq ke b kf kg kj kk kn np kr nq kv nr kz ns nt nu nv bi translated">将C/C++代码构建到dll中</li></ul><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/c42e8829d781df90daa6f49c31bf9f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/0*VhTJrs1K3IIOzGy2"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb">微软Visual Studio 2019 —构建过程</em></figcaption></figure><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/60b9a8fe58bee9e53aeb27801097a06e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d4dlca9ixjseEeeJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb">微软Visual Studio 2019 —构建控制台</em></figcaption></figure><p id="1114" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的解决方案构建成功</p><ul class=""><li id="7e66" class="nn no iq ke b kf kg kj kk kn np kr nq kv nr kz ns nt nu nv bi translated">获取生成的dll</li></ul><p id="c063" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要轻松访问生成的dll，请在解决方案资源管理器中右键单击您的解决方案，然后选择“在文件资源管理器中打开文件夹”</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/99d1882c6f29182b05abcf534d11c1c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/0*PyZmKCE7WY4oA_TM"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb">微软Visual Studio 2019 —文件浏览器</em></figcaption></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="fccc" class="md me iq bd mf mg ni mi mj mk nj mm mn mo nk mq mr ms nl mu mv mw nm my mz na bi translated">在Unity中使用原生dll</h1><ul class=""><li id="abf2" class="nn no iq ke b kf nc kj nd kn op kr oq kv or kz ns nt nu nv bi translated">创建新的Unity项目或打开现有项目:</li></ul><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/44f23fc4fdf6e70ab31d28704457435f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tVGyfgARZpPHql30"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb"> Unity — Hub </em></figcaption></figure><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ot"><img src="../Images/60e8e70f39cc7cc2d028fbe4ee824781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7JCeI0NM_PCIMY-L"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb"> Unity —项目窗口</em></figcaption></figure><ul class=""><li id="56b7" class="nn no iq ke b kf kg kj kk kn np kr nq kv nr kz ns nt nu nv bi translated">首先，如果我们在Unity项目中创建一个插件文件夹来重组我们所有的dll会更容易。这可以通过右击我们的场景-&gt;创建-&gt;文件夹来完成。将文件夹命名为:“插件”。</li></ul><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/e18fe6e92e3aafbed2eea1c5d87fa544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/0*Bhp269QD4UlamL1p"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb"> Unity —创建新文件夹</em></figcaption></figure><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/97cd06c52034c9a08c6c6ebbba3b3db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/0*xWN34tmjZFiXlqqL"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb"> Unity —文件浏览器</em></figcaption></figure><ul class=""><li id="563e" class="nn no iq ke b kf kg kj kk kn np kr nq kv nr kz ns nt nu nv bi translated">然后，我们可以将我们创建的DLL文件复制到Unity plugins文件夹中。</li></ul><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/3d55268d3e85ab79bbb641fba624ff91.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/0*vQqJ0llo4X0RcA_7"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb"> Unity — DLL文件</em></figcaption></figure><ul class=""><li id="2ead" class="nn no iq ke b kf kg kj kk kn np kr nq kv nr kz ns nt nu nv bi translated">我们的下一步是给我们的主摄像头添加一个新的C#脚本。这个C#脚本将用于访问我们创建的三个C++函数。</li></ul><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ox"><img src="../Images/12edf8cbb3c548a7fe020e7ac50cd4c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/0*wNQgIJopCj1U6QXG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb"> Unity —添加组件</em></figcaption></figure><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/b1d943e6be049fc197bb2c617bfe0fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/0*l0NmZ36k0i97SoJ6"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb"> Unity— C#脚本</em></figcaption></figure><ul class=""><li id="86d5" class="nn no iq ke b kf kg kj kk kn np kr nq kv nr kz ns nt nu nv bi translated">在C#中调用本机C/C++函数</li></ul><p id="b0fc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">双击脚本将其打开。</p><p id="5281" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们需要加上“使用系统。运行时. InteropServices"允许我们在函数声明中使用“extern”修饰符。</p><p id="6c07" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们定义DLL入口点，这可以使用DLLImport注释来完成。我们需要指定DLL的名称和函数的名称。EntryPoint中使用的字符串必须与C++库中使用的名称匹配。我们决定，如果我们也在DllImport下定义每个函数，会更容易。但是，您可以按照自己的方式调用函数；从现在开始C#就这么叫它了。</p><p id="be45" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用[DllImport]属性标记为extern的方法通常是对C librarires的调用。当调用WindowsAPI(WinAPI)或遗留代码时，记住这一点很有用。</p><p id="6311" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在方法声明中指定extern修饰符表示该方法是在外部实现的。我们的C++函数调用是用那个属性来管理的。</p><p id="6fb6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每个新的C#文件还包括两个函数Start()和Update()。当在第一次调用任何Update()函数之前启用脚本时，会调用Start()函数。因为我们希望在运行Unity应用程序时只调用一次函数，所以我们可以忽略Update()方法，并将其从脚本中删除。</p><p id="8ea3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="lz">nativecpplibraryintegration . cs脚本</em></p><pre class="ll lm ln lo gt nz oa ob oc aw od bi"><span id="c1a9" class="oe me iq oa b gy of og l oh oi">using System.Collections;</span><span id="8ba6" class="oe me iq oa b gy oj og l oh oi">using System.Collections.Generic;</span><span id="78e2" class="oe me iq oa b gy oj og l oh oi">using UnityEngine;</span><span id="e28d" class="oe me iq oa b gy oj og l oh oi">using System.Runtime.InteropServices;<br/></span><span id="803e" class="oe me iq oa b gy oj og l oh oi">public class NativeCppLibraryIntegration: MonoBehaviour {<br/></span><span id="eb45" class="oe me iq oa b gy oj og l oh oi">// Import and expose native c++ functions</span><span id="077f" class="oe me iq oa b gy oj og l oh oi">[DllImport(“NATIVECPPLIBRARY”, EntryPoint = “displayNumber”)]</span><span id="d20f" class="oe me iq oa b gy oj og l oh oi">public static extern int displayNumber();<br/></span><span id="e90a" class="oe me iq oa b gy oj og l oh oi">[DllImport(“NATIVECPPLIBRARY”, EntryPoint = “getRandom”)]</span><span id="a4d6" class="oe me iq oa b gy oj og l oh oi">public static extern int getRandom();<br/></span><span id="56e4" class="oe me iq oa b gy oj og l oh oi">[DllImport(“NATIVECPPLIBRARY”, EntryPoint = “displaySum”)]</span><span id="dcc5" class="oe me iq oa b gy oj og l oh oi">public static extern int displaySum();<br/></span><span id="aeb3" class="oe me iq oa b gy oj og l oh oi">// Start is called before the first frame update</span><span id="f68f" class="oe me iq oa b gy oj og l oh oi">void Start() {</span><span id="70f4" class="oe me iq oa b gy oj og l oh oi">  // Display output of functions</span><span id="1602" class="oe me iq oa b gy oj og l oh oi">  print(displayNumber());</span><span id="ca9f" class="oe me iq oa b gy oj og l oh oi">  print(getRandom());</span><span id="fd08" class="oe me iq oa b gy oj og l oh oi">  print(displaySum());</span><span id="d20a" class="oe me iq oa b gy oj og l oh oi">  }</span><span id="778b" class="oe me iq oa b gy oj og l oh oi">}</span></pre><ul class=""><li id="7f3e" class="nn no iq ke b kf kg kj kk kn np kr nq kv nr kz ns nt nu nv bi translated">测试</li></ul><p id="37c0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们只需在Unity中运行我们的程序，并接收包含在Unity start()函数中的打印语句的结果:</p><p id="fd9d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">结果:</p><figure class="ll lm ln lo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ot"><img src="../Images/4d00dd0a0ad141b2b47f12546444dbd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5cTR6pwjs3kpDXL3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="nb"> Unity — Unity控制台结果</em></figcaption></figure><h1 id="7d8e" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">结论</h1><p id="5a96" class="pw-post-body-paragraph kc kd iq ke b kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv ng kx ky kz ij bi translated">本文介绍的技术正被用于集成<a class="ae lj" href="https://www.imstk.org/" rel="noopener ugc nofollow" target="_blank">交互式医疗模拟工具包(imstk) </a>和<a class="ae lj" href="https://unity.com/" rel="noopener ugc nofollow" target="_blank"> Unity </a>。</p><p id="120c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这篇文章展示了一个简单的技术，在Unity中集成现有的C/C++代码，允许我们使用插件直接从我们的C# Unity脚本中访问已经存在的C/C++方法和类。</p><p id="dd46" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">参考</p><ol class=""><li id="751b" class="nn no iq ke b kf kg kj kk kn np kr nq kv nr kz oz nt nu nv bi translated">Unity — <em class="lz">“底层原生插件接口”</em><a class="ae lj" href="https://docs.unity3d.com/560/Documentation/Manual/NativePluginInterface.html" rel="noopener ugc nofollow" target="_blank">https://docs . unity 3d . com/560/Documentation/Manual/nativeplugininterface . html</a></li><li id="00c6" class="nn no iq ke b kf pa kj pb kn pc kr pd kv pe kz oz nt nu nv bi translated">微软— <em class="lz">"什么是DLL "</em><a class="ae lj" href="https://support.microsoft.com/en-us/help/815065/what-is-a-dll" rel="noopener ugc nofollow" target="_blank">https://support . Microsoft . com/en-us/help/815065/What-is-a-DLL</a></li><li id="b852" class="nn no iq ke b kf pa kj pb kn pc kr pd kv pe kz oz nt nu nv bi translated">维基百科— <em class="lz">“动态链接库”</em><a class="ae lj" href="https://en.wikipedia.org/wiki/Dynamic-link_library#C_and_C++" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Dynamic-link _ library # C _ and _ c++</a></li><li id="946e" class="nn no iq ke b kf pa kj pb kn pc kr pd kv pe kz oz nt nu nv bi translated">海合会文件<em class="lz">“Ifdef”【https://gcc.gnu.org/onlinedocs/gcc-4.8.5/cpp/Ifdef.html】</em>T22</li><li id="0b96" class="nn no iq ke b kf pa kj pb kn pc kr pd kv pe kz oz nt nu nv bi translated"><em class="lz">“extern在C#中是如何工作的？”</em><a class="ae lj" href="https://stackoverflow.com/questions/5110706/how-does-extern-work-in-c" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/5110706/how-does-extern-work-in-c</a></li><li id="2328" class="nn no iq ke b kf pa kj pb kn pc kr pd kv pe kz oz nt nu nv bi translated">Unity — <em class="lz">【入门】</em><a class="ae lj" href="https://docs.unity3d.com/560/Documentation/Manual/GettingStarted.html" rel="noopener ugc nofollow" target="_blank">https://docs . unity 3d . com/560/Documentation/Manual/Getting Started . html</a></li></ol></div></div>    
</body>
</html>