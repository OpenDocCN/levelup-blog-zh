<html>
<head>
<title>To Create An Evolvable API, Stop Thinking About URLs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要创建一个可进化的API，不要再考虑URL了</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/to-create-an-evolvable-api-stop-thinking-about-urls-2ad8b4cc208e?source=collection_archive---------0-----------------------#2019-02-14">https://levelup.gitconnected.com/to-create-an-evolvable-api-stop-thinking-about-urls-2ad8b4cc208e?source=collection_archive---------0-----------------------#2019-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c634" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">API设计的基础</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b56c70310b784311adfcaaf29c063d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FwQsJ9LCwuOii7u-mYCrKw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">一只雄性<a class="ae kv" href="https://en.wikipedia.org/wiki/Peafowl" rel="noopener ugc nofollow" target="_blank">孔雀</a>站在草地上的照片。那只鸟正在扇动尾巴，展示所有的羽毛。羽毛巨大，有眼点。<a class="ae kv" href="https://en.wikipedia.org/wiki/Peafowl#Evolution_and_sexual_selection" rel="noopener ugc nofollow" target="_blank">根据Charles Darwin </a>的说法，孔雀发展出这种设置来吸引雌性。</figcaption></figure><p id="32fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个可进化的API是一个不用<a class="ae kv" href="https://hackernoon.com/how-to-accept-over-engineering-for-what-it-really-is-6fca9a919263" rel="noopener ugc nofollow" target="_blank">推测或过度工程</a>就能以最少的努力改变的API。这是一种以<strong class="ky ir">对话</strong>的形式模拟两台计算机之间通信的方式。大多数API可以利用可进化性的力量。然而，由于没有<a class="ae kv" href="https://medium.com/@fagnerbrack/how-to-reject-the-belief-on-the-silver-bullet-1d86b686acbb" rel="noopener">银弹</a>，一个简单的<a class="ae kv" href="https://en.wikipedia.org/wiki/Remote_procedure_call" rel="noopener ugc nofollow" target="_blank">远程过程调用</a>可能就足够了。</p><p id="2eff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章描述了可进化API的基础。它展示了如何在客户端和服务器之间建立会话模型，以使用网络请求的有效负载来维护会话的状态。它还讨论了统一接口对于分离客户机和服务器以及允许独立的系统发展是多么重要。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="c06f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下一个诊所的网站，患者可以在那里预约医生。你需要开发一个API，让第三方开发者可以和这个诊所的预约系统集成。API应该能够随着新业务需求的出现而改变。</p><p id="6655" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这篇文章，让我们忽略认证，只关注业务需求。</p><p id="ba54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如今，一个常见的解决方案是创建一个端点，在一个<code class="fe lz ma mb mc b">/booking</code>端点中接受HTTP <code class="fe lz ma mb mc b">POST</code>请求。该请求有两个参数，分别表示患者用户名和预期的医生。此外，还需要另外两个参数来表示他们想要预订的时间和预订的内容。</p><p id="2c75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是上午10:20预约请求的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://gist.github.com/FagnerMartinsBrack/5cce211a3a21a83e1dc848c910b8cc78" rel="noopener ugc nofollow" target="_blank">伪代码</a>显示了使用JavaScript“fetch”API的HTTP请求，该请求使用方法“post”指向URL“clinic . example . com/booking”请求正文包含字段“用户名”为“mary.doe”，字段“日期时间”为“2018年5月1日上午10:20”，格式为<a class="ae kv" href="https://en.wikipedia.org/wiki/ISO_8601" rel="noopener ugc nofollow" target="_blank">ISO8601</a>，字段“预定医生”为“jane”，字段“预约”为“咨询简医生”</figcaption></figure><p id="67b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一周后，商业规则改变了。现在医生“简”只工作15分钟而不是30分钟，工作日从上午10点开始。上午10:20的时间现在无效。</p><p id="39f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理这种变化的一个常见解决方案是向端点引入新版本。如果客户试图预订一个无效的日期，新版本会用一个验证状态代码<code class="fe lz ma mb mc b">422 Unprocessable Entity</code>来响应，而不会中断使用旧版本的客户。</p><p id="5859" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法是创建一个<code class="fe lz ma mb mc b">GET /booking</code>端点。响应返回医生Jane可用的时间段，以便客户可以分析并选择他们喜欢的时间段。</p><p id="8767" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是第二种方法的客户端代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://gist.github.com/FagnerMartinsBrack/99888db9392ae5945f0724ff82ee90af" rel="noopener ugc nofollow" target="_blank">伪代码</a>显示了使用JavaScript“fetch”API通过“get”方法对URL“clinic . example . com/booking”的HTTP请求。查询字符串的参数“预期医生”为“jane”该代码从响应中提取“本周可用时隙列表”。在下一条语句中，有与上一个示例相同的“post”HTTP请求，只是现在“date time”字段是函数调用的结果。该功能的名称是“选择可用时间”该函数以<a class="ae kv" href="https://en.wikipedia.org/wiki/ISO_8601" rel="noopener ugc nofollow" target="_blank"> ISO8601格式</a>接收“2018年5月1日上午10:20”的“日期时间”作为第一个参数，并以可用时间段列表作为最后一个参数。</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/22a16bab3c4ca65ed2675e7de58247f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*0wCDL1rFpt07US2oIuyAGA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">左侧显示客户端，右侧显示服务器的图表。客户端向“/booking”端点发出GET请求，查看响应，然后同步向同一个端点发出POST请求。</figcaption></figure><p id="dafd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子展示了人们在API上犯的一些关键错误:</p><ul class=""><li id="72df" class="mg mh iq ky b kz la lc ld lf mi lj mj ln mk lr ml mm mn mo bi translated">客户端代码拥有URL和方法。服务器无法控制客户端发出下一个请求的位置。因此，服务器不能更改它们的URL或方法，因为这些更改可能会破坏其他人。</li><li id="5470" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated">服务器中的业务逻辑变化很可能会导致客户端发生重大变化。这迫使服务器创建一个严格的响应体，并实现URL版本控制以保持向后兼容。</li><li id="a547" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated">客户端需要准确地找出服务器在每个端点上接受哪些参数。他们需要通过网站“开发者”部分的Swagger文档或代码示例来搜索这些参数。</li></ul><p id="e42d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的主要问题是，业务需求中的大多数变化都有更高的几率破坏每个人。</p><p id="f966" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">客户机可以向服务器询问完成一个操作需要什么，服务器可以提供，而不是强迫客户机事先知道所有的URL、字段和HTTP方法。客户端需要编写的唯一代码是解释消息的代码。</p><p id="c275" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住这一点，让我们重新想象一下同样的预订系统。</p><p id="6e31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，与其从代码开始，不如让我们先了解一下人们在没有技术的情况下是如何预约的:</p><blockquote class="mu mv mw"><p id="9d8c" class="kw kx mx ky b kz la jr lb lc ld ju le my lg lh li mz lk ll lm na lo lp lq lr ij bi translated">*顾客到达诊所*</p><p id="9315" class="kw kx mx ky b kz la jr lb lc ld ju le my lg lh li mz lk ll lm na lo lp lq lr ij bi translated">顾客:嗨，我想预约。</p><p id="3d43" class="kw kx mx ky b kz la jr lb lc ld ju le my lg lh li mz lk ll lm na lo lp lq lr ij bi translated"><strong class="ky ir">接待员:</strong>你叫什么名字？</p><p id="f823" class="kw kx mx ky b kz la jr lb lc ld ju le my lg lh li mz lk ll lm na lo lp lq lr ij bi translated">顾客:玛丽。</p><p id="95c6" class="kw kx mx ky b kz la jr lb lc ld ju le my lg lh li mz lk ll lm na lo lp lq lr ij bi translated">接待员:您想预约什么样的服务？</p><p id="8717" class="kw kx mx ky b kz la jr lb lc ld ju le my lg lh li mz lk ll lm na lo lp lq lr ij bi translated">顾客:我想和简医生商量一下。</p><p id="f278" class="kw kx mx ky b kz la jr lb lc ld ju le my lg lh li mz lk ll lm na lo lp lq lr ij bi translated">接待员:我们有这些时间段，你喜欢哪一个？</p><p id="8189" class="kw kx mx ky b kz la jr lb lc ld ju le my lg lh li mz lk ll lm na lo lp lq lr ij bi translated"><strong class="ky ir">顾客:</strong>那个。</p><p id="dcb7" class="kw kx mx ky b kz la jr lb lc ld ju le my lg lh li mz lk ll lm na lo lp lq lr ij bi translated">*对话结束*</p></blockquote><p id="d33d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为服务器，你可以询问客户他们需要哪些信息。如果你是现实生活中的接待员，你会怎么做。在你理解了人们如何在没有技术的情况下预约之后，你会很早就从商业中学习到一些微妙的规则。比如每个医生都有一套不同的工作时间；因此，接待员需要在提供可用时间段之前而不是之后了解预期的医生。</p><p id="fd7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器不知道你想要什么；它只知道字段的描述，默认情况下是空的。想要预约的客户有能力填写这些字段并向服务器提供必要的信息:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://gist.github.com/FagnerMartinsBrack/ff27e58fae538e86bf25d577cb7319b1" rel="noopener ugc nofollow" target="_blank">来自服务器的两个响应的示例</a>。服务器在第一个响应中返回“用户名”和“预定医生”字段。每个字段都有一个名为“只读”且值为“假”的属性服务器在第二个响应中返回“用户名”和“预定医生”字段以及它们各自的<strong class="ak">值</strong>，并将“只读”属性返回为“真”。另外，服务器在第二个响应中返回字段“available time slots”和“booking ”,它们的“只读”属性包含值“false”</figcaption></figure><p id="a18b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lz ma mb mc b">/start-booking</code>路径是“入口点”“入口点”是客户端发起对话所需的唯一URL。这很有意义，因为在现实生活中，你还需要知道该联系哪家<strong class="ky ir">诊所</strong>和<strong class="ky ir">接待员</strong>；你需要知道<strong class="ky ir">主机</strong>和<strong class="ky ir">路径</strong>。客户机知道服务器何时询问这些问题，并有一些逻辑来相应地填充每个字段的值。</p><p id="5025" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的例子中，查看<code class="fe lz ma mb mc b">value</code>中<code class="fe lz ma mb mc b">read-only</code>属性为<code class="fe lz ma mb mc b">true</code>的字段。客户机将这些字段放入请求体，服务器在下一次响应中返回它们。您可以开发一个契约，告诉客户不要用值<code class="fe lz ma mb mc b">true</code>填充具有<code class="fe lz ma mb mc b">read-only</code>属性的字段的值。</p><p id="469e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是你在网络中存储状态的方式。</p><p id="1c58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">客户端或服务器都不需要成为状态的永久规范源。状态在对话中。您可以编写一些代码，使用如下递归策略将有效负载发送回每个后续请求:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://gist.github.com/FagnerMartinsBrack/e37d8961472b98702514c4f45b574fe8" rel="noopener ugc nofollow" target="_blank">伪代码</a>，显示API的客户端实现。该函数的名称是“运行”代码在最后调用函数，并将返回值记录为“退出点”该函数有3个参数。一个参数名为“method”，默认值为“get”，一个参数名为“url”，默认值为“clinic . example . com/start-booking”，一个参数名为“fields”，没有默认值；最后一个参数是可选的。“run”函数中的代码使用参数“method”和“url”执行HTTP请求。然后，它从响应正文中查询id为“必填字段”的“操作”。如果它有那个动作，它调用一个名为“填充字段”的函数来为那个动作设置字段的值。然后，代码递归地执行函数“run ”,将字段传递给下一个请求，直到“必填字段操作”不再存在。如果HTTP请求返回的响应没有客户机支持的动作，那么函数将返回服务器返回的任何响应体。</figcaption></figure><p id="7ddb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，服务器可以改变时隙，客户端代码不会中断。在上面的代码示例中，有一个名为“填充字段”的函数这个功能代表了客户的大脑，即“司机”它具有消耗字段和选择时隙的域逻辑。大脑可以智能地选择最佳时间段来满足他们的需求，就像人类会做的那样。</p><blockquote class="nb"><p id="abe6" class="nc nd iq bd ne nf ng nh ni nj nk lr dk translated">可进化的API是一种不同的架构风格，一种思考两台计算机如何通信的方式。</p></blockquote><figure class="nm nn no np nq kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/2525a728eb045d19767b1d2bfa2dfffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RB1cTzCpt9bPQpUrszo1KQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">左边是显示机器驱动程序和客户端代码的图表。服务器在右边。每个服务器和驱动程序都有自己的大脑。司机使用客户机代码向服务器发起GET请求，并请求预订；服务器返回这些字段，以便驱动程序可以填充它们。服务器最终返回book选项，驱动程序遵循该选项。作为对话的最后一步，即“退出点”，服务器可能会返回成功或不成功的预订。</figcaption></figure><p id="fb29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有可能是机器司机不够聪明，无法选择最佳的可用时间段。毕竟他们的大脑只是由电路板和电路组成的。在这种情况下，您可以使用一个用户界面，这样每个字段的值都可以由人工输入，只需提供一个列表供用户选择，并输入文本。代替作为大脑执行智能的机器，司机是订票的人:一个<strong class="ky ir">人脑</strong>！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://gist.github.com/FagnerMartinsBrack/0fef5db5d87cd875fabd7d41143ad6fb" rel="noopener ugc nofollow" target="_blank">伪代码</a>显示了API的CLI实现。代码和以前一样；只是现在“运行”函数接受名为“使用CLI”的函数“使用CLI”功能提示用户输入字段名，以便系统可以接收输入值。</figcaption></figure><p id="8ba5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种风格中，服务器定义动作、URL和方法。此外，服务器定义哪些字段是完成对话所必需的，驱动程序可以编写代码来查找这些字段。在对话的每一步，客户端总是将状态发送回服务器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/90e8d4b8ba2ea8be0612081a20513215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VRa72QNSc49APwQ2GaP5oA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">左边是人类驾驶员的示意图。客户端代码是一个CLI。服务器在右边。每个服务器和司机都有自己的大脑。司机使用CLI向服务器发起GET请求，要求预订；服务器返回这些字段，以便用户可以使用命令提示符的界面来填充它们。服务器最终返回预订选项，CLI显示为用户可以选择的可选选项。作为对话的最后一步，服务器可能会将预订返回为成功或不成功，CLI可能会以自己的方式来表示。</figcaption></figure><p id="ca9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些是使API可进化的关键方面:</p><ul class=""><li id="5a79" class="mg mh iq ky b kz la lc ld lf mi lj mj ln mk lr ml mm mn mo bi translated">你将对话的<strong class="ky ir">状态</strong>存储在<strong class="ky ir">网络</strong>中。如果服务器希望跟踪预订交易，并且客户端总是发回这些字段，那么服务器可以创建一个新字段，其值包含交易ID。您不需要在客户端修改任何代码。一切正常。</li><li id="9670" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated">你不需要版本控制。您可以在任何请求的响应中添加或删除数据，客户端知道如何对其做出反应。例如，如果服务器返回验证错误，CLI可能不会显示启动预订的选项；服务器决定该选项是否可见。如果客户端不知道如何解释来自服务器的新功能，比如为某些类型的字段添加掩码，他们可以忽略该功能，继续使用旧方法。</li><li id="83b3" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated">服务器拥有包含URL、方法和字段值的“动作”。这样他们可以控制客户去哪里继续对话。例外是第一次调用，即“入口点”“入口点”需要硬编码在客户机中。有许多方法来模拟这个想法；你不需要像这篇文章中的例子那样使用“动作”这个术语。</li></ul><p id="a76b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是在服务器中控制URL非常重要的原因:</p><ul class=""><li id="71ae" class="mg mh iq ky b kz la lc ld lf mi lj mj ln mk lr ml mm mn mo bi translated">服务器可以运行A/B测试，并将客户端定向到运行同一应用程序实例的不同服务器，而无需更改客户端。</li><li id="c10c" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated">服务器可以决定实现轮询功能来异步跟踪预订的状态，而无需更改客户端。</li><li id="7bb9" class="mg mh iq ky b kz mp lc mq lf mr lj ms ln mt lr ml mm mn mo bi translated">服务器可以更改中间的URL、方法或响应，不需要在客户端进行任何向后兼容的更改，只需要向前更改。</li></ul><p id="6092" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可演化API方法和RPC方法之间的区别在于，它使得新的业务需求更容易实现。这也迫使你<strong class="ky ir">思考</strong>你领域内的系统和团队是如何沟通的。权衡是一个小的设计投资。</p><p id="dc2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有魔法。如果客户端或服务器决定用“下划线”填充<code class="fe lz ma mb mc b">user_name</code>,而不是没有“下划线”的<code class="fe lz ma mb mc b">username</code>,并且该字段是强制的，那么显然服务器将永远不会完成对话。如果代码进入一个无限循环，它可能会报错一个API速率限制。有些事情，比如字段名，两个系统需要达成一致，这就是API契约。</p><blockquote class="nb"><p id="7c8f" class="nc nd iq bd ne nf ng nh ni nj nk lr dk translated">开始考虑功能，而不是URL。</p></blockquote><p id="d527" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">如果你想设计可进化的API，首先你需要明白的是，除了“入口点”，URL是一个无意义的实现细节如果你花时间讨论URL应该是单数<code class="fe lz ma mb mc b">/restaurant/:id</code>还是复数<code class="fe lz ma mb mc b">/restaurants/:id</code>，那么这意味着你没有创建可进化的API。此外，如果您使用id对URL建模，您可能会无意中暴露敏感数据，从而影响应用程序的安全性。</p><p id="f4d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于同一主机的每个请求，不管URL是什么，客户机都应该能够解释响应的内容，并填充服务器需要的数据。服务器可能会在第一个请求中请求所有字段，或者他们可能会确认一些字段并在另一个请求中请求剩余的字段。</p><p id="b1cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里最重要的一点是，服务器用相同的<strong class="ky ir">统一的</strong> <a class="ae kv" href="https://codeburst.io/why-do-you-need-to-know-interface-fundamentals-a129ac6ab0c3" rel="noopener" target="_blank"> <strong class="ky ir">接口</strong> </a>来响应每个交互。这样，您为一个响应编写的代码适用于同一主机中的任何类型的响应，只要主机以约定的格式发送响应。</p><p id="2ed9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，特定的URL和响应之间就没有耦合。一个团队可以开发客户端，另一个团队可以开发服务器；他们只需要就通信格式达成一致。不需要按照特定的顺序同时部署客户端和服务器<a class="ae kv" href="https://medium.com/@fagnerbrack/front-end-separation-and-the-irrational-love-for-curly-braces-b6472f48bde7" rel="noopener">！</a></p><blockquote class="nb"><p id="34e6" class="nc nd iq bd ne nf ng nh ni nj nk lr dk translated">您编写的所有代码都应该能够解释来自API的任何URL的任何响应。</p></blockquote><p id="3184" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">想象你在现实生活中预约医生。当您打电话或到达诊所(主持人)时，您搜索接待员以询问您需要什么来进行预约(“入口点”的路径)。接待员给你一个可能时间的列表，你选择一个(作为客户)。如果列表没有显示一整天，您需要更多(分页)。</p><p id="91ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你和诊所都知道“可用时间列表”或“预约”是什么意思，这是<strong class="ky ir">领域词汇</strong>。服务器的响应来自于<a class="ae kv" href="https://jsonapi.org/format/#document-structure" rel="noopener ugc nofollow" target="_blank"> JSON API </a>规范，包含“数据”属性作为第一级文档结构。JSON API规范是两个系统用来通信的<strong class="ky ir">语言</strong>。两个系统只用一种语言是无法相互理解的；他们需要理解领域词汇。</p><p id="57c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对话的当前状态在双方的相互理解中。接待员知道你正在挑选时间；你知道你正在选择你喜欢的时间。没有人使用一张纸来存储对话的状态；双方都知道状态。状态是在网络中，而不是在数据库中。</p><blockquote class="nb"><p id="0984" class="nc nd iq bd ne nf ng nh ni nj nk lr dk translated">要进行有效的对话，仅有通用语言是不够的。当你设计一个API时，开发领域词汇表是程序员的工作。</p></blockquote><p id="9f3f" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">在领域驱动设计中，你用你的业务人员如何操作来建模代码的架构。有了可进化的API，也是一样的。你精确地模拟机器之间的通信，就像你的企业中的人如何通信一样。</p><p id="941a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想一想，如果没有技术，人们将如何解决业务问题，并使用技术来提升业务。</p><p id="103f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您编写代码来解释服务器的消息，并且服务器提供了一个可演化的API，那么随着时间的推移，您将会发现您能够以最少的努力满足许多业务需求。这意味着更少的代码更改和更少的不受您控制的代码损坏。</p><p id="3dac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个问题:这不是一个新的想法。</p><p id="f8f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如今，大多数设计API的开发人员都在努力解决别人在15年前就已经解决的问题。鉴于这篇文章越来越大，我不会告诉你这个想法从何而来，也不会告诉你那个“别人”是谁。这是另一篇文章的主题。</p><p id="7dce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我只能说你和我该休息了。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="fe47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你的团队从我关于这篇文章或我正在进行的任何其他项目的谈话和/或问答中受益，请在<code class="fe lz ma mb mc b">contact at fagnermartins.com</code>给我写信。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="14f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。如果您有任何反馈，请通过<a class="ae kv" href="https://twitter.com/FagnerBrack" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae kv" href="https://www.facebook.com/fagner.brack" rel="noopener ugc nofollow" target="_blank">脸书</a>或<a class="ae kv" href="http://github.com/FagnerMartinsBrack" rel="noopener ugc nofollow" target="_blank"> Github </a>联系我。</p><p id="f1fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢<strong class="ky ir">丹尼尔·西服</strong>、<strong class="ky ir">塞巴斯蒂安·阿鲁、</strong>、<a class="ae kv" href="https://twitter.com/mamund" rel="noopener ugc nofollow" target="_blank">迈克·阿蒙森</a>、<a class="ae kv" href="https://twitter.com/wael_emara" rel="noopener ugc nofollow" target="_blank">瓦尔·艾马拉</a>、<strong class="ky ir">拉塞尔·范·伯特</strong>和<a class="ae kv" href="https://twitter.com/gtramontina" rel="noopener ugc nofollow" target="_blank">古伊列梅·特拉蒙蒂娜</a>对这篇文章的深刻见解。</p><p id="6a68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想当面聊聊吗？你可以在<a class="ae kv" href="https://www.meetup.com/Software-Crafters-Sydney/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">悉尼软件工匠聚会</strong> </a>找到我。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="aa4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">编辑2019年2月28日:</strong> <a class="nw nx ep" href="https://medium.com/u/63d3c9a9b3be?source=post_page-----2ad8b4cc208e--------------------------------" rel="noopener" target="_blank"> Phil Sturgeon </a>在Twitter 上指出<a class="ae kv" href="https://twitter.com/apisyouwonthate/status/1100551083569676288" rel="noopener ugc nofollow" target="_blank">他在自己的</a><a class="ae kv" href="https://blog.apisyouwonthate.com/understanding-rpc-rest-and-graphql-2f959aadebe7" rel="noopener ugc nofollow" target="_blank"> RPC、REST和GraphQL </a>帖子上提出了非常相似的例子。这证明了可演化API的概念是一个<a class="ae kv" href="https://keydifferences.com/difference-between-discovery-and-invention.html" rel="noopener ugc nofollow" target="_blank">发现，而不是一个发明</a>。</p></div></div>    
</body>
</html>