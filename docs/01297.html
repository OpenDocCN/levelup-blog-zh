<html>
<head>
<title>Components of Reactive Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应式编程的组成部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/components-in-reactive-programming-365c7bd9d271?source=collection_archive---------4-----------------------#2019-12-12">https://levelup.gitconnected.com/components-in-reactive-programming-365c7bd9d271?source=collection_archive---------4-----------------------#2019-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="3d2b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Rxjs</h2><div class=""/><div class=""><h2 id="2ebc" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">介绍反应式编程的3个组成部分——生产者、消费者和数据管道。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3642eb93c9849b8dbdd3492cee8ac5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*trDQYG0c7pPplQVXbQm7qQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">在<a class="ae lh" href="https://unsplash.com/s/photos/coffee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae lh" href="https://unsplash.com/@heftiba?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Toa Heftiba </a>拍摄的照片</figcaption></figure><p id="d533" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这篇文章是关于反应式编程中组件的基础知识。</p><ol class=""><li id="7130" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">生产者</li><li id="d4e5" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">顾客</li><li id="8107" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">数据管道</li></ol><p id="2e42" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">【https://betterfullstack.com查看 <a class="ae lh" href="https://betterfullstack.com" rel="noopener ugc nofollow" target="_blank"> <em class="ms">更多类似内容</em></a></p><p id="aff7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下图展示了反应式编程在大背景下是如何工作的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/9759e751d512784b2b76056621d7c8df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*U6m8gA1gYISuQevFrYZMHw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">反应式规划中从上游观测者到下游观测者的一般模型</figcaption></figure><h1 id="dee7" class="mu mv it bd mw mx my mz na nb nc nd ne ki nf kj ng kl nh km ni ko nj kp nk nl bi translated">生产者</h1><p id="18ae" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated"><strong class="lk jd"> <em class="ms">生产者</em> </strong>是你数据的来源。</p><p id="35c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个<strong class="lk jd"> <em class="ms">流</em> </strong>必须总是有一个数据生产者，这将是你将在RxJS中执行的任何逻辑的起点。</p><blockquote class="nr"><p id="f3ec" class="ns nt it bd nu nv nw nx ny nz oa md dk translated">流只不过是一段时间内的一系列事件</p></blockquote><p id="0f90" class="pw-post-body-paragraph li lj it lk b ll ob kd ln lo oc kg lq lr od lt lu lv oe lx ly lz of mb mc md im bi translated"><a class="ae lh" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> <em class="ms">观察者模式</em> </strong> </a>将生产者定义为主体。我们称它们为<strong class="lk jd"> <em class="ms">可观察物</em> </strong>，就像是能够被观察到的东西。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi og"><img src="../Images/f039e60f53815a2c2fd24398c5f7b918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*8EbbgK0HFZo3xZNN0JexoQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">rxjs中的生产者样本</figcaption></figure><p id="c905" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="ms"> Observables </em> </strong>负责推送通知，所以我们把这种行为称为fire-and-forget。这意味着我们永远不会期望生产者参与事件的处理，而只是参与事件的排放。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="2a19" class="mu mv it bd mw mx oo mz na nb op nd ne ki oq kj ng kl or km ni ko os kp nk nl bi translated">顾客</h1><p id="e2b8" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated"><strong class="lk jd"> <em class="ms">消费者</em> </strong>是接受来自<strong class="lk jd"> <em class="ms">生产者</em> </strong>的事件并以某种方式进行处理的组件。当消费者开始监听生产者的事件时，您现在就有了一个流。正是在这一点上，流开始推动事件；我们将消费者称为<strong class="lk jd"> <em class="ms">观察者</em> </strong>。</p><p id="769c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="ms">流</em> </strong>只从<strong class="lk jd"> <em class="ms">生产者</em> </strong>流向<strong class="lk jd"> <em class="ms">消费者</em> </strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/0cb0e0e07598b667917bb97b1816b8fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KmFhxNmT3itCR1bHwUFxA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">rxjs中的消费者样本</figcaption></figure><p id="2721" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从上面的例子来看，每当用户点击提交按钮时，都会产生一个事件传递给消费者。</p><p id="e0d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">自然界中，一条小溪会从上游流向下游；同样的事情也发生在反应式编程中。这些流总是从上游观察者流向下游观察者。</p><p id="1e52" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">来自用户的点击动作将是上游可观察的，因为它只会产生事件，而不会消费它们。基于点击动作执行逻辑的代码是下游观察者。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="10d3" class="mu mv it bd mw mx oo mz na nb op nd ne ki oq kj ng kl or km ni ko os kp nk nl bi translated">数据管道</h1><p id="117b" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">反应式编程的最大好处是，当数据从生产者传递到消费者时，您可以对其进行编辑。</p><p id="ef94" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">来自我最近的一篇文章是<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/approach-reactive-programming-in-modern-web-application-b20f59b7699d?source=friends_link&amp;sk=684ddc59cda0a05ca81cbb68184c6b98">现代Web应用中的反应式编程</a>，我提到:</p><blockquote class="ou ov ow"><p id="7ca3" class="li lj ms lk b ll lm kd ln lo lp kg lq ox ls lt lu oy lw lx ly oz ma mb mc md im bi translated">它将<a class="ae lh" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者模式</a>与<a class="ae lh" href="https://en.wikipedia.org/wiki/Iterator_pattern" rel="noopener ugc nofollow" target="_blank">迭代器模式</a>和<a class="ae lh" href="http://martinfowler.com/articles/collection-pipeline/#NestedOperatorExpressions" rel="noopener ugc nofollow" target="_blank">函数式编程与集合</a>相结合，作为管理事件序列的理想方式来满足需求。</p></blockquote><p id="5566" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">函数式编程？是的，这就是为什么我们可以在像RxJS这样的库中找到许多函数式编程语法实现。</p><p id="b847" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了创建数据管道，我们使用RxJS库提供的<a class="ae lh" href="https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md" rel="noopener ugc nofollow" target="_blank"> pipable操作符</a>和操作符，通过使用函数式编程将数据从生产者转换到消费者。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/88db40473ebcbafb60816566c3ae9a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*28LCsCN0a4klw7GJyReIkg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">rxjs中的数据管道示例</figcaption></figure><p id="e524" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">生产者将通过数据管道和<code class="fe pb pc pd pe b"><strong class="lk jd">pipe</strong></code> <strong class="lk jd">操作符</strong>发出一个包含姓名和年龄信息的用户数组，使用<code class="fe pb pc pd pe b">map</code>转换来自生产者的数据，并只将用户名返回给消费者。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="673a" class="mu mv it bd mw mx oo mz na nb op nd ne ki oq kj ng kl or km ni ko os kp nk nl bi translated">摘要</h1><p id="06c2" class="pw-post-body-paragraph li lj it lk b ll nm kd ln lo nn kg lq lr no lt lu lv np lx ly lz nq mb mc md im bi translated">本文提供了反应式编程中组件的基础知识。我们有3个部分，即生产者、数据管道和消费者。</p><p id="d2cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这篇文章对你有用！可以跟着我上<a class="ae lh" href="https://medium.com/@transonhoang?source=post_page---------------------------" rel="noopener">媒</a>。我也在推特上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt pf"><a href="https://betterfullstack.com/stories/" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd jd gy z fp pk fr fs pl fu fw jc bi translated">故事-更好的全栈</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">关于JavaScript、Python和Wordpress的有用文章，有助于开发人员减少开发时间并提高…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">betterfullstack.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt lb pf"/></div></div></a></div></div></div>    
</body>
</html>