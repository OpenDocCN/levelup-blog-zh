<html>
<head>
<title>Rust: Reassign (with Copy or Clone) vs Mutate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust:重新分配(复制或克隆)vs变异</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rust-reassign-vs-mutate-66f76f468bc3?source=collection_archive---------5-----------------------#2020-08-27">https://levelup.gitconnected.com/rust-reassign-vs-mutate-66f76f468bc3?source=collection_archive---------5-----------------------#2020-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7308" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Rust中再分配和变异的实现、存储和性能比较</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/dc392c67bb37ad1adaba60792e2cea69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qs3gcCupDj0_Hkn-Rbrryg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">图片来源:<a class="ae le" href="https://theproductanalyst.com/blog/" rel="noopener ugc nofollow" target="_blank">产品分析师</a></figcaption></figure><p id="a5ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在许多编程语言中，知道何时使用突变而不是重新分配是一个常见的决定，在Rust这样的内存安全语言中，它们是一个基本问题。由于Rust的主导因素是知道如何有效地借用<strong class="js iu"/>，我们可以通过重新分配与直接突变的镜头来看待Rust语言，从而轻松地了解它的规则。</p><p id="bd1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>在这之后，仔细阅读<a class="ae le" href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" rel="noopener ugc nofollow" target="_blank">所有权</a>以及它与Rust变量的借用、切片和内存管理的关系。如果您正在使用Rust，您可能已经知道了一些，但是通读这一部分并没有坏处。</p><p id="d8cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在很多情况下，Rustaceans指的是在Rust中使用类似于<code class="fe lf lg lh li b"><a class="ae le" href="https://doc.rust-lang.org/std/clone/trait.Clone.html" rel="noopener ugc nofollow" target="_blank">Clone</a></code>或<code class="fe lf lg lh li b"><a class="ae le" href="https://doc.rust-lang.org/std/marker/trait.Copy.html" rel="noopener ugc nofollow" target="_blank">Copy</a></code>特征的性能影响，这允许将<code class="fe lf lg lh li b">struct</code>复制到一个全新的变量绑定中。</p><p id="4346" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们将看看使用可变对象引用、复制对象和克隆对象以及代码示例对内存的影响。<strong class="js iu">基准测试结束。</strong></p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="2f40" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">简单的例子:自行车——克隆与变异</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mo"><img src="../Images/df1bc4afda29496a74221ec9b0f708ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZkZjoXnlmWcul8S4"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated"><a class="ae le" href="https://unsplash.com/@kiwihug?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奇异果抱</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d240" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们有一个自行车模块，它是一个相当简单的<a class="ae le" href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html" rel="noopener ugc nofollow" target="_blank">结构</a>，带有几个<a class="ae le" href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html" rel="noopener ugc nofollow" target="_blank">方法</a>:一个自行车实例的构造函数和变异函数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="56ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在内部，<code class="fe lf lg lh li b">accelerate</code>方法在每次被调用时都会改变<code class="fe lf lg lh li b">speed</code>字段。</p><p id="861c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，请注意<code class="fe lf lg lh li b">#[derive(Copy, Clone)]</code>属性，它允许我们轻松地复制该结构。</p><p id="9587" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用这个模块，我们可以创建两个不同的例子来演示如何修改给定的自行车实例。</p><h2 id="6301" class="mr lr it bd ls ms mt dn lw mu mv dp ma kb mw mx me kf my mz mi kj na nb mm nc bi translated">克隆自行车</h2><p id="e128" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">在第一个示例中，代码克隆了自行车:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7e6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们浏览一下上面的代码。</p><p id="5f96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们声明了一些常量，比如值为100，000的<code class="fe lf lg lh li b">NUM_BIKES</code>(喊出Rust <a class="ae le" href="https://medium.com/the-innovation/post-mozilla-rust-the-future-of-the-rust-language-61a5cfb1f615" rel="noopener">是因为它很棒</a>并且为了可读性允许使用下划线)，以及另一个名为<code class="fe lf lg lh li b">TOTAL_EPOCHS</code>的常量来跟踪总迭代次数。</p><p id="195c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe lf lg lh li b">main function</code>中，我们创建了一个<code class="fe lf lg lh li b">Vector</code>来存储100，000辆自行车的列表，并用数据填充它:</p><pre class="kp kq kr ks gt ni li nj nk aw nl bi"><span id="6dbd" class="mr lr it li b gy nm nn l no np">let mut bikes: Vec&lt;Bicycle&gt; = Vec::new();</span><span id="2df9" class="mr lr it li b gy nq nn l no np">for i in 0..NUM_BIKES {<br/>    bikes.push(Bicycle::new(i));<br/>}</span></pre><p id="5865" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">底部是事情变得有趣的地方，因为我们操作一个嵌套循环来运行每辆自行车五次并加速它们。</p><pre class="kp kq kr ks gt ni li nj nk aw nl bi"><span id="4bcd" class="mr lr it li b gy nm nn l no np">for _i in 0..<strong class="li iu">TOTAL_EPOCHS</strong> {<br/>  for j in 0..<strong class="li iu">bikes.len()</strong> {<br/>    let mut bike = bikes[j].clone();<br/>    bike.accelerate();<br/>    bikes[j] = bike;<br/>  }<br/>}</span></pre><p id="f560" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">这段代码是使用</strong> <code class="fe lf lg lh li b"><strong class="js iu">clone</strong></code> <strong class="js iu">方法复制对象，然后</strong> <code class="fe lf lg lh li b"><strong class="js iu">accelerates</strong></code> <strong class="js iu">将它和</strong> <code class="fe lf lg lh li b"><strong class="js iu">Vector</strong></code> <strong class="js iu">中的引用更新到新的自行车</strong>。</p><pre class="kp kq kr ks gt ni li nj nk aw nl bi"><span id="18d8" class="mr lr it li b gy nm nn l no np">let mut bike = bikes[j]<strong class="li iu">.clone()</strong>;<br/>bike.accelerate();<br/>bikes[j] = bike;</span></pre><h2 id="8cbb" class="mr lr it bd ls ms mt dn lw mu mv dp ma kb mw mx me kf my mz mi kj na nb mm nc bi translated">变异自行车</h2><p id="f2f1" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">在第二个例子中，我们稍微修改了一下程序，让<strong class="js iu">在每个循环中直接改变</strong>自行车对象。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e309" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个版本的主要区别是嵌套for循环的内部:</p><p id="7aef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lf lg lh li b">&amp;mut bikes[j].accelerate();</code></p><p id="a50c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一次我们将引用声明为<strong class="js iu">可变</strong>，这允许<code class="fe lf lg lh li b">accelerate</code>在<code class="fe lf lg lh li b">Vector</code>内的对象<em class="nr">上运行。</em></p><p id="a8b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就简洁多了！</p><h1 id="c660" class="lq lr it bd ls lt ns lv lw lx nt lz ma mb nu md me mf nv mh mi mj nw ml mm mn bi translated">复杂的例子:Car——克隆vs复制vs变异</h1><p id="18e2" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">当然，自行车的例子过于简化了。如果我们有一个更复杂的带有子引用的对象，并且总的内存占用更大，会怎么样？</p><p id="11fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们用一个带字段的结构来描述更复杂的东西，比如一辆汽车会怎么样？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nx"><img src="../Images/47392668697e57b7a47f76cabc57e97d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ElPzPp5MzNnGWwIy"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">罗伯特·诺达尔在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a611" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是Car模块，其结构包括对引擎模块的引用(见下文):</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5de5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">car也是一个简单的<a class="ae le" href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html" rel="noopener ugc nofollow" target="_blank">结构</a>，这次有三个<a class="ae le" href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html" rel="noopener ugc nofollow" target="_blank">方法</a>:一个构造函数、一个赋值函数和一个记录对象内容及其引擎的新方法。和以前一样，<code class="fe lf lg lh li b">accelerate</code>方法在每次被调用时都会改变<code class="fe lf lg lh li b">speed</code>字段，我们再次使用<code class="fe lf lg lh li b">#[derive(Copy, Clone)]</code>属性来允许复制。</p><p id="2866" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">汽车模块使用引擎模块，看起来像:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="141a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">引擎模块和其中的结构非常简单。我加了<code class="fe lf lg lh li b">engine_array</code>来填充一些多余的空间。</p><h2 id="e3be" class="mr lr it bd ls ms mt dn lw mu mv dp ma kb mw mx me kf my mz mi kj na nb mm nc bi translated">克隆汽车</h2><p id="80c0" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">再一次，使用我们为自行车所做的相同代码，我们可以在循环中克隆汽车:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3e15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了一些不同的变量名，实现是相同的。</p><h2 id="1244" class="mr lr it bd ls ms mt dn lw mu mv dp ma kb mw mx me kf my mz mi kj na nb mm nc bi translated">复制汽车</h2><p id="ee8d" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">这是复制一辆汽车而不是克隆的样子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b042" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">这段代码使用了一个隐式的</strong> <code class="fe lf lg lh li b"><strong class="js iu">copy</strong></code> <strong class="js iu">方法来复制对象，然后</strong> <code class="fe lf lg lh li b"><strong class="js iu">accelerates</strong></code> <strong class="js iu">将它和</strong> <code class="fe lf lg lh li b"><strong class="js iu">Vector</strong></code> <strong class="js iu">中的引用更新到新的自行车</strong>。</p><pre class="kp kq kr ks gt ni li nj nk aw nl bi"><span id="6046" class="mr lr it li b gy nm nn l no np">let mut car = cars[j];<br/>car.accelerate();<br/>car[j] = car;</span></pre><h2 id="5a47" class="mr lr it bd ls ms mt dn lw mu mv dp ma kb mw mx me kf my mz mi kj na nb mm nc bi translated">变异汽车</h2><p id="dfcf" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">下面是代码的变种版本，使用cars模块代替自行车:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3271" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一切都很好，但是使用克隆和突变的性能权衡是什么？</p><p id="d220" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们来看看吧！</p><h1 id="2656" class="lq lr it bd ls lt ns lv lw lx nt lz ma mb nu md me mf nv mh mi mj nw ml mm mn bi translated">基准</h1><h2 id="403d" class="mr lr it bd ls ms mt dn lw mu mv dp ma kb mw mx me kf my mz mi kj na nb mm nc bi translated">构建版本</h2><p id="5f08" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">使用Cargo，我们可以轻松地将我们的代码编译成发布优化的自包含bin文件，使用:</p><pre class="kp kq kr ks gt ni li nj nk aw nl bi"><span id="7cdb" class="mr lr it li b gy nm nn l no np">cargo build --release</span></pre><p id="09a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将为我们在Cargo.toml中定义的每个bin生成一个唯一的程序(摘录):</p><pre class="kp kq kr ks gt ni li nj nk aw nl bi"><span id="7d38" class="mr lr it li b gy nm nn l no np">...</span><span id="4fa9" class="mr lr it li b gy nq nn l no np">[[bin]]<br/>name = "clone_bikes"<br/>path = "src/clone_bikes.rs"</span><span id="499b" class="mr lr it li b gy nq nn l no np">[[bin]]<br/>name = "mutate_bikes"<br/>path = "src/mutate_bikes.rs"</span><span id="911e" class="mr lr it li b gy nq nn l no np">[[bin]]<br/>name = "clone_cars"<br/>path = "src/clone_cars.rs"</span><span id="3d92" class="mr lr it li b gy nq nn l no np">[[bin]]<br/>name = "copy_cars"<br/>path = "src/copy_cars.rs"</span><span id="491e" class="mr lr it li b gy nq nn l no np">[[bin]]<br/>name = "mutate_cars"<br/>path = "src/mutate_cars.rs"</span></pre><p id="d7a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">结果文件夹<code class="fe lf lg lh li b">target</code>有一个可执行程序用于每个bin，如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/b9148f54ebe494de432910bce60141df.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*hsKO9iU2uT6c_J1lIm0dqw.png"/></div></figure><p id="f1ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这里，我们可以看到每个发布文件都已准备就绪。</p><p id="3ebf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们看看使用我们的release ready Rust程序的一些基准测试。</p><h2 id="d769" class="mr lr it bd ls ms mt dn lw mu mv dp ma kb mw mx me kf my mz mi kj na nb mm nc bi translated">Heaptrack</h2><p id="7bcd" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated"> <a class="ae le" href="https://github.com/KDE/heaptrack" rel="noopener ugc nofollow" target="_blank">堆轨</a>到底是什么<em class="nr">？</em></p><p id="efaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为KDE的一部分维护的Heaptrack跟踪所有的内存分配，并用堆栈跟踪注释这些事件。它附带了一个漂亮的GUI，提供了分析工具来解释堆内存配置文件，以便深入了解代码的内存分配和内存占用情况。</p><p id="2fee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是三项汽车试验的结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/c75b455d80b0d70073f3241e3c53f63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cdb6FazJpYz3sQ_ooCYyw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">复制汽车的heapstack输出</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/c75b455d80b0d70073f3241e3c53f63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cdb6FazJpYz3sQ_ooCYyw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">克隆汽车的heapstack输出</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/480f258758bd7e47bba78dd479805668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwEibc2q7tLqZkwO24V1-g.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">变异汽车的堆栈输出</figcaption></figure><p id="58e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以看到，它们几乎完全相同，三者之间唯一的区别是<strong class="js iu">峰值RSS ( </strong> <a class="ae le" href="https://en.wikipedia.org/wiki/Resident_set_size" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">常驻集大小</strong> </a> <strong class="js iu"> ) </strong>，其中mutate cars的量最高，为134.3 MB。</p><h2 id="17f8" class="mr lr it bd ls ms mt dn lw mu mv dp ma kb mw mx me kf my mz mi kj na nb mm nc bi translated">使用Linux时间</h2><p id="ed0f" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">使用L <a class="ae le" href="https://man7.org/linux/man-pages/man1/time.1.html" rel="noopener ugc nofollow" target="_blank"> inux time命令</a>，我们可以针对应用程序的速度和整体性能运行一个简单的基准<a class="ae le" href="https://stackoverflow.com/a/4444766" rel="noopener ugc nofollow" target="_blank">测试。</a></p><p id="bf08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当运行汽车示例的三个释放箱时，我们看到<code class="fe lf lg lh li b">copy_cars</code>箱是最快的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/ef509eb97a2b531e1b8bf421fbcb53b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*uOj8yWmWVgsfs-7mjypYng.png"/></div></div></figure><h2 id="b204" class="mr lr it bd ls ms mt dn lw mu mv dp ma kb mw mx me kf my mz mi kj na nb mm nc bi translated">使用超精细</h2><p id="7b47" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">在命令行上对程序进行基准测试的另一个选项是名为hyperfine 的<a class="ae le" href="https://github.com/sharkdp/hyperfine" rel="noopener ugc nofollow" target="_blank">实用程序。</a></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/883242e28f9a5ac5213e7f5949a76cbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9Ty5EvVXGtxipqTjxI0RRg.gif"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">对复制汽车流程进行基准测试</figcaption></figure><p id="e355" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过将示例的三个版本放入hyperfine基准测试工具中，我们可以看到<code class="fe lf lg lh li b">copy_cars</code>似乎又是最快的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oc"><img src="../Images/c716111716b6e0b7911e81541b73c42d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V6nz_vd3dq5JMKb3aTKUTQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">最终基准使用超精细基准工具</figcaption></figure><h1 id="5b60" class="lq lr it bd ls lt ns lv lw lx nt lz ma mb nu md me mf nv mh mi mj nw ml mm mn bi translated">结论</h1><p id="090f" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">总的来说，这里的一般结论是<em class="nr">可能是</em>您可以使用任何适合您的目的的方法，但是如果您认为您可能需要性能提升，尝试一个<code class="fe lf lg lh li b">copy</code>可能是有用的。</p><p id="67a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">个人认为在突变中语法简洁，但在克隆版本中更明显。</p><p id="366f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你最喜欢的选项是什么？</p></div></div>    
</body>
</html>