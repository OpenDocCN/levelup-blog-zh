<html>
<head>
<title>What is so Special About the Intersection Observer API in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的交叉点观察器API有什么特别之处</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-so-special-about-intersection-observer-api-in-javascript-f2430a159fa7?source=collection_archive---------5-----------------------#2020-06-27">https://levelup.gitconnected.com/what-is-so-special-about-intersection-observer-api-in-javascript-f2430a159fa7?source=collection_archive---------5-----------------------#2020-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="861f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解这个神奇的应用编程接口，轻松加载图像，滚动播放动画，播放或暂停视频。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/30555507eba7887f0ce14d3f256a45e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rHzjSL4PM1Yxn8xB"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Julien Pouplard 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="kz la lb"><p id="d08d" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">交叉点观察器API提供了一种异步观察目标元素与祖先元素或顶级文档的视口的交叉点变化的方法。</p></blockquote><p id="e3b2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">简而言之，<code class="fe mc md me mf b">Intersection Observer</code>提供了一种方法来观察页面上的任何元素，并在部分显示、完全显示或即将显示时做一些事情。</p><p id="ad98" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这在各种情况下都很有用，例如</p><p id="cfe5" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">1.开始或停止滚动动画<br/> 2。滚动时惰性加载图像<br/> 3。滚动时自动播放或暂停视频<br/> 4。分析广告是否显示以及被浏览的次数<br/> 5。识别什么时候从视窗中显示或隐藏某些东西</p><p id="68cf" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">可能性是无穷的，因为你现在只需使用<code class="fe mc md me mf b">Intersection Observer</code>就可以轻松完成许多困难的事情。</p><h1 id="38cd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建交叉点观察点</h1><p id="0216" class="pw-post-body-paragraph lc ld it lf b lg my ju li lj mz jx ll lz na lo lp ma nb ls lt mb nc lw lx ly im bi translated">为了创建一个<code class="fe mc md me mf b">Intersection Observer</code>，我们通过提供两个参数来调用构造函数</p><ul class=""><li id="6627" class="nd ne it lf b lg lh lj lk lz nf ma ng mb nh ly ni nj nk nl bi translated">观察到元素时要执行的回调函数</li><li id="8dfa" class="nd ne it lf b lg nm lj nn lz no ma np mb nq ly ni nj nk nl bi translated">指定何时调用回调的可选选项</li></ul><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="4cd6" class="nv mh it mf b gy nw nx l ny nz">const observer = new IntersectionObserver((entries, observer) =&gt; {<br/>  <br/>}, options);</span></pre><p id="fc41" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">然后我们添加我们想要观察的页面元素</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="318c" class="nv mh it mf b gy nw nx l ny nz">observer.observe(element);</span></pre><p id="5e55" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">看看下面的演示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/40108945cded38f01fc28198f8430bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/1*BuhrGe6SGLEv0y3BlTkLkw.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">演示</figcaption></figure><p id="fcc7" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如您所见，在页面加载时，只有box1可见，因此box1的<code class="fe mc md me mf b">visible</code>和其他box的<code class="fe mc md me mf b">invisible</code>显示在控制台中。</p><p id="0959" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当您滚动页面时，第二个框一显示出来，控制台中就会显示<code class="fe mc md me mf b">visible</code>，如果您继续滚动，没有显示的框就会显示出来。</p><p id="8119" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">看一下上面演示的代码。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="8238" class="nv mh it mf b gy nw nx l ny nz">const boxes = document.querySelectorAll(".box");</span><span id="ec14" class="nv mh it mf b gy od nx l ny nz">const observer = new IntersectionObserver((entries, observer) =&gt; {<br/>  entries.forEach((entry) =&gt; {<br/>    console.log(<br/>      entry.target.getAttribute("class"),<br/>      entry.isIntersecting ? "visible" : "invisible"<br/>    );<br/>  });<br/>});</span><span id="96a5" class="nv mh it mf b gy od nx l ny nz">boxes.forEach((box) =&gt; {<br/>  observer.observe(box);<br/>});</span></pre><p id="3acc" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这里，最初，我们选择页面上的所有框。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="3ade" class="nv mh it mf b gy nw nx l ny nz">const boxes = document.querySelectorAll('.box');</span></pre><p id="17a4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">然后我们通过传递一个回调函数作为第一个参数来创建一个<code class="fe mc md me mf b">Intersection Observer</code>。</p><p id="0315" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">最后，我们添加我们想要观察的单个元素</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="a7f1" class="nv mh it mf b gy nw nx l ny nz">boxes.forEach((box) =&gt; {<br/> observer.observe(box);<br/>});</span></pre><p id="a525" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">所以现在，每当任何元素在viewport ( <code class="fe mc md me mf b">which is a browser by default</code>)上显示或隐藏时，回调处理程序将被调用，回调函数的<code class="fe mc md me mf b">entries</code>参数将是包含每个被观察元素的信息的数组。</p><p id="6f68" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果在控制台中打印条目，可以看到每个元素中包含的值。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="ccb5" class="nv mh it mf b gy nw nx l ny nz">const observer = new IntersectionObserver((entries, observer) =&gt; {<br/>  entries.forEach((entry) =&gt; {<br/>    console.log(entry);<br/>  });<br/>});</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/7dc42e33e20b7e03b90bfb95f489f75e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JjiuLPWuPSsJdTGnLb2lAw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">条目信息</figcaption></figure><p id="3418" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">输出中最有用的属性是<code class="fe mc md me mf b">isIntersecting</code>、<code class="fe mc md me mf b">target</code>和<code class="fe mc md me mf b">intersectionRect</code></p><ul class=""><li id="7c4c" class="nd ne it lf b lg lh lj lk lz nf ma ng mb nh ly ni nj nk nl bi translated"><code class="fe mc md me mf b">isIntersecting</code>:当元素与默认根元素相交时，这将是真的，默认根元素在我们的例子中是viewport</li><li id="01a7" class="nd ne it lf b lg nm lj nn lz no ma np mb nq ly ni nj nk nl bi translated"><code class="fe mc md me mf b">target</code>:这将是我们将要观察的页面上的实际元素</li><li id="3ce1" class="nd ne it lf b lg nm lj nn lz no ma np mb nq ly ni nj nk nl bi translated"><code class="fe mc md me mf b">intersectionRect</code> : <code class="fe mc md me mf b">intersectionRect</code>告知元素的多少部分可见。这将包含关于元素的信息，它的高度，宽度，它在视图中的位置，等等</li></ul><p id="e394" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><code class="fe mc md me mf b">options</code>对象是<code class="fe mc md me mf b">Intersection Observer</code>构造函数的第二个参数，它有三个属性</p><ul class=""><li id="10a3" class="nd ne it lf b lg lh lj lk lz nf ma ng mb nh ly ni nj nk nl bi translated"><code class="fe mc md me mf b">root</code>:用作检查目标可见性的视口的元素(如果未指定或指定为空，则默认为浏览器)</li><li id="450e" class="nd ne it lf b lg nm lj nn lz no ma np mb nq ly ni nj nk nl bi translated"><code class="fe mc md me mf b">threshold</code>:该值的范围为0到1。它是一个<code class="fe mc md me mf b">single number or an array of numbers</code>,指示回调应该在目标可见性的多少百分比上执行。如果只想检测可见性何时超过50%标记，可以使用值0.5。如果您希望每次可视性超过25%时都运行回调，那么您应该指定数组<code class="fe mc md me mf b">[0, 0.25, 0.5, 0.75, 1]</code>。threshold的默认值是<code class="fe mc md me mf b">0</code>(意味着只要有一个像素可见，就会执行回调)。值<code class="fe mc md me mf b">1</code>意味着直到每个像素都可见时才认为通过了阈值。</li><li id="81eb" class="nd ne it lf b lg nm lj nn lz no ma np mb nq ly ni nj nk nl bi translated"><code class="fe mc md me mf b">rootMargin</code>:指定根部周围的边距。类似于CSS的margin属性，例如<code class="fe mc md me mf b">"10px 20px 30px 40px"</code>(上、右、下、左)。这些值可以是百分比。默认值为<code class="fe mc md me mf b">0px</code>。注意，如果以像素为单位指定值，则不能省略<code class="fe mc md me mf b">px</code>关键字，因此<br/> <code class="fe mc md me mf b">"10px 0 30px 40px"</code>无效。你必须添加<code class="fe mc md me mf b">px</code>关键字，否则它将无法工作。</li></ul><p id="12d4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">让我们添加<code class="fe mc md me mf b">options</code>对象，它是<code class="fe mc md me mf b">Intersection Observer</code>构造函数的第二个参数。</p><h1 id="f7ca" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">阈值选项</h1><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="474f" class="nv mh it mf b gy nw nx l ny nz">const options = {<br/>  threshold: 0.1<br/>};</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">10%阈值演示</figcaption></figure><p id="406e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">正如你在上面的演示中看到的，当box2的一部分滚动显示时，回调函数不会被触发，但是当box2的10%滚动显示时，由于阈值的原因，回调函数会被触发。</p><h1 id="5635" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">根保证金期权</h1><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="7a5b" class="nv mh it mf b gy nw nx l ny nz">const options = {<br/> rootMargin: '10px'<br/>};</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="2b4d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这里，我们在选项中指定了<code class="fe mc md me mf b">rootMargin</code>,对于顶部、右侧、底部和左侧为<code class="fe mc md me mf b">10px</code>,因此视口将在每一侧移动<code class="fe mc md me mf b">10px</code>,这意味着视口和目标元素之间的交集将在每一侧扩展<code class="fe mc md me mf b">10px</code>。所以在box2的例子中，当box2在视窗上显示之前到达顶部<code class="fe mc md me mf b">10px</code>时，回调将被调用。</p><p id="2936" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果我们将<code class="fe mc md me mf b">rootMargin</code>指定为<code class="fe mc md me mf b">-10px</code>，那么视口将下移<code class="fe mc md me mf b">10px</code>，因此当box2元素的<code class="fe mc md me mf b">10px</code>部分显示时，回调将被触发。</p><h1 id="e208" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">根选项</h1><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="8f18" class="nv mh it mf b gy nw nx l ny nz">const options = {<br/> root: document.querySelector('#root')<br/>};</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f705" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这与上面的演示是一样的，唯一的区别是浏览器不是视窗，id为<code class="fe mc md me mf b">root</code>的div将成为子元素的视窗。</p><p id="4702" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">大多数时候<code class="fe mc md me mf b">root</code>没有被指定，所以它将默认为浏览器视窗。</p><p id="966b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">为了更好地理解<code class="fe mc md me mf b">threshold</code>和<code class="fe mc md me mf b">rootMargin</code>，请查看下面由<a class="ae ky" href="https://michellebarker.co.uk/" rel="noopener ugc nofollow" target="_blank">米歇尔·巴克</a>制作的可视化演示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">演示以清楚了解根界限和阈值</figcaption></figure><p id="bca1" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在上面的可视化中，黑色虚线边框指定了<code class="fe mc md me mf b">rootMargin</code>，顶部和底部的两个浅色框指定了<code class="fe mc md me mf b">threshold</code>值。</p><p id="67ac" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当您滚动页面时，哪些元素会显示在左侧部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/f6c78d86b5df44de5089eac0351d77d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qASFtnbim99uJnmDHwpepg.gif"/></div></div></figure><p id="30cc" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">让我们从<code class="fe mc md me mf b">Intersection Observer</code>的一些实际应用开始</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><h1 id="6b22" class="mg mh it bd mi mj on ml mm mn oo mp mq jz op ka ms kc oq kd mu kf or kg mw mx bi translated">滚动时延迟加载图像</h1><p id="f26e" class="pw-post-body-paragraph lc ld it lf b lg my ju li lj mz jx ll lz na lo lp ma nb ls lt mb nc lw lx ly im bi translated">这是<code class="fe mc md me mf b">Intersection Observer</code>最有用的功能之一。如果网站显示了大量图像，那么当浏览器一个接一个地下载图像时，显示这些图像需要一些时间。</p><p id="76f0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">因此，我们可以只下载显示区域上的图像，并在用户滚动时下载更多的图像，而不是一次下载页面的所有图像。这将节省带宽，也将更快地加载页面。</p><p id="e837" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果用户永远不会滚动页面，那么下载页面的所有图片就没有意义。使用延迟加载可以避免用户在移动设备上浏览时下载额外的数据。</p><p id="a207" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这种按需下载的概念被称为<code class="fe mc md me mf b">lazy loading</code></p><p id="98da" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">让我们看看如何使用<code class="fe mc md me mf b">Intersection Observer.</code>轻松实现它</p><p id="c720" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">为了延迟加载图像，我们需要一个可以观察的部分，它将触发新图像的加载。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="2492" class="nv mh it mf b gy nw nx l ny nz">&lt;div class="container"&gt;&lt;/div&gt;<br/>&lt;div class="loading"&gt;Loading...&lt;/div&gt;<br/>&lt;footer&gt;Footer content&lt;/footer&gt;</span></pre><p id="6806" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这里，我们将加载<code class="fe mc md me mf b">container</code> div中的图像，当<code class="fe mc md me mf b">loading</code> div在视口中可见时，我们将调用一个函数来下载更多的图像并将其附加到<code class="fe mc md me mf b">container</code> div中。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="f551" class="nv mh it mf b gy nw nx l ny nz">const sectionToWatch = document.querySelector(".loading");<br/>const container = document.querySelector(".container");<br/>const MAX_IMAGES_TO_LOAD = 40;</span><span id="dce2" class="nv mh it mf b gy od nx l ny nz">const loadMoreData = () =&gt; {<br/>  fetch("./<a class="ae ky" href="https://gist.githubusercontent.com/myogeshchavan97/2202735a1c3d63a16800b91f38921e14/raw/02326380aff81fbae3321426eed19e3cfb83907b/images.json" rel="noopener ugc nofollow" target="_blank">images.json</a>")<br/>    .then((response) =&gt; response.json())<br/>    .then((result) =&gt; {<br/>        const images = result.images;</span><span id="e915" class="nv mh it mf b gy od nx l ny nz">        images.forEach((image) =&gt; {<br/>          const imageDiv = document.createElement("div");<br/>          imageDiv.classList.add("image");<br/>          const img = document.createElement("img");<br/>          img.src = image.source;<br/>          imageDiv.appendChild(img);<br/>          container.appendChild(imageDiv);<br/>       });<br/>    });<br/>};</span><span id="7e8a" class="nv mh it mf b gy od nx l ny nz">const observer = new IntersectionObserver((entries, observer) =&gt; {<br/>  const [end] = entries; // get the first element from entries and store it in variable with name end</span><span id="a57e" class="nv mh it mf b gy od nx l ny nz">  if (end.isIntersecting) {<br/>    loadMoreData();<br/>  }<br/>  if (container.querySelectorAll(".image").length === MAX_IMAGES_TO_LOAD) {<br/>    observer.unobserve(end.target);<br/>    sectionToWatch.parentNode.removeChild(sectionToWatch);<br/>  }<br/>});</span><span id="d5f9" class="nv mh it mf b gy od nx l ny nz">observer.observe(sectionToWatch);</span></pre><p id="1e55" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">一旦我们达到了要加载的图像数量，我们将通过观察加载div并删除加载div来停止加载更多的图像</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="fc67" class="nv mh it mf b gy nw nx l ny nz">if (container.querySelectorAll(".image").length === MAX_IMAGES_TO_LOAD) {<br/>    observer.unobserve(end.target);<br/>    sectionToWatch.parentNode.removeChild(sectionToWatch);<br/>  }</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">延迟加载图像</figcaption></figure><h1 id="08b8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">滑入图像动画</h1><p id="659a" class="pw-post-body-paragraph lc ld it lf b lg my ju li lj mz jx ll lz na lo lp ma nb ls lt mb nc lw lx ly im bi translated">为了在卷轴上实现滑入动画，我们将为所有需要滑入的图像创建CSS动画。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="a331" class="nv mh it mf b gy nw nx l ny nz">.image img {<br/>  width: 250px;<br/>  height: 250px;<br/>  margin-right: 20px;<br/>  transform: translateX(-100%);<br/>  transition: all 1s;<br/>}</span><span id="f672" class="nv mh it mf b gy od nx l ny nz">.image img.slide-in {<br/>  transform: translateX(0);<br/>}</span></pre><p id="9bb4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">然后在<code class="fe mc md me mf b">Intersection Observer</code>中，我们将添加或删除<code class="fe mc md me mf b">slide-in</code> CSS类</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="0ab2" class="nv mh it mf b gy nw nx l ny nz">const observer = new IntersectionObserver((entries, observer) =&gt; {<br/>  entries.forEach((entry) =&gt; {<br/>    if (entry.isIntersecting) {<br/>      entry.target.classList.add('slide-in');<br/>    } else {<br/>      entry.target.classList.remove('slide-in');<br/>    }<br/>  });<br/>}, options);</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用交叉点观察器的滑入动画</figcaption></figure><p id="4788" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果您不想每次都在卷轴上滑动图像，您可以在图像滑入后取消观察。</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="c261" class="nv mh it mf b gy nw nx l ny nz">observer.unobserve(entry.target);</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="ae8e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">滚动播放或暂停视频</h1><p id="6da0" class="pw-post-body-paragraph lc ld it lf b lg my ju li lj mz jx ll lz na lo lp ma nb ls lt mb nc lw lx ly im bi translated">假设，我们的页面上正在播放一个视频，当视频因为我们滚动了页面而没有显示在屏幕上时，我们可以暂停视频，并在滚动到显示视频的视图时播放它。</p><p id="79c2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我们可以通过添加html5视频标签和提供视频源来实现这一点</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="97d1" class="nv mh it mf b gy nw nx l ny nz">&lt;div class="video-section"&gt;<br/>  &lt;video id="endgame_trailer" width="400" controls muted="muted"&gt;<br/>    &lt;source src="<a class="ae ky" href="https://www.dropbox.com/s/y3guaolykymubxr/video.mp4?dl=1" rel="noopener ugc nofollow" target="_blank">https://www.dropbox.com/s/y3guaolykymubxr/video.mp4?dl=1</a>" type="video/mp4" /&gt;<br/>    Your browser does not support HTML5 video.<br/>  &lt;/video&gt;<br/>&lt;/div&gt;</span></pre><p id="138d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">然后在代码中，使用播放或暂停方法</p><pre class="kj kk kl km gt nr mf ns nt aw nu bi"><span id="20c3" class="nv mh it mf b gy nw nx l ny nz">const video = document.querySelector('#endgame_trailer');<br/><br/>const options = {<br/>  threshold: 0.1<br/>};</span><span id="8bdb" class="nv mh it mf b gy od nx l ny nz">const observer = new IntersectionObserver((entries, observer) =&gt; {<br/>  entries.forEach((entry) =&gt; {<br/>    if (entry.isIntersecting) {<br/>      if (video.paused) {<br/>        video.play();<br/>        console.log('playing video');<br/>      }<br/>    } else {<br/>      video.pause();<br/>      console.log('video paused');<br/>    }<br/>  });<br/>}, options);</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="16c9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak">浏览器支持:</strong></h1><blockquote class="kz la lb"><p id="26d6" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">除Internet Explorer之外，所有浏览器都支持交叉点观察器API。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/53134603855eceab605e44254d965a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OL1nSDyDBUUYdqY7eCD_Xw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#Browser_compatibility" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/Intersection _ Observer _ API # Browser _ compatibility</a></figcaption></figure><blockquote class="kz la lb"><p id="88d1" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">要添加对Internet Explorer的支持，您可以使用此处的<a class="ae ky" href="https://github.com/w3c/IntersectionObserver/tree/master/polyfill" rel="noopener ugc nofollow" target="_blank">中的polyfill</a></p></blockquote><p id="0b69" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">因此，正如你所看到的<code class="fe mc md me mf b">Intersection Observer</code> Javascript API是如此的神奇，你可以在任何Javascript框架或库中使用它，如React、Angular、Vue等。</p><p id="f8e6" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">今天到此为止。我希望你学到了新东西。</p><p id="1148" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">别忘了订阅我的每周简讯，里面有惊人的技巧、窍门和文章，直接在这里的收件箱里</strong> <a class="ae ky" href="https://yogeshchavan.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lf iu">。</strong> </a></p></div></div>    
</body>
</html>