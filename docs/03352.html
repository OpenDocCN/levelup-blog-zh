<html>
<head>
<title>Node.js Best Practices — Security and Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—安全性和性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-best-practices-security-and-performance-cc53da71226d?source=collection_archive---------17-----------------------#2020-05-04">https://levelup.gitconnected.com/node-js-best-practices-security-and-performance-cc53da71226d?source=collection_archive---------17-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/189e2908ae3dcdc523a287db0470a187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*451sVGQtwWuhlUcG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@jrcatalano?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰克·卡塔拉诺</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="9859" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js是编写应用程序的流行运行时。这些应用程序通常是许多人使用的生产质量应用程序。为了使维护它们变得更容易，我们必须为人们设定一些准则来遵循。</p><p id="9fa7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究构建和运行Node.js应用程序时的一些安全性和性能考虑。</p><h1 id="3657" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用子进程时要小心</h1><p id="d3c8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们必须小心投入。这意味着我们应该清理以防止任何外壳注入攻击。我们不希望攻击使用我们从应用程序中创建的子流程实例来运行命令。</p><p id="4c53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不采取预防措施，我们可以很容易地让攻击者从我们的系统远程运行命令，通过输入恶意输入未经整理的系统命令。</p><h1 id="9182" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对客户端隐藏错误详细信息</h1><p id="8045" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">客户不应该知道我们系统的部分或任何私人数据。因此，我们应该隐藏任何容易出错的信息。</p><p id="22d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该确保我们不会将整个错误对象返回给客户端，其中可能包含一些敏感的应用程序细节。敏感的东西包括文件路径、第三方模块、应用程序的内部工作流程等。，攻击者可以利用该漏洞。</p><h1 id="75ae" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为NPM或纱线配置2FA</h1><p id="57bb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用多因素认证来访问我们的私有包存储库。这样，攻击者就不能发布被他们修改过的包。</p><p id="53b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果这些攻击未被检测到，那么我们的包可能会暴露数据或做一些我们不希望攻击者对我们的系统做的事情。</p><h1 id="419b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">修改会话中间件设置</h1><p id="bb18" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该删除任何让攻击者了解我们系统的信息。其中之一是我们使用哪个web框架来开发我们的应用程序。这是因为攻击者可以利用这些信息来查找如何攻击我们的系统。</p><p id="a550" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该隐藏像<code class="fe mh mi mj mk b">X-Powered-By</code>响应头这样的东西，它返回Express中默认使用的框架。</p><h1 id="2ff0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">通过明确设置进程崩溃的时间来避免DOS攻击</h1><p id="cbe9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果错误没有得到处理，节点流程将会崩溃。许多人建议，即使错误被处理，进程也应该退出。</p><p id="edf6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们让我们的应用程序在输入某些输入时崩溃，那么攻击者可以找到什么输入使我们的应用程序崩溃的模式。这并不好，因为我们不想让他们想办法让我们的系统崩溃。</p><p id="742f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何时候我们的应用程序崩溃，一个关键的警报应该被发送，让我们知道它。</p><h1 id="f0fa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">防止不安全的重定向</h1><p id="7641" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该验证用户输入以防止恶意重定向，这样攻击者就无法发起网络钓鱼来窃取用户凭据。</p><h1 id="c330" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免向NPM登记处泄露机密</h1><p id="4099" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">秘密永远不应该出现在NPM的注册表里。否则，我们增加了向公众暴露秘密的机会。我们可以使用<code class="fe mh mi mj mk b">npmignore</code>文件将特定的文件或文件夹列入黑名单，或者使用<code class="fe mh mi mj mk b">package.json</code>中的<code class="fe mh mi mj mk b">files</code>数组作为白名单。</p><h1 id="d1a3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要阻塞事件循环</h1><p id="00a4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">因为Node.js是单线程的，所以我们不应该运行任何需要很长时间的同步代码。这样，我们就不会阻塞事件循环，以便运行其他代码。</p><p id="8c31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当我们有长时间运行的流程时，我们应该使用异步代码，比如promises，这样只有当应用程序得到结果时，这些类型的代码才会运行。</p><p id="39cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，一个请求就可以挂起成千上万用户正在使用的应用程序。</p><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ml"><img src="../Images/8be9f3d4a9b4ccd73405cf67b36df384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ovfw_fDnQBNbZDL-"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@bonniekdesign?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">邦妮·凯特</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="4443" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">比起Lodash等第三方工具，更喜欢本地JS方法</h1><p id="0e3b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果JavaScript标准库中有可用的函数，那么我们应该使用它。这样，我们需要更少的依赖，因此，我们的应用程序将运行得更快。</p><p id="7ac3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原生JavaScript函数现在比实用程序库快50%。</p><h1 id="941f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="acae" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该验证子进程的输入，以消除攻击者输入和注入恶意命令的风险。应该检查不安全的重定向，这样用户就不会被重定向到恶意站点。</p><p id="9366" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们应该隐藏任何可能对攻击有用的信息，比如使用了什么框架、堆栈跟踪等。秘密永远不应该出现在NPM注册表中。</p><p id="fb61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就性能而言，我们应该尽可能地使用JavaScript标准库来提高性能，以减少所使用的依赖项的数量。</p></div></div>    
</body>
</html>