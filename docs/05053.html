<html>
<head>
<title>Colonize Space with Fractal Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用分形树开拓空间</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/colonize-space-with-fractal-trees-ecd6cbb6e78c?source=collection_archive---------17-----------------------#2020-07-31">https://levelup.gitconnected.com/colonize-space-with-fractal-trees-ecd6cbb6e78c?source=collection_archive---------17-----------------------#2020-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e306" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">分形和空间殖民算法快速指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e56fc1426f9a09674048e0194d233d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKFt9cxMBnHdabPMF2X3Ug.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://logancyang.com/simulations/charting/charting.html" rel="noopener ugc nofollow" target="_blank">我的P5.js实现</a></figcaption></figure><p id="ef8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">在</span>这篇文章中，我将编写一些特殊的曲线形状，它们可能不会很快帮助我们殖民银河系，但可能会改变你的想法，让数学再次变得有趣。这个主题叫做<strong class="lb iu">分形</strong>。</p><h1 id="89d2" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">什么是分形？</h1><p id="268b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在回答这个问题之前，我们先来看一些例子。想想英国海岸线的长度。你认为有多长？稍微搜索一下，你可能会发现:</p><blockquote class="nb nc nd"><p id="3168" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated">根据英国测绘局的数据，为11，073英里</p></blockquote><p id="b654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是它也提到了一种叫做<strong class="lb iu"> <em class="ne">海岸线悖论</em> </strong>的东西。显然，回答这个问题并不像我们想象的那么简单！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/d461c4629d4386a667704e0323555ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*J9NCI9jZXFqT_kNCxHDtEg.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://upload.wikimedia.org/wikipedia/commons/2/20/Britain-fractal-coastline-combined.jpg" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="d25c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图中显示长度取决于<em class="ne">你用来测量它的最小单位</em>。如果你放大海岸线的一部分，你会看到类似的曲线，和大图中的一样。理论上，你可以在上面无限放大<em class="ne"/>，仍然可以看到那些弯弯曲曲的曲线。这意味着如果你有无限的分辨率，长度也会接近无限。这有多违反直觉？</p><p id="9b80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是另一个例子。假设我们有一个等边三角形，我们对每条边做如下操作:</p><ol class=""><li id="4320" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">将边分成3等份</li><li id="811e" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">画一个较小的等边三角形，以中间的线段为底边，向外指向</li><li id="720e" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">在步骤2中移除小三角形的底部线段</li></ol><p id="b869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一次又一次地重复这个过程，我们从三角形变成了像雪花一样的东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/7de08596f5bbe470e095a5b91993a608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*15fS3yqEAr9yg8xUWiO3cg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Koch_snowflake#/media/File:KochFlake.svg" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="babd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这被称为<strong class="lb iu">科赫雪花</strong>，或<strong class="lb iu">科赫曲线</strong>，以瑞典数学家<em class="ne">黑尔格·冯·科赫</em>的名字命名，他在1904年的一篇论文中介绍了这一曲线。如果我们永远重复这个过程，科赫雪花的周长是多少？是<strong class="lb iu">无穷大</strong>！因为在这个过程的每一步中，我们得到的周长是前一步的1/3倍。周长呈指数增长并发散。就像海岸线一样，当你放大它时，你会得到相似的(在这种情况下，完全相同的)结构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/1b01eea8e1c629bd643ef16589b7298e.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/1*O2193QKnjHi-R03hKeujbQ.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Koch_snowflake#/media/File:Kochsim.gif" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="ef4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，科赫雪花的面积显然是有限的，因为<em class="ne">我们总是可以画一个圆把它包围起来</em>。这不是很神奇吗？</p><p id="1e0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧…这些分形的东西到底是什么？让我们试着得到一个定义。</p><h1 id="f537" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">定义</h1><p id="e689" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">分形这个术语是数学家伯努瓦·曼德尔布罗在1975年创造的。它意味着破碎或断裂。</p><blockquote class="nb nc nd"><p id="852a" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated"><strong class="lb iu">一个结构需要有3个属性才能成为分形:</strong></p><p id="aa37" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated"><strong class="lb iu"> 1。自相似性:当你放大它时，它看起来与整体相似(或完全相同)。</strong></p><p id="88c3" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated"><strong class="lb iu"> 2。小尺度下的精细结构。</strong></p><p id="2ce6" class="kz la ne lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated"><strong class="lb iu"> 3。从递归定义生成</strong></p></blockquote><p id="f593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我上面描述的生成Koch雪花的过程是递归过程的一个很好的例子。</p><p id="40fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分形不仅看起来很有趣，而且在测量理论、自然科学、技术和艺术方面也有很大的意义。它在混沌理论领域特别相关。如果你感兴趣，你可以阅读其他一些著名的分形:</p><ul class=""><li id="91a1" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu nz np nq nr bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Cantor_set" rel="noopener ugc nofollow" target="_blank">康托尔集</a></li><li id="4755" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Mandelbrot_set" rel="noopener ugc nofollow" target="_blank">曼德勃罗集</a></li><li id="55df" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Sierpiński_triangle" rel="noopener ugc nofollow" target="_blank"> Sierpiński三角形</a></li><li id="70d3" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Attractor#Strange_attractor" rel="noopener ugc nofollow" target="_blank">奇怪的吸引子</a></li></ul><p id="8381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我将向你展示如何使用一种叫做<a class="ae ky" href="http://algorithmicbotany.org/papers/colonization.egwnp2007.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">空间殖民</strong> </a>的算法来创建分形树。这绝对是算法最酷的名字之一！我们开始吧！</p><h1 id="1df5" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">2D的太空殖民</h1><p id="2d9c" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">该算法通过捕捉预先生成的“树叶”来创建分形。这些叶子通常是随机生成的，以填充目标空间，并且<em class="ne">它们吸引附近的树枝向它们生长</em>。</p><p id="9f18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先定义3个类:<code class="fe oa ob oc od b">Leaf</code>、<code class="fe oa ob oc od b">Branch</code>和<code class="fe oa ob oc od b">Tree</code>。</p><p id="d0a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(我使用的是P5.js，但是你可以使用任何你想要的渲染器。下面的算法不依赖于特定的技术)</p><h2 id="1e99" class="oe mf it bd mg of og dn mk oh oi dp mo li oj ok mq lm ol om ms lq on oo mu op bi translated">叶子</h2><p id="be9d" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated"><code class="fe oa ob oc od b">Leaf</code>的构造器创建了一个随机的2D点和一个布尔标志<code class="fe oa ob oc od b">reached</code>,用于跟踪一个分支是否到达它。</p><p id="bb4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还有一个<code class="fe oa ob oc od b">show()</code>方法在画布上呈现这个叶子。</p><h2 id="6d1b" class="oe mf it bd mg of og dn mk oh oi dp mo li oj ok mq lm ol om ms lq on oo mu op bi translated">树枝</h2><p id="8442" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">一个分支由它的<strong class="lb iu">位置</strong>、它的<strong class="lb iu">父分支的位置</strong>和一个从它的父分支复制的<strong class="lb iu">方向</strong>来表示。该方向可用于为其子代创建新的方向。</p><p id="1cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oa ob oc od b">Branch</code>对象的属性:</p><ul class=""><li id="92b8" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu nz np nq nr bi translated"><code class="fe oa ob oc od b">parent</code>:母分公司</li><li id="ac31" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated"><code class="fe oa ob oc od b">pos</code>:位置</li><li id="7982" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated"><code class="fe oa ob oc od b">dir</code>:方向</li><li id="50a8" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated"><code class="fe oa ob oc od b">originDir</code>:跟踪父母的方向</li><li id="c400" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated"><code class="fe oa ob oc od b">count</code> : #找到这个分支最近的叶子</li><li id="ff88" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated"><code class="fe oa ob oc od b">stepSize</code>:调整增长速度的参数</li></ul><p id="d76a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oa ob oc od b">Branch</code>也有</p><ul class=""><li id="e15c" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu nz np nq nr bi translated"><code class="fe oa ob oc od b">reset()</code>:将方向设置回<code class="fe oa ob oc od b">originDir</code>(父方向)，将<code class="fe oa ob oc od b">count</code>设置为0。它在每次<code class="fe oa ob oc od b">grow()</code>通过后被调用。</li><li id="de89" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated"><code class="fe oa ob oc od b">show()</code>:将分支渲染为从其父位置到其位置的直线。</li></ul><h2 id="2048" class="oe mf it bd mg of og dn mk oh oi dp mo li oj ok mq lm ol om ms lq on oo mu op bi translated">树</h2><p id="80db" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">一个<code class="fe oa ob oc od b">Tree</code>有属性:</p><ul class=""><li id="1974" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu nz np nq nr bi translated">一排树叶</li><li id="5b65" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated">一排树枝</li><li id="e56c" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated">一个<code class="fe oa ob oc od b">maxDistance</code>和一个<code class="fe oa ob oc od b">minDistance</code>:定义什么是“附近的”,以便树叶对相关树枝施加吸引力</li></ul><p id="3e11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及空间殖民算法的核心方法<code class="fe oa ob oc od b">grow()</code>。</p><p id="e371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要显示该树，只需定义一个<code class="fe oa ob oc od b">show()</code>，它调用我们之前定义的<code class="fe oa ob oc od b">Leaf</code>和<code class="fe oa ob oc od b">Branch</code>的<code class="fe oa ob oc od b">show()</code>。</p><p id="7c25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在增长我们的树之前，需要在以下步骤中初始化它:</p><ol class=""><li id="8553" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">它需要一个根作为分支中的第一个元素。这个根是一个<code class="fe oa ob oc od b">Branch</code>对象，有位置，有方向，没有父对象。</li><li id="ad1f" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">所有的叶子都需要生成。</li><li id="62bb" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">作为<code class="fe oa ob oc od b">grow()</code>的先决条件，根需要长到某些叶子附近，才能开始吸引过程。</li></ol><h2 id="886f" class="oe mf it bd mg of og dn mk oh oi dp mo li oj ok mq lm ol om ms lq on oo mu op bi translated">种植树木</h2><p id="e412" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">这是这个算法最关键的部分。它由3个高级部分组成:</p><ol class=""><li id="1720" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">在所有的叶子和树枝上画一个双圈，以示“吸引”。</li><li id="ba89" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">在每个相关分支的“方向”向量上应用“吸引力”。如果一个分支被识别为最接近多个叶子，则吸引力被累积<em class="ne"/>。</li><li id="1c4f" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">在先前分支的末端使用先前计算的方向生长新的分支。</li></ol><p id="c499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想关注的一步是确定一个新的方向。对于每个<code class="fe oa ob oc od b">leaf</code>和<code class="fe oa ob oc od b">closestBranch</code>对，</p><ul class=""><li id="7f7f" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu nz np nq nr bi translated">得到向量(closestBranch -&gt; leaf)，<em class="ne">规格化</em>它。</li><li id="d250" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated">将这个归一化向量添加到<code class="fe oa ob oc od b">closestBranch</code>的方向向量中，该向量将被用作其子分支的方向。再次注意，这个方向是<em class="ne">累积的</em>，所有的叶子共享这个<code class="fe oa ob oc od b">closestBranch</code>。</li><li id="8b37" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated">增加<code class="fe oa ob oc od b">closestBranch</code>的计数，记录共享它的叶子的数量，换句话说，可以影响它的累积方向。</li></ul><p id="099b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建子分支时，方向除以分支的<code class="fe oa ob oc od b">count</code>。这一步是当周围有太多叶子时减缓生长，以便在未来的通道中有更多的机会到达这些叶子。</p><p id="8c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你真的编写了这个算法，你会发现有些树叶不会被树捕获。这是因为树枝长得太快，太大了，或者正好在一些树叶中间，吸引力被抵消了。为了避免这种现象，我们可以在每个新分支的方向上添加一个小的随机扰动，并根据需要使<code class="fe oa ob oc od b">stepSize</code>变小。</p><p id="a2dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了我刚才提到的主要观点外，还有一些细节需要注意。遗漏一个细节会给你带来麻烦。一个特别容易错过的是在一次<code class="fe oa ob oc od b">grow()</code>通过后<em class="ne">重置所有分支计数和方向</em>。</p><p id="0da7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会用代码搞乱页面，但是你可以在这里找到它。结果如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/24b5b40429e211a9fbcc7831dda59d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0BYywwD_Hlz9u9V0vX8xuQ.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://logancyang.com/simulations/fractals/space_colonization.html" rel="noopener ugc nofollow" target="_blank">我的P5.js实现</a></figcaption></figure><h1 id="5975" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">太空殖民:3D的一个变种</h1><p id="469f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我发现观察3D空间中的垂直线很令人满意，所以我对上面的算法进行了一点调整，以生长一棵分支在正交方向x，y和z上的分形树。我调整的地方是决定新分支方向的部分。</p><p id="07c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法很简单。</p><ol class=""><li id="ff62" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">获取向量(closestBranch -&gt; leaf)，归一化它，和前面一样。</li><li id="bade" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">找到最大的x，y，z分量，并将其设置为新方向。</li></ol><p id="8376" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。让它变成3D的方法就更简单了。只需在代码中的所有坐标上添加一个<code class="fe oa ob oc od b">z</code>组件即可。</p><p id="3d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下所示。也可以在浏览器直播<a class="ae ky" href="https://logancyang.com/simulations/charting/charting.html" rel="noopener ugc nofollow" target="_blank">这里</a>观看。(P5.js在3D中旋转的线条太多显得比较慢。如果缩小窗口并刷新，它会运行得更快。)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/e106ea1b959ccfdea4b6f3767057ebdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nOtyEuF_s70qWog1HgpFbQ.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://logancyang.com/simulations/charting/charting.html" rel="noopener ugc nofollow" target="_blank">我的P5.js实现</a></figcaption></figure><h1 id="14a7" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">摘要</h1><p id="2ba8" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">分形是惊人的结构，不仅在智力上引人入胜，而且在各种应用中也非常有价值。这是一个伟大的演习，以编码他们，并欣赏其魔力。如果你想了解更多关于在P5.js中可视化分形和处理的信息，请查看丹尼尔·希夫曼的<a class="ae ky" href="https://www.youtube.com/playlist?list=PLRqwX-V7Uu6bXUJvjnMWGU5SmjhI-OXef" rel="noopener ugc nofollow" target="_blank">精彩编码训练YouTube视频</a>！</p><h1 id="67a6" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">资源</h1><ul class=""><li id="5b3b" class="nj nk it lb b lc mw lf mx li os lm ot lq ou lu nz np nq nr bi translated">编码训练<a class="ae ky" href="https://www.youtube.com/playlist?list=PLRqwX-V7Uu6bXUJvjnMWGU5SmjhI-OXef" rel="noopener ugc nofollow" target="_blank">视频</a></li><li id="2d04" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Fractal" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Fractal</a></li><li id="bb29" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Coastline_paradox" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Coastline_paradox</a></li><li id="3941" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu nz np nq nr bi translated"><a class="ae ky" href="http://algorithmicbotany.org/papers/colonization.egwnp2007.html" rel="noopener ugc nofollow" target="_blank">太空殖民论文</a></li></ul><p id="702c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ne">见我在</em> <a class="ae ky" href="https://medium.com/@loganyang" rel="noopener"> <em class="ne">中</em> </a> <em class="ne">上的其他帖子，或者关注我在</em> <a class="ae ky" href="https://twitter.com/logancyang" rel="noopener ugc nofollow" target="_blank"> <em class="ne">上的推特</em> </a> <em class="ne">。</em></p></div></div>    
</body>
</html>