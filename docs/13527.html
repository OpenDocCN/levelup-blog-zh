<html>
<head>
<title>React.js Performance Optimization Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React.js性能优化技术</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-js-performance-optimization-techniques-39728d89e56e?source=collection_archive---------2-----------------------#2022-09-13">https://levelup.gitconnected.com/react-js-performance-optimization-techniques-39728d89e56e?source=collection_archive---------2-----------------------#2022-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="60dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文将介绍几种优化React.js应用程序性能的方法。React.js帮助我们创建更快的ui。但是，如果管理不当，它会降低应用程序的速度(例如，由于组件的不必要的重新渲染)。</p><p id="e344" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了提高任何应用程序的性能，我们首先需要测量和识别应用程序中比定义的阈值慢的地方。然后，我们必须进一步调查和缓解这些问题，并进行修复。</p><p id="681b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我在职业生涯中用来衡量性能的一些资源，以及我用来优化react应用程序的一些技术。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/70673bd1e42b1a9169f0e873d25cac48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gD5l0uEtQu_XSyg5zstg8g.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://www.pexels.com/photo/person-coding-on-a-macbook-pro-4974912/" rel="noopener ugc nofollow" target="_blank">olia danilevich拍摄的照片</a></figcaption></figure><h1 id="1ce2" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">React.js中的性能测量技术</h1><ul class=""><li id="18d6" class="ma mb iq jp b jq mc ju md jy me kc mf kg mg kk mh mi mj mk bi translated">为<a class="ae lb" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" rel="noopener ugc nofollow" target="_blank"> Chrome </a>、<a class="ae lb" href="https://addons.mozilla.org/en-GB/firefox/addon/react-devtools/" rel="noopener ugc nofollow" target="_blank"> Firefox、</a>或<a class="ae lb" href="https://www.npmjs.com/package/react-devtools" rel="noopener ugc nofollow" target="_blank"> React的独立节点包</a>安装<strong class="jp ir"> React开发者工具</strong>。该工具帮助我们收集不同组件渲染的时间信息，并帮助我们确定它们是否是实际的性能瓶颈。<br/> <strong class="jp ir"> <em class="ml">参考:</em> </strong> <em class="ml"> </em> <a class="ae lb" href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" rel="noopener ugc nofollow" target="_blank"> <em class="ml">官方使用React Profiler的分步指南</em> </a></li><li id="381a" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated">在Chrome DevTools中，使用<strong class="jp ir">审计选项卡</strong>生成报告，并分析各种指标和改进领域。<br/> <strong class="jp ir"> <em class="ml">参考:</em> </strong> <em class="ml"> </em> <a class="ae lb" href="https://www.digitalocean.com/community/tutorials/how-to-use-chrome-dev-tools-to-find-performance-bottlenecks" rel="noopener ugc nofollow" target="_blank"> <em class="ml">数字罗汉的博客衡量性能瓶颈</em> </a></li><li id="1c8f" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated">在Chrome DevTools中，使用<strong class="jp ir">性能选项卡</strong>来记录、执行性能分析，并跟踪有问题的地方。<br/> <strong class="jp ir"> <em class="ml">参考:</em> </strong> <em class="ml"> </em> <a class="ae lb" href="https://calibreapp.com/blog/react-performance-profiling-optimization" rel="noopener ugc nofollow" target="_blank"> <em class="ml">录制&amp;查看一条表演轨迹</em> </a></li><li id="54c5" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated">各种<strong class="jp ir">库</strong>也可以帮助追踪和识别改进的领域。几个例子——<code class="fe mr ms mt mu b"><a class="ae lb" href="https://www.npmjs.com/package/web-vitals" rel="noopener ugc nofollow" target="_blank">web-vitals</a></code>、<code class="fe mr ms mt mu b"><a class="ae lb" href="https://www.npmjs.com/package/react-addons-perf" rel="noopener ugc nofollow" target="_blank">react-addons-perf</a></code>。</li></ul><blockquote class="mv mw mx"><p id="0592" class="jn jo ml jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated"><strong class="jp ir">快速提示</strong></p><p id="4865" class="jn jo ml jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated"><strong class="jp ir"> 1。</strong>我们必须进行多次读数，以确保结果真实可信，不受任何其他外部因素的影响。</p><p id="a622" class="jn jo ml jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated"><strong class="jp ir"> 2。</strong>我们可以密切关注web控制台以查看警告(在开发模式期间)。警告有时是有益的，可以帮助我们提高应用程序的整体质量。</p><p id="0a30" class="jn jo ml jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated"><strong class="jp ir"> 3。我们必须留意代价高昂的重建。在我们的代码中，很少有地方会引起组件不必要的重新呈现。</strong></p><p id="8c43" class="jn jo ml jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated">React内部是如何工作的？</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/8081795290117e7624a603ca11429b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J8ft1qQ_IpPFy69daOvf5Q.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://www.pexels.com/photo/close-up-shot-of-a-person-using-a-laptop-7172094/" rel="noopener ugc nofollow" target="_blank">玛特制作的照片</a></figcaption></figure><h1 id="ccea" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">React.js中的性能优化技术</h1><p id="adc8" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated"><strong class="jp ir"> TLDR: </strong>我最初在<a class="ae lb" href="https://wearecommunity.io/communities/india-united-ui-community/articles/1879" rel="noopener ugc nofollow" target="_blank">我们社区</a>上发表了这些技巧的简短版本。</p><h2 id="93d7" class="ne ld iq bd le nf ng dn li nh ni dp lm jy nj nk lq kc nl nm lu kg nn no ly np bi translated"><strong class="ak"> 1。覆盖shouldComponentUpdate生命周期方法</strong></h2><p id="e339" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">当<code class="fe mr ms mt mu b">props</code>或<code class="fe mr ms mt mu b">state</code>发生变化时，react组件会进行渲染。覆盖<code class="fe mr ms mt mu b">shouldComponentUpdate()</code>将帮助我们控制和避免任何不必要的重新渲染。</p><p id="45bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b"><a class="ae lb" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">shouldComponentUpdate()</a></code>在重新渲染组件前触发。</p><p id="e6db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将比较当前和下一个<code class="fe mr ms mt mu b">props</code> &amp; <code class="fe mr ms mt mu b">state</code>。然后，如果我们要重新渲染，返回<code class="fe mr ms mt mu b">true</code>；否则，返回<code class="fe mr ms mt mu b">false</code>以避免重新渲染。</p><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="805b" class="ne ld iq mu b gy nu nv l nw nx">function shouldComponentUpdate(next_props, next_state) {<br/>    return next_props.id !== this.props.id;<br/>}</span></pre><p id="9477" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在更高级别的组件<em class="ml">(类似下图中的A1)</em>中触发的任何更新也会触发其子组件的更新，从而导致性能下降。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ny"><img src="../Images/aac77eb21aef066b4aebd4202b2d05bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zN3dkTOApOQhDez4bmioQA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">嵌套组件结构</figcaption></figure><p id="3556" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在更高级别的组件上添加一个检查并覆盖<code class="fe mr ms mt mu b">shouldComponentUpdate()</code>方法对于嵌套组件结构很有帮助，可以避免任何额外的重新呈现。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="14d2" class="ne ld iq bd le nf ng dn li nh ni dp lm jy nj nk lq kc nl nm lu kg nn no ly np bi translated">2.使用React。纯组件</h2><p id="156d" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">我们可以简单地创建一个从<code class="fe mr ms mt mu b"><a class="ae lb" href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener ugc nofollow" target="_blank">React.PureComponent</a></code>扩展而来的组件，而不是覆盖<code class="fe mr ms mt mu b">shouldComponentUpdate()</code>方法。</p><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="a0ae" class="ne ld iq mu b gy nu nv l nw nx">class ListOfBooks extends React.PureComponent {<br/>  render() {<br/>    return &lt;div&gt;{this.props.books.join(',')}&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="2944" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">劣势？<br/> </strong>它对当前和以前的<em class="ml">道具</em> &amp; <em class="ml">状态</em>做了一个粗浅的比较，在处理更复杂的数据结构时会产生bug，比如嵌套对象。</p><p id="c781" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例如:</strong></p><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="6582" class="ne ld iq mu b gy nu nv l nw nx">class ListOfBooks extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      books: ['rich dad poor dad']<br/>    };<br/>    this.handleClick = this.handleClick.bind(this);<br/>  }<br/><br/>  handleClick() {<br/>    <strong class="mu ir">// This way is not recommended</strong><br/>    const books = this.state.books;<br/>    books.push('good to great');<br/>    this.setState({books: books});<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;button onClick={this.handleClick} /&gt;<br/>        &lt;ListOfBooks books={this.state.books} /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="6de4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是<code class="fe mr ms mt mu b">PureComponent</code>会对<code class="fe mr ms mt mu b">this.props.books</code>的旧&amp;新值做一个简单的比较。</p><p id="3311" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于在<code class="fe mr ms mt mu b">handleClick()</code>方法中，我们改变了<code class="fe mr ms mt mu b">books</code>数组，因此<code class="fe mr ms mt mu b">this.props.books</code>的新旧值将相等，即使数组中的实际字已经改变。</p><p id="6453" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如何避免这种情况？<br/> </strong>使用<strong class="jp ir">不可变数据结构</strong>以及使用<code class="fe mr ms mt mu b">React.PureComponent</code>来自动检查复杂的状态变化。</p><p id="c15d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的方法<code class="fe mr ms mt mu b">handleClick()</code>可以改写成下面的任一种-</p><p id="0264" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用</strong> <code class="fe mr ms mt mu b"><strong class="jp ir">concat</strong></code> <strong class="jp ir">语法</strong></p><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="3325" class="ne ld iq mu b gy nu nv l nw nx">handleClick() {<br/>  this.setState(state =&gt; ({<br/>    books: state.books.concat(['think and grow rich'])<br/>  }));<br/>}</span></pre><p id="5b34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用</strong> <code class="fe mr ms mt mu b"><strong class="jp ir">spread</strong></code> <strong class="jp ir">语法</strong></p><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="e404" class="ne ld iq mu b gy nu nv l nw nx">handleClick() {<br/>  this.setState(state =&gt; ({<br/>    books: [...state.books, 'think and grow rich'],<br/>  }));<br/>};</span></pre><p id="73b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，在<code class="fe mr ms mt mu b">object</code>的情况下，我们可以使用<code class="fe mr ms mt mu b">Object.assign()</code>或<code class="fe mr ms mt mu b">spread</code>语法不改变对象。</p><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="7f35" class="ne ld iq mu b gy nu nv l nw nx"><strong class="mu ir">\\this is not recommended - this mutates</strong><br/>function updateBookAuthorMap(bookAuthorMap) {<br/>  bookAuthorMap.goodtogreat = 'James';<br/>}</span><span id="1d43" class="ne ld iq mu b gy og nv l nw nx"><strong class="mu ir">\\recommended way - without mutating</strong><br/>function updateBookAuthorMap(bookAuthorMap) {<br/>  return Object.assign({}, bookAuthorMap, {goodtogreat: 'James'});<br/>}</span><span id="8133" class="ne ld iq mu b gy og nv l nw nx"><strong class="mu ir">\\recommended way - without mutating - object spread syntax</strong><br/>function updateBookAuthorMap(bookAuthorMap) {<br/>  return {...bookAuthorMap, goodtogreat: 'James'};<br/>}</span></pre><blockquote class="mv mw mx"><p id="0f1f" class="jn jo ml jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated"><strong class="jp ir">快速提示</strong></p><p id="3e1a" class="jn jo ml jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated">在处理深度嵌套的对象时，以不可变的方式更新它们是非常具有挑战性的。</p><p id="e6ce" class="jn jo ml jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated">对于这种情况，很少有库让我们编写一个可读性很高的代码而不失去其不变性的好处，比如— <code class="fe mr ms mt mu b"><a class="ae lb" href="https://github.com/immerjs/immer" rel="noopener ugc nofollow" target="_blank">immer</a></code>、<code class="fe mr ms mt mu b"><a class="ae lb" href="https://github.com/kolodny/immutability-helper" rel="noopener ugc nofollow" target="_blank">immutability-helper</a></code>、<code class="fe mr ms mt mu b"><a class="ae lb" href="https://immutable-js.com/" rel="noopener ugc nofollow" target="_blank">immutable.js</a></code>、<code class="fe mr ms mt mu b"><a class="ae lb" href="https://www.npmjs.com/package/seamless-immutable" rel="noopener ugc nofollow" target="_blank">seamless-immutable</a></code>、<code class="fe mr ms mt mu b"><a class="ae lb" href="https://www.npmjs.com/package/react-copy-write" rel="noopener ugc nofollow" target="_blank">rect-copy-write</a></code>。</p></blockquote></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="c863" class="ne ld iq bd le nf ng dn li nh ni dp lm jy nj nk lq kc nl nm lu kg nn no ly np bi translated">3.使用React片段</h2><p id="ca10" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated"><code class="fe mr ms mt mu b">React.Fragments</code>帮助我们组织子组件列表，而无需在DOM中添加额外的节点。</p><p id="cfe7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下图中，我们可以看到使用<code class="fe mr ms mt mu b">React.fragments</code>和不使用<code class="fe mr ms mt mu b">React.fragments</code>时节点数量的明显差异。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oh"><img src="../Images/0e9c53a70cade0700f1a42211fb8e460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WCDZ9i3RMAOC9F5M2HBiVw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">左侧:使用片段|右侧:不使用片段</figcaption></figure><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="c432" class="ne ld iq mu b gy nu nv l nw nx"><strong class="mu ir">//Sample</strong><br/>export default function App() {<br/>  return (<br/>    <strong class="mu ir">&lt;React.Fragment&gt;</strong><br/>      &lt;h1&gt;Hello Component App&lt;/h1&gt;<br/>      &lt;h2&gt;This is a sample component&lt;/h2&gt;<br/>   <strong class="mu ir"> &lt;/React.Fragment&gt;</strong><br/>  );<br/>}</span><span id="f8e1" class="ne ld iq mu b gy og nv l nw nx"><strong class="mu ir">//Alternatively, we can also use &lt;&gt; &lt;/&gt; to denote fragments</strong><br/>export default function App() {<br/>  return (<br/>    <strong class="mu ir">&lt;&gt;</strong><br/>      &lt;h1&gt;Hello Component App&lt;/h1&gt;<br/>      &lt;h2&gt;This is a sample component&lt;/h2&gt;<br/>    <strong class="mu ir">&lt;/&gt;</strong><br/>  );<br/>}</span></pre><p id="c40c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以分叉这个<a class="ae lb" href="https://codesandbox.io/s/react-fragment-v-s-non-fragment-2jxwlu" rel="noopener ugc nofollow" target="_blank">代码沙箱</a>自己测试。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="1d34" class="ne ld iq bd le nf ng dn li nh ni dp lm jy nj nk lq kc nl nm lu kg nn no ly np bi translated">4.节流和去抖动事件操作</h2><ul class=""><li id="6b5c" class="ma mb iq jp b jq mc ju md jy me kc mf kg mg kk mh mi mj mk bi translated">在我们的代码中找出那些昂贵的或者多次执行的事件处理程序(例如——滚动、鼠标悬停、DOM操作、处理大型列表等)。)</li><li id="94ea" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated">在这种情况下，<strong class="jp ir">节流</strong>和<strong class="jp ir">去抖动</strong>将是救命稻草，而无需对事件处理程序进行重大更改。</li><li id="85b2" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated"><strong class="jp ir">节流— </strong>在指定时间过后执行任何函数，并帮助限制对函数的调用。</li><li id="2e5a" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated"><strong class="jp ir">去抖动— </strong>防止过于频繁地触发任何事件，也就是说，直到上次调用后经过了定义的持续时间，它才调用该函数。</li></ul><p id="160d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用<code class="fe mr ms mt mu b">lodash</code>库及其助手函数— <code class="fe mr ms mt mu b">throttle</code>和<code class="fe mr ms mt mu b">debounce</code>。</p><p id="b78c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">举例——</strong>参考我的<strong class="jp ir"> </strong> <a class="ae lb" href="https://codesandbox.io/s/throttling-v-s-debounce-eu6wbt?file=/src/App.js" rel="noopener ugc nofollow" target="_blank"> CodeSandbox举例</a></p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="f856" class="ne ld iq bd le nf ng dn li nh ni dp lm jy nj nk lq kc nl nm lu kg nn no ly np bi translated">5.记忆反应成分</h2><p id="ce5c" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">我们可以使用memoize技术来存储任何昂贵的函数调用的结果，并返回缓存的结果。</p><p id="8984" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当发生相同的执行时，这种技术将帮助我们优化函数的速度(即，如果用与前一个函数相同的值调用一个函数，那么它将返回缓存的结果，而不是执行逻辑)。</p><p id="79e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在ReactJs - </strong>中，我们可以用以下方法来记忆</p><p id="5032" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 5.1 </strong> <a class="ae lb" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Rect。备忘录</strong> </a> <strong class="jp ir"> <br/> </strong>反应过来。只要<em class="ml"> props </em>保持不变，Memo将一次记忆该组件，并且不会在下一次执行时呈现它。</p><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="3dfb" class="ne ld iq mu b gy nu nv l nw nx">const BookDetails = ({book_details}) =&gt;{<br/>    const {book_title, author_name, book_cover} = book_details;<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;img src={book_cover} /&gt;<br/>            &lt;h4&gt;{book_title}&lt;/h4&gt;<br/>            &lt;p&gt;{author_name}&lt;/p&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span><span id="6e81" class="ne ld iq mu b gy og nv l nw nx"><strong class="mu ir">//memoize the component</strong><br/>export const MemoizedBookDetails = React.memo(BookDetails)<br/><strong class="mu ir">//React will call the MemoizedBookDetails in first render</strong><br/>&lt;MemoizedBookDetails<br/>  book_title="rich dad poor dad"<br/>  author_name="Robert"<br/>/&gt;</span><span id="1082" class="ne ld iq mu b gy og nv l nw nx"><strong class="mu ir">//React will not call MemoizedBookDetails on next render</strong><br/>&lt;MemoizedBookDetails<br/>  book_title="rich dad poor dad"<br/>  author_name="Robert"<br/>/&gt;</span></pre><p id="05e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">5.2 React Hook</strong><a class="ae lb" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">use memo</strong></a><strong class="jp ir"><br/></strong>它有助于避免在一个组件中重复执行同样昂贵的函数。当我们将一个<em class="ml"> prop </em>传递到一个数组或对象的子组件中时，这个钩子将会非常有用，然后<em class="ml"> useMemo </em>将会记忆渲染之间的值。</p><p id="a7b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">举例- </strong></p><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="66a2" class="ne ld iq mu b gy nu nv l nw nx">import { useState, useMemo } from 'react';<br/>export function CalculateBookPrice() {<br/>  const [price, setPrice] = useState(1);<br/>  const [increment, setIncrement] = useState(0);<br/>  <strong class="mu ir">const newPrice = useMemo(() =&gt; finalPrice(number), [number]);</strong><br/>  <br/>  const onChange = event =&gt; {<br/>    setPrice(Number(event.target.value));<br/>  };<br/>  <br/>  const onClick = () =&gt; setIncrement(i =&gt; i + 1);<br/>  <br/>  return (<br/>    &lt;div&gt;<br/>      New Price of Book<br/>      &lt;input type="number" value={price} onChange={onChange} /&gt;<br/>      is {newPrice}<br/>      &lt;button onClick={onClick}&gt;Re-render&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/>function finalPrice(n) {<br/>  return n &lt;= 0 ? 1 : n * finalPrice(n * 0.25);<br/>}</span></pre><p id="28f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">5.3</strong><a class="ae lb" href="https://www.npmjs.com/package/moize" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">moize</strong></a><strong class="jp ir">库对任何纯方法进行内存化<br/> </strong>这是一个JavaScript的内存化库。</p><p id="ea1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">举例- </strong></p><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="b4f4" class="ne ld iq mu b gy nu nv l nw nx">import moize from 'moize';</span><span id="92f0" class="ne ld iq mu b gy og nv l nw nx">const BookDetails = ({book_details}) =&gt;{<br/>    const {book_title, author_name, book_cover} = book_details;</span><span id="4eca" class="ne ld iq mu b gy og nv l nw nx">return (<br/>        &lt;div&gt;<br/>            &lt;img src={book_cover} /&gt;<br/>            &lt;h4&gt;{book_title}&lt;/h4&gt;<br/>            &lt;p&gt;{author_name}&lt;/p&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}</span><span id="44d6" class="ne ld iq mu b gy og nv l nw nx"><strong class="mu ir">export default moize(BookDetails,{<br/>    isReact: true<br/>});</strong></span></pre></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="4d8b" class="ne ld iq bd le nf ng dn li nh ni dp lm jy nj nk lq kc nl nm lu kg nn no ly np bi translated">6.使用React挂钩使用回调</h2><ul class=""><li id="7484" class="ma mb iq jp b jq mc ju md jy me kc mf kg mg kk mh mi mj mk bi translated">在React中，当组件重新呈现时，每个方法都会再次生成。</li><li id="3ae7" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated"><code class="fe mr ms mt mu b">useCallback(function, dependencies)</code>可以帮助我们返回一个方法的记忆化实例，该实例随着<strong class="jp ir">依赖</strong>的改变而改变(即，不是在每次渲染中重新创建函数的实例，而是使用相同的实例)</li><li id="3b05" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated"><strong class="jp ir">示例— </strong>一个很好的用例是当我们想要呈现一个内容丰富的项目列表时。</li></ul><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="76c2" class="ne ld iq mu b gy nu nv l nw nx">import { useCallback } from 'react';</span><span id="25ae" class="ne ld iq mu b gy og nv l nw nx">export function MyBook({ book }) {</span><span id="ba77" class="ne ld iq mu b gy og nv l nw nx"><strong class="mu ir">const onItemClick = useCallback(event =&gt; {<br/>    console.log('You clicked ', event.currentTarget);<br/>  }, [book]);</strong></span><span id="6959" class="ne ld iq mu b gy og nv l nw nx">return (<br/>    &lt;MyBookList<br/>      book={book}<br/>      onItemClick={onItemClick}<br/>    /&gt;<br/>  );<br/>}</span></pre><blockquote class="mv mw mx"><p id="3b5e" class="jn jo ml jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated"><strong class="jp ir">快速提示— </strong>我们需要确保只在相关情况下使用React挂钩<code class="fe mr ms mt mu b"><em class="iq">useCallback</em></code>，而不要在多个地方过度使用。<br/> <strong class="jp ir">参考:</strong> <a class="ae lb" href="https://dmitripavlutin.com/dont-overuse-react-usecallback/" rel="noopener ugc nofollow" target="_blank">不要过度使用React UseCallback </a></p></blockquote></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="eb41" class="ne ld iq bd le nf ng dn li nh ni dp lm jy nj nk lq kc nl nm lu kg nn no ly np bi translated">7.使用Web Workers处理CPU密集型任务</h2><ul class=""><li id="e6ab" class="ma mb iq jp b jq mc ju md jy me kc mf kg mg kk mh mi mj mk bi translated"><strong class="jp ir"> Web Workers </strong>在<strong class="jp ir">后台</strong>运行脚本，与<strong class="jp ir">主执行线程</strong>分开。</li><li id="db65" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated">这个后台线程将帮助主线程(UI)运行，而不会被阻塞或有任何延迟。</li><li id="3010" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated">由于JavaScript是单线程的，我们需要使用下面的方法之一来并行计算开销很大的操作- <br/> <strong class="jp ir"> A. </strong>伪并行(使用<code class="fe mr ms mt mu b">setTimeout</code> ) <br/> <strong class="jp ir"> B. </strong> Web Workers</li><li id="4136" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated">下面是一个使用Web Workers的例子</li></ul><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="d19a" class="ne ld iq mu b gy nu nv l nw nx"><strong class="mu ir">//component</strong><br/>export default Books extends React.Component{</span><span id="644f" class="ne ld iq mu b gy og nv l nw nx">constructor(props){<br/>   super(books);<br/>}</span><span id="7e36" class="ne ld iq mu b gy og nv l nw nx">state = {<br/>   books: this.props.books<br/>}</span><span id="9db0" class="ne ld iq mu b gy og nv l nw nx">componentDidMount() {<br/>    <strong class="mu ir">this.worker = new Worker('booksorter.worker.js');</strong><br/>        <br/>    this.worker.addEventListener('message', event =&gt; {<br/>        const sortedBooks = event.data;<br/>        this.setState({<br/>           books: sortedBooks<br/>        })<br/>    });<br/>}</span><span id="5749" class="ne ld iq mu b gy og nv l nw nx">doSortingByReaders = () =&gt; {<br/>   if(this.state.books &amp;&amp; this.state.books.length){<br/>       this.worker.postBookDetails(this.state.books);<br/>   }<br/>}</span><span id="2813" class="ne ld iq mu b gy og nv l nw nx">render(){<br/>        const books = this.state.books;<br/>        return (<br/>            &lt;&gt;<br/>                &lt;Button onClick={this.doSortingByReaders}&gt;<br/>                    Sort By Readers Count<br/>                &lt;/Button&gt;<br/>                &lt;BookList books={books}&gt;&lt;/BookList&gt;<br/>            &lt;/&gt;<br/>        )<br/>    }<br/>}</span><span id="5ce5" class="ne ld iq mu b gy og nv l nw nx"><strong class="mu ir">// booksorter.worker.js</strong><br/>export default  function sort() {<br/>    self.addEventListener('message', e =&gt;{<br/>        if (!e) return;<br/>        let books = e.data;<br/>        <br/>        //sorting logic<br/>        postBookDetails(books);<br/>    });<br/>}</span></pre><p id="5754" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，我们在一个单独的线程中执行sort方法。这确保了我们不会阻塞主线程。</p><p id="6beb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">网络工作者的使用案例</strong> —图像处理、分类、过滤或任何大量的CPU任务。</p><p id="9959" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ml">官方参考:</em> </strong> <em class="ml"> </em> <a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" rel="noopener ugc nofollow" target="_blank"> <em class="ml">使用网页工作者</em> </a></p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="5b6d" class="ne ld iq bd le nf ng dn li nh ni dp lm jy nj nk lq kc nl nm lu kg nn no ly np bi translated">8.使用动态导入()进行代码拆分</h2><ul class=""><li id="c290" class="ma mb iq jp b jq mc ju md jy me kc mf kg mg kk mh mi mj mk bi translated">当react应用程序在浏览器中呈现时，包含应用程序全部代码的<strong class="jp ir">捆绑</strong>文件将加载并提供给用户。</li><li id="7ec6" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated">捆绑很有帮助，因为它减少了一个页面可以处理的服务器请求的数量。</li><li id="924e" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated">react文件的大小随着应用程序大小的增加而增加。因此，增加了束的尺寸。这种增加可能会降低页面的初始加载速度。</li><li id="6d3c" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated">要将一个大的bundle文件分割成多个<strong class="jp ir">块</strong>，我们可以使用<strong class="jp ir">动态</strong> <code class="fe mr ms mt mu b"><strong class="jp ir">import()</strong></code> <strong class="jp ir"> </strong>以及使用<code class="fe mr ms mt mu b">React.lazy</code>的<strong class="jp ir">惰性加载技术</strong>。</li></ul><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="3613" class="ne ld iq mu b gy nu nv l nw nx"><strong class="mu ir">//Normal way</strong><br/>import Book from "./components/Book";<br/>import BookDetails from "./components/BookDetails";</span><span id="9b10" class="ne ld iq mu b gy og nv l nw nx"><strong class="mu ir">//React Lazy way</strong><br/>const Book = React.lazy(() =&gt; import("./components/Book"));</span><span id="614e" class="ne ld iq mu b gy og nv l nw nx">const BookDetails = React.lazy(() =&gt; import("./components/BookDetails"));</span><span id="6304" class="ne ld iq mu b gy og nv l nw nx">import("./Book").then(book =&gt; {<br/>  ...//logic<br/>});</span></pre><p id="a3a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">惰性组件必须在<code class="fe mr ms mt mu b"><a class="ae lb" href="https://reactjs.org/docs/code-splitting.html#reactlazy:~:text=The%20lazy%20component%20should%20then%20be%20rendered%20inside%20a%20Suspense%20component%2C%20which%20allows%20us%20to%20show%20some%20fallback%20content%20(such%20as%20a%20loading%20indicator)%20while%20we%E2%80%99re%20waiting%20for%20the%20lazy%20component%20to%20load." rel="noopener ugc nofollow" target="_blank">Suspense</a></code>组件中呈现。当React等待在前端呈现组件时，<code class="fe mr ms mt mu b">Suspense</code>将允许我们显示加载文本或任何指示器作为后备。</p><pre class="km kn ko kp gt nq mu nr ns aw nt bi"><span id="8c2f" class="ne ld iq mu b gy nu nv l nw nx">&lt;React.Suspense fallback={&lt;p&gt;Loading page...&lt;/p&gt;}&gt;<br/>  &lt;Route path="/Book" exact&gt;<br/>    &lt;Book/&gt;<br/>  &lt;/Route&gt;<br/>  &lt;Route path="/BookDetails"&gt;<br/>    &lt;BookDetails/&gt;<br/>  &lt;/Route&gt;<br/>&lt;/React.Suspense&gt;</span></pre></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="8ff9" class="ne ld iq bd le nf ng dn li nh ni dp lm jy nj nk lq kc nl nm lu kg nn no ly np bi translated">9.虚拟化/窗口化长列表数据</h2><ul class=""><li id="8cdc" class="ma mb iq jp b jq mc ju md jy me kc mf kg mg kk mh mi mj mk bi translated">要呈现大量数据列表，我们不能一次呈现整个列表。相反，在可见视口内一次只渲染列表的一小部分。</li><li id="ceed" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated">随着用户滚动呈现更多的数据，为了实现这一点，我们可以使用各种库，如<code class="fe mr ms mt mu b"><a class="ae lb" href="https://www.npmjs.com/package/react-window" rel="noopener ugc nofollow" target="_blank">react-window</a></code>、<code class="fe mr ms mt mu b"><a class="ae lb" href="https://www.npmjs.com/package/react-virtualized" rel="noopener ugc nofollow" target="_blank">react-virtualized</a></code>等。</li></ul></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="c499" class="ne ld iq bd le nf ng dn li nh ni dp lm jy nj nk lq kc nl nm lu kg nn no ly np bi translated">10.React v 18的新改进(2022年3月发布)</h2><p id="1256" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">React 18于今年发布，通过最新更新的渲染引擎和更多功能来提高应用性能。</p><p id="0174" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="ml">参考:</em> </strong> <em class="ml"> </em> <a class="ae lb" href="https://www.freecodecamp.org/news/react-18-new-features/" rel="noopener ugc nofollow" target="_blank"> <em class="ml"> React 18新特性</em> </a></p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h2 id="cd63" class="ne ld iq bd le nf ng dn li nh ni dp lm jy nj nk lq kc nl nm lu kg nn no ly np bi translated"><strong class="ak">结论</strong></h2><p id="2ad5" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">仅此而已。如果您喜欢这篇文章，或者您知道更多优化React.js应用程序性能的方法，请告诉我。</p><p id="9889" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上大部分例子来自我的实践经验，我希望这些对你有用。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><a href="https://www.buymeacoffee.com/mansimanhas"><div class="gh gi oi"><img src="../Images/6d60b235fcc46a4bd696b90e886419ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*Dpw8-hNGI2fDmosV4E8DVQ.png"/></div></a><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">感谢您的支持！</figcaption></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><blockquote class="mv mw mx"><p id="1f7c" class="jn jo ml jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated"><strong class="jp ir">参考文献:</strong></p><p id="de96" class="jn jo ml jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated"><a class="ae lb" href="https://reactjs.org/docs/optimizing-performance.html" rel="noopener ugc nofollow" target="_blank">官方参考—优化性能</a></p><p id="7a64" class="jn jo ml jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated"><a class="ae lb" href="https://blog.logrocket.com/immutability-in-react-ebe55253a1cc/" rel="noopener ugc nofollow" target="_blank">React中的不变性:变异对象没有任何问题</a></p><p id="13d0" class="jn jo ml jp b jq jr js jt ju jv jw jx my jz ka kb mz kd ke kf na kh ki kj kk ij bi translated">明智地使用react . memo</p></blockquote></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="88aa" class="lc ld iq bd le lf oj lh li lj ok ll lm ln ol lp lq lr om lt lu lv on lx ly lz bi translated">分级编码</h1><p id="9210" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy nb ka kb kc nc ke kf kg nd ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="9b72" class="ma mb iq jp b jq jr ju jv jy oo kc op kg oq kk mh mi mj mk bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="b096" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated">📰查看<a class="ae lb" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="3fed" class="ma mb iq jp b jq mm ju mn jy mo kc mp kg mq kk mh mi mj mk bi translated">🔔关注我们:<a class="ae lb" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae lb" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae lb" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="4b9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae lb" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>