<html>
<head>
<title>gRPC Basics Part 1: Getting Started</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gRPC基础知识第1部分:入门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/grpc-basics-part-1-getting-started-7bca84ad2478?source=collection_archive---------2-----------------------#2019-06-20">https://levelup.gitconnected.com/grpc-basics-part-1-getting-started-7bca84ad2478?source=collection_archive---------2-----------------------#2019-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f15309f193e12b20c7e99f31606eb6a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wZkczapCXWq5O1Aoq56hXA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:https://grpc.io/</figcaption></figure><p id="4ab7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>是一个开源的高性能RPC框架，可以有效地连接数据中心内和跨数据中心的服务，在我看来这是一个奇迹。几年前我第一次遇到gRPC，并被它的优秀所折服。我的同事<a class="ae kf" href="https://www.linkedin.com/in/scott-walker-38542a6a/" rel="noopener ugc nofollow" target="_blank">斯科特·沃克</a>和<a class="ae kf" href="https://www.linkedin.com/in/andrew-hayes-belfast/" rel="noopener ugc nofollow" target="_blank">我</a>决定在gRPC上为<a class="ae kf" href="https://www.meetup.com/Cloud-Native-Computing-Belfast/" rel="noopener ugc nofollow" target="_blank">云本地计算Belfast </a> Meetup创建一个演讲，以帮助向其他人展示它有多好。然而，我们不得不为这次谈话粉饰一些东西，所以我们决定通过一系列的文章来进行更详细的讨论。</p><h1 id="be75" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">gRPC有什么特别之处？</h1><p id="dd8d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">远程过程调用已经存在很多年了，无论如何它都不是一个新概念。然而，gRPC去掉了很多烦人的部分，让你专注于有趣的部分。它提供了一种以语言中立的方式定义服务的方法，使用。“原型”文件。然后，它会自动生成代码进行联网等。给你的。因此，您不必创建和测试所有样板代码来链接您的客户机和服务器。这也意味着，如果您愿意，您可以让您的客户机使用一种语言，而让服务器使用另一种语言。</p><h1 id="e85c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我就不能用休息吗？</h1><p id="c0f6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">是的，你能，他们确实解决非常相似的问题。然而，gRPC比REST有一些优势。首先是速度，gRPC序列化为二进制数据，因此在发送前后不需要封送和解封JSON(例如),这对于像短期微服务这样需要最佳吞吐量的情况特别有用。gRPC为您处理网络和序列化，因此这意味着您要编写和测试的代码要少得多。它还使用HTTP/2作为传输，所以您仍然可以像使用REST服务一样使用TLS和负载平衡器。它还以您想要的语言生成代码，因此您可以像调用本地对象一样调用远程函数。</p><p id="a015" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文和后续文章中，我们将通过几个例子来展示各种特性，并有望解释它们如此酷的原因。这个例子的完整代码可以在我们的<a class="ae kf" href="https://github.com/scottyw/grpc-example" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>中找到</p><h1 id="2b13" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">示例A:普通gRPC服务器</h1><p id="39cd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们的第一个例子，一个基本的gRPC客户端和服务器在这里:'<a class="ae kf" href="https://github.com/scottyw/grpc-example/tree/master/A.plain-grpc-server" rel="noopener ugc nofollow" target="_blank">gRPC-example/a . plain-gRPC-Server【T13]'</a></p><p id="993f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当创建gRCP服务时，我们在a '中描述我们想要什么。“proto”文件，然后使用“proto”生成所需的代码。我们需要定义我们想要的“服务”以及这些服务将发送和接收的对象。因此，在第一个示例中，服务被称为“MakeBox ”,如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b0b4" class="mq lf it mm b gy mr ms l mt mu">service BoxFactory {<br/>    rpc MakeBox(BoxSpecification) returns (Box) {} <br/>}</span></pre><p id="7276" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们需要定义对象“BoxSpecification”和“Box”。看起来像这样:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bf0d" class="mq lf it mm b gy mr ms l mt mu">message BoxSpecification {<br/>    int32 height = 1;<br/>    int32 width = 2;<br/>    int32 depth = 3;<br/>}</span><span id="39ad" class="mq lf it mm b gy mv ms l mt mu">message Box {<br/>    int32 volume = 1;<br/>}</span></pre><p id="6173" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以告诉“协议”为我们生成代码。在我们的示例repo 中，您可以运行“make generate”来完成此操作。所做的就是运行带有几个参数的protoc命令，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="402b" class="mq lf it mm b gy mr ms l mt mu">protoc \<br/>  -I/usr/local/include \<br/>  -I. \<br/>  -I$(GRPC_GATEWAY_DIR)/third_party/googleapis \<br/>  --go_out=plugins=grpc:factory \<br/>  --grpc-gateway_out=logtostderr=true:factory \<br/>  --proto_path proto factory.proto</span></pre><p id="484b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将为生成的go代码创建一个目录“工厂”。您可以忽略大部分内容，主要部分是如下几行:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f651" class="mq lf it mm b gy mr ms l mt mu">// BoxFactoryServer is the server API for BoxFactory service.<br/>type BoxFactoryServer interface {<br/>    MakeBox(context.Context, *BoxSpecification) (*Box, error)<br/>}</span></pre><p id="79ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个我们需要实现的“go接口”。这正是我们在“factoryserver/factory.go”文件中所做的:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ec4a" class="mq lf it mm b gy mr ms l mt mu">type factoryServer struct {<br/>}</span><span id="4ef7" class="mq lf it mm b gy mv ms l mt mu">func (*factoryServer) MakeBox(context context.Context, spec *factory.BoxSpecification) (*factory.Box, error) {<br/>    log.Println("Making a box ...")<br/>    return &amp;factory.Box{Volume: spec.Depth * spec.Height * spec.Width}, nil<br/>}</span></pre><p id="d19f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们对“协议”生成的接口的实现。我们需要在启动时将它传递给GRPC服务器。这是我们在“factoryserver/server.go”中执行的操作:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4d7b" class="mq lf it mm b gy mr ms l mt mu">func startGRPC() {<br/>    lis, err := net.Listen("tcp", "localhost:5566")<br/>    if err != nil {<br/>        log.Fatalf("failed to listen: %v", err)<br/>     }</span><span id="e205" class="mq lf it mm b gy mv ms l mt mu">     grpcServer := grpc.NewServer()</span><span id="e7f4" class="mq lf it mm b gy mv ms l mt mu">     factory.RegisterBoxFactoryServer(grpcServer, &amp;factoryServer{})<br/>     log.Println("gRPC server ready...")<br/>     grpcServer.Serve(lis)<br/>}</span><span id="1ece" class="mq lf it mm b gy mv ms l mt mu">func main() {<br/>    go startGRPC()</span><span id="f718" class="mq lf it mm b gy mv ms l mt mu">    // Block forever<br/>    var wg sync.WaitGroup<br/>    wg.Add(1)<br/>    wg.Wait()<br/>}</span></pre><p id="f109" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将我们的BoxFactoryServer实现传递给gRCP服务器并启动它。当客户端连接时，我们的代码就会被调用。</p><p id="c0df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了测试这一点，您需要启动一个客户端并连接它。我们在:'<a class="ae kf" href="https://github.com/scottyw/grpc-example/tree/master/A.plain-grpc-server/factoryclient" rel="noopener ugc nofollow" target="_blank"> factoryclient </a> /client.go:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2e33" class="mq lf it mm b gy mr ms l mt mu">// Make a remote call<br/>box, err := client.MakeBox(context.Background(), &amp;factory.BoxSpecification{Height: 2, Width: 3, Depth: 4})</span><span id="d579" class="mq lf it mm b gy mv ms l mt mu">if err != nil {<br/>  log.Fatalf("Failed to make a box: %v", err)<br/>}</span><span id="6616" class="mq lf it mm b gy mv ms l mt mu">log.Printf("Got a lovely box with volume %d", box.Volume)</span></pre><h1 id="b95a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">运行代码</h1><p id="5ca5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要在<a class="ae kf" href="https://github.com/scottyw/grpc-example/tree/master/A.plain-grpc-server" rel="noopener ugc nofollow" target="_blank">我们的示例repo </a>中生成所需的二进制文件，并将它们放在‘bin’目录中，运行以下命令:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1554" class="mq lf it mm b gy mr ms l mt mu">make all</span></pre><p id="466a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要启动服务器，请运行以下命令:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="63c8" class="mq lf it mm b gy mr ms l mt mu">./bin/server</span></pre><p id="b1ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要运行几次客户端，请运行以下命令:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bb8d" class="mq lf it mm b gy mr ms l mt mu">./bin/client</span></pre><h1 id="eed4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">摘要</h1><p id="e887" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在我们的。“proto”文件，我们定义了一个服务，并使用“proto”来生成go代码。然后我们实现了“go接口”,将其传递给GRPC服务器，并在客户端做了类似的事情。所有生成的代码然后处理连接和序列化。</p></div></div>    
</body>
</html>