<html>
<head>
<title>Why You Should (Often) Wrap Your Dependencies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么您应该(经常)包装您的依赖项</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-you-should-often-wrap-your-dependencies-5fced2999616?source=collection_archive---------2-----------------------#2020-07-22">https://levelup.gitconnected.com/why-you-should-often-wrap-your-dependencies-5fced2999616?source=collection_archive---------2-----------------------#2020-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/917f8f0e861073866e7cb3878d6e62d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a5IndvIr0RqWgtSO"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">一个好的包装器隐藏了最美味的实现细节</figcaption></figure><div class=""/><h1 id="bbcc" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">如何包装你的依赖将使你免于未来的痛苦</h1><p id="5c3d" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">几个月前，我和团队中的一名开发人员聊天，不知怎么的，我们聊到了我认为我在过去几年中在我们公司学到的最多的东西。我已经做了6年的软件开发员，在<a class="ae ly" href="http://www.resource.io" rel="noopener ugc nofollow" target="_blank"> Resource </a>工作了2年多。</p><p id="7ce0" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">“收起你的依赖吧，”我告诉我的同事，眼神有些憔悴，这是一个头发花白的老兵会有的表情。</p><p id="021b" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">尽管我已经写了五年多的软件，但直到最近我才学到这一课。在Resource工作之前，我在一家公司工作，在前端使用Vue.js，在后端使用Django。在那里工作期间，我主要处理来自<a class="ae ly" href="https://pypi.org/" rel="noopener ugc nofollow" target="_blank"> PyPI </a>的依赖项，偶尔也会处理<a class="ae ly" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>生态系统，以添加组件库或小型实用程序库。当我开始在Resource工作时，这一切都改变了。当我最初加入时，代码库是用MeteorJS编写的。在我开始之后不久，我们迁移到了React/Node堆栈。没过多久，我就意识到朋友和同事告诉我的关于npm包质量的很多事情都是真的:很多包都是垃圾。</p><p id="be2d" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">从历史上看，我倾向于成为那种尽可能使用现有包的开发人员。我厌恶重新发明轮子，厌恶NIH综合症。然而，当我日复一日地在npm生态系统中工作时，这种态度无疑给我带来了一些痛苦。</p><p id="7ed9" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在花费了比我自豪地承认的多得多的时间来应对这种痛苦之后，我们开始采用一种策略，这种策略将使我们免于许多痛苦:我们决定开始在我们的代码中包装第三方依赖。</p><blockquote class="me mf mg"><p id="55d6" class="la lb mh lc b ld lz lf lg lh ma lj lk mi mb ln lo mj mc lr ls mk md lv lw lx ij bi translated">注意:我在这篇文章中使用包装器这个词来描述一组设计模式，这些模式涉及到在代码和第三方依赖之间添加一些抽象。人们有时使用“适配器”或“外观”这样的词来表示带有某种意图的包装代码。这段代码需要调整它的参数来与其他代码交互吗，或者我在其他模块前面创建了一个门面来简化它的接口？当我在本文的其余部分提到“包装器”时，我将它作为一个包罗万象的术语，它包括了这些模式，并且不太担心意图。</p></blockquote><h1 id="8fb5" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">设置</h1><p id="f460" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">你第一次后悔没有包装你的依赖项可能会像下面这样。有一天，你需要一些你怀疑存在于第三方库中的通用功能。你尽职尽责地搜索npm，直到找到一个库，比如<a class="ae ly" href="https://www.npmjs.com/package/request" rel="noopener ugc nofollow" target="_blank"> <em class="mh"> request </em> </a>，它提供了一个简单的API来进行HTTP请求。你把它加到你的项目里，并没有真正去思考它。</p><p id="a8ff" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">几个月或者几年后，不可思议的事情发生了；请求已被否决，没有计划添加任何新功能，也不保证会合并错误修复或安全补丁。</p><figure class="mm mn mo mp gt is gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/156a21e229e858eac8a7823a93a06fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*TAPYWFSYJ6TO1gPXH99Uxw.jpeg"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">你读了你的图书馆后被弃用了</figcaption></figure><p id="c8de" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">啊哦。这可不好。我想你最好找个替代品。你选择了一个似乎很流行的HTTP库，<a class="ae ly" href="https://www.npmjs.com/package/cross-fetch" rel="noopener ugc nofollow" target="_blank"> <em class="mh">交叉获取</em> </a>。</p><p id="afbf" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">不幸的是，<em class="mh">请求</em>和<em class="mh">交叉获取</em>的API完全不同。<em class="mh">请求</em>对每个HTTP方法都有方便的方法，而<em class="mh">交叉获取</em>需要一个url和一个带有<code class="fe mq mr ms mt b">method</code>键的配置对象。<em class="mh">请求</em>接受一个<code class="fe mq mr ms mt b">json</code>参数，而<em class="mh">交叉获取</em>希望您在响应中调用<code class="fe mq mr ms mt b">.json()</code>。这样的例子不胜枚举。</p><p id="4292" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">如果你有好的工具，并且没有对你的构建系统做任何疯狂的事情，这可能不是一个太困难的改变。你可以从某种形式的粗略查找和替换开始，然后开始手动检查所有你以前使用过<em class="mh">请求</em>的地方。在大型代码库中，这可能是一场噩梦，而且风险很大。</p><p id="f91a" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">这是包装依赖关系的最好理由之一:它使得替换依赖关系变得更加容易。</p><h2 id="a65b" class="mu kd jf bd ke mv mw dn ki mx my dp km ll mz na kq lp nb nc ku lt nd ne ky nf bi translated">两次进口的故事</h2><p id="7f0d" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">现在想象一下，当您第一次决定需要一个HTTP库时，您用自己的模块包装了<em class="mh"> request </em>库。你可以想象它看起来像下面这样。</p><figure class="mm mn mo mp gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5526" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">起初，这看起来像是一个相当无用的模块。在功能上，它做同样的事情，但是现在不是在我们的代码库中写一个像<code class="fe mq mr ms mt b">import request from 'request'</code>这样的导入，而是写<code class="fe mq mr ms mt b">import myRequest from 'myrequest.js'</code>。</p><p id="9823" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">最终，当那一天到来时，您需要用<em class="mh">、</em>交叉获取来替换<em class="mh">请求</em>，现在您只需要在这一个文件中进行更改。您只需要修改<em class="mh">请求</em> API接受的参数，并将它们转换成<em class="mh">交叉获取</em>期望的形状。以下要点显示了这可能是什么样子。</p><figure class="mm mn mo mp gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e3a7" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">写那个代码肯定有点痛苦。但是这比试图找到代码库中所有发出HTTP请求的地方并更新它们以符合<em class="mh">交叉获取</em>的API要容易得多。也安全很多。</p><p id="86a8" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">现在，您不仅能够在必要时(例如出于安全原因)替换这种依赖关系，而且还可以出于其他原因灵活地替换它。也许您发现这些代码路径中的一个对您的产品非常关键，而且太慢了。你去检查npm，发现有一个执行得更好的抓取库，可以被交换进来。</p><p id="7d77" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">或者，当库的维护者休假时，您可能会遇到一个bug。理想情况下，您应该修复库本身源代码中的bug，并向项目提交一个pull请求。但是如果您需要立即进行修复，您可以很容易地在包装器的源代码中对其进行修补。</p><p id="5501" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">然而，能够轻松替换第三方依赖并不是使用包装器带来的唯一好处。</p><h2 id="f186" class="mu kd jf bd ke mv mw dn ki mx my dp km ll mz na kq lp nb nc ku lt nd ne ky nf bi translated">当好的测试变坏时</h2><p id="c325" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在没有包装器的场景中，您可能会注意到在替换所有调用站点以使用<em class="mh">交叉获取</em> API时的其他情况。您进行了更改，然后看到一堆测试中断。这是因为一堆测试在嘲笑<em class="mh">请求</em>依赖，但是现在正在尝试使用<em class="mh">交叉获取</em>。现在，您陷入了更新大量测试代码的困境，尽管您并没有改变发出HTTP请求的实际业务逻辑。</p><p id="67ac" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">有一句谚语经常提到测试:不要嘲笑你不拥有的东西。这个想法是，如果你不维护某个东西的源代码，你就不应该嘲笑它。</p><p id="3219" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">通过在测试中嘲笑<em class="mh"> request </em>库，这条格言被打破了，你正在为此付出代价。现在你必须去更新所有模拟<em class="mh">请求</em>的调用，而不是模拟<em class="mh">交叉获取</em>。呃。</p><p id="0b75" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在使用包装器的场景中，您可以通过简单地模仿包装器来避免这种痛苦。而不是如下所示的应用程序代码:</p><figure class="mm mn mo mp gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d306" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">您只需在应用程序代码中引用包装器:</p><figure class="mm mn mo mp gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="91bf" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在测试中，您现在可以用类似于<code class="fe mq mr ms mt b">jest.mock('./wrappers/request.js')</code>的语句模拟包装器。如果你采用这种方法，当用<em class="mh">请求</em>依赖关系替换<em class="mh">交叉获取</em>时，你不会破坏任何测试。</p><p id="00cf" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">这应该会引起一些人的注意……如果你在嘲笑包装器，测试会不会检测不出包装器是否错误地将<em class="mh">请求</em> API改编为<em class="mh">交叉获取</em> API？</p><p id="befd" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">没错。</p><p id="212f" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">这就是为什么您必须为包装器编写集成测试。理想情况下，您希望为包装器编写不模仿任何东西的测试，并验证用一个第三方实现替换另一个不会破坏任何东西。在某些情况下，这比其他情况更可行。当编写HTTP客户端包装器时，如本例所示，您可以使用类似于<a class="ae ly" href="https://netflix.github.io/pollyjs/" rel="noopener ugc nofollow" target="_blank"> pollyjs </a>的东西来模仿HTTP层的一切，而不是模仿第三方依赖。</p><p id="9697" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">在嘲笑第三方依赖时，还有另一个更阴险的场景。想象一个没有包装器的场景，你已经模拟出了<em class="mh">请求</em>，而不是试图用<em class="mh">交叉获取</em>替换<em class="mh">请求</em>，你只是希望将<em class="mh">请求</em>从版本<code class="fe mq mr ms mt b">2.81.0</code>升级到版本<code class="fe mq mr ms mt b">2.82.0</code>。</p><p id="8a31" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">你撞库，运行测试，一切都通过了。太好了！您合并代码并推向生产，只是为了看着一切都失控。</p><p id="34f0" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">那是因为<code class="fe mq mr ms mt b">2.82.0</code>引入了一个突破性的改变，但是因为你嘲笑了<em class="mh">请求</em>库，并且在测试中没有执行它的任何代码，所以它们成功通过了。</p><p id="dba7" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">同样，这是一个可以通过包装依赖性并为包装器编写集成测试来避免的场景。在这种情况下，模仿包装器的测试会愉快地通过，而集成测试会由于突破性的改变而严重失败。</p><h2 id="ef85" class="mu kd jf bd ke mv mw dn ki mx my dp km ll mz na kq lp nb nc ku lt nd ne ky nf bi translated">为了形成更完善的API</h2><p id="8649" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">使用包装器的一个难以量化的好处是，您可以根据应用程序的实际需求更准确地设计API。尽管第三方依赖节省了实现时间，但它们不能代替设计。在许多情况下，第三方依赖者已经通过大量的实战测试发现了它的API。但是您通常会发现，您的应用程序具体需要如何使用它，与库的设计略有不同。</p><p id="f688" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">让我们回过头来看看<em class="mh">请求</em>。对于这个例子，我们将了解如何设置一个需要指定不同代理配置集的抓取应用程序。</p><p id="c0d9" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">让我们假设您有许多想要使用的不同刮擦“配置文件”。每个配置文件都将配置一些东西，比如要使用的代理服务器、一些特定的HTTP头和一些特定的认证凭证。例如，您将有一个US-EAST配置文件，它需要一个用于该代理的特定授权头，还有一个US-WEST配置文件，它需要一个不同的授权头。</p><p id="7c9d" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">要求调用代码在任何需要发出HTTP请求的地方指定特定于配置文件的授权头并不理想。相反，您可以在包装文件中定义每个概要文件的名称和配置。然后您将修改包装API来接受一个<code class="fe mq mr ms mt b">profile</code>参数。这样，每个调用站点都不需要担心HTTP头的具体细节，而是可以指定一个特定的配置文件来使用。</p><figure class="mm mn mo mp gt is"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="79c1" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">结果是一个更适合用例的API，这意味着测试将更容易，并且对调用代码的修改应该耦合得更少。更好的是，系统有更清晰的边界，这样任何关于如何处理概要文件的实现问题都不会泄露到测试中。</p><h1 id="c91e" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">只有西斯工程师处理绝对的事情</h1><figure class="mm mn mo mp gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/0c943e73b810d97a8448666b05e0eecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AFBHco3_25Px8bPb8vY4Ew.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">你要么和包装纸在一起，要么就是他们的敌人</figcaption></figure><p id="59be" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">当然，就像软件设计中的任何选择一样，使用包装器总会有所取舍。对于每一种情况，您都会想问自己几个问题，以确定为依赖关系构建包装器是否真的值得。</p><p id="82f2" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">至少，添加包装器总是会增加额外的工作。有额外的间接性，现在开发人员不能只是去阅读依赖关系的文档来理解它是如何工作的。他们可能需要查看包装器的源代码，以真正理解包装器API提供了什么契约。好的工具可以帮你很多。使用一个全功能的IDE将会提供像带有参数和文档字符串的工具提示这样的东西。</p><p id="1833" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">添加包装器通常也需要添加更多的文档。因为您不直接处理第三方包，所以查看这些文档可能会产生误导，这取决于您的包装器中实现了什么。对于现代工具，我不认为这有什么大不了的。使用像Typescript或Flow这样的静态分析工具，将大大有助于告诉您是否试图做一些太愚蠢的事情。</p><p id="668e" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">正如我前面提到的，您总是希望确保测试这个包装器，这是添加到您的代码库的另一个负担。</p><p id="9f87" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">那么这个负担什么时候不值得呢？我通常会问自己几个问题。</p><p id="a716" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><em class="mh">这段代码与我的核心业务逻辑有多接近？使用这种依赖或包装的代码可能会改变吗，或者我的需求可能会改变吗？</em></p><p id="783b" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">我对我所需要的API契约理解得越少，我就越不可能马上提交一个包装器。否则，当我发现我实际上需要完全不同的东西时，可能会有很多浪费的工作被扔掉。</p><p id="918f" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><em class="mh">这是“商品”库吗？是否有其他库在相同的抽象层次上提供类似的服务？</em></p><p id="6cd3" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">一般来说，一个图书馆越是“商品”，我就越有可能包装它。如果许多库在同一抽象层次上工作，很有可能它是大致正确的，包装将允许我替换或扩展抽象以适应我的应用程序。</p><p id="7e62" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><em class="mh">这是实施细节吗？这仅仅是对Lodash这样的函数库的数据操作调用吗？</em></p><p id="f202" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">可能不值得包装。</p><p id="efe9" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><em class="mh">包装起来会不会太复杂/困难/不可行？</em></p><p id="448c" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">对于像ORM这样的东西，我可能会通过试图包装一个现有的ORM来有效地实现一个内部ORM。实际上，代码库很少决定用一个ORM替换另一个ORM，所以好处很少。</p><p id="7204" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated"><em class="mh">这是不是一个API客户端库，像Github的</em><a class="ae ly" href="https://github.com/octokit/rest.js/" rel="noopener ugc nofollow" target="_blank"><em class="mh">octo kit</em></a><em class="mh">？</em></p><p id="10f2" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">选择在这里编写包装器取决于几个因素。以octokit为例，如果您计划支持多个git托管提供者，那么几乎可以肯定的是，您最好编写一个抽象，位于可以处理多个提供者的特定库之上。但是如果您只是使用一个库来获取数据，而没有更好的抽象，那么包装它可能是多余的。但是，包装它仍然可以防止您不小心嘲笑它和处理假阳性测试。</p><p id="3351" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">我想到的适合包装的例子有:日志记录、HTTP请求、ui元素/组件、通用字符串实用程序或事务性电子邮件发送。</p><blockquote class="me mf mg"><p id="9d7e" class="la lb mh lc b ld lz lf lg lh ma lj lk mi mb ln lo mj mc lr ls mk md lv lw lx ij bi translated">您可能已经注意到，我建议包装“商品”库，比如进行HTTP调用，并且我还建议设计更多特定于应用程序的API作为包装的好处。我们如何包装一个相当通用的操作，同时使它的API更符合我们应用程序的需求呢？再加一层包装就行了！算是吧。如果您发现自己有一个不完全正确抽象的包装器API，请随意将包装器下移。例如，如果您的应用程序有一个总是添加特定头的HTTP包装器，然后您发现在一个地方，您需要在没有那个头的情况下进行HTTP调用，那么从您的初始包装器中取出一个较低级别的包装器是完全可以的，它可以在不需要额外头的地方重用。重要的部分是确保您仍然只在一个地方导入第三方依赖项。</p></blockquote><h1 id="19d5" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">"实施细节"</h1><p id="d063" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在我们的案例中，我们发现实现这一策略的最佳方式是利用<a class="ae ly" href="https://yarnpkg.com/features/workspaces" rel="noopener ugc nofollow" target="_blank"> yarn workspaces </a>并构建提供清晰边界的内部包装器包。这使得它们易于打包并在我们维护的多个项目之间分发。</p><p id="5970" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">如果您不熟悉，yarn工作区提供了一种在同一个存储库中轻松管理多个包的方法。即使您不打算将这些包发布到包注册中心，通过工作区加强一些隔离也有助于确保离散组件之间没有太多的耦合。</p><p id="1e0e" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">要开始使用HTTP包装器，我们所要做的就是向monorepo添加一个新的包:<code class="fe mq mr ms mt b">@resource/http</code>。现在，我们只在想要进行HTTP调用的地方导入<code class="fe mq mr ms mt b">@resource/http</code>。如果我们再次发现自己需要为不同的HTTP库交换实现，而不是必须到处更新调用点，我们只需要更新<code class="fe mq mr ms mt b">@resource/http</code>来强制我们的包装API到新交换的实现。这也意味着我们可以编写模拟<code class="fe mq mr ms mt b">@resource/http</code>的测试，我们不必担心API签名会改变，因为我们控制着它。</p><p id="5993" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">这里重要的是，我们有自由和控制权来修补、修复、替换和改变我们进行HTTP调用的方式，而不必修改我们代码库中的所有调用站点。</p><h1 id="3f7c" class="kc kd jf bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">就这样结束了</h1><p id="9ef4" class="pw-post-body-paragraph la lb jf lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">尽管您不应该总是包装您的依赖项，但是在编写代码时，您应该使用您的判断来确定这是否是正确的步骤。在决定我是否应该包装一些东西时，我总是问自己:</p><ul class=""><li id="6104" class="nj nk jf lc b ld lz lh ma ll nl lp nm lt nn lx no np nq nr bi translated">这是一个“商品”图书馆吗？</li><li id="888a" class="nj nk jf lc b ld ns lh nt ll nu lp nv lt nw lx no np nq nr bi translated">我是否很好地理解了我的应用程序需要什么样的抽象？</li><li id="261f" class="nj nk jf lc b ld ns lh nt ll nu lp nv lt nw lx no np nq nr bi translated">我能确定这种依赖不是太耦合或者太多的实现细节吗？</li></ul><p id="4f40" class="pw-post-body-paragraph la lb jf lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">如果我可以自信地对这三个问题回答是，这是一个很好的指标，包装的额外工作将是值得的。</p></div></div>    
</body>
</html>