<html>
<head>
<title>3 Ways to Implement Strategy Design Pattern in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中实现策略设计模式的3种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-ways-to-implement-strategy-design-pattern-in-c-a58548d8a4ad?source=collection_archive---------0-----------------------#2021-06-26">https://levelup.gitconnected.com/3-ways-to-implement-strategy-design-pattern-in-c-a58548d8a4ad?source=collection_archive---------0-----------------------#2021-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e18f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">战略模式的实际应用。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29ed603d6ed344577e2879609c70b307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qCMxNdSKsrUVCsbs"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@mvdheuvel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马腾·范登赫维尔</a>拍摄的照片</figcaption></figure><p id="c422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">策略设计模式的目的可以归结为在运行时替换一些通用算法的部分。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="03e6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用策略模式的真实场景</h1><ul class=""><li id="77b0" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">数据可以转换为CSV，HTML，JSON格式。将来，可能还需要添加对降价格式的支持。在这种情况下，可以使用策略模式从数据如何被<strong class="lb iu">转换</strong>中抽象出代码，从而更容易扩展应用程序。</li><li id="1d4e" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">一些应用服务可能需要在不同的<strong class="lb iu">数据存储</strong>之间切换:数据库、文件系统、消息总线、另一个服务(通过HTTP调用)。与特定数据存储进行通信的每个提供者都是一个单独的策略。</li><li id="5b96" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">任何在线商店的网站上的产品都可以通过不同的参数进行分类:价格、评级、发布年份和许多其他参数。策略对象将封装不同的属性选择器，这些选择器将被传递到通用排序算法中。</li><li id="20b7" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">验证</strong>某些对象的规则可以封装在单独的策略对象中，以允许动态地改变规则。</li><li id="fdbe" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">订单的价格可以根据用户状态、折扣等进行不同的计算。</li><li id="88d2" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">应用程序的配置值可以从不同的<strong class="lb iu">源</strong>中提取:应用程序设置文件、环境变量、Azure Key Vault。每个配置源都是一个单独的策略。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a658" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实施#1:动态策略</h1><p id="cb2f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">实现策略的最常见方式是定义一个策略接口，然后从表示一般算法的类中实现和使用该接口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f77677ac6e3f9801cf5aae47daab3c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*iVQQsGjtNY8lFZMLzvX2gQ.png"/></div></figure><p id="4fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个实际的例子。需要处理类似<code class="fe no np nq nr b">key1=value;key2=value;</code>的字符串。字符串处理包括常规部分，如字符串验证，以及移动部分，如将字符串转换并保存为XML或JSON格式。</p><p id="c839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是用策略模式实现键值字符串处理的方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b07d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">KeyValueStringProcessor</code>对象不知道它将把字符串转换和存储成什么格式。这些知识封装在单独的可重用的<code class="fe no np nq nr b">XmlOutputStrategy</code>和<code class="fe no np nq nr b">JsonOutputStrategy</code>对象中，这些对象可以在运行时注入到<code class="fe no np nq nr b">KeyValueStringProcessor</code>中。</p><h2 id="12c1" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">有什么好处？</h2><p id="ce67" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe no np nq nr b">KeyValueStringProcessor</code>类可以使用if-else风格独立实现所有内容，但是，该策略提供了以下好处:</p><ul class=""><li id="fcf6" class="mu mv it lb b lc ld lf lg li og lm oh lq oi lu nb nc nd ne bi translated">具体的策略<code class="fe no np nq nr b">XmlOutputStrategy</code>和<code class="fe no np nq nr b">JsonOutputStrategy</code>很容易在其他类中重用。<code class="fe no np nq nr b">KeyValueStringProcessor</code>不一定是唯一的消费者。</li><li id="b223" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe no np nq nr b">KeyValueStringProcessor</code>类遵循开闭原则，因为它的行为可以在不改变代码的情况下被扩展/改变。</li><li id="5e51" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><code class="fe no np nq nr b">KeyValueStringProcessor, XmlOutputStrategy, JsonOutputStrategy</code>类更容易进行单元测试，因为它们遵循单一责任原则。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2481" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实现#2:基于代表的策略</h1><p id="0da7" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">实现策略设计模式背后的主要思想是，算法可以在运行时被其他算法替换，并且这些算法不总是需要像前面的例子那样封装在单独的类中。</p><p id="3dbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得LINQ的疑问吗。每次你调用<code class="fe no np nq nr b">Where, Select, TakeWhile</code>或其他扩展方法时，你使用策略设计模式，你将<strong class="lb iu">策略定义为λ表达式</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="44ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">Where</code>方法实现了遍历项目集合并为集合中的每个项目应用您指定的谓词(<code class="fe no np nq nr b">i =&gt; i % 2 == 0</code>)的框架算法。</p><p id="92fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自定义谓词是一种策略，它使方法<code class="fe no np nq nr b">Where</code>变得灵活——您可以通过将策略作为lambda表达式传入来改变LINQ方法的行为。</p><p id="f95c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，您将谓词“硬编码”到LINQ方法调用中，因为它们很简单。然而，当谓词更复杂，代表一个可重用的领域知识时，谓词可以被封装到单独的对象中。</p><h2 id="7ecf" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">接口与委托</h2><p id="85ce" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当策略只有一个方法时，可以使用基于委托的实现。但是当策略有几个方法时，将它们封装在一个单独的类中并提取接口会更方便。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ebf1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实现#3:静态策略</h1><p id="9c23" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在以前的策略模式实现中，策略消费者类不知道在编译时将使用哪个特定的策略。</p><p id="16c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当不需要用动态灵活性实现多态行为时，有一种方法可以静态地而不是动态地将策略消费者和某些策略实现结合起来。</p><p id="3f6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态组合是通过使用泛型类实现的。下面是如何重构<code class="fe no np nq nr b">KeyValueStringProcessor</code>类来静态构建策略。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6d88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，一旦用其中一个策略实例化了<code class="fe no np nq nr b">KeyValueStringProcessor&lt;T&gt;</code>类，就不能再改变该实例的策略了。我们所能做的就是创建<code class="fe no np nq nr b">KeyValueStringProcessor&lt;T&gt;</code>类的另一个实例，指定不同类型的策略。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e840" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">关键要点</h1><ul class=""><li id="7de1" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">策略设计模式允许您在运行时替换算法。</li><li id="c5e5" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">该模式允许将算法封装到单独的对象中，这提高了可重用性、单元测试和可维护性。</li><li id="6b96" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">当一个策略定义了一组方法时，它最好用一个接口来实现。</li><li id="8050" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">如果策略只有一个方法，则可以使用委托来实现该策略。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="64e5" class="nu md it bd me nv nw dn mi nx ny dp mm li nz oa mo lm ob oc mq lq od oe ms of bi translated">我的其他文章</h2><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/fast-database-fast-application-useful-db-performance-optimization-techniques-34b6926d1196"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">快速数据库—快速应用程序(有用的数据库性能优化技术)</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">了解加速关系数据库的最佳实践。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ks om"/></div></div></a></div><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-professionally-to-do-a-code-review-of-a-bug-fix-f17de72d42e0"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">如何专业地对Bug修复进行代码审查</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">审查bug修复时要问的几个重要问题。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa ks om"/></div></div></a></div><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/5-github-repositories-for-net-developers-to-take-tech-skills-to-the-next-level-84f244f6257b"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">5 GitHub。净回购，让你的技术技能更上一层楼</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">亲身体验GitHub资源库。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ov l"><div class="pc l ox oy oz ov pa ks om"/></div></div></a></div></div></div>    
</body>
</html>