<html>
<head>
<title>Mastering TypeScript Generics: The Ultimate Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握类型脚本泛型:最终指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mastering-typescript-generics-the-ultimate-guide-3a62afeff44?source=collection_archive---------5-----------------------#2022-12-27">https://levelup.gitconnected.com/mastering-typescript-generics-the-ultimate-guide-3a62afeff44?source=collection_archive---------5-----------------------#2022-12-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8a0378f23c3abd8d9f6046e59ec97738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XAKKiw1BY37eEllWfa0OTQ@2x.jpeg"/></div></div></figure><h1 id="3e02" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">目录</h1><ul class=""><li id="5414" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">无商标消费品</li><li id="7a3a" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">使用通用函数</li><li id="346b" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">通用约束</li><li id="e892" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">使用多个泛型</li><li id="acab" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">通用接口</li><li id="203b" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">通用类</li><li id="7847" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">通用实用程序类型</li></ul><h1 id="a2a2" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">无商标消费品</h1><p id="ca7b" class="pw-post-body-paragraph lw lx it lb b lc ld ly lz le lf ma mb lg mc md me li mf mg mh lk mi mj mk lm im bi translated">泛型允许函数和其他类型处理多种类型，同时仍然确保类型安全，支持重用。它们通常用于函数、接口和类中。在我们的日常工作中，我们经常会创建一些函数，这些函数接受某种类型的数据并返回相同类型的数据，这意味着参数和返回类型是相同的，如下所示:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="fac9" class="mu kc it mq b be mv mw l mx my">function identity&lt;T&gt;(arg: T): T {<br/>  return arg;<br/>}</span></pre><p id="fd88" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在此示例中，函数“identity”接受一个T类型的参数，并返回一个T类型的值。T类型是一个占位符，在调用该函数时将被替换为特定的类型。例如，如果我们使用参数“hello”调用函数，类型T将被替换为字符串类型，函数将返回字符串类型的值。</p><p id="642b" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">以前，为了允许函数接受任何类型，我们可以将参数类型更改为“any”。但是，这将失去TypeScript提供的类型安全性，使函数变得不安全。泛型允许我们保持类型安全，同时仍然使函数能够处理多种不同的类型，提供了灵活性和重用性。</p><h2 id="e58b" class="ne kc it bd kd nf ng dn kh nh ni dp kl lg nj nk kp li nl nm kt lk nn no kx np bi translated">使用通用函数</h2><p id="d468" class="pw-post-body-paragraph lw lx it lb b lc ld ly lz le lf ma mb lg mc md me li mf mg mh lk mi mj mk lm im bi translated">为了创建一个通用函数，我们在函数名后面添加了&lt;&gt;(尖括号)，并在括号内包含了一个类型变量。例如:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="75f8" class="mu kc it mq b be mv mw l mx my">function identity&lt;T&gt;(arg: T): T {<br/>  return arg;<br/>}</span></pre><p id="56f2" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">注意，泛型函数的类型变量可以是任何有效的变量名，而不仅仅是上面例子中的“T”。</p><p id="be9b" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">要调用通用函数，我们在尖括号中指定类型参数，如下所示:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="0de3" class="mu kc it mq b be mv mw l mx my">let output = identity&lt;string&gt;("hello");  // type of output is 'string'</span></pre><p id="5b6d" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">或者，我们可以使用类型推断来自动确定类型参数:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="97fc" class="mu kc it mq b be mv mw l mx my">let output = identity("hello");  // type of output is also 'string'</span></pre><p id="5dd6" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这种情况下，TypeScript将根据传递给该函数的参数类型推断该函数的类型参数是“string”。</p><p id="0a69" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">为了调用通用函数，我们在调用函数时在尖括号中指定类型参数:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="a150" class="mu kc it mq b be mv mw l mx my">let output = identity&lt;string&gt;("hello");  // type of output is 'string'</span></pre><p id="07de" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">或者，我们可以使用类型推断来自动确定类型参数:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="5b6b" class="mu kc it mq b be mv mw l mx my">let output = identity("hello");  // type of output is also 'string'</span></pre><p id="3ae6" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这种情况下，TypeScript将根据传递给该函数的参数类型推断该函数的类型参数是“string”。</p><p id="3be9" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">例如:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="887c" class="mu kc it mq b be mv mw l mx my">function identity&lt;T&gt;(arg: T): T {<br/>  return arg;<br/>}<br/>let output = identity&lt;string&gt;("hello");  // type of output is 'string'</span></pre><p id="7058" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">当调用泛型函数时，也可以省略类型参数<type>，因为TypeScript包含一个称为“类型参数推断”的机制，它可以根据传递给函数的参数类型自动推断类型变量的类型。这可以使代码更短，更容易阅读。</type></p><p id="ce33" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">例如:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="08b0" class="mu kc it mq b be mv mw l mx my">function identity&lt;T&gt;(arg: T): T {<br/>  return arg;<br/>}<br/>let output = identity("hello");  // type of output is inferred as 'string'</span></pre><p id="685d" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">请注意，在某些情况下，有必要显式指定类型参数，例如当编译器无法推断类型或推断的类型不准确时。</p><h1 id="d0c1" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">通用约束</h1><p id="f8fa" class="pw-post-body-paragraph lw lx it lb b lc ld ly lz le lf ma mb lg mc md me li mf mg mh lk mi mj mk lm im bi translated">默认情况下，泛型函数的类型变量可以表示多种类型，这意味着不可能访问任何属性。例如，试图使用泛型来获取字符串的长度会导致错误，因为泛型表示任何类型，并且不能保证特定属性的存在。在这种情况下，我们可以向泛型添加一个约束，以缩小可能类型的范围。</p><p id="fbcf" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">添加通用约束有两种主要方法:</p><ul class=""><li id="96b5" class="kz la it lb b lc mz le na lg nq li nr lk ns lm ln lo lp lq bi translated">指定更具体的类型:您可以将通用函数的类型修改为更具体的类型，以便访问其属性，如下所示:</li></ul><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="6d6e" class="mu kc it mq b be mv mw l mx my">function identity&lt;T extends string | number&gt;(arg: T): T {<br/>  console.log(arg.length);  // okay to access 'length' property<br/>  return arg;<br/>}<br/>let output = identity("hello");  // type of output is 'string'</span></pre><p id="02b7" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在本例中，类型变量T被约束为联合类型“string | number”，这意味着它只能是字符串或数字。这允许我们访问参数的“长度”属性，因为字符串和数字都有这个属性。</p><ul class=""><li id="cd71" class="kz la it lb b lc mz le na lg nq li nr lk ns lm ln lo lp lq bi translated">使用类型参数作为约束:也可以使用类型参数作为约束，方法是用“extends”关键字扩展它，如下所示:</li></ul><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="fc1c" class="mu kc it mq b be mv mw l mx my">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {<br/>  return obj[key];<br/>}<br/>let x = { a: 1, b: 2, c: 3, d: 4 };<br/>getProperty(x, "a");  // okay<br/>getProperty(x, "m");  // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.</span></pre><p id="5735" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个示例中，类型参数K被约束为t类型的键。这允许我们使用作为第二个参数传递的键来访问作为第一个参数传递的对象的属性。</p><p id="55a3" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">添加约束:您可以创建一个描述约束并提供所需属性的接口，然后使用“extends”关键字将约束添加到类型变量:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="d35f" class="mu kc it mq b be mv mw l mx my">interface Lengthwise {<br/>  length: number;<br/>}<br/>function identity&lt;T extends Lengthwise&gt;(arg: T): T {<br/>  console.log(arg.length);  // okay to access 'length' property<br/>  return arg;<br/>}<br/>let output = identity({ length: 10, value: 3 });  // type of output is { length: number, value: number }</span></pre><p id="9d58" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在本例中，类型变量T被约束为具有number类型的“length”属性的类型。这允许我们访问参数的“length”属性，该属性的类型为{ length: number，value: number }。</p><h1 id="b649" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">使用多个泛型</h1><p id="5933" class="pw-post-body-paragraph lw lx it lb b lc ld ly lz le lf ma mb lg mc md me li mf mg mh lk mi mj mk lm im bi translated">在泛型中可以有多个类型变量，并且可以基于一个类型变量约束另一个类型变量(例如，可以基于第一个类型变量约束第二个类型变量)。例如:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="223c" class="mu kc it mq b be mv mw l mx my">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {<br/>  return obj[key];<br/>}<br/>let x = { a: 1, b: 2, c: 3, d: 4 };<br/>getProperty(x, "a");  // returns 1</span></pre><p id="2954" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个示例中，函数“getProperty”有两个类型变量:T和K。类型变量T表示作为第一个参数传递的对象的类型，类型变量K表示作为第二个参数传递的键的类型。类型变量K被约束为T类型的键，这意味着它只能是作为第一个参数传递的对象的有效键的字符串。这允许我们使用键来访问对象的属性。</p><p id="7321" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">您还可以使用多个类型变量来创建更复杂的类型。例如:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="7719" class="mu kc it mq b be mv mw l mx my">function createPair&lt;T, U&gt;(first: T, second: U): [T, U] {<br/>  return [first, second];<br/>}<br/>let pair = createPair(1, "second");  // type of pair is [number, string]</span></pre><p id="4850" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在本例中，函数“createPair”有两个类型变量:T和U。该函数分别接受T和U类型的两个参数，并返回具有相同类型的元组。元组的类型是[T，U]，这意味着它是一对，第一个元素的类型是T，第二个元素的类型是U。</p><h1 id="35b3" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">通用接口</h1><p id="ddba" class="pw-post-body-paragraph lw lx it lb b lc ld ly lz le lf ma mb lg mc md me li mf mg mh lk mi mj mk lm im bi translated">为了创建一个通用接口，我们在接口名后面添加了一个类型变量。接口也可以和泛型一起使用，以增加灵活性和重用性。</p><p id="8c38" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">例如:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="61fd" class="mu kc it mq b be mv mw l mx my">interface Pair&lt;T, U&gt; {<br/>  first: T;<br/>  second: U;<br/>}<br/>let pair: Pair&lt;number, string&gt; = { first: 1, second: "second" };</span></pre><p id="4cb5" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个例子中，接口“pair”有两个类型变量:T和u。对象“Pair”的类型是“Pair <number string="">”，这意味着它是一个具有类型number的“第一”属性和类型string的“第二”属性的对象。</number></p><p id="8cfa" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">还可以使用泛型接口为函数创建类型别名:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="640d" class="mu kc it mq b be mv mw l mx my">type Callback&lt;T&gt; = (arg: T) =&gt; void;<br/>let callback: Callback&lt;string&gt; = (arg) =&gt; console.log(arg);</span></pre><p id="0156" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在此示例中，类型别名“callback”有一个类型变量t。变量“Callback”的类型是“Callback <string>”，这意味着它是一个采用类型string的单个参数且不返回值的函数。</string></p><p id="62bc" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">您还可以使用通用接口来约束对象的属性类型:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="43a0" class="mu kc it mq b be mv mw l mx my">interface Dictionary&lt;T&gt; {<br/>  [key: string]: T;<br/>}<br/>let dictionary: Dictionary&lt;number&gt; = { a: 1, b: 2, c: 3 };</span></pre><p id="771e" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个例子中，接口“dictionary”只有一个类型变量t。对象“Dictionary”的类型是“Dictionary <number>”，这意味着它是一个具有number类型属性的对象。接口的索引签名指定对象的键必须是字符串。这允许我们使用字符串键来访问对象的属性。</number></p><h1 id="430e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">通用类</h1><p id="065a" class="pw-post-body-paragraph lw lx it lb b lc ld ly lz le lf ma mb lg mc md me li mf mg mh lk mi mj mk lm im bi translated">像泛型接口一样，类也可以和泛型一起使用。</p><p id="ef2e" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">为了创建一个泛型类，我们在类名后添加一个类型变量，如下所示:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="1ec3" class="mu kc it mq b be mv mw l mx my">class Pair&lt;T, U&gt; {<br/>  constructor(public first: T, public second: U) {}<br/>}<br/>let pair = new Pair&lt;number, string&gt;(1, "second");</span></pre><p id="1094" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个例子中，类“pair”有两个类型变量:T和u。对象“Pair”的类型是“Pair <number string="">，这意味着它是一个具有类型number的“第一”属性和类型string的“第二”属性的对象。</number></p><p id="eafb" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">您还可以使用泛型类来约束对象的属性类型:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="cddd" class="mu kc it mq b be mv mw l mx my">class Dictionary&lt;T&gt; {<br/>  [key: string]: T;<br/>}<br/>let dictionary = new Dictionary&lt;number&gt;();<br/>dictionary.a = 1;<br/>dictionary.b = 2;<br/>dictionary.c = 3;</span></pre><p id="fe05" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个例子中，类“dictionary”只有一个类型变量t。对象“Dictionary”的类型是“Dictionary <number>”，这意味着它是一个具有number类型属性的对象。类的索引签名指定对象的键必须是字符串。这允许我们使用字符串键来访问对象的属性。</number></p><p id="6545" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">还可以使用泛型类为函数创建类型别名:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="2fa9" class="mu kc it mq b be mv mw l mx my">type Callback&lt;T&gt; = new (arg: T) =&gt; void;<br/>class MyClass&lt;T&gt; {<br/>  public value: T;<br/>  constructor(value: T) {<br/>    this.value = value;<br/>  }<br/>}<br/>let callback: Callback&lt;string&gt; = MyClass;<br/>let instance = new callback("value");</span></pre><p id="b290" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个例子中，类型别名“callback”有一个类型变量t。变量“Callback”的类型是“Callback <string>”，这意味着它是一个采用类型string的单个参数并且不返回值的类。“MyClass”类有一个类型变量T和一个采用T类型参数的构造函数。“instance”变量是“MyClass <string>”的实例，这意味着它是一个具有string类型的“value”属性的对象。</string></string></p><h1 id="f43e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">通用实用程序类型</h1><p id="0e1f" class="pw-post-body-paragraph lw lx it lb b lc ld ly lz le lf ma mb lg mc md me li mf mg mh lk mi mj mk lm im bi translated">“Partial <t>”实用程序类型用于构造T的所有属性都设置为可选的类型。当您希望创建一个基于现有类型的新类型，但某些属性是可选的时，这很有用。</t></p><p id="8335" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">例如:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="0a35" class="mu kc it mq b be mv mw l mx my">interface Person {<br/>  name: string;<br/>  age: number;<br/>  occupation: string;<br/>}<br/>type PartialPerson = Partial&lt;Person&gt;;<br/>// type PartialPerson = { name?: string; age?: number; occupation?: string; }<br/>let person: PartialPerson = {};</span></pre><p id="eff9" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个例子中，接口“Person”有三个必需的属性:“name”、“age”和“occupation”。“PartialPerson”类型是使用“Partial <t>”实用程序类型创建的，它具有与“Person”接口相同的属性，但它们都是可选的。“person”变量属于“PartialPerson”类型，这意味着它是一个具有可选“姓名”、“年龄”和“职业”属性的对象。</t></p><p id="9a3b" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">您还可以使用“Partial <t>”实用程序类型来创建一个类的部分版本:</t></p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="7933" class="mu kc it mq b be mv mw l mx my">class Person {<br/>  constructor(public name: string, public age: number, public occupation: string) {}<br/>}<br/>type PartialPerson = Partial&lt;Person&gt;;<br/>// type PartialPerson = { name?: string; age?: number; occupation?: string; }<br/>let person = new PartialPerson();</span></pre><p id="7122" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个例子中，“Person”类有三个必需的属性:“姓名”、“年龄”和“职业”。“PartialPerson”类型是使用“Partial <t>”实用程序类型创建的，它具有与“Person”类相同的属性，但是它们都是可选的。“person”变量是“PartialPerson”的实例，这意味着它是一个具有可选“姓名”、“年龄”和“职业”属性的对象。</t></p><p id="619c" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">其他实用程序类型包括:</p><ul class=""><li id="93ea" class="kz la it lb b lc mz le na lg nq li nr lk ns lm ln lo lp lq bi translated">Readonly <t>:创建一个T的所有属性都设置为只读的类型。</t></li><li id="4f4a" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">挑选<t k="">:通过从t中挑选一组属性K来创建一个类型</t></li><li id="ce86" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">记录<k t="">:创建一个具有t类型的一组属性K的类型。</k></li><li id="cf0c" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">Exclude <t u="">:通过从T中排除那些可赋给u的类型来创建一个类型。</t></li><li id="4c88" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">Extract <t u="">:通过从T中提取那些可赋给u的类型来创建一个类型。</t></li><li id="4715" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">省略<t k="">:通过从t中省略一组属性K来创建一个类型。</t></li></ul><h2 id="202b" class="ne kc it bd kd nf ng dn kh nh ni dp kl lg nj nk kp li nl nm kt lk nn no kx np bi translated">只读<t/></h2><p id="4698" class="pw-post-body-paragraph lw lx it lb b lc ld ly lz le lf ma mb lg mc md me li mf mg mh lk mi mj mk lm im bi translated">“Readonly <t>”实用程序类型用于构造T的所有属性都设置为只读的类型。当您希望创建基于现有类型的新类型，但所有属性都为只读时，这很有用。</t></p><p id="dd0c" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">例如:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="43c1" class="mu kc it mq b be mv mw l mx my">interface Person {<br/>  name: string;<br/>  age: number;<br/>  occupation: string;<br/>}<br/>type ReadonlyPerson = Readonly&lt;Person&gt;;<br/>// type ReadonlyPerson = { readonly name: string; readonly age: number; readonly occupation: string; }<br/>let person: ReadonlyPerson = { name: "John", age: 30, occupation: "Developer" };<br/>person.name = "Jane"; // error: cannot assign to 'name' because it is a read-only property</span></pre><p id="3698" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个例子中，界面“Person”有三个属性:“姓名”、“年龄”和“职业”。“ReadonlyPerson”类型是使用“Readonly <t>”实用程序类型创建的，它具有与“Person”接口相同的属性，但它们都是只读的。“person”变量属于“ReadonlyPerson”类型，这意味着它是一个具有只读“姓名”、“年龄”和“职业”属性的对象。</t></p><p id="ad96" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">您还可以使用“Readonly <t>”实用程序类型来创建类的只读版本:</t></p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="13e4" class="mu kc it mq b be mv mw l mx my">class Person {<br/>  constructor(public name: string, public age: number, public occupation: string) {}<br/>}<br/>type ReadonlyPerson = Readonly&lt;Person&gt;;<br/>// type ReadonlyPerson = { readonly name: string; readonly age: number; readonly occupation: string; }<br/>let person = new ReadonlyPerson("John", 30, "Developer");<br/>person.name = "Jane"; // error: cannot assign to 'name' because it is a read-only property</span></pre><p id="ac67" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个例子中，“Person”类有三个属性:“姓名”、“年龄”和“职业”。“ReadonlyPerson”类型是使用“Readonly <t>”实用程序类型创建的，它具有与“Person”类相同的属性，但它们都是只读的。“person”变量是“ReadonlyPerson”的实例，这意味着它是一个具有只读“姓名”、“年龄”和“职业”属性的对象。</t></p><h2 id="85db" class="ne kc it bd kd nf ng dn kh nh ni dp kl lg nj nk kp li nl nm kt lk nn no kx np bi translated">选择<t k=""/></h2><p id="a5e9" class="pw-post-body-paragraph lw lx it lb b lc ld ly lz le lf ma mb lg mc md me li mf mg mh lk mi mj mk lm im bi translated">“Pick <t k="">”实用程序类型用于通过从t中选取一组属性K来创建一个新类型。当您想要创建一个基于现有类型的新类型，但只有一个属性子集时，这很有用。</t></p><p id="665e" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">例如:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="29a7" class="mu kc it mq b be mv mw l mx my">interface Person {<br/>  name: string;<br/>  age: number;<br/>  occupation: string;<br/>}<br/>type NameAge = Pick&lt;Person, "name" | "age"&gt;;<br/>// type NameAge = { name: string; age: number; }<br/>let person: NameAge = { name: "John", age: 30 };</span></pre><p id="4d89" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个例子中，界面“Person”有三个属性:“姓名”、“年龄”和“职业”。“NameAge”类型是使用“Pick <t k="">”实用程序类型创建的，它只有来自“Person”接口的“name”和“Age”属性。“person”变量属于“NameAge”类型，这意味着它是一个具有“name”和“Age”属性的对象。</t></p><p id="5a74" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">您也可以使用“Pick <t k="">”实用程序类型从一个类中创建一个新的类型:</t></p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="81bf" class="mu kc it mq b be mv mw l mx my">class Person {<br/>  constructor(public name: string, public age: number, public occupation: string) {}<br/>}<br/>type NameAge = Pick&lt;Person, "name" | "age"&gt;;<br/>// type NameAge = { name: string; age: number; }<br/>let person = new Person("John", 30, "Developer");<br/>let nameAge: NameAge = { name: person.name, age: person.age };</span></pre><p id="a214" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个例子中，“Person”类有三个属性:“姓名”、“年龄”和“职业”。“NameAge”类型是使用“Pick <t k="">”实用程序类型创建的，它只有来自“Person”类的“name”和“Age”属性。“person”变量是“Person”的实例，“namAge”变量是“namage”类型，这意味着“namage”变量是“namage”类型，这意味着它是一个具有“name”和“age”属性的对象。“nameAge”变量是通过从“person”对象中提取“name”和“Age”属性创建的，该对象是“Person”类的一个实例。</t></p><h2 id="51ae" class="ne kc it bd kd nf ng dn kh nh ni dp kl lg nj nk kp li nl nm kt lk nn no kx np bi translated">记录<k t=""/></h2><p id="e5cf" class="pw-post-body-paragraph lw lx it lb b lc ld ly lz le lf ma mb lg mc md me li mf mg mh lk mi mj mk lm im bi translated">“Record <k t="">”实用程序类型用于创建一个表示键K和值t的记录(字典)的类型。当您想要创建一个表示具有特定类型的一组固定键和值的对象的类型时，这很有用。</k></p><p id="d5e2" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">例如:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="f08b" class="mu kc it mq b be mv mw l mx my">type UserId = Record&lt;"id", number&gt;;<br/>// type UserId = { id: number; }<br/>let userId: UserId = { id: 123 };</span></pre><p id="a59c" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在本例中，“UserId”类型是使用“Record <k t="">”实用程序类型创建的，它表示一个具有“number”类型的单个“Id”属性的对象。“UserId”变量属于“userId”类型，这意味着它是一个具有“number”类型的“Id”属性的对象。</k></p><p id="8e9e" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">您还可以使用“Record <k t="">”实用程序类型来创建一个表示具有多个键和值的对象的类型:</k></p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="b0fb" class="mu kc it mq b be mv mw l mx my">type User = Record&lt;"id" | "name" | "age", number | string&gt;;<br/>// type User = { id: number; name: string; age: number; }<br/>let user: User = { id: 123, name: "John", age: 30 };</span></pre><p id="b7ec" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">在这个例子中,“User”类型是使用“Record <k t="">”实用程序类型创建的，它表示一个具有三个属性的对象:“number”类型的“id”、“string”类型的“name”和“number”类型的“age”。“user”变量属于“User”类型，这意味着它是一个具有相应类型的“id”、“name”和“age”属性的对象。</k></p><h2 id="b1c3" class="ne kc it bd kd nf ng dn kh nh ni dp kl lg nj nk kp li nl nm kt lk nn no kx np bi translated">延伸阅读:</h2><ul class=""><li id="41b8" class="kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><a class="ae nt" rel="noopener ugc nofollow" target="_blank" href="/typescript-must-know-fundamentals-for-your-next-tech-interview-or-project-255ae70df0a3"> TypeScript必备基础知识—类型别名和接口</a></li><li id="6067" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nt" rel="noopener ugc nofollow" target="_blank" href="/use-typescript-keyof-like-a-pro-56f3a3d06b73">像专业人士一样使用Typescript keyof】</a></li><li id="81d8" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nt" rel="noopener ugc nofollow" target="_blank" href="/typescript-classes-from-zero-to-hero-a429a3c96189">打字稿类——从零到英雄</a></li><li id="c559" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nt" rel="noopener ugc nofollow" target="_blank" href="/next-level-your-typescript-runtime-type-validation-using-class-and-decorators-ddd2ce3c86f3">使用类和装饰器的下一级Typescript运行时类型验证</a></li><li id="c096" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nt" href="https://bootcamp.uxdesign.cc/typescript-tricks-and-tips-become-a-pro-in-no-time-5390aba151be" rel="noopener" target="_blank">打字技巧和提示:立即成为专业人士</a></li><li id="f813" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nt" rel="noopener ugc nofollow" target="_blank" href="/generics-in-typescript-must-know-fundamentals-stupidly-simplified-e7b4d7ffc0e3">打字稿中的泛型——基础知识被愚蠢地简化</a></li><li id="c0f9" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nt" rel="noopener ugc nofollow" target="_blank" href="/typescript-missed-this-but-you-shouldnt-runtime-type-validation-aa8a81ce4289"> Typescript遗漏了这一点，但你不应该—运行时类型验证</a></li><li id="ff23" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nt" rel="noopener ugc nofollow" target="_blank" href="/typescript-enum-pitfalls-and-solutions-must-know-bb971cb0f7d2"> Typescript枚举陷阱和解决方案必须知道</a></li><li id="27e6" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nt" href="https://bootcamp.uxdesign.cc/mastering-typescript-generics-the-ultimate-guide-essential-interface-techniques-86e793cf1fc" rel="noopener" target="_blank">掌握TypeScript泛型—终极指南—基本接口技术</a></li><li id="0a9f" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">【Javascript开发者经常忽略的Typescript特性</li><li id="bc34" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated"><a class="ae nt" rel="noopener ugc nofollow" target="_blank" href="/mastering-intersection-and-union-types-in-typescript-the-ultimate-guide-essential-techniques-49aa9f6a188a">掌握TypeScript中的交集和并集类型:终极指南和基本技巧</a></li></ul></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="8571" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">如果你觉得这个指南有帮助，请鼓掌并跟我来。通过<a class="ae nt" href="https://medium.com/@caopengau/membership" rel="noopener">链接</a>加入medium，在medium上访问我和所有其他优秀作家的所有优质文章。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="277e" class="kb kc it bd kd ke ob kg kh ki oc kk kl km od ko kp kq oe ks kt ku of kw kx ky bi translated">分级编码</h1><p id="4363" class="pw-post-body-paragraph lw lx it lb b lc ld ly lz le lf ma mb lg mc md me li mf mg mh lk mi mj mk lm im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="05e3" class="kz la it lb b lc mz le na lg nq li nr lk ns lm ln lo lp lq bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="5628" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">📰查看<a class="ae nt" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="8243" class="kz la it lb b lc lr le ls lg lt li lu lk lv lm ln lo lp lq bi translated">🔔关注我们:<a class="ae nt" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae nt" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nt" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="c773" class="pw-post-body-paragraph lw lx it lb b lc mz ly lz le na ma mb lg nb md me li nc mg mh lk nd mj mk lm im bi translated">🚀👉<a class="ae nt" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>