<html>
<head>
<title>C# .NET — JSON Deserialization with System.Net.Http.Json and HttpClient</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#。用System反序列化。Json和HttpClient</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/c-net-json-deserialization-with-system-net-http-json-and-httpclients-9f49ffb7d9e3?source=collection_archive---------0-----------------------#2021-11-10">https://levelup.gitconnected.com/c-net-json-deserialization-with-system-net-http-json-and-httpclients-9f49ffb7d9e3?source=collection_archive---------0-----------------------#2021-11-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="541b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">简单的JSON反序列化。NET内置库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a2ddb7c8ae0f86b064af910515926eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ta2FUhAFJXU2X727OcFq9w.png"/></div></div></figure><p id="11c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">老派。NET开发人员非常熟悉Newtonsoft。Json，因为它一直是在。NET框架并没有对它提供很好的支持。</p><p id="4b3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不久前，从。网核3，后面的团队。NET引入了新的命名空间——System。Json——包含一组很酷的内置特性来处理Json序列化和反序列化。</p><p id="5b5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最近，我们又接触到了System.Net.Http.Json。</p><p id="1103" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个命名空间建立在系统之上。JSON，并通过扩展方法与HttpClients完全集成，以便在涉及rest APIs的HTTP调用期间实现更容易的Json序列化和反序列化。</p><p id="fc8c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们以一个简单的<strong class="kw iu"> HTTP GET </strong>操作为例，看看发生了什么变化，该操作从网络中检索一些JSON信息，并将其反序列化为MyObject实例:</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="4cda" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">牛顿软件:旧的做事方式</h1><p id="2214" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">下面是我们过去如何使用旧的Newtonsoft类做事情的一个片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0b73" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总的来说，这段代码工作得很好，但也带来了一定程度的复杂性，包括一些HTTP相关的语句、一些低级的流操作，以及最后GET操作内容的反序列化。</p><p id="dd34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有这些复杂性常常导致开发人员实现一个更短但不是最佳的反序列化例程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="fd49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这也很好，但众所周知，为了创建另一个对象而创建中间字符串并丢弃初始字符串完全是浪费内存，并且经常会导致更多的<strong class="kw iu"> <em class="mw">应用程序暂停</em> </strong>，因为需要更多的GC周期来清理内存。</p><p id="a023" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于大型JSON对象来说尤其如此。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="d892" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">新的选择:系统。Json</h1><p id="025f" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">新系统。Net.Http.Json命名空间为我们提供了一些序列化和反序列化Json的替代方法。下面是我们如何使用<code class="fe mx my mz na b">ReadFromJsonAsync</code>扩展方法反序列化HTTP内容的一个片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="84a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用<code class="fe mx my mz na b">GetFromJsonAsync</code>扩展方法，也可以跳过对状态代码的检查，而选择空检查:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a054" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上述选项提供了简单性和效率之间的完美结合，因为处理底层流和正确反序列化JSON对象的所有复杂性都从框架中抽象出来并内置到框架中。</p><p id="eb55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您真的喜欢一行程序，我们的最后一段代码仍然可以进一步简化为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="b112" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外两个有趣的方法是<code class="fe mx my mz na b">PostAsJsonAsync</code>和<code class="fe mx my mz na b">PutAsJsonAsync</code>。两者的工作方式非常相似，都是根据各自的HTTP方法。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="afc3" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">你可能也喜欢</h1><div class="nb nc gp gr nd ne"><a rel="noopener  ugc nofollow" target="_blank" href="/avoiding-array-pitfalls-in-c-net-a229a29bc45d"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">避免C#中的数组陷阱。网</h2><div class="nl l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ks ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener  ugc nofollow" target="_blank" href="/8-hidden-visual-studio-features-26723606631b"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">8个隐藏的Visual Studio功能</h2><div class="ns l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">掌握Visual Studio快捷方式和隐藏功能</h3></div><div class="nl l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nm l"><div class="nt l no np nq nm nr ks ne"/></div></div></a></div><h1 id="d727" class="lx ly it bd lz ma nu mc md me nv mg mh jz nw ka mj kc nx kd ml kf ny kg mn mo bi translated">参考</h1><ul class=""><li id="07f3" class="nz oa it kw b kx mp la mq ld ob lh oc ll od lp oe of og oh bi translated"><a class="ae oi" href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to?pivots=dotnet-6-0" rel="noopener ugc nofollow" target="_blank">如何在？网络</a></li><li id="6cd6" class="nz oa it kw b kx oj la ok ld ol lh om ll on lp oe of og oh bi translated"><a class="ae oi" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.json?view=net-5.0" rel="noopener ugc nofollow" target="_blank">系统。Net.Http.Json名称空间</a></li></ul></div></div>    
</body>
</html>