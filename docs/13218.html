<html>
<head>
<title>Java Memory Model: Practical Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java内存模型:实用指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-memory-model-practical-guide-java-1cbdccc3e3b1?source=collection_archive---------2-----------------------#2022-08-18">https://levelup.gitconnected.com/java-memory-model-practical-guide-java-1cbdccc3e3b1?source=collection_archive---------2-----------------------#2022-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="994b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">JVM的家伙们！✌️:你想了解更多关于Java内存模型的知识(从这里开始— <strong class="jp ir"> JMM </strong>)并查看它的实用指南吗？然后深入研究这篇文章😁。</p><blockquote class="ku kv kw"><p id="aa52" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated"><strong class="jp ir">免责声明:</strong>我已经搜索了很多资源，在整篇文章和文章末尾都可以找到这些资源的链接。尽管如此，我不是布莱恩·戈茨或阿列克谢·希皮列夫那样的大师。这就是为什么如果你有任何问题，偶然发现错误或什么的，请随时发表评论或给我发电子邮件。</p></blockquote><p id="4a53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">文章结构👓：</p><ul class=""><li id="e4ee" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">介绍</li><li id="711b" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">CS理论</li><li id="323e" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">出版</li><li id="bad4" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">内存模型概述:开始</li><li id="0260" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">硬件图片</li><li id="f65b" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">总订单与部分订单</li><li id="6f95" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">内存模型概述:读写素材<br/> -易失性<br/> -同步<br/> -线程开始<br/> -最终</li><li id="c8fa" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">更多关于volatile</li><li id="79a4" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">结尾部分</li></ul><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/7742d7854254fcede782be42e8ab1392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4-u2p23nmMpN83q5TGfag.jpeg"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">强大而可爱的爪哇👻</figcaption></figure></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h2 id="8302" class="mm mn iq bd mo mp mq dn mr ms mt dp mu jy mv mw mx kc my mz na kg nb nc nd ne bi translated">介绍</h2><p id="3fd2" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">许多人会回避JMM和与它相关的一切，因为在各种文章中很难解释😥然而，就我个人而言，我研究了各种文章、书籍的章节、视频，发现……理解起来非常困难，但如果我们从实践者的角度来说，并非不可能🙌。由于对这个问题的实际方面更感兴趣，我决定强调它，然后在本文中纪念它，以便其他人理解它。</p><h2 id="f1f2" class="mm mn iq bd mo mp mq dn mr ms mt dp mu jy mv mw mx kc my mz na kg nb nc nd ne bi translated">CS理论</h2><p id="3b3c" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">首先，当我们谈论处理器和与之相关的一切时，让我们来看看我们的电脑中的核心概念。我不会在这里深入讨论细节，但是给出一个大概的概述，这对于现在来说已经足够了。</p><p id="f961" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我创建了一个图表，非常简单明了🤯。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi nk"><img src="../Images/b1cf43172cc6394b820915a8ed8bb1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kl9GDb-gcNmRaVj7QT4UMw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">表示数据和处理器之间关系的图表</figcaption></figure><p id="c724" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，处理器将数据从RAM加载到缓存中。它不能直接对来自RAM的数据进行操作，即使可以，也太慢了。处理器做出更改后，会将其写回RAM。因此，JVM将通过组合或转换变量来优化代码。在<strong class="jp ir">内存模型概述</strong>部分有更多相关信息。</p><p id="7e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果多个处理器获取了同一个变量，在本地缓存中对其进行了更改，并需要将其写回，会发生什么情况呢？对于这样的问题，有<strong class="jp ir">缓存一致性</strong>。</p><blockquote class="ku kv kw"><p id="cb89" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated">共享内存多处理器体系结构:每个处理器都有自己的缓存，与主内存相协调。</p></blockquote><p id="17f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有3种类型的<strong class="jp ir">高速缓存一致性</strong> ➿:</p><ul class=""><li id="4ecd" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">立即写入</li><li id="358b" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">看到一系列操作数</li><li id="fcba" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">无粘聚力的</li></ul><p id="8b92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阅读下面的文章，了解有关高速缓存一致性的更多信息:</p><div class="nl nm gp gr nn no"><a href="https://www.geeksforgeeks.org/cache-coherence/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">缓存一致性- GeeksforGeeks</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">先决条件-高速缓冲存储器高速缓冲存储器一致性:在多处理器系统中，相邻的高速缓冲存储器之间可能发生数据不一致</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc lz no"/></div></div></a></div><p id="8fde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">❗️ <strong class="jp ir">请，非常仔细地读台词直到画面。我会告诉你下来线回到这里</strong> ❗️ <strong class="jp ir"> : </strong></p><p id="ccae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">处理器放松内存一致性=提高性能</p><p id="7512" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当在多个处理器之间共享数据时，我们需要协调数据:</p><ul class=""><li id="06f5" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">架构的内存模型指定了<em class="kx">内存屏障/栅栏</em>以在共享数据时获得数据协调(JVM减少了我们对所有这些东西的关心，但有些情况将在<strong class="jp ir">硬件图片</strong>块中查看)</li><li id="7019" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kx">顺序一致性</em> </strong> —程序执行的单一顺序。每次读取都会看到最后一次写入。没有什么(甚至JMM)不能保证这一点。但是我们可以试着用… <strong class="jp ir">达到它的某些部分，阅读下一个项目符号</strong></li><li id="9f2a" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">如果不使用<em class="kx">内存屏障</em> - &gt;共享内存多处理器&amp;编译器可以做各种事情。在Java中我们不需要使用<em class="kx">内存屏障</em>，而是识别<em class="kx">共享状态</em>和<strong class="jp ir">杠杆同步</strong>。</li><li id="66e8" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir"> <em class="kx">排序</em></strong>——操作可能延迟或出现无序的情况。也就是说，对于两个线程，JMM可以允许以不同的顺序执行操作= &gt;使用<strong class="jp ir">同步</strong>来防止编译器、运行时、硬件对违反<em class="kx">可见性保证</em>的操作进行重新排序。</li></ul><p id="68c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将进一步了解同步关闭器<strong class="jp ir">内存模型概述:读写内容</strong></p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi od"><img src="../Images/f0735bcbfcef352909ac12f926b3f387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhdIhxM02u3OVCgQqAkY6w.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">显示缓存关系的图表</figcaption></figure><p id="08f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想深入了解，请阅读下面的文章:</p><div class="nl nm gp gr nn no"><a href="https://www.geeksforgeeks.org/cache-memory-in-computer-organization/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">计算机组织中的高速缓存</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">高速缓冲存储器是一种特殊的超高速存储器。它用于加速和与高速CPU同步。缓存…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="nx l"><div class="oe l nz oa ob nx oc lz no"/></div></div></a></div><h2 id="e323" class="mm mn iq bd mo mp mq dn mr ms mt dp mu jy mv mw mx kc my mz na kg nb nc nd ne bi translated">🛠出版物</h2><p id="804e" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">什么是出版？这是一个允许在当前范围之外访问对象的过程。有什么问题吗？请务必记住，如果您执行以下操作:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7059" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么值<code class="fe oh oi oj ok b">states</code>已经被<strong class="jp ir">转义</strong>。这意味着由于<code class="fe oh oi oj ok b">private</code>修饰符，它不应该在类的范围之外使用，但是<code class="fe oh oi oj ok b">public</code>方法修饰符完成了它的脏工作。所以，任何人都可以修改<code class="fe oh oi oj ok b">states</code>变量。</p><blockquote class="ku kv kw"><p id="c394" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated">阅读第3.2章<em class="iq">发布和转义</em><strong class="jp ir">《Java并发实践》。</strong></p></blockquote><p id="b057" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们进一步了解<em class="kx">出版物</em>:</p><p id="98c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说到<strong class="jp ir">不可变对象</strong>，有特别的要求<strong class="jp ir">(都必须完成才能达到真正的不可变状态)</strong>:</p><ul class=""><li id="6462" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">不可修改的状态。阅读此处了解更多信息:</li></ul><div class="nl nm gp gr nn no"><a href="https://www.geeksforgeeks.org/create-immutable-class-java/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">如何在Java中创建不可变类？- GeeksforGeeks</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">java中的不可变类意味着一旦一个对象被创建，我们就不能改变它的内容。在Java中，所有的包装器…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="nx l"><div class="ol l nz oa ob nx oc lz no"/></div></div></a></div><ul class=""><li id="69be" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">所有的领域都是<code class="fe oh oi oj ok b">final</code></li><li id="c3fd" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">安全初始化。看看这个SO帖子:</li></ul><div class="nl nm gp gr nn no"><a href="https://stackoverflow.com/a/11307418/16543524" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">请解释Java内存模型中的初始化安全</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">初始化安全提供了一个外部线程可以看到的完全构造(初始化)的对象…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">stackoverflow.com</p></div></div><div class="nx l"><div class="om l nz oa ob nx oc lz no"/></div></div></a></div><p id="7dfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;我们可以创建没有任何<code class="fe oh oi oj ok b">synchronized</code>关键字的对象。</p><p id="9667" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，有些事情会破坏安全初始化，因此我们需要使用同步:❗️</p><ul class=""><li id="0750" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">状态是非<code class="fe oh oi oj ok b">final</code></li><li id="9f46" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">除构造函数之外的任何方法都会修改其内容</li></ul><p id="84f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;如果你允许其他线程(或者只是类之外的范围)访问非<code class="fe oh oi oj ok b">final</code>字段，一定要使用同步。</p><ul class=""><li id="d2f1" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">一个好的做法是返回对象的深层副本，而不是对象本身。此外，在设置时，设置一个新对象也是一个好主意:</li></ul><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="af33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在针对<strong class="jp ir">可变对象</strong>。下面写的其中一个一定是accomplished❗️:</p><ul class=""><li id="f7c3" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">从静态初始化器初始化对象引用:<code class="fe oh oi oj ok b">public static Example ex = new Example(32);</code></li><li id="ddc1" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">将对对象的引用存储在<code class="fe oh oi oj ok b">volatile</code>或<code class="fe oh oi oj ok b">atomic</code>字段引用中</li><li id="a490" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">将对对象的引用存储到一个<code class="fe oh oi oj ok b">final</code>字段中，或者用锁来保护它</li></ul><p id="2d99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">但是为什么要对初始化之类的事情大惊小怪呢？我们将在</strong> <code class="fe oh oi oj ok b"><strong class="jp ir">final</strong></code> <strong class="jp ir">字段解释中查看。</strong></p><p id="a7f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何安全的分享对象？</p><ul class=""><li id="ff26" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ir">线程受限:</strong>对象被一个线程拥有，并且被它修改</li><li id="093a" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir">共享只读:</strong>对象可以被多个线程访问，不需要额外的同步，但是不能被任何线程修改。它适用于不可变的和实际上不可变的对象(技术上不是不可变的，但实际上是不可变的)</li><li id="9c2e" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir">共享线程安全:</strong>对象内部有同步(即<code class="fe oh oi oj ok b">atomic</code>变量。我们稍后将回到他们身上)</li><li id="3071" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ir">受保护:</strong>由特定锁保护的对象(即<code class="fe oh oi oj ok b">synchronized)</code></li></ul><h2 id="7ca3" class="mm mn iq bd mo mp mq dn mr ms mt dp mu jy mv mw mx kc my mz na kg nb nc nd ne bi translated">内存模型概述🙌🏽</h2><p id="884f" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">首先，看完我的文章后，一定要查一下Oracle关于并发的教程。它可能看起来很长，但绝对值得一读:</p><div class="nl nm gp gr nn no"><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">课程:并发</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Java教程是为JDK 8编写的。本页中描述的示例和实践没有利用…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">docs.oracle.com</p></div></div></div></a></div><p id="3072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一部分中，我们将看看它是如何工作的核心概念，以及你可以使用哪些工具来防止自己犯下严重的错误。</p><p id="38e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编译器可能不按照written⚙️:的顺序执行代码</p><ul class=""><li id="1afd" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">处理器可以并行执行指令(我们已经看到了上面的例子)</li><li id="f17a" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">缓存改变了变量写入提交到主内存的顺序</li><li id="8c2e" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">本地处理器缓存中的变量可能对其他处理器缓存不可见(向<strong class="jp ir">缓存一致性</strong>问好)</li><li id="b236" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">将变量存储在寄存器中，而不是内存中(同样，你好<strong class="jp ir"> L1缓存</strong></li></ul><p id="cfd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kx">线程内as-if-serial: </em> </strong> <em class="kx"> </em>写在高级程序中的指令，不保证在低级中以相同的顺序运行。但是结果是一样的。<strong class="jp ir">单线程程序为真</strong>。对于并发程序，<strong class="jp ir">不为真</strong>。这是什么意思？让我们看得更远:</p><p id="5781" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我们的代码流程</strong> 🪢 <strong class="jp ir"> : </strong></p><ol class=""><li id="fc62" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk on lh li lj bi translated">Java源代码</li><li id="4b4c" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">将它编译成字节码</li><li id="478e" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">JVM优化字节码(转换它等等)。我们以后会看这个例子。</li><li id="27f4" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">JVM用<strong class="jp ir">解释器</strong>解释部分代码，并借助<strong class="jp ir"> JIT编译器</strong>将字节码编译成机器码。</li></ol><p id="39ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阅读以下文章了解更多信息:</p><div class="nl nm gp gr nn no"><a href="https://programmerbay.com/how-does-jvm-convert-bytecode-into-machine-code/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">JVM如何把字节码转换成机器码？程序员海湾</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">JVM如何把字节码转换成机器码？JVM ( Java虚拟机)接收生成的字节码…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">programmerbay.com</p></div></div><div class="nx l"><div class="oo l nz oa ob nx oc lz no"/></div></div></a></div><p id="afeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我上面谈到的转变是什么？JVM很聪明，如果我们在不同的地方使用相同的变量或者类似的东西，它可以发现。</p><p id="d69b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">顺序不一致</strong></p><p id="1b77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先看看我们源代码的第一个例子，然后看看优化版本:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="14f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，我们的代码被修改了。但听起来不像是坏事，对吧？唉，如果我们谈论单线程——一切都很好，但是如果我们谈论多线程呢？在这里，我们可能会掉进陷阱，得不到我们想要的价值。这是一个非常简单的例子，如果我们谈论高负载服务，会发生什么？</p><p id="d99c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">最终一致性</strong></p><p id="9031" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这不是关于NoSQL数据库，而是Java。是的，我们的代码里有一些。让我们看看下面的例子:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8d7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，JVM优化了部分代码，在这些代码中，它看不到在<em class="kx">方法</em>的作用域中使用的变量(尽管这可能不仅仅发生在方法的作用域中)。</p><p id="17b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确保没有类似的事情发生，我们需要遵循<strong class="jp ir"> <em class="kx">发生——先于</em> </strong>的咒语。我们将在<strong class="jp ir">内存模型概述:读写材料</strong>部分中查看它。</p><h2 id="0841" class="mm mn iq bd mo mp mq dn mr ms mt dp mu jy mv mw mx kc my mz na kg nb nc nd ne bi translated">硬件图片🦾</h2><p id="ca93" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">虽然JVM让我们不用考虑我们的应用程序运行在什么架构上，就像我们不需要考虑L1缓存或任何与之相关的东西，但我们仍然需要记住我们的应用程序运行在什么架构上。</p><p id="c44a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看下表。ARM和x86是两种不同的架构。它展示了<strong class="jp ir">各种系统如何优化操作</strong>(或者根本不优化)。</p><ul class=""><li id="e0a1" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">负载==读取</li><li id="3bcc" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">存储==写入</li></ul><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div class="gh gi op"><img src="../Images/2d99442db44fdc235623b89358aa0a0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*cSTnI6THDhv9PclxEnksXQ.png"/></div></figure><p id="23e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在X86上流畅运行的应用程序可能会在ARM上出现问题。</p><h2 id="6fed" class="mm mn iq bd mo mp mq dn mr ms mt dp mu jy mv mw mx kc my mz na kg nb nc nd ne bi translated">总订单与部分订单</h2><p id="192e" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">我不是给你数学公式的数学专家，而是对问题的实际方面更感兴趣的工程师。我将向您概述这两个东西，并进一步向您展示它们的用途。</p><p id="fa9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">总顺序:</strong>小于——<em class="kx">集合()</em>中的任何数字都可以与之相关</p><p id="673f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">偏序:</strong>可除数——不能应用任何数字</p><blockquote class="ku kv kw"><p id="c38a" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated">线程程序—部分订单，而串行程序—全部订单</p></blockquote><p id="50fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看这个SO帖子，获得更多的学术解释:</p><div class="nl nm gp gr nn no"><a href="https://stackoverflow.com/a/59909382/16543524" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">“同步操作是完全有序的”是什么意思？</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">分析“同步动作是完全有序的”这句话:“同步动作”是一组程序…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">stackoverflow.com</p></div></div><div class="nx l"><div class="oq l nz oa ob nx oc lz no"/></div></div></a></div><p id="d6af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JMM定义了<strong class="jp ir">偏序</strong> — <strong class="jp ir"> <em class="kx">发生在</em> </strong> <em class="kx"> </em>之前(在下一章，我们会更仔细地研究它)。没有它——JVM可以随意重新排序。没有<strong class="jp ir"> <em class="kx">数据竞争</em> </strong> —即2个线程读取，1个线程写入。</p><blockquote class="ku kv kw"><p id="a525" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated"><strong class="jp ir">数据竞争</strong> —称为<strong class="jp ir">竞争条件</strong>(或<strong class="jp ir">螺纹干涉</strong>)。当2个以上的线程读/写同一个变量时，结果变量值变得混乱(回想一下我谈到缓存的第一部分)</p><p id="1d8d" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated">正确同步的程序表现出<em class="iq">顺序一致性</em>。</p><p id="726d" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated">同步动作— <code class="fe oh oi oj ok b">lock</code>获取和释放，<code class="fe oh oi oj ok b">volatile</code>变量的读取和写入被<strong class="jp ir">完全排序</strong></p></blockquote><h2 id="5bd3" class="mm mn iq bd mo mp mq dn mr ms mt dp mu jy mv mw mx kc my mz na kg nb nc nd ne bi translated">内存模型概述:读写stuff🖊📃</h2><p id="bdbd" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">Java中有一些特殊的词可以帮助我们告诉JVM在某些问题可能发生时不要进行优化。Ta-dam:引入引入总订单的附加<strong class="jp ir">同步动作</strong>。如果没有这样的关键字，可能会出现数据竞争(弱记忆模型)。</p><p id="5035" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">同步动作</strong>代表什么，有哪些关键词？<strong class="jp ir">看下面:</strong></p><p id="274f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">字段范围:</strong> <code class="fe oh oi oj ok b">final</code>，<code class="fe oh oi oj ok b">volatile</code></p><p id="ff6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">方法作用域:</strong> <code class="fe oh oi oj ok b">synchronized</code>，<code class="fe oh oi oj ok b">java.util.concurrent.*</code></p><blockquote class="ku kv kw"><p id="69cf" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated">请注意，像<code class="fe oh oi oj ok b">volatile</code>、<code class="fe oh oi oj ok b">synchronized</code>这样的词会降低性能。明智地应用它们</p></blockquote><p id="8218" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，回来重读以<em class="kx">“处理器放松内存……”</em>开头的单词。</p><blockquote class="ku kv kw"><p id="3701" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated">记住，JMM转换代码来优化它。并且可能存在平台差异。</p></blockquote><p id="c488" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其实，<strong class="jp ir"> <em class="kx">是怎么回事——之前</em> </strong>文章中多次提到？</p><blockquote class="ku kv kw"><p id="1f0f" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated"><strong class="jp ir">发生在</strong>之前——定义<strong class="jp ir">一个字段</strong>的写和读操作之间顺序的规则。如果这样的规则适用，JMM保证返回特定的/正确的值(没有内存不一致的问题)</p></blockquote><ul class=""><li id="4225" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">线程看到由它/另一个线程写入的实际数据</li><li id="4e17" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">只有在这个/另一个线程释放了对象上的监视器锁之后，才能获取该对象上的监视器锁</li></ul><p id="2cb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯？监视器锁定？实际上，每个对象都有锁，它会告诉其他线程这个对象是否空闲。</p><p id="7f2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阅读以下文章了解更多信息:</p><div class="nl nm gp gr nn no"><a href="https://howtodoinjava.com/java/multi-threading/multithreading-difference-between-lock-and-monitor/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">锁和监视器的区别——Java并发性</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">你可能在面试中面对过这个问题，锁和显示器有什么区别？嗯，为了…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">howtodoinjava.com</p></div></div><div class="nx l"><div class="or l nz oa ob nx oc lz no"/></div></div></a></div><blockquote class="ku kv kw"><p id="4fa6" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated">在多线程环境中，每个线程做自己的事情。如果不需要的话，我们不需要让它们互相协调，因为这会显著降低应用程序的速度。只有在共享数据的情况下，我们才需要通过使用<strong class="jp ir">同步</strong>来协调线程</p><p id="438a" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated">注意:<strong class="jp ir">处理器</strong>有缓存，但是<strong class="jp ir">线程</strong>没有</p></blockquote><p id="5fb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">易变</strong></p><p id="6107" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有写在<code class="fe oh oi oj ok b">volatile</code>之前的变量都被持久化。<code class="fe oh oi oj ok b">volatile</code>之后的所有读数都是最新的。这是一个著名的<strong class="jp ir">发生在</strong>之前的顺序。</p><p id="18b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">同步顺序</strong> —写入和读取之间。</p><p id="34d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用<strong class="jp ir">最终一致性(！！！从上面回忆一下！！！)</strong> —线程在写入易失性字段时，将所有数据从缓存刷新到主存储器。读取易失性字段的线程也是如此，但顺序相反。</p><p id="3b88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看下面的例子。无挥发物</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8433" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么<code class="fe oh oi oj ok b">volatile</code>会营救我们？如果应用于<code class="fe oh oi oj ok b">ready</code>字段，我们将:</p><ul class=""><li id="1ba5" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">参见<code class="fe oh oi oj ok b">threadOne()</code>中的<code class="fe oh oi oj ok b">ready</code>，读取它，更新值(当<code class="fe oh oi oj ok b">volatile</code>域被读取时，所有数据从缓存中刷新)</li><li id="3999" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">在<code class="fe oh oi oj ok b">threadTwo()</code>中，我们首先写入非易失性存储器，然后写入<code class="fe oh oi oj ok b">volatile</code>。这样，我们也将所有数据从缓存中刷新到内存中。</li></ul><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi os"><img src="../Images/5032e5ba5570b16de685f52db7c00a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mDlkM3xVASxFL3luFjkAkw.png"/></div></div></figure><p id="66fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">因此，先写入非易失性，然后写入易失性，再从易失性读取非易失性</strong></p><blockquote class="ku kv kw"><p id="cf04" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated">如果应用于相同的领域，以前发生的情况将会发生</p></blockquote><p id="13ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记性能:</p><blockquote class="ku kv kw"><p id="ad0b" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated">易失性字段滥用问题—降低处理器速度</p></blockquote><p id="8748" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果你创建一个数组<code class="fe oh oi oj ok b">volatile</code>，它不会在数组<code class="fe oh oi oj ok b">volatile</code>中创建变量。这是很多人都会犯的一个常见错误。使用像<code class="fe oh oi oj ok b">AtomicIntegerArray</code>这样的<code class="fe oh oi oj ok b">atomic</code>变量。检查:</p><div class="nl nm gp gr nn no"><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">原子访问</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">在编程中，原子动作是一次有效发生的动作。原子动作不能停止在…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">docs.oracle.com</p></div></div></div></a></div><p id="b367" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">同步(也称为互斥)</strong></p><p id="9cbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只需将<code class="fe oh oi oj ok b">synchronized</code>添加到方法或代码块中</p><p id="860c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">！！在下面的例子中，第二个线程必须首先获得锁，否则可能会导致死锁！！</strong></p><p id="1900" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请看下面的例子:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="69fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它也是有秩序的(我会在图片上展示)。并且当退出该块时，高速缓存还将数据刷新到主存储器。</p><p id="f4f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据的相同规则:仅适用于相同的字段。更准确地说，是同一监视器上具有解锁-锁定关系的两个线程。</p><p id="336a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使变量在synchronized块<strong class="jp ir">中重新排序，它们仍然在一个块</strong>中。所以，另一个线程不会中断。因此，它也解决了前面描述的重新排序问题。</p><p id="9a5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它也有<strong class="jp ir">发生在</strong>之前。我们来看下图:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi ot"><img src="../Images/4b327bb911b92e6df33757799a0d05e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1ZR47AxLlPzsMLAXfUg3A.png"/></div></div></figure><p id="290f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确信它可能导致死锁。当两个线程相互锁定时。<strong class="jp ir">看这里:</strong></p><div class="nl nm gp gr nn no"><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">僵局</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Java教程是为JDK 8编写的。本页中描述的示例和实践没有利用…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">docs.oracle.com</p></div></div></div></a></div><p id="5d27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">线程开始</strong></p><p id="5673" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">线程1 —当前正在运行的线程。在Java中，我们至少有一个线程来运行整个程序。线程2是由第一个线程启动的另一个线程</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="of og l"/></div></figure><ul class=""><li id="9105" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">线程1启动线程2 -&gt;保证线程2看到来自线程1的所有数据</li><li id="1137" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">线程1 <strong class="jp ir">加入</strong>线程2 - &gt;线程1看到来自线程2(加入的线程)的所有数据</li></ul><p id="6791" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">决赛场地</strong></p><p id="9d28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，重读关于publication plz的块，因为我们现在将非常依赖它。</p><p id="9a18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们来谈谈<strong class="jp ir">初始化过程:</strong></p><p id="d107" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个分为两步的过程:</p><ul class=""><li id="a14d" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">首先:在堆中为对象分配位置</li><li id="da70" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><em class="kx">其次:</em>调用构造函数放值，结束新对象的创建</li></ul><p id="973f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">当你有2个线程和对象初始化时会发生什么:</strong></p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="of og l"/></div></figure><ol class=""><li id="7b85" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk on lh li lj bi translated">第一个线程开始初始化。发生初始化的第一步</li><li id="cf85" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">第二个线程检查对象是否不是<code class="fe oh oi oj ok b">null</code>。眼见不是- &gt;一把抓住它。但是它还没有完全初始化。= &gt;容易出错，因为第二步初始化在第一个线程中尚未结束。</li></ol><p id="62f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">= &gt;我们只有部分的<strong class="jp ir">发生——在</strong>在这里工作之前，因为我们没有得到完整的对象。</p><p id="dac1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解答—使用<code class="fe oh oi oj ok b">final</code>关键字。</p><p id="e3d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe oh oi oj ok b">final</code>字段使变量冻结——在将该字段设置为它在构造函数中接收的值之前，JVM不允许<strong class="jp ir">向另一个线程发布</strong>实例。</p><h2 id="7806" class="mm mn iq bd mo mp mq dn mr ms mt dp mu jy mv mw mx kc my mz na kg nb nc nd ne bi translated">什么时候挥发就够了？</h2><p id="2973" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">根据Jenkov教程:</p><blockquote class="ku kv kw"><p id="360e" class="jn jo kx jp b jq jr js jt ju jv jw jx ky jz ka kb kz kd ke kf la kh ki kj kk ij bi translated">如果只有<strong class="jp ir">一个线程</strong>读写可变变量的值，而其他<strong class="jp ir">线程</strong>只读取该变量，那么保证读取线程看到写入可变变量的最新值。如果不使变量变得不稳定，这是无法保证的。</p></blockquote><div class="nl nm gp gr nn no"><a href="https://jenkov.com/tutorials/java-concurrency/volatile.html" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">Java挥发性关键字</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Java volatile关键字用于将Java变量标记为“存储在主内存中”。更准确地说，这意味着…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">jenkov.com</p></div></div><div class="nx l"><div class="ou l nz oa ob nx oc lz no"/></div></div></a></div><p id="8861" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我对Brian Goetz的“实践中的Java并发性”的重新表述是:</p><p id="4f45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe oh oi oj ok b">Locking</code>(又名<strong class="jp ir">同步</strong>)可以同时保证:可见性和原子性，<code class="fe oh oi oj ok b">voltile</code>只能保证可见性。您可以在以下情况下自由使用<code class="fe oh oi oj ok b">volatile</code>:</p><ul class=""><li id="4ceb" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">只有单线程写入变量或写入值不依赖于它的当前值</li><li id="35a6" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">访问变量时不需要锁定</li><li id="6d21" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">变量不参与任何具有其他状态变量的<strong class="jp ir">不变量</strong></li></ul><p id="53da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阅读这里关于<strong class="jp ir">不变量</strong>:</p><div class="nl nm gp gr nn no"><a href="https://www.geeksforgeeks.org/what-is-class-invariant/" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">什么是类不变量</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">概述:面向对象编程中的不变量指的是一些需要保持…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="nx l"><div class="ov l nz oa ob nx oc lz no"/></div></div></a></div><p id="523a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也可以看看StackOverflow上的这篇好文章:</p><div class="nl nm gp gr nn no"><a href="https://stackoverflow.com/a/3519736/16543524" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">Java中volatile和synchronized的区别</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">理解线程安全有两个方面很重要。执行控制和内存可见性…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">stackoverflow.com</p></div></div><div class="nx l"><div class="ow l nz oa ob nx oc lz no"/></div></div></a></div><h2 id="8a63" class="mm mn iq bd mo mp mq dn mr ms mt dp mu jy mv mw mx kc my mz na kg nb nc nd ne bi translated">结尾部分👋🏼</h2><p id="eb50" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">希望这篇文章对你有所帮助！查看我在<a class="ox oy ep" href="https://medium.com/u/504c7870fdb6?source=post_page-----1cbdccc3e3b1--------------------------------" rel="noopener" target="_blank">媒体</a>上的其他文章</p><p id="93b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎发表评论或联系我💪：</p><ul class=""><li id="909f" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">领英:<a class="ae oz" href="http://www.linkedin.com/in/sleeplesschallenger" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/sleeplesschallenger</a></li><li id="e0a2" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">GitHub:【https://github.com/SleeplessChallenger T21】</li><li id="ad28" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">leet code:<a class="ae oz" href="https://leetcode.com/SleeplessChallenger/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/SleeplessChallenger/</a></li><li id="5ff1" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">电报:@无眠挑战者</li></ul><p id="3575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于创建这篇文章的所有资源👨🏻‍💻：</p><ol class=""><li id="38d2" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk on lh li lj bi translated">Brian Goetz的“实践中的Java并发”</li><li id="2df4" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">https://youtu.be/XgiXKPEILoc</li><li id="6d74" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">不可修改状态:<a class="ae oz" href="https://www.geeksforgeeks.org/create-immutable-class-java/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/create-immutable-class-java/</a></li><li id="e9f8" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">关于安全初始化的StackOverflow帖子:【https://stackoverflow.com/a/11307418/16543524T2】</li><li id="b61d" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">极客归极客:关于缓存<a class="ae oz" href="https://www.geeksforgeeks.org/cache-memory-in-computer-organization/" rel="noopener ugc nofollow" target="_blank">https://www . Geeks forgeeks . org/cache-memory-in-computer-organization/</a></li><li id="b105" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">关于部分和全部订单的StackOverflow帖子:<a class="ae oz" href="https://stackoverflow.com/a/59909382/16543524" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/59909382/16543524</a></li><li id="caa3" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">锁与监视器:<a class="ae oz" href="https://howtodoinjava.com/java/multi-threading/multithreading-difference-between-lock-and-monitor/" rel="noopener ugc nofollow" target="_blank">https://howtodoinjava . com/Java/多线程/多线程-锁与监视器之间的差异/ </a></li><li id="ff52" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">Oracle doc:deadlock<a class="ae oz" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/tutorial/essential/concurrency/deadlock . html</a></li><li id="a55c" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">Oracle doc:atomic<a class="ae oz" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/tutorial/essential/concurrency/atomic . html</a></li><li id="84ed" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">极客的极客:缓存一致性<a class="ae oz" href="https://www.geeksforgeeks.org/cache-coherence/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/cache-coherence/</a></li><li id="075e" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">StackOverflow关于同步和易变的帖子:<a class="ae oz" href="https://stackoverflow.com/a/3519736/16543524" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/3519736/16543524</a></li><li id="2bb3" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">Oracle关于并发的教程:<a class="ae oz" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/javase/tutorial/essential/concurrency/index . html</a></li><li id="185a" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk on lh li lj bi translated">JVM如何解释代码:<a class="ae oz" href="https://programmerbay.com/how-does-jvm-convert-bytecode-into-machine-code/" rel="noopener ugc nofollow" target="_blank">https://programmer bay . com/how-does-JVM-convert-bytecode-into-machine-code/</a></li></ol></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="d4aa" class="pa mn iq bd mo pb pc pd mr pe pf pg mu ph pi pj mx pk pl pm na pn po pp nd pq bi translated">分级编码</h1><p id="9f55" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="14d5" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="ca8f" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">📰查看<a class="ae oz" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="9f7d" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">🔔关注我们:<a class="ae oz" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae oz" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae oz" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="9e26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae oz" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入升级达人集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>