<html>
<head>
<title>Flutter: Medium-like Text Editor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter:类似中型的文本编辑器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-medium-like-text-editor-b41157f50f0e?source=collection_archive---------1-----------------------#2020-09-04">https://levelup.gitconnected.com/flutter-medium-like-text-editor-b41157f50f0e?source=collection_archive---------1-----------------------#2020-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="8543" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">颤振教程</h2><div class=""/><div class=""><h2 id="763e" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">构建在中型移动应用程序中使用的文本编辑器的简化版本</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/75c699767df1549d4dc3d7c9fb1b1e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwkQxpqc05gWjjVbW5bFJA.jpeg"/></div></div></figure><p id="1687" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在接下来的教程中，我们将构建一个简化版本的文本编辑器，用于中型移动应用程序的<em class="lw">“新故事”</em>部分。<strong class="lc ja">之后，你的应用应该是这样的:</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lx"><img src="../Images/467bd031d15e2691e60cd17d6c30b492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JBhYe-LjKF2052dtsbz7uQ.gif"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">行动的最终结果</figcaption></figure><h2 id="6b3e" class="mc md iq bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt iw bi translated">媒体应用程序中“新故事”部分的简短分析</h2><p id="7e5e" class="pw-post-body-paragraph la lb iq lc b ld mu ka lf lg mv kd li lj mw ll lm ln mx lp lq lr my lt lu lv ij bi translated">如果你导航到Medium应用程序的“新故事”部分，你会注意到键盘工具栏出现在屏幕底部，即使键盘不可见。当键盘出现时，工具栏向上移动，显示在键盘上方。如果您创建了两个文本块，您会发现尝试从多个块中选择文本将会失败。一次只能对一个文本块这样做。所以我们可以看到，Medium很可能使用了<code class="fe mz na nb nc b">TextFields</code>中的一个<code class="fe mz na nb nc b">ListView</code>，不同的样式。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="924d" class="nk md iq bd me nl nm nn mh no np nq mk kf nr kg mn ki ns kj mq kl nt km mt nu bi translated">开始之前</h1><p id="1290" class="pw-post-body-paragraph la lb iq lc b ld mu ka lf lg mv kd li lj mw ll lm ln mx lp lq lr my lt lu lv ij bi translated">首先，让我们创建一个新的Flutter项目</p><pre class="kp kq kr ks gt nv nc nw nx aw ny bi"><span id="02c2" class="mc md iq nc b gy nz oa l ob oc">flutter create medium_text_editor</span></pre><p id="8030" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在，我们将下面的包添加到<code class="fe mz na nb nc b">dependencies:</code>中的<code class="fe mz na nb nc b">pubspec.yaml</code></p><pre class="kp kq kr ks gt nv nc nw nx aw ny bi"><span id="ba0a" class="mc md iq nc b gy nz oa l ob oc">provider: ^4.1.3<br/>community_material_icon: ^5.3.45<br/>keyboard_visibility: ^0.5.6</span></pre><p id="46df" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">并安装软件包</p><pre class="kp kq kr ks gt nv nc nw nx aw ny bi"><span id="3cf4" class="mc md iq nc b gy nz oa l ob oc">flutter packages get</span></pre></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="09d5" class="nk md iq bd me nl nm nn mh no np nq mk kf nr kg mn ki ns kj mq kl nt km mt nu bi translated">第1部分:使用键盘工具栏进行文本格式化</h1><blockquote class="od"><p id="2a56" class="oe of iq bd og oh oi oj ok ol om lv dk translated">保持简单，专注于重要的事情。<br/>不要让自己不知所措。<br/>——孔子——</p></blockquote><p id="a9ed" class="pw-post-body-paragraph la lb iq lc b ld on ka lf lg oo kd li lj op ll lm ln oq lp lq lr or lt lu lv ij bi translated">在第一部分中，我们将保持实现尽可能简单。我们将着重于显示一个键盘工具栏，它可以在单击按钮时改变文本字段的文本格式。</p><h2 id="6c10" class="mc md iq bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt iw bi translated">文本格式</h2><p id="e6bb" class="pw-post-body-paragraph la lb iq lc b ld mu ka lf lg mv kd li lj mw ll lm ln mx lp lq lr my lt lu lv ij bi translated">我们将只实现标题、纯文本、项目符号和引号作为文本格式选项。让我们为每个选项指定文本样式和填充。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">text_field .镖</figcaption></figure><p id="febd" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja"> <em class="lw">注意:</em> </strong> <em class="lw">我们使用了Unicode字符</em> <code class="fe mz na nb nc b"><em class="lw">\u2002</em></code> <em class="lw">作为项目符号的前缀。</em></p><h2 id="5e22" class="mc md iq bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt iw bi translated">可定制的键盘工具栏</h2><p id="33f3" class="pw-post-body-paragraph la lb iq lc b ld mu ka lf lg mv kd li lj mw ll lm ln mx lp lq lr my lt lu lv ij bi translated">接下来，我们将构建将显示在键盘上方的键盘工具栏。工具栏只是<code class="fe mz na nb nc b">IconButtons</code>中的一个<code class="fe mz na nb nc b">Row</code>，用于设置点击时选择的格式类型。</p><p id="5543" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja"> <em class="lw">注意:</em> </strong> <em class="lw">我们不会使用</em><a class="ae ou" href="https://pub.dev/packages/keyboard_actions" rel="noopener ugc nofollow" target="_blank"><em class="lw">keyboard _ actions</em></a><em class="lw">包，因为它不太灵活，会导致很多奇怪的实现。</em></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">工具栏.镖</figcaption></figure><h2 id="d6ab" class="mc md iq bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt iw bi translated">连接键盘工具栏和文本格式</h2><p id="ec4c" class="pw-post-body-paragraph la lb iq lc b ld mu ka lf lg mv kd li lj mw ll lm ln mx lp lq lr my lt lu lv ij bi translated">目前，状态管理非常简单，只需要更新选择的文本类型。因为在第二部分中会变得更加复杂，为了简单起见，我们将使用<code class="fe mz na nb nc b">Provider</code>框架。</p><p id="edbc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja"> <em class="lw">注:</em></strong><em class="lw"/><code class="fe mz na nb nc b"><em class="lw">EditorProvider</em></code><em class="lw">通告程序以后会更有用。</em></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">状态管理. dart</figcaption></figure><p id="aa68" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">既然我们已经定义了我们的<code class="fe mz na nb nc b">ChangeNotifier</code>，我们需要使用<code class="fe mz na nb nc b">ChangeNotifierProvider.</code>来初始化我们的状态</p><p id="6bb3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">要在键盘上方显示工具栏，我们只需使用<code class="fe mz na nb nc b">Stack</code>，并用<code class="fe mz na nb nc b">bottom: 56</code>定位我们的<code class="fe mz na nb nc b">SmartTextField</code>，用<code class="fe mz na nb nc b">bottom: 0.</code>定位我们的<code class="fe mz na nb nc b">Toolbar</code>。如果键盘可见，<code class="fe mz na nb nc b">Scaffold</code>的<code class="fe mz na nb nc b">resizeToAvoidBottomInset</code>属性将自动调整布局，使工具栏显示在上方。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">text_editor .镖</figcaption></figure><h2 id="4486" class="mc md iq bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt iw bi translated">风格很重要</h2><p id="c46f" class="pw-post-body-paragraph la lb iq lc b ld mu ka lf lg mv kd li lj mw ll lm ln mx lp lq lr my lt lu lv ij bi translated">因为如果事情看起来不那么糟糕，编码总是更令人愉快，所以我们修改了<code class="fe mz na nb nc b">main.dart</code>中的主题。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">主.镖</figcaption></figure><p id="ed3f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">哒哒🎉</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lx"><img src="../Images/1ef3b72d6a885eeb276637c53db1280c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rdQcOFmo5yGKpd8ed9L7KQ.gif"/></div></div></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="a021" class="nk md iq bd me nl nm nn mh no np nq mk kf nr kg mn ki ns kj mq kl nt km mt nu bi translated">第2部分:从单行编辑器到全文编辑器</h1><p id="5730" class="pw-post-body-paragraph la lb iq lc b ld mu ka lf lg mv kd li lj mw ll lm ln mx lp lq lr my lt lu lv ij bi translated">既然我们已经实现了单个<code class="fe mz na nb nc b">TextField</code>案例，那么是时候构建一个全功能的文本编辑器了。</p><h2 id="4934" class="mc md iq bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt iw bi translated">丰富国家管理</h2><p id="f9cb" class="pw-post-body-paragraph la lb iq lc b ld mu ka lf lg mv kd li lj mw ll lm ln mx lp lq lr my lt lu lv ij bi translated">如前所述，我们需要一个<code class="fe mz na nb nc b">TextFields</code>的<code class="fe mz na nb nc b">ListView</code>。因此，我们将在<code class="fe mz na nb nc b">EditorProvider</code>中存储三个列表:</p><ul class=""><li id="3f04" class="ov ow iq lc b ld le lg lh lj ox ln oy lr oz lv pa pb pc pd bi translated"><code class="fe mz na nb nc b">List&lt;SmartTextType&gt;</code>包含每个块的格式样式</li><li id="e0c2" class="ov ow iq lc b ld pe lg pf lj pg ln ph lr pi lv pa pb pc pd bi translated"><code class="fe mz na nb nc b">List&lt;TextEditingController&gt;</code>包含我们可以用来监听用户输入的每个块的控制器</li><li id="da5a" class="ov ow iq lc b ld pe lg pf lj pg ln ph lr pi lv pa pb pc pd bi translated"><code class="fe mz na nb nc b">List&lt;FocusNode&gt;</code>为每个块包含一个<code class="fe mz na nb nc b">FocusNode</code>，我们将使用它来管理<code class="fe mz na nb nc b">TextFields</code>的焦点</li></ul><p id="6735" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了简单和可读性，我们创建了以下五个getters，我们将在代码的多个部分使用它们:</p><ul class=""><li id="d395" class="ov ow iq lc b ld le lg lh lj ox ln oy lr oz lv pa pb pc pd bi translated"><em class="lw">长度:</em>返回文本块的数量</li><li id="94ca" class="ov ow iq lc b ld pe lg pf lj pg ln ph lr pi lv pa pb pc pd bi translated"><em class="lw">焦点:</em>返回具有当前焦点的块的索引</li><li id="c11b" class="ov ow iq lc b ld pe lg pf lj pg ln ph lr pi lv pa pb pc pd bi translated"><em class="lw"> nodeAt: </em>返回某个索引处的<code class="fe mz na nb nc b">FocusNode</code></li><li id="d7b2" class="ov ow iq lc b ld pe lg pf lj pg ln ph lr pi lv pa pb pc pd bi translated"><em class="lw"> textAt: </em>返回某个索引处的<code class="fe mz na nb nc b">TextEditingController</code></li><li id="4e10" class="ov ow iq lc b ld pe lg pf lj pg ln ph lr pi lv pa pb pc pd bi translated"><em class="lw"> typeAt: </em>返回某个索引处的<code class="fe mz na nb nc b">SmartTextType</code></li></ul><p id="a6b9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">此外，我们将添加一个<code class="fe mz na nb nc b">setFocus()</code>方法，用于在用户将焦点切换到另一个文本块时更新键盘工具栏，并添加一个<code class="fe mz na nb nc b">insert()</code>方法，用于添加一个新的文本块。</p><p id="093f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">好了，让我们使用下面的实现来更新我们的<code class="fe mz na nb nc b">EditorProvider</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">状态管理. dart</figcaption></figure><p id="e305" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">既然我们更改了<code class="fe mz na nb nc b">EditorProvider</code>来存储文本块列表，我们需要更新我们的<code class="fe mz na nb nc b">TextEditor</code>来显示<code class="fe mz na nb nc b">SmartTextFields</code>列表。为此，转到<code class="fe mz na nb nc b">TextEditor</code>的实现，在第31行用下面的代码替换<code class="fe mz na nb nc b">Consumer</code>。</p><pre class="kp kq kr ks gt nv nc nw nx aw ny bi"><span id="fc2c" class="mc md iq nc b gy nz oa l ob oc">Consumer&lt;EditorProvider&gt;(<br/>  builder: (context, state, _) {<br/>    return ListView.builder(<br/>      itemCount: state.length,<br/>      itemBuilder: (context, index) {<br/>        return Focus(<br/>          onFocusChange: (hasFocus) {<br/>            if (hasFocus) state.setFocus(state.typeAt(index));<br/>          },<br/>          child: SmartTextField(<br/>            type: state.typeAt(index),<br/>            controller: state.textAt(index),<br/>            focusNode: state.nodeAt(index),<br/>          )<br/>        );<br/>      }<br/>    );<br/>  }<br/>)</span></pre><p id="a360" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja"> <em class="lw">注:</em> </strong> <em class="lw">我们使用了</em> <code class="fe mz na nb nc b"><em class="lw">Focus</em></code> <em class="lw">小部件来轻松监听焦点变化并更新</em> <code class="fe mz na nb nc b"><em class="lw">EditorProvider</em></code>的 <code class="fe mz na nb nc b"><em class="lw">selectedType</em></code></p><h2 id="5e3f" class="mc md iq bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt iw bi translated">创建和删除文本块</h2><p id="7fc6" class="pw-post-body-paragraph la lb iq lc b ld mu ka lf lg mv kd li lj mw ll lm ln mx lp lq lr my lt lu lv ij bi translated">好了，现在我们已经更新了状态管理和文本编辑器来存储和显示文本块列表，我们需要实现创建和删除块的逻辑。如果用户按enter，我们需要创建一个新的<code class="fe mz na nb nc b">TextField</code>并将焦点切换到它上面。如果用户按backspace键删除一个文本块，我们需要删除该文本或将其与上面的文本块合并。</p><p id="c27c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们将首先检查如何处理这两个事件的逻辑和代码片段。之后，我将向您展示您需要复制到<code class="fe mz na nb nc b">EditorProvider</code>的<code class="fe mz na nb nc b">insert</code>方法中的完整代码。所以请容忍我！</p><p id="4797" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">处理移除事件</strong></p><p id="2c1c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了检测remove事件，我们将使用一个小技巧。我们使用零宽度空格Unicode字符<code class="fe mz na nb nc b">\u200B</code>作为新行开始的参考</p><pre class="kp kq kr ks gt nv nc nw nx aw ny bi"><span id="fefe" class="mc md iq nc b gy nz oa l ob oc">final TextEditingController controller = TextEditingController(<br/>  text: '\u200B' + (text?? '')<br/>);</span></pre><p id="cbf2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果用户随后按下退格键并移除起始字符，即<code class="fe mz na nb nc b">\u200B</code>，我们检测到移除事件，删除聚焦的文本块，并将焦点移动到上面的文本块。</p><pre class="kp kq kr ks gt nv nc nw nx aw ny bi"><span id="9089" class="mc md iq nc b gy nz oa l ob oc">if (!controller.text.startsWith('\u200B')) {<br/>  final int index = _text.indexOf(controller);<br/>  if (index &gt; 0) {<br/>    textAt(index-1).text += controller.text;<br/>    nodeAt(index-1).requestFocus();<br/>    _text.removeAt(index);<br/>    _nodes.removeAt(index);<br/>    _types.removeAt(index);<br/>  }<br/>}</span></pre><p id="238c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja"> <em class="lw">注:</em> </strong> <em class="lw">我们通过</em> <code class="fe mz na nb nc b"><em class="lw">+= controller.text</em></code> <em class="lw">将两个文本块的文本连接起来，这样用户可以很容易地将两个独立的块合并成一个。</em></p><p id="1153" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">处理输入事件</strong></p><p id="ef51" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">接下来，我们需要检测用户何时按下了回车键。由于我们的<code class="fe mz na nb nc b">TextFields</code>使用多行键盘类型(即<code class="fe mz na nb nc b">keyboardType: TextInputType.multiline</code>，我们可以检查<code class="fe mz na nb nc b">TextEditingController</code>是否包含代表换行符的Unicode字符<code class="fe mz na nb nc b">\n</code>。如果是这样，我们将分割文本，并将<code class="fe mz na nb nc b">\n</code>字符之后的部分移动到我们在移动中创建的下一个文本块。这种方法非常重要，因为它允许用户将现有的文本块分成两部分。在这里，您可以看到上述逻辑的实现。</p><pre class="kp kq kr ks gt nv nc nw nx aw ny bi"><span id="344a" class="mc md iq nc b gy nz oa l ob oc">if(controller.text.contains('\n')) {<br/>  final int index = _text.indexOf(controller);<br/>  List&lt;String&gt; _split = controller.text.split('\n');<br/>  controller.text = _split.first;<br/>  insert(<br/>    index: index+1,<br/>    text: _split.last<br/>  );<br/>  nodeAt(index+1).requestFocus();<br/>}</span></pre><p id="e4d3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在一个项目符号点上按下enter，很直观的是下面又出现了一个。因此，我们稍微修改了对<code class="fe mz na nb nc b">insert</code>函数的调用，如您在下面的代码片段中所见。</p><pre class="kp kq kr ks gt nv nc nw nx aw ny bi"><span id="40b3" class="mc md iq nc b gy nz oa l ob oc">insert(<br/>  index: index+1,<br/>  text: _split.last,<br/>  type: typeAt(index) == SmartTextType.BULLET<br/>    ? SmartTextType.BULLET<br/>    : SmartTextType.T<br/>);</span></pre><p id="1885" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">实施</strong></p><p id="347b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">结合上述步骤，我们得到了下面的<code class="fe mz na nb nc b">TextEditingController</code>和<code class="fe mz na nb nc b">Listener</code>的实现，我们可以将它们粘贴到<code class="fe mz na nb nc b">EditorProvider.</code>的<code class="fe mz na nb nc b">insert</code>函数的开头</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="os ot l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">addListener</figcaption></figure><h2 id="e74d" class="mc md iq bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt iw bi translated">隐藏键盘工具栏</h2><p id="2cd9" class="pw-post-body-paragraph la lb iq lc b ld mu ka lf lg mv kd li lj mw ll lm ln mx lp lq lr my lt lu lv ij bi translated">虽然我们只实现了中型移动应用程序的文本编辑器的简化版本，但有一点我们可以很容易地改进。在中型应用程序中，工具栏在底部可见，即使键盘不可见。这当然不是问题，但从设计的角度来看，不是很吸引人。但是好消息是，使用<a class="ae ou" href="https://pub.dev/packages/keyboard_visibility" rel="noopener ugc nofollow" target="_blank"> keyboard_visibility </a>包很容易修复。</p><p id="f082" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">首先，通过将keyboard_visibility包导入到<code class="fe mz na nb nc b">text_editor.dart</code></p><pre class="kp kq kr ks gt nv nc nw nx aw ny bi"><span id="be8f" class="mc md iq nc b gy nz oa l ob oc">import 'package:keyboard_visibility/keyboard_visibility.dart';</span></pre><p id="484f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">然后将以下内容添加到<code class="fe mz na nb nc b">_TextEditorState</code>:</p><pre class="kp kq kr ks gt nv nc nw nx aw ny bi"><span id="f6d6" class="mc md iq nc b gy nz oa l ob oc">bool showToolbar = false;</span><span id="8136" class="mc md iq nc b gy pj oa l ob oc"><a class="ae ou" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>void initState() { <br/>  super.initState();<br/>  KeyboardVisibilityNotification().addNewListener(<br/>    onChange: (isVisible) {<br/>      setState(() {<br/>        showToolbar = isVisible;<br/>      });<br/>    },<br/>  );<br/>}</span><span id="b155" class="mc md iq nc b gy pj oa l ob oc"><a class="ae ou" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>void dispose() { <br/>  KeyboardVisibilityNotification().dispose();<br/>  super.dispose();<br/>}</span></pre><p id="584c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">然后，同样在<code class="fe mz na nb nc b">_TextEditorState</code>中，用下面的if语句包装第二个<code class="fe mz na nb nc b">Positioned</code>小部件:</p><pre class="kp kq kr ks gt nv nc nw nx aw ny bi"><span id="c38e" class="mc md iq nc b gy nz oa l ob oc">if (showToolbar) Positioned(<br/>  bottom: 0,<br/>  ...</span></pre><p id="959e" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">而且，就是这样！</strong></p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="4799" class="nk md iq bd me nl nm nn mh no np nq mk kf nr kg mn ki ns kj mq kl nt km mt nu bi translated">完整代码</h1><p id="278e" class="pw-post-body-paragraph la lb iq lc b ld mu ka lf lg mv kd li lj mw ll lm ln mx lp lq lr my lt lu lv ij bi translated">你可以在这里找到最终代码<a class="ae ou" href="https://github.com/neuencer/Flutter_Medium_Text_Editor" rel="noopener ugc nofollow" target="_blank">。</a>或者查看一下<a class="pk pl ep" href="https://medium.com/u/8b8d99eb72aa?source=post_page-----b41157f50f0e--------------------------------" rel="noopener" target="_blank">Peter Aleksander biz JAK</a>T24】repository他把我的想法转换成了一个可用的flutter库。</p></div></div>    
</body>
</html>