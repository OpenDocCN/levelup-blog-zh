<html>
<head>
<title>Reactive Spring Boot API with Next.js Client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有Next.js客户端的反应式Spring Boot API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/reactive-spring-boot-api-with-next-js-client-b08147ae5712?source=collection_archive---------0-----------------------#2020-10-14">https://levelup.gitconnected.com/reactive-spring-boot-api-with-next-js-client-b08147ae5712?source=collection_archive---------0-----------------------#2020-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f825" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用一个很酷的反应式UI来扩展反应式API服务</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/658a64ab3a03b8a166bb064ade476ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ydd18fNiMxHaOAKv"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">马库斯·斯皮斯克在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="84b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我想用一个用户界面来扩展我的<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/creating-a-reactive-restful-api-with-spring-boot-e706954f0633">上一篇文章</a>中的课程服务API。我也会继续走电抗元件这条路。</p><p id="bb90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我简单总结一下我们在上一篇文章中所做的事情。我们与Spring Boot合作创建了一项微服务，允许我们创建新的课程。我们已经向该服务添加了两个GET端点。一个传统的，允许检索所有课程。客户端可以订阅第二个端点，并通知他们新的课程。我们已经为此使用了Spring Webflux。</p><p id="288d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我想用用户界面组件来扩展服务。</p><p id="c83b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2015年，我开始使用Reactjs来实现很酷的用户界面。我很快就被前端代码的良好结构迷住了。我还喜欢这样一个事实，你可以专注于“视图”而不用样板文件。最后但同样重要的是，您可以简单地更新单个页面元素，而不必重新加载整个页面。当然，之前也有类似的概念使得这成为可能。但是我一直觉得挺繁琐的。从那以后，只要方便或可能，我就使用Reactjs。在过去的所有项目中，我都在客户端渲染React。对我来说，通常没有什么大问题，因为它工作得很好，而且大部分公共API都被使用了。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/6c85f4cdc858984c546fa5b96c6584a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*V2HSeJi360jSqsAHrX_Jhg.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">React Web应用程序连接到运行在Kubernetes上的微服务后端</figcaption></figure><p id="55bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数系统的设计如上图所示。业务逻辑被分割成小的独立服务，这些服务在Kubernetes集群上展开。各个服务通过NGINX入口控制器向外界公开。用户界面是作为独立的应用程序实现的，并在专用的web服务器上推出。API网关允许React应用程序访问发布的REST端点。在我看来，这是一种非常普通的方式。</p><p id="bf37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果我想让每个服务都有自己的UI组件，并在Kubernetes集群上推出它，该怎么办呢？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/12750c6d13cc10e4a8880049843a27d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*nVzIE2flW9_H-zVRj2Suvw.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在Kubernetes上的一个pod中运行React UI容器和REST API容器</figcaption></figure><p id="72e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想在每个微服务的一个Kubernetes pod中部署REST API和客户端组件，如上图所示。例如，在这种情况下，我们可以确保API和UI之间没有版本冲突，因为我们可以使用相同的发布管道推出两个容器。</p><p id="61ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是在这种情况下，我必须避免的是，UI组件是在客户端呈现的，因此必须通过API网关回调到集群中，才能到达其服务的API端点。</p><p id="6f1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，服务器端呈现(SSR)开始发挥作用。服务器端渲染是指在网站的服务器上渲染网站的JavaScript。</p><p id="2824" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不想在本文中深入探讨服务器端呈现的利弊。然而，一个优势是在任何情况下网页的性能。缺点是服务器端需要更多的负载来进行渲染。无论如何，我主要关心的是，我们可以通过UI交付微服务，对于UI组件，API调用是通过公共端点进行的。</p><p id="4f92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我计划使用NGINX作为入口控制器，它将把来自互联网的请求路由到各个微服务的相应用户界面。UI组件与REST API的通信应该在Kubernetes中从一个容器到另一个容器进行，或者用Kubernetes的话说:UI容器通过服务资源层调用REST API容器。在本文中，我不会讨论Kubernetes集群上的服务组件的操作。我将在下一篇文章中更详细地讨论这个问题。</p><p id="4cbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将在REST API项目中添加一个UI客户端，这是我们在上一篇文章中用Spring Boot/ Webflux创建的。这个我想用Next.js。如果你没有听说过Next.js:它是一个服务器渲染的React应用程序的极简框架。在我看来，Next.js提供了一个现成的平台。你可以安装它。你已经具备了启动我们项目所需的一切。</p><p id="cfd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Next.js的原因是，如前所述，一方面我想使用React.js，但另一方面我想呈现服务器端。没有Next.js这当然也是可能的，但当然不是没有相应的努力。</p><p id="623a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后让我们将UI组件集成到上次创建的课程微服务中。目前(<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/creating-a-reactive-restful-api-with-spring-boot-e706954f0633">源自上一篇文章</a>)我们有以下可用的项目结构，见下图。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi le"><img src="../Images/26569bafc42fa0a359a0cad5ad388066.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*2wHJ6B5CO-hVqpbOj9bKzQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">项目结构-课程服务Spring Boot REST API</figcaption></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="5b8c" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">创建并准备Next.js客户机</h1><p id="d772" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">让我们在与<em class="mp"> /src </em>文件夹相同的层次上创建客户端应用程序。我们可以使用下面的命令很容易地做到这一点。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="187d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了下面的项目结构。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="6110" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好消息是，我们的课程服务客户端应用程序已经启动并运行。</p><p id="2891" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以用命令来测试这个:<strong class="jp ir"><em class="mp">$ CD client&amp;&amp;yarn dev</em></strong></p><p id="3b9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们可以简单地在浏览器中调用<a class="ae lb" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>来查看典型的Next.js索引页面。</p><p id="0581" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还记得上一篇文章中的场景。REST API创建了以下端点。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7d28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们将需要这些端点来实现用户界面。基本上我们需要两个页面:一个页面列出所有课程，另一个页面允许创建新的课程。</p><p id="0ed7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在开始之前，我们可以从刚刚创建的Next.js应用程序中删除一些东西。在文件夹<em class="mp">页面</em>中有一个文件夹<em class="mp"> api </em>。该文件夹的内容可以被删除。在文件夹<em class="mp"> styles </em>中，我们也可以删除文件<em class="mp"> Home.modules.css </em>，因为我们不需要其中定义的样式。</p><p id="7a4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们定义一些CSS。您可以将以下样式复制/粘贴到文件夹<em class="mp"> styles </em>中已经存在的<em class="mp"> global.css </em>中。这没什么特别的，我们也不会拿设计师冠军。但是我们稍后需要它来显示创建新课程的表格和表单。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="430e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我想调整<em class="mp">索引</em>页面，以便我们看到现有课程的列表。在我的上一篇文章中，我描述了如何使用H2内存数据库运行我们的API。为了最初有一些可用的数据，我现在将使用一个数据初始化器类来扩展我们的Spring Boot Rest API，以创建一些示例数据。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="4a00" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">调整Spring Boot API</h1><p id="4984" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">因此，我将类<em class="mp"> CategoryInitializer </em>重命名为<em class="mp"> DataInitializer </em>，并使用私有方法<em class="mp"> createExampleCourses </em>对其进行扩展，如以下代码片段所示。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="6ddc" class="mx ln iq mt b gy my mz l na nb">private void createExampleCourses(List&lt;Category&gt; categories){<br/>    List&lt;Course&gt; courses = new ArrayList&lt;&gt;() {<br/>        {<br/>            add(new Course("Outdoor Bootcamp", categories.get(0), UUID.<em class="mp">randomUUID</em>(), 60L));<br/>            add(new Course("Hurricane Bootcamp", categories.get(0), UUID.<em class="mp">randomUUID</em>(), 45L));<br/>            add(new Course("Six Pack Workout", categories.get(3), UUID.<em class="mp">randomUUID</em>(), 45L));<br/>            add(new Course("XXL Legs Workout", categories.get(4), UUID.<em class="mp">randomUUID</em>(), 90L));<br/>        }<br/>    };<br/><br/>    this.courseRepository.saveAll(courses);<br/>    <em class="mp">log</em>.debug("Sample courses created.");<br/>}</span></pre><p id="b8de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在创建完所有类别后，这个新方法由ApplicationEvent 方法上的<em class="mp">调用。</em></p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="4c2d" class="mx ln iq mt b gy my mz l na nb">@Override<br/>public void onApplicationEvent(ApplicationReadyEvent applicationReadyEvent) {<br/>    ...<br/><br/>    this.createExampleCourses(categories);<br/>}</span></pre><p id="53c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们现在重新启动我们的Spring Boot应用程序，将会创建四个示例课程。这些将首先作为列表显示在我们新的Next.js的索引页面中。</p><p id="719d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在文件夹页面中，我们找到一个名为Index.js的文件。我们现在用函数<em class="mp"> getInitialProps </em>扩展它，以从REST API获取数据，如下所示。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="3b9f" class="mx ln iq mt b gy my mz l na nb">Index.getInitialProps = async () =&gt; {<br/>  const res = await fetch('http://localhost:4500/course');<br/>  const json = await res.json();<br/>  return {<br/>      courses: json<br/>  }<br/>};</span></pre><p id="657f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Next.js提供<em class="mp"> getStaticProps </em>和<em class="mp"> getServerSideProp </em>获取数据。它们主要用于从外部来源获取数据。通过这样做，<em class="mp"> getInitialProps </em>可以专注于准备在呈现页面之前填充的属性。</p><p id="85bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们用下面的代码替换现有的<em class="mp"> home </em>函数。如上所述，在呈现之前，最初将在服务器端获取课程列表。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="60c4" class="mx ln iq mt b gy my mz l na nb">const Index = ({ courses }) =&gt; {<br/>  const courseList = courses.map(course =&gt; {<br/>    return &lt;tr key={course.id}&gt;<br/>      &lt;td style={{whiteSpace: 'nowrap'}}&gt;{course.title}&lt;/td&gt;<br/>      &lt;td&gt;{course.categoryTitle}&lt;/td&gt;<br/>      &lt;td&gt;{course.duration}&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>  });<br/><br/>  return (<br/>    &lt;div &gt;<br/>      &lt;Head&gt;<br/>        &lt;title&gt;Course Service Example&lt;/title&gt;<br/>        &lt;link rel="icon" href="/favicon.ico" /&gt;<br/>      &lt;/Head&gt;<br/><br/>      &lt;div&gt;<br/>        &lt;h1&gt;Courses&lt;/h1&gt;<br/>        &lt;table&gt;<br/>          &lt;thead&gt;<br/>          &lt;tr&gt;<br/>            &lt;th width="40%"&gt;Title&lt;/th&gt;<br/>            &lt;th width="30%"&gt;Category&lt;/th&gt;<br/>            &lt;th width="30%"&gt;Duration (minutes)&lt;/th&gt;<br/>          &lt;/tr&gt;<br/>          &lt;/thead&gt;<br/>          &lt;tbody&gt;<br/>          {courseList}<br/>          &lt;/tbody&gt;<br/>        &lt;/table&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="8a06" class="mx ln iq mt b gy nc mz l na nb">... // getInitialProps</span><span id="f4e9" class="mx ln iq mt b gy nc mz l na nb">export default Index;</span></pre><p id="6913" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们现在调用<strong class="jp ir"> <em class="mp">纱dev </em> </strong>，然后在浏览器中转到<a class="ae lb" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"><em class="mp">http://localhost:3000</em></a>，我们得到如下页面。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nd"><img src="../Images/3f1a6966d88d3ad973d6c7a5c8e2d356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BUHVcFxwLTte-1ApGYeqPQ.png"/></div></div></figure><p id="3713" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的输出是通过调用<strong class="jp ir"> <em class="mp"> yarn build </em> </strong>创建的。图中显示<em class="mp">索引</em>页面是一个服务器文件。我们通过页面名称'/'左边的λ符号<strong class="jp ir"> <em class="mp"> λ </em> </strong>来识别这一点。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/cb2d55241409160e3af3b779ef2398e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RrJVSKQ-Apz7YNFZISxqPw.png"/></div></div></figure><h1 id="f72f" class="lm ln iq bd lo lp nf lr ls lt ng lv lw lx nh lz ma mb ni md me mf nj mh mi mj bi translated">但是，小心！！！</h1><p id="ee91" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">构建输出表明数据是在服务器端获取的。而这也发生在你直接调用页面的时候。你可以在浏览器的控制台日志中很好地看到这一点，因为当你直接调用页面时，控制台日志中没有任何输出。这是因为数据是从服务器获取的。基本上正是我们想要的。<br/>但是当我开始使用Next.js时，有一个问题让我绝望:如果我们从另一个位置导航到这个页面，例如来自Next.js库的组件<em class="mp"> &lt; Link / &gt; </em>，数据将在客户端获取。</p><p id="7443" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了防止这种情况，我们必须使用<strong class="jp ir"><em class="mp">getServerSideProps</em></strong>而不是<em class="mp"> getInitialProps </em>，参见下面的代码示例。在我们的例子中，这比经典的混合方法<em class="mp"> getInitialProps要好得多。</em></p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="aeef" class="mx ln iq mt b gy my mz l na nb">export const getServerSideProps = async () =&gt; {<br/>  <strong class="mt ir"><em class="mp">console</em></strong>.log("Fetch data...");<br/>  const res = await fetch('http://localhost:4500/course');<br/>  const json = await res.json();<br/>  return { props: {<br/>      courses: json<br/>    }<br/>  }<br/>};</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="ed61" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">“创建课程”页面</h1><p id="d3b9" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">现在让我们创建一个新页面，通过UI添加新的课程。为此，我们在<em class="mp"> /pages </em>中创建了一个名为course.js的新文件。</p><p id="176c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下图中，我们看到了页面应该是什么样子。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nk"><img src="../Images/5fdb997218446dadfb2a82d760682980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5lP0zBJ96mPeygW5g2_69w.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在浏览器中创建课程页面</figcaption></figure><p id="50a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到，我们有一个选择框，用户可以在其中选择课程的类别。当然，为此我们必须请求REST API。如前所述，我们必须在服务器端完成这项工作。因此，我们再次需要一个getServerSideProps函数来检索可用的类别，请参见下面的代码片段。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="5fa5" class="mx ln iq mt b gy my mz l na nb">export const getServerSideProps = async () =&gt; {<br/>    const res = await fetch(<br/>          `http://localhost:4500/course/category`);<br/>    const data = await res.json();<br/>    return { props: {<br/>            categories: data,<br/>            userId: uuid() // Fake user id<br/>        }<br/>    }<br/>}</span></pre><p id="d728" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个函数中，我们加载初始的<em class="mp">属性</em>，即类别列表和一个随机的用户标识。我们稍后调用POST端点时需要这个ID。因为我们还没有集成身份验证，所以我们没有当前用户的ID。为了生成一个随机的UUID，我使用了节点模块“uuid”。</p><p id="7947" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加此模块:</p><blockquote class="nl nm nn"><p id="6605" class="jn jo mp jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated">$纱线添加uuid</p></blockquote><p id="7fd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一个Create Course组件或页面，我现在实现了一个React挂钩，并为该组件提供了在服务器端创建的<em class="mp"> props </em>。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="ab18" class="mx ln iq mt b gy my mz l na nb">const NewCourse = ({ categories, userId }) =&gt; {<br/>    return &lt;div&gt;<br/>      &lt;h1&gt;Create New Course&lt;/h1&gt;<br/>        &lt;form onSubmit={handleSubmit}&gt;<br/>        ...<br/>    &lt;/div&gt;</span><span id="e31c" class="mx ln iq mt b gy nc mz l na nb">}</span><span id="a192" class="mx ln iq mt b gy nc mz l na nb">export default NewCourse;</span></pre><p id="082f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如代码片段所示，我们将使用<em class="mp"> onSubmit </em>处理程序构建一个调用函数<em class="mp"> handleSubmit </em>的表单。</p><p id="7794" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个<em class="mp"> handleSubmit </em>函数成为我们的<em class="mp"> React </em>钩子的一部分，负责向API发送数据。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="a1c4" class="mx ln iq mt b gy my mz l na nb">const handleSubmit = async(e) =&gt; {<br/>    e.preventDefault();</span><span id="e093" class="mx ln iq mt b gy nc mz l na nb">    await fetch(`http://localhost:4500/course`, {<br/>        method: 'POST',<br/>        headers: {<br/>            'Accept': 'application/json',<br/>            'Content-Type': 'application/json'<br/>        },<br/>        body: <strong class="mt ir"><em class="mp">JSON</em></strong>.stringify(course),<br/>    }).then(res =&gt; {<br/>        if(res.status === 200){<br/>            setSaved(true);<br/>        }else{<br/>            setError('Error: ' + res.status + ' :: ' <br/>              + res.statusText);<br/>        }<br/>    });<br/>}</span></pre><p id="fa68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是当我们在客户端代码中直接调用<em class="mp"> fetch </em>时会发生什么呢？只要我们在本地开发环境中运行服务，它就能完美地工作，在本地开发环境中，我们可以访问<em class="mp"> localhost:4500 </em>。在实际情况下，只有通过公共端点才能访问API。</p><p id="a375" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们的目标是在服务器端执行与后端的通信。Next.js提供了一种很好的方式来实现这一点，即<em class="mp"> /api </em>路线。文件夹<em class="mp">/页面</em>下面是文件夹<em class="mp"> /api </em>。我们在<em class="mp"> /pages/api </em>中定义的一切都被路由到<em class="mp"> /api/* </em>。基本上，这是一种提供自己的API的方式。/api文件夹中的所有内容都是服务器端绑定的，与客户端绑定无关。</p><p id="40d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着我们需要我们的REST API调用作为next.js应用程序中的<em class="mp"> /api </em>路由。因此我们创建一个新文件夹<em class="mp"> /pages/api/course </em>，并在新文件夹中创建一个文件<em class="mp"> index.js. </em></p><p id="df7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了舒适清晰地定义路由处理程序，我使用了轻量级库next-connect。</p><blockquote class="nl nm nn"><p id="89e2" class="jn jo mp jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated">$纱线添加下一个-连接</p></blockquote><p id="8f13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过将以下代码添加到<em class="mp"> /course </em>文件夹中的新<em class="mp"> index.js </em>文件中，我们已经有了一个使用Next.js的工作API路径。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="14e3" class="mx ln iq mt b gy my mz l na nb">import nextConnect from 'next-connect';<br/>const <strong class="mt ir"><em class="mp">handler </em></strong>= nextConnect();</span><span id="a47b" class="mx ln iq mt b gy nc mz l na nb"><strong class="mt ir"><em class="mp">handler</em></strong>.post(async (req, res) =&gt; {<br/>    <strong class="mt ir"><em class="mp">console</em></strong>.log("api call");<br/><br/>    const course = req.body.course;<br/><br/>    await fetch(`http://localhost:4500/course`, {<br/>        method: 'POST',<br/>        headers: {<br/>            'Accept': 'application/json',<br/>            'Content-Type': 'application/json'<br/>        },<br/>        body: <strong class="mt ir"><em class="mp">JSON</em></strong>.stringify(course),<br/>    }).then(r =&gt; {<br/>        if(r.status === 201){<br/>            res.json({ message: "ok" });<br/>        }else{<br/>            res.status(r.status).json({status: r.status, message: r.statusText})<br/>        }<br/>    });<br/>});<br/><br/>export default <strong class="mt ir"><em class="mp">handler</em></strong>;</span></pre><p id="9af4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，我们将REST API调用移到了应用程序的服务器端包中。从课程页面代码(<em class="mp"> React Hook </em>)中，我们现在可以通过简单地处理对<em class="mp"> /api/course的<em class="mp"> POST </em>调用来处理我们的新API，</em>参见下面的代码示例。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="06c8" class="mx ln iq mt b gy my mz l na nb">const handleSubmit = async (e) =&gt; {<br/>    e.preventDefault();<br/>    await fetch('/api/course', {<br/>        method: 'POST',<br/>        headers: {<br/>            'Accept': 'application/json',<br/>            'Content-Type': 'application/json'<br/>        },<br/>        body: <strong class="mt ir"><em class="mp">JSON</em></strong>.stringify({<br/>            course: course,<br/>        }),<br/>    }).then(res =&gt; {<br/>        if(res.status === 200){<br/>            setSaved(true);<br/>        }else{<br/>            setError('Error: ' + res.status + ' :: ' + res.statusText);<br/>        }<br/>    });<br/>}</span></pre><p id="2652" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">酷，现在我们已经有我们的网站来创建新的课程，它执行所有必要的请求到Spring Boot后端服务器端。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="d37a" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">无功课程列表</strong></h1><p id="8d00" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">现在我们来看看这个小应用的亮点。当然，我们不希望<strong class="jp ir">用户A </strong>在<strong class="jp ir">用户B </strong>添加新课程时不得不重新加载他的可用课程列表。</p><p id="02a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们必须订阅我们的Spring Boot REST API的SSE流。在上一篇文章中，我们已经从终端和邮递员的角度研究过这个问题。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/81d4f1cb2cd8f7f89e1b409441d1bf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*gmM7BIUDDFSeWimWUuGhLA.gif"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">用户A添加了新的费率，这更新了用户b的列表。</figcaption></figure><p id="6962" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过我们到目前为止所做的一切，我们已经获得了足够的知识来实现这一部分。我们知道，我们不允许在<em class="mp"> React Hook </em>中对REST API进行任何调用，因为它们会在客户端执行。在“创建课程”部分，我们展示了可以使用Next.js的<em class="mp"> /api </em>路径来创建服务器端包。<br/>我们已经为客户端代码实现了一个可以通过端点<em class="mp"> /api/course </em>调用的POST处理程序。<br/>现在，我们要从Spring Boot API订阅课程更新(<em class="mp">服务器发送事件</em>)需要做些什么？<br/>我们必须实现一个SSE客户端。为此，我们首先将依赖项<strong class="jp ir"> eventsource </strong>添加到我们的项目中。</p><blockquote class="nl nm nn"><p id="cabc" class="jn jo mp jp b jq jr js jt ju jv jw jx no jz ka kb np kd ke kf nq kh ki kj kk ij bi translated">$ yarn添加事件源</p></blockquote><p id="fae4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将此模块导入到课程API模块中(<em class="mp"> /api/course/index.js </em>)。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="00ab" class="mx ln iq mt b gy my mz l na nb">import EventSource from 'eventsource';</span></pre><p id="86fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们能够通过node.js订阅服务器发送事件。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="990a" class="mx ln iq mt b gy my mz l na nb">const stream = async (req, res) =&gt; {<br/>    <strong class="mt ir"><em class="mp">console</em></strong>.log("connect to sse stream");<br/><br/>    let eventSource = new EventSource(`${API_HOST}/course/sse`);<br/>    eventSource.onopen = (e) =&gt; { <strong class="mt ir"><em class="mp">console</em></strong>.log('listen to sse endpoint now', e)};<br/>    eventSource.onmessage = (e) =&gt; {<br/>        res.flushData(e.data);<br/>    };<br/>    eventSource.onerror = (e) =&gt; { <strong class="mt ir"><em class="mp">console</em></strong>.log('error', e )};<br/><br/>    // close connection (detach subscriber)<br/>    res.on('close', () =&gt; {<br/>        <strong class="mt ir"><em class="mp">console</em></strong>.log("close connection...");<br/>        eventSource.close();<br/>        eventSource = null;<br/>        res.end();<br/>    });<br/>}</span></pre><p id="c805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事件发生时(<em class="mp"> onmessage </em>)，调用<em class="mp"> flushData </em>，传输接收到的数据。为此我们必须实现一个<em class="mp">中间件</em>，它基本上只是一个小功能，见下一段代码。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="68ce" class="mx ln iq mt b gy my mz l na nb">const sseMiddleware = (req, res, next) =&gt; {<br/>    res.setHeader('Content-Type', 'text/event-stream');<br/>    res.setHeader('Cache-Control', 'no-cache');<br/>    res.flushHeaders();<br/><br/>    const flushData = (data) =&gt; {<br/>        const sseFormattedResponse = `data: ${data}\n\n`;<br/>        res.write("event: message\n");<br/>        res.write(sseFormattedResponse);<br/>        res.flush();<br/>    }<br/><br/>    <strong class="mt ir"><em class="mp">Object</em></strong>.assign(res, {<br/>        flushData<br/>    });<br/><br/>    next();<br/>}</span></pre><p id="93f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，我们设置所需的响应头，并确保响应的格式正确，并且编写正确。</p><p id="68cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以从客户端代码使用这个API端点，并且确保到Spring Boot后端的连接是服务器端的，不需要公共API端点。</p><p id="d16f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下代码显示了课程列表页面(/pages/index.js)如何订阅新的node.js SSE端点。<em class="mp"> Onmessage </em>将接收到的数据从流解析到JSON，并将新数据推送到课程列表。</p><pre class="km kn ko kp gt ms mt mu mv aw mw bi"><span id="1162" class="mx ln iq mt b gy my mz l na nb">useEffect(() =&gt; {<br/>  let eventSource = new <strong class="mt ir"><em class="mp">EventSource</em></strong>(`/api/course`);<br/>  eventSource.onopen = (e) =&gt; { <strong class="mt ir"><em class="mp">console</em></strong>.log('listen to api-sse endpoint', e)};<br/><br/>  eventSource.onmessage = (e) =&gt; {<br/>    const course = <strong class="mt ir"><em class="mp">JSON</em></strong>.parse(e.data);<br/><br/>    if (!courses.includes(course)){<br/>      setCourses( courses =&gt; [...courses, course]);<br/>    }<br/>  };<br/><br/>  eventSource.onerror = (e) =&gt; { <strong class="mt ir"><em class="mp">console</em></strong>.log('error', e )};<br/><br/>  // returned function will be called on component unmount<br/>  return () =&gt; {<br/>    eventSource.close();<br/>    eventSource = null;<br/>  }<br/>},[])</span></pre><p id="6610" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样，所以课程列表能够收听新事件并更新列表。</p><p id="aa57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我看来，一旦你理解了Next.js的工作原理以及在哪里放置哪些功能，它的概念就非常清晰，并且易于使用。说实话，刚开始的时候我有时候有点迷茫。</p><p id="de2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，你可以在GitHub上找到整个项目。开心快乐编码！</p><p id="95c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的下一篇文章中，我将展示如何在Kubernetes集群上安装和运行Spring Boot API服务和Next.js前端应用程序。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="03f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我总是乐于收到反馈、建议、批评或问题。如果你喜欢这篇文章，或者对当前的问题有所帮助，那么请在这里留下你的掌声。</p><p id="4e8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">干杯！</p></div></div>    
</body>
</html>