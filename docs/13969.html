<html>
<head>
<title>Lessons Learned from Upgrading to PostgreSQL 13</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">升级到PostgreSQL 13的经验教训</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lessons-learned-from-upgrading-to-postgresql-13-14e9a4549cea?source=collection_archive---------7-----------------------#2022-10-20">https://levelup.gitconnected.com/lessons-learned-from-upgrading-to-postgresql-13-14e9a4549cea?source=collection_archive---------7-----------------------#2022-10-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b3a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记录VACUUM、ANALYZE和REINDEX的性能改进，以及一些AWS RDS意外情况。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/2937bc1284776aa0ba0245cab623432e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NXJebqubG9AQqWfP"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯文·Ku</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="811e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于PostgreSQL社区计划在2022年11月10日之后取消对PostgreSQL 10的支持，而<a class="ae le" href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/CHAP_PostgreSQL.html" rel="noopener ugc nofollow" target="_blank"> AWS RDS也将于2023年4月17日</a>跟进，我最近受命将我们的数据库升级到PostgreSQL 13。为了准备主要版本升级，我们遵循了<a class="ae le" href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.PostgreSQL.html#USER_UpgradeDBInstance.PostgreSQL.MajorVersion.Process" rel="noopener ugc nofollow" target="_blank"> RDS升级用户指南</a>。</p><h1 id="8fad" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">准备升级</h1><p id="a307" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">首先，我们确定了最新的兼容主版本升级目标:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="2f47" class="mn lg it mj b gy mo mp l mq mr">$ aws rds describe-db-engine-versions --engine postgres  --engine-version 10.18--query "DBEngineVersions[*].ValidUpgradeTarget[*].{EngineVersion:EngineVersion}" --output text</span><span id="2b87" class="mn lg it mj b gy ms mp l mq mr">&gt; 13.4</span></pre><p id="7828" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们检查了不支持的用法:</p><ul class=""><li id="07da" class="mt mu it js b jt ju jx jy kb mv kf mw kj mx kn my mz na nb bi translated"><strong class="js iu">准备好的交易:<br/> </strong> <code class="fe nc nd ne mj b">SELECT count(*) FROM pg_catalog.pg_prepared_xacts;</code></li><li id="155f" class="mt mu it js b jt nf jx ng kb nh kf ni kj nj kn my mz na nb bi translated"><strong class="js iu"> Reg*数据类型:</strong> <br/> <code class="fe nc nd ne mj b">SELECT count(*) FROM pg_catalog.pg_class c, pg_catalog.pg_namespace n, pg_catalog.pg_attribute a<br/> WHERE c.oid = a.attrelid<br/> AND NOT a.attisdropped<br/> AND a.atttypid IN (‘pg_catalog.regproc’::pg_catalog.regtype,<br/> ‘pg_catalog.regprocedure’::pg_catalog.regtype,<br/> ‘pg_catalog.regoper’::pg_catalog.regtype,<br/> ‘pg_catalog.regoperator’::pg_catalog.regtype,<br/> ‘pg_catalog.regconfig’::pg_catalog.regtype,<br/> ‘pg_catalog.regdictionary’::pg_catalog.regtype)<br/> AND c.relnamespace = n.oid<br/> AND n.nspname NOT IN (‘pg_catalog’, ‘information_schema’);</code></li></ul><p id="8960" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们没有使用复制插槽或其他PostgreSQL扩展，所以我们在较低的环境中进行了一次试运行。升级花费了10-15分钟，没有出现任何问题。</p><h1 id="80d1" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">RDS备份注意事项</h1><p id="9340" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">然而，在升级过程中，我们遇到了一个意外的问题。对于UAT和Prod，我们让主要版本升级在维护窗口期间生效。但是，当我们更改时间点恢复(PITR)保留期以符合新的法规遵从性标准时，升级立即发生了。</p><p id="c051" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这在<a class="ae le" href="https://docs.aws.amazon.com/aws-backup/latest/devguide/point-in-time-recovery.html" rel="noopener ugc nofollow" target="_blank"> AWS备份开发人员指南</a>中有所记录，但它让我们大吃一惊:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="c75e" class="mn lg it mj b gy mo mp l mq mr">When you change your PITR retention period, AWS Backup calls <!-- -->ModifyDBInstance<!-- --> and applies that change immediately. <strong class="mj iu">If you have other configuration updates pending the next maintenance window, changing your PITR retention period will also apply those configuration updates immediately</strong>. For more information, see <a class="ae le" href="https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBInstance.html" rel="noopener ugc nofollow" target="_blank">ModifyDBInstance</a><a class="ae le" href="https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBInstance.html" rel="noopener ugc nofollow" target="_blank"> in the <em class="nk">Amazon Relational Database Service API Reference</em></a>.</span></pre><p id="a3c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">值得庆幸的是，PITR保留期的更改发生在非工作时间，但令人担忧的是，由于看似无关的更改，升级发生在维护窗口之外。</p><h1 id="2aa2" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">PostgreSQL 13中的性能更新</h1><p id="33e0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在升级后运行VACUUM、ANALYZE和REINDEX来提高和优化数据库性能总是一个好主意。这是因为在升级(或还原)过程中，索引可能会产生碎片，导致数据库可能会使用非优化的查询计划。尽管RDS已经打开了自动清空功能，但由于升级可能发生在维护窗口期间，所以这是同时运行这些任务的好时机。</p><p id="9302" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在PostgreSQL 13中运行REINDEX的另一个原因是对PostgreSQL如何处理重复的B树索引的改进。对于基数较低的表，比如一个值与多行相关联的表，索引值中有很多重复。以加密账户持有者(例如，个人、银行、交易所等)及其相关加密地址的简单表格为例。如果表是按帐户索引的，PostgreSQL 13之前的底层B树索引看起来类似于:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="7dfe" class="mn lg it mj b gy mo mp l mq mr">+------------+---------+<br/>|  Account   | Address |<br/>+------------+---------+<br/>| Customer A | bc1q... |<br/>| Customer A | 0xe82.. |<br/>| Customer A | 3Kzh9.. |<br/>| Customer B | 0x95g.. |<br/>+------------+---------+</span></pre><p id="c345" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过重复数据删除，该表可以将每个键存储一次，从而节省存储空间:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="7ee8" class="mn lg it mj b gy mo mp l mq mr">+------------+---------------------------+<br/>|  Account   |          Address          |<br/>+------------+---------------------------+<br/>| Customer A | bc1q..., 0xe82.., 3Kzh9.. |<br/>| Customer B | 0x95g..                   |<br/>+------------+---------------------------+</span></pre><p id="f62c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在极端的情况下，尺寸上的差异可以节省高达90%的成本。</p><p id="f699" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要开始性能改进，首先发出VACUUM命令。我们可以使用<a class="ae le" href="https://www.postgresql.org/docs/current/app-vacuumdb.html" rel="noopener ugc nofollow" target="_blank"> vacuumdb </a>或者直接在数据库中使用PSQL:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="08d9" class="mn lg it mj b gy mo mp l mq mr">SELECT <br/>   'VACUUM(FULL, ANALYZE, VERBOSE) '|| '"' || table_name || '"' || ';'<br/>FROM <br/>   information_schema.tables<br/>WHERE <br/>  table_catalog = '&lt;your-database&gt;' AND <br/>  table_schema = 'public';</span></pre><p id="1756" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述查询将为每个表生成相应的VACUUM语句。</p><p id="3907" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，我们可以为所有表生成REINDEX语句:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="c012" class="mn lg it mj b gy mo mp l mq mr">SELECT 'REINDEX TABLE CONCURRENTLY ' || quote_ident(relname) || ' /*' || pg_size_pretty(pg_total_relation_size(C.oid)) || '*/;'<br/>FROM pg_class C<br/>LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)<br/>WHERE nspname = 'public'<br/>  AND C.relkind = 'r'<br/>  AND nspname !~ '^pg_toast'<br/>ORDER BY pg_total_relation_size(C.oid) ASC;</span></pre><p id="35e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将输出具有相关表大小的<code class="fe nc nd ne mj b">REINDEX TABLE CONCURRENTLY &lt;table&gt;</code>语句。我们可以从较小的表开始，在整个数据库中调用它之前获得信心。</p><p id="03f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">若要跟踪重新索引操作的进度，可以使用以下查询:</p><pre class="kp kq kr ks gt mi mj mk ml aw mm bi"><span id="b67f" class="mn lg it mj b gy mo mp l mq mr">SELECT<br/>  now()::TIME(0),<br/>  a.query,<br/>  p.phase,<br/>  round(p.blocks_done / p.blocks_total::numeric * 100, 2) AS "% done",<br/>  p.blocks_total,<br/>  p.blocks_done,<br/>  p.tuples_total,<br/>  p.tuples_done,<!-- --> <br/>  p.current_locker_pid,<br/>  <!-- -->ai.schemaname,<br/>  ai.relname,<br/>  ai.indexrelname<br/>FROM pg_stat_progress_create_index p<br/>JOIN pg_stat_activity a ON p.pid = a.pid<br/>LEFT JOIN pg_stat_all_indexes ai on ai.relid = p.relid AND ai.indexrelid = p.index_relid;</span></pre><p id="a238" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，如果对整个数据库(而不是单个表)发出REINDEX命令，查询将不会显示进度。</p><p id="53f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，PostgreSQL升级完成，数据库应该得到优化。可选地，检查<code class="fe nc nd ne mj b">pg_upgrade_internal.log</code>和<code class="fe nc nd ne mj b">pg_upgrade_server.log</code>是否有任何错误或建议。</p><h2 id="5d3a" class="mn lg it bd lh nl nm dn ll nn no dp lp kb np nq lt kf nr ns lx kj nt nu mb nv bi translated">资源</h2><ul class=""><li id="1688" class="mt mu it js b jt md jx me kb nw kf nx kj ny kn my mz na nb bi translated"><a class="ae le" href="https://www.percona.com/blog/2020/09/10/index-improvements-in-postgresql-13/" rel="noopener ugc nofollow" target="_blank">https://www . per ConA . com/blog/2020/09/10/index-improvements-in-PostgreSQL-13/</a></li><li id="d390" class="mt mu it js b jt nf jx ng kb nh kf ni kj nj kn my mz na nb bi translated"><a class="ae le" href="https://adamj.eu/tech/2021/04/13/reindexing-all-tables-after-upgrading-to-postgresql-13/" rel="noopener ugc nofollow" target="_blank">https://adamj . eu/tech/2021/04/13/reindexing-all-tables-after-upgrading-to-PostgreSQL-13/</a></li><li id="6a1c" class="mt mu it js b jt nf jx ng kb nh kf ni kj nj kn my mz na nb bi translated"><a class="ae le" href="https://confluence.atlassian.com/jirakb/reindex-progresses-very-slowly-after-postgres-upgrade-or-restore-1070073091.html" rel="noopener ugc nofollow" target="_blank">https://confluence . atlassian . com/jira kb/reindex-progresses-very-slow-after-postgres-upgrade-or-restore-1070073091 . html</a></li></ul></div></div>    
</body>
</html>