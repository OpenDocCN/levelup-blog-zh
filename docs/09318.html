<html>
<head>
<title>How not to use Functional Programming in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在TypeScript中不使用函数式编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-not-to-use-functional-programming-in-typescript-dcc318200510?source=collection_archive---------4-----------------------#2021-07-27">https://levelup.gitconnected.com/how-not-to-use-functional-programming-in-typescript-dcc318200510?source=collection_archive---------4-----------------------#2021-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5d7a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在过去的几年里，我深入研究了函数式编程。尽管我在这次旅程中毫发无损，但我一路上学到了很多东西，尤其是当我将它应用到我的TypeScript项目中时。今天，我与你分享我的知识；我希望你能从我的成功和失败中吸取教训。</p><p id="1a29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我是从一个JavaScript/TypeScript开发人员的角度写这篇文章的。如果您不是这样的人，您可能仍然会发现许多与不同主流编程语言相关的问题。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/850d01775b29b64b265004ed8293739a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qc4REnM5Gc4RW8tW"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">安托万·道特里在Unsplash<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></figcaption></figure><h1 id="33ad" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">到处应用FP</h1><p id="378e" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">函数式编程的范例已经在主流中获得了很大的吸引力，同时，可以说，其他范例由于其明显的弱点而受到了很大的反对。这自然引起了我的注意，因为我努力根据技术在商业产品中的实用性来做出判断。</p><p id="1d67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数式编程可能会吸引一些软件开发人员，因为它与数学，尤其是代数有着密切的联系。大多数编码人员可能会同意不变性、函数纯度或可组合性等原则。对于一些人来说，使用正式验证的可能性听起来也很令人兴奋。</p><p id="172d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是否意味着函数式编程更好？</p><p id="67b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不一定。</p><p id="9c60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">主流编程语言支持多种范例，有些人甚至将它们的成功归功于此。如果我们可以在一个项目中利用许多范例，我们应该约束自己只支持一个范例吗？</p><p id="03c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在大多数情况下，我们可以结合其他模式使用函数式编程，例如，面向对象编程。毕竟，我们可以对类实例应用不变性，不是吗？</p><p id="9c7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，国家并不总是对手；我们可以使用有状态对象更好地表达一些想法——例如，web套接字有一个称为连接状态的自然状态属性。</p><p id="4891" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">投掷失误怎么办？我发现可抛出代码可读性更好，即使我的想法违背了函数式编程的原则。更不用说我们可能仍然希望使用原生的<code class="fe mi mj mk ml b">Error</code>类型来标记堆栈跟踪。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">错误管理看起来不同，但看起来相似(这个片段使用fp-ts)。</figcaption></figure><p id="5839" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我相信有经验的开发人员知道在函数式编程中处理横切关注点(比如日志)有多难。</p><h1 id="552c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">关闭偏好</strong></h1><p id="f6aa" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">当我第一次了解到<em class="mo">curry</em>和<em class="mo">局部应用</em>时，它永远地改变了我使用函数的方式。由于这两个概念是不同的，从现在开始，我将使用更宽泛的术语<em class="mo">闭包</em>来表示它们在代码中的用法。</p><p id="d791" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">闭包是JavaScript的基础，就像情态动词对于英语一样重要。我相信大多数软件开发人员基于他们的编码本能使用它们，甚至不知道闭包的概念。既然每个人都应该理解他们代码的影响，我们应该更仔细地研究一下闭包(双关语！).</p><p id="0fb0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">闭包不一定比将参数显式传递给函数更高效。由于闭包的广泛使用，您选择的TypeScript编译器可能无法应用某些优化(读取:重写)。同样，由于闭包，JavaScript引擎可能不会在运行时优化代码。闭包需要足够快地释放捕获的变量——否则内存消耗会增加。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">你在这里看到了多少个闭包？(这个代码片段使用fp-ts)</figcaption></figure><p id="7920" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在一些语言中(例如Java)，闭包只接受外部作用域的不可变变量。如果你知道为什么会这样，你可能想在评论区留下评论！</p><p id="0357" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据定义，闭包会破坏功能和数据。当我们调用一个curried或部分应用的函数时，它的调用者不知道闭包内捕获的变量。由于TypeScript类型系统的性质，调用方永远不会知道传递给它的函数的来源。</p><p id="367d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一些函数式编程的鼓吹者声称混合功能和数据是一种反模式。通常，他们会谈到使用面向对象模式的项目中的过度继承，导致即使是经验丰富的开发人员也难以理解的代码。我完全同意。不过，在我的例子中，我可以对过度使用闭包提出类似的观点。</p><h1 id="e037" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">依靠代码覆盖率</strong></h1><p id="39bb" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">代码覆盖率是我用来确定项目质量的众多指标之一。我的经验是，被覆盖分支的百分比既不能太低，也不能太高。对于我遇到的大多数项目来说，这条规则相当有效。</p><p id="5928" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会问为什么以实现100%的覆盖率为目标是错误的？根据我的经验，这不一定是坏事，但你可以更明智地投资你的时间。毕竟，商业项目的资金和时间预算有限。</p><p id="46f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，如果您在代码库中无处不在地应用函数式编程，您可能会观察到代码覆盖率变得异常高。是因为这种范式帮助开发人员编写更好的测试吗？</p><p id="624d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="mo">号</em></p><p id="a373" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">命令式编程迫使编码人员使用条件语句来控制代码流。每个条件都会添加两个或更多对代码覆盖工具可见的分支。在函数式编程中也会发生同样的情况吗？</p><p id="c5bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一元运算封装了条件语句，隐藏了分支的存在。开发人员将复合操作表示为函数的组合，称为管道。函数式编程将显式分支减少到了最低限度。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">代码覆盖率来自我的开源项目“fp-backend”。注意分支百分比。</figcaption></figure><p id="f63c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述事实表明，我们不能依赖代码覆盖工具，至少在使用分支作为一般报告方法时不能。我们仍然可以看到我们是否忘记了导入特定的文件或函数——但是我们也可以从我们的ide接收到这些信息。</p><h1 id="7f64" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">克服语言限制</strong></h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mp"><img src="../Images/ac5405a702877d705be386b7ab1303db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KlkL-nFiueUUPLP2"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">安迪·比尔斯在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="11ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现有的每一种编程语言都有其局限性。有些限制是故意的。有些是因为最初的语言设计而出现的。重要的是，我们，软件工匠，在某种程度上依赖于我们使用的工具。</p><p id="795e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，TypeScript不支持<em class="mo">高阶类型</em>。对于想要使用这种功能的开发人员来说，这意味着什么？</p><p id="2305" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">他们需要找到另一种方式来实现他们的目标。坦率地说，目标是交付他们的产品，而不是编写使用<em class="mo">高阶类型</em>的代码。我不会尝试编写接受任何单子作为参数的函数，除非我不想失去拥有类型系统的好处。</p><p id="1915" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些年来，我学会了不要在没人能解决的问题上投入太多时间。有时候我们需要接受他们的现状，继续前进。</p><p id="775f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顺便说一句，如果你总是得到类型错误，这可能意味着你的代码太复杂了。也许你引入了太多的成分，或者你使用了太多不同的<em class="mo">单子</em>？</p><h1 id="5d44" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">偏爱单子</strong></h1><p id="3a14" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">单子可能是函数式编程中新手在学习基础知识后偶然发现的第一个高级概念。一些开发人员可能会发现具有普遍适用功能的容器的想法是革命性的。在学习了所有主要的一元类型之后，很难回到其他范式。</p><p id="4e0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，在处理单子时了解一些注意事项是有好处的。</p><p id="aac1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于TypeScript允许开发人员管理可空性，我相信我们不需要依赖于<code class="fe mi mj mk ml b">Option</code> ( <code class="fe mi mj mk ml b">Maybe</code>，<code class="fe mi mj mk ml b">Nullable</code>)单子。我们仍然可以编写返回可空值的简单函数；当我们需要一个单子时，我们可以根据需要从一个特定的变量创建一个<code class="fe mi mj mk ml b">Option</code>单子。</p><p id="f485" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数式编程促进了函数组合，尤其是构建一元函数的流水线。在这里，这样的构造要么接受一元参数，要么返回一元参数。</p><p id="8ffd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果一个函数中返回的一元类型与第二个函数中接受的参数类型不同怎么办？</p><p id="7394" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要依赖单子转换器——接受一种类型的单子并返回另一种类型的单子的构造函数。这样，我们可以瞬间将一个<code class="fe mi mj mk ml b">Option</code>转换成一个<code class="fe mi mj mk ml b">Either</code> ( <code class="fe mi mj mk ml b">Result</code>)。</p><p id="2d03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我花了大量的编码时间试图简化项目中的管道。我建议在一个项目中只坚持少数单子，以避免大量处理单子变压器。你还可以因为不必向同事解释新概念而获得加分。</p><h1 id="799f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">总结</strong></h1><p id="8727" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">正如我之前提到的，我认为每个开发人员都应该了解他们的代码是如何工作的，以及它对整体性能的影响。毕竟，编码人员使用所有可用的工具来构建产品。如果使用一个特定的模式或范例使你偏离了成功，你可以考虑放弃它。</p><p id="9472" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现函数式编程非常有用，尤其是从它引发的思维转变来看。像不变性、函数纯度或单子这样的想法有助于将代码组织成独立的块。只要我们不试图取代其他范例，我们就只会从函数式编程中受益。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="22c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文中的所有代码片段都来自我的开源项目“fp-backend”，可在这里<a class="ae le" href="https://github.com/grzpab/fp-backend" rel="noopener ugc nofollow" target="_blank">获得</a>。请注意，这是一个实验项目，是我各种想法的游乐场。</p></div></div>    
</body>
</html>