<html>
<head>
<title>Scaling UIBezierPath for Custom SwiftUI Shapes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为自定义SwiftUI形状缩放UIBezierPath</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scaling-an-uibezierpath-for-a-custom-swiftui-shape-c6d1d6c30a88?source=collection_archive---------14-----------------------#2020-07-29">https://levelup.gitconnected.com/scaling-an-uibezierpath-for-a-custom-swiftui-shape-c6d1d6c30a88?source=collection_archive---------14-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8249" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让-马克·布里安内</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/49ef6ca7e43a16f2f86f5fcd9679fa46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L4MoYcS_AS1PQjeKs9xJIQ@2x.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">缩放UIBezierPath以创建自定义SwiftUI形状</figcaption></figure><p id="19ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天的快速提示！当您从设计器或设计程序获得SVG输出时会发生什么？如何将其转换成定制的SwiftUI <code class="fe lu lv lw lx b">Shape</code>结构呢？</p><blockquote class="ly lz ma"><p id="8aeb" class="ky kz mb la b lb lc ju ld le lf jx lg mc li lj lk md lm ln lo me lq lr ls lt im bi translated">在开始之前，请考虑使用这个<a class="ae mf" href="https://trailingclosure.com/signup/?utm_source=medium&amp;utm_medium=blog_post&amp;utm_campaign=scaling_uibezierpath" rel="noopener ugc nofollow" target="_blank">链接</a>订阅，如果你没有在<a class="ae mf" href="https://trailingclosure.com/?utm_source=medium&amp;utm_medium=blog_post&amp;utm_campaign=scaling_uibezierpath" rel="noopener ugc nofollow" target="_blank">TrailingClosure.com</a>上阅读这篇文章，请随时来看看我们！</p></blockquote><h2 id="6704" class="mg mh it bd mi mj mk dn ml mm mn dp mo lh mp mq mr ll ms mt mu lp mv mw mx my bi translated">转换SVG路径</h2><ol class=""><li id="60af" class="mz na it la b lb nb le nc lh nd ll ne lp nf lt ng nh ni nj bi translated">首先，您可以使用Mike Engel创建的流行工具<a class="ae mf" href="https://swiftvg.mike-engel.com/" rel="noopener ugc nofollow" target="_blank"> SwiftVG </a>将SVG路径代码转换为Swift UIBezierPath代码。</li><li id="ccea" class="mz na it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">从这里开始，你需要缩放<code class="fe lu lv lw lx b">UIBezierPath</code>以适应<code class="fe lu lv lw lx b">path(in rect:)</code>函数中提供给你的自定义<code class="fe lu lv lw lx b">Shape</code>结构的<code class="fe lu lv lw lx b">CGRect</code>。您可以使用<code class="fe lu lv lw lx b">Path</code>上的扩展来应用<code class="fe lu lv lw lx b">CGAffineTransform</code>来完成此操作。从那里，您可以像往常一样返回路径。</li></ol><pre class="kj kk kl km gt np lx nq nr aw ns bi"><span id="d4e1" class="mg mh it lx b gy nt nu l nv nw">struct Wave: Shape {<br/>    func path(in rect: CGRect) -&gt; Path {<br/>        let path = UIBezierPath()<br/>        <br/>        // Path drawing code here<br/>        // ...<br/>        <br/>        return Path(path.cgPath).scaled(for: rect)<br/>    }<br/>}<br/><br/>extension Path {<br/>    func scaled(for rect: CGRect) -&gt; Path {<br/>        let scaleX = rect.width/boundingRect.width<br/>        let scaleY = rect.height/boundingRect.height<br/>        let scale = min(scaleX, scaleY)<br/>        return applying(CGAffineTransform(scaleX: scale, y: scale))<br/>    }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/e1ac6f6af00eebf85f8818b5660c412f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fqu4rIPKpv8nWKEV.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/699703d6dbd7d5c76ae9688ec2b966a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PET2yWR-bIXOJwm8.png"/></div></div></figure><p id="44e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">缩放前(左)，缩放后(右)</p><h2 id="1e5e" class="mg mh it bd mi mj mk dn ml mm mn dp mo lh mp mq mr ll ms mt mu lp mv mw mx my bi translated">沿X或Y方向缩放</h2><p id="7412" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">如果你想在一个方向上进一步缩放路径，那么你可以再次为<code class="fe lu lv lw lx b">Path</code>写一个扩展。通过在<code class="fe lu lv lw lx b">Path</code>上执行<code class="fe lu lv lw lx b">CGAffineTransform</code>，您可以获得想要的结果。</p><pre class="kj kk kl km gt np lx nq nr aw ns bi"><span id="7888" class="mg mh it lx b gy nt nu l nv nw">struct Wave: Shape {<br/>    func path(in rect: CGRect) -&gt; Path {<br/>        let path = UIBezierPath()<br/>        <br/>        // Path drawing code here<br/>        // ...<br/>        <br/>        return Path(path.cgPath).scaled(for: rect).scale(x: 1, y: 5)<br/>    }<br/>}<br/><br/>extension Path {<br/>    func scale(x: CGFloat, y: CGFloat) -&gt; Path {<br/>        return applying(CGAffineTransform(scaleX: x, y: y))<br/>    }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/e4fc5bb6dda6fbdca3b7ec18581fc13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/0*teZme9VqK_E8gSKz.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">仅在Y方向缩放的波形</figcaption></figure></div></div>    
</body>
</html>