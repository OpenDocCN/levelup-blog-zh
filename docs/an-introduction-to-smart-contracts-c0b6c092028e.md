# 智能合同简介

> 原文：<https://levelup.gitconnected.com/an-introduction-to-smart-contracts-c0b6c092028e>

![](img/ebdee08111a63225a9ec748843cf884e.png)

[https://www . pymnts . com/区块链/2021/what-is-a-smart-contract/](https://www.pymnts.com/blockchain/2021/what-is-a-smart-contract/)

在你开始阅读这篇文章之前，你应该对区块链是如何工作的有一个基本的了解。

一般来说，合同是遵守合同条款的两方或多方**之间达成的协议。它通常采用详细文件的形式，包含几个条款和条件，由各方签署。通常，这些合同是由法律强制执行的，并且用人类语言书写。**

在我们的生活中，合同无处不在；例如，如果你要出租或租用一所房子，你要签署一份租赁协议。当你接受一份新工作时，你就签署了一份雇佣合同。每当你去购物并想退货时，员工会查看退货政策，这是一份合同。任何保险或金融协议也是合同。

在本文中，我将介绍熟悉智能合约需要知道的一切。

那么，让我们来看看以下每个主题:

*   **它们是什么**
*   **简史**
*   **它们如何工作**
*   **好处/优势**
*   **限制/缺点**
*   **应用**
*   智能合约的未来
*   **智能合同样本**
*   **额外阅读/来源**

# 它们是什么

智能合同是基于规则的计算机程序，可以根据合同中的条件做出决定。这些程序可以自动验证、控制和执行协议。例如，当满足某些条件时，他们可以在各方之间转移数字资产。这部法典强制执行合同，而传统合同是由法律强制执行的。

我喜欢把智能合约想象成自动售货机。本质上，当你运行智能合约的代码时，**你选择执行哪些功能，或者从自动售货机获得哪些商品。有时这些操作需要**货币补偿**来支付天然气费用(我将在本文的后面部分解释)，或者其他时候它们可能是免费的(这取决于智能合同的类型)。**

## Dapps

很多人互换使用智能合同和分散应用程序(Dapps)这两个术语，但这是不正确的。智能合约只是存储在区块链上的一段代码。然而，Dapp 将前端连接到后端，并且**可以使用几个智能契约来运行**。

## 智能合同/dapp 示例

智能合同的一个例子可以是在选举投票领域中使用的智能合同。它可以统计每个政党的票数，然后做出谁获胜的最终决定。这种智能合同将是不可变的，这意味着没有人能够改变它，使它完全可信。

你可能听说过的 Dapp 的一个很大的例子是 MakerDAO。它本质上是一个金融系统，你可以使用加密货币借贷。MakerDAO 有一个与后端通信的前端，并使用几个智能合约。

# 简史

密码学家 Nick Szabo 在 1994 年提出了分布式账本智能合约的最初想法。他所说的“智能合同”指的是一系列以数字形式书写的承诺，包括双方履行承诺的协议。然而，在 2008 年中本聪引入比特币概念之前，“智能合约”这个词很少被使用。

2015 年晚些时候，以太坊推广了智能合约的概念，如今，它们正被用于各种任务。

# 它们是如何工作的

智能合同由**三部分组成:**当事人、合同主体以及适用于合同的条款或条件。每个智能合约都被放在区块链上，并广播到整个网络，而且有一个地址。这段代码可在**网络**中的每个节点上执行。

每个节点都有所有智能合约的历史记录、所有交易的历史记录以及所有智能合约的当前状态。

Dapp 是人们与智能合约交互的界面。它由前端和 API 组成，用于与智能合约进行交互。智能合约为 Dapp 提供了一种与区块链交互的方式。

以下是一些有助于理解智能合约如何最适合以太坊平台的概念。

## 图灵完全性

比特币使用一种叫做比特币脚本的编程语言，而以太坊使用 Solidity。这两种语言的一个很大区别是**比特币脚本不是图灵完全语言，不像以太坊的 Solidity 是图灵完全语言**。当一种编程语言可以编写任何逻辑(包括循环)时，它就被认为是图灵完全的。

比特币脚本不支持循环的使用，原因很明显——如果在系统中放置一个无限的或计算要求很高的循环，会降低整个区块链的速度。因此，按照设计，比特币脚本中不包含循环。

但是以太坊的坚固性确实支持循环，那么以太坊是如何处理区块链变慢的问题的呢？Vitalik Buterin 想出了一个解决这个问题的巧妙方法。

## 煤气，煤气，煤气…

Vitalik 引入了 Gas 的概念，Gas 是智能合约的开发者在以太坊平台上执行**任何操作**都要支付的费用。它鼓励程序员让他们的智能合同尽可能的高效**，这样他们支付的费用尽可能的少。如果有人编写了非常低效的代码，或者在最糟糕的情况下，智能合同中出现了无限循环，这可能会暂时降低网络速度，直到智能合同的开发人员耗尽汽油。这种结构允许 Solidity 使用循环，同时保持区块链平稳运行。**

**气价的计量单位是卫。智能合约上运行的每个操作都被转换为消耗并向开发者收取的 Wei 数。一个威是以太的 10^-18，或一个以太的**千万亿分之一**，区块链以太坊使用的加密货币。**

**如果您想了解哪些操作消耗了多少 Wei，请查看[这张电子表格。](https://docs.google.com/spreadsheets/d/1n6mRqkBz3iWcOlRem_mO09GtSKEKrAsfO7Frgx18pNU/edit#gid=0)**

## **以太坊虚拟机**

**智能合同运行在网络中的每一台计算机上。智能合约被恶意编写感染电脑怎么办？如果他们可以访问您的个人文件，甚至打开您的网络摄像头，会怎么样？我们如何解决这个安全问题？**

**以太坊虚拟机(EVM)有效地解决了这个问题。当您加入以太坊网络时，您的计算机上会安装一个 EVM。EVM 完全封装了区块链上运行的所有东西，并将其与运行它的机器隔离开来。EVM 就像是你电脑中的**电脑，没有任何东西可以从 EVM 逃到你真正的电脑上。事实上，EVM 完全不知道它之外的任何事情，这也增加了它的几层安全性，保证了 EVM 上发生的所有事情都停留在 EVM 上。****

# **好处/优势**

**下面是使用智能合同相对于传统的实体合同的一些优势。**

****取消中介:**智能合约取消了对中介的需求，允许所有相关方之间建立直接透明的关系。**

****效率:**智能合同使用软件代码将繁琐的任务和相关文书工作自动化，从而节省时间和金钱。这种任务自动化还有助于避免人为错误。**

****安全性:**由于文档以加密形式存储在不可变的分类账上，因此安全性很高，误用或篡改的可能性很低。因为数据是按时间顺序存储的，所以跟踪审计线索变得非常容易。**

****去中心化:**因为你的数据存储在网络上的所有节点上，即使一个节点宕机或者出现故障，其他节点也可以备份。**

# **局限性/缺点**

**虽然智能合约有一些令人敬畏的优势，但肯定还有一些方面需要改进。**

****缺乏国际认可:**没有第三方参与的分散交易在一些国家不被合法认可。此外，法律在得到认可的领域还不够成熟。这种监管的缺失使得它很难被完全采纳。**

****不可变:**智能合约一旦放到区块链上，就不能更改。在解决智能协定中的错误或将来需要更改智能协定中的代码等情况下，灵活性会降低。您更改代码的唯一方法是在区块链上添加智能合约的新副本。**

****新技术:**这项技术仍然相对较新，在它的几个用例中，它的含义仍然没有得到充分的评估。因此，随着它变得更加成熟，它仍然需要获得更广泛的信任。**

# **应用程序**

**智能合同有潜力应用于我们生活的几乎每一个方面——医疗保健、金融/银行业、工业、房地产、政府和私营部门。**

**下面是智能合约的几个应用。**

## **银行/保险**

**许多项目正在开发中，希望将银行业转变为基于区块链技术运行。这些项目，主要是 Dapps，如 Meld 和 MakerDAO，将内在地需要智能合同，以消除第三方干预的需要。**

**在保险领域，智能合同可用于错误检查、路由和高效支付。他们通过使用分散的、不可变的分类账记账，并最大限度地降低欺诈风险来实现这一目标。**

## **卫生保健**

**智能合同可以用来实现医疗保健支付系统的自动化。它可以在区块链上记录所有医疗保健交易和账单，并通过创建单一视图在患者、医疗保健提供商和保险公司之间实现透明。这些记录可以以编码形式存储，以解决数据安全和隐私问题。只有这些记录所属的人才能访问它。**

## **房地产**

**房地产交易包括给房地产经纪人的大量佣金和给律师的费用，律师帮助买方或卖方进行交易以转移财产的所有权。通过使用智能合约，中间商的这些佣金和费用可以被取消。**

**人们可以在智能合同中构建复杂的逻辑，以确保在所有权转移发生之前满足协议的所有条款。这些交易将被记录在一个不可变的分类账上，以尽量减少欺诈的机会。**

## **管理**

**在去中心化自治组织(Dao)中，智能契约可以用来根据内置的复杂条件逻辑代表人类做出决策。例如，如果原材料供应低于某个阈值，智能合同可以触发订单，要求供应商/制造商交付一批新的原材料。**

# **智能合约的未来**

**未来智能合同的采用取决于我们如何应对上述挑战。更简单和更直接的传统合同可以容易地标准化为智能合同模板。然而，更复杂的合同由于其独特的性质和不断变化的环境而需要经常变更，在我们找到解决上述一些问题的共同点之前，这些合同可能必须保持常规。**

**随着这项技术的成熟，我们将在日常生活的各个方面看到越来越多的智能合同。**

# **智能合同示例**

**下面是来自 [Solidity Docs](https://docs.soliditylang.org/en/v0.8.11/introduction-to-smart-contracts.html?#subcurrency-example) 的简单代码片段，它制作了一个小型模拟加密货币。我建议查看 Solidity 文档，看看更多的例子。**

```
*// SPDX-License-Identifier: GPL-3.0*
**pragma solidity** ^**0.8.4**;
```

**在第 1 行，我们确定代码是在 GPL 版本 3.0 下授权的，在第 2 行，我们指定了我们将要使用的 Solidity 的版本。我们这样做是因为在新的 Solidity 编译器中可能会有突破性的变化，所以我们希望保持这个版本。**

```
**contract** **Coin** {
    address **public** minter;
    mapping (address => uint) public balances;
```

**在第 4 行，我们初始化了我们的契约，我们将它命名为*硬币*，在第 5 行，我们初始化了一个名为*铸币商*的地址，但是我们还没有给它赋值。注意，它还有 **public** 标签，这意味着这个变量可以被其他契约访问。在第 6 行，我们现在创建一个名为 *balances* 的映射。映射本质上类似于一个键和值查找器，所以如果您向 balances 变量输入一个地址，您将得到一个 *uint* ，或者无符号整数，这本质上意味着它不是负的。**

```
 event Sent(address from, address to, uint amount);
```

**在这里，在第 8 行，我们仍然在契约内，现在我们正在创建一个*事件*。一个事件基本上允许用户看到对合同做了什么更改。可以发出一个事件，表示它已经被执行。**

```
 constructor() {
        minter = **msg.sender**;
    }
```

**在第 10 行，我们使用了一个*构造函数*。创建契约时，嵌套在构造函数中的所有代码都会被执行。在第 11 行，我们最后定义了变量 *minter* ，并将其值设置为 *msg.sender* ，这实际上是发送“消息”的帐户的地址**

```
 function mint(address receiver, uint amount) public {
        require(**msg.sender** == minter);
        balances[receiver] += amount;
    }
```

**在第 13 行，一个函数 *mint* 被调用。这个功能实质上是创建和发送(或铸造)货币到一个特定的地址。该函数的参数是作为地址的接收者，以及作为无符号整数发送的数量。 *mingt* 函数只能由智能合约的开发者调用。在第 14 行，我们要求初始化智能合约的帐户地址 msg.sender 等于 minter 的地址。然后，通过使用我们的*余额*映射，我们将我们想要给予的金额添加到接收者的账户中。**

```
 error InsufficientBalance(uint requested, uint available);
```

**在第 18 行，我们定义了一个*错误*。错误可以提供有关操作失败的方式和原因的信息。我们正在传递所需的参数*和可用的参数*。**

```
 function send(address receiver, uint amount) public {
        if (amount > balances[**msg.sender**])
            revert InsufficientBalance({
                requested: amount,
                available: balances[**msg.sender**]
            });
```

**在第 20 行，我们创建了一个名为 *send* 的函数，它将硬币发送到调用该函数的地址。在第 21–24 行，我们首先检查请求发送的金额是否大于调用该函数的人的余额。如果条件为真， *revert* 关键字无条件地停止所有代码，并给出一个*错误*，参数为请求了多少和有多少可用。**

```
 balances[**msg.sender**] -= amount;
        balances[receiver] += amount;
        emit Sent(**msg.sender**, receiver, amount);
    }
}
```

**仍然在函数内部，如果前面的条件是假的，那么我们继续下一行。在这里，我们减去发送方发送的硬币数量，然后将相同的数量添加到接收方。然后，我们*发出*事件，*发送*，告知我们交易成功。**

# **其他读物/资料来源**

**这里是我用来创作这篇文章的一些资料来源，以及一些额外的阅读材料。**

*   **[区块链|智能合约— GeeksforGeeks](https://www.geeksforgeeks.org/smart-contracts/)**
*   **什么是智能合约？【智能合约初级入门指南】**
*   **[智能合同——概述、用途、优势和局限性](https://corporatefinanceinstitute.com/resources/knowledge/deals/smart-contracts/)**
*   **[5 个智能合同示例](https://www.kaleido.io/blockchain-blog/5-examples-of-blockchain-smart-contracts)**
*   **智能合约的历史。|下载科学图表**
*   **[智能合约是如何开始的，它们将走向何方](https://www.forbes.com/sites/davidpetersson/2018/10/24/how-smart-contracts-started-and-where-they-are-heading/?sh=671053a137b6)**
*   **[魏定义](https://www.investopedia.com/terms/w/wei.asp)**
*   **[汽油和费用| ethereum.org](https://ethereum.org/en/developers/docs/gas/)**

**如果你做到了这一步，感谢你阅读我的文章。一定要保持安全和快乐的假期！**