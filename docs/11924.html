<html>
<head>
<title>Go: Function Names and Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go:函数名和泛型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-function-names-and-generics-c4a2cd6eefc7?source=collection_archive---------8-----------------------#2022-04-29">https://levelup.gitconnected.com/go-function-names-and-generics-c4a2cd6eefc7?source=collection_archive---------8-----------------------#2022-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/39216bc30ae0c2897d3c9abfc3816524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*7cdIN7ncTNPzhkBvr-OzMw.png"/></div></figure><p id="e1b8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用Go，您会立即了解到函数<a class="ae kv" href="https://en.wikipedia.org/wiki/Type_signature#Signature" rel="noopener ugc nofollow" target="_blank">签名</a>不包含类型信息。所以，<em class="kw">不像很多语言</em>，你不能有:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="edae" class="lg lh it lc b gy li lj l lk ll">func Max(a, b int)<br/>func Max(a, b float)</span></pre><p id="1591" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您需要在函数名中明确包含类型信息，以区分它们:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="89d9" class="lg lh it lc b gy li lj l lk ll">func MaxInt(a, b int)<br/>func MaxFloat(a, b float)</span></pre><p id="5d04" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">很烦，但问题不大。</p><h2 id="a54d" class="lg lh it bd lm ln lo dn lp lq lr dp ls ki lt lu lv km lw lx ly kq lz ma mb mc bi translated">当…时，事情变得有点混乱</h2><p id="19fc" class="pw-post-body-paragraph jx jy it jz b ka md kc kd ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku im bi translated">当你开始写结构“方法”(我把方法放在引号中，因为我更喜欢结构函数)，事情变得更加混乱。它们变得更加混乱，因为在结构函数中，类型信息<em class="kw">被</em>隐式包含:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="4eac" class="lg lh it lc b gy li lj l lk ll">func (f *Foo) String() string<br/>func (b *Bar) String() string</span></pre><p id="d398" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">以上是好的和正确的，并且它是必需的，没有这个东西像<em class="kw">接口</em>就不会工作。在一种情况下，类型信息本质上不是函数签名的一部分，而在另一种情况下却是。有原因，有逻辑，但还是有点乱。你会熬过去的。您将学习何时使用结构函数，何时使用传统函数，以及每种函数的命名要求。</p><h2 id="5d12" class="lg lh it bd lm ln lo dn lp lq lr dp ls ki lt lu lv km lw lx ly kq lz ma mb mc bi translated">然后我们有了仿制药</h2><p id="5ef2" class="pw-post-body-paragraph jx jy it jz b ka md kc kd ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku im bi translated">我喜欢在Go中加入泛型。我立即开始和他们一起工作。特别是，我看了Kotlin的<em class="kw">序列</em>和<em class="kw">地图</em>并实现了一个Go包<a class="ae kv" href="https://github.com/nwillc/genfuncs" rel="noopener ugc nofollow" target="_blank"> genfuncs </a>很大程度上是受他们的启发。</p><p id="cf24" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">很快我就能够将Go的泛型应用到它的<em class="kw">切片</em>和<em class="kw">映射</em>中，创建了一个<em class="kw"> GSlice </em>和<em class="kw"> GMap </em>，给人一种与Kotlin非常相似的感觉，我发现使用它是一种享受。</p><h2 id="dfe1" class="lg lh it bd lm ln lo dn lp lq lr dp ls ki lt lu lv km lw lx ly kq lz ma mb mc bi translated">但是我忘了那些乱七八糟的东西</h2><p id="2f28" class="pw-post-body-paragraph jx jy it jz b ka md kc kd ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku im bi translated">使用泛型，提供类型作为参数，让它<strong class="jz iu">只</strong> <strong class="jz iu">工作</strong>让我暂时忘记了那些乱七八糟的东西。我写了我的<em class="kw"> GSlice </em>和<em class="kw"> GMap </em>，它们很好地利用了参数化类型。太棒了。我在这两个平台上都写了类似于<em class="kw"> ForEach </em>的东西，它做了正确的事情。我又回到了泛型的老路，实现了越来越多的泛型。然后…</p><h2 id="d5e9" class="lg lh it bd lm ln lo dn lp lq lr dp ls ki lt lu lv km lw lx ly kq lz ma mb mc bi translated">它变得更加混乱</h2><p id="1667" class="pw-post-body-paragraph jx jy it jz b ka md kc kd ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku im bi translated">Go的泛型不允许在结构函数上添加或细化类型。符合逻辑，符合语言，但是烦人。假设您有一个泛型<em class="kw"> GSlice </em>并且您想要提供一个<em class="kw"> Map </em>函数，该函数通过用函数转换元素来返回一个新的<em class="kw"> GSlice </em>类型的<em class="kw"> any </em>。除了，在Go的泛型中，你不能。不能在结构函数中引入或细化新的类型参数。好的，没问题，用一个传统函数:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="9004" class="lg lh it lc b gy li lj l lk ll"><em class="kw">func </em>Map[T, R any](s GSlice[T], fn func(t T) R) GSlice[R]</span></pre><p id="9f67" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">那很好。不过后来我又去给一个<em class="kw"> GMap </em>写了相应的<em class="kw"> Map </em>函数。失败。我已经使用了函数名<em class="kw">地图</em>。怎么办？我可以将<em class="kw"> GSlice </em>和<em class="kw"> GMap </em>移到单独的包中，或者我可以用类型重命名<em class="kw"> Map </em>，比如<em class="kw"> MapGSlice </em>和<em class="kw"> MapGMap </em>。两者都不是优雅的选择，但都行得通<em class="kw">【1】</em>。</p><h2 id="5c39" class="lg lh it bd lm ln lo dn lp lq lr dp ls ki lt lu lv km lw lx ly kq lz ma mb mc bi translated">总而言之</h2><p id="b84e" class="pw-post-body-paragraph jx jy it jz b ka md kc kd ke me kg kh ki mf kk kl km mg ko kp kq mh ks kt ku im bi translated">Go在这方面的限制不是无法忍受的，但是它们很烦人，导致代码不够优雅。</p><p id="18b9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我希望函数签名中包含类型。</p><p id="b89a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我希望你能在泛型的结构函数上提炼/添加类型参数。</p><p id="270e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但我会克服的。我只需要记住围棋的限制。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="965f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><strong class="jz iu">脚注:</strong></p><p id="189f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">[1]虽然Go要求函数名是唯一的，并且通常您想要区分它们的只是类型信息，但是它并没有统一的模式。看看像<em class="kw"> math </em>和<em class="kw"> strconv </em>这样的软件包，你会发现一个混合的命名模式包。</p></div></div>    
</body>
</html>