<html>
<head>
<title>Exploring External Authentication with Envoy — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Envoy探索外部认证—第一部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/exploring-external-authorisation-with-envoy-part-i-dd0b5fd83d8f?source=collection_archive---------21-----------------------#2022-08-14">https://levelup.gitconnected.com/exploring-external-authorisation-with-envoy-part-i-dd0b5fd83d8f?source=collection_archive---------21-----------------------#2022-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bb3b84ae91f6370623f736b455bd2f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rzh_quFLyP85kWr7MZ3QJg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">资料来源:联合国人类住区规划署</figcaption></figure><p id="54f9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在微服务架构中，会出现许多服务服务于来自经过身份验证的用户的请求的用例。例如，假设电子商务网站中的order create API要求用户身份验证(简称为authN)令牌出现在请求中。下单API或添加到购物车API也是如此。它们都只期望来自经过身份验证的用户的请求。</p><p id="d2c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">大多数互联网后端服务都已经有一个authN服务来验证用户，它在用户登录时向经过验证的用户发放令牌。来自同一用户帐户的任何后续API调用都将包含用户令牌。我们可以通过从每个其他服务调用相同的authN服务来非常简单地处理上面的用例。该架构的框图如下所示。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi la"><img src="../Images/cea8f5557bd53ff1fa684359cd21c651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UHYmmOb0iP4FUTNVnpFmzA.png"/></div></div></figure><p id="83db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虽然，上面的架构没有任何问题(就像生活中的其他事情一样，不完全是二进制的:p)，但我们需要添加相同的代码来调用authN服务，以验证来自每个服务的令牌。</p><p id="6dff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有一个更好的方法从一个前端代理来处理这个问题。嗯，前端代理是一个只将有效的(读取认证的)请求传递给服务的代理。特使非常适合做这个前台代理。所以我们的架构现在看起来是这样的。现在看起来简单多了。</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lf"><img src="../Images/0049773a7f092c81949a65073a16d1e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UykOP-FM-NNzUJ-rCGWZgg.png"/></div></div></figure><p id="9116" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们博客的下一部分<a class="ae lg" rel="noopener ugc nofollow" target="_blank" href="/exploring-external-authorisation-with-envoy-part-ii-573c35f64c78">中，我们将会看到如何用Envoy处理外部认证。</a></p></div></div>    
</body>
</html>