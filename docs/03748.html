<html>
<head>
<title>Evaluating Performance on Classic Sorting Algorithms in Python and Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python和Rust中经典排序算法的性能评估</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/evaluating-performance-on-classic-sorting-algorithms-in-python-and-rust-76f981dfc0c?source=collection_archive---------14-----------------------#2020-05-25">https://levelup.gitconnected.com/evaluating-performance-on-classic-sorting-algorithms-in-python-and-rust-76f981dfc0c?source=collection_archive---------14-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/14e4f75bb40360dada8b6707ce568d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I51zkOMA5WXQcS8Q"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kf" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>拍摄</figcaption></figure><h1 id="0186" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">背景</h1><p id="6690" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">算法性能一直是解决复杂现实世界用例的关键因素之一。我们需要高效的算法，尤其是在对大量数据进行排序的情况下。在本文中，我将带您了解如何在Python和Rust编程语言中实现冒泡、插入、快速和合并排序算法，以了解编程语言是否对获得性能优势有影响。</p><div class="mc md gp gr me mf"><a href="https://www.eduelk.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">教育</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">通过我们的练习题为您的下一次技术认证考试树立信心。我们提供课程来加速…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">www.eduelk.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jz mf"/></div></div></a></div><div class="mc md gp gr me mf"><a href="https://www.eduelk.com/about-us" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">关于我们——教育</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">在爱德克教育，我们相信熟能生巧。我们知道准备参加技术认证是…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">www.eduelk.com</p></div></div><div class="mo l"><div class="mu l mq mr ms mo mt jz mf"/></div></div></a></div><div class="mc md gp gr me mf"><a href="https://www.eduelk.com/shop-for-practice-questions" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">通过我们负担得起的练习题获得自信——教育</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">编辑描述</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">www.eduelk.com</p></div></div><div class="mo l"><div class="mv l mq mr ms mo mt jz mf"/></div></div></a></div><div class="mc md gp gr me mf"><a href="https://www.eduelk.com/book-a-lesson" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">联系方式1——教育</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">编辑描述</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">www.eduelk.com</p></div></div><div class="mo l"><div class="mw l mq mr ms mo mt jz mf"/></div></div></a></div><h1 id="a56d" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">先决条件</h1><p id="3205" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在继续本文之前，您应该已经，</p><ul class=""><li id="9584" class="mx my it lg b lh mz ll na lp nb lt nc lx nd mb ne nf ng nh bi translated">Python和Rust的基本编程经验</li><li id="eb69" class="mx my it lg b lh ni ll nj lp nk lt nl lx nm mb ne nf ng nh bi translated">对一些经典排序算法的基本理解</li></ul><h1 id="f946" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">环境</h1><ul class=""><li id="df21" class="mx my it lg b lh li ll lm lp nn lt no lx np mb ne nf ng nh bi translated">Docker版本19.03.6</li><li id="57c7" class="mx my it lg b lh ni ll nj lp nk lt nl lx nm mb ne nf ng nh bi translated">Python 3.7.3</li><li id="3c88" class="mx my it lg b lh ni ll nj lp nk lt nl lx nm mb ne nf ng nh bi translated">铁锈1.43.1</li></ul><h1 id="6c6d" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">冒泡排序</h1><h2 id="4df9" class="nq kh it bd ki nr ns dn km nt nu dp kq lp nv nw ku lt nx ny ky lx nz oa lc ob bi translated">计算机编程语言</h2><p id="a1df" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu">源代码:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="899c" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">import </strong>random<br/><strong class="oh iu">import </strong>datetime</span><span id="9091" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">def </strong>BubbleSortAsc(array):<br/> no_swap = True<br/> <br/> while no_swap:<br/>  no_swap = False</span><span id="5710" class="nq kh it oh b gy op om l on oo">  for position in range(0, len(array)-1):<br/>   if array[position] &gt; array[position+1]:</span><span id="bd30" class="nq kh it oh b gy op om l on oo">    # swap<br/>    temp = array[position]<br/>    array[position] = array[position+1]<br/>    array[position+1] = temp<br/>    no_swap = True</span></pre><p id="4eba" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">运行:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="0408" class="nq kh it oh b gy ol om l on oo">if __name__ == "__main__":<br/> <!-- -->array = [index for index in range(1, 100001)]<br/> random.shuffle(array)<br/> start = datetime.datetime.now()<br/> BubbleSortAsc(array)<br/> end = datetime.datetime.now()<br/> print("It took: ", (end-start).total_seconds()*1000, "ms to sort")</span></pre><p id="7eab" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">性能:</strong></p><ul class=""><li id="d3a4" class="mx my it lg b lh mz ll na lp nb lt nc lx nd mb ne nf ng nh bi translated">按升序对随机的10000个正整数进行排序花费了<strong class="lg iu"> 9953.896999999999 </strong>毫秒</li><li id="fc87" class="mx my it lg b lh ni ll nj lp nk lt nl lx nm mb ne nf ng nh bi translated">按升序对随机的<strong class="lg iu"> 100000 </strong>正整数进行排序花费的时间太长。我不够耐心。</li></ul><h2 id="bd37" class="nq kh it bd ki nr ns dn km nt nu dp kq lp nv nw ku lt nx ny ky lx nz oa lc ob bi translated">锈</h2><p id="456b" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu">源代码:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="c7ca" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">use </strong>rand::seq::SliceRandom;<br/><strong class="oh iu">use </strong>rand::thread_rng;<br/><strong class="oh iu">use </strong>std::time::Instant;</span><span id="7d45" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">fn </strong>bubble_sort(vec: &amp;mut Vec&lt;i32&gt;) {<br/> let mut no_swap = true;</span><span id="de24" class="nq kh it oh b gy op om l on oo"> while no_swap {<br/>  no_swap = false;</span><span id="50a7" class="nq kh it oh b gy op om l on oo">  for index in 0..vec.len()-1 {</span><span id="f7d5" class="nq kh it oh b gy op om l on oo">   if vec[index] &gt; vec[index+1]{<br/> <br/>    let temp = vec[index];<br/>    vec[index] = vec[index+1];<br/>    vec[index+1] = temp;<br/>    no_swap = true;<br/>   }<br/>  }<br/> }<br/>}</span></pre><p id="5cd4" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">运行:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="a28e" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">fn </strong>main() {<br/> let mut rng = thread_rng();<br/> let mut int_vec = Vec::new();<br/> let max_num = 10001;<br/> <br/> for num in 1..max_num {<br/>  int_vec.push(num as i32);<br/> }</span><span id="4d74" class="nq kh it oh b gy op om l on oo"> println!("Unshuffled: {:?}", int_vec);<br/> int_vec.shuffle(&amp;mut rng);<br/> println!("Shuffled: {:?}", int_vec);</span><span id="aa24" class="nq kh it oh b gy op om l on oo"> let start = Instant::now();<br/> bubble_sort(&amp;mut int_vec);<br/> let elapsed = start.elapsed();<br/> println!("It took: {} milliseconds to sort", elapsed.as_millis());<br/>}</span></pre><p id="5ef6" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">表现:</strong></p><ul class=""><li id="22b7" class="mx my it lg b lh mz ll na lp nb lt nc lx nd mb ne nf ng nh bi translated">将随机的10000个正整数按升序排序花费了8316毫秒</li><li id="4c05" class="mx my it lg b lh ni ll nj lp nk lt nl lx nm mb ne nf ng nh bi translated">将随机的<strong class="lg iu"> 100000 </strong>正整数按升序排序花费的时间太长。我不够耐心。</li></ul><h1 id="81b5" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">插入排序</h1><h2 id="b957" class="nq kh it bd ki nr ns dn km nt nu dp kq lp nv nw ku lt nx ny ky lx nz oa lc ob bi translated">计算机编程语言</h2><p id="18d8" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu">源代码:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="730b" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">import</strong> random<br/><strong class="oh iu">import </strong>datetime</span><span id="f14a" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">def </strong>InsertionSortAsc(array):<br/> for index in range(1, len(array)):<br/> <br/>  key = array[index]<br/>  j = index — 1</span><span id="0433" class="nq kh it oh b gy op om l on oo">  while j &gt;=0 and key &lt; array[j]:<br/>   array[j+1] = array[j]<br/>   j -= 1<br/> <br/>  array[j+1] = key</span></pre><p id="a914" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">运行:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="5b04" class="nq kh it oh b gy ol om l on oo">if __name__ == "__main__":<br/> <!-- -->array = [index for index in range(1, 100001)]<br/> random.shuffle(array)<br/> start = datetime.datetime.now()<br/> InsertionSortAsc(array)<br/> end = datetime.datetime.now()<br/> print("It took: ", (end-start).total_seconds()*1000, "ms to sort")</span></pre><p id="e73d" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">性能:</strong></p><ul class=""><li id="2449" class="mx my it lg b lh mz ll na lp nb lt nc lx nd mb ne nf ng nh bi translated">按升序对随机的<strong class="lg iu"> 10000 </strong>正整数<strong class="lg iu"> </strong>进行排序花费了<strong class="lg iu"> 2714.989 </strong>毫秒</li><li id="deae" class="mx my it lg b lh ni ll nj lp nk lt nl lx nm mb ne nf ng nh bi translated">将随机的<strong class="lg iu"> 100000 </strong>正的<strong class="lg iu"> </strong>整数按升序排序花费的时间太长。我不够耐心。</li></ul><h2 id="803c" class="nq kh it bd ki nr ns dn km nt nu dp kq lp nv nw ku lt nx ny ky lx nz oa lc ob bi translated">锈</h2><p id="9039" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu">源代码:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="32ce" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">use</strong> rand::seq::SliceRandom;<br/><strong class="oh iu">use</strong> rand::thread_rng;<br/><strong class="oh iu">use</strong> std::time::Instant;</span><span id="66f9" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">fn </strong>insertion_sort(vec: &amp;mut Vec&lt;i32&gt;) {<br/> for index in 1..vec.len() {<br/>  let mut j = index;<br/>  while j &gt; 0 &amp;&amp; vec[j-1] &gt; vec[j] {<br/>   vec.swap(j — 1, j);<br/>   j -= 1;<br/>  }<br/> }<br/>}</span></pre><p id="2f3f" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">运行:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="fbdd" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">fn </strong>main() {<br/> let mut rng = thread_rng();<br/> let mut int_vec = Vec::new();<br/> let max_num = 10001;</span><span id="0741" class="nq kh it oh b gy op om l on oo"> for num in 1..max_num {<br/>  int_vec.push(num as i32);<br/> }</span><span id="b5a1" class="nq kh it oh b gy op om l on oo"> println!("Unshuffled: {:?}", int_vec);<br/> int_vec.shuffle(&amp;mut rng);<br/> println!("Shuffled: {:?}", int_vec);</span><span id="35ef" class="nq kh it oh b gy op om l on oo"> let start = Instant::now();<br/> insertion_sort(&amp;mut int_vec);<br/> let elapsed = start.elapsed();<br/> println!("sorted: {:?}", int_vec);<br/> println!("It took: {} milliseconds to sort", elapsed.as_millis());<br/>}</span></pre><p id="ac3c" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">性能:</strong></p><ul class=""><li id="42a3" class="mx my it lg b lh mz ll na lp nb lt nc lx nd mb ne nf ng nh bi translated">用了<strong class="lg iu"> 1377 </strong>毫秒将随机的<strong class="lg iu"> 10000 </strong>正的<strong class="lg iu">T5】整数按升序排序</strong></li><li id="3ecc" class="mx my it lg b lh ni ll nj lp nk lt nl lx nm mb ne nf ng nh bi translated">按升序对随机的<strong class="lg iu"> 100000 </strong>正整数<strong class="lg iu"> </strong>进行排序花费的时间太长。我不够耐心。</li></ul><h1 id="efa2" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">快速排序</h1><h2 id="f4f1" class="nq kh it bd ki nr ns dn km nt nu dp kq lp nv nw ku lt nx ny ky lx nz oa lc ob bi translated">计算机编程语言</h2><p id="0dee" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu">源代码:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="0cdb" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">import </strong>random<br/><strong class="oh iu">import </strong>datetime</span><span id="c113" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">def </strong>partitionAsc(arr, low, high):<br/> i = low — 1 # index of smaller element<br/> pivot = arr[high] # pivot: using last element as pivot<br/> for j in range(low, high): #j = 0,1,2,..,7<br/>  # If current element is smaller than or equal to pivot<br/>  if arr[j] &lt;= pivot:<br/>   # increment index of smaller element<br/>   i = i+1<br/>   arr[i], arr[j] = arr[j], arr[i] #swaps arr[i] and arr[j]<br/> <br/> arr[i+1], arr[high] = arr[high], arr[i+1] #swaps<br/> return i+1 #index of the partition that is in its correct position</span><span id="1f68" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">def </strong>quickSortAsc(arr, low, high):<br/> if low &lt; high:<br/>  # pi is partitioning index, arr[p] is now at right place<br/>  pi = partitionAsc(arr, low, high)<br/>  # Separately sort elements before partition and after partition<br/>  quickSortAsc(arr, low, pi-1)<br/>  quickSortAsc(arr, pi+1, high)</span><span id="674b" class="nq kh it oh b gy op om l on oo"> return</span></pre><p id="59c8" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">运行:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="2f7b" class="nq kh it oh b gy ol om l on oo">if __name__ == "__main__":<br/> <!-- -->array = [index for index in range(1, 100001)]<br/> random.shuffle(array)<br/> start = datetime.datetime.now()<br/> quickSortAsc(array, 0, len(array)-1)<br/> end = datetime.datetime.now()<br/> print("It took: ", (end-start).total_seconds()*1000,  "ms to sort")</span></pre><p id="346e" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">性能:</strong></p><ul class=""><li id="1318" class="mx my it lg b lh mz ll na lp nb lt nc lx nd mb ne nf ng nh bi translated">用了<strong class="lg iu"> 17.005 </strong>毫秒对随机<strong class="lg iu"> 10000 </strong>正整数<strong class="lg iu"> </strong>进行升序排序。</li><li id="2d9c" class="mx my it lg b lh ni ll nj lp nk lt nl lx nm mb ne nf ng nh bi translated">用了<strong class="lg iu">230.286999999999998</strong>毫秒对随机<strong class="lg iu"> 100000 </strong>正整数<strong class="lg iu"> </strong>进行升序排序。</li></ul><h2 id="be2f" class="nq kh it bd ki nr ns dn km nt nu dp kq lp nv nw ku lt nx ny ky lx nz oa lc ob bi translated">锈</h2><p id="c07d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu">源代码:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="f939" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">use </strong>rand::seq::SliceRandom;<br/><strong class="oh iu">use </strong>rand::thread_rng;<br/><strong class="oh iu">use </strong>std::time::Instant;</span><span id="c8e0" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">fn </strong>swap(vec: &amp;mut Vec&lt;i32&gt;, i: usize, j: usize ) {<br/> let temp = vec[i];<br/> vec[i] = vec[j];<br/> vec[j] = temp;<br/>}</span><span id="95b6" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">fn </strong>partition(vec: &amp;mut Vec&lt;i32&gt;, start: usize, end: usize ) -&gt; i32 {<br/> let mut pivot = vec[end];<br/> let mut index = start;<br/> let mut i = start;<br/> <br/> while i &lt; end {<br/> <br/>  if vec[i] &lt; pivot {<br/>   swap(vec, i, index);<br/>   index+=1;<br/>  }<br/> <br/>  i+=1;<br/> }</span><span id="4e7d" class="nq kh it oh b gy op om l on oo"> swap(vec, index, end);<br/> return index as i32;<br/>}</span><span id="048a" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">fn </strong>quick_sort(vec: &amp;mut Vec&lt;i32&gt;, start: usize, end: usize) {<br/> if start &gt;= end {<br/>  return;<br/> }</span><span id="708b" class="nq kh it oh b gy op om l on oo"> let mut pivot = partition(vec, start, end);<br/> let min_pivot = if pivot == 0 { 0 } else { pivot — 1 };<br/> <br/> quick_sort(vec, start, min_pivot as usize);<br/> quick_sort(vec, (pivot + 1) as usize, end);<br/>}</span></pre><p id="c729" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated">Rust源代码灵感来自Turreta.com[1]。</p><p id="a2fa" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">运行:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="6baa" class="nq kh it oh b gy ol om l on oo">fn main() {<br/> let mut rng = thread_rng();<br/> let mut int_vec = Vec::new();<br/> let max_num = 10001;</span><span id="4ccf" class="nq kh it oh b gy op om l on oo"> for num in 1..max_num {<br/>  int_vec.push(num as i32);<br/> }</span><span id="110b" class="nq kh it oh b gy op om l on oo"> println!("Unshuffled: {:?}", int_vec);<br/> int_vec.shuffle(&amp;mut rng);<br/> println!("Shuffled: {:?}", int_vec);</span><span id="7815" class="nq kh it oh b gy op om l on oo"> let start = Instant::now();<br/> let high = int_vec.len()-1;<br/> quick_sort(&amp;mut int_vec, 0, high);<br/> let elapsed = start.elapsed();<br/> println!("It took: {} milliseconds to sort", elapsed.as_millis());<br/>}</span></pre><p id="336a" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">性能:</strong></p><ul class=""><li id="f45c" class="mx my it lg b lh mz ll na lp nb lt nc lx nd mb ne nf ng nh bi translated">按升序对随机的<strong class="lg iu"> 10000个</strong>正整数排序花费了<strong class="lg iu"> 8 </strong>毫秒</li><li id="d94f" class="mx my it lg b lh ni ll nj lp nk lt nl lx nm mb ne nf ng nh bi translated">将随机的100000个正整数按升序排序花费了<strong class="lg iu"> 113 </strong>毫秒</li></ul><h1 id="8ef1" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">合并排序</h1><h2 id="8b55" class="nq kh it bd ki nr ns dn km nt nu dp kq lp nv nw ku lt nx ny ky lx nz oa lc ob bi translated">计算机编程语言</h2><p id="2993" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu">源代码:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="4180" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">import </strong>random<br/><strong class="oh iu">import </strong>datetime</span><span id="6bb4" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">def </strong>MergeAsc(left,right):<br/> #Function to merge two lists</span><span id="df50" class="nq kh it oh b gy op om l on oo"> temp_array = [] #additional memory needed<br/> while len(left) != 0 and len(right) != 0:</span><span id="85e3" class="nq kh it oh b gy op om l on oo">  if left[0] &lt; right[0]:</span><span id="7047" class="nq kh it oh b gy op om l on oo">   temp_array.append(left[0])<br/>   left.remove(left[0])</span><span id="5073" class="nq kh it oh b gy op om l on oo">  else:</span><span id="2aae" class="nq kh it oh b gy op om l on oo">   temp_array.append(right[0])<br/>   right.remove(right[0])<br/> <br/> if len(left) == 0:<br/>  temp_array += right<br/> else:<br/>  temp_array += left</span><span id="6a62" class="nq kh it oh b gy op om l on oo"> return temp_array</span><span id="c258" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">def </strong>MergeSortAsc(array):<br/> # Function to sort a list using merge sort algorithm</span><span id="b725" class="nq kh it oh b gy op om l on oo"> if len(array) == 0 or len(array) == 1:<br/>  return array<br/> else:</span><span id="68d9" class="nq kh it oh b gy op om l on oo">  middle = int(len(array)/2)<br/>  left = MergeSortAsc(array[:middle])<br/>  right = MergeSortAsc(array[middle:])</span><span id="eb79" class="nq kh it oh b gy op om l on oo">  return MergeAsc(left,right)</span></pre><p id="990c" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">运行:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="38c4" class="nq kh it oh b gy ol om l on oo">if __name__ == "__main__":<br/> <!-- -->array = [index for index in range(1, 100001)]<br/> random.shuffle(array)<br/> start = datetime.datetime.now()<br/> array = MergeSortAsc(array)<br/> end = datetime.datetime.now()<br/> print("It took: ", (end-start).total_seconds()*1000, "ms to sort")</span></pre><p id="27f0" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">性能:</strong></p><ul class=""><li id="1d09" class="mx my it lg b lh mz ll na lp nb lt nc lx nd mb ne nf ng nh bi translated">用了<strong class="lg iu"> 56.284 </strong>毫秒对随机<strong class="lg iu"> 10000 </strong>正整数进行升序排序。</li><li id="2bee" class="mx my it lg b lh ni ll nj lp nk lt nl lx nm mb ne nf ng nh bi translated">用了<strong class="lg iu"> 1185.939 </strong>毫秒对随机<strong class="lg iu"> 100000 </strong>正整数进行升序排序。</li></ul><h2 id="0c75" class="nq kh it bd ki nr ns dn km nt nu dp kq lp nv nw ku lt nx ny ky lx nz oa lc ob bi translated">锈</h2><p id="0482" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="lg iu">源代码:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="edb7" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">use </strong>rand::seq::SliceRandom;<br/><strong class="oh iu">use </strong>rand::thread_rng;<br/><strong class="oh iu">use </strong>std::time::Instant;</span><span id="9bd9" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">fn </strong>merge(original_vec: &amp;mut Vec&lt;i32&gt;, copy_vec: &amp;mut Vec&lt;i32&gt;, low: usize, mid: usize, high: usize) {<br/> let mut x = low;<br/> let mut y = low;<br/> let mut z = mid + 1;<br/> <br/> while y &lt;= mid &amp;&amp; z &lt;= high {<br/>  if original_vec[y] &lt; original_vec[z] {<br/>   copy_vec[x] = original_vec[y];<br/>   x+=1;<br/>   y+=1;<br/>  } else {<br/>   copy_vec[x] = original_vec[z];<br/>   x+=1;<br/>   z+=1;<br/>  }<br/> }<br/> <br/> while y &lt;= mid {<br/>  copy_vec[x] = original_vec[y];<br/>  x+=1;<br/>  y+=1;<br/> }<br/> <br/> y = low;<br/> while y &lt;= high {<br/>  original_vec[y] = copy_vec[y];<br/>  y+=1;<br/> }<br/>}</span><span id="bb2b" class="nq kh it oh b gy op om l on oo"><strong class="oh iu">fn </strong>merge_sort(original_vec: &amp;mut Vec&lt;i32&gt;, copy_vec: &amp;mut Vec&lt;i32&gt;, low: usize, high: usize) {<br/> if high == low {<br/>  return;<br/> }<br/> <br/> let mut mid: usize = (low + (( high — low ) &gt;&gt; 1));<br/> <br/> merge_sort(original_vec, copy_vec, low, mid);<br/> merge_sort(original_vec, copy_vec, mid + 1, high);<br/> merge(original_vec, copy_vec, low, mid, high);<br/> <br/>}</span></pre><p id="9149" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated">受Turreta.com启发的Rust源代码[2]。</p><p id="38f4" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">运行:</strong></p><pre class="oc od oe of gt og oh oi oj aw ok bi"><span id="df16" class="nq kh it oh b gy ol om l on oo"><strong class="oh iu">fn </strong>main() {<br/> let mut rng = thread_rng();<br/> let mut int_vec = Vec::new();<br/> let max_num = 10001;</span><span id="e0c6" class="nq kh it oh b gy op om l on oo"> for num in 1..max_num {<br/>  int_vec.push(num as i32);<br/> }</span><span id="0786" class="nq kh it oh b gy op om l on oo"> println!("Unshuffled: {:?}", int_vec);<br/> int_vec.shuffle(&amp;mut rng);<br/> println!("Shuffled: {:?}", int_vec);</span><span id="7fdc" class="nq kh it oh b gy op om l on oo"> let len:usize = int_vec.len() — 1;<br/> let start = Instant::now();<br/> merge_sort(&amp;mut int_vec, &amp;mut copy_vec, 0, len);<br/> let elapsed = start.elapsed();<br/> println!("It took: {} milliseconds to sort", elapsed.as_millis());<br/> <br/>}</span></pre><p id="75b1" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated"><strong class="lg iu">性能:</strong></p><ul class=""><li id="1d34" class="mx my it lg b lh mz ll na lp nb lt nc lx nd mb ne nf ng nh bi translated">将随机的10000个正整数按升序排序花费了<strong class="lg iu"> 13 </strong>毫秒</li><li id="5fef" class="mx my it lg b lh ni ll nj lp nk lt nl lx nm mb ne nf ng nh bi translated">按升序对随机的100000个正整数排序花费了174毫秒</li></ul><h1 id="4f8c" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">思想</h1><p id="1806" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">作为一个实验，用Rust编写的排序算法与用Python编写的相比性能稍好。对于10000和100000个正整数的排序，平均性能分别提高了大约10到100毫秒。</p><p id="84f4" class="pw-post-body-paragraph le lf it lg b lh mz lj lk ll na ln lo lp oq lr ls lt or lv lw lx os lz ma mb im bi translated">我觉得除了实时视频分析解决方案等时间关键型应用之外，这在大多数用例中不会成为大问题。我将会发表一篇文章来评估Python和Rust中经典搜索算法的性能。敬请期待！和平！✌️</p><div class="mc md gp gr me mf"><a href="https://www.eduelk.com/" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">教育</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">通过我们的练习题为您的下一次技术认证考试树立信心。我们提供课程来加速…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">www.eduelk.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jz mf"/></div></div></a></div><div class="mc md gp gr me mf"><a href="https://www.eduelk.com/about-us" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">关于我们——教育</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">在爱德克教育，我们相信熟能生巧。我们知道准备参加技术认证是…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">www.eduelk.com</p></div></div><div class="mo l"><div class="mu l mq mr ms mo mt jz mf"/></div></div></a></div><div class="mc md gp gr me mf"><a href="https://www.eduelk.com/shop-for-practice-questions" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">通过我们负担得起的练习题获得自信——教育</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">编辑描述</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">www.eduelk.com</p></div></div><div class="mo l"><div class="mv l mq mr ms mo mt jz mf"/></div></div></a></div><div class="mc md gp gr me mf"><a href="https://www.eduelk.com/book-a-lesson" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">联系方式1——教育</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">编辑描述</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">www.eduelk.com</p></div></div><div class="mo l"><div class="mw l mq mr ms mo mt jz mf"/></div></div></a></div><h1 id="2335" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">参考</h1><ol class=""><li id="510f" class="mx my it lg b lh li ll lm lp nn lt no lx np mb ot nf ng nh bi translated">加布里埃尔，K. S. (2020年1月11日)。Rust中的快速排序算法示例。2020年5月22日检索，来自<a class="ae kf" href="https://turreta.com/2019/10/22/quicksort-algorithm-example-in-rust/" rel="noopener ugc nofollow" target="_blank">https://turreta . com/2019/10/22/quick sort-algorithm-example-in-rust/</a></li><li id="f550" class="mx my it lg b lh ni ll nj lp nk lt nl lx nm mb ot nf ng nh bi translated">加布里埃尔，K. S. (2020年1月11日)。Rust码中的归并排序算法。2020年5月22日检索，来自<a class="ae kf" href="https://turreta.com/2019/10/26/merge-sort-algorithm-in-rust-codes/" rel="noopener ugc nofollow" target="_blank">https://turreta . com/2019/10/26/merge-sort-algorithm-in-rust-codes/</a></li></ol></div></div>    
</body>
</html>