<html>
<head>
<title>Essential Keys to Crack CSS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解CSS的关键</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/essential-keys-to-crack-css-6f938bb9d4bf?source=collection_archive---------14-----------------------#2020-08-24">https://levelup.gitconnected.com/essential-keys-to-crack-css-6f938bb9d4bf?source=collection_archive---------14-----------------------#2020-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b75f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让你说:“啊啊啊……这就是原因！”。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4f41d544cd84a0ff109a79df2c335d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LltPBtg42NDVh06GpEntfg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@kobuagency?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> KOBU机构</a>在<a class="ae kv" href="https://unsplash.com/s/photos/css?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="17af" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">一切都是一个盒子！</h1><p id="84bb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们从假设每个HTML元素在DOM中呈现时都被呈现为一个<strong class="lq ir"> <em class="mk">框</em> </strong>开始。然后，你可以开始添加内容或一些风格，使它看起来更花哨。一开始，这是我们的盒子在浏览器中的实际外观:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/0e499d9bf0f9bda686bd60c083c1d0f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3oHMkw7XIUyKYc5SyczGYw.png"/></div></div></figure><p id="dafe" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><strong class="lq ir"> <em class="mk">蓝色</em> </strong>矩形表示内容大小，它可以由height或width属性指定，也可以适合子项的大小。</p><p id="28eb" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><strong class="lq ir"> <em class="mk">绿色</em> </strong>矩形是填充，它把盒子里包含的所有元素都往里推。内部间距。</p><p id="9d2e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><strong class="lq ir"> <em class="mk">浅橙色的</em> </strong>矩形是盒子的边框。</p><p id="43de" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><strong class="lq ir"> <em class="mk">深橙色</em> </strong>矩形是外部边距，它将框周围的元素推得更远。</p><p id="5c99" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">这4个维度组合在一起，就代表了我们的盒子所占据的物理空间:<em class="mk">高度/宽度+填充+边框+边距=实际空间。</em>不过，<em class="mk"> </em>这个CSS盒子模型就没那么直观了。</p><p id="e5f6" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">让我举一个例子来说明这一点。想象一下这种情况:<br/>在一个500px大的容器中，你有两个带填充和边框的盒子，你希望这两个盒子在父盒子中相邻。当你读到这些文字的时候，我打赌你在想:“<em class="mk">这很简单。我将只给他们两个宽度的50%”。</em></p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="d933" class="mw kx iq ms b gy mx my l mz na">.container {<br/>  width: 500px;<br/>}</span><span id="1ea6" class="mw kx iq ms b gy nb my l mz na">.box {<br/>  border: 1px solid;<br/>  padding: 10px;<br/>  width: 50%;<br/>}</span></pre><p id="d614" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">嗯，这将是结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/2be57b6403d89330bdd1edd6816c918a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RihOgwL0cwqhjd-JvNr9dQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">原始CSS盒模型</figcaption></figure><p id="4f6c" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">是的。这是你可以开始说“这到底是怎么回事！?"。<br/> 如果你还记得，我们说过一个盒子的大小等于宽度(容器的50%，所以250px)，加上两边的填充(10px)和边框(1px)一共是272px。因此，它们不能并排放在500像素的显示器上是有道理的。</p><h2 id="9481" class="mw kx iq bd ky nd ne dn lc nf ng dp lg lx nh ni li mb nj nk lk mf nl nm lm nn bi translated">介绍古怪的版本</h2><p id="752e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">不过有一个解决方案！信不信由你，它来自旧版的ie浏览器。在<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">【怪癖模式】</em> </strong> </a> <strong class="lq ir"> <em class="mk"> </em> </strong>中，盒子模型的物理空间是通过<em class="mk">高度/宽度+边距=实际空间来计算的。</em>因此，在社区的要求下，这个版本在CSS3标准中引入了属性<strong class="lq ir"><em class="mk"/></strong>。通过将值<em class="mk"> "border-box" </em>赋给该属性，填充和边框将应用于内部，使用我们上面提到的相同样式，结果如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/df74de5b1028c127e23818b61606a261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qppPKl86KBCXkLu80R8Qfg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">框尺寸边界框</figcaption></figure><p id="83c3" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">使用“<strong class="lq ir"> * </strong>”选择器在每个元素上应用这个规则是很常见的:</p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="1015" class="mw kx iq ms b gy mx my l mz na">* {<br/>  box-sizing: border-box;<br/>}</span></pre></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="c51f" class="kw kx iq bd ky kz nw lb lc ld nx lf lg jw ny jx li jz nz ka lk kc oa kd lm ln bi translated">你必须记住的两条规则是</h1><p id="8aed" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">大多数开发人员与CSS的关系非常糟糕。他们说“为什么这条规则不管用！?"或者“该死的div没有去它应该去的地方！”或者更糟他们开始使用<strong class="lq ir"> <em class="mk">！重要的</em> </strong> <em class="mk"> </em>无处不在，并赋予像<strong class="lq ir">‘99999’</strong>到<strong class="lq ir"> <em class="mk"> z-index这样的值。</em> </strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/31990d93e16980a1c4d9a34d4f93a007.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*n9LHPR1ep0rppFPkvd7bFw.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">“999999”</figcaption></figure><p id="9f91" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">如果你是这些人中的一员，那么，一旦你知道了下面两条规则，你将停止这样做，你将开始享受编写CSS。相信我！</p><h2 id="4176" class="mw kx iq bd ky nd ne dn lc nf ng dp lg lx nh ni li mb nj nk lk mf nl nm lm nn bi translated">位置</h2><p id="4c9f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">position属性定义元素在页面中的位置。<br/>使用类似于“<em class="mk"> top”、“right”、“bottom”、“left”和“z-index”的属性，可以操纵元素的最终位置，但是它们只会影响<strong class="lq ir"> <em class="mk">定位的元素</em> </strong>(即具有除<strong class="lq ir"> <em class="mk">【静态】</em> </strong>之外的任何值的元素)。以后请记住这一点！</em></p><p id="e51b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">可能的值有:</p><ul class=""><li id="6b62" class="oc od iq lq b lr mm lu mn lx oe mb of mf og mj oh oi oj ok bi translated"><strong class="lq ir">【静态】</strong>，默认值。该元素将与页面<em class="mk">的<em class="mk">正常</em> <em class="mk">流程* </em>一致。</em></li><li id="f9be" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated"><strong class="lq ir">【相对】</strong>。根据正常流程，元素相对于其静态位置，但受位置属性的影响。</li><li id="46bf" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated"><strong class="lq ir">【绝对】</strong>。<strong class="lq ir"> </strong>我认为这个最有争议。每个人都使用它，因为他们认为它做他们想要的，但没有人真正知道它是如何工作的。具有此位置值的元素将从流中物理移除。要知道它现在的位置是<em class="mk">“相对于它的第一个</em> <strong class="lq ir"> <em class="mk">非静态</em> </strong> <em class="mk">祖先”。</em>像口头禅一样重复！</li><li id="cb66" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated"><strong class="lq ir">【固定】</strong>。同样，元素将从页面流中删除，其位置将相对于视口(除了一些小的例外)。此外，固定元素不受滚动的影响。</li></ul><p id="cbca" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated"><strong class="lq ir"> * </strong>元素按照它们在文档中声明的顺序从上到下出现在DOM中。这被认为是正常的<em class="mk">流</em>。</p><h2 id="6328" class="mw kx iq bd ky nd ne dn lc nf ng dp lg lx nh ni li mb nj nk lk mf nl nm lm nn bi translated">显示</h2><p id="197f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">显示决定了一个元素相对于其他元素的行为。一旦你理解了不同的值是如何影响元素及其周围环境的，你就有了破解代码的钥匙。<br/>在“显示”的情况下，我们不能说有唯一的默认值。这取决于我们使用的HTML标签，每个标签都有一个来自"<em class="mk"> computed style"* </em>(例如，div是" block "，spans是" inline ")的默认值。</p><p id="ff24" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">可能的值有:</p><ul class=""><li id="a2f1" class="oc od iq lq b lr mm lu mn lx oe mb of mf og mj oh oi oj ok bi translated"><strong class="lq ir">《格挡》</strong>。它强制执行垂直堆叠，display属性设置为block的元素将占用所有可能的水平空间，在框的前后生成一个换行符。</li><li id="d0e4" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated"><strong class="lq ir">【内联】</strong>。与“块”不同，它允许水平对齐。行内元素将一个接一个地显示，它们将忽略任何给定的宽度、高度和垂直边距。</li><li id="2493" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated"><strong class="lq ir">“内嵌块”</strong>。前两者的混合。它允许水平对齐，我们仍然可以使用宽度和高度属性。</li><li id="e287" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated"><strong class="lq ir">【flex】</strong>。它初始化flexbox布局系统。容器(display设置为flex的元素)将控制其项目的流程。我们可以根据给出的选项排列物品并分配可用空间。</li><li id="0373" class="oc od iq lq b lr ol lu om lx on mb oo mf op mj oh oi oj ok bi translated"><strong class="lq ir">【网格】</strong>。它初始化网格布局，引入具有列和行的二维网格系统。基于一套规则，我们将能够创建“易于制作”的响应式布局。</li></ul><p id="589b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在以后的文章中，我们将更深入地讨论“网格”和“flex”。</p><p id="4027" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">浏览器有一个用户代理样式表，它将一些内置样式应用到我们使用的HTML标签中。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="5744" class="kw kx iq bd ky kz nw lb lc ld nx lf lg jw ny jx li jz nz ka lk kc oa kd lm ln bi translated">z指数的奥秘</h1><p id="8c87" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这可能是最容易被误解的规则。为了正确使用它，我们需要假设几个概念。首先，它的作用:<em class="mk">它控制</em> <strong class="lq ir"> <em class="mk">重叠</em> </strong>的元素的垂直堆叠顺序。这意味着它只对静态以外的位置起作用，否则，它们不能重叠。</p><p id="fde3" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">要理解的第二个重要行为是嵌套很重要。每当我们将元素放入容器中，我们就开始一个全新的堆栈，类似于当你有段落和子段落时。我们可以将段落编号为<strong class="lq ir"> 1 </strong>、<strong class="lq ir"> 2 </strong>、<strong class="lq ir">3</strong>……1的所有子段落将为<strong class="lq ir"> 1.1 </strong>、<strong class="lq ir"> 1.2 </strong>、<strong class="lq ir"> 1.3 </strong>。同样的，你希望所有的元素都在第2段之前，如果你有一个元素在另一个元素里面，并且z-index等于1，那么它将总是在其他元素的后面，这些元素在同一嵌套层次上有一个更大的数字。你应该问问自己:<strong class="lq ir"> 1.9999… </strong>比<strong class="lq ir"> 2 </strong>大吗？”。答案显然是“不”，那么元素为什么要在前面呢？</p><p id="eb75" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">这里有一个直观的例子，其中黄色和蓝色的两个div是红色div的子div，因此我们应该这样阅读它们的<em class="mk"> z索引</em>:<em class="mk"/><strong class="lq ir">4.1</strong>，<strong class="lq ir"> 4.3 </strong>，<strong class="lq ir"> 4.6 </strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/a15ff5589d452e2cf6303408470dc696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5l7Xw8oTegiRh38usZdqgw.png"/></div></div></figure><p id="f650" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">这开始变得有意义了！？</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="badc" class="kw kx iq bd ky kz nw lb lc ld nx lf lg jw ny jx li jz nz ka lk kc oa kd lm ln bi translated">外卖食品</h1><p id="2371" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有时CSS似乎无法预测，但这只是理解规则如何相互关联的问题，这是通过掌握这门语言的几个原则来实现的，如果你不知道什么，就试试看会发生什么。我在Codepen上有一个名为“<a class="ae kv" href="https://codepen.io/collection/AxLbQo" rel="noopener ugc nofollow" target="_blank"> CSS基础知识</a>的集合，每支笔处理不同的主题，在每个CSS文件的底部，我会一步一步地解释你需要做什么。你可以按照说明，看看每一个变化的后果。</p><p id="5909" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">如果你有任何问题或者只是想谈谈CSS，请通过Linkedin联系我。</p></div></div>    
</body>
</html>