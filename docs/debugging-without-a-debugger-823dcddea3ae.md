# 没有调试器的调试

> 原文：<https://levelup.gitconnected.com/debugging-without-a-debugger-823dcddea3ae>

## 如何在调试器不起作用时找到 bug

调试器很棒。但是在有些情况下，它们对追踪 bug 或找到崩溃的原因没有帮助。调试器最常见的问题是，崩溃的根源在第三方库中，而您无法访问该库的源代码。这几乎不意味着问题出在库的内部，尽管这种情况很少发生。更有可能的原因是您使用它的方式不对，或者您的某些代码损坏了内存，从而导致了后来在库中出现问题。以我个人的经验，我不能使用调试器的最大领域是 GPU 编程，或者更具体地说是 OpenGL。当 OpenGL 函数使用不当时，程序会崩溃，但调试器只会说崩溃发生在 Nvidia OpenGL DLL 中，您必须自己找到真正的问题。幸运的是，有一些策略可以帮助你在没有调试器的情况下追踪 bug。

![](img/28cd95676569d9d0c3814b2c8ec02ffc.png)

凯文·Ku 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 将()打印到控制台

当你学习编程时，你几乎肯定会遇到控制台调试。各大编程语言都有一个简单的向控制台写文本的函数:C++中的 *std::cout* ，Java 中的 *System.out.println()* ，或者 JavaScript 中的 *Console.log()* 等。一开始，当你的程序很小的时候，这是最容易调试的方法。只需打印出一个变量的值，并检查它是否是您所期望的，如果不是，您大概知道错误发生在哪里，并有希望修复它。

将行打印到控制台也有助于找到程序崩溃的位置。你可以在任何地方添加很多输出，在程序崩溃后，你可以看到最后一行打印的内容。这意味着您的程序至少已经到达了代码中的那一行，并且在它和下一个打印命令之间崩溃了。

即使在较大的程序中，这仍然是一种有效的技术。编程礼仪不赞成这种类型的调试，但实际上，在很多情况下，这仍然是调试的最快方法。然而，这取决于节目的类型。如果它是一个线性程序，那么它比实时程序要好得多，在实时程序中，更新函数可能每秒钟被调用 60 次以上。如此频繁地在控制台上打印大量文本不仅难以阅读，还会大大降低程序的速度。

使用控制台调试时的一个快速提示:在打印行中投入最少的努力。当我懒惰并开始感到沮丧时，我有时会添加类似于*STD::cout<<" jlasdkjalskdja "<<STD::endl；*到处看程序是否到了那一步。但是我最后会比较随机的字母来找出我把那条线放在哪里了。最好花几秒钟，写出像*STD::cout<<" Class A>function B>start "<<STD::endl；*这样你就知道去哪里找了。

# 注释掉

缩小代码中导致崩溃的区域的一个好方法是注释掉代码行。从注释掉大段代码开始，运行你的程序。如果它没有崩溃，你就知道问题在评论区的某个地方。然后你可以慢慢地重新启用越来越多的代码，直到程序再次崩溃，你知道有问题的行。

与控制台中的打印行不同，这也适用于频繁调用代码的情况，例如，如果您每秒钟更新 20 个不同的对象 100 次，您可以逐个注释掉它们，以找到导致崩溃的对象。就在最近，我用这种技术找到了我的游戏崩溃的原因，只有一个粗略的想法，在 100k 多行代码中查找。

# 记录

除了调试之外，你应该**总是**努力在你的代码中记录好错误。单独记录不会发现很多错误，但是它可以帮助缩小有问题的代码部分，类似于在控制台中打印代码行。然而，与控制台调试不同，日志记录可以在已经分发的程序中启用，这意味着它是帮助在用户 PC 上运行的程序中进行故障排除的唯一方法。

现代调试器已经变得非常强大，有助于解决程序中的大多数错误和崩溃。然而，在某些情况下，调试器不会产生任何有用的信息。问题可能出在第三方库中，您使用的是外部设备，或者您使用的语言没有很好的调试器。虽然适当的编程礼仪可能会轻视控制台中的打印行或注释掉代码，但这种方式可以更快、更容易地找到 bug，甚至是调试器不工作时的唯一方式。