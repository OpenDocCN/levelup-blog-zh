<html>
<head>
<title>Angular and RxJS Patterns — Use Reactive Programming to Compose and Manage Data in Angular Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular和RxJS模式—使用反应式编程在Angular应用程序中编写和管理数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-and-rxjs-patterns-use-reactive-programming-to-compose-and-manage-data-in-angular-apps-2e0c4ce7a39c?source=collection_archive---------0-----------------------#2019-10-21">https://levelup.gitconnected.com/angular-and-rxjs-patterns-use-reactive-programming-to-compose-and-manage-data-in-angular-apps-2e0c4ce7a39c?source=collection_archive---------0-----------------------#2019-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2f30" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">有角的</h2><div class=""/><div class=""><h2 id="bcca" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用RxJS构建可组合数据流、获取数据、处理用户交互和缓存API响应的指南</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/192eec284a28a1915de3d20fc89a8237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAsezdrRhcsFCCTfiLPUqg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@lexir703?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卫莱·鲁斯凯尔</a>在<a class="ae lh" href="https://unsplash.com/s/photos/coffee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a224" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Angular应用中，我们经常使用反应式编程，并且我们能够在不需要全局状态管理库的情况下开发应用。以下技术可以扩展到一般的真实使用案例:</p><ol class=""><li id="72fb" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/rxjs-subjects-explained-with-examples-78ae7b9edfc?source=friends_link&amp;sk=59c028b3e9fc6348f8faf54f1759701a">RxJS中的科目</a></li><li id="9420" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/communicate-between-angular-components-using-rxjs-7221e0468b2?source=friends_link&amp;sk=925501345e5562179adaff0700216fba">事件总线和可观察服务</a></li></ol><p id="0d05" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我将展示如何使用RxJS来处理以下情况:</p><ol class=""><li id="7dde" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">取数据</li><li id="812f" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">撰写数据</li><li id="0425" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">处理用户交互</li><li id="325a" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">缓存来自API请求的数据</li></ol><p id="bf4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，我将使用一个来自https://jsonplaceholder.typicode.com的虚拟API。</p><p id="a214" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ms">更多类似的内容，请查看</em><a class="ae lh" href="https://betterfullstack.com" rel="noopener ugc nofollow" target="_blank">https://betterfullstack.com</a></p><h1 id="9a0c" class="mt mu it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">取数据</h1><p id="68c8" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">在Angular中获取数据的方法有很多，但以下是最常用的方法:</p><ol class=""><li id="0424" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">创建一个业务服务，然后将其注入一个Angular容器组件，并订阅它以获取数据。然后将该数据赋给一个局部变量。</li><li id="a71e" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">在解析器上调用服务或在角度容器组件生命周期<code class="fe nq nr ns nt b">ngOnInit</code>中分派<code class="fe nq nr ns nt b">ACTION</code>，并通过使用原始数据或可观察数据将数据从全局状态映射到UI。</li></ol><p id="ed97" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这一部分，我将介绍另一种不使用<code class="fe nq nr ns nt b">subscribe</code>或状态管理从服务器获取数据的方法。</p><p id="f109" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我创建了一个简单的服务。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nu"><img src="../Images/d27ee5ee697a35e236b38f4907af1ba5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NldVuH_9c5Eso1iBhjXuSQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">获取用户列表的UsersService</figcaption></figure><p id="0c6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这项服务需要记住3点:</p><ol class=""><li id="f13e" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">我们可以在一个文件中定义一个URL，并将其导入到这个服务中。</li><li id="29e2" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">我们可以手动控制每个模块的导入，或者只需设置<code class="fe nq nr ns nt b">providedIn: 'root'</code>来进行全局设置。</li><li id="2f83" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">我们可以使用<code class="fe nq nr ns nt b">pipe</code>从这里转换数据。</li></ol><p id="146e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在将服务注入容器组件</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/0763a38588e68298efc88e4fefcceea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*AbpT0_VFOCmb4v3IxhjXmg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">在AppComponent上使用UsersService</figcaption></figure><p id="9f6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你看到发生在<code class="fe nq nr ns nt b">AppComponent</code>的怪事了吗？就是<code class="fe nq nr ns nt b">changeDetection: ChangeDetectionStrategy.OnPush</code>。</p><p id="6777" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是什么？</p><p id="df1f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用于此组件的更改检测策略。当组件被实例化时，Angular会创建一个变化检测器，负责传播组件的绑定。</p><p id="6177" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们有两种类型:</p><ul class=""><li id="86ec" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md nw mk ml mm bi translated"><code class="fe nq nr ns nt b">ChangeDetectionStrategy#OnPush</code>将策略设置为<code class="fe nq nr ns nt b">CheckOnce</code>(按需)。</li><li id="3832" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nw mk ml mm bi translated"><code class="fe nq nr ns nt b">ChangeDetectionStrategy#Default</code>将策略设置为<code class="fe nq nr ns nt b">CheckAlways</code>。</li></ul><p id="8cd7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使用<code class="fe nq nr ns nt b">OnPush</code>,因为它通过最小化变更检测周期来提高性能。</p><p id="c3e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用<code class="fe nq nr ns nt b">OnPush</code>，仅在以下情况下检查组件的变化:</p><ol class=""><li id="1b33" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated"><code class="fe nq nr ns nt b">@Input</code>属性发生变化。</li><li id="f558" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">发出一个事件</li><li id="e9ea" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">一个可观测的发射</li></ol><p id="aff4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后我们在模板中使用<code class="fe nq nr ns nt b">async</code>管道:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/645eedc1bb65288c701a48bd120230ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*i--o3b_oHgYT16ZX579PQA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">AppComponent模板</figcaption></figure><p id="a52a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意<code class="fe nq nr ns nt b">async</code>管道非常强大，因为它会在组件被销毁时自动删除订阅。</p><h1 id="1447" class="mt mu it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">撰写数据</h1><p id="ad0d" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">对于反应式编程的初学者来说，这个概念很奇怪。你可以认为这类似于在函数式编程中在React 或<code class="fe nq nr ns nt b">compose</code>中组合<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/understanding-react-higher-order-components-by-example-95e8c47c8006?source=friends_link&amp;sk=bca6849417321a91c7fa313962b41ad7">高阶组件。</a></p><p id="44fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将把两个流组合在一起获取数据。所以从<code class="fe nq nr ns nt b">/users</code>我有基本的用户信息，从<code class="fe nq nr ns nt b">/posts</code>我可以得到所有的帖子。然后根据<code class="fe nq nr ns nt b">userId</code>我可以确定作者的帖子。</p><p id="968f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将创建一个带有用户信息的响应，其属性为<code class="fe nq nr ns nt b">posts</code>，包含属于该特定用户的所有帖子。</p><p id="6c6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我创建一个<code class="fe nq nr ns nt b">PostsService</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ny"><img src="../Images/bfd4671f5ebd52bd1c51e916f98a34d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0BsPUTxh3slGfMmfaKKUg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">获取帖子数据的PostsService</figcaption></figure><p id="72eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我将这个服务注入到<code class="fe nq nr ns nt b">UsersService</code>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/d92e6fa017f9bda176f718cd948a98ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZTLvqaFm6jrSwTVolyOJKA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">将PostsService注入UsersService</figcaption></figure><p id="5cd6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以从上面的代码中看到，我使用<code class="fe nq nr ns nt b">combineLatest</code>将来自<code class="fe nq nr ns nt b">PostsService</code>的<code class="fe nq nr ns nt b">user$</code>和<code class="fe nq nr ns nt b">post$</code>组合在一起。然后我使用<code class="fe nq nr ns nt b">pipe</code>和<code class="fe nq nr ns nt b">map</code>将来自两个流的数据合并成一个。</p><p id="309a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我将拥有用户信息和一个<code class="fe nq nr ns nt b">posts</code>属性。</p><p id="8e16" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后我把它加到<code class="fe nq nr ns nt b">AppComponent</code>里。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/47e40dff63314e3bc7232e5ac4fd695f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*8USwngGcFhYfvyF0wF3mWA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">将userWithPost$添加到AppComponent</figcaption></figure><h1 id="f791" class="mt mu it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">处理用户交互</h1><p id="bdac" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">在这一节中，我将展示如何简单地通过在Angular中使用RxJS来处理用户交互。</p><p id="06e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是步骤:</p><ol class=""><li id="5325" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">创建一个动作流。</li><li id="99b6" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">组合动作和数据流。</li><li id="20cd" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">每次动作发生时发出一个值。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oa"><img src="../Images/8cfa112aa5f8cfd75d46201fba1c07a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-kXVVOTc1tLWO2EMC7MBA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">将操作流添加到UsersService</figcaption></figure><p id="7a1c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以使用<code class="fe nq nr ns nt b">Subject</code>或<code class="fe nq nr ns nt b">BehaviorSubject</code>来创建一个动作流。在代码示例中，我使用<code class="fe nq nr ns nt b">Subject</code>创建<code class="fe nq nr ns nt b">userSelectedAction</code>，并将其设置为<code class="fe nq nr ns nt b">private</code>。</p><p id="6919" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后我通过<code class="fe nq nr ns nt b">combineLatest</code>将动作流和数据流结合在一起，也就是<code class="fe nq nr ns nt b">selectedUser$</code>。</p><p id="d466" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我创建了一个名为<code class="fe nq nr ns nt b">changedSelectedUser(id)</code>的方法，在每次动作发生时发出新的用户ID。</p><p id="b75b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在您可以在<code class="fe nq nr ns nt b">AppComponent</code>上看到新的变化:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/7d468c8f5aeda7e36bab7da1806bbde5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*C_onYjRaZr8ouFufkaLU2A.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">AppComponent的新更新</figcaption></figure><p id="5421" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里有一个演示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ob"><img src="../Images/77f7eb8e0b66204c7c8be27cbd6e3646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aRNpUBHTmIvxoPq4aHkF3w.gif"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">rxjs演示处理用户点击</figcaption></figure><h1 id="06b5" class="mt mu it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">缓存来自API请求的数据</h1><p id="74fe" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">在这一节中，我将演示一种从API缓存数据的简单方法。</p><p id="de47" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我见过的许多开发人员用来缓存数据的模式。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/5148fb8fc96c2964f57cb1134fbf4120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*8ZxhOJJPUjbdWO_QocWoZg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">将数据存储在公共变量中</figcaption></figure><p id="3feb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这有一个问题，我们会在流中失去。</p><p id="cb32" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我更喜欢使用<code class="fe nq nr ns nt b">shareReplay()</code>:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b6887b5786064e50e61de95a8ee6b47a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*6j1ZmoFM9aRlXNChb4gpZw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用shareReplay进行缓存</figcaption></figure><p id="437c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我使用<code class="fe nq nr ns nt b">shareReplay</code>有三个原因:</p><ol class=""><li id="cfba" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">它与所有订户共享一个可观测值。</li><li id="634b" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">它在订阅时重放指定数量的条目。</li><li id="865f" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">即使当前没有订户，它也会保持活动状态。</li></ol><p id="8e4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，当您有副作用或者您不希望在多个订户之间执行的昂贵计算时，您通常希望使用<code class="fe nq nr ns nt b">shareReplay</code>。</p><h1 id="aafb" class="mt mu it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">摘要</h1><p id="0f14" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">总而言之，在Angular中我们可以应用RxJS做几乎所有的事情，这些反应式编程技术可以让你的应用更简单。</p><p id="4d21" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以在没有<code class="fe nq nr ns nt b">subscribe</code>的情况下获取数据，生成可组合的流，创建一种有效的方式来处理用户动作，并无缝地缓存我们的API响应数据。</p><p id="9d4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们还了解到，我们可以使用<code class="fe nq nr ns nt b">OnPush</code>来提升应用程序的性能。</p><p id="2410" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这篇文章对你有用！可以跟着我上<a class="ae lh" href="https://medium.com/@transonhoang" rel="noopener">媒</a>。我也在推特上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><p id="2d20" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">点击此处查看源代码示例:</p><div class="od oe gp gr of og"><a href="https://stackblitz.com/edit/data-composition?embed=1&amp;file=src/app/services/users.service.ts" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jd gy z fp ol fr fs om fu fw jc bi translated">数据合成堆栈</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">导出到Angular CLI的Angular应用程序的启动项目</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">stackblitz.com</p></div></div><div class="op l"><div class="oq l or os ot op ou lb og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://betterfullstack.com/stories/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd jd gy z fp ol fr fs om fu fw jc bi translated">故事-更好的全栈</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">关于JavaScript、Python和Wordpress的有用文章，有助于开发人员减少开发时间并提高…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">betterfullstack.com</p></div></div><div class="op l"><div class="ov l or os ot op ou lb og"/></div></div></a></div></div></div>    
</body>
</html>