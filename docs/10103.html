<html>
<head>
<title>9 Coding Guidelines to follow in JavaScript | Better JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript |更好的JavaScript应遵循的9条编码准则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/9-coding-guidelines-you-should-follow-in-javascript-better-javascript-6a6c84353d82?source=collection_archive---------12-----------------------#2021-10-26">https://levelup.gitconnected.com/9-coding-guidelines-you-should-follow-in-javascript-better-javascript-6a6c84353d82?source=collection_archive---------12-----------------------#2021-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f6e480e279b6964b207c419b9dc2c9b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bmfL12C9GcxAeUJe"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@jeshoots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><div class=""/><p id="4e95" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript世界中有很多可用的工具和插件。你可能以前听说过多重编码指南或林挺规则。在这篇文章中，我列出了一些我个人最喜欢的，并附有适当的代码解释。这些编码指南将帮助您的应用程序在JavaScript代码中更具可伸缩性和可维护性。</p><h2 id="d545" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">主题:</h2><ol class=""><li id="eee6" class="lx ly jj ki b kj lz kn ma kr mb kv mc kz md ld me mf mg mh bi translated">使用<code class="fe mi mj mk ml b">enum</code></li><li id="e699" class="lx ly jj ki b kj mm kn mn kr mo kv mp kz mq ld me mf mg mh bi translated">使用可选的链接/Elvis运算符</li><li id="0df7" class="lx ly jj ki b kj mm kn mn kr mo kv mp kz mq ld me mf mg mh bi translated">对象速记的使用</li><li id="670b" class="lx ly jj ki b kj mm kn mn kr mo kv mp kz mq ld me mf mg mh bi translated">hasOwnProperty的使用</li><li id="8457" class="lx ly jj ki b kj mm kn mn kr mo kv mp kz mq ld me mf mg mh bi translated">扩展运算符的使用</li><li id="4e6d" class="lx ly jj ki b kj mm kn mn kr mo kv mp kz mq ld me mf mg mh bi translated">使用来自的<strong class="ki jk">数组</strong></li><li id="31f3" class="lx ly jj ki b kj mm kn mn kr mo kv mp kz mq ld me mf mg mh bi translated">使用析构来提取值</li><li id="60bb" class="lx ly jj ki b kj mm kn mn kr mo kv mp kz mq ld me mf mg mh bi translated">使用“of”和“in”运算符迭代对象</li><li id="b8e6" class="lx ly jj ki b kj mm kn mn kr mo kv mp kz mq ld me mf mg mh bi translated">可选参数的使用</li></ol><h2 id="3e8e" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated"><strong class="ak">使用枚举</strong></h2><p id="5f0f" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">你可能没听说过什么神奇的数字。它说我们不应该创造随机数，没有有意义的名字的字符串。</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="71d8" class="le lf jj ml b gy nc nd l ne nf">// TypeScript Sample</span><span id="da83" class="le lf jj ml b gy ng nd l ne nf">enum HTTP_RESPONSE_STATUS {<br/>  OK = 200,<br/>  CREATED,<br/>  MOVED = 301,<br/>  BAD_REQUEST = 400,<br/>  UNAUTHORIZED,<br/>  FORBIDDEN = 403,<br/>}</span><span id="2cbd" class="le lf jj ml b gy ng nd l ne nf">console.log(HTTP_RESPONSE_STATUS);</span><span id="9775" class="le lf jj ml b gy ng nd l ne nf">/**<br/> * <br/>{<br/>  '200': 'OK',<br/>  '201': 'CREATED',<br/>  '301': 'MOVED',<br/>  '400': 'BAD_REQUEST',<br/>  '401': 'UNAUTHORIZED',<br/>  '403': 'FORBIDDEN',<br/>  OK: 200,<br/>  CREATED: 201,<br/>  MOVED: 301,<br/>  BAD_REQUEST: 400,<br/>  UNAUTHORIZED: 401,<br/>  FORBIDDEN: 403<br/>}<br/>*/</span><span id="0942" class="le lf jj ml b gy ng nd l ne nf">export const createUsers = async (user) =&gt; {<br/>  try {<br/>    const newUser = await db.createUser(user);<br/>    return { data: newUser, status: HTTP_RESPONSE_STATUS.OK };<br/>  } catch (error) {<br/>    return { error: error.message, status: HTTP_RESPONSE_STATUS.BAD_REQUEST };<br/>  }<br/>};</span></pre><p id="d55f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的例子是用TypeScript写的。<strong class="ki jk">“枚举”</strong>是TypeScript的一级成员。但是，<code class="fe mi mj mk ml b">enum</code>在<strong class="ki jk">普通JavaScript </strong>中是没有的。您可以使用键值对象来实现相同的功能。</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="38cd" class="le lf jj ml b gy nc nd l ne nf">const HTTP_RESPONSE_STATUS = Object.entries({<br/>  OK: 200,<br/>  CREATED: 201,<br/>  MOVED: 301,<br/>  BAD_REQUEST: 400,<br/>  UNAUTHORIZED: 401,<br/>  FORBIDDEN: 403,<br/>}).reduce((m, [key, value]) =&gt; {<br/>  m[key] = value;<br/>  m[value] = key;<br/>  return m;<br/>}, {});</span><span id="8d39" class="le lf jj ml b gy ng nd l ne nf">console.log(HTTP_RESPONSE_STATUS);<br/></span></pre><p id="6b72" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能还注意到我们有交叉值和键的对象。也就是说，对于每个<strong class="ki jk">键-值</strong>，都有一个值-键映射。这是值-键映射，对交叉引用检查很有用。</p><p id="d4c3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nh">你可以在</em><a class="ae jg" href="https://medium.com/swlh/implement-enum-in-vanilla-javascript-using-proxy-class-391edd1dd608" rel="noopener"><em class="nh">implement-enum-in-vanilla-JavaScript-using-proxy-class</em></a><em class="nh">中阅读更多关于enum实现的内容。</em></p><h2 id="c919" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated"><strong class="ak">使用可选的链接/Elvis操作符</strong></h2><p id="dda3" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">猫王运营商被定义为<code class="fe mi mj mk ml b"><strong class="ki jk">?.</strong></code>。Elvis运算符对于在属性链的深层读取属性值非常有用。</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="aa46" class="le lf jj ml b gy nc nd l ne nf">const user = {<br/>  name: "Deepak",<br/>  address: {<br/>    street: "30 Lorem Address",<br/>    pin: 67090,<br/>  },<br/>  fullAddress() {<br/>    return `${this.address.street}, ${this.address.pin}`;<br/>  },<br/>};</span><span id="0295" class="le lf jj ml b gy ng nd l ne nf">// Case 1: Extract Property<br/>console.log(user?.address?.street);<br/>/// 30 Lorem Address</span><span id="711c" class="le lf jj ml b gy ng nd l ne nf">// Case 2: Extract Property and call function<br/>console.log(user.fullAddress?.());<br/>// 30 Lorem Address, 67090</span></pre><p id="cec5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在案例1中，您从<strong class="ki jk">地址</strong>中提取<strong class="ki jk">街道</strong>属性。如果没有定义prop地址，首先会返回<code class="fe mi mj mk ml b"><strong class="ki jk">undefined</strong></code>。否则它将导航并获取<strong class="ki jk">地址</strong>中<strong class="ki jk">街道</strong>的值。</p><p id="d6b1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在例2中，还可以寻找函数<code class="fe mi mj mk ml b">user.fullAddress<strong class="ki jk">?.()</strong></code>的属性并在验证后调用。</p><p id="e5c4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">真实生活用例</strong>:在SSR(服务器端渲染)中从navigator安全地获取语言</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="d6b4" class="le lf jj ml b gy nc nd l ne nf">const currentLanguage = window?.navigator?.language</span></pre><h2 id="f7ff" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated"><strong class="ak">使用物体速记</strong></h2><p id="09c4" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated"><strong class="ki jk"> ES6 </strong>引入了许多漂亮清晰的语法，与<strong class="ki jk">类</strong>和<strong class="ki jk">对象</strong>一起工作。如果您使用过ES6类语法和函数，您可以对对象使用相同的类函数符号。<em class="nh">查看以下示例。</em></p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="f437" class="le lf jj ml b gy nc nd l ne nf">// Bag<br/>const lukeSkywalker = "Luke Skywalker";<br/>const atom = {<br/>  value: 1,<br/>  lukeSkywalker: lukeSkywalker, <strong class="ml jk">// Too verbose</strong><br/>  addValue: function (value) {<br/>    return atom.value + value;<br/>  },<br/>};</span></pre><p id="7eb1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的例子可以写成</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="cd74" class="le lf jj ml b gy nc nd l ne nf">// Good <br/>const atom = {<br/>  value: 1,<br/>  lukeSkywalker, <strong class="ml jk">// Short hand for Property</strong><br/>  addValue(value) { <strong class="ml jk">// Short hand for function</strong><br/>    return atom.value + value;<br/>  },<br/>};</span></pre><p id="9bea" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">速记使得用值给对象分配属性变得容易得多。而且有了<code class="fe mi mj mk ml b">()</code>语法，就不需要显式定义函数关键字了。</p><h2 id="2613" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">hasOwnProperty的使用</h2><p id="b6f4" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">您可能已经在对象的键迭代中看到了对<strong class="ki jk"> hasOwnProperty </strong>的检查。基本上，每当我们对所有属性进行循环时，我们都希望确保不包含一些原型属性。为此，我们可以在对象上使用<strong class="ki jk"> hasOwnProperty </strong>方法。</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="998b" class="le lf jj ml b gy nc nd l ne nf">class A {<br/>  constructor() {<br/>    this.a = "A";<br/>  }<br/>}<br/>A.prototype.c = "c";</span><span id="e065" class="le lf jj ml b gy ng nd l ne nf">class B extends A {<br/>  constructor() {<br/>    super();<br/>    this.b = "B";<br/>  }<br/>}<br/>const b = new B();</span><span id="a600" class="le lf jj ml b gy ng nd l ne nf">for (let key in b) {<br/>  if (b.hasOwnProperty(key)) {<br/>    console.log("hasOwnProperty: ", key);<br/>  } else {<br/>    console.log("hasOwnProperty: != ", key);<br/>  }<br/>}<br/>// hasOwnProperty:  a<br/>// hasOwnProperty:  b<br/>// hasOwnProperty: !=  c</span></pre><p id="6810" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，属性<strong class="ki jk">【a】</strong><strong class="ki jk">b】</strong>直接和间接地附加到对象be上。然而，属性<strong class="ki jk">“c”</strong>可以使用原型成员访问。然而，根据经验，您不应该使用<code class="fe mi mj mk ml b">for-in </code>循环遍历类属性。</p><p id="b87f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在<strong class="ki jk"> </strong> <a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" rel="noopener ugc nofollow" target="_blank">对象/hasOwnProperty </a>中阅读更多关于<strong class="ki jk"> hasOwnProperty </strong>的内容。</p><h2 id="ec0c" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">扩展运算符的使用</h2><p id="a664" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">要使一个<strong class="ki jk">对象</strong>或<strong class="ki jk">数组</strong>变浅，可以使用一个扩展操作符<code class="fe mi mj mk ml b">…</code>。您也可以使用<strong class="ki jk"> Object.assign </strong>来复制对象。但是，<strong class="ki jk"> Object.assign </strong>更容易出错，应该只在想要修改实际对象的时候使用。</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="3b7f" class="le lf jj ml b gy nc nd l ne nf">// good<br/>const original = { a: 1, b: 2 };<br/>const original2 = { c: 3, d: 4 };</span><span id="8048" class="le lf jj ml b gy ng nd l ne nf">const copy = { ...original, c: 3 }; <br/>// copy =&gt; { a: 1, b: 2, c: 3 }</span><span id="41eb" class="le lf jj ml b gy ng nd l ne nf">const mergedObject = { ...original, ...original2 }; <br/>// { a: 1, b: 2, c: 3, d: 4 }</span><span id="137b" class="le lf jj ml b gy ng nd l ne nf">const { a, ...noA } = copy; // noA =&gt; { b: 2, c: 3 }</span><span id="960e" class="le lf jj ml b gy ng nd l ne nf">const originalArray = [1, 2, 3];<br/>const originalArray2 = [4, 5, 6];<br/>const copyArray = [...originalArray, 4]; // [1,2,3,4]</span><span id="d0bd" class="le lf jj ml b gy ng nd l ne nf">const without1 = originalArray.slice(1); //[2,3,4]</span><span id="8724" class="le lf jj ml b gy ng nd l ne nf">const mergedArray = [...originalArray, ...originalArray2]; ///[1,2,3,4,5,6]</span></pre><p id="00ae" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似的想法，但一个糟糕的代码。</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="02bb" class="le lf jj ml b gy nc nd l ne nf">const original = { a: 1, b: 2 };<br/>const copy = Object.assign(original, { c: 3 }); // this mutates `original` ಠ_ಠ<br/>delete copy.a; // so does this</span></pre><p id="cd35" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在这里阅读更多关于<a class="ae jg" href="https://airbnb.io/javascript/#objects--rest-spread" rel="noopener ugc nofollow" target="_blank">物体-休息-传播</a>的内容。</p><h2 id="6751" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">使用Array.from</h2><p id="6e30" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated"><strong class="ki jk"> Array.from </strong>是利用不足的方法之一。使用Array.from可以将任何看起来像数组的东西转换成实际的数组。</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="964a" class="le lf jj ml b gy nc nd l ne nf">const numbers = [1, 2, 3, 4];<br/>const squares = [...numbers].map((num) =&gt; num * num);<br/>console.log(squares); // [ 1, 4, 9, 16 ]</span><span id="9d79" class="le lf jj ml b gy ng nd l ne nf">const squares2 = Array.from(numbers, (num) =&gt; num * num);<br/>console.log(squares2); // [ 1, 4, 9, 16 ]</span></pre><p id="ef1e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，您可以看到您可以使用spread operator和map从给定的数字列表中创建一个新的数组。映射函数有助于创建操作返回数据。你可以用的<strong class="ki jk">数组做同样的事情。<strong class="ki jk"> Array.from </strong>将映射函数作为第二个参数。</strong></p><p id="dfbd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> Array.from </strong>也有助于将一个看起来像数组的元素转换成数组。然而，如果你没有映射器的用例。建议使用spread运算符而不是Array.from。</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="0a15" class="le lf jj ml b gy nc nd l ne nf">const foo = document.querySelectorAll('.foo');</span><span id="45b9" class="le lf jj ml b gy ng nd l ne nf">// good<br/>const nodes = Array.from(foo);</span><span id="54f1" class="le lf jj ml b gy ng nd l ne nf">// best<br/>const nodes = [...foo];</span></pre><h2 id="3b73" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">使用析构来提取值</h2><p id="0e6c" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">spread运算符用于创建元素的副本。析构是用来打破一个对象(或数组)。</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="f090" class="le lf jj ml b gy nc nd l ne nf">const directions = [<br/>  [-1, 0],<br/>  [0, 1],<br/>  [1, 0],<br/>  [0, -1],<br/>];</span><span id="5eb2" class="le lf jj ml b gy ng nd l ne nf">const getNighbours = (i, j) =&gt; {<br/>  const [up, right, down, left] = directions;<br/>  console.log(up, right, down, left);<br/>  /// [ -1, 0 ] [ 0, 1 ] [ 1, 0 ] [ 0, -1 ]<br/>};</span></pre><p id="841e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你正在处理一个图形问题，你可以很容易地创建一个每个相邻点的数组，并且可以使用数组的析构来访问。析构对于从函数中返回元组作为值也很有用。</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="88cd" class="le lf jj ml b gy nc nd l ne nf">const getMaxValue = (array) =&gt; {<br/>  let [index, max] = [-1, -Infinity];<br/>  for (let i in array) {<br/>    if (array[i] &gt; max) {<br/>      index = i;<br/>      max = array[i];<br/>    }<br/>  }<br/>  return [max, index];<br/>};</span><span id="f910" class="le lf jj ml b gy ng nd l ne nf">const [max, i] = getMaxValue([1, 3, 5, 2, 7]);</span><span id="91be" class="le lf jj ml b gy ng nd l ne nf">console.log(max, i); // 7 4</span></pre><p id="a3a8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">析构对于访问对象的属性值也很有用。您可以从对象的属性创建变量/常量。</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="ee98" class="le lf jj ml b gy nc nd l ne nf">const MyReactComponents = ({ name, onSubmit }) =&gt; {<br/>  console.log(name);<br/>  onSubmit("On callback function");<br/>};</span><span id="b617" class="le lf jj ml b gy ng nd l ne nf">MyReactComponents({ name: "Deepak", onSubmit: console.log });</span><span id="7753" class="le lf jj ml b gy ng nd l ne nf">// Deepak<br/>// On callback function</span></pre><p id="76fe" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">注意:</strong> <em class="nh">同样不建议使用数组重组返回3个以上的参数。</em>如果你想阅读更多关于<a class="ae jg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构_赋值</a>的内容，请点击链接。</p><h2 id="0f6f" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated"><strong class="ak">使用“of”和“in”运算符迭代对象</strong></h2><p id="5a88" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">你应该总是使用高阶函数迭代器和数组。然而，使用高阶函数打破循环/提前返回是一项繁琐的任务。万一，你只是在处理值。可以使用<code class="fe mi mj mk ml b"><strong class="ki jk">for-of</strong></code> <strong class="ki jk"> </strong>循环<strong class="ki jk">。</strong></p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="bc28" class="le lf jj ml b gy nc nd l ne nf">const contains = (array, num) =&gt; {<br/>  for (let value of array) {<br/>    if (value === num) return true;<br/>  }<br/>  return false;<br/>};</span><span id="c5ad" class="le lf jj ml b gy ng nd l ne nf">console.log(contains([1, 2, 3, 4], 5)); // false</span></pre><p id="22c9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类似地，您可以使用<code class="fe mi mj mk ml b">for-in</code>循环迭代所有键。</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="cfcd" class="le lf jj ml b gy nc nd l ne nf">const contains = (object, num) =&gt; {<br/>  for (let key in object) {<br/>    if (object[key] === num) return true;<br/>  }<br/>  return false;<br/>};</span><span id="d752" class="le lf jj ml b gy ng nd l ne nf">console.log(contains({ a: 1, b: 2 }, 2)); // true</span></pre><p id="2c4e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你对循环更感兴趣。你可以阅读我的文章<a class="ae jg" href="https://javascript.plainenglish.io/weird-part-how-to-break-the-loop-in-javascript-8bba3e658267" rel="noopener ugc nofollow" target="_blank">如何在javascript中打破循环</a>。</p><h2 id="61b7" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">可选参数的使用</h2><p id="abd7" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">使用ES6，您可以为给定函数的可选参数定义默认值。这对JavaScript中的<code class="fe mi mj mk ml b">function overload</code>非常有用。</p><pre class="mu mv mw mx gt my ml mz na aw nb bi"><span id="4535" class="le lf jj ml b gy nc nd l ne nf">const request = (url, options = { method: "GET" }) =&gt; {<br/>  return fetch(url, options);<br/>};</span><span id="cac8" class="le lf jj ml b gy ng nd l ne nf">console.log(request("test.com")); //get request<br/>console.log(request("test.com", { method: "POST" })); //get request</span></pre><p id="6b52" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">注意:</strong>所有可选参数都应该在结束参数处定义。可能有一个以上的可选参数。</p><h2 id="2b1c" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">结论</h2><p id="f8c1" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated"><em class="nh">很难在一篇文章中涵盖所有的编码指南。我想在接下来的文章中讨论一些其他更好的编写代码的方法。</em></p><h2 id="ee15" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">参考资料:</h2><p id="7363" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated"><a class="ae jg" href="https://airbnb.io/javascript/#arrays--from" rel="noopener ugc nofollow" target="_blank">https://airbnb.io/javascript/</a></p><p id="73e0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae jg" href="https://developer.mozilla.org/en-US/" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/</a></p><p id="2284" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae jg" href="https://google.github.io/styleguide/jsguide.html" rel="noopener ugc nofollow" target="_blank">https://google.github.io/styleguide/jsguide.html</a></p></div></div>    
</body>
</html>