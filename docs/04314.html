<html>
<head>
<title>Getting started with Puppeteer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">木偶师入门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-started-with-puppeteer-24fc44f0a637?source=collection_archive---------3-----------------------#2020-06-20">https://levelup.gitconnected.com/getting-started-with-puppeteer-24fc44f0a637?source=collection_archive---------3-----------------------#2020-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8507007b41e2656163edf2739b0abdb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWYm3Dm7s0t8lLWYRW4pow.jpeg"/></div></div></figure><p id="69ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">木偶师可能是目前最有名的无头浏览器自动化库。它提供了一个高级Node.js API，允许您启动Chrome或Chrome浏览器实例并向其发送命令。事实证明，它易于安装，使用简单，性能良好。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/aa0916b26da227931066445f6952f5eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7H-A0hquCEuyLG08.png"/></div></div></figure><h1 id="29cd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一些背景故事📖</h1><p id="d4a2" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">木偶师的工作方式是在<a class="ae me" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank"> DevTools协议</a>之上提供一个薄薄的层。</p><p id="cf76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">DevTools协议赋予你在浏览器的“检查元素”工具栏中做所有酷事情的能力。实际上这个协议和大多数基于眨眼的浏览器<em class="mf"> (Chrome，Chromium等)是一样的。)</em>提供用于DOM检查、网络剖析、调试和所有其他我们可以使用的酷功能的工具。<br/> <em class="mf">在《木偶师》中，你可以做几乎任何你能在实际浏览器中做的事情，不包括黑客。</em></p><p id="071b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">木偶师属于谷歌Chrome旗下，具体由Chrome DevTools团队维护。这个事实本身就应该让你对项目的长期可持续性有一些信心。此外，它保证与Chromium/Chrome浏览器中的最新功能保持同步。你通常不必等待一个特性被移植到库中。</p><p id="b12b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们开始吧！👷</p><h1 id="fedc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">去图书馆</h1><p id="15d3" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">最初确保你在一台安装了Node.js &gt; =v10.18.1的机器上，这样我们就可以使用最新的木偶版本。</p><p id="31b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个名为<strong class="ka ir">木偶师-示例</strong>的新项目文件夹，这样我们就可以开始整个过程了。</p><pre class="kx ky kz la gt mg mh mi mj aw mk bi"><span id="65bb" class="ml lc iq mh b gy mm mn l mo mp">mkdir puppeteer-example<br/>  cd puppeteer-example</span></pre><p id="1ef3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以开始引导所需的Node.js设置。</p><pre class="kx ky kz la gt mg mh mi mj aw mk bi"><span id="a8cf" class="ml lc iq mh b gy mm mn l mo mp">npm init -y</span></pre><p id="d257" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样你就可以安装你喜欢的库了，比如<a class="ae me" href="https://www.npmjs.com/package/left-pad" rel="noopener ugc nofollow" target="_blank">左键盘</a>或者<a class="ae me" href="https://www.npmjs.com/package/browser-redirect" rel="noopener ugc nofollow" target="_blank">浏览器重定向</a>，但是你现在可以跳过它😂。回到我们的目标:</p><pre class="kx ky kz la gt mg mh mi mj aw mk bi"><span id="6156" class="ml lc iq mh b gy mm mn l mo mp">npm install puppeteer@3</span></pre><p id="6087" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在安装库的时候，你可能会在你的控制台上看到一条消息，说<em class="mf">正在下载Chromium xxx </em>。这条消息是为了让您知道，通过puppet er库，还下载了针对您的操作系统的特定版本的Chromium(在node_modules 中的<em class="mf">),供您的puppet er安装使用。原因是每一个木偶版本<strong class="ka ir">只能保证</strong>与捆绑的特定Chromium版本一起工作。特别提示:如果您的磁盘空间有限，那么在您完成之后，从您的测试或未使用的木偶项目中删除node_modules目录。</em></p><h1 id="3c41" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">初次相遇🤞</h1><p id="2aff" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我们完成了安装，现在可以开始写代码了。您可能会惊讶于几行代码能做多少事情。</p><p id="725d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的第一个任务，我们将尝试探索官方木偶网站https://pptr.dev/<a class="ae me" href="https://pptr.dev/" rel="noopener ugc nofollow" target="_blank"/>。<br/>创建一个测试文件<code class="fe mq mr ms mh b">index.js</code>，内容如下:</p><pre class="kx ky kz la gt mg mh mi mj aw mk bi"><span id="eb88" class="ml lc iq mh b gy mm mn l mo mp">const puppeteer = require("puppeteer");</span><span id="fd5b" class="ml lc iq mh b gy mt mn l mo mp">(async function () {<br/>  const browser = await puppeteer.launch({ headless: false }); // We use this option to go into non-headless mode<br/>  const page = await browser.newPage(); // Create a new page instance<br/>  await page.goto("https://pptr.dev"); // Navigate to the pptr.dev website</span><span id="964c" class="ml lc iq mh b gy mt mn l mo mp">  await page.waitFor(5000); // Wait for 5 seconds to see the beautiful site<br/>  await browser.close(); // Close the browser<br/>})();</span></pre><p id="779b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，通过使用<code class="fe mq mr ms mh b">node test.js</code>运行这段代码，您将看到Chromium实例启动并导航到pptr.dev网站5秒钟，然后关闭。</p><p id="8a36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我确信，对于web自动化爱好者来说，这是一个舒适的地方。唯一缺少的组件是您需要运行的场景，以及对Puppeteer宣传的直观而简单的API的感受。</p><p id="502a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么不看一看呢？</p><h1 id="4694" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">探索一个简单的场景🕵</h1><p id="e6a2" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">跳过客套话，我们的目标是探索pptr.dev网站为我们提供的自动完成搜索功能。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/edc69ba586c466633e0ca99a180facde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g4PCZc5eFwePQuHt.png"/></div></div></figure><h1 id="3e0c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">大声思考</h1><p id="e91e" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">所以让我们开始描述一个<em class="mf">实际用户</em>需要做什么来获得这个自动完成特性以达到它的目的。</p><p id="d99b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们期望用户:<br/> <strong class="ka ir"> 1。</strong>打开<br/>页面<strong class="ka ir"> 2。</strong>尝试查找自动完成搜索<br/> <strong class="ka ir"> 3。</strong>为他正在寻找的API方法键入他的查询<br/> 4。点击列表中最相关的结果<br/>5。期待看到他选择的商品的部分</p><p id="0b1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了测试木偶师API是否像它声称的那样直观，我们可以继续将这种想法转化为木偶师命令。</p><pre class="kx ky kz la gt mg mh mi mj aw mk bi"><span id="facb" class="ml lc iq mh b gy mm mn l mo mp">/* Somewhere else... */<br/>const Homepage = {<br/>  autocompleteSearchInput: "input[type='search']",<br/>};<br/>const apiSearchTerm = "metrics"; // The API method we are looking for<br/>/* ... */</span><span id="2e95" class="ml lc iq mh b gy mt mn l mo mp">await page.goto("https://pptr.dev");<br/>await page.waitForSelector(Homepage.autocompleteSearchInput);<br/>await page.type(Homepage.autocompleteSearchInput, apiSearchTerm);<br/>await page.click("search-item");</span><span id="3f9c" class="ml lc iq mh b gy mt mn l mo mp">// Find the API name using XPath<br/>const $apiMethod = await page.$x(<br/>  "//api-method-name[text()='" + apiSearchTerm + "']"<br/>)[0];</span><span id="0eb0" class="ml lc iq mh b gy mt mn l mo mp">// Check if this method name section is actually visible on the viewport<br/>const isApiMethodVisible = await $apiMethod.isIntersectingViewport();</span><span id="df09" class="ml lc iq mh b gy mt mn l mo mp">assert.equal(isApiMethodVisible, true);</span></pre><p id="6d02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，就这样了！🎉上面的代码，也包含一些内务处理，在我看来，基于我们设计的思考过程，看起来相当简单，我甚至不认为我需要解释大多数命令的作用。该API成功地翻译成清晰的语言，而不依赖于其他外部抽象。</p><p id="3016" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以考虑的一点是用于检测我们正在寻找的API方法是否确实在浏览器视窗中的命令组合。在这个领域有经验的人知道，要断言这个事实，你要么创建你自己的定制命令(<em class="mf">进行视口尺寸计算</em>)要么依赖一个已经为我们实现的框架命令。</p><p id="19d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与众不同的是，我们直接从木偶师那里得到的命令被认为是最可靠的，因为它是由平台本身提供的。</p><h1 id="86a2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">少了一两件东西🙈</h1><p id="17a8" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">在我们都同意API相当直观且易于使用之后，我们可以回顾并提及一些在使我们的开发体验变得更好方面似乎“缺失”的东西。</p><h2 id="0e1c" class="ml lc iq bd ld mv mw dn lh mx my dp ll kj mz na lp kn nb nc lt kr nd ne lx nf bi translated">1)用关键字<code class="fe mq mr ms mh b">async</code>填充你的代码</h2><p id="45bd" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">正如你肯定观察到的，有这个<em class="mf"> async </em>关键字，你必须把它撒在你的代码中，至少对我来说感觉有点吵。这个关键字是必需的，因为浏览器API具有事件驱动的特性。用JavaScript围绕异步和事件驱动平台编码的方法是使用<a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>来建模你的操作，而Puppeteer已经做到了这一点。</p><p id="5321" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了减轻处理这些异步操作的痛苦，JavaScript在语言语法中添加了一些新的关键字。这些关键字是你在我们的代码上看到的<a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">异步&amp;等待</a>。因为Puppeteer的API需要使用承诺，所以我们编写代码的最佳方式是对大多数命令使用这种<em class="mf"> async/await </em>语法。</p><h2 id="fee5" class="ml lc iq bd ld mv mw dn lh mx my dp ll kj mz na lp kn nb nc lt kr nd ne lx nf bi translated">2)尚无可用的链接</h2><p id="01cb" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">由于一些设计决策和库的性质，正如我们在上面提到的，目前还不支持我们所谓的<em class="mf">方法链接</em>。有了这种能力，我们的代码阅读起来会更加流畅。想象一下:</p><pre class="kx ky kz la gt mg mh mi mj aw mk bi"><span id="0ad0" class="ml lc iq mh b gy mm mn l mo mp">await page.$("input[type='search']").click().type("metrics").submit();</span></pre><p id="13ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不能保证，但我认为有一些第三方库解决方案可以尝试。如果你想了解一下状态和可能的外部解决方案，你可以从查看一个相关的GitHub <a class="ae me" href="https://github.com/puppeteer/puppeteer/issues/928" rel="noopener ugc nofollow" target="_blank">问题</a>开始。</p><h1 id="7c6c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关闭</h1><p id="c863" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">您刚刚快速地了解了如何设置Puppeteer并为自动完成搜索编写了一个简单的场景。从现在开始，你只能靠你自己了，除了所有将出现在Web自动化之家的菜谱。</p><p id="bbc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的建议是开始在你自己的用例上做实验，作为睡前故事，在GitHub上浏览详细的API文档。几乎可以肯定的是，您会发现一些意想不到的事情。</p><p id="06e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mf">十字贴来自</em><a class="ae me" href="https://www.thehomeofwebautomation.com/getting-started-puppeteer/" rel="noopener ugc nofollow" target="_blank"><em class="mf">Web自动化之家</em> </a></p><p id="39cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mf">照片来自</em> <a class="ae me" href="https://www.pexels.com/el-gr/@kevin-ku-92347?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <em class="mf">凯文·Ku</em></a><em class="mf">at</em><a class="ae me" href="https://www.pexels.com/el-gr/photo/ai-macro-577585/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"><em class="mf">Pexels</em></a></p></div></div>    
</body>
</html>