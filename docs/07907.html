<html>
<head>
<title>Set up a project using Express, Graphql, and Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express、Graphql和Typescript设置项目</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/set-up-a-project-using-express-graphql-and-typescript-1fa38ee79886?source=collection_archive---------0-----------------------#2021-03-21">https://levelup.gitconnected.com/set-up-a-project-using-express-graphql-and-typescript-1fa38ee79886?source=collection_archive---------0-----------------------#2021-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e4f7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用Express、Graphql (Apollo server)、Typescript、Codegen和Graphql文件设置后端</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/81113263b362d5cf1f140c4289cc3edd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFe2abfw2mq9mggrPURtwA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片来自<a class="ae ky" href="https://www.pexels.com/photo/turned-on-silver-imac-with-might-mouse-and-keyboard-930530/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a></figcaption></figure><h1 id="abe3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">工具</h1><p id="9234" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们回顾一下我们将要使用的工具以及我们为什么要使用它们。当然，如果你只是对设置项目感兴趣，你可以直接向下滚动到练习！</p><h2 id="d0fd" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">阿波罗服务器</h2><p id="08a0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Apollo是一个开源的Graphql组织，为客户机和服务器开发Javascript Graphql库。阿波罗服务器是它的服务器端。它支持完整的Graphql实现。在本文中，我们将使用<code class="fe mz na nb nc b">apollo-server-express</code>，它是Apollo的一个版本，可以嵌入到Express服务器中。这样选择的原因是，如果您想在不使用Graphql的情况下添加更多的API端点，您可能需要一个Express服务器。</p><h2 id="c64f" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">Codegen</h2><p id="ae0e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您将graphql与Typescript一起使用，Codegen是您需要的工具。Codegen将扫描您的graphql文件，并生成一个包含您的解析器所需的所有类型的Typescript文件！</p><p id="81f5" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">我不打算列举像Express或Typescript这样的工具。他们已经足够出名了！</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="a01c" class="kz la it bd lb lc np le lf lg nq li lj jz nr ka ll kc ns kd ln kf nt kg lp lq bi translated">我们开始吧</h1><p id="02c9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，让我们通过简单地运行<code class="fe mz na nb nc b">npm init -y</code>来建立一个新项目</p><p id="f353" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">然后安装typescript，并通过执行以下操作初始化您的typescript项目</p><p id="2bac" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated"><code class="fe mz na nb nc b">npm install -D typescript &amp;&amp; tsc --init</code></p><blockquote class="nu nv nw"><p id="b3f4" class="lr ls nx lt b lu nd ju lw lx ne jx lz ny nf mc md nz ng mg mh oa nh mk ml mm im bi translated">如果<code class="fe mz na nb nc b">tsc --init</code>不起作用，运行<code class="fe mz na nb nc b">npx tsc --init</code>代替</p></blockquote><h2 id="1186" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">设置codegen</h2><p id="aa4e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">然后，我们将设置codegen，开始基于我们的模式生成我们的typescript文件。</p><p id="112c" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">为此，我们需要添加一个graphql文件，这样我们就有东西可以扫描了。为了文章的目的。我们将创建一个非常简单的文件来登录/注册，并从一个假用户那里获得令牌。</p><p id="cacc" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">创建一些文件夹，使您的层次结构如下所示:</p><pre class="kj kk kl km gt ob nc oc od aw oe bi"><span id="faf9" class="mn la it nc b gy of og l oh oi">- src<br/>  - graphql<br/>    - schemas<br/>    - resolvers</span></pre><p id="1f01" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">在schemas文件夹中，创建一个<code class="fe mz na nb nc b">user.graphql</code>文件，内容如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/955a247041d450731803cb54040f8334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_IIR9BFpiJFi4mogcVdFQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">src/graph QL/schemas/user . graph QL</figcaption></figure><p id="67b5" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">在graphql文件中，我们只是每次添加一个请求(突变和查询)和一个类型(AuthenticateResponse ),这样我们就可以充分利用codegen的优势。</p><p id="a1ec" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">现在，在您的终端中，运行以下命令来安装我们需要的新包:<code class="fe mz na nb nc b">npm install -D @graphql-codegen/cli graphql</code>然后运行以下命令来设置codegen: <code class="fe mz na nb nc b">npx graphql-codegen init</code> <br/>该命令将启动一个向导来创建您的新codegen配置。</p><p id="6ba9" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">第一个问题是关于你希望运行codegen的环境类型。因为我们这里的目标是nodeJS，所以使用space选择第一个选项(API或server ),并按enter键进入下一步。</p><p id="4d7d" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">第二个问题是关于模式在哪里。您可以使用URL(但是您必须运行您的服务器来更新typescript文件),或者您可以指定graphql文件的文件路径。在我们的案例中，我们希望针对所有。graphql文件位于<code class="fe mz na nb nc b">src/graphql/schemas</code>下。<br/>只需键入以下值:<code class="fe mz na nb nc b">src/graphql/schemas/**/*.graphql</code>。</p><p id="807c" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">第三个问题是关于你可能需要生成类型脚本文件的插件。在我们的例子中，默认选项非常好。如果您想将codegen用于mongodb，那么您可以选择第三个选项。否则，只需按回车键</p><p id="b352" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">第四个问题是生成我们的typescript文件的路径。你可以把它放在你喜欢的任何地方。就我而言，我会选择<code class="fe mz na nb nc b">src/graphql/generated.ts</code></p><p id="e1c0" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">对于第五个问题，选择“否”(键入N，然后按回车键)</p><p id="9e5a" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">对于最后一个，只需保持默认状态并按回车键</p><p id="0940" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">最后，对于最后一个问题，codegen询问脚本名称来运行codegen命令。在我的例子中，我只需键入<code class="fe mz na nb nc b">codegen</code>并按回车键</p><p id="e698" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">一旦设置完成，按照codegen的要求运行<code class="fe mz na nb nc b">npm install</code>，然后运行<code class="fe mz na nb nc b">npm run codegen</code>来生成typescript文件。</p><p id="4854" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">如果设置已经正确完成，那么您将在向导的第四步中指定的路径下找到一个新的typescript文件！</p><p id="eb93" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">如果您打开项目根目录下的codegen.yml文件，您将看到cli是如何生成配置的。</p><h2 id="2bb8" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">设置解析程序映射器</h2><p id="88be" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了更好地维护，我希望能够将我的文件分开。这就是为什么我想直接向您展示如何设置解析器映射器(将多个解析器合并为一个),而不是只为所有解析器使用一个文件。</p><p id="694e" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">首先，在我们的文件夹<code class="fe mz na nb nc b">resolvers</code>中创建一个名为<code class="fe mz na nb nc b">UserResolver.ts</code>的新的typescript文件。这个文件将包含所有与user.graphql文件相关的解析器。</p><p id="319d" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">您可以在其中填入以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/31fcc412ed18f054782d8dcd5745fafe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdAEhYfFOElwqFI5HfvXZQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">src/graph QL/resolvers/user resolver . ts</figcaption></figure><blockquote class="nu nv nw"><p id="1b95" class="lr ls nx lt b lu nd ju lw lx ne jx lz ny nf mc md nz ng mg mh oa nh mk ml mm im bi translated">不要忘记运行<code class="fe mz na nb nc b">npm install -D graphql-tools</code>来访问这个文件中使用的graphql-tools包。Graphql-tools提供了许多类型和助手来处理Graphql。</p></blockquote><p id="09aa" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">这个文件包含两个解析器，分别对应于相应graphql文件中的查询和变异。此外，我们从生成的文件中获取类型，并在我们的解析器中使用它们。</p><p id="13db" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">我决定让我们的解析器变得简单，只返回一个简单的带有令牌的对象。</p><blockquote class="nu nv nw"><p id="d442" class="lr ls nx lt b lu nd ju lw lx ne jx lz ny nf mc md nz ng mg mh oa nh mk ml mm im bi translated">如您所见，codegen使用一种模式来生成类型。在你的graphql文件中，如果你定义了一个类型，这个名字是不会改变的。然而，对于查询或变异，它将遵循模式<code class="fe mz na nb nc b">&lt;requestType&gt;&lt;RequestName&gt;Args</code></p></blockquote><p id="bd27" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">既然are resolver已经准备好了，我们将使用它将它合并(暂时单独)到一个专用文件中。在文件夹graphql中创建名为<code class="fe mz na nb nc b">resolversMap.ts</code>的文件，并将以下内容放入其中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/dbcdbbf7444ccc6627bcbe8823d1e174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BwxSvTj0BxqL6a5NgLPAMw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">src/graphql/resolversMap.ts</figcaption></figure><blockquote class="nu nv nw"><p id="7c68" class="lr ls nx lt b lu nd ju lw lx ne jx lz ny nf mc md nz ng mg mh oa nh mk ml mm im bi translated">不要忘记运行<code class="fe mz na nb nc b">npm install --save lodash</code>和<code class="fe mz na nb nc b">npm install -D @types/lodash</code>来访问合并函数及其类型。</p></blockquote><p id="28bb" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">这个文件的目的是获取所有的解析器，并将它们合并成一个。这个新的解析器稍后将被您的graphql服务器使用。</p><h2 id="41f0" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">设置模式映射器</h2><p id="8fe9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，我们将对我们的模式做同样的事情。在resolversMap.ts旁边，创建一个名为<code class="fe mz na nb nc b">schemasMap.ts</code>的新文件，并将以下内容放入其中</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/cc99945d38e0466177e5daa830e16fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pkh5vuWKc1U9DMIRZrUHqg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">src/graphql/schemasMap.ts</figcaption></figure><blockquote class="nu nv nw"><p id="467d" class="lr ls nx lt b lu nd ju lw lx ne jx lz ny nf mc md nz ng mg mh oa nh mk ml mm im bi translated">别忘了跑<code class="fe mz na nb nc b">npm install --save graphql-import-node</code>。这个包允许您在应用程序中导入。graphql文件。如果没有它，您在导入它们时很可能会出错。</p></blockquote><p id="1834" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">现在还不要担心empty.graphql导入，我将在完成这个文件后向您展示它。</p><p id="c8be" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">函数<code class="fe mz na nb nc b">makeExecutableSchema</code>是管理整个合并的关键函数。它将模式(或typeDefs)和解析器作为参数，并生成一个新的标准Graphql模式。</p><blockquote class="nu nv nw"><p id="28ed" class="lr ls nx lt b lu nd ju lw lx ne jx lz ny nf mc md nz ng mg mh oa nh mk ml mm im bi translated">注意typeDefs数组中的顺序。emptypedefs<strong class="lt iu">必须</strong>是数组中的第一个，否则将不起作用。</p></blockquote><p id="a000" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">现在，对于empty.graphql文件。在user.graphl one旁边创建它，并将此内容放入其中</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/9188293268a56307ab9f27b8d81e6eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*Go3Jbs08g-oB1V5BRZvrMQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">src/graph QL/schemas/empty . graph QL</figcaption></figure><p id="77d7" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">该文件的目标是定义查询和变异类型，以便所有其他模式文件都可以从它们扩展。这就是前面提到的emptyTypeDefs必须位于数组第一位的原因。</p><blockquote class="nu nv nw"><p id="1ecc" class="lr ls nx lt b lu nd ju lw lx ne jx lz ny nf mc md nz ng mg mh oa nh mk ml mm im bi translated">这里的<code class="fe mz na nb nc b">_empty</code>值是占位符，因为graphql不授权空对象</p></blockquote><p id="ad55" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">我们还对user.graphql文件做了一点小小的修改。因为我们现在正在合并，你必须在<code class="fe mz na nb nc b">type Query</code>和<code class="fe mz na nb nc b">type Mutation</code>之前添加关键字<code class="fe mz na nb nc b">extend</code>，并且将来你必须在任何使用这种类型的文件中这样做。只有empty.graphql没有使用extend，因为它定义了原始类型。</p><h2 id="50c4" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">设置Express/Apollo服务器并测试我们的API</h2><p id="8ce3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们快到了！现在我们所有的工具都准备好了，我们只需要把它们连接起来。</p><p id="691a" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">在src文件夹中，创建一个index.ts文件，其中包含以下内容</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/c2ef98d17754655547e44631d96f1e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mtJ4gQHImYNMZZYgUKWeyA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">src/索引. ts</figcaption></figure><blockquote class="nu nv nw"><p id="677d" class="lr ls nx lt b lu nd ju lw lx ne jx lz ny nf mc md nz ng mg mh oa nh mk ml mm im bi translated">不要忘记通过运行<code class="fe mz na nb nc b">npm install --save express apollo-server-express</code>和<code class="fe mz na nb nc b">npm install -D @types/express</code>来安装新的依赖项</p></blockquote><p id="95c2" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">这个文件是你的应用程序的入口点。它将首先设置一个express应用程序，然后通过给它之前创建的schemaMap创建一个新的Apollo服务器。然后，我们将应用Apollo server express作为中间件，并将graphql路径设置为<code class="fe mz na nb nc b">/graphql</code></p><p id="0457" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">终于，我们开始听了！</p><p id="f292" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">现在，如果我们想测试我们的应用程序，我们必须能够运行它。为此，我们将通过运行命令<code class="fe mz na nb nc b">npm install -D nodemon ts-node</code>来安装nodemon和ts-node。</p><p id="d203" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">然后在package.json中添加一个新脚本，使用您喜欢的名称，并让它运行这个命令:<code class="fe mz na nb nc b">nodemon src/index.ts</code></p><p id="8166" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">如果一切顺利，控制台上会显示一条消息，说明Apollo正在端口4000上运行</p><h1 id="6fdf" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">测试我们的graphql应用程序</h1><h2 id="935b" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">图形QL</h2><p id="49d3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在是测试时间！有很多方法可以连接到graphql应用程序。对于初学者来说，最直接的方法是graphql，这是graph QL的一个开源GUI。你可以在这里下载<a class="ae ky" href="https://www.electronjs.org/apps/graphiql" rel="noopener ugc nofollow" target="_blank"/></p><p id="02fc" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">下载并打开之后，您可以在<code class="fe mz na nb nc b">GraphQL Endpoint</code>字段中输入您的graphql应用程序的url，应该是<a class="ae ky" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graph QL</a></p><p id="ccc6" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">确保右侧的<code class="fe mz na nb nc b">Method</code>设置为POST。</p><p id="63c9" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">如果一切都配置好了，您将会在右边看到您的graphql API的文档</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/02339e9937a06c5127a36f06d01a897c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K2XJM2tVACKhFSj1JChmzg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">你的申请文件</figcaption></figure><p id="7f7c" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">然后，您可以单击不同的类型来查看它们包含的内容。你应该四处玩一玩，让自己熟悉GraphiQL！</p><h2 id="5bc7" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">运行查询</h2><p id="63b7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">应用程序的主要部分是一个用于输入查询的多行字段(在左边)和结果区域(在屏幕中间)</p><p id="f7f7" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">要运行一个查询，您必须首先输入它的类型(查询或变异),然后输入您想要为查询指定的名称。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/89ac6ef78b460cb7184fc7faba099863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xhNME5jquhC3pFggUsR2WQ.png"/></div></div></figure><p id="c358" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">然后，在对象中，您将调用您想要执行的查询。我们要打电话给<code class="fe mz na nb nc b">login</code>。按照模式中的定义，login将电子邮件和密码作为参数。我们将在查询中给出它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/f11147203b566ab928dec0e326e54916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vR3eZJh71LCJkLAAXpuqNA.png"/></div></div></figure><p id="1590" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">最后，在第二个对象中，你将放置你想从这个请求中获取的值。</p><blockquote class="nu nv nw"><p id="17ad" class="lr ls nx lt b lu nd ju lw lx ne jx lz ny nf mc md nz ng mg mh oa nh mk ml mm im bi translated">Graphql的伟大之处在于，您可以选择您感兴趣的参数，而不会得到您不想要的参数。这允许保存数据并降低一些对象的复杂性。例如，如果您想只获取用户的令牌而不获取完整用户，则只能指定token！</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/053c2523d5fed4bac2420fb65e5dea63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jddwRsx41Ov9gkQFZYD5xA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">你最后的请求</figcaption></figure><p id="714a" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">这是我们的要求！现在，你所要做的就是按下播放按钮，在中间的面板上看到结果！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/c163b26b2b7bb9036f5afaa715c14ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*gAlCW_1W8IaFDUa2d4zDDw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们的结果</figcaption></figure><p id="0325" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">开始了。我们的graphql应用程序向我们发送了来自解析器的预期响应！</p><h1 id="f91f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="227f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这就是我想要的完美的Apollo/Typescript服务器。它已经让你有可能分裂你的文件，并在良好的基础上开始！</p><p id="24e1" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">如果你想让整个项目已经准备好，你可以在<a class="ae ky" href="https://github.com/psyycker/graphql-ts-express-codegen" rel="noopener ugc nofollow" target="_blank">我的github </a>上得到它。</p><p id="add1" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">我希望你喜欢读这篇文章，就像我喜欢写它一样:)</p><p id="b527" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">下一集再见！</p><p id="b710" class="pw-post-body-paragraph lr ls it lt b lu nd ju lw lx ne jx lz ma nf mc md me ng mg mh mi nh mk ml mm im bi translated">雷米</p></div></div>    
</body>
</html>