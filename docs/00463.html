<html>
<head>
<title>The Importance of State &amp; UI Actors in Web Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web应用程序中状态和用户界面参与者的重要性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-importance-of-state-ui-actors-in-web-apps-f69cc523798b?source=collection_archive---------0-----------------------#2019-03-15">https://levelup.gitconnected.com/the-importance-of-state-ui-actors-in-web-apps-f69cc523798b?source=collection_archive---------0-----------------------#2019-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/666136297b81a322a9203a6cb87f3b04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NfDr_qIXhpbLle3p94QHyQ.jpeg"/></div></div></figure><p id="5917" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React既可以被视为一个UI库，也可以被视为一个状态和UI管理库。当您开始学习React时，本地组件状态的使用对于您构建应用程序的方式至关重要。您可以呈现一些JSX，添加事件处理程序来修改用户交互的状态，反过来，您可以在屏幕上呈现新的HTML。</p><p id="3468" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">开始时，一切都很好，每个组件都有自己的本地状态，您的关注点分离得到了正确的实现。混合状态和用户界面的方法可能是执行快速原型开发，以及创建背后几乎没有业务逻辑的小规模应用程序的最简单的方法。不过我认为这最终不会很好地扩展到大型应用程序。</p><p id="1a9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您看，您将不可避免地需要为您的子组件提供一种方法来修改父组件的本地状态，因此您将状态修改函数传递到组件属性链。不幸的是，子组件也有自己的本地状态，它们有时会想要对其父组件的状态变化做出反应(没有双关语的意思)。</p><p id="6f5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种情况会一直持续下去，在你意识到这一点之前，你就面临着像一个疯狂的球一样上下跳动的数据流。因为状态是由组件拥有的，所以前面提到的反弹实际上与你的应用程序的构造方式有关，也就是你的React组件树。如果你决定把一个组件移动到其他地方，你需要提升状态，或者<a class="ae kw" href="https://kentcdodds.com/blog/prop-drilling/" rel="noopener ugc nofollow" target="_blank">沿着链</a>向下钻取你的道具，或者利用<a class="ae kw" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>。</p><blockquote class="kx"><p id="2d53" class="ky kz iq bd la lb lc ld le lf lg kv dk translated">UI块的重新排列不应该以任何方式影响你的状态</p></blockquote><p id="0946" class="pw-post-body-paragraph jy jz iq ka b kb lh kd ke kf li kh ki kj lj kl km kn lk kp kq kr ll kt ku kv ij bi translated">出于这个原因，我真的认为大型应用程序应该将数据的存储方式与呈现给用户的方式完全分离。Redux在这方面起着关键作用，因为它从组件中抽象出状态意识，从而使它们更加“笨”。组件越笨，就越容易测试、重构和重新安排。</p><p id="cc82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个库越是只承担单一的责任，它就越容易完全转换。如果您已经将应用程序状态与React组件完全隔离，那么您可以很容易地将React与Vue交换，因为您将只是切换表示层。这是双向的，因为你可以很容易地将Redux与未声明的<a class="ae kw" href="https://github.com/jamiebuilds/unstated" rel="noopener ugc nofollow" target="_blank"/>互换。</p><p id="7819" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的React组件甚至不会知道这一变化，因为您只是替换了状态层。当然，表示层和状态层的方式必须根据库的不同而改变，但这只是它们之间的粘合剂，而不是核心代码本身。真正的力量来自于这样一个事实，即这些层可能彼此完全不可知，因为这使得它们能够被单独测试并按需替换。</p><p id="a101" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">中央集权的国家并不伟大，因为所有的国家都在一个地方。这很好，因为所有的更新都通过一个点，为中间件和副作用打开了大门。如果你编写一个大规模的应用程序，你肯定需要日志和分析。有了中间件，你可以开箱即用，因为你可以记录用户在你的应用程序中执行的每一个动作(这是客户支持非常珍惜的)。不要只考虑Redux，要考虑动作通过您已经在使用的mediator模式的实现的方式。它通过自己的中间件为您提供了与API服务器相同的功能。</p><p id="9605" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">国家集权意味着自动化现在轻而易举。想想看，对你来说，使用任何主流的状态管理库以编程方式<strong class="ka ir"/>与状态交互要比将状态存储在不同的React组件中容易得多。您只需导入状态修改函数Redux中的动作创建器，Mobx中的类方法，等等。—然后解雇他们。状态越集中，回调就越少(回调异步操作，以便React组件可以更新它们自己的本地状态)。回调越少，过程就越流畅，代码库就越易读和易维护。</p><p id="7b1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，我们要完全抛弃本地组件状态吗？实际上不是。本地状态可以用于那些当前状态与业务逻辑和应用程序的其余部分无关的组件。例如，让一个按钮改变颜色，或者当你悬停在它上面时控制下拉菜单的打开，这些都是本地状态擅长的任务。这是因为，在大多数情况下，您的核心应用程序状态并不关心按钮在任何给定时刻是红色还是绿色，尽管颜色是通过本地状态控制的，但这个本地状态与您的应用程序状态层有所不同。你可以很容易地认为它是你的表示层的一部分，然后就到此为止。在完全隔离/解耦的React组件中利用本地状态获取和显示数据仍然是一个有效的选择，但我向您保证，这种隔离迟早会被打破，当它打破时，就需要进行重构。</p><h1 id="4720" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结束注释</h1><p id="095b" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">当编写干净的代码并遵循特定的模式时，我们努力使我们的代码可维护。可维护性与团队中的新开发人员(或者几个月后的您)掌握代码的速度有很大关系。状态和UI的适当分离减少了理解业务逻辑所花费的时间，降低了可维护性的成本，并减少了升级堆栈的工作量。它简化了测试，并且允许自动化和状态复制。不管你现在需要什么，请想想未来…</p><p id="5058" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读:)</p><p id="89f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="mt"/></strong>👋<strong class="ka ir"> <em class="mt">嗨，我是</em></strong><a class="ae kw" href="https://aggelosarvanitakis.me" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mt">Aggelos</em></strong></a><strong class="ka ir"><em class="mt">！如果你喜欢这个，考虑一下</em> </strong> <a class="ae kw" href="https://twitter.com/AggArvanitakis" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="mt">在twitter上关注我</em> </strong> </a> <strong class="ka ir"> <em class="mt">并与你的开发者朋友分享这个故事</em>😀</strong></p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="c0cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能也会对我前几周的一些故事感兴趣</p><ul class=""><li id="17b8" class="nb nc iq ka b kb kc kf kg kj nd kn ne kr nf kv ng nh ni nj bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/3-small-tips-for-better-redux-performance-in-a-react-app-9cde549df6af">https://level up . git connected . com/3-small-tips-for-better-redux-performance-in-a-react-app-9 CDE 549 df 6 af</a></li><li id="851c" class="nb nc iq ka b kb nk kf nl kj nm kn nn kr no kv ng nh ni nj bi translated"><a class="ae kw" href="https://medium.com/@aggelosarvanitakis/6-tips-for-better-react-performance-4329d12c126b" rel="noopener">https://medium . com/@ aggelosarvanitakis/6-tips-for-better-react-performance-4329 d12 c126 b</a></li></ul></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><figure class="nq nr ns nt gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi np"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure></div></div>    
</body>
</html>