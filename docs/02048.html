<html>
<head>
<title>Some Useful RxJS Transformation Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一些有用的RxJS变换运算符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/some-useful-rxjs-transformation-operators-ba4e1ba92cec?source=collection_archive---------7-----------------------#2020-02-15">https://levelup.gitconnected.com/some-useful-rxjs-transformation-operators-ba4e1ba92cec?source=collection_archive---------7-----------------------#2020-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/90b73707d473938029deb973b6a4df91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uwqheWw-Xa6hIz4G"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">沃纳·范·格雷宁在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="2f7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RxJS是一个反应式编程的库。创建操作符对于从各种数据源生成供观察者订阅的数据非常有用。</p><p id="5b0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将查看一些RxJS转换操作符，如<code class="fe le lf lg lh b">bufferTime</code>、<code class="fe le lf lg lh b">bufferToggle</code>、<code class="fe le lf lg lh b">bufferWhen</code>和<code class="fe le lf lg lh b">concatMap</code>操作符。</p><h1 id="c514" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">缓冲时间</h1><p id="237f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">bufferTime</code>算子将原始观测数据的发射数据缓冲一段特定的时间。</p><p id="3100" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它需要一个参数<code class="fe le lf lg lh b">bufferTimeSpan</code>，即填充每个缓冲区数组的时间。时间跨度的单位是毫秒。</p><p id="3e62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦达到指定的时间，就会发出缓冲区数据并重置缓冲区。</p><p id="b33b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还需要一个<code class="fe le lf lg lh b">bufferCreationInterval</code>参数，该参数指定缓冲区数据建立的时间跨度。操作员每隔<code class="fe le lf lg lh b">bufferCreationInterval</code>毫秒打开一次缓冲器，每隔<code class="fe le lf lg lh b">bufferTimeSpan</code>毫秒发射和复位一次。</p><p id="7d07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该操作符的另一个可选参数是<code class="fe le lf lg lh b">maxBufferSize</code>，它是一个指定缓冲项的最大大小的数字。</p><p id="b2fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="69ff" class="mt lj it lh b gy mu mv l mw mx">import { interval } from "rxjs";<br/>import { bufferTime } from "rxjs/operators";</span><span id="258b" class="mt lj it lh b gy my mv l mw mx">const clicks = interval(2000);<br/>const buffered = clicks.pipe(bufferTime(1000));<br/>buffered.subscribe(x =&gt; console.log(x));</span></pre><p id="aca5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该看到在发出的数组中每2秒钟发出一个新的数字，而其余发出的数组是空的。</p><p id="9fa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">bufferCreationInterval</code>参数可以如下使用:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7f2d" class="mt lj it lh b gy mu mv l mw mx">import { interval } from "rxjs";<br/>import { bufferTime } from "rxjs/operators";</span><span id="80ef" class="mt lj it lh b gy my mv l mw mx">const clicks = interval(2000);<br/>const buffered = clicks.pipe(bufferTime(1000, 1000));<br/>buffered.subscribe(x =&gt; console.log(x));</span></pre><p id="d1e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，缓冲的数据每秒发出一次，缓冲区每秒创建一次。</p><h1 id="57e5" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">bufferToggle</h1><p id="fa5f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">bufferToggle</code>缓冲源可观测值，从<code class="fe le lf lg lh b">openings</code>发射开始，到<code class="fe le lf lg lh b">closingSelector</code>输出发射结束。</p><p id="2286" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原始可观测值发出的值被缓冲，直到<code class="fe le lf lg lh b">closingSelector</code>告诉我们停止从原始可观测值发出值。</p><p id="5884" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有如下按钮:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="468d" class="mt lj it lh b gy mu mv l mw mx">&lt;button&gt;Click Me&lt;/button&gt;</span></pre><p id="4606" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以缓冲按钮上的鼠标点击事件，并发出根据<code class="fe le lf lg lh b">closingSelector</code>函数规范缓冲的<code class="fe le lf lg lh b">MouseEvent</code>对象，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0061" class="mt lj it lh b gy mu mv l mw mx">import { fromEvent, interval, EMPTY } from "rxjs";<br/>import { bufferToggle } from "rxjs/operators";</span><span id="651b" class="mt lj it lh b gy my mv l mw mx">const clicks = fromEvent(document.querySelector("button"), "click");<br/>const openings = interval(1000);<br/>const buffered = clicks.pipe(<br/>  bufferToggle(openings, i =&gt; (i % 2 ? interval(1500) : EMPTY))<br/>);<br/>buffered.subscribe(x =&gt; console.log(x));</span></pre><p id="681f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上例中的<code class="fe le lf lg lh b">closingSelector</code>是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2536" class="mt lj it lh b gy mu mv l mw mx">(i % 2 ? interval(1500) : EMPTY)</span></pre><p id="b6f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当代码开始发射时，也就是当我们点击按钮时，它将从<code class="fe le lf lg lh b">openings</code>可观察对象发射数据，每隔1.5秒。发射的数据被缓冲到一个数组中，然后当<code class="fe le lf lg lh b">i % 2</code>为<code class="fe le lf lg lh b">false</code>时缓冲结束，返回<code class="fe le lf lg lh b">interval(1500)</code>可观测值，表示关闭。当<code class="fe le lf lg lh b">EMPTY</code>发射时，它会继续缓冲。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/ec8a6d1a5e2e0c3ff27b9b671114b068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9xbdMJ-zrhs9CaL7"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@alessandrodesantis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历山德罗·德桑蒂斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="47fd" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">布弗亨</h1><p id="592f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">bufferWhen</code>运算符缓冲来自源可观测数据的数据，直到<code class="fe le lf lg lh b">closingSelector</code>函数关闭缓冲区。</p><p id="ed97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它需要一个参数，即<code class="fe le lf lg lh b">closingSelector</code>函数来指定何时关闭缓冲区。</p><p id="be2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以像在下面的代码中一样使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="de84" class="mt lj it lh b gy mu mv l mw mx">import { fromEvent, interval } from "rxjs";<br/>import { bufferWhen } from "rxjs/operators";</span><span id="4d82" class="mt lj it lh b gy my mv l mw mx">const clicks = fromEvent(document.querySelector("button"), "click");<br/>const buffered = clicks.pipe(<br/>  bufferWhen(() =&gt; interval(1000 + Math.random() * 4000))<br/>);<br/>buffered.subscribe(x =&gt; console.log(x));</span></pre><p id="81a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所做的是获取按钮点击，然后从缓冲的点击中发出<code class="fe le lf lg lh b">MouseEvent</code>的<code class="fe le lf lg lh b">MouseEvent</code>对象数组。</p><p id="8226" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们这样做了，<code class="fe le lf lg lh b">closingSelector</code>指定我们每隔<code class="fe le lf lg lh b">1000 + Math.random() * 4000</code>毫秒发出缓冲值，清空缓冲区并再次缓冲点击事件。</p><h1 id="4868" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">串联图</h1><p id="f254" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">concatMap</code>运算符获取原始可观察对象的每个源值，并等待原始可观察对象的一个值发出，然后再发出下一个发出的值。</p><p id="5e79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它需要两个参数。第一个是<code class="fe le lf lg lh b">project</code>函数，该函数返回一个新的可观察对象，我们希望将该操作应用于从原始可观察对象发出的值。第二个参数是<code class="fe le lf lg lh b">resultSelector</code>。这是一个可选参数，它是一个函数，用来选择我们希望在返回的可观察值中发出的值。</p><p id="3652" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="cc1e" class="mt lj it lh b gy mu mv l mw mx">import { fromEvent, interval, of } from "rxjs";<br/>import { concatMap, take } from "rxjs/operators";</span><span id="cfd3" class="mt lj it lh b gy my mv l mw mx">const clicks = fromEvent(document, "click");<br/>const result = clicks.pipe(concatMap(ev =&gt; interval(1000).pipe(take(5))));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="c018" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码将接收点击事件，然后在1秒后发出0，然后在另一秒后发出1，直到达到4。</p><p id="491f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们每次点击它都会做同样的事情。</p><p id="a9d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">bufferTime</code>操作符将原始观测值的发射数据缓冲一段时间，然后缓冲的数据将作为一个数组发射。</p><p id="c830" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">bufferToggle</code>缓冲源可观测值，从<code class="fe le lf lg lh b">openings</code>的发射开始，到<code class="fe le lf lg lh b">closingSelector</code>功能的输出发射时结束。</p><p id="6abc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">bufferWhen</code>操作符缓冲来自源可观察对象的数据，直到<code class="fe le lf lg lh b">closingSelector</code>函数发出它的数据。</p><p id="6c79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，<code class="fe le lf lg lh b">concatMap</code>操作符获取原始可观测值的每个源值，并等待原始可观测值的一个值发出，然后再发出下一个发出的值。</p></div></div>    
</body>
</html>