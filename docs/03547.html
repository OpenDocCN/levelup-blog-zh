<html>
<head>
<title>How to Convert ARGB Integer into RGBA Tuple in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中将ARGB整数转换成RGBA元组</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-convert-argb-integer-into-rgba-tuple-in-python-eeb851d65a88?source=collection_archive---------6-----------------------#2020-05-15">https://levelup.gitconnected.com/how-to-convert-argb-integer-into-rgba-tuple-in-python-eeb851d65a88?source=collection_archive---------6-----------------------#2020-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5b77" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python中<code class="fe ko kp kq kr b">&amp;</code>和<code class="fe ko kp kq kr b">&gt;&gt;</code>位运算符的真实用例</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/0c0c249971134e9de3e49c0e5060c822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ptuN1AjiNr-_w6R02PrDA.jpeg"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated"><a class="ae li" href="https://unsplash.com/@sigmund?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae li" href="https://unsplash.com/s/photos/pixel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="c33d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过阅读本文，您将了解如何将无符号32位ARGB8888整数值转换为其相应的RGBA元组，反之亦然。让我们来看看32位ARGB8888的颜色空间是什么样的</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi lj"><img src="../Images/bd4bf7560573e6784c8ccba69751fbe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MzrIWc_fWEVDzi6F.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">图片来自<a class="ae li" href="https://en.wikipedia.org/wiki/RGBA_color_model" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="b213" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据上面的图像，我们可以确定每个颜色空间按以下顺序占用整数的8位:</p><ul class=""><li id="0455" class="lk ll it js b jt ju jx jy kb lm kf ln kj lo kn lp lq lr ls bi translated"><code class="fe ko kp kq kr b">0–7</code> —前8位代表蓝色空间。</li><li id="f7f1" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated"><code class="fe ko kp kq kr b">8–15</code> —接下来的8位代表绿色空间。</li><li id="c8e8" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated"><code class="fe ko kp kq kr b">16–23</code> —红色空间由第16至23位表示。</li><li id="9373" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated"><code class="fe ko kp kq kr b">24–31</code> —最后8位代表alpha颜色空间，表示像素的透明度。</li></ul><p id="bace" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些整数数据中的每一个都代表图像的一个像素中的色彩空间。将这样的数据转换成元组是必要的，因为它将在与其他模块集成时为我们提供更多的灵活性。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="4b3b" class="mf mg it bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">履行</h1><p id="f17a" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">我将在本教程中使用Python，但也可以随意使用其他语言。这段代码的实现是基于位运算的。你也可以用算术方法来达到同样的效果。至于像素值，我将使用以下颜色，RGB值为(38，192，204)。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/19c586e366168a5189dcbb56a811d8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*2JcD48f5haj0W7mpt7SdKg.png"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">作者图片</figcaption></figure><p id="6698" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们初始化一个代表无符号32位ARGB整数的变量。</p><pre class="kt ku kv kw gt nj kr nk nl aw nm bi"><span id="7e80" class="nn mg it kr b gy no np l nq nr">pixel_data = 4280729804</span></pre><p id="9242" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您不确定使用什么作为输入，您可以使用<code class="fe ko kp kq kr b">int</code>函数直接将十六进制代码转换为整数。它接受表示基数的第二个输入参数，在本例中是16。<code class="fe ko kp kq kr b">0x</code>是十六进制的前缀，其余部分是ARGB风格。</p><pre class="kt ku kv kw gt nj kr nk nl aw nm bi"><span id="7097" class="nn mg it kr b gy no np l nq nr">pixel_data = int('0xff26c0cc', 16)</span></pre><h2 id="0808" class="nn mg it bd mh ns nt dn ml nu nv dp mp kb nw nx mt kf ny nz mx kj oa ob nb oc bi translated">按位&amp;运算符</h2><p id="d6f1" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">我们将开始提取颜色空间。最简单的方法是将其屏蔽，只保留前8位。你可以用<code class="fe ko kp kq kr b">&amp;</code>符号来做。供您参考，255代表二进制值11111111。换句话说，我们将对这两个值执行AND运算。</p><pre class="kt ku kv kw gt nj kr nk nl aw nm bi"><span id="ecd9" class="nn mg it kr b gy no np l nq nr">11111111 00100110 11000000 11001100 #binary for pixel_data<br/>00000000 00000000 00000000 11111111 #binary for 255</span><span id="ee66" class="nn mg it kr b gy od np l nq nr">00000000 00000000 00000000 11001100 #binary after AND operation</span></pre><p id="48aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您运行下面的代码时，您将获得值<code class="fe ko kp kq kr b">204</code>。</p><pre class="kt ku kv kw gt nj kr nk nl aw nm bi"><span id="e1be" class="nn mg it kr b gy no np l nq nr">int('0b11001100', 2)</span></pre><h2 id="f49d" class="nn mg it bd mh ns nt dn ml nu nv dp mp kb nw nx mt kf ny nz mx kj oa ob nb oc bi translated">按位&gt;&gt;运算符</h2><p id="5cdb" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">上述方法仅适用于蓝色空间，因为它由前8位表示。为了解决这个问题，我们可以使用按位运算符<code class="fe ko kp kq kr b">&gt;&gt;</code>，它将根据您指定的位数向右移动。假设我将值向右移动了8。</p><pre class="kt ku kv kw gt nj kr nk nl aw nm bi"><span id="817d" class="nn mg it kr b gy no np l nq nr">11111111 00100110 11000000 11001100 #binary for pixel_data</span><span id="f1e7" class="nn mg it kr b gy od np l nq nr">00000000 11111111 00100110 11000000 #binary after right shift<br/>00000000 00000000 00000000 11111111 #binary for 255</span><span id="1031" class="nn mg it kr b gy od np l nq nr">00000000 00000000 00000000 11000000 #binary after AND operation</span></pre><p id="41af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您运行下面的代码时，您应该得到<code class="fe ko kp kq kr b">192</code>。</p><pre class="kt ku kv kw gt nj kr nk nl aw nm bi"><span id="18f6" class="nn mg it kr b gy no np l nq nr">int('0b11000000', 2)</span></pre><h2 id="1cf1" class="nn mg it bd mh ns nt dn ml nu nv dp mp kb nw nx mt kf ny nz mx kj oa ob nb oc bi translated">从整数到RGBA</h2><p id="7ad7" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">让我们把所有我们学过的东西组合成一个函数。创建一个新函数，并根据自己的喜好命名。它接受一个参数作为输入，该参数将是无符号的32位整数。</p><pre class="kt ku kv kw gt nj kr nk nl aw nm bi"><span id="e68c" class="nn mg it kr b gy no np l nq nr">def RGBAfromInt(argb_int):<br/>    blue =  argb_int &amp; 255<br/>    green = (argb_int &gt;&gt; 8) &amp; 255<br/>    red =   (argb_int &gt;&gt; 16) &amp; 255<br/>    alpha = (argb_int &gt;&gt; 24) &amp; 255</span><span id="9a58" class="nn mg it kr b gy od np l nq nr">return (red, green, blue, alpha)</span></pre><ul class=""><li id="86d7" class="lk ll it js b jt ju jx jy kb lm kf ln kj lo kn lp lq lr ls bi translated"><code class="fe ko kp kq kr b">blue</code> —仅获取前8位数据。</li><li id="d78f" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated"><code class="fe ko kp kq kr b">green</code> —将位值右移8位，得到前8位数据。</li><li id="c4c2" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated"><code class="fe ko kp kq kr b">red</code> —将位值右移16，得到前8位数据。</li><li id="f419" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn lp lq lr ls bi translated"><code class="fe ko kp kq kr b">alpha</code> —将位值右移24，得到前8位数据。</li></ul><p id="56f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们将按照RGBA顺序以元组的形式返回值。您可以根据自己的喜好随意重新排列元组中的顺序。让我们通过运行下面的代码来测试一下</p><pre class="kt ku kv kw gt nj kr nk nl aw nm bi"><span id="b570" class="nn mg it kr b gy no np l nq nr">result_tuple = RGBAfromInt(pixel_data)<br/>print(result_tuple)</span></pre><p id="8fbe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该在终端上看到以下输出。</p><pre class="kt ku kv kw gt nj kr nk nl aw nm bi"><span id="c58b" class="nn mg it kr b gy no np l nq nr">[38, 192, 204, 255]</span></pre><h2 id="45d4" class="nn mg it bd mh ns nt dn ml nu nv dp mp kb nw nx mt kf ny nz mx kj oa ob nb oc bi translated">来自RGBA的Int</h2><p id="d8da" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">让我们创建另一个相反的函数，将RGBA元组改回它原来的无符号32位整数。这次我们将把位向左移动，并对所有的值求和。</p><pre class="kt ku kv kw gt nj kr nk nl aw nm bi"><span id="f5d4" class="nn mg it kr b gy no np l nq nr">def IntfromRGBA(rgba):<br/>    red = rgba[0]<br/>    green = rgba[1]<br/>    blue = rgba[2]<br/>    alpha = rgba[3]</span><span id="849a" class="nn mg it kr b gy od np l nq nr">    RGBint = (alpha &lt;&lt; 24) + (red &lt;&lt; 16) + (green &lt;&lt; 8) + blue</span><span id="3d27" class="nn mg it kr b gy od np l nq nr">    return RGBint</span></pre><p id="946a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们用下面的代码来测试一下。我们将使用之前获得的结果作为输入数据。</p><pre class="kt ku kv kw gt nj kr nk nl aw nm bi"><span id="3b92" class="nn mg it kr b gy no np l nq nr">result_int = IntfromRGBA(result_tuple)<br/>print(result_int)</span></pre><p id="1c6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该得到<code class="fe ko kp kq kr b">4280729804</code>,因为最终输出表明我们已经成功地将其转换回原始数据。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="4ccd" class="mf mg it bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">结论</h1><p id="07e4" class="pw-post-body-paragraph jq jr it js b jt nd jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj nh kl km kn im bi translated">让我们回顾一下今天所学的内容。</p><p id="002e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先简要解释了ARGB8888数据的结构。</p><p id="d6c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们深入探讨了如何使用<code class="fe ko kp kq kr b">&amp;</code>和<code class="fe ko kp kq kr b">&gt;&gt;</code>位运算符。此外，我们测试了转换成不同的基础，如二进制和十六进制值。</p><p id="cb0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们创建了一个函数来将无符号32位整数转换为RGBA元组。同样，我们实现了reverse函数，将元组改回其原始形式。</p><p id="890e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢你阅读这篇文章。希望在下一篇文章中再见到你！</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="5621" class="mf mg it bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">参考</h1><ol class=""><li id="9233" class="lk ll it js b jt nd jx ne kb oe kf of kj og kn oh lq lr ls bi translated"><a class="ae li" href="https://stackoverflow.com/questions/17483557/python-transforming-one-dimensional-array-into-two-dimensional-array" rel="noopener ugc nofollow" target="_blank">将一维转换为二维</a></li><li id="256b" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn oh lq lr ls bi translated"><a class="ae li" href="https://pillow.readthedocs.io/en/latest/handbook/concepts.html#concept-modes" rel="noopener ugc nofollow" target="_blank">枕头的文档</a></li><li id="6df2" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn oh lq lr ls bi translated"><a class="ae li" href="https://github.com/python-pillow/Pillow/issues/3781" rel="noopener ugc nofollow" target="_blank">灰度图像问题</a></li><li id="18a1" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn oh lq lr ls bi translated"><a class="ae li" href="https://stackoverflow.com/questions/2262100/rgb-int-to-rgb-python" rel="noopener ugc nofollow" target="_blank"> RGB转整数</a></li><li id="84e8" class="lk ll it js b jt lt jx lu kb lv kf lw kj lx kn oh lq lr ls bi translated"><a class="ae li" href="https://en.wikipedia.org/wiki/RGBA_color_model" rel="noopener ugc nofollow" target="_blank"> RGBA色彩模型百科</a></li></ol></div></div>    
</body>
</html>