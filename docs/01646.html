<html>
<head>
<title>Node.js FS Module — Opening Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js FS模块-打开文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-fs-module-opening-files-f4388a459001?source=collection_archive---------4-----------------------#2020-01-19">https://levelup.gitconnected.com/node-js-fs-module-opening-files-f4388a459001?source=collection_archive---------4-----------------------#2020-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/95cdfb04ceccab7d30e71448cce3c0f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qL9Zg5G3mC0O9pqq"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">维克多·塔拉舒克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f2ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">操作文件是任何程序的基本操作。因为Node.js是一个服务器端平台，可以直接与运行它的计算机交互，所以能够操作文件是一个基本特性。幸运的是，Node.js的库中内置了一个<code class="fe le lf lg lh b">fs</code>模块。它有许多功能，可以帮助操纵文件和文件夹。</p><p id="74b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">支持的文件和文件夹操作包括基本的操作，如操作和打开目录中的文件。同样，它也可以对文件做同样的事情。它可以同步和异步地做到这一点。它有一个异步API，该API具有支持承诺的功能。此外，它还可以显示文件的统计数据。</p><p id="e8fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">几乎所有我们能想到的文件操作都可以用内置的<code class="fe le lf lg lh b">fs</code>模块来完成。在本文中，我们将介绍<code class="fe le lf lg lh b">fs</code>模块，以及如何构造可用于打开文件的路径和用它打开文件。</p><p id="b3c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还将尝试使用<code class="fe le lf lg lh b">fs</code> promises API来执行常规<code class="fe le lf lg lh b">fs</code>模块中存在的等效操作，如果它们存在于<code class="fe le lf lg lh b">fs</code> promises API中的话。<code class="fe le lf lg lh b">fs</code> promise API函数返回承诺，因此这让我们更容易地顺序运行异步操作。</p><p id="35b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用<code class="fe le lf lg lh b">fs</code>模块，我们只需像下面这行代码那样要求它:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="0553" class="lq lr it lh b gy ls lt l lu lv">const fs = require('fs');</span></pre><h1 id="cc3d" class="lw lr it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">异步操作</h1><p id="892e" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">文件函数的异步版本接受一个回调，该回调包含一个错误和操作结果作为参数。如果操作成功完成，那么<code class="fe le lf lg lh b">null</code>或<code class="fe le lf lg lh b">undefined</code>将被传入错误参数，这应该是为每个函数传入的回调函数的第一个参数。异步操作不是按顺序执行的。例如，如果我们想删除一个名为<code class="fe le lf lg lh b">file</code>的文件，我们可以写:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="56b4" class="lq lr it lh b gy ls lt l lu lv">const fs = require('fs');<br/><br/>fs.unlink('/file', (err) =&gt; {<br/>  if (err) throw err;<br/>  console.log('successfully deleted file');<br/>});</span></pre><p id="804a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有<code class="fe le lf lg lh b">err</code>参数，如果它存在就有错误数据，如果发生错误就有错误数据。异步操作不是按顺序完成的，要按顺序完成多个操作，我们可以将它转换为一个承诺，或者将操作嵌套在前面操作的回调函数中。例如，如果我们要重命名一个文件，然后检查该文件是否存在，我们可以不应该编写以下内容:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="687c" class="lq lr it lh b gy ls lt l lu lv">fs.rename('/file1', '/file2', (err) =&gt; {<br/>  if (err) throw err;<br/>  console.log('renamed complete');<br/>});<br/>fs.stat('/file1', (err, stats) =&gt; {<br/>  if (err) throw err;<br/>  console.log(stats);<br/>});</span></pre><p id="c7b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为它们不能保证按顺序运行。因此，我们应该改为写:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="f4db" class="lq lr it lh b gy ls lt l lu lv">fs.rename('./file1', './file2', (err) =&gt; {<br/>  if (err) throw err;<br/>  console.log('renamed complete');</span><span id="b1db" class="lq lr it lh b gy my lt l lu lv">  fs.stat('./file2', (err, stats) =&gt; {<br/>    if (err) throw err;<br/>    console.log(stats);<br/>  })<br/>;});</span></pre><p id="7a47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果我们想顺序地做很多操作，这就变得很麻烦了。如果我们有多个文件操作，我们有太多的回调函数嵌套。过多的回调函数嵌套被称为回调地狱，它使得阅读和调试代码变得非常困难和混乱。因此，我们应该使用类似承诺的东西来执行异步操作。例如，我们应该用下面的代码重写上面的例子:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="4f04" class="lq lr it lh b gy ls lt l lu lv">const fsPromises = require("fs").promises;</span><span id="17e1" class="lq lr it lh b gy my lt l lu lv">(async () =&gt; {<br/>  try {<br/>    await fsPromises.rename("./files/file1.txt", "./files/file2.txt");<br/>    const stats = await fsPromises.stat("./files/file2.txt");<br/>    console.log(stats);<br/>  } catch (error) {<br/>    console.log(error);<br/>  }<br/>})();</span></pre><p id="f585" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用了<code class="fe le lf lg lh b">fs</code> promises API，它具有返回承诺的文件操作函数。这要干净得多，并且利用了<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>链接承诺的语法。注意，<code class="fe le lf lg lh b">fs</code> promises API有一个警告，说它是实验性的。</p><p id="04b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，到目前为止，它非常稳定，对于需要链接多个文件操作的基本文件操作来说，它很好。注意，我们正在用<code class="fe le lf lg lh b">try...catch</code>块捕捉错误。<code class="fe le lf lg lh b">async</code>函数看起来像同步函数，但只能返回承诺。</p><p id="6b9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的每个示例都将输出如下内容:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="ec50" class="lq lr it lh b gy ls lt l lu lv">Stats {<br/>  dev: 3605029386,<br/>  mode: 33206,<br/>  nlink: 1,<br/>  uid: 0,<br/>  gid: 0,<br/>  rdev: 0,<br/>  blksize: undefined,<br/>  ino: 6192449489177455,<br/>  size: 0,<br/>  blocks: undefined,<br/>  atimeMs: 1572568634188,<br/>  mtimeMs: 1572568838068,<br/>  ctimeMs: 1572569087450.1968,<br/>  birthtimeMs: 1572568634187.734,<br/>  atime: 2019-11-01T00:37:14.188Z,<br/>  mtime: 2019-11-01T00:40:38.068Z,<br/>  ctime: 2019-11-01T00:44:47.450Z,<br/>  birthtime: 2019-11-01T00:37:14.188Z }</span></pre><h1 id="a783" class="lw lr it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">同步操作</h1><p id="d9b4" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">同步文件操作通常在名字的末尾有单词<code class="fe le lf lg lh b">Sync</code>并且被逐行调用。我们得到了<code class="fe le lf lg lh b">try...catch</code>块的错误。如果我们把上面的例子重写为一个同步操作，我们可以写成:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="0267" class="lq lr it lh b gy ls lt l lu lv">const fs = require('fs');<br/><br/>try {<br/>  fs.unlinkSync('./files/file1.txt');<br/>  console.log('successfully deleted ./files/file1.txt');<br/>} catch (err) {<br/>  console.err(err);<br/>}</span></pre><p id="8ae8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到与<code class="fe le lf lg lh b">catch</code>子句绑定的<code class="fe le lf lg lh b">err</code>来获得错误数据。Node.js中同步操作的问题是，它会在进程完成之前一直占用处理器，这使得长时间的资源密集型操作会挂起计算机。因此，它降低了程序的执行速度。</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/21c46bd802cb4a307abbebf614f23888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OsLRGaVkpA-SiSsw"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@lili_popper?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Lili Popper </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="d574" class="lw lr it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">文件路径</h1><p id="c45d" class="pw-post-body-paragraph kg kh it ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">大多数文件操作函数使用<code class="fe le lf lg lh b">file:</code>协议接受字符串、缓冲区或URL对象形式的路径。字符串路径被解释为UTF-8字符序列，用于标识文件或文件夹的绝对或相对路径。</p><p id="a000" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相对路径是相对于当前工作目录解析的，当前工作目录是由<code class="fe le lf lg lh b">process.cwd()</code>函数返回的。例如，我们可以用相对路径打开一个文件，如下面的代码所示:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="59f2" class="lq lr it lh b gy ls lt l lu lv">const fs = require("fs");</span><span id="67c4" class="lq lr it lh b gy my lt l lu lv">fs.open("./files/file.txt", "r", (err, fd) =&gt; {<br/>  if (err) throw err;<br/>  fs.close(fd, err =&gt; {<br/>    if (err) throw err;<br/>  });<br/>});</span></pre><p id="ea97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个斜杠前面的点表示相对路径的当前工作目录。或者使用promise API，我们可以将其重写为以下代码:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="8555" class="lq lr it lh b gy ls lt l lu lv">(async () =&gt; {<br/>  try {<br/>    const fileHandle = await fsPromises.open("./files/file.txt", "r");<br/>    console.log(fileHandle);<br/>  } catch (error) {<br/>    console.log(error);<br/>  }<br/>})();</span></pre><p id="39ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，promise API没有<code class="fe le lf lg lh b">close</code>函数。常规的<code class="fe le lf lg lh b">fs</code> API将文件操作许可标志作为第二个参数。<code class="fe le lf lg lh b">r</code>代表只读。</p><p id="15d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">fs</code> promise API有一个<code class="fe le lf lg lh b">open</code>函数，你可以得到<code class="fe le lf lg lh b">fd</code>对象，它代表文件描述符，是对我们打开的文件的引用。我们可以通过传递文件描述符<code class="fe le lf lg lh b">fd</code>来调用<code class="fe le lf lg lh b">close</code>函数。</p><p id="52d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">fs</code> promise API没有这个，所以文件不能用promise API关闭。</p><p id="faf1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">fs</code> API也接受一个URL对象作为文件位置的引用。它必须有<code class="fe le lf lg lh b">file:</code>协议，并且它们必须是绝对路径。例如，我们可以创建一个URL对象，并将其传递给<code class="fe le lf lg lh b">read</code>函数来读取文件。为此，我们可以编写以下代码:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="77d6" class="lq lr it lh b gy ls lt l lu lv">const fs = require("fs");<br/>const fileUrl = new URL(`file://${__dirname}/files/file.txt`);</span><span id="6b16" class="lq lr it lh b gy my lt l lu lv">fs.open(fileUrl, "r", (err, fd) =&gt; {<br/>  if (err) throw err;<br/>  fs.close(fd, err =&gt; {<br/>    if (err) throw err;<br/>  });<br/>});</span></pre><p id="7546" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它做的事情和使用相对路径完全一样。只是稍微复杂一点，因为我们必须获得URL对象，并用<code class="fe le lf lg lh b">__dirname</code>对象获得代码的当前目录。在Windows上，任何带有主机名的路径都被解释为UNC路径，UNC路径是通过局域网或互联网访问文件的路径。例如，如果我们有以下内容:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="13e6" class="lq lr it lh b gy ls lt l lu lv">fs.readFileSync(new URL('file://hostname/path/to/file'));</span></pre><p id="7b39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么这将被解释为使用主机名<code class="fe le lf lg lh b">hostname</code>访问服务器上的文件。</p><p id="2315" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Windows上，任何包含驱动器号的文件URL都将被解释为绝对路径。例如，如果我们有以下路径:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="66d8" class="lq lr it lh b gy ls lt l lu lv">fs.readFileSync(new URL('file://c:/path/to/file'));</span></pre><p id="041c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后它会尝试访问<code class="fe le lf lg lh b">c:\path\to\file</code>路径中的文件。任何没有主机名的文件都必须有驱动器号。因此，只有与上述格式相同的文件路径才是Windows上URL对象的有效文件路径。以驱动器号开头的路径必须在驱动器号后有一个冒号。在所有其他平台上，<code class="fe le lf lg lh b">file:</code>带主机名的URL不受支持，像<code class="fe le lf lg lh b">fs.readFileSync(new URL('file://hostname/path/to/file'));</code>这样的文件路径会抛出错误。</p><p id="9347" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何带有转义斜杠字符的<code class="fe le lf lg lh b">file:</code> URL都将在所有平台上抛出错误，因此下面的任何例子都将是无效的并抛出错误。在Windows上，这些示例会引发错误:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="5fb6" class="lq lr it lh b gy ls lt l lu lv">fs.readFileSync(new URL('file:///C:/path/%2F'));<br/>fs.readFileSync(new URL('file:///C:/path/%2f'));</span></pre><p id="ed33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在POSIX系统上，这些会失败:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="6d3c" class="lq lr it lh b gy ls lt l lu lv">fs.readFileSync(new URL('file:///pathh/%2F'));<br/>fs.readFileSync(new URL('file:///path/%2f'));</span></pre><p id="10ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Windows上，带有编码反斜杠字符的文件URL将引发错误，因此以下示例无效:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="7659" class="lq lr it lh b gy ls lt l lu lv">fs.readFileSync(new URL('file:///D:/path/%5C'));<br/>fs.readFileSync(new URL('file:///D:/path/%5c'));</span></pre><p id="e814" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在POSIX系统上，内核为每个进程维护一个打开的文件和资源列表。每个打开的文件都被分配一个简单的数字标识符，称为文件描述符。</p><p id="1bf9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">操作系统使用文件描述来识别和跟踪每个特定的文件。在Windows上，跟踪文件使用类似的机制，文件描述符仍然用于跟踪由各种进程打开的文件和资源。</p><p id="fdf6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js负责将文件描述符分配给资源，因此我们不必手动完成这项工作。这对于清理打开的资源很方便。</p><p id="d329" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Node.js中，<code class="fe le lf lg lh b">fs.open()</code>函数用于打开文件，并为打开的文件分配一个新的文件描述符。处理完成后，可以通过<code class="fe le lf lg lh b">close</code>函数关闭它，以便关闭和清理开放的资源。这可以像下面的代码一样使用:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="381a" class="lq lr it lh b gy ls lt l lu lv">const fs = require("fs");</span><span id="9fa6" class="lq lr it lh b gy my lt l lu lv">fs.open("./files/file.txt", "r", (err, fd) =&gt; {<br/>  if (err) throw err;<br/>  console.log(fd);<br/>  fs.fstat(fd, (err, stat) =&gt; {<br/>    if (err) throw err;<br/>    console.log("Stat", stat);</span><span id="3706" class="lq lr it lh b gy my lt l lu lv">  fs.close(fd, err =&gt; {<br/>      if (err) throw err;<br/>      console.log('Closed');<br/>    });<br/>  });<br/>});</span></pre><p id="fe4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，我们会得到类似如下的输出:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="2f32" class="lq lr it lh b gy ls lt l lu lv">3<br/>Stat Stats {<br/>  dev: 3605029386,<br/>  mode: 33206,<br/>  nlink: 1,<br/>  uid: 0,<br/>  gid: 0,<br/>  rdev: 0,<br/>  blksize: undefined,<br/>  ino: 22799473115106240,<br/>  size: 0,<br/>  blocks: undefined,<br/>  atimeMs: 1572569358035.625,<br/>  mtimeMs: 1572569358035.625,<br/>  ctimeMs: 1572569358035.625,<br/>  birthtimeMs: 1572569358035.625,<br/>  atime: 2019-11-01T00:49:18.036Z,<br/>  mtime: 2019-11-01T00:49:18.036Z,<br/>  ctime: 2019-11-01T00:49:18.036Z,<br/>  birthtime: 2019-11-01T00:49:18.036Z }<br/>Closed</span></pre><p id="218b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用<code class="fe le lf lg lh b">open</code>函数打开了文件，该函数在回调函数中提供了包含文件描述符的<code class="fe le lf lg lh b">fd</code>对象，我们可以用它来用<code class="fe le lf lg lh b">fstat</code>函数获取文件的信息。完成后，我们可以用<code class="fe le lf lg lh b">close</code>函数关闭打开的文件资源。</p><p id="6832" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们完成了文件打开操作，读取了文件元数据，然后用<code class="fe le lf lg lh b">close</code>函数关闭了文件。</p><p id="5815" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">promise API没有<code class="fe le lf lg lh b">fstat</code>或<code class="fe le lf lg lh b">close</code>函数，所以我们不能用它做同样的事情。</p><p id="a94f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js运行时平台的标准库中内置了一个<code class="fe le lf lg lh b">fs</code>模块。它有许多功能，可以帮助操纵文件和文件夹。</p><p id="8ae7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">支持的文件和文件夹操作包括基本的操作，如操作和打开目录中的文件。</p><p id="9ded" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，它也可以对文件做同样的事情。它可以同步和异步地做到这一点。它有一个异步API，该API具有支持承诺的功能。</p><p id="9ae1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它还可以显示文件的统计数据。几乎所有我们能想到的文件操作都可以用内置的<code class="fe le lf lg lh b">fs</code>模块来完成。在本文中，我们将介绍<code class="fe le lf lg lh b">fs</code>模块，以及如何构造可用于打开文件的路径，并使用它打开文件。</p><p id="278d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还将尝试使用<code class="fe le lf lg lh b">fs</code> promises API来执行常规<code class="fe le lf lg lh b">fs</code>模块中存在的等效操作，如果它们存在于<code class="fe le lf lg lh b">fs</code> promises API中的话。</p><p id="8d5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">fs</code> promise API函数返回承诺，因此这让我们更容易地顺序运行异步操作。我们仅仅触及了表面，所以请继续关注本系列的第2部分。</p></div></div>    
</body>
</html>