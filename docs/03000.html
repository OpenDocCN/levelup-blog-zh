<html>
<head>
<title>Feistel Cypher for the Money Heist Gang (Netflix) Implementation in Ionic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Feistel Cypher为金钱抢劫团伙(网飞)在爱奥尼亚实施</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/feistel-cypher-for-the-money-heist-gang-netflix-implementation-in-ionic-8b91747523db?source=collection_archive---------16-----------------------#2020-04-14">https://levelup.gitconnected.com/feistel-cypher-for-the-money-heist-gang-netflix-implementation-in-ionic-8b91747523db?source=collection_archive---------16-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5122" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这段不确定的全球隔离期间，我花了很多时间在网飞。有一个系列引起了我的注意——一个非常棒的系列，叫做《金钱大劫案》,最初它的西班牙名字是:<em class="ko"> Le Casa de Papel </em>(纸之屋)。在第三季的中间，有一句台词，其中一个角色，巴勒莫(顺便说一下，所有的小偷都是以城市命名的)，拿出一个旧的1941年的timey短波无线电通信器和一个计算机编码器。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi kw"><img src="../Images/aaefc8536bd1ad2b54e608d92f25de74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DCIpQsIqIduNk9ftxkztsQ.jpeg"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">由<a class="ae lm" href="https://unsplash.com/@samuelegiglio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Samuele Giglio </a>在<a class="ae lm" href="https://unsplash.com/s/photos/money-heist?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="7c3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Palermo继续解释说，通信将使用2300层加密进行加密，并将继续添加2300层加密，等等。这将是几乎不可能破解的“…即使有超过1亿的程序员在工作…”。</p><p id="562c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑一种高效完成“2300层加密”的方法，在我看来，最合适、最高效的方法是使用Feistel cypher方法，而不是普通的AES 256。这是因为机器，计算机编码器看起来过时了，可能是从20世纪70年代开始的，当然，因为这是最容易开发的方法，在我假设的很短的时间内。</p><h1 id="00d4" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">为什么？</strong></h1><p id="e520" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">Feistel密码是一种非常有趣的加密方法，它形成了许多其他加密技术的基础并为其进行了修改。Feistel cypher本身在20世纪70年代到21世纪初是一种加密标准。Feistel的修改版本仍然存在，并一直使用到21世纪初，直到后来在2001年被现在著名的高级加密标准(AES)取代。</p><p id="cde6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我跑题了。如果你想一想巴勒莫想要什么，我们这里想要什么，我们打算做什么，基本上就是一种加密2300层深的数据块的方法，Feistel方法就是为此而建立的，因为在Feistel方法中，你需要定义层数，以将你想要的消息“洗”成混乱的乱码，然后发送出去。</p><p id="ff07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Feistel cypher最酷的一点是，该方法可以根据定义的层数进行反转，也就是说，根据您定义的层数，当然还有用于将模糊消息转换回原始预期消息的源/令牌，您可以恢复原始消息。</p><p id="d427" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单。</p><h1 id="30d1" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">Feistel方法是谁想出来的？</h1><p id="7b97" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">Feistel密码或Feistel网络是以德国出生的物理学家和密码学家Horst Feistel的名字命名的，他在IBM工作时进行了开创性的研究。该方法是最早使用块加密的方法之一，这在20世纪70年代并不常见。Feistel的酷之处在于，您可以根据已定义的层数反转密钥计划，从而以非常相似的方法进行加密和解密。</p><p id="36d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要了解更多关于Feistel的信息，这里有一个关于它的wiki页面:</p><div class="mq mr gp gr ms mt"><a href="https://en.wikipedia.org/wiki/Feistel_cipher" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd iu gy z fp my fr fs mz fu fw is bi translated">费斯特尔密码</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">在密码学中，Feistel密码是一种用于构造分组密码的对称结构，以…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">en.wikipedia.org</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh lg mt"/></div></div></a></div><p id="b6b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个来自Computerphile的视频，我觉得它是由Mike Pound博士对Feistel的一个非常容易理解的解释。</p><p id="861d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">推特:@_mikepound </strong></p><div class="mq mr gp gr ms mt"><a href="https://twitter.com/_mikepound" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd iu gy z fp my fr fs mz fu fw is bi translated">迈克·庞德</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">迈克庞德的最新推文(@_mikepound)。诺丁汉大学计算机科学讲师和研究员…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">twitter.com</p></div></div><div class="nc l"><div class="ni l ne nf ng nc nh lg mt"/></div></div></a></div><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="62bb" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">按照帕勒莫的建议和爱奥尼亚一起做加密应用ala Money Heist】</strong></h1><p id="59af" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">虽然有可能将这款应用程序变成一款发送语音和文本的合适的通信应用程序，也有可能开始实现巴勒莫的原始想法，即每次发送语音时都添加一层又一层的加密，但这里有几个注意事项会让这款应用程序有点不同:</p><ol class=""><li id="7b16" class="nl nm it js b jt ju jx jy kb nn kf no kj np kn nq nr ns nt bi translated">该应用程序将只加密和解密的基础上，原来的2300层的想法使用Feistel。就是这样。我不是在构建一个通信应用程序，虽然它可以被修改来这样做。</li><li id="c108" class="nl nm it js b jt nu jx nv kb nw kf nx kj ny kn nq nr ns nt bi translated">这个应用程序不会在额外的加密层上添加额外的层，但如果需要的话，可以在以后完成。我可以在这里做，但我不想编写复杂的代码。我只想说明一个想法。</li><li id="bcb2" class="nl nm it js b jt nu jx nv kb nw kf nx kj ny kn nq nr ns nt bi translated">这个应用程序不是用来作为一个通讯应用程序，只是为了好玩来说明一个想法。我不是在建一个通讯app。还是那句话，这只是为了说明一个想法。</li><li id="28bd" class="nl nm it js b jt nu jx nv kb nw kf nx kj ny kn nq nr ns nt bi translated">最后，我不是达利帮的成员，是吗？</li></ol><h1 id="384a" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">第一步:构建Ionic应用</strong></h1><p id="fce5" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">首先，我们启动一个Ionic应用程序。如果你对Ionic不熟悉，我建议在我们开始之前先阅读一下关于Ionic的内容。Ionic是一个在多个平台上开发移动应用程序的框架，使用HTML、TypeScript和CSS中已经掌握的技能很容易。要了解如何启动Ionic项目的更多信息，请点击此处进一步探索:</p><div class="mq mr gp gr ms mt"><a href="https://www.ionicframework.com" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd iu gy z fp my fr fs mz fu fw is bi translated">Ionic -跨平台移动应用开发</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">Ionic是面向web开发者的应用开发平台。构建令人惊叹的跨平台移动、web和桌面应用程序…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">www.ionicframework.com</p></div></div><div class="nc l"><div class="nz l ne nf ng nc nh lg mt"/></div></div></a></div><p id="9ee8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在撰写本文时，Ionic版本是Ionic 5，带有@ionic/cli版本6.5.0。我将使用的离子方法是角方法，而不是反应方法，因为我非常熟悉角方法。</p><p id="447a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我已经包含了电容器版本2.0，所以如果我决定把这个离子项目变成一个应用程序，我可能会使用电容器。</p><h1 id="c085" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">第二步:安装Feistel </strong></h1><p id="0bb6" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">要将Feistel Cipher安装到您的应用程序中，您可以使用已经可用的NPM库:</p><div class="mq mr gp gr ms mt"><a href="https://www.npmjs.com/package/feistel-cipher" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd iu gy z fp my fr fs mz fu fw is bi translated">费斯特尔密码</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">这是一个实现Feistel密码的类型脚本库，用于“几乎”保留格式的加密。“几乎”…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">www.npmjs.com</p></div></div><div class="nc l"><div class="oa l ne nf ng nc nh lg mt"/></div></div></a></div><p id="afc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您需要做的只是在命令行中键入以下内容:</p><pre class="kx ky kz la gt ob oc od oe aw of bi"><span id="717e" class="og lo it oc b gy oh oi l oj ok">npm install feistel-cipher --save</span></pre><p id="84bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将把<code class="fe ol om on oc b">feistel-cipher</code>库安装到您的应用程序中，然后您就可以在您的应用程序中使用Feistel密码方法了。</p><p id="d325" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，实际上，我确实遇到了一些问题…</p><h1 id="503a" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">第三步:修复全局和缓冲区问题</strong></h1><p id="2d99" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">有三个问题:</p><ol class=""><li id="5af2" class="nl nm it js b jt ju jx jy kb nn kf no kj np kn nq nr ns nt bi translated"><code class="fe ol om on oc b">globals is not defined ....blablabla</code></li><li id="093b" class="nl nm it js b jt nu jx nv kb nw kf nx kj ny kn nq nr ns nt bi translated"><code class="fe ol om on oc b">buffer is not defined ....blablabla</code></li></ol><p id="f347" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.<code class="fe ol om on oc b">process is not defined ….blablabla</code></p><p id="b949" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要解决这些问题，您需要在命令行中键入以下内容:</p><p id="de34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ol om on oc b">npm install ts-polyfill --save</code></p><p id="9669" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这应该会将您的TypeScript的polyfill安装到应用程序中。在我继续之前，如果您想了解更多关于polyfill的信息，我不打算在这里解释，但我建议您在这里了解更多信息:</p><div class="mq mr gp gr ms mt"><a href="https://polyfill.io/v3/" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd iu gy z fp my fr fs mz fu fw is bi translated">Polyfill.io</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">Polyfill.io</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">聚合填充</p></div></div></div></a></div><p id="a16c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装polyfill后。你需要在你的应用程序中安装<code class="fe ol om on oc b">process</code> NPM库。您可以通过执行以下操作来实现这一点:</p><pre class="kx ky kz la gt ob oc od oe aw of bi"><span id="df00" class="og lo it oc b gy oh oi l oj ok">npm install process --save</span></pre><p id="5fba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将把过程库安装到您的Ionic应用程序中。然后，您需要修改以下文件:</p><p id="e7a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">A.添加到<code class="fe ol om on oc b">index.html</code>的头部，固定<code class="fe ol om on oc b">global is not defined...bla bla bla</code></p><pre class="kx ky kz la gt ob oc od oe aw of bi"><span id="d739" class="og lo it oc b gy oh oi l oj ok">&lt;script&gt;<br/>  if (global === undefined) {<br/>    var global = window;<br/>  }</span><span id="3d0c" class="og lo it oc b gy oo oi l oj ok">&lt;/script&gt;</span></pre><p id="74a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">B.添加到<code class="fe ol om on oc b">app.component.ts</code>内的导入行，修复<code class="fe ol om on oc b">buffer is not defined…bla bla bla</code></p><pre class="kx ky kz la gt ob oc od oe aw of bi"><span id="ae4a" class="og lo it oc b gy oh oi l oj ok">import('buffer').then(({Buffer}) =&gt; {global.Buffer = Buffer;})</span></pre><p id="0842" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">C.添加到<code class="fe ol om on oc b">polyfills.ts</code>中，以固定<code class="fe ol om on oc b">process id not defined …bla bla bla</code></p><pre class="kx ky kz la gt ob oc od oe aw of bi"><span id="ce53" class="og lo it oc b gy oh oi l oj ok">import * as process from 'process';<br/> window['process'] = process;</span></pre><p id="2b1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们开始写任何东西之前，你应该能够没有任何错误地运行<code class="fe ol om on oc b">ionic serve </code>。</p><h1 id="dc1e" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">第四步:编写加密和解密的函数</strong></h1><p id="ab1c" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">接下来的步骤是编写函数。我将在我的<code class="fe ol om on oc b">home.page.html</code>和<code class="fe ol om on oc b">home.page.ts</code>中构建它，但是当然，你可以在服务或组件中的其他地方处理它，这可能取决于你的需求。</p><p id="6c32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以要编写<code class="fe ol om on oc b">encrypt</code>和<code class="fe ol om on oc b">decrypt</code>函数:</p><pre class="kx ky kz la gt ob oc od oe aw of bi"><span id="69c2" class="og lo it oc b gy oh oi l oj ok">import * as feistel from 'feistel-cipher';<br/></span><span id="c2c9" class="og lo it oc b gy oo oi l oj ok">...</span><span id="80e4" class="og lo it oc b gy oo oi l oj ok">encryptedData:any;<br/>messageData:any</span><span id="3d4a" class="og lo it oc b gy oo oi l oj ok">async encryptData()<br/> {<br/>    const cipher= await new feistel.Cipher('ciao bella',2300);<br/>    const obfuscated=await cipher.encrypt(this.messageData);</span><span id="99ad" class="og lo it oc b gy oo oi l oj ok">    this.encryptedData=await obfuscated;<br/> }</span><span id="ed3e" class="og lo it oc b gy oo oi l oj ok">async decryptData()<br/>  {<br/>    const cipher= await new feistel.Cipher('ciao bella',2300);<br/>    const deciphered=await cipher.decrypt(this.encryptedData);</span><span id="e4d3" class="og lo it oc b gy oo oi l oj ok">    this.messageData=await deciphered;<br/>  }</span></pre><p id="ddd9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不要忘记导入上面第一行所示的<code class="fe ol om on oc b">feistel-cipher</code> NPM库。如果您注意到，单词<code class="fe ol om on oc b">ciao bella</code>并不是实际的消息，而是将用作加密种子的令牌。你可以把它变成你想要的任何东西。实际消息在<code class="fe ol om on oc b">this.messageData</code>里。</p><p id="1952" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的函数将加密和解密2300层，如巴勒莫所要求的。</p><p id="ecca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来就是用<code class="fe ol om on oc b">home.page.html</code> <em class="ko">搭建一个简单的接口。</em>更改和添加用下面的<strong class="js iu">粗体</strong>标记:</p><pre class="kx ky kz la gt ob oc od oe aw of bi"><span id="dfbf" class="og lo it oc b gy oh oi l oj ok">&lt;ion-header [translucent]="true"&gt;<br/>  &lt;ion-toolbar&gt;<br/>    &lt;ion-title&gt;<br/>      <strong class="oc iu">Encrypt/Decrypt</strong><br/>    &lt;/ion-title&gt;<br/>  &lt;/ion-toolbar&gt;<br/>&lt;/ion-header&gt;</span><span id="c118" class="og lo it oc b gy oo oi l oj ok">&lt;ion-content [fullscreen]="true"&gt;</span><span id="0156" class="og lo it oc b gy oo oi l oj ok">  <strong class="oc iu">&lt;ion-list&gt;<br/>    &lt;ion-item&gt;<br/>      &lt;ion-input<br/>      [(ngModel)]="messageData"<br/>      type="text"<br/>      placeholder="MESSAGE TEXT"&gt;<br/>      &lt;/ion-input&gt;<br/>    &lt;/ion-item&gt;<br/>    &lt;ion-item&gt;<br/>      &lt;ion-input<br/>      [(ngModel)]="encryptedData"<br/>      type="text"<br/>      placeholder="ENCRYPTED"&gt;<br/>      &lt;/ion-input&gt;<br/>    &lt;/ion-item&gt;<br/>  &lt;/ion-list&gt;<br/>  &lt;ion-grid&gt;<br/>  &lt;ion-row&gt;<br/>    &lt;ion-col size="6"&gt;<br/>      &lt;ion-button expand="full" color="danger" (click)="encryptData()"&gt;<br/>        ENCRYPT<br/>      &lt;/ion-button&gt;<br/>    &lt;/ion-col&gt;<br/>    &lt;ion-col size="6"&gt;<br/>      &lt;ion-button expand="full" color="dark" (click)="decryptData()"&gt;<br/>        DECRYPT<br/>      &lt;/ion-button&gt;<br/>    &lt;/ion-col&gt;<br/>  &lt;/ion-row&gt;<br/>  &lt;/ion-grid&gt;</strong></span><span id="3193" class="og lo it oc b gy oo oi l oj ok">&lt;/ion-content&gt;</span></pre><p id="1b98" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个如下所示的应用程序:</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi op"><img src="../Images/65da2431cbbe8ba6babc003294e04321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4N2T1UjEPiOcJbynYpNBw.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">加密/解密应用程序</figcaption></figure><h1 id="1ffe" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">就是这样！</strong></h1><p id="52b9" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">看完这篇文章，你现在是大理帮的一员了…如果你能构建上述应用程序，请查看以下秘密消息:</p><p id="621a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ol om on oc b">2u+pz:s(+”pq!g”/yj`~300/2t5h2yk| TTL Z2</code></p><p id="92fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">再见，再见，再见！再见。再见。</p></div></div>    
</body>
</html>