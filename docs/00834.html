<html>
<head>
<title>Simplify Redux Reducers with Lenses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带透镜的简化Redux减压器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simplify-redux-reducers-with-lenses-8ec6b2de3ae2?source=collection_archive---------0-----------------------#2019-08-18">https://levelup.gitconnected.com/simplify-redux-reducers-with-lenses-8ec6b2de3ae2?source=collection_archive---------0-----------------------#2019-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7d50e9f58a0fd0c6735c9afa344b6d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ym8JOmgcQXdqSQS_Lo-KrA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">让我们做一些清理工作；)</figcaption></figure><div class=""/><blockquote class="kc kd ke"><p id="6a46" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">请禁用您的广告拦截器/隐私獾。否则示例代码将被禁用…</p></blockquote><p id="0681" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ij bi translated">现代JavaScript环境有许多处理状态的方法。我们可以使用闭包或类来拥有一些共享状态，但是有时需要一个更复杂的状态管理库。一个流行的选择是Redux模式。</p><h1 id="da4e" class="lh li jf bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Redux 101</h1><p id="45e3" class="pw-post-body-paragraph kf kg jf ki b kj mf kl km kn mg kp kq le mh kt ku lf mi kx ky lg mj lb lc ld ij bi translated">如果你熟悉Redux，你可以跳过这一步，但是简单回顾一下，这里有一个Redux是什么的概述。<br/> <strong class="ki jg">属性</strong></p><ul class=""><li id="c5c2" class="mk ml jf ki b kj kk kn ko le mm lf mn lg mo ld mp mq mr ms bi translated">有一个状态对象</li><li id="a757" class="mk ml jf ki b kj mt kn mu le mv lf mw lg mx ld mp mq mr ms bi translated">状态对象是不可变的</li><li id="0454" class="mk ml jf ki b kj mt kn mu le mv lf mw lg mx ld mp mq mr ms bi translated">每一次改变都会产生状态对象新版本</li><li id="9a65" class="mk ml jf ki b kj mt kn mu le mv lf mw lg mx ld mp mq mr ms bi translated">通过调度操作发生变化，导致下面的流程</li></ul><p id="0b43" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ij bi translated"><strong class="ki jg">流(在使用thunk的场景中)</strong></p><ul class=""><li id="26cb" class="mk ml jf ki b kj kk kn ko le mm lf mn lg mo ld mp mq mr ms bi translated">用户点击按钮</li><li id="3415" class="mk ml jf ki b kj mt kn mu le mv lf mw lg mx ld mp mq mr ms bi translated">一个动作被分派。一个动作是一个包含一个<code class="fe my mz na nb b">type</code>和<code class="fe my mz na nb b">data</code>的普通对象。</li><li id="a8da" class="mk ml jf ki b kj mt kn mu le mv lf mw lg mx ld mp mq mr ms bi translated">中间件监听该动作并发出异步请求。让我们假设它成功了，然后它将分派另一个动作(<code class="fe my mz na nb b">{type: LOGIN_SUCCESS, data: {accessToken: x, refreshToken: y}}</code>)</li><li id="1f22" class="mk ml jf ki b kj mt kn mu le mv lf mw lg mx ld mp mq mr ms bi translated">缩减器监听该动作，并将旧状态缩减为新版本的状态。(<code class="fe my mz na nb b">(state, action) =&gt; ({…state, someNewStateValues })</code>)</li><li id="422c" class="mk ml jf ki b kj mt kn mu le mv lf mw lg mx ld mp mq mr ms bi translated">状态被更新，并且组件可以用新状态重新呈现。</li></ul><p id="7661" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ij bi translated">Redux最好的一点是，它使得推断状态变得非常容易，因为所有的更改都必须经过这些步骤。然而，最大的缺点是这需要相当多的样板文件。创建<code class="fe my mz na nb b">actions</code>和<code class="fe my mz na nb b">reducers</code>会有很多工作，更不用说大部分UI状态现在应该包含在那个对象中了。因此，即使像复选框或开关这样的东西也需要经过那里，而不仅仅是在本地或服务中改变一个变量。</p><h1 id="b728" class="lh li jf bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">问题是</h1><p id="12ac" class="pw-post-body-paragraph kf kg jf ki b kj mf kl km kn mg kp kq le mh kt ku lf mi kx ky lg mj lb lc ld ij bi translated">如上所述，整个Redux设置需要大量样板文件。有些可以用<a class="ae nc" href="https://redux.js.org/recipes/reducing-boilerplate" rel="noopener ugc nofollow" target="_blank"> redux网站</a>上的指针还原。但是有一些东西可以进一步减少它(并在这个过程中使它变得更加清晰)。<br/>有时，状态对象变得非常嵌套。以这个对象为例，简而言之，它描述了一个包含对象和对象组的3d场景。</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2ee3" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ij bi translated">比方说，用户需要能够向场景结构和该结构中的组添加额外的对象。这些减速器可以写成如下形式:</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ed3d" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ij bi translated">虽然这不一定是这段代码的最佳版本(我们可以使用一些其他的常量使其可读性更好，并使用一些函数来抽象掉一些对象突变)，但还有一些其他的事情需要更棘手地解决。</p><blockquote class="kc kd ke"><p id="d1ac" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">状态的结构越深，我们需要做的保持一切完整的对象传播就越多，代码就越复杂。</p></blockquote><p id="cbf1" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ij bi translated">幸运的是，有一个解决方案。</p><h1 id="fe26" class="lh li jf bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">镜头</h1><blockquote class="kc kd ke"><p id="1371" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ij bi translated">镜头和一些配合使用的功能提供了一种方式:查看值，不变地设置它们，并对它们应用功能。都在一个物体内，在某个路径上。它允许你给镜头一个完整的对象(就像一个状态)并获得完整的对象，但是使用新的值集或应用的函数，无论你想要改变的值嵌套有多深。</p></blockquote><p id="28fd" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ij bi translated">当查看Ramda 的<a class="ae nc" href="https://ramdajs.com/docs/#lens" rel="noopener ugc nofollow" target="_blank">文档时(我们正在使用这个库来实现它的镜头)。有4件事与镜头有关，我们将使用其中的两件，<code class="fe my mz na nb b">lensPath</code>和<code class="fe my mz na nb b">lensProp</code>。<code class="fe my mz na nb b">lensPath</code>功能允许您为嵌套路径创建一个镜头，而<code class="fe my mz na nb b">lensProp</code>功能允许您为特定属性创建一个镜头。另外两个在某些情况下可能有用(尤其是<code class="fe my mz na nb b">lensIndex</code>)，但是一旦你知道了这两个，就不难推断出来。在我们的情况下，让我们为我们的小场景中的那些对象和组制作一个镜头。</a></p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4c64" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ij bi translated">如果你对<code class="fe my mz na nb b">compose</code>有疑问，我已经写了<a class="ae nc" href="https://medium.com/@rolandpeelen/function-composition-currying-in-real-life-e74c86302205" rel="noopener">一篇关于这个的文章</a>。<br/>指定镜头后，我们可以使用三个功能，<code class="fe my mz na nb b">view</code>、<code class="fe my mz na nb b">set</code>和<code class="fe my mz na nb b">over</code>。这些允许您分别查看给定对象在镜头路径上的值，设置值，或对该值运行函数。像这样:</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8754" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ij bi translated">最好的事情是，我们不必手动传播对象！还有，<code class="fe my mz na nb b">over</code>功能让它变得无比强大。所以让我们用透镜重写我们早期的减速器。</p><figure class="nd ne nf ng gt is"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3854" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq le ks kt ku lf kw kx ky lg la lb lc ld ij bi translated">通过将<code class="fe my mz na nb b">append</code>功能分解成一个函数，这样我们就可以使用<code class="fe my mz na nb b">over</code>，我们已经能够将实际的缩减器本身减少到一行！当然，现在有一些镜头需要定义，但这意味着实际reducer的switch语句(或lookup对象)要简单得多。镜头甚至可以从单独的文件中导入。在第二个例子中，使用多个<code class="fe my mz na nb b">lensProps</code>并组合它们的想法变得清晰了。在<code class="fe my mz na nb b">groups</code>中，有<code class="fe my mz na nb b">objects</code>，因为我们有<code class="fe my mz na nb b">lensProp</code>用于<code class="fe my mz na nb b">objects</code>，我们可以在那里重用它。</p><h1 id="cda5" class="lh li jf bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结束的</h1><p id="0fc1" class="pw-post-body-paragraph kf kg jf ki b kj mf kl km kn mg kp kq le mh kt ku lf mi kx ky lg mj lb lc ld ij bi translated">是的，redux有一定的开销。尤其是在存在极度嵌套状态的情况下。当然，在某些情况下，尽量避免这种嵌套更好。在其他情况下，没有嵌套实际上可能会使推理对象变得更加困难。在这些情况下，使用透镜可能是有益的。</p></div></div>    
</body>
</html>