<html>
<head>
<title>DRY Principle in Your AWS SAM Application with Middlewares</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的AWS SAM应用中的DRY原则与中间件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dry-principle-in-your-aws-sam-application-with-middlewares-b013fc294727?source=collection_archive---------9-----------------------#2021-11-17">https://levelup.gitconnected.com/dry-principle-in-your-aws-sam-application-with-middlewares-b013fc294727?source=collection_archive---------9-----------------------#2021-11-17</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="3a60" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">让您的lambda架构更上一层楼</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/145fe490bc34d248faeb5ca3899a42ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOLFirS0yJ2s28QpIQu6cA.jpeg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">来自<a class="ae kz" href="https://www.pexels.com/photo/female-software-engineer-coding-on-computer-3861972/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kz" href="https://www.pexels.com/@thisisengineering?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">this is工程</a>摄影</figcaption></figure><p id="8b48" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">AWS Lambda在无服务器领域非常受欢迎。能够编写代码并且不用担心任何基础设施真的很棒。</p><p id="9feb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">AWS SAM(无服务器应用程序模型)是一个只用lambda编写完整后端应用程序的好方法。这个想法是，你只需编写函数并在代码中定义基础设施。</p><p id="29eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是这造成了大量的逻辑重复，因为每个函数都是单独编写的。但是我们能改善我们的建筑吗？让我们来了解一下！</p><h1 id="fec8" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">Lambda的问题</h1><p id="5d61" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">这个世界上没有什么是完美的。和lambda没有什么不同。当我们使用像express这样的后端nodejs框架时，我们可以在一个地方处理一些常见的任务。喜欢</p><ul class=""><li id="9cce" class="mt mu iu lc b ld le lg lh lj mv ln mw lr mx lv my mz na nb bi translated">传入请求验证</li><li id="cb54" class="mt mu iu lc b ld nc lg nd lj ne ln nf lr ng lv my mz na nb bi translated">错误处理</li><li id="f42d" class="mt mu iu lc b ld nc lg nd lj ne ln nf lr ng lv my mz na nb bi translated">记录</li></ul><p id="74ba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是在aws lambda中，我们没有这个特权。我们使用的每个lambda都具有以下结构</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">λ. ts</figcaption></figure><p id="36e8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是重复和无聊的。不如我们找到一种方法来处理这个问题，并改善我们的lambda架构？</p><h1 id="d542" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">Lambda中间件来了</h1><p id="65f3" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">中间件是nodejs程序员非常熟悉的一个概念。基本上，它可以拦截每一个进来的请求。这对于解决共同的问题是完美的。</p><p id="16df" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://dbartholomae.github.io/lambda-middleware/" rel="noopener ugc nofollow" target="_blank"> lambda-middleware </a>是一个中间件集合，可以与您现有的lambda架构一起使用。</p><h1 id="8933" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">使用单一中间件</h1><p id="1021" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">错误处理是任何应用程序的关键部分。我们可以利用已经编写好的错误处理中间件。</p><p id="145a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，安装依赖项。</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="dc4b" class="no lx iu nk b gz np nq l nr ns">npm i @lambda-middleware/errorHandler</span></pre><p id="f6b8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后像下面这样使用这个中间件</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">错误处理程序演示</figcaption></figure><p id="5d15" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用这个中间件使您不必在应用程序中使用任何类型的try/catch块。这是巨大的！</p><h1 id="71ad" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">使用多个中间件</h1><p id="bea8" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">现在，正如你所看到的，只使用一个中间件，我们就改进了代码。假设我们想要引入请求验证。</p><p id="e687" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常在AWS Lambda中，请求体出现在<code class="fe nt nu nv nk b">event.body</code>中。我们通常解析请求，然后手动检查我们想要的参数是否已经到达，如下所示</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div></figure><p id="519c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，如果我们可以做同样的事情，但是以一种更加声明性的方式呢？</p><p id="9e4a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们首先创建一个新的请求类</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div></figure><p id="7040" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个类中，我们使用著名的<a class="ae kz" href="https://github.com/typestack/class-validator" rel="noopener ugc nofollow" target="_blank">类验证器</a>来修饰我们的请求参数。这样，我们将如何使用我们的请求对象和所有东西就更清楚了。</p><p id="ec26" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后安装以下中间件依赖项</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="1ba4" class="no lx iu nk b gz np nq l nr ns">npm i @lambda-middleware/class-validator</span></pre><p id="3453" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后在lambda中使用它，如下所示</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">类验证器演示程序</figcaption></figure><h1 id="6918" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">使用多个中间件</h1><p id="1ea9" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">现在我们已经看到了如何通过引入中间件来改进我们的代码。如果我们想同时使用2个中间件呢？</p><p id="91d5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">嗯，有另一个名为<a class="ae kz" href="https://dbartholomae.github.io/lambda-middleware/packages/compose/" rel="noopener ugc nofollow" target="_blank"> compose </a>的包就是为了做这个。这个想法是我们得到一个名为<code class="fe nt nu nv nk b">composeHandler</code>的函数，并用它来聚合多个lambda中间件。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div></figure><p id="276d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这就是我们如何使用多个中间件。</p><h1 id="3584" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">进一步改善这一点！</h1><p id="e198" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">现在让我们假设你正在编写数百个lambda函数。从代码中，我们仍然可以看到我们在每个中间件内部调用相同的<code class="fe nt nu nv nk b">compose</code>函数。</p><p id="8951" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们能减少吗？让我们首先创建一个将创建lambda函数的效用函数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">createLambdaHandler.ts</figcaption></figure><p id="8e9a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个函数中，我们传递两个东西。第一个参数是由<code class="fe nt nu nv nk b">class-validator</code>使用的lambda的请求主体的类型，第二个参数是lambda的实际业务逻辑。</p><p id="9322" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后我们调用<code class="fe nt nu nv nk b">executeBusinessLogic</code>内部的业务逻辑来调用实际的逻辑并返回响应。</p><p id="9a89" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们可以使用这个函数来创建任何我们想要的lambda，而不需要复制代码。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nh ni l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">应用程序</figcaption></figure><h1 id="e748" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">最后的想法</h1><p id="2776" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">老实说，发现我们可以使用中间件改变了我的游戏。它将代码质量提高到了另一个水平。</p><p id="cc53" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以用这个概念做很多事情。例如，您也可以编写自己的中间件。因为归根结底它们只是函数。所以去吧！</p><p id="2de1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">今天到此为止。祝您愉快！:D</p><p id="a9db" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">通过</strong> <a class="ae kz" href="https://www.linkedin.com/in/56faisal/" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv"> LinkedIn </strong> </a>联系我</p></div></div>    
</body>
</html>