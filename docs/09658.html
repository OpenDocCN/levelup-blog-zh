<html>
<head>
<title>A server-less CI/CD approach for mono-repo micro-frontends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种用于单回购微前端的无服务器CI/CD方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-server-less-ci-cd-approach-for-mono-rep-micro-frontends-e91261bbdf69?source=collection_archive---------5-----------------------#2021-08-31">https://levelup.gitconnected.com/a-server-less-ci-cd-approach-for-mono-rep-micro-frontends-e91261bbdf69?source=collection_archive---------5-----------------------#2021-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e1bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文为AWS中基于GitHub mono-repo的微前端架构提供了一种CI/CD管道方法，利用了一系列AWS无服务器服务，如AWS <a class="ae kl" href="https://aws.amazon.com/codepipeline" rel="noopener ugc nofollow" target="_blank"> CodePipeline </a>、<a class="ae kl" href="https://aws.amazon.com/codebuild" rel="noopener ugc nofollow" target="_blank"> CodeBuild </a>和<a class="ae kl" href="https://aws.amazon.com/codedeploy/" rel="noopener ugc nofollow" target="_blank"> CodeDeploy </a>。</p><p id="be37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">微前端增加了管理基础设施的复杂性，这使得组织必须认真投入时间来支持持续集成(CI)、持续部署(CD)管道和随组织扩展的自动化工具。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/101bfb81866776a912651ac4c249852a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHjJA1RJpWif1UtWcjiD1g.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">用于构建mono repo微前端的CI/CD</figcaption></figure><p id="4efa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">建议的方法为组织提供了一个可扩展的选择，以扩展他们的技术微前端生态系统，保持团队自治，并让他们专注于业务和快速发布周期的早期反馈。</p><p id="b1c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于完整的单一回购客户端微前端架构，也可以查看本文:</p><div class="lc ld gp gr le lf"><a rel="noopener  ugc nofollow" target="_blank" href="/a-complete-aws-architecture-for-module-federated-micro-frontends-a0306ba466e3"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">用于模块联合微前端的完整AWS架构</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">我的下一个系列文章将介绍一个完整的无服务器架构，旨在部署和托管客户端单一报告…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt kw lf"/></div></div></a></div><h1 id="c869" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak">一些背景:单一和多种回购</strong></h1><p id="3601" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">在深入研究这个架构之前，让我们先提一下构建微前端模块的主要方法。</p><ul class=""><li id="a191" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">所有的团队都在一个仓库中工作</li><li id="49e1" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated"><strong class="jp ir"> Poly (multi)-repos: </strong>每个领域特定的微前端都位于自己的存储库中，由单个团队拥有。</li></ul><p id="94be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该PoC将重点关注基于单一回购的实际操作、详细且实用的CI/CD设置，其中主要分支作为管道变更的来源。为了更好的概述和详细的比较，我推荐Luca Mezzalira即将出版的<a class="ae kl" href="https://www.buildingmicrofrontends.com/" rel="noopener ugc nofollow" target="_blank">书</a>。</p><h1 id="29bc" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">体系结构</h1><p id="2e7e" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">该架构基于一个场景，其中一家公司正在mono GitHub存储库上实现微前端，并希望在AWS中实现无服务器的CI/CD管道。</p><p id="eeb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个PoC，mono-repo包含两个微不足道的角度微前端，<em class="nl"> mfe-accounts </em>和<em class="nl"> mfe-payments </em>，尽管这个模型允许您使用任何选择的框架独立编写每个模块:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/1cf5edbd5d38dee75d61fd30025f757a.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*bxYzUMH6TnjmGRwkXgC6GQ.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">单一回购结构</figcaption></figure><p id="4dbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该场景包括一些步骤:</p><ul class=""><li id="2b55" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">开发者将他们的代码推送到GitHub中的主分支，这将通过<a class="ae kl" href="https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks" rel="noopener ugc nofollow" target="_blank"> GitHub webhooks </a>触发一个推事件到负责处理事件的<a class="ae kl" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS API网关</a>。</li><li id="3c6b" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">API网关触发一个<a class="ae kl" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>函数，该函数验证请求，分析事件，并根据受影响的文件，触发文件所属的微前端的管道。</li><li id="ca2a" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">一个或多个管道通过<a class="ae kl" href="https://aws.amazon.com/codepipeline/" rel="noopener ugc nofollow" target="_blank"> AWS CodePipeline </a>、<a class="ae kl" href="https://aws.amazon.com/codebuild/" rel="noopener ugc nofollow" target="_blank"> CodeBuild </a>和<a class="ae kl" href="https://aws.amazon.com/codedeploy/" rel="noopener ugc nofollow" target="_blank"> CodeDeploy </a>开始构建、测试和部署动作。</li><li id="94ff" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">变化可在S3桶和暴露在<a class="ae kl" href="https://aws.amazon.com/cloudfront/" rel="noopener ugc nofollow" target="_blank">云锋</a>分布。</li></ul><p id="b552" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们深入了解一下设置。</p><h1 id="1eea" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">API网关设置</h1><p id="321b" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">GitHub允许通过<a class="ae kl" href="https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks" rel="noopener ugc nofollow" target="_blank"> webhooks </a>设置针对其事件的集成，例如存储库推送，webhooks 向端点发布GitHub事件数据有效载荷。让我们通过API Gateway在AWS中公开一个RESTful API，其中包含一个POST端点，如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/53d23df1cc1ecccdb7f4eaf5b35ff1ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*NqZHmyRKTLt-7k8nCyIcZg.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">创建API网关</figcaption></figure><p id="7411" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的屏幕中，我们使用了一个<a class="ae kl" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html" rel="noopener ugc nofollow" target="_blank"> Lambda集成代理</a>,因为我们关联的“Hello World”Lambda需要访问API网关请求头，以便认证GitHub即将到来的请求。有了API，让我们创建webhook。</p><h1 id="e17e" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">GitHub Webhook设置</h1><p id="ff13" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">一旦在一个阶段中部署了API网关，就该创建GitHub webhook了，(参考这个<a class="ae kl" href="https://docs.github.com/en/github/setting-up-and-managing-your-enterprise/managing-organizations-in-your-enterprise-account/configuring-webhooks-for-organization-events-in-your-enterprise-account" rel="noopener ugc nofollow" target="_blank">直观指南</a>)。<strong class="jp ir"> <em class="nl">重要的</em> </strong>:提供一个秘密来确保我们的Lambda只能接受来自webhook的请求(稍后会详细介绍)。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/0849af354c3fd89a013663c949d1047f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*JQxroMYLlDxW0Rq6rORHuA.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">创建GitHub webhook</figcaption></figure><p id="9ebe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">集成准备好了！将文件推送到存储库将导致Lambda触发“Hello world”消息，这可以在<a class="ae kl" href="https://aws.amazon.com/cloudwatch/" rel="noopener ugc nofollow" target="_blank"> Cloudwatch </a>中的流日志下看到。现在让我们更新Lambda代码，以确保我们支持您的repo中任何微前端的CI/CD。</p><h1 id="fb9c" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">Lambda设置的微前端策略</h1><p id="5099" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">Lambda函数的最终目标是给定一个包含repo commits的GitHub push事件，然后它为任何受影响的微前端触发一个或多个管道。让我们详细看看以下要点:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><ul class=""><li id="a68d" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">首先，Lambda使用crypto模块，通过HMAC256安全检查来验证SHA256请求头，从而只验证来自GitHub webhook的请求。这个检查是基于早先在GitHub webhook中定义的秘密，也存储在AWS Secret Manager中(按照<a class="ae kl" href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/tutorials_basic.html" rel="noopener ugc nofollow" target="_blank">这个教程</a>)。Lambda将通过IAM动作<em class="nl">secrets manager:GetSecretValue</em>以安全的方式访问这个秘密</li><li id="a6db" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">一旦被验证，通过从提交列表中添加/修改和移除的文件中提取微前端的名称，有效载荷被用于推断哪些微前端已经被影响。</li><li id="aa0d" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">如果任何微前端发生了变化，我们在<a class="ae kl" href="https://aws.amazon.com/codepipeline/" rel="noopener ugc nofollow" target="_blank"> AWS代码管道</a>中触发一个新的构建，它将构建和部署微前端。为简单起见，管道的名称与将要构建的微前端相同。AWS SDK客户端库需要IAM角色，以允许<em class="nl">code pipeline:StartPipelineExecution</em>操作访问资源</li></ul><p id="ba4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整体Lambda代码可以在这里看到<a class="ae kl" href="https://github.com/aladevlearning/microfrontends-pipeline/blob/main/aws/lambdas/pipeline-ci/index.js" rel="noopener ugc nofollow" target="_blank">。现在是时候创建管道本身了，这是下一节的一部分。</a></p><h1 id="5bd6" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">代码管道设置</h1><p id="1632" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">在AWS中创建代码管道涉及许多步骤和概念，所以我会尽量保持简单。代码管道有助于自动化发布管道，实现快速可靠的应用和基础设施更新。每个步骤，这里称为<em class="nl">阶段</em>，在所涉及的构建工件上执行动作。我将研究如何:</p><ul class=""><li id="cc21" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">通过选择一些设置来创建管道</li><li id="f50a" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">添加一个源阶段，回答问题“要构建的代码来自哪里？”</li><li id="5c71" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">添加一个构建阶段:“我如何构建你刚才提供的源代码？”</li><li id="3fec" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">添加一个部署阶段:“我如何以及在哪里部署您刚才提供的构建工件？”</li></ul><p id="6d7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要的想法是隔离每个代码管道和代码构建项目，给每个团队灵活性和所有权来管理团队内的过程。类似项目的管道重用和CloudFormation模板等优化超出了范围。</p><h2 id="80ec" class="nq lv iq bd lw nr ns dn ma nt nu dp me jy nv nw mi kc nx ny mm kg nz oa mq ob bi translated">通过选择设置创建管道</h2><p id="9f5f" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">首先，通过提供与建筑物微前端和默认设置相匹配的名称来创建管道，如下所示。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/6ef2dc0324c20f5613c49d535274a4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*S1ImESpU2mpnRv-LVsdoMA.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">创建管道的第一步。</figcaption></figure><h2 id="23ef" class="nq lv iq bd lw nr ns dn ma nt nu dp me jy nv nw mi kc nx ny mm kg nz oa mq ob bi translated">源阶段</h2><p id="2f1f" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">该阶段将待处理的源代码与代码管道相链接。我们将通过单击connect按钮并启动一个向导来连接CodePipeline和GitHub repo。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2a562be3a778c297a07c1f9cec786608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*NpEkKgDO3-eb-VLZ3_RCZQ.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">用GitHub连接管道</figcaption></figure><p id="08b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在向导结束时，如下所示，您将能够:</p><ul class=""><li id="442a" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">来访问您的GitHub repo(在我的例子中是<em class="nl">aladevlearning/microfrontends-pipeline</em>)</li><li id="200b" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">选择<em class="nl">主</em>分支</li><li id="a01b" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">取消选择源代码变更时的<em class="nl">启动管道</em>，因为我们想让Lambda函数来处理它</li><li id="0725" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">然后单击“下一步”进入下一阶段。</li></ul><p id="5d12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上步骤可以在下面的gif中看到。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e6d2052b7ba4fbae0888f65cc697cc07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*2qMyfsPlTH1g3183CwJXxw.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">在代码管道中添加源阶段</figcaption></figure><h2 id="e9ab" class="nq lv iq bd lw nr ns dn ma nt nu dp me jy nv nw mi kc nx ny mm kg nz oa mq ob bi translated">构建阶段</h2><p id="452b" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">此阶段负责构建前一阶段收到的源。它将创建或重用现有的<em class="nl"> CodeBuild </em>项目，该项目指示管道:</p><ul class=""><li id="e768" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">如何通过一个<em class="nl"> builspec.yml </em>文件运行构建。</li><li id="9698" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">CodeBuild将实际上构建</li></ul><p id="cc53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于<em class="nl"> buildspec.yml </em>，我们可以决定是为所有微前端提供一个公共文件，还是为每个微前端提供一个公共文件。这在很大程度上取决于是否所有微前端都遵循相同的选择框架和相同的构建/测试步骤。通过将它们分开，您可以让每个团队独立于如何构建它，代价是构建过程和治理的概述稍微复杂一些。对于我们的微前端，文件如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e94f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<em class="nl"> buildspec.yaml </em>由安装/准备环境、构建代码和指导如何构建工件的直观阶段组成。从管道发起者获得微前端名称后，该文件安装依赖项并压缩最终的工件，该工件将被部署到部署部分中指定的S3存储桶。详见本指南<a class="ae kl" href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="e3e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，构建过程需要一个运行环境(又名:机器)。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/958f63aba41c44db02467d4065e84b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*rmXTOdRcT99YFm78HdnDsw.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">创建代码生成项目</figcaption></figure><p id="d3f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的gif展示了CodeBuild配置是如何基于一个<em class="nl">构建环境</em>的，它代表了操作系统、编程语言运行时和用于运行构建的工具的组合。我们还选择了一个特定的<em class="nl"> buildspec.yml </em>文件位置，因为每个微前端在构建过程和管道方面可能有所不同(例如，一个可能是Angular项目，另一个可能是React项目，或者两者仍然使用相同的框架，但使用不同的步骤构建)。</p><p id="3365" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦建立了代码构建项目，我们将构建提供者设置为代码构建，我们选择新创建的代码构建项目(<em class="nl"> mfe-accounts-build </em>)并继续到最后阶段。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/8c944f8dfffa33ddfc7209df58de108e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*YlPorAgo2sNf5lfw-We5nQ.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">创建构建阶段</figcaption></figure><p id="3f96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建项目创建完毕，让我们进入代码管道的最后阶段。</p><h2 id="8a07" class="nq lv iq bd lw nr ns dn ma nt nu dp me jy nv nw mi kc nx ny mm kg nz oa mq ob bi translated">部署阶段</h2><p id="1fb8" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">最后，我们想在S3上部署我们的工件。为了做到这一点，我们需要<a class="ae kl" href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html" rel="noopener ugc nofollow" target="_blank">创建S3存储桶</a>，工件将在其中独立部署。由于CodeBuild将压缩构建的工件，我们在部署设置之前检查<em class="nl">提取文件，并将<em class="nl">固定ACL </em>设置为public-read，因为我们希望能够看到在S3部署的工件。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/896332d8393f87ea036b10025c45fc6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*scmER-OcW5nDxIUHzEMPJA.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">创建部署阶段</figcaption></figure><p id="102d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！您的代码现在部署在S3，这允许将它与一个CloudFront发行版相关联，以便更好地部署。对于任何微前端，都应该重复上述代码管道步骤。这种级别的冗余将允许每个团队独立自主，调整他们的CI/CD以</p><h1 id="254b" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">结果</h1><p id="8138" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">在推送至影响包含变更的微前端的储存库时，将启动一个或多个代码管道。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/0b6a25af246777324b9c93a92081f8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Txua6bFrunxGlwrBttboIA.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">管道开始活跃起来</figcaption></figure><p id="75e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">成功的管道应该是这样的:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/feb96359243c7ff54ee0f01e7b252ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*GrH0Um70FpOdan4SIkFVmw.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">成功的管道</figcaption></figure><p id="eb9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署的工件位于指定的S3存储桶下:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oe"><img src="../Images/c13643a78b6a2a7ab9fc832971679bd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IsniGXK_oAwKXdtXUp6bhA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">用于部署微前端的S3桶</figcaption></figure><p id="11e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与Cloudfront发行版相关联，我们部署的微前端将如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi of"><img src="../Images/48fed1a4af4062055a1dc9140fb90ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DuW0-nm785bugWCnNMPXPA.png"/></div></div></figure><p id="7905" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的代码可以在<a class="ae kl" href="https://github.com/aladevlearning/microfrontends-pipeline" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="2b02" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">总结和想法</h1><p id="f636" class="pw-post-body-paragraph jn jo iq jp b jq ms js jt ju mt jw jx jy mu ka kb kc mv ke kf kg mw ki kj kk ij bi translated">本文深入介绍了为基于mono-repo的前端架构创建无缝CI/CD管道的10分钟设置。这应该被看作是一个可行的，虽然是初步的方法，可以用很多方式探索，再次证明了在AWS中构建东西是多么伟大和有创造性。一些想法可能是:</p><ul class=""><li id="87ba" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">拥有不同的管道来满足不同的需求，例如不同的框架、测试套件、集成和功能测试、多阶段环境等</li><li id="189a" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">在不同的AWS帐户中发布工件，一个用于测试，一个用于生产，以保持隔离和安全性。</li><li id="e554" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">扩展特性分支CI/CD的方法，您可以在不阻塞主分支的情况下，为早期原型和反馈创建分支部署。</li><li id="5020" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">将上述内容作为CloudFormation模板。这是提升这种方法的必要条件，并在任何微前端中不断重复。</li><li id="d4c5" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">CloudFront失效步骤。如果对在管道中添加CloudFront感兴趣，通过Lambda函数的缓存失效步骤可能是必要的，以确保所有最新的更改都正确地传播给消费者(或者AWS可能会将其作为反馈并将其公开，因为这似乎是一种非常常用的模式)。</li></ul><h1 id="6d4f" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">参考</h1><div class="lc ld gp gr le lf"><a href="https://aws.amazon.com/blogs/devops/complete-ci-cd-with-aws-codecommit-aws-codebuild-aws-codedeploy-and-aws-codepipeline/" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">通过AWS CodeCommit、AWS CodeBuild、AWS CodeDeploy和AWS CodePipeline完成CI/CD | Amazon Web…</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">许多组织已经转移到DevOps实践，这是文化哲学，实践，…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">aws.amazon.com</p></div></div><div class="lo l"><div class="og l lq lr ls lo lt kw lf"/></div></div></a></div><div class="lc ld gp gr le lf"><a href="https://www.buildingmicrofrontends.com" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd ir gy z fp lk fr fs ll fu fw ip bi translated">构建微前端:这本书</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">微前端是当今日益复杂的web应用程序的答案。受微服务模型的启发，…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">www.buildingmicrofrontends.com</p></div></div><div class="lo l"><div class="oh l lq lr ls lo lt kw lf"/></div></div></a></div></div></div>    
</body>
</html>