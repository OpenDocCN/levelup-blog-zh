<html>
<head>
<title>Deploy your first Flask+MongoDB app on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes上部署您的第一个Flask+MongoDB应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deploy-your-first-flask-mongodb-app-on-kubernetes-8f5a33fa43b4?source=collection_archive---------0-----------------------#2020-06-28">https://levelup.gitconnected.com/deploy-your-first-flask-mongodb-app-on-kubernetes-8f5a33fa43b4?source=collection_archive---------0-----------------------#2020-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d535b71436047bc8f649f516b3f6ce11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JjIZJavAi1OyKvgaXlqjdQ.png"/></div></div></figure><p id="2ac6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将开发一个Python Flask应用程序，它可以与MongoDB数据库对话，使用Docker将其容器化，并将其部署在Kubernetes集群上。上一句话中的许多术语可能听起来目标很复杂，但是让我们把它分解成简单的步骤，然后一个一个地征服它们。点击查看完整代码<a class="ae kw" href="https://github.com/varunkumar032/tasksapp-python" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="a75f" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第1部分:创建您的应用程序</h1><p id="ca0b" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated"><strong class="ka ir">先决条件:</strong>如果您希望在本地运行一次应用程序，请在您的机器上安装Flask、Flask-PyMongo和MongoDB服务器实例。你可以跳过这一步，因为我们将应用程序和数据库容器化。</p><p id="789c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在这里构建的应用程序是一个简单的任务应用程序，您可以在其中创建、更新和删除简单的任务。这些数据将存储在MongoDB数据库中，这是一个存储灵活的类似JSON的文档的开源数据库。默认情况下，当MongoDB服务器实例在机器上启动时，它开始监听端口<code class="fe mh mi mj mk b">27017</code>。Flask-PyMongo模块帮助我们架起了Flask和MongoDB的桥梁，并提供了一些便利的帮手。ObjectId模块是一个使用MongoDB ObjectId的工具，ObjectId是每个文档的<code class="fe mh mi mj mk b">_id</code>字段的默认值，在任何文档的创建过程中生成。我们将使用<code class="fe mh mi mj mk b">curl</code>命令与我们的应用程序对话，这将在我们将应用程序部署到集群后讨论。</p><p id="4a23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目前，我们的工作目录<code class="fe mh mi mj mk b">tasksapp-python</code>包括:</p><p id="775a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.<code class="fe mh mi mj mk b">requirements.txt</code> -由Flask和Flask-PyMongo条目组成，这些条目将在我们构建Docker映像时安装。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7985" class="mt lf iq mk b gy mu mv l mw mx">Flask<br/>Flask-PyMongo</span></pre><p id="4814" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.<code class="fe mh mi mj mk b">app.py</code> -当运行在任何主机(<code class="fe mh mi mj mk b">python app.py</code>)上时，可以在其中的<code class="fe mh mi mj mk b">http://localhost:5000/</code>处访问。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8961" class="mt lf iq mk b gy mu mv l mw mx">from flask import Flask, request, jsonify<br/>from flask_pymongo import PyMongo<br/>from bson.objectid import ObjectId<br/>import socket</span><span id="67ce" class="mt lf iq mk b gy my mv l mw mx">app = Flask(__name__)<br/>app.config["MONGO_URI"] = "mongodb://mongo:27017/dev"<br/>mongo = PyMongo(app)<br/>db = mongo.db</span><span id="9fe1" class="mt lf iq mk b gy my mv l mw mx">@app.route("/")<br/>def index():<br/>    hostname = socket.gethostname()<br/>    return jsonify(<br/>        message="Welcome to Tasks app! I am running inside {} pod!".format(hostname)<br/>    )</span><span id="ea54" class="mt lf iq mk b gy my mv l mw mx">@app.route("/tasks")<br/>def get_all_tasks():<br/>    tasks = db.task.find()<br/>    data = []<br/>    for task in tasks:<br/>        item = {<br/>            "id": str(task["_id"]),<br/>            "task": task["task"]<br/>        }<br/>        data.append(item)<br/>    return jsonify(<br/>        data=data<br/>    )</span><span id="2520" class="mt lf iq mk b gy my mv l mw mx">@app.route("/task", methods=["POST"])<br/>def create_task():<br/>    data = request.get_json(force=True)<br/>    db.task.insert_one({"task": data["task"]})<br/>    return jsonify(<br/>        message="Task saved successfully!"<br/>    )</span><span id="314a" class="mt lf iq mk b gy my mv l mw mx">@app.route("/task/&lt;id&gt;", methods=["PUT"])<br/>def update_task(id):<br/>    data = request.get_json(force=True)["task"]<br/>    response = db.task.update_one({"_id": ObjectId(id)}, {"$set": {"task": data}})<br/>    if response.matched_count:<br/>        message = "Task updated successfully!"<br/>    else:<br/>        message = "No Task found!"<br/>    return jsonify(<br/>        message=message<br/>    )</span><span id="2d72" class="mt lf iq mk b gy my mv l mw mx">@app.route("/task/&lt;id&gt;", methods=["DELETE"])<br/>def delete_task(id):<br/>    response = db.task.delete_one({"_id": ObjectId(id)})<br/>    if response.deleted_count:<br/>        message = "Task deleted successfully!"<br/>    else:<br/>        message = "No Task found!"<br/>    return jsonify(<br/>        message=message<br/>    )</span><span id="5473" class="mt lf iq mk b gy my mv l mw mx">@app.route("/tasks/delete", methods=["POST"])<br/>def delete_all_tasks():<br/>    db.task.remove()<br/>    return jsonify(<br/>        message="All Tasks deleted!"<br/>    )</span><span id="0339" class="mt lf iq mk b gy my mv l mw mx">if __name__ == "__main__":<br/>    app.run(host="0.0.0.0", port=5000)</span></pre><p id="6c3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mh mi mj mk b">app.py</code>文件中，我们首先导入所有需要的模块，并创建Flask类(我们的应用程序)和PyMongo类(我们的数据库)的实例。请注意，<code class="fe mh mi mj mk b">MONGO_URI</code> Flask配置变量中的主机名被定义为‘mongo’而不是‘localhost’。这是因为‘mongo’将是我们的数据库容器的名称，同一个Docker网络中的容器可以通过它们的名称相互对话。</p><p id="d48b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您希望在本地运行应用程序，请使用<code class="fe mh mi mj mk b">app.config[“MONGO_URI”] = “mongodb://localhost:27017/dev”</code>。</p><p id="9e5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的应用由六个函数组成，它们由<code class="fe mh mi mj mk b">@app.route()</code> Python decorator分配URL。乍一看，很容易理解装饰者告诉我们的应用程序，无论何时用户在给定的<code class="fe mh mi mj mk b">route()</code>访问我们的<code class="fe mh mi mj mk b">@app</code>域，执行底层功能。</p><ol class=""><li id="5ff0" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated"><code class="fe mh mi mj mk b">index()</code> -每当点击应用程序时显示欢迎信息。还显示运行我们应用程序的机器的主机名。这有助于理解我们每次尝试访问应用程序时都会碰到随机的pod。</li><li id="cce6" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><code class="fe mh mi mj mk b">get_all_tasks()</code> -以字典列表的形式显示数据库中所有可用的任务。</li><li id="c18f" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><code class="fe mh mi mj mk b">create_task()</code> -创建一个新任务，该任务以唯一的ID存储在数据库中。</li><li id="fd08" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><code class="fe mh mi mj mk b">update_task(id)</code> -修改任何现有任务。如果没有找到具有查询ID的任务，则返回适当的消息。</li><li id="ea68" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><code class="fe mh mi mj mk b">delete_task(id)</code> -从数据库中删除具有查询ID的任务条目。如果找不到具有指定ID的任务，则返回适当的消息。</li><li id="ea61" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><code class="fe mh mi mj mk b">delete_all_tasks()</code> -删除所有任务。返回一个空列表。</li></ol><p id="bd56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在运行应用程序的最后一部分，我们将<code class="fe mh mi mj mk b">host</code>参数定义为‘0 . 0 . 0 . 0 ’,使服务器可以公开使用，运行在机器的IP地址上。这里我说的机器是一个吊舱，我们以后再讨论。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="8fe1" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第2部分:容器化应用程序</h1><p id="feea" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated"><strong class="ka ir">先决条件:</strong>在你的机器上安装Docker并创建一个Docker Hub帐户，如果你没有的话。使用<code class="fe mh mi mj mk b">docker login</code>命令授权Docker连接到Docker Hub帐户。</p><p id="31ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们为我们的应用程序构建一个Docker映像，它可以被推送到Docker Hub注册中心。在我们的工作目录<code class="fe mh mi mj mk b">tasksapp-python</code>中，将创建一个包含以下内容的<code class="fe mh mi mj mk b">Dockerfile</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="888f" class="mt lf iq mk b gy mu mv l mw mx">FROM python:alpine3.7<br/>COPY . /app<br/>WORKDIR /app<br/>RUN pip install -r requirements.txt<br/>ENV PORT 5000<br/>EXPOSE 5000<br/>ENTRYPOINT [ "python" ]<br/>CMD [ "app.py" ]</span></pre><p id="071a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用基于Alpine Linux项目的官方Python映像作为基础映像，并将工作目录的内容复制到映像上的一个新目录中。我们指示图像在作为容器运行时公开端口<code class="fe mh mi mj mk b">5000</code>，在该端口上我们可以访问我们的应用程序。最后，我们的应用程序容器被配置为在创建时自动运行<code class="fe mh mi mj mk b">python app.py</code>。</p><p id="4355" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们使用下面的命令构建标签为<code class="fe mh mi mj mk b">&lt;username&gt;/&lt;image-name&gt;:&lt;version&gt;</code>格式的图像:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2296" class="mt lf iq mk b gy mu mv l mw mx">&gt;docker build -t varunkumarg/tasksapp-python:1.0.0 .</span></pre><p id="a996" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将其推送到Docker Hub注册表:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="327a" class="mt lf iq mk b gy mu mv l mw mx">&gt;docker push varunkumarg/tasksapp-python:1.0.0</span></pre><p id="0633" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nn">注意:确保用您的Docker Hub用户名替换&lt; varunkumarg &gt;。</em></p><p id="6b98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的图像在Docker Hub上公开，世界上任何人都可以下载并运行它。</p><p id="8c48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们的app容器化了，那我们的数据库呢？我们如何将它集装箱化？我们不必担心它，因为我们可以轻松地使用官方的<code class="fe mh mi mj mk b">mongo</code> Docker映像，并在与应用程序容器相同的网络上运行它。</p><p id="e90e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行以下命令在本地测试我们的映像:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1646" class="mt lf iq mk b gy mu mv l mw mx">&gt;docker network create tasksapp-net<br/>&gt;docker run --name=mongo --rm -d --network=tasksapp-net mongo<br/>&gt;docker run –-name=tasksapp-python --rm -p 5000:5000 -d –-network=tasksapp-net varunkumarg/tasksapp-python:1.0.0</span></pre><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/427d391e1518cfd2bbb7e6f820475c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yptcH2PMHiiq1woOOQZnLw.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">“c1f52953f86d”是tasksapp-python容器的容器ID</figcaption></figure><p id="cd69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是在容器编排器上运行这个容器化的应用程序。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="ccb3" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第3部分:部署应用程序</h1><p id="9b2e" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated"><strong class="ka ir">先决条件:</strong>使用Minikube(单节点集群)或kubeadm(多节点集群)等安装工具或GKE、EKS或AKS等托管Kubernetes服务创建的Kubernetes集群。在这里，我使用一个由1个主服务器和3个工作服务器组成的集群，使用kubeadm部署在Ubuntu 18.04虚拟机上。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5b3c" class="mt lf iq mk b gy mu mv l mw mx">myuser@master1:~$ kubectl get nodes<br/>NAME      STATUS   ROLES    AGE   VERSION<br/>master1   Ready    master   25h   v1.18.5<br/>worker1   Ready    &lt;none&gt;   25h   v1.18.5<br/>worker2   Ready    &lt;none&gt;   25h   v1.18.5<br/>worker3   Ready    &lt;none&gt;   25h   v1.18.5</span></pre><p id="8da1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了在Kubernetes集群上部署我们的应用程序，我们将为每个Kubernetes资源创建<code class="fe mh mi mj mk b">.yaml</code>文件，并运行一组<code class="fe mh mi mj mk b">kubectl</code>命令。这些资源将按如下方式部署:</p><p id="2abd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.<code class="fe mh mi mj mk b">tasksapp</code>部署:</p><p id="f7cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">tasksapp.yaml</code>文件定义了在任何工作节点上的pod中运行的应用程序的部署。<code class="fe mh mi mj mk b">spec</code>部分定义了我们指定要提取和运行的图像的窗格。Pod的端口<code class="fe mh mi mj mk b">5000</code>暴露在外。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3702" class="mt lf iq mk b gy mu mv l mw mx">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: tasksapp<br/>  labels:<br/>    app: tasksapp<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: tasksapp<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: tasksapp<br/>    spec:<br/>      containers:<br/>        - name: tasksapp<br/>          image: varunkumarg/tasksapp-python:1.0.0<br/>          ports:<br/>            - containerPort: 5000<br/>          imagePullPolicy: Always</span></pre><p id="442c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe mh mi mj mk b">kubectl create</code>创建<code class="fe mh mi mj mk b">tasksapp</code>部署。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5582" class="mt lf iq mk b gy mu mv l mw mx">myuser@master1:~$ kubectl create -f tasksapp.yaml<br/>deployment.apps/tasksapp created<br/>myuser@master1:~$ kubectl get deployments<br/>NAME       READY   UP-TO-DATE   AVAILABLE   AGE<br/>tasksapp   1/1     1            1           61s</span></pre><p id="0d76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用<code class="fe mh mi mj mk b">kubectl scale</code>和<code class="fe mh mi mj mk b">--replicas</code>选项来扩展部署。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="647c" class="mt lf iq mk b gy mu mv l mw mx">myuser@master1:~$ kubectl scale deployment tasksapp --replicas=3<br/>deployment.apps/tasksapp scaled<br/>myuser@master1:~$ kubectl get pods -o wide<br/>NAME                        READY   STATUS    RESTARTS   AGE   IP          NODE      NOMINATED NODE   READINESS GATES<br/>tasksapp-645b67dfbc-2kqp5   1/1     Running   0          37m   10.38.0.1   worker2   &lt;none&gt;           &lt;none&gt;<br/>tasksapp-645b67dfbc-mqh97   1/1     Running   0          32s   10.44.0.2   worker3   &lt;none&gt;           &lt;none&gt;<br/>tasksapp-645b67dfbc-ncrt7   1/1     Running   0          32s   10.40.0.2   worker1   &lt;none&gt;           &lt;none&gt;</span></pre><p id="6a50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.<code class="fe mh mi mj mk b">tasksapp-svc</code>负载平衡器服务:</p><p id="225c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">LoadBalancer服务使部署中的pod可以从集群外部进行访问。在这里，由于我们使用定制的Kubernetes集群，我们将在<code class="fe mh mi mj mk b">&lt;service-ip&gt;:&lt;service-port&gt;</code>从主节点访问应用程序。服务由<code class="fe mh mi mj mk b">tasksapp-svc.yaml</code>定义。使用服务的优势是，它为我们提供了一个一致的IP来访问我们的应用程序，因为在我们的部署中可能会有许多pod来来去去。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="457e" class="mt lf iq mk b gy mu mv l mw mx">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: tasksapp-svc<br/>spec:<br/>  selector:<br/>    app: tasksapp<br/>  ports:<br/>    - port: 8080<br/>      targetPort: 5000<br/>  type: LoadBalancer</span></pre><p id="7261" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，服务<code class="fe mh mi mj mk b">tasksapp-svc</code>的端口<code class="fe mh mi mj mk b">8080</code>被绑定到与其相连的pod的端口<code class="fe mh mi mj mk b">5000</code>。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="54b5" class="mt lf iq mk b gy mu mv l mw mx">myuser@master1:~$ kubectl create -f tasksapp-svc.yaml<br/>service/tasksapp-svc created<br/>myuser@master1:~$ kubectl get svc tasksapp-svc<br/>NAME           TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE<br/>tasksapp-svc   LoadBalancer   10.103.82.106   &lt;pending&gt;     8080:32156/TCP   13s</span></pre><p id="4054" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们应该能够在<code class="fe mh mi mj mk b">10.103.82.106:8080</code>访问我们的应用程序。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7990" class="mt lf iq mk b gy mu mv l mw mx">myuser@master1:~$ curl 10.103.82.106:8080<br/>{<br/>  "message": "Welcome to Tasks app! I am running inside tasksapp-645b67dfbc-2kqp5 pod!"<br/>}<br/>myuser@master1:~$ curl 10.103.82.106:8080<br/>{<br/>  "message": "Welcome to Tasks app! I am running inside tasksapp-645b67dfbc-2kqp5 pod!"<br/>}<br/>myuser@master1:~$ curl 10.103.82.106:8080<br/>{<br/>  "message": "Welcome to Tasks app! I am running inside tasksapp-645b67dfbc-mqh97 pod!"<br/>}<br/>myuser@master1:~$ curl 10.103.82.106:8080<br/>{<br/>  "message": "Welcome to Tasks app! I am running inside tasksapp-645b67dfbc-ncrt7 pod!"<br/>}</span></pre><p id="399c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以清楚地看到，每次我们试图点击我们的应用程序时，<code class="fe mh mi mj mk b">LoadBalancer</code>都会将流量发送到任意一个随机的pod。此时，我们应用程序的其他功能无法使用，因为我们的数据库pod还没有准备好。</p><p id="927a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.<code class="fe mh mi mj mk b">mongo-pv</code>持续音量:</p><p id="55fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这创建了一个256 MB的存储卷，可供mongo容器使用。即使MongoDB pod被删除或移动到不同的节点，该卷的内容仍然存在。这是在<code class="fe mh mi mj mk b">mongo-pv.yaml</code>中定义的。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3a4c" class="mt lf iq mk b gy mu mv l mw mx">apiVersion: v1<br/>kind: PersistentVolume<br/>metadata:<br/>  name: mongo-pv<br/>spec:<br/>  capacity:<br/>    storage: 256Mi<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  hostPath:<br/>    path: /tmp/db</span></pre><p id="d0c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，我使用主机上的本地路径<code class="fe mh mi mj mk b">/tmp/db</code>作为磁盘路径。如果我们使用像<code class="fe mh mi mj mk b">gcePersistentDisk</code>这样的持久磁盘就更好了。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a5bd" class="mt lf iq mk b gy mu mv l mw mx">myuser@master1:~$ kubectl create -f mongo-pv.yaml<br/>persistentvolume/mongo-pv created<br/>myuser@master1:~$ kubectl get pv<br/>NAME       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE<br/>mongo-pv   256Mi      RWO            Retain           Available                                   65s</span></pre><p id="0a81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以注意到，该卷的状态是<code class="fe mh mi mj mk b">Available</code>用于索赔。</p><p id="e9ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.<code class="fe mh mi mj mk b">mongo-pvc</code>持续量声明:</p><p id="6112" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这用于要求/获得上面创建的存储，并且可以安装在<code class="fe mh mi mj mk b">mongo</code>容器上。它在<code class="fe mh mi mj mk b">mongo-pvc.yaml</code>中定义。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="985a" class="mt lf iq mk b gy mu mv l mw mx">apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: mongo-pvc<br/>spec:<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 256Mi</span></pre><p id="2855" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建PersistentVolumeClaim，您可以看到卷的状态现在更改为<code class="fe mh mi mj mk b">Bound</code>。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4931" class="mt lf iq mk b gy mu mv l mw mx">myuser@master1:~$ kubectl create -f mongo-pvc.yaml<br/>persistentvolumeclaim/mongo-pvc created<br/>myuser@master1:~$ kubectl get pvc<br/>NAME        STATUS   VOLUME     CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br/>mongo-pvc   Bound    mongo-pv   256Mi      RWO                           20s<br/>myuser@master1:~$ kubectl get pv<br/>NAME       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM               STORAGECLASS   REASON   AGE<br/>mongo-pv   256Mi      RWO            Retain           Bound    default/mongo-pvc                           6m57s</span></pre><p id="477d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">5.<code class="fe mh mi mj mk b">mongo</code>部署:</p><p id="862b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类似于<code class="fe mh mi mj mk b">tasksapp.yaml</code>，在<code class="fe mh mi mj mk b">mongo.yaml</code>中我们定义了<code class="fe mh mi mj mk b">mongo</code>部署，它创建了MongoDB服务器的一个实例。在这里，我们公开了其他pod可以访问的端口<code class="fe mh mi mj mk b">27017</code>。所要求的持久卷可以被安装到容器上的目录中。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0abb" class="mt lf iq mk b gy mu mv l mw mx">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: mongo<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: mongo<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mongo<br/>    spec:<br/>      containers:<br/>        - name: mongo<br/>          image: mongo<br/>          ports:<br/>            - containerPort: 27017<br/>          volumeMounts:<br/>            - name: storage<br/>              mountPath: /data/db<br/>      volumes:<br/>        - name: storage<br/>          persistentVolumeClaim:<br/>            claimName: mongo-pvc</span></pre><p id="e4d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe mh mi mj mk b">kubectl create</code>创建<code class="fe mh mi mj mk b">mongo</code>部署。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1958" class="mt lf iq mk b gy mu mv l mw mx">myuser@master1:~$ kubectl create -f mongo.yaml<br/>deployment.apps/mongo created<br/>myuser@master1:~$ kubectl get deployments<br/>NAME       READY   UP-TO-DATE   AVAILABLE   AGE<br/>mongo      1/1     1            1           59s<br/>tasksapp   3/3     3            3           44m</span></pre><p id="649e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">6.<code class="fe mh mi mj mk b">mongo</code>服务:</p><p id="6bff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个由<code class="fe mh mi mj mk b">mongo-svc.yaml</code>定义的服务类似于为我们的应用程序创建的服务，除了它属于类型<code class="fe mh mi mj mk b">ClusterIP</code>(Kubernetes中的默认服务类型)。该服务使<code class="fe mh mi mj mk b">mongo</code> pod可以从集群内部访问，但不能从外部访问。唯一可以访问MongoDB数据库的资源是我们的应用程序。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="06af" class="mt lf iq mk b gy mu mv l mw mx">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: mongo<br/>spec:<br/>  selector:<br/>    app: mongo<br/>  ports:<br/>    - port: 27017<br/>      targetPort: 27017</span></pre><p id="3293" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，服务<code class="fe mh mi mj mk b">mongo-svc</code>的端口<code class="fe mh mi mj mk b">27017</code>被绑定到与之相连的<code class="fe mh mi mj mk b">mongo</code> pod的端口<code class="fe mh mi mj mk b">27017</code>。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="32f0" class="mt lf iq mk b gy mu mv l mw mx">myuser@master1:~$ kubectl create -f mongo-svc.yaml<br/>service/mongo created<br/>myuser@master1:~$ kubectl get svc mongo<br/>NAME    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)     AGE<br/>mongo   ClusterIP   10.100.83.25   &lt;none&gt;        27017/TCP   8s</span></pre><p id="f116" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用以下命令测试<code class="fe mh mi mj mk b">mongo</code> pod是否启动并运行。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5a0b" class="mt lf iq mk b gy mu mv l mw mx">myuser@master1:~$ curl 10.100.83.25:27017<br/>It looks like you are trying to access MongoDB over HTTP on the native driver port.</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="dc5a" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">第4部分:测试您的应用程序</h1><p id="49bb" class="pw-post-body-paragraph jy jz iq ka b kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr mg kt ku kv ij bi translated"><strong class="ka ir">前提:</strong> <code class="fe mh mi mj mk b">curl</code>要安装在<code class="fe mh mi mj mk b">master</code>节点上。</p><p id="7f0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以在<code class="fe mh mi mj mk b">10.103.82.106:8080</code>访问我们的应用程序，让我们试着测试我们的应用程序提供的所有功能。</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a349" class="mt lf iq mk b gy mu mv l mw mx">myuser@master1:~$ curl 10.103.82.106:8080<br/>{<br/>  "message": "Welcome to Tasks app! I am running inside tasksapp-645b67dfbc-ncrt7 pod!"<br/>}</span><span id="0eca" class="mt lf iq mk b gy my mv l mw mx">myuser@master1:~$ curl 10.103.82.106:8080/tasks<br/>{<br/>  "data": []<br/>}</span><span id="115d" class="mt lf iq mk b gy my mv l mw mx">myuser@master1:~$ curl -X POST -d "{\"task\": \"Task 1\"}" http://10.103.82.106:8080/task<br/>{<br/>  "message": "Task saved successfully!"<br/>}<br/>myuser@master1:~$ curl -X POST -d "{\"task\": \"Task 2\"}" http://10.103.82.106:8080/task<br/>{<br/>  "message": "Task saved successfully!"<br/>}<br/>myuser@master1:~$ curl -X POST -d "{\"task\": \"Task 3\"}" http://10.103.82.106:8080/task<br/>{<br/>  "message": "Task saved successfully!"<br/>}</span><span id="719e" class="mt lf iq mk b gy my mv l mw mx">myuser@master1:~$ curl 10.103.82.106:8080/tasks<br/>{<br/>  "data": [<br/>    {<br/>      "id": "5ef8bce7df44b8194ee30c9a",<br/>      "task": "Task 1"<br/>    },<br/>    {<br/>      "id": "5ef8bcef7bc5ec979ae73a43",<br/>      "task": "Task 2"<br/>    },<br/>    {<br/>      "id": "5ef8bcf742b0630f70328296",<br/>      "task": "Task 3"<br/>    }<br/>  ]<br/>}</span><span id="26c7" class="mt lf iq mk b gy my mv l mw mx">myuser@master1:~$ curl -X PUT -d "{\"task\": \"Task 1 Updated\"}" http://10.103.82.106:8080/task/5ef8bce7df44b8194ee30c9a<br/>{<br/>  "message": "Task updated successfully!"<br/>}</span><span id="49d0" class="mt lf iq mk b gy my mv l mw mx">myuser@master1:~$ curl 10.103.82.106:8080/tasks<br/>{<br/>  "data": [<br/>    {<br/>      "id": "5ef8bce7df44b8194ee30c9a",<br/>      "task": "Task 1 Updated"<br/>    },<br/>    {<br/>      "id": "5ef8bcef7bc5ec979ae73a43",<br/>      "task": "Task 2"<br/>    },<br/>    {<br/>      "id": "5ef8bcf742b0630f70328296",<br/>      "task": "Task 3"<br/>    }<br/>  ]<br/>}</span><span id="ce34" class="mt lf iq mk b gy my mv l mw mx">myuser@master1:~$ curl -X DELETE http://10.103.82.106:8080/task/5ef8bce7df44b8194ee30c9a<br/>{<br/>  "message": "Task deleted successfully!"<br/>}</span><span id="7449" class="mt lf iq mk b gy my mv l mw mx">myuser@master1:~$ curl 10.103.82.106:8080/tasks<br/>{<br/>  "data": [<br/>    {<br/>      "id": "5ef8bcef7bc5ec979ae73a43",<br/>      "task": "Task 2"<br/>    },<br/>    {<br/>      "id": "5ef8bcf742b0630f70328296",<br/>      "task": "Task 3"<br/>    }<br/>  ]<br/>}</span><span id="3936" class="mt lf iq mk b gy my mv l mw mx">myuser@master1:~$ curl -X POST http://10.103.82.106:8080/tasks/delete<br/>{<br/>  "message": "All Tasks deleted!"<br/>}</span><span id="6dc2" class="mt lf iq mk b gy my mv l mw mx">myuser@master1:~$ curl 10.103.82.106:8080/tasks<br/>{<br/>  "data": []<br/>}</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="10ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">咻！那真是一段旅程。我们实现了我们一开始对自己的承诺:</p><ol class=""><li id="9c78" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated">创建一个与MongoDB数据库对话的Flask应用程序</li><li id="5e0a" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">使用Docker将应用容器化</li><li id="3eb3" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">在Kubernetes集群上部署应用程序</li></ol><p id="df2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且成功了！！恭喜你！！给自己一个鼓励！！</p><p id="af78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">快乐学习！！</p></div></div>    
</body>
</html>