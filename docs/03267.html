<html>
<head>
<title>Learning C++: Mutating Algorithms of the STL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL的变异算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-mutating-algorithms-of-the-stl-583aa720d860?source=collection_archive---------14-----------------------#2020-04-28">https://levelup.gitconnected.com/learning-c-mutating-algorithms-of-the-stl-583aa720d860?source=collection_archive---------14-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0fa25b5086cb94dc0da985d668724390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2HpILPMNM4pk3tpr"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Sergi Viladesau 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="92e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最近的一组文章中，我介绍了如何使用几个标准模板库(STL)函数，这些函数在STL容器上执行任务，比如查找和搜索值。在下一组文章中，我将讨论一组STL函数的变异。这些函数改变容器元素的顺序，而不改变它们的值。</p><h1 id="a117" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">反转容器的元素</h1><p id="f56b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">reverse </code>函数做了您认为它会做的事情:它颠倒了容器元素的顺序。该函数从容器中获取开始和结束范围，并反转该范围的顺序。下面是<code class="fe mh mi mj mk b">reverse</code>的语法模板:</p><p id="3dcc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">反向(范围-开始，范围-结束)；</em></p><p id="278e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示反转函数如何工作的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="d12d" class="mu lf it mk b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/>using namespace std;</span><span id="9c41" class="mu lf it mk b gy mz mw l mx my">void printVec(vector&lt;string&gt; &amp;vec) {<br/>  for (const string s : vec) {<br/>    cout &lt;&lt; s &lt;&lt; " ";<br/>  }<br/>}</span><span id="045c" class="mu lf it mk b gy mz mw l mx my">int main () {<br/>  vector&lt;string&gt; names = {"Meredith", "Allison", "Mason",<br/>                          "Christine"};<br/>  printVec(names);<br/>  cout &lt;&lt; endl;<br/>  reverse(names.begin(), names.end());<br/>  printVec(names);<br/>  return 0;<br/>}</span></pre><p id="f462" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="f652" class="mu lf it mk b gy mv mw l mx my">Meredith Allison Mason Christine<br/>Christine Mason Allison Meredith</span></pre><p id="e52a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是如何在容器的子范围上使用该函数:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="fa87" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;string&gt; names = {"Meredith", "Cody", "Ty", "Allison"};<br/>  printVec(names);<br/>  cout &lt;&lt; endl;<br/>  vector&lt;string&gt;::iterator iter = names.begin()+2;<br/>  reverse(iter, names.end());<br/>  printVec(names);<br/>  return 0;<br/>}</span></pre><p id="b469" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="d90e" class="mu lf it mk b gy mv mw l mx my">Meredith Cody Ty Allison<br/>Meredith Cody Allison Ty</span></pre><p id="c459" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个函数<code class="fe mh mi mj mk b">reverse_copy</code>，当它反转容器的顺序时，将复制的元素发送到输出迭代器。这意味着您可以打印容器的反转元素，而无需永久更改顺序。</p><p id="45a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数的语法模板是:</p><p id="c749" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> reverse_copy(range0-start，range0-end，output-iterator)；</em></p><p id="693c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示<code class="fe mh mi mj mk b">reverse_copy</code>如何工作的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="36d0" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;string&gt; names = {"Meredith", "Allison", "Mason"};<br/>  printVec(names);<br/>  cout &lt;&lt; endl;<br/>  reverse_copy(names.begin(), names.end(),<br/>               ostream_iterator&lt;string&gt;(cout, " "));<br/>  cout &lt;&lt; endl;<br/>  printVec(names);<br/>  return 0;<br/>}</span></pre><p id="cbdf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="f624" class="mu lf it mk b gy mv mw l mx my">Meredith Allison Mason<br/>Mason Allison Meredith<br/>Meredith Allison Mason</span></pre><h1 id="ae1a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">旋转容器元件</h1><p id="4fe7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">rotate</code>功能用于旋转容器的元素。该函数接受一个范围起点、要旋转的元素数量(向左)和范围终点。下面是rotate函数的语法模板:</p><p id="829c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">旋转(range-start，new_range-start，range-end)；</em></p><p id="189e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> new-range-start </em>参数通过从迭代器中加减来设置，以指示容器的新的第一个元素。</p><p id="309a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的例子演示了<code class="fe mh mi mj mk b">rotate</code>函数如何通过在容器元素的循环中将容器的每个元素左移一位来工作:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="fa34" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;string&gt; names = {"Terri", "Meredith", "Allison",<br/>                          "Mason"};<br/>  cout &lt;&lt; "Before rotation: " &lt;&lt; endl;<br/>  printVec(names);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "During rotation: " &lt;&lt; endl;<br/>  for (int i = 1; i &lt;= names.size()-1; i++) {<br/>    rotate(names.begin(), names.begin()+1, names.end());<br/>    printVec(names);<br/>    cout &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="f504" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="04ba" class="mu lf it mk b gy mv mw l mx my">Before rotation:<br/>Terri Meredith Allison Mason</span><span id="0ef9" class="mu lf it mk b gy mz mw l mx my">During rotation:<br/>Meredith Allison Mason Terri<br/>Allison Mason Terri Meredith<br/>Mason Terri Meredith Allison</span></pre><p id="44bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序通过从容器的末尾减去1，将容器的元素向另一个方向移动:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="367f" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;string&gt; names = {"Terri", "Meredith", "Allison",<br/>                          "Mason"};<br/>  cout &lt;&lt; "Before rotation: " &lt;&lt; endl;<br/>  printVec(names);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "During rotation: " &lt;&lt; endl;<br/>  for (int i = 1; i &lt;= names.size()-1; i++) {<br/>    rotate(names.begin(), names.end()-1, names.end());<br/>    printVec(names);<br/>    cout &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="6b75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="9385" class="mu lf it mk b gy mv mw l mx my">Before rotation:<br/>Terri Meredith Allison Mason</span><span id="630c" class="mu lf it mk b gy mz mw l mx my">During rotation:<br/>Mason Terri Meredith Allison<br/>Allison Mason Terri Meredith<br/>Meredith Allison Mason Terri</span></pre><p id="739d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个<code class="fe mh mi mj mk b">rotate_copy</code>函数，其工作方式类似于<code class="fe mh mi mj mk b">reverse_copy</code>函数。您可以使用此函数显示容器旋转，而无需对容器进行实际更改。像<code class="fe mh mi mj mk b">reverse_copy</code>函数一样，函数的最后一个参数是输出迭代器。</p><p id="6714" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是<code class="fe mh mi mj mk b">rotate_copy</code>的语法模板:</p><p id="ade5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> rotate_copy(range-start，rotate-start-iterator，range-end，output-iterator)；</em></p><p id="c58c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个程序，它将容器向左旋转一个元素，显示旋转而不改变底层元素的顺序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="6860" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;string&gt; names = {"Terri", "Meredith", "Allison",<br/>                          "Mason"};<br/>  cout &lt;&lt; "Before rotation: " &lt;&lt; endl;<br/>  printVec(names);<br/>  cout &lt;&lt; endl;<br/>  cout &lt;&lt; endl &lt;&lt; "Rotating one element to the right: " &lt;&lt; endl;<br/>  rotate_copy(names.begin(), names.begin()+1,<br/>              names.end(), ostream_iterator&lt;string&gt;(cout, " "));<br/>  cout &lt;&lt; endl;<br/>  cout &lt;&lt; endl &lt;&lt; "After calling rotate_copy: " &lt;&lt; endl;<br/>  printVec(names);<br/>  return 0;<br/>}</span></pre><p id="6a4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="9acb" class="mu lf it mk b gy mv mw l mx my">Before rotation:<br/>Terri Meredith Allison Mason</span><span id="a616" class="mu lf it mk b gy mz mw l mx my">Rotating one element to the right:<br/>Meredith Allison Mason Terri</span><span id="58ed" class="mu lf it mk b gy mz mw l mx my">After calling rotate_copy:<br/>Terri Meredith Allison Mason</span></pre><h1 id="60ca" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">置换容器</h1><p id="9bcf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我将介绍的下一个函数处理容器排列。排列是在不改变元素值的情况下，对容器中的元素进行重新排序。比如集合<em class="ml"> {1，2} </em>还有一种排列:<em class="ml"> {2，1} </em>。</p><p id="a47c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些功能中的第一个是<code class="fe mh mi mj mk b">next_permutation</code>。这个函数是一个布尔函数，返回一个容器是否有另一种排列可供使用。但是，您可以使用它来简单地置换容器中的元素。</p><p id="20e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是<code class="fe mh mi mj mk b">next_permutation</code>函数的语法模板:</p><p id="1a9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">next _ permutation(range-begin，range-end)；</em></p><p id="d7c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个程序，演示了如何使用<code class="fe mh mi mj mk b">next_permutation</code>函数来生成数字向量的两种排列:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="1504" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers = {1,2,3,4};<br/>  next_permutation(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  next_permutation(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><p id="30f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="4b3d" class="mu lf it mk b gy mv mw l mx my">1 2 4 3<br/>1 3 2 4</span></pre><p id="c8e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下程序演示了如何查看容器的所有排列:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="c56e" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers = {1,2,3};<br/>  while (next_permutation(numbers.begin(), numbers.end())) {<br/>    printVec(numbers);<br/>    cout &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="4f27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="ddf9" class="mu lf it mk b gy mv mw l mx my">1 3 2<br/>2 1 3<br/>2 3 1<br/>3 1 2<br/>3 2 1</span></pre><p id="b71d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我保持数据集简短，因为数据集中排列的数量增长非常快。</p><p id="8813" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这组的另一个功能是<code class="fe mh mi mj mk b">prev_permutation</code>。这个函数将容器恢复到最后一次排列之前的排列。该函数具有与<code class="fe mh mi mj mk b">next_permutation</code>函数相同的语法模板，并且该函数也返回一个布尔值。</p><p id="ad73" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个演示<code class="fe mh mi mj mk b">prev_permutation</code>如何工作的程序:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="7531" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers = {1,2,3,4};<br/>  cout &lt;&lt; "Original data set: " &lt;&lt; endl;<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  next_permutation(numbers.begin(), numbers.end());<br/>  cout &lt;&lt; "First permutation: " &lt;&lt; endl;<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  next_permutation(numbers.begin(), numbers.end());<br/>  cout &lt;&lt; "Second permutation: " &lt;&lt; endl;<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  cout &lt;&lt; "Previous permutation: " &lt;&lt; endl;<br/>  prev_permutation(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><p id="8138" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="01c4" class="mu lf it mk b gy mv mw l mx my">Original data set:<br/>1 2 3 4<br/>First permutation:<br/>1 2 4 3<br/>Second permutation:<br/>1 3 2 4<br/>Previous permutation:<br/>1 2 4 3</span></pre><h1 id="974b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">洗牌容器元素</h1><p id="c46d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我将讨论的下一组函数用于随机打乱容器的元素。</p><p id="1d47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我开始讨论这些函数之前，它们都使用了更现代的生成随机数的C++方法。我将在另一篇文章中介绍这些技术，但是如果你现在想了解更多的话，<a class="ae kf" href="https://www.fluentcpp.com/2019/05/24/how-to-fill-a-cpp-collection-with-random-values/" rel="noopener ugc nofollow" target="_blank">这篇</a>教程介绍了基础知识。</p><p id="43ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该组中的第一个函数是<code class="fe mh mi mj mk b">shuffle</code>函数。这个函数接受一系列元素，以及一个随机数生成器引擎，并使用这个引擎打乱这些元素。以下是shuffle函数的语法模板:</p><p id="af30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">洗牌(范围开始，范围结束，随机引擎)；</em></p><p id="032a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用<code class="fe mh mi mj mk b">shuffle</code>函数改变容器顺序的例子:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="861d" class="mu lf it mk b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;random&gt;</span><span id="c59a" class="mu lf it mk b gy mz mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers = {1,2,3,4,5,6,7,8,9,10};<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  default_random_engine rnumEngine;<br/>  shuffle(numbers.begin(), numbers.end(), rnumEngine);<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><p id="96c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="f505" class="mu lf it mk b gy mv mw l mx my">1 2 3 4 5 6 7 8 9 10<br/>8 7 5 6 2 4 10 3 1 9</span></pre><p id="c5fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这组中的第二个功能是<code class="fe mh mi mj mk b">random_shuffle</code>。这个函数不需要随机数生成器，而是使用一个实现定义的函数，比如<code class="fe mh mi mj mk b">rand</code>。以下是该函数的语法模板:</p><p id="4e55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> random_shuffle(range-start，range-end)；</em></p><p id="7750" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的程序使用<code class="fe mh mi mj mk b">random_shuffle</code>来打乱vector中的元素:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="394e" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers = {1,2,3,4,5,6,7,8,9,10};<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  random_shuffle(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><p id="5f77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="9fe7" class="mu lf it mk b gy mv mw l mx my">1 2 3 4 5 6 7 8 9 10<br/>9 2 10 3 1 6 8 4 5 7</span></pre><p id="70b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过对元素重新排序并重新洗牌来测试函数的随机性，如下所示:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="602c" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers = {1,2,3,4,5,6,7,8,9,10};<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  random_shuffle(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  sort(numbers.begin(), numbers.end());<br/>  random_shuffle(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl;<br/>  sort(numbers.begin(), numbers.end());<br/>  random_shuffle(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><p id="3d75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="28b5" class="mu lf it mk b gy mv mw l mx my">1 2 3 4 5 6 7 8 9 10<br/>9 2 10 3 1 6 8 4 5 7<br/>7 5 10 8 4 1 2 9 6 3<br/>3 10 6 4 8 1 7 9 5 2</span></pre><p id="2b9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个输出表明<code class="fe mh mi mj mk b">random_shuffle</code>函数在随机洗牌方面做得很好。</p><p id="bb2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有第二个版本的<code class="fe mh mi mj mk b">random_shuffle</code>,但是为了节省空间，我不会在本文中涉及它。</p><h1 id="76ae" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将元素移到前面的函数</h1><p id="3765" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我将介绍的最后一组函数用于将容器元素移动到容器的前面。第一个是<code class="fe mh mi mj mk b">partition</code>，根据谓词函数将一组元素移动到容器的前面。</p><p id="6574" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是分区的语法模板:</p><p id="fd5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">划分(范围-开始，范围-结束，谓词-函数)；</em></p><p id="ddc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下程序使用lambda函数作为谓词，将大于50的数字移动到向量的前面:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="7464" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 20);<br/>  cout &lt;&lt; "Before partitioning numbers greater than 50: "<br/>       &lt;&lt; endl;<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  partition(numbers.begin(), numbers.end(),<br/>            [] (int num) { return num &gt; 50;});<br/>  cout &lt;&lt; "After partitioning: " &lt;&lt; endl;<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><p id="3938" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="0872" class="mu lf it mk b gy mv mw l mx my">Before partitioning numbers greater than 50:<br/>50 86 3 57 2 73 14 54 49 5 76 26 36 45 10 31 46 71 94 27</span><span id="afcd" class="mu lf it mk b gy mz mw l mx my">After partitioning:<br/>94 86 71 57 76 73 54 14 49 5 2 26 36 45 10 31 46 3 50 27</span></pre><p id="7f51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想保留容器中元素的相对顺序，甚至在分区之后，您可以使用<code class="fe mh mi mj mk b">stable_partition</code>函数。以下是该函数的语法模板:</p><p id="4ec3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">stable _ partition(range-start，range-end，谓词-函数)；</em></p><p id="03f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的程序中，使用了<code class="fe mh mi mj mk b">stable_partition</code>函数，如果您将输出与上面的分区示例的输出进行比较，您会看到<code class="fe mh mi mj mk b">stable_partition</code>函数做了它应该做的事情。代码如下:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="6f50" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 20);<br/>  cout &lt;&lt; "Before partitioning numbers greater than 50: "<br/>       &lt;&lt; endl;<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  stable_partition(numbers.begin(), numbers.end(),<br/>                   [] (int num) { return num &gt; 50;});<br/>  cout &lt;&lt; "After partitioning: " &lt;&lt; endl;<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><p id="f358" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是程序的输出:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="87f7" class="mu lf it mk b gy mv mw l mx my">Before partitioning numbers greater than 50:<br/>15 90 19 46 17 35 65 34 75 83 94 17 81 27 27 84 56 50 84 57</span><span id="cc27" class="mu lf it mk b gy mz mw l mx my">After partitioning:<br/>90 65 75 83 94 81 84 56 84 57 15 19 46 17 35 34 17 27 27 50</span></pre><p id="a86f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与使用分区函数的早期程序相比，数字的顺序保持得更好。</p><p id="1e90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该组的最后一个功能是<code class="fe mh mi mj mk b">partition_copy</code>。这个函数将一个容器分成两个范围。该函数的语法模板是:</p><p id="256e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> partition_copy(range-start，range-end，output-iterator1-range-start，output- <br/> iterator2-start，谓词-函数)；</em></p><p id="ad06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于该函数将元素放入输出迭代器类型的范围中，所以使用起来有点复杂。为了使这更容易，我使用了一个名为<code class="fe mh mi mj mk b">back_inserter</code>的函数。<a class="ae kf" href="https://www.cplusplus.com/reference/iterator/back_inserter/" rel="noopener ugc nofollow" target="_blank">这里的</a>描述了<code class="fe mh mi mj mk b">back_inserter</code>的功能和工作原理。</p><p id="66b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的程序获取一个随机生成的数字向量，并将其分成两个向量，一个包含小于50的值，另一个包含大于等于50的值。代码如下:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="1163" class="mu lf it mk b gy mv mw l mx my">int main () {<br/>  srand(time(0));<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 20);<br/>  cout &lt;&lt; "Original vector: " &lt;&lt; endl;<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  vector&lt;int&gt; lessThan50;<br/>  vector&lt;int&gt; greaterThan50;<br/>  partition_copy(numbers.begin(), numbers.end(),<br/>                 back_inserter(greaterThan50),<br/>                 back_inserter(lessThan50),<br/>                 [](int num) { return num &gt;= 50; });<br/>  cout &lt;&lt; "Less than 50: " &lt;&lt; endl;<br/>  printVec(lessThan50);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "Greater than or equal to 50: " &lt;&lt; endl;<br/>  printVec(greaterThan50);<br/>  return 0;<br/>}</span></pre><p id="4cfe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq mk mr ms aw mt bi"><span id="7641" class="mu lf it mk b gy mv mw l mx my">Original vector:<br/>50 12 47 31 74 61 35 57 73 81 38 49 79 24 87 60 30 37 19 41</span><span id="e8d8" class="mu lf it mk b gy mz mw l mx my">Less than 50:<br/>12 47 31 35 38 49 24 30 37 19 41</span><span id="f185" class="mu lf it mk b gy mz mw l mx my">Greater than or equal to 50:<br/>50 74 61 57 73 81 79 87 60</span></pre><h1 id="4fd5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">另一种变异算法:排序</h1><p id="806c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这就是STL中的一组变异算法。在我的下一篇文章中，我将讨论一组用于将容器元素排序的函数。</p><p id="61f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请给我发电子邮件提出意见和建议。</p></div></div>    
</body>
</html>