<html>
<head>
<title>JavaScript Best Practices — Avoid Variables Bad Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践——避免变量不良实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-avoid-variables-bad-practices-b764e90e76c8?source=collection_archive---------7-----------------------#2020-05-08">https://levelup.gitconnected.com/javascript-best-practices-avoid-variables-bad-practices-b764e90e76c8?source=collection_archive---------7-----------------------#2020-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/98d4ce735b091838677baafb898009cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7hvL7re-329XNfKq"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@anohin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维塔利·阿诺辛</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="50e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="52d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何在声明变量时避免一些不好的做法。</p><h1 id="3d32" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要链接变量赋值</h1><p id="36ab" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">变量赋值不应该是链式的，因为我们在链中的一些变量中创建了全局变量。</p><p id="7b41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们编写以下代码来声明一个链中的多个变量，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9aff" class="mq lf it mm b gy mr ms l mt mu">{<br/>  let a = b = c = 5;<br/>}</span></pre><p id="416a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mv mw mx mm b">a</code>将被用<code class="fe mv mw mx mm b">let</code>声明为一个块范围的变量。然而，<code class="fe mv mw mx mm b">let</code>关键字并不适用于<code class="fe mv mw mx mm b">b</code>和<code class="fe mv mw mx mm b">c</code>。</p><p id="0057" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们都被声明为全局变量。这绝对是我们不想要的。</p><p id="6d01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该避免上面提到的一连串的赋值操作。相反，我们应该用他们自己的方式给他们写信，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="326c" class="mq lf it mm b gy mr ms l mt mu">{<br/>  let a = 5<br/>  let b = a;<br/>  let c = a;<br/>}</span></pre><p id="95b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们以与上一个示例相同的方式声明了变量<code class="fe mv mw mx mm b">a</code>，但是我们将<code class="fe mv mw mx mm b">b</code>和<code class="fe mv mw mx mm b">c</code>的声明放在了它们自己的行中。</p><p id="6de2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe mv mw mx mm b">a</code>的值分配给<code class="fe mv mw mx mm b">b</code>和<code class="fe mv mw mx mm b">c</code>。这样，它们都是块范围的，我们不会意外地声明全局变量。</p><h1 id="4389" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免使用一元增量和减量(<code class="fe mv mw mx mm b">++</code>、<code class="fe mv mw mx mm b">--</code>)</h1><p id="b59e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该避免一元递增和递减语句，因为它们会自动插入分号，我们不希望这样，因为分号可能会被添加到我们不希望它们出现的位置。</p><p id="04f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不使用递增和递减操作符还可以防止我们无意中递增和递减值，这会导致程序中的意外行为。</p><p id="aa52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果我们有下面的代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f034" class="mq lf it mm b gy mr ms l mt mu">let num = 1;<br/>num++;</span></pre><p id="aaaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后应该将其更改为以下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a1de" class="mq lf it mm b gy mr ms l mt mu">let num = 1;<br/>num += 1;</span></pre><p id="68f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这更好，因为它是一个陈述而不是一个表达式，所以我们不能这样做:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d091" class="mq lf it mm b gy mr ms l mt mu">let num = 1;<br/>const foo = num++;</span></pre><p id="096a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">foo</code>仍然是1，因为如果<code class="fe mv mw mx mm b">++</code>或<code class="fe mv mw mx mm b">--</code>跟在变量后面，则不会返回最新的值。</p><p id="ef94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不能做同样的事情:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f254" class="mq lf it mm b gy mr ms l mt mu">num += 1;</span></pre><p id="8fbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以这要安全得多，因为在不创建新的一行的情况下，用上面的一行进行赋值是很困难的。</p><h1 id="85c5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在赋值时避免在<code class="fe mv mw mx mm b">=</code>之前或之后换行。如果我们赋值的表达式很长，就用括号把它们括起来</h1><p id="48b9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们想给一个变量分配一个长的JavaScript表达式，那么我们应该用括号把它们括起来，而不是使用换行符。在定界表达式中，换行符不如圆括号清晰。</p><p id="d822" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写以下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ffb5" class="mq lf it mm b gy mr ms l mt mu">let str =<br/>  'The quick brown fox jumps over the lazy dog';</span></pre><p id="d19c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该改为写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6854" class="mq lf it mm b gy mr ms l mt mu">let str = (<br/>  'The quick brown fox jumps over the lazy dog'<br/>);</span></pre><p id="af98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们的代码清楚地表明长字符串是一个表达式。</p><h1 id="e95c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有未使用的变量</h1><p id="08cd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">未使用的变量是死代码，死代码不应该出现在我们的生产代码中。</p><p id="641e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为它没有被使用，所以它们应该被移除。它们占用空间，让读者困惑。</p><p id="5111" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，与其写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9d4a" class="mq lf it mm b gy mr ms l mt mu">let unusedVar = 1;</span></pre><p id="0c6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该移除它。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/681ca2795c311ea433cd328dc07b940f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*koWwCHNhtPjJVxxN"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安迪·奇尔顿在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="9b36" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mv mw mx mm b">var</code>申报被提升</h1><p id="1cf0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">var</code>声明被提升到最近的封闭函数范围的顶部，但是它们的赋值却没有。</p><p id="20e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是许多开发者没有预料到的，因为他们对<code class="fe mv mw mx mm b">var</code>没有完全的了解。</p><p id="6b4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8e37" class="mq lf it mm b gy mr ms l mt mu">const foo = () =&gt; {<br/>  console.log(x);<br/>  var x = 1;<br/>  console.log(x);<br/>}</span><span id="e196" class="mq lf it mm b gy mz ms l mt mu">foo();</span></pre><p id="faf5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mv mw mx mm b">x</code>在第一个控制台日志中是<code class="fe mv mw mx mm b">undefined</code>，但在第二个日志中是1。如果我们在声明<code class="fe mv mw mx mm b">foo</code>之前记录它，那么我们会得到“未捕获的引用错误:x未定义”错误，并且函数不会运行。</p><p id="7772" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，声明被放在函数的顶部，但值没有。</p><p id="b70b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是JavaScript的一个恼人的特性，欺骗了很多人。没那么有用，所以<code class="fe mv mw mx mm b">let</code>和<code class="fe mv mw mx mm b">const</code>声明没有这个特性。</p><p id="98d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们应该使用<code class="fe mv mw mx mm b">let</code>和<code class="fe mv mw mx mm b">const</code>而不是<code class="fe mv mw mx mm b">var</code>的又一个原因。</p><h1 id="21c2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="295c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">var</code>声明很复杂，所以不应该使用。像未使用的变量这样的死代码应该被删除。</p><p id="56b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量赋值链也很棘手，因为中间件变量都被声明为全局变量，所以我们应该在它们自己的行中给它们赋值。</p><p id="1c1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，不应该使用递增和递减运算符，因为如果新值出现在操作数之前并进行赋值，它们都会返回新值。它还受分号自动插入的影响，这会做一些我们可能没有预料到的事情。</p></div></div>    
</body>
</html>