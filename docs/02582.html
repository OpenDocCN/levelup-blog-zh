<html>
<head>
<title>Looking at JSX In Depth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入观察JSX</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/looking-at-jsx-in-depth-c215eaf55b13?source=collection_archive---------14-----------------------#2020-03-23">https://levelup.gitconnected.com/looking-at-jsx-in-depth-c215eaf55b13?source=collection_archive---------14-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/703125c78f8050216eb05f4c75da8799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bdTP0tsSPdkAt19j"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">约书亚·牛顿在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1ae3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React是一个用于创建前端视图的库。React引入了一种叫做JSX的新语法，它使我们能够用JavaScript轻松构建UI组件。在本文中，我们将深入研究JSX语法。</p><h1 id="b853" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JSX是什么？</h1><p id="4e06" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JSX只是<code class="fe mh mi mj mk b">React.createElement</code>方法的语法糖。</p><p id="5c2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c7e5" class="mt lf it mk b gy mu mv l mw mx">&lt;Button color="blue"&gt;Click Me&lt;/Button&gt;</span></pre><p id="a0e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">被编译为:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5173" class="mt lf it mk b gy mu mv l mw mx">React.createElement(<br/>  <!-- -->Button<!-- -->,<br/>  {color: 'blue'},<br/>  'Click Me'<br/>)</span></pre><h1 id="33b8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">指定React元素类型</h1><p id="7f10" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JSX标签的第一部分决定了React元素的类型。</p><p id="354d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类型必须大写，以便React知道它引用的是React组件。</p><p id="de7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些标签被编译成一个命名变量。如果我们使用JSX反应元素，那么它必须在范围内。</p><p id="0568" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想使用<code class="fe mh mi mj mk b">&lt;Foo /&gt;</code>，那么<code class="fe mh mi mj mk b">Foo</code>必须在范围内。</p><h1 id="612f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">React必须在范围内</h1><p id="fb87" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">React必须始终在范围内，因为JSX编译为<code class="fe mh mi mj mk b">React.createElement</code>。既然<code class="fe mh mi mj mk b">React</code>被引用，那么它一定在范围内。</p><h1 id="f41b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JSX字体使用点符号</h1><p id="0152" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以在JSX内部使用点符号来引用React组件。从导出多个React组件的模块中引用React元素非常方便。</p><p id="430c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以创建一个对象来对组件进行分组，并在另一个组件中引用它，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bdd6" class="mt lf it mk b gy mu mv l mw mx">const Components = {<br/>  Foo: function(props) {<br/>    const { color } = props;<br/>    return &lt;div style={{ color }}&gt;foo&lt;/div&gt;;<br/>  }<br/>};</span><span id="cbf2" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/>    return &lt;Components.Foo color="blue" /&gt;;<br/>  }<br/>}</span></pre><p id="95d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个<code class="fe mh mi mj mk b">Components</code>对象，里面有<code class="fe mh mi mj mk b">Foo</code>属性。它的值是一个返回div的函数。</p><p id="a92d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mh mi mj mk b">App</code>模块中，我们通过写<code class="fe mh mi mj mk b">Component.Foo</code>来引用它。</p><h1 id="ec04" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用户定义的组件必须大写</h1><p id="25d6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该对用户定义的组件使用大写字母，这样就可以将它们与<code class="fe mh mi mj mk b">div</code>或<code class="fe mh mi mj mk b">span</code>等元素区分开来。</p><p id="c276" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有一个以小写字母开头的组件，那么我们应该把它赋给一个以大写字母开头的变量，然后在代码中引用它。</p><p id="56f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以这样做:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d873" class="mt lf it mk b gy mu mv l mw mx">function foo(props) {<br/>  const { color } = props;<br/>  return &lt;div style={{ color }}&gt;foo&lt;/div&gt;;<br/>}</span><span id="a011" class="mt lf it mk b gy my mv l mw mx">const Foo = foo;</span><span id="bd22" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/>    return &lt;Foo color="blue" /&gt;;<br/>  }<br/>}</span></pre><p id="6830" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个名为<code class="fe mh mi mj mk b">foo</code>的组件，然后我们将<code class="fe mh mi mj mk b">foo</code>赋值给<code class="fe mh mi mj mk b">Foo</code>，然后在<code class="fe mh mi mj mk b">App</code>中引用它，而不是直接引用<code class="fe mh mi mj mk b">foo</code>。</p><h1 id="069a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在运行时选择类型</h1><p id="eb5a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不能把JavaScript表达式作为组件类型。例如，我们不能写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d63e" class="mt lf it mk b gy mu mv l mw mx">function Foo() {<br/>  return &lt;div&gt;foo&lt;/div&gt;;<br/>}</span><span id="da50" class="mt lf it mk b gy my mv l mw mx">function Bar() {<br/>  return &lt;div&gt;foo&lt;/div&gt;;<br/>}</span><span id="ad20" class="mt lf it mk b gy my mv l mw mx">const components = {<br/>  Foo, Bar<br/>}</span><span id="937a" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {    <br/>    return &lt;components['Foo'] /&gt;;<br/>  }<br/>}</span></pre><p id="c89d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想在<code class="fe mh mi mj mk b">App</code>中引用<code class="fe mh mi mj mk b">components[‘Foo’]</code>，我们必须先将它赋给一个变量:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="eb5c" class="mt lf it mk b gy mu mv l mw mx">function Foo() {<br/>  return &lt;div&gt;foo&lt;/div&gt;;<br/>}</span><span id="1cc0" class="mt lf it mk b gy my mv l mw mx">function Bar() {<br/>  return &lt;div&gt;foo&lt;/div&gt;;<br/>}</span><span id="d3f2" class="mt lf it mk b gy my mv l mw mx">const components = {<br/>  Foo,<br/>  Bar<br/>};</span><span id="794f" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/>    const Foo = components["Foo"];<br/>    return &lt;Foo /&gt;;<br/>  }<br/>}</span></pre><h1 id="2fb8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">作为道具的JavaScript表达式</h1><p id="6d3b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过用<code class="fe mh mi mj mk b">{}</code>将JavaScript表达式括起来作为道具传入。</p><p id="9199" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b28a" class="mt lf it mk b gy mu mv l mw mx">function Foo(props) {<br/>  return &lt;div&gt;{props.num}&lt;/div&gt;;<br/>}</span><span id="f96c" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/>    return &lt;Foo num={1 + 2 + 3} /&gt;;<br/>  }<br/>}</span></pre><h1 id="4b15" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">字符串文字</h1><p id="6a57" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用两种方式传入字符串。</p><p id="d777" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5564" class="mt lf it mk b gy mu mv l mw mx">function Foo({ message }) {<br/>  return &lt;div&gt;{message}&lt;/div&gt;;<br/>}</span><span id="57e6" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/>    return &lt;Foo message={"foo"} /&gt;;<br/>  }<br/>}</span></pre><p id="81f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f67f" class="mt lf it mk b gy mu mv l mw mx">function Foo({ message }) {<br/>  return &lt;div&gt;{message}&lt;/div&gt;;<br/>}</span><span id="101a" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/>    return &lt;Foo message="foo" /&gt;;<br/>  }<br/>}</span></pre><p id="1923" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ff27" class="mt lf it mk b gy mu mv l mw mx">&lt;Foo message={"foo"} /&gt;</span></pre><p id="808f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与以下内容相同:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b4c1" class="mt lf it mk b gy mu mv l mw mx">&lt;Foo message="foo" /&gt;</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/f987cc8dd081384188361fb9a905ff3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c8d1UnELopV2U6uK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@arstyy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Austin Neill </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="0888" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">道具默认为“真”</h1><p id="67f7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们没有传入一个prop值，那么这个值默认为<code class="fe mh mi mj mk b">true</code>。</p><p id="1f32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="af4c" class="mt lf it mk b gy mu mv l mw mx">function Foo({ foo }) {<br/>  return &lt;div&gt;{`Foo is ${foo}`}&lt;/div&gt;;<br/>}</span><span id="96fa" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/>    return &lt;Foo foo /&gt;;<br/>  }<br/>}</span></pre><p id="1778" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们看到<code class="fe mh mi mj mk b">Foo is true</code>显示在屏幕上，因为<code class="fe mh mi mj mk b">foo</code>是<code class="fe mh mi mj mk b">true</code>，因为我们没有设置<code class="fe mh mi mj mk b">foo</code>道具的值。</p><h1 id="acea" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">传播属性</h1><p id="8206" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用spread操作符将对象属性扩展到道具中。例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="18af" class="mt lf it mk b gy mu mv l mw mx">function Greeting({ firstName, lastName }) {<br/>  return (<br/>    &lt;div&gt;<br/>      {firstName} {lastName}<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="d7c8" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/>    const props = { firstName: "Jane", lastName: "Smith" };<br/>    return &lt;Greeting {...props} /&gt;;<br/>  }<br/>}</span></pre><p id="10c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">把《简·史密斯》搬上银幕。<code class="fe mh mi mj mk b">props</code>对象作为属性名传入<code class="fe mh mi mj mk b">Greeting</code>，属性名作为属性名，值作为值。</p><p id="4dd6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它与以下内容相同:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="78b6" class="mt lf it mk b gy mu mv l mw mx">function Greeting({ firstName, lastName }) {<br/>  return (<br/>    &lt;div&gt;<br/>      {firstName} {lastName}<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="4037" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/>    return &lt;Greeting firstName="Jane" lastName="Smith" /&gt;;<br/>  }<br/>}</span></pre><p id="d48e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以在接收道具的组件中选择特定的道具来消费。</p><p id="a64d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1da7" class="mt lf it mk b gy mu mv l mw mx">const Button = ({ kind, children, ...other }) =&gt; {<br/>  const className = kind === "primary" ? "PrimaryButton" : "SecondaryButton";<br/>  return (<br/>    &lt;button className={className} {...other}&gt;<br/>      {children}<br/>    &lt;/button&gt;<br/>  );<br/>};</span><span id="1498" class="mt lf it mk b gy my mv l mw mx">class App extends React.Component {<br/>  render() {<br/>    const props = { kind: "primary", a: 1, b: 2 };<br/>    return &lt;Button {...props}&gt;Click Me&lt;/Button&gt;;<br/>  }<br/>}</span></pre><p id="81a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的<code class="fe mh mi mj mk b">Button</code>组件中，我们只想使用<code class="fe mh mi mj mk b">kind</code>和<code class="fe mh mi mj mk b">children</code>道具，忽略其余的。因此，我们可以使用参数中的析构操作符来获取那些，然后使用rest操作符将其余部分放入其自己的对象中。</p><p id="35b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过<code class="fe mh mi mj mk b">other</code>直接进入<code class="fe mh mi mj mk b">button</code>。<code class="fe mh mi mj mk b">other</code>就是<code class="fe mh mi mj mk b">{ a: 1, b: 2 }</code>。</p><h1 id="210a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="5b4b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JSX是<code class="fe mh mi mj mk b">React.createElement</code>方法的语法糖。</p><p id="e08c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该首先用大写字母命名我们自己的组件。我们不能用表达式来引用组件名。</p><p id="b4b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有，我们可以通过各种方式传入道具。它们可以显式传入。它们也可以通过spread操作符传入。</p><p id="c7d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，可以使用析构操作符来消耗道具，而不直接消耗的道具可以使用rest操作符放入一个单独的对象中。</p></div></div>    
</body>
</html>