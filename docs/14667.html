<html>
<head>
<title>How to Deploy Storybook with Chromatic and CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用彩色和圆形图标部署故事书</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-deploy-storybook-with-chromatic-and-circleci-84be5ed51507?source=collection_archive---------3-----------------------#2022-12-15">https://levelup.gitconnected.com/how-to-deploy-storybook-with-chromatic-and-circleci-84be5ed51507?source=collection_archive---------3-----------------------#2022-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6882" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让CircleCI只部署特定的文件更改可能会很棘手。在本文中，我们将看到如何使用Chromatic和<a class="ae kf" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>为<a class="ae kf" href="https://storybook.js.org/blog/why-storybook-in-2022/#:~:text=Storybook%20keeps%20track%20of%20stories&amp;text=That%20helps%20you%20focus%20development,node%20process%20from%20the%20app." rel="noopener ugc nofollow" target="_blank"> Storybook </a>创建一个自动化的持续部署过程。</h2></div><h1 id="d113" class="kg kh iq bd ki kj kk kl km kn ko kp kq jw kr jx ks jz kt ka ku kc kv kd kw kx bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="acc0" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果你正在寻找的只是如何只对特定的文件变化进行部署——参见下面的<strong class="la ir"> Bash脚本拯救</strong>部分。</p><h2 id="57b4" class="lu kh iq bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">介绍</h2><p id="0a57" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这里的重点是仅当相关文件发生更改时才运行部署过程，这在使用CircleCI时可能很棘手。这里的假设是你已经熟悉了<a class="ae kf" href="https://circleci.com/docs/concepts/" rel="noopener ugc nofollow" target="_blank"> CircleCI基础</a>。</p><p id="bffc" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">故事书是提高用户界面组件质量的好方法。它为您的组件提供了可视化的交互式文档，使保持一切一致和最新变得容易。除了在本地运行之外，您还可以使用故事书</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/b80532f72546fcce1a43ae09a5aabde8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*arJJtQ_KPfJ3fU_b.gif"/></div></figure><p id="71cf" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated"><a class="ae kf" href="https://www.chromatic.com/" rel="noopener ugc nofollow" target="_blank"> Chromatic </a>是故事书用户的专用平台，它自动收集UI反馈、视觉测试和文档，将故事书体验提升到一个全新的水平。Chromatic的文档为创建自动化流程提供了简单的指导。文档涵盖了很多服务，比如<a class="ae kf" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>、<a class="ae kf" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a>、<a class="ae kf" href="https://www.travis-ci.com/" rel="noopener ugc nofollow" target="_blank"> Tarvis CI </a>等等。</p><p id="e60d" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">一旦你打开了一个彩色帐户，你就可以创建一个项目并获得一个项目令牌。使用您的项目令牌，您可以通过终端上的一个命令来部署您的故事书。</p><pre class="mm mn mo mp gt mt mu mv mw aw mx bi"><span id="9acf" class="lu kh iq mu b gy my mz l na nb">npx chromatic --project-token=YOUR_PROJECT_TOKEN</span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/4a65e00baa6bf1ae53a85176be4ac941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2UrIxBUoE_Qdwfg2gVIgLA.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">创建一个彩色项目后，您可以用一个命令部署您的故事书。</figcaption></figure><p id="5665" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">在接下来的步骤中，我们将看到如何自动化这一过程。</p><h2 id="2ab3" class="lu kh iq bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">基本流程</h2><p id="164b" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因为常见的情况是，您想要将storybook-deploy作业添加到现有的CircleCI配置中，这里假设您已经有了一个基本的CircleCI作业并正在运行。如果没有，您可以通过<a class="ae kf" href="https://circleci.com/docs/getting-started/" rel="noopener ugc nofollow" target="_blank"> CircleCI quickstart </a>轻松设置。这些步骤包括注册CircleCI并为您的项目创建一个<a class="ae kf" href="https://circleci.com/docs/introduction-to-yaml-configurations/" rel="noopener ugc nofollow" target="_blank"> config.yml </a>，它将包含您所有的CircleCI配置。</p><p id="736a" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">然后，<a class="ae kf" href="https://www.chromatic.com/docs/circleci" rel="noopener ugc nofollow" target="_blank"> Chromatic documentation </a>指定了如何将storybook部署添加到您的流程中，分两步:</p><ol class=""><li id="976c" class="nl nm iq la b lb mg le mh lh nn ll no lp np lt nq nr ns nt bi translated">将您的<a class="ae kf" href="https://www.chromatic.com/docs/setup" rel="noopener ugc nofollow" target="_blank">色度项目标记</a>设置为CircleCI仪表板中的环境变量(在下面的示例中，命名为<code class="fe nu nv nw mu b">PROJECT_TOKEN</code>)</li><li id="6c79" class="nl nm iq la b lb nx le ny lh nz ll oa lp ob lt nq nr ns nt bi translated">设置一个<code class="fe nu nv nw mu b">storybook-deployment</code>作业并将其添加到您的工作流程中</li></ol><pre class="mm mn mo mp gt mt mu mv mw aw mx bi"><span id="8c04" class="lu kh iq mu b gy my mz l na nb"># .circleci/config.yml<br/><br/># Other required configuration<br/><br/>jobs:<br/>  # Other jobs (<!-- -->build, <!-- -->deployment etc.)<br/><br/>  # 👇 Adds Chromatic as a job<br/>  storybook-deployment:<br/>    docker:<br/>      - image: circleci/node:12<br/>    working_directory: ~/repo<br/>    steps:<br/>      - checkout<br/>      - restore_cache:<br/>          keys:<br/>            - v1-dependencies-{{ checksum "package.json" }}<br/>            - v1-dependencies-<br/>      - run: yarn install<br/>        # 👇 Runs the Chromatic CLI<br/>      - run: yarn chromatic --project-token=${PROJECT_TOKEN}<br/><br/>workflows:<br/>  # example for a build and deploy workflow<br/>  build-and-deploy:<br/>    jobs:<br/>       <!-- -->- build<br/>       - <!-- -->deployment<br/>       <!-- -->- storybook-deployment # 👈 Runs the Chromatic job above</span></pre><p id="99ff" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">就是这样！在这些步骤之后，当<code class="fe nu nv nw mu b">storybook-deployment</code>被触发时，你的工作流应该将Storybook部署到Chromatic。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="7bc2" class="kg kh iq bd ki kj oj kl km kn ok kp kq jw ol jx ks jz om ka ku kc on kd kw kx bi translated">高效地触发故事书部署</h1><p id="5e3a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">到目前为止，通过遵循官方文档，我们得到了一个基本的部署工作流程。<br/>此时，只要<code class="fe nu nv nw mu b">storybook-deployment</code>被触发，故事书就会被部署。然而，许多代码更改与Storybook无关。没有必要为一个自述文件的改变或者一个没有可视化方面的逻辑代码触发<code class="fe nu nv nw mu b">storybook-deployment</code>。我们希望我们的工作流程更加智能。</p><p id="094e" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">在大多数情况下，只有当相关文件已经被更改时，才需要故事书部署<strong class="la ir">——这意味着我们的UI组件文件、我们的故事文件或者故事书配置文件。</strong></p><p id="69b6" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">不幸的是，<a class="ae kf" href="https://discuss.circleci.com/t/how-to-avoid-ci-if-only-certain-files-change/44360/2" rel="noopener ugc nofollow" target="_blank"> CircleCI对您的git repo </a>中发生的事情一无所知。有几种方法可以绕过这个限制。</p><h2 id="9782" class="lu kh iq bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">动态配置和路径过滤球体</h2><p id="8655" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">就其本质而言，CircleCI是静态的和确定性的，但是现在您可以绕过这个限制。2021年，CircleCI通过设置工作流引入了<a class="ae kf" href="https://circleci.com/blog/introducing-dynamic-config-via-setup-workflows/" rel="noopener ugc nofollow" target="_blank">动态配置。在</a><a class="ae kf" href="https://circleci.com/docs/dynamic-config/#getting-started-with-dynamic-config-in-circleci" rel="noopener ugc nofollow" target="_blank">在你的Circle仪表板</a>中启用这个特性后，你可以开始为你的项目编写动态配置。<a class="ae kf" href="https://circleci.com/docs/dynamic-config/#how-dynamic-config-works" rel="noopener ugc nofollow" target="_blank">主要想法</a>是——创建一个“设置工作流”,它将创建您的管道配置的外观。<a class="ae kf" href="https://circleci.com/blog/building-cicd-pipelines-using-dynamic-config/" rel="noopener ugc nofollow" target="_blank">通过动态创建配置，现在可以使用全新的选项</a>。其中之一是路径过滤orb。</p><p id="09b6" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated"><a class="ae kf" href="https://circleci.com/docs/orb-intro/" rel="noopener ugc nofollow" target="_blank">orb</a>是可重用的代码片段，有助于自动化重复的过程，加速项目设置，并使其易于与第三方工具集成。CircleCI维护着一个包含认证、合作伙伴和第三方orb的orb注册表。<a class="ae kf" href="https://circleci.com/developer/orbs/orb/circleci/path-filtering" rel="noopener ugc nofollow" target="_blank">路径过滤</a> orb可与动态配置一起使用，创建仅在某些文件发生变化时触发的工作流。这个球是经过认证的，这意味着它是由CircleCI团队编写和测试的，所以它应该是安全的。</p><p id="1d10" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">然而，当我读到它时，我在想——“等等，对于这样一个简单的需求，听起来需要做很多工作，不是吗？我们想要的是防止<code class="fe nu nv nw mu b">storybook-deployment</code>进入，除非故事文件已经被改变。我们真的需要这些吗？”</p><p id="66f7" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">所以我一直在寻找其他选择。</p><h2 id="7662" class="lu kh iq bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">使用社区球体</h2><p id="05ee" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">一个更简单的选择是使用社区球。<a class="ae kf" href="https://circleci.com/developer/orbs/orb/roopakv/swissknife#commands-run_if_modified" rel="noopener ugc nofollow" target="_blank"> Swissknife </a>是一个社区orb，它为您的工作流提供了许多常用功能，如<a class="ae kf" href="https://circleci.com/developer/orbs/orb/roopakv/swissknife#commands-run_if_modified" rel="noopener ugc nofollow" target="_blank"> run_if_modified </a>。使用这个命令，您可以仅在某些文件被修改时运行一个步骤，这正是我们想要的。</p><p id="5c8e" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">然而，你应该记住以下来自CircleCI文档的关于球体的<a class="ae kf" href="https://circleci.com/docs/orb-intro/" rel="noopener ugc nofollow" target="_blank">说明</a></p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi oo"><img src="../Images/92748977c540649b129db4bacb23bedd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kWWr-4Rhd7xfsTk6tZJlCA.png"/></div></div></figure><blockquote class="op oq or"><p id="1409" class="ky kz os la b lb mg jr ld le mh ju lg ot mi lj lk ou mj ln lo ov mk lr ls lt ij bi translated"><strong class="la ir">注意:</strong> <em class="iq">为了使用未经认证的orb(合作伙伴或社区)，贵组织的管理员必须在贵组织的</em> <strong class="la ir"> <em class="iq">组织设置&gt;安全性</em> </strong> <em class="iq">页面上选择允许使用未经认证的orb。</em></p></blockquote><p id="129e" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">因为社区orb是由社区编写的，所以应该像对待任何开源代码一样对待这些orb:考虑到安全性。虽然大多数开源代码都是出于好意编写的，但其中总是存在安全风险。</p><p id="0dcd" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">现在，我们都以这样或那样的方式使用开源代码，所以这并不意味着你不应该使用社区orb。然而，尽量减少外部依赖性是一个好习惯，尤其是当涉及敏感数据时。</p><p id="2fbd" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">虽然<a class="ae kf" href="https://circleci.com/developer/orbs/orb/roopakv/swissknife#commands-run_if_modified" rel="noopener ugc nofollow" target="_blank"> Swissknife </a>看起来是我们这个问题的一个很好的解决方案，但是仅仅使用它来阻止<code class="fe nu nv nw mu b">storybook-deployment</code>发挥作用似乎有点矫枉过正，尤其是如果你到目前为止还没有在你的项目中使用过未经认证的球体(我就是这种情况)。考虑到这一点，我寻找了一个更简单的解决方案，并最终写了一个。</p><h2 id="d046" class="lu kh iq bd ki lv lw dn km lx ly dp kq lh lz ma ks ll mb mc ku lp md me kw mf bi translated">拯救脚本</h2><p id="6295" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在寻找解决方案时，我注意到CircleCI讨论上的一个<a class="ae kf" href="https://discuss.circleci.com/t/only-kicking-off-if-changes-are-to-a-specific-folder/9711" rel="noopener ugc nofollow" target="_blank">问题，它引导我找到了一个包含bash脚本</a>的<a class="ae kf" href="https://gist.github.com/naesheim/18d0c0a58ee61f4674353a2f4cf71475" rel="noopener ugc nofollow" target="_blank">要点。主要思想简单而高效:使用git搜索特定路径中的变化:</a></p><pre class="mm mn mo mp gt mt mu mv mw aw mx bi"><span id="604e" class="lu kh iq mu b gy my mz l na nb"># latest commit<br/>LATEST_COMMIT=$(git rev-parse HEAD) </span><span id="3b8d" class="lu kh iq mu b gy ow mz l na nb"># latest commit where path/to/folder1 was changed<br/>FOLDER1_COMMIT=$(git log -1 --format=format:%H --full-diff path/to/folder1)</span><span id="1aaf" class="lu kh iq mu b gy ow mz l na nb">if [ $FOLDER1_COMMIT = $LATEST_COMMIT ]; then<br/>  # do something on change<br/>else<br/> # do something on unchange<br/>fi</span></pre><p id="f823" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated"><code class="fe nu nv nw mu b">git log</code>命令<a class="ae kf" href="https://git-scm.com/docs/git-log" rel="noopener ugc nofollow" target="_blank">显示git提交日志</a>。我们可以用它来获得特定文件路径的最后一次提交。如果我们得到的提交等于最近的提交，这意味着最近的提交包含了<strong class="la ir">文件路径</strong>中的变更。</p><p id="7c08" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">我们来分析一下上面的代码:</p><ol class=""><li id="6bc6" class="nl nm iq la b lb mg le mh lh nn ll no lp np lt nq nr ns nt bi translated"><code class="fe nu nv nw mu b">rev-parse</code>是一个辅助命令，在我们的例子中用于获得<a class="ae kf" href="https://stackoverflow.com/questions/2304087/what-is-head-in-git" rel="noopener ugc nofollow" target="_blank">头</a>的提交散列。这个散列然后被保存到<strong class="la ir"> <em class="os">最新提交</em> </strong>变量</li><li id="d937" class="nl nm iq la b lb nx le ny lh nz ll oa lp ob lt nq nr ns nt bi translated"><code class="fe nu nv nw mu b">git log</code>是用<a class="ae kf" href="https://git-scm.com/docs/git-log" rel="noopener ugc nofollow" target="_blank">下面的参数</a> : <br/> <code class="fe nu nv nw mu b">-1</code> —限制提交输出的次数，所以我们只得到1次提交(最新的)<br/> <code class="fe nu nv nw mu b">-format=format:%H</code>格式化日志消息，只从消息中返回提交哈希。<br/> <code class="fe nu nv nw mu b">/path/to/folder1</code>我们文件的路径<br/>整个命令得到最后一次提交，包括对<code class="fe nu nv nw mu b">/path/to/folder1</code>的修改，并保存到<strong class="la ir"> <em class="os">文件夹1_COMMIT </em> </strong>变量</li><li id="7a11" class="nl nm iq la b lb nx le ny lh nz ll oa lp ob lt nq nr ns nt bi translated">最后，我们比较两个哈希值。如果它们相等—最后一次提交包含<code class="fe nu nv nw mu b">/path/to/folder1</code>中的更改</li></ol><p id="a2dd" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">考虑到这一点，我们只能在某些文件发生变化时调用命令。在我的React应用程序中，仅当对以下路径之一进行了更改时，才需要部署:</p><ul class=""><li id="920b" class="nl nm iq la b lb mg le mh lh nn ll no lp np lt ox nr ns nt bi translated"><code class="fe nu nv nw mu b">./.storybook</code> —故事书配置文件</li><li id="9c4b" class="nl nm iq la b lb nx le ny lh nz ll oa lp ob lt ox nr ns nt bi translated"><code class="fe nu nv nw mu b">./src/stories</code> —故事文件</li><li id="cb4c" class="nl nm iq la b lb nx le ny lh nz ll oa lp ob lt ox nr ns nt bi translated"><code class="fe nu nv nw mu b">./src/components</code> — UI纯可视化组件，对应故事文件。</li></ul><p id="d56e" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">我更喜欢将这段代码放在一个单独的文件中，而不是直接放在CircleCI的<code class="fe nu nv nw mu b">config.yml</code>中。我在<code class="fe nu nv nw mu b">.circleci</code>目录中创建了一个名为<code class="fe nu nv nw mu b">commit-check.sh</code>的文件。</p><p id="a3d2" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">完整的<code class="fe nu nv nw mu b">commit-check.sh</code>文件如下所示:</p><pre class="mm mn mo mp gt mt mu mv mw aw mx bi"><span id="1a3f" class="lu kh iq mu b gy my mz l na nb">set -u<br/>STORYBOOK_DIR="./.storybook"<br/>STORIES_DIR="./src/stories"<br/>UIKIT_DIR="./src/components"</span><span id="0c81" class="lu kh iq mu b gy ow mz l na nb"># current commit<br/>LATEST_COMMIT=$(git rev-parse HEAD)</span><span id="99c1" class="lu kh iq mu b gy ow mz l na nb"># latest commit where path "VAR" was changed<br/>STORYBOOK_COMMIT=$(git log -1 --format=format:%H --full-diff $STORYBOOK_DIR)<br/>STORIES_COMMIT=$(git log -1 --format=format:%H --full-diff $STORIES_DIR)<br/>COMPONENTS_COMMIT=$(git log -1 --format=format:%H --full-diff $UIKIT_DIR)</span><span id="9104" class="lu kh iq mu b gy ow mz l na nb">CHANGED=0<br/>if [ $STORYBOOK_COMMIT = $LATEST_COMMIT ]; then<br/>    echo "Commit check: files in $STORYBOOK_DIR has changed";<br/>    CHANGED=1<br/>fi<br/>if [ $STORIES_COMMIT = $LATEST_COMMIT ]; then<br/>    echo "Commit check: files in $STORIES_DIR has changed";<br/>    CHANGED=1<br/>fi<br/>if [ $COMPONENTS_COMMIT = $LATEST_COMMIT ]; then<br/>    echo "Commit check: files in $COMPONENTS_COMMIT has changed";<br/>    CHANGED=1<br/>fi</span><span id="438a" class="lu kh iq mu b gy ow mz l na nb">if [ $CHANGED -eq 0 ]; then<br/>    echo "Commit check: no storybook changes detected, halt CircleCI agent";<br/>    circleci-agent step halt<br/>fi</span></pre><p id="f728" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">上面的脚本可以改进，但是为了简单起见，我没有改动。我发现限制进程的最简单的方法是当没有相关文件改变时停止它。CircleCI包含一个特殊的命令— <a class="ae kf" href="https://support.circleci.com/hc/en-us/articles/360015562253-Conditionally-End-a-Running-Job-Gracefully" rel="noopener ugc nofollow" target="_blank">步进停止</a>。在文件末尾调用<code class="fe nu nv nw mu b">step halt</code>命令:</p><pre class="mm mn mo mp gt mt mu mv mw aw mx bi"><span id="1189" class="lu kh iq mu b gy my mz l na nb">circleci-agent step halt</span></pre><p id="3659" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated"><code class="fe nu nv nw mu b">step halt</code>被调用，CircleCI将停止当前步骤并结束当前作业。<br/>我已经修改了<code class="fe nu nv nw mu b">config.yml</code>，所以它将在<code class="fe nu nv nw mu b">storybook-deployment</code>之前运行:</p><pre class="mm mn mo mp gt mt mu mv mw aw mx bi"><span id="f617" class="lu kh iq mu b gy my mz l na nb">jobs:<br/><br/>  storybook-deployment:<br/>    # ...<br/>    steps:<br/>      # ...<br/>      - run:<br/>          name: Check file diffs<br/>          command: |<br/>            # will end the process when deployment is not required<br/>            .circleci/commit_check.sh<br/>      - run: yarn install<br/>      - run: yarn chromatic --project-token=${PROJECT_TOKEN}</span></pre><p id="2545" class="pw-post-body-paragraph ky kz iq la b lb mg jr ld le mh ju lg lh mi lj lk ll mj ln lo lp mk lr ls lt ij bi translated">就是这样！使用bash，我们可以完全控制在部署Storybook之前检查什么，并且我们可以在不需要部署的时候结束工作。</p><h1 id="dc8e" class="kg kh iq bd ki kj kk kl km kn ko kp kq jw kr jx ks jz kt ka ku kc kv kd kw kx bi translated">资源</h1><ul class=""><li id="2de8" class="nl nm iq la b lb lc le lf lh oy ll oz lp pa lt ox nr ns nt bi translated"><a class="ae kf" href="https://www.chromatic.com/docs/circleci" rel="noopener ugc nofollow" target="_blank">彩色文档— CircleCI集成</a></li><li id="068f" class="nl nm iq la b lb nx le ny lh nz ll oa lp ob lt ox nr ns nt bi translated"><a class="ae kf" href="https://gist.github.com/naesheim/18d0c0a58ee61f4674353a2f4cf71475" rel="noopener ugc nofollow" target="_blank">使用bash和git比较文件变化</a></li><li id="d85f" class="nl nm iq la b lb nx le ny lh nz ll oa lp ob lt ox nr ns nt bi translated"><a class="ae kf" href="https://circleci.com/blog/introducing-dynamic-config-via-setup-workflows/" rel="noopener ugc nofollow" target="_blank"> CircleCI通过设置工作流程进行动态配置</a></li><li id="bc41" class="nl nm iq la b lb nx le ny lh nz ll oa lp ob lt ox nr ns nt bi translated"><a class="ae kf" href="https://support.circleci.com/hc/en-us/articles/360015562253-Conditionally-End-a-Running-Job-Gracefully" rel="noopener ugc nofollow" target="_blank"> CircleCI </a> <a class="ae kf" href="https://www.chromatic.com/docs/circleci" rel="noopener ugc nofollow" target="_blank"> — </a> <a class="ae kf" href="https://support.circleci.com/hc/en-us/articles/360015562253-Conditionally-End-a-Running-Job-Gracefully" rel="noopener ugc nofollow" target="_blank">停步</a></li><li id="506f" class="nl nm iq la b lb nx le ny lh nz ll oa lp ob lt ox nr ns nt bi translated"><a class="ae kf" href="https://circleci.com/docs/orb-intro/" rel="noopener ugc nofollow" target="_blank">circle ci</a><a class="ae kf" href="https://www.chromatic.com/docs/circleci" rel="noopener ugc nofollow" target="_blank">—</a><a class="ae kf" href="https://circleci.com/docs/orb-intro/" rel="noopener ugc nofollow" target="_blank">宝珠介绍</a></li></ul></div></div>    
</body>
</html>