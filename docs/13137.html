<html>
<head>
<title>How to write a load performance test CLI tool with Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Golang编写负载性能测试CLI工具</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-a-load-performance-test-cli-tool-with-golang-95e332d58ebb?source=collection_archive---------3-----------------------#2022-08-11">https://levelup.gitconnected.com/how-to-write-a-load-performance-test-cli-tool-with-golang-95e332d58ebb?source=collection_archive---------3-----------------------#2022-08-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="3fc8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">背景</h1><p id="ec82" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当您想对HTTP后端服务进行负载性能测试时，一个方便而强大的工具可以让您的工作变得容易得多。比如<code class="fe lj lk ll lm b">ApacheBench</code>(简称<a class="ae ln" href="https://en.wikipedia.org/wiki/ApacheBench" rel="noopener ugc nofollow" target="_blank"> ab </a>)在这个领域的应用非常广泛。但不是今天的话题。相反，我想介绍用<code class="fe lj lk ll lm b">Golang</code>编写的<a class="ae ln" href="https://github.com/rakyll/hey" rel="noopener ugc nofollow" target="_blank"> Hey </a>，并支持与<code class="fe lj lk ll lm b">ab</code>相同的功能。</p><p id="9ba6" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lj lk ll lm b">Hey</code>用法如下:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f7dc" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">我没有列出所有的选项，只是显示了与本文内容相关的几个选项。从上面的列表中可以看出，<code class="fe lj lk ll lm b">Hey</code>可以支持不同的实用特性，比如<strong class="kn ir">多个工作器</strong>以<strong class="kn ir">并发</strong>方式运行，以及<strong class="kn ir">速率限制</strong>通过<strong class="kn ir">查询每秒(QPS) </strong>。它还可以支持<strong class="kn ir">按持续时间运行</strong>和<strong class="kn ir">按请求号运行</strong>两种模式。</p><p id="8b71" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在本文中，我们可以回顾一下<code class="fe lj lk ll lm b">Hey</code>的设计和实现，看看如何制作一个负载性能测试工具。</p><h1 id="76fb" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">建筑设计</h1><p id="e000" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lj lk ll lm b">Hey</code>的设计并不复杂，架构可以分为以下三个部分:</p><ul class=""><li id="c64d" class="ma mb iq kn b ko lo ks lp kw mc la md le me li mf mg mh mi bi translated">控制逻辑:主要工作流，如如何设置多个并发工人，如何控制QPS速率限制器，以及如何在达到持续时间时退出流程；</li><li id="5c5c" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">HTTP请求配置:发送请求所需的头或参数；</li><li id="a6af" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">测试报告:负载测试完成后打印或保存结果。</li></ul><p id="1917" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">架构图如下所示，阅读本文后，您将理解该图中的每个元素:</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/59d2f15f0bc8a067be63cfe58f33de4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Wy1-1Lz3nLEWesye.png"/></div></div></figure><p id="8ee1" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">本文将关注第一项(因为这是真正有趣的部分),展示如何使用<code class="fe lj lk ll lm b">Golang</code>的并发编程技术来实现这些特性。</p><h1 id="960c" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">退出流程</h1><p id="9c72" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<code class="fe lj lk ll lm b">hey.go</code>文件中，可以找到<strong class="kn ir">主</strong>函数的入口点。让我们隐藏样板代码，回顾一下<strong class="kn ir">主</strong>函数中的核心逻辑，如下所示:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="9e5b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">申请人。Work </strong> struct包含所有的选项设置，包括请求号、并发工作者和QPS(它还包含测试结果报告)。</p><p id="0cab" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">创建了<strong class="kn ir">请求者的实例后。工作</strong>，然后调用<strong class="kn ir"> Init() </strong>方法。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="4758" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir"> Init() </strong>方法将初始化两个<code class="fe lj lk ll lm b">channel</code> : <strong class="kn ir">结果</strong>和<strong class="kn ir"> stopCh </strong>。<strong class="kn ir">结果</strong>通道用于请求响应通信。<strong class="kn ir"> stopCh </strong>通道用于发出停止并行工作人员的信号。</p><p id="1f83" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">请注意，有两种方法可以退出程序。第一种是用户手动停止程序，例如按下<strong class="kn ir"> ctrl + c </strong>。在这种情况下，std库中的<code class="fe lj lk ll lm b">signal.Notify()</code>方法可以捕捉信号来终止进程。第二个是按时间<strong class="kn ir">持续时间</strong>选项。两个进程退出逻辑都在一个<code class="fe lj lk ll lm b">Goroutine</code>中运行。</p><p id="0f10" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">要停止工作进程，将调用<strong class="kn ir"> Stop() </strong>方法:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="3322" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">它的作用是向<strong class="kn ir"> stopCh </strong>通道发送几个值。请注意，它向通道发送<strong class="kn ir"> b.C </strong>值，该值与并发工作者的数量相同。</p><p id="46a8" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">你可以想象每个工人应该等待来自<strong class="kn ir"> stopCh </strong>通道的值。当worker收到一个值时，它应该停止发送请求。对吗？那么这样的话，我就可以把所有的并发工都停了。让我们在接下来的部分检查我们的猜测。</p><h1 id="468e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">兼职工人</h1><p id="62c1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在上面的<strong class="kn ir">主</strong>函数中，可以看到<strong class="kn ir"> Run() </strong>被调用:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="20ee" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">有几点值得讨论。在本节中，我们来回顾一下<strong class="kn ir"> runWorkers() </strong>。并且<strong class="kn ir"> runReporter() </strong>和<strong class="kn ir"> Finish() </strong>都与测试结果报告相关，我们将在本文后面重新讨论它们。</p><p id="3849" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir"> runWorkers() </strong>如下所示:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="15d8" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这是一个非常典型的通过<code class="fe lj lk ll lm b">sync.WaitGroup</code>发射多个<code class="fe lj lk ll lm b">goroutine</code>的模式。每个worker都是通过在goroutine中调用<strong class="kn ir"> b.runWorker </strong>来创建的。这样，多个并发工作者可以一起运行。</p><p id="39ab" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">注意，在所有工人完成他们的任务之前，<strong class="kn ir"> wg。Wait() </strong>将阻止<strong class="kn ir"> Finish() </strong>运行，它用于报告测试结果。我们将在接下来的章节中讨论它。</p><p id="f2a5" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">下一步，逻辑进入<strong class="kn ir"> runWorker </strong>方法，让我们回顾一下<strong class="kn ir"> QPS </strong>速率限制是如何工作的？</p><h1 id="e86f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">QPS</h1><p id="fc27" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir"> runWorker </strong>核心代码如下:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="8ac2" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">方法<strong class="kn ir"> runWorker </strong>的第一个参数是用于发送请求的<strong class="kn ir"> client </strong>。我们需要对第二个参数<strong class="kn ir"> n </strong>进行更多的分析，这个参数表示这个工作者需要发出的请求的数量。当<strong class="kn ir"> runWorker </strong>被调用时，<strong class="kn ir"> b.N/b.C </strong>传递给它。<strong class="kn ir"> b.N </strong>是需要发出的请求总数，<strong class="kn ir"> b.C </strong>是并发工人数。<strong class="kn ir"> b.N </strong>除以<strong class="kn ir"> b.C </strong>就是每个工人的请求数。对吗？</p><p id="c908" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">但是如果用户设置了<strong class="kn ir">持续时间</strong>选项，那么请求的数量是多少呢？您可以在<strong class="kn ir">主</strong>输入功能中找到以下逻辑:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="4d67" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">当用户设置<strong class="kn ir">持续时间</strong>选项时，请求编号将为<code class="fe lj lk ll lm b">math.MaxInt32</code>。在这种方法中，<strong class="kn ir">嘿</strong>可以将<strong class="kn ir">按持续时间运行</strong>和<strong class="kn ir">按请求号运行</strong>两种模式结合在一起。</p><p id="8a4f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">正如我们在简介部分提到的，<code class="fe lj lk ll lm b">Hey</code>可以支持<strong class="kn ir"> QPS </strong>速率限制，这个策略写在<strong class="kn ir"> runWorker </strong>方法里面。注意一个<code class="fe lj lk ll lm b">receive-only channel</code> <strong class="kn ir">节流</strong>是用<code class="fe lj lk ll lm b">time.Tick</code>创建的，它在每个时间段发出一个值。并且时间段由下式定义</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="983e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">例如，<strong class="kn ir"> QPS = 1000 </strong>，那么时间段是100ms，每100ms <strong class="kn ir">油门</strong>通道就会接收一个值。</p><p id="8c1a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir"> throttle </strong>放在<strong class="kn ir"> makeRequest() </strong>调用之前，通过这种方式，我们可以实现速率限制的效果。</p><h1 id="f3fd" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">停止工人</h1><p id="48cc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<strong class="kn ir"> runWorker </strong>方法中，还可以看到<code class="fe lj lk ll lm b">select and case</code>的用法。</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="22e2" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">正如我们在上面一节提到的，<strong class="kn ir"> stopCh </strong>通道是用来停止工作的。对吗？现在你可以看到它是如何实现的。它映射到我们上面讨论的<strong class="kn ir">停止</strong>方法，如下所示:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="27bc" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><code class="fe lj lk ll lm b">b.C</code>数量的值被发送到<strong class="kn ir"> stopCh </strong>通道，同时还有<code class="fe lj lk ll lm b">b.C</code>数量的并发工人。每个工作者可以从通道接收一个值并停止运行。</p><h1 id="8fee" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结果报告</h1><p id="3c46" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们快速回顾一下结果报告是如何工作的。首先在<strong class="kn ir"> makeRequest </strong>方法中，每个请求的结果被发送到<strong class="kn ir">结果</strong>通道，如下所示:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="cd5d" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在<code class="fe lj lk ll lm b">runReporter</code>方法中，您可以看到这样的逻辑:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="d6c1" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在这种情况下，使用一个<code class="fe lj lk ll lm b">for</code>从通道接收所有值。注意<strong class="kn ir">循环将继续，直到通道关闭</strong>。这是<code class="fe lj lk ll lm b">Golang</code>中另一个非常典型的并发编程模式。我们可以通过使用<code class="fe lj lk ll lm b">select case</code>模式来实现相同的功能，只要我们可以多添加一个通道来发送退出信号。但是在语法层面上，<code class="fe lj lk ll lm b">for</code>的循环模式要干净得多。</p><p id="0fce" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">所以必须有一个地方关闭通道，否则会出现<code class="fe lj lk ll lm b">deadlock</code>问题。详细的可以参考我之前的<a class="ae ln" href="https://baoqger.github.io/2020/10/26/golang-concurrent-twoways/" rel="noopener ugc nofollow" target="_blank">文章</a>进行更高级的解释。</p><p id="195b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">通道在<strong class="kn ir">结束</strong>方法中关闭，如下所示:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="be11" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">还请注意<strong class="kn ir">完成</strong>通道是如何工作的。<strong class="kn ir">先完成</strong>方法<code class="fe lj lk ll lm b">close</code><strong class="kn ir">结果</strong>通道，然后循环的<strong class="kn ir">将断开<code class="fe lj lk ll lm b">r.done &lt;- true</code>才有机会运行。最后<strong class="kn ir"> b.report.finalize() </strong>可以打印结果，因为<strong class="kn ir"> &lt; -b.report.done </strong>没有被阻塞。t</strong></p><h1 id="b88a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="6679" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文中，我将通过回顾<strong class="kn ir"> Hey </strong>作为一个例子，向您展示如何编写一个负载性能测试CLI工具。在代码层面，我们讨论了Golang提供的几种并发编程模式。并发(或并行)编程是困难的，Golang正是为此而构建的。坚持练习。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="ba35" class="jn jo iq bd jp jq nc js jt ju nd jw jx jy ne ka kb kc nf ke kf kg ng ki kj kk bi translated">分级编码</h1><p id="0afd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="84de" class="ma mb iq kn b ko lo ks lp kw mc la md le me li mf mg mh mi bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="bb2a" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">📰查看<a class="ae ln" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="e995" class="ma mb iq kn b ko mj ks mk kw ml la mm le mn li mf mg mh mi bi translated">🔔关注我们:<a class="ae ln" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ln" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ln" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="933c" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">🚀👉<a class="ae ln" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>