<html>
<head>
<title>Binary Search Trees in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的二分搜索法树</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/binary-search-trees-in-go-58f9126eb36b?source=collection_archive---------5-----------------------#2020-01-21">https://levelup.gitconnected.com/binary-search-trees-in-go-58f9126eb36b?source=collection_archive---------5-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="4eeb" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="30e6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这篇文章中，我们将关注二分搜索法树如何在Golang中实现，以及为什么它们比线性数据结构如数组或链表更受欢迎。</p><p id="b040" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">当我们还在思考为什么树比数组和列表更重要的时候，让我们对本文中将要实现的主要功能有一个基本的概述</p><ol class=""><li id="ff2d" class="lr ls it kq b kr lm kv ln kz lt ld lu lh lv ll lw lx ly lz bi translated">节点插入。</li><li id="533b" class="lr ls it kq b kr ma kv mb kz mc ld md lh me ll lw lx ly lz bi translated">树遍历。</li><li id="b3c9" class="lr ls it kq b kr ma kv mb kz mc ld md lh me ll lw lx ly lz bi translated">获取最小值。</li><li id="aad0" class="lr ls it kq b kr ma kv mb kz mc ld md lh me ll lw lx ly lz bi translated">去找麦克斯。</li></ol><h1 id="2a48" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">什么是树？</h1><p id="0864" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">树是用来表示层次结构的数据结构。它们通常由多个较小的树组成。它们表示用边连接的节点的集合，每个节点保存某种类型的数据。<br/>二叉树是一种最多可以有2个子节点的树。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/936319bd573f7b9abf1e64331fc3b9f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*h8w4gpvpx5_n1kvhzWE0Fw.png"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">一个二叉查找树</figcaption></figure><p id="84c4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">注意:<br/>二叉树可以有任意顺序的节点，但是二叉查找树在排列节点时遵循特定的顺序，如下一节所述。</p><h1 id="7c91" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">为什么需要它们？</h1><p id="f8e1" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">想象一下，在一个数组中寻找一个元素，用一个像数组这样的线性结构来完成这个任务的时间复杂度是O(n ), n随着要搜索的元素数量的增加而增加。</p><p id="6487" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">假设数据以树形结构表示，求值所需的步骤数将减少一半以上(对数时间复杂度O(log N))。发生这种情况是因为每当值被插入到二叉查找树中时，节点(数据)的添加以有序的方式发生，其中左边子节点的<strong class="kq iu">值小于父节点的值，而右边节点的值大于父节点的值</strong>。</p><p id="ac84" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">所以，当我们搜索一个值，如果它小于根，我们可以忽略树的整个右边部分，在树的左边部分递归地重复搜索过程。</p><h2 id="ff54" class="mr jr it bd js ms mt dn jw mu mv dp ka kz mw mx ke ld my mz ki lh na nb km nc bi translated">快速术语</h2><ol class=""><li id="ce25" class="lr ls it kq b kr ks kv kw kz nd ld ne lh nf ll lw lx ly lz bi translated">节点—每个节点都包含指向该节点的子节点的左指针和右指针，以及与该节点相关联的一些数据。</li><li id="8cd5" class="lr ls it kq b kr ma kv mb kz mc ld md lh me ll lw lx ly lz bi translated">叶节点—没有子节点的节点</li><li id="c3d2" class="lr ls it kq b kr ma kv mb kz mc ld md lh me ll lw lx ly lz bi translated">根节点—二叉树的最顶层节点。</li><li id="ca10" class="lr ls it kq b kr ma kv mb kz mc ld md lh me ll lw lx ly lz bi translated">边-将两个节点链接在一起。</li></ol><h1 id="221c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">围棋中的二叉查找树</h1><p id="6cb0" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">本文的重点是在Golang中实现二叉树结构，以及一些添加额外节点、删除节点等功能。</p><p id="98da" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">一个节点(称为treenode)可以表示为Go:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8c6e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这个节点结构存储int值，但是也可以修改它来存储其他数据类型。结构中的左右字段指向其他树节点。</p><h2 id="9759" class="mr jr it bd js ms mt dn jw mu mv dp ka kz mw mx ke ld my mz ki lh na nb km nc bi translated">将节点插入树中</h2><p id="64ba" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这相当简单，我们不断地比较要插入的节点的值和二叉树中的节点。如果要插入的数据的值小于要比较的节点，如果左子节点为零，我们可以插入新节点作为左节点，否则我们将其与左子树进行比较，并重复该过程。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="65b4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这些功能中的每一个都被实现为接收器功能。</p><h2 id="1093" class="mr jr it bd js ms mt dn jw mu mv dp ka kz mw mx ke ld my mz ki lh na nb km nc bi translated">获取最小值</h2><p id="698b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这将从树中获取最小元素。这种方法是递归的。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="57e5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们不断检查左边子元素的值，直到它达到零值。</p><h2 id="a437" class="mr jr it bd js ms mt dn jw mu mv dp ka kz mw mx ke ld my mz ki lh na nb km nc bi translated">获取最大值</h2><p id="07f4" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这将从树中获取最大元素。这种方法和min一样是递归的。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2768" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们不断检查右子代的值，直到它达到零值。</p><h2 id="56da" class="mr jr it bd js ms mt dn jw mu mv dp ka kz mw mx ke ld my mz ki lh na nb km nc bi translated">二叉查找树中的遍历</h2><p id="5612" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于有效的二叉查找树，inorder遍历将总是以升序进行。</p><p id="93f1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">有序遍历是遍历二叉树的一种方式，首先访问左边的子节点，然后是父节点，最后是右边的子节点。下面的代码显示了遍历的递归方法。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="555a" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="d50b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">二叉树在数据检索方面令人惊叹，因为它们的性能比线性搜索操作好得多。</p><p id="8a6b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">一个有效的二叉树的左子树的值小于根，右子树的值大于根。</p><p id="2809" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">包含许多其他功能的完整代码可在-<a class="ae nm" href="https://github.com/puneeth8994/binary-tree-go-impl" rel="noopener ugc nofollow" target="_blank">https://github.com/puneeth8994/binary-tree-go-impl</a>获得</p></div></div>    
</body>
</html>