<html>
<head>
<title>Minimum Swaps To Make Sequences Increasing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使序列增加的最小交换</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/minimum-swaps-to-make-sequences-increasing-3dfac67f26f2?source=collection_archive---------8-----------------------#2020-03-28">https://levelup.gitconnected.com/minimum-swaps-to-make-sequences-increasing-3dfac67f26f2?source=collection_archive---------8-----------------------#2020-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3979" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个LeetCode中级问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/7bc24acbc9be988aa03fd73eef1ae9e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*tHhAFyRCCa1TKCFf.png"/></div></figure><p id="366c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是来自LeetCode的一个有趣的问题。这是一个中级问题。它在谷歌被问了9次，在亚马逊编码面试中被问了两次。</p><h1 id="b249" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">那么问题是什么呢？</h1><p id="97b6" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">我们有两个非零长度的整数序列A和B。</p><p id="e1db" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们可以交换元素A[i]和B[i]。请注意，这两个元素在各自的序列中位于相同的索引位置。</p><p id="d942" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在一定数量的互换结束时，A和B都在严格增加。</p><blockquote class="mg"><p id="5d7a" class="mh mi iq bd mj mk ml mm mn mo mp li dk translated">一个序列是严格递增的当且仅当<br/>A[0]&lt;A[1]&lt;A[2]&lt;…&lt;A[A . length—1]</p></blockquote><p id="1c4a" class="pw-post-body-paragraph kn ko iq kp b kq mq jr ks kt mr ju kv kw ms ky kz la mt lc ld le mu lg lh li ij bi translated">给定A和B，我们必须返回最小数量的交换，以使两个序列严格递增。保证给定的输入总是使其成为可能。</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="8c69" class="na lk iq mw b gy nb nc l nd ne"><strong class="mw ir">Example:</strong><br/><strong class="mw ir">Input:</strong> A = [1,3,5,4], B = [1,2,3,7]<br/><strong class="mw ir">Output:</strong> 1<br/><strong class="mw ir">Explanation: </strong><br/>Swap A[3] and B[3].  Then the sequences are:<br/>A = [1, 3, 5, 7] and B = [1, 2, 3, 4]<br/>which are both strictly increasing.</span></pre><blockquote class="nf ng nh"><p id="bc47" class="kn ko ni kp b kq kr jr ks kt ku ju kv nj kx ky kz nk lb lc ld nl lf lg lh li ij bi translated"><strong class="kp ir">注:</strong></p><p id="8d46" class="kn ko ni kp b kq kr jr ks kt ku ju kv nj kx ky kz nk lb lc ld nl lf lg lh li ij bi translated">a、B是长度相同的数组，长度会在<br/>【11000】范围内。</p><p id="e58d" class="kn ko ni kp b kq kr jr ks kt ku ju kv nj kx ky kz nk lb lc ld nl lf lg lh li ij bi translated">A[i]，B[i]是范围[0，2000]内的整数值。</p></blockquote></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="b44b" class="lj lk iq bd ll lm nt lo lp lq nu ls lt jw nv jx lv jz nw ka lx kc nx kd lz ma bi translated">找到解决方案:</h1><h2 id="e1c0" class="na lk iq bd ll ny nz dn lp oa ob dp lt kw oc od lv la oe of lx le og oh lz oi bi translated">采取的方法:<strong class="ak">动态规划</strong></h2><p id="280f" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">让我们考虑以下情况-</p><blockquote class="nf ng nh"><p id="6337" class="kn ko ni kp b kq kr jr ks kt ku ju kv nj kx ky kz nk lb lc ld nl lf lg lh li ij bi translated"><strong class="kp ir"> ni → </strong>自然递增序列，因此在位置I处<strong class="kp ir">而不是</strong>完成交换。<br/> <strong class="kp ir"> si → </strong>表示直到位置I的交换次数，考虑在位置I处完成交换。</p></blockquote><ol class=""><li id="afbf" class="oj ok iq kp b kq kr kt ku kw ol la om le on li oo op oq or bi translated">让变量<strong class="kp ir"> n1 </strong>表示直到第(i-1)个位置没有交换的成本，在这种情况下，元素自然地按顺序增加。这意味着n1将是自然增加的元素的数量，直到(i-1)的位置。</li><li id="1cb7" class="oj ok iq kp b kq os kt ot kw ou la ov le ow li oo op oq or bi translated">设变量<strong class="kp ir"> n2 </strong>表示自然增加到第(I)个位置的成本，因此在第I个位置不需要执行交换。</li><li id="e0f3" class="oj ok iq kp b kq os kt ot kw ou la ov le ow li oo op oq or bi translated">让变量<strong class="kp ir"> s1 </strong>代表在第(i-1)个位置进行交换时的成本。</li><li id="adc5" class="oj ok iq kp b kq os kt ot kw ou la ov le ow li oo op oq or bi translated">让变量<strong class="kp ir"> s2 </strong>代表在第(I)个位置进行交换时的成本。</li></ol><h2 id="fc02" class="na lk iq bd ll ny nz dn lp oa ob dp lt kw oc od lv la oe of lx le og oh lz oi bi translated">初始值</h2><p id="6ee7" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated"><strong class="kp ir"> n1=0 </strong> → n1自然会是0，因为第一个元素之前没有更大的元素，所以所需的交换次数会是0</p><p id="05b0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> s1=1 </strong> →考虑到第一个元素被交换，所以1交换到第一个位置</p><h1 id="9605" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">现在，对于每个循环迭代，我们基本上需要考虑两种方法:</h1><h2 id="57e2" class="na lk iq bd ll ny nz dn lp oa ob dp lt kw oc od lv la oe of lx le og oh lz oi bi translated">案例1:</h2><p id="f7db" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">当数组a[]和b[]的相邻元素严格递增时</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="44e5" class="na lk iq mw b gy nb nc l nd ne"><strong class="mw ir">if(a[i-1]&lt;a[i] &amp;&amp; b[i-1]&lt;b[i])</strong></span></pre><p id="36d8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> n2=Math.min(n1，N2)；</strong></p><p id="ad1f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> s2=Math.min(s2，S1+1)；</strong> →考虑在位置I进行交换。第(I)个位置的交换可能需要用于第(i+1)个位置元素，以保持严格递增的属性。</p><h2 id="a88e" class="na lk iq bd ll ny nz dn lp oa ob dp lt kw oc od lv la oe of lx le og oh lz oi bi translated">案例二:</h2><p id="db41" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">当对角线元素也严格增加时</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="5040" class="na lk iq mw b gy nb nc l nd ne"><strong class="mw ir">if(a[i-1]&lt;b[i] &amp;&amp; b[i-1]&lt;a[i])</strong></span></pre><blockquote class="nf ng nh"><p id="4c91" class="kn ko ni kp b kq kr jr ks kt ku ju kv nj kx ky kz nk lb lc ld nl lf lg lh li ij bi translated"><strong class="kp ir">注:</strong>如果对角元素是严格递增的，那么两个数组的相邻元素可能是也可能不是严格递增的。</p></blockquote><p id="2e51" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果情况1和情况2都成立..即，如果相邻元素严格增加，对角元素也严格增加，那么<strong class="kp ir"> n2 </strong>和<strong class="kp ir"> s2 </strong>的值需要被floored。</p><p id="8400" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> n2=Math.min(n2，S1)；</strong> →考虑到我们没有交换，n2将是第(I)个位置之前的自然n2和第(i-1)个位置之前的交换次数s2之间的最小值。这适用于相邻元素没有严格增加，但对角线元素严格增加，因此需要进行交换的情况。</p><p id="08bf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir"> s2=Math.min(s2，n1+1) </strong> →最小的(直到第I个位置完成的交换)和(直到第(i-1)个位置的自然计数+对于第I个位置完成的1次交换)。(n1+1)被作为第二个参数，因为即使对于对角线元素，元素也是严格递增的，所以即使我们交换第(I)个元素，成本最终也是(n1+1)。</p><p id="a6b2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在循环开始考虑下一对元素的迭代之前，<br/>n1 = N2；<br/>S1 = S2；</p><h2 id="7c51" class="na lk iq bd ll ny nz dn lp oa ob dp lt kw oc od lv la oe of lx le og oh lz oi bi translated">最后，</h2><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="d16e" class="na lk iq mw b gy nb nc l nd ne">return Math.min(n1,s1);</span></pre><p id="6e92" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">返回最小的自然数和交换数。</p><h2 id="2002" class="na lk iq bd ll ny nz dn lp oa ob dp lt kw oc od lv la oe of lx le og oh lz oi bi translated"><strong class="ak">下面是用Java编写的函数，供你参考:</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="oz pa gj gh gi pb pc bd b be z dk translated">计算使序列递增的最小交换次数的函数</figcaption></figure></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><blockquote class="nf ng nh"><p id="8aab" class="kn ko ni kp b kq kr jr ks kt ku ju kv nj kx ky kz nk lb lc ld nl lf lg lh li ij bi translated"><strong class="kp ir">资源:</strong> <br/> 1。<a class="ae pd" href="https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/solution/" rel="noopener ugc nofollow" target="_blank"> LeetCode问题编号801</a>2<br/>。GitHub知识库提供其他类似LeetCode问题的解决方案</p></blockquote></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><blockquote class="nf ng nh"><p id="082a" class="kn ko ni kp b kq kr jr ks kt ku ju kv nj kx ky kz nk lb lc ld nl lf lg lh li ij bi translated">仅此而已！感谢您一路阅读！请留下您的反馈。如果你喜欢这个博客，请留下一些掌声👏也是。</p><p id="5c2a" class="kn ko ni kp b kq kr jr ks kt ku ju kv nj kx ky kz nk lb lc ld nl lf lg lh li ij bi translated">你可以在—<br/>Github:<a class="ae pd" href="https://github.com/Spreeha" rel="noopener ugc nofollow" target="_blank">https://github.com/Spreeha</a><br/>LinkedIn:<a class="ae pd" href="https://www.linkedin.com/in/spreehadutta/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/spreehadutta/</a><br/>Twitter:<a class="ae pd" href="https://twitter.com/DuttaSpreeha" rel="noopener ugc nofollow" target="_blank">https://twitter.com/DuttaSpreeha</a>上联系我</p></blockquote></div></div>    
</body>
</html>