<html>
<head>
<title>Creating a Force Graph using React, D3, and PixiJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React、D3和PixiJS创建力图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-force-graph-using-react-d3-and-pixijs-95616051aba?source=collection_archive---------16-----------------------#2021-03-07">https://levelup.gitconnected.com/creating-a-force-graph-using-react-d3-and-pixijs-95616051aba?source=collection_archive---------16-----------------------#2021-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4a51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个月前，我发表了一篇关于如何使用React和D3 创建力图的文章。但是如果力图数据源巨大呢？你还会使用D3吗，或者有其他的解决方案吗？<br/>在这篇文章中，我将解释如何结合D3和PixiJS来创建几乎相同的力图，但以不同的方式，这将使你能够支持更大的数据源。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="cd34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们创建的应用程序中，我们面临着一个非常棘手的性能问题。虽然D3帮助我们创建了需要在屏幕上显示的相关力图，但我们使用的数据源变得非常大。当使用D3时，下面的图形表示是使用SVG创建的，这意味着当数据源变大时，SVG元素的数量也会增加。屏幕上的SVG元素越多，应用程序的性能就越差。</p><p id="368d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，如何才能解决问题呢？如果我们可以将D3 SVG表示转换成canvas表示会怎么样。那会有帮助吗？<br/>在我们的应用中，这很有帮助。</p><h2 id="ba41" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">输入PixiJS</h2><p id="4bac" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">PixiJS是一个灵活的2D WebGL渲染器库，它工作在HTML5 canvas元素之上。</p><p id="34e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lr">注意——我不会在这篇文章中谈论PixiJS的基础知识，我鼓励你去它的</em> <a class="ae kl" href="https://www.pixijs.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lr">网站</em> </a> <em class="lr">做进一步的阅读。</em></p><p id="3fa8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，我所做的是一方面使用D3力图模拟来保持力图模拟，我让PixiJS处理画布元素上的所有渲染。</p><h2 id="8f93" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">创建示例应用程序</h2><p id="8f74" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">我将对我在“<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/creating-a-force-graph-using-react-and-d3-6579bcd9628c">使用React和D3 </a>创建力图”帖子中创建的应用进行一点重构。这意味着，如果你还没有阅读它，那么在你继续阅读这篇文章之前，先去阅读它。</p><p id="3faf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先你需要安装PixiJS库。在命令行中运行以下代码来安装PixiJS和PixiJS Viewport，这将帮助我们支持诸如放大和缩小之类的操作:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="52dd" class="kt ku iq lx b gy mb mc l md me"><strong class="lx ir">npm i</strong> <strong class="lx ir">pixi.js pixi-viewport</strong></span></pre><p id="e015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装完库之后，我们就可以开始了。</p><p id="a36c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将使用我在上一篇文章中创建的相同的<strong class="jp ir"> ForceGraph </strong>组件容器，但是这次我将使用<strong class="jp ir"> runForceGraphPixi </strong>函数，而不是<strong class="jp ir"> runForceGraph </strong>。runForceGraphPixi 将负责创建和运行新的力图。</p><h2 id="d98b" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">构建力图生成器</h2><p id="bb54" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">力图形生成器将是一个负责生成图形的功能。下面是获取包含div、链接和节点数据以及生成节点工具提示的函数的声明:</p><figure class="ls lt lu lv gt mf"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="afef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到我导入了D3和PixiJS，并且使用了我在上一篇文章的<strong class="jp ir"> runForceGraph </strong>中使用的相同签名。现在让我们实现函数。</p><p id="6f14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一行代码将复制数据并获得容器的<strong class="jp ir">宽度</strong>和<strong class="jp ir">高度</strong>:</p><figure class="ls lt lu lv gt mf"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="d8e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还添加了一个变量，稍后我将使用它来控制节点的拖放，并清除容器中先前生成的HTML内容。</p><p id="f6ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，让我们添加几个辅助函数:</p><figure class="ls lt lu lv gt mf"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="01b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">助手函数将帮助我们添加工具提示，支持节点的着色，并创建拖放功能。</p><p id="4782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们添加将创建节点及其链接的代码，并将模拟力图:</p><figure class="ls lt lu lv gt mf"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="4f0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意我加了两个<strong class="jp ir"> Pixi。应用</strong>和<strong class="jp ir"> d3 .力模拟</strong>。PixiJS应用程序将根据D3公开的力模拟负责图形渲染。</p><p id="f277" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当图表准备就绪时，我们将添加几个事件处理程序来处理tick发生时将要发生的事情:</p><figure class="ls lt lu lv gt mf"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="621a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在tick事件中，我们清理所有链接，然后再次在画布上重新绘制它们。</p><p id="8d11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后但同样重要的是，我们将返回图形容器在卸载图形时使用的销毁函数:</p><figure class="ls lt lu lv gt mf"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="0f6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个函数源代码:</p><figure class="ls lt lu lv gt mf"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="0e8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在一切就绪，你可以运行应用程序，看看你的花式力图。</p><figure class="ls lt lu lv gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/4df05e6e003860812c3ecae53f114c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pKQw_62EAYzW2HuFio5ijw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">生成的力图</figcaption></figure><h1 id="55be" class="mt ku iq bd kv mu mv mw ky mx my mz lb na nb nc le nd ne nf lh ng nh ni lk nj bi translated">摘要</h1><p id="8f79" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">在这篇文章中，我展示了如何使用<strong class="jp ir"> React、D3 </strong>和<strong class="jp ir"> PixiJS </strong>库创建一个力图组件。你可以在这里找到图形代码<a class="ae kl" href="https://onedrive.live.com/?authkey=%21AL75phd8K0DQDgs&amp;id=CC807E0FCC4169F4%2137455&amp;cid=CC807E0FCC4169F4" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>