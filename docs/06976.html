<html>
<head>
<title>5 Advanced TypeScript Tips To Make You a Better Programmer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你成为更好的程序员的5个高级打字技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-advanced-typescript-tips-to-make-you-a-better-programmer-bd4070aa2ab4?source=collection_archive---------0-----------------------#2021-01-17">https://levelup.gitconnected.com/5-advanced-typescript-tips-to-make-you-a-better-programmer-bd4070aa2ab4?source=collection_archive---------0-----------------------#2021-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0d6395587eb99150e5dcc245626de532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RKICUYO863Mu_2mX.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">漂亮:)</figcaption></figure><p id="d725" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Typescript是一种令人惊叹的语言——它允许我们在十分之一的调试时间内完成JavaScript所能做的一切。这些提示主要针对:</p><ul class=""><li id="8cad" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated">通过编写更明确、更容易理解的代码来减少错误</li><li id="2da6" class="ld le it kh b ki lm km ln kq lo ku lp ky lq lc li lj lk ll bi translated">在你的代码中加入更多的价值，而不用重新发明轮子。</li></ul><p id="a98e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你已经知道这些，那么恭喜你！你是TS的传奇——也许可以在评论中与我分享你的智慧(<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/5-tips-for-better-typescript-code-5603c26206ef">,并阅读我的另一篇关于5个不同技巧的文章</a>!).</p><p id="76f7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里有5个高级打字技巧，可以让你写出更好的打字代码。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h2 id="d3f6" class="lz ma it bd mb mc md dn me mf mg dp mh kq mi mj mk ku ml mm mn ky mo mp mq mr bi translated">1.“是”操作员/类型防护装置</h2><p id="4eda" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">Swagger非常非常有助于了解后端将为您提供什么服务——但是，更多的时候，程序员会得到糟糕或不一致的API来使用，其中属性可能存在，也可能不存在，或者根据状态返回不同的对象。</p><p id="cb09" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">不幸的是，如果您不知道API可能会产生什么结果，就没有办法在编译时捕捉到这些错误，但是我们可以让它变得容易处理(和报告！)在运行时。</p><p id="a042" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">API通常是typescript错误的入口点，API调用结果通常如下所示:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="4371" class="lz ma it nc b gy ng nh l ni nj">const myApiResult = await callApi("url.com/endpoint") as IApiResult</span></pre><p id="ee16" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">或者更糟…</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="cadf" class="lz ma it nc b gy ng nh l ni nj">const myApiResult = await callApi("url.com/endpoint") as any</span></pre><p id="04ed" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这两种方法都让编译器闭嘴，但是第一种方法明显比第二种更健壮——事实上，第二种方法只是将您对结果所做的任何事情都变成了JavaScript级别的不确定性。</p><p id="211b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是如果API给了我们一些不是<code class="fe nk nl nm nc b">IApiResult</code>的东西呢？如果它返回不同的东西，现在我们有一个随机的对象类型被转换为<code class="fe nk nl nm nc b">MyApiResult</code>会怎么样？这将是糟糕的，并且将100%导致输入错误。</p><p id="8343" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们可以使用TS型防护装置:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="bec9" class="lz ma it nc b gy ng nh l ni nj">interface IApiResponse { <br/>   bar: string<br/>}</span><span id="58b0" class="lz ma it nc b gy nn nh l ni nj">const callFooApi = async (): Promise&lt;IApiResponse&gt; =&gt; {<br/> let response = await httpRequest('foo.api/barEndpoint') //returns unknown<br/> if (responseIsbar(response)) {<br/>   return response<br/> } else {<br/>   throw Error("response is not of type IApiResponse")<br/> }<br/>}</span><span id="5a75" class="lz ma it nc b gy nn nh l ni nj">const responseIsBar = (response: unknown): response is IApiResponse =&gt; {<br/>    return (response as IApiResponse).bar !== undefined<br/>        &amp;&amp; typeof (response as IApiResponse).bar === "string"<br/>}</span></pre><p id="6e76" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通过使用<code class="fe nk nl nm nc b">responseIsBar</code>，我们可以保证不会先发制人地将响应发送给<code class="fe nk nl nm nc b">IApiResponse</code>，从而防止错误的发生。</p><p id="7aae" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在一个实际的用例中，你可能会向用户显示一个类似“从服务器得到了意外的响应，请重试”或类似的错误，而不是<code class="fe nk nl nm nc b">property 'bar' does not exist</code>。</p><p id="0a5a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">作为对“is”操作符的一般解释:<code class="fe nk nl nm nc b">value is type</code>实际上是一个布尔值，当输入true时，它告诉typescript值…嗯，是类型。</p><h2 id="9b30" class="lz ma it bd mb mc md dn me mf mg dp mh kq mi mj mk ku ml mm mn ky mo mp mq mr bi translated">2.作为常量/只读</h2><p id="4424" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">这是一个更简单，更符合语法的糖类型的东西。大多数人都知道，在分配一个接口时，可以写“readonly”来使该属性不可变。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="24b9" class="lz ma it nc b gy ng nh l ni nj">interface MyInterface {<br/>  readonly myProperty: string<br/>}</span><span id="b2d4" class="lz ma it nc b gy nn nh l ni nj">let t: MyInterface = {<br/>  myProperty: 'hi'<br/>}</span><span id="2e66" class="lz ma it nc b gy nn nh l ni nj">t.myProperty = "bye" //compiler err, saying myProperty is Read Only.</span></pre><p id="5e4a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这很好，直到你最终得到真正的大数据类，可能来自API结果。然后在每个属性前都有一个只读的垃圾邮件，只是对于一个简单的数据类。</p><p id="3dd5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Typescript支持在声明后使用“as const ”,这样我们就可以为每个属性添加readonly。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="20c7" class="lz ma it nc b gy ng nh l ni nj">let t = {<br/> myProperty: "hi" <br/> myArr: [1, 2, 3]<br/>} as const </span></pre><p id="f3cf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，T的每个属性都是不可变的。例如，<code class="fe nk nl nm nc b">t.myArr.push(1)</code>不会编译，重新分配<code class="fe nk nl nm nc b">myProperty</code>同样也不会编译。</p><p id="d2d5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我认为这是最有帮助的用例与前面的相同——不过，我们不是返回接口，而是希望代理从API调用的对象，并更改一些属性，使其成为数据对象。所以，结合前面的提示:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="e6d9" class="lz ma it nc b gy ng nh l ni nj">const callFooApi = async () =&gt; {<br/> let response = await httpRequest('foo.api/barEndpoint') //returns unknown<br/> if (responseIsbar(response)) {<br/>   //filter out unecessary data, do whatever formatting is required<br/>   return {<br/>      firstLastName: [response.firstName, response.lastName]<br/>   } as const<br/> } else {<br/>   throw Error("response is not of type IApiResponse")<br/> }<br/>}</span></pre><p id="8e32" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">任何从事这项工作的程序员都会喜极而泣——在返回值上仍然有智能感知(类型是从<code class="fe nk nl nm nc b">response </code>变量派生出来的)，但是它是不可变的。我们调用API，验证响应是我们期望的，然后以一种易于使用的方式返回它。这对所有人都是一个胜利！</p><p id="3465" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">作为一个小的补充，如果你想声明类型，但不想只读垃圾邮件，你可以做:<code class="fe nk nl nm nc b">type MyTypeReadonly = Readonly&lt;MyType&gt;</code>。我们将在第5点中更深入地讨论这一点。</p><h2 id="7e16" class="lz ma it bd mb mc md dn me mf mg dp mh kq mi mj mk ku ml mm mn ky mo mp mq mr bi translated">3.详尽的开关盒</h2><p id="4d2f" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">由于切换用例，扩展枚举通常是一件痛苦的事情——在我们打开枚举的任何地方，我们现在都需要添加另一个用例。如果我们错过了一个，我们就太不走运了，我们的程序会进入默认情况(如果有的话)或者失败，经常会导致意想不到的行为。</p><p id="8878" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">没有人喜欢无意识的行为。</p><p id="c46f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">许多语言通过强制开关情况要么详尽，要么有一个明确的<code class="fe nk nl nm nc b">default</code>状态来解决这个问题。Typescript对此没有编译器支持，但是我们可以以这样一种方式创建我们的开关情况，如果我们扩展一个枚举或一个可能的值，我们的程序将不会编译，直到我们显式地处理那个情况。</p><p id="3998" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">假设我们有这样的情况:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="551b" class="lz ma it nc b gy ng nh l ni nj">enum Directions {<br/>   Left,<br/>   Right<br/>}</span><span id="512b" class="lz ma it nc b gy nn nh l ni nj">const turnTowards = randomEnum(Direction)</span><span id="faf7" class="lz ma it nc b gy nn nh l ni nj">switch (turnTowards) {<br/>      case Directions.Right:<br/>         console.log('we\'re going right!')<br/>         break<br/>      case Directions.Left:<br/>         console.log('Turning left!')<br/>         break<br/>}</span></pre><p id="efc2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">即使是最菜鸟的程序员也可以说我们不是左转，就是右转。这里没有必要添加默认语句，这里只有两个枚举。但是请记住，我们编码不仅仅是为了完成任务，而是为了编写可维护的代码！</p><p id="2cb6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">比如说两年后，一个开发商决定增加一个新的方向:前进。现在，枚举看起来像这样:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="f97a" class="lz ma it nc b gy ng nh l ni nj">enum Directions {<br/>   Left,<br/>   Right,<br/>   Forward<br/>}</span></pre><p id="1ea3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">开关盒知道这一点，但它<em class="no">不在乎。</em>它会很乐意尝试打开<code class="fe nk nl nm nc b">goingTowards</code>，但如果遇到前锋，它会很乐意倒下。两年是一段很长的时间，开发者忘记了开关盒的存在。我们可以添加一个抛出错误的默认案例，但是与compiletime相比，运行时错误是糟糕的。</p><p id="e823" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以我们添加了这个默认案例:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="edac" class="lz ma it nc b gy ng nh l ni nj">default:<br/>   const exhaustiveCheck: never = myDirection<br/>   throw new Error(exhaustiveCheck)</span></pre><p id="dc18" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们把握住了“前进”的方向，那么一切都会好的。如果我们不这样做，那么我们的程序甚至不会编译！(<code class="fe nk nl nm nc b">throw</code>行是可选的，我这么做只是为了关闭eslint中未使用的变量)</p><p id="b2f5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这减少了每次我们决定打开枚举时记忆的心理开销，并让编译器为我们找到它们。</p><h2 id="1ec4" class="lz ma it bd mb mc md dn me mf mg dp mh kq mi mj mk ku ml mm mn ky mo mp mq mr bi translated">4.用Null代替？操作员</h2><p id="bde1" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">许多来自其他语言的人会认为null === undefined，但事实根本不是这样(别担心，这个技巧会变得更好！).</p><p id="3f87" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Undefined是JS可以赋值的——例如，如果我们有一个textbox，但没有输入任何值，那么它就是undefined。把undefined想象成JS的自动空。</p><p id="0edd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">很难判断一个字段是被设计为未定义的，还是我们不小心把它留在了那里。如果我有意想给一个字段赋值，我会使用null。这样，每个人都知道该字段是故意留空的。</p><p id="d6ea" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里有一个例子:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="5df1" class="lz ma it nc b gy ng nh l ni nj">interface Foo {<br/>   bar?: string<br/>}</span></pre><p id="92fd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">属性栏以一个问号结尾，这意味着字段可以是未定义的，所以做<code class="fe nk nl nm nc b">let baz: Foo = {}</code>编译(作为补充说明，<code class="fe nk nl nm nc b">let baz: Foo = {bar: null} </code>也编译)。然而，开发人员可能不知道我是有意将bar留空，还是无意中留下的。传播我的意图的一个更好的方法是创建这样的接口:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="e48a" class="lz ma it nc b gy ng nh l ni nj">interface Foo {<br/>  bar: string | null<br/>}</span></pre><p id="fbf1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">而现在，我们不得不<strong class="kh iu">明确声明bar为null。</strong>我的意图不容置疑——bar本来就没有价值。</p><p id="3ee1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这不仅仅对声明接口有好处——当函数可能不返回任何内容时，我也会使用它。这在编译时很有帮助:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="e9a6" class="lz ma it nc b gy ng nh l ni nj">//if we forget to return something, compiler will let <br/>const myFunc = (): string | void =&gt; {<br/>   console.log('blah')<br/>}</span><span id="3650" class="lz ma it nc b gy nn nh l ni nj">//if we forget to return, the compiler makes us return null<br/>const myFunc = (): string | null =&gt; {<br/> //compile time error for not returning null<br/>}</span></pre><h2 id="fca7" class="lz ma it bd mb mc md dn me mf mg dp mh kq mi mj mk ku ml mm mn ky mo mp mq mr bi translated">5.实用程序类型</h2><p id="aafa" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">如果你曾经做过大型的TS项目，你就会知道接口无处不在。有些是其他名称的精确副本，有些是其他名称的某些属性的副本，有些是组合属性的接口。</p><p id="d77b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果是这样，不要惊慌。您正在按预期安全地使用TS。但是，如果不利用内置类型，您可能会编写太多代码。这里是内置类型的<a class="ae lr" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">链接，你至少应该知道它们存在</a>，这样你就可以在你的代码中使用它们。</p><p id="f349" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我将浏览我最喜欢的和我最常用的，但是你知道的越多，你就能更好地编写你的代码。</p><p id="47ac" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">部分</strong></p><p id="10f9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">将所有类型字段设置为可选。这在您想要对对象执行更新时非常有用，例如:</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="7c21" class="lz ma it nc b gy ng nh l ni nj">function updateBook&lt;T extends Book&gt;(book: T, updates: Partial&lt;T&gt;) {<br/>   const updatedBook = {...book, ...updates }<br/>   notifyServer(updatedBook)<br/>   return updatedBook<br/>}</span></pre><p id="c5ec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">只读</strong></p><p id="c31e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个函数将所有字段设置为只读。我用这个作为返回值，主要是在返回数据类的时候。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="68cb" class="lz ma it nc b gy ng nh l ni nj">function generateData(): Readonly&lt;T&gt;</span></pre><p id="f8da" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">不可空</strong></p><p id="baed" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">创建移除null / undefined的新类型。如果我们正在丰富或填写一些数据，这是有用的，我们现在保证它在那里。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="00b1" class="lz ma it nc b gy ng nh l ni nj">interface IPerson {<br/>  name: string<br/>}</span><span id="7140" class="lz ma it nc b gy nn nh l ni nj">type MaybePerson = Person | null</span><span id="48ee" class="lz ma it nc b gy nn nh l ni nj">const fillMaybePerson = (maybe: MaybePerson): NonNullable&lt;MaybePerson&gt; ...</span></pre><p id="7ab4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">返回类型</strong></p><p id="03c1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">类型是函数的返回类型。如果您正在编写一个覆盖函数的API，并且不想约束函数，那么这是非常有用的。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="e3b1" class="lz ma it nc b gy ng nh l ni nj">const getMoney = (): number =&gt; {<br/>  return 100000<br/>}</span><span id="028b" class="lz ma it nc b gy nn nh l ni nj">ReturnType&lt;getMoney&gt; //number</span></pre><p id="e069" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">必填</strong></p><p id="5aa7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">移除？来自接口的所有字段。</p><pre class="mx my mz na gt nb nc nd ne aw nf bi"><span id="7a06" class="lz ma it nc b gy ng nh l ni nj">interface T {<br/>  maybeName?: string<br/>}</span><span id="978b" class="lz ma it nc b gy nn nh l ni nj">type CertainT = Required&lt;T&gt; // equal to { maybeName: string }</span></pre></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="fad6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就是这样！如果你在任何地方看到一个错误，请尽快让我知道，这样我就可以在其他人发现错误之前修复它。如果你认为我错过了什么，请告诉我！</p><p id="cee0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">否则，我希望你学到了一些可以成为更好的程序员的东西。</p></div></div>    
</body>
</html>