# “完美项目”如何差点毁了我这个程序员

> 原文：<https://levelup.gitconnected.com/how-the-perfect-project-nearly-ruined-me-as-a-programmer-8fc72fc8c9b9>

## 代码架构、测试基础设施和最佳实践

![](img/7fd284eafa8167dfe57302988b8da822.png)

照片由 [Alex wong](https://unsplash.com/@killerfvith?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

让我们以解决我所说的“完美项目”的任何假设来开始这篇文章。我指的是对细节的一丝不苟，*，但不是收益递减的程度*；我们对项目的各个方面都给予了适当的关心和重视。

下面这个故事开始已经 10 年了，我依然怀着无比崇敬的心情回顾“事情是怎么做的”。虽然我不能一直活在过去，但我一直在寻求在有着相似想法的环境中工作。至少，那些我能认同或尊重的标准相当高的人。

对于 TL；版本博士，跳到最下面的第 8 节——“这是如何毁了我的”。

# 1 -项目

> 有许多事情我们是第一次做，但是我们花时间仔细考虑和同行评审我们的模式…

我们的任务是一个绿地项目，比最初计划的更加绿色。我们将移植旗舰产品套件的查看器部分:一个从 Windows 桌面到 iPad 的交互式 3D 培训创作平台。我们的长期受众是国防和航空航天工业的几个分支。我们希望将教授拆卸喷气式发动机的 3D 虚拟体验放入手持多点触控设备中。

最初的计划是尽可能重用或利用现有代码。原始代码超过 120，000 个*可执行*行。可执行，意思是:不算注释，空行，只有大括号的行，多回车换行的单行，所以大概更接近 200，000。

由于第二代 iPad 的资源限制以及原始 Windows 代码中内存结构的自由使用，使用现有代码的早期峰值产生了不可接受的性能，无法缓解。除非对执行 3D 数学的对象的基本内存管理进行彻底检查。我们将计划转向编写完全绿色的代码，这些代码可以在以后重用。

有许多事情是我们第一次做的，但是我们花时间仔细琢磨和同行评审我们的模式，这样我们就有了一个强大的基础。

## 1.1 -结果

最终，这个项目取得了技术上的成功，以至于它的代码和我们的新实践在后来的项目中被重用。此外，我们在公司树立了一些先例。

它是第一个被单元测试覆盖的代码库。这是第一个开发人员在开发特性时编写 UI 自动化测试的项目，使用[行为驱动开发](https://en.wikipedia.org/wiki/Behavior-driven_development) (BDD)，而不是在事后很久才由 QA 自动化。

# 2 -团队

我们有一个 4 人的开发团队，大部分来自一个更大的工程团队。虽然这是一家 Windows 软件商店，但我们中的一些人(包括我自己)带来了一些在个人项目中使用 Apple APIs 的外部经验。

我们的团队领导(我很确定)是一个 10 倍的程序员，我们称他为 Gary。他不仅什么都知道，还热衷于每天早上分享 dev 新闻和文章。然后是米奇，他和加里一样聪明，他的经历(和年龄)介于我和加里之间。我从与米奇的无数次讨论中学到了很多，他非常固执己见。

尽管 Gary 和 Mitch 对公司来说都是新人，以前也从未一起工作过，但他们很容易就许多现代实践达成了一致，而我在公司的这些年里还没有听说过这些实践。他们的协同作用是不可思议的。后来我们雇佣了 Dan，他是我们 CI 系统的专门构建工程师，让一切顺利运行。

然后是我。尽管我已经从事了 12 年的真实世界应用程序编程(在企业编程领域只有 4 年)，但我从我的新队友那里学到了很多东西。我们都经历过旗舰代码库的设计问题带来的维护地狱，并做出了深思熟虑的选择，以避免在我们的白板上重复错误。

# 3 -技术堆栈

最初的应用程序逻辑是用 C#编写的，我们专有的 3D 渲染和数据引擎是用 C++编写的，包装在“托管 C++”中。净消费。我们外包了一家公司，让 C++在 Arm 处理器上运行，而我们的团队处理应用程序编程，并用对 x-plat 更友好的东西取代了微软独有的语言桥接。

## 3.1 -多语言技能组合

我们使用 C++来简化对渲染和数据引擎的一些 API 调用，并设计从本地层到内存管理应用层的内存分配和内存所有权转移。

然后，我们使用 [SWIG](https://www.swig.org) 为 C#应用层生成一个 C++到 C#的接口。这个瘦 SWIG 层由两种语言的代码组成，它处理语言之间数据类型编组的细节。我们定义了严格的模式来仔细规划 C#包装的实例在不再使用时如何被本机销毁。我们编写了自动化和更新这一层的整个过程和规则手册。

应用层是用 MonoTouch(后来被称为 [Xamarin.iOS](https://en.wikipedia.org/wiki/Mono_(software)#Xamarin.iOS) )编写的，这是一个轻量级 C#包装器(*而不是*一个抽象)，用于 iOS 的 Objective-C [CocoaTouch](https://en.wikipedia.org/wiki/Cocoa_Touch) 和 Foundation APIs。与 [Mono](https://en.wikipedia.org/wiki/Mono_(software)) 不同，MonoTouch 将 AOT 编译成原生 C 代码；它不会在. Net 或 Mono 运行时作为 IL 代码执行。

虽然基础类库是在 iPad 设备上运行的应用程序的 MonoTouch，但包含业务逻辑的每个子系统都是用通用 C#代码编写的，这些代码也面向。Net 运行时。这些与可以直接在中运行的单元测试运行程序兼容。Net 和 Mono 环境。这使得我们可以在 Visual Studio 和 Resharper 中编写代码，并使用非常先进的代码覆盖工具——甚至是今天的标准。

对于所有类型的自动化(构建、开发任务、UI 测试)，我们使用了 Javascript、Ruby 和 shell 脚本的组合。

# 4 -架构

> …如果您不有意设计来防止反模式，即使是小项目也会很快失控。

![](img/c569f061e3d075a15e10f3a51a5a5e6e.png)

照片由[斯科特·格雷厄姆](https://unsplash.com/@homajob?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

任何好的软件项目的基础都是使用可持续的软件模式。如果你没有花足够的精力和精力来规划软件架构，一个随意的设计可能会让你的代码库在其生命周期的早期就显示出熵和衰退的迹象——本质上是创建“即时遗留”代码。

大多数关于架构的高层决策都是在作战室里做出的，在那里，我们一次花几个小时，在多天里集思广益。除了构建早期的基础设施，在我们达成整体协议之前，没有编写任何产品代码，但是我们做了许多工作。没有太多详细的设计需要特别记录，因为我们选择使用非常成熟的现代编程概念，我们确实创建了大量的 wiki 页面。

## 4.1 级设计

我们在我们的类和接口设计中使用了[可靠原则](https://en.wikipedia.org/wiki/SOLID),并采用了一个控制反转(IoC)容器来进行依赖管理。这有助于我们最大化代码的单元可测试性，这是通过在几十个子系统中个性化我们大量的单个逻辑单元来实现的。

*   SRP 是设计每个类的核心。大多数班级都很小，每个人的责任都很明确。任何初级程序员都能够以最小的认知负荷阅读任何单个类(除了一些写流量低的基础设施位)。
*   [OCP](https://en.wikipedia.org/wiki/Open–closed_principle) 在我们的绿色应用中并不相关，但是我们在添加到 3D 引擎中的 API 抽象层上加强了这一点。
*   [LSP](https://en.wikipedia.org/wiki/Liskov_substitution_principle) 在实现我们的业务逻辑子系统的完全可测试的平台无关实现中发挥了重要作用。我们可以通过渲染引擎对 SWIG 支持的 iOS 运行时对象实例运行生产代码，或者用这些对象的存根或伪件对相同的代码进行单元测试。在这个项目之后，在将特性移植回 Windows Modern UI 解决方案时，也使用了 Liskov 替换。
*   ISP 使我们有可能从我们利用的 LSP 中获益。我们最终有 90%的类实现了接口，简单的数据结构是一个例外。
*   DIP 允许我们考虑各种生命周期范围，因此我们可以从渲染引擎和应用程序逻辑两方面来规划对象的内存管理。尤其是移动应用程序生命周期，这在当时与传统相去甚远。

## 4.2 -数据通信

通过子系统内部的交换，大多数对象可以通过公共方法和。Net 事件(对非 C#书呆子来说，也就是语法上的甜回调)通过它们的接口公开。然而，对于子系统间的通信，我们在设计上不鼓励子系统之间的耦合。从另一个子系统获取一个对象并直接获取它的数据几乎是不可能的。

**4.2.1 -订阅更新**

我们使用命令查询责任分离( [CQRS](https://martinfowler.com/bliki/CQRS.html) )来进一步分离来自跨功能子系统的数据请求，并通过**消息总线**使之成为可能。没有跨子系统的请求是同步的，也没有数据返回；我们将请求分为**命令**和**事件**。您可以通过消息总线对 void-return 命令进行排队，还可以使用总线订阅发布您感兴趣的更新的事件。只有子系统的控制器需要拥有总线的一个实例。

没有子系统访问另一个子系统的状态；它可以根据自己订阅的事件数据，保留另一个子系统相关状态的模型。这有双重影响:1) `Feature A`不必担心其他特性如何关心它的状态，从而将自己耦合到特性`B`和`C`，以及 2)特性`B`和`C`不能随意修改`Feature A`的状态并无意中导致`Feature A`中的错误，如果不改变任何一方的依赖设计，这个错误有时很难修复。

CQRS 并不适合所有的项目，但非常适合我们的项目，因为太多的子系统都对读取和写入彼此的状态感兴趣——这在原始代码库中是有问题的。

**4.2.2 -松散耦合的依赖关系**

此外，没有子系统程序集(库)依赖于另一个子系统的程序集。相反，每个子系统都有一个对其他子系统公开的“契约”程序集，外加一个“实现”程序集，该程序集私下满足子系统实现它公开声明要做的事情。

“契约”程序集只包含命令、事件、后两者中使用的类型的简化数据结构和一些接口。“实现”程序集只需要被应用程序的主程序集和单元测试引用。该程序集还可以自定义自己的类型如何通过反转控制模块来满足公共接口的要求。

我们的模式运行得如此之好，以至于很容易将这个代码库的单个部分引入到其他未来的项目中，大部分是原样的，因为每个子系统都是彼此独立的。

## 4.3 -交互和视图设计

针对我们精心设计的视图接口和模型接口，我们实现了用户与模型视图控制器模式(MVC)的交互。我们并不关心典型的苹果风格的 MVC 实现，因为 ViewControllers 在技术上更像“V”而不是“C”，因为它们通常仍然是 UI 逻辑。此外，ViewController 派生类是一个 iOS 细节，在平台无关的视图接口中没有位置。

我们的视图与大多数应用略有不同，因为许多用户交互是通过多点触控屏幕上的 3D 视图完成的。当然，我们也有按钮、标签和其他围绕视口的 UI chrome，但是有意义的交互是使用多点触摸手势进行的。虽然它对视图实现有很大的影响，但它不会影响您编写视图接口的方式；你可以继续使用用户意图的语义，而不是像“点击”这样依赖于输入媒介的术语。

编写跨平台视图接口很简单。记下视图中的每个用户输入，并从事件的角度考虑这些输入。记下需要传达给用户的任何信息，并提供更新这些信息的方法。现在将它们转换成事件和类方法，只使用平台无关的数据类型。一旦建立了接口，您就可以考虑具体的实现如何处理特定于操作系统的信息，这些信息可以是依赖注入的，也可以是映射的。

我们的视图需要的另一件事是设计 UI 控件，要么有自动化 id，要么使它们的元素可以被 UI 自动化测试的查询语言访问。

## 4.4 -有效设计的三重优势

一旦你掌握了其中的窍门，上面的三个概念(实体、CQRS 和 MVC)使得我们的项目很容易操作。除了 3D 数学问题和一些脚手架，我们绝大多数的业务逻辑都是愚蠢的代码。你头脑中没有什么“聪明”的东西可以解开；只是简单直白的阅读。

如前所述，这段代码在未来的几个其他项目中被重用，几乎没有任何麻烦。添加新功能时没有维护问题，因为这种架构风格的一切都是模块化的。

这种精确的组合并不是所有项目的金锤，但是你可能想考虑一下，如果你不使用上面的任何一个，你如何处理这些概念解决的设计问题？对于小项目来说，这是否有些矫枉过正？是的，但是如果您不有意设计来防止反模式，即使是小项目也会很快失控。

# 5 -编码实践和过程

> …我们都尽了自己的责任，没有一个人偏离这个过程，以保持我们的代码库干净和健康；如果团队不能就质量标准达成一致，就不可能有和谐。

![](img/24831e3f2c5b032df49c301ebc9fa117.png)

照片由[摄影师](https://unsplash.com/@ffstop?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

我们的开发团队(大部分)同意并定期实践我们建立的所有标准。下面是我们实践的一些关键事情，以确保我们对完成的定义的一致性。

## 5.1 -逻辑代码质量

*   我们定义的代码架构总是被遵循；当遇到前所未有的挑战时，我们不得不打破模式来创造新的模式，在这种罕见的情况下，团队达成了一致。
*   正在开发的每个功能都在单元测试中；不妥协。
*   我们使用实时代码覆盖工具，持续地保持对每一个`if`语句、`switch` `case`、早期`return`和未被测试覆盖的逻辑分支的了解，并对其负责。
*   每一个正在开发的特性在被认为是“完成”之前都在进行 UI 自动化测试。
*   我们使用行为驱动开发来确保每个特性按照业务需求在可接受的水平上运行。
*   在修复之前，发现的每个 bug 都被写成单元测试和/或 UI 自动化测试*。*

## 5.2 -源代码控制质量

*   我们都使用相同的代码格式设置，所以来自每个开发人员的所有提交在样式、间距和行尾方面都是一致的。
*   我们使用 git-annex(以及后来的 git-fat)将大型二进制文件与包含源代码的 repo 的其余部分分开。我们的许多二进制文件要么来自依赖项，要么来自用于对 3D 视口进行 UI 测试的图像差异基线。
*   我们将签入源代码控制的生成代码的数量减到最少，并且非常小心地管理`.gitignore`文件。
*   我们都把对方的机器设置成 git 遥控器；我们接受协作和分布式源代码控制的理念，而不是使用 git 作为一个集中的存储库。
*   我们以走查的方式亲自完成了所有的代码审查。虽然我们允许额外的时间用于异步的 PR 评论，但是代码评审更多的是关于知识转移而不是监管。这是因为我们已经就软件架构模式和现代 C#标准达成一致。
*   我们清楚地定义并实践了分支、重定基础和合并策略。
*   我们还在办公室里使用了一个物理对象，一次只能有一个人在他们的办公桌前拿着，让下一个人马上掌握。这减少了重新设定惊喜和“谁先合并，谁就赢”的比赛惯例。
*   我们有 CI 构建状态控制面板，永久显示在办公桌上方的显示器上。如果主人身上有任何东西是红色的，我们会尽快让它恢复健康。
*   我们把完成定义的清单打印出来，挂在我们的每张桌子上，所以我们不会不考虑就跳过一件事。

## 5.3 -技术和谐

最重要的是，我们都尽了自己的责任，没有一个人偏离这个过程，以保持我们的代码库干净和健康；如果团队不能就质量标准达成一致，就不可能有和谐。

# 6 -方法

> 通过查看办公桌旁的白板和 CI 仪表盘，公司的其他人随时都知道我们在做什么。

![](img/b0d5e734020d7829295c72ca9070d355.png)

照片由[i̇rfan·西姆萨尔](https://unsplash.com/@irfansimsar?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

## 6.1 -董事会

我们使用看板方法进行敏捷编程。没有花哨的票务系统:只是一堆基于需求的功能，我们分成任务，写在便签上。我们会在办公桌旁的大白板上沿着泳道移动我们的子任务。在基础设施建立之后，我们大部分时间都是独立工作的，但是在更大的挑战中，我们经常是成对编程的。

## 6.2 -评估和节奏

根据故事点的平均节奏，在计划扑克游戏时进行估计，并使用非常简单的 JSON/Javascript 工具跟踪时间线，该工具有助于根据发布日期可视化功能。产品所有者可以根据这些预测对特性进行优先级排序。我们可以修复特性集，或者修复里程碑的日期，但是不能两者都修复——因此没有加班。

## 6.3 -问题跟踪

你可能想知道如果没有标签系统，我们如何记录错误？每个 bug 都作为完全可执行的自动化用户验收测试记录在 repo 中。由于我们使用的是 BDD，小黄瓜语言用商业术语描述了 bug 场景，所以你不必是程序员也能读懂它们。当错误被修复后，我们更新测试的接受标准，从重现它到验证它不再可重现。

我并不是说每个人(或任何人)都应该这样做。然而，在那段时间里，这对我们很有效——这是我在工作场所做过的最酷的事情之一。

## 6.4 -轻巧高效

我们的过程非常“敏捷”,不需要从敏捷工具和实践中获取大量开销。我们没有太多的会面，但是很有规律的交流*。通过查看办公桌旁的白板和 CI 仪表盘，公司的其他人随时都知道我们在做什么。*

# 7 -持续集成

我们的日常开发任务通过脚本自动化。这包括但不限于在。Net，在基于 Arm 的 iPad 上运行单元测试，部署到 iPad，在设备上运行 UI 自动化测试，并为 AppStore 创建一个构建。这些任务可以从任何可以克隆代码库的 Mac 上运行。我们使用 [Rake](https://www.stuartellis.name/articles/rake/) 使这些任务跨平台，因为其中一些也可以在 Windows 开发机器上运行。

Jenkins 是我们的 CI 系统，它分配任务来构建在 Mac 虚拟机上运行的代理，USB 指向各种 iPad 设备以实现 UI 测试自动化。每个构建都运行工作:编译、单元测试、部署到 iPad 并运行 UI 测试。

## 7.1 -保持绿色

我们使用了分级分支策略。我们的目标是我们的个人和功能分支只进入`master`。主构建在 CI 中至少 96%的时间应该是绿色的。在连续几天无一故障地通过用户验收自动化之后,`master`分支合并成了`stable`,这意味着 stable 100%的时间都是绿色的。然后`stable`进入`release`,当它通过更严格的新特性测试时，它将成为利益相关者的下一个目标。

## 7.2 -早期投资

构建脚本、单元测试、UI 自动化、CI 系统——所有这些东西，即使是以最简单的形式，在我们构建了项目的框架和架构之后，就已经开始运行了。这种方法，与事后添加这些片段相反，有时是一种永无止境的追赶许多项目的游戏。

如果你有能力的话，一个 UI 测试来启动一个实际上还没做多少事情的应用程序，要比在应用程序已经完成的时候再去写那些东西要容易得多。这样，对于实现的每个特性，我们都有能力编写测试来覆盖该特性。

我们并不是通过将这一切都推给我们的构建工程师 Dan 来实现的，因为这不仅仅是一个人的全职工作。每个开发人员都拥有围绕他们工作的特性的测试基础设施。

# 这是如何毁了我

> 使用实践和工具让你对自己编写的代码负责是责任上的一个巨大飞跃，但这是一种**授权**，而不是苦差事。

![](img/301eff1310ee20d5e798d81db7d195f3.png)

由 [charlesdeluvio](https://unsplash.com/@charlesdeluvio?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

或许更贴切的词是“宠坏了”。职业生涯中独一无二的黄金时刻不会永远持续(并不是说你不会有另一个)，因此必须结束。一些好的经历很难再回来，回到以前的状态，在那里 bug 横行，每个人都深陷科技债务。

我早年的无知是一种福气。即使以前科技债务让我焦头烂额，我也不知道有更好的方法，也从未渴望过。给我打击最大的是，Gary 和 Mitch 给我的印象是，大多数现代软件商店都热衷于这些做法——不知何故，在他们到来之前，我们公司仍处于黑暗时代——但我后来发现这是例外，而不是规律。

## 8.1 -初始阻力

我必须承认，起初，我很难适应这些额外的规则。当时我认为自己是一个经验丰富的开发人员，我讨厌所有实践 SOLID 和 MVC 要求我创建的额外的类、接口和文件。禁止子系统直接获取彼此的数据——这让一切看起来像是迂回的杂务。我总是想“如果不是遵循了所有这些规则，我现在可能已经完成了”并进入下一个功能。

我把我的新队友视为万事通，他们对一切都有答案。虽然他们在架构、代码味道、反模式和最佳实践方面显然比我更有经验，但我看不出这些设计选择会走向何方——这正是问题所在。我还没有意识到这一点，但我觉得自己很渺小，没有安全感，这种抗拒只是对我是多么短视和粗心的一种否认。

## 8.2 -顿悟

几个月后，我的态度和解决问题的心态发生了变化。使用实践和工具让你对你写的代码负责是责任上的一个巨大飞跃，但这是一种**授权**，而不是苦差事。这也有助于你保护自己，所以你知道你的提交没有破坏任何东西。

对我来说，另一个转折点是看到如果不使用这些架构模式，一些类在没有重大重构的情况下无法进行单元测试。回顾我过去到现在为止的所有错误、可读性问题和维护问题，我现在发现大多数都是反模式的结果，而这正是设计所要防止的。

当你把不可读的、错误的和不可测试的代码放在一个代码库中时，维护就变成了每天的地狱。我不想再下去了，尤其是爬出来之后。

## 8.3 -我看不到的

在这个项目之前的 10 年里，以及之后的 10 年里，我现在可以看到编写软件的许多问题要么是可以预防的，要么是可以通过积极的心态来缓解的。对反模式的盲目，对细节和关怀的缺乏关注，对责任的恐惧——所有这一切，当它们都被安排好的时候是如此简单，但也是不被注意的典型。

我无法忘记我所看到的，以及它如何改变了我对每个项目的看法。看着一个代码库或开发过程，不去想你是如何经历同样的错误并知道如何避免它们变得很困难。

## 8.4 -选择谦逊

这使得人们很容易判断“糟糕的代码”，对自己的工作产生负面情绪，或者更糟糕的是，对普通程序员的普遍鄙视——但你不必变成“那个人”，认为自己比所有人都好(无意识地或以其他方式)。这是一条你不想走的丑陋之路。

学习和实践本文中的所有关键概念并不意味着我们可以轻视我们的程序员同事。这给了我们一个相对于那些不这样做的人的优势，以及 T2 以身作则的机会。

## 8.5 -寻求志同道合者

不幸的是，如果安于现状，并不是每个人都想被领导。我曾经花了几年的时间试图影响一群观众，他们大多是不参与的，听天由命于不可持续的做法，这些做法是我生存的祸根。我得到了一些支持，但变革推动者大多充耳不闻。这只会导致完全彻底的倦怠。

团结起来，和志同道合的人建立融洽的关系。你可以加入一个行会，如果有必要的话可以组建一个。如果其他方法都失败了，也许你更适合类似代码质量标准的地方？

虽然我喜欢分享我对设计和实践的看法，这对我来说是一个技术上的成功，但如果每个人都已经在同一页上，那么不必说服整个工程部门会好得多。虽然不太可能共享所有相同的标准，但在一个热衷于代码质量的公司中，会有许多重叠或合理选择的等效标准。

# 如果你不买的话

虽然被认为是“现代”的，但我们在这篇文章中谈论的许多事情都是长期建立的，并且是有原因的——而不是我试图把你拖入其中的一些时尚或货物崇拜的废话。你可以否认以上任何一个话题的优点或价值，但是你最好有一个好的答案来说明如何做得更好。

我看得够多了，知道哪里需要东西。以下是一些经常出现的常见设计错误:

*   每当有人编辑代码时，新的错误总是出现，这就像你的团队在玩打地鼠游戏。如果你的代码被单元测试和/或 UI 测试覆盖，你应该能够发现什么时候出了问题，而不是合并一个 bug 让其他人以后发现。
*   当代码没有被充分分解以允许单元测试时(因为依赖耦合或其他原因)，它总是提醒我 SRP、LSP、ISP 和来自 SOLID principles 的 DIP 是如何阻止这一点的。如果代码还很年轻，重构为 SOLID 风格的设计可能还不算太晚，但是第一次就把它做好总是好的。
*   许多事情完全没有经过测试。不是因为测试计划很差，而是因为通常，编写测试计划的人并不知道代码中的每个条件语句和逻辑分支。如果您没有使用代码覆盖工具，那么您可能不知道在任何时候有多少边缘案例被执行。
*   特性嫉妒(或对象嫉妒)是一种代码味道，在这种情况下，为了访问一个值或调用一个方法，你必须通过一个封装链来遍历两个或更多的对象。如果你的代码库有很多这样的东西，那么它肯定会有各种各样的设计问题。依赖倒置有助于防止这种情况。
*   太多的特性访问彼此的数据，并将它们自己的含义(和结果)投射到数据上，可能是许多棘手的状态管理错误的来源。消息总线上的 CQRS 有助于实现低耦合和高内聚的跨特性交互。
*   代码的某些部分依赖于单例模式的类，因为开发人员不能确定谁需要拥有它的生命周期。这可能会阻止您解耦代码、编写单元测试或拥有可预测的生存期范围。依赖倒置可以消除这些限制。Liskov 替换还可以帮助模仿被测试单元所依赖的前单例。
*   有时，一个令人讨厌的 bug 来自于受意外的生命周期变化影响的状态，在这种情况下，项目中的对象范围完全是特定的。这让我想起了控制容器的反转是如何帮助明确定义长寿命对象的范围的。
*   业务逻辑嵌入在 UI 代码中。这可能特别糟糕，但也很常见，因为代码示例通常是架构中最糟糕的示例。无论是 MVC、MVVM 还是一些类似的范例，选择一种强调关注点分离的模式。
*   UI 测试自动化或用户验收测试自动化作为 QA 的兼职工作来完成，而不是 BDD 每天驱动开发过程，这是很常见的。当开发人员取得所有权时，测试套件总是最新的，而不是无休止的追赶游戏，在那里 bug 很晚才被发现。
*   成熟的 CI 系统不仅保持代码库健康，而且保持工程部门的普遍士气。当一切例行公事般地停止编译或工作时，开发人员将不再信任他们的同事，团队可以在公司内部形成“我们对他们”的局面。

# 最后的想法

虽然这篇文章是我迄今为止读得最长的一篇，但没有足够的词语来描述我学到了什么，以及这段经历如何改变了我；我们只是触及了表面。

前进中最重要的部分是负责用这些知识做什么。我把它带到了让我崩溃的地方，如果我做出正确的选择，它将把我带到职业生涯的下一个黄金时代。

# 分级编码

感谢您成为我们社区的一员！更多内容见[级编码出版物](https://levelup.gitconnected.com/)。
跟随:[推特](https://twitter.com/gitconnected)，[领英](https://www.linkedin.com/company/gitconnected)，[通迅](https://newsletter.levelup.dev/)
**升一级正在改造理工大招聘➡️** [**加入我们的人才集体**](https://jobs.levelup.dev/talent/welcome?referral=true)