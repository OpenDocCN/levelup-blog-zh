<html>
<head>
<title>The Magician’s Guide to Algorithms, part 5: The Breadth First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">魔术师算法指南，第5部分:广度优先搜索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-magicians-guide-to-algorithms-part-4-the-breadth-first-search-b800aec8ccf8?source=collection_archive---------0-----------------------#2017-11-13">https://levelup.gitconnected.com/the-magicians-guide-to-algorithms-part-4-the-breadth-first-search-b800aec8ccf8?source=collection_archive---------0-----------------------#2017-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/0c89f060681c0144b49e98db65e9c616.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*W-pRMzzXKtscet-UEdHYjQ.gif"/></div></figure><p id="4961" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以本周我们将讨论列表中最难的算法之一，或者说是咒语。这和最终铸造一个完全成形的守护神是一样的，所以当你破解了这个的时候要自豪。</p><p id="33a4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">广度优先搜索</strong></p><p id="283c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以广度优先搜索(bfs)这个咒语在我们理解它要遍历什么样的数据结构之前没有多大意义。这意味着我们需要了解一些关于树的知识。</p><p id="96af" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">树是一种数据结构，看起来像这样:</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="fd59" class="lb lc iq kx b gy ld le l lf lg">                                   6<br/>                                  / \<br/>                                 5   7<br/>                                / \   \<br/>                               3   4   9<br/>                              /       / \<br/>                             2       8   10<br/>                            /<br/>                           1</span></pre><p id="de1e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事实上，这就是所谓的二叉树。这意味着根节点，也就是<em class="lh"> 6 </em>，以及其后的每个子节点最多只能有两个子节点，一边一个。此外，左侧的每个子节点的值必须小于其父节点的值，甚至右侧的节点的值也必须大于其父节点的值。</p><p id="95d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">花点时间检查下面的代码。上面的树可以用一组对象来表示，如下所示:</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="64cf" class="lb lc iq kx b gy ld le l lf lg">var tree = [<br/>    {value: 6, left: 1, right: 2},<br/>    {value: 5, left: 3, right: 4},<br/>    {value: 7, left: null, right: 5},<br/>    {value: 3, left: 6, right: null},<br/>    {value: 4, left: null, right: null},<br/>    {value: 9, left: 7, right: 8},<br/>    {value: 2, left: 9, right: null},<br/>    {value: 8, left: null, right: null},<br/>    {value: 10, left: null, right: null},<br/>    {value: 1, left: null, right: null}<br/>    ]</span></pre><p id="930e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们来看看这个咒语:</p><figure class="ks kt ku kv gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="511e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">bfs咒语有两个参数。第一个是树，第二个是我们要寻找的值。为了开始滚动，我们将<code class="fe lk ll lm kx b">tree[0]</code>处的节点推到<code class="fe lk ll lm kx b">queue</code>——这是根节点。这就是所谓的“入队”</p><p id="69d3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们立即进入一个while循环，如果我们找到了正确的节点或者用完了队列中的节点，这个循环就会退出。</p><p id="e231" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，对于队列中的每个节点，我们首先将它从数组中移出。这就是所谓的“出列”我们首先检查刚刚出队的节点的值是否等于我们正在搜索的值。如果是这样的话，我们不需要继续循环，只需要返回节点。</p><p id="97cf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">否则，我们检查是否有一个左节点和一个右节点，根据我们的发现将其中一个或两个节点添加到队列中。这里我们不需要if/else子句，因为我们总是需要检查两个条件。</p><p id="a480" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们到达了树的底部而没有找到正确的节点，一条消息将被记录到控制台，通知我们没有找到该节点。</p><p id="a435" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在你知道了。</p><p id="4dd2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">为什么要进行“广度优先”搜索？</strong></p><p id="6b55" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们快速回顾一下这个叫做广度优先搜索的东西。这种算法通过在下降到下一行之前读取树的同一行中的所有节点来遍历树，这使得它成为Pince夫人通过一次扫描每一层来查找书架上的书的有用咒语。</p><p id="1526" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在上面的树中，如果我们想找到值为1的节点，它会这样读它们:6 5 7 3 4 9 2 8 10 1，然后返回。</p><p id="3c93" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">BFS算法有一个表亲，叫做DFS算法，或者我们将在下周讨论的深度优先搜索。</p><p id="10bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下次见。干杯！</p><p id="ed0b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">点击查看上周关于选择排序的帖子<a class="ae ln" href="https://medium.com/gitconnected/the-magicians-guide-to-algorithms-part-4-the-selection-sort-454148f55c73" rel="noopener">。</a></p></div></div>    
</body>
</html>