<html>
<head>
<title>Python Dunder Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Dunder方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-dunder-methods-ea98ceabad15?source=collection_archive---------4-----------------------#2020-06-29">https://levelup.gitconnected.com/python-dunder-methods-ea98ceabad15?source=collection_archive---------4-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3967" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python魔术方法使用指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e6f22a3bb7cfd3aa4faf5b2ed6f33c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NcFWChzq1k-cqXDah3PsJg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cristian1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·埃斯科瓦尔</a>在<a class="ae ky" href="/s/photos/magic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5c0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，通过定义具有特定名称的方法，类可以具有由特殊语法(如算术运算或切片)调用的特殊方法。</p><p id="4193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些方法被称为<strong class="lb iu">邓德方法</strong>或<strong class="lb iu">魔法方法</strong>，尽管它们没有任何魔法在里面。它们是Python处理<em class="lv">操作符重载</em>的方法。</p><p id="40cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们还用于模拟一些内置类型，并可以用来以更pythonic化的方式丰富您的类。</p><p id="de47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:本指南基于Python 3.8。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1525" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">初始化</h1><p id="5a81" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">方法来帮助和更改类初始化行为。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/b450779169e7abad81ddd6d599c2b894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sWthu_8-6_R-d_AeLToTrQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</figcaption></figure><h2 id="ae50" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">评论</h2><ul class=""><li id="c2d4" class="nn no it lb b lc mv lf mw li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe nw nx ny nz b">__new__</code>的返回应该是类的一个实例。如果没有返回任何内容，则不调用新实例的<code class="fe nw nx ny nz b">__init__</code>。</li><li id="0e0d" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated"><code class="fe nw nx ny nz b">__init__</code>不应该返回值。如果返回的不是<code class="fe nw nx ny nz b">None</code>，则引发<code class="fe nw nx ny nz b">TypeError</code>。</li><li id="0c66" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">操作<code class="fe nw nx ny nz b">del x</code>不直接调用<code class="fe nw nx ny nz b">x.__del__</code>。它递减<code class="fe nw nx ny nz b">x</code>的引用计数，只有当它为零时才真正被调用。</li><li id="0538" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">在<code class="fe nw nx ny nz b">__del__</code>期间发生的任何异常都将被忽略，而是向<code class="fe nw nx ny nz b">sys.stderr</code>打印一条警告。</li></ul><h2 id="5371" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">例子</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f37e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">表现</h1><p id="06d9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">用于获取表示类实例的字符串。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/57f8799c110b4be1472f3c3609a7a70a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fD16vt088LbTFaO_qo_XVA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</figcaption></figure><h2 id="5570" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">评论</h2><ul class=""><li id="4654" class="nn no it lb b lc mv lf mw li np lm nq lq nr lu ns nt nu nv bi translated">如果一个类声明了<code class="fe nw nx ny nz b">__repr__</code>而没有声明<code class="fe nw nx ny nz b">__str__</code>，那么<code class="fe nw nx ny nz b">__repr__</code>也被用作“非正式”表示，即被<code class="fe nw nx ny nz b">str()</code>调用。</li><li id="f034" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated"><code class="fe nw nx ny nz b">spec</code>参数是一个包含所需格式选项描述的字符串，由类来解释。大多数情况下，类要么委托给内置类型之一，要么遵循类似的语法。</li><li id="7bbe" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated"><code class="fe nw nx ny nz b">__repr__</code>和<code class="fe nw nx ny nz b">__str__</code>的主要区别在于目标受众。<code class="fe nw nx ny nz b">__repr__</code>函数旨在产生机器可读的输出(甚至可以是Python表达式)，而<code class="fe nw nx ny nz b">__str__</code>更像是人类可读的输出(必须是字符串)。</li></ul><h2 id="46d5" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">例子</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ff86" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">丰富的比较</h1><p id="48d9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">一些方法，使一个类的行为像内置类型一样，并使用运算符实现对象之间的直观比较。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a598800ee7401114ce2661dead54bab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7eglYMfJEwMo4qbil2O28g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</figcaption></figure><h2 id="f339" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">评论</h2><ul class=""><li id="f726" class="nn no it lb b lc mv lf mw li np lm nq lq nr lu ns nt nu nv bi translated">如果没有实现给定参数对的操作，它可能会返回<code class="fe nw nx ny nz b">NotImplemented</code>错误。</li><li id="9ee8" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">按照惯例，它应该返回<code class="fe nw nx ny nz b">False</code>和<code class="fe nw nx ny nz b">True</code>。但是这些方法可以返回任何值，如果在布尔上下文(比如<code class="fe nw nx ny nz b">if </code>语句)中使用，Python将对该值调用<code class="fe nw nx ny nz b">bool()</code>来确定它是真还是假。</li><li id="57e8" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">如果没有定义<code class="fe nw nx ny nz b">__bool__</code>，Python调用<code class="fe nw nx ny nz b">__len__</code>，如果结果不为零，对象被定义为真。</li><li id="9b2c" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">如果一个类没有定义<code class="fe nw nx ny nz b">__eq__</code>，那么它也不应该定义<code class="fe nw nx ny nz b">__hash__</code>。</li><li id="a279" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">定义了<code class="fe nw nx ny nz b">__eq__</code>但没有定义<code class="fe nw nx ny nz b">__hash__</code>的类会将其<code class="fe nw nx ny nz b">__hash__</code>隐式设置为<code class="fe nw nx ny nz b">None</code>。在这种情况下，不可能在可散列集合中使用它们，例如<code class="fe nw nx ny nz b">set</code>。</li><li id="b4d8" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated"><code class="fe nw nx ny nz b">__hash__</code>应该返回一个整数。而<code class="fe nw nx ny nz b">a == b</code>就是说<code class="fe nw nx ny nz b">hash(a) == hash(b)</code>。</li></ul><h2 id="cd1f" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">例子</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b0fb" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">属性访问</h1><p id="fb0e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">可以自定义访问属性的含义(使用、分配或删除)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/a7829a4daf67decc9189813459a67509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7FVfTZh0IPIFZ_a8xuthVQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</figcaption></figure><h2 id="9ab0" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">评论</h2><ul class=""><li id="5912" class="nn no it lb b lc mv lf mw li np lm nq lq nr lu ns nt nu nv bi translated">如果方法是通过正常机制找到的，<code class="fe nw nx ny nz b">__getattr__</code>就永远不会被调用。</li><li id="fbcd" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">如果类同时定义了<code class="fe nw nx ny nz b">__getattr__</code>和<code class="fe nw nx ny nz b">__getattribute__</code>，那么<code class="fe nw nx ny nz b">__getattr__</code>只有在<code class="fe nw nx ny nz b">__getattribute__</code>引发<code class="fe nw nx ny nz b">AttributeError</code>或显式调用它时才会被调用。</li><li id="2931" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">如果<code class="fe nw nx ny nz b">__setattr__</code>要赋值给实例属性，就要调用同名的基类方法，比如<code class="fe nw nx ny nz b">object.__setattr__(self, name, value)</code>或者<code class="fe nw nx ny nz b">self.__dict__[name]=value</code>。</li></ul><h2 id="3154" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">例子</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2eaa" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">描述符</h1><p id="24ee" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">描述符是这样的类，当通过获取、设置或删除进行访问时，也可以改变其他对象。这里的描述符是一个类，它声明了一个或多个这样的方法，并出现在owner类的一个属性中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/d16d15b54358bf9cf4fbf3971212da0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*912cNPioQyMLETwHnY3MNQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</figcaption></figure><h2 id="d99f" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">评论</h2><ul class=""><li id="0fa7" class="nn no it lb b lc mv lf mw li np lm nq lq nr lu ns nt nu nv bi translated">描述符并不是孤立的；相反，它们应该由所有者阶层持有。当构建具有属性值相互依赖的面向对象的数据库或类时，描述符会很有用</li><li id="48a3" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">要成为描述符，一个类必须至少实现了<code class="fe nw nx ny nz b">__get__</code>、<code class="fe nw nx ny nz b">__set__</code>和<code class="fe nw nx ny nz b">__delete__</code>中的一个</li><li id="94e0" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">使用<code class="fe nw nx ny nz b">property</code>装饰器可以实现相同的行为。</li></ul><h2 id="716e" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">例子</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="2a01" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">容器方法</h1><p id="56af" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">可以定义以下方法来实现容器对象。容器通常是<em class="lv">序列</em>(如列表或元组)或<em class="lv">映射</em>(如字典)，但也可以表示其他容器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/8717d32ebde2e7e07d34c617b112b540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eRv5XKxVQtvDEXAZAaWLw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</figcaption></figure><h2 id="09ad" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">评论</h2><p id="40ba" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对于方法<code class="fe nw nx ny nz b">__getitem__</code>、<code class="fe nw nx ny nz b">__setitem__</code>和<code class="fe nw nx ny nz b">__delitem__</code>:</p><ul class=""><li id="a6ac" class="nn no it lb b lc ld lf lg li ok lm ol lq om lu ns nt nu nv bi translated">如果<em class="lv">键</em>型号不合适，则应升起<code class="fe nw nx ny nz b">TypeError</code>。</li><li id="db2f" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">如果<em class="lv">键</em>是一组索引之外的值(对于序列类型)，它应该引发<code class="fe nw nx ny nz b">IndexError</code>。</li><li id="28a3" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">如果<em class="lv">键</em>缺失(对于映射类型)，它应该引发<code class="fe nw nx ny nz b">KeyError</code>。</li></ul><h2 id="9ff0" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">例子</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a490" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">数字运算</h1><p id="65bf" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">可以定义以下方法来模拟数字对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/80a7f365801335e65c7f9df639f15ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hyM-aAqna9iOWTHuWjq4-A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</figcaption></figure><h2 id="611c" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">评论</h2><ul class=""><li id="b1bb" class="nn no it lb b lc mv lf mw li np lm nq lq nr lu ns nt nu nv bi translated">增强的算术方法(如<code class="fe nw nx ny nz b">__iadd__</code>)应该尝试就地进行运算，修改<em class="lv"> self </em>，并返回结果(应该是，但不是必须是，<em class="lv"> self </em>)。</li><li id="e3a6" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">只有当左操作数不支持相应的运算且操作数类型不同时，才调用反向二进制算术方法(如<code class="fe nw nx ny nz b">__radd__</code>)。也就是说，在一个表达式<code class="fe nw nx ny nz b">x + y</code>中，如果<code class="fe nw nx ny nz b">x</code>没有实现<code class="fe nw nx ny nz b">__add__</code>而<code class="fe nw nx ny nz b">y</code>实现了<code class="fe nw nx ny nz b">__radd__</code>，那么<code class="fe nw nx ny nz b">y.__radd__(x)</code>被调用。</li><li id="80ef" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">如果<code class="fe nw nx ny nz b">__int__</code>、<code class="fe nw nx ny nz b">__float__</code>和<code class="fe nw nx ny nz b">__complex__</code>未定义，则相应的功能<code class="fe nw nx ny nz b">int()</code>、<code class="fe nw nx ny nz b">float()</code>和<code class="fe nw nx ny nz b">complex()</code>返回到<code class="fe nw nx ny nz b">__index__</code>。</li><li id="023d" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">如果<code class="fe nw nx ny nz b">__int__</code>没有定义，那么函数<code class="fe nw nx ny nz b">int()</code>返回到<code class="fe nw nx ny nz b">__trunc__</code>。</li></ul><h2 id="ddb2" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">例子</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="d5a7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">上下文管理器</h1><p id="b50f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">上下文管理器允许在被<code class="fe nw nx ny nz b">with</code>语句包装或直接调用时执行设置和清理动作。这可用于保存和恢复状态、锁定和解锁资源，或者关闭文件和连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/f5dbaac88ed921f8cd4ec747c29261f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OIg4_NyOQHKLHPLRIf38ww.png"/></div></div></figure><h2 id="0c50" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">评论</h2><ul class=""><li id="f91a" class="nn no it lb b lc mv lf mw li np lm nq lq nr lu ns nt nu nv bi translated">如果上下文无任何异常退出，所有三个参数<code class="fe nw nx ny nz b">exc</code>、<code class="fe nw nx ny nz b">exc_value</code>和<code class="fe nw nx ny nz b">traceback</code>将为<code class="fe nw nx ny nz b">None</code>。</li><li id="be5e" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">如果提供了异常，该方法应该返回<code class="fe nw nx ny nz b">True</code>来抑制它。否则，它将在退出此方法时正常继续。</li></ul><h2 id="ac9d" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">例子</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6cc7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">可调用对象</h1><p id="e824" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">允许对象的实例像函数一样存在，也就是说，你可以“调用”它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/169f781bdf8222fe74b455557331ed36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hdCsLUZ2yr8DHQI4A60e8A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</figcaption></figure><h2 id="1e7f" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">评论</h2><ul class=""><li id="0de7" class="nn no it lb b lc mv lf mw li np lm nq lq nr lu ns nt nu nv bi translated">可以将<code class="fe nw nx ny nz b">__call__</code>方法声明为任何其他函数，因为您可以声明任意多个参数。</li><li id="f529" class="nn no it lb b lc oa lf ob li oc lm od lq oe lu ns nt nu nv bi translated">当实例必须大量改变其当前状态时，这是有用的，例如在表示平面中的点的类中。</li></ul><h2 id="9c55" class="nb me it bd mf nc nd dn mj ne nf dp mn li ng nh mp lm ni nj mr lq nk nl mt nm bi translated">例子</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fd5e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="304c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">您可以使用<em class="lv"> dunder </em>方法来丰富您的类并模拟Python中的内置类型。还可以让一些操作更“pythonic”一点。</p><p id="0d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是注意不要过度使用它们。如同任何其他功能一样，必须负责任地使用它。</p><p id="d82b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢阅读。如果您有任何疑问或建议，请在下面留下评论。你可以在<a class="ae ky" href="https://docs.python.org/3/reference/datamodel.htm" rel="noopener ugc nofollow" target="_blank">官方文档</a>中获得更多关于这些方法的信息。</p></div></div>    
</body>
</html>