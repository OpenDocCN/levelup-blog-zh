<html>
<head>
<title>Colliding JavaScript Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript对象冲突</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/colliding-javascript-objects-80257a58dcd0?source=collection_archive---------23-----------------------#2020-05-24">https://levelup.gitconnected.com/colliding-javascript-objects-80257a58dcd0?source=collection_archive---------23-----------------------#2020-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a972" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何合并物体和处理它们的碰撞。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/9b59f231e489d71ffb6a38faed360639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5uUjqPaL18ubmzb6-utUUQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">物体碰撞</figcaption></figure><p id="821a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">合并Javascript对象是一个经常讨论的话题。快速搜索会找到很多文章和合并对象的方法。他们中的大多数没有谈到当两个或更多的被合并的对象具有相同的键时会发生什么。很多教程会“非常方便地”使用合并时不会有碰撞的例子。</p><p id="05fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看看最现代和最简单的合并对象的方法。展开语法:<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">let objClone = {…obj }；</a>ECMAScript 2018中引入。</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="1529" class="lh li iq ld b gy lj lk l ll lm">let object1 = {<br/>  name: 'John Smith',<br/>  age: 34<br/>}<br/><br/>let object2 = {<br/>  name: 'Mark Smith',<br/>  height: 180<br/>}</span><span id="9984" class="lh li iq ld b gy ln lk l ll lm">let object3 = {<br/>  name: 'Jane Smith',<br/>  height: 175<br/>}</span><span id="fc92" class="lh li iq ld b gy ln lk l ll lm">let object4 = {...object1, ...object2, ...object3 }</span><span id="3aa7" class="lh li iq ld b gy ln lk l ll lm">/*<br/>  {name: "Jane Smith", age: 34, height: 175}<br/>*/</span></pre><p id="d167" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面我们可以看到，当所有的物体被合并时，我们实际上由于碰撞而丢失了数据。唯一没有出现问题的关键值是“年龄”。值<strong class="jp ir">名称</strong>和<strong class="jp ir">高度</strong>已经根据它们在序列中的放置顺序被覆盖。</p><p id="d591" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这像预期的那样工作，但是如果您没有意识到存在冲突，它将会在没有警告的情况下继续运行，从而导致潜在的数据丢失。虽然这种合并方法绝对是最简单和最容易理解的，但它可能并不是在所有情况下都是理想的。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="9581" class="lv li iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">Object.assign({}，<code class="fe ms mt mu ld b">object1</code>，<code class="fe ms mt mu ld b">object2, object3</code>)；</h1><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="7145" class="lh li iq ld b gy lj lk l ll lm">let object1 = {<br/>  name: 'John Smith',<br/>  age: 34<br/>}<br/><br/>let object2 = {<br/>  name: 'Mark Smith',<br/>  height: 180<br/>}</span><span id="0ef3" class="lh li iq ld b gy ln lk l ll lm">let object3 = {<br/>  name: 'Jane Smith',<br/>  height: 175<br/>}</span><span id="7aae" class="lh li iq ld b gy ln lk l ll lm">let object4 = Object.assign({}, <!-- -->object1<!-- -->, <!-- -->object2, object3<!-- -->);</span><span id="e19f" class="lh li iq ld b gy ln lk l ll lm">/*<br/>  {name: "Jane Smith", age: 34, height: 175}<br/>*/</span></pre><p id="cbe8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面可以看出，它的行为与“扩展”操作符完全相同，当发生冲突时，最后添加的对象优先。虽然这是意料之中的，但我们还是不知道有冲突，除非您事先知道，或者您后来发现(希望不是在生产中)有丢失的值。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="dfb5" class="lv li iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">带警报的自定义功能</h1><p id="f3b8" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">如果你对以上两种方法的工作方式感到满意，并且你知道你的物体不会碰撞，那么就没有任何问题。如果您确实想知道何时发生冲突，那么您将需要使用一个自定义函数，当发生冲突时，该函数要么失败，要么发出警告。</p><pre class="km kn ko kp gt lc ld le lf aw lg bi"><span id="10a4" class="lh li iq ld b gy lj lk l ll lm">let object1 = {<br/>  name: 'John Smith',<br/>  age: 34<br/>}<br/><br/>let object2 = {<br/>  name: 'Mark Smith',<br/>  height: 180<br/>}</span><span id="2335" class="lh li iq ld b gy ln lk l ll lm">let object3 = {<br/>  name: 'Jane Smith',<br/>  height: 175<br/>}<!-- --> </span><span id="ff81" class="lh li iq ld b gy ln lk l ll lm">function mergeObjs (...objects) {  <br/>  let target = {};<br/>  // Merge the object into the target object<br/>  function merger (obj) {<br/>    for (let prop in obj) {<br/>      // Check if target already has this property<br/>      if (target.hasOwnProperty(prop)) {<br/>        console.error(`${prop} has been overwritten`);<br/>      } <br/>      target[prop] = obj[prop];<br/>    }<br/>  };<br/>  // Loop through each object and conduct a merge<br/>  for (let i = 0; i &lt; objects.length; i++) {<br/>    merger(objects[i]);<br/>  }<br/>  return target;<br/>}</span><span id="ce3a" class="lh li iq ld b gy ln lk l ll lm">mergeObjs(object1, object2, object3);</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/0d3e79f9bb5dfc48cc07de546f09a478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-6Dh4l3Soia7_gma05zYg.png"/></div></div></figure><p id="2f98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上图可以看出，生成的对象与spread操作符和Object.assign方法完全相同。主要的区别是，当对象碰撞时，我们现在有一个警告，因为当<strong class="jp ir">名称</strong>和<strong class="jp ir">高度</strong>都被覆盖时，它们都抛出了一个控制台错误。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="6589" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，虽然很容易找到简单问题的解决方案，但它们并不总是以我们期望的方式运行。在我们的碰撞问题中，简单的解决方案会产生意想不到的后果，导致数据丢失。通过自己处理对象合并，我们有了解决碰撞问题的方法。</p></div></div>    
</body>
</html>