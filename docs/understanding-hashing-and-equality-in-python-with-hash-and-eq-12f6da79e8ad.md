# 使用 __hash__ 和 __eq__ 了解 Python 中的哈希和等式

> 原文：<https://levelup.gitconnected.com/understanding-hashing-and-equality-in-python-with-hash-and-eq-12f6da79e8ad>

## 计算机编程语言

## 了解它们是如何工作的，你应该如何使用它们，以及你绝对不应该做什么。

![](img/f4e230c214f64e437d848f615a8854df.png)

由 [Jacob Ferus](https://medium.com/@dreamferus) 使用 Midjourney 生成的图像。

Python 中的*内置*类型的相等比较和散列很简单，你真的不需要考虑太多，它就是有意义。但是如果你打算创建你自己的定制类，你需要注意你在做什么。很可能，默认行为是*而不是*您想要的。在本文中，我将介绍这些操作符的内部工作原理，并解释将它们正确应用到您自己的类并避免重大错误的必要细节。让我们开始吧。

# 等号“__eq__”运算符和“is”

Python 中的`__eq__`操作符是一种重载默认`==`操作符的方法，即定义两个对象是否*等于*。它是这样补充的:

当你认为两个对象相等时，你通常会根据它们的*值*来考虑相等。让我给你举个例子:

显然`a`和`b`有相同的值，反过来，它们应该相等是有道理的，对吗？但这并不总是正确的，我一会儿会再回到这一点。首先，让我们谈谈另一个叫做`is`的运营商。如果你检查两个对象是否“是”彼此，即`a is b`，那么只有当它们是完全相同的对象时才成立。例如:

现在是关键。如果你创建了一个自定义类而没有添加一个`__eq__`方法，那么使用`is`和`==` **将会和****一样。也就是说，相等运算符只检查对象是否相同，它不关心类的属性。因此，如果您想通过值来比较您的自定义类，您需要自己定义操作符。**

**不过，对于内置对象，正如在前面的代码片段中所看到的，基于值的等式有明确的定义。一个例外是可能存在浮点错误的浮点。**

**让我们看一个例子来巩固你刚刚读到的内容:**

**好吧，那么`__hash__`呢？**

# **__hash__ 运算符**

**先说一下什么是通用的*哈希函数*。哈希函数是一种获取潜在可变长度的数据并将其转换为固定大小表示的值的函数。散列函数有不同的应用，这些应用使用不同种类的散列函数。例如:**

## **存储和比较密码**

**以纯文本形式存储密码存在安全风险。为什么？因为如果存在安全漏洞，黑客能够从数据库中读取密码，黑客就可以用它来登录。其次，它还能够记住用户使用的密码，并有可能在用户使用相同密码的其他地方登录(尽管在多个帐户上使用相同的密码并不是一个好主意)。第三，你和其他开发者也可以看到密码。**

**哈希函数如何解决这个问题？不是直接存储密码，而是将密码转化为哈希值，然后存储。然后，下一次用户想要登录并输入密码时，该密码将与之前的哈希值进行哈希运算*和*。**

**因此，不会存储任何密码。现在，如果有人发现*哈希*密码，他们就不能使用它。原因是用于密码散列的散列函数是单向函数，即，给定输出散列，实际上不可能找到输入。因此，有效地防止了所有前述问题。这里非常重要的一点是，所谓的*哈希冲突*，即当两个不同的输入返回相同的哈希时，是极其罕见的(实际上是不可能的)。否则，您可以使用不同的密码作为用户登录。**

**这是**密码术**的一个应用，其中散列函数被广泛使用。另一个应用是加密货币。**

## **哈希映射/哈希表**

***哈希映射*是一种数据结构，用于存储值以便快速访问。它有一个键到值的关系，根据每个键的哈希值将数据分组到*桶*中。这个过程背后的思想是，通过首先快速找到一个桶，通常包含很少的元素(或者只有 1 个)，相等比较的次数会大大减少。例如，假设你在一个列表中有一百万个元素，你想看看其中是否存在一个元素。然后，如果列表没有排序，我们将不得不一个接一个地检查元素，并比较每个元素是否相等。相反，如果我们有一个包含 500000 个桶的散列表，我们只需要散列键，找到桶，然后平均进行两次相等比较。速度差异是巨大的。**

**注意，每个桶没有必要只有一个值，即每个关键字有一个唯一的散列。如果有哈希冲突，我们将简单地遍历桶的值，检查是否相等，直到找到正确的值。但理想情况下，碰撞是非常罕见的。与加密的用例相反，这里更重要的是散列函数比零冲突更快。**

**现在，Python *中的**字典**就是*一个散列图，简单明了。**集合**或 **frozenset** 也是使用哈希映射实现的。Python 中的`__hash__`用例只是作为散列函数，用于散列散列表(即集合和字典)中的键。因此，如前所述，它不应该是在密码学中使用的慢散列函数，冲突是容许的。**

**就像`__eq__`，`__hash__`是一个可以添加到类中的方法。方法的值可以使用`hash(object)`返回:**

**这里有一些关于`__hash__`的规则:**

*   **`__hash__`的返回固定大小表示应该是整数。如果不这样做，将会抛出一个错误。**
*   **一个对象的`__hash__`应该是**不可变的**，也就是说，在它的生命周期中不应该改变。这样做的原因是，如果你把一个对象放在一个集合中，然后改变散列，下次你寻找它时，你将找不到它，因为散列是不同的。**
*   **如果两个对象“相等”，即`__eq__`返回相等，则它们应该具有相同的`__hash__`值(但反之不一定成立，即在碰撞过程中)。**
*   **如果你定义了`__eq__`而没有定义`__hash__`，这个对象将变得不可散列，如果你试图散列它，将会抛出一个错误。这样做的原因是，如果您定义了`__eq__`，唯一有效的原因应该是默认的`is`不再合适，因此，默认散列也不再合适(因为默认情况下它具有旨在与“is”-equality 一起使用的属性)。**
*   **如果`__eq__`方法使用可变属性，那么您也不应该定义`__hash__`函数。这是因为散列应该是不可变的，并且两个相等的对象应该具有相同的散列。如果你改变一个对象，那么其他对象的`__eq__`也应该改变，反过来，`__hash__`也应该改变，因此它不再是不可变的。这个异常可能是一个常量`__hash__`，但是它没有用。**

**请注意，并非所有这些属性都是强制的。因此，你可以在实践中偏离这些规则，但这是一个坏主意。**

**让我们看一些例子。**

## ****非整数返回类型导致错误:****

## ****保留不可变哈希值的原因:****

**注意集合中的对象是同一个对象，它们在引用和值上都是相等的。但是因为散列已经改变，我们再也找不到它。可以看出，这不是强制的，即没有抛出错误。**

## ****如果相等，它们应该有相同的哈希值****

## **添加 __eq__ 而不添加 __hash__ 会使对象不可修复**

## **常量哈希呢？**

**常量哈希意味着哈希表中只有一个桶，因为只有冲突。下面是一个速度比较，首先是一个常量哈希:**

**现在有了一个唯一的散列:**

**具有唯一散列的那个要快 1742 倍，并且随着更多的条目被添加到字典/散列表中，它只会增长。使用常量散列，单个桶中的项目会循环，并比较它们的相等性，直到找到匹配为止，这实际上消除了散列表的全部好处。同样，插入也会变慢。**

## **最后一个问题**

**在我结束这篇文章之前，我给你最后一个问题:下面的代码片段将返回什么？**

**我会把答案放在评论区。如果您对更多关于 Python 中的字典和集合的文章感兴趣，我已经分别写了一篇:**

**[](/the-ultimate-guide-to-sets-in-python-c7556402726c) [## Python 集合的终极指南

### 你需要知道的一切。

levelup.gitconnected.com](/the-ultimate-guide-to-sets-in-python-c7556402726c) [](https://medium.com/@dreamferus/python-dictionary-operations-you-should-know-bb91a77bd97a) [## 你应该知道的 Python 字典操作

### dictionary/dict 是 Python 中的基本数据结构之一。它确实是 Python 的核心，并被用于…

medium.com](https://medium.com/@dreamferus/python-dictionary-operations-you-should-know-bb91a77bd97a) 

如果你喜欢这篇文章，并想阅读我未来的作品，你可以在 Medium 上关注我。如果你有兴趣成为中级会员，你可以使用我的[推荐链接](https://medium.com/@dreamferus/membership)。祝你有愉快的一天。**