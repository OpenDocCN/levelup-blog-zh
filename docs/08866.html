<html>
<head>
<title>Understanding Reference and Copy in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Python中的引用和复制</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-reference-and-copy-in-python-c681341a0cd8?source=collection_archive---------0-----------------------#2021-06-13">https://levelup.gitconnected.com/understanding-reference-and-copy-in-python-c681341a0cd8?source=collection_archive---------0-----------------------#2021-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0ec9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">引用、复制和深层复制</h2></div><h1 id="e10f" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">引用</h1><p id="9400" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">考虑以下情况</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="4c7f" class="mc kg iq ly b gy md me l mf mg">a = [1, 2, 3]<br/>b = a<br/>b[2] = 11<br/><br/>print("list a:", a)<br/>print("list b:", b)</span></pre><p id="59d0" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">我们创建了一个新的变量<code class="fe mm mn mo ly b">b</code>并将列表<code class="fe mm mn mo ly b">a</code>的值赋给它，修改了列表<code class="fe mm mn mo ly b">b</code>中的值后，列表<code class="fe mm mn mo ly b">a</code>和<code class="fe mm mn mo ly b">b</code>的结果会是什么呢？</p><p id="17b6" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">考虑第二种情况:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="49f2" class="mc kg iq ly b gy md me l mf mg">a = [1, 2, 3]<br/><br/>def func(input_list):<br/>    input_list[2] = 11<br/>    return input_list<br/><br/>b = func(a)<br/>print("list a:", a)<br/>print("list b:", b)</span></pre><p id="9696" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">在这个例子中，list <code class="fe mm mn mo ly b">a</code>作为输入传递给我们的函数，我们在函数内部修改了输入，那么<code class="fe mm mn mo ly b">a</code>会发生什么呢？</p><p id="a367" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">在上面的两个例子中，你可能已经猜到了，<code class="fe mm mn mo ly b">a</code>的结果会被无意地修改。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="e40c" class="mc kg iq ly b gy md me l mf mg">list a: [1, 2, 11]</span></pre><p id="221e" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">这是因为在上面的两个场景中，我们创建的新变量实际上绑定到了同一个内存地址<code class="fe mm mn mo ly b">a</code>，这意味着尽管看起来我们创建了一个新变量<code class="fe mm mn mo ly b">b</code>，但它并没有占用实际的内存空间，并且这个新变量是对list <code class="fe mm mn mo ly b">a</code>的引用。</p><p id="2a67" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">一个说明性的图表如下:</p><figure class="lt lu lv lw gt mq gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/5be9250e8563e9356fd4253f8932f4f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*KnEK6RAAwdEm4bzCo7z0hg.png"/></div></figure><p id="58b5" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">第一个例子中的变量<code class="fe mm mn mo ly b">b</code>和第二个例子中的<code class="fe mm mn mo ly b">input_list</code>都指向变量<code class="fe mm mn mo ly b">a</code>的同一个地址，所以改变元素将直接修改特定内存地址中的值，这也导致了<code class="fe mm mn mo ly b">a</code>的改变。</p><p id="f3be" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">您可以通过打印变量的内存地址来验证这一点:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="671e" class="mc kg iq ly b gy md me l mf mg">a = [1, 2, 3]<br/>b = a<br/>print("address of a:", id(a))<br/>print("addrss of b", id(b))</span><span id="f1a0" class="mc kg iq ly b gy mt me l mf mg">#############################<br/>address of a: 4385545984<br/>addrss of b 4385545984</span></pre><p id="c1f8" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">那么如何解决这个问题呢？</p><h1 id="7d75" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">浅拷贝</h1><p id="2bb3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一种方法是使用python中的复制模块。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="1c87" class="mc kg iq ly b gy md me l mf mg">import copy</span><span id="37ed" class="mc kg iq ly b gy mt me l mf mg">a = [1, 2, 3]<br/>b = copy.copy(a)<br/>b[2] = 11<br/><br/>print("list a:", a)<br/>print("list b:", b)<br/>print("address of a:", id(a))<br/>print("addrss of b", id(b))</span></pre><p id="e504" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">这将得到结果。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="18ff" class="mc kg iq ly b gy md me l mf mg">list a: [1, 2, 3]<br/>list b: [1, 2, 11]<br/>address of a: 4472440000<br/>addrss of b 4479677056</span></pre><p id="ca5f" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">复制功能对原始对象进行浅层复制，将原始变量<code class="fe mm mn mo ly b">a</code>与新变量<code class="fe mm mn mo ly b">b</code>分开。这条线</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="d588" class="mc kg iq ly b gy md me l mf mg">b = copy.copy(a)</span></pre><p id="9072" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">基本上是说请给我12字节(考虑一个<code class="fe mm mn mo ly b">int</code>占用4字节)的内存，并将a的值复制到新分配的内存地址。</p><figure class="lt lu lv lw gt mq gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/558c8f64f63fb4bf806a3b77cddb2bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*scvjM44jDkDUUhz4GP3m6A.png"/></div></figure><p id="84bf" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">但是浅拷贝也有问题，请看下面的例子，</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="15cd" class="mc kg iq ly b gy md me l mf mg">import copy</span><span id="8fb2" class="mc kg iq ly b gy mt me l mf mg">a = [1, 2, [1, 2]]<br/>b = copy.copy(a)<br/>b[2][0] = 11<br/><br/>print("list a:", a)<br/>print("list b:", b)</span></pre><p id="2eb1" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated"><code class="fe mm mn mo ly b">a</code>的结果会是什么？</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7687" class="mc kg iq ly b gy md me l mf mg">list a: [1, 2, [11, 2]]<br/>list b: [1, 2, [11, 2]]</span></pre><p id="7470" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">在这个场景中，修改<code class="fe mm mn mo ly b">b</code>再次改变了<code class="fe mm mn mo ly b">a</code>中的元素，发生了什么？</p><p id="7b65" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">浅层复制的问题是它不复制嵌套对象，在这种情况下，嵌套在原始列表中的是<code class="fe mm mn mo ly b">[1, 2]</code>。</p><figure class="lt lu lv lw gt mq gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/70770da0cf9b568c6512f0dd06f95641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*M7CBG82KnRYDJJvfQUyhiA.png"/></div></figure><p id="0c12" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">就像名字shallow copy一样，它只是复制表面而不是深入钻研递归，这里的第三个元素<code class="fe mm mn mo ly b">b</code>引用回原列表而不是制作副本。您可以通过打印元素的内存地址来验证。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="2edf" class="mc kg iq ly b gy md me l mf mg">print("address of a[2]:", id(a[2]))<br/>print("address of b[2]:", id(b[2]))</span><span id="fb03" class="mc kg iq ly b gy mt me l mf mg">################################<br/>address of a[2]: 4340761792<br/>address of b[2]: 4340761792</span></pre><p id="9fcd" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">如何解决这个问题？</p><h1 id="ae1e" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">深层拷贝</h1><p id="edf2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">深度复制会递归地复制一个对象。将副本替换为深层副本，您将得到:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="8d53" class="mc kg iq ly b gy md me l mf mg">import copy</span><span id="9017" class="mc kg iq ly b gy mt me l mf mg">a = [1, 2, [1, 2]]<br/>b = copy.deepcopy(a)<br/>b[2][0] = 11<br/><br/>print("list a:", a)<br/>print("list b:", b)<br/><br/>print("address of a[2]:", id(a[2]))<br/>print("address of b[2]:", id(b[2]))</span></pre><p id="5e8f" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">结果是:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="1a3b" class="mc kg iq ly b gy md me l mf mg">list a: [1, 2, [1, 2]]<br/>list b: [1, 2, [11, 2]]</span><span id="8ebc" class="mc kg iq ly b gy mt me l mf mg">address of a[2]: 4507899200<br/>address of b[2]: 4515136448</span></pre><p id="e5d2" class="pw-post-body-paragraph kx ky iq kz b la mh jr lc ld mi ju lf lg mj li lj lk mk lm ln lo ml lq lr ls ij bi translated">这里对<code class="fe mm mn mo ly b">b</code>所做的改变不会影响原始变量，并且<code class="fe mm mn mo ly b">a</code>和<code class="fe mm mn mo ly b">b</code>的地址会完全不同。</p></div></div>    
</body>
</html>