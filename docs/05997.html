<html>
<head>
<title>The power of Swift + Web Assembly (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift + Web Assembly的力量(第二部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-power-of-swift-web-assembly-part-2-30b6c4619c27?source=collection_archive---------3-----------------------#2020-10-17">https://levelup.gitconnected.com/the-power-of-swift-web-assembly-part-2-30b6c4619c27?source=collection_archive---------3-----------------------#2020-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="73da" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">导出函数和内存管理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a5e1806554ea15b474e30c3a137a30ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*duPJW32aIIQ16riCr3eNnQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://prog.hu/welcome/" rel="noopener ugc nofollow" target="_blank">https://prog.hu/welcome/</a></figcaption></figure><p id="666d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是<strong class="ky ir"><em class="ls">Swift+Web Assembly</em></strong>教程的第二部分，更侧重于导出函数、函数参数和内存管理等高级主题。在第1部分中，我们看到了如何从Swift包中生成wasm二进制文件，以及如何用Go应用程序启动它。在第2部分中，我将向您展示如何定义您自己的公共函数，这些函数可以从Go应用程序中调用。如果您还没有阅读第1部分，请从那里开始。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c9c9" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">导出的函数</h1><p id="f904" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">打开Swift项目，通过添加以下功能编辑<em class="ls">Source/your-project-name/main . Swift</em></p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="4401" class="nc mb iq my b gy nd ne l nf ng"><a class="ae kv" href="http://twitter.com/_cdecl" rel="noopener ugc nofollow" target="_blank">@_cdecl</a>("hello")<br/>func helloFromHost() {<br/>  print("The function is called from a host application")<br/>}</span></pre><p id="638a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是一个简单的Swift函数，但它的特别之处在于<em class="ls"> _cdecl </em>，它允许您为函数定义一个名称，并让主机(在我们的例子中是Go应用程序)通过该名称调用它。构建项目和生成wasm二进制文件还需要一个步骤，您应该为<em class="ls"> -Xlinker </em>构建标志提供公共名称。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="6f3f" class="nc mb iq my b gy nd ne l nf ng">$ TOOLCHAIN_PATH=$(cd $(dirname "$(swiftenv which swiftc)") &amp;&amp; cd ../share &amp;&amp; pwd)</span><span id="4f60" class="nc mb iq my b gy nh ne l nf ng">$ swift build --triple wasm32-unknown-wasi -c release --toolchain $TOOLCHAIN_PATH -Xlinker --export=hello</span></pre><p id="8182" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在编辑Go项目以访问"<em class="ls"> hello </em>"功能</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="6eb0" class="nc mb iq my b gy nd ne l nf ng">func hello(instance *wasmer.Instance) {<br/> // Gets hello function from the WebAssembly instance.<br/> hello := instance.Exports["hello"]</span><span id="7fa6" class="nc mb iq my b gy nh ne l nf ng">// Calls that exported function with Go standard values. The WebAssembly types are inferred and values are casted automatically.<br/> result, err := hello()<br/> if err != nil {<br/>  panic(err)<br/> }</span><span id="53c1" class="nc mb iq my b gy nh ne l nf ng"> // To ensure the hello function doesn't return any values<br/> fmt.Println(result.GetType() == wasmer.TypeVoid)<br/>}</span></pre><p id="4d29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用新的wasm结果运行Go项目，输出如下</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="61d8" class="nc mb iq my b gy nd ne l nf ng">$ go run ./<br/>&gt; The function is called from a host application<br/>&gt; true</span></pre><h1 id="ae56" class="ma mb iq bd mc md ni mf mg mh nj mj mk jw nk jx mm jz nl ka mo kc nm kd mq mr bi translated">函数参数和回报</h1><p id="c215" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">现在我们知道了如何为主机导出函数，让我们通过添加参数和返回值使Swift函数变得更加复杂</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="5f67" class="nc mb iq my b gy nd ne l nf ng"><a class="ae kv" href="http://twitter.com/_cdecl" rel="noopener ugc nofollow" target="_blank">@_cdecl</a>("sum")<br/>func sumFromHost(x: Int32, y: Int32) -&gt; Int32 {<br/>  return x + y<br/>}</span></pre><p id="f78b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建并复制新的wasm二进制文件</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="2b88" class="nc mb iq my b gy nd ne l nf ng">$ TOOLCHAIN_PATH=$(cd $(dirname "$(swiftenv which swiftc)") &amp;&amp; cd ../share &amp;&amp; pwd)</span><span id="0c3d" class="nc mb iq my b gy nh ne l nf ng">$ swift build --triple wasm32-unknown-wasi -c release --toolchain $TOOLCHAIN_PATH -Xlinker --export=hello -Xlinker --export=sum</span></pre><p id="aaba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后编辑您的Go项目以添加对“<em class="ls">sum”</em>函数的访问</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a50a" class="nc mb iq my b gy nd ne l nf ng">func sum(instance *wasmer.Instance) {<br/> // Gets sum function from the WebAssembly instance.<br/> sum := instance.Exports["sum"]</span><span id="dce6" class="nc mb iq my b gy nh ne l nf ng">// Calls that exported function with Go standard values. The WebAssembly types are inferred and values are casted automatically.<br/> result, err := sum(1, 2)<br/> if err != nil {<br/>  panic(err)<br/> }</span><span id="8aa3" class="nc mb iq my b gy nh ne l nf ng"> // To ensure the hello function doesn't return any values<br/> fmt.Println(result.ToI32())<br/>}</span></pre><p id="9e26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用新的wasm运行Go项目会产生以下输出</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="f361" class="nc mb iq my b gy nd ne l nf ng">$ go run ./<br/>&gt; 3</span></pre><h1 id="3b33" class="ma mb iq bd mc md ni mf mg mh nj mj mk jw nk jx mm jz nl ka mo kc nm kd mq mr bi translated">字符串作为参数</h1><p id="f156" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">函数“<em class="ls">sum”</em>使用Int作为参数和返回，但是如果我们想要一个更复杂的类型比如字符串呢？答案很简单，但是需要更多的步骤。让我们看看，如果我们像对Int类型那样尝试，会发生什么:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="6b84" class="nc mb iq my b gy nd ne l nf ng"><a class="ae kv" href="http://twitter.com/_cdecl" rel="noopener ugc nofollow" target="_blank">@_cdecl</a>("concatenate")<br/>func concatenateFromHost(s1: String, s2: String) -&gt; String {<br/>  return s1 + " " + s2<br/>}</span></pre><p id="1a5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您尝试构建项目，您将得到以下错误，表明在使用"<em class="ls"> _cdecl </em>时无法使用<em class="ls">字符串</em>类型。这是因为<a class="ae kv" href="https://webassembly.github.io/spec/core/syntax/types.html#value-types" rel="noopener ugc nofollow" target="_blank"> Web Assembly目前只支持简单的值类型</a></p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="8a65" class="nc mb iq my b gy nd ne l nf ng">$ swift build --triple wasm32-unknown-wasi -c release --toolchain $TOOLCHAIN_PATH -Xlinker --export=concatenate</span><span id="1466" class="nc mb iq my b gy nh ne l nf ng">&gt; error: method cannot be marked <a class="ae kv" href="http://twitter.com/_cdecl" rel="noopener ugc nofollow" target="_blank">@_cdecl</a> because the type of the parameter 1 cannot be represented in Objective-C                          <br/>func concatenateFromHost(s1: String, s2: String) -&gt; String</span><span id="f3ae" class="nc mb iq my b gy nh ne l nf ng">&gt; error: method cannot be marked <a class="ae kv" href="http://twitter.com/_cdecl" rel="noopener ugc nofollow" target="_blank">@_cdecl</a> because the type of the parameter 2 cannot be represented in Objective-C                          <br/>func cconcatenateFromHost(s1: String, s2: String) -&gt; String</span></pre><h1 id="b1a6" class="ma mb iq bd mc md ni mf mg mh nj mj mk jw nk jx mm jz nl ka mo kc nm kd mq mr bi translated">内存管理</h1><p id="5c7f" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">但是没有什么是不可能的。为了使错误消失，我们必须根据内容的大小(长度为<em class="ls"> s1 </em>和<em class="ls"> s2 </em>)分配内存，然后将指向内存的指针作为参数传递给Swift函数。然后，通过改变函数来使用指针而不是原始的字符串类型，我们可以很容易地访问<em class="ls"> s1 </em>和<em class="ls"> s2 </em></p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="dc6c" class="nc mb iq my b gy nd ne l nf ng"><a class="ae kv" href="http://twitter.com/_cdecl" rel="noopener ugc nofollow" target="_blank">@_cdecl</a>("allocate")<br/>func allocate(size: Int) -&gt; UnsafeMutableRawPointer {<br/>  return UnsafeMutableRawPointer.allocate(byteCount: size, alignment: MemoryLayout&lt;UInt8&gt;.alignment)<br/>}<br/><a class="ae kv" href="http://twitter.com/_cdecl" rel="noopener ugc nofollow" target="_blank">@_cdecl</a>("deallocate")<br/>func deallocate(pointer: UnsafeMutableRawPointer, size: Int) {<br/>  pointer.deallocate()<br/>}</span><span id="98ec" class="nc mb iq my b gy nh ne l nf ng"><a class="ae kv" href="http://twitter.com/_cdecl" rel="noopener ugc nofollow" target="_blank">@_cdecl</a>("concatenate")<br/>func concatenateFromHost(s1: UnsafePointer&lt;CChar&gt;, s2: UnsafePointer&lt;CChar&gt;) -&gt; UnsafePointer&lt;CChar&gt; {<br/>  let str1 = String(cString: s1)<br/>  let str2 = String(cString: s2)<br/>  let result = str1 + " " + str2<br/>  <br/>  return UnsafeMutablePointer&lt;CChar&gt;(mutating: result)<br/>}</span></pre><p id="1a85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Go应用程序中，你应该分配内存，然后用<em class="ls">字符串</em>内容填充它。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="db02" class="nc mb iq my b gy nd ne l nf ng">func main() {<br/> .........<br/> concatenate(&amp;instance, "Hello", "World!")<br/>}</span><span id="c30e" class="nc mb iq my b gy nh ne l nf ng">func concatenate(instance *wasmer.Instance, s1, s2 string) {<br/> // Allocate memory function<br/> allocate := instance.Exports["allocate"]</span><span id="7836" class="nc mb iq my b gy nh ne l nf ng"> memoryPointerS1 := func() int32 {<br/>  // run allocate for s2<br/>  pointer, err := allocate(len(s1) + 1)<br/>  if err != nil {<br/>   panic(err)<br/>  }</span><span id="953d" class="nc mb iq my b gy nh ne l nf ng">  // copy s2 to memory<br/>  memoryS1 := instance.Memory.Data()[pointer.ToI32():]<br/>  copy(memoryS1, s2)<br/>  memoryS1[len(s1)] = 0</span><span id="92e7" class="nc mb iq my b gy nh ne l nf ng">  return pointer.ToI32()<br/> }()</span><span id="2c70" class="nc mb iq my b gy nh ne l nf ng"> memoryPointerS2 := func() int32 {<br/>  // run allocate for s2<br/>  pointer, err := allocate(len(s2) + 1)<br/>  if err != nil {<br/>   panic(err)<br/>  }</span><span id="56d3" class="nc mb iq my b gy nh ne l nf ng">  // copy s2 to memory<br/>  memoryS2 := instance.Memory.Data()[pointer.ToI32():]<br/>  copy(memoryS2, s2)<br/>  memoryS2[len(s2)] = 0</span><span id="1e70" class="nc mb iq my b gy nh ne l nf ng">  return pointer.ToI32()<br/> }()</span><span id="cbb2" class="nc mb iq my b gy nh ne l nf ng">// Get concatenate function from the WebAssembly instance.<br/> concatenate := instance.Exports["concatenate"]</span><span id="00aa" class="nc mb iq my b gy nh ne l nf ng">// Calls that exported function with memory pointers.<br/> result, err := concatenate(memoryPointerS1, memoryPointerS2)<br/> if err != nil {<br/>  panic(err)<br/> }</span><span id="e8d7" class="nc mb iq my b gy nh ne l nf ng"> // The result is another memory pointer is another string<br/> fmt.Println(result)<br/>}</span></pre><p id="948e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次构建并生成wasm</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="12c2" class="nc mb iq my b gy nd ne l nf ng">$ swift build --triple wasm32-unknown-wasi -c release --toolchain $TOOLCHAIN_PATH -Xlinker --export=allocate -Xlinker --export=deallocate -Xlinker --export=concatenate<br/>&gt; [1/1] Linking swiftwasm</span><span id="836e" class="nc mb iq my b gy nh ne l nf ng">$ go run ./<br/>2031808</span></pre><p id="85e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，返回值是另一个Int，它指向返回值的指针。这是因为函数"<em class="ls"> concatenate </em>"返回一个指向包含结果字符串的内存的指针。为了使它变回字符串，我们必须在Go项目中添加以下函数</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="52dd" class="nc mb iq my b gy nd ne l nf ng">func concatenate(instance *wasmer.Instance, s1, s2 string) {<br/> ...........  <br/> output, _ := convertToString(instance, result)<br/> fmt.Println(output)<br/>}</span><span id="d4a1" class="nc mb iq my b gy nh ne l nf ng">func convertToString(instance *wasmer.Instance, output wasmer.Value) (string, int32) {<br/> memory := instance.Memory.Data()[output.ToI32():]<br/> var builder strings.Builder<br/> counter := 0</span><span id="769d" class="nc mb iq my b gy nh ne l nf ng">for memory[counter] != 0 {<br/>  builder.WriteByte(memory[counter])<br/>  counter++<br/> }<br/> return builder.String(), int32(counter)<br/>}</span></pre><p id="23a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果会是什么</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="2b8e" class="nc mb iq my b gy nd ne l nf ng">$ go run ./<br/>&gt; World World!</span></pre><p id="23a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是在代码执行完成后释放内存。不执行最后一步很容易增加未使用的内存并影响Go运行时性能</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="93db" class="nc mb iq my b gy nd ne l nf ng">func concatenate(instance *wasmer.Instance, s1, s2 string) {<br/> ...........  <br/> output, size := convertToString(instance, result)<br/> <br/> // deallocate memory function<br/> deallocate := instance.Exports["deallocate"]</span><span id="00e8" class="nc mb iq my b gy nh ne l nf ng"> // deallocate memoryS1<br/> _, err = deallocate(memoryPointerS1, len(s1))<br/> if err != nil {<br/>  panic(err)<br/> }</span><span id="a444" class="nc mb iq my b gy nh ne l nf ng"> // deallocate memorySs<br/> _, err = deallocate(memoryPointerS2, len(s2))<br/> if err != nil {<br/>  panic(err)<br/> }</span><span id="9653" class="nc mb iq my b gy nh ne l nf ng"> // deallocate output memory<br/> _, err = deallocate(result, size)<br/> if err != nil {<br/>  panic(err)<br/> }<br/>}</span></pre><h1 id="d7df" class="ma mb iq bd mc md ni mf mg mh nj mj mk jw nk jx mm jz nl ka mo kc nm kd mq mr bi translated">作为参数的数组</h1><p id="a4b3" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">处理<em class="ls">数组</em>与处理<em class="ls">字符串</em>几乎是一样的，这可能是一个很好的练习，让你检查到目前为止你的学习情况。如果你觉得在处理它们时有问题，你可以在GitHub上查看完整的代码(下面的链接)</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a042" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">下一步是什么</h1><p id="51d9" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这一部分主要是关于在二进制端运行导出的函数，而我们仍然不知道如何在Go端调用函数<em class="ls"/>。如果你想了解那个，可以关注这里发布的下篇:<a class="ae kv" href="https://medium.com/@h.shahbazi/the-power-of-swift-web-assembly-part-3-e583c6ab8afe" rel="noopener">https://medium . com/@ h . shah bazi/the-power-of-swift-web-assembly-part-3-e 583 c 6 ab 8 AFE</a></p><p id="10ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，这两个项目都可以在<a class="ae kv" href="https://github.com/hassan-shahbazi/swiftwasm-go/tree/part2" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上访问</p></div></div>    
</body>
</html>