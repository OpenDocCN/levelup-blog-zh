<html>
<head>
<title>A Practical Guide to Azure Durable Functions — Part 4: Retry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure持久功能实用指南—第4部分:重试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-practical-guide-to-azure-durable-functions-part-4-retry-3b60c46067fa?source=collection_archive---------13-----------------------#2020-06-08">https://levelup.gitconnected.com/a-practical-guide-to-azure-durable-functions-part-4-retry-3b60c46067fa?source=collection_archive---------13-----------------------#2020-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5853bc51e5a94bb5e51a06ed3432c91b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALS6Yowowy9FmOQXnYrTcA.png"/></div></div></figure><div class=""/><div class=""><h2 id="da39" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">通过Azure Durable Functions创建生产就绪功能应用程序所需的一切。</h2></div><p id="99f2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">本系列的第4部分是关于Azure持久功能的重试机制。这个故事中的示例代码采用了一种非常简单的方法来设置配置。如果您对更复杂的配置设置感兴趣，您可能想看看前面的故事。</p><div class="ip iq gp gr ir lm"><a href="https://medium.com/@allen.zhang1983713/a-practical-guide-to-azure-durable-functions-part-3-configurations-6baa1b49f532" rel="noopener follow" target="_blank"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd jc gy z fp lr fr fs ls fu fw ja bi translated">Azure持久功能实用指南——第3部分:配置</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">通过Azure Durable Functions创建生产就绪功能应用程序所需的一切。</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">medium.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma ix lm"/></div></div></a></div><p id="bac8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">主要有3种重试机制可用于持久功能。</p><ul class=""><li id="a637" class="mb mc jb ks b kt ku kw kx kz md ld me lh mf ll mg mh mi mj bi translated">通过服务总线重试。</li><li id="af16" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated">带有重试功能的内置活动/子流程调用。</li><li id="0900" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated">内置子编排器重试。</li></ul><p id="95aa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们之前在系列中根本没讲过副指挥。这是耐用功能的一个非常强大的功能。我们会找到的，请耐心听我说。</p><p id="a023" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们的演示应用程序仍然是旧的GitHub视图计数器。在实际应用程序中，您可能希望重试任何web API调用，因为:</p><ul class=""><li id="5085" class="mb mc jb ks b kt ku kw kx kz md ld me lh mf ll mg mh mi mj bi translated">API可能是速率受限的，以保护自己免受DDOS攻击。</li><li id="e4bd" class="mb mc jb ks b kt mk kw ml kz mm ld mn lh mo ll mg mh mi mj bi translated">网络有时可能不稳定。</li></ul><p id="b901" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了模拟速率受限的API端点，我让<strong class="ks jc"> GetRepositoryViewCount </strong>活动函数随机抛出一个自定义异常。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9eff" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果我们用这个代码变化在本地运行它，它有时会失败。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mv"><img src="../Images/4a547fa218a05ee6ebb46816d971783b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0B9mkYYAHvJLzkq6R2VfWA.png"/></div></div></figure><p id="0d33" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">那很好。现在我们需要重试API调用。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="a1fa" class="nd ne jb bd nf ng nh ni nj nk nl nm nn kh no ki np kk nq kl nr kn ns ko nt nu bi translated">服务总线重试</h1><p id="350b" class="pw-post-body-paragraph kq kr jb ks b kt nv kc kv kw nw kf ky kz nx lb lc ld ny lf lg lh nz lj lk ll ij bi translated">严格来说，这与Azure持久功能无关。重试发生在Azure服务总线上。</p><p id="9c10" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">实现它的代码是三个中最简单的:什么都不做。但是简单的方法总是好的方法吗？</p><p id="5bda" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通过消息队列的重试机制已经存在很多年了，并且被证明是可靠的。然而，我不建议使用服务总线触发器来增加Azure持久功能应用的弹性。</p><p id="ba9d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">请记住，服务总线触发器只是Azure函数触发器的一种。如果您的应用程序的弹性仅仅依赖于它，其他触发器必须将它们的请求转发给服务总线。orchestrator实际上只接受来自服务总线触发器的真实请求。</p><p id="a65c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于一个简单的Azure Function应用程序来说，这可能是唯一的选择，也确实是一个限制。但是我们当然不必依赖服务总线来获得具有持久功能的弹性。有更好的内置重试机制。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="7167" class="nd ne jb bd nf ng nh ni nj nk nl nm nn kh no ki np kk nq kl nr kn ns ko nt nu bi translated">带RetryOptions的函数调用</h1><p id="f39a" class="pw-post-body-paragraph kq kr jb ks b kt nv kc kv kw nw kf ky kz nx lb lc ld ny lf lg lh nz lj lk ll ij bi translated">到目前为止，在本系列的示例代码中，我们一直使用<strong class="ks jc"> CallActivityAsync </strong>来调用活动函数。当活动函数抛出异常时，编排失败并存在。</p><p id="120a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但是在<strong class="ks jc">IDurableOrchestrationContext</strong>接口上还有另外两个方法可用于<strong class="ks jc"> RetryOptions </strong>:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a87d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们稍后会讲到副指挥。让我们通过用<strong class="ks jc">callactivitywithreyasync</strong>调用替换<strong class="ks jc"> CallActivityAsync </strong>调用来改进我们现有的代码。</p><p id="baa4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这个简单的演示应用程序中，我们可以定义一个单独的<strong class="ks jc"> RetryOptions </strong>，并让所有活动函数共享它。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="884b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这意味着第一次重试应该发生在异常后2秒，最大重试次数应该是5次，我们只想重试<strong class="ks jc"> TooManyRequestsException </strong>异常类型。</p><p id="5a78" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们现在可以在orchestrator中用重试版本替换活动函数调用。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a860" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果我们现在运行应用程序，并且如果我们不是非常不走运(经过这么多次重试，随机数总是大于或等于7的可能性很小)，异常仍然会发生，但是orchestrator应该会成功完成重试。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/67f11861151e4ecb793ff76a436815f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qlHwSbuzqUs4O3gcPPQLiw.png"/></div></div></figure><p id="77a6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">依我看，这比服务总线重试要好。它不需要另一个Azure资源(Azure服务总线),并且可以按照你想要的方式进行配置。</p><p id="41ac" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">带有重试功能的子流程调用的工作方式与活动调用非常相似。</p><p id="be21" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但是，如果您需要实现更复杂的逻辑，还有另一个使用子编排器的重试选项。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="3c05" class="nd ne jb bd nf ng nh ni nj nk nl nm nn kh no ki np kk nq kl nr kn ns ko nt nu bi translated">副指挥重试</h1><p id="5fcd" class="pw-post-body-paragraph kq kr jb ks b kt nv kc kv kw nw kf ky kz nx lb lc ld ny lf lg lh nz lj lk ll ij bi translated">此选项仅通过子协调器提供。那么什么是副指挥呢？</p><p id="20a3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你可能已经从名字猜到了。当一个指挥A可以调用另一个指挥B <strong class="ks jc">，</strong>时，我们开始称B为副指挥。</p><p id="2499" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从编码的角度来看，orchestrator B没有什么特别的，它只是一个普通的orchestrator函数。它只有在从。</p><p id="ffb6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在有趣的事情发生了，当你像这样链接管弦乐队时:</p><pre class="mp mq mr ms gt ob oc od oe aw of bi"><span id="0cc1" class="og ne jb oc b gy oh oi l oj ok">A =&gt; B =&gt; C =&gt; A</span></pre><p id="48e7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">是的，持久函数可以递归！现在，使用持久函数处理树数据结构应该没有问题了。当然，当你设计这样的东西时要小心，就像设计任何其他递归方法一样。</p><p id="c1e8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">子编排器不仅使持久函数变得非常强大和灵活，而且还提供了另一种重试机制，可以更好地控制代码。</p><p id="dba0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">首先，演示应用程序中的主编排器不应该再直接调用活动。它会调用一个子指挥器。</p><p id="7478" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">注意，我们不使用<strong class="ks jc"> WithRetry </strong>方法调用子流程。重试发生在子协调器内部。</p><p id="3a7c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">新创建的子编排器将调用活动函数。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6d85" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最重要的一行是<strong class="ks jc">上下文。ContinueAsNew(updatedRepoName)；</strong></p><p id="f7fa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc"> ContinueAsNew </strong>让orchestrator重置当前状态(持久函数是有状态的，记得吗？)并用给定的输入参数重新启动。</p><p id="cb13" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上面的代码中，在重试之前添加了10到30秒之间的随机延迟。调用一个更新输入参数的方法来演示您可以在重试之前更新输入。</p><p id="866b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">将此选项与前一个选项进行比较，我们可以看到这允许实现更复杂的重试逻辑。并且<strong class="ks jc">不</strong>需要<strong class="ks jc">T3】最大尝试次数。你可以永远重试。</strong></p><p id="fb50" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了验证它的工作，我们在本地运行更新的应用程序。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/eaccbdb8da1c9db5f6e592948c3bc550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQ9qjPHm0RMQ7192UY9jNg.png"/></div></div></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="9a65" class="nd ne jb bd nf ng nh ni nj nk nl nm nn kh no ki np kk nq kl nr kn ns ko nt nu bi translated">摘要</h1><p id="1737" class="pw-post-body-paragraph kq kr jb ks b kt nv kc kv kw nw kf ky kz nx lb lc ld ny lf lg lh nz lj lk ll ij bi translated">这个故事展示了Azur持久函数的三个重试选项。以及为什么您可能不应该依赖服务总线来获得弹性。请不要急于得出Azure服务总线无用的结论。与系统的其他部分集成仍然是一个不错的选择。</p><p id="b006" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当您的需求相对简单时，使用重试方法调用函数。设置简单，阅读清晰。</p><p id="068a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但是，如果您的场景需要通过重试来实现复杂的逻辑，那么子编排器方法可能更合适。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="8189" class="nd ne jb bd nf ng nh ni nj nk nl nm nn kh no ki np kk nq kl nr kn ns ko nt nu bi translated">系列摘要</h1><p id="002d" class="pw-post-body-paragraph kq kr jb ks b kt nv kc kv kw nw kf ky kz nx lb lc ld ny lf lg lh nz lj lk ll ij bi translated">这个系列是否兑现了字幕上的承诺？</p><blockquote class="om on oo"><p id="759f" class="kq kr op ks b kt ku kc kv kw kx kf ky oq la lb lc or le lf lg os li lj lk ll ij bi translated">通过Azure Durable Functions创建生产就绪功能应用程序所需的一切。</p></blockquote><p id="3d5c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">差不多了。本系列为开发人员或软件工程师创建满足业务需求的复杂无服务器软件奠定了基础。</p><p id="b001" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在真正投入生产之前，留给读者探索的唯一内容是devops方面。系列有点触及但没深入。在这里覆盖一个完整的Azure Devops管道感觉不太对。值得拥有自己的系列。读者可能有其他更喜欢的devops工具。所以我会让你自己去想应该怎么做。</p><p id="a92f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是Azure耐久功能系列的最后一个故事。以后大概还会再写Azure Function。关注我的新故事。</p></div></div>    
</body>
</html>