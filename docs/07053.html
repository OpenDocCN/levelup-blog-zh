<html>
<head>
<title>Find potential memory leaks with automated tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过自动化测试发现潜在的内存泄漏</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/find-potential-memory-leaks-with-automated-tests-7b8d78a5274f?source=collection_archive---------13-----------------------#2021-01-20">https://levelup.gitconnected.com/find-potential-memory-leaks-with-automated-tests-7b8d78a5274f?source=collection_archive---------13-----------------------#2021-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e816" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">内存处理和引用类型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dfb29efedbbe676445899e23f61fbef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yo2nG22qI8-u3PdFCD46Ww.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">豪尔赫·拉米雷斯在<a class="ae kv" href="https://unsplash.com/s/photos/ram-memory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="31f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就内存处理而言，在我们的iOS应用中工作可能非常具有挑战性，这意味着我们需要非常小心分配在内存中的<code class="fe ls lt lu lv b">object instances</code>,并保证它们的正确释放。</p><p id="25ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你可能知道的，实例是通过<strong class="ky ir"> ARC </strong>或<strong class="ky ir">自动引用计数</strong>从内存中释放的，在iOS上有两种类型的引用:强引用和弱引用。</p><p id="fb18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">强引用是默认的引用类型，让我们看一个简单的对象声明。假设我们有一个名为<code class="fe ls lt lu lv b">Person</code>的类，我们如下声明一个对象:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2312" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">var</strong> person = Person()</span></pre><p id="88b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的声明中，我们创建了一个对<code class="fe ls lt lu lv b">Person</code>对象的强引用。每次我们创建一个强引用，我们就把<em class="mg">对象保留计数</em>加1。那是什么意思？这为什么有用？这很有用，因为ARC不会从内存中删除一个对象，直到它的保留计数等于0。</p><p id="76b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，弱引用不会增加对象保留计数。让我们看一个例子:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="c50a" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">var</strong> person = Person()<br/><strong class="lv ir">weak</strong> <strong class="lv ir">var</strong> anotherPerson: Person? = person</span></pre><p id="0765" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的例子中，我们创建了一个对同一个人对象的弱引用，现在我们有了强引用和弱引用。这意味着，即使我们对同一个person对象有两个引用，它的保留计数仍然是1，因为其中一个是弱引用。弱引用的另一个重要方面是它们是可选的，因为我们可能在它们已经从内存中释放的时候访问它们。</p><h1 id="640f" class="mh mb iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">通过测试找到保留周期和内存泄漏</h1><p id="9f64" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">当两个对象彼此具有强引用时，就会发生保留循环。结果是两个对象都将自己保留在内存中，因为它们的保留计数永远不会为0。作为开发人员，我们需要打破这种循环，以便ARC能够释放那些对象占用的内存空间。</p><p id="b1c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有两个对象，其中一个类型为<code class="fe ls lt lu lv b">HTTPClient</code>，是<code class="fe ls lt lu lv b">UserProfileLoader</code>对象的合作者。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="a3d1" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">class</strong> UserProfileLoader {</span><span id="ffa9" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   private</strong> <strong class="lv ir">let</strong> client: HTTPClient<br/>   <strong class="lv ir">private</strong> <strong class="lv ir">let</strong> url: URL</span><span id="8acf" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   init</strong>(url: URL, client: HTTPClient) {<br/>      <strong class="lv ir">self</strong>.url = url<br/>      <strong class="lv ir">self</strong>.client = client<br/>   }</span><span id="9661" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   enum</strong> Error: Swift.Error {<br/>      <strong class="lv ir">case</strong> invalidProfileData<br/>      <strong class="lv ir">case</strong> connectivity<br/>   }</span><span id="0fb6" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   enum</strong> Result: Equatable {<br/>      <strong class="lv ir">case</strong> success(UserProfile)<br/>      <strong class="lv ir">case</strong> failure(Error)<br/>   }</span><span id="439c" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   func</strong> loadProfile(completion: <strong class="lv ir">@escaping</strong> (Result) -&gt; Void) {<br/>      client.get(from: url) { data <strong class="lv ir">in<br/>         let</strong> result = <strong class="lv ir">self</strong>.map(data: data)<br/>         completion(result)<br/>      }<br/>   }</span><span id="69e0" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   func</strong> map(data: HTTPClientResult) -&gt; Result {<br/>      <strong class="lv ir">return</strong> .success(UserProfile(id: "an-user-id"))<br/>   }</span><span id="79ab" class="ma mb iq lv b gy nd md l me mf">}</span></pre></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><pre class="lw lv lx ly aw lz bi"><span id="f2a5" class="ma mb iq lv b gy nl nm nn no np md l me mf"><strong class="lv ir">enum</strong> HTTPClientResult {<br/>   <strong class="lv ir">case</strong> success(Data)<br/>   <strong class="lv ir">case</strong> failure(Error)<br/>}</span><span id="01bb" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">protocol</strong> HTTPClient {</span><span id="1564" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   func</strong> get(from url: URL, <br/>            completion: <strong class="lv ir">@escaping</strong> (HTTPClientResult) -&gt; Void)</span><span id="415b" class="ma mb iq lv b gy nd md l me mf">}</span><span id="58d4" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">class</strong> HTTPClientSpy: HTTPClient {</span><span id="ae1f" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   var</strong> completion: ((HTTPClientResult) -&gt; Void)? = <strong class="lv ir">nil</strong></span><span id="15f1" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   func</strong> get(from url: URL, <br/>            completion: <strong class="lv ir">@escaping</strong> (HTTPClientResult) -&gt; Void) {<br/>       <br/>       <strong class="lv ir">self</strong>.completion = completion<br/>   }</span><span id="8970" class="ma mb iq lv b gy nd md l me mf">}</span></pre></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><pre class="lw lv lx ly aw lz bi"><span id="92b0" class="ma mb iq lv b gy nl nm nn no np md l me mf"><strong class="lv ir">struct</strong> UserProfile: Equatable {<br/>   <strong class="lv ir">var</strong> id: String<br/>}</span></pre><p id="6948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的例子中，我们的<code class="fe ls lt lu lv b">UserProfileLoader</code>有一个名为<code class="fe ls lt lu lv b">loadProfile</code>的方法，它调用类型为<code class="fe ls lt lu lv b">HTTPClient</code>的组合<code class="fe ls lt lu lv b">client</code>中的<code class="fe ls lt lu lv b">get</code>方法。正如你所看到的，我们的<code class="fe ls lt lu lv b">HTTPClientSpy</code>中的<code class="fe ls lt lu lv b">get</code>的实现在一个名为<code class="fe ls lt lu lv b">completion</code>的属性中存储了一个闭包，这使得我们的闭包可以从测试中访问。</p><p id="7e7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的实现肯定包含了保留周期，但是为什么呢，在哪里呢？乍一看并不明显，不是吗？，我们再来看看。<code class="fe ls lt lu lv b">UserProfileLoader</code>对<code class="fe ls lt lu lv b">HTTPClient</code>对象有强引用，在哪里？另一方面，在<code class="fe ls lt lu lv b">client</code>属性上，<code class="fe ls lt lu lv b">HTTPClient</code>实现也强烈引用了<code class="fe ls lt lu lv b">UserProfileLoader</code>，在哪里？你可能会说我们的<code class="fe ls lt lu lv b">HTTPClientSpy</code>中没有存储任何<code class="fe ls lt lu lv b">UserProfileLoader</code>，但肯定有一个。让我们再看看我们的<code class="fe ls lt lu lv b">get</code>方法，这个方法将接收到的闭包存储在<code class="fe ls lt lu lv b">completion </code>属性中，这个闭包对我们的<code class="fe ls lt lu lv b">UserProfileLoader</code>对象有一个强引用，在哪里？在<code class="fe ls lt lu lv b">map</code>方法调用中。如你所见，我们通过明确使用<code class="fe ls lt lu lv b">self</code>添加了一个强引用。</p><p id="ad7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种错误通常会在很多代码库中发现，有时它们并不明显，我们也不能避免陷入其中。我们可以通过使用自动化测试来减少这种可能性，但是怎么做呢？我们必须确保被测系统及其合作者<strong class="ky ir"> SUT </strong>或<strong class="ky ir">被适当地解除分配。</strong></p><p id="f72e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从写出第一个测试开始，这个测试将覆盖成功的路径。在这个例子中，我们的SUT将是我们的<code class="fe ls lt lu lv b">UserProfileLoader</code>实例。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="94d1" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">func</strong> test_load_withSuccesfulClientResponseDeliversSuccesLoadingResult() {</span><span id="1d52" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   let</strong> url = URL(string: "https://a-url.com")!<br/>   <strong class="lv ir">let</strong> client = HTTPClientSpy()<strong class="lv ir"><br/>   let</strong> sut = UserProfileLoader(url: url, client: client)</span><span id="684e" class="ma mb iq lv b gy nd md l me mf">}</span></pre><p id="1153" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经有了给定的结果，现在我们必须将加载结果存储在某个地方，以做出一些断言，正如你所记得的那样，<code class="fe ls lt lu lv b">loadProfile</code>方法将使用类型为<strong class="ky ir"> (Result) - &gt; Void </strong>的闭包来完成。让我们将结果存储在测试中。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2e50" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">func</strong> test_load_withSuccesfulClientResponseDeliversSuccesLoadingResult() {</span><span id="9b44" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   let</strong> url = URL(string: "https://a-url.com")!<br/>   <strong class="lv ir">let</strong> client = HTTPClientSpy()<strong class="lv ir"><br/>   let</strong> sut = UserProfileLoader(url: url, client: client)</span><span id="72fa" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   var</strong> capturedResults = [UserProfileLoader.Result]()<br/>   sut.loadProfile { capturedResults.append($0) }</span><span id="e599" class="ma mb iq lv b gy nd md l me mf">}</span></pre><p id="d78f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们之前的测试中，负载闭包永远不会被执行，为什么？因为我们的<code class="fe ls lt lu lv b">loadProfile</code>在调用<code class="fe ls lt lu lv b">get</code>的实现，你还记得<code class="fe ls lt lu lv b">get</code>的实现是做什么的吗？在我们的<code class="fe ls lt lu lv b">HTTPClientSpy</code>实例中，<code class="fe ls lt lu lv b">get</code>方法将接收到的闭包存储在一个属性中。我们必须在测试中调用存储的完成块来获得结果。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7f61" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">func</strong> test_load_withSuccesfulClientResponseDeliversSuccesLoadingResult() {</span><span id="3657" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   let</strong> url = URL(string: "https://a-url.com")!<br/>   <strong class="lv ir">let</strong> client = HTTPClientSpy()<strong class="lv ir"><br/>   let</strong> sut = UserProfileLoader(url: url, client: client)</span><span id="b39c" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   var</strong> capturedResults = [UserProfileLoader.Result]()<br/>   sut.loadProfile { capturedResults.append($0) }</span><span id="b6bf" class="ma mb iq lv b gy nd md l me mf">   client.completion?(.success(Data()))</span><span id="bdab" class="ma mb iq lv b gy nd md l me mf">}</span></pre><p id="47a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以开始用<code class="fe ls lt lu lv b">capturedResults</code>数组做一些断言了。我们的<code class="fe ls lt lu lv b">loadProfile</code>方法将总是以包含<code class="fe ls lt lu lv b">UserProfile</code>实例的成功结果完成。这就是我们在测试中所期待的。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="b14f" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">class</strong> MemoryLeaksTests: XCTestCase {</span><span id="7f68" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   func</strong> test_load_withSuccesfulCallDeliversSuccesLoadingResult() {</span><span id="dc99" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">      let</strong> url = URL(string: "https://a-url.com")!<br/>      <strong class="lv ir">let</strong> client = HTTPClientSpy()<strong class="lv ir"><br/>      let</strong> sut = UserProfileLoader(url: url, client: client)</span><span id="a156" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">      let</strong> expectedResult: UserProfileLoader.Result =<br/>          .success(UserProfile(id: "an-user-id"))</span><span id="1f08" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">      var</strong> capturedResults = [UserProfileLoader.Result]()<br/>      sut.loadProfile { capturedResults.append($0) }<br/>      client.completion?(.success(Data()))</span><span id="2fcc" class="ma mb iq lv b gy nd md l me mf">      XCTAssertEqual(capturedResults, [expectedResult])</span><span id="da31" class="ma mb iq lv b gy nd md l me mf">   }</span><span id="bb23" class="ma mb iq lv b gy nd md l me mf">}</span></pre><p id="60ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！我们有一个通过测试！这个测试能确保我们的SUT和它的合作者的正确释放吗？还没有。让我们添加一些断言来确保我们的测试是从内存中释放的。</p><p id="712d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe ls lt lu lv b">MemoryLeaksTests</code>类从<code class="fe ls lt lu lv b">XCTestCase</code>类扩展而来，<code class="fe ls lt lu lv b">XCTestCase</code>类为我们提供了一个名为<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.apple.com/documentation/xctest/xctestcase/2887226-addteardownblock" rel="noopener ugc nofollow" target="_blank">addTearDownBlock</a></code>的方法，这个方法接收一个类型为<strong class="ky ir"> () - &gt; Void </strong>的块，每次测试函数结束时都会执行这个块。我们可以添加一个拆除块后，我们的SUT和它的合作者创造的权利。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="d2a2" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">class</strong> MemoryLeaksTests: XCTestCase {</span><span id="32c4" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   func</strong> test_load_withSuccesfulCallDeliversSuccesLoadingResult() {</span><span id="2e76" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">      let</strong> url = URL(string: "https://a-url.com")!<br/>      <strong class="lv ir">let</strong> client = HTTPClientSpy()<strong class="lv ir"><br/>      let</strong> sut = UserProfileLoader(url: url, client: client)</span><span id="5cdb" class="ma mb iq lv b gy nd md l me mf">      addTeardownBlock { [<strong class="lv ir">weak</strong> sut, <strong class="lv ir">weak</strong> client] <strong class="lv ir">in<br/>         </strong>XCTAssertNil(client, "Instance has not been deallocated")<br/>         XCTAssertNil(sut, "Instance has not been deallocated")<br/>      }</span><span id="b918" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">      let</strong> expectedResult: UserProfileLoader.Result =<br/>          .success(UserProfile(id: "an-user-id"))</span><span id="2a4e" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">      var</strong> capturedResults = [UserProfileLoader.Result]()<br/>      sut.loadProfile { capturedResults.append($0) }<br/>      client.completion?(.success(Data()))</span><span id="1ac9" class="ma mb iq lv b gy nd md l me mf">      XCTAssertEqual(capturedResults, [expectedResult])</span><span id="9a08" class="ma mb iq lv b gy nd md l me mf">   }</span><span id="f2eb" class="ma mb iq lv b gy nd md l me mf">}</span></pre><p id="5c19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经有了我们的积木。请注意，在我们的块中，我们添加了对<code class="fe ls lt lu lv b">sut</code>和<code class="fe ls lt lu lv b">client</code>实例的弱引用，以避免进一步增加它们的保留计数。现在我们的绿色测试不再是绿色的了，因为拆卸块断言失败了。</p><p id="fc24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了去除保留循环，我们可以避免在我们的<code class="fe ls lt lu lv b">loadProfile</code>方法中显式使用<code class="fe ls lt lu lv b">self</code>。我们有一些选择:</p><ol class=""><li id="ebfc" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">在我们的闭包中使用一个<strong class="ky ir">弱</strong>引用，并添加guard let块来解开结果；</li><li id="5334" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">把我们的<code class="fe ls lt lu lv b">map</code>方法变成静态方法；或者</li><li id="0c9e" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">将<code class="fe ls lt lu lv b">map</code>方法移动到映射器类静态方法</li></ol><p id="c83d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，我将使用第二个选项来打破保留循环并通过测试。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="1314" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">func</strong> loadProfile(completion: <strong class="lv ir">@escaping</strong> (Result) -&gt; Void) {<br/>   client.get(from: url) { data <strong class="lv ir">in<br/>      </strong>completion(UserProfileLoader.map(data: data))<br/>   }<br/>}</span><span id="9d28" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">static</strong> <strong class="lv ir">func</strong> map(data: HTTPClientResult) -&gt; Result {<br/>   <strong class="lv ir">return</strong> .success(UserProfile(id: "an-user-id"))<br/>}</span></pre><p id="537f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们的测试通过了，但是…它看起来有点乱，所以让我们重构我们的测试来清理一下。假设我们想要添加更多的测试功能(相信我，我们会想要的🙂)，我们将创建我们的SUT和它的合作者，并为他们每个人添加拆除块，这意味着我们将重复自己。</p><p id="441e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了重构这个测试，我们将创建一些工厂方法。第一个将是我们的<code class="fe ls lt lu lv b">makeSUT</code>方法，这个方法将返回SUT及其合作者。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="4d26" class="ma mb iq lv b gy mc md l me mf"><strong class="lv ir">class</strong> MemoryLeaksTests: XCTestCase {</span><span id="5037" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   func</strong> test_load_withSuccesfulCallDeliversSuccesLoadingResult() {</span><span id="62a5" class="ma mb iq lv b gy nd md l me mf">      <strong class="lv ir">let</strong> (sut, client) = <br/>          makeSUT(url: URL(string: "https://a-url.com")!)<br/>      <strong class="lv ir">let</strong> expectedResult: UserProfileLoader.Result =<br/>          .success(UserProfile(id: "an-user-id"))</span><span id="0df2" class="ma mb iq lv b gy nd md l me mf">      <strong class="lv ir">var</strong> capturedResults = [UserProfileLoader.Result]()<br/>      sut.loadProfile { capturedResults.append($0) }<br/>      client.completion?(.success(Data()))</span><span id="22c2" class="ma mb iq lv b gy nd md l me mf">      XCTAssertEqual(capturedResults, [expectedResult])<br/>   }</span><span id="3a97" class="ma mb iq lv b gy nd md l me mf">   // MARK:<strong class="lv ir"> - Helpers</strong></span><span id="fd3b" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">   func</strong> makeSUT(url: URL,<br/>                file: StaticString = <strong class="lv ir">#filePath</strong>,<br/>                line: UInt = <strong class="lv ir">#line</strong>) -&gt; (sut: UserProfileLoader, client: HTTPClientSpy) {</span><span id="600a" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">      let</strong> client = HTTPClientSpy()<br/>      <strong class="lv ir">let</strong> sut = UserProfileLoader(url: url, client: client)<br/>      addTeardownBlock { [<strong class="lv ir">weak</strong> sut, <strong class="lv ir">weak</strong> client] <strong class="lv ir">in<br/>         </strong>XCTAssertNil(client, <br/>                      "Instance has not been deallocated", <br/>                      file: file, <br/>                      line: line)<br/>         XCTAssertNil(sut, <br/>                      "Instance has not been deallocated", <br/>                      file: file, <br/>                      line: line)<br/>      }</span><span id="772b" class="ma mb iq lv b gy nd md l me mf"><strong class="lv ir">      return</strong> (sut, client)</span><span id="52e3" class="ma mb iq lv b gy nd md l me mf">   }</span><span id="f92d" class="ma mb iq lv b gy nd md l me mf">}</span></pre><p id="a1a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有一个更干净的测试！我们的测试可读性更强，我们还有一个很大的优势！除了清洁剂测试还有哪个？你可能会说，如果你看一看<code class="fe ls lt lu lv b">makeSUT</code>工厂方法，这个方法添加了我们的分解块，这意味着一旦测试完成，使用这个方法创建SUT的每个测试将自动验证SUT及其合作者是否被正确地从内存中释放。如果SUT及其合作者没有从内存中释放，测试将在<code class="fe ls lt lu lv b">makeSUT</code>调用中显示错误，因为我们正在将<code class="fe ls lt lu lv b">file</code>和<code class="fe ls lt lu lv b">line</code>参数传递给<code class="fe ls lt lu lv b">XCTAssertNil</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/79b1629f6238f6b867da8cc264838774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*OAiMyVvA0WIRf21eIpalVw.png"/></div></figure><p id="cdb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遵循这种方法将给予我们重构的信心，并验证我们正在进行正确的内存管理。</p></div></div>    
</body>
</html>