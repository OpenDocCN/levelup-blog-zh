<html>
<head>
<title>Performance Optimization Techniques In React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的性能优化技术</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/performance-optimization-techniques-in-react-31dee64c3b5?source=collection_archive---------5-----------------------#2020-03-03">https://levelup.gitconnected.com/performance-optimization-techniques-in-react-31dee64c3b5?source=collection_archive---------5-----------------------#2020-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5964015b9fedfab0a72f7f61e6bb59d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p3rIQcMKIGbzPCBT.jpeg"/></div></div></figure><p id="8c82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React在内部使用了许多技术来最小化更新UI所需的DOM操作的数量。</p><p id="a7dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，任何应用程序，无论是在React还是任何其他前端框架中开发，其性能最终都会下降。</p><p id="5a81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">开发人员必须了解React的工作原理及其组件生命周期。如果我们能够正确理解这些概念，我们可以获得很多性能改进。这可以通过组件渲染的<strong class="kd iu">测量</strong>和<strong class="kd iu">优化</strong>、<strong class="kd iu">如何</strong>和<strong class="kd iu">何时</strong>来实现。</p><p id="f281" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除此之外，还有许多其他方法可以提高React应用程序的速度。基于我团队的经验，我写下几点我认为对优化有帮助的内容。</p><p id="a83b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，这个列表并不详尽，它只涵盖了几个方面。还有许多其他技术可以用来提高性能。</p><h1 id="9c11" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用生产版本</h1><p id="dd8d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这是一个非常基本的技术，我相信每个人都在这样做。不过，值得一提的是。在向用户部署我们的应用程序时，我们应该使用缩小的生产版本。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/76ce65b9856652405bf64941cc6a6992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*FwziebNkTS8YeJMJ.png"/></div></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="9762" class="kz la it bd lb lc mo le lf lg mp li lj lk mq lm ln lo mr lq lr ls ms lu lv lw bi translated">捆绑和缩小</h1><p id="57db" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">对于任何React SPA，我们可以将所有JavaScript代码捆绑在一个小文件中。只要我们的应用程序很小，这就很好。</p><p id="70fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，一旦它开始增长，在一个文件中管理所有的JS代码就变得很乏味，代码也很难理解。此外，将这个大文件发送到浏览器本身将是一个非常耗时的过程。因此，我们需要使用某种机制将我们的应用程序分成多个文件，并在需要时将它们提交给浏览器。</p><p id="da1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们使用的是<strong class="kd iu"> <em class="mt"> Webpack </em> </strong>，我们可以利用它的代码分割功能将我们的应用程序代码转换成多个“块”文件。</p><p id="747d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有两种类型的拆分:资源拆分和按需代码拆分。</p><p id="d81f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">利用<strong class="kd iu"> <em class="mt">资源拆分</em> </strong>，我们可以将资源内容拆分成多个文件。例如，使用<em class="mt"> CommonsChunkPlugin </em>，我们可以将公共代码(比如所有外部库)提取到一个自己的“chunk”文件中。</p><p id="6862" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<em class="mt">ExtractTextWebpackPlugin</em>，您可以将所有CSS代码提取到一个单独的CSS文件中。这种拆分将在两个方面有所帮助。</p><ul class=""><li id="4408" class="mu mv it kd b ke kf ki kj km mw kq mx ku my ky mz na nb nc bi translated">它有助于浏览器缓存那些变化不太频繁的资源。</li><li id="3c3c" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">这也将有助于浏览器利用并行下载来潜在地减少加载时间。</li></ul><p id="5a97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mt"> Webpack </em>另一个值得注意的特点是<strong class="kd iu"> <em class="mt">按需代码拆分</em> </strong>。我们可以用它将代码分割成可以按需加载的块。</p><p id="b681" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这可以保持初始下载量较小，从而减少加载应用程序的时间。然后，当应用程序需要时，浏览器可以按需下载其他代码块。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/4dff5df90e2d8ba8d190a0a28234bdf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*Pf_6YSeIdqrsyzlqv-Y0uA.png"/></div></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="4617" class="kz la it bd lb lc mo le lf lg mp li lj lk mq lm ln lo mr lq lr ls ms lu lv lw bi translated">使用时，不要使用数组索引作为键。地图()</h1><p id="fd2d" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">假设我们想要呈现一个列表，如果我们没有设置任何键，我们将在控制台看到下面的警告。</p><pre class="md me mf mg gt nj nk nl nm aw nn bi"><span id="8899" class="no la it nk b gy np nq l nr ns">Warning: Each child in an array or iterator should have a unique “key” prop.</span></pre><p id="8d41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了解决这个问题，很多时候我们只是简单地将循环的<code class="fe nt nu nv nk b">index</code>值作为子元素的<code class="fe nt nu nv nk b">key</code>值传入。</p><pre class="md me mf mg gt nj nk nl nm aw nn bi"><span id="d6f6" class="no la it nk b gy np nq l nr ns">{todos.map((todo, index) =&gt;<br/>  &lt;Todo<br/>    {...todo}<br/>    key={index}<br/>  /&gt;<br/>)}</span></pre><p id="97ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它看起来很干净，完成了任务。它去掉了警告，这才是真正的问题，对吗？然而，真正的危险还在前面。</p><blockquote class="nw nx ny"><p id="c09c" class="kb kc mt kd b ke kf kg kh ki kj kk kl nz kn ko kp oa kr ks kt ob kv kw kx ky im bi translated">它可能会破坏我们的应用程序并显示错误的数据…！</p></blockquote><p id="1ded" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae oc" href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318" rel="noopener">索引作为键是一个反模式</a>。</p><p id="2390" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为什么，因为T2是React用来标识DOM元素的唯一东西。当我们从列表中推送或移除任何项目时，如果键与之前相同，React会假设DOM元素表示相同的组件。但是自从更新发生后，情况就不再是这样了。</p><p id="b42a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用一个惟一的属性作为键总是明智的，或者如果它不存在，那么我们可以使用<code class="fe nt nu nv nk b"><a class="ae oc" href="https://www.npmjs.com/package/shortid" rel="noopener ugc nofollow" target="_blank">shortid</a></code> npm包来生成一个惟一的键。</p><pre class="md me mf mg gt nj nk nl nm aw nn bi"><span id="8614" class="no la it nk b gy np nq l nr ns">var shortid <strong class="nk iu">=</strong> require('shortid');</span><span id="e35d" class="no la it nk b gy od nq l nr ns">function createNewTodo(text) {<br/>  return {<br/>    completed: false,<br/>    id: shortid.generate(),<br/>    text<br/>  }<br/>}</span></pre><p id="748b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，这里需要注意的重要一点是，在许多情况下，我们可以安全地使用索引作为键。</p><ul class=""><li id="7dd6" class="mu mv it kd b ke kf ki kj km mw kq mx ku my ky mz na nb nc bi translated">列表和项目是静态的，它们不会被计算，也不会改变</li><li id="a7bc" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">列表中的项目没有id</li><li id="10c3" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">列表不会被重新排序或过滤</li></ul><p id="70a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当<em class="mt">所有这些条件</em>都满足时，我们<strong class="kd iu">可以安全地使用索引作为关键字</strong>。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="ca1d" class="kz la it bd lb lc mo le lf lg mp li lj lk mq lm ln lo mr lq lr ls ms lu lv lw bi translated">在DOM元素上散布道具</h1><p id="b83b" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们通常将属性分散到元素中，以避免手动编写每个属性。</p><p id="3161" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，当我们将props扩展到一个DOM元素中时，我们冒了添加未知HTML属性的风险，这是不必要的，也是一种不好的做法。</p><p id="58c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们举一个例子</p><pre class="md me mf mg gt nj nk nl nm aw nn bi"><span id="ee10" class="no la it nk b gy np nq l nr ns">const Spread = () =&gt; &lt;div hero="superman" /&gt;</span></pre><p id="d2bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们得到的消息如下所示，因为<code class="fe nt nu nv nk b">hero</code>属性对于div元素无效。</p><pre class="md me mf mg gt nj nk nl nm aw nn bi"><span id="2e37" class="no la it nk b gy np nq l nr ns">Unknown props 'hero' on &lt;div&gt; tag. Remove this prop from the element</span></pre><p id="f0bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，很容易发现我们不正确地传递了什么，并删除它。然而，在spread操作符的情况下，我们不能像下面的例子那样控制所有的属性从父类中传递什么。</p><pre class="md me mf mg gt nj nk nl nm aw nn bi"><span id="1b65" class="no la it nk b gy np nq l nr ns">const Spread = props =&gt; &lt;div {...props} /&gt;</span></pre><p id="829f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此建议不要散布道具，而是设置特定的属性。</p><pre class="md me mf mg gt nj nk nl nm aw nn bi"><span id="4b54" class="no la it nk b gy np nq l nr ns">const SpecificAttribute = props =&gt; <br/>      &lt;div <!-- -->specificAttr={props.specificAttr}<!-- --> /&gt;</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="ca50" class="kz la it bd lb lc mo le lf lg mp li lj lk mq lm ln lo mr lq lr ls ms lu lv lw bi translated">仅在必要和要求时更新组件</h1><p id="c19f" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">每当任何组件的属性或状态改变时，React都会检查它是否需要更新实际的DOM。</p><p id="4b6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是通过比较现有的呈现组件和新返回的组件来实现的。如果它们相同，React什么也不做，否则它将基于新组件更新DOM。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/ccd7da40e98595207f8a21556c211280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*JhAAc4le-76Kqtnj.jpg"/></div></figure><p id="6d32" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">React只更新改变的DOM节点，不会重新渲染整个页面。然而，可能是单个渲染需要时间，我们不想在所有情况下都更新节点。</p><p id="7aa3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了解决这个问题，我们可以覆盖生命周期函数<code class="fe nt nu nv nk b">shouldComponentUpdate</code> <em class="mt"> </em>，它会在重新渲染过程开始前自动触发。我们可以覆盖它的默认实现，根据我们的场景返回false。</p><p id="b89a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也可以使用<code class="fe nt nu nv nk b">React.PureComponent</code>而不是更新<code class="fe nt nu nv nk b">shouldComponentUpdate()</code>。然而，我将把这留给开发者他们想要使用哪一个。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="5c8e" class="kz la it bd lb lc mo le lf lg mp li lj lk mq lm ln lo mr lq lr ls ms lu lv lw bi translated">不可变数据结构</h1><p id="d78a" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如果我们想使用<code class="fe nt nu nv nk b">React.PureComponent</code>来自动检查复杂的状态变化，我们需要使用不可变的数据结构。它不是一种架构或设计模式，它更像是一种编写代码的方式。</p><p id="62b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">建立不可变数据结构包括创建需要更新的对象的副本，而不是更新同一个对象本身。</p><p id="198e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，我们可以简化对象协调的过程来检测变化。然而，我们应该记住，它也有限制，我们不能改变不可变的数据一旦它被创建。</p><p id="4819" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好处:</p><ul class=""><li id="b2b0" class="mu mv it kd b ke kf ki kj km mw kq mx ku my ky mz na nb nc bi translated">没有副作用</li><li id="7a14" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">不可变数据对象更容易创建、测试和使用</li><li id="5c65" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">有助于防止时间耦合，这是一种代码在某种程度上依赖于时间的耦合</li><li id="9eae" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated">帮助我们编写可以用来快速检查状态是否有更新的逻辑，而不用递归地检查数据</li></ul><p id="ec4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用下面的库，它们提供了一组不可变的数据结构。</p><ul class=""><li id="8fae" class="mu mv it kd b ke kf ki kj km mw kq mx ku my ky mz na nb nc bi translated"><a class="ae oc" href="https://github.com/kolodny/immutability-helper" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">不变性助手</strong> </a> <strong class="kd iu"> : </strong>这是一个在不改变源代码的情况下对数据副本进行变异的好库。</li><li id="e850" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated"><a class="ae oc" href="https://facebook.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">immutable . js</strong></a><strong class="kd iu">:</strong>这是我最喜欢的库，因为它提供了很多持久不变的数据结构，包括:List、Stack、Map、OrderedMap、Set、OrderedSet和Record。</li><li id="4019" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated"><a class="ae oc" href="https://github.com/rtfeldman/seamless-immutable" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">无缝不可变</strong> </a> <strong class="kd iu"> : </strong>不可变JavaScript数据结构的库，向后兼容普通数组和对象。</li><li id="5a9a" class="mu mv it kd b ke nd ki ne km nf kq ng ku nh ky mz na nb nc bi translated"><a class="ae oc" href="https://github.com/aweary/react-copy-write" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">React-copy-write</strong></a><strong class="kd iu">:</strong>一个不可变的React状态管理库，有一个简单的可变API，记忆化的选择器，结构共享。</li></ul></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="382d" class="kz la it bd lb lc mo le lf lg mp li lj lk mq lm ln lo mr lq lr ls ms lu lv lw bi translated">摘要</h1><p id="eae0" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">微调任何React应用程序的主要关键在于确保组件只在绝对需要时更新。</p><p id="c7ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，不用说，我们需要确保性能优化应该是一个常规的优先事项，而不是把它留到最后。</p><p id="3a2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，如果我们进行任何与性能相关的更改，我们需要在更改前后运行基准分析，以查看是否有任何改进。</p><p id="a78a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们仍有许多方法或领域可以优化性能。然而，为了简洁起见，我没有在一篇文章中包括所有这些内容。我将尝试在以后文章中包括所有这些内容。</p><p id="4b22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">暂时就这样了。编码快乐！</p></div></div>    
</body>
</html>