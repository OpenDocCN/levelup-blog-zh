<html>
<head>
<title>Handling Unix Signals In Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang中处理Unix信号</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handling-unix-signals-in-golang-c8f75ca3da8?source=collection_archive---------6-----------------------#2021-06-29">https://levelup.gitconnected.com/handling-unix-signals-in-golang-c8f75ca3da8?source=collection_archive---------6-----------------------#2021-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c72c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak"> Unix信号</strong>是发送给程序的软件中断，用来指示某个重要事件已经发生。这些事件可能从用户请求到非法内存访问错误不等。有些信号，如中断信号，表明用户要求程序做一些事情，而不是在通常的控制流中。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/46d1a7be1399e6002726dc541c400837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sqx4n3KmLaAnMTJ9-1ydjg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Arif Riyanto 在<a class="ae kv" href="https://unsplash.com/collections/4510513/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a54a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于应用程序中的各种用例来说，处理操作系统信号是很重要的。例如，我们可能希望服务器在收到SIGTERM时正常关闭，或者希望命令行工具在收到SIGINT时停止处理输入。以下是如何在Go with channels中处理信号。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/20ba163d5e118e6c03e738921de65546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*TcBagFadL_Cjk9eFUNdqwQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片:操作系统信号</figcaption></figure><p id="e0ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将介绍如何使用Golang的<code class="fe lt lu lv lw b">os/signal</code>包处理Unix信号。</p><h2 id="7916" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">操作系统/信号包</h2><p id="1461" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">Golang的<code class="fe lt lu lv lw b">os/signal</code>这个包允许你在收到特定类型的UNIX信号时配置Golang程序的行为。大多数基于Linux/Unix的程序在收到终止信号时会很高兴地终止，但是如果你想让你的程序在终止前先拦截信号，执行一些备份，将数据刷新到磁盘等等，那么你应该使用<code class="fe lt lu lv lw b">os/signal</code>包。</p><h2 id="7bea" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">信号类型</h2><p id="65ee" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">我们将集中讨论异步信号。它们不是由程序错误触发的，而是由内核或其他程序发出的。</p><ul class=""><li id="d2aa" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated"><code class="fe lt lu lv lw b">SIGHUP</code>当程序失去控制终端时发出信号</li><li id="85d0" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe lt lu lv lw b">SIGINT</code>当用户在控制终端按下中断字符时，信号发出，默认为<strong class="ky ir"> ^C (Control-C) </strong></li><li id="7ec2" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe lt lu lv lw b">SIGQUIT</code>当用户在控制终端按下退出字符时发出信号，默认为<strong class="ky ir"> ^\(控制反斜杠)</strong></li><li id="32c5" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated"><code class="fe lt lu lv lw b">SIGTERM</code>该信号是用于导致程序终止的通用信号</li></ul><p id="ec91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个简单的Golang示例，演示如何拦截最常见的UNIX kill/terminate信号。</p><p id="6c96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>为了更好的理解，请阅读代码注释。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">代码清单1.1</figcaption></figure><p id="2a8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将上述程序复制到本地机器上运行。我用名称<strong class="ky ir">信号控制器运行我的程序。走吧。下面是我在我的Ubuntu机器上执行这个程序的步骤和我的观察。</strong></p><ul class=""><li id="3b92" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">终端1 — <code class="fe lt lu lv lw b">go build signal-controller.go</code></li><li id="6675" class="mv mw iq ky b kz ne lc nf lf ng lj nh ln ni lr na nb nc nd bi translated">1号航站楼— <code class="fe lt lu lv lw b">./signal-controller</code></li></ul><p id="5b56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的机器上，运行二进制文件的PID是451575。</p><ul class=""><li id="d61e" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">2号航站楼— <code class="fe lt lu lv lw b">kill -SIGINT 451575</code></li></ul><pre class="kg kh ki kj gt nl lw nm nn aw no bi"><span id="f4fb" class="lx ly iq lw b gy np nq l nr ns">Terminal 1 - Output - <strong class="lw ir">"Signal interrupt triggered."</strong></span></pre><ul class=""><li id="2141" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">2号航站楼— <code class="fe lt lu lv lw b">kill -SIGHUP 451575</code></li></ul><pre class="kg kh ki kj gt nl lw nm nn aw no bi"><span id="bc67" class="lx ly iq lw b gy np nq l nr ns">Terminal 1 - Output - <strong class="lw ir">"Signal hang up triggered."</strong></span></pre><ul class=""><li id="f38e" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">2号航站楼— <code class="fe lt lu lv lw b">kill -SIGTERM 451575</code></li></ul><pre class="kg kh ki kj gt nl lw nm nn aw no bi"><span id="f795" class="lx ly iq lw b gy np nq l nr ns">Terminal 1 - Output - <strong class="lw ir">"Signal terminte triggered."</strong></span></pre><ul class=""><li id="b707" class="mv mw iq ky b kz la lc ld lf mx lj my ln mz lr na nb nc nd bi translated">端子2 — <code class="fe lt lu lv lw b">kill -SIGQUIT 451575</code></li></ul><pre class="kg kh ki kj gt nl lw nm nn aw no bi"><span id="e9c9" class="lx ly iq lw b gy np nq l nr ns">Terminal 1 - Output - <strong class="lw ir">"Signal quit triggered."</strong></span></pre><h2 id="87b8" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lj mj mk ml ln mm mn mo mp bi translated">结论</h2><p id="2625" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">使用<code class="fe lt lu lv lw b">os/signal</code>包可以在Golang中轻松处理Unix信号。我们需要使用类型为<code class="fe lt lu lv lw b">os.Signal</code>的通道来读取信号。您可以实现代码来处理程序接收的每种类型的Unix信号。</p><p id="ffbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是现在的全部…快乐学习😃</p></div></div>    
</body>
</html>