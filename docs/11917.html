<html>
<head>
<title>Introduction to Round Robin Scheduling Algorithm (C++ and Java Code)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">循环调度算法介绍(C++和Java代码)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-round-robin-scheduling-algorithm-c-and-java-code-fa1909dd46ab?source=collection_archive---------1-----------------------#2022-04-29">https://levelup.gitconnected.com/introduction-to-round-robin-scheduling-algorithm-c-and-java-code-fa1909dd46ab?source=collection_archive---------1-----------------------#2022-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/880a2a3c4f8604dfb93105280151ff88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gj7DnZJ2ZUGr8Gfhb7E5fg.png"/></div></div></figure><div class=""/><h1 id="c1b5" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是循环调度，它是如何工作的？</h1><p id="840d" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">循环概念是一种向CPU分配任务的方法。在这个算法中，每个个体得到等量的东西，反过来，受这个方法名字的启发。它是最简单、最古老的调度方法，多用于多任务处理。</p><p id="32be" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">循环调度允许每个就绪作业在循环队列中运行一段时间。这种技术还允许流程执行时没有饥饿。</p><p id="cac1" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky jc">本文涵盖了以下主题:</strong></p><ul class=""><li id="767e" class="lz ma jb ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">循环算法简介</li><li id="7d2b" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">循环算法的利弊</li><li id="c58f" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">算法的计算</li><li id="170f" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">Java和C++代码实现</li><li id="45f0" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">结论</li></ul><h1 id="4575" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">循环算法简介</h1><ol class=""><li id="9f85" class="lz ma jb ky b kz la ld le lh mn ll mo lp mp lt mq mf mg mh bi translated">它是一种抢占式算法，这意味着操作系统可以随时从CPU中强制(抢占)一个进程，要么是为了释放CPU用于其他更高优先级的任务，要么是因为时间片已经结束。被抢占/强制的进程被移动到队列的末尾。</li><li id="d3b7" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt mq mf mg mh bi translated">它是为分时系统开发的。</li><li id="33e2" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt mq mf mg mh bi translated">分配给进程的最大时间段称为“量程”。</li><li id="6c00" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt mq mf mg mh bi translated">CPU调度程序一次为就绪队列中的每个任务分配一个时间片。</li><li id="a15f" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt mq mf mg mh bi translated">该算法使用先进先出(FIFO)排队系统。</li><li id="91f6" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt mq mf mg mh bi translated">当前的CPU突发可能会影响分配给CPU的进程:-</li></ol><p id="0f2e" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">a)与时间片相同—该过程将自行释放CPU</p><p id="a615" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">b)小于时间间隔—该过程将自行释放CPU</p><p id="7bb0" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">c)超过时间间隔—现有进程被抢占</p><p id="599b" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">7.应该为必须处理的特定作业设置最小时间片。然而，它可能因操作系统而异。在定义的时间间隔之后，CPU被转移到下一个进程，这被称为时间段/时间片。</p><p id="8bb4" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">8.循环模式是一种时钟驱动的混合模式。</p><p id="5500" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">9.这是一种实时算法，在设定的时间内对事件做出反应。</p><h1 id="7bfd" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">循环算法的利弊</h1><h2 id="2db9" class="mr jz jb bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">优势</h2><ul class=""><li id="db26" class="lz ma jb ky b kz la ld le lh mn ll mo lp mp lt me mf mg mh bi translated">实现起来简单明了。</li><li id="e813" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">每个进程都有平等的运行机会。</li><li id="4920" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">以非优先方式管理所有流程。</li><li id="3d5b" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">不会有饥饿。</li><li id="4102" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">在这种调度中，每个进程都有机会在某个时间段后重新调度。</li><li id="1212" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">每个工作都被赋予相同数量的CPU时间。</li><li id="65be" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">它处理所有进程，不考虑优先级。</li><li id="e702" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">如果知道运行队列中的进程总数，就可以估计出同一进程最坏情况下的响应时间。</li><li id="1c50" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">这种类型的调度与突发时间无关。因此，很容易集成到系统中。</li><li id="f94b" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">就平均响应时间而言，它的性能最好。</li></ul><h2 id="3bf8" class="mr jz jb bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">不足之处</h2><ul class=""><li id="f1f4" class="lz ma jb ky b kz la ld le lh mn ll mo lp mp lt me mf mg mh bi translated">这取决于时间片有多长。</li><li id="a24f" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">如果时间片无限大，和FCFS一样。</li><li id="9e28" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">由于频繁的上下文变化，一点点时间切片就会退化。</li><li id="5515" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">如果用于计划的量程时间较少，甘特图会显得过大。例如，对于大型调度，1 ms是一个很好的起点。)</li><li id="b6ff" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">安排一点量程(时间段)需要很长时间。</li><li id="8adb" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">不能为流程定义优先级。</li><li id="509e" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">循环调度不会给特殊任务更多的优先级。</li><li id="e558" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">有时，找到正确的时间段是一项具有挑战性的任务。</li></ul><h1 id="755e" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">算法的计算</h1><figure class="ne nf ng nh gt is gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/923beb54d4d1a97708e54ce304a94e31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*hthRH1bbEab9YDGhf5slUw.png"/></div></figure><p id="513f" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在您已经熟悉了Round-Round算法，是时候了解它到底是如何工作的了。</p><p id="3029" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们学习一些可能会遇到的术语-</p><ol class=""><li id="f034" class="lz ma jb ky b kz lu ld lv lh mb ll mc lp md lt mq mf mg mh bi translated">完成时间—一个过程完成其执行所需的时间。</li><li id="8563" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt mq mf mg mh bi translated">周转时间—完成和到达之间的时间差称为周转时间。</li></ol><p id="ab95" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">周转时间=完成时间-到达时间</p><p id="f3cf" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">3.等待时间(W.T) —周转时间和突发时间之差。</p><p id="26f0" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">等待时间=周转时间-突发时间</p><p id="8424" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">考虑下面的例子:</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/e233613febd03a871a8f3e116d777913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rcduDg9-Z1q1yy2G"/></div></div></figure><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/999a3b7ba257ae1ab6662a0101b78ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QSngF5rQTA78DXwD"/></div></div></figure><p id="77c7" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在本例中，给出了3个过程及其突发时间。此外，还提到时间片的持续时间为4毫秒，这意味着进程运行的最长时间为4毫秒。因此，对于每个需要超过4毫秒的进程，我们将首先运行它4毫秒，然后再运行4毫秒，以此类推，直到其突发时间结束。</p><p id="afe5" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">上面显示的表格被称为“甘特图”。让我们看看如何制作一个。</p><ul class=""><li id="cd13" class="lz ma jb ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">每个流程的到达时间没有给定，就当是0 ms，所以，完成时间和周转时间是一样的。</li><li id="f141" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">从进程1开始，它的突发时间是24毫秒。但是我们知道，我们最多只能运行进程4毫秒。因此P1进程将运行0到4毫秒</li><li id="c958" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">接下来是P2，它只需要3毫秒。所以P2将运行4到7毫秒。接下来P3将运行7到10毫秒，因为它的突发时间也是3毫秒</li><li id="fb3d" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">现在每道工序都完成了一次。再次从P1开始，运行接下来的4 ms，即从10到14。现在进入下一个过程。</li><li id="b5bf" class="lz ma jb ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">P2和P3的爆发时间已经在第一轮完成。因此，我们将继续运行P1最多4毫秒，直到它的爆发时间达到24毫秒</li></ul><figure class="ne nf ng nh gt is gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/c56a0e2785b4061690e2a5728ed9cbe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/0*5Y5H4jAM2KbcyuAu"/></div></figure><p id="24e9" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，让我们找出每个进程的等待时间。</p><p id="60da" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">P1从0毫秒开始，所以它一开始没有等待。但是它必须等待P2和P3正在运行的时间进程，即从4毫秒到10毫秒，所以它的等待时间= 10–4 = 6毫秒</p><p id="4a99" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">P1跑的时候，P2一开始等了4毫秒。所以它的等待时间= 4 ms。</p><p id="785c" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">P3为P1等待了4毫秒，为P2等待了3毫秒。所以它的等待时间是4+3=7 ms。</p><h1 id="ca6e" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">Java和C++代码实现</h1><h2 id="29b0" class="mr jz jb bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">//C++程序</h2><figure class="ne nf ng nh gt is"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="a976" class="mr jz jb bd ka ms mt dn ke mu mv dp ki lh mw mx km ll my mz kq lp na nb ku nc bi translated">//Java程序</h2><figure class="ne nf ng nh gt is"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6ed2" class="pw-post-body-paragraph kw kx jb ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你可以在<a class="ae nn" href="https://www.interviewbit.com/online-java-compiler/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky jc">采访位</strong> </a>上运行程序</p><h1 id="4914" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="882a" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">循环调度是传统操作系统中最古老、最公平、使用最广泛的调度算法之一。循环调度算法最大的好处是所有的作业都能得到公平的CPU分配，而且它处理所有的进程都没有任何优先级。这种技术需要更多的时间在上下文之间转换。</p></div></div>    
</body>
</html>