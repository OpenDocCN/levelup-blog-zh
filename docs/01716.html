<html>
<head>
<title>RxJS a deep dive with Angular 8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS以8°角深潜</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rxjs-a-deep-dive-with-angular-8-7fe9fd675aaa?source=collection_archive---------1-----------------------#2020-01-24">https://levelup.gitconnected.com/rxjs-a-deep-dive-with-angular-8-7fe9fd675aaa?source=collection_archive---------1-----------------------#2020-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="209e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我和一群开发人员在一个团队中工作。我们正在Angular 8中构建一个门户应用程序。我通常在我的应用程序中看到大量的嵌套代码。如果有多个调用，那么逐个订阅会导致嵌套代码。此外，在许多地方，请求和响应中需要一些数据消息，使用标准的Angular或Typescript方法并不容易。答案是开始用RxJS。我将解释RxJS如何利用我们的角度应用。在这里，我将介绍我们使用RxJS运算符的真实角度项目示例。</p><p id="c841" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">【RxJS是什么，为什么？</p><p id="4d8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">反应式编程最初是由微软工程师Eric Meijer在LINQ从事C#工作时实现的。LINQ在。NET framework为开发人员提供了第一种反应式体验。2012年晚些时候，它被开源，现在被所有大公司使用，包括GitHub、网飞等。</p><p id="d3c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">RxJS实现了TypeScript和JavaScript的反应式扩展。ReactiveX是<strong class="js iu">观察者模式、迭代器模式和函数式编程</strong>的组合。查看reactive.io了解更多详细信息。</p><p id="eee6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面附上图片查看RxJS世界！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7af1d272a447e9677913051ee59ae7d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HeOwc9fteR4oiVheE7qnAg.png"/></div></div></figure><ul class=""><li id="79a9" class="la lb it js b jt ju jx jy kb lc kf ld kj le kn lf lg lh li bi translated"><strong class="js iu">可观察模式:</strong>定义对象间一对多的依赖关系，这样当一个对象改变状态时，它所有的依赖对象都会得到通知并自动更新。在Angular中，有很多场景，我们必须处理事件，事件流。</li><li id="8257" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated"><strong class="js iu">迭代器模式:</strong>提供了一种顺序访问聚合对象元素的方法，而无需暴露其底层表示。</li><li id="efde" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated"><strong class="js iu">函数式编程:</strong>函数式编程是一种编程范式，我们使用纯函数，避免共享状态和可变数据。JavaScript中的Currying是函数式编程的一个很好的例子。</li></ul><div class="lo lp gp gr lq lr"><a href="https://medium.com/@codingindepth/curry-recipe-in-javascript-af236028c8f7" rel="noopener follow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd iu gy z fp lw fr fs lx fu fw is bi translated">JavaScript中的咖喱食谱</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">Curry在javascript中是一个非常重要但又非常混乱的概念。它开启了javascript编程的大门…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">medium.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf ky lr"/></div></div></a></div><p id="3d33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">RxJS是一个基于事件的异步程序，使用可观察序列。观察值可以由一个方法订阅，由一组方法更改，并且可以返回一组异步流，这些流由一组方法进一步更改。</p><p id="ede0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在这里看到“订阅”这个词，等等，看起来你是在说类似承诺的东西？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/c02fbe102487a0e2540dd3c614049520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*odA03SqGBri7oaYh.jpg"/></div></figure><p id="7263" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">可观察与承诺:</strong></p><p id="bc61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般来说，承诺处理失败或成功的单一事件。虽然现在有许多图书馆可以让这个承诺更有力量。</p><p id="6f36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可观察的是一个能处理许多事件的流的集合。可观察的东西比承诺更受欢迎，因为它们可以被中止，如果失败了可以重试，等等！</p><p id="4e6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">示例:</strong></p><p id="e9cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的代码中，我们创建了一个实现HttpClient的服务ObservableDemoService。此服务获取初始页面信息以加载数据。方法getinfo$获取DemoInterface[]的数组流，并在管道中处理错误。在组件构造函数中注入ObservableDemoService的依赖项。同时创建一个错误主题errorMessageSubject来保存或显示视图中的错误。现在使用管道调用ObservableDemoService的getinfo$方法。Pipe采用了许多其他方法。当我们对响应执行一些数据消息传递时，管道非常有用，这里我们初始化数据网格组件。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="811d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们创建promiseinAction，当分别提供true和false时，它返回resolve和reject承诺。我们正在实现ngOnInit方法来调用getPromise(true || false)方法。我们在这里可以清楚地看到我们只有两种反应成功或失败。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="ba78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">好消息！承诺可以转化为可观的东西:</strong></p><p id="c538" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好的一面是承诺可以在需要的时候转化为实际行动！</p><p id="06bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接受可观测量的RxJS算子也可以接受承诺。你只需要把承诺变成可观察的。最好的部分是你不需要改变Angular应用程序中的所有代码！</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="a0a8" class="mo mp it mk b gy mq mr l ms mt">import { from } from 'rxjs';<br/>const observable = from(promise)</span></pre><p id="b4e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运筹学</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="252d" class="mo mp it mk b gy mq mr l ms mt">import { defer, fromEvent, interval } from 'rxjs';<br/>Observable.defer(p =&gt; Promise())</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="6377" class="nb mp it bd nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated"><strong class="ak">可观察与主体</strong></h1><p id="0080" class="pw-post-body-paragraph jq jr it js b jt ny jv jw jx nz jz ka kb oa kd ke kf ob kh ki kj oc kl km kn im bi translated">主体是一种特殊的可观察对象。Observable是RxJS中的基类之一，Subject是它的派生类型之一。主体实现观察者设计模式，该模式需要设置一些值，例如。Subject.next(消息)。Observable总是需要订阅并实现observable模式。可观察性始终是单向的，这意味着它从源流向订户。主体是双向的，信息从来源流向订阅者，反之亦然。</p><p id="558c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">主题类型:</strong></p><ol class=""><li id="29c8" class="la lb it js b jt ju jx jy kb lc kf ld kj le kn od lg lh li bi translated"><strong class="js iu">behavior subject:</strong>behavior subject存储最新的值，并立即将其发送给所有订户。也就是说，我已经创建了一个消息服务，它可以由两个角度分量及其双向分量使用。</li></ol><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="3169" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">组件1:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="72bf" class="mo mp it mk b gy mq mr l ms mt">sendMessage(message: any): void {</span><span id="5d58" class="mo mp it mk b gy oe mr l ms mt">this.messageService.changeMessage(message);</span><span id="ba3f" class="mo mp it mk b gy oe mr l ms mt">}</span></pre><p id="c887" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">组件2:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="a9d6" class="mo mp it mk b gy mq mr l ms mt">let getMessage;</span><span id="f4dd" class="mo mp it mk b gy oe mr l ms mt">this.messageService.currentMessage.subscribe(message =&gt; (getMessage = message));</span></pre><p id="15b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2。replay subject:</strong>replay subject存储<code class="fe of og oh mk b">n</code>个值，并立即将其发送给订阅者。即，在上述数据服务中，如果我们将messageSource更改为ReplaySubject并传递3，那么它将缓存订阅的最后三个值。</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="c5a1" class="mo mp it mk b gy mq mr l ms mt">private messageSource = new ReplaySubject&lt;string&gt;(3);</span></pre><p id="4313" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3。AsyncSubject: </strong> Async subject一直等到完成，然后将最终值发送给订阅者。这里的关键字是最终值。如果我们在下面的示例中添加两个值“Hello 1”和“Hello Again”，那么当我们执行asyncsub.complete()时，将只打印最后一个值。在我们的例子中，最后一个值是最终值。</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="2086" class="mo mp it mk b gy mq mr l ms mt">import { AsyncSubject } from ‘rxjs’;</span><span id="9b34" class="mo mp it mk b gy oe mr l ms mt">const asyncsub = new AsyncSubject();</span><span id="a29b" class="mo mp it mk b gy oe mr l ms mt">asyncsub.subscribe(subs =&gt; console.log(subs));</span><span id="2c4d" class="mo mp it mk b gy oe mr l ms mt">asyncsub.next("Hello 1");</span><span id="1ef5" class="mo mp it mk b gy oe mr l ms mt">asyncsub.next("Hello Again");</span><span id="fcd2" class="mo mp it mk b gy oe mr l ms mt">asyncsub.complete();</span><span id="197f" class="mo mp it mk b gy oe mr l ms mt">//Logged only Hello Again NOT Hello 1</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="eeca" class="nb mp it bd nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated"><strong class="ak">理流威力更大！！</strong></h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/3171924f11303b7f43f5f21bcd8e6566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4SvabBrPCknw-n1b74ZW-Q.jpeg"/></div></div></figure><p id="d1de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">RxJS操作符提供管理流，将流组合成单个流。它还有助于顺序和并行调用API(一组可观察对象)。但主要问题是有这么多运营商。组合运算符总是一个挑战。RxJs在其网站上提供了一组向导来组合这些操作符。如果组合了错误的操作符，将会导致竞态条件。此外，当组件超出范围时，所有的订阅都需要取消订阅，否则将导致内存泄漏。内存泄漏真的非常可怕，尤其是当应用程序在生产环境中运行时。</p><p id="c5e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">将可观测量组合成一个流:</strong></p><ul class=""><li id="38ae" class="la lb it js b jt ju jx jy kb lc kf ld kj le kn lf lg lh li bi translated"><strong class="js iu">合并地图:</strong>为任何给定的源创建新的可观测量。所有先前的流/可观察的保持活动。在返回的可观测量中没有顺序，而且顺序不被保留。mergeMap的最佳用例是将点击事件与API调用结合起来。</li><li id="babf" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated"><strong class="js iu">串联图:</strong>类似于合并图，但是可观测量的顺序保留得很好。保存顺序并发出所有可观察值，同步工作。执行缓慢，因为它同步工作，等待第一个观察完成，然后才开始新的观察流。最好的用例是当你调用一个给你id的API，而这个id被另一个API使用。</li><li id="32c4" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated"><strong class="js iu"> switchMap: </strong>立即创建新的可观测量，并完成旧的可观测量。switchMap的最佳用例是搜索自动完成。每当用户开始键入一个新的关键字进行搜索时，就会创建一个新的可观察对象，并完成旧的可观察对象。使用mergeMap和switchMap检查下面的combineLatest示例。</li><li id="e8a0" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated"><strong class="js iu">平面图:</strong>立即创建可观测量，之前的可观测量保持有效。fatmap是mergemap的别名，mergeMap接受一个可选参数concurrency，该参数定义了可以同时订阅多少个Observables。</li><li id="7a7c" class="la lb it js b jt lj jx lk kb ll kf lm kj ln kn lf lg lh li bi translated"><strong class="js iu">穷举映射:</strong>创建可观察对象，并等待其完成。在等待可观察对象完成时，忽略所有其他可观察对象。最好的用例是使用Angular应用程序中的登录。一旦用户点击登录，然后等待，直到认证完成！exhaustMap与switchMap正好相反。switchMap会立即创建一个新的可观测值，并完成旧的可观测值，但export map会首先完成初始可观测值，并忽略新的可观测值。</li></ul><p id="29e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">将可观测量加入数组:</strong></p><ul class=""><li id="d81a" class="la lb it js b jt ju jx jy kb lc kf ld kj le kn lf lg lh li bi translated"><strong class="js iu"> forkJoin: </strong>调用所有可观察的并行。完成所有调用后，以数组形式返回所有可观察值。最好的用例是当您想要调用不相互依赖的API时。多次上传是我们可以使用forkJoin的场景之一。此外，我们可以根据条件在forkJoin中组合插入和更新API。</li></ul><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="afff" class="mo mp it mk b gy mq mr l ms mt">ngOnInit() {</span><span id="1f5f" class="mo mp it mk b gy oe mr l ms mt">const promiseList = [];</span><span id="f40e" class="mo mp it mk b gy oe mr l ms mt">promiseList.push(this.myService.getData1());</span><span id="e74f" class="mo mp it mk b gy oe mr l ms mt">promiseList.push(this.myService.getData2());</span><span id="fabc" class="mo mp it mk b gy oe mr l ms mt">if (promiseList.length) {</span><span id="59d1" class="mo mp it mk b gy oe mr l ms mt">forkJoin(promiseList).subscribe(resultList=&gt;{</span><span id="716d" class="mo mp it mk b gy oe mr l ms mt">//Initialize component data here<br/>this.dataModel.data1= resultList[0]</span><span id="d777" class="mo mp it mk b gy oe mr l ms mt">})</span><span id="f4cf" class="mo mp it mk b gy oe mr l ms mt">}</span><span id="1cc5" class="mo mp it mk b gy oe mr l ms mt">}</span></pre><ul class=""><li id="0a59" class="la lb it js b jt ju jx jy kb lc kf ld kj le kn lf lg lh li bi translated">组合测试:当所有的可观测值至少触发一次时开始。之后，当任何事件发生变化时，它就会触发。</li></ul><p id="c6c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Angular应用程序中最好的用例是将数据表和下拉事件动作结合起来。下拉列表显示了带有类别和类别id的产品，一旦选中，我们必须根据类别id显示产品详细信息。现在检查下面的代码:</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="4de7" class="mo mp it mk b gy mq mr l ms mt">products$ =combineLatest([this.productService.product$,this.action$])</span><span id="779b" class="mo mp it mk b gy oe mr l ms mt">.pipe(map(([products,category])=&gt;</span><span id="23c0" class="mo mp it mk b gy oe mr l ms mt">products.filter(x=&gt;x.categoryId===category)</span><span id="ad60" class="mo mp it mk b gy oe mr l ms mt">));</span></pre><p id="4dc2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦合并，结合最新的每当用户选择一个产品类别下拉数据表数据自动过滤。不需要在角度分量中写任何事件。这有时被称为反应式开发。</p><p id="27f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以在过滤所选类别时使用mergeMap。如果用户再次点击下拉菜单，而之前的请求没有完成，那么switchMap将取消之前的请求，并启动一个新的Observables。</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="76a1" class="mo mp it mk b gy mq mr l ms mt">selectedCategoryCliks$ = this.selectedCategory$</span><span id="7804" class="mo mp it mk b gy oe mr l ms mt">  .pipe(</span><span id="fcb8" class="mo mp it mk b gy oe mr l ms mt">    filter(selectedCategory =&gt; Boolean(selectedCategory)),</span><span id="8420" class="mo mp it mk b gy oe mr l ms mt">    switchMap(selectedCategory =&gt;</span><span id="02a6" class="mo mp it mk b gy oe mr l ms mt">    from(selectedCategory.Id)</span><span id="249b" class="mo mp it mk b gy oe mr l ms mt">  .pipe(</span><span id="a53e" class="mo mp it mk b gy oe mr l ms mt">    mergeMap(Id =&gt; this.http.get&lt;Interface&gt;(`${environment.getURL}`)),</span><span id="bace" class="mo mp it mk b gy oe mr l ms mt">    toArray(),</span><span id="f775" class="mo mp it mk b gy oe mr l ms mt">    tap(x =&gt; console.log(‘’)</span><span id="c9e2" class="mo mp it mk b gy oe mr l ms mt">  )</span><span id="eb74" class="mo mp it mk b gy oe mr l ms mt"> )</span><span id="8797" class="mo mp it mk b gy oe mr l ms mt">);</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="edb8" class="nb mp it bd nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx bi translated">权力越大，责任越大！内存泄漏是真的！</h1><p id="3c05" class="pw-post-body-paragraph jq jr it js b jt ny jv jw jx nz jz ka kb oa kd ke kf ob kh ki kj oc kl km kn im bi translated">我知道你已经听过这个阶段了。但是在RxJS的世界里，总是取消订阅公开的观察和主题是非常重要的。在Angular中，实现ngOnDestroy和unsubscribe。</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="aca3" class="mo mp it mk b gy mq mr l ms mt">ngOnDestroy(): void {</span><span id="7795" class="mo mp it mk b gy oe mr l ms mt">  this.subject.unsubscribe();</span><span id="75e4" class="mo mp it mk b gy oe mr l ms mt">}</span></pre><p id="8294" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，很多时候很难记住退订的拆机方法。</p><p id="6da8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果订阅是自动退订而不是手动退订呢？</p><p id="0c7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们使用异步管道，在Angular这样的框架中是可能的。一旦组件超出范围，异步管道会自动取消订阅打开的观察对象和主题。现在，我们已经在上面的例子中创建了products$来保存来自获取服务的产品列表。使用product$ | async pipe，我们可以显示产品详细信息。下面是视图代码片段。</p><pre class="kp kq kr ks gt mj mk ml mm aw mn bi"><span id="7078" class="mo mp it mk b gy mq mr l ms mt">&lt;ng-container *ngIf=”products$ | async as productList”&gt;</span><span id="9bab" class="mo mp it mk b gy oe mr l ms mt">  &lt;tr *ngFor=”let prod of productList; let i = index” class=”tr-clickable” (click)=”clickonRow(prod)”&gt;</span><span id="f6ca" class="mo mp it mk b gy oe mr l ms mt">    &lt;td *ngIf=”prod.Name”&gt;&lt;span style=”display: none;”&gt;{{ prod.Name }}&lt;/span&gt;</span><span id="789b" class="mo mp it mk b gy oe mr l ms mt">   &lt;/td&gt;</span><span id="ab38" class="mo mp it mk b gy oe mr l ms mt">  &lt;/tr&gt;</span><span id="e22d" class="mo mp it mk b gy oe mr l ms mt">&lt;/ng-container&gt;</span></pre><p id="58f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">结论:</strong> RxJS提供了更方便的代码，一旦你在你的Angular应用中启动它。这看起来很难理解，但慢慢地，随着时间的推移，你会觉得非常容易和方便。在大多数地方复制粘贴类似的代码是非常容易的。此外，可读性随着时间的推移增加流形。在初始阶段，它看起来像是正在进行的代码块，但是慢慢地你会发现写反应式编程比基于方法的编程更容易。因此，现在就开始在您的角度应用中使用RxJs吧。</p></div></div>    
</body>
</html>