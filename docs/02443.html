<html>
<head>
<title>Centralised logging with Loggly and Bunyan</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Loggly和Bunyan的集中测井</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/centralised-logging-with-loggly-and-bunyan-63c24f4d5617?source=collection_archive---------7-----------------------#2020-03-13">https://levelup.gitconnected.com/centralised-logging-with-loggly-and-bunyan-63c24f4d5617?source=collection_archive---------7-----------------------#2020-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a7e342bb673f28936bbeb28900d62e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r91FG9Xno0CXonJu"/></div></div></figure><p id="808e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你是否曾经在没有任何有意义的日志记录的情况下尝试调试软件？如果没有，请认为你是幸运的，并心存感激！日志实现起来相对简单，并且提供了对生产中代码内部发生的事情的大量洞察——当然假设它被正确实现。</p><p id="69ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文假设您对TypeScript有基本的了解，并且能够阅读和理解一些代码片段。</p><p id="b28f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看如何将一个专用的日志库引入我们的代码库，并将日志集中在Loggly上。本文将使用TypeScript来演示与Loggly的集成。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="bd30" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">班扬入门</h1><p id="3d21" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">Bunyan是一个很棒的日志库，实现起来非常简单。我们还将使用bunyan-loggly作为我们的客户来与loggly集成。让我们安装我们的依赖项并开始行动吧！</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="7533" class="mp le iq ml b gy mq mr l ms mt">$ npm i bunyan bunyan-loggly<br/>$ npm i -D @types/bunyan</span></pre><p id="ac75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经安装了日志库及其适当的类型定义，我们就可以开始记录代码了。</p><p id="21ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该从创建一个<code class="fe mu mv mw ml b">LoggerFactory</code>类开始。原因很简单，我们可以用特定的配置定义一个记录器，然后我们可以调用一个函数来返回一个子记录器。子记录器将从应用程序级记录器派生出来，继承已经定义的配置，并被恰当地命名！这也将在以后变得更加重要。</p><p id="01a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看这是如何实现的，好吗？</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">实现bunyan的LoggerFactory示例</figcaption></figure><p id="9e15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的要点中，我们可以看到，在构造函数中，我们正在初始化我们的第一个记录器。这个日志记录器不会用于日志记录，但将用于生成我们的子日志记录器，这同样会继承父日志记录器的配置。</p><p id="67ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很好，但是我们现在如何在现有的代码库中实现这个工厂方法呢？</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">通过依赖注入实现LoggerFactory的示例类</figcaption></figure><p id="5c48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面我们可以看到如何利用伐木工厂。我们可以将它依赖注入到我们的一个类中，并在构造函数中检索一个新的记录器命名实例。在我们的<code class="fe mu mv mw ml b">bar()</code>函数中，我们可以看到一些普通的日志记录函数，<code class="fe mu mv mw ml b">info</code>，<code class="fe mu mv mw ml b">debug</code>，<code class="fe mu mv mw ml b">warn</code>和<code class="fe mu mv mw ml b">error</code>，它们可以用来记录数据和消息。正如所料，这些函数返回一个<code class="fe mu mv mw ml b">void</code>数据类型。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/754a533e4451f554871d22a72fe214e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6uOIeXNL389-zN1R"/></div></div></figure><h1 id="5893" class="ld le iq bd lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw ni ly lz ma bi translated">听说过集中伐木吗？</h1><p id="c664" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">对于那些可能没有意识到的人来说，集中日志正是这样做的…集中你的日志。它会将我们所有的日志发送到一个专门处理日志数据的单一系统。它还提供了一个易于使用的界面来查看这些日志！</p><p id="0842" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，我们将实现一个Loggly集成，因为谢天谢地，它是免费使用的！</p><p id="be8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们如何着手做这件事呢？嗯，我们首先需要在Loggly上创建一个帐户。<a class="ae nj" href="https://www.loggly.com/signup/" rel="noopener ugc nofollow" target="_blank">你可以在这里报名</a>。这是免费的，根本不需要信用卡。快乐的日子！</p><p id="2fcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了一个帐户，我们想创建一个“客户令牌”,这样我们就可以将我们的日志发送到Loggly。导航至“源设置”→“客户令牌”并创建一个新令牌，该令牌将用于我们的集成。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="22cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们开始将我们的Loggly集成添加到我们现有的<code class="fe mu mv mw ml b">LoggerFactory</code>类中。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">我们的LoggerFactory与集中日志记录的Loggly集成示例</figcaption></figure><p id="e6eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的要点中，我们可以看到，我们真正改变的只是用我们新生成的“客户令牌”和子域作为配置实例化了bunyan-loggly库的一个新实例。就这么简单。</p><p id="2698" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在这一切都完成了，当我们旋转应用程序并调用上面定义的<code class="fe mu mv mw ml b">bar()</code>函数时，我们的日志将被发送到Loggly。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/3e4d13f6e8fd8883a44747d80c2db975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRwvQ4TDS5rqh-QsfvZQCQ.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">我们的日志在Loggly中的样子</figcaption></figure><h1 id="729d" class="ld le iq bd lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw ni ly lz ma bi translated">把我们的日志联系起来怎么样？</h1><p id="7a2f" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">让我们假设一下，我们的应用程序可以处理许多请求，我们可能希望通过系统跟踪一个特定的请求，我们该如何做呢？<em class="nl">输入相关ID</em></p><p id="12cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们快速地看一下如何将一个关联ID添加到我们的日志中，这样我们就可以在Loggly中看到一个完整的请求，从传入的请求到传出的响应。</p><p id="9afa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要构建一个decorator类，它能够在每个日志被发送到Loggly之前，将相关ID添加到我们的日志对象中。如果你不熟悉装饰设计模式，你可以在本文的底部找到更多！</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">一个装饰类的例子，它将把相关ID添加到给定的流中</figcaption></figure><p id="283c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们可以看到我们正在接收一个“WritableStream”对象和一个函数，该函数可用于从某个全局上下文中检索我们的相关ID。这很好，因为我们可以决定每个流如何获取ID。</p><p id="4ef7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们解析流对象，添加我们的相关ID，并在写入流之前解析它。我们的日志现在应该包括我们从注入函数中检索到的任何ID。相当直接的东西！</p><p id="8661" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看如何在我们的<code class="fe mu mv mw ml b">LoggerFactory.ts</code>中实现它。</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">我们的LoggerFactory示例，在bunyan-loggly实例周围有一个流装饰器，用于附加我们的相关ID</figcaption></figure><p id="14a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们非常简单地将实例化的Bunyan-logly实例转换为“WritableStream ”,并将其提供给我们的装饰器类。然后我们可以直接把它作为一条小溪还给班扬，然后砰！我们现在有了Loggly中的相关ID！</p><h1 id="2c9b" class="ld le iq bd lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw ni ly lz ma bi translated">集中记录的好处是什么？</h1><p id="bba4" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">让我们考虑一下这个问题。首先，我们可以让员工在无法访问生产环境的情况下为客户提供支持。挺有用的。</p><p id="d2b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们有多台服务器运行并相互集成，我们可以将所有的日志发送到一个中央系统。这使我们能够在整个生态系统中端到端地查看请求。(关联ID在这里非常有用)</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/9283d59eac493acb66d4d8da2da2a39c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n3PaYVK2N4LeJkGf"/></div></div></figure><h1 id="d9ab" class="ld le iq bd lf lg ne li lj lk nf lm ln lo ng lq lr ls nh lu lv lw ni ly lz ma bi translated">还有别的吗？</h1><p id="6b13" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">这里有一些链接可以帮助你在未来的项目中更好更有效地记录日志！</p><ul class=""><li id="acae" class="nn no iq ka b kb kc kf kg kj np kn nq kr nr kv ns nt nu nv bi translated"><a class="ae nj" href="https://www.npmjs.com/package/bunyan-loggly" rel="noopener ugc nofollow" target="_blank">班扬-logly</a></li><li id="91e6" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nj" href="https://www.npmjs.com/package/bunyan" rel="noopener ugc nofollow" target="_blank">班扬</a></li><li id="46dd" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nj" href="https://www.loggly.com/" rel="noopener ugc nofollow" target="_blank">logly</a></li><li id="57ef" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nj" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html" rel="noopener ugc nofollow" target="_blank">打字稿3.8 </a></li><li id="5a69" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nj" href="https://www.tutorialspoint.com/design_pattern/decorator_pattern.htm" rel="noopener ugc nofollow" target="_blank">装饰设计模式</a></li><li id="6108" class="nn no iq ka b kb nw kf nx kj ny kn nz kr oa kv ns nt nu nv bi translated"><a class="ae nj" href="https://www.tutorialspoint.com/design_pattern/factory_pattern.htm" rel="noopener ugc nofollow" target="_blank">工厂设计模式</a></li></ul></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="7e79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢你阅读这篇文章，我希望你学到了一些新的东西。如果你有任何意见，请随意写在下面的评论区！</p><p id="364f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你喜欢就鼓掌，如果你有兴趣看更多，就跟随！</p><p id="bdfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再见了。</p></div></div>    
</body>
</html>