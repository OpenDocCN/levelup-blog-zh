<html>
<head>
<title>Creating a SpaceX Crew Dragon simulator autopilot in Clojure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Clojure中创建SpaceX Crew Dragon模拟器自动驾驶仪</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-spacex-crew-dragon-simulator-autopilot-in-clojure-1ac095d9209b?source=collection_archive---------1-----------------------#2020-05-20">https://levelup.gitconnected.com/creating-a-spacex-crew-dragon-simulator-autopilot-in-clojure-1ac095d9209b?source=collection_archive---------1-----------------------#2020-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7fb7e171325b237427e8b3998d3d40a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71EgDpxJ5YfH_KVujPtX_Q.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">美国宇航局太空探索技术公司宇航员龙</figcaption></figure><p id="f834" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了准备5月下旬SpaceX载人龙的首次载人任务<a class="ae la" href="https://en.wikipedia.org/wiki/Crew_Dragon_Demo-2" rel="noopener ugc nofollow" target="_blank"> Demo-2 </a>，SpaceX发布了一个非常酷的小<a class="ae la" href="https://iss-sim.spacex.com/" rel="noopener ugc nofollow" target="_blank"> WebGL对接模拟器</a>，以龙飞船为特色。在成功完成几次对接后，我意识到这是编写对接自动驾驶仪的绝佳机会！一个人如何处理这样的问题？</p><p id="2707" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">轨道航天器与你所认为的普通交通工具有点不同，比如汽车或飞机。在太空中，你有全部6个<strong class="ke ir">自由度</strong>，这意味着你可以上下、左右、顺时针-逆时针滚动等。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/5626368b4d45fa9b9cde1b67a9fc15d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*nmiT7Xz2r0Pjem3npFC2nA.png"/></div></figure><p id="6c11" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">那太好了，但是我们实际上如何对接呢？</p><p id="fb2b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在模拟器中，成功对接意味着:</p><ul class=""><li id="9d88" class="lg lh iq ke b kf kg kj kk kn li kr lj kv lk kz ll lm ln lo bi translated">我们与国际空间站的对接端口完全对齐</li><li id="df22" class="lg lh iq ke b kf lp kj lq kn lr kr ls kv lt kz ll lm ln lo bi translated">我们的最终<strong class="ke ir">接近率</strong>低于某个值</li><li id="be3d" class="lg lh iq ke b kf lp kj lq kn lr kr ls kv lt kz ll lm ln lo bi translated">我们不想让我们价值数百万美元的宇宙飞船撞上沿途的任何东西</li></ul><p id="0df4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你把它分解，问题只是简单地包括调整龙应该如何(与国际空间站对接端口对齐)，并慢慢地把它飞到它应该在的地方(在对接端口)。</p><p id="bd38" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于语言，我使用的是运行在JVM上的类似Lisp的函数式编程语言。它是高度可扩展的，简单的，有很多库和强大的并发抽象，我们以后绝对需要。</p><p id="81b7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">第一步显然是弄清楚如何<strong class="ke ir">控制</strong>模拟器。如今，驱动浏览器的最佳方式是使用<a class="ae la" href="https://www.w3.org/TR/webdriver/" rel="noopener ugc nofollow" target="_blank"> WebDriver </a>，以及一些API或客户端库来发送命令。在我们这边，我们所要做的就是在代码中创建一个控制接口。在整个项目中，我使用了<a class="ae la" href="https://github.com/igrishaev/etaoin" rel="noopener ugc nofollow" target="_blank"> Etaoin </a>，这是WebDriver协议的一个完美的纯Clojure实现。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/e95fd684d8d15dba62fccd50649191fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x7wql1rTMxuxq9cswYcSHw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">SpaceX ISS模拟器GUI发布</figcaption></figure><p id="42a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虽然模拟器有可点击的屏幕控件，但它也有<strong class="ke ir">键绑定</strong>，我们可以利用:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="8208" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，如果没有<strong class="ke ir">遥测</strong>的话，自动化飞船是没有希望的。简而言之，我们必须知道<strong class="ke ir">我们在看哪里</strong>和<strong class="ke ir">如何</strong>，我们应该看哪里，以及我们在太空中的位置。幸运的是，SpaceX的优秀工程师为HUD中的信息制作了易于定位的元素，我们的<strong class="ke ir">司机</strong>将从中获取信息。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lx"><img src="../Images/af5e585ea7710539c21e872836717241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nulLQM7Ps3OuUpXy8rI5aA.png"/></div></div></figure><p id="b77e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在编写了一堆定位器和解析器之后，我们有了一个从HUD获取所有需要的数据的好方法:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="d4e6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在这里存在第一个问题:当我们移动航天器时，HUD一直在更新信息，因此我们需要不断获取新的遥测数据，并使其可用于所有未来的控制系统，而不是用一些循环阻塞<strong class="ke ir">主线程</strong>。这就是Clojure的并发性真正闪光的地方，因为我们可以简单地创建一个递归的<code class="fe ly lz ma mb b">poll</code>函数，并使用一个<code class="fe ly lz ma mb b">future</code>将它放在一个单独的线程中，并将主线程向前移动。</p><p id="e02a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还需要以某种方式将遥测数据保存在某个<code class="fe ly lz ma mb b">state</code>中，这也是线程安全的。幸运的是，<code class="fe ly lz ma mb b">atoms</code>来帮忙了，我们可以用<code class="fe ly lz ma mb b">swap!</code>简单地用新数据更新遥测数据:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3378" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可能已经注意到我们也在用船的<code class="fe ly lz ma mb b">x, y and z</code>坐标做一些计算。不幸的是，平视显示器没有给出我们的<strong class="ke ir">速度矢量分量</strong>，所以我们必须通过使用距离/时差来自己计算。</p><p id="d1f9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一步是为每个<strong class="ke ir">旋转</strong>控制轴——滚动、俯仰和偏航——编写校准函数。归结起来就是这个简单的逻辑:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3326" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，这里我们有下一个问题:对准需要一直保持，并且对于每个轴<strong class="ke ir">同时</strong>。这意味着，如果我们尝试按顺序执行此操作<strong class="ke ir">，我们将会遇到<strong class="ke ir">锁定问题</strong>:滚动校准功能可能会阻止偏航校准并阻止其旋转等。</strong></p><p id="b2e9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是<code class="fe ly lz ma mb b">future</code>再次出手相救的地方！</p><pre class="lc ld le lf gt mc mb md me aw mf bi"><span id="e396" class="mg mh iq mb b gy mi mj l mk ml"><em class="mm">;; concurrent futures for each control axis<br/></em>(<em class="mm">println </em>"Rotation alignment enabled")<br/>(<em class="mm">future </em>(<em class="mm">dragon/align-roll-rot </em>chr))<br/>(<em class="mm">future </em>(<em class="mm">dragon/align-pitch-rot </em>chr))<br/>(<em class="mm">future </em>(<em class="mm">dragon/align-yaw-rot </em>chr))</span></pre><p id="434b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">既然已经解决了旋转问题，下一步就是为这个方法编写逻辑。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/109f226eb2b40865db9c71bb85ca6a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*b-4aV2Mc9qKy89mkBPqSrg.png"/></div></figure><p id="0be3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们需要在<code class="fe ly lz ma mb b">z</code>和<code class="fe ly lz ma mb b">y</code>轴上对齐，并在<code class="fe ly lz ma mb b">x</code>轴上稳步移动。我们已经编写了速度分量计算，所以我们所要做的就是在需要的时候解引用我们的<code class="fe ly lz ma mb b">telem</code>遥测原子。</p><p id="afec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">棘手的部分是在这个阶段为RCS点火编写所有正确的逻辑——开始总是朝一个方向推得太多，它会变成不可控制的摇摆运动，燃烧大量燃料！我想出了实现“死区”的方法——当我们基本上接近现场时，我们不会以错误的方式或过多地启动推进器。我们再次使用<code class="fe ly lz ma mb b">future</code> s进行平移对齐。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="7901" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将所有东西绑在一起，这大致就是我们的线程的样子，以及我们的控制功能如何使用遥测技术:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/0769c6500eab33ee3ff5dda3ef3a8aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i69GH3iC6PfS-0kQAIobUw.png"/></div></div></figure><p id="1747" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">总之，宇宙飞船很难，SpaceX和NASA的人显然比我更清楚他们在做什么。然而，这是一个有趣的练习，思考这些自动对接系统在现实生活中是如何工作的，以及展示<strong class="ke ir">函数式编程</strong>和并发性真正闪耀的地方。</p><p id="6da8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">可以去看看Github里的代码:<a class="ae la" href="https://github.com/DaniruKun/spacex-iss-docking-sim-autopilot" rel="noopener ugc nofollow" target="_blank">https://Github . com/DaniruKun/spacex-ISS-docking-sim-auto pilot</a></p><p id="4593" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">展示自动驾驶仪的小演示视频:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mp lw l"/></div></figure></div></div>    
</body>
</html>