<html>
<head>
<title>Go, Lambda and the API Gateway — the OpenAPI v3.0 story</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go、Lambda和API网关OpenAPI v3.0的故事</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-lambda-and-the-api-gateway-the-openapi-v3-0-story-a8afe5f841df?source=collection_archive---------7-----------------------#2021-01-29">https://levelup.gitconnected.com/go-lambda-and-the-api-gateway-the-openapi-v3-0-story-a8afe5f841df?source=collection_archive---------7-----------------------#2021-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/588c04bf2b54f1d2888b1007542b8089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mnSLvuSJqI8KTGnW"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@cazat69?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维克托·卢</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b2b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae kc" href="https://medium.com/me/stats/post/b9c0b8c5712b" rel="noopener">之前的一篇文章</a>中，我描述了广泛使用的<a class="ae kc" href="https://github.com/go-swagger/go-swagger" rel="noopener ugc nofollow" target="_blank"> go-swagger </a>模块如何在Lambda/API网关环境中使用。go-swagger对此解决方案的一个限制是，它只支持<a class="ae kc" href="https://swagger.io/specification/v2/" rel="noopener ugc nofollow" target="_blank">Swagger/open API v 2.0</a>(open API规范2—OAS 2)；随着<a class="ae kc" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI v3.0 </a> (OpenAPI规范3 — OAS3)支持变得越来越重要，探索如何实现OAS3解决方案变得很有意思。一个具体的驱动因素是<a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html" rel="noopener ugc nofollow" target="_blank"> AWS API网关HTTP API </a>仅<a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-open-api.html" rel="noopener ugc nofollow" target="_blank">支持OAS 3</a>；不支持OAS2。</p><p id="dbca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，这篇文章考虑了以下几点:</p><ul class=""><li id="fb27" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">如何使用Go实现OAS3 API</li><li id="ae2e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">如何使用HTTP API将其部署到AWS</li></ul><p id="89bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">示例代码在<a class="ae kc" href="https://github.com/seanrmurphy/lambda-openapi3-test" rel="noopener ugc nofollow" target="_blank">本github报告</a>中提供。</p><p id="924f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Go支持OAS3 </strong></p><p id="d2d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Go生态系统包含许多为OAS3提供支持的项目。kin-openapi 项目提供了解析OAS3规范时可以使用的基本原语——因此，它是一个强大的工具箱，可以在其上开发其他OAS3解决方案。我选择了<a class="ae kc" href="https://github.com/deepmap/oapi-codegen" rel="noopener ugc nofollow" target="_blank"> oapi-codegen </a>项目，因为它支持基于OAS3规范生成OAS3兼容的后端。</p><p id="b242" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">oapi-codegen是一个相对较新的项目——它比go-swagger更轻量级，并且不为OAS3规范中定义的每个端点的有效返回代码生成特定的数据类型；焦点似乎更多地放在让某些东西工作上，即使没有提供所有的功能，并在必要时对其进行迭代。</p><p id="128f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">oapi-codegen在用法上也有很大的不同；与go-swagger不同，它不考虑生成的代码应该如何组织，只是将输出发送到stdout然后，开发人员必须选择它应该放在哪里。像go-swagger一样，它支持生成不同的输出——例如客户端、服务器存根和类型——尽管oapi-codegen与<code class="fe lp lq lr ls b">go generate</code>工作流集成得更好，并且支持配置文件的定义，这些文件指定了生成的代码应该放在哪里。</p><p id="7e96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与go-swagger不同，oapi-codegen的请求验证没有那么全面；当前版本不支持POST主体内容的验证——它当然会执行数据的去marshalling，从eg提供的JSON转换为Go <code class="fe lp lq lr ls b">struct</code>,但是如果输入数据中缺少一些字段，框架不会自动生成错误响应。(在<a class="ae kc" href="https://github.com/deepmap/oapi-codegen/pull/245" rel="noopener ugc nofollow" target="_blank">这个PR </a>中已经有关于这个问题的工作，可能很快会合并)。</p><p id="589b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">oapi-codegen支持与不同的、更现代的Go HTTP服务器集成；<a class="ae kc" href="https://github.com/labstack/echo" rel="noopener ugc nofollow" target="_blank">呼应</a>和<a class="ae kc" href="https://github.com/go-chi/chi" rel="noopener ugc nofollow" target="_blank">驰</a>，具体来说。</p><p id="71c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">在本地实施OAS 3 API</strong></p><p id="e5df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下文中，我们将考虑一个简单的OAS3文件，它只在<code class="fe lp lq lr ls b">/</code>上提供一个端点，并定义了一个模式。</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="040e" class="mb mc iq ls b gy md me l mf mg">openapi: 3.0.1<br/>paths:<br/>  /:<br/>    get:<br/>      operationId: getApiIdentifier<br/>      produces:<br/>      - application/json<br/>      responses:<br/>        '200':<br/>          schema:<br/>            $ref: '#/components/schemas/SimpleMessageResponse'</span><span id="1f25" class="mb mc iq ls b gy mh me l mf mg">components:<br/>  schemas:<br/>    SimpleMessageResponse:<br/>      required:<br/>      - message<br/>      properties:<br/>        message:<br/>          type: string</span></pre><p id="3205" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用oapi-codegen，会生成以下代码，</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="a337" class="mb mc iq ls b gy md me l mf mg">// auto-generated code</span><span id="fa7c" class="mb mc iq ls b gy mh me l mf mg">// SimpleMessageResponse defines model for SimpleMessageResponse.<br/>type SimpleMessageResponse struct {<br/>  Message string `json:"message"`<br/>}</span><span id="2230" class="mb mc iq ls b gy mh me l mf mg">type ServerInterface interface {<br/>  // API Identifier endpoint<br/>  // (GET /)<br/>  GetApiIdentifier(ctx echo.Context) error<br/>}</span></pre><p id="1dc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面自动生成的代码中，模型<code class="fe lp lq lr ls b">SimpleMessageResponse</code>是从OAS3文件中定义的模型生成的；<code class="fe lp lq lr ls b">ServerInterface</code>由OAS3文件中定义的路径生成——通过OAS3文件中定义的<code class="fe lp lq lr ls b">operationId </code>将<code class="fe lp lq lr ls b">/</code>路径映射到被调用的<code class="fe lp lq lr ls b">GetApiIdentifier</code>函数。</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="317b" class="mb mc iq ls b gy md me l mf mg">// code to provide API implementation</span><span id="c2db" class="mb mc iq ls b gy mh me l mf mg">type Api struct {<br/>}</span><span id="a541" class="mb mc iq ls b gy mh me l mf mg">func NewApi() *Api {<br/>  return &amp;Api{}<br/>}</span><span id="a30e" class="mb mc iq ls b gy mh me l mf mg">func (*Api) GetApiIdentifier(ctx echo.Context) error {<br/>  str := "oapi-codegen Lambda integration API (OpenAPI v3 version) - version 1.0"</span><span id="492e" class="mb mc iq ls b gy mh me l mf mg">  r := SimpleMessageResponse{<br/>    Message: str,<br/>  }</span><span id="4c61" class="mb mc iq ls b gy mh me l mf mg">  return ctx.JSON(http.StatusOK, r)<br/>}</span></pre><p id="4d65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本的oapi-codegen方法是，开发人员必须创建一个<code class="fe lp lq lr ls b">struct </code>，它提供自动生成的<code class="fe lp lq lr ls b">interface</code>的实现。在上面的例子中，<code class="fe lp lq lr ls b">Api</code>结构提供了这一点，而<code class="fe lp lq lr ls b">GetApiIndentifier</code>只是返回一个带有JSON编码消息的HTTP OK。</p><p id="621d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如下所示的<code class="fe lp lq lr ls b">main()</code>函数可用于实例化API注意对<code class="fe lp lq lr ls b">RegisterHandlers()</code>的调用将<code class="fe lp lq lr ls b">Api </code>结构中定义的函数链接到路由器中定义的相关路径。</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="c594" class="mb mc iq ls b gy md me l mf mg">func main() {<br/>  a := api.NewApi()</span><span id="2584" class="mb mc iq ls b gy mh me l mf mg">  e = echo.New()<br/>  api.RegisterHandlers(e, a)</span><span id="c493" class="mb mc iq ls b gy mh me l mf mg">  e.Logger.Fatal(e.Start(fmt.Sprintf("0.0.0.0:%d", 8080)))<br/>}</span></pre><p id="277f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些部分可以放在一起实现一个简单的OAS3兼容API。</p><p id="9459" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请参见<a class="ae kc" href="https://github.com/seanrmurphy/lambda-openapi3-test" rel="noopener ugc nofollow" target="_blank">示例报告</a>中稍微复杂一点的示例。</p><p id="9325" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">使用HTTP API将API部署到AWS</strong></p><p id="72a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要将API作为Lambda函数部署到AWS，必须修改代码库，以便它可以使用一个事件——触发Lambda函数的事件——并将其转换为HTTP请求，然后传递给API逻辑。OAS2的实施也是如此；AWS 提供的<a class="ae kc" href="https://github.com/awslabs/aws-lambda-go-api-proxy" rel="noopener ugc nofollow" target="_blank"> Go API代理模块可以用来做这个绑定。</a></p><p id="dbf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个在这个特定案例中出现但在OAS2工作中没有出现的问题涉及到在使用<a class="ae kc" href="https://swagger.io/docs/specification/describing-parameters/" rel="noopener ugc nofollow" target="_blank">路径参数</a>的情况下从事件到HTTP请求的映射。更具体地说，在转换之后，HTTP请求包含一个<code class="fe lp lq lr ls b">Path</code>和一个<code class="fe lp lq lr ls b">Resource</code>；<code class="fe lp lq lr ls b">Path</code>包含完整的路径名，包括API网关中定义的阶段名，<code class="fe lp lq lr ls b">Resource</code>包含端点名，包括参数名而不是参数值(例如<code class="fe lp lq lr ls b">/endpoint/{param-name}</code>而不是<code class="fe lp lq lr ls b">/endpoint/1234</code>，其中1234是参数值)。这两者都不是API所期望的；因此，需要一些小的字符串操作来合并<code class="fe lp lq lr ls b">Path</code>和<code class="fe lp lq lr ls b">Resource</code>以获得API期望的端点形式。</p><p id="f97b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦构建了可执行文件，就可以将它部署到AWS。和以前一样，我们使用<a class="ae kc" href="https://aws.amazon.com/serverless/sam/" rel="noopener ugc nofollow" target="_blank"> SAM </a>进行部署，但是当然也可以使用<a class="ae kc" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"> CloudFormation </a>。</p><p id="5e3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要对之前的案例进行一些小的修改:</p><ul class=""><li id="50e1" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">API类型必须从<code class="fe lp lq lr ls b"><a class="ae kc" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-resource-api.html" rel="noopener ugc nofollow" target="_blank">AWS::Serverless::Api</a></code>更改为<code class="fe lp lq lr ls b"><a class="ae kc" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-resource-httpapi.html" rel="noopener ugc nofollow" target="_blank">AWS::Serverless::HttpApi</a></code>，类似地，链接到Lambda函数的事件必须从<code class="fe lp lq lr ls b"><a class="ae kc" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-function-api.html" rel="noopener ugc nofollow" target="_blank">Api</a></code>事件更改为<code class="fe lp lq lr ls b"><a class="ae kc" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-function-httpapi.html" rel="noopener ugc nofollow" target="_blank">HttpApi</a></code>事件</li><li id="f878" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">OAS3 API规范也必须稍加修改——与REST API变体的一个具体区别是,<a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions-integration.html" rel="noopener ugc nofollow" target="_blank"> HTTP API要求需要定义一个</a><code class="fe lp lq lr ls b"><a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions-integration.html" rel="noopener ugc nofollow" target="_blank">payloadFormatVersion</a></code><a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions-integration.html" rel="noopener ugc nofollow" target="_blank"/>,而这在REST API变体中是不必要的</li></ul><p id="e823" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这些适度的修改，使用HTTP API设计、实现和部署OAS3兼容的API到AWS成为可能。</p><p id="7b6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想亲自尝试一下，请查看github repo 。</p></div></div>    
</body>
</html>