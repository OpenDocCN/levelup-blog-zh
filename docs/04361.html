<html>
<head>
<title>Handling SocketIO rooms with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React吊钩处理插座室</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handling-socketio-rooms-with-react-hooks-4723dd44692e?source=collection_archive---------2-----------------------#2020-06-23">https://levelup.gitconnected.com/handling-socketio-rooms-with-react-hooks-4723dd44692e?source=collection_archive---------2-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6bd3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">使用效果挂钩处理SocketIO交互</strong></h2></div><p id="88e4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文假设您了解React挂钩和套接字的基础知识。IO并跟进这些文章，以熟悉这些主题:</p><div class="le lf gp gr lg lh"><a href="https://medium.com/@chathuranga94/introduction-to-socket-io-600025322cd2" rel="noopener follow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">套接字介绍。超正析象管(Image Orthicon)</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">实时|双向|客户端-服务器| HTML5</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">medium.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv lw lh"/></div></div></a></div><div class="le lf gp gr lg lh"><a href="https://medium.com/@chathuranga94/introduction-to-react-hooks-4694fe2d0fc0" rel="noopener follow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">React挂钩简介</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">赋予功能组件超能力</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">medium.com</p></div></div><div class="lq l"><div class="lx l ls lt lu lq lv lw lh"/></div></div></a></div></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/f8496f90ddd33d160e91cbfd47eeff4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*-IP3p4RH7XIvyTHBfXBhoA.png"/></div></figure><p id="76ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这构建了一个演示聊天应用程序，涉及使用React钩子集成的socket.io房间。客户端可以在聊天室之间连接和切换，其中的更新将由socket.io事件复制。根据所选择的房间，它将向使用该房间的socket客户端广播聊天消息。</p><p id="ef8c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(一旦运行，我们可以旋转多个浏览器标签，并查看聊天消息是否通过套接字更新。)</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="c8b1" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用Nodejs设置SocketIO服务器</h1><p id="8b47" class="pw-post-body-paragraph ki kj it kk b kl ne ju kn ko nf jx kq kr ng kt ku kv nh kx ky kz ni lb lc ld im bi translated">让我们用简单的socket.io设置创建一个节点服务器</p><pre class="mg mh mi mj gt nj nk nl nm aw nn bi"><span id="abc0" class="no mn it nk b gy np nq l nr ns">var http = require('http').createServer().listen(3000);<br/>var io = require('socket.io').listen(http);</span><span id="9c66" class="no mn it nk b gy nt nq l nr ns"><strong class="nk iu">io.on('connection'</strong>, (socket) =&gt; {<br/>   console.log(`Connected: ${socket.id}`);</span><span id="6a2b" class="no mn it nk b gy nt nq l nr ns">   <strong class="nk iu">socket.on('disconnect'</strong>, () =&gt;<br/>      console.log(`Disconnected: ${socket.id}`));</span><span id="528f" class="no mn it nk b gy nt nq l nr ns">   <strong class="nk iu">socket.on('join'</strong>, (room) =&gt; {<br/>      console.log(`Socket ${socket.id} joining ${room}`);<br/>      <strong class="nk iu">socket.join(room)</strong>;<br/>   });</span><span id="3a6b" class="no mn it nk b gy nt nq l nr ns">   <strong class="nk iu">socket.on('chat'</strong>, (data) =&gt; {<br/>      const { message, room } = data;<br/>      console.log(`msg: ${message}, room: ${room}`);<br/>      <strong class="nk iu">io.to(room).emit('chat', message)</strong>;<br/>   });<br/>});</span></pre><p id="1b90" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里需要安装npm包<code class="fe nu nv nw nk b">socket.io</code>，并且在与http服务器相同的端口<code class="fe nu nv nw nk b">3000</code>中创建套接字服务器。</p><ul class=""><li id="3ecb" class="nx ny it kk b kl km ko kp kr nz kv oa kz ob ld oc od oe of bi translated"><code class="fe nu nv nw nk b">io.on('connection')</code>是指初始化任何客户端套接字连接，然后，<code class="fe nu nv nw nk b">(socket) =&gt;</code>是指具有唯一id的特定套接字。</li><li id="690e" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld oc od oe of bi translated">每个插座可以通过向<code class="fe nu nv nw nk b">join</code>事件发送房间名称来加入所需的socket.io房间，服务器会监听<code class="fe nu nv nw nk b">join</code>事件并将该插座连接到给定的房间。</li><li id="2cb4" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld oc od oe of bi translated">当socket向<code class="fe nu nv nw nk b">chat</code>事件发出聊天消息时，它将被广播到该特定房间中的所有客户端socket，使这些聊天室。</li></ul></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="63d4" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用Reactjs挂钩设置前端客户端</h1><p id="4034" class="pw-post-body-paragraph ki kj it kk b kl ne ju kn ko nf jx kq kr ng kt ku kv nh kx ky kz ni lb lc ld im bi translated">让我们安装<code class="fe nu nv nw nk b">socket.io-client</code>包并创建socket相关函数来处理socket服务器，这些函数将与React挂钩一起使用。</p><pre class="mg mh mi mj gt nj nk nl nm aw nn bi"><span id="968e" class="no mn it nk b gy np nq l nr ns">import io from 'socket.io-client';<br/>let socket;</span><span id="db2a" class="no mn it nk b gy nt nq l nr ns">export const <strong class="nk iu">initiateSocket</strong> = (room) =&gt; {<br/>  <strong class="nk iu">socket = io('</strong><a class="ae ol" href="http://localhost:3000'" rel="noopener ugc nofollow" target="_blank"><strong class="nk iu">http://localhost:3000'</strong></a><strong class="nk iu">)</strong>;<br/>  console.log(`Connecting socket...`);<br/>  if (socket &amp;&amp; room) <strong class="nk iu">socket.emit('join', room)</strong>;<br/>}</span><span id="e331" class="no mn it nk b gy nt nq l nr ns">export const <strong class="nk iu">disconnectSocket</strong> = () =&gt; {<br/>  console.log('Disconnecting socket...');<br/>  if(socket) <strong class="nk iu">socket.disconnect();</strong><br/>}</span><span id="aa25" class="no mn it nk b gy nt nq l nr ns">export const <strong class="nk iu">subscribeToChat</strong> = (cb) =&gt; {<br/>  if (!socket) return(true);</span><span id="5ed1" class="no mn it nk b gy nt nq l nr ns">  <strong class="nk iu">socket.on('chat'</strong>, msg =&gt; {<br/>    console.log('Websocket event received!');<br/>    return cb(null, msg);<br/>  });<br/>}</span><span id="9470" class="no mn it nk b gy nt nq l nr ns">export const <strong class="nk iu">sendMessage</strong> = (room, message) =&gt; {<br/>  if (socket) <strong class="nk iu">socket.emit('chat', { message, room });</strong><br/>}</span></pre><ul class=""><li id="c280" class="nx ny it kk b kl km ko kp kr nz kv oa kz ob ld oc od oe of bi translated">这里的<code class="fe nu nv nw nk b">socket</code>被声明为一个变量，并没有在开始时初始化，因为它会在文件加载时建立套接字连接。但是这里它是在函数中启动的，这样客户机就可以控制何时进行套接字连接。</li><li id="e2ee" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld oc od oe of bi translated">一旦与<code class="fe nu nv nw nk b">io(URL...)</code>连接，它将发出加入特定房间的事件。注意，房间概念只在后端维护，前端的客户端套接字不知道房间。</li><li id="4ffc" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld oc od oe of bi translated">Subscribe事件使用回调函数与其目的进行交互，其中回调函数将使用<code class="fe nu nv nw nk b">data</code>针对给定事件上的任何消息进行调用。</li></ul></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="32d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些套接字函数可以很容易地用钩子在React应用程序中使用。通过<code class="fe nu nv nw nk b">useState</code>钩子，它将为<code class="fe nu nv nw nk b">room</code>(选中)、<code class="fe nu nv nw nk b">message</code>(当前消息)和<code class="fe nu nv nw nk b">chat</code>(所有消息)维护它们的变量。</p><pre class="mg mh mi mj gt nj nk nl nm aw nn bi"><span id="5677" class="no mn it nk b gy np nq l nr ns">import React, { useEffect, useState } from 'react';<br/>import { initiateSocket, disconnectSocket,<br/>    subscribeToChat, sendMessage } from './Socket';</span><span id="d905" class="no mn it nk b gy nt nq l nr ns">function App() {<br/>  const rooms = ['A', 'B', 'C'];<br/>  const [room, setRoom] = useState(rooms[0]);<br/>  const [message, setMessage] = useState('');<br/>  const [chat, setChat] = useState([]);</span><span id="94da" class="no mn it nk b gy nt nq l nr ns"><strong class="nk iu">  useEffect(() =&gt; {<br/>    if (room) initiateSocket(room);</strong></span><span id="ddae" class="no mn it nk b gy nt nq l nr ns"><strong class="nk iu">    subscribeToChat((err, data) =&gt; {<br/>      if(err) return;</strong></span><span id="7857" class="no mn it nk b gy nt nq l nr ns"><strong class="nk iu">      setChat(oldChats =&gt;[data, ...oldChats])<br/>    });</strong></span><span id="95fc" class="no mn it nk b gy nt nq l nr ns"><strong class="nk iu">    return () =&gt; {<br/>      disconnectSocket();<br/>    }<br/>  }, [room]);</strong></span><span id="92b2" class="no mn it nk b gy nt nq l nr ns">return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Room: {room}&lt;/h1&gt;<br/>      { rooms.map((r, i) =&gt;<br/>        &lt;button onClick={() =&gt; setRoom(r)} key={i}&gt;{r}&lt;/button&gt;)}</span><span id="7211" class="no mn it nk b gy nt nq l nr ns">      &lt;h1&gt;Live Chat:&lt;/h1&gt;<br/>      &lt;input type="text" name="name" value={message}<br/>        onChange={e =&gt; setMessage(e.target.value)} /&gt;<br/>      &lt;button onClick={()=&gt; sendMessage(room,message)}&gt;Send&lt;/button&gt;<br/>      { chat.map((m,i) =&gt; &lt;p key={i}&gt;{m}&lt;/p&gt;) }<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="4982" class="no mn it nk b gy nt nq l nr ns">export default App;</span></pre><p id="3b35" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用于套接字交互(或任何其他外部调用)的最重要的钩子是这里使用的<code class="fe nu nv nw nk b">useEffect</code>。</p><ul class=""><li id="238e" class="nx ny it kk b kl km ko kp kr nz kv oa kz ob ld oc od oe of bi translated">它有一个<code class="fe nu nv nw nk b">[room]</code>的依赖数组，简单地说，每次<code class="fe nu nv nw nk b">room</code>变量改变时，内部函数将被重新执行。</li><li id="bc12" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld oc od oe of bi translated">在内部函数中，它将为给定的<code class="fe nu nv nw nk b">room</code>启动套接字连接。如前所述，它将调用<code class="fe nu nv nw nk b">initiateSocket</code>，并加入给定的房间。</li><li id="439a" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld oc od oe of bi translated">接下来，我们为所需的事件注册一个订阅，回调函数将在每次服务器发出事件时执行。这将在从套接字更改时在<code class="fe nu nv nw nk b">subscribeToChat</code>的回调内<code class="fe nu nv nw nk b">setChat</code>。</li><li id="3086" class="nx ny it kk b kl og ko oh kr oi kv oj kz ok ld oc od oe of bi translated">最后，<code class="fe nu nv nw nk b">useEffect</code> hook能够返回一些函数来清理这些套接字交互。在这里的<code class="fe nu nv nw nk b">disconnectSocket</code>中，它将断开套接字连接，这样服务器就不会因空闲套接字而饥饿。</li></ul><p id="ec46" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种简单的方法创建了功能性聊天室，多个使用浏览器标签的客户可以在他们的聊天室内进行交互。但是，在处理高级场景时，很少需要考虑。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="c49d" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">需要考虑的问题很少！</h1><h2 id="726c" class="no mn it bd mo om on dn ms oo op dp mw kr oq or my kv os ot na kz ou ov nc ow bi translated">避免在每条聊天消息中发送聊天室:</h2><p id="b916" class="pw-post-body-paragraph ki kj it kk b kl ne ju kn ko nf jx kq kr ng kt ku kv nh kx ky kz ni lb lc ld im bi translated">每次发送聊天消息时，即使客户端socket早些时候加入了特定的房间，也需要发送哪个<code class="fe nu nv nw nk b">room</code>消息。这是因为socket可以有多个房间(每个房间都有自己的id ),并且可以存储在<code class="fe nu nv nw nk b">socket.rooms</code>的服务器中。每次都通过房间，以确保它将被广播到正确的插座组。</p><pre class="mg mh mi mj gt nj nk nl nm aw nn bi"><span id="e990" class="no mn it nk b gy np nq l nr ns">socket.rooms → { <strong class="nk iu">a8Kpvr_5JqG80SqtAAAB</strong>:'a8Kpvr_5JqG80SqtAAAB', <strong class="nk iu">A</strong>:'A'}<br/>socket.io    → <strong class="nk iu">a8Kpvr_5JqG80SqtAAAB</strong></span><span id="0f76" class="no mn it nk b gy nt nq l nr ns">joinedRooms other that default room with socket id → <br/>   <strong class="nk iu">Object.values(socket.rooms).filter(room =&gt; room !== socket.id)</strong></span></pre><p id="8fa3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在服务器中，socket可以在单个套接字范围内保存相关信息，也可以在绑定了唯一id的全局范围内保存相关信息。这也可以存储单一的东西，如用户名，附加聊天室等。请注意，这需要在连接、断开或更新时进行维护，并且需要额外的参与。</p><p id="3e11" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本地套接字范围内:</p><pre class="mg mh mi mj gt nj nk nl nm aw nn bi"><span id="506c" class="no mn it nk b gy np nq l nr ns">io.on("connection", (socket) =&gt; {<br/>  <strong class="nk iu">let socketRoom;</strong></span><span id="b612" class="no mn it nk b gy nt nq l nr ns">  socket.on('join', (room) =&gt; {<br/>    socket.join(room);<br/>    <strong class="nk iu">socketRoom = room;</strong><br/>  });</span><span id="ea4c" class="no mn it nk b gy nt nq l nr ns">  socket.on('chat', (data) =&gt; {<br/>    <strong class="nk iu">io.to(socketRoom).emit('chat'</strong>, data.message);<br/>  });<br/>});</span></pre><p id="edea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在全局套接字范围内:</p><pre class="mg mh mi mj gt nj nk nl nm aw nn bi"><span id="72b3" class="no mn it nk b gy np nq l nr ns"><strong class="nk iu">const socketMap = {};</strong></span><span id="5b11" class="no mn it nk b gy nt nq l nr ns">io.on("connection", (socket) =&gt; {</span><span id="a111" class="no mn it nk b gy nt nq l nr ns">socket.on('join', (data) =&gt; {<br/>    socket.join(data.room);<br/>    <strong class="nk iu">socketMap[socket.id] = data.username;</strong><br/>  });</span><span id="88e6" class="no mn it nk b gy nt nq l nr ns">socket.on('chat', (data) =&gt; {<br/>    io.to(data.room).emit('chat',<br/>      { message: data.message, <strong class="nk iu">user: socketMap[socket.id]</strong> });<br/>  });<br/>});</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h2 id="ff71" class="no mn it bd mo om on dn ms oo op dp mw kr oq or my kv os ot na kz ou ov nc ow bi translated">更换房间时避免重新连接:</h2><p id="4945" class="pw-post-body-paragraph ki kj it kk b kl ne ju kn ko nf jx kq kr ng kt ku kv nh kx ky kz ni lb lc ld im bi translated">一个重要的缺点是，当在房间之间切换时，它会断开前一个房间的插座，并在新的房间上建立新的连接。这将在切换房间时增加不必要的开销，而是可以使用现有的连接插座在房间之间切换。</p><pre class="mg mh mi mj gt nj nk nl nm aw nn bi"><span id="e2c2" class="no mn it nk b gy np nq l nr ns">Socket <strong class="nk iu">Q9_wYGZtDJVjf7MWAAAI</strong> joining A<br/>Disconnected: <strong class="nk iu">Q9_wYGZtDJVjf7MWAAAI</strong><br/>Connected: <strong class="nk iu">eWn2OGaXaml-0eS6AAAJ</strong><br/>Socket <strong class="nk iu">eWn2OGaXaml-0eS6AAAJ</strong> joining B</span></pre><p id="e38b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe nu nv nw nk b">useRef</code> &amp; <code class="fe nu nv nw nk b">useEffect</code>挂钩改变<code class="fe nu nv nw nk b">App.js</code>在房间之间切换:</p><pre class="mg mh mi mj gt nj nk nl nm aw nn bi"><span id="4b3d" class="no mn it nk b gy np nq l nr ns">// <strong class="nk iu">Let's keep track of previous room</strong> <br/>const prevRoomRef = useRef();<br/>useEffect(() =&gt; {<br/>  prevRoomRef.current = room;<br/>});<br/>const prevRoom = prevRoomRef.current;<br/></span><span id="243b" class="no mn it nk b gy nt nq l nr ns">// <strong class="nk iu">Initiate or Switch Rooms depending on previous and current values</strong><br/>useEffect(() =&gt; {<br/>    if (prevRoom &amp;&amp; room) switchRooms(prevRoom, room);<br/>    else if (room) initiateSocket(room);<br/>    setChat([]);<br/>    <br/>    // <strong class="nk iu">Reset chat messages upon change in room</strong><br/>    // <strong class="nk iu">Avoid subscribeToChat as it will duplicate subscriptions.</strong><br/>    // <strong class="nk iu">Avoid disconnectSocket as cleanup as socket is reused.</strong><br/>  }, [room]);</span><span id="e347" class="no mn it nk b gy nt nq l nr ns"><br/>// <strong class="nk iu">Subscribe only once to event as socket is reused</strong><br/>useEffect(() =&gt; {<br/>    subscribeToChat((err, data) =&gt; {<br/>      if(err) return;<br/>      setChat(oldChats =&gt;[data, ...oldChats])<br/>    });<br/>}, []);</span></pre><p id="d36b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在相关房间的<code class="fe nu nv nw nk b">Socket.js</code>上发出<code class="fe nu nv nw nk b">switch</code>事件:</p><pre class="mg mh mi mj gt nj nk nl nm aw nn bi"><span id="79b5" class="no mn it nk b gy np nq l nr ns">export const switchRooms = (prevRoom, nextRoom) =&gt; {<br/>  if (socket) <strong class="nk iu">socket.emit('switch', { prevRoom, nextRoom })</strong>;<br/>}</span></pre><p id="818e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在服务器上消费<code class="fe nu nv nw nk b">switch</code>事件并进行必要的房间变更:</p><pre class="mg mh mi mj gt nj nk nl nm aw nn bi"><span id="1cb8" class="no mn it nk b gy np nq l nr ns">socket.on('switch', (data) =&gt; {<br/>  const { prevRoom, nextRoom } = data;<br/>  if (prevRoom) <strong class="nk iu">socket.leave(prevRoom)</strong>;<br/>  if (nextRoom) <strong class="nk iu">socket.join(nextRoom);</strong><br/>  socketRoom = nextRoom;<br/>});</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h2 id="5060" class="no mn it bd mo om on dn ms oo op dp mw kr oq or my kv os ot na kz ou ov nc ow bi translated">向房间广播时避免发送者:</h2><p id="e6d0" class="pw-post-body-paragraph ki kj it kk b kl ne ju kn ko nf jx kq kr ng kt ku kv nh kx ky kz ni lb lc ld im bi translated">在某些情况下，实时应用程序可能会在等待套接字更新之前在本地附加聊天消息。对于这种方法，最好不要通过套接字订阅将该消息发送给发送者，这就要求不要将该消息广播给该房间中的发送者。</p><pre class="mg mh mi mj gt nj nk nl nm aw nn bi"><span id="ea79" class="no mn it nk b gy np nq l nr ns"><em class="ox">// In server replace io.to with socket.broadcast to avoid sender:</em></span><span id="043d" class="no mn it nk b gy nt nq l nr ns">-   io.to(socketRoom).emit('chat', data.message)<br/>+   <strong class="nk iu">socket.broadcast.to(socketRoom).emit('chat', data.message);</strong></span><span id="0f4a" class="no mn it nk b gy nt nq l nr ns"><br/>// In client, upon Send append to local chat state:</span><span id="753b" class="no mn it nk b gy nt nq l nr ns">onClick={() =&gt; {<br/>  <strong class="nk iu">setChat(oldChats =&gt; [message, ...oldChats]);<br/>  sendMessage(room, message);</strong><br/>}}</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h2 id="bd47" class="no mn it bd mo om on dn ms oo op dp mw kr oq or my kv os ot na kz ou ov nc ow bi translated">加入房间时加载初始数据:</h2><p id="b7df" class="pw-post-body-paragraph ki kj it kk b kl ne ju kn ko nf jx kq kr ng kt ku kv nh kx ky kz ni lb lc ld im bi translated">后端需要在全局范围内存储其聊天历史，并在加入该socketio room时返回与该房间相关的现有聊天消息。</p><pre class="mg mh mi mj gt nj nk nl nm aw nn bi"><span id="9d86" class="no mn it nk b gy np nq l nr ns"><strong class="nk iu">const socketHistory = {};</strong></span><span id="9524" class="no mn it nk b gy nt nq l nr ns">io.on("connection", (socket) =&gt; {<br/>  let socketRoom;</span><span id="67af" class="no mn it nk b gy nt nq l nr ns">  socket.on('join', (room) =&gt; {<br/>    socket.join(room);<br/>    socketRoom = room;<br/>    <strong class="nk iu">socket.emit('joinResponse', socketHistory[room]);</strong><br/>  });</span><span id="e6ac" class="no mn it nk b gy nt nq l nr ns">  socket.on('chat', (data) =&gt; {<br/>    socket.broadcast.to(socketRoom).emit('chat', data.message);<br/>    <strong class="nk iu">socketHistory[socketRoom] = socketHistory[socketRoom] ?<br/>      [data.message, ...socketHistory[socketRoom]] : [data.message]</strong><br/>  });</span></pre><p id="d7ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在前端订阅一次<code class="fe nu nv nw nk b">joinResponse</code>事件，这样它将加载初始数据</p><pre class="mg mh mi mj gt nj nk nl nm aw nn bi"><span id="f15b" class="no mn it nk b gy np nq l nr ns">// Socket.js</span><span id="68c1" class="no mn it nk b gy nt nq l nr ns">export const loadInitialChat = (cb) =&gt; {<br/>    if (!socket) return(true)<br/>  <br/>    <strong class="nk iu">socket.on('joinResponse', msg =&gt; cb(null, msg));</strong><br/>}</span><span id="f005" class="no mn it nk b gy nt nq l nr ns">// App.js</span><span id="ee82" class="no mn it nk b gy nt nq l nr ns">useEffect(() =&gt; {<br/>  <strong class="nk iu">loadInitialChat</strong>((err, data) =&gt; {<br/>    if(err) return;<br/>    <strong class="nk iu">setChat(data);</strong><br/>  });<br/>}, []);</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><p id="1f46" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个演示教程，介绍如何使用reactjs挂钩轻松集成socketio房间。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="oz pa di pb bf pc"><div class="gh gi oy"><img src="../Images/57458c50ee8851814eff7389ed86804f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAil9bPMCuvJUoRQHOjbMg.png"/></div></div></figure></div></div>    
</body>
</html>