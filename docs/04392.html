<html>
<head>
<title>Understanding Interfaces in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Go中的接口</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-interfaces-in-go-978edc3eaaf7?source=collection_archive---------3-----------------------#2020-06-24">https://levelup.gitconnected.com/understanding-interfaces-in-go-978edc3eaaf7?source=collection_archive---------3-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/462356578c39f227d705a17d8dda3328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgkaPc08v4_rTl2Nbzzk_g.jpeg"/></div></div></figure><p id="8fca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于编程新手和没有使用过接口的程序员来说，接口可能看起来是一个奇怪的概念，因为他们要么对接口不太有信心，要么可能是因为他们到目前为止使用的工具不太依赖于使用接口。</p><p id="c147" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，界面应该让你的生活更轻松，而不是让你紧张！我写这篇博客来告诉你为什么。</p><p id="c90a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将以我最喜欢的游戏之一《巫师3》为基础，来理解界面的概念。</p><p id="79de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在游戏中，考虑以下两类经常偶遇并以打斗告终的角色:<br/>巫师<br/>怪物</p><p id="312e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两种类型的角色都有一些共同的特征:<br/>名字<br/>等级<br/>攻击<br/>生命力(或生命值)</p><p id="8258" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，他们也有自己独特的特点。比如，一个巫师可能属于某一派，一个怪物会属于某一类怪物。</p><p id="22aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这些因素，让我们为巫师和怪物创建我们的<a class="ae kw" href="https://gobyexample.com/structs" rel="noopener ugc nofollow" target="_blank">结构</a>:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="93bd" class="lg lh iq lc b gy li lj l lk ll">package main</span><span id="de5c" class="lg lh iq lc b gy lm lj l lk ll">import "fmt"</span><span id="dfd2" class="lg lh iq lc b gy lm lj l lk ll"><strong class="lc ir">type character struct {<br/> name     string<br/> level    int<br/> attacks  map[string]int<br/> vitality int<br/>}</strong></span><span id="e71f" class="lg lh iq lc b gy lm lj l lk ll"><strong class="lc ir">type witcher struct {<br/> character<br/> school string<br/>}</strong></span><span id="b58a" class="lg lh iq lc b gy lm lj l lk ll"><strong class="lc ir">type monster struct {<br/> character<br/> monsterType string<br/>}</strong></span><span id="e611" class="lg lh iq lc b gy lm lj l lk ll">func main() {<br/>  <br/>}</span></pre><p id="a424" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，所以我们看到了角色结构中的共同特征，其他<em class="ln">巫师</em>和<em class="ln">怪物</em>结构也有它们自己的独特字段，除了我们从<em class="ln">角色</em>中重用的字段。</p><p id="7afe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们创造一个巫师和一个怪物:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="7159" class="lg lh iq lc b gy li lj l lk ll">...</span><span id="765e" class="lg lh iq lc b gy lm lj l lk ll">func main() {</span><span id="8cd1" class="lg lh iq lc b gy lm lj l lk ll"> geralt := <strong class="lc ir">witcher</strong>{<br/>  <strong class="lc ir">character</strong>: <strong class="lc ir">character</strong>{<br/>   name:     "Geralt",<br/>   level:    112,<br/>   attacks: map[string]int{"swordHeavy": 1250, "swordQuick": 750},<br/>   vitality: 3000,<br/>  },<br/>  school: "Wolf",<br/> }</span><span id="8ffc" class="lg lh iq lc b gy lm lj l lk ll"> ekkimmara := <strong class="lc ir">monster</strong>{<br/>  <strong class="lc ir">character</strong>: <strong class="lc ir">character</strong>{<br/>   name:     "Ekkimmara",<br/>   level:    114,<br/>   attacks: <strong class="lc ir">m</strong>ap[string]int{"heavySlash": 1440, "rush": 800},<br/>   vitality: 6500,<br/>  },<br/>  monsterType: "Vampire",<br/> }</span><span id="5e95" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><p id="c464" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们有我们的巫师杰洛特，他有两种攻击:一种重剑攻击和一种快剑攻击。这两种攻击都是地图<a class="ae kw" href="https://gobyexample.com/maps" rel="noopener ugc nofollow" target="_blank">中的关键，与它们将造成的伤害相对应。Ekkimmara也有自己的攻击和伤害。</a></p><p id="001a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">酷，我们列出了对这些角色的攻击以及这些攻击会造成的伤害。</p><p id="b959" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们现在仔细想想，这是这两个角色的共同特征。如果他们在战斗中相遇，他们都可以通过攻击对方来造成伤害，并且他们可以在成为任何攻击的受害者后受到伤害。</p><p id="70ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们可以开始考虑实现一个通用行为的接口的地方！</p><p id="7e60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个接口将帮助我们把巫师和ekkimmara放入一个共同的类型:战斗角色，然后我们可以用它来分享共同的行为。这可以通过代码变得更清楚:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="2ca9" class="lg lh iq lc b gy li lj l lk ll"><strong class="lc ir">type combatCharacters interface {<br/>   <br/>   attack(attackName string) int<br/>   takeDamage(damage int)<br/>   getName() string<br/>   getVitality() int</strong></span><span id="511e" class="lg lh iq lc b gy lm lj l lk ll"><strong class="lc ir">}</strong></span></pre><p id="ebf8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个接口将保存一个方法签名列表，任何实现这些方法的结构(或者更精确的类型)也将是类型<strong class="ka ir"> combatCharacters。</strong></p><p id="cd84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Go中，接口是隐式实现的。你所要做的就是把在一个接口中定义的方法附加到一个结构上，这样这个结构就有资格成为这个接口所提到的类型。</p><p id="4b9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果我们将上面提到的方法附加到我们的witcher和monster结构，那么为这些结构获得的任何实例也将是类型<strong class="ka ir"> combatCharacters。</strong></p><p id="4a45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将有助于创建一个造成攻击和伤害的通用函数。这个函数可以把一个巫师当作攻击者，把一个怪物当作受害者。</p><p id="486d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们即将创建的函数的一瞥:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b77b" class="lg lh iq lc b gy li lj l lk ll">...<br/><em class="ln">// our interface for reference</em></span><span id="4dc6" class="lg lh iq lc b gy lm lj l lk ll">type <strong class="lc ir">combatCharacters</strong> interface {<br/>   <br/>   attack(attackName string) int<br/>   takeDamage(damage int)<br/>   getName() string<br/>   getVitality() int</span><span id="766d" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="abb0" class="lg lh iq lc b gy lm lj l lk ll">...</span><span id="f471" class="lg lh iq lc b gy lm lj l lk ll">func <strong class="lc ir">doDamage</strong>(<br/>  <em class="ln">attacker</em> <strong class="lc ir">combatCharacters</strong>, <br/>  <em class="ln">victim</em> <strong class="lc ir">combatCharacters</strong>, <br/>  attackName string<br/>) {</span><span id="2ba7" class="lg lh iq lc b gy lm lj l lk ll">    <em class="ln">// since the attack method was part of our interface    <br/>    // we will get the damage inflicted by an attacker<br/>    // attackName is a string and an int is returned</em></span><span id="d284" class="lg lh iq lc b gy lm lj l lk ll">    <strong class="lc ir">damageInflicted := attacker.attack(attackName)</strong></span><span id="21c1" class="lg lh iq lc b gy lm lj l lk ll">    <em class="ln">// since the takeDamage method was part of our interface<br/>    // we can use it to record damage inflicted on a victim</em><br/>    <br/>    <strong class="lc ir">victim.takeDamage(damageInflicted)</strong></span><span id="8247" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="7d92" class="lg lh iq lc b gy lm lj l lk ll">...</span></pre><p id="f47d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的函数可以将任何类型为<strong class="ka ir">战斗角色</strong>的攻击者和类型为<strong class="ka ir">战斗角色</strong>的受害者作为参数。</p><p id="a80c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，这可以通过简单地实现我们的接口中定义的方法来实现。</p><p id="d129" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将首先为我们的巫师做这件事:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="dee8" class="lg lh iq lc b gy li lj l lk ll">...</span><span id="ab03" class="lg lh iq lc b gy lm lj l lk ll">type witcher struct {<br/> character<br/> school string<br/>}</span><span id="2dca" class="lg lh iq lc b gy lm lj l lk ll">func (w witcher) <strong class="lc ir">attack(attackName string) int</strong> {<br/> return w.attacks[attackName]<br/>}</span><span id="3761" class="lg lh iq lc b gy lm lj l lk ll"><em class="ln">// pointer to witcher taken <br/>// to reflect actual damage to a witcher's vitality</em><br/>func (w *witcher) <strong class="lc ir">takeDamage(damage int)</strong> {<br/> w.vitality = w.vitality - damage<br/>}</span><span id="312c" class="lg lh iq lc b gy lm lj l lk ll">func (w witcher) <strong class="lc ir">getName() string</strong> {<br/> return w.name<br/>}</span><span id="cb65" class="lg lh iq lc b gy lm lj l lk ll">func (w witcher) <strong class="lc ir">getVitality() int</strong> {<br/> return w.vitality<br/>}</span><span id="b407" class="lg lh iq lc b gy lm lj l lk ll">...</span></pre><p id="9467" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们已经将所有必需的方法签名(根据我们的接口)添加到了我们的witcher结构中，使其符合类型<strong class="ka ir"> combatCharacters </strong>。</p><p id="484f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在takeDamage方法中，请注意我们使用了一个指向witcher struct类型值的指针。这样做实际上是为了改变巫师的生命力，以防他在攻击中受到伤害。</p><p id="a575" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对怪物做同样的事情:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="bbe1" class="lg lh iq lc b gy li lj l lk ll">...</span><span id="7d34" class="lg lh iq lc b gy lm lj l lk ll">type monster struct {<br/> character<br/> monsterType string<br/>}</span><span id="e7ce" class="lg lh iq lc b gy lm lj l lk ll">func (m monster) <strong class="lc ir">attack(attackName string) int</strong> {<br/> return m.attacks[attackName]<br/>}</span><span id="6987" class="lg lh iq lc b gy lm lj l lk ll">func (m *monster) <strong class="lc ir">takeDamage(damage int)</strong> {<br/> m.vitality = m.vitality - damage<br/>}</span><span id="e4a3" class="lg lh iq lc b gy lm lj l lk ll">func (m monster) <strong class="lc ir">getName() string</strong> {<br/> return m.name<br/>}</span><span id="00b2" class="lg lh iq lc b gy lm lj l lk ll">func (m monster) <strong class="lc ir">getVitality() int</strong> {<br/> return m.vitality<br/>}</span><span id="0173" class="lg lh iq lc b gy lm lj l lk ll">...</span></pre><p id="8622" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了使用的结构类型之外，没有太大的区别。这也符合现在<strong class="ka ir">战斗角色</strong>的类型。</p><p id="1875" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，剩下要添加的是我们描述敌人之间冲突的功能:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="a8d4" class="lg lh iq lc b gy li lj l lk ll">...</span><span id="7e86" class="lg lh iq lc b gy lm lj l lk ll">func doDamage(<br/>  attacker <strong class="lc ir">combatCharacters</strong>, <br/>  victim <strong class="lc ir">combatCharacters</strong>, <br/>  attackName string<br/>) {<br/>    damageInflicted := attacker.<strong class="lc ir">attack</strong>(attackName)<br/>    victim.<strong class="lc ir">takeDamage</strong>(damageInflicted)<br/>    <br/>    fmt.Println(<br/>      attacker.<strong class="lc ir">getName</strong>(), <br/>      "attacked", <br/>      victim.<strong class="lc ir">getName</strong>(), <br/>      "did", <br/>      damageInflicted, <br/>      "damage",<br/>    )<br/>    <br/>    fmt.Println(<br/>      victim.<strong class="lc ir">getName</strong>(), <br/>      "now has", <br/>      victim.<strong class="lc ir">getVitality</strong>(), <br/>      "health remaining",<br/>    )<br/>}</span><span id="02ca" class="lg lh iq lc b gy lm lj l lk ll">...</span></pre><p id="20b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">粗体突出显示的是我们在界面中提到的方法。</p><p id="a190" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着，我们现在可以执行类似于:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="26e9" class="lg lh iq lc b gy li lj l lk ll">...</span><span id="8c6b" class="lg lh iq lc b gy lm lj l lk ll">doDamage(geralt, ekkimmara, "swordHeavy")</span><span id="567b" class="lg lh iq lc b gy lm lj l lk ll">...</span></pre><p id="e4cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">geralt和ekkimmara都符合战斗角色类型，将被传递到函数中。在这种情况下，杰勒特将成为攻击者，而埃克金马拉将成为“剑重”攻击的受害者。</p><p id="459a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总的来说，我们的代码如下所示:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="4903" class="lg lh iq lc b gy li lj l lk ll">package main</span><span id="f685" class="lg lh iq lc b gy lm lj l lk ll">import (<br/> "fmt"<br/>)</span><span id="aae6" class="lg lh iq lc b gy lm lj l lk ll"><strong class="lc ir">type combatCharacters interface {<br/> attack(attackName string) int<br/> takeDamage(damage int)<br/> getName() string<br/> getVitality() int<br/>}</strong></span><span id="f257" class="lg lh iq lc b gy lm lj l lk ll">type character struct {<br/> name     string<br/> level    int<br/> attacks  map[string]int<br/> vitality int<br/>}</span><span id="4b20" class="lg lh iq lc b gy lm lj l lk ll">type witcher struct {<br/> character<br/> school string<br/>}</span><span id="9510" class="lg lh iq lc b gy lm lj l lk ll">func (w witcher) attack(attackName string) int {<br/> return w.attacks[attackName]<br/>}</span><span id="f600" class="lg lh iq lc b gy lm lj l lk ll">func (w *witcher) takeDamage(damage int) {<br/> w.vitality = w.vitality - damage<br/>}</span><span id="d6f2" class="lg lh iq lc b gy lm lj l lk ll">func (w witcher) getName() string {<br/> return w.name<br/>}</span><span id="ec36" class="lg lh iq lc b gy lm lj l lk ll">func (w witcher) getVitality() int {<br/> return w.vitality<br/>}</span><span id="a26a" class="lg lh iq lc b gy lm lj l lk ll">type monster struct {<br/> character<br/> monsterType string<br/>}</span><span id="de0f" class="lg lh iq lc b gy lm lj l lk ll">func (m monster) attack(attackName string) int {<br/> return m.attacks[attackName]<br/>}</span><span id="7699" class="lg lh iq lc b gy lm lj l lk ll">func (m *monster) takeDamage(damage int) {<br/> m.vitality = m.vitality - damage<br/>}</span><span id="4f69" class="lg lh iq lc b gy lm lj l lk ll">func (m monster) getName() string {<br/> return m.name<br/>}</span><span id="d45f" class="lg lh iq lc b gy lm lj l lk ll">func (m monster) getVitality() int {<br/> return m.vitality<br/>}</span><span id="078e" class="lg lh iq lc b gy lm lj l lk ll">func doDamage(<br/>  attacker <strong class="lc ir">combatCharacters</strong>, <br/>  victim <strong class="lc ir">combatCharacters</strong>, <br/>  attackName string,<br/>) {<br/>    damageInflicted := attacker.<strong class="lc ir">attack</strong>(attackName)<br/>    victim.<strong class="lc ir">takeDamage</strong>(damageInflicted)<br/>    <br/>    fmt.Println(<br/>      attacker.<strong class="lc ir">getName</strong>(), <br/>      "attacked", <br/>      victim.<strong class="lc ir">getName</strong>(), <br/>      "did", <br/>      damageInflicted, <br/>      "damage",<br/>    )<br/>    <br/>    fmt.Println(<br/>      victim.<strong class="lc ir">getName</strong>(), <br/>      "now has", <br/>      victim.<strong class="lc ir">getVitality</strong>(), <br/>      "health remaining",<br/>    )<br/>}</span><span id="eb85" class="lg lh iq lc b gy lm lj l lk ll">func main() {<br/> geralt := witcher{<br/>  character: character{<br/>   name:     "Geralt",<br/>   level:    112,<br/>   attacks:  map[string]int{<strong class="lc ir">"swordHeavy": 1250</strong>, "swordQuick": 750},<br/>   vitality: 3000,<br/>  },<br/>  school: "Wolf",<br/> }</span><span id="d675" class="lg lh iq lc b gy lm lj l lk ll"> ekkimmara := monster{<br/>  character: character{<br/>   name:     "Ekkimmara",<br/>   level:    114,<br/>   attacks:  map[string]int{"heavySlash": 1440, "rush": 800},<br/>   <strong class="lc ir">vitality: 6500</strong>,<br/>  },<br/>  monsterType: "Vampire",<br/> }</span><span id="42cf" class="lg lh iq lc b gy lm lj l lk ll"> <strong class="lc ir">doDamage(&amp;geralt, &amp;ekkimmara, "swordHeavy")</strong></span><span id="2b38" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><p id="b67b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们将geralt和ekkimmara的地址作为参数传递，这符合我们的takeDamage方法定义，我们实际上是在该方法中改变了活力:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="60c1" class="lg lh iq lc b gy li lj l lk ll">func (w *witcher) takeDamage(damage int) {<br/> w.vitality = w.vitality - damage<br/>}</span><span id="75a4" class="lg lh iq lc b gy lm lj l lk ll">...</span><span id="cfd2" class="lg lh iq lc b gy lm lj l lk ll">func (m *monster) takeDamage(damage int) {<br/> m.vitality = m.vitality - damage<br/>}</span></pre><p id="a26f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在运行完整的代码时，您应该在终端中获得以下输出:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="01e1" class="lg lh iq lc b gy li lj l lk ll">Geralt attacked Ekkimmara did 1250 damage<br/>Ekkimmara now has 5250 health remaining</span></pre><p id="0d68" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在你知道了，接口是很好的俱乐部共同行为和重用通用函数！</p><p id="0e2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是Ekkimmara攻击我们的巫师:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="aa71" class="lg lh iq lc b gy li lj l lk ll">doDamage(&amp;ekkimmara, &amp;geralt, "heavySlash")</span></pre><p id="d72d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出是:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="6088" class="lg lh iq lc b gy li lj l lk ll">Ekkimmara attacked Geralt did 1440 damage<br/>Geralt now has 1560 health remaining</span></pre><p id="a11e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便提一下，每个类型都将实现空接口<a class="ae kw" href="https://tour.golang.org/methods/14" rel="noopener ugc nofollow" target="_blank">:interface { }，因为每个类型至少没有方法！所以每个类型都可以作为空接口——接口{}类型。这也是因为接口在Go中是隐式实现的。通过使用一个<em class="ln">实现</em>关键字或类似的东西，你不能明确地说出某个东西使用了某个接口。</a></p><p id="772a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在Go的文档中，您可能经常会发现这样的内容:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="3d25" class="lg lh iq lc b gy li lj l lk ll"><a class="ae kw" href="https://golang.org/pkg/fmt/#Println" rel="noopener ugc nofollow" target="_blank">func Println(a ...interface{}) (n int, err error)</a></span></pre><p id="7d97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面是非常常见的fmt的方法签名。Println()。</p><p id="0228" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所知，它可以接受任意类型的可变数量的参数，因此定义中包含一个空接口！这样做是为了使任何类型的值都可以作为参数传递。</p><p id="b6c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还要记住，在运行时，一个值只能有一种类型。只要需要，Go运行时会将不同类型的值转换为接口{}类型。更多信息请点击。</p></div></div>    
</body>
</html>