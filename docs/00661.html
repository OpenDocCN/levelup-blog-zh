<html>
<head>
<title>Load Balance and Scale Node.js Containers with Nginx and Docker Swarm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nginx和Docker Swarm对Node.js容器进行负载平衡和扩展</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/load-balance-and-scale-node-js-containers-with-nginx-and-docker-swarm-9fc97c3cff81?source=collection_archive---------0-----------------------#2019-06-21">https://levelup.gitconnected.com/load-balance-and-scale-node-js-containers-with-nginx-and-docker-swarm-9fc97c3cff81?source=collection_archive---------0-----------------------#2019-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/26fdf8c593e507430457c23f9572dd03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2kLrLgDZjAt0P_xNrM1qtg.jpeg"/></div></div></figure><div class=""/><p id="e644" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我之前的博客<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/set-up-a-nginx-load-balancer-for-a-dockerized-node-js-application-6bff1a54655a">中，我们看到了如何在不同主机端口上的docker容器中部署Node.js应用程序，并使用Nginx对其进行负载平衡。</a></p><p id="eb25" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个很好的方法，可以用来理解基础知识。然而，在生产环境中，在不同的端口上单独部署一个一个的容器是不可行的，还要在我们的Nginx配置文件中写入每个ip:port，此外，当容器由于某种原因关闭时，还要管理和重写配置文件。因此，当容器数量增加时，它变得难以管理和令人沮丧。</p><p id="5e26" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个问题的一个解决方案是使用<code class="fe kx ky kz la b">Container Orchestration</code>。我们将使用docker本身提供的称为<code class="fe kx ky kz la b">docker swarm</code>的编排来简化我们的工作。你可以在这里阅读对swarm、服务、堆栈<a class="ae kw" href="https://docs.docker.com/get-started/part4/" rel="noopener ugc nofollow" target="_blank">的一般介绍</a></p><p id="62f4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">必备:<br/> </strong> Docker基础知识</p><p id="c49d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">概述:</strong></p><p id="af6c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇博客中，我们将对接一个Node.js应用程序，然后在一个swarm集群中部署15个容器，看看我们如何使用Nginx在单个IP后面对它们进行负载平衡，最后以放大和缩小它们并以更好的方式可视化容器来结束。</p><p id="f634" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="lb">好了，我们开始吧</em> </strong></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="3f78" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的节点应用程序的app.js看起来像这样。</p><figure class="lj lk ll lm gt is"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="04e4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它只是在端口5000上用os.hostname()响应，这样我们就可以区分不同的运行容器。<br/>我们需要将此应用程序归档，因此复制下面的docker文件，并打开您的终端cmd/shell到同一个文件夹。</p><figure class="lj lk ll lm gt is"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="0ec9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，您需要运行<code class="fe kx ky kz la b">docker build -t username/appname .</code>，其中用户名是您的docker-hub用户名，然后使用<code class="fe kx ky kz la b">docker image push username/appname</code>将其推送到docker hub。<br/>我们正在将它推送到docker hub，这样我们就可以进行一次性设置，并可以在任何需要的时候在任何服务器上使用docker-compose.yml文件来旋转我们的容器，此外，我们不需要在每台服务器上构建映像，我们只需要在我们的云服务器上使用docker-compose.yml文件。<br/>所以对我来说，命令是:</p><ul class=""><li id="df66" class="lp lq jb ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated"><code class="fe kx ky kz la b">docker build -t aagam29/nodeapp_balancerdemo .</code></li><li id="2b39" class="lp lq jb ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated"><code class="fe kx ky kz la b">docker image push aagam29/nodeapp_balancerdemo</code></li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="3167" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要Nginx作为容器的负载平衡器，所以让我们来设置它。移动到新文件夹并复制这些文件。<br/>根据您的服务器更改nginx.conf中的IP。<br/>要了解更多关于Nginx的信息，你可能想参考<a class="ae kw" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank">这个</a></p><figure class="lj lk ll lm gt is"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="d6e6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将做一个类似的图像构建和推动我们做了以上</p><ul class=""><li id="693f" class="lp lq jb ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated"><code class="fe kx ky kz la b">docker image build -t aagam29/nginx_balancerdemo</code></li><li id="3b19" class="lp lq jb ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated"><code class="fe kx ky kz la b">docker image push aagam29/nginx_balancerdemo</code></li></ul><p id="fa68" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成后，你应该可以在docker hub上看到图片</p><figure class="lj lk ll lm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi md"><img src="../Images/69b1985d2e0321f850fd9192f9289474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTOKF80F8ejMpZNnYil6zw.png"/></div></div></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="98b5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，下一个任务是在我们的部署服务器上创建一个swarm集群。简单地输入<code class="fe kx ky kz la b">docker swarm init </code>，一个蜂群就会被创造出来。我们将在一台服务器上看到部署，以防您希望使用多台服务器，只需<a class="ae kw" href="https://docs.docker.com/engine/swarm/swarm-tutorial/add-nodes/" rel="noopener ugc nofollow" target="_blank">添加一个<strong class="ka jc">管理器</strong>节点</a>到集群，并在构建nginx映像之前添加其IP:Port，并开放所需的容器<a class="ae kw" href="https://docs.docker.com/engine/swarm/swarm-tutorial/#open-protocols-and-ports-between-the-hosts" rel="noopener ugc nofollow" target="_blank">端口</a>供它们通信。</p><p id="297b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您的服务器上复制以下docker-compose文件，根据您在构建图像时使用的用户名/appname更改图像名称。</p><figure class="lj lk ll lm gt is"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="44ac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您熟悉docker-compose文件，就很容易理解这里发生了什么。对于那些没有的人，我们提供两种服务:</p><ul class=""><li id="4c76" class="lp lq jb ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">第一个被命名为<code class="fe kx ky kz la b">nodeapp</code>，它将生成我们的映像<code class="fe kx ky kz la b">aagam29/nodeapp_balancerdemo</code>的<code class="fe kx ky kz la b">15</code>容器，映射将从主机端口5000到容器端口5000。如果一个容器关闭，将有<code class="fe kx ky kz la b">3</code>次连续重启尝试，当更新时，它将延迟10秒关闭→启动容器<br/> <code class="fe kx ky kz la b">3 by 3</code>，容器将被添加到在文件末尾创建的名为<code class="fe kx ky kz la b">balance</code>的网络中</li><li id="b07d" class="lp lq jb ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">第二个名为<code class="fe kx ky kz la b">proxy</code>，它将从我们的映像<code class="fe kx ky kz la b">aagam29/nginx_balancerdemo</code>中旋转一个容器，该映像位于从主机端口80映射到容器端口80的同一个网络<code class="fe kx ky kz la b">balance</code>中，它依赖于<code class="fe kx ky kz la b">nodeapp</code>，这意味着一旦<code class="fe kx ky kz la b">nodeapp</code>服务启动，它就会启动，并且该节点应该是群中的<code class="fe kx ky kz la b">manager</code>，以便运行该服务</li></ul><p id="abba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">复制该文件后，我们需要使用<code class="fe kx ky kz la b">docker stack deploy -c docker-compose.yml swarmnodeapp<br/></code>使用docker stack部署我们的服务堆栈。部署完堆栈后，我们可以使用<code class="fe kx ky kz la b">docker service ls </code>和<code class="fe kx ky kz la b">docker service ps <strong class="ka jc">servicename</strong></code> <strong class="ka jc"> </strong>检查部署状态，还可以使用<code class="fe kx ky kz la b">docker container ls</code>查看正在运行的容器。</p><p id="b6ea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lb">随后的截图清晰的说出了整个过程！</em></p><figure class="lj lk ll lm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi me"><img src="../Images/58ff16255d04ef5e7f7361a635cd2ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQHcnsWs1cEyxExcXwoncQ.png"/></div></div></figure><figure class="lj lk ll lm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi md"><img src="../Images/13309263b6ce15be96a0dc62a8521f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uja6yXEP-mYK8ZQGwgL0Jw.png"/></div></div></figure><p id="b695" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">祝贺😃，我们快完成了！如果一切顺利，您可以访问您的ip来查看容器ID，并多次点击刷新来查看它们每次的变化，以交叉检查负载平衡工作是否非常顺利！！</p><figure class="lj lk ll lm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi md"><img src="../Images/1c9a08e54a79e9d4671c0357dc531e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FczxRJwevBv0oZ_ioj2yXw.png"/></div></div></figure><p id="cb49" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在到了扩展的时候了，你可以用swarm很容易地扩展你的容器，你所需要做的就是运行<code class="fe kx ky kz la b">docker service scale servicename=replicas</code>比如<code class="fe kx ky kz la b">docker service scale swarmnodeapp_nodeapp=50</code></p><figure class="lj lk ll lm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mf"><img src="../Images/4f0cb827b22da74a1618092d9a3a5f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xKH1cY_IRx_sQrap-Lz6yQ.png"/></div></div></figure><p id="eb15" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更好地可视化运行的容器，我们可以使用docker可视化工具。只需运行<code class="fe kx ky kz la b">docker container run -p 8080:8080 -v /var/run/docker.sock:/var/run/docker.sock -d dockersamples/visualizer</code></p><figure class="lj lk ll lm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/4d71677fdf86bc1546604b48029da043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-t54VpLXtYRt6uICOiPhQ.png"/></div></div></figure><p id="8384" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后访问您的IP:8080，以正确查看您的群中运行的容器。</p><figure class="lj lk ll lm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mh"><img src="../Images/fd42ecb11f5d52f23679ef14acf6c767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*haegJQ-5NZn0BugiTddkmg.png"/></div></div></figure><p id="eaae" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">干得好！</p><p id="7e79" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们刚刚为您的Node.js应用程序实现了一次性可伸缩部署设置，还为它配置了负载平衡，并在不使用命令行的情况下可视化了它们。</p><p id="58de" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="lb">感谢阅读！如果你喜欢你所读的，那么留下一个👏然后跟着走。</em> </strong></p></div></div>    
</body>
</html>