<html>
<head>
<title>Next Level Your Typescript Runtime Type Validation Using Class and Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用类和装饰器进行下一级Typescript运行时类型验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/next-level-your-typescript-runtime-type-validation-using-class-and-decorators-ddd2ce3c86f3?source=collection_archive---------5-----------------------#2022-11-09">https://levelup.gitconnected.com/next-level-your-typescript-runtime-type-validation-using-class-and-decorators-ddd2ce3c86f3?source=collection_archive---------5-----------------------#2022-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c7c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文旨在展示一种使用Typescript类和<code class="fe ko kp kq kr b">class-validator</code>decorator来验证数据的简单明了的方法。</p><p id="9294" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TL；这里是的<a class="ae ks" href="https://github.com/caopengau/typescript-type-validation" rel="noopener ugc nofollow" target="_blank"/></p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/6b2ef4cccc88bf80f0c40c25245313f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hMyaDUG5PBF6FqjBsVybqA.png"/></div></div></figure><h1 id="cef5" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第1/2部分。JSON数据到类中</h1><p id="53ac" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们使用JSON对象在服务器和客户端应用程序之间，或者在本地节点项目中存储和传输数据。在Typescript中，有两种类型的对象。</p><ul class=""><li id="11e4" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated"><strong class="js iu">普通对象:</strong>当我们试图使用<a class="ae ks" href="https://www.geeksforgeeks.org/javascript-json-parse-method/" rel="noopener ugc nofollow" target="_blank"> JSON.parse() </a>方法解析JSON数据时，我们得到的是普通对象而不是类对象。</li><li id="e6c7" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><strong class="js iu">Class(constructor)objects:</strong>Class对象是一个Typescript类的实例，它有自己定义的属性、构造函数和方法。</li></ul><p id="dea1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">示例:</strong></p><p id="6c32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">数据1: </strong>假设，我们在客户端定义了一个Typescript类:</p><pre class="ku kv kw kx gt mw kr mx my aw mz bi"><span id="770c" class="na lg it kr b gy nb nc l nd ne">class Todo {<br/>    id: number;<br/>    title: string;<br/>    done: boolean;<br/>    // some additional props or methods<br/>}</span></pre><p id="62fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">数据2: </strong>我们在项目中本地存储了一个JSON对象:</p><pre class="ku kv kw kx gt mw kr mx my aw mz bi"><span id="9270" class="na lg it kr b gy nb nc l nd ne">const jsonData = {<br/>  "id": 1,<br/>  "title": "Upgrade typescript runtime validation with class decorators",<br/>  "done": true,<br/>}</span></pre><p id="af2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上述JSON对象可以由服务器发送到网页或任何其他客户端应用程序。如果我们观察清楚了，JSON对象的结构和Typescript类的结构是等价的，但是如果我们要为JSON对象访问Todo类的方法呢！我们有两种方法可以完成这项任务，使用<a class="ae ks" href="https://www.geeksforgeeks.org/javascript-objects/" rel="noopener ugc nofollow" target="_blank"> Object </a>类的<strong class="js iu"> assign </strong>方法，这实质上是将JSON对象克隆到Todo类对象。另一种是使用<strong class="js iu">类转换器</strong>工具，该工具用于将类型脚本对象转换成类对象。</p><h2 id="91d1" class="na lg it bd lh nf ng dn ll nh ni dp lp kb nj nk lt kf nl nm lx kj nn no mb np bi translated"><strong class="ak">方法一:</strong> <code class="fe ko kp kq kr b">Object.assign()</code></h2><p id="5de1" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">首先，我们必须在我们的TypeScript文件中导入JSON对象，这可以通过使用TypeScript中的<strong class="js iu"> import </strong>关键字来完成，这将把JSON对象加载到TypeScript变量中。在我的例子中，我们将JSON文件存储在与我的TypeScript文件相同的目录中。然后，我们可以使用<code class="fe ko kp kq kr b">Object.assign()</code>这个方法，它将返回一个Todo类对象，我们可以访问在Todo类中定义的方法。</p><p id="e292" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">程序1: </strong></p><pre class="ku kv kw kx gt mw kr mx my aw mz bi"><span id="7670" class="na lg it kr b gy nb nc l nd ne">const jsonData = {<br/>  "id": 1,<br/>  "title": "Upgrade typescript runtime validation with class decorators",<br/>  "done": true,<br/>}</span><span id="d21c" class="na lg it kr b gy nq nc l nd ne">// Defining our Todo class<br/>class Todo {<br/> userId: number;<br/> id: number;<br/> title: string;<br/> done: boolean;<br/>}</span><span id="36f2" class="na lg it kr b gy nq nc l nd ne">// Object.assign() will clone jsonData into<br/>// Todo class object Storing the new class<br/>// object in a typescript variable<br/>let todoClass = Object.assign(new Todo(), jsonData);</span><span id="d8f8" class="na lg it kr b gy nq nc l nd ne">// Logging the output onto the console<br/>console.log(newTodo);</span></pre><p id="9739" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出:</p><pre class="ku kv kw kx gt mw kr mx my aw mz bi"><span id="7ee3" class="na lg it kr b gy nb nc l nd ne">Todo {<br/> id: 1,<br/> title: ‘Upgrade typescript runtime validation with class decorators’,<br/> done: true<br/>}</span></pre><h2 id="95ba" class="na lg it bd lh nf ng dn ll nh ni dp lp kb nj nk lt kf nl nm lx kj nn no mb np bi translated"><strong class="ak">方法2: </strong>普通级(<strong class="ak">变压器级)</strong></h2><p id="4fd1" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这里讨论的第一种方法对于简单的JSON对象来说既简单又有用，但是如果我们有一个具有复杂层次结构的对象或者一组复杂的JSON对象，事情可能会出错。为此，我们可以使用<strong class="js iu">类变压器</strong>工具。在您的本地系统中，使用终端或命令窗口(取决于您的操作系统)执行以下命令。</p><ul class=""><li id="09d7" class="mi mj it js b jt ju jx jy kb mk kf ml kj mm kn mn mo mp mq bi translated"><strong class="js iu">命令:</strong><strong class="js iu">-g</strong>标志用于全局安装。我们将使用class-transformer工具的<strong class="js iu"> plainToClass </strong>方法将我们的JSON对象转换成TypeScript类对象。</li></ul><pre class="ku kv kw kx gt mw kr mx my aw mz bi"><span id="8bbe" class="na lg it kr b gy nb nc l nd ne">npm install -g class-transformer</span></pre><p id="0eb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个方法有两个参数，第一个参数是Todo类的实例，第二个参数是从本地项目导入的JSON对象。首先，我们必须从我们的TypeScript文件中的class-transformer工具导入方法，以便TypeScript知道使用哪个方法。同样，我们将JSON文件存储在与TypeScript文件相同的目录中。</p><p id="91aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">程序:</strong></p><pre class="ku kv kw kx gt mw kr mx my aw mz bi"><span id="7aca" class="na lg it kr b gy nb nc l nd ne">import { plainToClass } from "class-transformer";</span><span id="6f04" class="na lg it kr b gy nq nc l nd ne">const jsonData = {<br/>  "id": 1,<br/>  "title": "Upgrade typescript runtime validation with class decorators",<br/>  "done": true,<br/>}</span><span id="4322" class="na lg it kr b gy nq nc l nd ne">// Defining our Todo class<br/>class Todo {<br/> id: number;<br/> title: string;<br/> done: boolean;<br/>}</span><span id="131d" class="na lg it kr b gy nq nc l nd ne">// plainToClass method will convert<br/>// JSON data to Todo class object<br/>// Storing the new class object in<br/>// a typescript variable<br/>let todoClass = plainToClass(Todo, jsonData);</span><span id="24dd" class="na lg it kr b gy nq nc l nd ne">// Logging the output to the console<br/>console.log(todoClass);</span></pre><p id="6838" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出:</strong></p><pre class="ku kv kw kx gt mw kr mx my aw mz bi"><span id="7f71" class="na lg it kr b gy nb nc l nd ne">Todo {<br/>  id: 1,<br/>  title: 'Upgrade typescript runtime validation with class decorators',<br/>  done: true<br/>}</span></pre><h1 id="8c8a" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">第2/2部分用类验证器装饰器进行验证</h1><p id="a645" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">允许使用基于装饰和非装饰的验证。内部使用<a class="ae ks" href="https://github.com/chriso/validator.js" rel="noopener ugc nofollow" target="_blank"> validator.js </a>执行验证。<code class="fe ko kp kq kr b"><a class="ae ks" href="https://www.npmjs.com/package/class-validator" rel="noopener ugc nofollow" target="_blank">class-validator</a></code>可在浏览器和node.js平台上运行。</p><p id="20fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要添加那些装饰者</p><pre class="ku kv kw kx gt mw kr mx my aw mz bi"><span id="3c2e" class="na lg it kr b gy nb nc l nd ne">import { IsBoolean, IsNumber, IsString, validate } from "class-validator";</span><span id="e2f0" class="na lg it kr b gy nq nc l nd ne">class Todo {<br/>  @IsNumber()<br/>  id: number;</span><span id="69b2" class="na lg it kr b gy nq nc l nd ne">  @IsString()<br/>  title: string;</span><span id="3d4c" class="na lg it kr b gy nq nc l nd ne">  @IsBoolean()<br/>  done: boolean;<br/>}</span></pre><p id="f909" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后</p><pre class="ku kv kw kx gt mw kr mx my aw mz bi"><span id="f30e" class="na lg it kr b gy nb nc l nd ne">const jsonData = {<br/>  "id": 1,<br/>  "title": "Upgrade typescript runtime validation with class decorators",<br/>  "done": false,<br/>}<br/>const convertedClass = plainToClass(Todo, jsonData);<br/>console.log(convertedClass);</span><span id="30f7" class="na lg it kr b gy nq nc l nd ne">validate(todoClass).then((errors) =&gt; {<br/>  console.log(errors); // here handle errors such as logging, throwing, alerting<br/>});</span></pre><p id="c82f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请随意查看<a class="ae ks" href="https://www.npmjs.com/package/class-validator" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">正式文档</strong> </a>了解更多特性，如值验证、嵌套验证、定制消息…等</p><h2 id="d77d" class="na lg it bd lh nf ng dn ll nh ni dp lp kb nj nk lt kf nl nm lx kj nn no mb np bi translated">延伸阅读:</h2><ul class=""><li id="41b8" class="mi mj it js b jt md jx me kb nr kf ns kj nt kn mn mo mp mq bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/typescript-must-know-fundamentals-for-your-next-tech-interview-or-project-255ae70df0a3"> TypeScript必备基础知识—类型别名和接口</a></li><li id="6067" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/use-typescript-keyof-like-a-pro-56f3a3d06b73">像专家一样使用打字键盘</a></li><li id="81d8" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/typescript-classes-from-zero-to-hero-a429a3c96189">打字稿类——从零到英雄</a></li><li id="68aa" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">掌握类型脚本泛型:终极指南</li><li id="c096" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">打字技巧和提示:立刻成为专业人士</li><li id="f813" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/generics-in-typescript-must-know-fundamentals-stupidly-simplified-e7b4d7ffc0e3">TypeScript中的泛型——愚蠢简化的基础知识</a></li><li id="c0f9" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/typescript-missed-this-but-you-shouldnt-runtime-type-validation-aa8a81ce4289"> Typescript遗漏了这一点，但你不应该—运行时类型验证</a></li><li id="ff23" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/typescript-enum-pitfalls-and-solutions-must-know-bb971cb0f7d2"> Typescript枚举陷阱和解决方案必须知道</a></li><li id="27e6" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae ks" href="https://bootcamp.uxdesign.cc/mastering-typescript-generics-the-ultimate-guide-essential-interface-techniques-86e793cf1fc" rel="noopener" target="_blank">掌握类型脚本泛型—终极指南—基本接口技术</a></li><li id="0a9f" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated">【Javascript开发者经常忽略的Typescript特性</li><li id="bc34" class="mi mj it js b jt mr jx ms kb mt kf mu kj mv kn mn mo mp mq bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/mastering-intersection-and-union-types-in-typescript-the-ultimate-guide-essential-techniques-49aa9f6a188a">掌握TypeScript中的交集和并集类型:终极指南和基本技术</a></li></ul></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="1881" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你觉得这个指南有帮助，请鼓掌并跟我来。通过<a class="ae ks" href="https://medium.com/@caopengau/membership" rel="noopener">链接</a>加入medium，获取我和所有其他优秀作家在medium上发表的所有优质文章。</p></div></div>    
</body>
</html>