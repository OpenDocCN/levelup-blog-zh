<html>
<head>
<title>Quick Sort Algorithm Visually Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速排序算法直观解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/quick-sort-algorithm-visually-explained-bc691dba7662?source=collection_archive---------10-----------------------#2020-04-14">https://levelup.gitconnected.com/quick-sort-algorithm-visually-explained-bc691dba7662?source=collection_archive---------10-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0002fdb5ee5c65427147c5b11113827f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8pGWQBEkaZPrJaqW.jpg"/></div></div></figure><p id="6cdb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像大多数排序算法一样，快速排序算法按升序对项目数组进行排序。快速排序有多种方法。本文将重点介绍一种方法。这种方法选择数组最左边的元素作为支点。然后将它与数组中的最后一个元素进行比较。如果枢纽小于它所比较的元素，该元素将成为枢纽，左侧将递增。如果透视大于与之比较的元素，则该元素的索引值将递增。这种情况一直持续到左侧和右侧相遇。一旦这些值相遇，它们相遇的元素就被排序了。创建了左右分区，并生成了新的轴心点。</p><p id="83ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此版本的快速排序算法将遵循以下规则:</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi kz"><img src="../Images/4d66c9568a19f265b723531fc769ad70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7p-a916R8sOS_phfSKR_mQ.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/432ae17044f0339d2a9c4b0a920235f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6D3JEm9YfX_viddn6gMiw.png"/></div></div></figure><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lf"><img src="../Images/e34f2ebd0fbc34661ee1b19312469e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsEzA9Eg6koLFMRQTZbdRg.png"/></div></div></figure><p id="f0de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这只是快速排序算法的一种方法。我们现在来看一个例子。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lg"><img src="../Images/e4a0c8edbc9cda4b8150e6bfc1ba95ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bdf7WGoWQj6B_15XldSMPw.png"/></div></div></figure><p id="a99f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">索引0处的左侧元素被设置为透视值，右侧元素被设置为数组中的最后一个元素。透视值与右侧元素进行比较。由于右值小于主值，右值与主值交换，右值成为新的主值；左索引递增。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lh"><img src="../Images/b3b843ea0d898416d5f2569c23bab120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GrBsiTVwvGjwwLoiWX14oQ.png"/></div></div></figure><p id="87cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，将新的透视值与索引1处的值进行比较。由于pivot大于left值，因此pivot保持在当前位置，left元素递增。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi li"><img src="../Images/7c38b5d22fe3e93b1e26f0996c6438da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pq99pT8Z-J0RHGA4zWf3uA.png"/></div></div></figure><p id="1a5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快速排序算法将pivot与left进行比较。因为轴值不大于左值，所以轴值与左值交换。索引2成为新的枢纽，右索引递减。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lj"><img src="../Images/805e5a6965ba07b1fcda03f913798d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5qVhr8mSKHwbozb_sKBGw.png"/></div></div></figure><p id="a85b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，将索引2处的新透视与索引4处的值进行比较。因为5不小于3，所以交换这些值，并且增加左索引值。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lk"><img src="../Images/6b1aa47f83437ec95ea176a158b9e18d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hL4G9jjPsOLS5vAK4pCX_w.png"/></div></div></figure><p id="0920" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快速排序算法将透视值与左侧值进行比较。由于pivot值大于left值，因此左索引递增。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ll"><img src="../Images/84fd98e45486619153cf81597b0aeb20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gX9YhkGTYn4__Mg20pc2Gg.png"/></div></div></figure><p id="e509" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，左右箭头都指向同一个元素。算法知道这个值是排序的。创建左和右分区。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lm"><img src="../Images/9d63b27a23d413c92391384bd9a65fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UvgB1zmZfBxNc3zfPtYDZQ.png"/></div></div></figure><p id="ae3c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">算法开始在左边的分区上工作。索引0处的值成为新的枢纽。左箭头指向透视值，右箭头指向左分区中的最后一个元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ln"><img src="../Images/9f9a45d197a3677ff24284d789457dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qhBgX_stJ7SuD5U1UPd1Fw.png"/></div></div></figure><p id="0f4d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将枢轴值与右值进行比较。由于枢轴大于右侧值，所以两个值互换。索引3成为新的枢纽，并且左索引值递增。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lo"><img src="../Images/59d39b46070181c80b2efa0e04645595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZjnJ3jfIRFtpVYI-law-Kg.png"/></div></div></figure><p id="a602" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该算法将透视值与索引1处的值进行比较。因为枢纽值较大，所以左索引值会递增。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lp"><img src="../Images/68def9d51227186c30d643363f2af50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W7yABGqFC9wcgUejiwNZBg.png"/></div></div></figure><p id="83d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该算法将透视值与索引2处的值进行比较。因为枢纽值较大，所以左索引值会递增。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ln"><img src="../Images/c7a92aeb9067b1c55251fc4b94fd7413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5X056-dn2bNqX4_x6cTTUQ.png"/></div></div></figure><p id="fec5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">左箭头和右箭头在同一元素相遇。快速排序算法现在知道索引3处的值已排序。创建新的分区。由于透视右侧没有未排序的值，因此只创建了左侧分区。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lq"><img src="../Images/86dc4ef9f0385203b6d46283bf8f5231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGTI0v4AGrCtV0THVnwTeg.png"/></div></div></figure><p id="422e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该算法开始在新的左分区上工作，因为它仍然在旧的左分区内。它将索引0指定为透视值，并将左箭头指向它。右箭头指向新的左分区中的最后一个元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lr"><img src="../Images/711f50c6025f29e732fe3d59d63c692b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gQFj2YRkZKQoqOg-fJnxcA.png"/></div></div></figure><p id="a4a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该算法首先将枢轴值与右侧值进行比较。因为枢纽值小于右值，所以右索引递减。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ls"><img src="../Images/53917869803370f6325021e4fa10f501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rpjSg15JjXt1wnrqUzopCg.png"/></div></div></figure><p id="4629" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，比较索引0和1处的值。因为枢纽值较小，所以右边的值会减少。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lo"><img src="../Images/ac218a6f3367dbd5996cc0ad28d3a1c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-V5mLKbMJ37FioA_mGFlQ.png"/></div></div></figure><p id="a6fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">左右箭头在索引0处相遇。快速排序算法知道索引0处的值现在已排序。创建新的分区。由于透视左侧没有值，因此只创建了右侧的分区。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lt"><img src="../Images/bec28c33be6b419981246f04dfdb4bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Sue50qG_v204tEpY13xng.png"/></div></div></figure><p id="a151" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于算法仍然在左分区内，它开始在新的右分区上工作。枢轴和左箭头都指向索引1；右箭头指向索引2。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lu"><img src="../Images/52775612aed9991808e7bfc7f792847a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xvUhzupKU3Ax_dZ7E1x7Fg.png"/></div></div></figure><p id="244f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">比较索引1和2处的值。因为枢纽值小于右值，所以右索引递减。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lv"><img src="../Images/de189a622912686112db3aa5afdcf6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lv1FzmpglAlsPYtVieIzKA.png"/></div></div></figure><p id="2dc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">左右箭头在索引1处相遇。该算法知道索引1处的值已排序。创建新的分区。因为在这个分区中，索引1的左边没有未排序的元素，所以只创建右边的分区。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lw"><img src="../Images/3b5d18a880fcc9479c08a20723797b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Isk7QYjSLANfsyYWHtXlMg.png"/></div></div></figure><p id="8bc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为快速排序算法仍然在第一个左分区内，所以它开始在新的右分区上工作。它将枢轴、左箭头和右箭头指向索引2，因为这是该分区中的唯一元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lr"><img src="../Images/70c5e6a0ad8c5afa02bc78c99b0220b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vj05x_Qm11bVsG6A2iqEjA.png"/></div></div></figure><p id="e233" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">箭头在索引2处相遇，因此算法知道索引2处的值现在已排序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lr"><img src="../Images/5765fb2bf53bb1b05f3508811f1874ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qD69pHD6GC3fIgRuv1Sybg.png"/></div></div></figure><p id="a3c8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快速排序算法终于走出了第一个左边的分区，并开始处理右边的分区。它将枢轴、左箭头和右箭头指向唯一可用的元素。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lx"><img src="../Images/817e99c4de1b32d2c18e2657e2afabb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RerqJiHWUw_JB5lA1uvq-Q.png"/></div></div></figure><p id="7f54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为两个箭头都指向同一个元素，所以该算法断定索引5处的值现在已排序。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lj"><img src="../Images/ffe0316a64c03c2b48f7dd883670bbd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYFcIY2aLPq0WwIT4oNl0Q.png"/></div></div></figure><p id="2054" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为没有其他分区要排序，所以快速排序算法结束。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ly"><img src="../Images/5aca370c4f9fdad1c55015559aadf1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*amatWrTiN7wOKOsjlaZ3WQ.png"/></div></div></figure><blockquote class="lz"><p id="8a6d" class="ma mb it bd mc md me mf mg mh mi ky dk">***</p></blockquote><p id="3661" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">如果你喜欢你所读的，我的书，<a class="ae mp" href="https://www.amazon.com/Illustrative-Introduction-Algorithms-Dino-Cajic-ebook-dp-B07WG48NV7/dp/B07WG48NV7/ref=mt_kindle?_encoding=UTF8&amp;me=&amp;qid=1586643862" rel="noopener ugc nofollow" target="_blank"><em class="mo"/></a><em class="mo">【算法的说明性介绍】，涵盖了这个算法和更多。</em></p><h1 id="0865" class="mq mr it bd ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn bi translated">我的书:算法的说明性介绍</h1><figure class="la lb lc ld gt ju gh gi paragraph-image"><div class="gh gi no"><img src="../Images/bcf5d7a3eedd66065fc04a47710a35ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*SRjQgwZZ2UQZdxNb.jpg"/></div></figure><p id="4714" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这本书是为了填补计算机科学学生和程序员试图学习和分析目前存在的不同算法的空白而写的。我上了一门算法课程，对目前可用的材料类型感到失望。我经常碰到两种类型的书:</p><ul class=""><li id="b36b" class="np nq it kd b ke kf ki kj km nr kq ns ku nt ky nu nv nw nx bi translated">第一，过于复杂的书。这本书看起来像是为那些已经对这个主题很熟悉，并且想要一个更详细的数学算法的人设计的。</li><li id="bd26" class="np nq it kd b ke ny ki nz km oa kq ob ku oc ky nu nv nw nx bi translated">第二，过于简单的书。算法的基本介绍。这是对一些算法的高级概述，大部分复杂的算法都没有提到。完成后，这个人仍然不能展示当出现问题时算法是如何运行的。</li></ul><p id="899d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这本书是为想要扩展视野的大学高年级学生和程序员设计的。它可以和复杂的书一起作为补充的书。读者将获得必要的知识来解决那些复杂的书中提出的数学密集型算法问题。每章包括一个简单的描述算法是如何工作的，然后是一个或两个详细的例子。遍历过程中不会跳过任何步骤。给读者呈现一个清楚的，简化的方法来解决本章致力于的算法。</p><p id="703e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每一章都遵循前一章的自然发展。如果某些算法很大程度上依赖于先验知识，前一章会讨论这个话题。例如，Kruskal的算法严重依赖于最小生成树和贪婪算法的先验知识。每个主题都有自己的一章。</p><p id="e632" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在可以在<a class="ae mp" href="https://www.amazon.com/Illustrative-Introduction-Algorithms-Dino-Cajic-ebook-dp-B07WG48NV7/dp/B07WG48NV7/ref=mt_kindle?_encoding=UTF8&amp;me=&amp;qid=1586643862" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"/></a>买到</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/c6686d9cf964faa0d2678692582e41a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P_wlT0iZ1kvuGAl6.jpeg"/></div></div></figure><p id="db1c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">迪诺·卡伊奇目前是<a class="ae mp" href="https://www.lsbio.com/" rel="noopener ugc nofollow" target="_blank"> LSBio(生命周期生物科学公司)</a>、<a class="ae mp" href="https://absoluteantibody.com/" rel="noopener ugc nofollow" target="_blank">绝对抗体</a>、<a class="ae mp" href="https://www.kerafast.com/" rel="noopener ugc nofollow" target="_blank"> Kerafast </a>、<a class="ae mp" href="https://everestbiotech.com/" rel="noopener ugc nofollow" target="_blank">珠穆朗玛生物</a>、<a class="ae mp" href="https://www.nordicmubio.com/" rel="noopener ugc nofollow" target="_blank">北欧MUbio </a>和<a class="ae mp" href="https://www.exalpha.com/" rel="noopener ugc nofollow" target="_blank"> Exalpha </a>的IT主管。他还担任我的自动系统的首席执行官。他有十多年的软件工程经验。他拥有计算机科学学士学位，辅修生物学。他的背景包括创建企业级电子商务应用程序、执行基于研究的软件开发，以及通过写作促进知识的传播。</p><p id="d148" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在<a class="ae mp" href="https://www.linkedin.com/in/dinocajic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系他，在<a class="ae mp" href="https://instagram.com/think.dino" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上关注他，或者<a class="ae mp" href="https://dinocajic.medium.com/subscribe" rel="noopener">订阅他的媒体出版物</a>。</p><p id="4f87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae mp" href="https://dinocajic.medium.com/membership" rel="noopener"> <em class="mo">阅读迪诺·卡吉克(以及媒体上成千上万其他作家)的每一个故事。你的会员费直接支持迪诺·卡吉克和你阅读的其他作家。你也可以在媒体上看到所有的故事。</em> </a></p></div></div>    
</body>
</html>