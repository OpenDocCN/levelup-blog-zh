<html>
<head>
<title>React’s useImperativeHandle made simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React的useImperativeHandle变得简单</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/reacts-useimperativehandle-made-simple-81035a21eef0?source=collection_archive---------3-----------------------#2020-06-30">https://levelup.gitconnected.com/reacts-useimperativehandle-made-simple-81035a21eef0?source=collection_archive---------3-----------------------#2020-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn js jt ju jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi jr"><img src="../Images/4722c5ded2089331b6de6808c0f6a649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E_0jTgz9-16cdzSb"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">Mick Haupt 在<a class="ae kg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7d11" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">一般的React风格是数据和逻辑单向流动；也就是说，您应该通过props向下传递函数和数据，组件应该只能访问作为props传入的内容。在需要双向或横向数据流的情况下，我们可以使用Redux或React的上下文API等库。</p><p id="e0ae" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kj ir">然而，</strong>在某些情况下，导入redux或使用context简直就是矫枉过正——这就是<code class="fe jn jo jp jq b">useImperativeHandle</code>的用武之地。这将为我们提供一个轻量级的双向流解决方案。考虑下面的例子:</p><p id="4599" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我们有一个<code class="fe jn jo jp jq b">Settings</code>组件，允许用户定制他们的用户设置和可访问性设置:</p><figure class="lf lg lh li gt jv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="a0ac" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这是标准的做事方式；有一个传入状态的父组件和该状态的更新函数。当用户点击提交按钮时，我们将把用户和可访问性设置提交给它们各自的端点。虽然这种方法可行，但也有一些缺点:</p><p id="c9fb" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kj ir"> <em class="ll"> a)设置组件内部的任何东西都可以修改设置的任何一个状态，即使这些状态应该被隔离到它们各自的组件</em> </strong></p><p id="4371" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><strong class="kj ir"> <em class="ll"> b)当onSubmit在任一子设置组件</em> </strong>内被调用时，我们无法监听</p><p id="3017" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我们可以通过使用<code class="fe jn jo jp jq b">useImperativeHandle</code>来改变这一点。这允许我们通过引用来公开子组件内部的函数。让我们修改一下之前的代码:</p><figure class="lf lg lh li gt jv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="de61" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">所以我们用<code class="fe jn jo jp jq b">useRef</code>创建了一个ref，然后通过一个叫做<code class="fe jn jo jp jq b">passedInRef</code>的属性将这个ref传递给UserSettings。然后我们用<code class="fe jn jo jp jq b">passedInRef</code>和一个函数调用<code class="fe jn jo jp jq b">useImperativeHandle</code>。我们的函数返回了一个对象。该对象将被存储在<code class="fe jn jo jp jq b">passedInRef.current</code>中。在我们的对象中，我们定义了一个<code class="fe jn jo jp jq b">submit</code>函数。所以现在父对象可以调用<code class="fe jn jo jp jq b">userSettings.current.submit()</code>并提交<code class="fe jn jo jp jq b">userSettings</code>。</p><p id="665d" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">咻！那是很难接受的。<strong class="kj ir">但是现在我们可以确定我们的userSettings状态被隔离到了</strong> <code class="fe jn jo jp jq b"><strong class="kj ir">UserSettings</strong></code> <strong class="kj ir">组件</strong>——让我们探索第二个优点；当<code class="fe jn jo jp jq b">submit</code>被调用时被通知。因为我们现在可以在提交被调用时得到通知(在<code class="fe jn jo jp jq b">UserSettings</code>的上下文中)，所以我们可以将验证消息之类的东西应用到<code class="fe jn jo jp jq b">UserSettings</code>组件:</p><figure class="lf lg lh li gt jv"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="d5be" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">以前，这只能通过引入像context或redux这样重量级的东西来实现，但是有了<code class="fe jn jo jp jq b">useImperativeHandle</code>,我们可以用一种更加轻量级的方式来实现同样的事情，允许我们在失败时在<code class="fe jn jo jp jq b">UserSettings</code>组件内部显示一条错误消息。</p><h1 id="34cd" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="0a49" class="pw-post-body-paragraph kh ki iq kj b kk mk km kn ko ml kq kr ks mm ku kv kw mn ky kz la mo lc ld le ij bi translated"><code class="fe jn jo jp jq b">useImperativeHandle</code>为双向数据和逻辑流提供redux和props之间的中间地带。这不是你经常使用的东西，但在极少数情况下，它非常有用，可以防止你不得不过度使用redux这样的极端解决方案，或者绞尽脑汁想出像传入多个道具、状态更新器和孤立的错误消息这样的解决方案——后者是最难的。</p></div></div>    
</body>
</html>