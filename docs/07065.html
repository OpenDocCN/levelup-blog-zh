<html>
<head>
<title>File and Directory Backup, Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">文件和目录备份，第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/file-and-directory-backup-part-1-5be98cd7441e?source=collection_archive---------8-----------------------#2021-01-21">https://levelup.gitconnected.com/file-and-directory-backup-part-1-5be98cd7441e?source=collection_archive---------8-----------------------#2021-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0b5d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Python和PyQt5</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/07ee1bc1b026f425580c589e96a4b6f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vwgDhuaTIaJDypMZvYKrsQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">来自Unsplash的Jan Antonin Kolar的照片</figcaption></figure><p id="da7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们都知道备份文件很重要。我想用python写自己的备份程序。这个项目可以从Github下载，网址是:</p><p id="e854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">https://github.com/zazen000/File-and-Directory-Backup<a class="ae kv" href="https://github.com/zazen000/File-and-Directory-Backup" rel="noopener ugc nofollow" target="_blank"/></p><p id="696d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的要求是在程序运行时，不要引人注目，只显示一条小消息。很简单，对吧？毕竟，这是有着过多内部和外部模块的python。</p><p id="f182" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我花了很长时间完成最后一部分，需要三个独立的文件，我们将会看到。但是，首先，主备份程序的导入。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="57f9" class="lx ly iq lt b gy lz ma l mb mc">import os</span><span id="158a" class="lx ly iq lt b gy md ma l mb mc">import sys</span><span id="93f9" class="lx ly iq lt b gy md ma l mb mc">import time</span><span id="f94d" class="lx ly iq lt b gy md ma l mb mc">import filecmp</span><span id="07ad" class="lx ly iq lt b gy md ma l mb mc">import subprocess</span></pre><p id="fb0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要设置想要备份的源和目标目录。我在一个元组中有10个源/目标对:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="b83b" class="lx ly iq lt b gy lz ma l mb mc">dirs = <em class="me">(</em><br/> <em class="me">(</em>r”C:\Users\mount\source\repos”, r”M:\_BACKUP\REPOS”<em class="me">)</em>,<br/> <em class="me">(</em>r”D:\mount\Downloads”, r”M:\_BACKUP\DOWNLOADS”<em class="me">)</em>,<br/> <em class="me">(</em>r”D:\mount\Documents”, r”M:\_BACKUP\DOCUMENTS”<em class="me">)</em>,<br/> <em class="me">(</em>r”D:\Internet-Marketing”, r”M:\_BACKUP\IM”<em class="me">)</em>,<br/> <em class="me">(</em>r”D:\_HOLOSYNC”, r”M:\_BACKUP\HOLOSYNC”<em class="me">)</em>,<br/> <em class="me">(</em>r”D:\mount\Music”, r”M:\_BACKUP\MUSIC”<em class="me">)</em>,<br/> <em class="me">(</em>r”D:\_BIZ”, r”M:\_BACKUP\BIZ”<em class="me">)</em>,<br/> <em class="me">(</em>r”D:\_PWA”, r”M:\_BACKUP\PWA”<em class="me">)</em>,<br/> <em class="me">(</em>r”C:\data\db”, r”M:\_BACKUP\DB”<em class="me">)</em>,<br/> <em class="me">(</em>r”C:\ProgramData\MongoDB”, r”M:\_BACKUP\MONGODB “<em class="me">)</em>,<br/> <em class="me">)</em></span></pre><p id="5878" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于每一行，第一个参数是源目录，第二个参数是目标目录。如你所见，这几乎是我电脑上的所有数据目录。现在来写一些函数。</p><p id="63d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用robocopy.exe的<em class="me">作为复制引擎。Robocopy将现有的源目录复制到现有的目的目录，但是如果目的目录不存在呢？我们需要一个函数来检查并建立一个子目录，如果它没有。</em></p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="0d6b" class="lx ly iq lt b gy lz ma l mb mc">def ensure_directory<em class="me">( </em>destination <em class="me">)</em>:</span><span id="47ef" class="lx ly iq lt b gy md ma l mb mc">    directory = os.path.dirname<em class="me">( </em>destination <em class="me">)</em><br/>    if not os.path.exists<em class="me">( </em>directory <em class="me">)</em>:<br/>    os.makedirs<em class="me">( </em>directory <em class="me">)</em></span></pre><p id="5271" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<em class="me">确保目录</em>检查目标文件夹是否存在。如果没有，则<em class="me">操作系统</em>创建目录。</p><p id="b998" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要比较源目录和目标目录的内容。如果它们不匹配(大小、日期等)，则启动复制例程。所以，当然，我们需要一个函数来比较目录。我叫它，<em class="me">比较_目录</em>。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="d350" class="lx ly iq lt b gy lz ma l mb mc">def compare_directories<em class="me">( </em>source, destination <em class="me">)</em>:</span><span id="c26c" class="lx ly iq lt b gy md ma l mb mc">    try:<em class="me"><br/>        </em>comp = filecmp.dircmp<em class="me">( </em>source, destination <em class="me">)<br/>        </em>common = sorted<em class="me">( </em>comp.common <em class="me">)<br/>    </em>except:<em class="me"><br/>        </em>return False<em class="me"><br/> <br/>    </em>left = sorted<em class="me">( </em>comp.left_list <em class="me">)<br/>    </em>right = sorted<em class="me">( </em>comp.right_list <em class="me">)<br/>    </em>if left != common or right != common:<em class="me"><br/>    </em>return False<em class="me"><br/> <br/>    </em>if len<em class="me">( </em>comp.diff_files <em class="me">)</em>:<em class="me"><br/>    </em>return False<em class="me"><br/> <br/>    </em>for subdir in comp.common_dirs:<em class="me"><br/>    </em>left_subdir = os.path.join<em class="me">( </em>source, subdir <em class="me">)<br/>    </em>right_subdir = os.path.join<em class="me">( </em>destination, subdir <em class="me">)<br/>    </em>return compare_directories<em class="me">( </em>left_subdir, right_subdir <em class="me">)<br/> <br/>    </em>return True</span></pre><p id="f5b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<em class="me"> filecmp.dircmp </em>，将源目录与目标目录进行比较，并对对象进行排序。有三种可能会返回布尔值False，从而启动备份序列。</p><p id="c2d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<em class="me"> sorted(comp.common) </em>有错误，则返回False。</p><p id="f4d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<em class="me">排序(比较左列表)</em>或<em class="me">排序(比较右列表)</em>对象不同于<em class="me">排序(比较公共)</em>对象，则返回False。</p><p id="5105" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，如果源目录和目标目录中的文件数量不同，则返回False。</p><p id="6ed2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当三个都为真时，返回一个真；不需要后援。</p><p id="4b53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我决定在我的项目中添加日志功能。在研究<em class="me"> robocopy的时候，</em>我发现它有一个丰富的日志工具包。这意味着我们需要另一个函数，<em class="me"> log_directory </em>。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="0cc3" class="lx ly iq lt b gy lz ma l mb mc">def log_directory<em class="me">()</em>:</span><span id="7581" class="lx ly iq lt b gy md ma l mb mc">    now = time.strftime<em class="me">(</em>“%Y-%m-%d___%H-%M”<em class="me">)</em><br/>    direct = os.path.dirname<em class="me">(</em>“C:\\Users\\mount\\source\\repos\\MyDashboard\\LOG\\”<em class="me">)</em><br/>    directory = direct + ‘\\’ + now + ‘\\’</span><span id="8d1a" class="lx ly iq lt b gy md ma l mb mc">    if not os.path.exists<em class="me">( </em>directory <em class="me">)</em>:<br/>        os.makedirs<em class="me">( </em>directory <em class="me">)</em></span><span id="190e" class="lx ly iq lt b gy md ma l mb mc">    return directory</span></pre><p id="1d23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一行创建日期/时间字符串。该函数的第二行指向存储日志目录的路径。如果语句写入文件夹，则第三行命名文件夹和<em class="me">。</em></p><p id="3d02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="me"> Robocopy </em>使用<em class="me"> _BACKUP.log </em>作为它的日志文件名，并且为每个源/目标对拷贝序列写入，或者在我们的例子中，写入10次。然后我发现，对于每次备份运行，可以将单独的日志附加到一个日志文件中。问题解决了！</p><p id="0371" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不完全是。</p><p id="c4d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我早上备份了一次，下午又备份了一次。当我去检查日志文件时，只有一个，因为旧的那个被覆盖了。</p><p id="ac1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何更改每个备份的文件名？当时，我不知道。</p><p id="9e8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想到的解决方案是创建一个文件夹，并以备份的日期和时间命名。该运行的<em class="me"> _BACKUP.log </em>放在该文件夹中。</p><p id="5ed1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，您可以根据日期和时间来命名文件本身，而放弃多个目录。</p><p id="0d02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个源/目标对的日志文件的样子。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="b0af" class="lx ly iq lt b gy lz ma l mb mc"> — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — <br/> ROBOCOPY :: Robust File Copy for Windows <br/> — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — <br/> <br/> Started : Monday, January 18, 2021 7:53:59 PM<br/> Source : C:\Users\mount\source\repos\<br/> Dest : M:\_BACKUP\REPOS\<br/> <br/> Files : *.*<br/> <br/> Options : *.* /S /DCOPY:DA /COPY:DAT /XX /XO /MT:128 /R:2 /W:5 <br/> <br/> — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — <br/> <br/> Newer 353 C:\Users\mount\source\repos\trading\get_symbols.py<br/> 100% <br/> Newer 26307 C:\Users\mount\source\repos\trading\ubStock_Research.py<br/> 100% <br/> — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — </span><span id="2d0b" class="lx ly iq lt b gy md ma l mb mc">        Total  Copied Skipped Mismatch FAILED Extras<br/>  Dirs : 618    618    612      0        0      89<br/> Files : 34096   9     34087    0        0     119<br/> Bytes : 2.964g 76.6k  2.964g   0        0     108.21 m<br/> Times : 0:01:09 0:00:16 0:00:00 0:00:15</span></pre><p id="b13e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些日志中的一个被附加到序列中十个源/目标对的日志文件中。现在来写一些逻辑。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="642d" class="lx ly iq lt b gy lz ma l mb mc">count = 0<br/>logg = log_directory<em class="me">()</em><br/>lenn = len<em class="me">(</em>dirs<em class="me">)</em></span></pre><p id="26a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们初始化一些变量。<em class="me"> logg </em>调用<em class="me"> log_directory </em>，c<em class="me">count</em>被初始化为0，并且<em class="me"> lenn </em>是dirs的长度，我们的源/目的地对列表。</p><p id="1a17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在继续之前，我想展示一下<em class="me"> robocopy </em>的语法:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="adc9" class="lx ly iq lt b gy lz ma l mb mc">&gt;robocopy source_directory destination_directory switches</span></pre><p id="6b69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们为上述参数分配变量。</p><p id="8721" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">src =源目录<br/> dst =目标目录<br/>swt = robo copy的开关</p><p id="a328" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些是我使用的开关及其用途:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="825c" class="lx ly iq lt b gy lz ma l mb mc"> /xo = only newer versions of file,<br/> /s = all occupied sub-directories,<br/> /MT:nn = # of threads (maximum=128, default=8)<br/> /xx = copy source file even when destination file does not exist<br/> /LOG+ = a log is created for every d in dirs. /LOG+ appends all logs to one file<br/> /r:n = number of times to retry, default = 1,000,000<br/> /w:nn = number of seconds to wait before retrying</span></pre><p id="3f54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，所使用的开关在备份日志中的Options:下有注释。</p><p id="15e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以迭代通过<em class="me"> dirs </em>。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="e2ca" class="lx ly iq lt b gy lz ma l mb mc">for dir in dirs:</span><span id="4097" class="lx ly iq lt b gy md ma l mb mc">    count += 1<br/>    src, dst, swt = dir<em class="me">[</em>0<em class="me">]</em>, dir<em class="me">[</em>1<em class="me">]</em>, f”/XX /r:2 /xo /s /w:5 /MT:128 /LOG+:<em class="me">{</em>logg<em class="me">}</em>_BACKUP.log”</span><span id="2fbb" class="lx ly iq lt b gy md ma l mb mc">    status = <em class="me">(</em>compare_directories<em class="me">(</em>src, dst<em class="me">))</em></span></pre><p id="35c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剩下的代码。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="ce72" class="lx ly iq lt b gy lz ma l mb mc">    if status == False:<br/> <br/>        ensure_directory<em class="me">( </em>dst <em class="me">)</em><br/>        compare_directories<em class="me">( </em>src, dst <em class="me">)</em><br/>        cmnd = f”robocopy <em class="me">{</em>src<em class="me">} {</em>dst<em class="me">} {</em>swt<em class="me">}”</em><br/>        copi = subprocess.Popen<em class="me">( </em>cmnd, shell=False <em class="me">)</em><br/>        code = copi.wait<em class="me">()</em><br/> <br/>     codes = range(0,9)<br/> <br/>     if count == lenn and code in codes:<br/>         write_txt_file<em class="me">( “</em>oo.txt”, “this file has changed!” <em class="me">)</em><br/> <br/> sys.exit<em class="me">()</em></span></pre><p id="e7b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<em class="me"> compare_directories </em>返回False时，<em class="me"> if status == False </em>语句生效。首先，我们确定目标目录是否存在，如果不存在就创建它们。然后，<em class="me">比较目录</em>再次被调用。</p><p id="a1bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，初始化robocopy复制序列的变量。剩下的代码是我在尝试将这个程序与显示“工作中…”标签的GUI集成时遇到的一个问题的解决方案。</p><p id="3108" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们去掉上面的五行代码，这个程序应该运行得很好(实际上，它运行得很好)。那么，我们如何知道备份何时完成？我们怎么知道它是否在运行？</p><p id="9ce1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我花了点时间，但我想出了一个办法。</p><p id="006d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这是第二部分的内容。</p><p id="d19d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢阅读这样的故事，并想支持我成为一名作家，可以考虑每月5美元订阅Medium。作为会员，你可以无限制地访问媒体上的故事。如果你用我的<a class="ae kv" href="https://zenndogg-52643-medium.com/membership" rel="noopener ugc nofollow">链接</a>注册，我会赚一小笔佣金。</p></div></div>    
</body>
</html>