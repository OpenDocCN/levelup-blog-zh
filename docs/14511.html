<html>
<head>
<title>5 Advanced Git tips that all developers should know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">所有开发人员都应该知道的5个高级Git技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-advanced-git-tips-that-all-developers-should-know-15bf9b634847?source=collection_archive---------6-----------------------#2022-12-03">https://levelup.gitconnected.com/5-advanced-git-tips-that-all-developers-should-know-15bf9b634847?source=collection_archive---------6-----------------------#2022-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/faeaa6ab173c522f5f62f0aa22b7feec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VPEsNzAQ4Cgvc_1-"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><p id="8713" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章是继我的<a class="ae jg" href="https://medium.com/swlh/squash-and-rebase-git-basics-5cb1be1e0dac" rel="noopener"/>帖子之后的。</p><p id="3a54" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">许多开发人员以直接的“提交”、“拉”和“合并”方式来处理Git。然而，Git提供了大量的能力、技巧和技术，可以提高开发人员的技能。</p><p id="5743" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为“拉请求”和“代码审查”是任何开发人员工作中至关重要的一部分，所以理解Git的内部工作方式可以让您和您的同事在审查自己的工作时更加简单。</p><h1 id="6bdc" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">1.隐藏您的修正</h1><p id="1652" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">你始终致力于代码库，就像一个好的开发人员应该做的那样。保持一整天提交的运行时间表将有助于你记录当天你完成了什么。</p><p id="bd06" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就我个人而言，当我编码时，我会做一个“有内容的”提交，然后是一系列的“修正”提交。</p><ul class=""><li id="e72d" class="mh mi jj ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">也许我忘了检查一个文件？</li><li id="594c" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">代码不工作，所以我做了一个小改动</li><li id="5616" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">测试不再通过，所以我更新了代码库，直到他们通过</li></ul><p id="7a9b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在所有这些情况下，你的同事不会因为他们需要筛选的大量提交而感谢你，特别是如果这些提交包含一些应该是之前提交的一部分的小行。</p><p id="edd4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是<strong class="ki jk">交互式Rebase </strong>“修正”命令的用武之地。使用交互式Rebase，您可以重放一系列提交，并在此过程中进行更改。对于每次提交，您都会看到几个选项，例如:</p><ul class=""><li id="837c" class="mh mi jj ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><strong class="ki jk">挤压</strong> —使用提交，但是合并到先前的提交中</li><li id="d338" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><strong class="ki jk">删除</strong> —移除/删除此提交</li><li id="d582" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated"><strong class="ki jk">修正</strong> —类似于“挤压”，但是忽略提交消息</li><li id="f430" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">…还有更多吗</li></ul><p id="3581" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有许多小的提交，它们构成了一个更大的特性的一部分，那么“修复”在这里非常有用。</p><p id="8adc" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">举个简单的例子。我有5个提交，3个特性，1个bug修复和一个“修正”。理想情况下，修复提交应该是“特性B”的一部分，因此我们可以很容易地将其合并到“特性B”提交中，并放弃修复提交。</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mv"><img src="../Images/9e130fb219c24f03642347cda07afce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ForMNy2EFFtmPlGMn1Hvw.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">将“修正”提交压缩到先前提交中</figcaption></figure><p id="f2f6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此:</p><pre class="mw mx my mz gt na nb nc bn nd ne bi"><span id="908a" class="nf lf jj nb b be ng nh l ni nj"># Perform an interactive rebase on the last 3 commits<br/>git rebase -i HEAD~3</span></pre><p id="bdc4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Git现在将打开您最喜欢的编辑器(在我的例子中是VS代码),您将看到一个文本文件，其中列出了您的3次提交以及一些有用的文本。</p><blockquote class="nk nl nm"><p id="e053" class="kg kh nn ki b kj kk kl km kn ko kp kq no ks kt ku np kw kx ky nq la lb lc ld im bi translated"><strong class="ki jk">提示:</strong>要将VS代码设置为您的Git编辑器，运行以下命令:<br/> <code class="fe nr ns nt nb b">git config — global core.editor “code -w”</code></p></blockquote><pre class="mw mx my mz gt na nb nc bn nd ne bi"><span id="dbdc" class="nf lf jj nb b be ng nh l ni nj">pick f9738b8 Feature B<br/>pick 634966f Fixup<br/>pick 6cef066 Feature C<br/><br/># Rebase 6b4e8f3..6cef066 onto 6b4e8f3 (3 commands)<br/># ....</span></pre><p id="8b5c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在要做的最简单的事情就是把单词<code class="fe nr ns nt nb b">pick</code>(意思是“使用这个提交”)换成<code class="fe nr ns nt nb b">f</code>或者<code class="fe nr ns nt nb b">fixup</code>。</p><p id="5d43" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您保存并关闭编辑器时，交互式基础将自动:</p><ol class=""><li id="e12d" class="mh mi jj ki b kj kk kn ko kr mj kv mk kz ml ld nu mn mo mp bi translated">将您的历史倒回3次提交</li><li id="3b30" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld nu mn mo mp bi translated">一起重放提交“特性B”<strong class="ki jk">和</strong>“修正”提交</li><li id="0118" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld nu mn mo mp bi translated">提交“特性C”</li></ol><p id="1b86" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“修复”提交现在已经合并到您的干净树中，就好像它总是前一个提交的一部分一样！</p><blockquote class="nk nl nm"><p id="4b8d" class="kg kh nn ki b kj kk kl km kn ko kp kq no ks kt ku np kw kx ky nq la lb lc ld im bi translated"><strong class="ki jk">提示:</strong>使用<code class="fe nr ns nt nb b">s</code>或<code class="fe nr ns nt nb b">squash</code>将执行与<code class="fe nr ns nt nb b">fixup</code>相同的操作，但会保留您的提交消息，并将其合并到之前的提交消息中。</p></blockquote><h1 id="1984" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">2-重做上次提交</h1><p id="6544" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">你写了一些代码，但是你犯了一个错误！假设您意外地在提交中包含了一个不应该在那里的文件，一些测试结果可能不属于树。</p><p id="64f8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，<code class="fe nr ns nt nb b">git reset</code>前来救援。</p><p id="b41b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然您的大部分提交是好的，但这个额外的文件是不受欢迎的。您不能真正运行<code class="fe nr ns nt nb b">revert</code>,因为您不想撤销整个提交，只是在没有额外文件的情况下重新提交。</p><h2 id="c6bb" class="nv lf jj bd lg nw nx dn lk ny nz dp lo kr oa ob ls kv oc od lw kz oe of ma og bi translated">软复位</h2><p id="2b0d" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Git有两种类型的重置，软重置和硬重置。对于这个例子，<strong class="ki jk">软复位</strong>将简单地撤销您的最后一次提交并存放文件，为您再次提交做好准备。</p><pre class="mw mx my mz gt na nb nc bn nd ne bi"><span id="d4e6" class="nf lf jj nb b be ng nh l ni nj"># Run a "soft reset" on the last commit<br/>git reset --soft HEAD~1</span></pre><p id="2bdf" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦执行了重置，就好像提交从未发生过一样。您可以自由地从提交中“卸载”流氓文件，然后再次提交。</p><h2 id="221f" class="nv lf jj bd lg nw nx dn lk ny nz dp lo kr oa ob ls kv oc od lw kz oe of ma og bi translated">硬重置</h2><p id="4c8d" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">与软重置不同，硬重置将撤销提交，但不会暂存文件。相反，它们会被完全移除。</p><p id="9ab8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你这样做的时候要小心，因为你会删除你的提交，但是如果你想了解如何恢复它们，请继续往下读。</p><pre class="mw mx my mz gt na nb nc bn nd ne bi"><span id="bc82" class="nf lf jj nb b be ng nh l ni nj"># Delete the previous commit from the branch<br/>git reset --hard HEAD~1</span></pre><h1 id="6317" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">3 —樱桃采摘</h1><p id="3376" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">你已经开始了一个“spike”分支来测试一些新的功能，但是在几次提交之后，你意识到它就是不能工作。</p><p id="fe53" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，在这个分支中进行的提交可能是有用的，并且可能需要用到项目的其余部分。</p><p id="e0c9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不是合并整个“坏的”分支，你只是想<strong class="ki jk">“挑选”好的提交并丢弃其余的</strong>。</p><figure class="mw mx my mz gt iv gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/25b633dde64e96a269b27d078a9f7a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*mDKtT8yfLdYfQxLjq82-dQ.jpeg"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">从“坏分支”中挑选“好”提交</figcaption></figure><pre class="mw mx my mz gt na nb nc bn nd ne bi"><span id="5903" class="nf lf jj nb b be ng nh l ni nj"># Using git log to find the commit id (hash) of the good commit you want<br/><br/># Checkout the good branch<br/>git checkout goodbranch<br/><br/># Cherry pick into `good branch` the commit 634966f<br/>git cherry-pick 634966f</span></pre><p id="8c5e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在您挑选之后，Git将简单地将提交应用到当前分支。</p><p id="90c9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">确保您的传入提交与您当前的树很好地配合</p><p id="d0af" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，您可能遇到的任何合并冲突在这里仍然适用，所以要小心。</p><h1 id="fbcd" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">4 —改进提交消息</h1><p id="1ede" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">作为一个在我的主要工作中多产的代码审查者，我可以从第一手经验中说，好的“提交消息”对理解开发人员从代码库中想要什么大有帮助。</p><p id="21fc" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，我并不总是实践我所宣扬的，很多时候我会定期承诺，然后意识到我的信息并不完全是描述性的。</p><p id="9f4d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像Git中的大多数东西一样，有许多方法可以解决这个问题。</p><h2 id="f5d3" class="nv lf jj bd lg nw nx dn lk ny nz dp lo kr oa ob ls kv oc od lw kz oe of ma og bi translated">修改上次提交</h2><p id="79a4" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果你需要做的只是修改你最近的提交，那么<code class="fe nr ns nt nb b">git commit --amend</code>就是完美的命令。</p><p id="bdbe" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只需运行命令，编辑器就会打开。将显示您之前的提交消息，您可以简单地编辑该消息并关闭编辑器。</p><p id="4294" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后Git将“重放”您的提交，但是这次是用您新的有用的提交消息。</p><h2 id="98a8" class="nv lf jj bd lg nw nx dn lk ny nz dp lo kr oa ob ls kv oc od lw kz oe of ma og bi translated">修改多个提交</h2><p id="d7ac" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果你需要重写多个提交，或者，如果你需要重写的提交不是最近的，那么<strong class="ki jk">交互式Rebase </strong>可以帮助你。</p><p id="3296" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像<code class="fe nr ns nt nb b">fixup</code>一样，您可以让Git重放许多提交，然后对它们执行操作。但是，不使用<code class="fe nr ns nt nb b">f</code>(或<code class="fe nr ns nt nb b">fixup)</code>，我们将使用<code class="fe nr ns nt nb b">r</code>(或<code class="fe nr ns nt nb b">reword)</code>)。</p><pre class="mw mx my mz gt na nb nc bn nd ne bi"><span id="c6a1" class="nf lf jj nb b be ng nh l ni nj"># Perform an interactive rebase on the last 2 commits<br/>git rebase -i HEAD~2<br/><br/># Change the second commit (826cb5a) from pick to reword<br/>pick 6b4e8f3 Bug Fix<br/>reword 826cb5a Feature B<br/><br/># When you close the interactive editor,<br/># git will open a new editor for each commit you wish to edit</span></pre><p id="c34b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和以前一样，交互式rebase将自动运行以下过程:</p><ol class=""><li id="40d1" class="mh mi jj ki b kj kk kn ko kr mj kv mk kz ml ld nu mn mo mp bi translated">展开2次提交</li><li id="1867" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld nu mn mo mp bi translated">重放每次提交</li><li id="186c" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld nu mn mo mp bi translated">对于每个标记为<code class="fe nr ns nt nb b">r</code>的提交，打开一个新的文本编辑器来改写提交消息</li></ol><blockquote class="nk nl nm"><p id="ab5b" class="kg kh nn ki b kj kk kl km kn ko kp kq no ks kt ku np kw kx ky nq la lb lc ld im bi translated">reword功能是保持提交标题可读性的理想选择，同时使用其他行来更深入地解释提交的目标。这是因为大多数在线Git评审工具(Azure DevOps、GitHub等。)使用提交消息的第一行作为“标题”</p></blockquote><h1 id="04bd" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">5 —恢复删除的提交</h1><p id="5345" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">“丢失的提交”很容易通过错误的重置或者过于激进的<strong class="ki jk">硬重置</strong>而发生，但是，幸好有一些快速技巧，“丢失的提交”不需要担心。</p><p id="e9e0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">举个例子:</p><ol class=""><li id="d456" class="mh mi jj ki b kj kk kn ko kr mj kv mk kz ml ld nu mn mo mp bi translated">3个提交被添加到分支</li><li id="9a72" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld nu mn mo mp bi translated">运行一个交互式的Rebase，并且，意外地，通过<code class="fe nr ns nt nb b">drop</code>命令删除了最终提交</li><li id="8537" class="mh mi jj ki b kj mq kn mr kr ms kv mt kz mu ld nu mn mo mp bi translated">…接下来会发生什么？</li></ol><p id="dac5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，<strong class="ki jk"> reflog </strong>将保存保存。Reflog 是Git内部引擎深处的一个小日志，它记录了每一个动作及其对应的提交id。</p><pre class="mw mx my mz gt na nb nc bn nd ne bi"><span id="f737" class="nf lf jj nb b be ng nh l ni nj"># Commit "Feature D" to the tree<br/>git commit -m "Feature D"<br/><br/># Perform an interactive rebase on HEAD~3<br/>git rebase -i HEAD`3<br/><br/># Accidentially drop the final commit (Feature D)<br/><br/># Run git reflog to see the final commit tree<br/>git reflog<br/><br/>a8e2d9e (HEAD -&gt; main) HEAD@{0}: rebase (finish): returning to refs/heads/main<br/>a8e2d9e (HEAD -&gt; main) HEAD@{1}: rebase (start): checkout HEAD~3<br/>44bd680 HEAD@{2}: commit: Feature D<br/>a8e2d9e (HEAD -&gt; main) HEAD@{3}: rebase (finish): returning to refs/heads/main<br/>a8e2d9e (HEAD -&gt; main) HEAD@{4}: rebase (reword): Feature B<br/>826cb5a HEAD@{5}: rebase: fast-forward<br/>6b4e8f3 HEAD@{6}: rebase (start): checkout HEAD~2<br/><br/># We can see the commit ID of Feature D (44bd680)<br/><br/># Using git cherry-pick, we can add it back in<br/>git cherry-pick 44bd680</span></pre><p id="8414" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过这个简单的例子，我们可以看到reflog维护了发生的所有事情的提交Id，即使我们的提交<code class="fe nr ns nt nb b">44bd680</code>不再是树的一部分，我们也能够将它选回到我们的分支中。唷！</p><h1 id="70b6" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">下一步是什么</h1><p id="396c" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这5个技巧仅仅是Git力量的冰山一角。如您所见，除了基本功能之外，Git还有许多命令可以真正增强您的流程。</p><p id="5139" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些技巧都可以进一步探索，所以我强烈推荐阅读位于<a class="ae jg" href="https://www.git-scm.com." rel="noopener ugc nofollow" target="_blank">https://www.git-scm.com的Git参考文档。</a></p><div class="is it gp gr iu oi"><a href="https://git-scm.com/docs" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd jk gy z fp on fr fs oo fu fw ji bi translated">参考</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">快速参考指南:GitHub备忘单|可视化Git备忘单</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">git-scm.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ja oi"/></div></div></a></div><p id="3611" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章的灵感来自我写的另一篇关于<a class="ae jg" href="https://medium.com/swlh/squash-and-rebase-git-basics-5cb1be1e0dac" rel="noopener">重置</a>的文章。一位评论者问到“从中间挤压”，我建议使用<strong class="ki jk">交互式Rebase </strong>。但是，这是一个如此巨大的话题，也许会有其他文章，我会把这变成一个系列…</p></div></div>    
</body>
</html>