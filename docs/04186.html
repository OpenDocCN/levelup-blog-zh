<html>
<head>
<title>How to Design Software By Contract to Reduce Risk</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过合同设计软件来降低风险</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-design-software-by-contract-to-reduce-risk-1c1c439c573f?source=collection_archive---------7-----------------------#2020-06-13">https://levelup.gitconnected.com/how-to-design-software-by-contract-to-reduce-risk-1c1c439c573f?source=collection_archive---------7-----------------------#2020-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0156f5829764f8448babb51332e3d38f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f03Blcj75tJ1AAjC"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kf" href="https://unsplash.com/@bubo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">路博宣礼塔</a>拍摄的照片</figcaption></figure><p id="32a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对代码进行任何更改都会带来风险。我们应该思考这些问题，以便在问题出现时能够应对。</p><p id="8f99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过联系来设计软件是记录我们的代码并降低变更风险的一种方式。</p><p id="ab58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何通过文档或软件的契约来设计软件。</p><h1 id="311a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">前提</h1><p id="4c82" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这是函数被调用时必须满足的条件。如果违反了前提条件，就不应该调用函数。</p><h1 id="e6cd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">后置条件</h1><p id="a082" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这是该函数保证要做的事情。它是程序完成时软件的状态。</p><h1 id="5bb8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">类别不变量</h1><p id="99ea" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">从调用者的角度来看，类确保条件总是真的。</p><p id="8f15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当函数退出并且控制返回到调用者时，不变量必须为真。</p><h1 id="b0d2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">常数参数</h1><p id="b476" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">传递到函数中的参数不应该被更改，以便遵循约定。</p><p id="432c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，函数的代码就不会破坏契约。</p><h1 id="448e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">合同设计</h1><p id="fa48" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该遵守Liskov替换原则，该原则声明“子类必须可以通过基类接口使用，而不需要用户知道区别”</p><p id="413d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着，如果我们用实现相同契约的另一个子类替换一个子类，那么它们应该表现相同。</p><p id="ae3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们不必知道这些类的实现是什么。</p><p id="ebd2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只需要确保两个类都有返回相同内容的方法。</p><p id="898c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也意味着我们必须确保我们创建的新子类型是一个“独一无二”的基本类型。</p><p id="9fcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过合同做到这一点。我们只需要指定它一次，然后我们离开它。</p><p id="63c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们可以确保所有的子类都符合特定的方法签名。</p><p id="9eff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果我们有一个基类契约，我们可以确定未来的子类不能改变方法的含义。</p><h1 id="0678" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">通过合同实施设计</h1><p id="5d25" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过枚举每个功能的输入、边界条件和输出来通过契约实现设计。</p><p id="5732" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于不使用像JavaScript这样的代码进行契约式设计的语言来说，这可能是我们所能做到的最大限度了。</p><p id="8458" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，像TypeScript这样的语言确实支持通过接口的契约来设计，我们可以使用接口和抽象类来为我们的类指定契约。</p><h1 id="c07d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">断言</h1><p id="8c76" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过使用断言来确保我们的函数和类遵循契约。</p><p id="5b57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果我们有子类，那么它们将不会正确运行，除非我们在子类的方法中复制断言功能。</p><p id="adf4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还必须保存任何旧值，以便在必要时用来检查后置条件。</p><p id="bc51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行时库不是为支持契约而设计的，所以不检查它们。如果需要，我们必须自己检查这些函数的返回值。</p><h1 id="8bf8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">循环不变量</h1><p id="cf7a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">循环不变量是循环最终目标的陈述。然而，它是一般化的，因此在循环执行之前和循环的每次迭代中它也是有效的。</p><p id="d4a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想找到一个循环的最小数，那么我们可以写如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e269" class="mq lf it mm b gy mr ms l mt mu">const arr = [4, 5, 6, 2, 1];<br/>let [m] = arr;<br/>i = 1;</span><span id="6532" class="mq lf it mm b gy mv ms l mt mu">while (i &lt; arr.length) {<br/>  m = Math.min(m, arr[i]);<br/>  i = i + 1;<br/>}</span></pre><p id="b47d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们的循环不变量是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="132b" class="mq lf it mm b gy mr ms l mt mu">m = Math.min(m, arr[i]);</span></pre><p id="266e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它总是设置当前找到的从<code class="fe mw mx my mm b">arr</code>数组到<code class="fe mw mx my mm b">m</code>的最小数。</p><p id="bcf2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，只要循环正在运行，它总是来自数组的最小值。</p><p id="dc84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以它是一个循环不变量，因为<code class="fe mw mx my mm b">m</code>是数组的最小值，到目前为止从未改变。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/4132666542b42dd319c5f8a669a46098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uVY18f2TmHgKmM5C"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@picoftasty?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">湄木</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="256d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">语义不变量</h1><p id="b67c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">语义不变量是由需求直接驱动的法则，只在管理体制改变时才会改变。</p><p id="a81c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不应该混淆语义不变量和固定的需求。新政策可能会改变这一要求。</p><p id="7f6c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论当时的需求是什么，我们都应该清楚地记录下来，这样每个人都知道它的存在。</p><p id="81c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">加强语义不变量的最好方法是站在用户的角度出错。我们必须向用户保证我们系统的行为。</p><h1 id="624b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="b94d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">契约式设计通过强制执行契约来降低变更破坏事物的风险，也可以作为我们所写内容的文档。</p><p id="41b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它遵循一些不变的条件，这些条件减少了变化给我们的系统带来的风险。</p></div></div>    
</body>
</html>