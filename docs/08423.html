<html>
<head>
<title>Data Structures Written In Python and their respective LeetCode questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python写的数据结构及其各自的LeetCode问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-most-common-data-structures-written-in-python-b63f864e71c?source=collection_archive---------2-----------------------#2021-05-01">https://levelup.gitconnected.com/the-most-common-data-structures-written-in-python-b63f864e71c?source=collection_archive---------2-----------------------#2021-05-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6f56" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">包括完整的代码片段(GitHub Gists)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8e3ea3d4e6d13d28c0276e9d5c75a344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V9wH_wnAB2FXF_nD"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@synkevych?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗曼·辛克维奇</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有代码片段都是可运行的(也就是说，您可以复制并粘贴它，它将是可运行的)。如果你发现任何错误，请在评论中告诉我！</p><p id="3ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有片段还描述了每个操作及其对应的渐近运行时(即大O)。所有代码片段都是我自己创作的。</p><h1 id="07de" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">目录</h1><ol class=""><li id="4324" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu mu mv mw mx bi translated"><strong class="lb iu">堆栈</strong></li><li id="0c26" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">队列</strong></li><li id="35e4" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">堆</strong></li><li id="7fd2" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">链表</strong></li><li id="0154" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">树(BST) </strong></li><li id="bc2e" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">树(Trie) </strong></li></ol><h1 id="4005" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">大量</h1><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="fe0f" class="ni lw it ne b gy nj nk l nl nm"><strong class="ne iu">Operation: </strong>push<strong class="ne iu"> </strong>(add element to the stack)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span><span id="56db" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>pop<strong class="ne iu"> </strong>(remove from stack)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span><span id="67ef" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>peek<strong class="ne iu"> </strong>(return first/topmost item in stack)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span><span id="6ebc" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>clear<strong class="ne iu"> </strong>(removes all elements in stack)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="cf4b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">行列</h1><p id="40d8" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">区分单端队列和双端队列非常重要。</p><h2 id="bf96" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated"><strong class="ak">单端队列</strong></h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="e40e" class="ni lw it ne b gy nj nk l nl nm"><strong class="ne iu">Operation: </strong>enqueue<strong class="ne iu"> </strong>(add an element to the start of queue)<br/><strong class="ne iu">Time Complexity</strong>: O(n)</span><span id="c82d" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>dequeue<strong class="ne iu"> </strong>(remove an element from the queue)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="c366" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">双头队列</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3e1a" class="ni lw it ne b gy nj nk l nl nm"><strong class="ne iu">Operation: </strong>append<strong class="ne iu"> </strong>(add element to the right of queue)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span><span id="2364" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>appendleft<strong class="ne iu"> </strong>(add element to the left of queue)<br/><strong class="ne iu">Time Complexity</strong>: O(n)</span><span id="c795" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>pop (removes rightmost element in queue)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span><span id="24c7" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>popleft<strong class="ne iu"> </strong>(removes leftmost element in queue)<br/><strong class="ne iu">Time Complexity</strong>: O(n)</span><span id="875b" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>clear<strong class="ne iu"> </strong>(removes all elements in queue)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="63ef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">很</h1><p id="2b83" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">与最大堆相比，最小堆需要做很小的改动。请注意下面代码片段的不同之处。</p><h2 id="a557" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated"><strong class="ak">最大堆数</strong></h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="e88e" class="ni lw it ne b gy nj nk l nl nm"><strong class="ne iu">Operation: </strong>push<strong class="ne iu"> </strong>(adds a new element to the heap)<br/><strong class="ne iu">Time Complexity</strong>: O(log n)</span><span id="acef" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>peek<strong class="ne iu"> </strong>(returns max element in heap)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span><span id="c0d9" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>pop<strong class="ne iu"> </strong>(removes max element from heap)<br/><strong class="ne iu">Time Complexity</strong>: O(log n)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="510b" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated"><strong class="ak">最小堆数</strong></h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="ef7b" class="ni lw it ne b gy nj nk l nl nm"><strong class="ne iu">Operation: </strong>push<strong class="ne iu"> </strong>(adds a new element to the heap)<br/><strong class="ne iu">Time Complexity</strong>: O(log n)</span><span id="6e05" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>peek<strong class="ne iu"> </strong>(returns max element in heap)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span><span id="20e0" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>pop<strong class="ne iu"> </strong>(removes max element from heap)<br/><strong class="ne iu">Time Complexity</strong>: O(log n)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="185f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">链接列表</h1><p id="a0c6" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">下面所有的链表数据结构都将使用下面代码片段中的<code class="fe oe of og ne b">Node</code>类。一个<code class="fe oe of og ne b">Node</code>跟踪单个元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="e550" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">与链表相关的LeetCode问题</h2><ul class=""><li id="0953" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" rel="noopener ugc nofollow" target="_blank">从排序列表中删除重复项</a></li><li id="134a" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/intersection-of-two-linked-lists/" rel="noopener ugc nofollow" target="_blank">两个链表的交集</a></li><li id="65ba" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/linked-list-cycle/" rel="noopener ugc nofollow" target="_blank">链表循环</a></li><li id="327c" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/reverse-linked-list/" rel="noopener ugc nofollow" target="_blank">反向链表</a></li><li id="8a22" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/middle-of-the-linked-list/" rel="noopener ugc nofollow" target="_blank">链表中间</a></li><li id="eeae" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/remove-linked-list-elements/" rel="noopener ugc nofollow" target="_blank">移除链表元素</a></li><li id="78d3" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/palindrome-linked-list/" rel="noopener ugc nofollow" target="_blank">回文链表</a></li><li id="fcd5" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/merge-two-sorted-lists/" rel="noopener ugc nofollow" target="_blank">合并两个排序后的链表</a></li></ul><h2 id="aa49" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated"><strong class="ak">单链表</strong></h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="df40" class="ni lw it ne b gy nj nk l nl nm"><strong class="ne iu">Operation: </strong>add (insert element to Linked List)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span><span id="9368" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>find<strong class="ne iu"> </strong>(returns element from Linked List)<br/><strong class="ne iu">Time Complexity</strong>: O(n)</span><span id="65d3" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>remove<strong class="ne iu"> </strong>(removes max element from Linked List)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="309b" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated"><strong class="ak">循环链表</strong></h2><p id="d093" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated"><strong class="lb iu">循环</strong>和<strong class="lb iu">单链表</strong>的区别:</p><ol class=""><li id="f400" class="mn mo it lb b lc ld lf lg li oi lm oj lq ok lu mu mv mw mx bi translated">链表末尾的节点没有<code class="fe oe of og ne b">None</code>作为<code class="fe oe of og ne b">next_node</code>。相反，它指回根节点。</li><li id="2195" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">由于这种循环，我们修改:</li></ol><ul class=""><li id="c872" class="mn mo it lb b lc ld lf lg li oi lm oj lq ok lu oh mv mw mx bi translated"><code class="fe oe of og ne b">insert</code>:我们不是在根处插入，而是作为第二个<strong class="lb iu">元素插入到链表中，即根的next_node。</strong></li><li id="6368" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><code class="fe oe of og ne b">find</code>:我们需要知道什么时候我们已经循环了一次链表，否则我们将会陷入一个无限循环</li><li id="74f1" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><code class="fe oe of og ne b">remove</code>:类似于单链表，除了在根节点中找到值的场景中，我们需要将最后一个节点的next_node更新为新的根节点</li></ul><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="715d" class="ni lw it ne b gy nj nk l nl nm"><strong class="ne iu">Operation: </strong>add (insert element toLinked List)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span><span id="0758" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>find<strong class="ne iu"> </strong>(returns element from Linked List)<br/><strong class="ne iu">Time Complexity</strong>: O(n)</span><span id="5533" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>remove<strong class="ne iu"> </strong>(removes element from Linked List)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="b610" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated"><strong class="ak">双向链表</strong></h2><p id="185a" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated"><strong class="lb iu">双</strong>和<strong class="lb iu">单</strong>链表的区别:</p><ol class=""><li id="e221" class="mn mo it lb b lc ld lf lg li oi lm oj lq ok lu mu mv mw mx bi translated"><code class="fe oe of og ne b">Node</code>类具有附加的<code class="fe oe of og ne b">prev_node</code>属性(双向)</li><li id="5389" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><code class="fe oe of og ne b">DoubleLinkedList</code>类跟踪作为属性的<code class="fe oe of og ne b">last</code>节点</li></ol><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d7c5" class="ni lw it ne b gy nj nk l nl nm"><strong class="ne iu">Operation: </strong>add (insert element to Linked List)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span><span id="c462" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>find<strong class="ne iu"> </strong>(returns element from Linked List)<br/><strong class="ne iu">Time Complexity</strong>: O(n)</span><span id="6786" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>remove<strong class="ne iu"> </strong>(remove element from Linked List)<br/><strong class="ne iu">Time Complexity</strong>: O(1)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="ed86" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">树</h1><h2 id="87ca" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">术语:</h2><ol class=""><li id="1327" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu mu mv mw mx bi translated"><strong class="lb iu">节点/顶点</strong>——树中的每个元素被称为一个节点或顶点</li><li id="b5db" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">边</strong>—<em class="ol">边</em>连接两个节点</li><li id="507d" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">根</strong>——最顶端的节点</li><li id="cdb2" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">祖先</strong> —所述节点之上的所有节点</li><li id="6b34" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">后代</strong> —所述节点下的所有节点</li><li id="ea0e" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">父节点</strong> —问题节点的正上方节点</li><li id="118c" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">子节点</strong> —直接位于相关节点下的节点</li><li id="0198" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">同级</strong> —具有相同父节点的节点</li><li id="243b" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><strong class="lb iu">叶</strong> —没有子节点的节点</li></ol><h2 id="7d73" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">树的类型</h2><ol class=""><li id="7cb5" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu mu mv mw mx bi translated">二叉树—具有两个子节点的树</li><li id="1c2f" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">二叉查找树—类似于(1)，除了每个节点大于其左子树<strong class="lb iu">中的每个<strong class="lb iu"> <em class="ol">节点和其右子树中的每个</em> </strong>节点和</strong>节点小于<strong class="lb iu"> <em class="ol">节点</em></strong></li></ol><h2 id="e1b5" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">与树木相关的LeetCode问题</h2><ul class=""><li id="48fc" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" rel="noopener ugc nofollow" target="_blank">二叉树的最大深度</a></li><li id="017a" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" rel="noopener ugc nofollow" target="_blank">二叉树的最小深度</a></li><li id="8a15" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/symmetric-tree/" rel="noopener ugc nofollow" target="_blank">对称树</a></li><li id="07c1" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/invert-binary-tree/" rel="noopener ugc nofollow" target="_blank">反转二叉树</a></li><li id="047a" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/search-in-a-binary-search-tree/" rel="noopener ugc nofollow" target="_blank">在二叉查找树搜索</a></li><li id="2105" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/merge-two-binary-trees/" rel="noopener ugc nofollow" target="_blank">合并两棵二叉树</a></li><li id="0547" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/subtree-of-another-tree" rel="noopener ugc nofollow" target="_blank">另一棵树的子树</a></li><li id="b107" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" rel="noopener ugc nofollow" target="_blank">二叉查找树的最低共同祖先</a></li></ul><h2 id="4ce8" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">二分搜索法树</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9986" class="ni lw it ne b gy nj nk l nl nm"><strong class="ne iu">Operation: </strong>add (add an element to the BST)<br/><strong class="ne iu">Time Complexity</strong>: O(log n)</span><span id="e415" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>find<strong class="ne iu"> </strong>(find an element in the BST)<br/><strong class="ne iu">Time Complexity</strong>: O(log n)</span><span id="5d92" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>remove<strong class="ne iu"> </strong>(removes an element from the BST)<br/><strong class="ne iu">Time Complexity</strong>: O(log n)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="18f5" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">努力</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="9f48" class="ni lw it ne b gy nj nk l nl nm"><strong class="ne iu">Operation: </strong>add_word (add word to Trie)<br/><strong class="ne iu">Time Complexity</strong>: O(n) where n is length of word</span><span id="5c41" class="ni lw it ne b gy nn nk l nl nm"><strong class="ne iu">Operation: </strong>does_word_exist<strong class="ne iu"> </strong>(boolean to check if word is in Trie)<br/><strong class="ne iu">Time Complexity</strong>: O(n) where n is length of word</span></pre><h2 id="8050" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">与尝试相关的LeetCode问题</h2><ul class=""><li id="0566" class="mn mo it lb b lc mp lf mq li mr lm ms lq mt lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/implement-trie-prefix-tree/" rel="noopener ugc nofollow" target="_blank">实现Trie(前缀树)</a></li><li id="4627" class="mn mo it lb b lc my lf mz li na lm nb lq nc lu oh mv mw mx bi translated"><a class="ae ky" href="https://leetcode.com/problems/design-add-and-search-words-data-structure/" rel="noopener ugc nofollow" target="_blank">设计添加和查找单词的数据结构</a></li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="480a" class="ni lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">结束语</h2><p id="8e05" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">暂时就这样吧！让我知道你还想看什么样的数据结构。</p><p id="3112" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢我的内容并且没有订阅Medium，请考虑支持我并通过我的推荐链接订阅。</p></div></div>    
</body>
</html>