# JavaScript 单元测试。NET 开发人员—第 2 部分用 Jest 测试和嘲弄

> 原文：<https://levelup.gitconnected.com/javascript-unit-testing-for-net-developers-part-2-testing-and-mocking-with-jest-1c2d44828c26>

![](img/560fd6adc73ddcb987e77fe638cb7c69.png)

# 介绍

在第一部分中，我们概述了本系列的目标以及我们的工具设置。在第二部分中，我们将开始讨论在 ES6 中使用 Jest 对 JavaScript 进行单元测试，以及在 Visual Studio 和测试 C#等经典 OOP 语言中相似之处的开始和结束。

在这一部分，我们将涉及:

*   JavaScript 中的公共和私有
*   依赖性和让自己的测试更容易
*   JavaScript 用 Jest 模仿并创造了它们
*   测试功能和副作用

# JavaScript 中的公共和私有

当从. Net 语言开始学习全新的 JavaScript 时，我们想知道的第一件事就是封装。从单元测试的角度来看，通过将一些东西变成公共的，而将另一些变成私有的，你就在类上建立了一个“这些是它能做的事情”的契约，并且通过扩展，公共的东西是你测试被测系统的方法。私有的东西是实现细节，只有类知道，你和下一个开发者可以看到公共的东西是如何实现的。

显而易见，JavaScript 中没有公共和私有关键字。我们在 JavaScript 中拥有的是作用域，以及在其他作用域中可用和可见的内容。

为了证明这一点，让我们看看在 ES6 之前这是如何实现的。

这里我们创建了一个相当于类的东西。我们创建了私有变量和函数以及公共属性和函数。我们创建了一个新的 Foo 对象并访问了 public 方法两次，一次从 public 属性中给它一个字符串，另一次强制它使用私有字符串变量。

现在，让我们看看如何使用 ES6 实现相同的行为。

上面的类可以像 ES5 版本一样使用。但是看看我们的私有变量和函数发生了什么，它们不再在类体内声明。这肯定会使私有变量和函数对所有东西都可用吗？

不，ES6 代码依赖于从 JavaScript 文件导入和导出的内容。要使用 Foo 类，您需要另一个 JavaScript 文件，如下所示:

掌握 export 关键字，理解什么是以及如何使用从 JavaScript 文件导出的内容，是 JavaScript 测试和开发中的一个重要概念。在 ES5 中，我们只关心范围，尽管这是可行的，但在大型应用程序开发中会变得不实用。在 ES6 中，事情更加模块化，我们仍然有作用域，并且`const`和`let`单词允许我们创建变量，这些变量的工作方式与我们在中预期的一样。Net 但是导出有点不一样。

你可以把一个 JavaScript 文件看作一个类，你可以在其中创建私有变量和函数，并且只导出你想要的类，如上所示。导出是灵活的，它允许你导出任何东西，如果你想用函数式风格开发，你可以把一个 JavaScript 文件当作一个没有任何类的函数库，只导出函数。您也可以只导出变量来创建可共享的常量值。

从根本上说，从 JavaScript 文件中导出的内容是公共的。然而，该文件的用户可以选择导入所有内容或选择性地选择他们想要的内容，这与使用. Net 中的类或接口不同。参见[https://developer . Mozilla . org/en-US/docs/web/JavaScript/reference/statements/export](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export)

# 依赖性和让你自己的测试更容易。

现在我们已经建立了至少相当于。Net 世界让我们来谈谈依赖。

我们建立了 public(或`export`)我们说这是我的类将做的东西，这是行为和可用的数据，到目前为止都是好东西。

不幸的是，从测试的角度来看，这不是很好。这不是很好的原因是因为你现在为自己的类或函数使用的`import`相当于 C#中的`using`,你可以从命名空间中新建一个类。你可能听说过“哪里有新，哪里就有胶水”这句话。也就是说，您刚刚将您的代码耦合并硬绑定到您刚刚导入的代码。

在 solid 中，依赖性反转原理声明:

*   高层模块不应该依赖低层模块。两者都应该依赖于抽象。
*   抽象不应该依赖于细节。细节(具体实现)应该依赖于抽象

这两句话本质上可以总结为“你不应该依赖和新建包含实现细节的类，相反，你应该依赖和使用你的类实现的接口或抽象类，并且可以用多态来代替”。

通过不依赖抽象，你的代码变成了耦合的。想象一下，您正在编写一个 API，作为该 API 的一部分，您有一个控制器，它有一个服务类，本质上是系统内组件的包装器，如持久性和将数据保存到数据库。您的类和依赖项如下所示:

![](img/0a4e9595365cff49298fed9011d26c37.png)

如果您决定测试控制器或服务类，您别无选择，只能称之为集成测试。没有较低级别的组件，您无法独立测试单个组件。相反，DI 原则教导我们的和我们通常做的。Net 就是有一些看起来更像这样的东西:

![](img/2331ed7dd70d6c801e7297e695b8c0e3.png)

这里我们颠倒了控制流程。当然，我们有更多的东西，但是在测试控制器时，我可以通过创建一个 stub 或 mock `IService`来独立于服务类测试它。在测试控制器时，我创建并使用了假对象，这样我也可以更好地控制我的预期输出。

这对我们已经习惯的东西来说很好，但是我们现在在 JavaScript 领域，JavaScript 没有接口。这是否意味着我们被困在依赖低级细节中？

不，一点也不。Jest 有内置的方法来获得与在中使用 Moq 相同的功能。Net，它只是以一种你意想不到的方式工作，我们接下来会谈到这一点。但在我们这样做之前，我希望我已经明白了，通过进口和直接使用出口的东西，你是在把自己耦合到它上面，而不是使用 Jest 中的一些技巧。

如前所述，JavaScript 没有接口。它确实有鸭子类型，这意味着如果你有一个对象有一个名为`doStuff`的方法，而你有另一个对象也有一个名为`doStuff`的方法，这些对象和方法是可以互换的，JavaScript 不会抱怨它们是不同的类。例如:

在上面的代码片段中，两个记录器都是可互换的，并且`MyImportantClass`并不关心它得到哪个类，只是它将使用具有 log 方法的东西。这是 JavaScript 的依赖注入。

将依赖项注入到类中比在 JavaScript 文件中导入和使用组件要好得多。这些依赖关系当然需要被导入到某个地方，并且它们需要以某种方式进入到将要使用它们的类中。如果你正在使用 React，你已经在以一种模块化的方式思考，并且应该考虑分离和组件化你的组件。为此，你应该考虑非可视容器组件和可视组件。

您的容器组件本质上是您的复合根。这些是导入所有依赖项并将它们注入到可视化组件中的组件。强烈推荐你阅读[https://medium . com/@ Dan _ abra mov/smart-and-dumb-components-7 ca 2 f 9 a 7 c 7d 0](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)。如果你同时使用 React 和 Redux，你可以使用像`mapStateToProps`和`mapDispatchToProps`这样的方法，它们允许你将依赖注入到组件的 props 中。

重要的是要意识到你导入和使用的越多，你以后需要做的就越多。这未必是一件坏事，毕竟 Jest 可以很容易地为您注入这些依赖项，但在我看来，使用 duck typing 和手工创建您自己的模拟来注入它们作为依赖项比单独使用 Jest 更容易。你必须保持务实，意识到这种来自进口的耦合是有好处的。

# JavaScript 用 Jest 模仿并创造了它们

在我们开始用 Jest 模拟之前，让我们快速看一下测试套件和单元测试。

上面我们有一个单一的测试套件和一个单一的测试，这是你用 Jest 设置一个测试的最低要求。你可以从 NUnit so `beforeEach`、`afterEach`等中得到相同的设置和拆卸方法(关于 expect[https://jestjs.io/docs/en/expect](https://jestjs.io/docs/en/expect)的断言，参见[https://jestjs.io/docs/en/setup-teardown.html](https://jestjs.io/docs/en/setup-teardown.html)

现在让我们来看一个实际的例子。

上面是一个 redux reducer 的例子，用于改变 redux 应用程序中的区域设置，但这并不重要。重要的是，我们的文件中有两个依赖项，一个用于`defaultLocalProvider`，另一个用于`localActionTypes`。我不太关心`localeActionTypes`，但我更关心`defaultLocaleProvider`。它有一些实现细节，这些细节依赖于获取浏览器的语言环境并将其解析为一种格式，这种格式可以在以后用于识别正确的本地化文件。与我们的减速器无关。

我们想要的是我们的`defaultLocaleProvider`的模拟实现，以返回我们可以测试的东西，一些我们可以在测试中预期的可靠的东西。

我们需要做的是告诉 jest 在运行测试时寻找`defaultLocaleProvider`的模拟实现:

上面我们已经导入了`localeReducer`，这是我们正在测试的系统。但是在那下面，我们有一个新的系列`jest.mock`。这指示 Jest 在`defaultLocaleProvider`依赖于我们的测试系统时，寻找`defaultLocaleProvider`(T4 在自己的文件中导入了它)的模拟实现。

`defaultLocaleProvider`的模拟看起来像这样:

如您所见，这是一个简单的函数，只返回“fakeLocale”字符串。当我们的 reducer 在我们的测试中第一次运行时，它将从这个函数中获取它的初始状态(locale ),将 locale 设置为“fakeLocale ”,因此我们可以在我们的测试中对此进行测试。

为了让它工作，我们需要一个新的文件夹，我们的解决方案中的`defaultLocaleProvider`就在这个文件夹中，这个文件夹叫做`__mocks__`，在这个文件夹中，我们必须有另一个文件，它的名字和我们模仿的文件一样，就像这样:

![](img/81ea9dcc3aaaed272b89fbef9d971a25.png)

这个 mocks 文件夹是一个特殊的文件夹，Jest 在查找 mock 实现时会查看这个文件夹。通常，您在模拟模块时执行这种类型的模拟。

`jest.mock`有一个优点，因为它自动将模块的所有导出设置为模拟函数，允许您稍后覆盖它们。

让我们看看`jest.SpyOn`中`jest.mock`的替代方案。

我们将尝试并测试这段简单的代码:

在这里，我们可以看到，没有依赖关系，而只是一个函数与导航对象。然后，它尝试从导航器中检索一种语言，如果没有找到，它将返回“en”。

在使用`jest.spyOn`时，我们不需要在同一个目录中模拟实现。相反，我们可以这样做:

这里我们导入了被测系统`navigatorLocale`。我们利用`beforeAll`将`langaugesMock`设置为模拟，然后`beforeEach`将返回值重置为空。

在第一个测试中，我们没有模拟，我们正在测试默认值返回(“en”)。在第二个例子中，我们将返回值设置为一个数组，正如我们从代码中知道的，languages 数组的第一个元素应该被返回，在我们的例子中是“ja”。

如果有一个关于`jest.mock`和`jest.spyOn`的经验法则，我可能会建议在需要跨多个文件(模拟模块)的模拟时使用`jest.mock`,在单个案例中需要时使用`jest.spyOn`。

# 测试功能和副作用

可能是上面的`jest.mock`和`jest.spyOn`对你的需要来说太重了，或者它们可能不完全适合你想要测试的副作用，功能使用或变异的东西，你可能有也可能没有。

想象一下，您正在编写一个 React 组件，它封装了一个 HTML 按钮，如下所示:

在这个简单的例子中，您希望确保在单击按钮时调用了`onClick`函数。这是事件发生的副作用。

使用`jest.spyOn`和`Jest.fn`都可以做到这一点。`jest.spyOn`的另一个用途是，你不必替换被调用函数的实现细节，而只需让 Jest 观察函数，这样你就可以稍后测试它是否被调用。

`jest.fn`不允许恢复被模仿函数的原始细节，但是知道这一点是有好处的，因为`jest.spyOn`是使用`jest.fn`的语法糖。

回到上面的例子，我们可以这样测试这个组件:

这里我们使用特定于测试 React 组件的方法，但是这里需要注意的最重要的事情是我们注入了一个名为`mockOnClick`的模拟函数。然后，我们模拟了组件上的点击。最后，我们期望已经调用了`mockOnClick`函数。我也可以测试这个函数被调用的次数。

要向`jest.spyOn`添加一个模拟实现，您必须像这样使用`mockImplementation`属性:

将您的函数作为参数添加到函数中，但使用`jest.fn`创建函数时，您可以在创建时将其作为第一个参数添加:

使用哪一个将取决于你和测试的环境。

# 结论

在第二部分中，我们介绍了 JavaScript 封装及其重要性，我们还讨论了依赖倒置原则以及我们通常如何在。Net 以及用 JavaScript 和 ES6 做同样的事情的困难，以获得对我们的依赖性的认识。

最后，我们讨论了创建三种类型的 Jest mocks，以及何时使用每种类型以及如何测试它们。

在下一部分，我们将讨论测试 react 组件。