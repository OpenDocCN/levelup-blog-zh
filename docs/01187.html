<html>
<head>
<title>Fluttering Dart: Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">飞舞的飞镖:操作符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/fluttering-dart-ee493f4b0440?source=collection_archive---------6-----------------------#2019-11-24">https://levelup.gitconnected.com/fluttering-dart-ee493f4b0440?source=collection_archive---------6-----------------------#2019-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ff2b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener ugc nofollow" target="_blank" href="https://levelup.gitconnected.com/fluttering-dart/home">飘动的飞镖</a></h2><div class=""/><div class=""><h2 id="e6ba" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Dart的操作员…一个接一个</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/53443d6e32697d21ef8eef26bfb3fa1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Di0qEDK0OSsTRXmZnRwQkw.gif"/></div></div></figure><p id="c34b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae lz" href="https://flutter.dev" rel="noopener ugc nofollow" target="_blank"> Flutter </a>项目既可以使用特定平台代码，也可以使用跨平台代码。后者是用<a class="ae lz" href="https://dart.dev" rel="noopener ugc nofollow" target="_blank"> Dart </a>写的，而且，构建Flutter apps，需要一些Dart的基础知识。</p><p id="50dc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae lz" href="https://medium.com/tag/fluttering-dart/archive" rel="noopener"/></p><p id="5647" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在本系列的前两部分中，我们介绍了Dart <a class="ae lz" href="https://medium.com/@constanting/fluttering-dart-9a3e74b0d9c5" rel="noopener"> <strong class="lf jd">内置数据类型</strong> </a>和<a class="ae lz" href="https://medium.com/@constanting/fluttering-dart-b37110f4d1bf" rel="noopener"> <strong class="lf jd">函数</strong> </a>。</p><p id="92c2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在这一部分中，我们将发现Dart的操作员:如何使用和滥用甚至覆盖他们的行为。</p><p id="1da8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">使用<a class="ae lz" href="https://dartpad.dev" rel="noopener ugc nofollow" target="_blank"><strong class="lf jd"/></a>，可以对一些代码示例进行试验和测试。</p><h2 id="8eff" class="ma mb it bd mc md me dn mf mg mh dp mi lm mj mk ml lq mm mn mo lu mp mq mr iz bi translated">经营者</h2><p id="c7a8" class="pw-post-body-paragraph ld le it lf b lg ms kd li lj mt kg ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">运算符是我们在代码中使用的任何符号，它允许我们进行数学计算、执行布尔逻辑或做其他事情，如字符串连接或计算交集。</p><p id="08fe" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">运算符的行为类似于函数，尽管它们的语法或语义与我们对函数的预期不同。</p><p id="98b0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">根据它们的位置，有<strong class="lf jd">前缀</strong>、<strong class="lf jd">中缀</strong>或<strong class="lf jd">后缀</strong>运算符，并且根据它们的操作数，它们被分类为<strong class="lf jd">一元</strong> —一个操作数、<strong class="lf jd">二元</strong> —两个操作数<strong class="lf jd"> </strong>或<strong class="lf jd">三元</strong> —三个操作数。</p><p id="c233" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对于处理两个操作数的运算符，使用最左边操作数版本的运算符。例如，如果我们有一个String对象和一个int对象，<code class="fe mx my mz na b">sVal + iVal</code>使用String版本的<code class="fe mx my mz na b">+</code>，并且需要使用<strong class="lf jd"> int </strong>的<code class="fe mx my mz na b">toString()</code>方法将整数值转换为<strong class="lf jd"> String </strong>。</p><pre class="ks kt ku kv gt nb na nc nd aw ne bi"><span id="7308" class="ma mb it na b gy nf ng l nh ni">// unary prefix operator<br/><strong class="na jd">++</strong>one</span><span id="1d7d" class="ma mb it na b gy nj ng l nh ni">// infix binary operator<br/>one <strong class="na jd">+</strong> two</span><span id="e9af" class="ma mb it na b gy nj ng l nh ni">// unary postfix<br/>one<strong class="na jd">++</strong></span><span id="7143" class="ma mb it na b gy nj ng l nh ni">// ternary operator<br/>one <strong class="na jd">?</strong> two <strong class="na jd">:</strong> three</span></pre><p id="5fe1" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">运算符的语义因求值策略和参数传递模式而异。包含运算符的表达式以某种方式进行计算，结果可能只是一个值，也可能是一个允许赋值的对象。与Dart一样，我们已经发现<a class="ae lz" href="https://medium.com/@constanting/fluttering-dart-9a3e74b0d9c5" rel="noopener">所有结果都是对象</a>。</p><pre class="ks kt ku kv gt nb na nc nd aw ne bi"><span id="d163" class="ma mb it na b gy nf ng l nh ni">// example of operator<br/><strong class="na jd">a + b <br/></strong>// and equivalent function<br/><strong class="na jd">add(a, b)</strong></span></pre><h2 id="658b" class="ma mb it bd mc md me dn mf mg mh dp mi lm mj mk ml lq mm mn mo lu mp mq mr iz bi translated"><strong class="ak">先例</strong></h2><p id="3881" class="pw-post-body-paragraph ld le it lf b lg ms kd li lj mt kg ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">正如我们在下面看到的，Dart有许多操作符。它们的<strong class="lf jd">优先级</strong>决定了在执行我们漂亮的代码时每个操作符的优先级。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/b635c661473ec3d8f392eada0ef4e163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHVjquC0RAHA5AgKHN8HRg.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd mc">运算符优先级和结合性</strong></figcaption></figure><p id="48b7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf jd">结合律</strong>适用于具有相同优先级的运算符。大多数操作符都有从左到右的结合性(方向由一个小箭头指示)。赋值运算符和条件运算符从右向左，前面没有箭头的运算符没有结合性。</p><p id="4682" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">举例来说，我将使用乘法优先于加法的原则(你可能在数学课上还记得):</p><pre class="ks kt ku kv gt nb na nc nd aw ne bi"><span id="d92d" class="ma mb it na b gy nf ng l nh ni">r = a + b * c;</span></pre><p id="498a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">上面的表达式在执行时，将检测所有操作符，并按优先顺序执行它们。如果我们看上面的列表，我们会发现3个操作符(按出现的顺序):</p><ul class=""><li id="0ade" class="no np it lf b lg lh lj lk lm nq lq nr lu ns ly nt nu nv nw bi translated">第一个也是最不重要的</li><li id="a63a" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">+</strong></code>是第二个，比<code class="fe mx my mz na b"><strong class="lf jd">=</strong></code>更“重要”</li><li id="3163" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b">*</code>是最后也是最“重要”的</li></ul><p id="d8d3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，按照重要性的顺序，我们有<code class="fe mx my mz na b">*</code>、<code class="fe mx my mz na b"><strong class="lf jd">+</strong></code>和<code class="fe mx my mz na b"><strong class="lf jd">=</strong></code>(讽刺的是，它们的出现正好相反)。</p><p id="62ee" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">首先，<code class="fe mx my mz na b">b</code>会乘以<code class="fe mx my mz na b">*</code>与<code class="fe mx my mz na b">c</code>。然后，结果将被加到<code class="fe mx my mz na b"><strong class="lf jd">+</strong></code>到<code class="fe mx my mz na b">c</code>上，最后，结果将被分配给<code class="fe mx my mz na b"><strong class="lf jd">=</strong></code>到<code class="fe mx my mz na b">r</code>。</p><p id="e474" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了更容易理解，我们通常按照表达式求值的方式来编写表达式:</p><pre class="ks kt ku kv gt nb na nc nd aw ne bi"><span id="04c4" class="ma mb it na b gy nf ng l nh ni">// easier to read<br/>r = a + (b * c);</span></pre><h2 id="bc3c" class="ma mb it bd mc md me dn mf mg mh dp mi lm mj mk ml lq mm mn mo lu mp mq mr iz bi translated">种类</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/102512bbeb8656966b6b801a016c8f30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQl002cmwb_NWMjq6Zldug.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd mc">算术运算符</strong></figcaption></figure><ul class=""><li id="2852" class="no np it lf b lg lh lj lk lm nq lq nr lu ns ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">+</strong></code> <strong class="lf jd"> </strong>添加<code class="fe mx my mz na b">assert(5 + 3 == 8);</code></li><li id="0b7e" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">-</strong></code>减去<code class="fe mx my mz na b">assert(5 - 3 == 2);</code></li><li id="b1a7" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">-expr</strong></code>一元减号——反转表达式的符号<code class="fe mx my mz na b">assert(-(5 + 3) == -8);</code></li><li id="dc77" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">*</strong></code>乘<code class="fe mx my mz na b">assert(5 * 3 == 15);</code></li><li id="c4fc" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">/</strong></code>划分<code class="fe mx my mz na b">assert(5 / 3 == 1.6666666666666667);</code></li><li id="1683" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">~/</strong></code> <strong class="lf jd"> </strong>除法返回整数结果<code class="fe mx my mz na b">assert(5 / 3 == 1);</code></li><li id="4564" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">%</strong></code> <strong class="lf jd"> </strong>模—返回整数除法的余数<code class="fe mx my mz na b">assert(5 % 3 == 2);</code></li><li id="ce54" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">expr++</strong></code> <strong class="lf jd"> </strong>后缀增量—表达式值为<code class="fe mx my mz na b"><strong class="lf jd">expr</strong></code></li><li id="5044" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">++expr</strong></code> <strong class="lf jd"> </strong>前缀增量—表达式值为<code class="fe mx my mz na b"><strong class="lf jd">expr</strong> + 1</code></li><li id="573a" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">expr--</strong></code> <strong class="lf jd"> </strong>后缀增量—表达式值为<code class="fe mx my mz na b"><strong class="lf jd">expr</strong></code></li><li id="423d" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">--expr</strong></code> <strong class="lf jd"> </strong>前缀增量—表达式值为<code class="fe mx my mz na b"><strong class="lf jd">expr</strong> - 1</code></li></ul><p id="6fbb" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">前缀和后缀的递增和递减运算符有点难以理解:</p><pre class="ks kt ku kv gt nb na nc nd aw ne bi"><span id="3261" class="ma mb it na b gy nf ng l nh ni">var a, b;<br/>a = 0;<br/>b = ++a; // increments <strong class="na jd">a</strong> <strong class="na jd">first,</strong> then assigns the value to <strong class="na jd">b</strong><br/>assert(b == a); // 1 == 1<br/>a = b++; // <strong class="na jd">first</strong> assigns the value to <strong class="na jd">a</strong>, then increments a <br/>assert(b != a); // 2 != 1<br/>print('a=$a and b=$b'); // prints <strong class="na jd">a=1 and b2</strong></span></pre><p id="1e89" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">后缀运算<code class="fe mx my mz na b"><strong class="lf jd">expr++</strong></code>或<code class="fe mx my mz na b"><strong class="lf jd">expr--</strong></code>比前缀运算<code class="fe mx my mz na b"><strong class="lf jd">++expr</strong></code>或<code class="fe mx my mz na b"><strong class="lf jd">++expr</strong></code>效率稍低。在不使用后缀创建的临时值的情况下，应该使用前缀。</p><p id="31d2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这打破了以前的优先规则。我能说什么？规则就是用来打破的！</p><p id="3211" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">Dart编程语言规范(<a class="ae lz" href="https://dart.dev/guides/language/specifications/DartLangSpec-v2.2.pdf" rel="noopener ugc nofollow" target="_blank">版本2.2 </a>)解释:</p><blockquote class="od oe of"><p id="a758" class="ld le og lf b lg lh kd li lj lk kg ll oh ln lo lp oi lr ls lt oj lv lw lx ly im bi translated"><em class="it">评估一个后缀表达式</em><strong class="lf jd"><em class="it">e</em></strong><strong class="lf jd"><em class="it">v++</em></strong><em class="it">分别为</em> <strong class="lf jd"> <em class="it"> v - </em> </strong> <em class="it">，其中</em> <strong class="lf jd"> <em class="it"> v </em> </strong> <em class="it">是一个标识符，收益如下:评估</em> <strong class="lf jd"> <em class="it"> v </em>分别评估<strong class="lf jd"><em class="it">v = y+1</em></strong><em class="it">v = y-1</em></strong><em class="it">。然后</em> <strong class="lf jd"> <em class="it"> e </em> </strong> <em class="it">求值为</em> <strong class="lf jd"> <em class="it"> r </em> </strong> <em class="it">。</em></p><p id="2199" class="ld le og lf b lg lh kd li lj lk kg ll oh ln lo lp oi lr ls lt oj lv lw lx ly im bi translated">上面的代码确保了如果求值涉及到一个getter，那么它只被调用一次。同样在下面的例子中。</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/367a06c590ccb42e637e42f7d4dec371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHK-pOtycEWEMflNQIiAUQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd mc">等式和关系运算符</strong></figcaption></figure><ul class=""><li id="9553" class="no np it lf b lg lh lj lk lm nq lq nr lu ns ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">==</strong></code> <strong class="lf jd"> </strong>等于<code class="fe mx my mz na b">assert(3 == 3);</code></li><li id="3306" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">!=</strong></code>不等于<code class="fe mx my mz na b">assert(5 != 3);</code></li><li id="47f6" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">&gt;</strong></code>大于<code class="fe mx my mz na b">assert(5 &gt; 3);</code></li><li id="f1f0" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">&lt;</strong></code>小于<code class="fe mx my mz na b">assert(5 &lt; 8);</code></li><li id="ff3a" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">&gt;=</strong></code>大于或等于<code class="fe mx my mz na b">assert(5 &gt;= 5);</code></li><li id="8326" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">&lt;=</strong></code>小于或等于<code class="fe mx my mz na b">assert(5 &lt;= 5);</code></li></ul><p id="2a66" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">测试对象是否代表相同的东西。为了验证两个对象是否完全相同，我们应该使用<code class="fe mx my mz na b">identical()</code>函数。</p><p id="7a3a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在第一个操作数上调用该操作。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/6df23709052285ae98d551e98ebcbc3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*As9xq2s2v7fZalrm6QEe7A.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd mc">类型测试操作员</strong></figcaption></figure><ul class=""><li id="5b44" class="no np it lf b lg lh lj lk lm nq lq nr lu ns ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">as</strong></code> <strong class="lf jd"> </strong>类型演员表</li><li id="9454" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">is</strong></code>类型测试— <strong class="lf jd">真</strong>如果对象具有指定的类型</li><li id="d6df" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">is!</strong></code>类型测试— <strong class="lf jd">假</strong>如果对象具有指定的类型</li></ul><p id="21b6" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">后两个运算符基本上是测试两个对象是否是同一类型(相当于<code class="fe mx my mz na b">==</code>和<code class="fe mx my mz na b">!=</code>)。</p><pre class="ks kt ku kv gt nb na nc nd aw ne bi"><span id="23e2" class="ma mb it na b gy nf ng l nh ni">// because this operators work with objects, we'll use the fictional <strong class="na jd">Cat</strong> and <strong class="na jd">Dog </strong>these classes extend the <strong class="na jd">Pet</strong> class</span><span id="75cb" class="ma mb it na b gy nj ng l nh ni">List pets = &lt;Pet&gt;[Cat('Simba'), Cat('Micuta')]; <br/>Cat oneCat = (pets[0] <strong class="na jd">as</strong> Cat);<br/>Cat anotherCat = (pets[1] <strong class="na jd">as</strong> Cat);<br/>assert(oneCat.name == 'Simba');<br/>assert(anotherCat.name == 'Micuta');<br/>assert(anotherCat <strong class="na jd">is</strong> Cat);<br/>assert(oneCat <strong class="na jd">is!</strong> Dog);</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/96b36feaca32506fadfac12287b4ae62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GvHArNP-9y9xU_tjpltw5w.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd mc">赋值运算符</strong></figcaption></figure><p id="f86f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">可以使用<code class="fe mx my mz na b"><strong class="lf jd">=</strong></code>运算符赋值。要仅在被赋值变量为空时赋值，请使用空操作符。</p><p id="5ae5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">除了实际的<code class="fe mx my mz na b"><strong class="lf jd">=</strong></code> <strong class="lf jd"> </strong>操作员以外，上面的每个操作员都是一个<strong class="lf jd">复合操作员</strong>。</p><p id="63ba" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这意味着操作与赋值相结合。实际操作说明可以在它们各自的类别中找到。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/a268ecfcf0a2536df9bbd10e50db5590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2QPMMW8qY1uidxZ97rkdiQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd mc">逻辑运算符</strong></figcaption></figure><ul class=""><li id="78b2" class="no np it lf b lg lh lj lk lm nq lq nr lu ns ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">!expr</strong></code> <strong class="lf jd"> </strong>反转表达式(在假与真之间切换)<code class="fe mx my mz na b">assert(!true == false);</code></li><li id="918f" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">&amp;&amp;</strong></code>逻辑与<code class="fe mx my mz na b">assert(true &amp;&amp; false == false);</code></li><li id="5bad" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">||</strong></code>逻辑或<code class="fe mx my mz na b">assert(true || false == true);</code></li></ul><p id="3446" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们可以用这些来反转或合并布尔表达式。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/18d6c3e72a61f37835d2f3056b38c7ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7Dtv3xGcs7YX4_hESrGVA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd mc">按位和移位运算符</strong></figcaption></figure><ul class=""><li id="044d" class="no np it lf b lg lh lj lk lm nq lq nr lu ns ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">&amp;</strong></code> <strong class="lf jd">和</strong>取两个等长的二进制表示，对每一对对应的位进行<strong class="lf jd">逻辑与</strong>运算，相当于将它们相乘。如果比较位置的两位都是1，则结果二进制表示中的位是1 ( <code class="fe mx my mz na b">assert(1 &amp; 1 == 1);</code>)，否则结果是0 ( <code class="fe mx my mz na b">assert(0 &amp; 1 == 0);</code>、<code class="fe mx my mz na b">assert(1 &amp; 0 == 0)</code>和<code class="fe mx my mz na b">assert(0 &amp; 0 == 0);</code>)</li><li id="4844" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">|</strong></code> <strong class="lf jd">或</strong>取两个等长的二进制表示，并对每对相应的位执行<strong class="lf jd">逻辑异或</strong>运算。如果两位都为0 ( <code class="fe mx my mz na b">assert(0 | 0 == 0);</code>)，则每个位置的结果为0，否则结果为1 ( <code class="fe mx my mz na b">assert(0 | 1 == 1);</code>、<code class="fe mx my mz na b">assert(1 | 0 == 1)</code>和<code class="fe mx my mz na b">assert(1 | 1 == 1);</code>)</li><li id="b403" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">^</strong></code> <strong class="lf jd"> XOR </strong>取两个等长的二进制表示，对每对对应的位进行<strong class="lf jd">逻辑异或</strong>运算。如果只有一位为1 ( <code class="fe mx my mz na b">assert(0 ^ 1 == 1);</code>和<code class="fe mx my mz na b">assert(1 ^ 0 == 1);</code>)，则每个位置的结果为1，但如果两位都为0或都为1 ( <code class="fe mx my mz na b">assert(1 ^ 1 == 0);</code>和<code class="fe mx my mz na b">assert(0 ^ 0 == 0);</code>)，则结果为0</li><li id="eb65" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">~expr</strong></code> <strong class="lf jd">一元按位补码</strong>切换<strong class="lf jd"> 0 </strong>和<strong class="lf jd"> 1 </strong>之间的所有位。(<code class="fe mx my mz na b">assert(1 &amp; ~1 == 0);</code>)</li><li id="cc74" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">&lt;&lt;</strong></code> <strong class="lf jd">左移</strong>将位左移，零作为新数字移入。(<code class="fe mx my mz na b">assert(1 &lt;&lt; 1 == 2);</code>)</li><li id="7faa" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">&gt;&gt;</strong></code> <strong class="lf jd">右移</strong>将数字右移，移入零以替换丢弃的位。(<code class="fe mx my mz na b">assert(1 &gt;&gt; 1 == 0);</code>)</li></ul><p id="cd0f" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在Dart中，我们可以使用按位和移位操作符来操作二进制数据的位。</p><p id="10a7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">4294967295是我们对0求补后得到的数。即(2的32次方)-1，或无符号int 32位的最大值。</p><pre class="ks kt ku kv gt nb na nc nd aw ne bi"><span id="d803" class="ma mb it na b gy nf ng l nh ni">assert(~0 == math.pow(2,32) — 1);</span></pre><p id="0846" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">4294967295(十进制)的实际二进制表示为:</p><pre class="ks kt ku kv gt nb na nc nd aw ne bi"><span id="c013" class="ma mb it na b gy nf ng l nh ni">11111111111111111111111111111111</span></pre><p id="b891" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我打算在现实生活的用例中详细讨论按位和移位操作。如果有兴趣，请关注我。</p><div class="ok ol gp gr om on"><a href="https://medium.com/@aflutterdev/bit-masking-a-practical-example-657ea8b621a8" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd jd gy z fp os fr fs ot fu fw jc bi translated">位屏蔽:一个实际例子</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">在简短的二进制介绍之后，在极小的比特上存储数据</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">medium.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb lb on"/></div></div></a></div><div class="ok ol gp gr om on"><a href="https://medium.com/@aflutterdev/bit-masking-control-movement-8d5c743cb076" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd jd gy z fp os fr fs ot fu fw jc bi translated">位屏蔽:控制移动</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">一点一点地移动部件</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">medium.com</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb lb on"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/49e248dcf4a817e78c5b87646ab78ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yIYH8Q0yPvAvQijwzg8MgA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd mc">条件表达式</strong></figcaption></figure><ul class=""><li id="471b" class="no np it lf b lg lh lj lk lm nq lq nr lu ns ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">expr ? expr1 : expr2</strong></code>如果<code class="fe mx my mz na b">expr</code>为真，则对<code class="fe mx my mz na b">expr1</code>求值(并返回其值)；否则，评估并返回<code class="fe mx my mz na b">expr2</code>的值</li><li id="5a71" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">expr1 ?? expr2</strong></code> <strong class="lf jd"> </strong>如果<code class="fe mx my mz na b">expr1</code>非空，则返回其值；否则，评估并返回<code class="fe mx my mz na b">expr2</code>的值。例如，当您希望确保在第一个表达式为<strong class="lf jd"> null </strong>的情况下使用默认值时，这个支持null的操作符非常有用:</li></ul><pre class="ks kt ku kv gt nb na nc nd aw ne bi"><span id="4a61" class="ma mb it na b gy nf ng l nh ni">class Cat {<br/>  String name;<br/>}</span><span id="80db" class="ma mb it na b gy nj ng l nh ni">void main() {<br/>  // we create a generic cat<br/>  Cat <strong class="na jd">genericCat</strong> = Cat();</span><span id="a2a4" class="ma mb it na b gy nj ng l nh ni">  // we create a stray cat<br/>  Cat <strong class="na jd">strayCat</strong> = Cat();</span><span id="ddc8" class="ma mb it na b gy nj ng l nh ni">  // we set the stray cat's name <br/>  // to the generic cat's name value <br/>  // that will be null so our stray cat<br/>  // name will be <strong class="na jd">Catonymous</strong><br/>  strayCat = genericCat.name ?? 'Catonymous';<br/>}</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/0a3ca93c402aa0a2cb9bdc5778532564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyO62IiD2z4WSlkM8ETmdQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd mc">级联符号(..)</strong></figcaption></figure><p id="43e2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">级联(<code class="fe mx my mz na b">..</code>)允许我们对同一对象进行一系列操作。除了函数调用，我们还可以访问同一个对象上的字段。这通常使我们免于创建临时变量，并允许我们编写更流畅的代码。</p><pre class="ks kt ku kv gt nb na nc nd aw ne bi"><span id="e166" class="ma mb it na b gy nf ng l nh ni">// we'll use the fictional <strong class="na jd">Cat</strong> class we used before</span><span id="8f23" class="ma mb it na b gy nj ng l nh ni">Cat()<br/>  ..name = 'Simba'<br/>  ..feed()<br/>  ..pet();</span></pre><p id="77ba" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">上面的例子用简单的英语读起来相当流利(瀑布之美):我们不知从哪里弄来一只流浪猫，给它取名辛巴，然后喂养和抚摸它，让它快乐地喵喵叫和咕噜咕噜叫。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/22a006e51bd84c950a8ae1b40cca4504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnflyFOrcW6M88qTYeuUJw.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd mc">其他操作员</strong></figcaption></figure><ul class=""><li id="62cb" class="no np it lf b lg lh lj lk lm nq lq nr lu ns ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">()</strong></code> <strong class="lf jd"> </strong>函数应用——代表一个函数调用</li><li id="8026" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">[]</strong></code>列表访问—指列表中指定索引处的值</li><li id="1a42" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">.</strong></code>成员访问——指表达式的属性</li><li id="6768" class="no np it lf b lg nx lj ny lm nz lq oa lu ob ly nt nu nv nw bi translated"><code class="fe mx my mz na b"><strong class="lf jd">?.</strong></code> <strong class="lf jd"> </strong>条件成员访问——一个空操作符，其行为与上述类似，但最左边的操作数可以是<strong class="lf jd">空值</strong></li></ul><p id="8f3d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在前面的例子中，我们到处都在使用这些方法(<code class="fe mx my mz na b">?.</code>是一个例外，也可能帮助我们避免捕捉到一个例外)。</p><p id="b488" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当我们想要(或需要)在不抛出异常的情况下使用可以为空的对象时，条件成员访问<code class="fe mx my mz na b">?.</code>非常有用。</p><pre class="ks kt ku kv gt nb na nc nd aw ne bi"><span id="929f" class="ma mb it na b gy nf ng l nh ni">class Cat {<br/>  String name;<br/>}<br/>void main() {<br/>  Cat strayCat;<br/>  // prints <strong class="na jd">null</strong><br/>  print(t?.name);<br/>  // throws <strong class="na jd">null is not an object</strong> exception<br/>  print(t.name);<br/>}</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/53443d6e32697d21ef8eef26bfb3fa1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Di0qEDK0OSsTRXmZnRwQkw.gif"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated"><strong class="bd mc">还没完呢！</strong></figcaption></figure><h2 id="ac60" class="ma mb it bd mc md me dn mf mg mh dp mi lm mj mk ml lq mm mn mo lu mp mq mr iz bi translated">最重要的</h2><p id="b453" class="pw-post-body-paragraph ld le it lf b lg ms kd li lj mt kg ll lm mu lo lp lq mv ls lt lu mw lw lx ly im bi translated">你有没有梦想过为某些操作者定义你的自定义行为？Dart允许你通过超越来实现你的梦想。</p><p id="e7b2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">请注意，只有Dart操作符的子集可以被覆盖。这些是<code class="fe mx my mz na b">[]</code>、<code class="fe mx my mz na b">[]=</code>、<code class="fe mx my mz na b">~</code>、<code class="fe mx my mz na b">*</code>、<code class="fe mx my mz na b">/</code>、<code class="fe mx my mz na b">~/</code>、<code class="fe mx my mz na b">%</code>、<code class="fe mx my mz na b">+</code>、<code class="fe mx my mz na b">-</code>、<code class="fe mx my mz na b">&lt;&lt;</code>、<code class="fe mx my mz na b">&gt;&gt;</code>、<code class="fe mx my mz na b">&amp;</code>、<code class="fe mx my mz na b">^</code>、<code class="fe mx my mz na b">|</code>、<code class="fe mx my mz na b">&lt;</code>、<code class="fe mx my mz na b">&gt;</code>、<code class="fe mx my mz na b">&lt;=</code>、<code class="fe mx my mz na b">&gt;=</code>和<code class="fe mx my mz na b">==</code>。</p><p id="3ba7" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe mx my mz na b">!=</code>不是可重写的运算符。表达式<code class="fe mx my mz na b">expr1 != expr2</code>只是<code class="fe mx my mz na b">!(expr1 == expr2)</code>的一个快捷方式，所以如果我们覆盖了<code class="fe mx my mz na b">==</code>，我们也覆盖了<code class="fe mx my mz na b">!=</code>。</p><p id="62c8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对于某些类，使用运算符比使用方法更简洁。例如，List类覆盖了列表连接的<code class="fe mx my mz na b">+</code>操作符。代码<code class="fe mx my mz na b">[a, b, c] + [d, e, f]</code>非常容易理解。</p><p id="052a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们最终定义了一个猫类，并想比较我们的猫的体重。我们通过重写关系和等式操作符来做到这一点。</p><pre class="ks kt ku kv gt nb na nc nd aw ne bi"><span id="eac1" class="ma mb it na b gy nf ng l nh ni">class Cat {<br/>  <br/>  final String name;<br/>  final double weight;<br/>  <br/>  Cat({this.name, this.weight});<br/>  <br/>  bool operator ==(Object cat) =&gt; this.hashCode == cat.hashCode;</span><span id="a67c" class="ma mb it na b gy nj ng l nh ni">  String operator &lt;(Cat cat) =&gt; (weight &lt; cat.weight)?'$name is lighter than ${cat.name}.':'$name is heavier than ${cat.name}.';</span><span id="7650" class="ma mb it na b gy nj ng l nh ni">  String operator &gt;(Cat cat) =&gt; (weight &gt; cat.weight)?'$name is heavier than ${cat.name}.':'$name is lighter than ${cat.name}.';</span><span id="da9f" class="ma mb it na b gy nj ng l nh ni">  String operator &gt;=(Cat cat) =&gt; (weight &gt;= cat.weight)?((this==cat)?'$name is as heavy as ${cat.name}.':'$name is heavier than ${cat.name}.'):'$name is lighter than ${cat.name}.';</span><span id="de09" class="ma mb it na b gy nj ng l nh ni">  String operator &lt;=(Cat cat) =&gt; (weight &lt;= cat.weight)?((this==cat)?'$name is as light as ${cat.name}.':'$name is lighter than ${cat.name}.'):'$name is heavier than ${cat.name}.';<br/>  <br/>  <a class="ae lz" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank"><strong class="na jd">@override</strong></a><br/>  int get hashCode =&gt; weight.hashCode;<br/>  <br/>}</span><span id="a0b5" class="ma mb it na b gy nj ng l nh ni">void main() {</span><span id="daab" class="ma mb it na b gy nj ng l nh ni">  // create our cats <br/>  Cat oneCat = Cat(name: 'Simba', weight: 4.1);<br/>  Cat anotherCat = Cat(name: 'Micuta', weight: 3.8);<br/>  Cat yetAnotherCat = Cat(name: 'Saki', weight: 3.8);<br/>  Cat meowCat = Cat(name: 'Klein', weight: 5.0);</span><span id="790d" class="ma mb it na b gy nj ng l nh ni">  // and compare them<br/>  print(oneCat&gt;anotherCat);<br/>  print(yetAnotherCat&lt;=anotherCat);<br/>  print(meowCat&lt;=oneCat);<br/>  <br/>}</span></pre><p id="2516" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这些覆盖的例子有点复杂，因为它们甚至将表达式的求值结果类型从<strong class="lf jd"> bool </strong>更改为<strong class="lf jd"> String </strong>，并且<code class="fe mx my mz na b">&gt;=</code>和<code class="fe mx my mz na b">&lt;=</code>甚至使用了两个混合条件运算符。我们这样做是为了克服我们不能改变<code class="fe mx my mz na b">==</code>的返回类型这一事实，它必须保持布尔值。</p><p id="4c71" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注意，我们已经覆盖了<strong class="lf jd"> hashCode </strong> getter(当覆盖<code class="fe mx my mz na b">==</code>操作符时，这是必须的)。</p><p id="73e0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">上面代码的结果是:</p><pre class="ks kt ku kv gt nb na nc nd aw ne bi"><span id="ebbf" class="ma mb it na b gy nf ng l nh ni">Simba is heavier than Micuta. <br/>Saki is as light as Micuta. <br/>Klein is heavier than Simba.</span></pre></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><p id="147e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在<a class="ae lz" href="https://medium.com/tag/fluttering-dart/archive" rel="noopener"> <strong class="lf jd">颤动飞镖</strong> </a>系列的下一部分中，我们将深入研究<a class="ae lz" href="https://medium.com/@constanting/fluttering-dart-the-flow-7be2080763ad" rel="noopener">控制流语句</a>构建健壮颤动应用程序所需的另一个飞镖基础。</p><div class="ok ol gp gr om on"><a href="https://medium.com/@constanting/fluttering-dart-the-flow-7be2080763ad" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd jd gy z fp os fr fs ot fu fw jc bi translated">飞舞的飞镖:流动</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">所有关于控制流的语句</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">medium.com</p></div></div><div class="ow l"><div class="pk l oy oz pa ow pb lb on"/></div></div></a></div><p id="f25e" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">就这些！</p></div></div>    
</body>
</html>