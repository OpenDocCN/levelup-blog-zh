<html>
<head>
<title>Database Transaction Isolation Levels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库事务隔离级别</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/database-transaction-isolation-levels-5d76c27d42bb?source=collection_archive---------7-----------------------#2022-08-02">https://levelup.gitconnected.com/database-transaction-isolation-levels-5d76c27d42bb?source=collection_archive---------7-----------------------#2022-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e9bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一天，朋友问我:“两个并发的事务能看到对方写的数据吗？”我毫不犹豫地回答:“没有！”。然而，答案并不像我想象的那么简单。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1b4e2b14889bca700e77f45393e5bdfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GSv8boCRcTD0c9c7"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">由<a class="ae lb" href="https://unsplash.com/es/@kazuend?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> kazuend </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="7081" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">数据库一致性</h1><p id="72b1" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">每个使用数据库引擎的人都会知道它的四个重要属性，即:<strong class="jp ir">原子性、一致性、隔离性和持久性。</strong></p><p id="3d8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于第三个属性，<strong class="jp ir">隔离</strong>意味着并发执行多个事务的结果必须与顺序执行它们的结果相同。我们可以强制数据库连续运行事务以避免冲突。然而，在现实中，这种方式行不通，因为它没有很好的伸缩性。数据库处理的事务越多，性能就越差。现在，每个数据库引擎都有不同的隔离级别和实现，但是它们总是致力于运行尽可能多的事务，同时不断减少由并发事务引起的错误。</p><h1 id="8a6f" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">并发事务问题</h1><p id="0588" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在深入探讨隔离级别之前，让我们来看看不按顺序运行多个事务会发生什么。它们通常被称为竞争条件问题。</p><h2 id="42b8" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">肮脏的阅读</h2><p id="ab9d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><em class="mr">脏读</em>意味着一个事务可以看到其他事务没有提交的数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ms"><img src="../Images/7eb7befb519c23bae72c6c43f2007e19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZugyEDDDQWc1Dx2doFXUWw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">脏读问题</figcaption></figure><p id="a6b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，即使事务A没有被提交，事务B也可以看到x (3)的新值。它使用户感到困惑，并可能导致不正确的决策。此外，它还违反了<strong class="jp ir">原子性</strong>属性。如果事务A失败，中间数据不会被丢弃，可能会被事务b保存到数据库中。</p><h2 id="49f7" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">不可重复读取</h2><p id="a722" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><em class="mr">不可重复读取</em>是指一个事务在不同的时间点查询数据，但是因为数据已经被其他<strong class="jp ir">提交的</strong>事务<strong class="jp ir">修改</strong>而得到<strong class="jp ir">不同的结果</strong>的问题。</p><p id="09fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此图说明了银行系统中的<em class="mr">不可重复读取</em>问题。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/feeeb799b230015e5d21777dfd377932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPsubZ5-7lAWgp6GiYP7-g.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">不可重复读取问题</figcaption></figure><p id="0932" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们假设一个用户总共有1000美元，并将它们平均分成两个账户。一天，他从账户2向账户1转账100美元(交易B)。最后，账户1应该有600美元，账户2应该有400美元。同时，系统管理员查询两个账户的余额(交易A)。管理员读取两次，一次在事务B提交之前，另一次在提交之后。现在，管理员看到不一致的数据，用户只有$900。在这种情况下，管理员可以简单地刷新网页，他将有正确的数据。</p><p id="5e32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相比之下，这个问题在某些情况下变得更加严重，例如进行备份和执行分析查询。即使我们多次尝试运行该作业，我们也不知道结果是否是旧版本数据和新版本数据的混合。此外，这些作业非常耗时，在大型数据库上可能需要几个小时。</p><h2 id="5fdc" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">幻像读取</h2><p id="6f7b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">幻影读取是指一个事务在不同的时间点查询数据，但由于数据已经被其他<strong class="jp ir">提交的</strong>事务<strong class="jp ir">插入</strong>或<strong class="jp ir">删除</strong>而得到<strong class="jp ir">不同的结果</strong>的问题。</p><p id="abe0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到它与前面的问题非常相似。然而，在这种情况下，我们看到的数据比前一个查询更多或更少。从数据库系统的角度来看，也很难容忍暂时的不一致。</p><h2 id="a498" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">丢失更新</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/14f1e61f299cce940aed1ee83f9e96a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6CybOdc9pSUTlgubI7Y_1g.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">丢失更新问题</figcaption></figure><p id="8d89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mr">丢失更新</em>发生在多个并发事务<strong class="jp ir">从数据库中读取</strong>相同的值，<strong class="jp ir">修改</strong>并且<strong class="jp ir">写回</strong>它们修改后的值。几乎所有的应用系统都会遇到这个问题。我们可以在某些情况下看到它，例如:增加脸书帖子上的赞或评论数，同时编辑维基页面…</p><h2 id="8b54" class="mf ld iq bd le mg mh dn li mi mj dp lm jy mk ml lq kc mm mn lu kg mo mp ly mq bi translated">写入偏斜</h2><p id="597b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果多个并发事务从数据库中查询数据，并基于此做出决策，将数据的<strong class="jp ir">不同部分</strong>写回，导致数据变得不一致，则称为<em class="mr">写偏斜</em>问题。</p><p id="a936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更清楚，我们举个例子。假设您正在为您的应用程序实现基于角色的访问控制(T21)授权。一个组织有两个角色:<em class="mr">管理员</em>和<em class="mr">成员。该系统确保一个组织至少有一名管理员才能正常工作。最初，有两个管理员，如下表所示:</em></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/f307e22daf411cd9d2eefea42bf45d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePsmPhcpPwKcBfSEW6M2Yg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">发生写入偏斜前的数据</figcaption></figure><p id="3a01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Alice和Bob刚刚开始学习这个新系统，他们将自己的角色换成了会员，看看会员能做些什么。不幸的是，它们同时发生，过程如下图所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/21b32ce088ba17800d16613035a02552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TZzl1AKgjhtzbWLtCXTbTA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">写偏斜问题</figcaption></figure><p id="6bba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">应用程序创建了2个事务，他们检查组织中有多少管理员，他们都看到了2，然后继续下一步:更新他们的角色。结果，现在没有管理员，违反了上述要求！</p><p id="648d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mr">写歪斜</em>是<em class="mr">丢失更新</em>的概括。在这种情况下，事务写入不同的数据，它们不会相互覆盖，但不一致仍然会发生。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="dcb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们刚刚讨论了并发执行多个事务时出现的一些问题。在下一节中，让我们看看Mysql和Postgres如何用它们的事务隔离级别来处理它们。</p><h1 id="70e6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Mysql中的事务隔离级别</h1><p id="9350" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">Mysql提供了4个级别的事务隔离:</p><ul class=""><li id="1037" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nh ni nj nk bi translated"><em class="mr">读取未提交:</em>本级事务可以看到其他<strong class="jp ir">未提交</strong>事务的数据。</li><li id="4473" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><em class="mr"> READ COMMITTED: </em>该级别的事务只能看到其他<strong class="jp ir"> committed </strong>事务的数据。</li><li id="71f4" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><em class="mr">可重复读取:</em>一个事务在开始之前只看到<strong class="jp ir">提交</strong> <strong class="jp ir">的事务的数据。这是Mysql中默认的<strong class="jp ir">事务隔离级别。</strong></strong></li><li id="d373" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><em class="mr">可序列化:</em>Mysql中最严格的级别。它试图通过使用<strong class="jp ir">锁定</strong>来顺序运行<strong class="jp ir">事务</strong>。该级别隐式地将所有普通的SELECT语句转换为<a class="ae lb" href="https://dev.mysql.com/doc/refman/8.0/en/select.html" rel="noopener ugc nofollow" target="_blank"> SELECT … FOR SHARE </a>，并强制所有事务等待直到锁被释放。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nq"><img src="../Images/ac8dab922f27906dddde1e2d24c39960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0-o3eU1qvqpmD3-RjgheAw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Mysql中的事务隔离级别</figcaption></figure><p id="64e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上表显示了每个级别可以处理的问题。我们之前讨论的所有问题都可能发生在<em class="mr">未提交读取</em>级别。这也是为什么在现代系统中很少使用的原因。<em class="mr">提交读</em>只能解决<em class="mr">脏读</em>问题，而<em class="mr">可重复读</em>几乎可以解决所有问题，除了<em class="mr">丢失更新</em>和<em class="mr">写偏斜</em>。SERIALIZABLE level似乎是避免这些问题的最佳选择，但它的性能令人担忧，因为它几乎是串行运行事务的。</p><p id="ab5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过显式使用锁定(<a class="ae lb" href="https://dev.mysql.com/doc/refman/8.0/en/select.html" rel="noopener ugc nofollow" target="_blank"> SELECT … FOR SHARE或者SELECT … FOR UPDATE </a>)在<em class="mr"> REPEATABLE READ </em>级别实现<em class="mr"> SERIALIZABLE </em>级别的可串行化。这种灵活性有助于开发人员根据他们系统的特点选择合适的方法。</p><h1 id="5cba" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Postgres怎么样？</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/478fe3f36cbae6cadfdc0746ce042902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*goXUOk1a_ghn1tu0ELwzQw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">Postgres中的事务隔离级别</figcaption></figure><p id="d87b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Postgres也像Mysql一样支持4级事务隔离。</p><p id="060d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，<em class="mr"> READ UNCOMMITTED </em> level和<em class="mr"> READ COMMITTED </em> level做的完全一样，也就是说<em class="mr"> dirty read </em>问题并不会发生在所有级别的Postgres中。</p><p id="b561" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，Postgres中的<em class="mr"> SERIALIZABLE </em> level实现了与Mysql中相同的目标，但实现方式不同。与Mysql使用悲观锁不同，Postgres使用<a class="ae lb" href="https://wiki.postgresql.org/wiki/SSI" rel="noopener ugc nofollow" target="_blank">乐观锁</a>来解决问题。基本上，Postgres允许一个事务并发运行，不必等待其他事务。提交交易时，Postgres会检查交易的数据是否被他人修改。如果为真，事务将被强制重试。这种机制在9.1版的Postgres中得到应用，并且很有前途，因为它提供了完全的可序列化性，同时只有很小的性能损失。</p><h1 id="a573" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">最后</h1><p id="28fc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">事务隔离级别决定了运行并发事务的结果。根据数据库引擎的不同，有几个级别。开发人员需要理解它们，以便有效地解决竞争条件问题，同时仍然保持数据库的良好性能。</p><h1 id="b2ca" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">参考资料:</h1><ul class=""><li id="2acc" class="nc nd iq jp b jq ma ju mb jy ns kc nt kg nu kk nh ni nj nk bi translated"><a class="ae lb" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/ACID</a></li><li id="6925" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><a class="ae lb" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html" rel="noopener ugc nofollow" target="_blank">https://dev . MySQL . com/doc/ref man/8.0/en/innodb-transaction-isolation-levels . html</a></li><li id="ec39" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><a class="ae lb" href="https://www.postgresql.org/docs/current/transaction-iso.html" rel="noopener ugc nofollow" target="_blank">https://www . PostgreSQL . org/docs/current/transaction-iso . html</a></li><li id="2530" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated"><a class="ae lb" href="https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321" rel="noopener ugc nofollow" target="_blank">设计数据密集型应用</a> —第7章</li></ul></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="ef09" class="lc ld iq bd le lf nv lh li lj nw ll lm ln nx lp lq lr ny lt lu lv nz lx ly lz bi translated">分级编码</h1><p id="63fc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="dfb9" class="nc nd iq jp b jq jr ju jv jy ne kc nf kg ng kk nh ni nj nk bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="4c47" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated">📰查看<a class="ae lb" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="11b0" class="nc nd iq jp b jq nl ju nm jy nn kc no kg np kk nh ni nj nk bi translated">🔔关注我们:<a class="ae lb" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae lb" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae lb" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="3f34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae lb" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">加入升级达人集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>