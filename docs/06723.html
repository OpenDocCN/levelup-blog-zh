<html>
<head>
<title>concat: Learn JavaScript’s Array Methods by Building Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">concat:通过构建JavaScript的数组方法来学习它们</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/concat-learn-javascripts-array-methods-by-building-them-cd2cbb44b4e2?source=collection_archive---------14-----------------------#2020-12-22">https://levelup.gitconnected.com/concat-learn-javascripts-array-methods-by-building-them-cd2cbb44b4e2?source=collection_archive---------14-----------------------#2020-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5004" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的第三篇文章中，我们将探索<code class="fe kl km kn ko b">concat</code>方法，以及如何将复杂的逻辑抽象成一个函数，这样我们就不必考虑它了。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/91b5cbf002f3afd12b5b99515d1fdb37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZzbfIPfoq_GJSKROLBElA.png"/></div></div></figure><h1 id="f51a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">介绍</h1><p id="1cfe" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">数组是JavaScript最强大的特性之一。它们的灵活性和力量是微妙的，所以聚光灯倾向于照射在功能或物体上。这导致即使是一些涉及数组的最简单的任务也要经过层层编码。</p><p id="3a7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经研究了两种流行的JavaScript数组方法，并了解了它们如何使我们的代码更易于阅读。在本文中，我们将继续探索<code class="fe kl km kn ko b">concat</code>方法，它提供了一种将多个数组连接成一个数组的简单方法。</p><h1 id="0031" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">它是如何工作的</h1><p id="3060" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><code class="fe kl km kn ko b">concat</code>方法(缩写为<em class="me"> concatenate </em>)接受任意数量的数组，并将它们组合成一个新数组。我们可以不使用<code class="fe kl km kn ko b">concat</code>方法来实现。例如，如果我们有以下两个数组:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="85f6" class="mj lc iq ko b gy mk ml l mm mn">const num1 = [1, 2, 3];<br/>const num2 = [4, 5, 6];</span></pre><p id="0f74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以将它们与两个<code class="fe kl km kn ko b">for</code>循环结合起来(每个数组一个):</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="158f" class="mj lc iq ko b gy mk ml l mm mn">const nums = []</span><span id="6a31" class="mj lc iq ko b gy mo ml l mm mn">for (let i = 0; i &lt; num1.length; i++) {<br/>  nums.push(num1[i])<br/>}</span><span id="d5ed" class="mj lc iq ko b gy mo ml l mm mn">for (let i = 0; i &lt; num2.length; i++) {<br/>  nums.push(num2[i])<br/>}</span><span id="4fc4" class="mj lc iq ko b gy mo ml l mm mn">console.log(nums) // [1, 2, 3, 4, 5, 6]</span></pre><p id="ce91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个解决方案工作得很好，但是它有几个缺点。</p><p id="4aa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，它不是非常动态的。如果我们需要添加第三个数组，我们该怎么做？我们要增加第三个循环吗？好吧，让我们把它变得更有活力:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="a37f" class="mj lc iq ko b gy mk ml l mm mn">const numArrays = [num1, num2]</span><span id="cf66" class="mj lc iq ko b gy mo ml l mm mn">const nums = []</span><span id="3d27" class="mj lc iq ko b gy mo ml l mm mn">for (let i = 0; i &lt; numArrays.length; i++) {<br/>  let currentArray = numArrays[i]<br/>  for (let j = 0; j &lt; currentArray.length; j++) {<br/>    nums.push(currentArray[j])<br/>  }<br/>}</span><span id="b620" class="mj lc iq ko b gy mo ml l mm mn">console.log(nums) // [1, 2, 3, 4, 5, 6]</span></pre><p id="7f66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码块中，我们获取两个数组<code class="fe kl km kn ko b">num1</code>和<code class="fe kl km kn ko b">num2</code>，并将它们添加到一个数组<code class="fe kl km kn ko b">numArrays</code>。这将让我们一起处理所有的数组。然后我们遍历数组列表。然后，我们可以遍历每个数组，并将条目推入我们的<code class="fe kl km kn ko b">num</code>数组。</p><p id="5f8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它更加动态，意味着我们可以更容易地适应数据的变化。关于嵌套循环还有一点需要说明，但是我们现在可以把它放在一边。主要问题是这段代码很长，难以阅读，难以理解我们在做什么。如果你看到这段没有任何注释的代码，你会花一些时间去理解开发者想要做什么。</p><p id="50ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们想做这样的事情:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="4e08" class="mj lc iq ko b gy mk ml l mm mn">const num1 = [1, 2, 3];<br/>const num2 = [4, 5, 6];</span><span id="c5e8" class="mj lc iq ko b gy mo ml l mm mn">const nums = num1.concat(num2)</span><span id="101b" class="mj lc iq ko b gy mo ml l mm mn">console.log(nums) // [1, 2, 3, 4, 5, 6]</span></pre><p id="f6f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">眨眼就错过了！这段代码在一行易于阅读的代码中实现了相同的结果。</p><p id="3538" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哈利路亚！</p><h1 id="8e08" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">实现我们自己的</h1><p id="8a3f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们已经确定了它的作用，所以让我们来谈谈<code class="fe kl km kn ko b">concat</code>是如何做到的。要实现我们自己的，我们需要一个函数:</p><ul class=""><li id="8423" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated">接受任意数量的数组</li><li id="b8fd" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">循环通过它们</li><li id="b977" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">将每个数组的项添加到最终数组中</li><li id="0f18" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">然后，返回最后一个数组</li></ul><p id="348a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们将要构建的<code class="fe kl km kn ko b">concat</code>最终版本的规范，但是为了得到它们，我们将练习一个叫做<em class="me"> reduction </em>的技巧。我们不会试图解决所有这些问题，而是将问题的复杂性降低一点。我们的第一个解决方案将采用两个数组并将它们连接起来，然后我们将修改该解决方案以处理任意数量的数组。</p><p id="4c05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要一个带两个数组的函数:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="41c6" class="mj lc iq ko b gy mk ml l mm mn">function concat(arr1, arr2) {<br/>	// More to come here ...<br/>}</span></pre><p id="d3c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们把这两个数组合并成一个数组，这样我们就可以一起处理它们了。然后我们可以遍历组合数组:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="838f" class="mj lc iq ko b gy mk ml l mm mn">function concat(arr1, arr2) {<br/>  let arrs = [arr1, arr2]<br/>  <br/>  for (let i = 0; i &lt; arrs.length; i++) {<br/>    // More to come here ...<br/>  }<br/>}</span></pre><p id="5262" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是遍历传入的两个数组，并将每一项推入一个<code class="fe kl km kn ko b">final</code>数组，然后我们可以返回该数组:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="5467" class="mj lc iq ko b gy mk ml l mm mn">function concat(arr1, arr2) {<br/>  let arrs = [arr1, arr2]<br/>  let final = []<br/>  <br/>  for (let i = 0; i &lt; arrs.length; i++) {<br/>    let currentArray = arrs[i]<br/>    for (let j = 0; j &lt; currentArray.length; j++) {<br/>      final.push(currentArray[j])<br/>    }<br/>  }<br/>  <br/>  return final<br/>}</span></pre><p id="1c85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这与我们之前的实现是一样的，但是我们去掉了难以理解的逻辑，使其可重用。现在，当我们想要连接两个数组时，我们不必考虑<em class="me">如何</em>去做，我们只需要:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="7665" class="mj lc iq ko b gy mk ml l mm mn">const letters1 = ['a', 'b', 'c'];<br/>const letters2 = ['d', 'e', 'f'];</span><span id="5127" class="mj lc iq ko b gy mo ml l mm mn">const letters = concat(letters1, letters2);</span><span id="39b4" class="mj lc iq ko b gy mo ml l mm mn">console.log(nums) // ['a', 'b', 'c', 'd', 'e', 'f']</span></pre><p id="f19d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经解决了这个问题的简化版本。我们已经定义了一个函数，它接受两个数组并将它们连接成一个新的数组。现在我们需要解决原来的作用域，使这个函数可以处理任意数量的传入数组。为此，我们需要一种动态的方式来处理函数传入的参数。</p><h1 id="7db1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用函数的<code class="fe kl km kn ko b">arguments</code></h1><p id="266a" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们需要一种方法来处理任意数量的传入数组。有几种方法可以做到这一点，但最简单的是使用内置的<code class="fe kl km kn ko b">arguments</code>对象:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="f0a7" class="mj lc iq ko b gy mk ml l mm mn">function printArguments() {<br/>  // Print out the `arguments` object<br/>  console.log(arguments)<br/>}</span><span id="9703" class="mj lc iq ko b gy mo ml l mm mn">printArguments('hello', 'world')</span></pre><p id="1ac4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码片段中，我们定义了一个使用<code class="fe kl km kn ko b">console.log</code>打印<code class="fe kl km kn ko b">arguments</code>对象的函数。然后我们调用这个函数，传递两个参数:<code class="fe kl km kn ko b">'hello'</code>和<code class="fe kl km kn ko b">'world'</code>。</p><p id="11a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您运行这段代码，您将在控制台中看到如下内容:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="2f36" class="mj lc iq ko b gy mk ml l mm mn">{<br/>  '0': 'hello',<br/>  '1': 'world',<br/>  length: 2,<br/>  callee: ƒ printArguments(),<br/>  __proto__: { ... }<br/>}</span></pre><p id="e003" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">arguments</code>对象是类似数组的。你可以通过索引访问<code class="fe kl km kn ko b">arguments</code>中的条目(即<code class="fe kl km kn ko b">arguments[0]</code>会给你<code class="fe kl km kn ko b">'hello'</code>)，它有一个长度，但它不是一个真正的数组。</p><p id="e597" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果我们可以通过索引访问条目，那么我们就可以遍历它。所以我们可以修改我们的<code class="fe kl km kn ko b">concat</code>实现来使用<code class="fe kl km kn ko b">arguments</code>:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="17b8" class="mj lc iq ko b gy mk ml l mm mn">function concat() {<br/>  let final = []<br/>  <br/>  for (let i = 0; i &lt; arguments.length; i++) {<br/>    let currentArray = arguments[i]<br/>    for (let j = 0; j &lt; currentArray.length; j++) {<br/>      final.push(currentArray[j])<br/>    }<br/>  }<br/>  <br/>  return final<br/>}</span></pre><p id="5e88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经用<code class="fe kl km kn ko b">arguments</code>替换了<code class="fe kl km kn ko b">numsArray</code>，但是除此之外，这段代码与之前的代码是一样的。现在我们的<code class="fe kl km kn ko b">concat</code>方法可以接受任意数量的传入数组:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="4b05" class="mj lc iq ko b gy mk ml l mm mn">let num1 = [1, 2, 3]<br/>let num2 = [4, 5, 6]<br/>let num3 = [7, 8, 9]<br/>let num4 = [0]</span><span id="2699" class="mj lc iq ko b gy mo ml l mm mn">let nums = concat(num1, num2, num3, num4)</span><span id="f215" class="mj lc iq ko b gy mo ml l mm mn">console.log(nums) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</span></pre><p id="27f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经完成了我们的<code class="fe kl km kn ko b">concat</code>版本，但是我们当然可以让它更干净一点，我们现在就去做。</p><h1 id="571b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">清理我们的实现</h1><p id="cb8b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我们对<code class="fe kl km kn ko b">concat</code>的实现工作得很好，但不是很干净。在以前的文章中，我谈到了循环一般是如何难以阅读的。嗯，嵌套循环特别难！</p><p id="f238" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以开始清理这个问题，用<code class="fe kl km kn ko b">forEach</code>替换我们的<code class="fe kl km kn ko b">for</code>循环。我们只需将<code class="fe kl km kn ko b">arguments</code>转换成一个完整的数组:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="ee3b" class="mj lc iq ko b gy mk ml l mm mn">function concat() {<br/>  let final = []<br/>  let args = Array.from(arguments);</span><span id="3def" class="mj lc iq ko b gy mo ml l mm mn">  args.forEach(arg =&gt; {<br/>    arg.forEach(num =&gt; final.push(num))<br/>  })</span><span id="b006" class="mj lc iq ko b gy mo ml l mm mn">  return final<br/>}</span></pre><p id="0d7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们删除了几行代码，并使我们的实现更容易阅读。我们可以更进一步，但是使用rest和spread操作符。</p><p id="189f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将实现rest操作符，这是替换<code class="fe kl km kn ko b">arguments</code>的一种方式:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="e8d3" class="mj lc iq ko b gy mk ml l mm mn">function concat(...args) {<br/>  let final = []</span><span id="0d1e" class="mj lc iq ko b gy mo ml l mm mn">  args.forEach(arg =&gt; {<br/>    final = [ ...final, ...arg ]<br/>  })</span><span id="93a5" class="mj lc iq ko b gy mo ml l mm mn">  return final<br/>}</span></pre><p id="4aa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">剪掉了几行。这也是处理未知数量输入问题的更现代的方法。</p><p id="3f09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将使用spread运算符删除一个循环:</p><pre class="kq kr ks kt gt mf ko mg mh aw mi bi"><span id="a7a4" class="mj lc iq ko b gy mk ml l mm mn">function concat(...args) {<br/>  let final = []</span><span id="48ac" class="mj lc iq ko b gy mo ml l mm mn">  args.forEach(arg =&gt; {<br/>    final = [ ...final, ...arg ]<br/>  })</span><span id="2806" class="mj lc iq ko b gy mo ml l mm mn">  return final<br/>}</span></pre><p id="65ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">spread运算符“解包”一个对象，就像数组一样。我把它比作把背包倒扣在行李箱上，然后拉开拉链:背包里的所有东西都会掉到行李箱里。</p><p id="a9a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们解压数组(<code class="fe kl km kn ko b">arg</code>)中传递的每一个数据，让所有数据都进入<code class="fe kl km kn ko b">final</code>数组。</p><p id="01b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么我们对<code class="fe kl km kn ko b">final</code>做同样的事情？随着循环的每一次迭代，我们都在创建一个新的数组来代替之前的版本。所以在我们的<code class="fe kl km kn ko b">forEach</code>循环的第一次迭代之后，<code class="fe kl km kn ko b">final</code>数组将保存传递到<code class="fe kl km kn ko b">concat</code>的第一个数组中的所有项目。我们希望当前版本<code class="fe kl km kn ko b">final</code>中的这些项目出现在下一个版本中(在<code class="fe kl km kn ko b">forEach</code>的下一次迭代之后)，所以我们也解压它。</p><h1 id="932a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9b6e" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">您仍然可以看到，任何数组方法都可以用循环来实现，但是我们对<code class="fe kl km kn ko b">concat</code>的实现比我们之前对<code class="fe kl km kn ko b"><a class="ae nd" href="https://zkf.io/js-array-methods-foreach/" rel="noopener ugc nofollow" target="_blank">forEach</a></code>和<code class="fe kl km kn ko b"><a class="ae nd" href="https://zkf.io/js-array-methods-map/" rel="noopener ugc nofollow" target="_blank">map</a></code>的实现要复杂一些。我们可以看到，这些数组方法不仅仅是让我们的代码更具声明性，它们还隐藏了复杂性。随着我们探索一些更复杂的数组方法，比如<code class="fe kl km kn ko b">reduce</code>，这种情况会更加真实。</p><p id="41d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将详细介绍并解释和实现每个内置数组方法，这将帮助您理解它们是如何工作的，以及何时以及如何使用它们。我已经完成了<code class="fe kl km kn ko b"><a class="ae nd" href="https://zkf.io/js-array-methods-foreach/" rel="noopener ugc nofollow" target="_blank">forEach</a></code>和<code class="fe kl km kn ko b"><a class="ae nd" href="https://zkf.io/js-array-methods-map/" rel="noopener ugc nofollow" target="_blank">map</a></code>，所以如果你还没有完成的话，请检查一下。要跟进，注册我的<a class="ae nd" href="https://hawthorne.substack.com" rel="noopener ugc nofollow" target="_blank">时事通讯</a>并在<a class="ae nd" href="https://twitter.com/ZFleischmann" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我。</p></div></div>    
</body>
</html>