<html>
<head>
<title>Mongoose Beginner’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">猫鼬初学者指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mongoose-beginner-guide-4737b1ed1fe9?source=collection_archive---------5-----------------------#2020-11-25">https://levelup.gitconnected.com/mongoose-beginner-guide-4737b1ed1fe9?source=collection_archive---------5-----------------------#2020-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="a915" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">学习建议</h1><p id="344f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">学习mongoose的最好方法是从后端程序员的角度来看待它，而不是从数据库管理员的角度。</p><p id="ef12" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">Mongoose专注于帮助我们的后端程序处理需要保存到mongoDB数据库和从中检索的数据。它强调对文档的操作，而“淡化”集合和数据库的作用。事实上，如果你检查猫鼬手册的内容表，你不会找到数据库或集合。</p><p id="6037" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">原生mongoDB nodeJS驱动程序和mongo shell方法主要从集合级别操作数据。要操作任何文档，我们首先选择目标数据库，然后获取目标集合。</p><p id="31bc" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">Mongoose采用了一种完全不同的方法，大多数操作都发生在文档级。对于初学者来说，使用猫鼬可能感觉像用非惯用手写字。适应猫鼬可能需要一段时间。</p><h1 id="46b5" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">什么是猫鼬</h1><p id="20a2" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Mongoose角色的技术术语是ODM:对象数据建模。它将mongoDB文档映射到JS对象，使我们的nodeJS程序能够操作连接的mongoDB数据库。</p><p id="5d7e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">简单来说，Mongoose是连接后端程序和mongoDB服务的桥梁。原生mongoDB nodeJS驱动程序是连接nodeJS程序和mongod进程的“官方桥梁”。</p><p id="aed3" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">Mongoose构建在原生mongoDB nodeJS驱动之上。当我们通过mongoose操作mongoDB时，我们的数据库相关操作实际上是由原生nodeJS mongoDB驱动来执行的。</p><p id="93c5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果检查mongoose包的package.json文件，会发现原生mongoDB nodeJS驱动被列为依赖项。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/d6a0ab9544147e4d44c08ef919fe3d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*VStc0UmoInWK8YrLZBJrEA.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">mongoose包的package.json</figcaption></figure><p id="8276" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在学习mongoose之前，最好先学习如何使用原生nodeJS mongoDB驱动程序。</p><div class="md me gp gr mf mg"><a href="https://onlykiosk.medium.com/mongodb-nodejs-driver-8eae0ac84cb5" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">MongoDB NodeJS驱动程序</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">我们在这里有一个mongoDB部署。它是一个独立的mongod进程，托管在端口45000上。目前，这…</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">onlykiosk.medium.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu lx mg"/></div></div></a></div><h1 id="c4d3" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">为什么是猫鼬</strong></h1><p id="7a74" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">既然我们已经有了原生的mongoDB nodeJS驱动，那么重新发明轮子又有什么意义呢，尤其是考虑到新轮子是建立在旧轮子之上的？除此之外，mongoose也比原生的mongoDB nodeJS驱动更难学。</p><p id="84b3" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这是mongoose开发者必须回答的问题。为了让他们的产品物有所值，赢得更多用户，他们必须提供更多更好的服务。简单来说，mongoose是一个比原生mongodb nodeJS驱动“更大更好的桥”。mongoose不仅为我们搭建了桥梁，还为我们提供了处理、存储和检索数据的工具。</p><p id="8b86" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">原生mongoDB nodeJS驱动程序只构建桥，这意味着它只将nodeJS程序连接到mongod进程。对于我们现实生活中的项目来说，这远远不够。我们需要创建一个后端程序来操作nodeJS驱动程序。</p><p id="97a5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在某种程度上，mongoose就像一个半成品的后端程序。它将预定义的后端程序与原生mongoDB nodeJS驱动程序相结合。它为我们奠定了基础，这样我们的项目开发可以用更少的时间和精力来完成。</p><h1 id="4a55" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">安装Mongoose并连接</h1><p id="b8fa" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">安装Mongoose就像安装原生mongoDB nodeJS驱动一样。你先通过NPM安装它。然后，您需要mongoose包，并将其分配给一个变量。最好把变星命名为猫鼬。</p><p id="8bcf" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">你只需要安装mongoose包本身。您不需要安装本机驱动程序。</p><pre class="ls lt lu lv gt mv mw mx my aw mz bi"><span id="85e9" class="na jr it mw b gy nb nc l nd ne">let mongoose = require('mongoose')</span></pre><p id="9553" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在我们收到mongoose包之后，我们可以开始准备连接字符串，并将其传递给<em class="nf">mongose . connect()</em>方法。</p><p id="5eb7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><em class="nf">mongose . connect()</em>有两个参数。第一个是连接字符串，第二个是选项对象。与连接相关的选项在这里设置，并传递给本地nodeJS驱动程序。</p><p id="ffa2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">例如，在下面的示例中，用户名、密码和数据库名存储在options对象中。这三条信息将被传递给本地驱动程序的MongoClient方法，以帮助建立连接。</p><pre class="ls lt lu lv gt mv mw mx my aw mz bi"><span id="17b4" class="na jr it mw b gy nb nc l nd ne"><strong class="mw iu">// get connected using mongoose</strong></span><span id="f025" class="na jr it mw b gy ng nc l nd ne">mongoose.<strong class="mw iu">connect</strong>('mongodb://localhost:33333', {</span><span id="eed2" class="na jr it mw b gy ng nc l nd ne">useNewUrlParser:true, useUnifiedTopology:true,</span><span id="f268" class="na jr it mw b gy ng nc l nd ne"><strong class="mw iu">dbName:'cars', user:'rootUser', pass:'pwd123'</strong></span><span id="3c4e" class="na jr it mw b gy ng nc l nd ne">})</span><span id="43d3" class="na jr it mw b gy ng nc l nd ne"><strong class="mw iu">// mongoose.connect() returns a promise<br/>// the fulfilled value resolves to THIS</strong></span></pre><p id="f273" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在，我们通过mongoose连接到一个mongod进程。connect方法返回一个承诺。完成的值解析为这个值，这意味着connect方法返回一个“修改的”mongoose对象。</p><p id="549a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">就像我们之前说过的，mongoose构建在原生mongoDB nodeJS驱动之上。所以我们这里的连接实际上是由MongoClient和来自本地MongoDB nodeJS驱动程序的connect方法构建的。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/a2f501438fbefd5dfd864691b4240bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlx1MhRYVEpPWI6brBAhKQ.png"/></div></div></figure><h1 id="2405" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">猫鼬图案</h1><p id="365f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Mongoose是从帮助nodeJS程序操作mongoDB的角度来设计的。它侧重于解决现实生活中的需求。大多数与数据相关的操作都发生在文档级别。所以mongoose的设计强调文档，“淡化”了数据库和集合的作用。如果你看一下mongoose手册的内容表，你甚至找不到数据库或集合这个词。</p><p id="f8f3" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">建立连接时会预先选择数据库。因此，在我们连接后，我们不再需要担心选择数据库。</p><p id="112f" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">棘手的部分是mongoose如何看待mongoDB集合。</p><p id="0192" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">Mongoose将集合视为一组满足相同文档需求的文档。这些要求包括字段名、字段值范围和类型等。这些需求由模式描述。图式通过模型起作用。这里有两个基本的猫鼬概念:模式和模型。</p><p id="a946" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">使用mongo shell或原生mongoDB nodeJS驱动程序，我们首先创建一个数据库和一个集合。大多数与文档相关的操作都是使用集合对象中的方法执行的。</p><p id="88ae" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">但是对于mongoose，我们从在文档上设置需求开始。我们首先设计文档模式，然后基于它创建一个模型。然后，我们根据模型创建文档。我们通过文档的模型来访问集合。</p><p id="aba4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu"> Mongo Shell &amp; nodeJS驱动:db→集合→文档</strong></p><p id="2aac" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated"><strong class="kq iu">mongose:文档需求(模式)→模型→文档</strong></p><h1 id="0340" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">模式和模型</h1><p id="d52d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">MongoDB以无模式而闻名。一个集合可以接受不同种类的文档，因此给了我们很大的灵活性。但这并不意味着您应该将任何文档都塞进同一个集合中。</p><p id="5b1b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">为了保证数据安全，必须仔细检查所有的写操作，尤其是文档插入和更新。集合应该只接受合格的文档。您还可以选择使用后端程序或使用mongoDB的内置验证器来验证文档。</p><p id="b5e4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">MongoDB允许我们在更新和插入期间设置执行模式验证。验证规则是按集合级别设置的。这意味着MongoDB集合可以决定它接受哪种类型的文档。</p><p id="79ec" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">使用原生mongoDB nodeJS驱动程序，您可以使用createCollection方法创建一个集合。在其options对象中，设置validator属性来设置模式规则。</p><pre class="ls lt lu lv gt mv mw mx my aw mz bi"><span id="3c34" class="na jr it mw b gy nb nc l nd ne"><strong class="mw iu">// native mongoDB nodeJS driver</strong></span><span id="7fc6" class="na jr it mw b gy ng nc l nd ne">let client = MongoClient(uri,{options_obj})<br/>await client.connect()<br/>client.<strong class="mw iu">createCollection</strong>('<em class="nf">coll_name</em>',{ <strong class="mw iu">validator:{}</strong> })</span></pre><div class="md me gp gr mf mg"><a href="http://mongodb.github.io/node-mongodb-native/3.6/api/Db.html#createCollection" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">Node.js的MongoDB驱动程序API</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">检索MongoDB的当前分析信息。不推荐使用的方法是直接查询system.profile集合。添加一个…</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">mongodb.github.io</p></div></div></div></a></div><p id="7a3a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">猫鼬非常重视图式。<strong class="kq iu">猫鼬的一切都必须从一个模式开始。</strong>连接后您要做的第一件事是创建一个新的模式对象。</p><p id="2c18" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">要创建一个新的模式，您需要实例化<strong class="kq iu">模式构造器</strong> r并传递一个模式对象给它。模式对象规定了可接受的文档字段和字段值。</p><pre class="ls lt lu lv gt mv mw mx my aw mz bi"><span id="4198" class="na jr it mw b gy nb nc l nd ne"><strong class="mw iu">// mongoose</strong></span><span id="39cc" class="na jr it mw b gy ng nc l nd ne">const schema_example = new <strong class="mw iu">Schema</strong>({ <strong class="mw iu">brand</strong>:String, <strong class="mw iu">model</strong>:String })</span></pre><p id="edbc" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">上面的模式要求文档必须至少有两个列出的属性之一:brand和model。两个字段值都必须是字符串。</p><p id="a7e9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">Mongoose schema可以做<strong class="kq iu">许多其他事情</strong>，包括定义实例方法、静态模型方法、复合索引和中间件。目前，我们只关注使用模式来定义文档结构和属性的转换。我们当前的首要任务是弄清楚如何使用mongoose插入和读取文档。</p><h1 id="b4a6" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Mongoose模型和MongoDB集合</h1><p id="328f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">与我们使用原生NodeJS MongoDB驱动程序所做的不同，我们不能直接从模式对象转到新的集合。这中间多了一个环节:模型。事实上，mongoose并不直接访问一个集合。它通过集合的模型来操作集合。</p><p id="92e5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">为了构建模型，我们使用mongoose.model方法。它有两个参数。第一个是模型名，第二个是模式。您可以直接使用schema对象作为第二个参数值。</p><pre class="ls lt lu lv gt mv mw mx my aw mz bi"><span id="e192" class="na jr it mw b gy nb nc l nd ne">mongoose.<strong class="mw iu">model</strong>('<strong class="mw iu">model_name</strong>',schema or {schema_obj})</span></pre><p id="7b16" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">模型是建立在模式对象上的。你可以把它想象成一个文档模板。它从模式中继承文档需求，并在新文档中实施这些需求。</p><p id="ad47" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">模型名称将用于命名新集合。这里注意，型号名称不会直接作为集合名称。Mongoose附录在模型名称后面加上字母S，并使用“复数”模型名称作为集合名称。</p><p id="6961" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">例如，在下面的例子中，我们将模型命名为car_list，最终的集合名称将是car_list <strong class="kq iu"> s </strong>。</p><pre class="ls lt lu lv gt mv mw mx my aw mz bi"><span id="a655" class="na jr it mw b gy nb nc l nd ne">const <strong class="mw iu">Car</strong> = mongoose.<strong class="mw iu">model</strong>('<strong class="mw iu">car_list</strong>',schema_obj)</span></pre><p id="523d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">mongoose.model方法返回给我们一个构造函数。我们称之为模型构造器。在下面的课程中，术语模型构造函数特指由mongoose.model()方法返回的构造函数。</p><p id="6d41" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">构造函数名字的第一个字母应该大写。这就是为什么您应该大写接收模型方法返回值的变量的第一个字母。</p><p id="cc3b" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">那么模型构造器能为我们做什么呢？</p><h1 id="f768" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">通过实例化模型构造器来创建文档。</strong></h1><p id="0f9c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在我们创建了模型构造器之后，我们可以开始创建新的文档。我们首先使用JS objet文本准备新文档。然后我们需要将这个对象文字转换成一个mongoDB文档。</p><p id="42c7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这种转换是通过将这个对象文字传递给模型构造函数并实例化该构造函数来完成的。</p><p id="6c72" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">模型构造器返回给我们最终的文档。不符合架构要求的字段将从文档中删除。</p><pre class="ls lt lu lv gt mv mw mx my aw mz bi"><span id="bdbb" class="na jr it mw b gy nb nc l nd ne">const <strong class="mw iu">Car</strong> = mongoose.<strong class="mw iu">model</strong>('<strong class="mw iu">car_list</strong>',schema)</span><span id="ee43" class="na jr it mw b gy ng nc l nd ne">const car_1 = new <strong class="mw iu">Car</strong>({ brand:'Toyota', model:'Supra' })</span></pre><p id="ab1f" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在上面的例子中，我们成功地创建了一个带有两个定制字段的新文档:品牌和型号。将自动添加文档ID。新文档将由模型构造器返回。</p><p id="68eb" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">创建新文档只是第一步，最重要的一步是将其保存到mongoDB集合中。这需要save方法。这个方法来自模型构造函数返回的文档对象。</p><pre class="ls lt lu lv gt mv mw mx my aw mz bi"><span id="c13a" class="na jr it mw b gy nb nc l nd ne">car_1.save() // the save method returns a promise</span></pre><p id="dac3" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在，新文档已经保存到基于<strong class="kq iu"> car_list </strong>模型创建的<strong class="kq iu">car _ list</strong>集合中。</p><p id="4367" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这就是我们如何创建一个新文档并将其保存到mongoDB中。</p><h1 id="91db" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">从集合中读取文档</h1><p id="fa9f" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果我们需要查找保存的文档，只需将find方法连接到相应的模型构造函数。find方法是模型构造函数的静态方法。这次不需要实例化模型构造函数。</p><p id="abd5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">例如，我们想读取car_lists集合。我们将find方法连接到汽车构造器。find方法返回一个承诺。解析的值是保存检索到的文档的数组。</p><pre class="ls lt lu lv gt mv mw mx my aw mz bi"><span id="5dab" class="na jr it mw b gy nb nc l nd ne">const schema = new Schema({ brand:String, model:String })</span><span id="2038" class="na jr it mw b gy ng nc l nd ne">const <strong class="mw iu">Car</strong> = mongoose.<strong class="mw iu">model</strong>('<strong class="mw iu">car_list</strong>',schema)</span><span id="6fc6" class="na jr it mw b gy ng nc l nd ne"><em class="nf">// new </em><strong class="mw iu"><em class="nf">Car</em></strong><em class="nf">({brand:'Toyota', model:'Camry'}).</em><strong class="mw iu"><em class="nf">save()</em></strong><em class="nf"> // adding new doc</em></span><span id="dce5" class="na jr it mw b gy ng nc l nd ne"><strong class="mw iu">Car</strong>.find(( err, results )=&gt;{ console.log(results) }) </span></pre><h1 id="4a8d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">摘要:插入和阅读文档</h1><p id="c692" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">以下是完整的代码:</p><pre class="ls lt lu lv gt mv mw mx my aw mz bi"><span id="1ffd" class="na jr it mw b gy nb nc l nd ne">const mongoose  = <strong class="mw iu">require</strong>('mongoose')</span><span id="8236" class="na jr it mw b gy ng nc l nd ne"><strong class="mw iu">// mongoose.connect() returns a promise</strong></span><span id="a13e" class="na jr it mw b gy ng nc l nd ne">mongoose.<strong class="mw iu">connect</strong>('mongodb://localhost:33333',</span><span id="1a60" class="na jr it mw b gy ng nc l nd ne"> {</span><span id="9d24" class="na jr it mw b gy ng nc l nd ne">   useNewUrlParser:true, useUnifiedTopology:true,</span><span id="6482" class="na jr it mw b gy ng nc l nd ne">   dbName:'cars', user:'rootUser', pass:'pwd123'</span><span id="4693" class="na jr it mw b gy ng nc l nd ne"> }</span><span id="acdb" class="na jr it mw b gy ng nc l nd ne">)<br/>.<strong class="mw iu">then</strong>( ()=&gt;{ console.log('Connected!') } )<br/>.<strong class="mw iu">catch</strong>( ()=&gt;{ console.log('Cannot Connect!') } )</span><span id="11fc" class="na jr it mw b gy ng nc l nd ne">let schema_obj = { brand:String, model:String }</span><span id="4f17" class="na jr it mw b gy ng nc l nd ne">const<strong class="mw iu"> Car</strong> = mongoose.<strong class="mw iu">model</strong>('car_list',schema_obj)</span><span id="f654" class="na jr it mw b gy ng nc l nd ne">let <strong class="mw iu">car1</strong> = new <strong class="mw iu">Car</strong>({brand:'Lexus', engine:'Petrol'})</span><span id="2078" class="na jr it mw b gy ng nc l nd ne"><strong class="mw iu">car1</strong>.<strong class="mw iu">save</strong>() // .save() returns a promise as well</span><span id="beb1" class="na jr it mw b gy ng nc l nd ne"><strong class="mw iu">Car</strong>.find((err, results)=&gt;{ console.log(result) })</span><span id="76b5" class="na jr it mw b gy ng nc l nd ne">// Found any problems?</span></pre><p id="c370" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">上面的程序可以完美地工作。但是你发现它有什么问题吗？看save方法的位置，有什么问题吗？</p><h1 id="9668" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">不需要“等待”mongoose.connect()</h1><p id="ec83" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">save方法来自模型构造函数的实例。模型构造函数是由mongoose对象的model方法创建的。所以最后，save方法间接地来自mongoose对象。这意味着mongoose对象的状态会影响保存方法。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nm"><img src="../Images/985a6dd9ee7128c3c8f2c7e5fbc68ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*md9mLcLzpTko8_f18ZKT-A.png"/></div></div></figure><p id="70a0" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我们只能在连接到mongod进程后保存文档。这意味着当save方法被执行时，连接必须已经建立。</p><p id="976d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这意味着我们应该从mongoose connect方法的回调中运行模型并保存方法。</p><p id="b4bf" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果我们不想使用回调，我们应该在connect方法前面加上await，以便在连接建立之前保持模型和保存方法的执行。</p><p id="c607" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">所以我们这里的代码应该不起作用，因为我们把连接、建模和保存方法放在了<strong class="kq iu">相同的作用域</strong>中，而<strong class="kq iu">没有给</strong>加上前缀<strong class="kq iu">等待</strong>。所以这个程序不应该工作，因为在执行model和save方法时，连接还没有建立。在执行save方法之前，JS引擎将<strong class="kq iu">而不是</strong>等待连接建立。</p><p id="7e33" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">但这不是我们得到的结果。新文档已成功保存。那么这是怎么发生的呢？为什么一个不正确的程序可以产生正确的结果？</p><p id="9dcb" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">答案可以在手册里找到。</p><div class="md me gp gr mf mg"><a href="https://mongoosejs.com/docs/connections.html" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd iu gy z fp ml fr fs mm fu fw is bi translated">mongose v 5 . 10 . 15:连接到MongoDB</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">可以用mongoose.connect()方法连接到MongoDB。这是连接myapp数据库的最低要求…</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">mongoosejs.com</p></div></div></div></a></div><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nn"><img src="../Images/e0800db3e995ac5f4ea41a1a9d0ff732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29ebxd8fw4eEVRB7ttojng.png"/></div></div></figure><p id="6d6d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">默认情况下，mongose会缓冲模型函数，这意味着mongose会在连接建立之前暂停模型方法的执行。这就是为什么save方法可以在connect方法的回调之外工作。</p><p id="35ea" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您可以通过全局关闭bufferCommands来关闭缓冲功能。</p><pre class="ls lt lu lv gt mv mw mx my aw mz bi"><span id="cf3f" class="na jr it mw b gy nb nc l nd ne">mongoose.set('<strong class="mw iu">bufferCommands</strong>', false);</span></pre><p id="4e35" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这是一个非常有用的功能。这让我们在安排代码时更加灵活。我们可以避免嵌套回调或者使用异步await。</p><p id="5d26" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">顺便说一下，从手册的描述中，我们也可以看出，我们早在运行model方法时就需要连接，而不是save方法。建模方法还负责创建新的集合。所以它需要一个已建立的连接。</p><h1 id="2cd0" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">手动创建新收藏</h1><p id="08e8" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">猫鼬淡化了收藏的作用。它更喜欢使用模型的概念来指代集合。默认情况下，在我们创建了一个新模型之后，mongoose会自动为我们创建一个新的集合。我们可以关闭这个特性，手动创建一个新的收藏。</p><p id="5509" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在设计模式时，我们将false赋给autoCreate。</p><p id="dcb5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然后，我们将模式传递给mongoose.model()方法，以创建一个新的模型构造函数。</p><p id="c5b0" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然后我们从模型构造函数调用createCollection方法。createCollection方法返回一个承诺，有两个参数。第一个是选项对象，第二个是回调。</p><p id="3da9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在这个例子中，我们已经手动创建了一个封顶的集合。新系列仍以型号名称命名。</p><pre class="ls lt lu lv gt mv mw mx my aw mz bi"><span id="02f0" class="na jr it mw b gy nb nc l nd ne">const schema = new Schema( { <strong class="mw iu">autoCreate: false</strong> } )</span><span id="6c2a" class="na jr it mw b gy ng nc l nd ne">const New_model = mongoose.model('model_name', schema)</span><span id="89ee" class="na jr it mw b gy ng nc l nd ne">New_model.<strong class="mw iu">createCollection</strong>(<strong class="mw iu">{capped:true, size:5120}</strong>, ()=&gt;{})</span></pre><p id="d3df" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">从这个设计也可以看出，mongoose淡化了集合的作用，想用模型代替集合。模型是一组满足相同模式的文档。本质上还是一个文档级的概念。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi no"><img src="../Images/bdfe753669862efdbc8a830edfa35b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MizC-KOHCv20VUSnw9ZAog.png"/></div></div></figure></div></div>    
</body>
</html>