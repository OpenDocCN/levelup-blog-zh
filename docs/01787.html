<html>
<head>
<title>Why is Lodash Still Useful?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Lodash还有用？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-is-lodash-still-useful-1503a4215762?source=collection_archive---------10-----------------------#2020-01-29">https://levelup.gitconnected.com/why-is-lodash-still-useful-1503a4215762?source=collection_archive---------10-----------------------#2020-01-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2f5df2b43b541cdd5907de92bcdb9f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hCTv2kaKr34pB_EK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">卡尔·安德森在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="19f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着ES6和更高版本JavaScript的发布，有许多方法随之发布，扩展了语言的功能。例如，有新的数组和字符串方法，以及有用的操作符，如spread和rest操作符。</p><p id="a5f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，JavaScript仍然没有让Lodash这样的实用程序库过时，因为有许多有用的方法在JavaScript中仍然不可用。</p><p id="6b4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究Lodash的一些方法，这些方法仍然比普通的JavaScript更容易开发，包括<code class="fe le lf lg lh b">times</code>、<code class="fe le lf lg lh b">get</code>、<code class="fe le lf lg lh b">set</code>、<code class="fe le lf lg lh b">debounce</code>、<code class="fe le lf lg lh b">deburr</code>和<code class="fe le lf lg lh b">keyBy</code>方法。</p><h1 id="74ef" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak"> _。次数</strong></h1><p id="df23" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">times</code>方法让我们多次调用一个函数，将每个函数调用的所有返回结果放入一个数组，然后返回它。</p><p id="26db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它有两个参数，一个是函数被调用的次数，另一个是要调用的函数。</p><p id="33b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6ad1" class="mt lj it lh b gy mu mv l mw mx">import * as _ from "lodash";</span><span id="bdd5" class="mt lj it lh b gy my mv l mw mx">const getRandomInteger = () =&gt; Math.round(Math.random() * 100);<br/>let result = _.times(5, getRandomInteger);<br/>console.log(result);</span></pre><p id="97ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可能会得到以下结果:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="02c0" class="mt lj it lh b gy mu mv l mw mx">[16, 83, 35, 87, 41]</span></pre><h1 id="0625" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak"> _。去抖</strong></h1><p id="0807" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">debounce</code>方法将一个函数的调用延迟一段指定的时间。用JavaScript实现这一点并不容易。</p><p id="913c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对于事件处理非常有用，在这种情况下，我们希望等待事情完成，然后调用一个函数。例如，使用预输入搜索，反跳会等到用户完成输入后再进行API调用，从而消除服务器上不必要的点击。</p><p id="c638" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它。给定以下数字输入:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="293b" class="mt lj it lh b gy mu mv l mw mx">&lt;input type="number" /&gt;</span></pre><p id="397d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以编写以下JavaScript代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2243" class="mt lj it lh b gy mu mv l mw mx">import * as _ from "lodash";</span><span id="b488" class="mt lj it lh b gy my mv l mw mx">const checkPositiveNumber = e =&gt; {<br/>  console.log(+e.target.value &gt; 0);<br/>};</span><span id="844f" class="mt lj it lh b gy my mv l mw mx">const numInput = document.querySelector("input[type=number]");<br/>numInput.addEventListener("input", _.debounce(checkPositiveNumber, 600));</span></pre><p id="1e96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码有<code class="fe le lf lg lh b">checkPositiveNumber</code>函数，它检查输入的值是否为正。然后我们使用<code class="fe le lf lg lh b">debounce</code>方法，该方法在调用函数之前以毫秒为单位获取函数和延迟。</p><p id="177b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由<code class="fe le lf lg lh b">debouce</code>返回的函数具有与原始函数相同的参数和内容，除了在调用它之前延迟了给定的毫秒数。</p><h1 id="ca75" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak"> _。获取</strong></h1><p id="23ae" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">get</code>方法让我们以安全的方式访问对象的属性。也就是说，即使属性的路径不存在，它也将返回<code class="fe le lf lg lh b">undefined</code>或默认值，而不是使程序崩溃。</p><p id="359b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，给定以下对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5576" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  foo: {<br/>    bar: { baz: { a: 3 } },<br/>    foo: { b: 2 },<br/>    baz: [1, 2, 3]<br/>  }<br/>};</span></pre><p id="ddde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过以下方式访问<code class="fe le lf lg lh b">obj</code>的属性:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8a8b" class="mt lj it lh b gy mu mv l mw mx">const result = _.get(obj, "foo.bar.baz.a", 1);</span></pre><p id="48ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个参数是我们想要访问属性值的对象。第二个是属性的路径。最后一个参数是默认值。</p><p id="ae55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于<code class="fe le lf lg lh b">result</code>我们应该得到3。</p><p id="c658" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果路径不存在或者它是<code class="fe le lf lg lh b">undefined</code>，那么我们得到<code class="fe le lf lg lh b">undefined</code>或者返回一个默认值。</p><p id="e374" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="774f" class="mt lj it lh b gy mu mv l mw mx">const result = _.get(obj, "foo.bar.a", 1);</span></pre><p id="3d7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们为<code class="fe le lf lg lh b">result</code>得到1。</p><p id="6726" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不指定默认值，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="25b7" class="mt lj it lh b gy mu mv l mw mx">const result = _.get(obj, "foo.bar.a");</span></pre><p id="2eac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe le lf lg lh b">undefined</code>。</p><p id="8595" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在可选的链接操作符成为主流之前，没有办法安全地获取深度嵌套属性的值。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/30c031d23b266cc483a43caace7a93b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ab1V_a9L_T65znL0"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jorgezapatag?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">豪尔赫·萨帕塔</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="d689" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">_.设置</h1><p id="0a2d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">还有一个<code class="fe le lf lg lh b">set</code>方法可以给对象的属性赋值。例如，给定我们之前拥有的同一个对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="83ba" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  foo: {<br/>    bar: { baz: { a: 3 } },<br/>    foo: { b: 2 },<br/>    baz: [1, 2, 3]<br/>  }<br/>};</span></pre><p id="fa56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过编写以下代码来设置属性的值:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d56e" class="mt lj it lh b gy mu mv l mw mx">_.set(obj, "foo.bar.a", 1);</span></pre><p id="ba92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">obj</code>对象被就地改变。正如我们所见，它可以为尚不存在的属性设置值。原始对象没有<code class="fe le lf lg lh b">foo.bar.a</code>，它添加后自动将值设置为1。</p><p id="cda5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="91ab" class="mt lj it lh b gy mu mv l mw mx">{<br/>  "foo": {<br/>    "bar": {<br/>      "baz": {<br/>        "a": 3<br/>      },<br/>      "a": 1<br/>    },<br/>    "foo": {<br/>      "b": 2<br/>    },<br/>    "baz": [<br/>      1,<br/>      2,<br/>      3<br/>    ]<br/>  }<br/>}</span></pre><p id="45e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使嵌套对象不存在，它也能工作，所以如果我们写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9248" class="mt lj it lh b gy mu mv l mw mx">_.set(obj, "foo.foofoo.bar.a.b", 1);</span></pre><p id="130e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6f7b" class="mt lj it lh b gy mu mv l mw mx">{<br/>  "foo": {<br/>    "bar": {<br/>      "baz": {<br/>        "a": 3<br/>      }<br/>    },<br/>    "foo": {<br/>      "b": 2<br/>    },<br/>    "baz": [<br/>      1,<br/>      2,<br/>      3<br/>    ],<br/>    "foofoo": {<br/>      "bar": {<br/>        "a": {<br/>          "b": 1<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h1 id="7932" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak"> _。去毛刺</strong></h1><p id="2fce" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">要从字符串字符中删除重音符号，我们可以使用<code class="fe le lf lg lh b">deburr</code>方法。它接受一个字符串并返回一个新字符串，其中有重音的字符被没有重音的字符替换。</p><p id="2013" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有<code class="fe le lf lg lh b">“S’il vous plaît”</code>:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0dfd" class="mt lj it lh b gy mu mv l mw mx">const result = _.deburr("S'il vous plaît");</span></pre><p id="60be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe le lf lg lh b">result</code>就是<code class="fe le lf lg lh b">"S’il vous plait"</code>。“我”不再有重音。</p><h1 id="9f24" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak"> _。按键操作</strong></h1><p id="6712" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">keyBy</code>方法接受一个数组和属性名，并返回一个对象，将属性值作为对象的键。</p><p id="58b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下数组:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0167" class="mt lj it lh b gy mu mv l mw mx">const people = [<br/>  { name: "Joe", age: 20 },<br/>  { name: "Jane", age: 18 },<br/>  { name: "Mary", age: 20 }<br/>];</span></pre><p id="f453" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以如下使用<code class="fe le lf lg lh b">keyBy</code>:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4cbc" class="mt lj it lh b gy mu mv l mw mx">const results = _.keyBy(people, "name");</span></pre><p id="fa23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe le lf lg lh b">results</code>会有以下内容:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="cd42" class="mt lj it lh b gy mu mv l mw mx">{<br/>  "Joe": {<br/>    "name": "Joe",<br/>    "age": 20<br/>  },<br/>  "Jane": {<br/>    "name": "Jane",<br/>    "age": 18<br/>  },<br/>  "Mary": {<br/>    "name": "Mary",<br/>    "age": 20<br/>  }<br/>}</span></pre><p id="bad9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们通过编写以下内容获得名为<code class="fe le lf lg lh b">'Joe'</code>的对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4be1" class="mt lj it lh b gy mu mv l mw mx">results['Joe']</span></pre><p id="8e75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果不编写多行代码，用普通的JavaScript无法轻松做到这一点。</p><h1 id="1e95" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="2c39" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">Lodash有许多有用的函数，它们没有像这些方法一样容易使用的等价函数。</p><p id="03dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一种在一行中多次调用一个函数的<code class="fe le lf lg lh b">times</code>方法。<code class="fe le lf lg lh b">debounce</code>函数返回一个新函数，它具有与原始函数相同的签名和代码，但是它在被调用之前被延迟了给定的毫秒数。</p><p id="de68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了安全地访问和设置对象属性和值，有<code class="fe le lf lg lh b">get</code>和<code class="fe le lf lg lh b">set</code>方法，当我们访问不存在或有值<code class="fe le lf lg lh b">undefined</code>的属性路径时，它们不会崩溃。</p><p id="dc3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后是用这些字符的非重音版本替换重音字符的<code class="fe le lf lg lh b">deburr</code>方法。</p><p id="e95a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，有一个<code class="fe le lf lg lh b">keyBy</code>方法将一个数组传递到一个对象中，该对象将每个条目的给定属性值作为键，并将具有给定属性值的条目作为这些键的值。</p></div></div>    
</body>
</html>