<html>
<head>
<title>Design Best Practices In .NET C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在中设计最佳实践。NET C#</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-best-practices-in-net-c-8e37b7c3500a?source=collection_archive---------1-----------------------#2022-01-10">https://levelup.gitconnected.com/design-best-practices-in-net-c-8e37b7c3500a?source=collection_archive---------1-----------------------#2022-01-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="a038" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">最佳实践</h2><div class=""/><div class=""><h2 id="1efb" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">一些需要遵循的设计最佳实践。NET C#</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/81460da17669e628db81b475e72cfa95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SS8Bq9f9iyVYIyjGQwyEgA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae lh" href="https://unsplash.com/@macroman?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Immo Wegmann </a>拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><p id="5843" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在软件领域工作了一段合理的时间后，日复一日，你会越来越有信心，仍然有一些你还不知道的新事物。</p><p id="4d48" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据您对不同类型的项目和需求的接触，您将利用新的技能。不过，依我拙见，最珍贵的技能是<strong class="lk jd">分析</strong>和<strong class="lk jd">设计</strong>技能。</p><p id="9efc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不要误解我的意思，我们都知道最终会有一些代码需要编写，并且最终会有人去做。然而，编写代码可以从在线或离线文档或教程中学习。另一方面，<strong class="lk jd">分析</strong>和<strong class="lk jd">设计</strong>技能不同…</p><p id="f447" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将探索一些实践证明有效的<strong class="lk jd">设计最佳实践</strong>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><div class="mf mg gp gr mh mi"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">🔥订阅艾哈迈德的时事通讯🔥</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">medium.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw lb mi"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="bd92" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">统一返回对象</h1><p id="73a2" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">你知道当你发现自己需要描述一个方法返回的数据时？我们称之为<strong class="lk jd">元数据</strong>,因为这种信息不是数据本身，而是一些重要的信息，这些信息可以在以后被同一个模块或其他模块用来理解实际的数据或知道如何处理数据。</p><p id="391b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时，您需要定义一些元数据并在系统中传播，这一点听起来很清楚，但有时有点棘手。</p><p id="d0a1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用<strong class="lk jd">元数据</strong>的一个著名例子是树结构中的节点对象。除了树结构中关于节点名称、id…和位置的信息之外，您知道每个节点最终都应该保存一些关于业务层次结构中某个实体的信息。</p><p id="2e55" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，有时并不清楚你是否有元数据T21。</p><p id="2df9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">当调用一个</strong> <code class="fe nu nv nw nx b"><strong class="lk jd">void RenameFile(string newName)</strong></code> <strong class="lk jd">方法</strong>时，传入一个新名称，并且不期望任何返回。然而，在现实世界中，这可能是一个问题，因为可能在保存该文件的文件系统中，这个<code class="fe nu nv nw nx b">newName</code>已经存在。在这种情况下，该方法需要返回一些东西来通知调用者这一点。</p><p id="499b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我可以听到有人说“让我们以新名称的字符串形式返回”或者另一个人说“让我们在这种情况下抛出一个异常”。</p><p id="8d3e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些解决方案可能有效，但是，这里最好的办法是返回一个统一的对象，其中包含一些描述实际发生的事情的数据。类似于:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="aa77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">返回统一对象的一些好处:</p><ol class=""><li id="423c" class="oa ob it lk b ll lm lo lp lr oc lv od lz oe md of og oh oi bi translated">将逻辑移动到它实际属于的地方，因为在大多数情况下，这迫使调用的处理程序完成其全部工作并提供全部信息，而不是毫无逻辑地将此委托给调用者。</li><li id="1a62" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">在调用者和处理者之间定义一个更清晰的契约。</li><li id="3efb" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">呼叫者现在可以根据处理程序提供的全部信息做出准确的决定。</li><li id="fd4e" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">处理统一对象使得设计通用模块变得更加容易。</li><li id="0ff8" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">还有其他人…</li></ol><p id="0161" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想看使用<strong class="lk jd">统一返回对象</strong>的实际实现，你可以查看<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/paging-partitioning-main-equations-to-make-it-easy-44fe89d5290b?sk=f65265d7b4c203ac219e7dec1208c0f2"> <strong class="lk jd">分页/分区——学习主要的等式以使</strong> </a>和<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/better-enhanced-repository-pattern-implementation-in-net-c-4e6f4bbe48a9?sk=dff8866ff91a36a314de8eb40a169955"> <strong class="lk jd">更好的增强存储库模式实现。NET C# </strong> </a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="9c09" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">不要滥用依赖注入(DI)、控制反转(IoC)和IoC容器</h1><p id="3162" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">假设您正在定义<code class="fe nu nv nw nx b">Car</code>类，并且在<code class="fe nu nv nw nx b">Accelerate</code>方法中您想要记录一条关于汽车当前速度的消息。你会把你的华丽的<code class="fe nu nv nw nx b">ILogger</code>注入到类的构造函数中，然后开始使用它，对吗？</p><p id="2795" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，它可以工作，不幸的是，根据今天的设计标准，这是完美的。不过，我可以问你一件事吗？</p><p id="7d11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们没有一个<code class="fe nu nv nw nx b">ILogger</code>，<code class="fe nu nv nw nx b">Car</code>级应该能有预期的表现吧？我们是否可以说<code class="fe nu nv nw nx b">Car</code>类实际上依赖<code class="fe nu nv nw nx b">ILogger</code>到了没有它就无法完成工作的程度？</p><p id="6539" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">答案很简单，<code class="fe nu nv nw nx b">Car</code>不应该依赖于<code class="fe nu nv nw nx b">ILogger</code>。你可能会说，即使它不完全依赖它，它仍然需要它。我对此的回答是:不完全是。<code class="fe nu nv nw nx b">Car</code>甚至不需要<code class="fe nu nv nw nx b">ILogger</code>，真正需要<code class="fe nu nv nw nx b">ILogger</code>的是知道<code class="fe nu nv nw nx b">Car</code>和<code class="fe nu nv nw nx b">ILogger</code>的主应用程序。主应用程序需要从<code class="fe nu nv nw nx b">Car</code>获取一些信息，然后开始使用<code class="fe nu nv nw nx b">Ilogger</code>记录这些信息。</p><p id="0288" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，这里正确的设计是完全去除这种依赖性，开始实现<strong class="lk jd">事件</strong>。因此，在我们的例子中，<code class="fe nu nv nw nx b">Car</code>类需要定义一个<code class="fe nu nv nw nx b">CarAccelerationChanged</code>事件，主应用程序应该订阅它。</p><p id="30e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想了解更多这方面的内容，可以查看<a class="ae lh" href="https://betterprogramming.pub/when-not-to-use-di-ioc-and-ioc-containers-f95881d0fe0?sk=b2aa002a72db4258756feb9cf1daa2a9" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">何时不使用DI、IoC和IoC容器</strong> </a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="7d0b" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">委派控制如何触发事件</h1><p id="8712" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">现在，您听取了前面的建议，在<code class="fe nu nv nw nx b">Car</code>类中定义了伟大的<code class="fe nu nv nw nx b">CarAccelerationChanged</code>事件，现在让我们看看您是如何实现它的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="cf58" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">太好了，它工作得很好。然而，如果你现在有一种新型汽车，一辆<code class="fe nu nv nw nx b">GhostCar</code>呢？这个<code class="fe nu nv nw nx b">GhostCar</code>是一个<code class="fe nu nv nw nx b">Car</code>但是它是无声的，它不应该报告它的加速度。</p><p id="4161" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，您需要执行如下操作:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2233" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你必须对<code class="fe nu nv nw nx b">Car</code>类做一些修改，你必须从那里复制一些逻辑，这是因为你只想停止触发<code class="fe nu nv nw nx b">CarAccelerationChanged</code>事件。</p><p id="23c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以通过遵循一个<strong class="lk jd">最佳实践</strong>从一开始就避免这种情况。您应该已经如下定义了您的<code class="fe nu nv nw nx b">Car</code>类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="5033" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">快照结构</h1><p id="a2db" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">继续我们的<code class="fe nu nv nw nx b">Car</code>类，现在你正在构建一个<code class="fe nu nv nw nx b">Tracker</code>模块，它应该跟踪<code class="fe nu nv nw nx b">Car</code>加速度。现在很明显，<code class="fe nu nv nw nx b">Tracker</code>模块将订阅<code class="fe nu nv nw nx b">CarAccelerationChanged</code>事件，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="703b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们有一个问题，<code class="fe nu nv nw nx b">Car</code>在产生<code class="fe nu nv nw nx b">Tracker</code>之前已经在以稳定的加速度移动了。这意味着在创建<code class="fe nu nv nw nx b">Tracker</code>的实例时，第<strong class="lk jd"> 13 </strong>行的<code class="fe nu nv nw nx b">ShowOnScreen(CurrentAcceleration)</code>调用将在屏幕上显示<strong class="lk jd">零</strong>，尽管这不是真的。</p><p id="0a6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了解决这个问题，你需要你的<code class="fe nu nv nw nx b">Car</code>类来公开一个加速属性，然后使用这个属性来获得第13行的加速度的初始值。</p><p id="12da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，如果不仅仅是关于加速度呢？如果你有更多的属性来反映某一时刻的<code class="fe nu nv nw nx b">Car</code>状态呢？在<code class="fe nu nv nw nx b">Car</code>类中为所有这些创建属性并不好。</p><p id="b9cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这方面有一个最佳实践，称为<strong class="lk jd">快照</strong>。因此，要应用这一点，代码应该如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="bb58" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">遵循以下模式:</p><ol class=""><li id="2568" class="oa ob it lk b ll lm lo lp lr oc lv od lz oe md of og oh oi bi translated">我们定义了一个<code class="fe nu nv nw nx b">CarState</code>类，用加速度和温度来表示<code class="fe nu nv nw nx b">Car</code>在某一时刻的状态。注意，它是不可变的。</li><li id="97bf" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">它还实现了<code class="fe nu nv nw nx b">IEquatable&lt;CarState&gt;</code>,因此在任何时候，我们都可以比较不同时刻的两个状态，看看状态是否发生了变化。供您参考，如果您使用的是Visual Studio，您可以使用一些键盘快捷键轻松生成这些成员(在我的VS键盘方案上，是<strong class="lk jd"> Alt + Insert </strong>)。</li><li id="26b7" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">我们在<code class="fe nu nv nw nx b">Car</code>类中定义了<code class="fe nu nv nw nx b">public CarState Snapshot</code>。</li><li id="4b6f" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">在<code class="fe nu nv nw nx b">Accelerate</code>方法中，我们现在正在更新<code class="fe nu nv nw nx b">Snapshot</code>并在任何需要的地方使用它。</li><li id="aac5" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">现在，在<code class="fe nu nv nw nx b">Tracker</code>类中，除了订阅<code class="fe nu nv nw nx b">CarAccelerationChanged</code>事件之外，我们还使用<code class="fe nu nv nw nx b">Snapshot</code>来获得加速度值。</li></ol><p id="7d02" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，这是完美的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="da1c" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">不变</h1><p id="126f" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">长话短说，不变性是好的，让我们做更多🙂</p><p id="407b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">开个玩笑，要知道为什么不变性是好的，让我们看看:</p><ol class=""><li id="0294" class="oa ob it lk b ll lm lo lp lr oc lv od lz oe md of og oh oi bi translated">你保持对象的状态安全，不被篡改。</li><li id="07b8" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">你可以依靠它来做很多事情，比如比较来检查状态。</li><li id="0441" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">您可以轻松地编写单元测试。</li><li id="4bfe" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">你可以写干净的代码。</li><li id="fa39" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">您可以省去在应用更改之前复制对象以保持不同状态的麻烦。</li><li id="5f3d" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated">还有其他人…</li></ol><p id="14a1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，正如我们对<code class="fe nu nv nw nx b">CarState</code>类所做的，这是使类不可变的方法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3f9c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里值得一提的是，从C# 9.0开始我们有了一个叫做<code class="fe nu nv nw nx b">Record</code>的东西。我将让你去寻找它。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="bd46" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">分页和分区</h1><p id="4708" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">分页是被广泛使用的模式之一，但是几乎没有人在设计实践中谈论它。简单来说，没有什么是绝对的。</p><p id="cdd0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当你创建一个API时，不管它是不是REST API，你都必须控制流经你的API的数据量。是的，你可以说你没有极限，但实际上，没有。你有极限，但这些极限是如此之高，以至于你错过了它们。</p><p id="a5ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我总是建议开发人员在设计API时要做的是设置一个节流策略，并设计解决方案，使他们的API和节流策略协调工作。</p><p id="d98f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，如果您有一个<code class="fe nu nv nw nx b">GetAllEmployees</code> API，那么您应该只允许调用者获取少于10，000人的所有雇员。然而，如果有一天系统拥有超过10，000名员工，此时应该只返回第一个10，000名员工，并向调用者提供一个<strong class="lk jd">元数据</strong>对象，告诉他发生了什么以及如何获得下一个10，000名员工，等等……这就是<strong class="lk jd">分页</strong>我的朋友。</p><p id="818c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想了解更多关于分页的内容，可以查看<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/paging-partitioning-main-equations-to-make-it-easy-44fe89d5290b?sk=f65265d7b4c203ac219e7dec1208c0f2"> <strong class="lk jd">分页/分区——学习主要方程使之变得简单</strong> </a> <strong class="lk jd">。</strong></p><p id="8930" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想看一个如何在设计API中使用分页的实际例子，你可以查看。NET C#  。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="a675" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">代表职能&lt;&gt;</h1><p id="a8b7" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">大多数时候，当我想定义一个方法的引用时，我更喜欢定义一个<code class="fe nu nv nw nx b">delegate</code>，然后开始使用它。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9181" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这两种方式的区别在于，通过定义的<code class="fe nu nv nw nx b">delegate</code>，您可以获得更好的智能感知和自动完成支持</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/b5f6b2f692a8969a5e3220aee8de09f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*xtVRz2cqxxWFkA2UHxRZnA.png"/></div></figure><p id="71f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">而不是像这样以另一种方式结束</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi op"><img src="../Images/68710696657a22b88310f06d44fd38bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*a0hU29eels-A7q3K_9fmqA.png"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="1b49" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">字符串。GetHashCode噩梦</h1><p id="d690" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">你有没有想过<code class="fe nu nv nw nx b">String.GetHashCode</code>会让你发疯？如果没有，它发生了，我的朋友。</p><p id="493d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在做兼职项目时，我遇到了一个让我抓狂的恼人问题。我花了一段时间才明白是怎么回事，最后我发现是由<code class="fe nu nv nw nx b">String.GetHashCode</code>引起的。</p><p id="44ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">长话短说，如果你打算持久保存从<code class="fe nu nv nw nx b">String.GetHashCode</code>返回的值，以便将来在不同的应用程序运行会话中使用，你应该用不同的方法。</p><p id="3108" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想了解这个问题以及如何修复它，你就需要查看文章<a class="ae lh" href="https://itnext.io/when-string-gethashcode-in-net-c-drives-you-crazy-c97ac7507d7b?sk=f9baa36c281e5f8afd79ef665ab39953" rel="noopener ugc nofollow" target="_blank">中的<strong class="lk jd">时的字符串。中的GetHashCode()。NET C#让你疯狂</strong> </a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="1bd9" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">将状态与行为分开</h1><p id="f372" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">在过去，我们曾经解释过<strong class="lk jd">面向对象编程(OOP)语言</strong>中的<strong class="lk jd">类</strong>的含义，它是用来创建对象的模板。我们常说这个模板定义了对象的状态和行为。</p><p id="8c6d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，按照这个概念，我们过去用字面上属于一个对象的一切来定义类，这包括状态和行为。</p><p id="749a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，在多年开发不同种类的软件系统之后，这种工作方式被证明是低效的，特别是在<strong class="lk jd">游戏开发</strong>领域。</p><p id="50f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<strong class="lk jd">游戏开发</strong>领域，对象更有可能改变它们的状态和行为，有时是分开的。因此，很难接受一个对象总是被这些随时可能改变的变量所膨胀。因此，需要一种新的工作方式。</p><p id="caa4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单来说:</p><ol class=""><li id="a481" class="oa ob it lk b ll lm lo lp lr oc lv od lz oe md of og oh oi bi translated"><strong class="lk jd">状态</strong>应该容易持久化、复制、再复制。</li><li id="66f3" class="oa ob it lk b ll oj lo ok lr ol lv om lz on md of og oh oi bi translated"><strong class="lk jd">行为</strong>应该在运行时根据需要和变化轻松切换。</li></ol><p id="8ab1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想阅读更多关于这个主题的内容，你可以查看文章<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/strategy-design-pattern-in-net-c-b9dbd863c31e?sk=e96fabc74efc59f6ba55784788b3b69f"> <strong class="lk jd">中的策略设计模式。</strong>NET c#</a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="332f" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">不使用IoC容器不是借口</h1><p id="7dd5" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">好吧，有时我看到开发人员在新项目或遗留项目上工作，我注意到<code class="fe nu nv nw nx b">new</code>关键字分散在整个解决方案中。</p><p id="1a11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">大多数时候当我问为什么我得到的答案是:</p><blockquote class="oq or os"><p id="73ad" class="li lj ot lk b ll lm kd ln lo lp kg lq ou ls lt lu ov lw lx ly ow ma mb mc md im bi translated">不幸的是，我们没有使用控制反转(IoC)容器。</p></blockquote><p id="6921" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好的，我明白了，出于某种原因，你没有使用控制反转(IoC)容器。但是，然后呢？！！</p><p id="e637" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这不是借口。让我用简单的话来说。</p><p id="cc6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">开发人员有时会对<strong class="lk jd">依赖注入(DI) </strong>、<strong class="lk jd">控制反转(IoC) </strong>和<strong class="lk jd"> IoC容器</strong>感到困惑。</p><p id="db30" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是三件不同的事情，有时它们并不在一起。它不像一个包裹，你要么全部接受，要么全部放弃。</p><p id="41b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">控制反转(IoC) </strong>讲的是哪个模块应该依赖哪个模块。因此，它主要是关于以正确的方式定义你的依赖关系。</p><p id="cce5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">依赖注入(DI) </strong>是关于在依赖它的模块内部注入依赖的方法。</p><p id="9e64" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">IoC容器是关于将依赖抽象映射到实现的方法。</p><p id="9ad3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，如果你在一天结束时没有使用IoC容器，这并不意味着你的依赖项应该在没有任何计划和设计的情况下浮动。</p><p id="f80c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，你最终会需要使用<code class="fe nu nv nw nx b">new</code>,但是在一些孤立的地方使用它和在解决方案的任何地方都使用它是有很大区别的。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="fc20" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">包装静态对象和第三方</h1><p id="d74f" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">大多数时候，我们在编写单元测试时遇到的困难是由静态对象和第三方引起的，我们开始在产品代码中直接使用它们。</p><p id="2a8f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于静态对象和第三方，你失去了使用mocks和stubs的好处，实际上你让你的生活变得如此艰难。</p><p id="6897" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，您应该将这些抽象出来，并将其包装到您可以轻松模仿和粘贴的薄包装中。</p><p id="3065" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想看一个如何做到这一点的实际例子，你可以查看<a class="ae lh" href="https://itnext.io/how-to-fully-cover-net-c-console-application-with-unit-tests-446927a4a793?sk=63c75b56de78903f09f0d0116df5fe3a" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">如何完全覆盖。带有单元测试的. NET C#控制台应用程序</strong> </a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="1365" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">使用计时器的最佳实践</h1><p id="8305" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">在某些情况下，您会发现您需要在解决方案中使用计时器。这是可以的。然而，不可以的是，你假设你不能完全控制你的计时器。</p><p id="dd3d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过控制，我的意思是能够完全测试使用定时器的模块。我知道一些开发者把计时器当成黑洞来处理。有时，在某种程度上，他们使用带有“等待”的循环，而不是使用计时器。</p><p id="9738" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好吧，我明白了，这不是直截了当的，但也不是不可能。我已经写了一篇带有代码示例的文章。如果你愿意，你可以查看文章<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/best-practice-for-using-system-timers-timer-in-net-c-867ab6b5027?sk=df2c03aff9a8bddbd62ce4d342d55c71"> <strong class="lk jd">中使用定时器的最佳实践。NET C# </strong> </a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="33de" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">避免代码隐藏意图</h1><p id="48bb" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">有一次，我和一个开发朋友聊天，聊到一半时，我告诉他我们的代码意图应该很清楚。他说到这里停了下来，说这是他第一次听到这句话。</p><p id="bd9f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我不确定这是不是我发明的，或者只是我脑海中的一个想法。不过，现在这不是重点。</p><p id="944e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了解释我所说的隐藏的意图，让我先解释一些事情。在软件解决方案中，我们有不同的模块。这些模块通过契约相互交互。这些契约代表了输入和输出，但这不是全部。</p><p id="b796" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">契约也代表了一些逻辑和它的商业意义。因此，如果你有一个包含两个方法的接口，比如<code class="fe nu nv nw nx b">CalculateIncomeTax</code>和<code class="fe nu nv nw nx b">CalculateVatTax</code>，你不能假设终端用户只关心输入和输出，不，他需要相信实现者不会交换这两个方法的实现。这是编译器无法检测到的。</p><p id="d2e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你已经知道SO <strong class="lk jd"> L </strong> ID原则中的<strong class="lk jd">利斯科夫替代原则</strong>，那么你会注意到这指的是我们正在谈论的东西。</p><p id="2d09" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想了解更多关于这个话题的内容，可以查看文章<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/the-liskov-substitution-principle-explained-in-net-c-2a838b8a5155?sk=e12ebd1a8be3c4e2fb7a6670a487f8bf"><strong class="lk jd">SOLID:lis kov Substitution Principle中的解释。NET C# </strong> </a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="fbf8" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">在通用接口旁边定义非通用接口</h1><p id="db63" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">好吧，仿制药是好的，但是……T2就足够了吗？我还需要定义<code class="fe nu nv nw nx b">IMyInterface</code>吗？</p><p id="73e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了理解我的意思，你需要看一个真实的例子，这个例子我在我的文章<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/a-best-practice-for-designing-interfaces-in-net-c-2c6ebdb4f1c1?sk=1f07b674adf763b7567d652ddd9f4a43"> <strong class="lk jd">中已经做过了。NET C# </strong> </a>。</p><p id="816c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我给你的建议是去看看这篇文章，因为它会带你经历整个经历。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ox"><img src="../Images/20ca78dc3120c31c859165c18c887c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MMfdvz7X9A0g7aRWwIvsNA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@peterampazzo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">皮埃特罗·拉姆帕佐</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄，由<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="bf91" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">最后的话</h1><p id="e0aa" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">这些就是我想与你分享的所有<strong class="lk jd">设计最佳实践</strong>吗？绝对没有，但是，这些是最重要的，相信我，我认识一些实际上并不了解它们的前辈。</p><p id="4990" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就这样，希望你觉得读这个故事和我写它一样有趣。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="5502" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="57d4" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">如果您还不是<strong class="lk jd">中型</strong>会员，您可以使用<a class="ae lh" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="lk jd">我的推荐链接</strong> </a>，这样我就可以从<strong class="lk jd">中型</strong>中获得您的一部分费用，您无需支付任何额外费用。订阅<br/><a class="ae lh" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"><strong class="lk jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他很酷的东西直接发送到您的收件箱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="917b" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">其他资源</h1><p id="bcae" class="pw-post-body-paragraph li lj it lk b ll np kd ln lo nq kg lq lr nr lt lu lv ns lx ly lz nt mb mc md im bi translated">这些资源可能对你有用。</p><div class="mf mg gp gr mh mi"><a rel="noopener  ugc nofollow" target="_blank" href="/hierarchical-tree-form-data-in-net-c-d2a868fcb756"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">中的分层树形数据。NET C#</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">为分层树形数据及其相关操作设计一个数据结构。NET C#</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mr l"><div class="oy l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a rel="noopener  ugc nofollow" target="_blank" href="/passing-parameters-to-a-net-c-method-388badb7c095"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">将参数传递给. NET C#方法</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">向. NET C#方法传递参数的不同方式。</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mr l"><div class="oz l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a rel="noopener  ugc nofollow" target="_blank" href="/builder-design-pattern-in-net-c-bbf11c891548"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">中的生成器设计模式。NET C#</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">一步一步的指南，从零开始开发一个流畅的API。NET C#使用生成器设计模式。</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mr l"><div class="pa l mt mu mv mr mw lb mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a rel="noopener  ugc nofollow" target="_blank" href="/when-implementations-affect-abstractions-1bb2adc808d1"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd jd gy z fp mn fr fs mo fu fw jc bi translated">当实现影响抽象时</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">关于实现的知识会影响抽象设计吗？</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mr l"><div class="pb l mt mu mv mr mw lb mi"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi me"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure></div></div>    
</body>
</html>