<html>
<head>
<title>Angular Rest API Mock with Deno</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Deno的角度静止API模拟</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-rest-api-mock-with-deno-36ce91bcb8bf?source=collection_archive---------14-----------------------#2020-06-09">https://levelup.gitconnected.com/angular-rest-api-mock-with-deno-36ce91bcb8bf?source=collection_archive---------14-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="528f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何将你的客户端应用从模拟网络响应中分离出来？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3e1e4e61cff0835902e30521ab7130fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fGiI7IPqdZtI_oThm1XCgg.png"/></div></div></figure><p id="9dfc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的一门Angular课程中，我们目前正在使用Node Express服务器向Angular应用程序提供模拟数据。</p><p id="3fa2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于Deno已经发布了正式版1.0(2020年5月中旬)，我决定用它做实验，并为课程编写一个新的web服务器。最终的布局看起来像下面的截图(从布局的角度来看，你看不到任何花哨的东西):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lq"><img src="../Images/0016d59bad85be9aa249f902caecc8ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOScJouROCedRbhQv-ARYw.png"/></div></div></figure><p id="6dd7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文是一个循序渐进的实用指南，重点是为Angular应用程序创建一个具有完整CRUD操作的Rest API。不过我不会涉及太多关于Deno的细节，因为这会让帖子太长，而且已经有很多关于Deno的好介绍了。</p><h1 id="865b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">什么是Deno</h1><p id="1aa2" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><a class="ae mo" href="https://deno.land" rel="noopener ugc nofollow" target="_blank"> Deno </a>由Ryan Dahl创建，他也是Node.js的创始人</p><blockquote class="mp"><p id="8aaa" class="mq mr it bd ms mt mu mv mw mx my lp dk translated">Deno是一个简单、现代和安全的JavaScript和TypeScript运行时，使用V8并内置于Rust中。</p></blockquote><p id="46e9" class="pw-post-body-paragraph ku kv it kw b kx na ju kz la nb jx lc ld nc lf lg lh nd lj lk ll ne ln lo lp im bi translated">如果您已经熟悉Node，那么Deno可以做完全相同的事情，但是速度更快。Deno可以看做是<em class="nf"> rewamp </em> Node.js的一种方式，解决同一个Ryan认为他“遗憾”的不同方面。<br/>以下是他在JSConf EU 2018上的发言，他在发言中阐述了这些观点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk translated">“Node.js让我后悔的10件事——Ryan Dahl”</figcaption></figure><h1 id="9a1c" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">安装Deno</h1><p id="3db1" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们可以选择使用包管理器或直接在shell中执行命令。</p><h2 id="d0b9" class="nm ls it bd lt nn no dn lx np nq dp mb ld nr ns md lh nt nu mf ll nv nw mh nx bi translated">通过命令安装</h2><p id="c343" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><strong class="kw iu">带外壳(Mac): </strong></p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="abe0" class="nm ls it nz b gy od oe l of og">curl -fsSL https://deno.land/x/install/install.sh | sh</span></pre><p id="60d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">使用PowerShell (Windows): </strong></p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="bdee" class="nm ls it nz b gy od oe l of og">iwr https://deno.land/x/install/install.ps1 -useb | iex</span></pre><h2 id="54eb" class="nm ls it bd lt nn no dn lx np nq dp mb ld nr ns md lh nt nu mf ll nv nw mh nx bi translated">通过软件包管理器安装</h2><p id="ac1d" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><strong class="kw iu">同</strong> <a class="ae mo" href="https://formulae.brew.sh/formula/deno" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">自制</strong> </a> <strong class="kw iu"> (Mac): </strong></p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="99c9" class="nm ls it nz b gy od oe l of og">brew install deno</span></pre><p id="47e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">同</strong> <a class="ae mo" href="https://chocolatey.org/packages/deno" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">巧克力</strong> </a> <strong class="kw iu"> (Windows): </strong></p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="aa46" class="nm ls it nz b gy od oe l of og">choco install deno</span></pre><p id="35ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Deno下载并在本地安装后，在shell中运行<code class="fe oh oi oj nz b">deno --version</code>来验证安装。我们应该得到类似的输出:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="9ea6" class="nm ls it nz b gy od oe l of og">$ deno --version<br/>deno 1.0.3<br/>v8 8.4.300<br/>typescript 3.9.2</span></pre><p id="2cf8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们想要一个可用命令的概览，我们可以调用指令<code class="fe oh oi oj nz b">deno --help</code>，显示所有可用的子命令。<br/>我们甚至可以获得每个命令的更多细节，只需像<code class="fe oh oi oj nz b">deno run --help</code>一样添加标志<code class="fe oh oi oj nz b">--help</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/e42f8f6f162d8e93a290d3efba30a225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*qDdGPRgCuOjrE9x9pM5Kcg.png"/></div></figure><h1 id="c850" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">可用模块</h1><p id="633d" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Deno提供了一个<strong class="kw iu">标准模块</strong>的列表，由核心团队审查，并保证与特定的Deno版本一起工作。这些标准模块位于https://deno.land/std，为大多数基本任务提供功能，例如:uuid生成、http调用和文件系统访问。</p><p id="86dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除此之外，deno.land网站还为在<a class="ae mo" href="https://deno.land/x" rel="noopener ugc nofollow" target="_blank">deno.land/x</a>兼容deno的<strong class="kw iu">第三方模块</strong>提供公共托管服务。<br/>我们可以搜索模块的详尽集合。</p><p id="2fa0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在一切就绪，让我们开始写一些代码。为您的服务器定义根文件夹:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/7ff68fa945e0208a6349a130c8c06f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gvXi56CgLe8Iuaxeo2K9Og.png"/></div></figure><h1 id="ae1d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建服务器</h1><p id="90d4" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在一切就绪，让我们开始写一些代码。为您的服务器定义根文件夹:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="0ca4" class="nm ls it nz b gy od oe l of og">mkdir webServer &amp;&amp; cd webServer</span></pre><h2 id="8bd2" class="nm ls it bd lt nn no dn lx np nq dp mb ld nr ns md lh nt nu mf ll nv nw mh nx bi translated">Server.ts</h2><p id="f637" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">创建一个<code class="fe oh oi oj nz b">server.ts</code>文件。</p><blockquote class="om on oo"><p id="bd2b" class="ku kv nf kw b kx ky ju kz la lb jx lc op le lf lg oq li lj lk or lm ln lo lp im bi translated"><em class="it">💡</em> <strong class="kw iu"> <em class="it">注意:</em> </strong> <em class="it">我们可以使用普通的JavaScript来代替typescript，但是我们会失去typescript提供的许多好处。此外，由于Deno是在Rust和Typescript之上编写的，它可以直接编译。ts文件给我们。</em></p></blockquote><h2 id="2d31" class="nm ls it bd lt nn no dn lx np nq dp mb ld nr ns md lh nt nu mf ll nv nw mh nx bi translated">使用标准的http模块</h2><p id="1452" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">要创建HTTP服务器，我们可以从<code class="fe oh oi oj nz b">http</code>标准模块导入<code class="fe oh oi oj nz b">server.ts</code>文件:</p><blockquote class="om on oo"><p id="dde2" class="ku kv nf kw b kx ky ju kz la lb jx lc op le lf lg oq li lj lk or lm ln lo lp im bi translated"><em class="it">💡</em> <strong class="kw iu"> <em class="it">注意:</em> </strong> <em class="it">您可能已经注意到，我们在这里是从url导入，而不是从本地路径。这是Deno中的一个新概念，我们不需要在本地安装软件包。我们可以导入他们的最新版本并缓存，即使离线也可以使用。Deno使用es模块导入包，而from Node使用npm。这是在没有</em> <code class="fe oh oi oj nz b"><em class="it">node_modules</em></code> <em class="it">文件夹和</em> <code class="fe oh oi oj nz b"><em class="it">package.json</em></code> <em class="it">文件的情况下翻译的(在我们的webServer文件夹中没有它们的任何踪迹)。使用Deno，我们可以通过它的url直接导入我们想要的包。</em></p></blockquote><h2 id="1038" class="nm ls it bd lt nn no dn lx np nq dp mb ld nr ns md lh nt nu mf ll nv nw mh nx bi translated">使用第三方模块</h2><p id="bf0e" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">或者，我们可以为Deno的http服务器选择一个中间件框架，包括一个路由器中间件。这个中间件框架受Koa的启发，因此已经为许多Node.js开发人员所熟悉。对于我们的模拟服务器，我决定使用oak。</p><p id="a187" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你已经使用过Express上面的代码应该已经很熟悉了。在创建了一个<code class="fe oh oi oj nz b">Application</code>类的实例后，我们可以使用<code class="fe oh oi oj nz b">use()</code>方法堆叠多个中间件，然后激活服务器(<code class="fe oh oi oj nz b">listen()</code>方法)，等待传入的请求。</p><h2 id="e87a" class="nm ls it bd lt nn no dn lx np nq dp mb ld nr ns md lh nt nu mf ll nv nw mh nx bi translated">克-奥二氏分级量表</h2><p id="8fe0" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们可以为我们的应用程序定义CORS，否则我们每次试图从Angular应用程序访问服务器时都会收到客户端错误。Deno提供了一个cors模块(<code class="fe oh oi oj nz b">https://deno.land/x/cors/mod.ts</code>)，其默认设置已经捕获了许多常见情况。我们可以通过以下调用启用CORS:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="1b53" class="nm ls it nz b gy od oe l of og">app.use(oakCors());</span></pre><p id="f9c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认配置，因此没有上面代码片段中的参数，转换为下面的选项集:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="fd09" class="nm ls it nz b gy od oe l of og">{<br/>  "origin": "*",<br/>  "methods": "GET,HEAD,PUT,PATCH,POST,DELETE",<br/>  "preflightContinue": false,<br/>  "optionsSuccessStatus": 204<br/>}</span></pre><h2 id="20f8" class="nm ls it bd lt nn no dn lx np nq dp mb ld nr ns md lh nt nu mf ll nv nw mh nx bi translated">Routes.ts</h2><p id="35fd" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">由于我们的模拟服务器非常简单，我决定只创建一个文件夹<code class="fe oh oi oj nz b">src</code>来存放所有的业务逻辑，并将其与<code class="fe oh oi oj nz b">server.ts</code>文件分开。</p><p id="b0c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">routes文件包含了我们希望向Angular客户端公开的所有端点，在我们的例子中实现了经典的CRUD操作。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="0dbc" class="nm ls it nz b gy od oe l of og">import { Router } from "https://deno.land/x/oak/mod.ts";<br/>import {<br/>    getAllEmployees,<br/>    getEmployeeById,<br/>    updateEmployee, <br/>    addEmployee,<br/>    deleteEmployee<br/>} from "./employeeApis.ts";<br/><br/>const router = new Router();<br/><br/>router.get("/employees", getAllEmployees)<br/>    .get("/employees/:id", getEmployeeById)<br/>    .put("/employees/:id", updateEmployee)<br/>    .post("/employees", addEmployee)<br/>    .delete("/employees/:id", deleteEmployee);<br/><br/>export default router;</span></pre><h2 id="996d" class="nm ls it bd lt nn no dn lx np nq dp mb ld nr ns md lh nt nu mf ll nv nw mh nx bi translated">员工. ts</h2><p id="ef75" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们需要为我们的领域定义一个通用模型。这里我们设计了一个<code class="fe oh oi oj nz b">Employee</code>对象，有一些静态数据，没有数据库存储，因为这超出了课程范围，只关注角度和客户端开发。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="bd37" class="nm ls it nz b gy od oe l of og">export interface Employee {<br/>    id: number;<br/>    firstname: string;<br/>    lastname: string;<br/>    email?: string;<br/>}<br/><br/>export const EmployeeData: Employee[] = [<br/>    { id: 1, firstname: 'Larry', lastname: 'Potter', email: 'larry.potter@hotmail.com' },<br/>    { id: 2, firstname: 'Mara', lastname: 'Croft', email: 'mara.croft@gmail.com' },<br/>    { id: 3, firstname: 'Thomas', lastname: 'Müller', email: 'thomas123@gmail.com' },<br/>    { id: 5, firstname: 'Karl', lastname: 'Fritz', email: 'Karl_great@microsoft.com' },<br/>    { id: 6, firstname: 'Paolo', lastname: 'Rossi' }<br/>];</span></pre><h2 id="a112" class="nm ls it bd lt nn no dn lx np nq dp mb ld nr ns md lh nt nu mf ll nv nw mh nx bi translated">EmployeeApis.ts</h2><p id="41fe" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在这个文件中，我们实现了每个端点背后的真正逻辑。任何数据突变都会影响本地数据结构<em class="nf"> EmployeeData </em>，如上所述。<br/>代码非常简单，不言自明，因此我不会详细讲述。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="2ed9" class="nm ls it nz b gy od oe l of og">import { EmployeeData, Employee } from './employee.ts';<br/><br/>// Returns all available employees<br/>export const getAllEmployees = ({ response }: { response: any }) =&gt; {<br/>    response.body = EmployeeData;<br/>};<br/><br/>// Returns one employee by its Id or 404 if not found<br/>export const getEmployeeById = ({ params, response }: { params: { id: string }; response: any }) =&gt; {<br/>    const selectedEmployee: Employee | undefined = EmployeeData.find((employee) =&gt;<br/>        employee.id === +params.id<br/>    );<br/>    if (selectedEmployee) {<br/>        response.status = 200;<br/>        response.body = selectedEmployee;<br/>    }<br/>    else {<br/>        response.status = 404;<br/>        response.body = [];<br/>    }<br/>};<br/><br/>// Add a new employee to the list<br/>export const addEmployee = async (<br/>    { request, response }: { request: any; response: any },<br/>) =&gt; {<br/>    if (!request.hasBody) {<br/>        response.status = 400;<br/>    } else {<br/>        const newEmployee: Employee = await request.body();<br/><br/>        newEmployee.id = getNextEmployeeId();<br/>        EmployeeData.push(newEmployee);<br/>        response.status = 201;<br/>    }<br/>};<br/><br/>//Provides the next number to be used as employee Id<br/>function getNextEmployeeId(): number {<br/>    let maxId = 1;<br/>    EmployeeData.forEach(p =&gt; {<br/>        maxId = Math.max(p.id, maxId);<br/>    });<br/>    return maxId + 1;<br/>}<br/><br/>// Removes an employee by its Id or 404 if not found<br/>export const deleteEmployee = (<br/>    { params, response }: { params: { id: string }; response: any },<br/>) =&gt; {<br/>    const targetId = +params.id;<br/>    const newEmployeeList = EmployeeData.filter(x =&gt; x.id !== targetId);<br/>    if (newEmployeeList.length &lt; EmployeeData.length) {<br/>        replaceCollection(EmployeeData, newEmployeeList);<br/>        response.status = 200;<br/>    } else {<br/>        response.status = 404;<br/>    }<br/>};<br/><br/>// Updates en existing employee<br/>export const updateEmployee = async (<br/>    { params, request, response }: {<br/>        params: { id: string };<br/>        request: any;<br/>        response: any;<br/>    },<br/>) =&gt; {<br/>    const targetId = +params.id;<br/>    let employeeToUpdate: Employee | undefined = EmployeeData.find((employee) =&gt;<br/>        employee.id === targetId<br/>    );<br/>    if (employeeToUpdate) {<br/>        const body = await request.body();<br/>        const newEmployeeData: Employee = body.value;<br/><br/>        let updatedData = EmployeeData.map((e: Employee) =&gt; {<br/>            return e.id === targetId ? { ...e, ...newEmployeeData } : e;<br/>        });<br/><br/>        replaceCollection(EmployeeData, updatedData);<br/>        response.status = 200;<br/>    } else {<br/>        response.status = 404;<br/>    }<br/>};<br/><br/>// Replaces the employee data structure with a new collection<br/>function replaceCollection(originalData: Employee[], newData: Employee[]) {<br/>    originalData.splice(0, originalData.length);<br/>    originalData.push(...newData);<br/>}</span></pre><h1 id="fe9d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">启动服务器</h1><p id="2b94" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在我们已经创建了所有需要的文件，是时候启动服务器了。从托管服务器文件的路径在shell中执行以下命令:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="b8c5" class="nm ls it nz b gy od oe l of og">deno run --allow-net server.ts</span></pre><blockquote class="om on oo"><p id="0ccc" class="ku kv nf kw b kx ky ju kz la lb jx lc op le lf lg oq li lj lk or lm ln lo lp im bi translated"><em class="it"> ⚠️ </em> <strong class="kw iu"> <em class="it">注意:</em> </strong> <em class="it">如果没有添加Deno安装根($HOME/)。deno/bin)添加到您的环境变量中，那么您可能需要将文件路径添加到server.ts </em></p></blockquote><p id="c269" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过运行该命令，不同的模块被下载，但是我们的解决方案中没有为它们创建文件夹。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="7a68" class="nm ls it nz b gy od oe l of og">Compile file:///.../server.ts Download https://deno.land/x/oak/mod.ts Download https://deno.land/x/oak/application.ts Download https://deno.land/x/oak/context.ts Download https://deno.land/x/oak/cookies.ts Download https://deno.land/x/oak/httpError.ts Download https://deno.land/x/oak/middleware.ts Download https://deno.land/x/oak/request.ts Download https://deno.land/x/oak/response.ts Download https://deno.land/x/oak/router.ts Download https://deno.land/x/oak/send.ts Download https://deno.land/x/oak/types.ts Download https://deno.land/x/oak/deps.ts Download https://deno.land/x/oak/keyStack.ts Download https://deno.land/x/oak/tssCompare.ts Download https://deno.land/std@v1.0.0-rc1/http/server.ts <br/>...</span></pre><p id="9650" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些模块从现在开始被缓存，我们不需要再次下载它们，除非我们明确地想要，例如使用<code class="fe oh oi oj nz b">--reload</code>选项。默认情况下，缓存的模块存储在Deno的基目录中:$HOME/。deno (DENO_DIR)，但是如果需要，我们可以更改这个位置，通常是在生产环境中。</p><p id="68e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe oh oi oj nz b">DENO_DIR</code>包含以下文件和目录:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/d033f4b7157670cbfa211173605743e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*J8Qime-jwGjBFnB6JTYxKQ.png"/></div></figure><blockquote class="om on oo"><p id="f149" class="ku kv nf kw b kx ky ju kz la lb jx lc op le lf lg oq li lj lk or lm ln lo lp im bi translated"><em class="it">💡</em> <strong class="kw iu"> <em class="it">注意:</em> </strong> <em class="it">在Deno中，需要在运行一个程序之前给出明确的权限。在上面的命令中，我们必须使用选项</em> <code class="fe oh oi oj nz b"><em class="it">--allow-net</em></code>授予网络访问权限</p></blockquote><p id="9183" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们忽略此选项，在下载完所有模块后，我们会得到以下错误:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="65c5" class="nm ls it nz b gy od oe l of og">error: Uncaught PermissionDenied: network access to "127.0.0.1:8280", run again with the --allow-net flag<br/>    at unwrapResponse ($deno$/ops/dispatch_json.ts:43:11)<br/>    at Object.sendSync ($deno$/ops/dispatch_json.ts:72:10)<br/>    at Object.listen ($deno$/ops/net.ts:51:10)<br/>    at listen ($deno$/net.ts:164:18)<br/>    at Application.serve (server.ts:261:20)<br/>    at Application.listen (application.ts:106:31)<br/>    at server.ts:18:11</span></pre><p id="6c2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们创建一个简单的http服务器来模拟客户端应用程序所需的全部内容。现在让我们创建一个使用REST APIs的Angular项目。</p><h1 id="cba3" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">排除故障</h1><p id="e3a0" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">Deno支持V8 Inspector协议。我们可以用Chrome DevTools或其他支持该协议的客户端来调试Deno程序。</p><p id="714a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们很可能使用可视化代码来实现我们的Angular应用程序，所以让我们看看如何从我们的IDE中直接调试Deno服务器。一个官方插件目前正在建设中，但目前我们可以创建一个<code class="fe oh oi oj nz b">launch.json</code>文件:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="706a" class="nm ls it nz b gy od oe l of og">{<br/>  "version": "0.2.0",<br/>  "configurations": [<br/>    {<br/>      "name": "Deno",<br/>      "type": "node",<br/>      "request": "launch",<br/>      "cwd": "${workspaceFolder}",<br/>      "runtimeExecutable": "deno",<br/>      "runtimeArgs": ["run", "--inspect-brk", "-A", "server.ts"],<br/>      "port": 9229<br/>    }<br/>  ]<br/>}</span></pre><blockquote class="om on oo"><p id="0abb" class="ku kv nf kw b kx ky ju kz la lb jx lc op le lf lg oq li lj lk or lm ln lo lp im bi translated"><em class="it">💡</em> <strong class="kw iu"> <em class="it">注意:</em> </strong> <em class="it">如果你给你的脚本文件命名与</em> <code class="fe oh oi oj nz b"><em class="it">server.ts</em></code> <em class="it">不同，你必须相应地修改“运行时间参数”的最后一项。</em></p></blockquote><p id="7df1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了上面的配置，VS代码调试器将在:<code class="fe oh oi oj nz b">127.0.0.1:9229</code>运行，并拦截我们设置的所有断点。</p><h1 id="1578" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">更多关于Deno的信息</h1><p id="95de" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">如果你有兴趣了解更多关于Deno的知识，我推荐关于v 1.0版本的官方<a class="ae mo" href="https://deno.land/v1" rel="noopener ugc nofollow" target="_blank">博文</a>。</p><p id="2855" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还要留意Deno备忘单，因为它是一个很好的资源，可以让你对所有可用的命令有一个总的了解。</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><h1 id="4fb2" class="lr ls it bd lt lu pa lw lx ly pb ma mb jz pc ka md kc pd kd mf kf pe kg mh mi bi translated">创建有角度的服务</h1><p id="f1f5" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">对于角度部分，我将只描述调用我们的REST服务器的http服务。所有的代码都可以在Github repo上找到，你可以下载整个项目。</p><p id="5d65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你还没有一个现成的Angular应用程序，并且你需要如何创建一个的指导，看看我关于它的帖子<a class="ae mo" href="https://dev.to/paco_ita/create-progressive-web-apps-with-angular-workbox-pwa-builder-step-4-27d#angular" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="8342" class="nm ls it bd lt nn no dn lx np nq dp mb ld nr ns md lh nt nu mf ll nv nw mh nx bi translated">员工服务. ts</h2><p id="00d5" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">多亏了schematics，在Angular中生成文件非常容易:</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="cc8a" class="nm ls it nz b gy od oe l of og">ng g service employee</span></pre><p id="a191" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个命令创建了<code class="fe oh oi oj nz b">EmployeeService.ts</code>及其单元测试文件。在服务中，我们定义了实现CRUD操作的方法，这些方法将调用我们之前实现的Deno服务器的端点。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="46a8" class="nm ls it nz b gy od oe l of og">import { Employee } from './../model/employee.model';<br/>import { Injectable } from '@angular/core';<br/>import { HttpClient } from '@angular/common/http';<br/><br/>import { Observable ,  of ,  throwError as _throw } from 'rxjs';<br/>import { catchError, delay, map } from 'rxjs/operators';<br/>import { environment } from '../../../environments/environment';<br/><br/>@Injectable()<br/>export class EmployeeService {<br/><br/>    constructor(private http: HttpClient) { }<br/><br/>    getEmployees(): Observable&lt;Employee[]&gt; {<br/>        return this.http<br/>          .get&lt;Employee[]&gt;(`${environment.apiBaseUrl}/employees`)<br/>          .pipe(catchError((error: any) =&gt; _throw(error)));<br/>      }<br/><br/><br/>    getEmployee(id: number): Observable&lt;Employee&gt; {<br/>      return this.http<br/>        .get&lt;Employee&gt;(`${environment.apiBaseUrl}/employees/${id}`)<br/>        .pipe(catchError((error: any) =&gt; _throw(error)));<br/>    }<br/><br/>      createEmployee(payload: Employee): Observable&lt;Employee&gt; {<br/>        return this.http<br/>          .post&lt;Employee&gt;(`${environment.apiBaseUrl}/employees`, payload)<br/>          .pipe(catchError((error: any) =&gt; _throw(error)));<br/>      }<br/><br/>      updateEmployee(payload: Employee): Observable&lt;Employee&gt; {<br/>        return this.http<br/>          .put&lt;Employee&gt;(`${environment.apiBaseUrl}/employees/${payload.id}`, payload)<br/>          .pipe(catchError((error: any) =&gt; _throw(error)));<br/>      }<br/><br/>      removeEmployee(payload: Employee): Observable&lt;any&gt; {<br/>        return this.http<br/>          .delete&lt;any&gt;(`${environment.apiBaseUrl}/employees/${payload.id}`)<br/>          .pipe(catchError((error: any) =&gt; _throw(error)));<br/>      }<br/>}</span></pre><h2 id="17b8" class="nm ls it bd lt nn no dn lx np nq dp mb ld nr ns md lh nt nu mf ll nv nw mh nx bi translated">环境. ts</h2><p id="171f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在文件<code class="fe oh oi oj nz b">environment.ts</code>中，我们可以保存服务器的基本url，并最终保存其他配置密钥。<code class="fe oh oi oj nz b">environment.prod.ts</code>保留用于生产构建，通常具有不同值的键，以生产服务器为目标，而不是临时服务器。</p><pre class="kj kk kl km gt ny nz oa ob aw oc bi"><span id="bb45" class="nm ls it nz b gy od oe l of og">export const environment = {<br/>  production: false,<br/>  apiBaseUrl: 'http://localhost:8280'<br/>};</span></pre><h1 id="8249" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="073c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">正如我们所看到的，用Deno创建一个web服务器并将其用作我们的客户端应用程序的模拟是非常容易的。</p><p id="4c0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种架构非常方便，因为它允许我们将web应用程序从服务器模拟中分离出来。我们可以从客户端执行真正的网络调用，而无需在将Angular应用程序部署到生产环境之前对其进行任何更改。</p><h1 id="710a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">Github回购</h1><p id="4091" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">示例代码(Angular和Deno服务器)可在Github:【https://github.com/pacoita/deno-api-mock T2】获得</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="72a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nf">原载于2020年6月9日</em><a class="ae mo" href="https://dev.to/paco_ita/create-an-angular-rest-api-mock-with-deno-598b" rel="noopener ugc nofollow" target="_blank"><em class="nf">https://dev . to</em></a><em class="nf">。</em></p></div></div>    
</body>
</html>