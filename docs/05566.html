<html>
<head>
<title>LocalStorage vs. Cookies: All You Need to Know About Storing JWT Tokens Securely in the Front-End</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LocalStorage与Cookies:关于在前端安全存储JWT令牌，您只需要知道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/localstorage-vs-cookies-all-you-need-to-know-about-storing-jwt-tokens-securely-in-the-front-end-519f83c2b282?source=collection_archive---------8-----------------------#2020-09-09">https://levelup.gitconnected.com/localstorage-vs-cookies-all-you-need-to-know-about-storing-jwt-tokens-securely-in-the-front-end-519f83c2b282?source=collection_archive---------8-----------------------#2020-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="38b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> JWT代币很棒，但你如何将它们安全地存储在你的前端呢？我们将讨论本地存储和Cookies的优缺点。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/31452fe51005159d381f520096d08d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-E57fLrlosWm3LeQ.png"/></div></div></figure><p id="5946" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ky" href="https://blog.cotter.app/what-on-earth-is-oauth-super-simple-intro-to-oauth-20-access-tokens-and-how-to-implement-it-in-your-site/" rel="noopener ugc nofollow" target="_blank">在我的上一篇文章</a>中，我们研究了OAuth 2.0是如何工作的，以及如何生成访问令牌和刷新令牌。现在，我们将深入探讨如何在您的前端存储令牌。</p><p id="d902" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">访问令牌</strong>通常是短暂的JWT令牌，由您的服务器签名，并包含在对您的服务器的每个HTTP请求中，以授权该请求。<strong class="jp ir">刷新令牌</strong>通常是存储在数据库中的长期不透明字符串，用于在到期时获取新的访问令牌。</p><h1 id="6be8" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">我应该在前端的哪里存放我的代币？</h1><p id="e06d" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">有两种常见的方法来存储您的令牌。第一个在<code class="fe mc md me mf b">localStorage</code>中，第二个在cookies中。关于哪一种更好有很多争论，大多数人倾向于cookies，因为它们更安全。</p><p id="d668" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回顾一下<code class="fe mc md me mf b">localStorage</code>和cookies的对比。本文主要是根据<a class="ae ky" href="https://dev.to/rdegges/please-stop-using-local-storage-1i04" rel="noopener ugc nofollow" target="_blank">这篇文章</a>和对这个帖子的评论。</p><h2 id="320b" class="mg la iq bd lb mh mi dn lf mj mk dp lj jy ml mm ln kc mn mo lr kg mp mq lv mr bi translated">局部存储器</h2><p id="7659" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated"><strong class="jp ir">优点:方便。</strong></p><ul class=""><li id="d00d" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated">纯JavaScript，很方便。如果你没有后端，并且依赖于第三方API，你不能总是要求第三方API为你的站点设置一个特定的cookie。</li><li id="baad" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">使用需要你把访问令牌放在头中的API，比如:<code class="fe mc md me mf b">Authorization Bearer ${access_token}</code>。</li></ul><p id="c1cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缺点:容易受到XSS的攻击。</p><p id="bce1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当攻击者可以在您的网站上运行JavaScript时，就会发生XSS攻击。这意味着攻击者可以获取您存储在<code class="fe mc md me mf b">localStorage</code>中的访问令牌。XSS攻击可能来自您网站中包含的第三方JavaScript代码，如React、Vue、jQuery、Google Analytics等。在你的站点中不包含任何第三方库几乎是不可能的。</p><h2 id="b52a" class="mg la iq bd lb mh mi dn lf mj mk dp lj jy ml mm ln kc mn mo lr kg mp mq lv mr bi translated">饼干</h2><p id="dcef" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated"><strong class="jp ir">优点:无法通过JavaScript访问cookie因此，它不像</strong> <code class="fe mc md me mf b"><strong class="jp ir">localStorage</strong></code> <strong class="jp ir">那样容易受到XSS的攻击。</strong></p><ul class=""><li id="435d" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated">如果你正在使用<code class="fe mc md me mf b">httpOnly</code>和<code class="fe mc md me mf b">secure</code>cookie，这意味着你的cookie不能使用JavaScript访问，所以即使攻击者可以在你的网站上运行JS，他们也不能从cookie中读取你的访问令牌。</li><li id="a040" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">它会在每个HTTP请求中自动发送到您的服务器。</li></ul><p id="1d7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点:根据不同的用例，您可能无法将令牌存储在cookies中。</strong></p><ul class=""><li id="62c3" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated">Cookies的大小限制为4KB。因此，如果您使用大的JWT令牌，存储在cookie中不是一个选项。</li><li id="149f" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">有些情况下，您不能与API服务器共享cookies，或者API要求您将访问令牌放在授权头中。在这种情况下，您将无法使用cookies来存储您的令牌。</li></ul><h1 id="ec2b" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">关于XSS袭击事件</h1><p id="d8eb" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">本地存储易受攻击，因为使用JavaScript很容易访问它，攻击者可以检索您的访问令牌并在以后使用它。然而，虽然使用JavaScript无法访问<code class="fe mc md me mf b">httpOnly</code> cookies，但这并不意味着使用cookies就可以免受涉及访问令牌的XSS攻击。</p><p id="aa01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一个攻击者可以在你的应用程序中运行JavaScript，那么他们可以向你的服务器发送一个HTTP请求，这个请求会自动包含你的cookies这对攻击者来说不太方便，因为他们无法读取令牌的内容，尽管他们很少需要这样做。对于攻击者来说，使用受害者的浏览器进行攻击(只需发送HTTP请求)可能比使用攻击者的机器更有利。</p><h1 id="08c1" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">饼干和CSRF攻击</h1><p id="4993" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">CSRF攻击是一种迫使用户执行非预期请求的攻击。例如，如果网站通过以下方式接受电子邮件更改请求:</p><pre class="kn ko kp kq gt ng mf nh ni aw nj bi"><span id="dab3" class="mg la iq mf b gy nk nl l nm nn">POST /email/change HTTP/1.1 <br/>Host: site.com <br/>Content-Type: application/x-www-form-urlencoded <br/>Content-Length: 50 Cookie: session=abcdefghijklmnopqrstu </span><span id="514f" class="mg la iq mf b gy no nl l nm nn">email=myemail.example.com</span></pre><p id="a323" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，攻击者可以很容易地在一个恶意网站中制作一个<code class="fe mc md me mf b">form</code>，向<code class="fe mc md me mf b">https://site.com/email/change</code>发送一个带有隐藏电子邮件字段的POST请求，然后<code class="fe mc md me mf b">session</code> cookie将自动包含在内。然而，这可以通过在你的cookie中使用<code class="fe mc md me mf b">sameSite</code>标志并包含一个<a class="ae ky" href="https://owasp.org/www-community/Anti_CRSF_Tokens_ASP-NET" rel="noopener ugc nofollow" target="_blank">反CSRF令牌</a>来轻松缓解。</p><h1 id="d02d" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">那么，我如何使用cookies来持久化我的OAuth 2.0令牌呢？</h1><p id="5304" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">概括来说，以下是存储代币的不同方法:</p><ul class=""><li id="e9d2" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated"><strong class="jp ir">选项1: </strong>将您的访问令牌存储在<code class="fe mc md me mf b">localStorage</code>中:倾向于XSS。</li><li id="25de" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">选项2: </strong>将您的访问令牌存储在<code class="fe mc md me mf b">httpOnly</code> cookie中:容易出现CSRF，但可以减轻，在暴露于XSS方面稍好一些。</li><li id="964e" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><strong class="jp ir">选项3: </strong>将您的刷新令牌存储在<code class="fe mc md me mf b">httpOnly</code> cookie中:安全来自CSRF，在暴露于XSS方面稍好一些。</li></ul><p id="2041" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将讨论<strong class="jp ir">选项3 </strong>的工作原理，因为它是3个选项中最好的。</p><h2 id="6fc1" class="mg la iq bd lb mh mi dn lf mj mk dp lj jy ml mm ln kc mn mo lr kg mp mq lv mr bi translated">选项3:将访问令牌存储在内存中，将刷新令牌存储在cookie中</h2><p id="efb1" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">为什么这对CSRF来说是安全的？尽管提交给<code class="fe mc md me mf b">/refresh_token</code>的表单可以工作，并且会返回一个新的访问令牌，但是如果攻击者使用HTML表单，他们无法读取响应。为了防止攻击者成功发出<code class="fe mc md me mf b">fetch</code>或<code class="fe mc md me mf b">AJAX</code>请求并读取响应，需要正确设置授权服务器的CORS策略，以防止来自未授权网站的请求。</p><h2 id="a91c" class="mg la iq bd lb mh mi dn lf mj mk dp lj jy ml mm ln kc mn mo lr kg mp mq lv mr bi translated">那么这个设置是如何工作的呢？</h2><p id="5c35" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated"><strong class="jp ir">第一步:用户通过认证后，返回访问令牌和刷新令牌。</strong></p><p id="6edc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用户通过认证后，授权服务器将返回一个<code class="fe mc md me mf b">access_token</code>和一个<code class="fe mc md me mf b">refresh_token</code>。<code class="fe mc md me mf b">access_token</code>将包含在响应体中，而<code class="fe mc md me mf b">refresh_token</code>将包含在cookie中。</p><p id="2ab4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">刷新令牌cookie设置:</p><ul class=""><li id="2e75" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated">使用<code class="fe mc md me mf b">httpOnly</code>标志来防止JavaScript读取它。</li><li id="6bf1" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">使用<code class="fe mc md me mf b">secure=true</code>旗，这样它只能通过HTTPS发送。</li><li id="e2a4" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">尽可能使用<code class="fe mc md me mf b">SameSite=strict</code>旗来防止CSRF。这只能在授权服务器与您的前端具有相同站点的情况下使用。如果不是这种情况，那么您的授权服务器必须在后端设置CORS头或使用其他方法来确保刷新令牌请求只能由授权网站完成。</li></ul><p id="3bf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤2:将访问令牌存储在存储器中</strong></p><p id="7966" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将令牌存储在内存中意味着将这个访问令牌放在前端站点的一个变量中。是的，这意味着如果用户切换到另一个选项卡或刷新站点，访问令牌将会消失。这就是为什么我们有刷新令牌。</p><p id="6b12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤3:使用刷新令牌更新访问令牌</strong></p><p id="8ef2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当访问令牌消失或过期时，点击<code class="fe mc md me mf b">/refresh_token</code>端点，步骤1中存储在cookie中的刷新令牌将包含在请求中。然后，您将获得一个新的访问令牌，可以用于您的API请求。这意味着您的JWT令牌可以大于4KB，您也可以将它放在授权头中。</p><h1 id="9d6d" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="da97" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">尽管cookies仍然有一些漏洞，但这种方法比<code class="fe mc md me mf b">localStorage</code>更可取。这是因为<code class="fe mc md me mf b">localStorage</code>和cookies都容易受到XSS攻击，但是当你使用<code class="fe mc md me mf b">httpOnly</code> cookies时，攻击者就更难攻击了。此外，cookies容易受到CSRF攻击，但这种威胁可以通过使用<code class="fe mc md me mf b">sameSite</code>标志和<a class="ae ky" href="https://owasp.org/www-community/Anti_CRSF_Tokens_ASP-NET" rel="noopener ugc nofollow" target="_blank">反CSRF令牌</a>来缓解。最后，即使你需要使用<code class="fe mc md me mf b">Authorization: Bearer</code>头或者你的JWT大于4KB，你也可以让它工作。</p><p id="856d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也符合OWASP社区的建议:</p><blockquote class="np nq nr"><p id="6021" class="jn jo kl jp b jq jr js jt ju jv jw jx ns jz ka kb nt kd ke kf nu kh ki kj kk ij bi translated"><em class="iq">不要在本地存储中存储会话标识符，因为JavaScript始终可以访问这些数据。Cookies可以使用</em> <code class="fe mc md me mf b"><em class="iq">httpOnly</em></code> <em class="iq">标志来减轻这种风险。</em></p><p id="1108" class="jn jo kl jp b jq jr js jt ju jv jw jx ns jz ka kb nt kd ke kf nu kh ki kj kk ij bi translated"><a class="ae ky" href="https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> - OWASP: HTML5安全备忘单</em> </a></p></blockquote><h1 id="6d36" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">就是这样！</h1><p id="0db8" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">这应该包括基本的，并帮助您保护您的网站。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="c8d8" class="kz la iq bd lb lc oc le lf lg od li lj lk oe lm ln lo of lq lr ls og lu lv lw bi translated">资源</h1><p id="d1e0" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">写这篇博客时，我们参考了几篇文章，尤其是这些文章:</p><ul class=""><li id="6631" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated"><a class="ae ky" href="https://dev.to/rdegges/please-stop-using-local-storage-1i04" rel="noopener ugc nofollow" target="_blank">请停止使用本地存储</a></li><li id="2947" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><a class="ae ky" href="https://hasura.io/blog/best-practices-of-using-jwt-with-graphql/#jwt_persist" rel="noopener ugc nofollow" target="_blank">在前端客户端处理jwt的终极指南(GraphQL) </a></li><li id="6a65" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated"><a class="ae ky" href="https://supertokens.io/blog/cookies-vs-localstorage-for-sessions-everything-you-need-to-know" rel="noopener ugc nofollow" target="_blank">cookie与会话的本地存储——你需要知道的一切</a></li></ul></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h1 id="7485" class="kz la iq bd lb lc oc le lf lg od li lj lk oe lm ln lo of lq lr ls og lu lv lw bi translated">问题和反馈</h1><p id="2feb" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">如果您需要帮助或有任何反馈，请随时在这里发表评论！</p><p id="f869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章是由<a class="ae ky" href="http://cotter.app/" rel="noopener ugc nofollow" target="_blank"> Cotter </a>的团队撰写的——你的网站或应用程序的无密码登录。</p></div></div>    
</body>
</html>