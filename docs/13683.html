<html>
<head>
<title>Turbocharge Your App with NestJS: Tips and Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NestJS增强你的应用:提示和技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-high-performance-nestjs-app-5b807ff452e4?source=collection_archive---------5-----------------------#2022-09-27">https://levelup.gitconnected.com/build-a-high-performance-nestjs-app-5b807ff452e4?source=collection_archive---------5-----------------------#2022-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2a4a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">4种性能提升技术，充分利用NestJS</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cc5a41f79812ba1a8599f5ce6c1bd923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5UmbCAgI31gKpqN11w73hQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/ja/@diegojimenez?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迭戈·希门尼斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/road?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="8e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个强大的Node.js应用程序框架，NestJS为构建服务器端应用程序提供了广泛的特性。随着越来越多的开发人员发现它的好处，它越来越受欢迎。</p><p id="46b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在构建NestJS应用程序时，性能往往是一个被忽视的方面。在本文中，我将讨论一些制作高性能NestJS应用程序的实用技术</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="bf67" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">架构选择</h2><p id="c22b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">默认情况下，由于其受欢迎程度，NestJS运行在<a class="ae ky" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a> primary之上。虽然有一些开销，但NestJS的性能与Express相差不远。Express被认为是一个性能良好的框架。因此，默认选项:Nest-Express对于普通的服务器端应用程序来说已经足够好了。</p><p id="ce5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果性能是第一优先考虑的，更好的选择是使用F <a class="ae ky" href="https://docs.nestjs.com/techniques/performance" rel="noopener ugc nofollow" target="_blank"> astify </a>比Express快得多。</p><p id="7235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是Nest-Express与Nest-Fastify和Express的近期基准测试结果。我们可以看到Nest-Fastify比Nest-Express快3倍以上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/40db218173173f999edb2514c6b07e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1LITO4dK7Uw3AJEuPrh-3g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">最近的一个基准(<a class="ae ky" href="https://github.com/nestjs/nest/pull/10276/checks?check_run_id=8318006381" rel="noopener ugc nofollow" target="_blank">https://github.com/nestjs/nest/pull/10276/checks?check_run_id=8318006381 </a></figcaption></figure><p id="09a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在构建一个新的NestJS应用程序，首先要考虑的事情之一就是你是应该坚持使用Express，还是从Fastify开始。对于现有的应用程序，也可以从Express迁移到Fastify，因为Nest使用<a class="ae ky" href="https://docs.nestjs.com/techniques/performance" rel="noopener ugc nofollow" target="_blank">适配器</a>提供了框架独立性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="cc60" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">贮藏</h2><p id="2e25" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">缓存可以显著提高您的NestJS应用程序或任何web应用程序的性能。这是一个复杂的话题，被认为是计算中的两大难题之一。然而，NestJS通过其良好抽象的API使之变得更加容易。</p><p id="6647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NestJS提供了一个现成的<a class="ae ky" href="https://docs.nestjs.com/techniques/caching" rel="noopener ugc nofollow" target="_blank">缓存管理器。</a>缓存管理器为各种缓存存储提供商提供API。默认的存储提供程序是内存中的数据存储，并且是内置的。要启用内存缓存，我们需要如下所示导入CacheModule。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="52a4" class="mc md it nc b gy ng nh l ni nj">import { CacheModule, Module } from '@nestjs/common';<br/>import { AppController } from './app.controller';<br/><br/>@Module({<br/>  imports: [CacheModule.register()],<br/>  controllers: [AppController],<br/>})<br/>export class AppModule {}</span></pre><p id="49ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多配置选项，请参考<a class="ae ky" href="https://docs.nestjs.com/techniques/caching" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="27ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以切换到许多其他存储提供商，例如，<a class="ae ky" href="https://github.com/dabroek/node-cache-manager-redis-store" rel="noopener ugc nofollow" target="_blank"> redis store </a>。</p><p id="5791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您选择哪个存储提供者，您都可以设置一个缓存拦截器来自动缓存get响应。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="67de" class="mc md it nc b gy ng nh l ni nj">import * as redisStore from 'cache-manager-redis-store';<br/>@Module({<br/>  imports: [CacheModule.register({store: <!-- -->redisStore}<!-- -->)],<br/>  controllers: [AppController],<br/>  providers: [<br/>    {<br/>      provide: APP_INTERCEPTOR,<br/>      useClass: CacheInterceptor,<br/>    },<br/>  ],<br/>})</span></pre><p id="efd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述配置将导入<code class="fe nk nl nm nc b">CacheInterceptor</code>，并将其全局绑定到所有端点。或者，您也可以使用<code class="fe nk nl nm nc b">UseInterceptors</code>在控制器级别绑定<code class="fe nk nl nm nc b">CacheInterceptor </code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f687" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">启用Gzip</h2><p id="85a6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">启用Gzip压缩可以大大提高API性能。它不仅适用于NestJS，相反，它适用于任何常见的Web API服务。它很容易实现并且非常有效，但同时也很容易被遗忘。</p><p id="21cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Gzip压缩API请求和响应。结果是有效负载减少了10倍。</p><p id="0f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过Nginx启用Gzip压缩。大多数NestJS应用程序位于Nginx之后，您可以配置Nginx使用<code class="fe nk nl nm nc b">gzip</code>来动态压缩HTTP响应。下面是一个在<code class="fe nk nl nm nc b">nginx.conf</code>中启用Gzip的例子。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="d660" class="mc md it nc b gy ng nh l ni nj">gzip on;<br/>gzip_disable "msie6";</span></pre><p id="5574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是在NestJS应用程序中启用Gzip。在您的NestJs应用程序中，您可以利用提供的压缩中间件包来压缩和提供内容。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="28f2" class="mc md it nc b gy ng nh l ni nj">import * as compression from 'compression';<br/>// somewhere in your initialization file<br/>app.use(compression());</span></pre><p id="6109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，<code class="fe nk nl nm nc b">compression</code>中间件是从<code class="fe nk nl nm nc b">@nestjs/common</code>包中导入的，用于为应用程序的所有请求启用gzip压缩。如果客户端支持，这允许应用程序使用gzip压缩响应，这可以提高应用程序的性能和效率。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="b596" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">集群模式</h2><p id="3eac" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">默认情况下，NestJS应用程序实例在单线程中运行。由于所有服务器都有多个CPU内核，单线程实例无法充分利用服务器资源。</p><p id="9bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了利用多核来提高性能，我们可以使用NodeJS中的集群<a class="ae ky" href="https://nodejs.org/api/cluster.html" rel="noopener ugc nofollow" target="_blank">模块</a>。在集群模式下，子进程作为一个集群运行，因此传入的请求被同时处理。这导致更好的吞吐量。</p><p id="29d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在NestJS中创建集群服务很简单。下面是一个实现的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6b7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述代码的要点是</p><ul class=""><li id="d31d" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">首先，我们导入集群模块并获得CPU内核的数量</li><li id="9789" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">主进程负责创建工作进程，工作进程负责运行NestJS应用程序。</li><li id="b271" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">对于主进程，为每个可用的CPU创建一个工作进程。我们还监听工作进程的退出，当任何工作进程崩溃时，主进程将派生一个新进程。</li><li id="32ed" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">对于子进程，我们可以使用bootstrap函数来启动服务器实例。</li></ul><p id="3034" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在生产环境中，您可以使用pm2在集群模式下运行应用程序。以下命令将以8个CPU内核的集群模式启动应用程序。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5912" class="mc md it nc b gy ng nh l ni nj">pm2 start dist/main.js -i 8</span></pre><p id="bff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，在NestJS应用程序中使用集群模式可以通过在多个工作进程之间分担工作负载来提高性能和可伸缩性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9b08" class="od md it bd me oe of og mh oh oi oj mk jz ok ka mn kc ol kd mq kf om kg mt on bi translated">摘要</h1><p id="856b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">优化NestJS应用程序的性能是一项复杂而多方面的任务。在本文中，我们讨论了如何利用内置的NestJS特性(如Fastify和Cache Manager)来提高性能。Gzip和Cluster模块通常不仅用于优化NestJS，还用于优化其他NodeJS web应用程序。</p><p id="d5a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你觉得这篇文章很有用，你可能也想看看我的其他与NestJS相关的文章，关于<a class="ae ky" href="https://medium.com/p/be6bc77e789e" rel="noopener">如何构建高效且可维护的NestJS应用</a>和<a class="ae ky" href="https://medium.com/gitconnected/maximize-code-security-in-your-nestjs-applications-part-1-b7abb99fa048" rel="noopener"> NestJS安全性</a>。</p><p id="95ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编程快乐！</p></div></div>    
</body>
</html>