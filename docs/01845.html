<html>
<head>
<title>The Stack in Magic and JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Magic和JavaScript中的堆栈</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-stack-in-magic-and-javascript-47229c148990?source=collection_archive---------6-----------------------#2020-02-02">https://levelup.gitconnected.com/the-stack-in-magic-and-javascript-47229c148990?source=collection_archive---------6-----------------------#2020-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b18" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是栈，在JavaScript中是如何使用的？它和魔法聚会有什么关系？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e4f5409aadea98fb6a4d8634d4e6f03b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*jLntjkvk_T6kqrWwRD6Tjw.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd ku">哇。</strong></figcaption></figure><p id="16b2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi lr translated"><span class="l ls lt lu bm lv lw lx ly lz di">作为广受欢迎的纸牌游戏<a class="ae ma" href="https://magic.wizards.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu"> <em class="mb">魔法:聚会</em> </strong> </a>的狂热玩家，我已经熟悉了计算机编程之外的一个概念“堆栈”。当我在<a class="ae ma" href="https://www.lighthouselabs.ca/" rel="noopener ugc nofollow" target="_blank"><strong class="kx iu"><em class="mb">light house Labs</em></strong></a>参加web开发训练营时，有一天听到一位讲师提到了堆栈，我想“<em class="mb">哦，嘿，我以前听说过这个。“我一点也不知道魔术和计算机的概念有多么相似。</em></span></p><p id="3a2d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那么，什么是“<strong class="kx iu">栈</strong>”？在魔法中，它是咒语(<em class="mb">召唤魔法生物、施放火球、操纵时间、起死回生、召唤自然、与灵魂交流……像</em>这样酷的东西)被施放、回应和解决的过程。在计算中，它是存储和解析数据和任务的数据结构。在这两种情况下，堆栈都是一个<strong class="kx iu">先入后出</strong> ( <em class="mb"> FILO </em>)类型数据结构的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/28fc56bb86c772a816fd596ace0de1e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*lem98yX4AzPhM_0tQbaaEw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd ku"> <em class="md">堆栈的标准可视图像，即先入后出数据结构。</em>T29】</strong></figcaption></figure><p id="85bf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那是什么意思？典型的类比是想象桌子上有一叠文件或一堆书:你把一本书放在另一本书的上面，如果你想拿走一本，你就从最上面的那本开始，一步步往下。栈的概念在计算中无处不在，指的是用于存储对象的线性数据结构；对象通常通过“<em class="mb">推</em>动作添加，通过“<em class="mb">弹出</em>动作移除。也可以使用“<em class="mb"> peek </em>”操作在不移除它们的情况下查看它们。在JavaScript中，使用的主堆栈被称为<strong class="kx iu">调用堆栈</strong>，它与函数的解析方式有关。</p><blockquote class="me"><p id="d32c" class="mf mg it bd mh mi mj mk ml mm mn lq dk translated">对象通常通过“推入”动作添加到堆栈中，通过“弹出”动作移除。</p></blockquote><p id="3661" class="pw-post-body-paragraph kv kw it kx b ky mo ju la lb mp jx ld le mq lg lh li mr lk ll lm ms lo lp lq im bi translated">JavaScript中使用的另一种数据结构是<strong class="kx iu">队列</strong>——或<strong class="kx iu">先进先出</strong> ( <em class="mb"> FIFO </em>)结构——现实生活中一个常见的例子是在银行排队:第一个排队的人是第一个被服务的人。在计算中，一个常见的例子是如何将文件发送到打印机队列进行打印:文件按照发送的顺序打印。在JavaScript中，队列或类似于<em class="mb"> FIFO的</em>结构用于<strong class="kx iu">事件循环</strong>——异步事件是如何处理的——但我们将在本文的后面讨论这一点(正如您将看到的，它也不是严格意义上的<em class="mb"> FIFO </em>系统)。</p><p id="b059" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们今天要提到的JavaScript中使用的最后一个数据结构叫做<strong class="kx iu">堆</strong>，它是一个很大程度上非结构化的内存区域，用于存储对象和变量。至少就本文的目的而言，您不需要了解更多关于堆的知识。</p><p id="eef1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是回到堆栈，我将会以一种不同于平常的方式来解释这个概念:通过使用魔法咒语被决斗的维度旅行巫师施放和回应的类比。干净利落。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/92f0e982474876cee9ca3d3b6b3adc43.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*97MmnStpU1XK8b8gFyjRPg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd ku"> <em class="md">一种稍微有趣一点的想象堆栈的方式。</em> </strong></figcaption></figure><p id="9c4d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi lr translated">agic:聚会(或简称MTG)是一种可收藏的纸牌游戏，发明于1993年，全球有超过2000万玩家玩。它是由美国数学家理查德·加菲尔德创造的，这可能解释了游戏中的概念与数学和计算领域之间的一些重叠。该游戏以其极度的深度和复杂性而闻名，最近被证明是<strong class="kx iu"> <em class="mb">图灵完全</em></strong>；这超出了本文的范围，但它非常有趣，如果你喜欢  <a class="ae ma" href="https://boingboing.net/2012/09/12/magic-the-gathering.html%29." rel="noopener ugc nofollow" target="_blank">，你可以在这里阅读它。</a>我是这款游戏的超级粉丝，它以<em class="mb">彩色轮盘</em>  <em class="mb"> l </em> 的形式包含了一个<a class="ae ma" href="https://medium.com/s/story/the-mtg-color-wheel-c9700a7cf36d" rel="noopener"> <strong class="kx iu">美丽简单却又深刻的人生哲学，它甚至帮助我在新兵训练营期间理解了某些关键的编程概念。</strong></a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/4769fdb4031a341c8302af48d2c5678e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*Z1n-GFCpGxXQjh6JvJqqWQ.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">只是几个咒语。</figcaption></figure><p id="7425" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">游戏的目标是将对手巫师(被称为<em class="mb">旅法师</em>)的生命值从最初的20或40减少到0(取决于游戏的版本)。这是通过伤害法术和能力的组合，用生物和其他动作攻击来完成的。就本文的目的而言，我将把重点放在施法上，因为这是堆叠在游戏中发挥作用的地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/a0199064eb22829b79405b3a90b5152f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*U0twOZyoOXw5GHkBTA-O4g.gif"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">MTG烟囱流动的可视化。不用担心“优先”。</figcaption></figure><p id="3057" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">上图说明了在MTG咒语和异能是如何被加入堆叠的。你可以把每个玩家添加咒语到堆栈中，就像JavaScript <em class="mb">把</em>函数推到调用堆栈中执行一样。这不是一个完美的类比，但是让我们通过代码进一步探索相似之处。</p><blockquote class="nh ni nj"><p id="7fc3" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">T <!-- -->看看下面的JavaScript代码，特别关注一下<strong class="kx iu"> console.log() </strong>的顺序:</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">魔术中使用堆栈的经典交换。</figcaption></figure><p id="dcd4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="mb">(注意:出于类比的目的，这个例子被稍微简化了。实际上，</em><strong class="kx iu"><em class="mb">console . log()</em></strong><em class="mb">也被推送到堆栈中，就像所有这些代码在其中运行的</em><strong class="kx iu"><em class="mb">main()</em></strong><em class="mb">执行上下文一样。要更深入地了解执行的背景，请查看这篇文章</em>   <em class="mb">，这篇文章对执行做了更深入的解释。)</em></p><p id="6d42" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果您从上到下阅读这段代码，您可能会认为<strong class="kx iu"> console.log() </strong>将按照它们在代码中出现的顺序从上到下出现在终端输出中。然而，事实并非如此。让我们看看它们在输出中实际出现的顺序:</p><blockquote class="nh ni nj"><p id="3590" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">玩家1施放闪电箭！</p><p id="a55d" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">玩家2施放反击术，目标是玩家1的闪电箭</p><p id="1562" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">没有更多的法术可以施展。开始解析堆栈。</p><p id="018d" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">反击解决和反击闪电箭！</p><p id="d9e8" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">闪电箭被反击并从堆叠中移除。</p></blockquote><p id="19e6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是怎么回事？让我们一步一步来。</p><p id="1a45" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最初，调用堆栈是空的。函数已定义但尚未调用。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="4f84" class="nu nv it nq b gy nw nx l ny nz">castLightningBolt();</span></pre><p id="5ab2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在文件的底部，第一个函数被调用，<em class="mb">将</em>推送到调用堆栈。第一个<strong class="kx iu"> console.log() </strong>打印:</p><blockquote class="nh ni nj"><p id="a1e9" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">玩家1施放闪电箭！</p></blockquote><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="8d6f" class="nu nv it nq b gy nw nx l ny nz">function castLightningBolt() {<br/>  console.log('Player 1 casts Lightning Bolt!');</span><span id="3780" class="nu nv it nq b gy oa nx l ny nz">  castCounterspell();</span><span id="0606" class="nu nv it nq b gy oa nx l ny nz">  console.log('Lightning Bolt is countered and removed from the stack.');<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/31cf28324dddb30baa6f49f2b5825e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*v2nnK5g4wpZVUmRMjsZajA.png"/></div></figure><p id="0cdd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">调用栈现在包含一个函数/法术。但是，在第二个<strong class="kx iu"> console.log() </strong>运行之前，调用了下一个函数:<strong class="kx iu"> castCounterspell() </strong>。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="4094" class="nu nv it nq b gy nw nx l ny nz">function castCounterspell() {<br/>  console.log('Player 2 casts Counterspell, targeting Player 1’s Lightning Bolt.');</span><span id="65fa" class="nu nv it nq b gy oa nx l ny nz">  resolvePhase();</span><span id="d371" class="nu nv it nq b gy oa nx l ny nz">  console.log('Counterspell resolves and counters Lightning Bolt!');<br/>}</span></pre><p id="d1f3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">和前面一样，<strong class="kx iu"> castCounterspell() </strong>被推送到调用堆栈中，<strong class="kx iu"> castCounterspell() </strong>函数中的第一个<strong class="kx iu"> console.log() </strong>被打印出来:</p><blockquote class="nh ni nj"><p id="6a61" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">玩家2施放反击术，目标是玩家1的闪电。</p></blockquote><p id="9d0a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">调用堆栈现在看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/2d7730a9ac928dc02bd09346e6d05b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*rTi4TuC2uMc949ig5n1i5Q.png"/></div></figure><p id="d5eb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在打印<strong class="kx iu"> castCounterspell() </strong>中的第二个<strong class="kx iu"> console.log() </strong>之前，调用函数<strong class="kx iu"> resolvePhase() </strong>并将<em class="mb">推送到调用栈。</em></p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="3970" class="nu nv it nq b gy nw nx l ny nz">function resolvePhase() {<br/>  console.log('No further spells to cast. Begin resolving the stack.');<br/>}</span></pre><p id="1673" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">由于函数体中没有进一步的函数调用，它继续打印:</p><blockquote class="nh ni nj"><p id="0d1a" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">没有更多的法术可以施展。开始解析堆栈。</p></blockquote><p id="e211" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">完全执行后，<strong class="kx iu"> resolvePhase() </strong>然后<em class="mb">从栈顶弹出</em>。</p><p id="a4e9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，堆栈上剩余的函数开始以调用它们的相反顺序逐一解析，并且<em class="mb">将</em>弹出调用堆栈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/5e3adbc23a6017d11afedf16b3e8b05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*IWsDhiB3uXhsBpYnBqdcIg.png"/></div></figure><p id="d420" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，从上面的日志序列中可以看到，<strong class="kx iu"> castCounterspell() </strong>函数将它的第二个<strong class="kx iu">console . log()</strong>——在调用<strong class="kx iu"> resolvePhase() </strong>之后的一个<em class="mb">——打印到控制台，然后从堆栈中删除，随后是<strong class="kx iu"> castLightningBolt() </strong>函数执行相同的操作:</em></p><blockquote class="nh ni nj"><p id="e321" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">反击解决和反击闪电箭！</p><p id="befe" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">闪电箭被反击并从堆叠中移除。</p></blockquote><p id="02b8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">堆栈现在是空的；在MTG，这导致阶段结束。在JavaScript中，这意味着代码运行完毕。</p><p id="bfb8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="mb">(通常函数有一个输出到</em> <strong class="kx iu"> <em class="mb">返回</em> </strong> <em class="mb">)，但是这个例子中的函数只是简单地将文本打印到控制台。)</em></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="b8d7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi lr translated">调用栈有一个可以达到的最大大小(在Chrome浏览器中是16000帧)；如果堆栈大小超过这个，将会抛出一个错误，浏览器将会崩溃，并显示消息<strong class="kx iu">最大堆栈错误达到。</strong>这通常是由函数进入无限循环引起的，也可以通过魔法卡演示。</p><p id="fd0a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">看看下面的卡片，看看你是否明白了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/5f6a613c883694d8100a0218a0ecd29c.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*VnVW5kxeqKUi6SaDSrDpgg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd ku">Magic IMO中最cheesiest的无限循环之一。</strong></figcaption></figure><blockquote class="nh ni nj"><p id="ab60" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated"><strong class="kx iu">现在用代码读出来:</strong></p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="df16" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如你可能推断的那样，调用<strong class="kx iu"> ping() </strong>通过调用<strong class="kx iu">excuse blood()</strong>来引发循环，后者调用<strong class="kx iu"> sanguineBond() </strong>，后者调用<strong class="kx iu">excuse blood()</strong>，后者调用<strong class="kx iu"> sanguineBo </strong> …。你明白了。</p><blockquote class="nh ni nj"><p id="0332" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">这导致玩家2立即获胜，并且控制台输出为:</p></blockquote><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="1f14" class="nu nv it nq b gy nw nx l ny nz"><strong class="nq iu"><em class="mb">...15,995 lines of the same output above...</em></strong></span><span id="a8d7" class="nu nv it nq b gy oa nx l ny nz">Player 2 gained one life. Player 1 loses one life.</span><span id="5fe9" class="nu nv it nq b gy oa nx l ny nz">Player 1 lost one life. Player 2 gains one life.</span><span id="2322" class="nu nv it nq b gy oa nx l ny nz">Player 2 gained one life. Player 1 loses one life.</span><span id="d4ef" class="nu nv it nq b gy oa nx l ny nz">Player 1 lost one life. Player 2 gains one life.</span><span id="6c1b" class="nu nv it nq b gy oa nx l ny nz">Player 2 gained one life. Player 1 loses one life.</span><span id="4bc7" class="nu nv it nq b gy oa nx l ny nz">_stream_readable.js:896</span><span id="3f11" class="nu nv it nq b gy oa nx l ny nz">Readable.prototype.removeListener = function(ev, fn) {</span><span id="ce57" class="nu nv it nq b gy oa nx l ny nz">RangeError: Maximum call stack size exceeded</span><span id="c0f2" class="nu nv it nq b gy oa nx l ny nz">at WriteStream.Readable.removeListener (_stream_readable.js:896:45)</span><span id="debd" class="nu nv it nq b gy oa nx l ny nz">at Object.Console.&lt;computed&gt; (internal/console/constructor.js:245:12)</span><span id="08fa" class="nu nv it nq b gy oa nx l ny nz">at Object.log (internal/console/constructor.js:282:26)</span><span id="d1a1" class="nu nv it nq b gy oa nx l ny nz">at sanguineBond (/Users/commoddity/lighthouse/w8/d5-writing/mtg-infinite.js:14:10)</span><span id="4e44" class="nu nv it nq b gy oa nx l ny nz">at exquisiteBlood (/Users/commoddity/lighthouse/w8/d5-writing/mtg-infinite.js:10:2)</span></pre><p id="9b53" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">结尾的那堆代码被称为<strong class="kx iu">堆栈跟踪</strong>，对调试非常有用。它通常包含对程序员有用的信息，帮助他们确定到底哪里出错了。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="bd43" class="od nv it bd ku oe of og oh oi oj ok ol jz om ka on kc oo kd op kf oq kg or os bi translated">异步函数和事件循环</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ot"><img src="../Images/eadc10e95eb0e1839a5c1ea636da7bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dth8FqGhMTpyBUZfELKcIg.jpeg"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">事件循环的可视化表示。感谢<a class="ae ma" href="https://www.leveluptutorials.com/" rel="noopener ugc nofollow" target="_blank">升一级教程。</a></figcaption></figure><p id="be93" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我之前提到的<strong class="kx iu">事件循环</strong>是JavaScript处理异步函数的方式。如果你不知道那些是什么，你可以在这里阅读<a class="ae ma" href="https://medium.com/javascript-in-plain-english/javascript-async-await-and-promises-explained-like-youre-five-years-old-61733751e9a5" rel="noopener"><strong class="kx iu"/></a>关于异步概念的精彩介绍。</p><p id="3741" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">基本上，几乎所有的互联网应用程序都会在某个时候包含依赖于数据或输入的代码，这些数据或输入可能会在不确定的时间返回或出现。由于JavaScript是单线程的<a class="ae ma" href="https://dev.to/steelvoltage/if-javascript-is-single-threaded-how-is-it-asynchronous-56gd" rel="noopener ugc nofollow" target="_blank"><strong class="kx iu"/></a><strong class="kx iu"/>和<strong class="kx iu"> </strong> <a class="ae ma" href="https://nodejs.org/de/docs/guides/blocking-vs-non-blocking/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx iu">阻塞的</strong> </a>，这意味着它需要一种方法来处理这些代码，而不停止它试图运行的整个代码块。如果在移动到下一行之前，它必须等待每一个不确定的数据或输入，那么它可能需要非常长的时间来运行，<em class="mb">或者可能根本不运行</em>；这对用户不利，因此对程序员也不利。这就是<strong class="kx iu">事件循环</strong>出现的地方。</p><p id="680d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当一个异步函数被调用时，它被推入一个名为<strong class="kx iu"> <em class="mb">回调队列</em> </strong>的队列中，等待程序的其余部分运行。当剩余的(<em class="mb">同步</em>)代码运行完毕，如果回调队列中的函数所依赖的数据已经返回或者它们等待的事件已经发生，那么这些函数将运行<em class="mb">。还记得我说过<strong class="kx iu">事件循环</strong>使用类似<em class="mb"> FIFO的</em>数据结构吗？</em></p><blockquote class="me"><p id="1720" class="mf mg it bd mh mi mj mk ml mm mn lq dk translated"><em class="md">回调队列</em>中的函数将按照特定的顺序运行，但是<em class="md">只有在它们的特定条件被满足时才会运行</em>。</p></blockquote><p id="25fd" class="pw-post-body-paragraph kv kw it kx b ky mo ju la lb mp jx ld le mq lg lh li mr lk ll lm ms lo lp lq im bi translated">如果函数仍在等待满足某个条件，队列中的下一个函数将改为运行，被跳过的函数稍后将返回。</p><p id="5fbb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果这有点令人困惑，那完全没关系。也许另一个<em class="mb">魔法:聚会</em>的类比可以帮助澄清它(不要担心理解这些卡片上的所有规则文本)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ou"><img src="../Images/a82b5c93bb7660002d01a50c752adeb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQyN6Wl-QVQxy5Hqgonx-A.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated"><strong class="bd ku">化为薄雾</strong>是这里的重要底牌。另外两个只是配角。</figcaption></figure><blockquote class="nh ni nj"><p id="f6c1" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated"><strong class="kx iu">转雾</strong>的效果就像一个异步函数；换句话说，它被推出调用堆栈，放入回调队列。示例中使用了一个<strong class="kx iu"> setTimeout() </strong>函数来模拟异步行为。</p><p id="5458" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">考虑到这一点，考虑下面的代码:</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="be81" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">和我们的第一个例子一样，直到程序的最后两行才调用函数。此时，<strong class="kx iu"> castTurnToMist() </strong>被调用，它打印:</p><blockquote class="nh ni nj"><p id="d7c1" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">玩家1施放变身迷雾。</p><p id="13b8" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">将目标生物移出场上。</p></blockquote><p id="26b8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后变量<strong class="kx iu"> saddlebackLagacInPlay </strong>被设置为<em class="mb">假。</em></p><p id="421b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">之后的下一行代码是我们的<strong class="kx iu"> setTimeout() </strong>函数，它表现得好像是异步的，这意味着它被<em class="mb">推送到<strong class="kx iu"> <em class="mb">回调队列</em> </strong>中，并将在至少5000毫秒后解析，打印它的<strong class="kx iu"> console.log() </strong>，并将<strong class="kx iu"> saddlebackLagacInPlay </strong>设置为<em class="mb"> true </em> <strong class="kx iu"> <em class="mb">。</em> </strong></em></p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="6c12" class="nu nv it nq b gy nw nx l ny nz">setTimeout(() =&gt; {<br/>  phase = 'end of turn';<br/>  saddlebackLagacInPlay = true;<br/>  console.log(`Return target creature to play at ${phase}.`);<br/>}, 5000);</span><span id="1b4f" class="nu nv it nq b gy oa nx l ny nz"><em class="mb">// This function simulates the behaviour of an asynchronous function // by pushing its execution outside the call stack and into the <br/>// event loop. In a real async function, this would be because the // function waits for data from a network request or user input.</em></span></pre><p id="c035" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这结束了<strong class="kx iu"> castTurnToMist()的</strong>函数体，因此<em class="mb">将</em>弹出调用堆栈。</p><p id="97b1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在<strong class="kx iu"> castFireball() </strong>被调用，针对可怜的鞍背拉加。<strong class="kx iu"> castFireball() </strong>根据s <strong class="kx iu"> addlebackLagacInPlay，</strong>的布尔值有条件地打印文本，该值当前仍为<em class="mb">假</em>。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="9a87" class="nu nv it nq b gy nw nx l ny nz">const castFireball = () =&gt; {<br/>  if (saddlebackLagacInPlay === true) {<br/>    console.log('Saddleback Lagac targeted by Fireball.')<br/>  } else {<br/>    console.log('Invalid target. Saddleback Lagac is not in play.');<br/>  }<br/>};</span></pre><p id="3da9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">尽管在代码中<strong class="kx iu"> setTimeout() </strong>函数在<strong class="kx iu"> castFireball() </strong>之前被调用，但是它异步地<em class="mb">动作</em>，因此所有剩余的代码必须在它可以从<strong class="kx iu"> <em class="mb">回调队列</em> </strong>解析之前运行。</p><p id="cfe8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此<strong class="kx iu"> saddlebackLagacInPlay </strong>仍然是<em class="mb"> false </em>并且<strong class="kx iu"> castFireball() </strong>将打印:</p><blockquote class="nh ni nj"><p id="a80a" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">无效目标。马鞍峰拉加克没有上场。</p></blockquote><p id="29fe" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">五秒钟后，当<strong class="kx iu"> setTimeout() </strong>函数体从其在<strong class="kx iu"> <em class="mb">回调队列</em> </strong>中的位置解析时，我们看到以下内容被打印到控制台:</p><blockquote class="nh ni nj"><p id="faba" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">回合结束时，将目标生物移回场上。</p></blockquote><p id="3f38" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="mb">【1】关于确切订单的更多细节，请阅读</em> <a class="ae ma" href="https://nodejs.org/uk/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank"> <em class="mb">本文</em> </a> <em class="mb">。</em></p><p id="3faa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="mb">【2】确切地说:5000毫秒加上运行</em> <strong class="kx iu"> <em class="mb">同步</em> </strong> <em class="mb">代码所需的时间，这些代码必须在回调队列开始运行之前执行。</em></p><p id="49a5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="mb">【3】如果没有了</em><strong class="kx iu"><em class="mb">setTimeout()</em></strong><em class="mb">函数内的</em><strong class="kx iu"><em class="mb">castTurnToMist()</em></strong><em class="mb">所有的代码早就同步运行了。这意味着当</em><strong class="kx iu"><em class="mb">cast fireball()</em></strong><em class="mb">被调用</em><strong class="kx iu"><em class="mb">saddlebackLagacInPlay</em></strong><em class="mb">就会被求值为true，而</em><strong class="kx iu"><em class="mb">cast fireball()</em></strong><em class="mb">就会被打印:</em></p><blockquote class="nh ni nj"><p id="b1f1" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">被火球瞄准的马鞍峰拉加。</p></blockquote></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="0815" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我希望这个例子让JavaScript中的异步函数和<strong class="kx iu">事件循环</strong>的行为更加清晰。如果没有，不要担心；这是一个复杂的话题，可能需要更多的阅读和经验来弄清楚。如果您想阅读更多内容，整篇文章中链接的文章可能会提供对该主题的更深入理解。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/0820b36199417480ba82844491436d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*Lvx0xkTWzc8HipPMFsU14Q.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">结束了。</figcaption></figure><blockquote class="nh ni nj"><p id="befd" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated"><strong class="kx iu"> 2020年，帕斯卡尔·范·卢文</strong></p><p id="fe71" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated">pascalvanleeuwen604@gmail.com</p><p id="bcd5" class="kv kw mb kx b ky kz ju la lb lc jx ld nk lf lg lh nl lj lk ll nm ln lo lp lq im bi translated"><a class="ae ma" href="https://github.com/Commoddity/" rel="noopener ugc nofollow" target="_blank">https://github.com/Commoddity/</a></p></blockquote></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="8583" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu">参考文献</strong></p><p id="09f1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><a class="ae ma" href="https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec" rel="noopener">了解Javascript函数执行—调用栈、事件循环、任务&amp;更多</a> — <em class="mb"> Gaurav Pandvia </em>、<strong class="kx iu"> Medium </strong></p><p id="2bc3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><a class="ae ma" href="https://developer.mozilla.org/en-US/docs/Glossary/Call_stack" rel="noopener ugc nofollow" target="_blank">调用栈</a> — <strong class="kx iu"> MDN Web Docs </strong></p><p id="650b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><a class="ae ma" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">堆栈(抽象数据类型)</a>——<strong class="kx iu">维基百科</strong></p><p id="9499" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><a class="ae ma" href="https://www.youtube.com/watch?v=1AJ4ldcH2t4" rel="noopener ugc nofollow" target="_blank">栈&amp;队列| JavaScript中的数据结构</a> — <em class="mb"> beiatrix </em>，<strong class="kx iu"> YouTube </strong></p><p id="e81d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><a class="ae ma" href="https://www.youtube.com/watch?v=IWQ74f2ot7E" rel="noopener ugc nofollow" target="_blank">栈:后进先出</a>——<em class="mb">复古游戏力学讲解</em>、<strong class="kx iu"> YouTube </strong></p></div></div>    
</body>
</html>