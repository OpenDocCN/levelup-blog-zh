<html>
<head>
<title>Why refactoring class components to Hooks is not always straightforward</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么将类组件重构为钩子并不总是简单明了的</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-refactoring-class-components-to-hooks-is-not-always-straightforward-e5775ebceef5?source=collection_archive---------8-----------------------#2020-06-19">https://levelup.gitconnected.com/why-refactoring-class-components-to-hooks-is-not-always-straightforward-e5775ebceef5?source=collection_archive---------8-----------------------#2020-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aa50" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过转换使用类组件的应用程序来学习它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d56399868cf743630da3fbd93145a4d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PKzlH5CIpEpJqgtp"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">杰斯·贝利在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5e54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探讨为什么从类组件到React Hooks的重构并不简单，以及如何有效地转换它。</p><p id="1d92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是React钩子的新手，可以在这里查看我以前的文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/an-introduction-to-react-hooks-50281fd961fe">来了解钩子的介绍。</a></p><h2 id="3939" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">我们开始吧</h2><p id="7a42" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">看看下面使用类组件的演示</p><p id="a8f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">演示:【https://codesandbox.io/s/using-class-component-rp4eu T21】</p><p id="e46b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们有一个从指定值开始倒计时的倒计时器。此外，我们有一个下拉菜单，允许我们用不同的值重新启动计时器。</p><p id="ea66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mt mu mv mw b">Counter.js</code>组件文件中，我们添加了一个<code class="fe mt mu mv mw b">startTimer</code>函数，当组件被挂载时，以及当下拉列表值改变时，我们都会调用这个函数。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="4bf0" class="lv lw it mw b gy nb nc l nd ne">startTimer = () =&gt; {<br/>  this.interval = setInterval(() =&gt; {<br/>    if (this.state.counter &gt; 0) {<br/>      this.setState(prevState =&gt; {<br/>        return { counter: prevState.counter - 1 };<br/>      });<br/>    } else {<br/>      clearInterval(this.interval);<br/>    }<br/>  }, 1000);<br/>};</span></pre><p id="86a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将代码从<code class="fe mt mu mv mw b">Counter.js</code>文件转换成使用<code class="fe mt mu mv mw b">Hooks</code>。</p><p id="d4ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mt mu mv mw b">Counter</code>组件中，使用从<code class="fe mt mu mv mw b">counter</code>属性中取值的<code class="fe mt mu mv mw b">useState</code>声明状态</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="9f0f" class="lv lw it mw b gy nb nc l nd ne">const [counter, setCounter] = useState(props.counter);</span></pre><p id="0573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并在<code class="fe mt mu mv mw b">counter</code>值变化时添加<code class="fe mt mu mv mw b">useEffect</code>钩子启动定时器。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="a800" class="lv lw it mw b gy nb nc l nd ne">useEffect(() =&gt; {<br/>  const interval = setInterval(() =&gt; {<br/>    if (counter &gt; 0) {<br/>      setCounter(prev =&gt; prev - 1);<br/>    } else {<br/>      clearInterval(interval);<br/>    }<br/>  }, 1000);<br/>}, [counter]);</span></pre><p id="9015" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">演示:<a class="ae ky" href="https://codesandbox.io/s/initialchange-vmtwm" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/initialchange-vmtwm</a></p><p id="0a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe mt mu mv mw b">counter</code>启动，但当它达到零值时不会停止。此外，它不能正确倒计时。</p><p id="e8f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为每隔1000毫秒(1秒)就会调用<code class="fe mt mu mv mw b">useEffect</code>中的<code class="fe mt mu mv mw b">setInterval</code>函数，所以我们需要在它开始向下计数下一个间隔之前清除前一个间隔。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="1fb7" class="lv lw it mw b gy nb nc l nd ne">useEffect(() =&gt; {<br/>  const interval = setInterval(() =&gt; {<br/>    if (counter &gt; 0) {<br/>      setCounter(prev =&gt; prev - 1);<br/>    } else {<br/>      clearInterval(interval);<br/>    }<br/>  }, 1000);</span><span id="7f46" class="lv lw it mw b gy nf nc l nd ne">  return () =&gt; clearInterval(interval);<br/>}, [counter]);</span></pre><p id="9eb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你可能知道的，从<code class="fe mt mu mv mw b">useEffect</code>返回一个函数将在组件被安装时执行，也是在再次运行该效果之前执行，因此<code class="fe mt mu mv mw b">useEffect</code>中的以下代码将在再次调用<code class="fe mt mu mv mw b">useEffect</code>之前清除间隔。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="cbf1" class="lv lw it mw b gy nb nc l nd ne">return () =&gt; clearInterval(interval);</span></pre><p id="157f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">演示:<a class="ae ky" href="https://codesandbox.io/s/clear-interval-ebc2h" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/clear-interval-ebc2h</a></p><p id="853f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的,<code class="fe mt mu mv mw b">counter</code>正确地倒计时，当它到达零时也停止。</p><p id="91da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们添加代码，以便在更改下拉列表值时重新启动计时器。</p><p id="3d06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了做到这一点，我们将把<code class="fe mt mu mv mw b">setInterval</code>功能分离到一个函数中，这样我们就可以在组件加载和下拉列表值改变时调用它。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="8eef" class="lv lw it mw b gy nb nc l nd ne">const startTimer = () =&gt; {<br/>  const interval = setInterval(() =&gt; {<br/>    if (counter &gt; 0) {<br/>      setCounter(prev =&gt; prev - 1);<br/>    } else {<br/>      clearInterval(interval);<br/>    }<br/>  }, 1000);</span><span id="74f7" class="lv lw it mw b gy nf nc l nd ne">  return () =&gt; clearInterval(interval);<br/>};</span><span id="c165" class="lv lw it mw b gy nf nc l nd ne">useEffect(() =&gt; {<br/>  startTimer();<br/>}, [startTimer]);</span></pre><p id="c5b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">演示:<a class="ae ky" href="https://codesandbox.io/s/timer-function-h8v52" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/timer-function-h8v52</a></p><p id="bc21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在上面的演示中所看到的，在将代码移动到一个函数中之后，它没有像预期的那样工作，并且我们在控制台中得到一个警告</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/5ab509a90d3fb0b0c0ff526222458f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7s03c6S6vIBSfoAHpzE2PA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在每次渲染警告时使用效果挂钩变化</figcaption></figure><p id="ce21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们已经按照警告的建议将<code class="fe mt mu mv mw b">startTimer</code>函数包装在<code class="fe mt mu mv mw b">useCallback</code>钩子中，但是<code class="fe mt mu mv mw b">counter</code>在达到零值时仍然没有停止。</p><p id="711e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为我们已经将<code class="fe mt mu mv mw b">counter</code>指定为<code class="fe mt mu mv mw b">useCallback</code>的依赖项，所以每次<code class="fe mt mu mv mw b">counter</code>改变时都会创建<code class="fe mt mu mv mw b">setInterval</code>函数。此外，当下拉列表值改变时，<code class="fe mt mu mv mw b">counter</code>不会重新启动。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="c02d" class="lv lw it mw b gy nb nc l nd ne">const startTimer = useCallback(() =&gt; {<br/>  const interval = setInterval(() =&gt; {<br/>    if (counter &gt; 0) {<br/>      setCounter(prev =&gt; prev - 1);<br/>    } else {<br/>      clearInterval(interval);<br/>    }<br/>  }, 1000);</span><span id="e355" class="lv lw it mw b gy nf nc l nd ne">  return () =&gt; clearInterval(interval);<br/>}, [counter]);</span><span id="a57e" class="lv lw it mw b gy nf nc l nd ne">useEffect(() =&gt; {<br/>  startTimer();<br/>}, [startTimer]);</span></pre><p id="bebe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">演示:<a class="ae ky" href="https://codesandbox.io/s/usecallback-hook-y4m70" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/usecallback-hook-y4m70</a></p><p id="6d23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，计数器在达到零值时并未停止，因为我们已经将计数器指定为<code class="fe mt mu mv mw b">useCallback</code>的依赖项，每次计数器改变时都会创建<code class="fe mt mu mv mw b">setInterval</code>函数。</p><p id="f9fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当下拉列表值发生变化时，计数器不会重新启动。所以问题在于计数器变量，因为在它改变之后，<code class="fe mt mu mv mw b">useCallback</code>钩子被再次调用。</p><p id="95a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以为了解决这个问题，我们需要一种方法来避免在<code class="fe mt mu mv mw b">useEffect</code>或<code class="fe mt mu mv mw b">useCallback</code>钩子中使用外部变量(在我们的例子中是<code class="fe mt mu mv mw b">counter</code>)。通过避免使用外部变量，我们可以最小化依赖的数量，并且效果不会运行多次。一种方法是使用updater函数语法来设置状态。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="7999" class="lv lw it mw b gy nb nc l nd ne">const startTimer = () =&gt; {<br/>  setInterval(() =&gt; {<br/>   console.log("inside startTimer");<br/>   setCounter(prev =&gt; {<br/>      if (prev &gt; 0) {<br/>        return prev - 1;<br/>      } else {<br/>        return prev;<br/>      }<br/>    });<br/>  }, 1000);<br/>};</span><span id="e39f" class="lv lw it mw b gy nf nc l nd ne">useEffect(() =&gt; {<br/>  setCounter(props.counter);<br/>  startTimer();<br/>}, [props.counter]);</span></pre><p id="50ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">演示:<a class="ae ky" href="https://codesandbox.io/s/using-updater-function-w90sk" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/using-updater-function-w90sk</a></p><p id="0d8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，当下拉列表的值改变时，<code class="fe mt mu mv mw b">counter</code>正确地递减并且重新开始。</p><p id="e832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们使用updater函数语法来获取<code class="fe mt mu mv mw b">counter</code>值的前一个状态，还将if条件移到了<code class="fe mt mu mv mw b">setCounter</code>函数中，这样我们在返回一个新状态时，将总是获得更新后的值。</p><p id="5443" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会注意到的一件事是，<code class="fe mt mu mv mw b">setInterval</code>函数仍然被调用，即使<code class="fe mt mu mv mw b">counter</code>达到零，正如在控制台中可以看到的，所以我们需要清除间隔。</p><p id="591e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要使用<code class="fe mt mu mv mw b">useRef</code>钩子，这样我们就可以在<code class="fe mt mu mv mw b">startTimer</code>函数之外访问<code class="fe mt mu mv mw b">interval</code>定时器值</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="19cd" class="lv lw it mw b gy nb nc l nd ne">const counterRef = useRef();</span><span id="48ce" class="lv lw it mw b gy nf nc l nd ne">useEffect(() =&gt; {<br/>  if (counter === 0) {<br/>    clearInterval(counterRef.current);<br/>  }<br/>}, [counter]);</span><span id="7d44" class="lv lw it mw b gy nf nc l nd ne">useEffect(() =&gt; {<br/>  clearInterval(counterRef.current);<br/>  setCounter(props.counter);<br/>  startTimer();<br/>}, [props.counter]);</span><span id="9730" class="lv lw it mw b gy nf nc l nd ne">const startTimer = () =&gt; {<br/>  counterRef.current = setInterval(() =&gt; {<br/>    setCounter(prev =&gt; {<br/>      if (prev &gt; 0) {<br/>        return prev - 1;<br/>      } else {<br/>        return prev;<br/>      }<br/>    });<br/>  }, 1000);<br/>};</span></pre><p id="e463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">演示:<a class="ae ky" href="https://codesandbox.io/s/final-working-countdown-z27wu" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/final-working-countdown-z27wu</a></p><p id="be2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们将<code class="fe mt mu mv mw b">setInterval</code>函数返回的值保存在<code class="fe mt mu mv mw b">counterRef.current</code>的<code class="fe mt mu mv mw b">startTimer</code>函数中。</p><p id="1762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在这种情况下，使用ref将保留其值，即使在多次重新呈现组件之后。</p><p id="6ed6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在第一个和第二个<code class="fe mt mu mv mw b">useEffect</code>钩子中使用ref值来清除间隔。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="9898" class="lv lw it mw b gy nb nc l nd ne">clearInterval(counterRef.current);</span></pre><p id="8b6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，现在代码工作正常，并且与我们的类组件演示相同。</p><p id="adc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天到此为止。我希望你学到了新东西。</p><p id="343d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">别忘了订阅我的每周时事通讯，里面有惊人的技巧、诀窍和文章，直接在这里的收件箱</strong> <a class="ae ky" href="https://yogeshchavan.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">订阅。</strong>T19】</a></p></div></div>    
</body>
</html>