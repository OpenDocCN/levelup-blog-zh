<html>
<head>
<title>TWIL: Deploying Node.js to Azure App Service with GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TWIL:使用GitHub操作将Node.js部署到Azure应用服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/twil-deploying-node-js-to-azure-app-service-with-github-actions-e5244073966e?source=collection_archive---------2-----------------------#2022-05-01">https://levelup.gitconnected.com/twil-deploying-node-js-to-azure-app-service-with-github-actions-e5244073966e?source=collection_archive---------2-----------------------#2022-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="abab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TWIL(本周我学习了)关于使用GitHub Actions将Node.js服务器部署到Azure应用服务的所有内容。👨‍💻星期三，是我居住的荷兰的国王日。👑当大多数人穿着橙色的衣服出现在瓷砖上的时候，🧡我从早到晚埋在代码中学习为<a class="km kn ep" href="https://medium.com/u/d6fbe35ec3ca?source=post_page-----e5244073966e--------------------------------" rel="noopener" target="_blank">schnoodle ao</a>部署令牌桥服务器所需的新技能，这将是SchnoodleV9发布的关键部分，支持SNOOD跨所有EVM兼容链的跨链互操作性。⛓️</p><p id="6d61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上个月，<a class="km kn ep" href="https://medium.com/u/d6fbe35ec3ca?source=post_page-----e5244073966e--------------------------------" rel="noopener" target="_blank">Schnoodle AO</a>发表了<a class="ae kl" href="https://schnoodledao.medium.com/building-a-sustainable-token-bridge-40adc33fd9c7" rel="noopener">这个关于我们完全自主桥梁(FAB)架构的故事</a>。🌉</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/d4b6b467a7b2d32e108ba45a8b591695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6URKAay8bTv16Tvf.png"/></div></div></figure><p id="904e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">FAB的底层技术是<strong class="jp ir">poly bridge infini chain mesh net协议</strong>，或简称皮条客。😎下面主要GitHub提交的焦点是架构的服务器部分(在上图中)，这是一个必须部署到<a class="ae kl" href="https://azure.microsoft.com/en-us/services/app-service/" rel="noopener ugc nofollow" target="_blank"> Azure App Service </a>的<a class="ae kl" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>服务器。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><a href="https://github.com/schnoodledao/contracts/commit/94f883d7ad10718667688856d9ea4c86974c891a"><div class="gh gi la"><img src="../Images/54c8ab8aceff3b89d1353afab313da1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*T1doR_JIGWqMZ9QD"/></div></a><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">重构令牌桥服务器以部署到Azure应用服务</figcaption></figure><p id="bfb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于部署，我选择使用<a class="ae kl" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>，这意味着每次提交都会导致自动部署。这被称为<a class="ae kl" href="https://en.wikipedia.org/wiki/CI/CD" rel="noopener ugc nofollow" target="_blank"> CI/CD </a>(持续集成和持续交付)，我通常是软件开发中的一个超级粉丝，因为它鼓励良好的<a class="ae kl" href="https://en.wikipedia.org/wiki/DevOps" rel="noopener ugc nofollow" target="_blank"> DevOps </a>软件实践，例如自动化构建和发布管道、测试自动化和增量变更(失败更容易识别)。♾️</p><p id="c5dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我们的Node.js令牌桥服务器并不太复杂，但它包含的一些特性带来了一些障碍，我不得不在学习所需技能的同时寻找解决方案。我实际上是一个试图从零开始的菜鸟💀英雄🦸‍♂️在24小时内。</p><p id="bef8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步，使用<a class="ae kl" href="https://docs.microsoft.com/en-us/azure/app-service/deploy-continuous-deployment?tabs=github" rel="noopener ugc nofollow" target="_blank">这些指令</a>，在Azure中创建一个带有测试部署槽的应用服务，并将其连接到部署中心的GitHub repo。很简单。🍋</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lf"><img src="../Images/1baed385946c5725e8f829eb08dfaaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xzFsjz4F_vzKvY2P2ioqNw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">Azure应用服务-部署中心</figcaption></figure><p id="29fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这生成了一个GitHub Actions工作流文件(如下所示),包含一些默认步骤。其中之一就是<code class="fe lg lh li lj b">npm run test</code>。而<a class="ae kl" href="https://github.com/schnoodledao/contracts/commit/a607f0173e40eb21c7b040464846f95a809a778d" rel="noopener ugc nofollow" target="_blank">这就是这个步骤自动创建的提交</a>，使用这个工作流文件将Azure App Service连接到GitHub。👨‍💻</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="8419" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务器使用的是<a class="ae kl" href="https://www.fastify.io/" rel="noopener ugc nofollow" target="_blank"> Fastify </a>，这是一个快速低开销的web框架。🌐这允许通过互联网从前端DApp ( <a class="ae kl" href="https://x.schnoodle.finance/" rel="noopener ugc nofollow" target="_blank"> Schnoodle X </a>)调用服务器来执行令牌桥所需的集中活动。🧐为了测试这个功能，我必须添加<a class="ae kl" href="https://node-tap.org" rel="noopener ugc nofollow" target="_blank">节点Tap </a>(由<a class="km kn ep" href="https://medium.com/u/2aba2e2f2208?source=post_page-----e5244073966e--------------------------------" rel="noopener" target="_blank"> isaacs </a>)这是一个用于JavaScript的<a class="ae kl" href="https://testanything.org/" rel="noopener ugc nofollow" target="_blank">test-any-protocol</a>(tap)库。目前，只添加了基本测试，因为最重要的测试是在智能合同单元测试中，这些测试是全面的，可以在这里找到<a class="ae kl" href="https://github.com/schnoodledao/contracts/blob/12ae3fc46ac89c651dce30e17deb346cc7ed4e09/test/Schnoodle.test.js#L304" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="93c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Schnoodle使用所谓的<a class="ae kl" href="https://en.wikipedia.org/wiki/Monorepo" rel="noopener ugc nofollow" target="_blank"> monorepo </a>。这是系统所有部分的所有代码都在一个GitHub库中的地方。这是由一些最大的科技公司引领的趋势，如谷歌、脸书、微软、优步、Airbnb和Twitter。🤯</p><p id="314e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这有很多好处，包括将所有代码放在一个地方。然而，在将Node.js服务器部署到Azure App Service时，这给我带来了三个问题。</p><h1 id="5297" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">问题1:文件夹结构</h1><p id="30ad" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">服务器代码不在根文件夹中；在一个子文件夹里。📂这导致了各种构建和部署错误，让我绞尽脑汁了几个小时，🤔我在网上找到了各种各样的黑客解决方案，看起来都有点难看。🧟‍♂️:最后，为了让它以一种干净的方式工作，我必须做三个主要的改变:</p><ol class=""><li id="ea0e" class="mp mq iq jp b jq jr ju jv jy mr kc ms kg mt kk mu mv mw mx bi translated">一个变化是在工作流文件中设置默认的<code class="fe lg lh li lj b">working-directory</code>，这样构建过程使用正确的文件夹来构建堆栈溢出的<a class="ae kl" href="https://stackoverflow.com/q/57806624/197591" rel="noopener ugc nofollow" target="_blank">解决方案。</a></li><li id="6777" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">另一个变化是将<code class="fe lg lh li lj b">PROJECT</code>添加到App Service应用程序设置中，并为其分配repo中项目的路径。这样服务器代码将被部署在<strong class="jp ir"> wwwroot </strong>中，而不是它的子文件夹中。否则，互联网上的通话将无法正常工作。🚫这个问题与Kudu有关，Kudu是Azure App Service中与基于源代码控制的部署相关的许多功能背后的引擎。一旦我的搜索引导我到GitHub上提出的一个关于Kudu的类似问题<a class="ae kl" href="https://github.com/projectkudu/kudu/issues/2661" rel="noopener ugc nofollow" target="_blank">，这引导我到这里</a>记录的解决方案<a class="ae kl" href="https://github.com/projectkudu/kudu/wiki/Customizing-deployments#using-app-settings-instead-of-a-deployment-file" rel="noopener ugc nofollow" target="_blank">。💪有时，解决方案被很好地记录下来，但是需要有人去体验如果没有正确的代码让谷歌搜索算法引导你找到这些解决方案，你就会遇到的问题。</a></li><li id="1ccc" class="mp mq iq jp b jq my ju mz jy na kc nb kg nc kk mu mv mw mx bi translated">最后，由于一个莫名其妙的错误，我又做了一个改动，将应用程序设置中的<code class="fe lg lh li lj b">SCM_DO_BUILD_DURING_DEPLOYMENT</code>设置为<code class="fe lg lh li lj b">false</code>。一个相当恼人的错误，我在网上发现的一些讨论暗示这是GitHub Actions的一个bug。🪲:无论如何，这是根据我找到的<a class="ae kl" href="https://errorsfixing.com/vs-code-publish-specific-folder-to-azure/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>解决的。</li></ol><h1 id="ffaa" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">问题2:智能协定构建文件</h1><p id="409b" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">当<a class="ae kl" href="https://trufflesuite.com/" rel="noopener ugc nofollow" target="_blank"> Truffle </a>在编译期间生成智能合约构建文件时，它们被输出到一个文件夹中，但是Node.js服务器和前端React应用程序都必须能够访问这些文件。对于monorepo，在本地开发环境中使用相对路径很容易。👨‍💻然而，对于服务器部署，这不起作用，因为部署的文件不包含monorepo中的所有文件；monorepo中特定应用程序所需的文件，如Node.js服务器。🙀</p><p id="86aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个问题，我必须使用符号链接来引用包含智能合约构建文件的文件夹。🔗我以前因为其他原因使用过很多次符号链接，但从来没有在GitHub repo中使用过。我在GitHub <a class="ae kl" href="https://stackoverflow.com/q/954560/197591" rel="noopener ugc nofollow" target="_blank">这里</a>找到了一个关于符号链接的很好的讨论。然后我通过添加两个符号链接解决了这个问题。一个用于Node.js服务器，一个用于React应用程序。问题解决了！✅一篇关于如何在Windows中添加符号链接的有用文章可以在这里找到<a class="ae kl" href="https://www.maketecheasier.com/create-symbolic-links-windows10/" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="eb0f" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">问题3:部署中有大量文件</h1><p id="288a" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">由于<strong class="jp ir"> node_modules </strong>中的文件数量(一个相当臭名昭著的“问题”)，我在构建期间收到了一个警告:</p><blockquote class="ne nf ng"><p id="b778" class="jn jo nd jp b jq jr js jt ju jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj kk ij bi translated">⚠️“这个工件中有超过10，000个文件，考虑在上传之前创建一个归档文件，以提高上传性能。”</p></blockquote><p id="ae9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">线索就在消息中，我遵循了<a class="ae kl" href="https://stackoverflow.com/a/69402502/197591" rel="noopener ugc nofollow" target="_blank">这个堆栈溢出答案</a>中的有用说明，它建议在部署期间压缩和解压缩工件。</p><p id="2a98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，由于同时使用<code class="fe lg lh li lj b">working-directory</code>选项的不寻常组合，这并不像我希望的那样顺利。😿</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nk"><img src="../Images/07f1fad1ebeae8e106129cdd73db0053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zjHEvsQWsPXG-t_zefB51A.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">将压缩工件与工作目录选项一起使用时出现部署错误</figcaption></figure><p id="a6a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我花了几个小时寻找解决方案，直到我自己写了一个关于堆栈溢出的问题来寻求某人的答案。然后我恍然大悟💡(仔细查看日志一段时间后)。解压到我解压的同一个文件夹。这成功了！🎉我贴出了解决方案，作为对我自己问题的<a class="ae kl" href="https://stackoverflow.com/a/72051608/197591" rel="noopener ugc nofollow" target="_blank">回答</a>。</p><h1 id="7d31" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">秘密！</h1><p id="723e" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">最后，我现在正在挑灯夜战，🕯️，我想解决存储和访问机密的问题🤭例如在任何桥操作中与目标链交互的<a class="ae kl" href="https://ethereum.org/en/glossary/#eoa" rel="noopener ugc nofollow" target="_blank"> EOA </a>的私钥。在本地开发期间，设置和秘密可以存储在<strong class="jp ir">中。使用<a class="ae kl" href="https://github.com/motdotla/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>访问env </strong>文件。</p><p id="6f9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得庆幸的是，我已经在开发NFT平台时建立了一个Azure Key Vault，我们在这里存储秘密，如Pinata API密匙，以及Azure Cosmos DB和Azure storage账户的密匙。🦾:我现在只需要在那里添加应用程序秘密，并按照这里的说明<a class="ae kl" href="https://docs.microsoft.com/en-us/samples/azure-samples/azure-sdk-for-js-keyvault-secret-get-set-managedid/get-set-keyvault-secrets-managed-id-nodejs/" rel="noopener ugc nofollow" target="_blank"/>(使用Azure托管身份)从Node.js服务器访问它们。</p><h1 id="a6c3" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">成功！</h1><p id="ec3d" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">瞧。服务器现在已经部署好了。💥这不仅是SNOOD迈出的重要一步，因为我们越来越接近发布加密领域最安全、最先进的令牌桥，对我来说，这也是一次非常充实、愉快的个人技术之旅。学习新技能让我们保持头脑清醒，大脑健康。🧠</p><p id="1fa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">永不停止。永不放弃。做一个胜利者！🥇即使这意味着在国庆节连续24小时不停地玩电脑！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/5bfcaff140c18b6150f61db1ad4c7c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*mM5NN8TxvM3ZiK3R.jpg"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">我说的是极客，不是瘸子！</figcaption></figure><p id="0b98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过<a class="ae kl" href="https://test.server.schnoodle.finance/Alive" rel="noopener ugc nofollow" target="_blank">链接</a>随意测试服务器是否处于活动状态。🕺</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/823319eddf177cdc1cabfd4767a6d18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*6ksdbE5WOPVnpzATHf0Ixg.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">{ "状态":"正常" }</figcaption></figure></div></div>    
</body>
</html>