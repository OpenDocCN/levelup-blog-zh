<html>
<head>
<title>Enumerations in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的枚举</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/enumerations-in-swift-5dd14b4055a7?source=collection_archive---------15-----------------------#2020-06-18">https://levelup.gitconnected.com/enumerations-in-swift-5dd14b4055a7?source=collection_archive---------15-----------------------#2020-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bbaee492788fe37786ad0310aa4e4298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zYxQFnE6NWjgiONUPo3j3Q.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="http://becodable.com/swift-enum/" rel="noopener ugc nofollow" target="_blank">http://becodable.com/swift-enum/</a></figcaption></figure><p id="a94b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">枚举是一种允许您定义可能值列表的数据类型。一个<strong class="ki iu">枚举</strong>允许你创建一个包含这些值的数据类型，这样它们就可以在你的应用中被一致地识别。</p><blockquote class="le lf lg"><p id="c5e9" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">换句话说:它是一组相关值的集合💯</p></blockquote><h1 id="b8ab" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">声明枚举</h1><p id="614b" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">若要声明枚举，请列出所有可能的成员值作为事例:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/6377b6131ea451b3e898a6b131565a8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*o0z5NLLvrHrI7p49djy3Aw.png"/></div></figure><p id="5470" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过将case子句压缩到一行来简化代码，每个值用逗号分隔:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/cf458a78aaf452fa5bdb03bc16432759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uG8tEBcK8GtyxAXK1Gb5HQ.png"/></div></div></figure><p id="dda4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi mu translated">他的代码创建了一个名为<code class="fe nd ne nf ng b">Month</code>的新枚举，有12个可能的成员值。普遍接受的最佳实践是每个成员值以小写首字母开头，就像属性一样。</p><h1 id="e257" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">了解枚举</h1><p id="dfc9" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">使用<em class="lh">枚举</em>的最佳方式是通过<code class="fe nd ne nf ng b">switch</code>语句。让我们做一个函数来证明:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/a40af1404ac782f090dd1b8772b189cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3iR60HfsZ67Q66a8gIq7AQ.png"/></div></div></figure><blockquote class="le lf lg"><p id="cda0" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">在上面的代码中，在函数参数中，就在参数被调用之前有一个<code class="fe nd ne nf ng b">for</code>名。它是一个内部名，我们在函数内部使用，在内部名之前有一个外部名，我们在函数之外使用。这里<code class="fe nd ne nf ng b">month</code>是内部名称，<code class="fe nd ne nf ng b">for</code>是外部名称。</p></blockquote><p id="82bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为Swift是强类型的，并且使用类型推断，所以您可以通过删除编译器已经知道类型的地方的枚举名称来简化<code class="fe nd ne nf ng b">semester(for:)</code>。保留点前缀，但丢失枚举名称，如下面switch语句中的情况所示:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/ec15639a3dcfe6d1586f5bc24a69eef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0cLIzQIhtyi1g-NH2QXYw.png"/></div></div></figure><h1 id="bccb" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">在Swift中迭代枚举案例</h1><p id="4e07" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">为了在一个特定的<em class="lh">枚举</em>中得到所有可用的<em class="lh">案例</em>，我们可以使用<em class="lh">枚举</em>类型<code class="fe nd ne nf ng b">CaseIterable</code>并且可以使用<code class="fe nd ne nf ng b">for</code>循环进行打印。参见下面的代码:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/51d46940143b519715127c723135bc20.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*wMrRudnBkBhGNvTtNTqlyA.png"/></div></figure><h1 id="5f64" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">Swift Enum中的原始值和关联值</h1><blockquote class="le lf lg"><p id="1900" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><strong class="ki iu">原始值</strong>:用<em class="it">枚举</em>事例附加值，为了访问这些我们写点原始值，可以访问那些用<em class="it">枚举事例</em>的值。</p></blockquote><p id="70f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有关原始值，请参见以下示例:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/31543d1bbf2edcc0201de57ac63fc334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UeN2B2OB0kF92mG7Pcdu9A.png"/></div></div></figure><p id="b96b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们创建了一个名为<code class="fe nd ne nf ng b">Fruits</code>的<em class="lh">枚举</em>，并在<em class="lh">处给出rawtype </em> <em class="lh">字符串</em>，并为每种情况给出原始值。没必要每个案例都给<code class="fe nd ne nf ng b">rawValues</code>。然后我们创建了一个函数来获取原始值。</p><p id="68f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将一个<em class="lh">枚举</em>设为类型<strong class="ki iu"> CaseIterable </strong>，那么你可以使用一个<code class="fe nd ne nf ng b">for</code>循环访问所有的案例，并且可以使用<strong class="ki iu"> allcases.count </strong>进行计数。</p><p id="1b1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来举例看看:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/09565444c5239f5f21577b7fe191ae2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*x9qjYrXOqz0c2tDT-sq5-Q.png"/></div></figure><p id="0cec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们将<strong class="ki iu"> CaseIterable </strong>添加到它的类型中，然后我们可以访问allCase和all case.count。</p><blockquote class="le lf lg"><p id="9efd" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><strong class="ki iu">关联值</strong>:关联值将Swift枚举的表达能力提升到了一个新的层次。它们允许您将一个自定义值(或多个值)与每个枚举案例相关联。</p></blockquote><p id="15c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了更好地理解关联值，我们应该浏览一下它们的代码示例:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/e8e5b9a87309adc341c118b25a2e656a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JMOaoOl8Fzn4WcRRpi2uvw.png"/></div></div></figure><p id="dd42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Swift中，不必将值与每个<em class="lh">枚举</em>案例相关联。在上面的代码中，我们制作了一个名为<code class="fe nd ne nf ng b">SocialMediaPaltaform</code>的<em class="lh">枚举</em>，并通过给出一个标准来检查谁有资格获得赞助。</p><blockquote class="nn"><p id="cd66" class="no np it bd nq nr ns nt nu nv nw ld dk translated"><strong class="ak">枚举可以有原始值或关联值，但不能两者都有。</strong></p></blockquote></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="deef" class="ll lm it bd ln lo oe lq lr ls of lu lv lw og ly lz ma oh mc md me oi mg mh mi bi translated">要点</h1><ul class=""><li id="d219" class="oj ok it ki b kj mj kn mk kr ol kv om kz on ld oo op oq or bi translated">一个<strong class="ki iu">枚举</strong>是定义一个公共类型的互斥案例的列表。</li><li id="67ce" class="oj ok it ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">枚举为老式的整数值提供了一种类型安全的替代方法。</li><li id="e16e" class="oj ok it ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">您可以使用枚举来处理响应、存储状态和封装值。</li><li id="fc4d" class="oj ok it ki b kj os kn ot kr ou kv ov kz ow ld oo op oq or bi translated">CaseIterable允许您循环遍历包含所有事例的枚举。</li></ul></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="b078" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">LinkedIn上有作者:【linkedin.com/in/my-pro-file】<a class="ae kf" href="https://www.linkedin.com/in/my-pro-file" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu"/></a></strong></p></div></div>    
</body>
</html>