<html>
<head>
<title>An SFML Input Handler Using C++ Lambda Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用C++ Lambda函数的SFML输入处理程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-sfml-input-handler-using-c-lambda-function-d011157d2907?source=collection_archive---------14-----------------------#2022-06-10">https://levelup.gitconnected.com/an-sfml-input-handler-using-c-lambda-function-d011157d2907?source=collection_archive---------14-----------------------#2022-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f4d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">支持我的内容通过</em> <a class="ae kp" href="https://anthony-a-morast.medium.com/membership" rel="noopener"> <em class="ko">成为中等会员</em> </a> <em class="ko">或者了解更多关于</em> <a class="ae kp" href="https://amzn.to/3NH9BZl" rel="noopener ugc nofollow" target="_blank"> <em class="ko">有效</em></a><em class="ko"/><a class="ae kp" href="https://amzn.to/3NGXtY7" rel="noopener ugc nofollow" target="_blank"><em class="ko">现代</em></a><em class="ko"/><a class="ae kp" href="https://amzn.to/3mBMy6m" rel="noopener ugc nofollow" target="_blank"><em class="ko">c++</em></a><em class="ko">开发(亚马逊附属链接)。</em></p><p id="ee60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">传统上，当处理计算机图形应用的输入时，例如用户界面、视频游戏等。使用越来越长的switch语句来确定哪个键被按下或释放，或者哪个鼠标按钮被点击。最近，我用C++创建了一个用户界面，使用SFML绘制了我最近关于现代投资组合理论的博客文章中的观点，以便更容易地查看数据(我知道我可以用Python来做这些，但我想学习SFML已经有一段时间了)。在这个过程中，我发现了一个有趣的解决方案，使用一组<em class="ko"> std::maps </em>和lambda函数来处理用户输入。在这篇文章中，我将通过一个简单的演示来介绍这种输入处理方法。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/6a3e7032637a703cedc5ee03a90d4844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cDUkTrM_gXbqZWVrYj31ow.jpeg"/></div></div></figure><h1 id="271b" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">演示</h1><p id="33e6" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">为了便于演示，我们创建了一个简单的二维SFML应用程序。这个应用程序在屏幕中间画了一个圆。用户可以使用箭头键移动圆圈(玩家)。可以使用数字键盘移动摄像机，包括对角线。加号和减号用于放大和缩小，按下Escape键可以关闭窗口并结束演示。此外，鼠标输入的一个例子是为鼠标左键添加一个回调函数，当鼠标左键被按下时，如果光标在player对象内，一条消息将被打印到屏幕上。</p><p id="3791" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">演示的大部分代码如下所示。在这篇文章的结尾提供了完整的代码。</p><h1 id="0001" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">λ表达式</h1><p id="19b4" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">Lambda表达式是在C++11中引入的，并且已经找到了许多实际的用例。本质上，Lambda表达式允许开发人员将C++函数视为变量，这比传递指向函数的指针要干净得多。Lambdas是许多其他编程语言的一个特性，包括Python和Java，并且已经成为许多类型的问题解决方案的支柱。我不会在这里详细介绍lambda表达式的基础知识，但是感兴趣的读者可以在<a class="ae kp" href="https://towardsdatascience.com/c-basics-understanding-lambda-7df00705fa48" rel="noopener" target="_blank">这篇文章</a>或者从<a class="ae kp" href="https://en.cppreference.com/w/cpp/language/lambda" rel="noopener ugc nofollow" target="_blank"> C++文档</a>中了解更多。</p><p id="26e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的例子中，我们将每个回调函数定义为一个lambda表达式，将它们存储在一个map中，并在需要时调用它们(即当相应的按钮被按下时)。</p><h1 id="a9a1" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">功能参数</h1><p id="051d" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">可能会想到的一个直接问题是:我们将如何处理不同输入可能需要的不同参数？很简单。创建一个类InputCallbackParameters，它保存所有回调函数需要的所有参数。这样做的好处是为每个回调创建一个通用的函数定义，因此输入处理类可以非常通用。由于这个类会很快变得很大(内存方面)，我建议尽可能通过<em class="ko">引用</em>或<a class="ae kp" href="https://stackoverflow.com/questions/2627166/what-is-the-difference-between-a-const-reference-and-normal-parameter" rel="noopener ugc nofollow" target="_blank"> <em class="ko">常量引用</em> </a> <em class="ko"> </em>来传递它，这样就不会在复制对象上花费太多的计算资源。</p><p id="9035" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在演示中，InputCallbackParameter类非常小</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="45bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该类将有四个可公开访问的成员:</p><ol class=""><li id="af4c" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">一个指向SFML窗口的指针，用来更新窗口和决定某些游戏参数。注意，这必须是一个指针，因为sf::Window类是不可复制的。</li><li id="393a" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">最后按下的键。这用于处理需要多次连续按键的输入。</li><li id="a065" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">“播放器”，实际上只是一个sf::CircleShape，即一个围绕屏幕移动的圆圈。</li><li id="f41e" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">一个bool值，用于存储当鼠标左键单击屏幕上的任何位置时，播放器是否被单击。</li></ol><h1 id="e00a" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">InputHandler类</h1><p id="321c" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">使用这个回调参数类，可以定义和实现输入处理类。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="bbf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如这里所看到的，这个类有三个私有映射，它们保存了从键盘/鼠标按钮到lambda回调函数的映射。lambda回调必须被定义为C++函数对象(std::function)。语法概括为</p><blockquote class="mv mw mx"><p id="c407" class="jq jr ko js b jt ju jv jw jx jy jz ka my kc kd ke mz kg kh ki na kk kl km kn im bi translated">标准::功能&lt;<return type=""> ( <parameter list="">)&gt; &gt;</parameter></return></p></blockquote><p id="40d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们的lambda函数将不返回任何内容(void ),只接受一个参数，parameter，它被定义为InputCallbackParameters类，或者是对一个参数的引用。</p><blockquote class="mv mw mx"><p id="19b3" class="jq jr ko js b jt ju jv jw jx jy jz ka my kc kd ke mz kg kh ki na kk kl km kn im bi translated">使用PARAMETER = InputCallbackParameters &amp;；</p></blockquote><p id="a5fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">InputHandler类中还有5个方法，其中3个方法用于将键/函数对添加到三个映射中的每一个，另外2个方法用于查找要执行的适当函数，前提是按钮/键被按下。实现如下所示。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ee33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">InputHandler类的实现非常简单明了。在Initialize*方法中将键/函数对添加到适当的映射中，并根据GetCallback方法的参数从适当的映射中提取回调。然后执行这些功能来完成所需的动作。</p><h1 id="c334" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">处理事件</h1><p id="5a74" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">通常，事件处理是在图形应用程序的循环中完成的。这是通过下面的代码完成的。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="4031" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如此处所示，处理了KeyReleased、KeyPressed和MouseButtonReleased事件，并使用InputHandler类的一个实例(<em class="ko"> ih </em>)来检索和执行回调函数。</p><h1 id="91e0" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">单按钮释放</h1><p id="26a4" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">最简单的情况是当用户按一次键时处理输入。这些事件被称为按键释放事件，因为按键事件是在按键被按下(即被按住)时发生的。可以说最有用的单个按键是关闭窗口的退出键(否则关闭SFML应用程序就太麻烦了)。因此，我们将首先实现这个回调。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d1d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Escape键回调很容易处理，只需用sf::Keyboard::Escape键和一个lambda函数初始化InputHandler中的key released事件来启动窗口关闭事件。这里有一个演示，虽然不是很精彩(以后的演示会更精彩一点)。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nb"><img src="../Images/7d74f892b2597554477f91b0b77696d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JJjzQ-8xe2Kf_3n-0zJnmA.gif"/></div></div></figure><h1 id="f985" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">按键(按住键)</h1><p id="aee8" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">其他有用的功能是通过按下(或按住)键来启动的。比如移动角色，移动相机，放大缩小。如果用户每次移动角色时都必须按下并释放按键，这种行为将会非常令人讨厌。所有这些都在下面的键绑定中实现。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="52bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面，数字键盘键1、2、3、4、6、7、8和9用于移动相机(绘制的对象保持静止)，箭头键用于移动角色(圆形)，加减键分别用于放大和缩小。下面是演示。观察“上次按下的键”文本的变化，以查看正在执行的操作。</p><h2 id="7223" class="nc ld it bd le nd ne dn li nf ng dp lm kb nh ni lq kf nj nk lu kj nl nm ly nn bi translated">变焦</h2><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nb"><img src="../Images/b864f4d445fe250177658e89a7f28f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dhRLRYNKtlkg4bdFuSkDRA.gif"/></div></div></figure><h2 id="bf58" class="nc ld it bd le nd ne dn li nf ng dp lm kb nh ni lq kf nj nk lu kj nl nm ly nn bi translated">相机移动</h2><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nb"><img src="../Images/3bc849ecb4b2480d7d7f63a954e8a14f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*t_DJnwep0ci9EXf_vT8huA.gif"/></div></div></figure><h2 id="091d" class="nc ld it bd le nd ne dn li nf ng dp lm kb nh ni lq kf nj nk lu kj nl nm ly nn bi translated">角色移动</h2><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nb"><img src="../Images/8e495b3c3bc97266a8b129dd308946b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*emkIPT8CwbaOWJFgAaAJLQ.gif"/></div></div></figure><h1 id="dfee" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">顺序按钮组合</h1><p id="7dce" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">接下来，需要多次按键的动作被添加到InputHandler中。请注意，这些是连续的按钮按下。不幸的是，这种方法不能处理同时按下按钮的情况，尽管可以把它们看作顺序按下按钮来代替。为了演示这一点，如果按下“C”键，然后按下“Y”、“R”、“B”或“G”中的一个，将会改变玩家的颜色，分别改变为黄色、红色、蓝色或绿色。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d058" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在Y、R、G或B键之前立即按下C键，此逻辑会将播放器的填充颜色更新为指定的颜色。</p><h2 id="0b32" class="nc ld it bd le nd ne dn li nf ng dp lm kb nh ni lq kf nj nk lu kj nl nm ly nn bi translated">演示</h2><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nb"><img src="../Images/1c4a3a785cba5805289f9dcd1a589b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7EP_qFJAvfzPd3sjce3DBQ.gif"/></div></div></figure><h1 id="195f" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">鼠标点击</h1><p id="8105" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">最后，鼠标左键点击功能将被初始化，如果玩家圈被点击，该功能将在屏幕顶部添加文本。如果在玩家当前不在的地方点击屏幕，文本将被清除。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="8ad5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此方法依赖于LocalContains方法，如果sf::Vector2f参数在sf::CircleShape参数内部，该方法将返回true。sf::Vector2f参数是单击鼠标左键时鼠标指针的位置。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h2 id="540c" class="nc ld it bd le nd ne dn li nf ng dp lm kb nh ni lq kf nj nk lu kj nl nm ly nn bi translated">演示</h2><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nb"><img src="../Images/b3005103fce34fa40fe08f73ff0f057c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XY0WBgSblDOwtDGo7EXZ9g.gif"/></div></div></figure><h1 id="3933" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="1a3b" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">在这篇文章中，我介绍了一种使用std::map对象和C++11 Lambda表达式处理鼠标和键盘事件的方法。这个方法可以扩展到处理滚轮事件和这里没有明确提到的其他键。虽然并不完美，但我觉得这种实现是标准的300行switch语句或更短的switch语句的一种受欢迎的替代方式，它具有许多不同的功能来实现所需的功能。</p><h1 id="133a" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">完整代码</h1><h2 id="b616" class="nc ld it bd le nd ne dn li nf ng dp lm kb nh ni lq kf nj nk lu kj nl nm ly nn bi translated">主页面</h2><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h2 id="9cca" class="nc ld it bd le nd ne dn li nf ng dp lm kb nh ni lq kf nj nk lu kj nl nm ly nn bi translated">InputHandler.cpp/hpp(包含InputCallbackParameters类)</h2><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h2 id="af36" class="nc ld it bd le nd ne dn li nf ng dp lm kb nh ni lq kf nj nk lu kj nl nm ly nn bi translated">生成文件</h2><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h2 id="b6d4" class="nc ld it bd le nd ne dn li nf ng dp lm kb nh ni lq kf nj nk lu kj nl nm ly nn bi translated">机器人字体TTF</h2><p id="cbee" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">为了编译和运行代码，需要一个<strong class="js iu"><em class="ko">font/roboto _ bold . TTF</em></strong>文件。Roboto字体可以从<a class="ae kp" href="https://fonts.google.com/share?selection.family=Roboto:wght@900" rel="noopener ugc nofollow" target="_blank">谷歌</a>下载。</p></div></div>    
</body>
</html>