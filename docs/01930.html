<html>
<head>
<title>What are Lisp macros good for, anyway?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不管怎样，Lisp宏有什么用？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-are-lisp-macros-good-for-anyway-dac97d74904a?source=collection_archive---------1-----------------------#2020-02-07">https://levelup.gitconnected.com/what-are-lisp-macros-good-for-anyway-dac97d74904a?source=collection_archive---------1-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c941" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问一个口齿不清的人，为什么任何心智健全的人都会选择这么奇怪的编程语言，他们可能会开始谈论宏。就像，Lisp有宏，而你的语言没有。也许你说“C有宏，它们大多只是危险的”，他们说“Lisp宏不是这样的，它们是<strong class="js iu">不同的</strong>”。那么，在像Common Lisp或Clojure这样的语言中，你能用宏做什么，而在其他编程语言中你却不能(理智地)做什么呢？让我们看一个例子，看看我们如何用Java、Python和Clojure(一种Lisp)做一些事情。</p><h1 id="7eb2" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">旁白:C/C++中的宏</h1><p id="416d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">下面的例子可能是在C或C++中用一个宏完成的。我想大多数人都会同意这种文本替换宏是有问题的。此外，他们没有完整的语言可供他们使用。如果有人想对C/C++宏发表评论或展示如何用它们来做这个例子，那就去做吧。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f7b2" class="ko kp it bd kq kr ly kt ku kv lz kx ky kz ma lb lc ld mb lf lg lh mc lj lk ll bi translated">操作时间</h1><p id="7a8f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">假设我们编写了一个名为<code class="fe md me mf mg b">foo</code>的函数，它接受一个参数并返回一个数字。我们想知道这个函数在一些典型参数上大概需要多长时间。</p><h2 id="ea5e" class="mh kp it bd kq mi mj dn ku mk ml dp ky kb mm mn lc kf mo mp lg kj mq mr lk ms bi translated"><strong class="ak"> Python </strong></h2><p id="bcff" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">python中的一个选项是内置的<a class="ae mt" href="https://docs.python.org/2/library/timeit.html" rel="noopener ugc nofollow" target="_blank"> timeit </a>库。用法可能如下所示:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">使用timeit</figcaption></figure><p id="4f95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意传递一个字符串，该字符串包含要计时执行的代码。还要注意，之后不能使用对<code class="fe md me mf mg b">avg</code>的调用的返回值。<code class="fe md me mf mg b">setup</code>的说法有点麻烦，也许这是一个解决办法。</p><p id="b501" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Pythonista更常用的方法似乎是使用<code class="fe md me mf mg b">time</code>:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">手动使用时间</figcaption></figure><p id="bd7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可能有点容易出错，但一般来说没问题。由于在一行之前和之后都需要时间，如果被计时的行更复杂，那么就不容易对该行的一部分计时(例如，它的一些子表达式)。</p><p id="2a57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也可以编写自己的计时函数，它采用不带参数的函数:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">自定义计时功能</figcaption></figure><p id="e97e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么用法将如下所示:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">使用时间呼叫</figcaption></figure><p id="e1ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，这允许捕获和使用对<code class="fe md me mf mg b">foo</code>的调用结果。这种方法更适合在一段较大的代码中添加计时，然后在不久之后删除它。</p><h2 id="99d3" class="mh kp it bd kq mi mj dn ku mk ml dp ky kb mm mn lc kf mo mp lg kj mq mr lk ms bi translated"><strong class="ak"> Java </strong></h2><p id="4c57" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">据我所知，Java中没有内置任何有助于此的东西。我们可以编写一些相当通用的计时函数:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">Java的自定义计时函数</figcaption></figure><p id="9c23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">带一个<code class="fe md me mf mg b">Supplier</code>的签名是为了返回值的东西，带一个<code class="fe md me mf mg b">Runnable</code>的签名是为了不返回值的东西。用法如下:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">在Java中使用自定义计时函数</figcaption></figure><p id="5355" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这非常类似于Python的情况，尽管由于类型系统而更加冗长。但是请注意，在Python和Java中，对一段代码计时可能需要将其包装在另一个表达式中，这样它就是某种函数。</p><h2 id="c08f" class="mh kp it bd kq mi mj dn ku mk ml dp ky kb mm mn lc kf mo mp lg kj mq mr lk ms bi translated">轮到Clojure了</h2><p id="dfbd" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">Clojure有一个名为<code class="fe md me mf mg b"><a class="ae mt" href="https://clojuredocs.org/clojure.core/time" rel="noopener ugc nofollow" target="_blank">time</a></code>的内置操作，我们可以这样使用它:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">使用Clojure时间</figcaption></figure><p id="3514" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe md me mf mg b">time</code>也返回它的参数，所以如果对<code class="fe md me mf mg b">foo</code>的调用在其他代码的上下文中(这是典型的)，它可以很容易地随意插入和删除:</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="09b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在你说“但我必须在删除或添加对时间的调用时平衡父母”之前，像Clojure这样的Lisp优秀编辑器会让这变得轻松。移除<code class="fe md me mf mg b">(time</code>会自动移除该表达式的相应右括号。</p><p id="7aa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不需要它的参数来实现一些接口或契约，<code class="fe md me mf mg b">time</code>是如何工作的？在Python中，参数可以是一个字符串，就像使用<code class="fe md me mf mg b">timeit</code>时一样，但是<code class="fe md me mf mg b">timeit</code>不会返回评估代码的结果；此外，插入一个<code class="fe md me mf mg b">timeit</code>调用并不容易，因为它需要将代码转换成字符串。在Python和Java中，都可以通过接受函数来计时，但这需要调用者将需要计时的代码包装在lambda表达式中。</p><p id="2993" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答案当然是Clojure <code class="fe md me mf mg b">time</code>是Lisp宏的一个例子，而不是一个函数。让我们看看<code class="fe md me mf mg b">time</code>的<a class="ae mt" href="https://github.com/clojure/clojure/blob/clojure-1.9.0/src/clj/clojure/core.clj#L3850" rel="noopener ugc nofollow" target="_blank">实现</a>(为简洁起见，文档省略):</p><figure class="mu mv mw mx gt my"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">clojure.core中时间的实现</figcaption></figure><p id="4614" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe md me mf mg b">time</code>是一个带有一个名为<code class="fe md me mf mg b">expr</code>的参数的宏。神奇的事情发生在表达式<code class="fe md me mf mg b">ret# ~expr</code>中，它执行提供的表达式如<code class="fe md me mf mg b">(foo 5)</code>并将其赋给变量<code class="fe md me mf mg b">ret#</code>。宏<em class="nf">中的<code class="fe md me mf mg b">~</code>运算符对表达式</em>求值。<code class="fe md me mf mg b">#</code>与<code class="fe md me mf mg b">ret#</code>一样，是一种确保该宏范围内唯一变量名的方法，以避免错误使用封闭范围内的变量(即程序中其他地方定义的变量)。</p><p id="d82f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，Clojure版本的<code class="fe md me mf mg b">time</code>获取一个任意的代码片段——在类似Lisp的Clojure中表示为一个由<code class="fe md me mf mg b">()</code>包围的列表——对其进行评估，打印花费的时间，并返回结果。</p><p id="ce5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过使用<a class="ae mt" href="https://clojuredocs.org/clojure.core/macroexpand" rel="noopener ugc nofollow" target="_blank">宏展开</a>来看看这个宏是如何工作的:</p><figure class="mu mv mw mx gt my gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/df4c509dca44a9109b05e6fd7755a82c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WwekXIkoPivgMjIOfXi8Nw.jpeg"/></div></div></figure><p id="1224" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe md me mf mg b">macroexpand</code>举例说明了什么是Lisp宏。它们是从源代码到源代码的函数；也就是一个从列表到列表的函数。在Clojure中，您使用<a class="ae mt" href="https://clojuredocs.org/clojure.core/defmacro" rel="noopener ugc nofollow" target="_blank"> defmacro </a>注册这样的函数，然后在编译期间调用您的宏来‘扩展’表达式。在上面的例子中，列表<code class="fe md me mf mg b">(time (foo 5))</code>被扩展成一个对<code class="fe md me mf mg b">(foo 5)</code>的执行进行计时的列表，然后返回它的结果。Lisp宏的特殊能力在于它们可以控制求值(通过<code class="fe md me mf mg b">~expr</code>对输入表达式求值可以看出),并利用语言的全部能力进行任意的源到源转换。</p><h1 id="794d" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">更多宏观例子</h1><p id="c5a8" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">讨论<code class="fe md me mf mg b">time</code>宏的部分原因是因为在大多数语言中实现类似的东西是可能的(尽管不那么方便)。这可能会让你怀疑宏是否值得。下面是Clojure中宏的更多例子；考虑如何用你的语言实现这一功能，或者这样做是否可行。</p><ul class=""><li id="f978" class="nn no it js b jt ju jx jy kb np kf nq kj nr kn ns nt nu nv bi translated">方便的控制流构造，如<a class="ae mt" href="https://clojuredocs.org/clojure.core/when" rel="noopener ugc nofollow" target="_blank"> when </a>、<a class="ae mt" href="https://clojuredocs.org/clojure.core/when-not" rel="noopener ugc nofollow" target="_blank"> when-not </a>、<a class="ae mt" href="https://clojuredocs.org/clojure.core/if-not" rel="noopener ugc nofollow" target="_blank"> if-not </a>。</li><li id="4a71" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae mt" href="https://clojuredocs.org/clojure.core/cond" rel="noopener ugc nofollow" target="_blank"> cond </a>，类似于Java 12 中的<a class="ae mt" href="https://docs.oracle.com/en/java/javase/13/language/switch-expressions.html" rel="noopener ugc nofollow" target="_blank"> switch表达式，但更通用。请注意，cond是一个宏，因为它不会计算不会被执行的分支的表达式，这就是为什么大多数没有宏的语言需要内置的支持。</a></li><li id="7d34" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">列出对的理解，如<a class="ae mt" href="https://clojuredocs.org/clojure.core/for" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="7f13" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae mt" href="https://clojure.org/guides/threading_macros" rel="noopener ugc nofollow" target="_blank">线程宏</a>类似<a class="ae mt" href="https://clojuredocs.org/clojure.core/-%3E" rel="noopener ugc nofollow" target="_blank">-&gt;-</a>可以用来使嵌套表达式更容易阅读，在外观上类似于Javascript中的<a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Pipeline_operator" rel="noopener ugc nofollow" target="_blank">管道运算符</a>。</li><li id="b086" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">像<a class="ae mt" href="https://clojuredocs.org/clojure.core/doto" rel="noopener ugc nofollow" target="_blank"> doto </a>和<code class="fe md me mf mg b">..</code>这样的宏使得在Clojure中与“宿主”语言(Java/Javascript)的互操作更容易。</li><li id="2548" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">测试库经常使用宏来使测试变得易读。例如，<a class="ae mt" href="https://github.com/marick/Midje" rel="noopener ugc nofollow" target="_blank"> Midje </a>使测试看起来像Clojure书中的例子。</li><li id="070f" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated"><a class="ae mt" href="https://clojuredocs.org/clojure.core/comment" rel="noopener ugc nofollow" target="_blank">批注</a></li><li id="2c63" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">宏可以支持更熟悉的数学中缀符号，例如<code class="fe md me mf mg b">(1 + (2 * 3))</code>通过将其重写为Lisps使用的前缀符号<code class="fe md me mf mg b">(+ 1 (* 2 3))</code>。一个例子是<a class="ae mt" href="https://github.com/rm-hull/infix" rel="noopener ugc nofollow" target="_blank">中缀</a>库。</li></ul><p id="576c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Lisp社区中的一个重要想法是，您可以自己编写这些东西(或者从库中获取)，而不是向语言委员会或<a class="ae mt" href="https://en.wikipedia.org/wiki/Benevolent_dictator_for_life" rel="noopener ugc nofollow" target="_blank">仁慈的终身独裁者</a>请愿以支持它们，从而保持核心语言的短小和连贯性。这种可扩展性的缺点是<a class="ae mt" href="http://winestockwebdesign.com/Essays/Lisp_Curse.html" rel="noopener ugc nofollow" target="_blank">lisp的诅咒</a>。</p><h1 id="8dca" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结论</h1><p id="e917" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">Lisp宏提供了在其他语言中不容易复制的强大功能。它们强大的关键在于Lisp是<a class="ae mt" href="https://en.wikipedia.org/wiki/Homoiconicity" rel="noopener ugc nofollow" target="_blank">同形的</a>，这意味着Lisp中的源代码可以用语言本身可以处理的数据结构来表示(即列表)，这使得这些定制的源代码转换变得明智和有用。</p><p id="9fa1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能会问，在一种语言中增加力量是否总是一件好事。这难道不是另一种把事情搞得一团糟的方式吗？强大的功能可能是一把双刃剑，但我真的很喜欢格伦·范德堡的说法:</p><blockquote class="ob oc od"><p id="1c59" class="jq jr nf js b jt ju jv jw jx jy jz ka oe kc kd ke of kg kh ki og kk kl km kn im bi translated">弱小的开发者会竭尽全力去做错误的事情。你不能通过锁住锋利的工具来限制它们造成的伤害。他们只会更用力地挥动钝器。</p></blockquote><p id="59b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我当然不是说不写Lisp宏的开发者‘弱’。但是我们不应该因为害怕别人会用它来做什么而限制我们的能力。</p><h1 id="88b5" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">附录</h1><p id="1a8f" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">非常感谢Reddit用户<em class="nf"> lispm </em>为<a class="ae mt" href="https://www.reddit.com/r/lisp/comments/f05xvw/what_are_lisp_macros_good_for_anyway/fh10skf?utm_source=share&amp;utm_medium=web2x" rel="noopener ugc nofollow" target="_blank">展示了<em class="nf">时间</em>可能是一个宏</a>的另一个原因:如果<em class="nf">时间</em>是一个宏，它可以在计时输出中包含原始源代码。这太棒了，我希望Clojure版本的<em class="nf"> time </em>能做到这一点。</p></div></div>    
</body>
</html>