<html>
<head>
<title>TypeScript Spymasters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿间谍大师</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-spymasters-7902ad895b6d?source=collection_archive---------14-----------------------#2022-01-24">https://levelup.gitconnected.com/typescript-spymasters-7902ad895b6d?source=collection_archive---------14-----------------------#2022-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a9f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">冷战期间，各种各样的小说家普及了间谍头子的概念。间谍头子是管理间谍网的人，在冲突中，他无疑是任何重要力量的重要人物。如果我告诉你我们可以把间谍大师引入打字稿呢？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a11f8ce33d1b6b67ef6f54c1e4e48cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VxUSDNdqLpAIfxgX"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由<a class="ae le" href="https://unsplash.com/@_staticvoid?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Lucas Santos </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="a700" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">间谍</h1><p id="5a73" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">首先，我们需要定义基本面。在TypeScript上下文中，间谍是代理对另一个对象的所有访问并记录交互的对象。Sinon.js库提供了一个示例性的spy实现。我在下面的一个片段中使用了它。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用Sinon.js库的例子。</figcaption></figure><p id="faca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一个练习，考虑在TypeScript中自己实现spies，而不用查看Sinon.js实现。我在本文的<strong class="js iu">解决方案</strong>章节中提供了这个问题的答案。</p><p id="c60e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们为什么需要间谍？</p><p id="9176" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在一些场景中，比如测试，我们想知道一个特定的函数是否:</p><ul class=""><li id="1442" class="ml mm it js b jt ju jx jy kb mn kf mo kj mp kn mq mr ms mt bi translated">叫做，</li><li id="1c9f" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">多少次了，还有，</li><li id="67c2" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">用哪些参数(包括上下文变量<code class="fe mz na nb nc b">this</code>)。</li></ul><p id="dfa4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，您可以跟踪函数返回值。您还可以检查函数是否抛出了异常。</p><p id="8e88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">间谍怎么可能知道函数调用者呢？请自行解决，作为练习。同样，我在本文的<strong class="js iu">解决方案</strong>章节中回答了这个问题。</p><p id="6f48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了测试，还有其他用例。我们可以使用它进行日志记录、审计、调试，或者基于传入的函数参数执行额外的操作。如果你是一个经验丰富的开发人员，短语<em class="mk">面向方面编程</em>可能会让你想起什么。这是有原因的。</p><h1 id="ff06" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">面向方面编程</h1><p id="47d7" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">面向方面编程需要一篇独立的文章——也许我很快就会写一篇。这种范式最重要的原则是分离横切关注点以增加代码模块化。</p><p id="dc4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们需要首先认识到这些<em class="mk">交叉关注点</em>。</p><p id="a86c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，HTTP后端需要一些与HTTP通信相关的代码，可能还需要一些日志记录。我们通常会编写一个类来完成这两项工作。这个类是一个跨领域的问题，因为它将两个功能(HTTP通信和日志记录)组合为一个方面。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/8d79c85871e03a8bb7c95ebb89d0ebfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*QZQBF7JoEnBbLgSu2amMJg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用非面向方面方法的项目的UML图。</figcaption></figure><p id="c666" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以分别实现这两个功能，一个不知道另一个的存在。我们将把日志转移到一个不同的类中，公开两个方法:</p><ul class=""><li id="6ca2" class="ml mm it js b jt ju jx jy kb mn kf mo kj mp kn mq mr ms mt bi translated">一个用于打印功能参数，</li><li id="0499" class="ml mm it js b jt mu jx mv kb mw kf mx kj my kn mq mr ms mt bi translated">一个用于打印函数返回值或返回的异常。</li></ul><p id="4823" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个问题仍然存在——我们如何将这两个类结合在一起？</p><p id="1149" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理想情况下，我们将使用一个框架，在HTTP通信正在进行时启用日志记录。这意味着框架会窥探(没有双关语的意思！)并在需要时调用适当的日志记录方法。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/4d693d4ce288eb502690b811e6cebcd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*-YBxha97xgnY2L4m3xUiEg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">使用面向方面方法的项目的UML图。</figcaption></figure><p id="adbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">显然，spies是AOP库的原始实现。一个库，而不是一个框架，因为我们需要建立自己的间谍。</p><p id="7623" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我提到AOP是因为我们可以使用它的术语和发现。间谍提取关于函数使用的元信息。您可以通过一些建议来利用它，这些建议是添加到您的业务逻辑中的独立代码。如果你单独维护你的建议，你可以在你的代码库中为不同的对象使用它们。</p><h1 id="ceb5" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">间谍组织的首脑</h1><p id="7c17" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">至此，我们已经定义了什么是间谍，以及我们为什么要使用他们。此外，我解释了它们与面向方面编程的明显联系。现在，我们为什么需要间谍头子？</p><p id="74a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们有间谍，我们可以直接把他们交给他们的附属国。因为它们是代理，我们不需要改变依赖代码的类型。这就是代码模块化近来越来越受欢迎的原因。</p><p id="a06f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我建议我们把间谍组织在一个间谍头子之下——一个保存所有间谍参考资料的对象。通过这种方式，我们可以将所有这些信息集中在一个地方，进行集中管理，就像在计划经济中一样。spymaster对象还允许我们切换到不同的间谍——这违反了不变性原则。</p><p id="a464" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您可能希望将spymasters传递给实现业务逻辑的代码。如果你这么做了会发生什么？您必须更改所有依赖项中的签名，暴露我们的spymaster用法。这不是很隐秘，是吗？</p><p id="71d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个好的间谍头子会让他们的间谍伪装起来，并保持行动的隐蔽性。我们必须以同样的方式行动。我们不是直接注入一个间谍，而是将一个代理传递给这个间谍，保持签名处于检查状态。每次我们换一个不同的间谍，间谍代理保持不变。</p><p id="8656" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着我们可以建立以下规则:</p><blockquote class="nf ng nh"><p id="cb5a" class="jq jr mk js b jt ju jv jw jx jy jz ka ni kc kd ke nj kg kh ki nk kk kl km kn im bi translated">间谍代理对某些对象的访问，间谍头子代理对间谍的访问。</p></blockquote><p id="02a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你仔细看看，间谍代理是间谍的间谍，这使得间谍大师成为一个终极代理人，因此得名。</p><h1 id="a5ef" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">我的图书馆</h1><p id="e8d0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">由于我已经介绍了间谍头子的概念，我需要首先向你们展示我为什么需要它。</p><p id="c018" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您编写了许多测试，您可能会花费大量的时间来建立集成测试的依赖关系。您可能最终得到一个为每个测试用例创建相同依赖集的测试套件，只有一个依赖是不同的。</p><p id="2db9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，我们可以轻松地节省时间和代码。我们可以在间谍头子手下使用间谍，并把这些间谍作为附属品传递。为了替换特定测试套件的特定间谍，我们将要求spymaster这样做，而无需重新创建所有依赖项。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">一个间谍大师取代引擎盖下的间谍参考的例子。</figcaption></figure><p id="9835" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以说spymaster是一个间接的依赖注入容器。我同意这一发现，但这不是计划中的功能，而且它超出了spymaster需要做的范围。</p><p id="a633" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的名为<code class="fe mz na nb nc b">@grzpab/ts-spymasters</code>的库可以在<a class="ae le" href="https://github.com/grzpab/ts-spymaster" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae le" href="https://www.npmjs.com/package/@grzpab/ts-spymaster" rel="noopener ugc nofollow" target="_blank"> NPM </a>上下载。使用前请阅读<code class="fe mz na nb nc b">README</code>文件。</p><h1 id="1e7f" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">解决方法</h1><p id="c39c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">我们如何自己实现间谍？</p><p id="65ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过使用代理API。我将在回答第二个问题时提供用法示例:</p><p id="cee1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们怎样才能告诉间谍打电话的人呢？</p><p id="759e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一般来说，我们需要检查函数调用栈来了解调用者。在函数中获取调用堆栈最简单的方法是抛出一个错误。它需要被抛出它的同一个可调用函数立即捕获。</p><p id="f603" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">提取错误后，我们可以检查它的堆栈属性。它是包含堆栈跟踪的可选字符串。我们需要从顶部取出存储在第三行中的信息。为什么是3号线？由于Node.js构建跟踪的方式。</p><p id="411f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">间谍通常是构建在代理API或合成代理实现之上的对象。当来电者访问间谍时，我们需要提取来电者信息。您可以在下面的代码片段中看到一个参考实现:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mi mj l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">检查函数调用方的示例代码片段。</figcaption></figure><h1 id="78aa" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">摘要</h1><p id="5d49" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">你可能想知道为什么我把间谍头子和冷战联系起来，为什么这篇文章如此频繁地提到那个时代。除了作为一名软件开发人员和技术内容作者，我对20世纪的历史很感兴趣。我不打算写历史文章，但也许我会在我即将发表的编程文章中用到我的知识。</p></div></div>    
</body>
</html>