<html>
<head>
<title>Security Basics: SQL Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安全基础:SQL注入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/security-basics-sql-injection-7a1f75ab3a5d?source=collection_archive---------11-----------------------#2020-09-17">https://levelup.gitconnected.com/security-basics-sql-injection-7a1f75ab3a5d?source=collection_archive---------11-----------------------#2020-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="b868" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为历史上最突出的漏洞之一，SQL注入在过去20年中可能给数千家公司造成了数百万(如果不是数十亿)美元的损失。Phrack contributer和安全研究员Jeff Forristal在1998年首次记录了该漏洞。互联网从此一蹶不振。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/c5741cd83f1700bae1b866e7cf8fb604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N6Ahk4NiX6QkyOx0yzuMkw.jpeg"/></div></div></figure><h1 id="9762" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">那是什么呢？</h1><p id="f78e" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">为了理解什么是SQL注入攻击，我们需要简单了解一下用户界面通常如何与后端或数据库通信:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi md"><img src="../Images/b8453cde892f5bea93331559111b1245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*K9TQ6VWUXpGDDgJtb9vjaA.png"/></div></figure><p id="01d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当用户提交一个表单，或者采取一些其他需要后端反馈的动作时，数据要么在API的帮助下进行通信，要么使用PHP之类的语言在服务器级进行通信，但在浏览器中触发。</p><p id="3262" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在API的情况下，浏览器向端点发送请求，该请求包含完成请求所需的所有数据。然后API发送响应，网页中的代码处理接收到的数据。使用PHP，与服务器对话的代码由web服务器本身加载，并通过从浏览器调用文件名来触发。例如，要提交表单，可以在表单的HTML中将名为“submit.php”的文件声明为“action”。当用户单击按钮提交时，就会调用该文件，并通过POST数据或GET请求中的URL参数发送参数。</p><p id="997f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在服务器上，假设数据被用来查询数据库。这样做的不安全方法是简单地将提供的数据插入数据库查询(最常见的是SQL查询)，这种方法会使应用程序面临注入攻击。</p><h1 id="6e58" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">简单的例子</h1><p id="88b6" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">下面是一些可能处理请求的服务器端代码的示例:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi me"><img src="../Images/df43c87a69630c8e9a2075024bf423d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*WJ1hoHxvAdpO_JxsXcYGmQ.png"/></div></figure><p id="6b49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以看到来自请求的$size变量实际上被放入查询中，而没有转换包含的任何数据。这意味着攻击者可以将他们想要的任何数据放入查询中。注意$size变量在查询中用单引号括起来。该查询需要一个用引号括起来的字符串，并且将接受任何提供的内容，只要它是正确的语法。您可能还注意到，SQL查询没有用分号显式结束，这也是一种不好的做法。</p><h1 id="ce23" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">让我们好好利用它！</h1><p id="b4b2" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">有了这段代码，就没有什么可以阻止攻击者发送这样的请求:</p><blockquote class="mf mg mh"><p id="05c5" class="jq jr mi js b jt ju jv jw jx jy jz ka mj kc kd ke mk kg kh ki ml kk kl km kn im bi translated">size= '或1 = 1；—</p></blockquote><p id="5d2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将把查询转换成这样:</p><blockquote class="mf mg mh"><p id="4743" class="jq jr mi js b jt ju jv jw jx jy jz ka mj kc kd ke mk kg kh ki ml kk kl km kn im bi translated">SELECT id，name，inserted，size FROM products，其中size = ' '或1=1。—</p></blockquote><p id="52ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将预期的查询转换为非预期的查询；查询现在返回每条记录，因为OR语句说“如果大小是这样，or 1=1”。1确实等于1，所以所有记录都匹配那个查询。双连字符注释掉后面的所有内容，实质上阻止它成为查询的一部分。</p><p id="03e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一些更恶意的东西可能采取这种请求的形式:</p><blockquote class="mf mg mh"><p id="e4f2" class="jq jr mi js b jt ju jv jw jx jy jz ka mj kc kd ke mk kg kh ki ml kk kl km kn im bi translated">size = '；滴表产品；</p></blockquote><p id="3c0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它将在执行第一个查询后执行一个查询来删除products表。</p><p id="0294" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可能性是无限的。攻击者可以查询information_schema.tables之类的表，查看数据库中有哪些表，然后开始枚举这些表，而无需事先了解数据库是如何设置的。这就是用户数据被窃取和数据被操纵的方式。</p><h1 id="a0de" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">预防</h1><p id="72be" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">那么，如何才能阻止这种事情发生呢？净化用户输入，不要将数据直接插入SQL查询。净化只是意味着删除或“转义”可能干扰查询的字符(如引号、连字符和分号)。通过在代码中使用ORM库或对象关系映射，可以避免将数据直接插入到查询中，ORM库或对象关系映射提供了原始查询的抽象层，并且通常带有针对注入攻击和其他漏洞的内置保护。</p><h1 id="4da0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="401d" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">基本就是这样。在野外，由于漏洞的年龄和暴露程度，这些注入点通常很难到达，并且需要大量的反复试验和特殊工具来发现。但是，他们仍然在那里，准备被那些有时间和知识的人利用。</p></div></div>    
</body>
</html>