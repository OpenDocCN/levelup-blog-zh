<html>
<head>
<title>How Python Represents Integers using Bignum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python如何使用Bignum表示整数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-python-represents-integers-using-bignum-f8f0574d0d6b?source=collection_archive---------3-----------------------#2020-06-03">https://levelup.gitconnected.com/how-python-represents-integers-using-bignum-f8f0574d0d6b?source=collection_archive---------3-----------------------#2020-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="17f7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解Python如何使用Bignum表示任意数量级的整数。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a9a1687e4b2f7398bb42fd2189666393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gmgN6g8wEJVUaGLsrD_7AQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由克里斯·贾维斯在<a class="ae kv" href="https://unsplash.com/s/photos/addition?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c420" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用C/C++等低级语言编码的程序员需要考虑整数表示所用的内存量。他们必须考虑变量的最小值和最大值，以避免溢出问题。这些程序员必须考虑一个<code class="fe ls lt lu lv b">int</code>是否足够，或者一个<code class="fe ls lt lu lv b">long</code>是否必要。</p><p id="b318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与C/C++相比，Python在处理整数时更有优势。在Python中，不存在整数溢出问题；因此，Python程序员不需要担心每个整数使用什么变量类型。Python允许程序员操纵巨大的数字，而不必担心精度损失。Python中整数的唯一表示限制是当机器用完空闲内存时，但这是硬件限制。</p><p id="50c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，这对于计算像阶乘这样的大值很有用。不使用外部库，Python可以独立于结果的大小计算阶乘。下面是一个计算阶乘的函数示例:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="81cc" class="ma mb iq lv b gy mc md l me mf">def factorial(n):<br/>   if n == 0 or n == 1:<br/>     return 1<br/>   return n * factorial(n-1)</span></pre><p id="2103" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用输入<code class="fe ls lt lu lv b">231</code>执行<code class="fe ls lt lu lv b">factorial</code>函数演示了Python可以表示的整数值的大小。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8c1c" class="ma mb iq lv b gy mc md l me mf">&gt;&gt;&gt; factorial(231)<br/>1792233667382633521618843263044232513197622942259968207385215805123682159320161029848328112148883186161436034535802659466205111867109614573242316954383604389464524535467759401326264883566523043560811873179996072188155290081861628010250468430411854935707396605833540921031884571521279145124581094374547412403086564118143957940727734634769439112260383017302489106932716079961487372942529947238400000000000000000000000000000000000000000000000000000000</span></pre><blockquote class="mg mh mi"><p id="cde8" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">注意，有更高效的算法来计算阶乘；这个例子用来说明输出的大小。</p></blockquote><p id="8f98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">整数表示法</strong></p><p id="efdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在进一步讨论之前，请注意本文只考虑了CPython实现。这个实现是Python的默认版本，也是最常见的分布式版本。不同的实现可以用不同的方式表示整数，但是这里的讨论只涉及CPython中的整数表示。使用CPython的一个好处是，整个代码库在Github上的CPython存储库中是公开的。</p><p id="ca12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从Python 3开始，所有整数值都用下面的结构表示:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="3468" class="ma mb iq lv b gy mc md l me mf">struct _longobject {<br/>   PyObject_VAR_HEAD<br/>   digit ob_digit[1];<br/> };</span></pre><p id="258b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以这样扩展宏和表示结构:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="07b7" class="ma mb iq lv b gy mc md l me mf">struct {<br/>   sssize_t ob_refcnt;<br/>   struct _typeobject *ob_type;<br/>   ssize_t ob_size; <br/>   uint32_t ob_digit[1];<br/> };</span></pre><p id="bb14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面结构的前两个元素对于这个讨论并不重要。元素<code class="fe ls lt lu lv b">ob_refcnt</code>用于Python的垃圾收集器中，而<code class="fe ls lt lu lv b">ob_type</code>用于类型标识，在本例中，对象是一个整数。</p><p id="c647" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整数值由另外两个变量表示:<code class="fe ls lt lu lv b">ob_digit</code>和<code class="fe ls lt lu lv b">ob_size</code>。Python使用<code class="fe ls lt lu lv b">ob_digit</code>数组将数字的每个数字分别存储在不同的索引位置。此外，ob_size变量用于存储两个值。它存储了<code class="fe ls lt lu lv b">ob_digit</code>数组的长度和整数的符号(正或负)。</p><p id="a7d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在大多数系统中，<code class="fe ls lt lu lv b">ob_digit</code>是一个<code class="fe ls lt lu lv b">uint32_t</code>数组，但是在一些旧的计算机中，<code class="fe ls lt lu lv b">ob_digit</code>可以是一个<code class="fe ls lt lu lv b">uint16_t</code>数组。本文将只考虑第一种情况的<code class="fe ls lt lu lv b">uint32_t</code>数组。</p><p id="0dc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种用字符串或数组表示整数值的方法称为Bignum算法。通常，Bignum实现用二进制表示值；然而，对于<code class="fe ls lt lu lv b">uint32_t</code>数组来说，这并不节省空间。</p><p id="bbc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">基地2 ⁰ </strong></p><p id="36d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到使用<code class="fe ls lt lu lv b">uint32_t</code>数组表示整数的系统，Python不能使用所有32位来存储数字。对这种限制的简要解释是，出于实用性和效率的原因，Python中的许多内置函数需要特定数量的位来表示整数。对于一个更好奇的读者，在官方的CPython库中有关于这个限制的评论。</p><p id="975c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为Python只能使用每个元素32位中的30位，所以所有整数都被转换为基数为2的⁰.因此，数组中所有数字的值都在0和1073741823 (2 ⁰-1).)之间注意，变量<code class="fe ls lt lu lv b">ob_size</code>存储数组的长度，数字以⁰为基数2，而不是以10为基数。</p><p id="c815" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，数组表示是按小端顺序排列的。换句话说，顺序是从最不重要的值开始(较低的索引值)。例如，假设数字存储在基数为10的⁰中，而不是基数为2的，那么使用数组表示的数字<code class="fe ls lt lu lv b">234</code>将是:<code class="fe ls lt lu lv b">&lt;4,3,2&gt;</code>。</p><p id="3820" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，Python中的数字<code class="fe ls lt lu lv b">234254646549834273498</code>将首先被转换成基数为2的⁰.因为我们没有足够的字符来表示基数为2的⁰中的所有数字，所以为了便于说明，基数为2的⁰中的数字将以基数为10来表示。因此，以2为基数的⁰中的数字<code class="fe ls lt lu lv b">234254646549834273498</code>是<code class="fe ls lt lu lv b">462328538,197050268,203</code>，其中<code class="fe ls lt lu lv b">462328538</code>代表第一个数字，其他两个值以此类推。那是因为462328538×(2⁰)⁰+197050268×(2⁰)+203×(2⁰)= 234254646549834273498。</p><p id="70aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，Python中基数为2的⁰的数字<code class="fe ls lt lu lv b">234254646549834273498</code>有3个数字:<code class="fe ls lt lu lv b">462328538,197050268,203</code>，它在Python中的表示方式如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/3efcefc71f33a763a1da7ca0023dc0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*LT_z2ItOO4NI7cLhvhM1lg.png"/></div></figure><blockquote class="mg mh mi"><p id="a6a9" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">如果这个数字是负数，Python表示将有相同的数组，但是<code class="fe ls lt lu lv b"><em class="iq">ob_size</em></code>将是<code class="fe ls lt lu lv b"><em class="iq">-3</em></code>。</p></blockquote><p id="e3ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">普通整数优化</strong></p><p id="5fbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Bignum算法转换和表示整数的过程对于运行时操作来说非常耗时。由于这个原因，因为<code class="fe ls lt lu lv b">int</code>类型在Python中是不可变的，所以Python在程序执行之前为<code class="fe ls lt lu lv b">-5</code>和<code class="fe ls lt lu lv b">256</code>之间的所有值创建表示。在执行过程中，每当请求这些对象时，Python都会重用它们。</p><p id="6823" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Bignum算法的一个明显缺点是在内存使用方面。Python中的任何整数值都至少使用28字节的内存，比C语言创建一个类型为<code class="fe ls lt lu lv b">int</code>的变量所需的内存多7到14倍。</p><p id="56f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Bignum加法</strong></p><p id="f9ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Bignum算法的一个好处是执行算术运算的简单性。本文将只讨论加法，但是其他操作遵循相同的概念。</p><p id="1a73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Bignum加法背后的想法是执行加法，就像人们用纸和铅笔在10进制中添加数字一样。该过程首先从最低有效位开始，并继续向最高有效位进行。每个数字的每个数字分别相加，结果通过一个<em class="mj">进位值</em>向下一个更高的有效数字移动。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/3ad81da35268f7fa52aec70a2bb93aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*4tn4ct4-G91GxixAWquTzQ.png"/></div></figure><p id="54d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Bignum算法使用数组遵循这种方法。该过程是将来自每个数组的相同索引的每个值分别相加，并将超出小数位的值结转到下一个索引。该算法从索引<code class="fe ls lt lu lv b">0</code>开始迭代，直到最小数组的长度，始终使用进位方法将数字相加。</p><p id="6ea6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该算法首先创建一个新的空数组来存储结果。请注意，两个值之和的结果最多比总和中的最大数字多一位。例如，<code class="fe ls lt lu lv b">9</code>和<code class="fe ls lt lu lv b">93</code>之和就是<code class="fe ls lt lu lv b">102</code>。本例中最大的值是<code class="fe ls lt lu lv b">93</code>，它有2个数字。加法的结果有3位数，比<code class="fe ls lt lu lv b">93</code>多一位。在某些情况下，结果的位数等于最大数的位数。在这种情况下，算法会减小数组的大小，以适应没有前导<code class="fe ls lt lu lv b">0</code>的结果。最后一个数组单元格(最高索引)具有值<code class="fe ls lt lu lv b">0</code>的唯一情况是用于表示数字<code class="fe ls lt lu lv b">0</code>。</p><p id="e140" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了便于说明，这里有一个用Bignum算法表示的两个数字相加的例子。加在一起的值是<code class="fe ls lt lu lv b">234254646549834273498</code>和<code class="fe ls lt lu lv b">23425464654983</code>。</p><p id="1947" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数字<code class="fe ls lt lu lv b">234254646549834273498</code>可以这样表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/3efcefc71f33a763a1da7ca0023dc0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*LT_z2ItOO4NI7cLhvhM1lg.png"/></div></figure><p id="10f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数字<code class="fe ls lt lu lv b">23425464654983</code>可以这样表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/84a4c268eef4a7b78ecff3025b11769f.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*4i0-SdwM2qHxIWPeY0_HVw.png"/></div></figure><p id="af85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该算法首先创建一个大小为4的新数组(比表示加法中最大值的数组长一个单元格)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/800357f4d56db51b3777cd56650e21b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*sKgUQIaXKYQvwq6lpmohGg.png"/></div></figure><p id="2bef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，该算法逐个索引地开始进位过程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/64ad54c6008cf69c114abfc7772defff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*MLo4RfzABQPu2x9CFHMrbQ.png"/></div></figure><p id="c524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在遍历所有索引直到最小数组长度之后，该算法计算以下值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/af4d1028b7b74dc9aa5751201ff3c8de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*9gUpD4Mju0lIf-ay7M5Atw.png"/></div></figure><p id="d31f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，程序将数组大小减1，以删除最后一个空单元格。然后，通过添加创建的完整结构以这种方式表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/598ba1db78bb5441513571ec2b7f8831.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*DZjG2tQUoq1Az01kl9WzjQ.png"/></div></figure><p id="dc09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最初的算法是用C写的，但这里有一个Python函数模拟了这个过程。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><blockquote class="mg mh mi"><p id="795b" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">函数<code class="fe ls lt lu lv b"><em class="iq">add</em></code>接受两个Python列表。每个列表代表这个函数中要添加的一个整数。这些数字已经被转换为以2为基数的⁰，并且每个列表元素存储该值的一个数字。</p></blockquote><p id="d4ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，Python使用Bignum算法来表示整数。与Java和C/C++等其他语言相比，Python使得处理整数变得非常简单。虽然其他语言要求程序员确定存储数字的大小变量，但Python抽象了这一需求。但是，这种方法在内存使用方面也有缺点。像C这样的语言使用2或4个字节来表示一个类型为<code class="fe ls lt lu lv b">int</code>的变量，而Python至少需要28个字节。对于简单的脚本，这种额外的内存使用不会造成差异；然而，对于数据量大的程序，使用c之类的其他语言可能会很有趣。</p><p id="e7d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢您阅读这篇文章！很快我将发布更多关于Python和其他编程主题的内容。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="8c27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">参考文献:</strong></p><p id="3bfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">https://rushter.com/blog/python-integer-implementation/<a class="ae kv" href="https://rushter.com/blog/python-integer-implementation/" rel="noopener ugc nofollow" target="_blank"/></p><p id="9a08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.codementor.io/@arpitbhayani/how-python-implements-super-long-integers-12icwon5vk" rel="noopener ugc nofollow" target="_blank">https://www . code mentor . io/@ arpitbhayani/how-python-implements-super-long-integers-12 icw5 vk</a></p></div></div>    
</body>
</html>