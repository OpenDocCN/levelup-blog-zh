<html>
<head>
<title>Python Optimizations — Peephole</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python优化—窥视孔</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-optimizations-a822db1f6bf5?source=collection_archive---------1-----------------------#2019-02-05">https://levelup.gitconnected.com/python-optimizations-a822db1f6bf5?source=collection_archive---------1-----------------------#2019-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e47d3ffbc10e52ab069d5c7e61541fd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXi1sWm5p5_90KXYu6tJ5w.jpeg"/></div></div></figure><p id="0167" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Peephole是Python在编译时通过预先计算常量表达式或转换特定数据结构来优化程序的一种方式。</p><h2 id="5ac4" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">常量表达式</h2><p id="69d8" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">优化常量表达式非常简单。Python所做的基本上是预先计算常数。假设在你的程序中，由于某种原因，你有下面的乘法运算，</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="753b" class="kz la it mc b gy mg mh l mi mj">secondsInADay = 60*60*24</span></pre><p id="3a22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">python要做的是预先计算乘法，并替换掉它作为<code class="fe mk ml mm mc b">86400</code>。你可能想知道为什么不直接用代码写<code class="fe mk ml mm mc b">86400</code>，答案是清晰。在上面的表达式中，你可以看到，为了计算一天有多少秒，你必须用60秒乘以一小时的60分钟乘以一天的24小时。这样你的代码可能看起来更清晰。Python不会在每次乘法出现时都进行计算，它只会预先计算并替换为最终值。</p><p id="b7b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">短序列也是预先计算的。想象你有这样的代码，</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="f73b" class="kz la it mc b gy mg mh l mi mj">myTuple = (2, 4)*5      # -&gt; (2, 4, 2, 4, 2, 4, 2, 4, 2, 4)<br/>myString = "qwerty "*2  # -&gt; "qwerty qwerty "</span></pre><p id="0db2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你在上面的代码中看到的，我们有两个变量，第一个是一个乘以5的元组，第二个是一个乘以2的短字符串，这个短序列将被预先计算，Python将用注释中的值替换原始表达式。值得一提的是，Python要在存储和计算之间做平衡。如果它预先计算长序列，程序可能会更快，但最终会使用大量内存。</p><p id="b245" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了看到这种情况，您只需打开一个Python控制台并编写以下代码，</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1f08" class="kz la it mc b gy mg mh l mi mj"><strong class="mc iu">def </strong>my_func():<br/>    a = 60*60*24<br/>    myString = (<strong class="mc iu">"querty "</strong>) * 2<br/>    myTupple = (2, 4) *5<br/>    myString = (<strong class="mc iu">"This is a sequence with a lot of characters"</strong>) * 100</span></pre><p id="d3f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦声明了这个函数，就可以编写下面的代码来访问在这个函数的作用域上声明的所有常量，</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="7648" class="kz la it mc b gy mg mh l mi mj">my_func.__code__.co_consts</span></pre><p id="f7d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输出应该如下所示，</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ffe7" class="kz la it mc b gy mg mh l mi mj">&gt;&gt;&gt; my_func.__code__.co_consts</span><span id="c7e7" class="kz la it mc b gy mn mh l mi mj">(None, <br/>86400, <br/>'querty querty ', <br/>(2, 4, 2, 4, 2, 4, 2, 4, 2, 4), <br/>'This is a sequence with a lot of characters', <br/>100)</span></pre><p id="8944" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如你所看到的，在上面的输出中，Python已经预先计算了常量值和短序列，而不是让<code class="fe mk ml mm mc b">60*60*24</code>函数已经有了常量值<code class="fe mk ml mm mc b">86400</code>，同样的事情也发生在元组和短字符串上，但是正如你所看到的，长序列没有预先计算，而是我们得到了两个不同的常量，<code class="fe mk ml mm mc b">'This is a sequence with a lot of characters'</code>和<code class="fe mk ml mm mc b">100</code>。如上所述，Python必须在存储和计算之间取得平衡。</p><h2 id="1cb0" class="kz la it bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">成员测试:用不可变的数据结构替换可变的数据结构</h2><p id="6176" class="pw-post-body-paragraph kb kc it kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">Python在这里所做的基本上是将可变的数据结构转换成不可变的版本。<em class="mo">列表</em>被转换成<em class="mo">元组</em>和<em class="mo">集</em>到<em class="mo">冷冻集</em>。</p><p id="d861" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">举个例子，</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="13c9" class="kz la it mc b gy mg mh l mi mj"><strong class="mc iu">def </strong>my_func(element):<br/>    <strong class="mc iu">if </strong>element <strong class="mc iu">in </strong>[<strong class="mc iu">"a"</strong>, <strong class="mc iu">"b"</strong>, <strong class="mc iu">"c"</strong>]:<br/>        print(element)</span></pre><p id="9b92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码将被转换成这样，</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4f59" class="kz la it mc b gy mg mh l mi mj"><strong class="mc iu">def </strong>my_func(element):<br/>    <strong class="mc iu">if </strong>element <strong class="mc iu">in ("a"</strong>, <strong class="mc iu">"b"</strong>, <strong class="mc iu">"c")</strong>:<br/>        print(element)</span></pre><p id="c021" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样做只是因为访问数据结构的不可变版本比访问可变版本更快。在运行以下代码之前，您可以通过执行相同的操作来检查这一点:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="67f0" class="kz la it mc b gy mg mh l mi mj">my_func.__code__.co_consts</span></pre><p id="f078" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输出应该如下所示，</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="38ab" class="kz la it mc b gy mg mh l mi mj">&gt;&gt;&gt; my_func.__code__.co_consts</span><span id="2f6c" class="kz la it mc b gy mn mh l mi mj">(None, ('a', 'b', 'c'))</span></pre><p id="0c31" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，该函数有一个常量值，它是声明的<em class="mo">列表</em>的不可变版本(一个<em class="mo">元组</em>)。</p><p id="782e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后做和之前一样的事情，但是用<em class="mo">设定</em>，你会看到它将被转换成<em class="mo">冷冻设定</em></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2d84" class="kz la it mc b gy mg mh l mi mj"><strong class="mc iu">def </strong>my_func(element):<br/>    <strong class="mc iu">if </strong>element <strong class="mc iu">in {"a"</strong>, <strong class="mc iu">"b"</strong>, <strong class="mc iu">"c"}</strong>:<br/>        print(element)</span><span id="3f06" class="kz la it mc b gy mn mh l mi mj">&gt;&gt;&gt; my_func.__code__.co_consts</span><span id="5e67" class="kz la it mc b gy mn mh l mi mj">(None, frozenset({'a', 'b', 'c'}))</span></pre></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="5cd3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你对Python优化感兴趣，你可以看看我关于<a class="ae mw" href="https://medium.com/@gmotzespina/python-optimizations-216205001b83" rel="noopener"> Python优化(Intering) </a>的文章。</p></div></div>    
</body>
</html>