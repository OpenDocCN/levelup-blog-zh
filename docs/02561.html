<html>
<head>
<title>Getting Started with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js入门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-started-with-node-js-48397c5f3c52?source=collection_archive---------4-----------------------#2020-03-22">https://levelup.gitconnected.com/getting-started-with-node-js-48397c5f3c52?source=collection_archive---------4-----------------------#2020-03-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2b04" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">异步编程和Node.js世界简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f0e6fdefb124e5363e663bba30e79b6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgCxCxTHFjEryZujQW2c3g.jpeg"/></div></div></figure><h1 id="6b2d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">Node.js是什么？</h1><p id="9bc7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Node.js是一个跨平台的运行时环境，面向服务器端，开源，用JavaScript编写。或者简单地说，它是一个用JavaScript编写的用于Web服务器的平台。</p><p id="96ca" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">web服务器的一个常见任务是打开服务器上的文件并将内容返回给客户端。</p><p id="c635" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是PHP或ASP处理文件请求的方式:</p><ul class=""><li id="514f" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">将任务发送到计算机的文件系统。</li><li id="b3c8" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">等待文件系统打开并读取文件。</li><li id="24fb" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">将内容返回给客户端。</li><li id="7836" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">准备好处理下一个请求。</li></ul><p id="b248" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下面是Node.js处理文件请求的方式:</p><ul class=""><li id="83cb" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">将任务发送到计算机的文件系统。</li><li id="7ab0" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">准备好处理下一个请求。</li><li id="fb13" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">当文件系统打开并读取文件时，服务器将内容返回给客户端。</li></ul><blockquote class="nb nc nd"><p id="7ba2" class="lm ln ne lo b lp mi ju lr ls mj jx lu nf mk lx ly ng ml mb mc nh mm mf mg mh im bi translated">Node.js使用<strong class="lo iu">异步编程</strong>，我们将在适当的时候回到这个话题。</p></blockquote></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="b2cf" class="ku kv it bd kw kx np kz la lb nq ld le jz nr ka lg kc ns kd li kf nt kg lk ll bi translated">下载并安装Node.js</h1><p id="83b8" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">安装Node.js非常容易。只需进入<a class="ae nu" href="https://nodejs.org/en/download" rel="noopener ugc nofollow" target="_blank"> Node.js网站</a>，选择相应的OS，按照指南操作即可。</p><p id="bd48" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">要检查安装是否成功，请打开“终端”并检查版本，如下所示:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="9084" class="oa kv it nw b gy ob oc l od oe">node -v</span></pre><p id="77ee" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它应该会返回类似这样的结果</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="3ff3" class="oa kv it nw b gy ob oc l od oe">v13.7.0</span></pre><blockquote class="nb nc nd"><p id="d0b1" class="lm ln ne lo b lp mi ju lr ls mj jx lu nf mk lx ly ng ml mb mc nh mm mf mg mh im bi translated">注意:版本号可能不同</p></blockquote><p id="d24c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">还要检查npm版本:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="5e4e" class="oa kv it nw b gy ob oc l od oe">npm -v</span></pre><p id="a0aa" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它应该会返回类似这样的结果</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="be30" class="oa kv it nw b gy ob oc l od oe">6.13.6</span></pre><blockquote class="nb nc nd"><p id="1217" class="lm ln ne lo b lp mi ju lr ls mj jx lu nf mk lx ly ng ml mb mc nh mm mf mg mh im bi translated">注意:版本号可能不同</p></blockquote><p id="fbb6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当我们安装Node.js时，npm(节点包管理器)随之而来。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="ab59" class="ku kv it bd kw kx np kz la lb nq ld le jz nr ka lg kc ns kd li kf nt kg lk ll bi translated">探索Node.js</h1><p id="5d7c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Node.js安装完成后，下一步是在终端中键入命令<code class="fe of og oh nw b">node</code>。您可以在终端上运行JavaScript命令，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="76ce" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">或者通过创建一个Javascript文件如<code class="fe of og oh nw b">test.js</code>进行测试，然后添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="22dc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">允许Node运行JS文件的命令是如下的<code class="fe of og oh nw b">node FILENAME</code>:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="59b9" class="oa kv it nw b gy ob oc l od oe">node test.js</span></pre><p id="4efb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">结果会是这样的</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="3c6f" class="oa kv it nw b gy ob oc l od oe">Hello, World!<br/>Hi!</span></pre><p id="9202" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，转到Node.js网站中的<a class="ae nu" href="https://nodejs.org/en/docs/guides/getting-started-guide" rel="noopener ugc nofollow" target="_blank">指南部分</a>，您将看到显示单词“Hello World”的示例代码，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="ead3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">创建一个包含上述内容的名为app.js的文件，然后使用<code class="fe of og oh nw b">node app.js</code>在命令行上运行它</p><p id="5715" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">访问<a class="ae nu" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>你会看到一条消息写着“Hello World”。</p><p id="0e9b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一些关键词的含义:</p><ul class=""><li id="8151" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated"><code class="fe of og oh nw b">require('http')</code> →导入http模块，这是Node.js的主模块</li><li id="3955" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><code class="fe of og oh nw b">createServer()</code> →使用参数请求和响应创建服务器</li><li id="b141" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><code class="fe of og oh nw b">.setHeader()</code> →指定内容类型</li><li id="e9e4" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><code class="fe of og oh nw b">.end()</code> →是回应的结尾和“Hello World”这个词</li><li id="d27f" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><code class="fe of og oh nw b">.listen()</code> →设置网络服务器的端口和主机名(主机名可选)</li></ul></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="80ca" class="ku kv it bd kw kx np kz la lb nq ld le jz nr ka lg kc ns kd li kf nt kg lk ll bi translated">fs模块的第一个项目</h1><p id="dcad" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在，让我们开始使用名为fs(文件系统)的内置模块编写Node.js的过程。</p><p id="9723" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们将创建一个包含两个文件的项目文件夹，即:</p><ul class=""><li id="e0d4" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated"><code class="fe of og oh nw b">package.json</code> →指定项目名称、项目版本以及其他依赖项的文件。</li><li id="d977" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated"><code class="fe of og oh nw b">app.js</code> →代码将要写入的主文件。</li></ul><p id="e08e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">文件<code class="fe of og oh nw b">package.json</code>使用JSON格式，每次都强制指定名称和版本，其他值是可选的。例如:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="1c07" class="oa kv it nw b gy ob oc l od oe">// The contents of 'package.json'<br/>{<br/>  "name": "hello-node",<br/>  "version": "0.0.1"<br/>}</span></pre><p id="1d92" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们也可以使用<code class="fe of og oh nw b">npm init</code>来创建<code class="fe of og oh nw b">package.json</code>文件。</p><h2 id="be86" class="oa kv it bd kw ok ol dn la om on dp le lv oo op lg lz oq or li md os ot lk ou bi translated">写文件</h2><p id="d644" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在<code class="fe of og oh nw b">app.js</code>文件中，键入以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="2f8a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">运行<code class="fe of og oh nw b">node app.js</code>看到有一个用内容‘Hello node . js’创建的文件<strong class="lo iu"> message.txt </strong>。</p><p id="1e88" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe of og oh nw b">fs.writeFile(filename, data, encoding, callback)</code> →将接受第一个参数作为文件名，第二个参数是要写入文件的信息，第三个参数是编码(默认为<em class="ne"> utf8 </em>)，最后一个参数是回调函数(我们将在本文稍后讨论)。</p><p id="7e7c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当<code class="fe of og oh nw b">file</code>是文件名时，将数据异步写入文件，替换已存在的文件。<code class="fe of og oh nw b">data</code>可以是字符串，也可以是缓冲区。</p><p id="211d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当<code class="fe of og oh nw b">file</code>是文件描述符时，行为类似于直接调用<code class="fe of og oh nw b">fs.write()</code>(这是推荐的)。</p><p id="c2e1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果<code class="fe of og oh nw b">data</code>是一个缓冲器，则<code class="fe of og oh nw b">encoding</code>选项被忽略。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><blockquote class="nb nc nd"><p id="2fb2" class="lm ln ne lo b lp mi ju lr ls mj jx lu nf mk lx ly ng ml mb mc nh mm mf mg mh im bi translated">在同一个文件上多次使用<code class="fe of og oh nw b">fs.writeFile()</code>而不等待回调是不安全的。对于这种情况，建议使用<code class="fe of og oh nw b">fs.createWriteStream()</code>。有关更多信息，请参考文档。</p></blockquote><h2 id="682d" class="oa kv it bd kw ok ol dn la om on dp le lv oo op lg lz oq or li md os ot lk ou bi translated">读取文件</h2><p id="6dc3" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">尝试通过添加一些文本来编辑<em class="ne"> message.txt </em>文件，然后使用下面的示例来读取该文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="4688" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe of og oh nw b">.readFile()</code>异步读取文件的全部内容。</p><p id="2774" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">回调被传递了两个参数<code class="fe of og oh nw b">(err, data)</code>，其中<code class="fe of og oh nw b">data</code>是文件的内容。</p><p id="de6e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果没有指定编码，则返回原始缓冲区。</p><p id="23f6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果<code class="fe of og oh nw b">options</code>是一个字符串，那么它指定了编码:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="ce2e" class="oa kv it nw b gy ob oc l od oe">fs.readFile('/etc/passwd', 'utf8', callback);</span></pre><p id="20ef" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当路径是一个目录时，<code class="fe of og oh nw b">fs.readFile()</code>和<code class="fe of og oh nw b">fs.readFileSync()</code>的行为是特定于平台的。在macOS、Linux和Windows上，将返回一个错误。在FreeBSD上，将返回目录内容的表示。</p><blockquote class="nb nc nd"><p id="a986" class="lm ln ne lo b lp mi ju lr ls mj jx lu nf mk lx ly ng ml mb mc nh mm mf mg mh im bi translated"><code class="fe of og oh nw b"><em class="it">fs.readFile()</em></code>函数缓冲整个文件。为了最大限度地降低内存成本，在可能的情况下，最好通过<code class="fe of og oh nw b"><em class="it">fs.createReadStream()</em></code>进行流式传输。有关更多信息，请参考文档。</p></blockquote></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="9209" class="ku kv it bd kw kx np kz la lb nq ld le jz nr ka lg kc ns kd li kf nt kg lk ll bi translated">回调函数</h1><p id="e4df" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你可能想知道什么是回调函数，为什么使用它，等等。</p><p id="db04" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在我们定义回调之前，我们需要理解它们为什么存在。它们的存在是因为节点的异步特性。每个人都知道异步编程“更好”但“更难”。</p><p id="076d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">好吧，最后那句话有点过于简单化了。</p><p id="8fe6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">让我们更深入一点，比较同步和异步编写的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="562e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">你马上会注意到的是，异步版本是…丑陋的。看起来我们为了一点点收益，把事情变得不必要的复杂。</p><p id="dc81" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">异步编程最好的一点是，当您的代码等待某件事情完成时(比如API调用或来自数据库的响应)，它可以做其他事情。</p><p id="ec8f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">换句话说，当一个进程花费很长时间时，你的代码不会被阻塞。这就是Node.js被创建的主要原因:运行同步代码的服务器需要花费大量时间等待。</p><p id="e1cc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果服务器能够在等待I/O的同时处理请求，事情就会做得更快。</p><p id="da09" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于异步编程来说，事情确实有点复杂，尤其是在您开始的时候，但是这并不是一个很难理解的概念，而且好处是值得的。</p><p id="a5b9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">随着对“异步编程”和“非阻塞”等术语的更好理解，让我们来回答我们最初的问题。</p><blockquote class="ov"><p id="8fdd" class="ow ox it bd oy oz pa pb pc pd pe mh dk translated">回调只是一个函数，作为参数传递给另一个函数，当异步任务完成时，该函数将调用它。</p></blockquote><p id="bd22" class="pw-post-body-paragraph lm ln it lo b lp pf ju lr ls pg jx lu lv ph lx ly lz pi mb mc md pj mf mg mh im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="cd92" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当<code class="fe of og oh nw b">fs.readFile()</code>获取完文件<code class="fe of og oh nw b">fileName</code>后，它执行回调函数，如果抛出错误，该函数将处理错误，并将获取的文件记录到控制台。</p><p id="f53b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意回调函数有两个参数:<code class="fe of og oh nw b">err</code>和<code class="fe of og oh nw b">data</code>。按照惯例，回调函数的第一个参数是一个错误。如果父函数抛出一个错误，它会在那里等待你去处理，如果没有抛出错误(有时会发生)，那么第一个参数应该是null。</p><p id="0df1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">同样按照惯例，以下参数是响应数据。查找<a class="ae nu" href="https://nodejs.org/api/errors.html#errors_error_first_callbacks" rel="noopener ugc nofollow" target="_blank">错误优先回调</a>了解更多相关信息。</p><p id="6d6a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这一切都很好，但为什么不简单地将上面的内容写成这样:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="2788" class="oa kv it nw b gy ob oc l od oe">let file = fs.readFile(fileName);<br/>console.log("file: ", file);</span></pre><p id="795f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">简而言之，因为<em class="ne">异步</em>。在上面的例子中，当我们试图记录时，<code class="fe of og oh nw b">file</code>将是未定义的，因为在我们到达<code class="fe of og oh nw b">console.log()</code>之前，<code class="fe of og oh nw b">fs.readFile()</code>不会完成获取。</p><p id="97db" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">但是，这个</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="0ef7" class="oa kv it nw b gy ob oc l od oe">let file = 1 + 1;<br/>console.log("file: ", file);</span></pre><p id="4883" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">会管用的。</p><p id="cb23" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于只和同步编程打过交道的新人来说，感觉有点混乱；你过着充满爱和逻辑的幸福生活，突然，第3行可以在第2行之前执行？！为了确保万无一失，你应该随时随地使用回调吗？号码</p><p id="4eef" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">回调是在我们不知道什么时候做什么的时候使用的。再一次，考虑类似API调用、从数据库获取数据或硬盘I/O的事情。所有这些都需要时间，所以我们希望在我们等待的事件完成时调用我们的回调。因此有了术语<strong class="lo iu">事件驱动编程</strong>。</p><p id="b30d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如果你觉得你只是有点明白，不要感到孤独。就像生活中的许多事情一样，需要一点亲身经历才能得到。</p><p id="f68c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在你获得实践经验之前，让我给你介绍下一个你将陷入的困境，叫做<a class="ae nu" href="http://callbackhell.com" rel="noopener ugc nofollow" target="_blank">回调地狱</a>。我让你自己想办法。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="8f6b" class="ku kv it bd kw kx np kz la lb nq ld le jz nr ka lg kc ns kd li kf nt kg lk ll bi translated">什么是npm？</h1><p id="2cda" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如前所述，npm(节点包管理器)是一个为我们管理节点包的向导。npm 包括一个CLI(命令行客户端),可以用来为您的项目下载和安装开源库/包。这里有一个例子:</p><pre class="kj kk kl km gt nv nw nx ny aw nz bi"><span id="d8ed" class="oa kv it nw b gy ob oc l od oe">npm install PACKAGENAME</span></pre><p id="11be" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><code class="fe of og oh nw b">PACKAGENAME</code>的包将被安装在当前目录下名为<em class="ne"> node_modules </em>的文件夹中。你可以在<a class="ae nu" href="https://www.npmjs.com" rel="noopener ugc nofollow" target="_blank"> npmjs </a>查看套餐。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="4383" class="ku kv it bd kw kx np kz la lb nq ld le jz nr ka lg kc ns kd li kf nt kg lk ll bi translated">结论</h1><p id="a253" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在本文中，我们了解了什么是Node.js，它的功能是什么，如何使用它。我们还了解了什么是npm，以及一些关于http和fs模块的基本知识。希望本文能为您的Node.js之旅提供一个良好的起点！</p><p id="e164" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">点击查看我的博客<a class="ae nu" href="https://the-minimalist.now.sh/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b916" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我走了，~噗~！</p></div></div>    
</body>
</html>