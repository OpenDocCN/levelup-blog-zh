<html>
<head>
<title>Building Serverless API’s Using Azure Functions And C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Azure函数和C#构建无服务器API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-serverless-apis-using-azure-functions-and-c-67110b922943?source=collection_archive---------8-----------------------#2022-12-20">https://levelup.gitconnected.com/building-serverless-apis-using-azure-functions-and-c-67110b922943?source=collection_archive---------8-----------------------#2022-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/063f7429ff26c1035c8357fdd5c47c99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*p05pdH5Tn7cROIZt.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">无服务器Azure功能</figcaption></figure><h1 id="a145" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="cdc6" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">Azure Functions是一种无服务器计算服务，是在云中运行小块代码或“功能”的简单解决方案。它可以使我们的发展更有成效。您将只为手头的事情编写您喜欢的代码，而不用担心整个应用程序或运行它的基础结构。</p><p id="b318" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在本教程中，我将尝试通过使用实体框架核心层作为ORM，使用C#代码和SQL数据库进行数据存储，让您了解Azure函数将如何允许我们使用HTTP Trigger创建API。那么，我们开始吧。</p><p id="3db6" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您可以从下面找到源代码。</p><div class="mc md gp gr me mf"><a href="https://github.com/JayKrishnareddy/API_EFCore_AzureFunctions" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">GitHub-JayKrishnareddy/API _ EFCore _ Azure functions:在Azure中使用HTTP触发器的无服务器API…</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">设置Azure功能数据库模式和实体模型，使用EF建立与SQL数据库的连接</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">github.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt jv mf"/></div></div></a></div><p id="8686" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">先决条件</strong></p><ul class=""><li id="c5f4" class="mu mv it lb b lc lx lg ly lk mw lo mx ls my lw mz na nb nc bi translated"><a class="ae nd" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank">邮递员</a></li><li id="e70e" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw mz na nb nc bi translated"><a class="ae nd" href="https://visualstudio.microsoft.com/downloads/" rel="noopener ugc nofollow" target="_blank"> Visual Studio 2019 </a></li></ul><h1 id="9937" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">目录</h1><ol class=""><li id="7d37" class="mu mv it lb b lc ld lg lh lk nj lo nk ls nl lw nm na nb nc bi translated">设置Azure功能</li><li id="c00b" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw nm na nb nc bi translated">数据库模式和实体模型</li><li id="b68b" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw nm na nb nc bi translated">使用EF Core建立与SQL数据库的连接</li><li id="fe65" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw nm na nb nc bi translated">初始化依赖注入</li><li id="eb19" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw nm na nb nc bi translated">将DbContext注入到函数中</li><li id="fe93" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw nm na nb nc bi translated">实现功能</li><li id="479f" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw nm na nb nc bi translated">使用Postman测试API</li><li id="62bc" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw nm na nb nc bi translated">结论</li></ol><h1 id="7ae0" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">设置Azure功能</h1><p id="8b9d" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">打开Visual Studio，搜索Blazor应用。点击下一步按钮，</p><figure class="no np nq nr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nn"><img src="../Images/bb687210ac8d82aeda905d3d9aa25094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N4b4ryjJMu9trMT8.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图一</figcaption></figure><p id="7b80" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">定义项目名称、路径和解决方案名称。点击创建按钮，</p><figure class="no np nq nr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/0ea14c7311c325e5e55ebfff2297df62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Jd-A12AmMv75PqZ5.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图二</figcaption></figure><p id="f937" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">之后会弹出一个新窗口选择目标框架(<strong class="lb iu"> Azure Functions v2(。Net Core) </strong>，确保选择<strong class="lb iu"> Http触发器</strong>，并在Authorization level部分选择<strong class="lb iu"> Anonymous </strong>，因为我们在本文中没有提到。</p><figure class="no np nq nr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nx"><img src="../Images/a5e2ee5a7c72ec1d5a4532da6592c3cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FsneXYrcp_MjP9Wf.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图三</figcaption></figure><p id="b900" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这创建了一个具有基本Azure功能的框架项目。</p><h1 id="97ee" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">数据库模式和模型实体</h1><p id="85c6" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">下面是employee表的模式。在各自的SQL数据库中执行模式。下面是在数据库中创建表格后的图片。</p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="no np nq nr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oa"><img src="../Images/aaca2f28d4f3c706e865cab7eec354c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cbvtW-w_VTzj1jLQ.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图4</figcaption></figure><p id="3f10" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">创建一个名为<strong class="lb iu"> Models </strong>的文件夹，在该文件夹内将创建一个名为<strong class="lb iu"> Employee </strong>的类——具有最少属性的实体模型，以使我们的实现变得容易</p><p id="e88f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">员工。cs </strong></p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="45a9" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">接下来，让我们将DbContext类添加到应用程序中。这有助于我们通过应用程序访问由我们的模型生成的数据库表。创建一个<strong class="lb iu"> AppDbContext </strong>类来定义我们的DbContext。</p><p id="76f8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu"> AppDbContext.cs </strong></p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="41d0" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">使用EF Core建立与SQL数据库的连接</h1><p id="1ff7" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了使用EF Core连接到SQL数据库，我们需要下面的包来使用Db first方法建立连接。我们可以通过使用Nuget包管理器或使用包管理器控制台来安装所需的包。</p><p id="5d28" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">请确保您安装了版本为<strong class="lb iu"> v2.0.0 </strong>的软件包，因为这是一个完全可用的版本，没有任何关于<strong class="lb iu"> v2 Net Core的问题。</strong></p><figure class="no np nq nr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nx"><img src="../Images/2bd5e07a9a7e1e1ec6393da33eeb68e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zWqinogLeG1yxQvX.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图五</figcaption></figure><h1 id="aff8" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">初始化依赖注入</h1><p id="5a72" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了为我们的函数应用程序设置依赖注入，我们在程序集上使用了<code class="fe ob oc od oe b"><strong class="lb iu"><em class="of">FunctionsStartup</em></strong></code>属性来指示一个启动类，它将在函数应用程序启动时运行。在继承自<code class="fe ob oc od oe b"><strong class="lb iu"><em class="of">FunctionsStartup</em></strong></code>的那个类中，我们覆盖了<code class="fe ob oc od oe b">Configure</code>方法。这允许我们从配置中检索SQL连接字符串，并在服务中注册一个<code class="fe ob oc od oe b">DbContext</code>，这将允许我们将<strong class="lb iu"> <em class="of"> AppDbContext </em> </strong>注入我们的函数。创建一个名为<strong class="lb iu"> Startup.cs </strong>的类来集成依赖注入</p><p id="e365" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu"> Startup.cs </strong></p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="e46e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">将DbContext注入到函数中</h1><p id="5fc0" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">依赖注入现在为我们提供的是在类中定义函数的能力，这些类将它们的依赖注入到它们的构造函数中。打开<strong class="lb iu"> Function1.cs </strong>文件来注入我们的依赖项。</p><p id="c3dd" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu"> Function1.cs </strong></p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="ff38" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">实现功能</h1><p id="b925" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在这个例子中，我们使用了五个函数</p><ul class=""><li id="297f" class="mu mv it lb b lc lx lg ly lk mw lo mx ls my lw mz na nb nc bi translated">GetEmployees:从数据库中获取所有雇员</li><li id="adc0" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw mz na nb nc bi translated">CreateEmployee:将员工相关信息插入数据库</li><li id="f3dc" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw mz na nb nc bi translated">GetEmployeebyId:根据雇员Id获取雇员记录</li><li id="5977" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw mz na nb nc bi translated">更新员工:用修改更新现有员工</li><li id="61ca" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw mz na nb nc bi translated">删除雇员:从数据库中删除雇员记录。</li></ul><p id="0af8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">获得员工</p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="82e6" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">第8行:</strong>增加了函数名属性的名称。</p><p id="f497" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">第9行:</strong>定义一个函数(方法)</p><p id="cd8e" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">第10行:</strong>HTTP触发器的属性特性。</p><ul class=""><li id="1375" class="mu mv it lb b lc lx lg ly lk mw lo mx ls my lw mz na nb nc bi translated"><strong class="lb iu">授权级别</strong> — Azure函数使用授权密钥保护您的HTTP触发器。授权级别有三种类型<br/> 1。匿名:不需要密钥。<br/> 2。功能:需要特定的功能键。如果没有指定，这是默认值。<br/> 3。管理员:需要主密钥。</li><li id="ed82" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw mz na nb nc bi translated"><strong class="lb iu">路由</strong> —定义端点监听的路由模板。路线的默认值设置为api/ &lt; FunctionName &gt;。</li><li id="71b0" class="mu mv it lb b lc ne lg nf lk ng lo nh ls ni lw mz na nb nc bi translated"><strong class="lb iu">方法</strong> —这用于为函数定义HTTP动词。</li></ul><p id="1d6b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">第13- 21行:</strong>添加try catch块来处理异常，并从数据库中获取所有雇员数据。</p><p id="9962" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">创建员工</strong></p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7a10" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu"> GetEmployeebyId </strong></p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ac30" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">更新员工</strong></p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="52ac" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">删除员工</strong></p><figure class="no np nq nr gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="680b" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">最后，我们已经设法将所有的代码更改放置到位。运行应用程序，并验证Postman中的所有方法都按预期工作。运行应用程序后，我们所有的函数都将加载到终端中，因为Azure函数将使用存储模拟器来获取终端内部的响应。</p><figure class="no np nq nr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nx"><img src="../Images/dd6d2882b8f28ca38ae0bfa9742bb459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-mdZOOLrEwCotWC-.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图6</figcaption></figure><blockquote class="og oh oi"><p id="fd6e" class="kz la of lb b lc lx le lf lg ly li lj oj lz lm ln ok ma lq lr ol mb lu lv lw im bi translated"><em class="it">Function运行时版本——我们在Azure Function设置时选择的目标框架。</em></p><p id="8e19" class="kz la of lb b lc lx le lf lg ly li lj oj lz lm ln ok ma lq lr ol mb lu lv lw im bi translated"><em class="it">现在监听Azure函数运行的端口号(7071)。</em></p></blockquote><h1 id="5a9b" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">使用Postman测试API</h1><p id="f138" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们首先使用Postman的CreateEmployee API创建雇员</p><figure class="no np nq nr gt ju gh gi paragraph-image"><div class="gh gi om"><img src="../Images/9b366239d708d776492ecf7a6b0f6df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/0*DrjZlzV87P1OuxAL.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图7</figcaption></figure><p id="fe63" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">这实际上是如何工作的？</strong></p><p id="6142" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们从HTTP触发器获取req主体，并将Json附加到我们的Employee模型类进行反序列化，然后将Employee对象传递到数据库，您可以在CreateEmployee函数中看到这个数据库。</p><p id="c354" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">从GetEmployee API获取雇员列表。</p><figure class="no np nq nr gt ju gh gi paragraph-image"><div class="gh gi on"><img src="../Images/324ea0171f175876be4927c9ee2916cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/0*gSumGiqO6O3cIU7Y.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图8</figcaption></figure><p id="4b1f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">使用UpdateEmployee API更新现有记录，在这个对象中，雇员Id是必需的。基于Id，我们从数据库中获取现有记录，并用新对象更新相同的记录。</p><figure class="no np nq nr gt ju gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/89cb6e06c9472e39c407cdceac1327ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/0*rZis4oT5s-o0jfKQ.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图9</figcaption></figure><p id="6a16" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">通过在路由中传递EmployeeId作为查询参数，从数据库中删除记录。</p><figure class="no np nq nr gt ju gh gi paragraph-image"><div class="gh gi op"><img src="../Images/190b4991fdf3e06cf75ea841e6ccf674.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/0*wCOo-SR7ez1eO3Bu.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">图10</figcaption></figure><h1 id="92f8" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="11b2" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在本文中，我们学习了如何使用Azure函数实现无服务器API，并通过使用实体框架核心依赖注入与数据库集成。谢谢你坚持到最后。</p><p id="e267" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">感谢您的阅读，请在评论区告诉我您的问题、想法或反馈。感谢您的反馈和鼓励。</p><p id="691a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">继续学习…！</p></div></div>    
</body>
</html>