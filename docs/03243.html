<html>
<head>
<title>LeetCode Problems with Rust: Two-Sum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Rust的LeetCode问题:两个和</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/leetcode-problems-two-sum-efa0b69b9505?source=collection_archive---------11-----------------------#2020-04-27">https://levelup.gitconnected.com/leetcode-problems-two-sum-efa0b69b9505?source=collection_archive---------11-----------------------#2020-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e581b9b5ed29251bc2c2d2cbf36eb5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-H2WUc3LU4EUTOupFUmrNQ.png"/></div></div></figure><h1 id="d581" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题</h1><p id="6ed6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">给定一个整数数组，返回这两个数字的索引，使它们加起来达到一个特定的目标。您可以假设每个输入只有一个解决方案，并且不能两次使用同一个元素。</p><h1 id="7942" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">例子</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0e5e" class="md jz iq lz b gy me mf l mg mh">Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].</span></pre><h1 id="19f0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">方法1:暴力</h1><p id="390d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">解决这个问题的简单方法是遍历<code class="fe mi mj mk lz b">nums</code>中的每个元素<code class="fe mi mj mk lz b">x</code>，然后再遍历每个元素，看看是否有一个值等于<code class="fe mi mj mk lz b">target</code> - <code class="fe mi mj mk lz b">x</code></p><h1 id="18cc" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">算法</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6fa0" class="md jz iq lz b gy me mf l mg mh">for i = 0 to length of nums <br/>    for j = i + 1 to length of nums <br/>        if nums[j] == target - nums[i] <br/>            return [i, j]</span></pre><h1 id="a4fc" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">履行</h1><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/1bb16c41d088272b48d503d6536024fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Sb2pj1heBamqxI75.png"/></div></div></figure><h1 id="b7c7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">复杂性</h1><ul class=""><li id="9541" class="mm mn iq ky b kz la ld le lh mo ll mp lp mq lt mr ms mt mu bi translated">时间复杂度:O(n2 ),因为对于数组的每个元素，我们都循环遍历</li><li id="d6de" class="mm mn iq ky b kz mv ld mw lh mx ll my lp mz lt mr ms mt mu bi translated">空间复杂度:O(1)</li></ul><h1 id="7392" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">方法2:两遍哈希表</h1><p id="f133" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">通过将输入数组转换成一个散列图，将值<code class="fe mi mj mk lz b">nums[i]</code>存储为键，将索引<code class="fe mi mj mk lz b">i</code>存储为值，可以降低时间复杂度。这将涉及两次迭代，一次构建散列图，另一次检查散列图中是否存在补码- <code class="fe mi mj mk lz b">target - nums[i]</code> -但不是同一个索引。</p><h1 id="901f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">算法</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="bbdd" class="md jz iq lz b gy me mf l mg mh">map = new HashMap <br/>for i = 0 to length of nums <br/>    map[nums[i]] = i </span><span id="b796" class="md jz iq lz b gy na mf l mg mh">for i = 0 to length of nums <br/>    complement = target - nums[i] <br/>    if map.contains(complement) and map[complement] != i <br/>        return [i, map[complement]]</span></pre><h1 id="ac99" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">履行</h1><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/6b5a6bc5c3a8f2d6f68bd02b3827d124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Lu-KhpHc4fgaFOuI.png"/></div></div></figure><h1 id="30be" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">复杂性</h1><ul class=""><li id="b437" class="mm mn iq ky b kz la ld le lh mo ll mp lp mq lt mr ms mt mu bi translated">时间复杂度:O(2n) -&gt; O(n) —遍历<code class="fe mi mj mk lz b">nums</code>数组两次，一次是为了构建散列图，另一次是为了检查是否看到了补码。</li><li id="3a10" class="mm mn iq ky b kz mv ld mw lh mx ll my lp mz lt mr ms mt mu bi translated">空间复杂度:O(n) —哈希映射的额外空间。</li></ul><h1 id="0caa" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">方法3:一遍哈希表</h1><p id="5a72" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">上面的解决方案可以通过仅检查是否已经看到对一个值的称赞来进一步改进。如果没有看到补码，将补码和索引添加到哈希映射中，否则已经找到了解决方案。</p><h1 id="7a4c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">算法</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="8ab8" class="md jz iq lz b gy me mf l mg mh">map = new HashMap <br/>for i in length of nums <br/>    if map.contains(num) <br/>        return [map[num], i] <br/>    else <br/>        map.insert(target - num, i)</span></pre><h1 id="f116" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">履行</h1><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/c94a4d3c61bd9d8f39e070fdb22afd7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aiVXk54HmvmG0bEA.png"/></div></div></figure><h1 id="942c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">复杂性</h1><ul class=""><li id="ef58" class="mm mn iq ky b kz la ld le lh mo ll mp lp mq lt mr ms mt mu bi translated">时间复杂度:O(n)—<code class="fe mi mj mk lz b">nums</code>向量只迭代一次。</li><li id="07c9" class="mm mn iq ky b kz mv ld mw lh mx ll my lp mz lt mr ms mt mu bi translated">空间复杂度O(n) —哈希映射的额外空间。</li></ul><h1 id="8795" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">回顾</h1><p id="ee79" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对于这个问题，使用两遍哈希表方法对于大多数数据集来说已经足够好了。然而，如果数据集足够大，一次就得到结果将是理想的。随意看一看<a class="ae nb" href="https://github.com/andrewleverette/leetcode_problems/blob/master/two_sum/src/lib.rs" rel="noopener ugc nofollow" target="_blank">源代码</a></p><p id="1813" class="pw-post-body-paragraph kw kx iq ky b kz nc lb lc ld nd lf lg lh ne lj lk ll nf ln lo lp ng lr ls lt ij bi translated"><em class="nh">原载于2020年4月27日</em><a class="ae nb" href="https://andrewleverette.github.io/two-sum/" rel="noopener ugc nofollow" target="_blank"><em class="nh">https://andrewleverette . github . io</em></a><em class="nh">。</em></p><figure class="lu lv lw lx gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/2ee1ea256190d57f75331cb76d9d3339.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*jLGtQ-ldYIEs8X6UUxL5Pg.jpeg"/></div></figure></div></div>    
</body>
</html>