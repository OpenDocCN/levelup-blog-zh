<html>
<head>
<title>Implementing FaaS in Kubernetes Using Kubeless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kubeless在Kubernetes中实现FaaS</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-faas-in-kubernetes-using-kubeless-c4797156f561?source=collection_archive---------7-----------------------#2020-03-04">https://levelup.gitconnected.com/implementing-faas-in-kubernetes-using-kubeless-c4797156f561?source=collection_archive---------7-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="adcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">本文原载于</em><a class="ae kp" href="https://www.magalix.com/blog/implementing-faas-in-kubernetes-using-kubeless" rel="noopener ugc nofollow" target="_blank">https://www . magalix . com/blog/implementing-FAAS-in-kubernetes-using-kubeless</a></p><h1 id="6f5b" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">什么是FaaS架构，我们什么时候需要它？</h1><p id="68a3" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">功能即服务(FaaS)是一种相对较新的架构模式。当AWS等主要云提供商开始提供Lambda函数等产品时，它就出现了，随后是Azure函数(微软Azure)和谷歌云函数(谷歌云)。这些产品背后的想法是，有时，你可能不需要“永远在线”模式的服务。相反，你想要“一次性”的服务；只有当一个请求到达，然后“死亡”时，它才被激活如果一个新的请求需要实现，一个新的服务实例被启动，等等。</p><p id="0388" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了帮助您更好地理解FaaS模型何时适用，请考虑以下用例:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/e047f7e880c5e209b9d52308ab1c7b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Dt7RGny_wEmNfPi5.png"/></div></div></figure><ul class=""><li id="c746" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated">双因素身份验证:您有一个非常棒的web应用程序，每天都有大量的访问者，由于它越来越受欢迎，您决定增加安全措施以避免任何黑客攻击。因此，您实现了一个双因素身份验证系统，在该系统中，用户输入他们的密码，还必须输入一次性密码(OTP)代码，该代码会发送到他们注册的手机上。问题是让web应用程序二进制发送SMS需要一个阻塞执行过程，这不仅会导致向最终用户显示页面的延迟，而且还会增加web应用程序服务器的负载，尤其是在繁忙/高峰时间。一个可能的解决方案是将发送SMS委托给一个功能。一旦被触发，该功能将在另一个容器中执行以满足请求(即发送SMS)。验证用户输入了用户名和密码后，web应用程序立即显示第二个页面，要求用户输入发送到他/她的手机的OTP代码。下图有助于解释在这种情况下使用FaaS的优势:</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mo"><img src="../Images/1c376dbd61db5322eb8822db6bc28707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M_T9Bp9FYTA_UZBU.png"/></div></div></figure><p id="a042" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无服务器编程:FaaS的一些应用程序包括创建整个web应用程序，而无需管理任何服务器。例如，一个web应用程序除了由应用服务器(PHP、Go、Ruby、Python等)生成的动态内容之外，还由一些静态内容(HTML、JavaScript、images、CSS等)组成。)，后端数据库可以使用FaaS和无服务器编程来构建，如下所示:</p><ul class=""><li id="5add" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated">请求到达网络服务器。像AWS这样的云提供商提供云管理的静态内容服务器，例如AWS S3。然后，从桶中提供任何静态文件。</li><li id="9c58" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">当请求动态内容时，静态HTML页面向API网关发出请求(通常通过AJAX ), API网关是应用程序和云功能之间的接口。</li><li id="29cd" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">云函数被触发，它完成请求并在终止前返回结果。在后台，云提供商启动一个容器，在其中执行该功能。一旦执行完成，容器就会死亡。我们可以在下图中以AWS为例描述无服务器托管:</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mu"><img src="../Images/bb72e362ce8d4faad912ed7bf9bf8a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j0cMe20uxxlmOgBS.png"/></div></div></figure><h1 id="06f2" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">什么是无库？</h1><p id="033b" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">现在，您已经了解了FaaS，以及为什么和何时应该使用它，是时候做一个快速实践练习来演示我们如何在Kubernetes中使用该模型了。让这成为可能的著名工具之一是<a class="ae kp" href="https://kubeless.io/" rel="noopener ugc nofollow" target="_blank"> kubeless </a>。Kubeless可以被认为是Kubernetes的附加产品。它创建了一个定制资源(和一个处理它的控制器),还提供了一个方便的命令行工具，允许您轻松地发出命令。在本文的其余部分，我们将在我们的集群中安装kubeless，并使用它为web应用程序实现一个非常简单、极简的FaaS模型。</p><h1 id="d368" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">无缝安装</h1><p id="283a" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">安装非常简单。它只涉及对正在运行的Kubernetes集群发出三个命令:</p><pre class="lu lv lw lx gt mv mw mx my aw mz bi"><span id="5c8b" class="na kr it mw b gy nb nc l nd ne">$ export RELEASE=$(curl -s https://api.github.com/repos/kubeless/kubeless/releases/latest | grep tag_name | cut -d '"' -f 4)<br/>$ kubectl create ns kubeless<br/>$ kubectl create -f <a class="ae kp" href="https://github.com/kubeless/kubeless/releases/download/$RELEASE/kubeless-$RELEASE.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/kubeless/kubeless/releases/download/$RELEASE/kubeless-$RELEASE.yaml</a></span></pre><p id="0a4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的命令创建了一个名称空间，并部署了必要的组件以使kubeless工作。如果您打算广泛使用kubeless，我们强烈建议您也安装他们提供的命令行工具:</p><pre class="lu lv lw lx gt mv mw mx my aw mz bi"><span id="e43b" class="na kr it mw b gy nb nc l nd ne">export OS=$(uname -s| tr '[:upper:]' '[:lower:]')<br/>curl -OL https://github.com/kubeless/kubeless/releases/download/$RELEASE/kubeless_$OS-amd64.zip &amp;&amp; \<br/>  unzip kubeless_$OS-amd64.zip &amp;&amp; \<br/>  sudo mv bundles/kubeless_$OS-amd64/kubeless /usr/local/bin/</span></pre><p id="309b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以上命令将在您的linux/macOS系统上安装kubeless CLI工具。如果你运行的是Windows，你可能想参考<a class="ae kp" href="https://kubeless.io/docs/quick-start/" rel="noopener ugc nofollow" target="_blank">文档</a>来了解具体步骤。</p><h1 id="4ce3" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">实验:使用FaaS在Kubernetes中实现一个Web Scraper</h1><p id="3f12" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们将编写一个非常简单的web应用程序，它接受来自用户的URL，然后从网站中抓取重要数据。最后，数据被清理并保存到后端数据库。使用FaaS，我们可以启动一个函数来异步抓取数据，这样它就不会阻塞用户的UI。该模型可以进一步扩展，以调用另一个函数，通知用户他们的数据已经成功抓取，可以下载了(可能以CSV或PDF的形式)。</p><p id="d9b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的工作流程可以详细描述如下:</p><ul class=""><li id="bc4d" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated">应用程序通过AJAX POST请求接收URL。</li><li id="b64c" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">web应用程序不是自己处理任务并阻塞UI，而是分派一个函数(通过由Kubernetes创建的Kubernetes服务)来抓取web页面的数据。</li><li id="1cf3" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">最终，数据可以保存到永久存储器(MySQL、Redis等)。).</li></ul><p id="d564" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以画一个简单的图表，描述应用程序的工作流程如下:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mo"><img src="../Images/1f4f992dc3ad43a869c17d885bd769fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*njWdTiiLtkxSl8nP.png"/></div></div></figure><p id="2601" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在您已经知道了系统的样子，让我们继续实际构建它。</p><p id="9414" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们正在使用的网站是https://webscraper.io/test-sites/e-commerce/allinone。这是一个专门为测试网络抓取工具而创建的网站。现在，让我们来完成实验步骤。</p><h1 id="deb6" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">创建无库函数</h1><p id="eb23" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">您可以为该函数使用许多运行时环境，这意味着您可以用自己喜欢的编程语言编写该函数。在这个实验中，我们使用Python。我们的Kubeless函数驻留在scraper.py文件中(名字不重要)。该文件的内容如下:</p><pre class="lu lv lw lx gt mv mw mx my aw mz bi"><span id="e421" class="na kr it mw b gy nb nc l nd ne">from bs4 import BeautifulSoup<br/>import requests<br/>import json</span><span id="27d6" class="na kr it mw b gy nf nc l nd ne">def main(event, context):<br/>   url = event['data']['url']<br/>   r = requests.get(url)<br/>   soup = BeautifulSoup(r.text, 'html.parser')<br/>   items =  [x.find("p",{"class":"description"}).text for x in soup.find_all("div",{"class":["col-sm-4", "col-lg-4", "col-md-4"]})]<br/>   return json.dumps(items)</span></pre><p id="ed32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该脚本简单地抓取页面并返回待售商品的标题。这里我们需要注意的第一件事是文件的结构:</p><ul class=""><li id="8551" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated">代码必须存在于接受两个参数的函数中(名称无关紧要):事件和上下文。事件是包含传递给函数的数据的对象，而上下文包含与函数相关的任何其他元数据。</li><li id="837b" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">您可以在文件中使用任意数量的其他函数。然而，您需要选择启动代码执行的引导函数(稍后在部署我们的函数时会详细介绍)</li></ul><p id="7d87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你以前使用过Python，你可能会注意到我们使用了两个非标准的库，即:requests和bs4 (BeautifulSoup)。这带来了一个重要的问题:</p><h1 id="cdad" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">如果代码需要依赖怎么办？</h1><p id="ae14" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">通常情况下，您需要安装第三方库来执行复杂的任务。在我们的实验室中，我们使用bs4进行网页抓取和请求，以便轻松获取网页数据。要允许无库函数使用外部库，您必须做两件事:</p><ol class=""><li id="e320" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn ng ml mm mn bi translated">将库安装到您的函数所在的根目录。在Python中使用pip: pip3 install -t . bs4请求可以很容易地做到这一点</li><li id="87a1" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn ng ml mm mn bi translated">将包含函数文件+外部库的整个目录打包到一个zip文件中。因此，假设您在目录中，zip -r9 ~/package.zip *将所有内容压缩到您主目录中的package.zip文件中。</li></ol><p id="5517" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您可以简单地将zip文件部署为函数文件。但是，根据设计，etcd不能存储大小超过1.5 MB的对象。这意味着如果zip文件很大(这是经常发生的情况)，我们就不能在Kubernetes数据库中存储我们的函数。此问题的解决方案是将文件存储在文件服务器上，并提供文件位置的URL。在我们的实验室中，我们使用GitHub来实现这个目的，但是您可以使用任何HTTP服务器，只要它可以从pod到达。现在，让我们看看如何部署我们的功能。</p><h1 id="0200" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">部署无库功能</h1><p id="d6fb" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">与其他Kubernetes对象一样，您可以使用无库工具强制部署无库功能，也可以使用YAML文件声明式部署。在本实验中，我们使用声明式方法，因为我们可以将YAML文件置于版本控制之下。我们的文件function.yml如下所示:</p><pre class="lu lv lw lx gt mv mw mx my aw mz bi"><span id="af09" class="na kr it mw b gy nb nc l nd ne">apiVersion: kubeless.io/v1beta1<br/>kind: Function<br/>metadata:<br/> name: scraper<br/> namespace: default<br/> label:<br/>   created-by: kubeless<br/>   function: scraper<br/>spec:<br/> runtime: python3.7<br/> timeout: "180"<br/> handler: scraper.main<br/> deps: ""<br/> checksum: sha256:8c1136a7ecf95aef19c7565b9acb3977645fe98d1f877dd2397aa6455673805e<br/> function-content-type: url+zip<br/> function: <a class="ae kp" href="https://github.com/MagalixCorp/k8s-faas/blob/master/packagae.zip?raw=true" rel="noopener ugc nofollow" target="_blank">https://github.com/MagalixCorp/k8s-faas/blob/master/packagae.zip?raw=true</a></span></pre><p id="6c74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看这个定义的重要部分:</p><p id="c163" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1-文件创建一个Function类型的对象。这是我们安装Kubeless时为我们创建的自定义资源。</p><p id="22c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2-规范部分包含许多有趣的功能:</p><ul class=""><li id="01ab" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated"><strong class="js iu">运行时</strong>:函数运行的环境。从技术上讲，这定义了函数的容器将使用的图像。在本实验中，我们使用Python 3.7。Kubeless支持许多运行时，比如Go、Python、Ruby、Java等等。你可以在这里看看完整的名单:【https://kubeless.io/docs/runtimes/】T2</li><li id="6747" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated"><strong class="js iu">超时</strong>指定功能运行的最大时间(秒)。如果执行时间超过这个数字，函数将被提前终止。如果代码遇到问题(例如，无限循环)并且浪费了宝贵的系统资源，这可能会很方便。</li><li id="9079" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated"><strong class="js iu">处理程序</strong>是告诉Kubeless如何执行函数的地方。它包含文件名，后跟由点分隔的函数名。所以，如果你在zip文件中有很多文件，在代码文件中有很多函数，这就是你指导Kubeless如何找到程序入口点的地方。</li><li id="d0b9" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated"><strong class="js iu">校验和</strong>是函数文件的SHA256哈希字符串。它确保下载的文件确实是应该执行的文件，并且没有被篡改。如果您输入了不正确的哈希值，pod将不会启动。那么，如何计算文件的散列字符串呢？只需执行以下命令:shasum-a 256 ~/package . zip。注意，对zip文件内容的任何更改都需要重新计算和更新哈希值。</li><li id="1ec2" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated"><strong class="js iu"> function-content-type </strong>是url+zip，表示我们需要使用应该从远程位置下载的压缩文件。其他可能的值包括text和base64(您可以选择向任何格式添加+zip，以表示文件是压缩的)。</li><li id="7cdb" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated"><strong class="js iu">函数</strong>:该函数的源文件。</li></ul><p id="c6b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以像对待任何其他Kubernetes对象一样应用这个定义:</p><pre class="lu lv lw lx gt mv mw mx my aw mz bi"><span id="4bcf" class="na kr it mw b gy nb nc l nd ne">kubectl apply -f function.yml</span></pre><p id="0853" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">部署完成后，您会注意到我们创建了一个新的pod和一项服务，两者的名称都是scraper:</p><pre class="lu lv lw lx gt mv mw mx my aw mz bi"><span id="b0c6" class="na kr it mw b gy nb nc l nd ne">$ kubectl get pods<br/>NAME                               READY   STATUS    RESTARTS   AGE<br/>scraper-dfc478fd6-n8w6c            1/1     Running   0          3h37m</span><span id="a398" class="na kr it mw b gy nf nc l nd ne">$ kubectl get svc<br/>NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE<br/>kubernetes   ClusterIP   10.12.0.1             443/TCP        11h<br/>scraper      ClusterIP   10.12.5.46            8080/TCP       9h</span></pre><p id="0594" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，服务类型是ClusterIP，这意味着只能从集群中的另一个pod调用它。然而，Kubeless支持向服务添加入口，以便可以从外部世界访问它。关于如何做的更多信息，请参考Kubeless文档。</p><p id="2382" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在继续之前，我们需要确保我们的功能正在工作。因为只有在集群内部才能调用它，所以我们有两个选择:</p><ul class=""><li id="a18f" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated">使用类似<a class="ae kp" href="https://kubernetes.io/docs/tasks/access-kubernetes-api/http-proxy-access-api/" rel="noopener ugc nofollow" target="_blank"> kubectl proxy </a>的工具访问集群的内部网络，并通过类似cURL的工具向服务发出原始HTTP POST请求。</li><li id="bbcf" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">使用无库命令行工具。</li></ul><p id="1c09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本实验中，我们将使用第二个选项，因为它简单得多:</p><pre class="lu lv lw lx gt mv mw mx my aw mz bi"><span id="91e8" class="na kr it mw b gy nb nc l nd ne">$ kubeless function call scraper --data '{"url":"https://webscraper.io/test-sites/e-commerce/allinone"}'<br/>["Asus VivoBook 15 X540NA-GQ008T Chocolate Black, 15.6\" HD, Pentium N4200, 4GB, 500GB, Windows 10 Home, En kbd", "Acer Swift 1 SF113-31 Silver, 13.3\" FHD, Pentium N4200, 4GB, 128GB SSD, Windows 10 Home", "Asus VivoBook X441NA-GA190 Chocolate Black, 14\", Celeron N3450, 4GB, 128GB SSD, Endless OS, ENG kbd"]</span></pre><p id="0fd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据以JSON格式传递给函数。您可以通过检查event['data']对象来访问发送给该函数的数据。现在，我们确信我们的函数响应HTTP POST请求并返回预期的响应，让我们添加包装器web应用程序。</p><h1 id="f1c5" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">构建Web应用程序并结束</h1><p id="b7b6" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">我们使用的web应用程序是我们在sidecar模式文章中使用的应用程序的一个略微修改的版本。它基本上有以下组件:</p><ul class=""><li id="23aa" class="mf mg it js b jt ju jx jy kb mh kf mi kj mj kn mk ml mm mn bi translated">由web服务器(Nginx)提供服务的HTML页面。该页面包含一个输入框和一个提交按钮，单击该按钮会触发对后端Flask应用程序的AJAX请求。用户应该在框中输入要抓取的URL，然后单击“提交”</li><li id="6b73" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">后端应用程序正在运行Python Flask和Gunicorn。一旦它接收到来自前端页面的URL，它就向scraper服务建立一个POST请求，然后触发Kubeless函数。</li></ul><p id="a0d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完整的工作项目可以在我们的GitHub repo【https://github.com/MagalixCorp/k8s-faas T2】找到。现在，让我们浏览一下申请文件:</p><h1 id="57a6" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">前端(网络)</h1><ul class=""><li id="5351" class="mf mg it js b jt lo jx lp kb nh kf ni kj nj kn mk ml mm mn bi translated">index.html是用户提交URL的地方。</li><li id="54a7" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">script.js:包含将数据发送到后端API的AJAX逻辑。</li><li id="9ac5" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">default.conf:将请求路由到/api/后端服务的Nginx配置。</li><li id="c640" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">Dockerfile来构建web图像。</li></ul><h1 id="d326" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">后端(应用程序)</h1><ul class=""><li id="67fb" class="mf mg it js b jt lo jx lp kb nh kf ni kj nj kn mk ml mm mn bi translated">mainapp.py从前端部分接收请求，并向scraper服务发送POST请求。</li><li id="8e7d" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">wswgi.py激活Gunicorn服务，该服务充当Flask的包装器。</li><li id="0efa" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">Dockerifle来构建应用程序映像。</li></ul><h1 id="90d6" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">Kubernetes部署(deploy.yml)</h1><p id="57ad" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">该文件包含节点端口服务类型和部署。该部署创建了一个托管两个容器的pod:应用程序和web。注意这里使用的sidecar模式，Nginx通过调用localhost将后端请求中继到API服务器，就好像两个服务运行在同一台主机上一样。</p><h1 id="1d90" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">运行实验室</h1><p id="3d5a" class="pw-post-body-paragraph jq jr it js b jt lo jv jw jx lp jz ka kb lq kd ke kf lr kh ki kj ls kl km kn im bi translated">这里的最后一步是测试我们的工作。导航到端口32001上的任何群集节点IP地址。在网址框中输入https://webscraper.io/test-sites/e-commerce/allinone<a class="ae kp" href="https://webscraper.io/test-sites/e-commerce/allinone" rel="noopener ugc nofollow" target="_blank">并点击提交。</a></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nk"><img src="../Images/ae4bde2905676ffbc3be7041fade1494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oy_BD_ZPcR99fF9r.png"/></div></div></figure><p id="b77d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们的函数能够如此快速地执行任务，所以我们可以通过浏览浏览器开发工具的network选项卡来查看返回给我们的结果。在真实的场景中，当函数异步开始它的执行之旅时，用户应该只收到一个很好的“谢谢”消息。当执行完成时，应该有某种警报逻辑来通知客户端他们的数据准备好了。该功能可以将结果存储在永久存储器中，用户可以通过另一个页面查看它。</p><h1 id="21d8" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="be61" class="mf mg it js b jt lo jx lp kb nh kf ni kj nj kn mk ml mm mn bi translated">通过FaaS(功能即服务)模式，您可以“按需”执行代码。例如，您可以使用web应用程序面向客户端的部分来执行验证，强制执行业务逻辑规则，同时将重担交给函数。</li><li id="08cb" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">所有主要的云提供商都已经通过产品实现了FaaS(例如，AWS Lambda功能)。</li><li id="06c7" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">您可以通过使用Kubernetes之类的工具在Kubernetes集群中实现自己的FaaS逻辑。</li><li id="dcdc" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">Kubeless的工作方式是在一个受支持的运行时环境中创建一个函数，并将其部署到集群中。</li><li id="ba53" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">该函数通过发送到专用于该函数pod的服务的POST请求来接收调用请求。</li><li id="e451" class="mf mg it js b jt mp jx mq kb mr kf ms kj mt kn mk ml mm mn bi translated">一旦接收到，该功能被触发。您可以选择以JSON格式将数据传递给函数。</li></ul></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="354c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">原载于2020年3月4日</em><a class="ae kp" href="https://www.magalix.com/blog/implementing-faas-in-kubernetes-using-kubeless" rel="noopener ugc nofollow" target="_blank"><em class="ko">【https://www.magalix.com】</em></a><em class="ko">。</em></p></div></div>    
</body>
</html>