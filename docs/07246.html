<html>
<head>
<title>Making a file path mapper with Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Typescript制作文件路径映射器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/making-a-file-path-mapper-with-typescript-7b10ad4ff0c8?source=collection_archive---------5-----------------------#2021-02-03">https://levelup.gitconnected.com/making-a-file-path-mapper-with-typescript-7b10ad4ff0c8?source=collection_archive---------5-----------------------#2021-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d826" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程是关于一个简单的算法，用于跟踪一个文件夹内和文件夹下的每个文件的路径。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/745287144d3c7b13ba5f4b6cd6621107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*fg8rzfQMv88U23MiECjuYw.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">文件路径映射思想</figcaption></figure><p id="d227" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我将使用TypeScript，但是您可以抽象出步骤和主要思想，并用您喜欢的语言重新创建这个算法</p><p id="6fde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始创建一个<code class="fe kx ky kz la b">src</code>文件夹和一个<code class="fe kx ky kz la b">index.ts</code>文件。</p><p id="5256" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe kx ky kz la b">index.ts</code>文件中，我们将为我们的算法创建API，这意味着它将接收用户选项，并将它们传递给其他模块，并在解析完成后返回值。</p><p id="e29d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从一个函数开始，这是我们的切入点。</p><pre class="km kn ko kp gt lb la lc ld aw le bi"><span id="3df2" class="lf lg iq la b gy lh li l lj lk">interface FilePathMapperOptions {<br/>  startDirectory: string<br/>}<br/><br/>export function filePathMapper({ startDirectory }: FilePathMapperOptions) {<br/>  <br/>}</span></pre><p id="bae2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它接收一个<code class="fe kx ky kz la b">startDirectory</code>参数，这个参数正是我们的翻找入口点。映射将只获取起始目录中的文件。</p><p id="2539" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在创建另一个文件，<code class="fe kx ky kz la b">files-searcher.ts </code>，这个文件将有实际进入文件夹和创建我们的地图的功能。</p><p id="87eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在files-searcher.ts中:</p><pre class="km kn ko kp gt lb la lc ld aw le bi"><span id="0552" class="lf lg iq la b gy lh li l lj lk">import { promises as fs } from 'fs'<br/>import path from 'path'</span><span id="269e" class="lf lg iq la b gy ll li l lj lk">let paths: Array&lt;string&gt; = []</span></pre><p id="be46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要<code class="fe kx ky kz la b">fs</code>和<code class="fe kx ky kz la b">path</code>核心模块，并定义一个名为paths的变量来存储我们收集的路径。</p><p id="ab76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">声明一个名为<code class="fe kx ky kz la b">searchFiles</code>的函数。它接收一个名为<code class="fe kx ky kz la b">folderName</code>的参数，在第一次运行时，它将只是一个文件夹名，随着它的深入，它将是当前文件夹名+以前的文件夹名。</p><pre class="km kn ko kp gt lb la lc ld aw le bi"><span id="6766" class="lf lg iq la b gy lh li l lj lk">import { promises as fs } from 'fs'<br/>import path from 'path'<br/><br/>let paths: Array&lt;string&gt; = []<br/><br/>export async function searchFiles(folderName: string) {}</span></pre><p id="6011" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用方法<code class="fe kx ky kz la b">fs.readdir</code>，我们可以获得一个文件夹中所有文件和文件夹的名称，让我们遍历它们并获得文件/文件夹的统计信息。</p><pre class="km kn ko kp gt lb la lc ld aw le bi"><span id="149d" class="lf lg iq la b gy lh li l lj lk">import { promises as fs } from 'fs'<br/>import path from 'path'</span><span id="1263" class="lf lg iq la b gy ll li l lj lk">let paths: Array&lt;string&gt; = []</span><span id="679f" class="lf lg iq la b gy ll li l lj lk">export async function searchFiles(folderName: string) {<br/>  const folderChildren = await fs.readdir(folderName)<br/>  <br/>  for(const child of folderChildren) {<br/>    const childPath = `${folderName}/${child}`<br/>    const childStats = await fs.lstat(childPath)<br/>  }<br/>}</span></pre><p id="1405" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用方法<code class="fe kx ky kz la b">fs.lstat</code>来获取关于文件/文件夹的信息，然后创建一个<code class="fe kx ky kz la b">childPath</code>常量来跟踪路径。</p><p id="fb1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了childStats，我们可以使用像<code class="fe kx ky kz la b">isFile</code>和<code class="fe kx ky kz la b">isDirectory</code>这样的方法。对于每一种情况，我们都会有不同的情况:</p><ul class=""><li id="3d83" class="lm ln iq jp b jq jr ju jv jy lo kc lp kg lq kk lr ls lt lu bi translated"><strong class="jp ir">文件</strong>:如果它是一个文件，我们获取该文件的完整路径并将其添加到路径中。</li><li id="8473" class="lm ln iq jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated"><strong class="jp ir">目录</strong>:如果是目录，我们使用<code class="fe kx ky kz la b">childPath</code>作为参数递归调用<code class="fe kx ky kz la b">searchFiles</code>。</li></ul><p id="fd8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">循环结束后，我们可以返回<code class="fe kx ky kz la b">paths</code>值。</p><pre class="km kn ko kp gt lb la lc ld aw le bi"><span id="d7c3" class="lf lg iq la b gy lh li l lj lk">import { promises as fs } from 'fs'<br/>import path from 'path'<br/><br/>let paths: Array&lt;string&gt; = []<br/><br/>export async function searchFiles(folderName: string) {<br/>  const folderChildren = await fs.readdir(folderName)<br/>  <br/>  for(const child of folderChildren) {<br/>    const childPath = `${folderName}/${child}`<br/>    const childStats = await fs.lstat(childPath)<br/><br/>    if(childStats.isDirectory()) {<br/>      await searchFiles(childPath)<br/>    }<br/><br/>    if(childStats.isFile()) {<br/>      const fullPathToFile = path.resolve(childPath)<br/><br/>      paths = [...paths, fullPathToFile]<br/>    }<br/><br/>  }<br/><br/>  return paths<br/>}</span></pre><p id="a4b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成后，我们在<code class="fe kx ky kz la b">index.ts</code>上调用这个函数:</p><pre class="km kn ko kp gt lb la lc ld aw le bi"><span id="01f9" class="lf lg iq la b gy lh li l lj lk">import { searchFiles } from './files-searcher'<br/><br/>interface FilePathMapperOptions {<br/>  startDirectory: string<br/>}<br/><br/>export function filePathMapper({ startDirectory }: FilePathMapperOptions) {<br/>  searchFiles(startDirectory).then(console.log)<br/>}<br/><br/>filePathMapper({<br/>  startDirectory: 'src'<br/>})</span></pre><p id="5c55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您运行这段代码，您将看到给定文件夹的内容。</p><p id="28e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是基础，从中你可以写出更复杂的算法。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="d658" class="mh lg iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">按扩展名查找并获取文件内容</h1><p id="8ba0" class="pw-post-body-paragraph jn jo iq jp b jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">我们可以更进一步，接收我们想要的文件扩展名列表。</p><p id="6f11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是在我们继续之前，现在我们的外部API，也就是<code class="fe kx ky kz la b">filePathMapper</code>函数，只接受选项并直接传递给<em class="nj"> searchFiles </em>函数。filePathMapper函数对于在调用<em class="nj"> searchFiles </em>函数之前进行一些检查或解析非常有用，但是如果您愿意，您可以直接调用<em class="nj"> searchFiles </em>。</p><p id="b37c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，添加扩展选项，并记住保持它的可选性。</p><p id="0f9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">索引. ts </strong></p><pre class="km kn ko kp gt lb la lc ld aw le bi"><span id="90b0" class="lf lg iq la b gy lh li l lj lk">import { searchFiles } from './files-searcher'</span><span id="b183" class="lf lg iq la b gy ll li l lj lk">interface FilePathMapperOptions {<br/>  startDirectory: string<br/>  extensions?: string[]<br/>}</span><span id="72d6" class="lf lg iq la b gy ll li l lj lk">export function filePathMapper({ startDirectory, extensions }: FilePathMapperOptions) {<br/>  searchFiles(startDirectory, extensions).then(console.log)<br/>}</span><span id="d0ec" class="lf lg iq la b gy ll li l lj lk">filePathMapper({<br/>  startDirectory: 'src',<br/>  extensions: ['html']<br/>})</span></pre><p id="7118" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> files-searcher.ts </strong></p><pre class="km kn ko kp gt lb la lc ld aw le bi"><span id="824f" class="lf lg iq la b gy lh li l lj lk">import { promises as fs } from 'fs'<br/>import path from 'path'</span><span id="9f0a" class="lf lg iq la b gy ll li l lj lk">let paths: Array&lt;string&gt; = []</span><span id="17c4" class="lf lg iq la b gy ll li l lj lk">export async function searchFiles(folderName: string, extensions?: string[]) {<br/>  const folderChildren = await fs.readdir(folderName)<br/>  <br/>  for(const child of folderChildren) {<br/>    const childPath = `${folderName}/${child}`<br/>    const childStats = await fs.lstat(childPath)</span><span id="d115" class="lf lg iq la b gy ll li l lj lk">    if(childStats.isDirectory()) {<br/>      await searchFiles(childPath, extensions)<br/>    }</span><span id="4e23" class="lf lg iq la b gy ll li l lj lk">    if(childStats.isFile()) {<br/>      const extension = child.split('.').pop() || ''<br/>      const skipFile = extensions?.length<br/>        ? !extensions.includes(extension)<br/>        : false</span><span id="e94e" class="lf lg iq la b gy ll li l lj lk">      if(skipFile) continue</span><span id="6fd2" class="lf lg iq la b gy ll li l lj lk">      const fullPathToFile = path.resolve(childPath)</span><span id="c6cb" class="lf lg iq la b gy ll li l lj lk">      paths = [...paths, fullPathToFile]<br/>    }</span><span id="2325" class="lf lg iq la b gy ll li l lj lk">  }</span><span id="6dc3" class="lf lg iq la b gy ll li l lj lk">  return paths<br/>}</span></pre><p id="c930" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe kx ky kz la b">child.split('.').pop()</code>我们可以得到所有点之后的最后一个单词，这可能是文件扩展名，这就是为什么我们把<code class="fe kx ky kz la b">|| ''</code>放在表达式后面，如果没有文件扩展名，它将是一个空字符串。</p><p id="804f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有更好的方法来获得文件的扩展名，请留下评论，我将不胜感激。</p><p id="409f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这个扩展名，我们可以定义一个布尔值<code class="fe kx ky kz la b">skipFile</code>，它表示我们是否要从列表中跳过这个文件。</p><p id="7740" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样，如果你愿意，你甚至可以使用<code class="fe kx ky kz la b">fs.readFile</code>来收集文件的内容，在这种情况下，你将不得不存储一个带有路径和文件内容的对象:</p><pre class="km kn ko kp gt lb la lc ld aw le bi"><span id="527c" class="lf lg iq la b gy lh li l lj lk">const fullPathToFile = path.resolve(childPath)<br/>const fileContent = await fs.readFile(fullPathToFile)</span><span id="1e11" class="lf lg iq la b gy ll li l lj lk">paths = [<br/>  ...paths,<br/>  {<br/>    path: fullPathToFile,<br/>    data: fileContent<br/>  }<br/>]</span></pre><p id="31d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从现在开始，你可以添加任何你想要的新特性。</p><p id="0e23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们添加一个try/catch块来捕捉任何可能的错误，并设置它返回一个带有ok属性的对象，以显示该过程是否成功。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><h1 id="e3a0" class="mh lg iq bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">结论</h1><p id="e829" class="pw-post-body-paragraph jn jo iq jp b jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">这是一个简单的算法，我想为它创建一个NPM模块，但它太简单了，我想我会通过创建一个如何做的教程来提供更多帮助。我希望你喜欢它，任何问题留下评论。</p></div></div>    
</body>
</html>