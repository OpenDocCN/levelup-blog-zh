<html>
<head>
<title>Blue-Green with Canary Deployment — A Novel approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蓝绿色搭配金丝雀部署——一种新颖的方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/blue-green-with-canary-deployment-a-novel-approach-2cee77ff564d?source=collection_archive---------8-----------------------#2020-04-30">https://levelup.gitconnected.com/blue-green-with-canary-deployment-a-novel-approach-2cee77ff564d?source=collection_archive---------8-----------------------#2020-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6a64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，你没看错。我想谈谈金丝雀与蓝绿色的结合。</p><p id="39e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，我们看到的部署要么是淡黄色，要么是蓝绿色。在本文中，我想花点时间谈谈蓝绿与金丝雀部署的前景和可能性。我将使用AWS术语解释这篇文章。</p><p id="ca62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用的术语:</p><p id="9fa4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">a.docker——一个容器化的平台，用于构建映像并像容器一样运行代码</p><p id="0647" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">b.AWS集群——部署在EC2实例上的AWS服务的逻辑分组</p><p id="1b34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">c.AWS服务—负责由ECS管理的docker容器成功运行的任务。</p><p id="483a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们从基础开始:</p><blockquote class="ko"><p id="db1c" class="kp kq it bd kr ks kt ku kv kw kx kn dk translated"><strong class="ak">什么是蓝绿部署？</strong></p></blockquote><p id="c01b" class="pw-post-body-paragraph jq jr it js b jt ky jv jw jx kz jz ka kb la kd ke kf lb kh ki kj lc kl km kn im bi translated">蓝绿色部署是一种部署机制，其中并行设置了两个相同的堆栈(AWS集群),称为蓝色和绿色，其中只有一个堆栈接收活动流量(为此假设为蓝色),而另一个堆栈处于空闲状态。</p><p id="77fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着新的生产版本的推出，新的代码部署将在非活动的绿色集群上进行。一旦部署完成，我们看到环境是稳定的，所有docker容器都已启动并积极运行，经由路由53的流量现在被系统地从蓝色路由到绿色，从而使绿色成为新的活动集群，而将蓝色淘汰为非活动状态。</p><p id="d401" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法在无法承受停机时间的生产系统和被认为非常关键的应用程序中非常有效。如果由于任何不可预见的问题而需要回滚发布，那么将流量从绿色(新)反转为蓝色(旧)是很容易的，因为旧的堆栈随时可用。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/4b3672e9b07cf652b20af41868719074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxMKlnAhfkcQzNBS9vYcAg.jpeg"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">之前:蓝色为活动状态</figcaption></figure><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/2a3dd9543d5232ee72250b3773c94bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*130E16BvabhOId_UJ4T7Hw.jpeg"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">之后:绿色表示活动</figcaption></figure><p id="c6e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法的缺点是可维护性和成本。</p><p id="ab34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要维护两个集群(蓝色和绿色)，并且并行维护这两个集群，从而使我们的服务器成本显著翻倍(EC2s和ALB花费了大量资金)。</p><p id="cd3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">人们可能会质疑这样一个事实，即在大量观察新部署的稳定性之后，旧的集群可以被删除。这种方法是可行的，但是通常被认为是非常麻烦的，大多数人倾向于保留两个集群。</p><blockquote class="ko"><p id="5744" class="kp kq it bd kr ks kt ku kv kw kx kn dk translated"><strong class="ak">什么是金丝雀部署？</strong></p></blockquote><p id="b2ee" class="pw-post-body-paragraph jq jr it js b jt ky jv jw jx kz jz ka kb la kd ke kf lb kh ki kj lc kl km kn im bi translated">Canary部署是另一种类型的部署，在现有集群上使用新的docker容器进行新的部署(根据您的ASG策略，可能是新的EC2实例)。新的部署将有自己的ALB和自己的目标组。使用路由53，流量以递增的百分比转出给用户。</p><p id="fa08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">增量方法降低了它对真实客户产生影响的风险。</p><p id="2b8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦新的部署完成，流量就在节流的基础上被路由到新的容器。使用Route 53加权记录，我们可以调整流量，并决定只将10%的流量发送到使用新ALB的新容器。一旦事情看起来不错，我们可以定期增加重量，直到它达到100:0。使用这种方法，即使在节流过程中出现问题，我们也可以轻松地回滚到旧版本，并确保只有一小部分(这里是10个)用户受到新版本的影响。</p><p id="a0b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦验证结果良好，就需要删除旧容器和旧ALB(包括目标组),并确保整个流量现在被路由到指向新容器的新ALB。</p><p id="ab91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法对于不太重要的应用程序是可取的，因为我们正在限制可能受到影响的新用户的流量。由于没有旧集群的开销，成本显著降低。无需维护旧的ALB、旧的ECS群集或旧的实例，所有内容在验证后都会被清理。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/3049f3709fb68fda7f43db6c06904a46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BiH5M3pmZBitpatAOtyzPg.jpeg"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">金丝雀:在部署期间</figcaption></figure><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/c58b4295f8e861670a4f897ac0276c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GmyFPBeRcoBSi9ZAV3Lr1A.jpeg"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">部署后的金丝雀</figcaption></figure><p id="5290" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种方法的一个主要问题是回滚。尽管我们在软件开发生命周期中采取了所有的验证和预防措施，但是在一段规定的时间后，系统仍有可能不稳定，代码中的新特性也会突然出现。</p><p id="78b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例子包括:</p><p id="f6d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">I .内存泄漏——不要让我开始讨论这个问题，因为没有直接的方法来解决内存泄漏问题。内存泄漏可能有多种原因，通常需要几天时间来识别和解决内存泄漏问题。在此过程中，当新版本中的问题得到修复时，您可能希望回滚到旧版本。我们不能在Canary中这样做，因为旧版本已被删除。</p><p id="9df9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">二。弹性问题—区域隔离导致的连接故障以及一个区域的服务器相对于另一个区域的故障是一个常见问题。尽管有自动故障转移功能，但连接性和弹性有时会是个问题。</p><p id="9e7f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">三。客户对该功能不满意——这可能是一种罕见的情况，但结果可能是发布的新功能没有满足客户的期望，这可能会促使我们立即回滚到旧版本。</p><p id="01ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，临时的解决方案是什么呢:构建和部署旧版本的代码，并重新经历旧版本的整个管道和发布过程(批准和可怕的繁文缛节)。如果定期发布新功能，这个过程可能会很乏味。</p><blockquote class="ko"><p id="3247" class="kp kq it bd kr ks kt ku kv kw kx kn dk translated">那么，蓝绿搭配金丝雀是怎么回事呢？</p></blockquote><p id="e794" class="pw-post-body-paragraph jq jr it js b jt ky jv jw jx kz jz ka kb la kd ke kf lb kh ki kj lc kl km kn im bi translated">我在这里的想法是提供一个简单的解决方案，我试图将两个部署过程合二为一。</p><blockquote class="lt lu lv"><p id="6555" class="jq jr lw js b jt ju jv jw jx jy jz ka lx kc kd ke ly kg kh ki lz kk kl km kn im bi translated">你会问，我们如何做到这一点</p></blockquote><p id="e951" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Canary部署完成后，不要删除旧的ALB和EC2实例。这样我们就模仿了蓝绿色模型，但是在同一个集群中使用了金丝雀模型。</p><p id="ac47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">保留旧的服务(容器)将帮助我们立即实现回滚，并帮助我们快速实现我们想要的。</p><p id="b3a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一步还将帮助我们减少维护额外的非活动集群的开销，对于纯蓝绿色模式，我们认为这种开销非常昂贵。</p><p id="0916" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管如此，我们仍然有一个EC2实例闲置的问题，旧的docker容器仍然在我们的钱包里。我们需要通过适当地调整我们的自动伸缩组和docker容器的内存分配来解决这个问题，并在一个EC2实例中挤进尽可能多的容器。</p><p id="b2f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不会在这里给出确切的数字，但出于一个想法的目的，我们可以考虑这个场景:</p><p id="850d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为实例保留20%的内存缓冲区，如果我们需要3个具有30%内存的docker容器，那么我们需要2个EC2实例，其中一个具有2个分配了60% + 20%(缓冲区)内存的docker容器，另一个EC2实例分配了30% + 20%(缓冲区)。因此，我们总共为2个EC2实例付费(纯粹的金丝雀方法)</p><p id="1121" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的解决方案:如果我们可以将docker内存减少到24%，那么我们将在一个EC2实例中分配72% + 20%(缓冲区)的内存，现在我们可以使用另一个EC2实例来托管旧代码，并将其压缩到同一个集群中。</p><p id="72d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是我上面给出的一个例子，你需要根据你的要求进行相应的微调。</p><p id="0e97" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望我的这篇文章有助于理解各种部署模型。快乐编码..！！</p><p id="cc5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这篇文章，请尽可能多地在页面底部拍手。它鼓励我写更多。</p></div></div>    
</body>
</html>