<html>
<head>
<title>Getting familiar with Redux concepts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熟悉Redux概念</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-familiar-with-redux-concepts-5de7a884cda7?source=collection_archive---------0-----------------------#2019-09-15">https://levelup.gitconnected.com/getting-familiar-with-redux-concepts-5de7a884cda7?source=collection_archive---------0-----------------------#2019-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d42c601813c3e26fc12b0a11d636d582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wPhDTFYUFC7QD-2E"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@samuelzeller?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">塞缪尔·泽勒</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="7b28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Redux是一个众所周知的状态管理库，经常在React应用程序中使用。从Redux开始，有很多名字和概念被抛来抛去。这篇文章旨在揭开这些名字和概念的神秘面纱，帮助你更快地学习Redux。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="1f00" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">一般概念</h1><p id="bde0" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们先来看一些一般概念。</p><h2 id="4fc9" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">应用程序状态与组件状态</h2><p id="43f4" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">国家通常分为两类。应用程序状态和组件状态。Redux应该处理应用程序状态。那么这几种状态之间有什么区别呢？</p><h2 id="1a38" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">组件状态</h2><p id="03b8" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">组件状态是组件用于按预期工作的状态。下拉菜单可能有一个名为<code class="fe mx my mz na b">isExpanded</code>的变量。组件维护这种状态，不需要与其他组件共享这种状态。组件仅使用它来知道下拉列表是可见的还是隐藏的。</p><h2 id="86b3" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">应用状态</h2><p id="621b" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">应用程序状态是使应用程序工作的状态。在待办事项列表应用程序中，待办事项将是应用程序状态的一部分。</p><h2 id="24f2" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">不变</h2><p id="380a" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">不变性意味着数据不应该被修改，而是制作该数据的副本并用新值交换旧值。例如，如果一个对象有一些值，不要只修改需要改变的值。使用当前对象，并用新值代替旧值创建一个新对象。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="128c" class="ml lj iq na b gy nj nk l nl nm">const obj = { <br/>  firstname: 'John', <br/>  surname: 'Foe' <br/>}</span><span id="b3a6" class="ml lj iq na b gy nn nk l nl nm">const newObj = { <br/>  ...obj,<br/>  surname: 'Doe'<br/>}</span></pre><h2 id="c804" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">支柱钻井</h2><p id="df89" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">当React组件具有需要一些数据子组件时，会发生正确的钻取。数据通常位于顶层组件中，并通过props发送给子组件，这没什么问题，这就是React的工作方式。不利的一面是，不需要道具的组件能够将它们传递得更远。</p><h1 id="3189" class="li lj iq bd lk ll no ln lo lp np lr ls lt nq lv lw lx nr lz ma mb ns md me mf bi translated">重复概念</h1><p id="202a" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">有一些Redux概念也是很好的了解。</p><h2 id="a182" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">还原剂</h2><p id="20fe" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在使用Redux时，Reducers是您经常会与之交互的东西。这是一个更新应用程序状态的switch语句。可以有一个以上的减速器。这是一个减速器的例子:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="393b" class="ml lj iq na b gy nj nk l nl nm">const initialState = {<br/>  todos: [],<br/>}</span><span id="bd4e" class="ml lj iq na b gy nn nk l nl nm">export default (state = initialState, action) =&gt; {<br/>  switch (action.type) {<br/>    case 'CREATE_TODO':<br/>      return {<br/>        ...state,<br/>        todos: [<br/>          ...state.todos, <br/>          action.data<br/>        ]<br/>      }<br/>    default: <br/>      return state<br/>  }<br/>}</span></pre><p id="482e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">状态是不可变的。这是一个很好的实践，对于React和Redux跟踪状态变化是必要的。</p><h2 id="4c91" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">行动</h2><p id="71c8" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">动作用于对Redux状态进行更改。动作是发送给缩减器的对象。该对象包含一个<code class="fe mx my mz na b">type</code>属性和一个<code class="fe mx my mz na b">data</code>的有效负载。类型用在开关中，决定将要发生什么，数据是我们想要添加到新状态的数据。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="c7e2" class="ml lj iq na b gy nj nk l nl nm">const addTodo = data =&gt; ({<br/>  type: 'CREATE_TODO', <br/>  data: { <br/>    ...data, <br/>    isCompleted: false<br/>  }<br/>});</span></pre><p id="5552" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里重要的一点是，<code class="fe mx my mz na b">addTodo</code>将无法与Redux通信，直到它被包装在Redux dispatch-function中。稍后会有更多的介绍。</p><h2 id="c70c" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">动作类型</h2><p id="2000" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">动作类型是上述动作中使用的类型。我通常把它们和常量字符串放在一个文件里，这样更容易重用。代码看起来会像这样:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="29e3" class="ml lj iq na b gy nj nk l nl nm">export const CREATE_TODO = 'CREATE_TODO';<br/>export const DELETE_TODO = 'DELETE_TODO';<br/>export const EDIT_TODO   = 'EDIT_TODO';</span></pre><h2 id="3148" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">选择器</h2><p id="286b" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">选择器是一个用来获取某种状态的函数。这或多或少是一个接受对象(状态对象)并返回特定属性的函数。如果我们要编写一个选择器来从上面的对象中获取姓氏，它看起来会像这样:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="b8fc" class="ml lj iq na b gy nj nk l nl nm">const applicationState ={ <br/>  firstname: 'John', <br/>  surname: 'Doe' <br/>}</span><span id="e036" class="ml lj iq na b gy nn nk l nl nm">const selectSurname = state =&gt; state.surname</span><span id="e510" class="ml lj iq na b gy nn nk l nl nm">selectSurname(applicationState)</span></pre><h2 id="854b" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">商店</h2><p id="ab9e" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">存储区是保存应用程序状态的地方。等店搭好了，就不用想这么多了。知道商店持有状态是件好事。一个基本的商店是这样的:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="c42e" class="ml lj iq na b gy nj nk l nl nm">import { <br/>  createStore, <br/>  applyMiddleware, <br/>  compose, <br/>  combineReducers<br/>} from 'redux';<br/>import thunk from 'redux-thunk';<br/>import todoReducer from 'from/some/file'</span><span id="8285" class="ml lj iq na b gy nn nk l nl nm">const rootReducer combineReducers({<br/>  todoReducer<br/>});</span><span id="04c6" class="ml lj iq na b gy nn nk l nl nm">export default function configureStore(initialState = {}) {<br/>  return createStore(<br/>    rootReducer,<br/>    initialState,<br/>    compose(applyMiddleware(thunk))<br/>  );<br/>}</span></pre><p id="0b5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有多个减速器，则使用<code class="fe mx my mz na b">combineReducers</code>功能。</p><h1 id="b39c" class="li lj iq bd lk ll no ln lo lp np lr ls lt nq lv lw lx nr lz ma mb ns md me mf bi translated">反应还原</h1><p id="55b8" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">当Redux与React一起使用时，通常会使用一个名为<code class="fe mx my mz na b">react-redux</code>的库。这使得Redux的使用变得更加容易。</p><h2 id="80f1" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">连接</h2><p id="ddb7" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">这是一种用于将组件连接到Redux的方法。要使用它，请在connect函数中包装组件的导出。connect函数返回一个函数，所以一开始看起来有点奇怪，下面是一个例子:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="0ba7" class="ml lj iq na b gy nj nk l nl nm">export default connect()(myComponent)</span></pre><p id="299f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">连接函数可以接受两个参数，<code class="fe mx my mz na b">mapStateToProps</code>和<code class="fe mx my mz na b">mapDispatchToProps</code>。有了这些参数，函数将如下所示:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="cab9" class="ml lj iq na b gy nj nk l nl nm">export default connect(<br/>  mapStateToProps,<br/>  mapDispatchToProps<br/>)(myComponent)</span></pre><p id="a6f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么这些论点是什么呢？</p><h2 id="6bd3" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">mapStateToProps</h2><p id="4291" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated"><code class="fe mx my mz na b">mapStateToProps</code>是将Redux状态映射到传递给组件的props的一种方式。如果属性是嵌套的，并且有点复杂，那么选择器是有用的。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="c037" class="ml lj iq na b gy nj nk l nl nm">const mapStateToProps = (state) =&gt; {<br/> const { todos } = state<br/> return { todos } <br/>}</span></pre><h2 id="13c9" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">mapDispatchToProps</h2><p id="005a" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated"><code class="fe mx my mz na b">mapDispatchToProps</code>是传递应该与Redux对话的函数的地方。这些功能可以从props中获得。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="b051" class="ml lj iq na b gy nj nk l nl nm">const mapDispatchToProps = dispatch =&gt; {<br/>  return {<br/>    addTodo: todo =&gt; dispatch({<br/>      type: 'ADD_TODO',<br/>      data: todo <br/>    })<br/>  }<br/>}</span></pre><p id="00dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象<code class="fe mx my mz na b">{ type: ‘ADD_TODO’, data: todo }</code>是一个动作。<code class="fe mx my mz na b">type</code>属性是动作类型。这可以被包装在一个叫做<code class="fe mx my mz na b">addTodo</code>的函数中。这叫做动作创建器，一个返回动作的函数。</p><p id="e3ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这些例子中，类型<code class="fe mx my mz na b">'ADD_TODO'</code>是一个字符串。这应该是常量，所以我们不会拼错。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="9fad" class="ml lj iq na b gy nj nk l nl nm">import { ADD_TODO } from 'from/some/file'</span><span id="e81d" class="ml lj iq na b gy nn nk l nl nm">const addTodo = todo =&gt; return ({ <br/>  type: ADD_TODO, <br/>  data: todo <br/>})</span><span id="e28b" class="ml lj iq na b gy nn nk l nl nm">export actions { addTodo }</span></pre><p id="4527" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者更好:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="fa9f" class="ml lj iq na b gy nj nk l nl nm">import { actions } from 'from/some/file'</span><span id="79c0" class="ml lj iq na b gy nn nk l nl nm">const addTodo = todo =&gt; return (actions.addTodo(todo))</span></pre><p id="38f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Redux连接的组件看起来像这样:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="1857" class="ml lj iq na b gy nj nk l nl nm">const TodoListContainer = ({todos, addTodo}) =&gt; {<br/> return (<br/>    &lt;TodoList <br/>      todos={todos} <br/>      addTodo={addTodo}<br/>    /&gt;<br/>  )<br/>}</span><span id="2924" class="ml lj iq na b gy nn nk l nl nm">const mapStateToProps = state =&gt; {<br/>  const { todos } = state<br/>  return {<br/>    todos<br/>  }<br/>}</span><span id="0e2f" class="ml lj iq na b gy nn nk l nl nm">const mapDispatchToProps = dispatch =&gt; ({<br/>  addTodo: todo =&gt; dispatch({<br/>    type: 'ADD_TODO', <br/>    data: todo, <br/>    isCompleted: false<br/>  }),<br/>})</span><span id="32f2" class="ml lj iq na b gy nn nk l nl nm">export default connect(<br/>  mapStateToProps,<br/>  mapDispatchToProps<br/>)(TodoListContainer);</span></pre><p id="28f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，使用了一个容器组件。如果你想了解更多关于这个模式的信息，我建议你<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/container-and-presentational-components-in-react-c56aca7713ba">阅读这篇文章</a>。</p><h2 id="5988" class="ml lj iq bd lk mm mn dn lo mo mp dp ls ko mq mr lw ks ms mt ma kw mu mv me mw bi translated">概括起来</h2><p id="ccf4" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">Redux是一个优秀的状态管理工具。在幕后，Redux还有助于提高性能，例如组件的重新渲染。除了我在这篇文章中提到的，还有更多可以重复的。如果你想了解更多，那么<a class="ae kc" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux网站</a>是一个很好的起点。这篇文章旨在解释Redux中使用的概念和名称，我希望你从中有所收获。</p><p id="3665" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还建议你检查一下Redux挂钩<code class="fe mx my mz na b">useDispatch</code>和<code class="fe mx my mz na b">useSelector</code>，这会使代码更干净。</p><p id="8301" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有兴趣看看Redux是如何用React设置的，我推荐你阅读<a class="ae kc" href="https://medium.com/@vikingjonsson/setup-react-with-redux-96dc91944644" rel="noopener">这篇文章。</a></p><p id="73a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>