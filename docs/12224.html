<html>
<head>
<title>Design Patterns in Python: Singleton Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的设计模式:单例模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-in-python-singleton-pattern-f76dc26281f8?source=collection_archive---------7-----------------------#2022-05-24">https://levelup.gitconnected.com/design-patterns-in-python-singleton-pattern-f76dc26281f8?source=collection_archive---------7-----------------------#2022-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b353" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python中Singleton设计模式的实现</h2></div><p id="6820" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单体设计模式是创造性设计模式之一。从单例类中只能创建一个对象。这是这种设计模式最显著的特点。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/3afed31abe2512b97ac58c826fdad45f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOYS9mojZJkysyfNoYKXsg.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@callmehangry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae lr" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上叫我hangry 🇫🇷 </a></figcaption></figure><h2 id="bb9d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">创造性的设计模式</h2><p id="6049" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">对象创建是基于OOP的系统中最常见的任务之一。这是一个昂贵的过程。一个对象与其他对象的关系、对象的任务、考虑可重用性的因素、对象所处的状态及其对这些状态的反应等等。，使该对象的结构变得复杂。因此，大多数时候，对象创建过程是<strong class="kh ir">而不是</strong>一个只能留给构造函数的过程。</p><p id="5382" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创造设计模式解决了两个问题:<strong class="kh ir">在哪里</strong>创建对象和<strong class="kh ir">如何</strong>创建对象。对象创建是抽象的，它们使过程更简单。</p><p id="661f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单例模式包含在创造性模式中。然而，它具有不同于其他创作模式的结构，在某些方面不同于其他模式。根据一些大师的说法，它被认为是一种反模式。</p><h1 id="e228" class="mq lt iq bd lu mr ms mt lx mu mv mw ma jw mx jx md jz my ka mg kc mz kd mj na bi translated">一个</h1><p id="c310" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">单例类只生成一个对象，这个对象是全局访问点。只能派生一个对象是一个约束，它阻止了类在其他地方被随机生成。这样就不会产生其他对象，所有系统部件都访问并使用唯一的现有对象。</p><p id="478d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文献中大量遇到的一个类比将这种设计模式比作一个国家的政府。一个国家只有一个政府，这个政府可以被这个国家的所有设备接入，而且这个接入肯定是对真正的政府。因此，无论何时我们想与政府联系，我们都能确保与真正的、唯一的政府联系。</p><p id="91e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单例设计模式违背了单一责任原则。因此，在决定其用途时，应考虑到这一点。</p><div class="nb nc gp gr nd ne"><a href="https://towardsdev.com/solid-principles-explained-635ad3608b20" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">解释了坚实的原则</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">用Python语言举例说明坚实的原理</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdev.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ll ne"/></div></div></a></div><h2 id="d39e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma ko mb mc md ks me mf mg kw mh mi mj mk bi translated">用例</h2><p id="1e5c" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">这种模式通常可以用在管理系统的对象上。文件系统或窗口管理器、缓存系统或管理数据库连接的单个数据库对象。</p><p id="bd8a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也可以用于“助手”类。它是许多不同工作的静态中心。同样，它也可以用作日志记录器(最常见的例子)。</p><p id="887d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住，单例对象是全局可访问的。所以我们可以用Singleton来代替定义全局变量。</p><h1 id="6da2" class="mq lt iq bd lu mr ms mt lx mu mv mw ma jw mx jx md jz my ka mg kc mz kd mj na bi translated">编码</h1><p id="b195" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">有多种方法可以在Python中实现单例设计模式。这里就不一一提及了，只展示我喜欢和使用的方法。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="63d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们检查这个类实现的逐行结构。</p><p id="9497" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我使用前缀下划线来命名该类，以表明它是特殊的:<em class="nv"> _Singleton </em>。</p><p id="4a8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nv"> __instance </em>是一个与类本身相关联的类变量。它跟踪该类是否已经被创建。</p><p id="5e9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nv"> __inited </em>用于消除Python中由于<em class="nv"> __init__ </em>构造函数带来的类初始化副作用。<em class="nv"> __init__ </em>在<em class="nv"> __new__ </em>构造函数运行后重新运行。因此，即使我们得到了相同的对象，因为它被重新初始化，每次我们调用这个单例类时，<em class="nv"> self.value </em>参数将等于10。想象一下，你把<em class="nv"> self.value </em>参数操纵成别的东西，由于<em class="nv"> __init__ </em>副作用，你每次调用class都会把它的值重新设置成10。通过检查它的初始化，我们消除了这个副作用。所以，我添加了一个方法来操作该值，并移除了<em class="nv"> __inited </em>来演示这个副作用。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nw"><img src="../Images/382facfeb1d486327a5eb340a2ddaffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5HcrN35Fj37ze2mDL7QBqw.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片作者。</figcaption></figure><pre class="lc ld le lf gt nx ny nz oa aw ob bi"><span id="5ab6" class="ls lt iq ny b gy oc od l oe of">s1 = _Singleton()<br/>print(s1.value) <strong class="ny ir">#10</strong><br/>s1.manipulate_value()<br/>print(s1.value)<strong class="ny ir"> #20</strong><br/>s2 = _Singleton()<br/>print(s1 == s2) <strong class="ny ir">#True --&gt; same object</strong><br/>print(s1.value) <strong class="ny ir">#10 --&gt; it is reset to 10</strong><br/>print(s2.value) <strong class="ny ir">#10</strong></span></pre><p id="0dec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nv"> __new__ </em>方法是另一种Pythonic式的构造函数。每当我们创建一个对象时都会调用它。在<em class="nv"> __init__ </em>方法之前调用。这个类给自己作为一个引用<em class="nv"> (cls) </em>。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi og"><img src="../Images/0086ac0fff371b48d7634b3d1a66af46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xbl_JAqaSlbJWBUfFfPTDA.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片由作者提供。</figcaption></figure><p id="8eab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果实例仍然是<em class="nv"> None </em>这意味着它仍然不存在，那么将通过调用基类来创建它。它为我们创建了一个单例，并返回实际的实例。</p><p id="0340" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="nv"> __init__ </em>构造函数中，我们检查Singleton之前是否初始化过。如果是这样，我们返回它，因此，它不操纵属性，并保持它们不变。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oh"><img src="../Images/4638dc26d7e80fc2cb2e336889db8dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fmB22eewVQgIfSCeqtRo0A.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片作者。</figcaption></figure><pre class="lc ld le lf gt nx ny nz oa aw ob bi"><span id="c506" class="ls lt iq ny b gy oc od l oe of">s1 = _Singleton()<br/>print(s1) #&lt;__main__._Singleton object at 0x7fcea840efd0&gt;<br/>s2 = _Singleton()<br/>print(s2) #&lt;__main__._Singleton object at 0x7fcea840efd0&gt;</span></pre><p id="e61f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读。如果您有任何问题或意见，请随时写信给我！</p><h1 id="9804" class="mq lt iq bd lu mr ms mt lx mu mv mw ma jw mx jx md jz my ka mg kc mz kd mj na bi translated">下一集:</h1><div class="nb nc gp gr nd ne"><a href="https://medium.com/@okanyenigun/design-patterns-in-python-factory-pattern-beea1da31c17" rel="noopener follow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">Python中的设计模式:工厂模式</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">工厂模式在Python中的实现</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">medium.com</p></div></div><div class="nn l"><div class="oi l np nq nr nn ns ll ne"/></div></div></a></div><h1 id="cf8d" class="mq lt iq bd lu mr ms mt lx mu mv mw ma jw mx jx md jz my ka mg kc mz kd mj na bi translated">阅读更多内容…</h1><div class="nb nc gp gr nd ne"><a href="https://towardsdev.com/solid-principles-explained-635ad3608b20" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">解释了坚实的原则</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">用Python语言举例说明坚实的原理</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdev.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ll ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a href="https://python.plainenglish.io/data-classes-abstraction-interfaces-in-python-ea107d235d3e" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">Python中的数据类、抽象和接口</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">Python中的抽象、接口和其他类概念</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">python .平原英语. io</p></div></div><div class="nn l"><div class="oj l np nq nr nn ns ll ne"/></div></div></a></div></div></div>    
</body>
</html>