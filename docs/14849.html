<html>
<head>
<title>Testing Microservices: Challenges and Solutions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试微服务:挑战和解决方案</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/testing-microservices-challenges-and-solutions-9e64a3c46c83?source=collection_archive---------11-----------------------#2022-12-28">https://levelup.gitconnected.com/testing-microservices-challenges-and-solutions-9e64a3c46c83?source=collection_archive---------11-----------------------#2022-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/aa5b1c75ee91b7d4980c8a590d6f99b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-t2vVhzaUODjUk8Rd0facw.jpeg"/></div></div></figure><p id="f0c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当编写和运行新的后端测试时，向分布式环境的过渡已经产生了复杂性、开销和摩擦。</p><p id="c36f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些测试需要大量的准备工作、基础设施建设和维护，因为许多服务是异步通信的，它们经常会遗漏系统架构“更深层次”上抛出的异常，并且很难使其可测试。</p><p id="583e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇博客中，我想展示通过运行基于跟踪的自动化测试，您可以几乎不费吹灰之力地通过健壮的测试来验证您的数据。下面是如何做到这一点。</p><h1 id="df98" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">分布式环境中的后端测试</h1><p id="93cd" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">今天分布式后端的测试是什么样的？下面的流程描绘了一个典型的金融交易app的痕迹。如您所见，有许多组件相互依赖。</p><p id="982d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有两个卡夫卡专题，还有Postgres，Dynamo DB，第三方API，五个微服务。任何服务中的任何代码更改都可能并且经常会影响多个其他服务。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/1ef8c2b66829565d15a3b8e1630b4848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-0ml0D_pneDOUlmL.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">使用Helios的典型微服务应用程序的踪迹</figcaption></figure><p id="13d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这是一个整体，失败将简单地从服务器返回一个HTTP 500状态代码。但是在这种微服务架构中，您可能会从BFF(后端对前端)微服务获得200，而该异常仍然会在另一个微服务上引发，而您不会收到任何有关它的指示。</p><h1 id="d342" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">开发人员通常如何为微服务构建测试自动化基础设施</h1><p id="da4a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">假设我们想要测试下面的用例。他们都是后端e2e快乐流的一部分。</p><ol class=""><li id="c4fd" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">每次POST请求到达“存款”端点时，我们都会检查电子邮件是否通过SES发送给客户。</li><li id="06c5" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">确保客户端已付费，并且条带调用成功。</li></ol><p id="8e46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有几种方法可以为这两种场景构建测试自动化。</p><h1 id="847a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">1.基于日志的测试</h1><p id="1ee2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">假设开发人员为每个操作添加了日志，我们可以从这些服务中获取日志，并验证相关数据是否存在。</p><p id="30e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如:</p><pre class="ma mb mc md gt mw mx my bn mz na bi"><span id="4b2c" class="nb kx iq mx b be nc nd l ne nf">class OrderTest(unittest.TestCase):<br/>   def test_process_order_happy_flow(self):<br/>       with self.assertLogs('foo', level='INFO') as cm:<br/>           requests.get(f'/process_order/{TEST_CLIENT_ID}')<br/>           self.assertEqual(<br/>               cm.output,<br/>               [f'INFO:send email to {TEST_CLIENT_ID}',<br/>                f'INFO:Charge {TEST_CLIENT_ID} succeeded!']<br/>           )</span></pre><p id="f233" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法有哪些挑战？</p><ol class=""><li id="4858" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">我们假设开发人员添加了日志，但这并不总是正确的。</li><li id="14c4" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">我们只能验证日志中写入的数据。例如，如果日志中没有写入请求的有效负载，就不能对它们进行验证。</li><li id="87e1" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">我们将日志和测试结合起来——这听起来是创建易变测试的完美方式。</li><li id="e732" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">我们只测试操作的日志，而不是操作本身。结果我们不知道手术是否成功。</li></ol><h1 id="5a19" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">2.数据库查询</h1><p id="2188" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">通过将操作指示保存在DB中，可以在测试期间查询DB以验证它是否存在。</p><pre class="ma mb mc md gt mw mx my bn mz na bi"><span id="8090" class="nb kx iq mx b be nc nd l ne nf">class OrderTest(unittest.TestCase):<br/>    def test_process_order_happy_flow(self):<br/>        requests.get(f'/process_order/{TEST_CLIENT_ID}')<br/>        client = Client.get_by_id(TEST_CLIENT_ID)<br/>        assert client.charged_successfully is True<br/>        assert client.email_sent is True</span></pre><p id="0625" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">这种方法有什么挑战？</strong></p><ol class=""><li id="536d" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">我们需要将数据库暴露给测试项目，这有时需要繁重的工作。</li><li id="b544" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">我们需要为测试设计数据库，这是过度工程化的，不是我们工作的重点，这使它成为一件奇怪的事情。</li><li id="23c8" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">我们将DB模型与测试相结合，这在逻辑上是错误的。</li><li id="0ed6" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">同样，就像前面的日志解决方案一样，我们测试的是DB对象更新操作，而不是实际的操作，这是完全错误的，不能检测任何真正的问题。</li></ol><p id="bffa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些测试解决方案只是分布式应用程序奇怪测试解决方案的冰山一角。</p><h1 id="9376" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">我们如何执行后端测试</h1><p id="1ed6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在<a class="ae ng" href="https://gethelios.dev/?utm_source=Medium&amp;utm_medium=External%20Blog&amp;utm_campaign=Testing%20microservices" rel="noopener ugc nofollow" target="_blank"> Helios </a>，我们使用<a class="ae ng" href="https://gethelios.dev/blog/trace-based-testing-modern-testing-for-the-modern-infrastructure/?utm_source=Medium&amp;utm_medium=External%20Blog&amp;utm_campaign=Testing%20microservices" rel="noopener ugc nofollow" target="_blank">基于痕迹的测试</a>。跟踪启用了一种新的测试类型，因为它们允许我们看到在我们的分布式系统中由单个操作触发的所有操作。这使得处理每一个操作变得容易，把它看作整体的一部分，而不是一个单独的动作。</p><p id="791b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，与日志不同，跟踪可以自动创建，开发人员不必决定在哪里插入它们。</p><p id="7b58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">跟踪的构造块是一个<strong class="ka ir">跨度</strong>(你可以在这里阅读更多关于那个<a class="ae ng" href="https://gethelios.dev/a-trace-visualization-worth-a-thousand-words/" rel="noopener ugc nofollow" target="_blank">)。跨度是应用程序中两个组件之间的交互。跨度允许我们在测试时回顾我们想要验证的属性。</a></p><p id="8363" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此:</p><ul class=""><li id="be6c" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv nh mo mp mq bi translated">您不需要创建测试基础设施来暴露他们系统中“内层”的接口。</li><li id="61f8" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv nh mo mp mq bi translated">您可以创建有意义的测试，而无需完全理解系统及其运行方式。</li><li id="0d5d" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv nh mo mp mq bi translated">跨多个服务查看应用程序中的各种流是非常容易的。</li><li id="890c" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv nh mo mp mq bi translated">如果开发人员在产品中发现了bug的痕迹，他们可以直接从bug中创建测试。这是一个范例的实现，它说“创建测试，使你避免你发现的每一个bug”。</li></ul><h1 id="0120" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">如何使用轨迹和跨度进行测试</h1><p id="2616" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在下一节中，我将展示我们如何使用Helios自动生成测试代码。你可以在这里免费试用一下<a class="ae ng" href="https://app.gethelios.dev/get-started?utm_source=Medium&amp;utm_medium=External%20Blog&amp;utm_campaign=Testing%20microservices" rel="noopener ugc nofollow" target="_blank"/>，只需按照下面的说明操作。如果你不想安装它，你可以从使用<a class="ae ng" href="https://sandbox.gethelios.dev/services?_gl=1*nl93kp*_ga*MTczMjE2NDc4Ni4xNjY4NDk3MDY0*_ga_PPRBERX8V9*MTY3MTYyNzUzOS4yNy4xLjE2NzE2MzAyNTQuMjkuMC4w&amp;from=20-12-22_15-44-33&amp;to=21-12-22_23-59-59&amp;utm_source=Medium&amp;utm_medium=External%20Blog&amp;utm_campaign=Testing%20microservices" rel="noopener ugc nofollow" target="_blank">沙箱</a>开始。</p><p id="430f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦安装完毕，自动仪器SDK就会自动创建跨度，这是基于<a class="ae ng" href="https://opentelemetry.io/" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry </a>的。<br/> <a class="ae ng" href="https://gethelios.dev/opentelemetry-otel-is-opening-new-possibilities-for-developers/" rel="noopener ugc nofollow" target="_blank"> OpenTelemetry </a> (OTel)，是一个开源解决方案，提供了一系列SDK、API和工具，用于收集和关联来自云本地分布式系统中不同交互的遥测数据。</p><p id="9281" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过spans，它收集系统中两个组件之间每个通信的所有有效负载，即每个请求和响应。有了这个功能，您可以构建健壮的测试，而无需更改任何代码行。</p><p id="d938" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是之前用例的代码，基于跟踪自动生成:</p><pre class="ma mb mc md gt mw mx my bn mz na bi"><span id="07b4" class="nb kx iq mx b be nc nd l ne nf">def test_by_helios():<br/>   requests.post(URL, headers=HEADERS, json=DATA)<br/>   http_post_spans = test_trace_manager.find_spans(<br/>       service=CHARGE_SERVICE_NAME,<br/>       operation=CHARGE_SPAN_OPERATION,<br/>       span_selectors=STRIPE_SPAN_SELECTORS<br/>   )<br/>   assert <br/>   http_post_spans, 'HTTPS POST in accounts-service did not occur'<br/>   <br/>   ses_send_spans = test_trace_manager.find_spans(<br/>       service=SES_SERVICE_NAME,<br/>       operation=SES_SPAN_OPERATION,<br/>       span_selectors=SES_SPAN_SELECTORS<br/>   )<br/>   assert <br/>   ses_send_spans, 'aws.ses.sendEmail in emails-service did not occur'</span></pre><p id="d4e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意[test _ trace _ manager . find _ spans(…)]方法。这种方法允许开发人员基于特定跟踪中发生的跨度来编写测试。这使得任何人，不管他们的代码经验如何，都可以生成后端自动化测试。</p><h1 id="bf73" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">生成基于跟踪的测试</h1><p id="0bc1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">要从Helios应用程序中的跟踪生成测试，您可以将模式从view更改为test，然后为每个span设置一个验证检查点。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/8051ad28e006a3eec2c56320200de37d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ActBL60tX5KTK1lF.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">将模式从“查看”切换到“测试”</figcaption></figure><p id="f0d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您还可以配置每个验证检查点，并选择它们要验证的内容。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/f4714ba84e4e3f88a60537d2f16b8403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1MaWpgooPenHbyWi.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">定制属性和有效负载，为各种流生成精确的测试</figcaption></figure><p id="62d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，他们可以生成测试代码，并将其导出到任何支持的语言。</p><p id="c03a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是自动生成的测试的样子:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/40d85b2fed454caed23e46bbf3d5ec06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7dXcsZ1V-d3WgsdK.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">使用Helios自动生成的测试代码</figcaption></figure><p id="8f7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以实现根据bug创建测试的已知方法。此外，使用trace visualization工具——您现在可以从一个跟踪中可视化地创建一个测试，这是后端测试领域中的一个游戏规则改变者。</p><p id="6af0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的阅读，请随时评论和询问以下任何问题。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="812a" class="kw kx iq bd ky kz ns lb lc ld nt lf lg lh nu lj lk ll nv ln lo lp nw lr ls lt bi translated">分级编码</h1><p id="b200" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="d681" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv nh mo mp mq bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="92eb" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv nh mo mp mq bi translated">📰查看<a class="ae ng" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="dab4" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv nh mo mp mq bi translated">🔔关注我们:<a class="ae ng" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ng" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ng" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="cdfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">🚀👉<a class="ae ng" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>