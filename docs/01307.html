<html>
<head>
<title>Random .NET Facts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">随机的。净事实</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/random-net-facts-79e4d3fd16e2?source=collection_archive---------8-----------------------#2019-12-13">https://levelup.gitconnected.com/random-net-facts-79e4d3fd16e2?source=collection_archive---------8-----------------------#2019-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="aa02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一页上，你会发现一堆与C#和。总的来说是网络。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/35247c024544a485b89ee843b91d0d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JE_X0zpWsRZVs3rN"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">帕特里克·托马索在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="2122" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">系统。ValueType是引用类型！</h1><p id="9b7c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">CLR基于以下标准区分值类型和引用类型:</p><blockquote class="mf mg mh"><p id="ed27" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">值类型是从<code class="fe mm mn mo mp b">System.ValueType</code>派生的类型</p></blockquote><p id="1a14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，<code class="fe mm mn mo mp b">System.ValueType</code>是一个引用类型。</p><h1 id="6490" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">垃圾收集何时发生？</h1><p id="a12e" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">当0代满的时候。</p><h1 id="4f10" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">具有终结器的对象可以保证至少到达第一代</h1><p id="c123" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">当创建具有终结器的对象时，对该对象的引用也存储在终结队列中。当对象不再被任何东西引用并且发生了垃圾收集时，GC可以看到它仍然被终结队列引用。所以它到了第一代。当垃圾回收发生时，会引发一个事件，终结线程被唤醒并开始运行，然后将运行由对象定义的终结器方法。终结在不同的线程上而不是由GC完成的原因是，终结可能需要一段时间，这会阻塞GC进程，从而阻塞所有应用程序线程。</p><h1 id="6b90" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Int32和Int的区别</h1><p id="0249" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><code class="fe mm mn mo mp b">Int32</code>是一个. NET类，可以用在任何。网语，例如<code class="fe mm mn mo mp b">Int32 x = 10;</code> <br/> <code class="fe mm mn mo mp b">int</code>但是，是C#特有的(大概还有其他。NET语言)并直接映射到<code class="fe mm mn mo mp b">Int32</code>。<br/>使用一种或另一种没有区别(除了一种情况，更多信息见下一节)。<br/> <code class="fe mm mn mo mp b">Int32 x = new Int32();</code>和<code class="fe mm mn mo mp b">int x;</code> <br/>完全一样使用<code class="fe mm mn mo mp b">new</code>操作符不在堆上分配内存，也不装箱<code class="fe mm mn mo mp b">int</code>。</p><p id="efd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下表显示了C#关键字和。网络:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/ab5a2e8eff951156b4f764ce2b704c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*k6_Q-6clo5TqWfy7Y0gHwA.png"/></div></figure><p id="21db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择C#关键字short、int和long显然是因为它们的位长(16、32和64)。</p><h1 id="d549" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Int32与Int</h1><h2 id="710c" class="mr ld iq bd le ms mt dn li mu mv dp lm jy mw mx lq kc my mz lu kg na nb ly nc bi translated">列举型别</h2><p id="84ee" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><code class="fe mm mn mo mp b">Int32</code>和<code class="fe mm mn mo mp b">int</code>在任何情况下都可以相互替换使用，除非将其用作枚举的支持类型。</p><p id="de73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">枚举的支持类型可以是任何整数类型(除了<code class="fe mm mn mo mp b">Char</code>)，默认为<code class="fe mm mn mo mp b">Int32</code>。</p><p id="4e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，如果你觉得需要显式地声明支持类型为<code class="fe mm mn mo mp b">Int32</code>，你必须使用关键字<code class="fe mm mn mo mp b">int</code>。</p><p id="119c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样做的原因是因为<code class="fe mm mn mo mp b">Int32</code>不是一个关键字，你可以创建你自己的名为<code class="fe mm mn mo mp b">Int32</code>的类，但是枚举不允许从这个类派生，因为它不是一个整型。</p><p id="b2cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以为了避免混淆，编译器团队决定让你使用关键字而不是类型名。</p><h2 id="d7ee" class="mr ld iq bd le ms mt dn li mu mv dp lm jy mw mx lq kc my mz lu kg na nb ly nc bi translated">Int32比Int好</h2><p id="4fa9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我更喜欢使用。NET类名而不是C#关键字，因为。NET类名赋予了更多的含义。</p><p id="ce46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以<code class="fe mm mn mo mp b">Single</code><em class="mi"/><code class="fe mm mn mo mp b">Double</code>为例，<code class="fe mm mn mo mp b"><em class="mi">Single</em></code>使用32位存储，<code class="fe mm mn mo mp b">Double</code>使用64位存储。</p><p id="0950" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mm mn mo mp b">Int32</code>告诉你是32位，<code class="fe mm mn mo mp b">Int64</code>告诉你是64位(比<code class="fe mm mn mo mp b">long</code>好多了)。</p><p id="8e93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">。NET类名在任何针对。NET framework，但是C#关键字只能在C#中使用(除非其他语言也偶然使用相同的关键字)。</p><h1 id="8afd" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">并非所有的类都是引用类型</h1><p id="e788" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这是因为结构和枚举只是从<code class="fe mm mn mo mp b"><a class="ae lb" href="http://msdn.microsoft.com/en-us/library/system.valuetype%28v=vs.71%29.aspx" rel="noopener ugc nofollow" target="_blank">System.ValueType</a></code>派生的类。</p><h1 id="2b2a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">转换。ToInt32()与造型</h1><p id="6c05" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><code class="fe mm mn mo mp b">Convert.ToInt32()</code>和铸造使用(<code class="fe mm mn mo mp b">int</code>)会产生不同的结果。编辑以下代码:</p><pre class="km kn ko kp gt nd mp ne nf aw ng bi"><span id="f047" class="mr ld iq mp b gy nh ni l nj nk">Convert.ToInt32(23.6);<br/>(int)23.6;</span></pre><p id="7ad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们总是被告知，当转换成<code class="fe mm mn mo mp b">Int32</code>时，小数部分被去除，然而这不是<code class="fe mm mn mo mp b">ToInt32()</code>方法的情况。</p><p id="94a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">转换将去掉小数部分并输出23，但是<code class="fe mm mn mo mp b">ToInt32()</code>方法使用舍入，因此输出24。</p><h1 id="79b0" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">LINQ的“关键词”并不是真正的关键词</h1><p id="e27b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><a class="ae lb" href="http://msdn.microsoft.com/en-us/library/bb397933.aspx" rel="noopener ugc nofollow" target="_blank"> LINQ </a>在综合<strong class="jp ir"> Q </strong>查询中代表<strong class="jp ir"> L </strong>语言<strong class="jp ir">并于2002年引入。净3.5。这基本上是一种用类似SQL的语法查询数据的方法。<br/>下面给出了一个LINQ查询表达式的例子:</strong></p><pre class="km kn ko kp gt nd mp ne nf aw ng bi"><span id="0036" class="mr ld iq mp b gy nh ni l nj nk">int[] numbers = new int[7] { 0, 1, 2, 3, 4, 5, 6 };<br/>var numQuery =<br/>            from num in numbers<br/>            where (num % 2) == 0<br/>            select num;</span></pre><p id="4eba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然<code class="fe mm mn mo mp b">from</code>、<code class="fe mm mn mo mp b">where</code>和<code class="fe mm mn mo mp b">select</code>这几个词看似是关键词，其实不然。<br/>变量名有可能是<code class="fe mm mn mo mp b">from</code>、<code class="fe mm mn mo mp b">where</code>或<code class="fe mm mn mo mp b">select</code>。</p><p id="8be2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为这些单词仅在上下文中被视为关键字。编译器寻找单词<code class="fe mm mn mo mp b">from</code>，并且知道这是LINQ查询的开始。因此，只有在LINQ查询的上下文中，这些单词才会被视为关键字。他们决定这样设计的原因是因为在引入LINQ之前，程序员可能一直使用<code class="fe mm mn mo mp b">from</code>、<code class="fe mm mn mo mp b">where</code>或<code class="fe mm mn mo mp b">select</code>作为变量名，在C#中引入一个新特性应该不会打破这一点。</p><h1 id="82c6" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">为什么LINQ不像在SQL中那样在“from”子句前使用“select”子句？</h1><p id="c388" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">LINQ在<code class="fe mm mn mo mp b">select</code>条款之前先有<code class="fe mm mn mo mp b">from</code>条款有两个原因。<br/> 1。它允许您使用智能感知。如果首先声明了<code class="fe mm mn mo mp b">select</code>子句，IntelliSense将无法工作，因为<code class="fe mm mn mo mp b">from</code>子句会告诉您变量名和类型。<br/> 2。<code class="fe mm mn mo mp b">from</code>逻辑上先发生，后发生<code class="fe mm mn mo mp b">select</code>，而不是反过来。</p><p id="b2bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不知道为什么SQL决定让它反过来。</p><h1 id="8a8a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">If语句和布尔方法</h1><p id="f18b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在if语句中使用布尔返回方法作为操作数时要小心。在下面的例子中，方法<code class="fe mm mn mo mp b">iWontExecute()</code>永远不会被执行:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f5a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为在第一个<code class="fe mm mn mo mp b">if</code>语句中，第一个操作数是<code class="fe mm mn mo mp b">true</code>。<br/>由于使用的是OR运算符，所以第二个操作数是什么并不重要，整个表达式都会求值到<code class="fe mm mn mo mp b">true</code>。<br/>同样在第二条<code class="fe mm mn mo mp b">if</code>语句中，第一个操作数是<code class="fe mm mn mo mp b">false</code>。<br/>因为这是AND运算符，所以不管第二个操作数是什么，整个表达式都将计算为<code class="fe mm mn mo mp b">false</code>。</p><p id="6855" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想让<code class="fe mm mn mo mp b">iWontExecute()</code>执行，你必须把它作为前两个<code class="fe mm mn mo mp b">if</code>语句的第一个操作数。<br/>在第三和第四个<code class="fe mm mn mo mp b">if</code>语句中，方法<code class="fe mm mn mo mp b">iWillExecute()</code>确实执行了，因为它的返回值将决定<code class="fe mm mn mo mp b">if</code>语句的最终求值。</p><p id="9d72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如今，大多数ide(如Visual Studio)会为前两条<code class="fe mm mn mo mp b">if</code>语句提供编译时警告(“检测到不可到达的表达式代码”)。</p><h1 id="d267" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">静态类</h1><p id="eaa7" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">静态类直接来源于<code class="fe mm mn mo mp b">System.Object</code>。静态类不可能从任何其他类派生，因为这没有任何意义。继承只适用于对象，不能创建静态类的实例。</p><p id="9d9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个静态类，一旦编译成IL代码，就会同时标记上<code class="fe mm mn mo mp b">abstract</code>和<code class="fe mm mn mo mp b">sealed</code>。这是有意义的，因为您不能实例化一个<code class="fe mm mn mo mp b">abstract</code>类，并且不能派生一个<code class="fe mm mn mo mp b">sealed</code>类。</p><h1 id="c59e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">重写方法和可访问性</h1><p id="b08d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果重写一个方法，被重写的方法必须和父类一样严格，或者不如父类严格。</p><p id="41a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样做的原因是，任何派生类都可以被转换为父类。如果你试图调用这个对象上的overriden方法，这个对象现在被转换为父类，它将不起作用，没有任何意义。</p></div></div>    
</body>
</html>