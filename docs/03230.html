<html>
<head>
<title>Implementing Minimax Tree Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现极大极小树搜索</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-minimax-tree-search-8ae8604a53b5?source=collection_archive---------15-----------------------#2020-04-26">https://levelup.gitconnected.com/implementing-minimax-tree-search-8ae8604a53b5?source=collection_archive---------15-----------------------#2020-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/06c06650e46ce1b78b15840c0611fd05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/0*_ELQQX7rKJnPKJqg"/></div></figure><p id="2958" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">玩游戏是学习机器学习策略的一种方式。大多数游戏机器人都包含一些搜索机制。这就是机器人如何“看到”哪一步会带来有利的结果。</p><p id="470d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们来学习minimax，这是一种构建人工智能在简单游戏中竞争的有用技术。</p><h1 id="168a" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">单人游戏树搜索</h1><p id="829b" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">让我们玩一个小游戏。游戏的目标是以最高的数字结束。</p><p id="9e8d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于单人游戏的一个回合来说，选择很简单。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ly"><img src="../Images/289c2b74a84dba198cfd5bfc93464fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*6AHQdpKBBCzgULB6PIF1FQ.png"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">单轮游戏</figcaption></figure><p id="8f57" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你往右，你以10分结束！这是我们这个小游戏中最高的分数了。</p><p id="c0a1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们把它变得复杂一点。我们的游戏现在有两个回合，你选择什么？</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/1b0195eac280fa7a34b69dc120a397c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*k2sEiIPg3ZJRY5lryKFRow.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">两回合游戏</figcaption></figure><p id="8124" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在你的第一个回合，如果你做了同样的决定(选10)，那么在你的第二个回合(2或3)你会有不好的选择。</p><p id="fd3a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了获得最高分，你需要在第一轮选择1，以便在第二轮选择20。</p><p id="5896" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对此建模的一种方法是从底部开始，并在每个节点选择最大值。如果我们对整个树都这样做，我们就确定了我们的最高分(20)和要做的决定(左，左)。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/b193b5087352dcaac2d19786ddd83f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*UP9oiVM1aJivT89bS-05Kg.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">两回合博弈建模</figcaption></figure><h1 id="e18e" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">双玩家树搜索(Minimax)</h1><p id="f982" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">如果我们在这个游戏中引入另一个玩家呢？现在两个玩家在互相竞争。对规则做了一点小小的改动。</p><ol class=""><li id="c014" class="mm mn it jz b ka kb ke kf ki mo km mp kq mq ku mr ms mt mu bi translated">如果选择正数，玩家1获胜。</li><li id="f2d9" class="mm mn it jz b ka mv ke mw ki mx km my kq mz ku mr ms mt mu bi translated">如果选择负数，2号玩家获胜。</li><li id="d151" class="mm mn it jz b ka mv ke mw ki mx km my kq mz ku mr ms mt mu bi translated">如果选择0，则出现平局。</li><li id="2eb1" class="mm mn it jz b ka mv ke mw ki mx km my kq mz ku mr ms mt mu bi translated">玩家轮流玩，玩家1先玩。</li></ol><p id="26b0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">就拿下面这个游戏来说吧。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi na"><img src="../Images/a8576a529128ec5f338b99b79b449aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*dMVOjTxXGRZoFu1tVr-RWg.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">双人游戏</figcaption></figure><p id="64ce" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一号玩家(P1)做出第一个选择，然后二号玩家(P2)有机会，最后一号玩家做出最后的选择。</p><p id="fd0b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一号玩家想要正数，所以他们想最大化他们的分数。</p><p id="f613" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">参与人2想要负数，所以他们想最小化他们的分数。</p><p id="2221" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这就是“极小极大”这个术语的来源，来自于玩家想要最小化或最大化他们的分数。</p><p id="4b36" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这场游戏会如何进行？如果每个玩家都选择了当时对他们来说最好的选择，那么最优的游戏结果是7，这意味着玩家1赢了！</p><p id="9c5c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们也为这个游戏建模。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/5b9337796da39aa3978ae75494a0819d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*0GjynhSi5kkU3AGQsNvJSw.png"/></div></figure><p id="07d7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">同样，参与人1试图最大化他们的分数，参与人2试图最小化他们的分数。</p><p id="3b01" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">参与人1向左，参与人2向左，最后参与人1向右，得分为7。</p><h1 id="2c86" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">编程最小值最大值</h1><p id="511b" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">让我们用python实现一个极大极小搜索！</p><p id="fe29" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们首先需要一个数据结构来保存我们的值。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2a21" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们创建了一个<code class="fe ne nf ng nh b">Node</code>类，它可以保存一个值并链接到一个左右<code class="fe ne nf ng nh b">Node</code>。</p><p id="b0b4" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后我们将创建一个代表玩家选择的<code class="fe ne nf ng nh b">Choice</code>类。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e878" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">接下来，我们将使用上面建模的两人游戏的值初始化一棵树。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="20de" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你会注意到在第41行，我在打印树。它输出以下内容:</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/0f44304373e85342239473a6868a3797.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*gODkhlFY0tTq0rMeE6hMjw.png"/></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">印刷树</figcaption></figure><p id="cad6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="nj">在</em><a class="ae nk" href="https://github.com/morgankenyon/RandomML/blob/master/src/minimax.py#L15" rel="noopener ugc nofollow" target="_blank"><em class="nj">github repo</em></a><em class="nj">上有</em> <code class="fe ne nf ng nh b"><em class="nj">print_tree</em></code> <em class="nj">功能。</em></p><p id="c336" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将通过编写递归深度优先搜索算法来解决这个问题。我们要记住的主要问题是:</p><ol class=""><li id="b75f" class="mm mn it jz b ka kb ke kf ki mo km mp kq mq ku mr ms mt mu bi translated">我们需要记录轮到哪些玩家，我用<code class="fe ne nf ng nh b">is_max</code>来记录。</li><li id="fd9c" class="mm mn it jz b ka mv ke mw ki mx km my kq mz ku mr ms mt mu bi translated">我们需要知道什么时候停止搜索，在递归中，这意味着我们需要一些基本情况。</li><li id="456a" class="mm mn it jz b ka mv ke mw ki mx km my kq mz ku mr ms mt mu bi translated">我们想探索整棵树。</li><li id="c9a4" class="mm mn it jz b ka mv ke mw ki mx km my kq mz ku mr ms mt mu bi translated">我们需要一些比较逻辑来决定我们将选择探索哪个子树。</li></ol><p id="7677" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们的基本情况是当我们的节点不再有任何子节点时，我们只返回节点的值。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9349" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了探索整个树，我们将在节点的每个子树上调用<code class="fe ne nf ng nh b">minimax</code>。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9739" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">确保反转<code class="fe ne nf ng nh b">is_max</code>，因为玩家轮流。</p><p id="67bc" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">最后，我们比较结果。如果我们最大化我们取最大结果，那么如果我们最小化我们取最小结果。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3de3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们创建一个小模拟器来玩我们的游戏。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="ab5d" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">运行此命令会输出以下内容:</p><pre class="lz ma mb mc gt nl nh nm nn aw no bi"><span id="a32f" class="np kw it nh b gy nq nr l ns nt">Moving left to node with value -2<br/>Moving left to node with value 3<br/>Moving right to node with value 7<br/>Game ends with a score of 7</span></pre><p id="17bf" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">恭喜你。我们已经正确地演示了如何使用极大极小来优化解决一个简单的双人游戏。</p><h1 id="16b6" class="kv kw it bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">离别的思绪</h1><p id="ccf6" class="pw-post-body-paragraph jx jy it jz b ka lt kc kd ke lu kg kh ki lv kk kl km lw ko kp kq lx ks kt ku im bi translated">这个游戏非常简单。但是搜索是大多数自动游戏机器人不可或缺的一部分。这就是机器人能够“预见”未来的方式。</p><p id="b112" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于一个挑战，看看你是否可以使用minimax来建立一个井字游戏机器人。</p><p id="1ced" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">可以想象，对于复杂的游戏(国际象棋和围棋)，由于时间和内存的限制，搜索有其局限性。在这些情况下，进一步的策略如alpha-beta修剪和蒙特卡罗模拟会有所帮助。</p><p id="0958" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您可能已经注意到，我的基本案例只适用于有两个或零个子节点的节点。<a class="ae nk" href="https://github.com/morgankenyon/RandomML/blob/master/src/minimax.py" rel="noopener ugc nofollow" target="_blank"> git repo </a>中的minimax将包含处理该条件的代码。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="d31c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="nj">原载于2020年4月26日</em><a class="ae nk" href="https://thesharperdev.com/implementing-minimax-tree-search/" rel="noopener ugc nofollow" target="_blank"><em class="nj">https://thesharperdev.com</em></a>T22。</p></div></div>    
</body>
</html>