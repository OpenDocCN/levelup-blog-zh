<html>
<head>
<title>Using templates and validating input in Hapi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在哈比神中使用模板和验证输入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/hapi-vision-and-joi-1b4702d3982f?source=collection_archive---------19-----------------------#2021-03-16">https://levelup.gitconnected.com/hapi-vision-and-joi-1b4702d3982f?source=collection_archive---------19-----------------------#2021-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/88a6c80a64ee0f2c9258f4e29eca7e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2CzQbpi7phYdpqeO"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@nate_dumlao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">内森·杜姆劳</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="dee0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将把以前的文章添加到我们的应用程序中。我们将使用Vision进行模板渲染，使用Joi进行输入验证。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="4314" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">视力</h1><p id="888e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated"><a class="ae kf" href="https://hapi.dev/module/vision/" rel="noopener ugc nofollow" target="_blank"> Vision </a>向<code class="fe mo mp mq mr b">Server</code>、<code class="fe mo mp mq mr b">Request</code>和<code class="fe mo mp mq mr b">ResponseToolkit</code>接口添加方法，这样您就可以使用视图引擎来呈现模板。它不知道所使用的特定引擎；在这篇文章中，我们将使用<a class="ae kf" href="https://ejs.co/" rel="noopener ugc nofollow" target="_blank"> EJS </a>，仅仅因为我对它很熟悉。</p><h2 id="ee2a" class="ms lm it bd ln mt mu dn lr mv mw dp lv kr mx my lz kv mz na md kz nb nc mh nd bi translated">设置</h2><p id="f670" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">包裹的通常处理:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="be28" class="ms lm it mr b gy nm nn l no np">$ yarn add @hapi/vision ejs<br/>$ yarn add -D @types/hapi__vision @types/ejs</span></pre><p id="0833" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还需要放置模板的地方；这不是很有想象力，但我通常使用一个名为<code class="fe mo mp mq mr b">templates</code>的目录。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="166a" class="ms lm it mr b gy nm nn l no np">$ mkdir templates<!-- --> </span></pre><p id="1f7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面列出的<code class="fe mo mp mq mr b">registerVision</code>函数注册并配置插件。插件选项显示使用哪个<code class="fe mo mp mq mr b">path</code>(在我们的例子中是<code class="fe mo mp mq mr b">templates</code>)。<code class="fe mo mp mq mr b">relativeTo</code>选项表示它位于顶层，和<code class="fe mo mp mq mr b">package.json</code>在一起，而不在源代码目录中。</p><p id="8961" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将模板目录放在顶层的一个原因是——如果它在<code class="fe mo mp mq mr b">src</code>目录中，那么在TypeScript编译之后，它必须被复制到<code class="fe mo mp mq mr b">lib</code>。不难，但这是我们不需要做的工作。</p><p id="0183" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我在开发中禁用了缓存，这样我就不必在每次更改模板时重启服务器。</p><p id="3156" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">src/server.ts</code>:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="0d8d" class="ms lm it mr b gy nm nn l no np">async function registerVision(server: Server) {<br/>  let cached: boolean;<br/><br/>  await server.register(hapiVision);<br/><br/>  if (!process.env.NODE_ENV || process.env.NODE_ENV === "development") {<br/>    cached = false;<br/>  } else {<br/>    cached = true;<br/>  }<br/>  console.log(`Caching templates: ${cached}`);<br/>  server.views({<br/>    engines: {<br/>      ejs: require("ejs")<br/>    },<br/>    relativeTo: __dirname + "/../",<br/>    path: ‘templates’,<br/>    isCached: cached<br/>  });<br/>}</span></pre><p id="50b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们根本不用改变现有的<code class="fe mo mp mq mr b">/</code>路线；我们可以同时使用视觉和其他反应方法。</p><h2 id="c8ec" class="ms lm it bd ln mt mu dn lr mv mw dp lv kr mx my lz kv mz na md kz nb nc mh nd bi translated">试验</h2><p id="da7f" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">为了测试，我们将添加另一个包，<code class="fe mo mp mq mr b">node-html-parser</code>。我们希望能够从应用程序发回的网页中提取一些细节，以确认(至少在某种程度上)它看起来像我们预期的那样。</p><p id="74aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:我们将把HTML测试保持在最低限度，这样就不会变成一篇真正的长文。在现实生活中，你的测试可能会更广泛。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="f7b0" class="ms lm it mr b gy nm nn l no np">$ yarn add -D node-html-parse</span></pre><p id="1fdc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">test/test.people.ts:</code></p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="91e8" class="ms lm it mr b gy nm nn l no np">import { Server } from "@hapi/hapi";<br/>import { describe, it, beforeEach, afterEach } from "mocha";<br/>import { expect } from "chai";<br/>import { parse } from "node-html-parser";</span><span id="48d5" class="ms lm it mr b gy nr nn l no np">// If the tests were in JavaScript we'd need to use ../lib/<br/>import { init } from "../src/server";<br/><br/>const personData = { name: "Sherlock Holmes", age: 32 }<br/><br/>describe.only("server handles people", async () =&gt; {<br/>	let server: Server;<br/><br/>	beforeEach(async () =&gt; {<br/>		server = await init();<br/>	})<br/>	afterEach(async () =&gt; {<br/>		await server.stop();<br/>	});<br/><br/>	it("can see existing people", async () =&gt; {<br/>		const res = await server.inject({<br/>			method: "get",<br/>			url: "/people"<br/>		});<br/>		expect(res.statusCode).to.equal(200);<br/>		expect(res.payload).to.not.be.null;<br/>		const html = parse(res.payload);<br/>		// Look for a list item with the person-entry class<br/>		const people = html.querySelectorAll("li.person-entry");;<br/>		// We seeded two of them.<br/>		expect(people.length).to.equal(2);<br/>	});<br/><br/>	it("can show 'add person' page", async () =&gt; {<br/>		const res = await server.inject({<br/>			method: "get",<br/>			url: "/people/add"<br/>		});<br/>		expect(res.statusCode).to.equal(200);<br/>	});<br/><br/>	it("can add a person and they show in the list", async () =&gt; {<br/>		let res = await server.inject({<br/>			method: "post",<br/>			url: "/people/add",<br/>            payload: personData<br/>		});<br/>		expect(res.statusCode).to.equal(302);<br/>		expect(res.headers.location).to.equal("/people");<br/><br/>		res = await server.inject({<br/>			method: "get",<br/>			url: "/people"<br/>		});<br/>		expect(res.statusCode).to.equal(200);<br/>		expect(res.payload).to.not.be.null;<br/>		const html = parse(res.payload);<br/>		const people = html.querySelectorAll("li.person-entry");;<br/>		// Did the person get added, and show up?<br/>		expect(people.length).to.equal(3);<br/>	});<br/>})</span></pre><p id="69f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以这看起来非常像我们上次写的测试，这是使用像mocha和chai这样的工具的优势之一。您会注意到的唯一区别是，我们解析HTML来查看列表中有多少人。这显然可以做得更好——检查页面标题，检查正确的按钮是否可用，诸如此类。</p><p id="df26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们还没有写任何代码，如果我们运行它，它会失败。这篇文章已经够长了，所以我就不贴进去了。</p><h2 id="3624" class="ms lm it bd ln mt mu dn lr mv mw dp lv kr mx my lz kv mz na md kz nb nc mh nd bi translated">模板</h2><p id="0361" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这是一个非常简单的页面，有一个无序的列表。</p><p id="4dc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">EJS模板逻辑期望<code class="fe mo mp mq mr b">people</code>是一个<code class="fe mo mp mq mr b">person</code>结构的数组；然后循环为每个条目构建一个<code class="fe mo mp mq mr b">&lt;li&gt;</code>元素。Vision在渲染时将<code class="fe mo mp mq mr b">people</code>数组传递给模板；我们将在下一部分看到这一点。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="0911" class="ms lm it mr b gy nm nn l no np">&lt;html&gt;<br/>	&lt;head&gt;<br/>		&lt;title&gt;Purple People Eaters&lt;/title&gt;<br/>	&lt;/head&gt;<br/>	&lt;body&gt;<br/>		&lt;ul&gt;<br/>			&lt;% people.forEach(person =&gt; { %&gt;<br/>				&lt;li class="person-entry"&gt;<br/>					&lt;%= person.name %&gt; - &lt;%= person.age %&gt;<br/>				&lt;/li&gt;<br/>			&lt;% }) %&gt;<br/>		&lt;/ul&gt;<br/>		&lt;a href="/people/add"&gt;Add person&lt;/a&gt;<br/>	&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="abe4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">templates/addPerson.ejs</code>是非常标准的形式；EJS扮演的唯一角色是使用提供的<code class="fe mo mp mq mr b">person</code>结构来设置输入字段的初始值。如果用户犯了一个错误，页面必须重新呈现，这很有帮助——如果我们将(坏的)数据传递回呈现，那么他们不会丢失他们输入的内容。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="7e66" class="ms lm it mr b gy nm nn l no np">&lt;html&gt;<br/>	&lt;head&gt;<br/>		&lt;title&gt;Purple People Eaters&lt;/title&gt;<br/>	&lt;/head&gt;<br/>	&lt;body&gt;<br/>		&lt;h1&gt;Add person&lt;/h1&gt;<br/>		&lt;form method="POST"&gt;<br/>			&lt;label for="name"&gt;Name&lt;/label&gt;<br/>			&lt;input type="text" name="name" value="&lt;%= person.name %&gt;"&gt;<br/>			&lt;label for="age"&gt;Age&lt;/label&gt;<br/>			&lt;input type="text" name="age"  value="&lt;%= person.age %&gt;"&gt;<br/>			&lt;button type="submit"&gt;Add&lt;/button&gt;<br/>		&lt;/form&gt;<br/>	&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="366a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经有了测试和模板——我们现在只需要添加代码。</p><h2 id="3dd7" class="ms lm it bd ln mt mu dn lr mv mw dp lv kr mx my lz kv mz na md kz nb nc mh nd bi translated">密码</h2><p id="c13e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">使用视觉出奇的简单。它将一个<code class="fe mo mp mq mr b">view</code>方法添加到<code class="fe mo mp mq mr b">ResponseToolkit</code>中，当被调用时，它将使用上下文中的数据呈现一个模板:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="ca32" class="ms lm it mr b gy nm nn l no np">h.view("template_file", { data: someDataForTheTemplate })</span></pre><p id="500b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您会注意到，在<code class="fe mo mp mq mr b">addPersonGet</code>中，我们声明了一个空结构(作为<code class="fe mo mp mq mr b">Person</code>类型)并将其传递给视图。如果我们不这样做，那么每次我们使用它时，我们必须在表达式中使用它之前检查变量是否存在，否则EJS会抛出一个异常。</p><p id="d3fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mo mp mq mr b">addPersonPost</code>中，如果因为某种原因抛出了异常，那么页面将重新呈现，并传回<code class="fe mo mp mq mr b">data</code>结构。如果你真的在构建一个页面，那么你可能至少想看看这个异常是什么。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="a88e" class="ms lm it mr b gy nm nn l no np">import { Request, ResponseToolkit, ResponseObject, ServerRoute } from "@hapi/hapi";<br/><br/>type Person = {<br/>    name: string;<br/>    age: number;<br/>}<br/><br/>const people: Person[] = [<br/>    { name: "Sophie", age: 37 },<br/>    { name: "Dan", age: 42 }<br/>];<br/><br/>async function showPeople(request: Request, h: ResponseToolkit): Promise&lt;ResponseObject&gt; {<br/>    return h.view("people", { people: people });<br/>}<br/><br/>async function addPersonGet(request: Request, h: ResponseToolkit): Promise&lt;ResponseObject&gt; {<br/>    let data = ({} as Person);<br/>    return h.view("addPerson", { person: data });<br/>}<br/><br/>async function addPersonPost(request: Request, h: ResponseToolkit): Promise&lt;ResponseObject&gt; {<br/>    let data = ({} as Person);<br/>    try {<br/>        data = (request.payload as Person);<br/>        people.push(data);<br/>        return h.redirect("/people");<br/>    } catch (err) {<br/>        console.error("Caught error", err);<br/>        return h.view("addPerson", { person: data })<br/>    }<br/>}<br/><br/>export const peopleRoutes: ServerRoute[] = [<br/>  { method: "GET", path: "/people", handler: showPeople },<br/>  { method: "GET", path: "/people/add", handler: addPersonGet },<br/>  { method: "POST", path: "/people/add", handler: addPersonPost }  <br/>];</span></pre><p id="c8a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">强制性检查:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="1ae4" class="ms lm it mr b gy nm nn l no np">yarn run v1.22.10<br/>$ NODE_ENV=test mocha -r ts-node/register test/**/*.test.ts<br/><br/><br/>  server handles people<br/>    ✓ can see existing people<br/>    ✓ can show 'add person' page<br/>    ✓ can add a person and they show in the list<br/><br/><br/>  3 passing (113ms)<br/><br/>✨  Done in 2.69s.</span></pre><p id="0a1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">搞定了。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="a4a4" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">向Joi确认</h1><p id="b473" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们刚刚添加的内容可以工作，但是它不会对输入进行任何检查——这很容易使服务器崩溃。处理这个问题是Joi的职责。</p><h2 id="826a" class="ms lm it bd ln mt mu dn lr mv mw dp lv kr mx my lz kv mz na md kz nb nc mh nd bi translated">设置</h2><p id="5411" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">设置真的很简单，加包就行！因为它包含了类型定义，所以我们不需要单独的类型包。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="ba8b" class="ms lm it mr b gy nm nn l no np">$ yarn add joi</span></pre><h2 id="6c2c" class="ms lm it bd ln mt mu dn lr mv mw dp lv kr mx my lz kv mz na md kz nb nc mh nd bi translated">添加测试</h2><p id="2700" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">只是为了确保每个人都在同一页上——积极测试检查如果给定有效的输入，事情会工作。负面测试检查如果输入错误，事物不会崩溃或烧毁。到目前为止，我们所写的只是正面的测试——这些都是好的，但是bug(或者讨厌的用户)会给你的API带来不好的参数。</p><h2 id="91b6" class="ms lm it bd ln mt mu dn lr mv mw dp lv kr mx my lz kv mz na md kz nb nc mh nd bi translated">阳性测试</h2><p id="3131" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">为此，我们将只使用现有的测试，并检查它们是否仍然通过。不过，将<code class="fe mo mp mq mr b">describe</code>子句修改得更清楚会更清楚:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="452b" class="ms lm it mr b gy nm nn l no np">describe("server handles people - positive tests", ...</span></pre><h2 id="c337" class="ms lm it bd ln mt mu dn lr mv mw dp lv kr mx my lz kv mz na md kz nb nc mh nd bi translated">阴性测试</h2><p id="0766" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这些方法试图通过传入坏数据来破坏API没有名字、没有年龄、没有数字年龄等等。我几乎总是发现，当你做完所有的事情时，消极的测试会比积极的多。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="c039" class="ms lm it mr b gy nm nn l no np">describe("server handles people - negative tests", async () =&gt; {<br/>	let server: Server;<br/><br/>	beforeEach(async () =&gt; {<br/>		server = await init();<br/>	})<br/>	afterEach(async () =&gt; {<br/>		await server.stop();<br/>	});<br/><br/>	it("can't add a person with no name", async () =&gt; {<br/>		let res = await server.inject({<br/>			method: "post",<br/>			url: "/people/add",<br/>			payload: { ...personData, name: null }<br/>		});<br/>		expect(res.statusCode).to.equal(200);<br/>	});<br/><br/>	it("can't add a person with no age", async () =&gt; {<br/>		let res = await server.inject({<br/>			method: "post",<br/>			url: "/people/add",<br/>			payload: { ...personData, age: null }<br/>		});<br/>		expect(res.statusCode).to.equal(200);<br/>	});<br/><br/>	it("can't add a person with non-number age", async () =&gt; {<br/>		let res = await server.inject({<br/>			method: "post",<br/>			url: "/people/add",<br/>			payload: { ...personData, age: "Watson" }<br/>		});<br/>		expect(res.statusCode).to.equal(200);<br/>	});<br/>})</span></pre><p id="c99b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们检查状态代码200，因为在错误的页面应该重新呈现。</p><h2 id="b451" class="ms lm it bd ln mt mu dn lr mv mw dp lv kr mx my lz kv mz na md kz nb nc mh nd bi translated">使用Joi</h2><p id="5acf" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">要使用Joi，您需要描述数据的允许形状。使用Joi的一个好处是模式描述非常像英语。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="1139" class="ms lm it mr b gy nm nn l no np">import Joi from "joi";<br/>const ValidationError = Joi.ValidationError;<br/><br/>const schema = Joi.object({<br/>    name: Joi.string().required(),<br/>    age: Joi.number().required()<br/>});</span></pre><p id="2584" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当<code class="fe mo mp mq mr b">addPersonPost</code>收到新数据时，模式对象可以用来验证它。<code class="fe mo mp mq mr b">stripUnknown</code>选项删除模式中没有列出的任何元素，这是另一层保护。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="4cf1" class="ms lm it mr b gy nm nn l no np">data = (request.payload as Person);<br/>const o = schema.validate(data, { stripUnknown: true });<br/>if (o.error) {<br/>    throw o.error;<br/>}<br/>data = (o.value as Person);<br/>people.push(data);</span></pre><p id="e1bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将下面的代码添加到<code class="fe mo mp mq mr b">catch</code>子句将处理Joi发现的任何错误，并将它们添加到呈现<code class="fe mo mp mq mr b">addPerson</code>页面的上下文中。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="8ecc" class="ms lm it mr b gy nm nn l no np">const errors: { [key: string]: string } = {};<br/>if (err instanceof ValidationError &amp;&amp; err.isJoi) {<br/>    for (const detail of err.details) {<br/>        errors[detail.context!.key!] = detail.message;<br/>    }<br/>} else {<br/>    console.error("error", err, "adding person");<br/>}<br/><br/>return h.view("addPerson", { person: data, errors: errors })</span></pre><p id="a712" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mo mp mq mr b">errors</code>对象被声明为具有引用<code class="fe mo mp mq mr b">string</code>值(例如<code class="fe mo mp mq mr b">errors["itBroke"] = "yes"</code>)的<code class="fe mo mp mq mr b">string</code>键(例如<code class="fe mo mp mq mr b">errors["itBroke"]</code>)的对象。</p><p id="d0f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们对异常进行健全性检查；如果它看起来真的像Joi异常，那么我们就处理它。当Joi引发一个验证异常时，它包含一个<code class="fe mo mp mq mr b">details</code>元素，这是一个失败细节的数组。我们遍历它，并将每一个添加到<code class="fe mo mp mq mr b">errors</code>对象中。</p><p id="1301" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们重新呈现了<code class="fe mo mp mq mr b">addPerson</code>模板，传入了<code class="fe mo mp mq mr b">errors</code>对象，以便页面可以处理它。</p><p id="df03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> NB </strong> : Joi声明<code class="fe mo mp mq mr b">context</code>和<code class="fe mo mp mq mr b">key</code>元素是可选的。不清楚这是为什么——我选择用<code class="fe mo mp mq mr b">!</code>装饰器覆盖这些元素，告诉TypeScript这些元素肯定会出现。</p><p id="7da7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了向用户报告错误，我们在模板中添加了<code class="fe mo mp mq mr b">span</code>部分。如果你有一个非常统一的模板，你可以用Javascript生成HTML，但是对于我们这里的小模板，这是最简单的方法。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="0a6e" class="ms lm it mr b gy nm nn l no np">&lt;label for="name"&gt;Name&lt;/label&gt;<br/>&lt;input type="text" name="name" value="&lt;%= person.name %&gt;"&gt;<br/><strong class="mr iu">&lt;span id="name-error" class="error text-red-500"&gt;&lt;/span&gt;</strong><br/>&lt;label for="age"&gt;Age&lt;/label&gt;<br/>&lt;input type="text" name="age"  value="&lt;%= person.age %&gt;"&gt;<br/><strong class="mr iu">&lt;span id="age-error" class="error text-red-500"&gt;&lt;/span&gt;</strong></span></pre><p id="5ee8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们将这段JavaScript代码添加到页面中:</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="ebc1" class="ms lm it mr b gy nm nn l no np">&lt;script&gt;<br/>const errors = &lt;%- JSON.stringify(locals.errors || null) %&gt;;<br/>if (errors) {<br/>  Object.keys(errors).forEach(error =&gt; {<br/>    const el = document.getElementById(error + "-error");<br/>    if (el) {<br/>      el.innerText = errors[error];<br/>    }<br/>  })<br/>}<br/>&lt;/script&gt;</span></pre><p id="bbad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意<code class="fe mo mp mq mr b">&lt;%-</code>标签而不是<code class="fe mo mp mq mr b">&lt;%=</code>——根据<a class="ae kf" href="https://ejs.co/#docs" rel="noopener ugc nofollow" target="_blank"> EJS文档</a>，它将一个非转义值输出到模板中。因为我们已经将对象转换为JSON，所以我们不希望它再次被转义。</p><p id="a802" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果定义了<code class="fe mo mp mq mr b">errors</code>,那么我们循环查找匹配的HTML元素。如果我们找到了它，然后将它设置为错误消息。这样做可以节省模板中大量复杂的调整，从而有条件地呈现错误消息。</p><p id="7cf5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，证据在测试中。</p><pre class="ne nf ng nh gt ni mr nj nk aw nl bi"><span id="0363" class="ms lm it mr b gy nm nn l no np">yarn run v1.22.10<br/>$ NODE_ENV=test mocha -r ts-node/register test/**/*.test.ts<br/><br/><br/>  server greets people<br/>    ✓ says hello world<br/>    ✓ says hello to a person<br/><br/>  smoke test<br/>    ✓ index responds<br/><br/>  server handles people - positive tests<br/>    ✓ can see existing people<br/>    ✓ can show 'add person' page<br/>    ✓ can add a person and they show in the list<br/><br/>  server handles people - negative tests<br/>    ✓ can't add a person with no name<br/>    ✓ can't add a person with no age<br/>    ✓ can't add a person with non-number age<br/><br/><br/>  9 passing (195ms)<br/><br/>✨  Done in 4.51s.</span></pre><p id="463a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只是触及了Joi的皮毛。我们可以对名称添加更多的限制—例如，它必须超过1个字符。我们可以在年龄上增加一些限制，使它只为正数(这将是合理的！)—如果我们这样做了，那么增加一个负年龄、零年龄等等的测试是有意义的。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="f80c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这是有用的；如果你有任何问题或建议，请告诉我。</p><p id="8986" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有的代码都可以在这个Github repo 中找到，如果你想克隆它并玩的话。</p></div></div>    
</body>
</html>