# Python 中的重载函数

> 原文：<https://levelup.gitconnected.com/overload-functions-in-python-d045375cff04>

函数重载是拥有多个同名但签名/实现不同的函数的能力。当调用重载函数`fn`时，运行时首先评估传递给函数调用的自变量/参数，并据此判断调用相应的实现。

在上面的例子中(用 C++写的)，函数`area`重载了两个实现；一个接受两个参数(都是整数)来表示矩形的长度和宽度，并返回面积；而另一个函数接受圆的整数半径。当我们像`area(7)`一样调用函数`area`时，它调用第二个函数，而`area(3, 4)`调用第一个函数。

# 为什么 Python 中没有函数重载？

Python 不支持函数重载。当我们用相同的名称定义多个函数时，后一个函数总是覆盖前一个函数，因此，在名称空间中，每个函数名总是有一个条目。我们通过调用函数`locals()`和`globals()`来查看 Python 名称空间中存在的内容，这两个函数分别返回本地和全局名称空间。

在定义了一个函数之后调用函数`locals()`，我们看到它返回了一个在本地名称空间中定义的所有变量的字典。字典的关键字是变量的名称，值是该变量的引用/值。当运行时遇到另一个同名函数时，它会更新本地命名空间中的条目，从而消除两个函数共存的可能性。因此 python 不支持函数重载。这是在创建语言时做出的设计决定，但这并不妨碍我们实现它，所以让我们重载一些函数。

# 在 Python 中实现函数重载

我们知道 Python 如何管理名称空间，如果我们想要实现函数重载，我们需要

*   在维护的虚拟名称空间中管理函数定义
*   根据传递给它的参数，找到调用适当函数的方法

为了简单起见，我们将实现函数重载，其中同名的函数通过它接受的参数数量来区分。

# 包装函数

我们创建了一个名为`Function`的类，它包装了任何函数，并通过一个被覆盖的`__call__`方法使其可调用，还公开了一个名为`key`的方法，该方法返回一个元组，该元组使该函数在整个代码库中是唯一的。

在上面的代码片段中，`key`函数返回一个元组，该元组唯一地标识代码库中的函数并保存

*   函数的模块
*   函数所属的类
*   函数的名称
*   函数接受的参数数量

被覆盖的`__call__`方法调用被包装的函数并返回计算出的值(现在这里没有什么特别的)。这使得实例就像函数一样可调用，并且它的行为就像包装的函数一样。

在上面的例子中，函数`area`被包装在`Function`中，并在`func`中实例化。`key()`返回元组，第一个元素是模块名`__main__`，第二个是类`<class 'function'>`，第三个是函数名`area`，第四个是函数`area`接受的参数个数`2`。

该示例还展示了我们如何调用实例`func`，就像通常的`area`函数一样，使用参数`3`和`4`并得到响应`12`，这正是我们本来会调用`area(3, 4)`得到的结果。这种行为在我们和装饰者一起玩的后期会派上用场。

# 构建虚拟命名空间

我们在这里构建的虚拟名称空间将存储我们在定义阶段收集的所有函数。因为只有一个名称空间/注册表，我们创建一个 singleton 类，它保存字典中的函数，它的键不仅仅是函数名，而是我们从`key`函数中得到的元组，它包含在整个代码库中唯一标识函数的元素。通过这样做，我们将能够在注册表中保存函数，即使它们具有相同的名称(但不同的参数),从而促进函数重载。

`Namespace`有一个方法`register`，它将函数`fn`作为一个参数，为它创建一个惟一的键，将它存储在字典中，并返回包装在`Function`的一个实例中的`fn`。这意味着来自`register`函数的返回值也是可调用的，并且(到目前为止)它的行为与被包装的函数`fn`完全相同。

# 使用装饰者作为挂钩

既然我们已经定义了一个能够注册函数的虚拟名称空间，我们需要一个在函数定义期间被调用的钩子；这里使用 Python 装饰器。在 Python 中，装饰器包装一个函数，并允许我们在不修改其结构的情况下向现有函数添加新功能。装饰器接受包装的函数`fn`作为参数，并返回另一个被调用的函数。该函数接受函数调用期间传递的`args`和`kwargs`，并返回值。

下面演示了一个计时函数执行的示例装饰器

在上面的例子中，我们定义了一个名为`my_decorator`的装饰器，它包装了函数`area`，并在`stdout`上打印出执行所花费的时间。

每次解释器遇到函数定义时，都会调用装饰函数`my_decorator`(这样它就包装了被装饰的函数，并将这个新的包装函数存储在 Python 的本地或全局名称空间中),对于我们来说，这是一个理想的钩子，可以在我们的虚拟名称空间中注册函数。因此，我们创建了名为`overload`的装饰器，它在虚拟名称空间中注册函数，并返回一个可调用的。

`overload`装饰器返回`Function`的一个实例，由`.register()`命名空间的函数返回。现在，无论何时调用函数(由`overload`修饰),它都会调用由`.register()`函数返回的函数——一个`Function`的实例，而`__call__`方法会在调用过程中通过指定的`args`和`kwargs`来执行。现在剩下的就是在类`Function`中实现`__call__`方法，这样它就可以调用适当的函数，给出调用过程中传递的参数。

# 从名称空间中寻找正确的函数

除了通常的模块类和名称之外，消歧的范围是函数接受的参数数量，因此我们在虚拟命名空间中定义了一个名为`get`的方法，该方法接受来自 python 命名空间的函数(将是同一名称的最后一个定义——因为我们没有改变 Python 命名空间的默认行为)和调用期间传递的参数(我们的消歧因子),并返回要调用的消歧函数。

这个`get`函数的作用是决定调用哪个函数的实现(如果重载的话)。获取适当函数的过程非常简单——从函数和参数使用`key`函数创建惟一键(就像注册时一样),并查看它是否存在于函数注册表中；如果有，那么就获取针对它存储的实现。

`get`函数创建了`Function`的一个实例，这样它就可以使用`key`函数获得一个惟一的键，而不会复制逻辑。然后使用该键从函数注册表中获取适当的函数。

# 调用函数

如上所述，每次调用用`overload`装饰器装饰的函数时，都会调用类`Function`中的`__call__`方法。我们使用这个函数通过名称空间的`get`函数获取适当的函数，并调用重载函数所需的实现。`__call__`方法实现如下

该方法从虚拟名称空间中获取适当的函数，如果没有找到任何函数，它将引发一个`Exception`，如果找到了，它将调用该函数并返回值。

# 作用中的函数重载

一旦所有代码就绪，我们定义两个名为`area`的函数:一个计算矩形的面积，另一个计算圆形的面积。这两个函数都在下面定义，并用一个`overload`装饰器装饰。

当我们用一个参数调用`area`时，它返回圆的面积，当我们传递两个参数时，它调用计算矩形面积的函数，从而重载函数`area`。你可以在这里找到整个工作演示[。](https://repl.it/@arpitbbhayani/Python-Function-Overloading)

# 结论

Python 不支持函数重载，但是通过使用公共语言结构，我们破解了一个解决方案。我们使用 decorators 和一个用户维护的名称空间来重载函数，并使用参数的数量作为消除歧义的因素。我们还可以使用参数的数据类型(在 decorator 中定义)来消除歧义——这允许具有相同数量参数但不同类型的函数重载。重载的粒度只受限于函数`getfullargspec`和我们的想象力。一个更整洁、更干净和更有效的方法也可以用上面的构造来实现，所以你可以自由地实现一个并发推特给我 [@arpit_bhayani](https://twitter.com/arpit_bhayani) ，我会很高兴知道你用它做了什么。

*如果你喜欢你读到的内容，订阅我的时事通讯，让邮件直接发送到你的收件箱，给我大声喊出来*[*@ arpit _ bhaya ni*](https://twitter.com/arpit_bhayani)*。*

*我的简讯中的往事*

*   [*python 如何实现超长整数？*](https://arpitbhayani.me/blogs/super-long-integers)
*   [*隔离森林异常检测算法*](https://arpitbhayani.me/blogs/isolation-forest)
*   [*伪随机数使用规则 30*](https://arpitbhayani.me/blogs/rule-30)
*   [*关于图像隐写术你需要知道的一切*](https://arpitbhayani.me/blogs/image-steganography)

*本文原载于我的* [*博客 Python 中的重载函数*](https://arpitbhayani.me/blogs/function-overloading) *。*

[![](img/be0338ec8dd04f0565fa3089860ce646.png)](https://arpitbhayani.me/blogs/function-overloading)[![](img/804f478b77eee456747bdd3a983a1a1a.png)](https://arpit.substack.com/)