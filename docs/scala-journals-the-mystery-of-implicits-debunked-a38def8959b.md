# Scala Journals——揭开隐含的神秘面纱

> 原文：<https://levelup.gitconnected.com/scala-journals-the-mystery-of-implicits-debunked-a38def8959b>

![](img/e3045f92504687ae36957d8b66bd57af.png)

来源: [Unsplash](https://unsplash.com/photos/EUqatWCcX-s)

今天我将讲述一个非常有趣的话题——隐含。它们几乎和它们因增加代码库复杂性和调试地狱故事而臭名昭著一样有趣(剧透:你很快就会发现——除非它们被错误地使用)。

所以让我们试着找出**它们是什么****，为什么需要它们**，最重要的是——我们应该在现实生活中什么时候使用它们？事实再次证明，一旦你掌握了基本知识，它们就不像想象中那么可怕了。

# 什么是隐含

随着时间的推移，当您习惯使用 Scala 时，您最终会遇到类似的编译器错误消息:

> **错误**:找不到参数 reads 的隐式值:JsonReads[Order]

我喜欢在英语词典中检查编程术语的意思，以真正尝试并理解为什么某样东西被称为它的样子。所以让我们仔细检查一下**隐含的**在人类语言中是什么意思。 [*柯林斯字典*](https://www.collinsdictionary.com/dictionary/english/implicit) 说:

> "含蓄的东西用间接的方式表达出来."

因此，我们可以对其进行调整，以匹配 Scala 领域:

> 隐含的东西意味着它以间接的方式“在幕后”被传递和使用。

下面是一个隐式值用法的例子。(免责声明:这是一种可怕的做法，但它仅用几行代码就阐明了隐含背后的思想。请不要对这样的事情使用暗示)。密切关注**包**中**位置**的代码片段:

```
// inside com.taxwebsite.StaticValues...
implicit val vat: Double = 0.19
...// inside com.taxwebsite.TaxCalulator
...
def getPriceWithTax(amount: Int)(implicit vat: Double) = amount + amount * vat
...// inside com.taxwebsite.PriceService
**import com.taxwebsite.StaticValues.vat <- important chunk here!**
...
def getFinalPrice(amount: Int) = getPriceWithTax(amount)
...
```

在上面的代码示例中，我们有一个隐式值`vat`，它被导入到`PriceService`的范围内。因为`vat`值被标记为**隐式**，那么就不需要**显式**说`getPriceWithTax(amount)**(vat)**`来满足`getPriceWithTax`签名——`vat`是在幕后通过*。*

*有几种方法可以重现我在开头提到的错误:*

*   *如果我们从`PriceService`移除导入*
*   *…或者如果我们没有将`val vat`标记为隐式*
*   *…或者如果`val vat`不是一个`Double`*
*   *…或者如果`getPriceWithTax`不是一个`Double`*

***重要提示！希望以上分解这种琐碎代码的方法说明了移动部件的数量，以及如果你追求简单的东西的类似实现而不必要地添加了隐含，你会给你未来的同事带来什么样的麻烦。***

## *编译器如何知道将哪个隐式“注入”到哪里？*

*没有“艺术”你无法拼出“地球”，但是没有“**魔法**”你绝对可以拼出“**编译器**”。*

***隐式解析***

*让我们讨论一下编译器在哪里寻找隐含，以及它在看什么。让我们以上面的例子为基础，像编译器一样思考。(*)*

1.  *我打电话给`getFinalPrice`*
2.  *我看到`getFinalPrice`调用了`getPriceWithTax`，它需要一个类型为 Double 的**隐式值(注意编译器并不关心值的名称。只是它的**型*****
3.  *`getFinalPrice`内部有没有**隐式双精度**值？号码*
4.  *`PriceService`中有没有**隐式双**值？号码*
5.  *`PriceService`有伴对象吗？号码*
6.  *在`PriceService`中有包含一个**隐式 Double** 值的导入吗？是的。*
7.  *好的，那么我假设这个值是`getPriceWithTax`需要的**隐式 Double** 值。我会在“幕后”隐晦地传递。*

## *有什么可以含蓄的？*

*不仅仅是`val`或者`var`。也可以是`implicit def`、`implicit class`、`implicit object`。*

# *为什么要使用暗示*

*我故意在**结尾跳过所有细节，可以隐含什么？**一节。我觉得在网上的大部分资料中，例子太多了，但是有两个****最重要的要点**总是被遗漏，这是高级初学者经常遇到的问题。他们在这里:***

1.  ***隐式对象(val、类、定义、对象)本身在日常编程中很少使用。有一组非常严格的用例，你可以将它们添加到你的代码中。在现实世界中，你不会像网上所有资料显示的那样，只写一个隐式对象并四处传递它(包括我上面的税务服务的例子！)***
2.  ***隐含在**更大的画面中发挥作用，**在**设计模式抽象层次上**。我想到的两个例子是实现**类型类**或**隐式转换**。现在我们来看两者。***

## ***类型类别***

***这里我将跳过实现细节。这是一个有点挑战性的设计概念，其中隐含着一些含义。我没有链接到任何资料，只是因为类型类太难了，仅仅通过阅读它们是难以理解的，我不想让你气馁。有一天我会在一篇文章中介绍它们。长话短说，类型类模式允许你(除了别的以外)在一个现有的类型中添加一个新的方法，而不改变这个类型的源代码。***

***所以使用一个类型类，你可以扩展类型`String`来调用一些有趣的东西:***

```
***"Berlin".getCountry***
```

***这就是所谓的**特定多态性**。类型类在一些函数式 Scala 库中被广泛使用，最著名的可能是 [cats](https://typelevel.org/cats/) 。***

*****有趣的事实:**在 Scala 的最新版本 Scala 3 中，类型类和扩展方法应该更容易使用。我承认我还没试过。***

## ***隐式转换***

***另一个设计模式级别的概念，通常用于实现**磁铁模式**。你可以把它看作是当一个不正确的参数类型被传递给一个现有的函数或类时，编译器试图应用的一些方法。他们**隐式地**转换类型，“在幕后”匹配被调用函数的签名。隐式转换的一个有趣例子是如何将 Scala Int 传递给期望 Java 的 Integer 的 Java 方法。***

# ***何时使用暗示***

***因此，我们终于谈到了可能大多数读者都在等待的话题。***

*****现实生活。*****

***我有一种感觉，你们中的大多数人在这个阶段理解隐含背后的思想，但是想不出一个可以使用它们的用例。***

***这很好。**正是如此**。正如我上面已经提到的，你不能像大多数介绍隐式的材料所建议的那样，只写一个隐式对象，然后把它传递出去。***

> ***被不正确的隐含用法污染的新代码库注定会很快变成遗留代码库。***

***除非在一个标准的众所周知的设计模式的框架内使用，或者用于一个众所周知的用例，否则隐式会让你的代码变得非常难以阅读，并且会很快积累大量的技术债务。***

***在现实生活中，你会在以下情况下遇到暗示:***

## *****你需要满足一个库依赖*****

***有大量的库，因为它们的内部设计(通常是类型类)会要求你在作用域中有一些隐含的值。举三个例子:***

*   ***要使用大多数带有**自定义**类型的 JSON serialiser 库，您需要创建一个**隐式读/写对象**，该对象将在您的自定义类型上公开一个类似于`.toJson`的扩展方法，然后导入它。然后可以调用:`Person("Andrew").toJson`***
*   ***要使用 Scala Future，你需要一个**隐式执行上下文**。***
*   ***Scala 的 Duration 看起来 **type class** -y 吧？***

```
***// extension methods for Int imported here, you will find a lot of implicits in this package
import scala.concurrent.Duration._1.second // "second" is an extension method on Int
10.millis // ...so is "millis"***
```

## *****您使用分布式跟踪*****

***我看到了隐式的一个有趣用法，那就是在系统中隐式地传递一个分布式跟踪 ID 和每个请求。结果，业务逻辑没有被分布式跟踪 ID 引用污染——毕竟它们与业务逻辑无关。***

## *****你实现一个类型类模式或者隐式转换*****

***如果你不知道怎么做或者不确定什么时候用，完全没问题。在工作中，到目前为止，我还没有从零开始实现这两个中的任何一个。在大多数情况下，您不会自己编写它们，而可能会使用库中已经存在的东西。***

***![](img/55e35af0e6850955592dacad8d8036b9.png)***

***来源: [Unsplash](https://unsplash.com/photos/qDY9ahp0Mto)***

# ***结论***

***让我们总结一下。***

***什么是暗示？
标有关键字“隐含”的对象。可以是值、变量、对象、类、定义。如果它们被列为另一个对象的依赖项，编译器会在“幕后”拾取它们。编译器只查看隐式值的类型，不查看名称。***

*****它们用在哪里？** 主要在函数库或众所周知的设计模式中，如**类型类**或**隐式转换**。***

***我应该什么时候在代码中使用它们？
不惜一切代价避免，除非你正在实现一个众所周知的设计模式，其他 Scala 工程师可以理解**或**满足一个库依赖。如果使用不当，隐含将使代码难以阅读、测试和维护。
长话短说:
如果其他事情需要暗示——完全没问题，那就提供吧。如果你认为你正在编写的代码中的某些东西需要被隐式化:100 个案例中有 99 个都不需要。***

***(*)当然还有更多——为了简单起见，我跳过了本解释中的大部分细节。***