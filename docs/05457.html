<html>
<head>
<title>Oracle: Order by/Group by/Having clauses and Window Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Oracle: Order by/Group by/Having子句和窗口函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/oracle-order-by-group-by-having-clauses-and-window-functions-d15194dc885b?source=collection_archive---------5-----------------------#2020-08-31">https://levelup.gitconnected.com/oracle-order-by-group-by-having-clauses-and-window-functions-d15194dc885b?source=collection_archive---------5-----------------------#2020-08-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/76eda056c47ca6dc8b5f80435e97efbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YvtN5KCoUy1t84-_.png"/></div></div></figure><p id="8022" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，值得一提的是，Oracle在这里是作为一种集合SQL语言出现的。聚合函数及其应用方式适合整个SQL家族，适用于考虑到每种语言语法的所有查询。</p><p id="e094" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将分两部分简要快速地解释所有的细节。这篇文章很可能对初学者有用。</p><h1 id="1d73" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第1部分<br/>排序依据、分组依据、拥有</h1><h2 id="3c12" class="lx la it bd lb ly lz dn lf ma mb dp lj km mc md ln kq me mf lr ku mg mh lv mi bi translated">以...排序</h2><p id="864b" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">ORDER BY子句允许对输出值进行排序，即按特定列对检索到的值进行排序。排序也可以由子句定义的列别名来应用。</p><p id="fca3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ORDER BY的优点是它可以应用于数值列和字符串列。字符串列通常按字母顺序排序。</p><p id="6793" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，应用升序(ASC)排序。对于降序排序，使用了一个附加的DESC子句。</p><p id="5bab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">语法:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6775" class="lx la it mt b gy mx my l mz na">SELECT column1, column2,... (indicates the name<br/>FROM table_name<br/>ORDER BY column1, column2... ASC | DESC;</span></pre><p id="a927" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们考虑一下例子:</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/bdae8ab8e25f1c42f6c6552f91919b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DW-eAf3CJyAwTFlC.png"/></div></div></figure><p id="4088" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一个表中，我们获取所有数据，并按照ID列对其进行升序排序。</p><p id="0e27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第二个示例中，我们还使用DESC将所有数据按ID列降序排序。</p><p id="3b30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第三个表使用几个字段进行排序。首先，我们按部门排序。如果第一个语句对于具有相同部门的字段是相等的，则应用第二个排序条件；在我们的情况下，是工资。</p><p id="8eb6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这很简单。我们可以指定多个排序条件，这使得我们可以更有效地对输出列表进行排序。</p><h2 id="3efa" class="lx la it bd lb ly lz dn lf ma mb dp lj km mc md ln kq me mf lr ku mg mh lv mi bi translated">分组依据</h2><p id="34db" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">在SQL中，GROUP BY子句收集从数据库中特定组检索的数据。分组将所有数据划分到逻辑集合中，以便可以在每个组中单独执行统计计算。</p><p id="6f0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此子句用于按一列或多列组合选择结果。分组后，列中使用的每个值只有一个条目。</p><p id="3872" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GROUP BY的使用与聚合函数和HAVING语句的使用密切相关。SQL中的聚合函数是对一组列值返回单个值的函数。例如:<strong class="kd iu">计数()，最小值()，最大值()，AVG()，总和()。</strong></p><p id="ebd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">语法:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9fb7" class="lx la it mt b gy mx my l mz na">SELECT column_name(s)<br/>FROM table_name<br/>WHERE condition<br/>GROUP BY column_name(s)<br/>ORDER BY column_name(s);</span></pre><p id="dcae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GROUP BY出现在选择查询中的条件WHERE子句之后。或者，您可以使用ORDER BY对输出值进行排序。</p><p id="b994" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据上例中的表格，我们需要找到每个部门的最高工资。最终的数据选择应该包括部门名称和最高工资。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/323f202d1589c52ad5730a9294efed66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n_vISC-0njlrbhtg.png"/></div></div></figure><p id="9d01" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一个示例中，我们不分组而是使用子查询来解决任务，即将一个查询嵌套到另一个查询中。在第二个解决方案中，我们使用分组。</p><p id="0bb1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个例子更短，可读性更好，尽管它执行的功能与第一个例子相同。</p><p id="3d0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GROUP BY在这里是如何工作的:它首先将两个部门分成QA和dev组，然后寻找每个部门的最高工资。</p><h2 id="90e6" class="lx la it bd lb ly lz dn lf ma mb dp lj km mc md ln kq me mf lr ku mg mh lv mi bi translated">拥有</h2><p id="8ff8" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">HAVING是一个过滤工具。它表示聚合函数性能的结果。HAVING子句用于不能使用WHERE关键字的情况，例如聚合函数。</p><p id="7e87" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然WHERE子句为行筛选定义了谓词，但是HAVING子句在分组后使用，以建立一个逻辑谓词，根据聚合函数值筛选组。该语句对于检查通过聚合函数从多组返回行中获得的值是必需的。</p><p id="232b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">语法:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="40d6" class="lx la it mt b gy mx my l mz na">SELECT column_name(s)<br/>FROM table_name<br/>WHERE condition<br/>GROUP BY column_name(s)<br/>HAVING condition</span></pre><p id="02fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们定义平均工资高于4000的部门，然后使用过滤定义最高工资。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/10508c07620935dd5b228af8aa7c9b96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rbN7n__VmG6l6kUh.png"/></div></div></figure><p id="68b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个示例使用了两个子查询:第一个用于查找最高工资，第二个用于筛选平均工资。第二个例子更简单、更简洁。</p><h2 id="ccf7" class="lx la it bd lb ly lz dn lf ma mb dp lj km mc md ln kq me mf lr ku mg mh lv mi bi translated">查询计划</h2><p id="a637" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">通常情况下，查询会运行很长时间，消耗大量内存资源和磁盘。为了理解为什么查询运行时间长且效率低，我们可以检查查询计划。</p><p id="907f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查询计划是查询的预期执行计划，即DMS将如何执行它。DMS描述了将在子查询中执行的所有操作。分析完一切之后，我们将能够理解查询中的弱点，并使用查询计划来优化它们。</p><p id="5688" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Oracle中执行任何SQL语句都会检索所谓的执行计划。该查询执行计划描述了Oracle将如何根据正在执行的SQL语句获取数据。计划是一棵树，包含一系列的步骤以及它们之间的关系。</p><p id="8a99" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">允许我们获得查询的估计执行计划的工具包括<strong class="kd iu"> Toad、SQL Navigator、PL / SQL Developer </strong>等。这些工具提供了许多查询资源密集度的指标，其中主要的有:成本——执行的<strong class="kd iu">成本</strong>和<strong class="kd iu">基数</strong>(或<strong class="kd iu">行</strong>)。</p><p id="4b91" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些指标的值越高，查询效率越低。</p><p id="bed9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是查询计划分析。第一种解决方案使用子查询；第二种使用分组。请注意，在第一种情况下，处理了22行，在第二种情况下，处理了15行。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/d8d35813f287d124fc399a5bd907a30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_610gyFckHVvvkek.png"/></div></div></figure><p id="93d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一个查询计划分析使用两个子查询:</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/b53ee562350dc8e3b0020941f9c25559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0wuQANBc0dPyMU9T.png"/></div></div></figure><p id="8a9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个无效使用SQL工具的例子，我们不建议在查询中使用它。</p><p id="1e7f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上述所有特性将使您在编写查询时更加轻松，并提高代码的质量和可读性。</p><h1 id="5395" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">第二部分<br/>窗口功能</h1><p id="7e3b" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">Microsoft SQL Server 2005中出现了窗口函数。它们对SELECT子句中给定范围的行执行计算。简而言之，“窗口”是一组进行计算的行。“窗口”允许我们减少数据并更好地处理它。这种特性允许我们将整个数据集分割成多个窗口。</p><p id="aed5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">窗口函数有一个巨大的优势。不需要为计算形成一个数据集，这允许我们用它们唯一的ID保存所有的数据集行。窗口函数操作的结果被添加到另一个字段的结果选择中。</p><p id="0852" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">语法:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="0b4e" class="lx la it mt b gy mx my l mz na">SELECT column_name(s) Aggregate function (column for calculation) OVER ([PARTITION BY column to the group] FROM table_name [ORDER BY column to sort] [ROWS or RANGE to delimit rows within a group])</span></pre><p id="ad4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">OVER PARTITION BY是定义窗口大小的属性。您可以在这里指定附加信息；例如，行号。</p><p id="65b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们考虑下面的例子:另一个部门被添加到我们的表中，现在那里有15行。我们将尝试导出员工、他们的工资以及组织的最高工资。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/3fcdd04139e441d5d44413833568f71b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vh8jy80MWChq-fyD.png"/></div></div></figure><p id="c297" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一个字段中，我们取名字，在第二个字段中—取薪水。接下来，我们使用<strong class="kd iu"> over () </strong>窗口函数来获得整个组织的最大工资，因为没有指明窗口大小。<strong class="kd iu"> Over () </strong>带空括号适用于整个选择。所以工资最高一万。窗口函数的结果被添加到每一行。</p><p id="32ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们从查询的第四行中删除对窗口函数的提及，也就是说，只剩下<strong class="kd iu"> max (salary) </strong>，该查询将不起作用。最高工资根本无法计算。由于数据将被逐行处理，并且在调用<strong class="kd iu"> max (salary) </strong>时，当前行将只有一个值，即当前雇员的值。这就是窗口函数的优势所在。在调用时，它处理整个窗口和所有可用的数据。</p><p id="f6cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们考虑另一个例子，我们需要得到每个部门的最高工资:</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/d4c53b86e0313ecb1caf301dfd72072f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5V-PkGE1VGk0TbIz.png"/></div></div></figure><p id="a3cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们设置窗口的框架(窗口函数操作的一组行)，将它分成几个部门。我们有三个部门:开发部、质量部和销售部。</p><p id="586f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该窗口查找每个部门的最高薪金。作为选择的结果，我们看到它首先找到了开发人员的最高工资，然后是QA，然后是销售。如上所述，窗口函数的结果被写入每一行的获取结果中。</p><p id="78fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是分区的工作原理。</p><h1 id="996e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="c93d" class="pw-post-body-paragraph kb kc it kd b ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku mn kw kx ky im bi translated">SQL并不像乍看起来那么简单。上面描述的都是窗口函数的基本功能。在他们的帮助下，你可以“简化”你的查询。但是其中隐藏着更多的潜力:有一些实用子句(例如，行或范围)可以组合起来为查询添加更多的功能。</p><p id="08cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望这篇文章对每个对这个话题感兴趣的人都有用。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="8e72" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="np">原载于2020年8月31日https://intexsoft.com</em><em class="np">的</em> <a class="ae nq" href="https://intexsoft.com/" rel="noopener ugc nofollow" target="_blank"> <em class="np">。</em></a></p></div></div>    
</body>
</html>