<html>
<head>
<title>Centralized authentication with a microservices gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过微服务网关进行集中认证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/centralized-authentication-with-a-microservices-gateway-aa83f7211a1b?source=collection_archive---------6-----------------------#2020-10-01">https://levelup.gitconnected.com/centralized-authentication-with-a-microservices-gateway-aa83f7211a1b?source=collection_archive---------6-----------------------#2020-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将为路由到两个不同微服务的网关API应用程序实现身份验证和授权。FusionAuth将成为网关的认证服务器。</p><p id="8d51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">带有微服务的API网关是企业架构的常见模式。在本帖中，我们将假装我们正在为一个电子商务企业设置这个。我们的网关应用程序是一个中央API，它将控制对产品目录服务和产品库存服务的访问。我们将允许客户访问公共端点，但要求对一些产品清单端点进行身份验证。</p><p id="f8a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于本文，我们需要一个正在运行的FusionAuth实例和三个简单的Node/Express应用程序。您可以下载本文的<a class="ae kl" href="https://github.com/FusionAuth/fusionauth-example-node-services-gateway" rel="noopener ugc nofollow" target="_blank">示例项目</a>，并相应地定制您的FusionAuth配置，或者您也可以从概念上遵循。</p><p id="e45c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想跟着做，先浏览一下<a class="ae kl" href="https://fusionauth.io/docs/v1/tech/5-minute-setup-guide" rel="noopener ugc nofollow" target="_blank"> 5分钟设置指南</a>会很有帮助，因为这将在FusionAuth中设置所需的用户和角色。</p><p id="7d8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在以下端口上运行四个应用程序:</p><ul class=""><li id="80d1" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">FusionAuth: <code class="fe kv kw kx ky b">9011</code></li><li id="9987" class="km kn iq jp b jq kz ju la jy lb kc lc kg ld kk kr ks kt ku bi translated">网关应用:<code class="fe kv kw kx ky b">3000</code></li><li id="d767" class="km kn iq jp b jq kz ju la jy lb kc lc kg ld kk kr ks kt ku bi translated">产品目录服务:<code class="fe kv kw kx ky b">3001</code></li><li id="d6db" class="km kn iq jp b jq kz ju la jy lb kc lc kg ld kk kr ks kt ku bi translated">产品库存服务:<code class="fe kv kw kx ky b">3002</code></li></ul><p id="4e97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将涉及相当多的身份验证和授权，所以让我们简单地澄清一下这些术语的含义。</p><h1 id="e313" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">认证和授权</h1><p id="6859" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">认证是对特定用户的验证。当用户登录时，他们对应用程序说，“嘿，这是真正的无名氏，让我进去。”应用程序验证他们的凭据，他们就可以访问。</p><p id="89ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的API gateway中，我们将根据上面提到的5分钟设置指南使用FusionAuth。我们将在稍后设置API网关应用程序时讨论具体的细节。</p><p id="1fcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">授权是我们验证特定用户(如John Doe)有权访问我们系统的某些部分(如产品库存)的过程。在我们的电子商务生态系统中，我们将要求产品库存API的授权，但不要求基本产品API的授权，因为我们希望每个人都能访问后者。对于产品库存路径，我们将允许具有“管理员”角色的用户访问。</p><h1 id="a39d" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">产品目录服务</h1><p id="10e8" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们将很快回到认证和授权，但是让我们开始构建我们的应用程序吧！我们将从服务开始，向网关应用程序发展。</p><h1 id="ce47" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设置nodejs产品目录</h1><p id="3f52" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">在开始之前，您需要安装node(用版本14测试代码)。如果你没有安装，从<a class="ae kl" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">节点网站</a>下载。</p><p id="5c8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将<a class="ae kl" href="https://github.com/FusionAuth/fusionauth-example-node-services-gateway" rel="noopener ugc nofollow" target="_blank">项目</a>克隆到您的本地计算机上，并将<code class="fe kv kw kx ky b">cd</code>克隆到目录中。</p><p id="74da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您会注意到与我们的应用程序相对应的三个文件夹:<code class="fe kv kw kx ky b">gateway</code>、<code class="fe kv kw kx ky b">product-catalog</code>和<code class="fe kv kw kx ky b">product-inventory</code>。继续操作<code class="fe kv kw kx ky b">cd</code>进入<code class="fe kv kw kx ky b">product-catalog</code>应用程序，并执行以下操作:</p><ul class=""><li id="da0e" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">运行<code class="fe kv kw kx ky b">npm install</code>来安装依赖项。</li><li id="2c4b" class="km kn iq jp b jq kz ju la jy lb kc lc kg ld kk kr ks kt ku bi translated">通过运行<code class="fe kv kw kx ky b">npm start</code>启动应用程序。它应该在端口<code class="fe kv kw kx ky b">3001</code>上运行，该端口在<code class="fe kv kw kx ky b">bin/www</code>中定义。</li></ul><p id="cddb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然您的应用程序已经启动并运行，您应该能够向它发送请求并获得响应。在一个单独的终端窗口中运行这个<code class="fe kv kw kx ky b">curl</code>命令，您应该得到一个成功的响应，其中包含一个空的产品列表(<code class="fe kv kw kx ky b">products: []</code>):</p><pre class="mh mi mj mk gt ml ky mm mn aw mo bi"><span id="6de4" class="mp lf iq ky b gy mq mr l ms mt">curl <a class="ae kl" href="http://localhost:3001/products" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/products</a></span></pre><p id="79db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们打开它的引擎盖，查看给出我们<code class="fe kv kw kx ky b">/products</code>路线的<code class="fe kv kw kx ky b">routes/index.js</code>文件。</p><pre class="mh mi mj mk gt ml ky mm mn aw mo bi"><span id="fe5f" class="mp lf iq ky b gy mq mr l ms mt">const express = require('express');<br/>const router = express.Router();</span><span id="c671" class="mp lf iq ky b gy mu mr l ms mt">router.get('/products', function(req, res, next) {<br/>  res.json('products: []')<br/>});</span><span id="e295" class="mp lf iq ky b gy mu mr l ms mt">router.get('/products/:id', function(req, res, next) {<br/>  res.json(`product: ${req.params.id}`)<br/>});</span><span id="8a6e" class="mp lf iq ky b gy mu mr l ms mt">module.exports = router;</span></pre><p id="3676" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经创建了两条基本路线，<code class="fe kv kw kx ky b">/products</code>和<code class="fe kv kw kx ky b">/products/:id</code>，因此我们可以获得产品列表和单个产品。显然，对于真正的微服务，这些路由将从数据存储中请求产品信息。现在，前者返回一个空数组<code class="fe kv kw kx ky b">[]</code>，后者返回请求的产品id。</p><p id="961f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试修改您的curl请求以添加一个产品ID，请注意，响应将指示您所请求的特定ID。</p><p id="0d4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">产品目录服务已经准备就绪！</p><h1 id="16ab" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">产品库存服务</h1><p id="3535" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">打开另一个终端窗口，进入<code class="fe kv kw kx ky b">product-inventory</code>文件夹。运行<code class="fe kv kw kx ky b">npm install</code>安装所需的依赖项。</p><p id="4912" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们的产品库存服务的样子(在<code class="fe kv kw kx ky b">routes/index.js</code>):</p><pre class="mh mi mj mk gt ml ky mm mn aw mo bi"><span id="69c2" class="mp lf iq ky b gy mq mr l ms mt">const express = require('express');<br/>const router = express.Router();</span><span id="4ea2" class="mp lf iq ky b gy mu mr l ms mt">router.get('/branches/:id/products', function(req, res, next) {<br/>  const roles = req.headers.roles;<br/>  if (roles &amp;&amp; roles.includes('admin')) {<br/>    res.json(`Products for branch #${req.params.id}`);<br/>  } else {<br/>    res.redirect(403, 'http://localhost:3000');<br/>    return;<br/>  }<br/>});</span><span id="7e90" class="mp lf iq ky b gy mu mr l ms mt">module.exports = router;</span></pre><p id="23a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这项服务中，我们只有一条路线，为特定的商店或分店获取产品。但是，请注意，我们是基于在<code class="fe kv kw kx ky b">roles</code>头中包含的<code class="fe kv kw kx ky b">admin</code>角色来允许(或拒绝)访问的。API网关应用程序将负责将这些数据传递给我们的产品库存服务。</p><p id="d52e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您要启动服务(继续用<code class="fe kv kw kx ky b">npm start</code>来做)并向<code class="fe kv kw kx ky b">http://localhost:3002/branches/1/products</code>发送请求，您应该会收到一个403。您可以通过添加一个值为<code class="fe kv kw kx ky b">admin</code>的<code class="fe kv kw kx ky b">roles</code>报头来模拟一个成功的响应:</p><pre class="mh mi mj mk gt ml ky mm mn aw mo bi"><span id="cd40" class="mp lf iq ky b gy mq mr l ms mt">curl -i -H "Accept: application/json" -H "Content-Type: application/json" -H "roles: admin" <a class="ae kl" href="http://localhost:3002/branches/1/products" rel="noopener ugc nofollow" target="_blank">http://localhost:3002/branches/1/products</a></span></pre><p id="cc7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经启动并运行了产品库存服务，并授权确保只有管理员才能访问分支机构的产品列表。在服务级别进行授权检查允许我们精确地实现授权。</p><h1 id="67ef" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">微服务的API级认证</h1><p id="2a6c" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">关于API级身份验证的简要说明。我们正在通过API网关实现集中认证。只有网关可以访问这些微服务。您可以在网络级别完成这项工作，或者使用某种形式的API级别的认证，比如一个<a class="ae kl" href="https://microservice-api-patterns.org/patterns/quality/qualityManagementAndGovernance/APIKey" rel="noopener ugc nofollow" target="_blank"> API密匙</a>。对于我们来说，在本文中涉及的内容有点多，但这绝对是您在将微服务投入生产之前想要实现的事情。</p><h1 id="f714" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">网关应用程序</h1><p id="036d" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">现在我们已经在端口<code class="fe kv kw kx ky b">3001</code>和<code class="fe kv kw kx ky b">3002</code>上运行了产品目录和产品库存服务，我们已经准备好处理API网关应用程序了。</p><p id="355a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们深入研究代码之前，让我们简要讨论一下为什么我们要创建自己的网关，而不是使用像<a class="ae kl" href="https://apigee.com/about/cp/api-gateway" rel="noopener ugc nofollow" target="_blank"> Apigee </a>或<a class="ae kl" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html" rel="noopener ugc nofollow" target="_blank">亚马逊的API网关</a>这样的东西。我们当然可以走这条路，但在创建我们自己的网关时，我们有最大的灵活性。了解网关应用程序到底在做什么还有另外一个好处。</p><p id="56a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的网关应用程序简单而轻量。它主要充当路由器，将请求定向到适当的服务。但是，因为它是我们分布式服务的门户，所以它是集中式用户级身份验证检查的最佳位置。</p><h1 id="1bc8" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">集中式认证</h1><p id="a0ea" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">集中身份验证是一种常见的模式，因为身份验证主要只是一种检查，以确保:</p><ul class=""><li id="cb1f" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">用户已登录</li><li id="6b3c" class="km kn iq jp b jq kz ju la jy lb kc lc kg ld kk kr ks kt ku bi translated">用户就是他们所说的那个人</li></ul><p id="4dd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在电子商务领域中的独立服务的上下文中，我们希望有这种集中的身份验证，以便在网关中进行一次检查就可以让用户访问服务，假设他们的凭据检查通过。在将路由转发给正确的服务之前，我们将使用FusionAuth来认证我们的每条路由。</p><h1 id="9167" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">FusionAuth设置</h1><p id="e50f" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">打开另一个终端窗口，进入<code class="fe kv kw kx ky b">gateway</code> director，运行<code class="fe kv kw kx ky b">npm install</code>。</p><p id="964a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前往<a class="ae kl" href="https://fusionauth.io/docs/v1/tech/5-minute-setup-guide" rel="noopener ugc nofollow" target="_blank">fusion auth的5分钟设置指南</a>。在设置过程中，您配置的应用程序将链接到我们的网关应用程序，因此您可以将其命名为“gateway”。请注意，虽然FusionAuth支持多租户配置，但这里您是在默认租户中设置一切。</p><p id="3052" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用您的FusionAuth应用程序的客户端ID和密码更新<code class="fe kv kw kx ky b">gateway</code>目录中的<code class="fe kv kw kx ky b">routes/index.js</code>,用您的客户端ID更新<code class="fe kv kw kx ky b">views/index.pug</code>。然后通过运行<code class="fe kv kw kx ky b">npm start</code>启动应用程序。</p><p id="8dd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个应用程序将是我们服务的网关(因此得名),所以在这一点上，我们应该只通过网关应用程序来访问我们的服务。运行<code class="fe kv kw kx ky b">/products</code>的<code class="fe kv kw kx ky b">curl</code>命令，但是在端口<code class="fe kv kw kx ky b">3000</code>上运行，这将影响我们的网关应用程序。</p><pre class="mh mi mj mk gt ml ky mm mn aw mo bi"><span id="fa6e" class="mp lf iq ky b gy mq mr l ms mt">curl <a class="ae kl" href="http://localhost:3000/products" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/products</a></span></pre><p id="f3b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们通过网关应用程序传输流量，并将其转发到产品目录服务。您可以通过打开正在运行的产品目录服务的终端窗口并检查日志来验证这一点。您应该会看到我们刚刚发送的请求到达该服务器:</p><pre class="mh mi mj mk gt ml ky mm mn aw mo bi"><span id="fbab" class="mp lf iq ky b gy mq mr l ms mt">GET /products 200</span></pre><h1 id="252a" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">路线</h1><p id="f76f" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">让我们一步一步地浏览网关应用程序的<code class="fe kv kw kx ky b">routes/index.js</code>文件。我们首先需要必要的文件并设置一个<code class="fe kv kw kx ky b">FusionAuthClient</code>。我们还包括一个方便的认证中间件，我们将在我们的路线上使用。</p><pre class="mh mi mj mk gt ml ky mm mn aw mo bi"><span id="92a1" class="mp lf iq ky b gy mq mr l ms mt">// ...<br/>const request = require('request');<br/>const express = require('express');<br/>const router = express.Router();<br/>const {FusionAuthClient} = require('@fusionauth/typescript-client');<br/>const clientId = [YOUR_CLIENT_ID];<br/>const clientSecret = [YOUR_CLIENT_SECRET];<br/>const client = new FusionAuthClient('noapikeyneeded', 'http://localhost:9011');<br/>const checkAuthentication = require('../middleware');<br/>// ...</span></pre><p id="cde9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的网关应用程序以及我们的服务都基于<a class="ae kl" href="https://github.com/FusionAuth/fusionauth-example-node" rel="noopener ugc nofollow" target="_blank">fusionauth-example-node</a>项目，该项目为我们提供了与fusion auth进行交互的基本UI(在根处)。我们也有OAuth重定向的路由:</p><pre class="mh mi mj mk gt ml ky mm mn aw mo bi"><span id="4fc6" class="mp lf iq ky b gy mq mr l ms mt">// ...<br/>/* GET home page. */<br/>router.get('/', function (req, res, next) {<br/>  const stateValue = Math.random().toString(36).substring(2,15) + Math.random().toString(36).substring(2,15) + Math.random().toString(36).substring(2,15) + Math.random().toString(36).substring(2,15) + Math.random().toString(36).substring(2,15) + Math.random().toString(36).substring(2,15);<br/>  req.session.stateValue = stateValue<br/>  res.render('index', {user: req.session.user, stateValue: stateValue, title: 'FusionAuth Example'});<br/>});</span><span id="3d21" class="mp lf iq ky b gy mu mr l ms mt">/* OAuth return from FusionAuth */<br/>router.get('/oauth-redirect', function (req, res, next) {<br/>  // This code stores the user in a server-side session<br/>  const stateFromServer = req.query.state;<br/>  if (stateFromServer !== req.session.stateValue) {<br/>    console.log("State doesn't match. uh-oh.");<br/>    console.log("Saw: "+stateFromServer+ ", but expected: "+req.session.stateValue);<br/>    res.redirect(302, '/');<br/>    return;<br/>  }<br/>  client.exchangeOAuthCodeForAccessToken(req.query.code,<br/>                                         clientId,<br/>                                         clientSecret,<br/>                                         'http://localhost:3000/oauth-redirect')<br/>      .then((response) =&gt; {<br/>        console.log(response.response.access_token);<br/>        return client.retrieveUserUsingJWT(response.response.access_token);<br/>      })<br/>      .then((response) =&gt; {<br/>        req.session.user = response.response.user;<br/>      })<br/>      .then((response) =&gt; {<br/>        res.redirect(302, '/');<br/>      }).catch((err) =&gt; {console.log("in error"); console.error(JSON.stringify(err));});<br/>});<br/>// ...</span></pre><p id="210e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，随着网关服务器的运行，您应该能够在浏览器中转至<code class="fe kv kw kx ky b">http://localhost:3000</code>并看到以下内容:</p><figure class="mh mi mj mk gt mw gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mv"><img src="../Images/3951bc2b064f82849e09bb7fab57e663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-GilIJjCjAR-o5Q4.png"/></div></div></figure><p id="c5aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们的设置工作正常，您应该能够点击“登录”。使用您之前设置的用户登录FusionAuth。您将看到一条“您好[您的姓名]”消息。</p><p id="11f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个UI在API网关应用程序的典型使用中不是必需的，但它是一个简单的、可视化的方法，可以让我们演示成功的OAuth登录。</p><p id="1c8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看我们的<code class="fe kv kw kx ky b">routes/index.js</code>文件的剩余部分，我们已经得到了转发到产品目录和产品库存服务的路线。</p><pre class="mh mi mj mk gt ml ky mm mn aw mo bi"><span id="bf76" class="mp lf iq ky b gy mq mr l ms mt">// ...<br/>/* PRODUCT CATALOG ROUTES */<br/>const productUrl = 'http://localhost:3001';</span><span id="86c9" class="mp lf iq ky b gy mu mr l ms mt">router.get('/products', function(req, res, next) {<br/>  request(`${productUrl}/products`).pipe(res);<br/>});</span><span id="66aa" class="mp lf iq ky b gy mu mr l ms mt">router.get('/products/:id', function(req, res, next) {<br/>  request(`${productUrl}/products/${req.params.id}`).pipe(res);<br/>});<br/>// ...</span></pre><p id="dfd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些路由是完全公开的，不需要端点级别的身份验证，因为我们希望客户和员工都能查看产品。我们想让他们买些东西，对吧？这些路由将转发到端口3001上的产品目录服务。不过，如果目录中有任何部分需要保护，我们已经构建了基础架构。</p><p id="5819" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在对于产品盘点路线，要在分支机构检索产品:</p><pre class="mh mi mj mk gt ml ky mm mn aw mo bi"><span id="8735" class="mp lf iq ky b gy mq mr l ms mt">// ...<br/>/* PRODUCT INVENTORY ROUTES */<br/>router.get('/branches/:id/products', checkAuthentication, function(req, res, next) {<br/>  const user = req.session.user;<br/>  const options = {<br/>    url: `http://localhost:3002/branches/${req.params.id}/products`,<br/>    headers: { roles: user.registrations[0].roles }<br/>  };<br/>  request(options).pipe(res);<br/>});<br/>// ...</span></pre><p id="fa47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此路由将转发给我们的产品库存服务。<code class="fe kv kw kx ky b">checkAuthentication</code>中间件可用于我们希望检查用户是否通过身份验证的任何路由；如果用户没有登录，它会将用户发送回根URL。</p><p id="a93c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用您的浏览器(利用我们的OAuth凭据，因为我们已登录)，转到<code class="fe kv kw kx ky b">http://localhost:3000/branches/1/products</code>。这是因为您在<a class="ae kl" href="https://fusionauth.io/docs/v1/tech/5-minute-setup-guide" rel="noopener ugc nofollow" target="_blank"> 5分钟设置指南</a>中设置的用户在FusionAuth中有一个<code class="fe kv kw kx ky b">admin</code>角色，我们将该角色作为标题传递给产品库存服务。</p><h1 id="c956" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="27e9" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们在这篇文章中谈到了很多。我们的目标是创建一个基本的电子商务生态系统，其中包含一个API网关应用程序和两个微服务，一个产品目录服务和一个产品清单服务。</p><p id="0bb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于API网关，我们利用FusionAuth进行集中身份验证和授权。然后，我们创建了两个服务的转发路由，能够将角色传递给服务。在服务本身中，我们实现了基于用户角色在端点级别允许或拒绝请求的能力。</p><p id="789a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想进一步了解这一点，您可以:</p><ul class=""><li id="cada" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">添加更多用户和角色；例如，可以查看某个分支的产品的<code class="fe kv kw kx ky b">branch-manager</code>角色。</li><li id="7f2b" class="km kn iq jp b jq kz ju la jy lb kc lc kg ld kk kr ks kt ku bi translated">构建产品和分支表，并让微服务返回动态数据。</li><li id="4923" class="km kn iq jp b jq kz ju la jy lb kc lc kg ld kk kr ks kt ku bi translated">构建应用程序以显示可用产品。</li></ul><p id="a40b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快乐编码！</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="ef7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nk">原文发表于</em> <a class="ae kl" href="https://fusionauth.io/blog/2020/09/15/microservices-gateway" rel="noopener ugc nofollow" target="_blank"> <em class="nk">。</em></a></p></div></div>    
</body>
</html>