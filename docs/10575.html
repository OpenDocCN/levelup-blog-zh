<html>
<head>
<title>Learning Solidity with Ease — Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轻松学习扎实——简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-solidity-with-ease-introduction-121281d36ad7?source=collection_archive---------8-----------------------#2021-12-22">https://levelup.gitconnected.com/learning-solidity-with-ease-introduction-121281d36ad7?source=collection_archive---------8-----------------------#2021-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/7946d5187c4580740b6d9cbb5babb3d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*04FXfJMltsYIEDoyt7Lfow.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">在<a class="ae jg" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jg" href="https://unsplash.com/@hiteshchoudhary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hitesh Choudhary </a>拍摄的照片</figcaption></figure><div class=""/><p id="470d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Solidity是一种面向对象的通用编程语言。Solidity用于在以太坊网络上编写智能合约。互联网上有很多可用的资源。然而，从不同的资源中收集信息需要很大的努力。所以我决定把这些资源做笔记，作为文章发表。在这篇文章中，我们将关注Solidity语言的基础。</p><h2 id="c6c2" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated"><strong class="ak">先决条件:</strong></h2><ol class=""><li id="2e8e" class="lx ly jj ki b kj lz kn ma kr mb kv mc kz md ld me mf mg mh bi translated">以太坊区块链的基本认识</li><li id="6e5b" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">对任何编程语言的基本理解</li></ol><h2 id="5d40" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">目录</h2><ol class=""><li id="d093" class="lx ly jj ki b kj lz kn ma kr mb kv mc kz md ld me mf mg mh bi translated">区块链网络</li><li id="4839" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">混音IDE—<a class="ae jg" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank">https://remix.ethereum.org/</a></li><li id="4534" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">智能合同</li><li id="1103" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">合同——写下你的第一份合同</li><li id="700c" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">基本数据类型</li><li id="e601" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">经营者</li><li id="80d6" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">功能</li><li id="f2bd" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">高级数据结构</li><li id="2680" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">范围和可见性</li></ol><h2 id="e31a" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">1.区块链网络</h2><p id="e1bd" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">以太坊生态系统是一个复杂的架构。它由许多组件组成。简单地说，区块链网络是一个分布式系统，您可以在其中部署智能合同，并使用智能合同编写业务逻辑。业务逻辑可以简单到在区块链网络上转储数据，也可以复杂到在区块链网络上构建整个运输管理。在现实世界中，你可能想也可能不想创建自己的网络。以太坊是一种公共的分布式大型技术，所有人都可以使用。在接下来的文章中，我们将学习如何创建自己的网络。在这篇文章中，我们将着重于对可靠性语言的基本理解。</p><h2 id="e2e1" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">2.混合IDE</h2><p id="ffc3" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">正如我上面提到的，创建区块链网络是一个复杂的过程。所以对于本文，我们将使用<a class="ae jg" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix IDE。Remix IDE是一个开发环境，我们可以在其中部署不同类型的区块链网络并与之交互。目前使用Remix，我们可以在<strong class="ki jk"> Javascript VM </strong>、<strong class="ki jk">注入web3 </strong>或<strong class="ki jk"> Web3提供者</strong>上工作。</a></p><ul class=""><li id="d0d6" class="lx ly jj ki b kj kk kn ko kr mq kv mr kz ms ld mt mf mg mh bi translated">Javascript VM是一个虚拟环境，就像模拟测试网一样，你可以在虚拟环境中工作。数据将在会话结束时被清除。</li><li id="0deb" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld mt mf mg mh bi translated">使用<strong class="ki jk">注入的web3，</strong>你可以使用<a class="ae jg" href="https://web3js.readthedocs.io/en/v1.5.2/" rel="noopener ugc nofollow" target="_blank"> Web3 </a>库/协议与不同的公共网络交互。为此，你可能需要一个客户端应用程序，如<a class="ae jg" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> MetaMask </a>。</li><li id="63d5" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld mt mf mg mh bi translated">如果你已经建立了自己的关系网。您可以使用<strong class="ki jk"> Web3提供商进行连接。</strong></li></ul><p id="36ba" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">注意:</strong>在本文中，我们将使用<strong class="ki jk"> Javascript VM </strong></p><h2 id="644c" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">3.智能合同</h2><p id="de2f" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">智能合约只是存储在区块链上的程序，在满足预定条件时运行。该定义摘自<a class="ae jg" href="https://www.ibm.com/sa-en/topics/smart-contracts" rel="noopener ugc nofollow" target="_blank">主题/智能合同</a>。智能契约通常包含共享资源及其所有权的业务逻辑。</p><p id="f1b0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们创建我们的第一个智能合同。打开RemixIDE，在<strong class="ki jk"> contracts </strong>文件夹下创建一个文件(<strong class="ki jk"> FirstContract.sol </strong>)。</p><figure class="mv mw mx my gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mu"><img src="../Images/a86c017c9b7da82c64c53aafdb424f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCMLrdPWwjbw65AMa6l1Qw.png"/></div></div></figure><p id="8d18" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有智能合约都以<strong class="ki jk">结尾。sol </strong>扩展。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="b23a" class="le lf jj na b gy ne nf l ng nh">// <strong class="na jk">FirstContract.sol<br/></strong></span><span id="a5be" class="le lf jj na b gy ni nf l ng nh">// SPDX-License-Identifier: GPL-3.0</span><span id="8729" class="le lf jj na b gy ni nf l ng nh">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span></pre><figure class="mv mw mx my gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/9e111fdca0ff9d76b0aa3717d206a459.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*5D4cfkvH1IaHjqCeiPO25w.png"/></div></figure><p id="04c1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编写智能合同所需的最少代码是提及solidity版本。现在你可以导航到编译器标签来编译<strong class="ki jk"> FirstContract.sol </strong>。一旦你编译，你不会看到任何事情发生。因为我们还没有写任何合同。</p><h2 id="22e1" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated"><strong class="ak"> 4。合同——写下你的第一份合同</strong></h2><p id="43c6" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">契约非常类似于面向对象编程中的类。它包含变量和函数。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="cf0a" class="le lf jj na b gy ne nf l ng nh">pragma solidity &gt;=0.7.0 &lt;0.9.0;</span><span id="e9c1" class="le lf jj na b gy ni nf l ng nh">contract Person {<br/>   string public name = "Deepak";<br/>}</span></pre><p id="0cb7" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以保存文件，编译并部署到<strong class="ki jk"> Javascript VM。</strong>一旦部署了契约，就可以交互获得一个相当于<strong class="ki jk">“Deepak”的名字。在上面的例子中，名字的作用域是public。这将创建一个getter函数来访问名称。我们将在本文后面学习作用域。</strong></p><p id="1b5e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">要了解更多关于编译和部署的信息，请阅读</strong><a class="ae jg" href="https://remix-ide.readthedocs.io/en/latest/create_deploy.html" rel="noopener ugc nofollow" target="_blank"><strong class="ki jk">create _ deploy</strong></a><strong class="ki jk">。</strong></p><h2 id="ed6d" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated"><strong class="ak"> 5。</strong>基本数据类型</h2><p id="08da" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">就像任何编程语言一样，Solidity有多种预定义的数据类型来处理区块链网络上的数据。数据既可以作为局部变量存储，也可以作为全局状态存储在网络中。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e66d" class="le lf jj na b gy ne nf l ng nh">pragma solidity ^0.8.1;<br/><br/>contract Person {<br/>    string public name;<br/>    uint256 public age;<br/>    address public paddress;<br/><br/>    function setDetail(string memory _name, uint256 _age)<br/>        public<br/>        returns (<br/>            string memory,<br/>            uint256,<br/>            address<br/>        )<br/>    {<br/>        name = _name;<br/>        age = _age;<br/>        paddress = msg.sender;<br/>        return (name, age, paddress);<br/>    }<br/>}</span></pre><p id="80b6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">局部变量是用-in函数创建的，一旦程序退出函数，它就会被销毁。状态变量与契约一起被创建，并且一旦契约在网络中被破坏，状态变量就被破坏。<br/>我们来看例子。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="883c" class="le lf jj na b gy ne nf l ng nh">function f(uint[] memory c) public {<br/>    // stores a reference to ``s`` in ``g``<br/>    StructType storage g = s;<br/>    // also changes ``s.moreInfo``.<br/>    g.moreInfo = 2;<br/>    // assigns a copy because ``g.contents``<br/>    // is not a local variable, but a member of<br/>    // a local variable.<br/>    g.contents = c;<br/>}</span></pre><p id="c3ec" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">详细了解数据类型:</strong>T3】docs.soliditylang.org/types</p><h2 id="a10d" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated"><strong class="ak"> 6。操作员</strong></h2><p id="9b4b" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">编程语言中的运算符是一个符号，它告诉编译器或解释器执行特定的数学、关系或逻辑运算，并产生最终结果[ref:<a class="ae jg" href="https://www.tutorialspoint.com/computer_programming/computer_programming_operators.htm" rel="noopener ugc nofollow" target="_blank">computer _ programming _ operators</a>]。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6375" class="le lf jj na b gy ne nf l ng nh">pragma solidity 0.4.8;</span><span id="9132" class="le lf jj na b gy ni nf l ng nh">contract Operators {</span><span id="9e29" class="le lf jj na b gy ni nf l ng nh">// Arithmatic Operators<br/>    uint a = 10;<br/>    // +, -, unary -, unary +, *, /, % (remainder), ** (exponentiation)<br/>    uint b = 2**3; // b = 8</span><span id="861c" class="le lf jj na b gy ni nf l ng nh">// a++ and a-- are equivalent to a += 1 / a -= 1 <br/>    // but the expression itself still has the previous value of a. <br/>    // In contrast, --a and ++a have the same effect on a but return the value after the change.<br/>    a = a++; // a = 10<br/>    a = ++a; // a = 11</span><span id="6476" class="le lf jj na b gy ni nf l ng nh">// a += e is equivalent to a = a + e. <br/>    // The operators -=, *=, /=, %=, a |=, &amp;= and ^= are defined accordingly. <br/>    a += 5; // a = 11+5 = 16</span><span id="d816" class="le lf jj na b gy ni nf l ng nh">// Logical Operators<br/>    // ! (logical negation)<br/>    // &amp;&amp; (logical conjunction, “and”)<br/>    // || (logical disjunction, “or”)<br/>    // == (equality)<br/>    // != (inequality)<br/>    bool isOwner;<br/>    isOwner = isMortal &amp;&amp; hasWriteAccess;<br/>    isOwner = true &amp;&amp; false; // false<br/>    isOwner = true || false; // true<br/>    isOwner = !false; // true<br/>    var check = (1 ether == 1000 finney); // true<br/>    var check = (1 ether != 2000 finney); // true</span><span id="c647" class="le lf jj na b gy ni nf l ng nh">// Bitwise Operators<br/>    // &amp; Bitwise AND <br/>    // | Bitwise OR <br/>    // ^ Bitwise exclusive OR <br/>    // ~ Bbitwise negation<br/>    // &gt;&gt; Bitwise right shift<br/>    // &lt;&lt; Bitwise left shift<br/>    var orValue = 0x02 | 0x01; // orValue = 0x03<br/>    uint shiftValue = 0x01 &lt;&lt; 2; // shiftValue = 4</span><span id="49ae" class="le lf jj na b gy ni nf l ng nh">// Define consutruct here<br/>    function Operators(uint initialCoins) {<br/>       // Initialize state variables here<br/>    }</span><span id="1915" class="le lf jj na b gy ni nf l ng nh">}</span></pre><p id="b1d0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> Ref，了解更多:</strong><a class="ae jg" href="https://www.toshblocks.com/solidity/operators-arithmetic-logical-bitwise/" rel="noopener ugc nofollow" target="_blank">toshblocks.com/operators-arithmetic-logical-bitwise</a></p><h2 id="ca7c" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">7.功能</h2><p id="283d" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">函数是可重复使用的代码块，可以反复执行。一个合同可以有一个或多个功能。可以在引用契约的同时直接调用函数。一旦动态创建了一个契约，就可以动态调用一个函数。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="1e3c" class="le lf jj na b gy ne nf l ng nh">contract Person {<br/>    string public name;<br/>    uint256 public age;<br/>    address public paddress;<br/><br/>    function setDetail(string memory _name, uint256 _age)<br/>        public<br/>        returns (<br/>            string memory,<br/>            uint256,<br/>            address<br/>        )<br/>    {<br/>        name = _name;<br/>        age = _age;<br/>        paddress = msg.sender;<br/>        return (name, age, paddress);<br/>    }<br/>}</span></pre><p id="01fe" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，<code class="fe nk nl nm na b">setDetail</code>是一个函数。这个函数接受三个输入参数，并返回一个元组作为结果。</p><h2 id="986c" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">8.高级数据结构</h2><p id="bd77" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">除了int，float，bool，Solidity还支持复杂的数据结构，如<a class="ae jg" href="https://www.tutorialspoint.com/solidity/solidity_mappings.htm" rel="noopener ugc nofollow" target="_blank">映射</a>，<a class="ae jg" href="https://www.tutorialspoint.com/solidity/solidity_arrays.htm" rel="noopener ugc nofollow" target="_blank">数组</a>，<a class="ae jg" href="https://www.tutorialspoint.com/solidity/solidity_structs.htm" rel="noopener ugc nofollow" target="_blank">结构</a>，<a class="ae jg" href="https://www.tutorialspoint.com/solidity/solidity_enums.htm" rel="noopener ugc nofollow" target="_blank">枚举</a>，地址。<br/> Struct是一种复杂的数据类型，可以包含其他数据类型。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2169" class="le lf jj na b gy ne nf l ng nh">contract test {<br/>   struct Book { <br/>      string title;<br/>      string author;<br/>      uint book_id;<br/>   }<br/>   Book book;<br/><br/>   function setBook() public {<br/>      book = Book('Learn Java', 'TP', 1);<br/>   }<br/>   function getBookId() public view returns (uint) {<br/>      return book.book_id;<br/>   }<br/>}</span></pre><p id="72dd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">映射是一种可以基于键存储值的数据结构。与映射类似，数组是一种可以存储相似数据类型集合的数据结构。我们可以使用值的索引来访问值。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e82b" class="le lf jj na b gy ne nf l ng nh">contract LedgerBalance {<br/>    mapping(address =&gt; uint) public balances;</span><span id="e85e" class="le lf jj na b gy ni nf l ng nh">    function updateBalance(uint newBalance) public {<br/>        balances[msg.sender] = newBalance;<br/>    }<br/>    function testMethod() public pure{<br/>      uint len = 7; <br/>      <br/>      //dynamic array<br/>      uint[] memory a = new uint[](7);<br/>      <br/>      //bytes is same as byte[]<br/>      bytes memory b = new bytes(len);<br/>      <br/>      assert(a.length == 7);<br/>      assert(b.length == len);<br/>      <br/>      //access array variable<br/>      a[6] = 8;<br/>      <br/>      //test array variable<br/>      assert(a[6] == 8);<br/>      <br/>      //static array<br/>      uint[3] memory c = [uint(1) , 2, 3];<br/>      assert(c.length == 3);<br/>    }<br/>}</span></pre><p id="8401" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">注:</strong></p><ol class=""><li id="f298" class="lx ly jj ki b kj kk kn ko kr mq kv mr kz ms ld me mf mg mh bi translated">基于数组的创建，数组可以是动态的或静态的。</li><li id="de3e" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">映射没有长度</li><li id="cde1" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">映射没有长度。理解这一点很重要。数组有长度，但是由于映射在内部的存储方式，它们没有长度。</li><li id="2d2d" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld me mf mg mh bi translated">结构用它们的默认值初始化</li></ol><blockquote class="nn no np"><p id="df07" class="kg kh nq ki b kj kk kl km kn ko kp kq nr ks kt ku ns kw kx ky nt la lb lc ld im bi translated">假设您有一个映射mapping(uint 256 = &gt; uint)my mapping，那么所有的元素myMapping[0]，myMapping[1]，myMapping[123123]，…都已经用默认值初始化了。如果将uint256映射到uint，则将键类型“uint”映射到值类型“uint”。</p></blockquote><p id="86ad" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">了解更多:</strong>【ethereum-blockchain-developer.com/mappings-and-structs】T2</p><p id="6127" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">地址:</strong>地址是一种特殊的数据类型。地址包含一个20字节的值(以太坊地址的大小)，即客户或合同的唯一位置。地址是可以播放的。可支付地址有一些特殊的功能，如转账或发送。<br/> <strong class="ki jk">了解更多:</strong><a class="ae jg" href="https://docs.soliditylang.org/en/v0.8.10/types.html#address" rel="noopener ugc nofollow" target="_blank">docs.soliditylang.org/types#address</a></p><h2 id="6583" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">9.范围和可见性</h2><p id="e9bf" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">要定义函数的可见性，可以问一个简单的问题“谁能调用函数”。可靠性函数有四种可见性私有、内部、外部或公共。默认情况下，函数具有公共范围。</p><p id="7a17" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">私有:</strong>私有函数只能被主契约调用。<br/> <strong class="ki jk">内部:</strong>内部函数只能被主契约或派生契约调用。<br/> <strong class="ki jk">外部:</strong>外部函数只能由第三方调用。它不能被主契约或派生契约调用。<br/> <strong class="ki jk">公共:</strong>公共函数可以被任何人在任何地方调用。</p><p id="3723" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">了解更多:</strong>T24】bitsofco.de/solidity-function-visibility-explained/</p><h2 id="ce54" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">结论</h2><p id="9de6" class="pw-post-body-paragraph kg kh jj ki b kj lz kl km kn ma kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">这篇文章只是对区块链的介绍。这篇文章的目的只是对要学习的题目做个简介。我在下面附上了所有的参考链接。如果你想找一个详细的版本，你可以阅读<a class="ae jg" href="https://github.com/ethereumbook/ethereumbook" rel="noopener ugc nofollow" target="_blank">ethereum book/ethereum book</a>。</p><h2 id="bec3" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">参考</h2><ul class=""><li id="e771" class="lx ly jj ki b kj lz kn ma kr mb kv mc kz md ld mt mf mg mh bi translated"><a class="ae jg" href="https://ethereum-blockchain-developer.com/" rel="noopener ugc nofollow" target="_blank">https://ethereum-blockchain-developer.com/</a></li><li id="c60e" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld mt mf mg mh bi translated"><a class="ae jg" href="https://decipher.dev/blockchain-introduction/" rel="noopener ugc nofollow" target="_blank">https://decipher.dev/blockchain-introduction/</a></li><li id="dfea" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld mt mf mg mh bi translated"><a class="ae jg" href="https://www.tutorialspoint.com/" rel="noopener ugc nofollow" target="_blank">https://www.tutorialspoint.com/</a></li><li id="4ff5" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld mt mf mg mh bi translated"><a class="ae jg" href="https://docs.soliditylang.org/en/v0.8.11/" rel="noopener ugc nofollow" target="_blank">https://docs.soliditylang.org/en/v0.8.11/</a></li><li id="1bf5" class="lx ly jj ki b kj mi kn mj kr mk kv ml kz mm ld mt mf mg mh bi translated"><a class="ae jg" href="https://bitsofco.de/solidity-function-visibility-explained/" rel="noopener ugc nofollow" target="_blank">https://bitsofco.de/solidity-function-visibility-explained/</a></li></ul></div></div>    
</body>
</html>