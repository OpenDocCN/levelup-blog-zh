<html>
<head>
<title>Building a Simple Rest API in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中构建一个简单的Rest API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-simple-rest-api-in-go-ee29cf3e7334?source=collection_archive---------5-----------------------#2020-01-30">https://levelup.gitconnected.com/building-a-simple-rest-api-in-go-ee29cf3e7334?source=collection_archive---------5-----------------------#2020-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="491d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Go的net/http包使用介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63a5f44efc88c770200f8d901c037b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oeYC1R1pqPOjb__v-0Sh9g.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Philipp Katzenberger 在Unsplash上的照片</figcaption></figure><p id="b4ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最近加入<a class="ae ky" href="https://central.tech" rel="noopener ugc nofollow" target="_blank"> Central Tech </a>后，我接到了我的第一个项目:实现一个新产品，在Go中创建和查询一个API。我把这当成一个最终深入围棋的机会，这是我在听到许多人对它的称赞后一直想做的事情。我还决定开始详细描述我一路上学到的东西，既是为了个人参考，也是为了确保我对概念的理解足以用文字来解释。</p><p id="74d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这篇文章和我的<a class="ae ky" href="https://tansawit.me" rel="noopener ugc nofollow" target="_blank">网站</a>将有望成为我可以参考的资源，也有望对其他人有所帮助。</p><h1 id="7712" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基础</h1><p id="92fd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这篇文章假设你已经在电脑上安装并运行了Go。如果没有，请看Go语言官方入门<a class="ae ky" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">指南</a>。</p><p id="678d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编写要执行的实际函数之前，我们首先需要定义我们的程序并导入必要的包。创建一个名为<code class="fe ms mt mu mv b">main.go</code>的新文件，并添加以下几行。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="2c38" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu">package</strong> main<br/><br/><strong class="mv iu">import</strong> (<br/>    "log"<br/>    "net/http"<br/>)</span></pre><p id="ba33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下上面代码的每个组件。</p><h1 id="7056" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">包装</h1><p id="2710" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://golang.org/pkg/" rel="noopener ugc nofollow" target="_blank">包</a>是Go的源代码，组织成系统目录。它们允许不同应用程序之间的代码重用。为了将一个可执行程序与其他程序使用的库区分开，Go要求我们在任何可执行程序的主文件头中包含<code class="fe ms mt mu mv b">package main</code>。编译时，那个<code class="fe ms mt mu mv b">package main</code>告诉Go编译器这个包应该编译成一个可执行程序，而不是构建成一个库。</p><h1 id="045a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">进口</h1><p id="d935" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">关键字' import '用于将包导入我们的程序或另一个包。导入包时，Go编译器将在两个环境变量指定的位置中查找:</p><ul class=""><li id="65d1" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe ms mt mu mv b">$GOROOT</code>Go附带的<a class="ae ky" href="https://golang.org/pkg/" rel="noopener ugc nofollow" target="_blank">标准库</a>中的包存放的地方</li><li id="878e" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe ms mt mu mv b">$GOPATH</code>用于抓取第三方或自制包。</li></ul><blockquote class="nt nu nv"><p id="7f88" class="kz la nw lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">注意</em> </strong> <em class="it"> : Go by design不允许声明未使用的导入，如果在编译时发现任何未使用的导入，将坚决投诉</em></p></blockquote><p id="874e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，两个包都来自标准库:</p><ul class=""><li id="21aa" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe ms mt mu mv b">log</code>允许我们记录错误和其他问题。</li><li id="d7d9" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe ms mt mu mv b">net/http</code>为我们提供了构建实际API的HTTP客户端和服务器实现</li></ul><p id="b395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在声明包之后，我们可以开始定义和服务我们的API。在不使用第三方库和路由器的情况下，有两种主要的“方法”可以做到这一点。</p><p id="4c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将处理程序实现为一个函数，我们将使用<code class="fe ms mt mu mv b">http.HandleFunc</code>。否则，如果我们用<code class="fe ms mt mu mv b">ServeHTTP</code>方法将我们的处理程序实现为一个类型，我们将使用<code class="fe ms mt mu mv b">http.Handle</code>。</p><p id="05cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于简单的实现，第一个选项更容易阅读和理解。但是使用struct类型允许在其中存储有用的信息，一个例子是来自标准库的<a class="ae ky" href="https://golang.org/src/net/http/fs.go?s=12662:12702#L418" rel="noopener ugc nofollow" target="_blank">文件服务器</a>。该结构包含文件服务的根目录。更详细的解释见<a class="ae ky" href="https://stackoverflow.com/questions/21957455/difference-between-http-handle-and-http-handlefunc" rel="noopener ugc nofollow" target="_blank">堆栈溢出帖子</a>。</p><p id="c0f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们的程序相当简单明了，我们将坚持第一种方法。</p><blockquote class="nt nu nv"><p id="14ea" class="kz la nw lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">注</em> </strong> <em class="it"> : HTTP处理程序是为响应web应用程序的请求而运行的进程。更多信息，请参见其</em> <a class="ae ky" href="https://en.wikipedia.org/wiki/HTTP_handler" rel="noopener ugc nofollow" target="_blank"> <em class="it">维基百科页面</em> </a></p></blockquote><h1 id="a1c0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">构建Web服务器</h1><p id="8a79" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们开始定义API服务器的实际行为，以及我们将作为响应发送的内容。在我们的进口和包装声明下面添加以下几行:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0484" class="na lw it mv b gy nb nc l nd ne">func apiResponse(w http.ResponseWriter, r *http.Request) { <br/>  w.WriteHeader(http.StatusOK)<br/>  w.Header().Set("Content-Type", "application/json")<br/>  w.Write([]byte(`{"message":"hello world!"}`))<br/>}<br/><br/>func main() {<br/>  http.HandleFunc("/",apiResponse)<br/>  log.Fatal(http.ListenAndServe(":8080",<strong class="mv iu">nil</strong>))<br/>}</span></pre><p id="b73b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，让我们浏览一下每个函数。</p><h1 id="fa40" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">apiResponse</h1><p id="ede4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">函数<code class="fe ms mt mu mv b">apiResponse</code>负责写响应代码和JSON。函数本身有两个参数:<code class="fe ms mt mu mv b">http.ResponseWriter</code>类型的<code class="fe ms mt mu mv b">w</code>组装我们的HTTP服务器的响应，而<code class="fe ms mt mu mv b">r</code>读取并解析请求。现在遍历函数的每一行:</p><ul class=""><li id="41f0" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe ms mt mu mv b">w.WriteHeader(http.StatusOK)</code>写HTTP <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" rel="noopener ugc nofollow" target="_blank">响应代码</a> 200，表示请求的资源(在我们的例子中是JSON响应)已经被成功获取并在消息体中传输。</li><li id="6f34" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe ms mt mu mv b">w.Header().Set("Content-Type", "application/json")</code>表示所请求资源的返回类型。</li><li id="7268" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">最后，在消息正文中写入我们的响应。</li></ul><h1 id="1304" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">主要的</h1><p id="3963" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe ms mt mu mv b">main()</code>函数在Go中有一个特殊的用途:它充当可执行程序的入口点。它不接受任何参数，也不返回任何内容。而且不像其他一些语言，我们不需要显式调用<code class="fe ms mt mu mv b">main</code>，因为Go运行时会自动调用该函数。</p><p id="15b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的主函数中，<code class="fe ms mt mu mv b">HandleFunc</code>调用告诉HTTP包用我们的<code class="fe ms mt mu mv b">apiResponse</code>函数处理所有对web根(“/”)的请求。然后它调用<code class="fe ms mt mu mv b">http.ListenAndServe</code>，指定它应该监听任何接口上的端口<code class="fe ms mt mu mv b">8080</code>。</p><p id="4d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行命令<code class="fe ms mt mu mv b">go run .</code>并在web浏览器上导航到<code class="fe ms mt mu mv b">localhost:8080</code>，我们应该会看到类似这样的内容。</p><p id="fea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用“GET”方法将相同的URL输入到我们的REST客户端(即<a class="ae ky" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>、<a class="ae ky" href="https://www.insomnia.rest" rel="noopener ugc nofollow" target="_blank">失眠症</a>、<a class="ae ky" href="https://paw.cloud/" rel="noopener ugc nofollow" target="_blank"> Paw </a>)中，以获得相同的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/d9ebc7ed6429c5782677cdbd5482b9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*lBPaSJyUP3XWhztRnYVj2w.png"/></div></figure><h1 id="51c0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">让它宁静</h1><p id="1db6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们的服务器可以返回一个响应，我们可以根据请求的方法配置它做不同的事情。</p><p id="55fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们可以这样修改我们的<code class="fe ms mt mu mv b">apiResponse</code>函数:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="8c37" class="na lw it mv b gy nb nc l nd ne">func apiResponse(w http.ResponseWriter, r *http.Request) {<br/>  <em class="nw">// Set the return Content-Type as JSON like before<br/></em>  w.Header().Set("Content-Type", "application/json")<br/><br/>  <em class="nw">// Change the response depending on the method being requested<br/></em>  switch r.Method {<br/>    case "GET":<br/>      w.WriteHeader(http.StatusOK)<br/>      w.Write([]byte(`{"message": "GET method requested"}`))<br/>    case "POST":<br/>        w.WriteHeader(http.StatusCreated)<br/>        w.Write([]byte(`{"message": "POST method requested"}`))<br/>    default:<br/>        w.WriteHeader(http.StatusNotFound)a<br/>        w.Write([]byte(`{"message": "Can't find method requested"}`))<br/>    }<br/>}</span></pre><p id="805a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们用<code class="fe ms mt mu mv b">ctrl-c</code>关闭先前版本的服务器，并再次启动它，我们应该会得到不同的响应，这取决于我们从REST客户机请求的方法。</p><p id="0d6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最终的<code class="fe ms mt mu mv b">main.go</code>应该是这样的:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="99f2" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu">package</strong> main<br/><br/><strong class="mv iu">import</strong> (<br/>    "log"<br/>    "net/http"<br/>)<br/><br/>func apiResponse(w http.ResponseWriter, r *http.Request) {<br/>  <em class="nw">// Set the return Content-Type as JSON like before<br/></em>  w.Header().Set("Content-Type", "application/json")<br/><br/>  <em class="nw">// Change the response depending on the method being requested<br/></em>  switch r.Method {<br/>    case "GET":<br/>      w.WriteHeader(http.StatusOK)<br/>      w.Write([]byte(`{"message": "GET method requested"}`))<br/>    case "POST":<br/>        w.WriteHeader(http.StatusCreated)<br/>        w.Write([]byte(`{"message": "POST method requested"}`))<br/>    default:<br/>        w.WriteHeader(http.StatusNotFound)a<br/>        w.Write([]byte(`{"message": "Can't find method requested"}`))<br/>    }<br/>}<br/><br/>func main() {<br/>  http.HandleFunc("/",apiResponse)<br/>  log.Fatal(http.ListenAndServe(":8080",<strong class="mv iu">nil</strong>))<br/>}</span></pre><h1 id="7649" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关闭</h1><p id="7481" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这涵盖了构建REST API服务器的基础知识。在后面的文章中，我计划更详细地研究一下<code class="fe ms mt mu mv b">net/http</code>库，并使用第三方路由器库，如<a class="ae ky" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank">‘gorilla/mux’</a>和<a class="ae ky" href="https://github.com/go-chi/chi" rel="noopener ugc nofollow" target="_blank">‘go-chi/chi’</a>进行更复杂的路由。</p><p id="eb95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何问题，请随时通过推特或电子邮件联系我。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="44ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nw">原载于2020年1月30日</em><a class="ae ky" href="https://tansawit.me/posts/building-a-simple-rest-api-with-go/" rel="noopener ugc nofollow" target="_blank"><em class="nw">https://tans awit . me</em></a><em class="nw">。</em></p></div></div>    
</body>
</html>