<html>
<head>
<title>How to Implement Authorization in Your Application Using JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用JWT在应用程序中实现授权</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-implement-authorization-in-your-application-using-jwt-bf19bffff9fe?source=collection_archive---------3-----------------------#2022-06-26">https://levelup.gitconnected.com/how-to-implement-authorization-in-your-application-using-jwt-bf19bffff9fe?source=collection_archive---------3-----------------------#2022-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e6f4fc3f43e626d5a1bde6cbeb5b1578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HeRvOkjQs74r-lqE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">克里斯汀·休姆在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3878" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您正在构建一个web应用程序，实现API是一个必要的需求。您向用户显示的数据需要从不同服务器上的API服务中获取。</p><p id="ed70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时，您的网站可能需要限制对其中一些API的访问，以防止它们被其他地方获取。这些限制可以是从用户的可用性到用户角色的任何内容。这被称为授权。</p><p id="4052" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将向你展示如何使用JSON Web Token (JWT)实现前端(React)和后端(Node JS)的授权。我们将实现三个API调用来演示这个过程。</p><h2 id="cfea" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">批准</h2><p id="9172" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在涉及API服务的应用程序中，应该考虑安全性。API应该不能从应用程序之外的任何地方访问。此外，您还希望确保API只能被必要的实体访问。为此，您需要实现授权。考虑以下两种情况。</p><p id="204c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的应用程序需要对用户进行身份验证，您需要确保某些服务只能由经过身份验证的用户访问。例如，在亚马逊上，任何人都可以查看可用产品的列表，但特定用户的订单、购买、支付信息等除外。应该只允许经过身份验证的用户访问。</p><p id="3627" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个用例是只有特定用户可以访问服务。在学校网站上，学生可以查看自己的成绩，但只有教师有权修改成绩。</p><p id="2966" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当用户通过身份验证后，身份验证服务会将访问令牌发送回应用程序。访问令牌包含关于用户、他/她的角色、登录时间、到期时间以及其他细节的信息。</p><p id="4612" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发出API请求时，会添加包含访问令牌的授权头。这个令牌在后端被解码，并检索关于用户的信息。根据这些信息，API决定用户是否有权获得响应。</p><p id="6671" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将实现一个类似的场景。我将在以后的文章中介绍认证。这里，我们将直接跳到身份验证的最后，即获取访问令牌，然后使用同一个令牌来演示三个API调用。</p><p id="f312" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将使用JWT。</p><h2 id="bbf7" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">什么是JWT？</h2><p id="15af" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">JWT是一种以编码形式发送信息的安全方式。该令牌包含三个部分:</p><ul class=""><li id="cc2b" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated"><strong class="kf ir">头:</strong>这个部分包含令牌的类型和用于编码令牌的算法。</li><li id="ec62" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">有效负载:</strong>这部分包含用户的信息和其他信息，如令牌有效期。</li><li id="6fca" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">签名:</strong>该部分用于对令牌进行签名，并验证消息在传输时未被更改。</li></ul><p id="4ca3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个JWT看起来像这样，所有的部分都以编码的形式:<br/> <code class="fe mn mo mp mq b">[Header].[Payload].[Signature]</code></p><p id="2b08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JWT的一个例子:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="fcb0" class="lb lc iq mq b gy mz na l nb nc">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span></pre><p id="732c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">访问<a class="ae kc" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank">这里</a>解码JWT。观看<a class="ae kc" href="https://www.youtube.com/watch?v=7Q17ubqLfaM&amp;t=32s" rel="noopener ugc nofollow" target="_blank">这个</a>视频，了解更多关于Node.js中JWT的实现</p><p id="adee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您对授权和JWT有了一点了解，让我们开始实现吧。</p><h1 id="065d" class="nd lc iq bd ld ne nf ng lg nh ni nj lj nk nl nm lm nn no np lp nq nr ns ls nt bi translated">安装</h1><h2 id="d6a5" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">React应用</h2><p id="d004" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在您的项目目录中创建一个文件夹<code class="fe mn mo mp mq b">authorization-frontend</code>。在其中，运行以下命令来创建React应用程序。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="2064" class="lb lc iq mq b gy mz na l nb nc">create-react-app authorization-frontend</span></pre><p id="6717" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在这个项目中使用Bootstrap，所以将这个CDN添加到<em class="nu">index.html</em>文件中。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="f32b" class="lb lc iq mq b gy mz na l nb nc">&lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous"&gt;</span></pre><p id="84bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，您可以从<a class="ae kc" href="https://getbootstrap.com/docs/5.1/getting-started/download/" rel="noopener ugc nofollow" target="_blank">这里</a>下载引导源文件。</p><p id="756e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用<a class="ae kc" href="https://axios-http.com/docs/intro" rel="noopener ugc nofollow" target="_blank"> <em class="nu"> Axios </em> </a>库来进行API调用。使用命令<code class="fe mn mo mp mq b">npm i axios</code>安装它。</p><h2 id="a20e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">Node.js服务器</h2><p id="d06a" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">首先，如果您的系统中没有Node.js，请安装它。从<a class="ae kc" href="https://nodejs.dev/download/" rel="noopener ugc nofollow" target="_blank">这里</a>下载。</p><p id="ba67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为服务器代码创建一个名为<code class="fe mn mo mp mq b">api-server</code>的单独文件夹。在该文件夹中，运行命令<code class="fe mn mo mp mq b">npm init</code>并根据给定的提示输入值。它应该会在您的文件夹中创建一个<code class="fe mn mo mp mq b">package.json</code>文件。该文件显示了您已经安装在项目目录中的模块。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/e9586270a77c8d7f0959aa80e1f4655b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKa_4Mkta8K4umHZXARrCw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">总体项目结构</figcaption></figure><p id="4702" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在使用以下模块:</p><ul class=""><li id="93aa" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated">express  : Node.js框架，使构建服务器变得容易</li><li id="0fdc" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated">cors :允许跨来源的源发出API请求。<a class="ae kc" href="https://www.section.io/engineering-education/how-to-use-cors-in-nodejs-with-express/" rel="noopener ugc nofollow" target="_blank">了解更多</a>。</li><li id="c833" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir"> jsonwebtoken </strong>:生成访问令牌</li></ul><p id="5c1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用命令<code class="fe mn mo mp mq b">npm i express cors jsonwebtoken</code>安装它们。</p><p id="253a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，创建一个文件<code class="fe mn mo mp mq b">server.js</code>，其中包含设置节点服务器所需的代码。包括以下代码:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="f48a" class="lb lc iq mq b gy mz na l nb nc">const express = require('express')<br/>const cors = require('cors')<br/>const jwt = require('jsonwebtoken')</span><span id="177c" class="lb lc iq mq b gy nw na l nb nc">const app = express()</span><span id="cec5" class="lb lc iq mq b gy nw na l nb nc">// For sending JSON data through POST requests<br/>app.use(express.json());</span><span id="3910" class="lb lc iq mq b gy nw na l nb nc">app.use(cors({<br/>    origin: '*'<br/>}))</span><span id="333e" class="lb lc iq mq b gy nw na l nb nc"><br/>// Define APIs here</span><span id="b67b" class="lb lc iq mq b gy nw na l nb nc">const PORT = 8000</span><span id="17d5" class="lb lc iq mq b gy nw na l nb nc">app.listen(PORT, () =&gt; {<br/>    console.log('Listening on port', PORT);<br/>})</span></pre><p id="77ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于这个项目，允许CORS下的所有源代码，即任何浏览器都可以访问这些API。但是在开发实际应用程序时，这不是一个好的做法。</p><h1 id="3ff8" class="nd lc iq bd ld ne nf ng lg nh ni nj lj nk nl nm lm nn no np lp nq nr ns ls nt bi translated">获取访问令牌</h1><p id="e89d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">既然您已经设置了这两个应用程序，现在是时候在后端生成访问令牌并将其传递给前端，即实现一个虚拟身份验证。</p><p id="8cb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将生成两种类型的访问令牌:一种用于普通用户，另一种用于管理员用户。</p><h2 id="30aa" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">用于提取令牌的端点</h2><p id="f02d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">创建一个API端点来获取令牌。使用POST API，因为我们从前端获取一个请求体，它通常包含身份验证期间的用户凭证。在我们的例子中，前端只发送一个指示要获取的令牌类型的值。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="7687" class="lb lc iq mq b gy mz na l nb nc">app.post('/access_token', (req, res) =&gt; {<br/>    const { value } = req.body;</span><span id="141d" class="lb lc iq mq b gy nw na l nb nc">    switch(value) {<br/>        case 1:<br/>            // generate normal token<br/>        case 2:<br/>            // generate admin token        <br/>        default:<br/>            // Send error message<br/>    }<br/>})</span></pre><h2 id="98b4" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">生成访问令牌</h2><p id="e41c" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们有两个用户对象，一个普通用户和一个管理员用户。此外，定义一个将用于对令牌进行签名的密码。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="da72" class="lb lc iq mq b gy mz na l nb nc">const NORMAL_USER = {<br/>    name: 'kunal',<br/>    admin: false<br/>}</span><span id="7491" class="lb lc iq mq b gy nw na l nb nc">const ADMIN_USER = {<br/>    name: 'alex',<br/>    admin: true<br/>}</span><span id="236e" class="lb lc iq mq b gy nw na l nb nc">const SECRET = 'client-secret'</span></pre><p id="8d5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意:</strong>在你的应用程序代码中定义一个秘密不是一个好习惯，你应该把它放在一个<em class="nu"> env </em>文件中。</p><p id="8d60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">令牌可以通过使用<code class="fe mn mo mp mq b">sign()</code>函数来生成。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="23d7" class="lb lc iq mq b gy mz na l nb nc">jwt.sign(NORMAL_USER, SECRET, (err, token) =&gt; {</span><span id="09c2" class="lb lc iq mq b gy nw na l nb nc">  res.json({ accessToken: token })</span><span id="fd9d" class="lb lc iq mq b gy nw na l nb nc">})</span></pre><p id="4574" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于管理令牌，用<code class="fe mn mo mp mq b">ADMIN_USER</code>替换<code class="fe mn mo mp mq b">NORMAL_USER</code></p><p id="37a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们通过解码令牌来检查。<code class="fe mn mo mp mq b">iat</code>字段表示令牌被发布的时间。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/854f30b6b997839126a2c62ca3e84a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mzObgpzHwkrjgaNwd5ByKg.png"/></div></div></figure><h2 id="b784" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">去拿令牌</h2><p id="8287" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在前端，导入Axios库并初始化后端服务器的主机名。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="96a5" class="lb lc iq mq b gy mz na l nb nc">import axios from 'axios'</span><span id="aeac" class="lb lc iq mq b gy nw na l nb nc">const HOST_NAME = 'http://localhost:8000'</span></pre><p id="b10a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，创建两个按钮，分别用于获取普通令牌和管理令牌。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/08131b7dad9396c622b5a0666c6d597a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xsIwAweRiRe3xbfMNLI6A.png"/></div></div></figure><p id="60fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单击按钮时，调用<code class="fe mn mo mp mq b">handleGetTokenClick()</code>方法，用一个<code class="fe mn mo mp mq b">option</code>参数获取访问令牌，以确定获取哪个令牌。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="d115" class="lb lc iq mq b gy mz na l nb nc">function handleGetTokenClick(option) {    }</span></pre><p id="6319" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个方法中，向端点<code class="fe mn mo mp mq b">/access_token</code>的API发出post请求。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="6416" class="lb lc iq mq b gy mz na l nb nc">axios.post(HOST_NAME+'/access_token', { value: option })</span><span id="79f5" class="lb lc iq mq b gy nw na l nb nc">  .then(res =&gt; {</span><span id="5656" class="lb lc iq mq b gy nw na l nb nc">       --- HANDLE THE RESPONSE ---</span><span id="6b2e" class="lb lc iq mq b gy nw na l nb nc">})</span></pre><p id="95d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回应是这样的。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/5866a6bdff3d45902a9ba05c8b924f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GmdOMMWmh-xJiZiOhyNjHw.png"/></div></div></figure><h2 id="62e1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">将令牌存储为状态</h2><p id="49c0" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">从响应中获取访问令牌，并将其存储在会话存储(或本地存储；在此阅读差异<a class="ae kc" href="https://www.geeksforgeeks.org/difference-between-local-storage-session-storage-and-cookies" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8666" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个状态变量来保存访问令牌。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="8bff" class="lb lc iq mq b gy mz na l nb nc">const [accessToken, setAccessToken] =               <br/>          useState(sessionStorage.getItem('accessToken'));</span></pre><p id="0399" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，当您从API接收访问令牌时，设置状态。下面是处理响应的代码。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="2421" class="lb lc iq mq b gy mz na l nb nc">const { accessToken } = res.data;<br/>sessionStorage.setItem('accessToken', accessToken);<br/>setAccessToken(accessToken);</span></pre><h1 id="b427" class="nd lc iq bd ld ne nf ng lg nh ni nj lj nk nl nm lm nn no np lp nq nr ns ls nt bi translated">API调用</h1><p id="567d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">现在，是实现API调用的时候了。如前所述，我们将进行三次GET API调用:</p><ul class=""><li id="a9a6" class="lz ma iq kf b kg kh kk kl ko mb ks mc kw md la me mf mg mh bi translated"><strong class="kf ir">公共API: </strong>任何人都可以访问。</li><li id="5421" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">私有API: </strong>仅授权用户可访问(即使用访问令牌)</li><li id="d4e3" class="lz ma iq kf b kg mi kk mj ko mk ks ml kw mm la me mf mg mh bi translated"><strong class="kf ir">受限API: </strong>仅管理员用户可访问。</li></ul><h2 id="e9a6" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">实现三个API</h2><p id="802f" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><strong class="kf ir">公共API </strong></p><p id="946f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个API在被调用时发送一个简单的响应。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="e6e4" class="lb lc iq mq b gy mz na l nb nc">app.get('/public_api', (req, res) =&gt; {</span><span id="c7c2" class="lb lc iq mq b gy nw na l nb nc">    res.send('Public API called')</span><span id="a4aa" class="lb lc iq mq b gy nw na l nb nc">})</span></pre><p id="aa6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">私有API </strong></p><p id="6edb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个API需要一个带有有效访问令牌的授权头。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="57fe" class="lb lc iq mq b gy mz na l nb nc">app.get('/private_api', (req, res) =&gt; {  ...  })</span></pre><p id="3f04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，检查用户是否发送了授权头。如果没有，则发送一条带有<code class="fe mn mo mp mq b">401</code>状态代码的错误消息。这表示缺少凭据或凭据无效。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="9aa9" class="lb lc iq mq b gy mz na l nb nc">const auth_header = req.headers.authorization;<br/>if(!auth_header)  res.send(401, 'Unauthorized request')</span></pre><p id="be1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果请求有一个授权头，从它那里获取访问令牌。因为授权头的形式是<code class="fe mn mo mp mq b">Bearer <em class="nu">access_token</em></code>，所以使用<code class="fe mn mo mp mq b">split()</code>函数来获取访问令牌。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="37ef" class="lb lc iq mq b gy mz na l nb nc">const accessToken = auth_header.split(' ')[1]</span></pre><p id="752e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，使用<code class="fe mn mo mp mq b">verify()</code>函数来验证令牌。它将令牌、秘密和回调函数作为参数。如果令牌有效，则使用解码后的有效负载调用回调函数，否则调用时出错。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="f0da" class="lb lc iq mq b gy mz na l nb nc">jwt.verify(accessToken, SECRET, (err, payload) =&gt; {<br/>    if (err) res.send(401, 'Unauthorized request')<br/>    res.send('Private API called')<br/>})</span></pre><p id="08a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Postman测试API。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/37cfaf24022196ee4bd07ae350ce880f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1hIOVmLsKbKEqoZHxFJOMQ.png"/></div></div></figure><p id="53b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">受限API </strong></p><p id="07d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此API只能由管理员用户调用。逻辑几乎类似于私有API，除了我们还检查用户是否是管理员。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="5a3e" class="lb lc iq mq b gy mz na l nb nc">app.get('/restricted_api', (req, res) =&gt; {<br/>    const auth_header = req.headers.authorization;<br/>    if(!auth_header)  res.send(401, 'Unauthorized request')<br/>    <br/>    const accessToken = auth_header.split(' ')[1]<br/>    <br/>    jwt.verify(accessToken, SECRET, (err, user) =&gt; {<br/>        if (err) res.send(401, 'Unauthorized request')<br/>        if (user.admin == true) res.send('Restricted API called')<br/>        res.send(401, 'Unauthorized request')<br/>    })<br/>})</span></pre><p id="1146" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果一个普通用户向这个API发出请求，它会发送一个401错误。</p><h2 id="ef9b" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">创建状态以存储响应</h2><p id="e08c" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在前端，创建三个状态变量来存储来自每个API的响应。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="ab96" class="lb lc iq mq b gy mz na l nb nc">const [publicResponse, setPublicResponse] = useState('')<br/>const [privateResponse, setPrivateResponse] = useState('')<br/>const [restrictedResponse, setRestrictedResponse] = useState('')</span></pre><h2 id="c5de" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">创建按钮来调用API</h2><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/66bd369790b52b089baf091e6bdfa708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ya9GfEuemufkKcC5hiQQWw.png"/></div></div></figure><p id="579f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在点击每个按钮时，调用<code class="fe mn mo mp mq b">handleAPIButtonClick()</code>方法，该方法也需要一个<code class="fe mn mo mp mq b">option</code>参数来决定调用哪个API。</p><p id="cd97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用switch-case语句根据传递的选项调用每个API。</p><h2 id="4e27" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">调用API</h2><p id="5d3a" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">调用公共API。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="1f7e" class="lb lc iq mq b gy mz na l nb nc">axios.get(HOST_NAME + '/public_api').then(res =&gt; {</span><span id="1e5a" class="lb lc iq mq b gy nw na l nb nc">    setPublicResponse(res.data)</span><span id="c4a1" class="lb lc iq mq b gy nw na l nb nc">})</span></pre><p id="ebe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用私有API时，以<code class="fe mn mo mp mq b">Bearer <em class="nu">access_token</em></code> <em class="nu">的形式传递授权头。</em>点击阅读更多关于无记名代币的信息<a class="ae kc" href="https://swagger.io/docs/specification/authentication/bearer-authentication/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="089d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，实现<code class="fe mn mo mp mq b">catch</code>块来处理错误响应。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="cfa5" class="lb lc iq mq b gy mz na l nb nc">axios.get(HOST_NAME + '/private_api', {<br/>    headers: {<br/>        Authorization: 'Bearer ' + accessToken<br/>    }<br/>}).then(res =&gt; {<br/>    setPrivateResponse(res.data)<br/>}).catch(err =&gt; {<br/>    setPrivateResponse(err.response.data)<br/>})</span></pre><p id="648a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以类似的方式调用受限API，但是替换端点和状态更新函数。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/34e5f78b261eba8a1e78c09c781d1add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RXWQnmop5eyUKHJOZ3UXvg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">函数来处理API调用</figcaption></figure><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/14e8e6cd4a9ca464ecf8f0f7bfcd8ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qv_-y69KfesalkEMxE7Ajw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">普通用户令牌的响应</figcaption></figure><h1 id="869a" class="nd lc iq bd ld ne nf ng lg nh ni nj lj nk nl nm lm nn no np lp nq nr ns ls nt bi translated">包扎</h1><p id="61c1" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">将上述API视为您自己实现的模板。如果您有一个显示用户信息的页面，请实现私有API。只有特定用户才能看到的信息属于受限API。</p><p id="1262" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以向API添加任何类型的限制。您所要做的就是传递访问令牌，解码它并检查用户是否满足这些限制。</p><p id="3f25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我没有在这篇文章中添加HTML和CSS代码，因为我只想关注逻辑部分。你可以在<a class="ae kc" href="https://github.com/KunalN25/authorization-with-jwt" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到实现。</p><p id="46d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您发现任何不正确的地方或知道更好的实现方式，请在下面评论。</p><h1 id="ecd4" class="nd lc iq bd ld ne nf ng lg nh ni nj lj nk nl nm lm nn no np lp nq nr ns ls nt bi translated">结论</h1><p id="3fc0" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">授权有助于使您的API安全并受到限制。使用JWT可以很容易地实现授权。在这篇文章中，我向您展示了如何生成一个访问令牌，并使用它来访问不同类型的API。这篇文章简单演示了如何在应用程序中实现授权。</p><p id="127c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我用简单的语言解释了每一个步骤，以帮助您理解授权。我希望这对你未来的项目有所帮助。</p><p id="ddbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您无法理解内容或对解释不满意，请在下面评论您的想法。新想法总是受欢迎的！如果你喜欢这篇文章，请鼓掌。<strong class="kf ir">订阅</strong>、<strong class="kf ir">关注</strong>我获取每周内容。如果你想讨论什么，可以在<a class="ae kc" href="https://twitter.com/nkunal25" rel="noopener ugc nofollow" target="_blank">推特</a>上联系我。到那时，再见！</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="0dc2" class="nd lc iq bd ld ne ol ng lg nh om nj lj nk on nm lm nn oo np lp nq op ns ls nt bi translated">分级编码</h1><p id="b80e" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">感谢您成为我们社区的一员！更多内容请参见<a class="ae kc" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>。<br/>跟随:<a class="ae kc" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae kc" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae kc" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="kf ir">升一级正在改造理工大招聘➡️ </strong> <a class="ae kc" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>