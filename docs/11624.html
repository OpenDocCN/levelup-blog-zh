<html>
<head>
<title>Use isort to sort your Python module imports automatically</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用isort自动对Python模块导入进行排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-isort-to-sort-your-python-module-imports-automatically-40918f3e2a8b?source=collection_archive---------0-----------------------#2022-04-01">https://levelup.gitconnected.com/use-isort-to-sort-your-python-module-imports-automatically-40918f3e2a8b?source=collection_archive---------0-----------------------#2022-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c98a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们以统一的方式对模块进行分类</h2></div><p id="1f34" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你的Python程序变得更大时，你会导入越来越多的模块。如果你不把它们整理好，它们看起来会很乱。但是，如果您手动格式化它们，将会非常麻烦。更糟糕的是，如果你在一个团队中工作，每个人可能都有他/她自己的模块排序习惯。因此，我们最终会在同一个存储库中拥有不同的格式。</p><p id="7ce2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你有这个问题，那么你来对地方了。<a class="ae le" href="https://github.com/PyCQA/isort" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> <em class="lf"> isort </em> </strong> </a>模块将为您解决这个问题！</p><blockquote class="lg lh li"><p id="4bf3" class="ki kj lf kk b kl km ju kn ko kp jx kq lj ks kt ku lk kw kx ky ll la lb lc ld im bi translated">isort是一个Python库，可以按字母顺序对导入进行排序，并自动按类型分成几个部分。</p></blockquote><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/834e7e8cb9191d33dddba836a23bd9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jg3iaInU1riDAq7E.jpg"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">图片来自<a class="ae le" href="https://pixabay.com/photos/tea-teabag-teas-drink-herbal-tea-1252397/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="8e09" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们使用<em class="lf"> isort </em>格式化我们的代码之前，让我们先安装这个库。由于<em class="lf"> isort </em>是一个非常基本且通用的工具，您可以将它安装在您系统的库中。但是，如果您无法将其安装在系统库中，或者想要安装不同版本的<em class="lf">或</em>，您可以将其安装在<a class="ae le" href="https://lynn-kwong.medium.com/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener">虚拟环境</a>中。</p><pre class="ln lo lp lq gt mj mk ml mm aw mn bi"><span id="dc9b" class="mo mp it mk b gy mq mr l ms mt">$ <strong class="mk iu">pip install isort</strong></span></pre></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="0bcb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本帖中，我们将使用<a class="ae le" href="https://github.com/lynnkwong/isort-demo" rel="noopener ugc nofollow" target="_blank">这个回购</a>进行演示。这是一个以不同方式运行Scrapy蜘蛛的实际例子。如果你对代码感兴趣，请看看<a class="ae le" href="https://lynn-kwong.medium.com/how-to-run-scrapy-spiders-in-your-program-7db56792c1f7" rel="noopener">这个帖子</a>。</p><p id="8ec3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该回购协议的结构如下:</p><pre class="ln lo lp lq gt mj mk ml mm aw mn bi"><span id="3ad1" class="mo mp it mk b gy mq mr l ms mt">├── pre-commit<br/>├── <strong class="mk iu">pyproject.toml</strong><br/>├── README.md<br/>├── scraping_proj<br/>│   ├── __init__.py<br/>│   ├── items.py<br/>│   ├── middlewares.py<br/>│   ├── pipelines.py<br/>│   ├── settings.py<br/>│   └── spiders<br/>│       ├── authors.py<br/>│       ├── __init__.py<br/>│       └── quotes.py<br/>├── scraping_script_with_api_and_signals.py<br/>├── scraping_script_with_api.py<br/>├── scraping_script_with_subprocess.py<br/>└── scrapy.cfg</span></pre><p id="235a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">特别的，我们将在<code class="fe mu mv mw mk b">pyproject.toml</code>中有<em class="lf"> isort </em>的配置，这是一个统一的Python项目设置文件，即将介绍。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="26d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个repo中每个文件中导入的模块以非标准的方式按字母顺序排序。例如:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1e4e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模块的顺序不符合<a class="ae le" href="https://peps.python.org/pep-0008/#imports" rel="noopener ugc nofollow" target="_blank"> PEP8 </a>。对于PEP8，模块应按以下顺序导入:</p><blockquote class="lg lh li"><p id="0de5" class="ki kj lf kk b kl km ju kn ko kp jx kq lj ks kt ku lk kw kx ky ll la lb lc ld im bi translated">1.标准库导入。</p><p id="9d51" class="ki kj lf kk b kl km ju kn ko kp jx kq lj ks kt ku lk kw kx ky ll la lb lc ld im bi translated">2.相关第三方进口。</p><p id="04d9" class="ki kj lf kk b kl km ju kn ko kp jx kq lj ks kt ku lk kw kx ky ll la lb lc ld im bi translated">3.特定于本地应用程序/库的导入。</p></blockquote><p id="7a9b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，PEP8没有定义同一组中的模块应该如何排序。此外，对于来自同一个模块的导入应该如何分组也没有定义。</p><p id="0422" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有这些基本细节都可以由<em class="lf"> isort </em>库自动处理。我们可以使用<em class="lf">或</em>单独格式化一个文件或递归格式化一个文件夹。让我们用它来格式化整个项目文件夹:</p><pre class="ln lo lp lq gt mj mk ml mm aw mn bi"><span id="0c08" class="mo mp it mk b gy mq mr l ms mt">$ <strong class="mk iu">isort .</strong></span></pre><p id="e4c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">圆点表示当前目录。当前文件夹和子文件夹中的所有Python文件都将被递归格式化。</p><p id="2e9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述模块应按如下方式分类:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0837" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在第三方图书馆被放在本地图书馆之前。此外，每组中的模块按照模块路径的字母顺序进行排序。并且从相同模块导入的函数/类被分组在一起，也按字母顺序排序。</p><p id="5310" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您对默认格式结果不满意，可以指定一些选项来自定义格式。<em class="lf">或</em>最常用的选项是<code class="fe mu mv mw mk b">--line-lenghth</code>和<code class="fe mu mv mw mk b">--src</code>，它们指定了导入行的最大长度和本地包的路径，即源路径。如果<em class="lf">或</em>不能区分第三方库和本地库，您必须指定<code class="fe mu mv mw mk b">--src</code>选项并在那里添加您的本地包。</p><p id="229e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们为上面的<em class="lf">或</em>命令设置线路长度和源路径:</p><pre class="ln lo lp lq gt mj mk ml mm aw mn bi"><span id="a47d" class="mo mp it mk b gy mq mr l ms mt">$ <strong class="mk iu">isort --line-length 79 --src scraping_proj .</strong></span></pre><p id="2ba0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模块应该按照默认方式进行排序。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="9416" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们之前提到过，有一个“神奇”的文件<code class="fe mu mv mw mk b">pyproject.toml</code>，可以存储统一的Python项目设置。您可以将不同工具的设置放在该文件中，如<a class="ae le" href="https://github.com/psf/black/blob/main/pyproject.toml" rel="noopener ugc nofollow" target="_blank"><em class="lf"/></a><a class="ae le" href="https://lynn-kwong.medium.com/how-to-configure-build-and-deploy-your-python-projects-to-pypi-dac40803fdf" rel="noopener"><em class="lf">setup tools</em></a><em class="lf">isort</em>等。</p><p id="c9c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们将isort的设置放在<code class="fe mu mv mw mk b">pyproject.toml</code>中:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a08f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想了解<em class="lf">或</em>的其他配置选项，请查看此处的<a class="ae le" href="https://pycqa.github.io/isort/docs/configuration/options.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9013" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们将设置放入<code class="fe mu mv mw mk b">pyproject.toml</code>后，我们不再需要在命令行上指定<em class="lf">或</em>的参数。如果你不相信，你可以把<code class="fe mu mv mw mk b">line_length</code>选项改成一个小数字，再次运行<em class="lf">或</em>命令，你就会看到区别。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="f8f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们知道如何使用<em class="lf"> isort </em>在命令行上显式格式化代码的模块导入。如果我们能够通过<em class="lf">或</em>实施一些预提交策略，将会更加有用和方便。有了这样的策略，如果开发人员的代码不能通过<em class="lf">或</em>的静态代码检查，他/她的代码将不被允许提交。</p><p id="ff9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们为<em class="lf">或</em>创建一个简单的预提交钩子。关于git钩子的基础知识，请查看<a class="ae le" href="https://lynn-kwong.medium.com/use-pre-commit-commit-msg-and-pre-push-git-hooks-to-fix-your-python-code-asap-77d80d3ce412" rel="noopener">这篇文章</a>。</p><p id="4b70" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要启用Git挂钩，我们必须将相应的脚本文件放在<code class="fe mu mv mw mk b">.git/hook</code>目录中。脚本文件必须有一个预定义的名称，没有任何扩展名，并且是可执行的。例如，脚本文件可以是<code class="fe mu mv mw mk b">pre-commit</code>、<code class="fe mu mv mw mk b">commit-msg</code>或<code class="fe mu mv mw mk b">pre-push</code>。</p><p id="2f55" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将创建的脚本名为<code class="fe mu mv mw mk b">pre-commit</code>，内容如下:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a64b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<a class="ae le" href="https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797" rel="noopener ugc nofollow" target="_blank"> ANSI转义序列</a>根据消息是错误、警告还是信息，用不同的颜色回显消息，这使得钩子的信息更容易识别。</p><p id="70b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，<em class="lf">或</em>的<code class="fe mu mv mw mk b">--check</code>选项只会检查模块的格式，不会就地更改。当没有任何改变时，<em class="lf"> isort </em>命令返回0，当文件被重新格式化时返回1。</p><p id="2ce7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，<code class="fe mu mv mw mk b">pre-commit</code>脚本必须是可执行的，否则它将无法工作:</p><pre class="ln lo lp lq gt mj mk ml mm aw mn bi"><span id="89eb" class="mo mp it mk b gy mq mr l ms mt">$ <strong class="mk iu">chmod +x pre-commit</strong></span><span id="cd25" class="mo mp it mk b gy mz mr l ms mt">$ <strong class="mk iu">cp pre-commit .git/hooks</strong></span></pre><p id="deda" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果您尝试提交(您不需要进行更改并将它们添加到<a class="ae le" href="https://lynn-kwong.medium.com/understand-different-git-states-and-the-corresponding-file-states-fc62348e81d7" rel="noopener">暂存区</a>来触发预提交挂钩)，您将看到<em class="lf">或</em>的预提交策略失败:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4be1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们用<em class="lf">或</em>格式化代码并再次提交。这一次，您应该看到策略成功通过:</p><pre class="ln lo lp lq gt mj mk ml mm aw mn bi"><span id="5608" class="mo mp it mk b gy mq mr l ms mt">$ isort .</span><span id="8cc0" class="mo mp it mk b gy mz mr l ms mt">$ git commit</span></pre><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="9472" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为手动创建的<code class="fe mu mv mw mk b">pre-commit</code>脚本的替代方案，我们可以使用<a class="ae le" href="https://pre-commit.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lf">预提交</em> </a>实用程序(与预提交Git挂钩同名)以更标准的方式管理预提交挂钩。我们可以在同一个配置文件中设置多个pre-commit钩子，即<code class="fe mu mv mw mk b">.pre-commit-config.yaml</code>，并逐个运行。现在有很多linters提供预提交钩子，我们可以直接使用它们。<a class="ae le" href="https://pycqa.github.io/isort/docs/configuration/pre-commit.html" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> isort </em> </a>就是其中之一。要了解更多关于<em class="lf">预提交</em>实用程序的信息，请查看<a class="ae le" href="https://pre-commit.com/" rel="noopener ugc nofollow" target="_blank">官方页面</a>。</p><p id="2069" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在这里使用<em class="lf">预提交</em>实用程序来管理预提交Git挂钩，我们不需要在本地安装<em class="lf">或</em>，而是需要安装<em class="lf">预提交</em>:</p><pre class="ln lo lp lq gt mj mk ml mm aw mn bi"><span id="b096" class="mo mp it mk b gy mq mr l ms mt">$ <strong class="mk iu">pip install pre-commit</strong></span></pre><p id="0991" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们需要创建另一个“神奇的”文件<code class="fe mu mv mw mk b">.pre-commit-config.yaml</code>,并将Git预提交钩子的配置放在那里。对于<em class="lf">或</em>，配置为:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mx my l"/></div></figure><ul class=""><li id="a711" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld nf ng nh ni bi translated"><code class="fe mu mv mw mk b">repo</code> —包含相应预提交钩子的源代码的GitHub repo。</li><li id="33bb" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mu mv mw mk b">rev</code>—<code class="fe mu mv mw mk b">git clone</code>的修订或标签，指定将要安装的代码版本。</li><li id="34c7" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mu mv mw mk b">hooks</code> —指定挂钩映射列表。挂钩映射配置将使用哪个挂钩。钩子的默认配置将从相应的GitHub库中读取。如果你去<em class="lf">或</em>的GitHub库，你会看到一个名为<code class="fe mu mv mw mk b"><a class="ae le" href="https://github.com/PyCQA/isort/blob/main/.pre-commit-hooks.yaml" rel="noopener ugc nofollow" target="_blank">.pre-commit-hooks.yaml</a></code>的文件，它定义了<em class="lf">或</em>钩子的默认配置。</li><li id="afd5" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mu mv mw mk b">hooks.id </code>—GitHub库的<code class="fe mu mv mw mk b">.pre-commit-hooks.yaml</code>中定义的钩子的id。在同一个<code class="fe mu mv mw mk b">.pre-commit-hooks.yaml</code>中可以定义多个钩子，我们需要指定使用哪一个。</li><li id="5c52" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mu mv mw mk b">hooks.name </code> —钩子执行期间将显示的钩子名称。</li></ul><p id="d5d9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，即使我们使用带有预定义钩子的<em class="lf">预提交</em>实用程序，仍然可以从<code class="fe mu mv mw mk b"> pyproject.toml</code>中读取<em class="lf">或</em>的参数。</p><p id="5207" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然已经创建了<code class="fe mu mv mw mk b">.pre-commit-hooks.yaml</code>，并且在其中定义了钩子。我们可以使用<code class="fe mu mv mw mk b">install</code>选项运行<em class="lf">预提交</em>，这将在<code class="fe mu mv mw mk b">.git/hooks</code>文件夹中创建一个新的<code class="fe mu mv mw mk b">pre-commit</code>脚本:</p><pre class="ln lo lp lq gt mj mk ml mm aw mn bi"><span id="6ce2" class="mo mp it mk b gy mq mr l ms mt">$ <strong class="mk iu">pre-commit install</strong><br/>pre-commit installed at .git/hooks/pre-commit</span></pre><p id="363a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，上面创建的旧的<code class="fe mu mv mw mk b">pre-commit</code>脚本将被重命名为<code class="fe mu mv mw mk b">pre-commit.legacy</code>，当我们提交一些东西时，它仍然会被使用。如果你不想要了，你可以删除它。</p><p id="4a3b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，应该注意的是，由<em class="lf">预提交</em>实用程序创建的钩子将只检查被修改的文件。当第一次使用<code class="fe mu mv mw mk b">--all-files</code>选项安装时，我们可以针对所有文件运行一个钩子:</p><pre class="ln lo lp lq gt mj mk ml mm aw mn bi"><span id="7981" class="mo mp it mk b gy mq mr l ms mt">$ <strong class="mk iu">pre-commit run --all-files</strong></span></pre><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5a5e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，您可以添加所有格式化的文件，并为其创建一个提交。稍后当您修改任何Python文件时，由<em class="lf">预提交</em>实用程序创建的预提交挂钩将只针对被修改的文件运行。例如:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="3723" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用预提交钩子的两种方式各有利弊，即手动编写<code class="fe mu mv mw mk b">pre-commit</code>脚本和使用<em class="lf">预提交</em>实用程序。通过手动编写的<code class="fe mu mv mw mk b">pre-commit</code>脚本，我们可以拥有更加灵活的策略。如上所示，我们可以为警报消息显示不同的颜色。然而，当挂钩需要在不同的项目之间共享时，使用<em class="lf">预提交</em>实用程序会更好。此外，它还可以方便地使用用不同语言编写的第三方钩子。可以选择最适合自己实际使用案例的方式。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="4222" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文通过实际例子介绍了用于自动Python模块排序的便捷工具<em class="lf"> isort </em>。现在你可以开始在工作中使用它了。它将从手动修复Python模块导入的琐碎重复工作中为您节省大量时间。更重要的是，这将使代码在您的团队中更加一致。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="02c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相关文章:</p><ul class=""><li id="65ed" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld nf ng nh ni bi translated"><a class="ae le" href="https://lynn-kwong.medium.com/use-pre-commit-commit-msg-and-pre-push-git-hooks-to-fix-your-python-code-asap-77d80d3ce412?source=your_stories_page----------------------------------------" rel="noopener">使用预提交、提交消息和预推送git挂钩尽快修复你的Python代码。</a></li><li id="7ac1" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">使用black、mypy和pylint让你的Python代码更加专业。</li></ul></div></div>    
</body>
</html>