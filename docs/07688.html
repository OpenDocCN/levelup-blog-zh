<html>
<head>
<title>Euclid’s GCD Using C++ Templates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">欧几里德的GCD使用C++模板</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/euclids-gcd-using-c-templates-873b43710684?source=collection_archive---------6-----------------------#2021-03-05">https://levelup.gitconnected.com/euclids-gcd-using-c-templates-873b43710684?source=collection_archive---------6-----------------------#2021-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/0ecd1d96e62b7f665b17442b245181fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*qaJZS_7FIu8rX769V4KJSw.png"/></div></figure><h1 id="0297" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">介绍</h1><p id="c68e" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">求2个数的最大公约数的一种方法是欧几里德算法。可汗学院有个很棒的描述<a class="ae lq" href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/the-euclidean-algorithm" rel="noopener ugc nofollow" target="_blank">这里</a>。基本算法是:</p><ol class=""><li id="2c41" class="lr ls iq ku b kv lt kz lu ld lv lh lw ll lx lp ly lz ma mb bi translated">从2个非零数字A和B开始，其中A ≥ B。</li><li id="8110" class="lr ls iq ku b kv mc kz md ld me lh mf ll mg lp ly lz ma mb bi translated">使用模运算，求余数r。</li><li id="b130" class="lr ls iq ku b kv mc kz md ld me lh mf ll mg lp ly lz ma mb bi translated">如果R == 0，那么我们就完成了，答案是b。</li><li id="2ba9" class="lr ls iq ku b kv mc kz md ld me lh mf ll mg lp ly lz ma mb bi translated">如果R！= 0，然后重复分配B -&gt; A和R-&gt;B的算法。</li></ol><p id="c4bc" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">这种算法的递归性质非常适合于<a class="ae lq" href="https://en.wikipedia.org/wiki/Template_metaprogramming" rel="noopener ugc nofollow" target="_blank"> C++模板元编程</a>。使用这种技术，我们可以让C++编译器为我们做这种计算。我不确定这在实践中有多大用处，但是它给了我们一个关于C++模板的快速教程，以及使用它们在编译时进行计算的能力。</p><h1 id="8e96" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">克隆存储库</h1><p id="c19c" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了检查这段代码并亲自试用这个程序，你可以在这里克隆这个回购:【https://github.com/danmcleran/euclid.git<a class="ae lq" href="https://github.com/danmcleran/euclid.git" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="42ce" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">GCD父结构</h1><p id="d9d1" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们首先定义希望用户实例化和使用的顶级结构:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="285d" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">你会注意到我们正在使用<a class="ae lq" href="https://en.cppreference.com/w/cpp/language/constexpr" rel="noopener ugc nofollow" target="_blank"> C++11 constexpr说明符</a>。这确保了我们所有的计算都发生在编译时。这些计算没有运行时开销。稍后我们将通过检查汇编语言输出来证明这一点。</p><p id="4bd6" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">结构gcd中的前两行:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="8cb2" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">确保我们选择两个模板参数(M，N)中较大的一个作为值1。然后，我们将值2设置为值≤值1。这是一个小助手，在我们调用gcd实现之前，确保我们的lhs我们的rhs，这发生在下一行:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="21d0" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">这是启动递归模板实例化来执行GCD计算的那一行。</p><h1 id="3088" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">GCD实施</h1><p id="ec24" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了使这个模板更加用户友好，我们在一个名为:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3c30" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">为了方便起见，提供了这个结构及其专门化来构造gcd。父结构处理除法余数的计算以及递归模板实例化。</p><h1 id="0968" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">模板专业化</h1><p id="b6a4" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们有一个<a class="ae lq" href="https://en.cppreference.com/w/cpp/language/partial_specialization" rel="noopener ugc nofollow" target="_blank">局部模板专门化</a>来防止被0:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5dd2" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">如果递归模板实例化试图实例化一个N == 0的模板，这个专门化将介入并返回答案GCD == M。</p><p id="f62f" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">我们有另一个<a class="ae lq" href="https://en.cppreference.com/w/cpp/language/partial_specialization" rel="noopener ugc nofollow" target="_blank">部分模板专门化</a>，它在M == 0时截取:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="f7a7" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">当M == 0时，GCD结果将== 0。</p><p id="4fd3" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">需要最后一个<a class="ae lq" href="https://en.cppreference.com/w/cpp/language/template_specialization" rel="noopener ugc nofollow" target="_blank">显式模板专门化</a>来停止递归模板实例化。当M和N都== 0时，我们需要一个特殊化:</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c9c7" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">有了上面的专门化，我们可以使用<a class="ae lq" href="https://en.wikipedia.org/wiki/Template_metaprogramming" rel="noopener ugc nofollow" target="_blank"> C++模板元编程</a>来计算欧几里德的GCD算法。</p><h1 id="6741" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">示例程序</h1><p id="9acf" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在我们已经整理好了模板，我们可以用它们来计算使用欧几里德算法的GCD。</p><figure class="mk ml mm mn gt jr"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="aa76" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">构建示例</h1><p id="7580" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们将使用g++来构建示例程序:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="c484" class="mv jv iq mr b gy mw mx l my mz">g++ -o euclid -std=c++11 euclid.cpp</span></pre><p id="8a22" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">我们指定C++ 11来确保constexpr的行为符合预期。</p><h1 id="b0d8" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">运行示例</h1><p id="d8cc" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">当我们运行该示例时，应该会看到以下输出:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="1c6b" class="mv jv iq mr b gy mw mx l my mz">GCD of 0, 0 = 0<br/>GCD of 6, 4 = 2<br/>GCD of 36, 24 = 12<br/>GCD of 270, 192 = 6<br/>GCD of 4, 6 = 2<br/>GCD of 24, 36 = 12<br/>GCD of 192, 270 = 6</span></pre><p id="7bc5" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">你可以看到，无论模板参数的顺序如何，我们得到的结果都是一样的。</p><h1 id="7da1" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">检查组件</h1><p id="5b44" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了确保我们不会招致运行时开销，我们可以生成程序集输出以供检查。在Linux上，我们这样做:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="b0a6" class="mv jv iq mr b gy mw mx l my mz">objdump -S --disassemble euclid &gt; euclid.lst</span></pre><p id="2ae1" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">您将看到，在程序执行期间，这些值被直接加载到寄存器中:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="617a" class="mv jv iq mr b gy mw mx l my mz">...<br/> 9f5:   be 02 00 00 00          mov    $0x2,%esi<br/> 9fa:   48 89 c7                mov    %rax,%rdi<br/> 9fd:   e8 9e fd ff ff          callq  7a0 &lt;_ZNSolsEm@plt&gt;<br/> a02:   48 89 c2                mov    %rax,%rdx<br/> a05:   48 8b 05 c4 15 20 00    mov    0x2015c4(%rip),%rax<br/>...<br/> a2a:   be 0c 00 00 00          mov    $0xc,%esi<br/> a2f:   48 89 c7                mov    %rax,%rdi<br/> a32:   e8 69 fd ff ff          callq  7a0 &lt;_ZNSolsEm@plt&gt;<br/> a37:   48 89 c2                mov    %rax,%rdx<br/>...</span></pre><p id="13d9" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">注意，我们将0x2和0xc的值直接载入微处理器寄存器:</p><pre class="mk ml mm mn gt mq mr ms mt aw mu bi"><span id="d21b" class="mv jv iq mr b gy mw mx l my mz">...<br/> 9f5:   be 02 00 00 00          mov    $0x2,%esi<br/>...<br/>a2a:   be 0c 00 00 00          mov    $0xc,%esi</span></pre><p id="e2a4" class="pw-post-body-paragraph ks kt iq ku b kv lt kx ky kz lu lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp ij bi translated">这是我们模板元编程的结果。</p><h1 id="d0a3" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="a092" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">C++模板可以通过<a class="ae lq" href="https://en.wikipedia.org/wiki/Template_metaprogramming" rel="noopener ugc nofollow" target="_blank"> C++模板元编程</a>做一些非常酷的事情。虽然这可能是一个玩具程序，但它展示了大多数模板元程序使用的机制。</p></div></div>    
</body>
</html>