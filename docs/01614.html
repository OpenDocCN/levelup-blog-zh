<html>
<head>
<title>Testing signed and encrypted cookies in Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rails中测试签名和加密的cookies</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/testing-signed-and-encrypted-cookies-in-rails-1742f4c15b6f?source=collection_archive---------21-----------------------#2020-01-15">https://levelup.gitconnected.com/testing-signed-and-encrypted-cookies-in-rails-1742f4c15b6f?source=collection_archive---------21-----------------------#2020-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dccdc5a0c3de73105a53d982b64de62c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oT7m5svU9X2Jm7sLL2YdeQ.png"/></div></div></figure><p id="fafc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近我一直在为我维护的gem重构测试，我需要测试它是否在正确的时间设置了正确的cookies。但是在gem中使用的cookie是签名cookie，这给我造成了一点小问题。我以前从未测试过签名cookie中的值，不知道该怎么做。</p><p id="dada" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我想分享一下我的发现，也许会有帮助。</p><h1 id="525b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">轨道上的饼干</h1><p id="3839" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在Rails应用程序中，有三种类型的cookie:简单会话cookie、签名cookie和加密cookie。您可以通过使用控制器中的<code class="fe ma mb mc md b">cookies</code>对象来设置这些，如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="ca46" class="mm ky iq md b gy mn mo l mp mq">class CookiesController &lt;  ApplicationController<br/>  def index<br/>    cookies["simple"] = "Hello, I am easy to read."<br/>    cookies.signed["protected"] = "Hello, I can be read, but I can't be tampered with."<br/>    cookies.encrypted["private"] = "Hello, I can't be read or tampered with."<br/>  end<br/>end</span></pre><h1 id="d277" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">简单的饼干</h1><p id="9411" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">简单的cookies由纯文本组成。如果你在浏览器中检查了上面的名为“simple”的cookie，你会看到文本“你好，我很容易阅读。”</p><p id="9902" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单的cookies可以用来存储无关紧要的数据。最终用户可以阅读和更改它，您的应用程序应该不会受到影响。</p><h1 id="d845" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">签名饼干</h1><p id="24e7" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">签名的cookies不会以纯文本的形式发送到浏览器。相反，它们包括由两个破折号<code class="fe ma mb mc md b">--</code>分隔的有效载荷和签名。在破折号之前，有效载荷是<a class="ae kw" href="https://en.wikipedia.org/wiki/Base64" rel="noopener ugc nofollow" target="_blank"> base 64编码数据</a>。要读取数据，你可以对它进行64位解码。这些数据不是秘密，但是不能被篡改，因为cookie的第二部分是签名。签名是通过对应用程序的<code class="fe ma mb mc md b">secret_key_base</code>和cookie中的数据进行HMAC·SHA1摘要而创建的。如果当您试图读取cookie时，cookie的内容被更改，签名将不再与内容匹配，Rails将返回<code class="fe ma mb mc md b">nil</code>。在引擎盖下，这一切都由<code class="fe ma mb mc md b"><a class="ae kw" href="https://api.rubyonrails.org/v6.0.2.1/classes/ActiveSupport/MessageVerifier.html" rel="noopener ugc nofollow" target="_blank">ActiveSupport::MessageVerifier</a></code>处理。正如您在上面看到的，您不需要担心这一点，您可以将<code class="fe ma mb mc md b">cookies.signed</code>对象视为一个散列。</p><p id="82c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">已签名的cookies对于可以被用户读取的数据是有用的，但是你需要信任的是当你再次把它拿回服务器时是一样的。</p><h1 id="2863" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">加密cookies</h1><p id="f8ea" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">加密cookie更进一步，加密cookie中的数据，然后签名。这是由<code class="fe ma mb mc md b"><a class="ae kw" href="https://api.rubyonrails.org/v6.0.2.1/classes/ActiveSupport/MessageEncryptor.html" rel="noopener ugc nofollow" target="_blank">ActiveSupport::MessageEncryptor</a></code>处理的，这意味着没有<code class="fe ma mb mc md b">secret_key_base</code>你就不能读写这个cookie。谢天谢地，你自己不需要担心加密问题，使用<code class="fe ma mb mc md b">cookies.encrypted</code>对象，你可以设置加密的cookies，就像它们是一个普通的散列一样。</p><p id="c6b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">加密的cookies对于您希望与用户一起存储的私有数据非常有用，但是您不希望他们或任何人读取这些数据。</p><h1 id="de85" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">测试cookies</h1><p id="3348" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">假设我们现在想要测试上面看到的控制器。我们希望确保我们所有的cookies设置正确。测试可能看起来像这样:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="0175" class="mm ky iq md b gy mn mo l mp mq">class CookiesControllerTest &lt; ActionDispatch::IntegrationTest<br/>  test "should set cookies when getting the index" do<br/>    get root_url<br/>    assert_response :success<br/>    assert_equal cookies["simple"], "Hello, I am easy to read."<br/>    assert_equal cookies["protected"], "Hello, I can be read, but I can't be tampered with."<br/>    assert_equal cookies["private"], "Hello, I can't be read or tampered with."<br/>  end<br/>end</span></pre><p id="f4af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或使用RSpec导轨:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e5d2" class="mm ky iq md b gy mn mo l mp mq">RSpec.describe CookiesController, type: :request do<br/>  it "should set cookies when getting the index" do<br/>    get root_url<br/>    expect(response).to have_http_status(:success)<br/>    expect(cookies["simple"]).to eq("Hello, I am easy to read.")<br/>    expect(cookies["protected"]).to eq("Hello, I can be read, but I can't be tampered with.")<br/>    expect(cookies["private"]).to eq("Hello, I can't be read or tampered with.")<br/>  end<br/>end</span></pre><p id="3621" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是这将无法通过签名cookie的测试，也无法通过加密cookie的测试。如果这些cookies已经被签名或加密，您就不能直接从罐子中调用它们。</p><p id="ddc6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能认为你应该测试一下<code class="fe ma mb mc md b">signed</code>和<code class="fe ma mb mc md b">encrypted</code>版本的cookies，就像这样:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e1f5" class="mm ky iq md b gy mn mo l mp mq">assert_equal cookies.signed["protected"], "Hello, I can be read, but I can't be tampered with."<br/>assert_equal cookies.encrypted["private"], "Hello, I can't be read or tampered with."</span></pre><p id="2253" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那也不行。至少如果你使用当前推荐的测试控制器的方式，在Minitest中使用<code class="fe ma mb mc md b">ActionDispatch::IntegrationTest</code>或者在RSpec中使用<code class="fe ma mb mc md b">type: :request</code>，它就不会工作。</p><p id="2283" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有旧的风格<code class="fe ma mb mc md b">ActionController::TestCase</code>或<code class="fe ma mb mc md b">type: :controller</code>测试，那么<code class="fe ma mb mc md b">cookies.signed</code>和<code class="fe ma mb mc md b">cookies.encrypted</code>将工作。如果您有一个使用旧风格测试的应用程序，请继续阅读，以防万一您决定重构它们以符合当前的Rails方式。</p><p id="be7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过上面的测试，<code class="fe ma mb mc md b">cookies</code>对象实际上是<code class="fe ma mb mc md b">Rack::Test::CookieJar</code>的一个实例，它不知道您的Rails应用程序的秘密。</p><h1 id="38a1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">那么我们如何测试这些饼干呢？</h1><p id="3223" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这就是我研究宝石的地方。我需要测试一个签名cookie的结果，但是我有一个<code class="fe ma mb mc md b">Rack::Test::CookieJar</code>对象。好消息是，我们可以让Rails应用程序自己的<code class="fe ma mb mc md b">ActionDispatch::Cookies::CookieJar</code>重新发挥作用，来解码您的签名cookie和解密您的加密cookie。</p><p id="a1b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，您使用来自测试的<code class="fe ma mb mc md b">request</code>对象和您的cookie数据的散列来实例化一个<code class="fe ma mb mc md b">ActionDispatch::Cookies::CookieJar</code>实例。然后你可以在饼干罐上调用<code class="fe ma mb mc md b">signed</code>或<code class="fe ma mb mc md b">encrypted</code>。所以现在测试看起来像:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="562a" class="mm ky iq md b gy mn mo l mp mq">class CookiesControllerTest &lt; ActionDispatch::IntegrationTest<br/>  test "should set cookies when getting the index" do<br/>    get root_url<br/>    assert_response :success<br/>    assert_equal cookies["simple"], "Hello, I am easy to read."<br/>    jar = ActionDispatch::Cookies::CookieJar.build(request, cookies.to_hash)<br/>    assert_equal jar.signed["protected"], "Hello, I can be read, but I can't be tampered with."<br/>    assert_equal jar.encrypted["private"], "Hello, I can't be read or tampered with."<br/>  end<br/>end</span></pre><p id="715f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者规格看起来像这样:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="9d8e" class="mm ky iq md b gy mn mo l mp mq">RSpec.describe CookiesController, type: :request do<br/>  it "gets cookies from the response" do<br/>    get root_url<br/>    expect(response).to have_http_status(:success)<br/>    expect(cookies["simple"]).to eq("Hello, I am easy to read.")<br/>    jar = ActionDispatch::Cookies::CookieJar.build(request, cookies.to_hash)<br/>    expect(jar.signed["protected"]).to eq("Hello, I can be read, but I can't be tampered with.")<br/>    expect(jar.encrypted["private"]).to eq("Hello, I can't be read or tampered with.")<br/>  end<br/>end</span></pre><h1 id="833a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">红色，绿色，再小吃-tor</h1><p id="046f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在这篇文章中，我们看到了如何在Rails中测试签名或加密的cookies。希望您的测试套件运行正常，并且您的cookies现在已经被覆盖。</p><p id="9a71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我要回到我正在做的重构。既然这些饼干已经被吃光了，还有很多测试要做。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="0db1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="my">原载于2020年1月15日</em><a class="ae kw" href="https://philna.sh/blog/2020/01/15/test-signed-cookies-in-rails/" rel="noopener ugc nofollow" target="_blank"><em class="my">https://philna . sh</em></a><em class="my">。</em></p></div></div>    
</body>
</html>