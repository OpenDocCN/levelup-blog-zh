<html>
<head>
<title>Reuse, reduce. . . useReducer?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重用，减少。。。useReducer？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/reuse-reduce-usereducer-5f11f2dd1e98?source=collection_archive---------2-----------------------#2022-03-10">https://levelup.gitconnected.com/reuse-reduce-usereducer-5f11f2dd1e98?source=collection_archive---------2-----------------------#2022-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/84815e8ceca31902e3fca2aa0b66ac30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fxa6oJFh2lRD7EnAcZIcQg.png"/></div></div></figure><p id="0c2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React是一个非常棒的工具，它让编写JavaScript应用程序变得更加容易和简洁。任何构建过普通JavaScript应用程序和React应用程序的人可能都会同意React应用程序具有明显的优势。幸运的是，在React 16.8中引入了钩子，这进一步增加了库的易用性和优雅性。</p><p id="2cfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些最常用的挂钩是useEffect和useState，这两个挂钩的学习曲线相对较浅，因为它们非常简单，并且使用简单的语法。然而，在这篇博文中，我想讨论一个更复杂的React钩子… useReducer。我们将看看实现这个钩子所需的每个步骤，并讨论它什么时候最有用。</p><h1 id="b8a5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是useReducer？</h1><p id="0c33" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在我们进入代码之前，让我们先讨论一下<em class="lz">useReducer实际上是什么。useReducer挂钩与useState挂钩非常相似，因为它是一种用于管理应用程序状态的工具。本质上，它允许我们存储状态，并为我们如何在应用程序中操作该状态设置规则。</em></p><p id="3899" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与useState相比，useReducer最显著的优点之一是它提供了更简洁的状态管理解决方案，尤其是对于更复杂的状态。此外，如<a class="ae ma" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"> React文档</a>所述，在基于前一状态计算下一状态的情况下，useReducer优于useState。这是因为useReducer产生了更加一致和可预测的状态转换。</p><h1 id="bbb9" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">useReducer挂钩的作用。</h1><p id="434f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">作为一个基本的例子，我创建了这个应用程序，它利用useReducer来管理/操作计数状态。在继续阅读的过程中，您可以随意打开沙箱，摆弄代码。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ee89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个应用程序有一个初始值1(存储为一个状态)和几个可以操作该状态的按钮。让我们看看使用useReducer实现这个应用程序需要做些什么。</p><ol class=""><li id="4af5" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated">当使用useReducer钩子时，我们需要做的第一件事是从React导入它。这将允许我们“挂钩”useReducer功能:</li></ol><pre class="mb mc md me gt mq mr ms mt aw mu bi"><span id="25af" class="mv kx iq mr b gy mw mx l my mz">import React, { <strong class="mr ir">useReducer</strong>, useState } from “react”;</span></pre><p id="a247" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.接下来，我们将使用析构赋值语法为useReducer进行初始设置，类似于useState。在我们的示例中，这个reducer函数将接受两个参数，即函数和初始值，并将返回一个数组(状态和调度函数):</p><pre class="mb mc md me gt mq mr ms mt aw mu bi"><span id="394a" class="mv kx iq mr b gy mw mx l my mz">const [state, dispatch] = useReducer(reducer, { count: 1 });</span></pre><p id="e10f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.现在我们需要编写传递给useReducer的reducer函数。这个函数将接受一个状态(当前状态)和一个动作。该动作将被传递到上面提到的dispatch函数中，并将被设置为我们称之为dispatch的任何值(参见5):</p><pre class="mb mc md me gt mq mr ms mt aw mu bi"><span id="9a9a" class="mv kx iq mr b gy mw mx l my mz">function reducer(state, action) {</span><span id="027d" class="mv kx iq mr b gy na mx l my mz">}</span></pre><p id="72b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4.一旦我们有了reducer函数，我们就可以开始使用switch语句构建我们的动作。在这里，我们可以为我们想要执行的每个状态操作创建一个案例:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nb mg l"/></div></figure><p id="b8ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">5.现在我们已经在reducer函数中描述了所有不同的情况，我们可以使用dispatch函数向reducer发送一个动作，该动作将触发与该动作类型相关的状态变化。这类似于useState挂钩中的setter函数:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nb mg l"/></div></figure><p id="4418" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些函数可以传递给JSX中按钮上的事件监听器:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="nb mg l"/></div></figure><h1 id="d7f4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">等等……有效载荷？就像在深红的天空中？</h1><p id="77a9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在上面的例子中，您可能已经注意到，其中一个分派函数传递了一个payload对象。这是你真正开始看到useReducer的魔力的地方。让我们再来看看我们的switch语句，特别是set-number的情况:</p><pre class="mb mc md me gt mq mr ms mt aw mu bi"><span id="2641" class="mv kx iq mr b gy mw mx l my mz">case “set-number”:</span><span id="c126" class="mv kx iq mr b gy na mx l my mz">return { count: (state.count = <strong class="mr ir">action.payload.value</strong>) };</span></pre><p id="5179" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该操作的目的是将计数器设置为我们在表单中输入的任何值。然而，为了让这个动作知道那个值是什么，我们需要以某种方式让它知道。我们可以通过向我们的调度函数传递一个有效负载来实现这一点。有效负载是一个对象，它应该包含执行我们调用的指定操作所需的所有值。</p><pre class="mb mc md me gt mq mr ms mt aw mu bi"><span id="86d8" class="mv kx iq mr b gy mw mx l my mz">const handleSet = (e, num) =&gt; {</span><span id="8eaf" class="mv kx iq mr b gy na mx l my mz">e.preventDefault();</span><span id="83cc" class="mv kx iq mr b gy na mx l my mz">dispatch({ type: “set-number”, <strong class="mr ir">payload: { value: num }</strong> });</span><span id="af02" class="mv kx iq mr b gy na mx l my mz">setNum();</span><span id="dd0e" class="mv kx iq mr b gy na mx l my mz">};</span></pre><p id="26ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在上面看到的，我们将num的值(这是一个保存表单提交时的值的状态)传递给我们的“set-number”操作，这样它就可以将计数器设置为这个数字。在switch语句中，我们可以通过点符号深入到对象中来获得该值。</p><h1 id="9e41" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">TL；速度三角形定位法(dead reckoning)</h1><ol class=""><li id="be96" class="mh mi iq ka b kb lu kf lv kj nc kn nd kr ne kv mm mn mo mp bi translated">useReducer是一个帮助我们管理和操作状态的React钩子。</li><li id="1478" class="mh mi iq ka b kb nf kf ng kj nh kn ni kr nj kv mm mn mo mp bi translated">useReducer对于复杂状态或基于前一状态计算的状态最为有用。</li><li id="2d1d" class="mh mi iq ka b kb nf kf ng kj nh kn ni kr nj kv mm mn mo mp bi translated">useReducer是使用析构赋值语法设置的。它被传递一个reducer函数和初始状态，并返回状态和一个分派函数。</li><li id="0330" class="mh mi iq ka b kb nf kf ng kj nh kn ni kr nj kv mm mn mo mp bi translated">reducer函数接受两个参数，当前状态和一个动作。</li><li id="7434" class="mh mi iq ka b kb nf kf ng kj nh kn ni kr nj kv mm mn mo mp bi translated">reducer函数包含所有操作状态的动作。</li><li id="7baa" class="mh mi iq ka b kb nf kf ng kj nh kn ni kr nj kv mm mn mo mp bi translated">dispatch函数向我们的reducer函数发送一个动作，该动作将根据我们预定义的规则触发状态的变化。</li><li id="962b" class="mh mi iq ka b kb nf kf ng kj nh kn ni kr nj kv mm mn mo mp bi translated">有效负载是传递给调度函数的对象，包含执行操作所需的所有值。</li></ol></div></div>    
</body>
</html>