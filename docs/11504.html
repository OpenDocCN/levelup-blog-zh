<html>
<head>
<title>Arity, Closure, Currying, Partial Application &amp; more in Dart [Functional Programming — Part 2]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Arity、闭包、Currying、部分应用&amp; Dart[函数式编程—第2部分]中的更多内容</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/arity-closure-currying-partial-application-more-in-dart-functional-programming-part-2-4534a8b7f374?source=collection_archive---------7-----------------------#2022-03-22">https://levelup.gitconnected.com/arity-closure-currying-partial-application-more-in-dart-functional-programming-part-2-4534a8b7f374?source=collection_archive---------7-----------------------#2022-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="2739" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/@yogi-6/list/functional-programming-in-dart-flutter-2f3ac9d7fa39" rel="noopener">Dart中的功能编程</a> / Arity、Closure、curring&amp;</h2><div class=""/><div class=""><h2 id="9361" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">本文旨在解释Dart和Flutter中的函数、闭包、部分应用程序、函数与调用堆栈的关系以及更多内容</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/93733cbbc6104222d5fdfccdf82f5f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGCUkKBdSI2RgWeVKsTdfw.png"/></div></div></figure><h1 id="66c2" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">目录</h1><ul class=""><li id="6d68" class="ls lt iq lu b lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><a class="ae mk" href="#78d1" rel="noopener ugc nofollow"> <strong class="lu ja">参数vs变元</strong> </a></li><li id="7cdb" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated"><a class="ae mk" href="#03b1" rel="noopener ugc nofollow"> <strong class="lu ja"> Arity </strong> </a></li><li id="85a4" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated"><a class="ae mk" href="#c2d6" rel="noopener ugc nofollow"> <strong class="lu ja">函数&amp;调用堆栈</strong> </a></li><li id="11cb" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated"><a class="ae mk" href="#42d5" rel="noopener ugc nofollow"> <strong class="lu ja">封</strong> </a></li><li id="0cd4" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated"><a class="ae mk" href="#7425" rel="noopener ugc nofollow"> <strong class="lu ja">局部应用</strong> </a></li><li id="f5d9" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated"><a class="ae mk" href="#a606" rel="noopener ugc nofollow"> <strong class="lu ja">无点风格</strong> </a></li><li id="cd8e" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated"><a class="ae mk" href="#6fda" rel="noopener ugc nofollow"><strong class="lu ja"/></a></li><li id="bff6" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated"><a class="ae mk" href="#f327" rel="noopener ugc nofollow"> <strong class="lu ja">例题</strong> </a></li><li id="821a" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated"><a class="ae mk" href="#ec47" rel="noopener ugc nofollow"> <strong class="lu ja">结论</strong> </a></li><li id="d3dc" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated"><a class="ae mk" href="#343b" rel="noopener ugc nofollow"> <strong class="lu ja">本系列其他文章</strong> </a></li></ul></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="78d1" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">我注意到这个术语的自变量和参数可以互换使用。所以在开始之前，我们先了解一下区别。</p><p id="7d1d" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated"><strong class="lu ja">参数:</strong>参数是函数声明的一部分。</p><p id="f569" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated"><strong class="lu ja">参数:</strong>参数是传递给函数的值。它是函数调用的一部分。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/dbcae6880d6e178cf0024402bf8af810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EyLZlSNMetTh1PHl719t6g.png"/></div></div></figure><p id="72cd" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">这里，在<code class="fe nn no np nq b">add</code>函数声明中，<code class="fe nn no np nq b">numberOne</code>和<code class="fe nn no np nq b">numberTwo</code>是参数。在2号线上；1和2是传递给add函数的参数。</p><p id="684b" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">简单地说，参数是接受值的变量，实参是传入的值。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="03b1" class="la lb iq bd lc ld nr lf lg lh ns lj lk kf nt kg lm ki nu kj lo kl nv km lq lr bi translated">Arity</h1><p id="29e2" class="pw-post-body-paragraph mx my iq lu b lv lw ka na lx ly kd nc lz nw ne nf mb nx nh ni md ny nk nl mf ij bi translated">Arity是函数接受的参数个数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nm"><img src="../Images/ed9f43d4b487f61ef63a618c41f0f6ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jWIKTBgMyxU2Fp9CjsCMAw.png"/></div></div></figure><p id="95f2" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated"><code class="fe nn no np nq b">increment</code>函数的arity为1。接受单个参数的函数称为<strong class="lu ja">一元</strong>函数。</p><p id="b276" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated"><code class="fe nn no np nq b">add</code>的arity是2。带两个参数的函数称为<strong class="lu ja">二元</strong>函数。</p><p id="6285" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated"><code class="fe nn no np nq b">now</code>的arity为0。不带参数的函数被称为<strong class="lu ja">空值</strong>函数。</p><p id="cfd0" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated"><code class="fe nn no np nq b">isOdd</code>的arity是1，因此它是一个<strong class="lu ja">一元</strong>函数。<code class="fe nn no np nq b">isOdd</code>也是一个<strong class="lu ja">谓词</strong>函数，因为它返回一个布尔值。谓词函数是返回布尔值的函数。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="c2d6" class="la lb iq bd lc ld nr lf lg lh ns lj lk kf nt kg lm ki nu kj lo kl nv km lq lr bi translated">函数和调用堆栈</h1><p id="2c5d" class="pw-post-body-paragraph mx my iq lu b lv lw ka na lx ly kd nc lz nw ne nf mb nx nh ni md ny nk nl mf ij bi translated">让我们理解一个函数经历哪些阶段。首先，声明。这包括函数名、它的参数和函数体。每个函数都有一个作用域，用于维护该函数所有变量的状态。一旦该函数被调用(即被调用)，它就被添加到调用堆栈中。</p><p id="f4d6" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">调用栈是函数调用的列表。它使用堆栈，遵循后进先出的原则。当函数返回时，它将从调用堆栈中移除。由于Dart是单线程语言，调用堆栈有助于维护所有函数调用的历史记录。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="42d5" class="la lb iq bd lc ld nr lf lg lh ns lj lk kf nt kg lm ki nu kj lo kl nv km lq lr bi translated">关闭</h1><p id="2294" class="pw-post-body-paragraph mx my iq lu b lv lw ka na lx ly kd nc lz nw ne nf mb nx nh ni md ny nk nl mf ij bi translated">正如所见，每个函数都有一个作用域。因此，当一个函数被定义到另一个函数中时，内部函数会记住外部函数的范围，即使外部函数已经执行并且不再可用。这就是所谓的终结。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nz"><img src="../Images/d8659412ab89f0aa11555e60637288ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mXOMUw9El8ABO2AV4E1RVA.png"/></div></div></figure><p id="7221" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated"><code class="fe nn no np nq b">_secondFunction</code>是在<code class="fe nn no np nq b">_firstFunction</code>内部声明的内部函数。在第5行，我们调用<code class="fe nn no np nq b">_firstFunction</code>，它返回<code class="fe nn no np nq b">_secondFunction</code>，存储在<code class="fe nn no np nq b">_firstFnResult</code>变量中。调用堆栈在返回值时移除<code class="fe nn no np nq b">_firstFunction</code>。我们来看看<code class="fe nn no np nq b">_secondFunction</code>的车身。它正在访问位于<code class="fe nn no np nq b">_firstFunction</code>范围内的<code class="fe nn no np nq b">_someValue</code>变量。如果我们调用<code class="fe nn no np nq b">_firstFnResult</code>，当它保持状态时，它将在控制台上打印值。是因为封闭。</p><p id="6d2a" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">我们再举一个例子。我们在第8行调用<code class="fe nn no np nq b">add</code>函数。函数add接受单个参数，并返回一个接受单个参数的函数。现在，由于函数记住了第一个参数(在我们的例子中是1)，我们只需要传递第二个参数，它就会返回总和。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="7425" class="la lb iq bd lc ld nr lf lg lh ns lj lk kf nt kg lm ki nu kj lo kl nv km lq lr bi translated">部分应用</h1><p id="d9b3" class="pw-post-body-paragraph mx my iq lu b lv lw ka na lx ly kd nc lz nw ne nf mb nx nh ni md ny nk nl mf ij bi translated">应用于某些输入的函数是部分应用。闭包帮助我们实现部分应用。部分应用程序背后的思想是锁定一些参数，这样我们就不必重复传递它们。让我们来看看闭包部分所附图片中的<code class="fe nn no np nq b">add</code>函数。<code class="fe nn no np nq b">add</code>函数需要两个连续的参数来返回结果，但是我们传递了一个参数并将其赋给了<code class="fe nn no np nq b">_increment</code>变量。我们没有给出所有的论点；我们已经部分应用了该功能。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="a606" class="la lb iq bd lc ld nr lf lg lh ns lj lk kf nt kg lm ki nu kj lo kl nv km lq lr bi translated">无点风格</h1><p id="927f" class="pw-post-body-paragraph mx my iq lu b lv lw ka na lx ly kd nc lz nw ne nf mb nx nh ni md ny nk nl mf ij bi translated">我们可以考虑像传递给函数的参数这样的点。无点风格定义了一个函数，而不需要显式地传递参数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oa"><img src="../Images/2e9b387009577d743cc0579e506d88ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F-EZvNBMvAm86EPJVLPH_g.png"/></div></div></figure><p id="317d" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">在3号线上；e是明确传递给增量函数的点。为了将其转换为无点样式，我们删除了显式参数。</p><p id="fa07" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">无点风格，如果不过分，会使代码简洁易读。这更多的是一种选择，而不是必须。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="6fda" class="la lb iq bd lc ld nr lf lg lh ns lj lk kf nt kg lm ki nu kj lo kl nv km lq lr bi translated">Currying</h1><p id="ef88" class="pw-post-body-paragraph mx my iq lu b lv lw ka na lx ly kd nc lz nw ne nf mb nx nh ni md ny nk nl mf ij bi translated">将一个多参数函数分解成一系列单参数函数就是currying。一个curried函数一次接受一个参数，然后返回一个接受一个参数的函数，以此类推，直到所有的参数都被传递。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/36045d9c231ba2d3111227068359dd66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ifu8pJ63SMLx3rXDVqPHKQ.png"/></div></div></figure><p id="bdc4" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated"><code class="fe nn no np nq b">greet</code>是一个接受两个参数并返回一个字符串的函数。</p><p id="70a1" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">一个咖喱版本的问候会看起来像<code class="fe nn no np nq b">curriedGreet</code>。它接受一个参数并返回一个函数，该函数接受一个参数并返回结果。</p><p id="10d3" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">如果这是您第一次查看curried函数，那么<code class="fe nn no np nq b">_curriedGreet</code>的实现可能看起来有点奇怪。此外，您可能已经注意到，随着参数数量的增加，它将有一个深度嵌套的结构。那么有没有办法克服这些问题呢？</p><p id="a1dd" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">欢迎光临，<strong class="lu ja">达斯！</strong>我们将使用<code class="fe nn no np nq b">dartz</code>包在dart中实现FP概念。让我们使用<code class="fe nn no np nq b">dartz</code>将greet函数转换成curried函数。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/9d795db83f0da49b59e11caf443d8c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IziLbx51NLqoMkQAZHkr5g.png"/></div></div></figure><p id="a430" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated"><code class="fe nn no np nq b">curry2</code>是由<code class="fe nn no np nq b">dartz</code>包提供的一个函数，它将两个参数的函数转换成一个curried函数。是的，你猜对了！<code class="fe nn no np nq b">curry3</code>是将一个三参数函数转化为一个可化函数，<code class="fe nn no np nq b">curry4</code>为四参数函数，以此类推，直到<code class="fe nn no np nq b">curry6</code>。</p><pre class="kp kq kr ks gt oc nq od oe aw of bi"><span id="cf39" class="og lb iq nq b gy oh oi l oj ok">C Function(B) Function(A) curry2&lt;A, B, C&gt;(C Function(A, B) fun)</span></pre><p id="fba1" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">上面是采用3个泛型的<code class="fe nn no np nq b">curry2</code>声明。<code class="fe nn no np nq b">A</code>和<code class="fe nn no np nq b">B</code>分别是您想要搜索的函数的第一个和第二个参数。<code class="fe nn no np nq b">C</code>是结果。我们的<code class="fe nn no np nq b">greet</code>函数接收两个字符串并返回一个字符串；因此我们传递3个字符串作为泛型。</p><h1 id="709d" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">curry vs部分应用</h1><p id="bdfa" class="pw-post-body-paragraph mx my iq lu b lv lw ka na lx ly kd nc lz nw ne nf mb nx nh ni md ny nk nl mf ij bi translated">部分应用和currying可能看起来一样，但它们是不同的概念。分部应用程序一次可以接受多个参数，而curried函数总是必须返回一个一元函数(单参数函数)。Curried函数用于创建部分应用程序，但并非所有部分应用程序都是curried函数。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="f327" class="la lb iq bd lc ld nr lf lg lh ns lj lk kf nt kg lm ki nu kj lo kl nv km lq lr bi translated">例子</h1><p id="1ba4" class="pw-post-body-paragraph mx my iq lu b lv lw ka na lx ly kd nc lz nw ne nf mb nx nh ni md ny nk nl mf ij bi translated">现在我们知道了这些概念，让我们把它们结合起来，创建一个用人们的语言问候他们的程序。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ol"><img src="../Images/8e45188c6628cd9a78fcec6750d08655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qw5eaVWOYBtv-1C6Px2JBQ.png"/></div></div></figure><p id="a648" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">我们有相同的<code class="fe nn no np nq b">greet</code>函数，它接受两个参数并返回一个字符串。第一个参数是称呼，可以根据用户的来源而不同，第二个参数是用户名。如果我们有50个来自印度的人，我们必须传递50次hello参数，这似乎是多余的。让我们用我们学过的概念，应用到这里。</p><p id="fcdb" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">我们使用<code class="fe nn no np nq b">dartz</code>包中的<code class="fe nn no np nq b">curry2</code>将我们的<code class="fe nn no np nq b">greet</code>函数转换成第15行的curried函数。利用这一点，我们可以创建几个salutation部分应用程序，以后只需传递用户名就可以使用它们。</p><p id="dbd1" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">我们从第17行到第20行创建部分应用程序，并传入salutation参数。现在<code class="fe nn no np nq b">_hello</code>是一个部分应用程序，因为它还没有完全执行。在我们的场景中，它是一个需要第二个参数，即用户名的函数。看第30行和第31行；当我们打印<code class="fe nn no np nq b">_hello</code>时，我们得到一个函数，它期望一个字符串作为参数。</p><p id="a58c" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">现在我们都准备好了，我们已经准备好使用这些部分应用的函数。如果需要新的称呼支持，我们只需要创建一个新的部分应用程序。为了使用它们，我们在第22到27行传递用户名，给出结果。即使我们没有传递salutation参数，<code class="fe nn no np nq b">_hello</code>和其他函数也会因为闭包而记住它们。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="ec47" class="la lb iq bd lc ld nr lf lg lh ns lj lk kf nt kg lm ki nu kj lo kl nv km lq lr bi translated">结论</h1><p id="70bc" class="pw-post-body-paragraph mx my iq lu b lv lw ka na lx ly kd nc lz nw ne nf mb nx nh ni md ny nk nl mf ij bi translated">唷！那很了不起。我们从基础知识开始:实参与形参，讨论了函数的Arity以及函数和调用栈如何协同工作。然后我们探讨了闭包、部分应用程序、Currying以及它们是如何一起工作的。我们还看到了单点自由风格，以及它如何导致一个可读的代码库。最后，我们用一个例子来展示这些概念。所有这些可能看起来有点奇怪，但是一旦我们开始使用这些，它就会成为第二天性。试着看看你是否能在你现有的代码库中实现它。像其他事情一样，你练习得越多，感觉就越自然。</p><p id="3099" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">在接下来的文章中，我们将提升我们在功能组合方面的水平，并将这些技术与我们今天所学的结合起来解决复杂的问题。</p><p id="10c0" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated"><strong class="lu ja">牛逼！</strong>拍拍自己的背，因为你坚持到了最后。我希望我为你投入的时间增加了一些价值。在<a class="ae mk" href="https://github.com/Yogi-6/functional_programming_dart" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ja"> GitHub </strong> </a>知识库上找到更多例子，并在<a class="ae mk" href="https://twitter.com/_yogi_6" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ja"> Twitter </strong> </a>或<a class="ae mk" href="https://www.linkedin.com/in/yogi6/" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ja"> LinkedIn </strong> </a>上寻求建议/问题或任何你希望我涵盖的主题。你可以鼓掌支持👏，感谢您的阅读:)更多信息请关注😄</p><p id="80ad" class="pw-post-body-paragraph mx my iq lu b lv mz ka na lx nb kd nc lz nd ne nf mb ng nh ni md nj nk nl mf ij bi translated">下次见，伙计们！</p><h1 id="343b" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">本系列的其他文章</h1><ul class=""><li id="5f85" class="ls lt iq lu b lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><a class="ae mk" href="https://yogi-6.medium.com/functional-programming-in-dart-foundation-part-0-7e932517b824" rel="noopener">基础</a></li><li id="fc3e" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated"><a class="ae mk" href="https://yogi-6.medium.com/pure-functions-side-effects-in-dart-functional-programming-part-1-fb931d6c0351" rel="noopener">纯功能&amp;副作用</a></li><li id="468e" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated">Arity，Closure，Currying，Partial Application &amp;更多。</li><li id="1d2e" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated"><a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/composition-in-flutter-dart-functional-programming-part-3-ffba917aee3d">构图</a></li><li id="8109" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated"><a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/immutability-equality-in-flutter-dart-functional-programming-part-4-339a4e9312bb">永恒性&amp;平等性</a></li><li id="accf" class="ls lt iq lu b lv ml lx mm lz mn mb mo md mp mf mg mh mi mj bi translated"><a class="ae mk" href="https://medium.com/flutter-community/higher-order-functions-recursion-in-dart-functional-programming-part-5-4237bc114005" rel="noopener">高阶函数&amp;递归</a></li></ul></div></div>    
</body>
</html>