<html>
<head>
<title>Getting Started with Docker Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker撰写入门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/docker-compose-97a18618565a?source=collection_archive---------11-----------------------#2020-07-02">https://levelup.gitconnected.com/docker-compose-97a18618565a?source=collection_archive---------11-----------------------#2020-07-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="54da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自动化和划分本地开发环境</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1f96e7dbf046a1558b6d879f892bc346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t58FnPNmAvZ5QqhJAem_wA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">划分——由<a class="ae le" href="https://www.flickr.com/photos/thomashawk/34563079732" rel="noopener ugc nofollow" target="_blank">托马斯·霍克</a></figcaption></figure><p id="48a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，Docker在CI/CD领域做得非常出色，许多开发人员无法想象回到过去糟糕、脆弱的部署时代。但是在本文中，我想先讨论一下Docker Compose，以及它如何从根本上改善了我的本地开发环境。</p><p id="7946" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">注意:</em>本文并不包括构建一个示例应用程序或服务。这意味着您可以带来自己的Nodejs服务，并利用本文中Docker Compose的优势。</p><h1 id="342a" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">什么是Docker Compose？</h1><p id="e628" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">引用Docker的官方文件:</p><blockquote class="mj mk ml"><p id="189b" class="jq jr lf js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated">Compose是一个定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用YAML文件来配置应用程序的服务。然后，只需一个命令，您就可以从您的配置中创建并启动所有服务。</p></blockquote><p id="9ec2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者换句话说，一个简单的文本文件，其中包含Docker应该运行哪些图像的指令，以及每个容器的命令或配置。</p><h1 id="262a" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">为什么使用Docker Compose？</h1><p id="010a" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">当我们的开发团队从。NET到nodejs，这对我们来说是一个相当大的变化。网退伍军人。一个困难是运行多个服务，所有服务都有不同的端口和配置，并且不断地改变我的本地配置以匹配我想要运行的任何服务。至少可以说是一团糟。</p><p id="2b08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是Docker Compose拯救世界的地方。</p><h1 id="9675" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">入门指南</h1><p id="771e" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">如果您的系统上已经安装并运行了Docker，您可以跳过这一部分。</p><p id="7ece" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">前往Docker下载Docker桌面。</p><p id="24ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦你完成了Docker桌面安装，打开一个终端并运行<code class="fe mp mq mr ms b">docker --version</code>来查看你的系统上安装了哪个版本的Docker。</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="6ed5" class="mx lh it ms b gy my mz l na nb">$ docker --version<br/>Docker version 19.03.<!-- -->8, build afacb8b</span></pre><p id="b56b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您看到类似上面的输出，那么恭喜您，您已经准备好了。</p><h1 id="27c0" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">示例设置</h1><p id="2f0b" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">在这个例子中，我们将使用节点版本10，更多解释如下。</p><p id="8094" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们从使用Node的一个非常简单的设置开始。在节点服务所在的同一父目录中创建一个名为<code class="fe mp mq mr ms b">docker-compose.yml</code>的文件(并行):</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="453d" class="mx lh it ms b gy my mz l na nb">repo-dir/<br/>  | -- docker-compose.yml<br/>  | -- my-first-service/</span></pre><p id="6a53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用您喜欢的文本编辑器，插入以下内容:</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="2dd5" class="mx lh it ms b gy my mz l na nb">version: '3'<br/>services:</span><span id="d910" class="mx lh it ms b gy nc mz l na nb">  my-first-service:<br/>    image: node:10<br/>    volumes:<br/>      - ./my-first-service:/app:ro<br/>    working_dir: /app<br/>    command: npm run start<br/>    ports:<br/>      - "3000:8080"</span></pre><p id="da93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lf">注意:</em>关于YAML，现在你需要知道的是，它类似于JSON，但是依赖于空格缩进而不是花括号。</p><p id="bb2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于Docker Compose文件格式，可以写一整篇文章，但出于本文的目的，我将简要解释上面的内容。更多详情见:<a class="ae le" href="https://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples" rel="noopener ugc nofollow" target="_blank"> Docker合成文件格式</a>。</p><p id="8abb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好了，我们把这个拆开，说说每一行是什么意思。第一行告诉Docker这个组合文件格式是哪个版本的。第二行描述了我们将执行哪个<code class="fe mp mq mr ms b">services</code>,这由一个全新的缩进部分表示</p><p id="31de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">。在本节中，我们给我们的服务起了个名字:<code class="fe mp mq mr ms b">my-first-service</code>，这个名字又缩进了:</p><p id="a22d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">映像</strong> <br/>这指示Docker使用<code class="fe mp mq mr ms b">node</code> Docker映像和该映像的版本<code class="fe mp mq mr ms b">10</code>，不一定是Node的版本10。然而，那些疯狂的酷节点家伙很聪明，他们将节点Docker映像的版本与节点本身的版本进行了映射。在这种情况下:<code class="fe mp mq mr ms b">node:10</code>意味着我们使用的是节点版本10的最新<em class="lf">版本。</em></p><p id="b99d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将服务所在的本地目录映射到容器中代码所在的目录。您还会注意到<code class="fe mp mq mr ms b">ro</code>，它指示Docker这个目录应该被视为只读的。</p><p id="e601" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦你的容器被初始化(快速说明:一个容器是从运行过的<code class="fe mp mq mr ms b">node:10</code>映像创建的，稍后会详细介绍)，这将指示Docker什么目录应该是工作目录。</p><p id="ae02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">命令</strong> <br/>一旦容器启动并运行，应该执行什么命令。这将通过Docker docs为该容器设置默认值:</p><blockquote class="mj mk ml"><p id="f881" class="jq jr lf js b jt ju jv jw jx jy jz ka mm kc kd ke mn kg kh ki mo kk kl km kn im bi translated">CMD的主要目的是为正在执行的容器提供默认值。</p></blockquote><p id="4c86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">端口</strong> <br/>这映射了哪些端口应该暴露在容器之外。因此，在本例中，节点在内部运行，端口<code class="fe mp mq mr ms b">8080</code>使用端口<code class="fe mp mq mr ms b">3000</code>将其暴露给外部。当您有多个服务(稍后将详细介绍)且所有服务都有意配置为在特定端口上运行时，这尤其有用。这使得本地环境中的配置非常简单。</p><h1 id="93b4" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">运行服务</h1><p id="0a8a" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">我们现在准备好运行服务了。现在是时候使用<code class="fe mp mq mr ms b">docker-compose</code>命令了。在与我们的<code class="fe mp mq mr ms b">docker-compose.yml</code>文件相同的目录中，我们只需执行:</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="186c" class="mx lh it ms b gy my mz l na nb">docker-compose up</span></pre><p id="e701" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，它所做的就是查看你的YAML文件，看看它需要什么样的映像，从<a class="ae le" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>获取映像，使用YAML文件中指定的所有参数通过<code class="fe mp mq mr ms b">docker run</code>启动映像，最后生成一个容器。</p><p id="b42a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，您应该可以通过curl、浏览器(GET)或优秀的<a class="ae le" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>应用程序在端口<code class="fe mp mq mr ms b">3000</code>访问您的任何服务端点。</p><h1 id="9546" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">管理容器</h1><p id="15c3" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">有很多非常有用的工具可以用来管理你的容器，我将简单描述其中的几个。</p><p id="58e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的容器正在运行，您将在某个时候需要停止它。为此，只需在命令行上执行组合键:<code class="fe mp mq mr ms b">ctrl-c</code>。现在您的容器停止了，让我们再次启动它，但这次是在分离模式下:</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="9ff9" class="mx lh it ms b gy my mz l na nb">docker-compose up -d</span></pre><p id="7b96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会注意到它很快启动容器，显示一个指示<code class="fe mp mq mr ms b">done</code>的状态，然后退出。</p><p id="309d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以通过以下方式检查容器的状态:</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="72e1" class="mx lh it ms b gy my mz l na nb">docker ps</span></pre><p id="c864" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其中有一些有用的信息，如每个集装箱的<code class="fe mp mq mr ms b">CONTAINER ID</code>、<code class="fe mp mq mr ms b">STATUS</code>和<code class="fe mp mq mr ms b">NAMES</code>。</p><p id="f3d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者，您也可以运行:</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="e3f8" class="mx lh it ms b gy my mz l na nb">docker-compose ps</span></pre><p id="4192" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它给你类似的信息，但是特定于<em class="lf">“组合的”</em>容器。</p><p id="6557" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然您的容器在后台愉快地运行，那么如果您希望准备好服务的输出，该怎么办呢？嗯，在分离模式下，这些<code class="fe mp mq mr ms b">stdout</code>消息将被隐藏。不用担心，我们可以使用下一个命令:</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="4511" class="mx lh it ms b gy my mz l na nb">docker logs &lt;container name&gt;</span></pre><p id="149c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只需提供容器的名称，这个名称可以在<code class="fe mp mq mr ms b">docker ps</code>中找到，它从这个服务中抛出<code class="fe mp mq mr ms b">stdout</code>。</p><p id="3027" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您不想在每次服务执行某项操作时都执行该命令，该怎么办呢？好的，你可以这样做:</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="a22e" class="mx lh it ms b gy my mz l na nb">docker logs --follow &lt;container name&gt;</span></pre><p id="c78e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这非常有用，因为您可以<code class="fe mp mq mr ms b">ctrl-c</code><em class="lf">【跟随】</em>日志，您的容器将继续运行。</p><p id="8809" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好的……现在我们的容器正在后台愉快地运行，我们如何停止它。“上”的反义词是什么？你猜对了:</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="7e2e" class="mx lh it ms b gy my mz l na nb">docker-compose down</span></pre><p id="d3ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">瞧啊。</p><h1 id="79ee" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">还有什么？</h1><p id="9965" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">现在假设你有多个服务，ala微服务！？让我们来看一个稍微修改过的YAML文件:</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="45ac" class="mx lh it ms b gy my mz l na nb">version: '3'<br/>services:</span><span id="30cd" class="mx lh it ms b gy nc mz l na nb">  my-first-service:<br/>    image: node:10<br/>    volumes:<br/>      - ./my-first-service:/app:ro<br/>    working_dir: /app<br/>    command: npm run start<br/>    env_file: my-first-service/.docker-env<br/>    ports:<br/>      - "3000:8080"</span><span id="af67" class="mx lh it ms b gy nc mz l na nb">  my-second-service:<br/>    image: node:10<br/>    volumes:<br/>      - ./my-first-service:/app:ro<br/>    working_dir: /app<br/>    command: npm run start<br/>    environment:<br/>      - SOME_ENV=some-value <br/>    ports:<br/>      - "3001:8080"</span></pre><p id="f5c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们在这里引入了两个新概念:</p><p id="1cf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，当然我们可以有多种服务，这也是Docker Compose的亮点所在。注意，这两个服务公开了不同的端口，但是在内部使用相同的<code class="fe mp mq mr ms b">8080</code>端口。因此，划分或更好:集装箱！</p><p id="07cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其次，这两个服务现在都在利用环境变量。在这里，您可以看到实现它们的两种不同方式。一个允许您指定一个文件的位置来解析多个环境变量，而另一个允许您从一个<code class="fe mp mq mr ms b">ENV</code>中指定一个。</p><h1 id="e534" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="a5c4" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">我希望这篇文章对你有所帮助，并提供一些我在整天敲键盘时也能得到的好处。</p><p id="246e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哦，对了，最后一个金块:这些服务可以继续在后台运行，而你不必每次都重启容器(也就是说，如果你的应用或服务有类似于<code class="fe mp mq mr ms b">nodemon</code>的东西，可以在代码改变时自动重启)。这允许您在模拟生产的同时，在本地环境中快速开发和故障排除。</p><p id="4e54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽情享受吧！</p></div></div>    
</body>
</html>