<html>
<head>
<title>JavaScript Rubik’s Cube Scrambler Part 2: An Improved Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript魔方加密器第2部分:改进的算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-rubiks-cube-scrambler-part-2-an-improved-algorithm-e279c3731c99?source=collection_archive---------10-----------------------#2020-04-04">https://levelup.gitconnected.com/javascript-rubiks-cube-scrambler-part-2-an-improved-algorithm-e279c3731c99?source=collection_archive---------10-----------------------#2020-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a3ddc366eb38a6587bcd0a65555d039e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J8SdgWAa9tY_Kz_WBuUYrA.jpeg"/></div></div></figure><h1 id="0bee" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="7fc2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这是我前几天写的关于用JavaScript打乱魔方的后续文章。如果你还没有看过这篇文章，请务必在这里查看<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/using-javascript-to-scramble-a-rubiks-cube-306f52908f18">然后再回到这篇文章。在这篇文章中，我将改进JavaScript扰码器。要做到这一点，我们将不得不不幸地重写大部分代码，但基本设计保持不变。我们开始吧！</a></p><h1 id="100c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是争夺</h1><p id="4c87" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你应该已经知道什么是魔方争夺(假设你读了第一篇文章)，但是，这里有一个快速复习以防万一。一次争夺是在已解决的立方体上进行的20次移动的序列。这20步棋是从以下一组棋中随机挑选出来的:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5a05" class="me jz iq ma b gy mf mg l mh mi">F, R, U, B, L, D, F2, R2, U2, B2, L2, D2, F', R', U', B', L', D'</span></pre><p id="011e" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">以下是一些加扰示例:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="419e" class="me jz iq ma b gy mf mg l mh mi">B2 R F' L2 R B L2 F' D' L2 F L2 R' U B D' F D' U2 R' <br/>B' D U2 F' L U' R2 L' D B D' R2 B' F' R2 B2 D2 R B D2 <br/>L' R2 U2 F U' B' D2 B D B' F2 U R2 F2 U' L2 B2 R2 L U'</span></pre><h1 id="3230" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题是</h1><p id="b5fc" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">上一篇文章的问题是，我们的编码算法没有考虑到两个相同的移动相邻的可能性。例如，我们可能会得到如下所示的扰码:</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="efe9" class="me jz iq ma b gy mf mg l mh mi">B2 R F' L2 R B L2 F' L' L2 F L2 R' U B D' F D' U2 R' <br/>B' D U2 F' L U' R2 R2 D B D' R2 B' F' R2 B2 D2 R B D2 <br/>L' R2 U2 F U' B' D2 B D B' F2 U R2 D D L2 B2 R2 L U'</span></pre><p id="59b3" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">起初，这些加扰可能看起来不像一个问题，但是如果你仔细看，你会看到第一个加扰有一个L '和一个L2直接相邻。最后一次争夺有两个相邻的D步。这毫无意义。以最后一次争夺为例。就是两个D步相邻的那个。这和说D2是一样的。本质上，现在是19步，而不是20步。这是一个问题，特别是当我们在争夺中有3或4个这样的移动时</p><p id="c726" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">此外，R后面跟着R '是没有意义的，因为它们只是相互抵消！我们所做的只是移动立方体两次到达同一个点。当这种情况在一次争夺中多次发生时，我们的争夺可能是15步或更少，而不是20步！</p><h1 id="dcb6" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">修复</h1><p id="f6fb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这似乎是一个简单的解决办法，但实际上并不那么容易。很难检查两个相邻的移动是否属于同一类型。我们需要考虑用不同于上次的方式来解决这个问题。让我们再来看看每一次争夺的选项。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="4f5e" class="me jz iq ma b gy mf mg l mh mi">F, R, U, B, L, D, F2, R2, U2, B2, L2, D2, F', R', U', B', L', D'</span></pre><p id="0fa9" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们可以看到字母有6个不同的移动。有F，R，U，B，L和d。此外，每一个都有3个不同的移动。一次顺时针移动(F)、两次移动(F2)和一次逆时针移动(F’)。这些组成了我们的18个可能的移动(6 x 3 = 18)。</p><p id="91d1" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们可以用数字来表示混乱。我们将把F赋给0，B赋给1，依此类推。然后在最后，我们可以把字母替换回来，并且可以确定没有相同的字母会彼此相邻。</p><h1 id="51dc" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">用JavaScript编写解决方案</h1><p id="9d30" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们现在可以利用这些知识来解决这个问题。让我们从给6种可能性中的每一种赋予一个数字0到6开始，并将它们存储在一个数组中。我们称这个数组为numOptions。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="7981" class="me jz iq ma b gy mf mg l mh mi">var numOptions = [0,1,2,3,4,5]</span></pre><p id="2cc6" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">现在，我们可以将这些数字随机添加到另一个名为scramble的数组中，直到数组中有20个随机字母。记住，一个魔方的争夺是20步。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="daf1" class="me jz iq ma b gy mf mg l mh mi">var scramble = [] // initialize to empty<br/><br/>    for (var i = 0; i &lt; 20; i++ ) {<br/>        scramble.push(numOptions[getRandomInt(6)])<br/>    }<br/><br/>    // random int code from last tutorial<br/>    function getRandomInt(max) {<br/>        // returns up to max - 1<br/>        return Math.floor(Math.random() * Math.floor(max))<br/>    }</span></pre><p id="c46d" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">现在，我们有一个从0到5的20个随机数的数组！现在，你们中的一些人在想，我们仍然有和上次一样的问题。如果那是你，你绝对是对的。我们仍然有两个3相邻或者两个1相邻的可能性。但是，由于我们使用的是数字(而不是字母)，所以遍历数组并检查这一点非常容易。我们现在可以编写代码来生成一个由20个数字组成的数组，遍历并检查是否有相同的数字相邻，如果是，则再次生成数组。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="5e67" class="me jz iq ma b gy mf mg l mh mi">var bad = true<br/><br/>    while (bad) {<br/>        scramble = []<br/>        for (var i = 0; i &lt; length; i++) {<br/>            scramble.push(numOptions[getRandomInt(6)])<br/>        }<br/>        // check if moves directly next to each other are the same letter<br/>        for (var i = 0; i &lt; length - 1; i++) {<br/>            if (scramble[i] == scramble[i + 1]) {<br/>                bad = true<br/>                break<br/>            } else {<br/>                bad = false<br/>            }<br/>        }<br/>    }</span></pre><p id="92c3" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">简单解释一下上面的代码:我们声明一个布尔值bad，并将其设置为true。我们已经看过的下一段代码。然后，我们通过循环数组来检查加扰。它将索引0处的值与索引1处的值进行比较。如果它们不相等，它继续前进，并以同样的方式检查数组的其余部分。如果在任何一点上两个数相等，它就中断，重新产生加扰，并再次检查。</p><h1 id="7536" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">添加字母</h1><p id="6c43" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最后一步是用字母代替数字。为此，我们将声明一个包含所有可能选项的数组，然后编写一个嵌套在for循环中的switch语句，用正确的字母替换每个数字。</p><p id="6bc1" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">《出埃及记》如果数字是3，我们将放置a、B、B2或B’(当然是随机的)。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="53c7" class="me jz iq ma b gy mf mg l mh mi">var options = ["F", "F2", "F'", "R", "R2", "R'", "U", "U2", "U'", "B", "B2", "B'", "L", "L2", "L'", "D", "D2", "D'"]<br/>var move<br/><br/>for (var i = 0; i &lt; 20; i++) {<br/>        switch (scramble[i]) {<br/>            case 0:<br/>                move = options[getRandomInt(3)] // 0,1,2<br/>                scrambleMoves.push(move)<br/>                break<br/>            case 1:<br/>                move = options[getRandomIntBetween(3, 6)] // 3,4,5<br/>                scrambleMoves.push(move)<br/>                break<br/>            case 2:<br/>                move = options[getRandomIntBetween(6, 9)] // 6,7,8<br/>                scrambleMoves.push(move)<br/>                break<br/>            case 3:<br/>                move = options[getRandomIntBetween(9, 12)] // 9,10,11<br/>                scrambleMoves.push(move)<br/>                break<br/>            case 4:<br/>                move = options[getRandomIntBetween(12, 15)] // 12,13,14<br/>                scrambleMoves.push(move)<br/>                break<br/>            case 5:<br/>                move = options[getRandomIntBetween(15, 18)] // 15,16,17<br/>                scrambleMoves.push(move)<br/>                break<br/>        }<br/>    }<br/>    <br/>function getRandomIntBetween(min, max) { // return a number from min to max - 1. Ex. 3, 9 returns 3 - 8<br/>    return Math.floor(Math.random() * (max - min) + min)<br/>}</span></pre><p id="f176" class="pw-post-body-paragraph kw kx iq ky b kz mj lb lc ld mk lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">你会注意到我们有另一个函数，它可以得到两个数字之间的一个随机数，叫做getRandomIntBetween。我添加这个是因为我们需要能够得到2个数字之间的一个随机数，而我们当前的randNum函数只允许我们得到一个从0到指定数字的随机数。</p><h1 id="85b1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="e09e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">看了我是怎么解决这个问题的，能不能更好的解决？我很想看看是否有更好的解决方案！如果你想试试，请在评论中告诉我。你可以在我的<a class="ae lu" href="https://github.com/bjcarlson42/blog-post-code/blob/master/Rubik's%20Cube%20JavaScript%20Scrambler/part_two.js" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> GitHub </strong> </a>上获得本教程的代码。</p></div></div>    
</body>
</html>