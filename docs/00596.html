<html>
<head>
<title>Getting Started with GraphQL: It’s pretty easy!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL入门:非常简单！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-started-with-graphql-its-pretty-easy-3ea803426298?source=collection_archive---------0-----------------------#2019-05-24">https://levelup.gitconnected.com/getting-started-with-graphql-its-pretty-easy-3ea803426298?source=collection_archive---------0-----------------------#2019-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="fcea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">许多公司已经转而使用GraphQL来构建他们的API。有一个很好的理由——这是一种关于我们如何获取数据的革命性思维方式。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ab9972a4af2a4cd884209558574363ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzuJnF3vENKW9BEPTBp65Q.png"/></div></div></figure><h1 id="b734" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">GraphQL的起源&amp;为什么使用它</h1><p id="b3b6" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">GraphQL来自脸书。在内部，脸书正在寻找一种方法，让他们的新闻订阅在移动设备上更加可靠。</p><p id="d451" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用传统的REST API结构，newsfeed对多个API端点进行多次调用，以获得所需的所有数据。在这一过程中，API调用还会溢出新闻提要不需要的额外数据。此外，在接收时，前端工程师仍然必须解析数据以找到他们想要的字段。</p><p id="a720" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">脸书的工程师想知道，“如果我们能编写一种查询语言，这样我们就能在一个API请求中指定我们需要的所有信息，那会怎么样？”</p><p id="48f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GraphQL就是这种努力的结果。它映射数据库中对象之间的关系——创建一个<a class="ae md" href="https://medium.com/@BennettGarner/what-the-graph-a-beginners-simple-intro-to-graphs-in-computer-science-3808d542a0e5" rel="noopener">图</a>。然后他们设计了一种查询语言来遍历关系图。因此，命名为GraphQL。</p><p id="296e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着查询语言的加入，GraphQL APIs现在可以在单个端点接受所有传入的请求。然后，它们获取并返回您请求的数据，并且只返回您请求的数据。不再过度蚀刻你不会使用的信息。</p><h1 id="e2be" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">一个规范，而不是一个实现</h1><p id="a0c1" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">至关重要的是，脸书决定开源GraphQL作为一种规范。</p><p id="5dc0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着它可以用任何编程语言来实现。只要实现以指定的方式解析查询、模式等，它就能与任何其他GraphQL应用程序配合得很好。</p><p id="cf63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，现在每种主要编程语言中都有几十种GraphQL的实现。</p><p id="5fe3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将使用用JavaScript编写的GraphQL的参考实现，但是相同的基本原则适用于任何语言。</p><p id="aa80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以查看GraphQL实现的完整<a class="ae md" href="https://graphql.github.io/code/" rel="noopener ugc nofollow" target="_blank">列表</a>来找到您最喜欢的语言。</p><h1 id="1032" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">基础建筑</h1><p id="30de" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">开发一个正常工作的GraphQL API需要两个组件:服务器和客户机。</p><ol class=""><li id="5d2b" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">服务器处理传入的查询，解析这些查询，使用定义的模式获取数据，并返回通常是JSON格式的响应。</li><li id="02e4" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">客户端使您的应用程序能够与服务器通信。虽然您可以向GraphQL端点发送一个普通的POST请求，但是如果您使用GraphQL客户端来帮助发送查询，那么您将获得更强大的功能。</li></ol><p id="1939" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构建一个GraphQL API可能比<a class="ae md" href="https://medium.com/@BennettGarner/build-your-first-rest-api-with-django-rest-framework-e394e39a482c" rel="noopener">构建一个REST API </a>更加密集。然而，在复杂或高性能应用程序中，速度和可用性方面的优势可能会弥补这一点。</p><h1 id="5e15" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">GraphQL是什么样子的</h1><p id="8627" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们的API的目标是发送一个GraphQL查询并得到一个响应。所以，让我们来看看那会是什么样子。</p><p id="97d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">记住，GraphQL是它自己的语言。这种语言不难学，而且在很大程度上，编写查询非常直观。</p><p id="d912" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们有一个包含航班和乘客信息的数据库。</p><p id="a177" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在GraphQL中，我们可能会像这样查询航班:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="17fd" class="mx lb it mt b gy my mz l na nb">{<br/>  flight(id: "1234") {<br/>    origin<br/>    destination<br/>  }<br/>}</span></pre><p id="ae16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是GraphQL的说法，“告诉我1234航班的始发地和目的地”</p><p id="0cbc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为回应，我们将收到:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="82d8" class="mx lb it mt b gy my mz l na nb">{<br/>  "data": {<br/>    "flight": {<br/>      "origin": "DFW",<br/>      "destination": "MKE"<br/>    }<br/>  }<br/>}</span></pre><p id="48a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:</p><ul class=""><li id="20b5" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn nc mk ml mm bi translated">我们得到的正是我们所要求的——不多也不少。</li><li id="884b" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn nc mk ml mm bi translated">我们还会收到与我们发送的原始查询格式完全相同的响应。</li></ul><p id="7701" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这些是GraphQL API的标志。这是GraphQL如此快速和强大的原因。</p><p id="a7cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，这不是我们能做的全部。假设我们想获得航班上的乘客信息:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="0b4d" class="mx lb it mt b gy my mz l na nb">{<br/>  flight(id: "1234") {<br/>    origin<br/>    destination<br/>    passengers {<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="6859" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，GraphQL将遍历该航班及其乘客之间的关系图。我们会得到一份乘客名单作为回报:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="8c5a" class="mx lb it mt b gy my mz l na nb">{<br/>  "data": {<br/>    "flight": {<br/>      "origin": "DFW",<br/>      "destination": "MKE",<br/>      "passengers": [<br/>        {<br/>          "name": "Luke Skywalker"<br/>        },<br/>        {<br/>          "name": "Han Solo"<br/>        },<br/>        {<br/>          "name": "R2-D2"<br/>        }<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="1946" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">酷，现在我们可以通过一个API调用立即看到这个航班上的所有乘客。</p><p id="be07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么韩、路克和在国内飞行是一个更大的问题，但我听说密尔沃基这个时候很美。</p><p id="5a72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为GraphQL将数据解释为图形，所以我们也可以从另一个方向遍历它。</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="a39e" class="mx lb it mt b gy my mz l na nb">{<br/>  person(name: "Luke Skywalker") {<br/>    passport_number<br/>    flights {<br/>      id<br/>      date<br/>      origin<br/>      destination<br/>   }<br/>}</span></pre><p id="9f46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以看到卢克预订了哪些航班:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="486e" class="mx lb it mt b gy my mz l na nb">{<br/>  "data": {<br/>    "person": {<br/>      "passport_number": 78120935,<br/>      "flights": [<br/>        {<br/>          "id": "1234",<br/>          "date": "2019-05-24",<br/>          "origin": "DFW",<br/>          "destination": "MKE"<br/>        },<br/>        {<br/>          "id": "2621",<br/>          "date": "2019-07-05",<br/>          "origin": "MKE",<br/>          "destination": "DFW"<br/>        }<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="e6b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">哇，他要在密尔沃基呆一个多月！我想知道他在那里做什么？</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="76ad" class="la lb it bd lc ld nk lf lg lh nl lj lk ll nm ln lo lp nn lr ls lt no lv lw lx bi translated">喜欢你目前读到的吗？</h1><p id="a838" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我免费与我的电子邮件列表分享我最好的内容。</p><p id="610d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae md" href="https://sunny-architect-5371.ck.page/0a60026a5d" rel="noopener ugc nofollow" target="_blank">加入我的电子邮件系列中的其他500名开发人员。</a></p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="ff6f" class="la lb it bd lc ld nk lf lg lh nl lj lk ll nm ln lo lp nn lr ls lt no lv lw lx bi translated">待办事项列表</h1><p id="013a" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">那么，我们需要什么来创建一个GraphQL API呢？</p><ol class=""><li id="369d" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">选择一个框架来实现您的GraphQL服务器。我们将使用快递。</li><li id="50d7" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">定义模式，以便GraphQL知道如何路由传入的查询</li><li id="23bc" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">创建解析器函数来处理查询并告诉GraphQL返回什么</li><li id="4555" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">构建一个端点</li><li id="630c" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">编写获取数据的客户端查询</li></ol><p id="ea9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，您可以使用GraphQL查询来增强客户端应用程序。本教程不会涉及在前端使用GraphQL的所有不同方式，但它可以很好地与所有现代前端框架集成。</p><p id="ea58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最终，GraphQL的大多数用途将涉及与数据库的对话。在本教程中，我们不会讨论添加一个数据库到Express并允许GraphQL查询和更新该数据库。这是一个完全不同的教程的主题。</p><h1 id="c090" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.实现服务器</h1><p id="a62f" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">首先，我们需要为我们的API打下基础。</p><p id="576c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从现在开始，你需要安装<a class="ae md" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> nodejs和NPM</a>来跟随本教程。</p><p id="6626" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们构建一个准系统Express服务器。首先初始化npm:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="5bff" class="mx lb it mt b gy my mz l na nb">$ npm init</span><span id="f178" class="mx lb it mt b gy np mz l na nb">This utility will walk you through creating a package.json file.<br/>It only covers the most common items, and tries to guess sensible defaults.</span><span id="f942" class="mx lb it mt b gy np mz l na nb">See `npm help json` for definitive documentation on these fields<br/>and exactly what they do.</span><span id="280a" class="mx lb it mt b gy np mz l na nb">Use `npm install &lt;pkg&gt;` afterwards to install a package and<br/>save it as a dependency in the package.json file.</span><span id="b69d" class="mx lb it mt b gy np mz l na nb">Press ^C at any time to quit.<br/>package name: (graphql-medium) <br/>version: (1.0.0) <br/>description: <br/>entry point: (index.js) <br/>test command: <br/>git repository: <br/>keywords: <br/>author: <br/>license: (ISC) <br/>About to write to /home/bennett/Repos/graphql-medium/package.json:</span><span id="03f8" class="mx lb it mt b gy np mz l na nb">{<br/>  "name": "graphql-medium",<br/>  "version": "1.0.0",<br/>  "description": "",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "author": "",<br/>  "license": "ISC"<br/>}</span><span id="fc30" class="mx lb it mt b gy np mz l na nb">Is this OK? (yes)</span></pre><p id="5a5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只需按回车键跳过初始化过程。如果你愿意，你可以回头编辑你的<code class="fe nq nr ns mt b">package.json</code>。</p><p id="77ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们安装Express、GraphQL和Express-GraphQL库:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="f8c9" class="mx lb it mt b gy my mz l na nb">$ npm install express express-graphql graphql</span><span id="911a" class="mx lb it mt b gy np mz l na nb">npm notice created a lockfile as package-lock.json. You should commit this file.<br/>npm WARN graphql-medium@1.0.0 No description<br/>npm WARN graphql-medium@1.0.0 No repository field.</span><span id="d224" class="mx lb it mt b gy np mz l na nb">+ express-graphql@0.8.0<br/>+ graphql@14.3.1<br/>+ express@4.17.0<br/>added 53 packages from 38 contributors and audited 151 packages in 6.169s<br/>found 0 vulnerabilities</span></pre><p id="b7e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们将创建一个名为<code class="fe nq nr ns mt b">index.js</code>的新文件，并在那里创建一个新的准系统Express服务器:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="8a47" class="mx lb it mt b gy my mz l na nb">// index.js</span><span id="1d12" class="mx lb it mt b gy np mz l na nb">const express = require('express');<br/>const app = express();</span><span id="af5a" class="mx lb it mt b gy np mz l na nb">app.get('/', function(req, res) {<br/>  res.send('Express is working!')<br/>});</span><span id="93c1" class="mx lb it mt b gy np mz l na nb">app.listen(4000, function() {<br/>  console.log('Listening on port 4000')<br/>});</span></pre><p id="694d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">试试跑<code class="fe nq nr ns mt b">node index.js</code>。您应该会看到一条消息“在端口4000上监听”，如果您访问<a class="ae md" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:4000/ </a>，那么您会看到“Express正在工作！”</p><h1 id="bac5" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.在GraphQL中添加并定义模式</h1><p id="a3d9" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们已经安装了GraphQL npm包。现在，让我们使用它。</p><p id="68cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我们需要导入必要的构件:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="5203" class="mx lb it mt b gy my mz l na nb">const graphqlHTTP = require('express-graphql');<br/>const { buildSchema } = require('graphql');</span></pre><p id="375d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将使用这些构建模块。</p><p id="a55f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从定义GraphQL API的模式开始。传入的查询应该是什么样的？</p><p id="7ed5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们定义一个hello world模式来让事情正常运行:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="8ce6" class="mx lb it mt b gy my mz l na nb">let schema = buildSchema(`<br/>  type Query {<br/>    hello: String<br/>  }<br/>`);</span></pre><p id="9be3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个简单的模式让GraphQL知道，当有人发送一个“hello”查询时，我们最终将返回一个字符串。</p><p id="c97d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意那些小反勾号(`)。这些表明我们正在使用JavaScript模板文字。基本上，我们使用这些反勾号来告诉JavaScript我们将使用不同的语言GraphQL查询语言。</p><h1 id="8710" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.解决查询</h1><p id="8bea" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">因此，当有人提交对<code class="fe nq nr ns mt b">hello</code>的查询时，我们知道我们最终将返回一个字符串。这是在我们的模式中定义的。</p><p id="3204" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们需要告诉GraphQL它应该返回什么字符串。</p><p id="763f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GraphQL中“解析器”的工作是根据传入的查询计算出返回什么数据。</p><p id="73c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，解析器很简单。我们将返回字符串“Hello world”</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="1bef" class="mx lb it mt b gy my mz l na nb">return 'Hello world!';</span></pre><p id="c1ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，我们需要将这个返回语句封装在一个函数中，只要有人查询hello:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="395c" class="mx lb it mt b gy my mz l na nb">function() {<br/>  return 'Hello world!';<br/>}</span></pre><p id="64ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，<code class="fe nq nr ns mt b">hello</code>可能不是我们实现的唯一查询类型。将来，我们可能还会包括其他功能的“端点”。因此，我们应该确保我们刚刚创建的这个函数被映射到hello，并与我们的API的所有其他解析器一起保存在一个对象中。</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="7859" class="mx lb it mt b gy my mz l na nb">let root = {<br/>  hello: function() {<br/>    return 'Hello world!';<br/>  },<br/>}</span></pre><p id="6179" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">按照惯例，调用保存所有解析器的对象<code class="fe nq nr ns mt b">root</code>，但是你可以随意调用它。</p><h1 id="e06f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">4.设置端点</h1><p id="9943" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">敏锐的读者会注意到我们在步骤2中导入了<code class="fe nq nr ns mt b">graphqlHTTP</code>,但是我们还没有使用它。现在是时候了。</p><p id="6b39" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们已经为GraphQL服务器做好了一切准备。我们只需要通过URL端点使它可用。</p><p id="f539" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Express中，我们将创建一个新的路由来提供GraphQL api:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="1508" class="mx lb it mt b gy my mz l na nb">app.use('/graphql', graphqlHTTP({<br/>  schema: schema,<br/>  rootValue: root,<br/>  graphiql: true,<br/>}));</span></pre><p id="ce59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Schema和root指向我们在步骤2和3中定义的变量。</p><p id="4511" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">GraphQL是一个有用的可视化工具，与graph QL一起安装。正如我们马上会看到的，测试你的API是如何工作的很容易。</p><p id="a6e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们GraphQL服务器的源代码的最终<a class="ae md" href="https://github.com/bennett39/graphql-medium/blob/master/index.js" rel="noopener ugc nofollow" target="_blank">状态。</a></p><h1 id="b7a5" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">5.运行它并编写一个查询</h1><p id="fd12" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们已经准备好测试它了！</p><ol class=""><li id="15c1" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">用<code class="fe nq nr ns mt b">node index.js</code>启动应用程序</li><li id="8a75" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">去<a class="ae md" href="http://localhost:4000/graphql?" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graph QL</a></li></ol><p id="5a83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该会看到graphiql界面:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/18d76010c0cd84dcb017076380d18326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ljwn539rzdaPvucdt733Bg.png"/></div></div></figure><p id="4701" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以使用这个接口来确保我们的API正在工作！</p><p id="1b7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们写一个查询。这个会非常简单。我们总是将GraphQL查询放在花括号中。然后，我们指定要查询的模式对象，后面跟着我们要获取的任何属性。</p><p id="13c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，到目前为止，我们的API中只有一个要获取的东西:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="5f1c" class="mx lb it mt b gy my mz l na nb">{<br/>  hello<br/>}</span></pre><p id="b5e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您单击提交按钮，您将看到:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="c328" class="mx lb it mt b gy my mz l na nb">{<br/>  "data": {<br/>    "hello": "Hello world!"<br/>  }<br/>}</span></pre><p id="2600" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">起作用了！</p><h1 id="3318" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">添加更多端点</h1><p id="e8ec" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">向API添加端点就像在模式中定义新字段，然后向<code class="fe nq nr ns mt b">root</code>添加解析函数一样简单</p><p id="64ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的查询也可以逐渐变得更加复杂。我推荐这篇来自官方文档的关于<a class="ae md" href="https://graphql.org/graphql-js/passing-arguments/" rel="noopener ugc nofollow" target="_blank">构建掷骰子API </a>的指南作为你的下一步。</p><h1 id="0202" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">GraphQL，FTW</h1><p id="dbd6" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">GraphQL非常棒，并且在采用方面增长迅速。在未来几年，它有可能成为API的一项无处不在的技术。</p><p id="7643" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望本指南很好地介绍了如何以及为什么可以在项目中使用GraphQL。</p><p id="ee8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的评论中分享你的想法吧！我看了每一个回复。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="d609" class="la lb it bd lc ld nk lf lg lh nl lj lk ll nm ln lo lp nn lr ls lt no lv lw lx bi translated">关于班尼特</h1><p id="dc8d" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我是一名用Python和JavaScript构建东西的web开发人员。</p><p id="cc33" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">想要我关于web开发和成为更好的程序员的最佳内容吗？</p><p id="2f1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在邮件列表中分享我最喜欢的建议——没有垃圾邮件，没有推销内容，只有有用的内容。</p><p id="b4b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae md" href="https://sunny-architect-5371.ck.page/0a60026a5d" rel="noopener ugc nofollow" target="_blank">加入我的电子邮件系列中目前的500名其他开发人员。</a></p></div></div>    
</body>
</html>