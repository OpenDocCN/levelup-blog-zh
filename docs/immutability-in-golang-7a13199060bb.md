# Golang 中的不变性

> 原文：<https://levelup.gitconnected.com/immutability-in-golang-7a13199060bb>

## 如何利用不变性来增强 Golang 应用程序的可读性和稳定性

![](img/811202a0c84a8de0f434127024960b45.png)

费伦茨·阿尔马西在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

不变性的概念非常简单。对象(或结构)一旦创建，就永远不能更改。这是不可改变的。虽然这个概念看起来很简单，但使用它或从中受益并不总是很容易。

正如计算机科学(和生活)中的大多数事情一样，有多种方法可以达到相同的结果，就不变性而言，没有什么不同。你必须将它视为你工具箱中的另一个工具，并针对你面临的每个问题使用最有效的工具。不变性的一个非常强的用例是当您使用并发编程时。Golang 在设计时就考虑到了并发性，所以在 go 中使用并发性是很常见的。如果你想了解 Golang 的并发模型，请查看[这篇文章](/goroutines-and-channels-concurrent-programming-in-go-9f9f8495c34d)。

以下是如何在 Golang 中使用一些不变性概念，使您的代码更具可读性和稳定性，而不管您使用的是哪种范式。

## 仅导出结构的函数，不导出其字段

这与封装的原理相同。创建具有非导出字段的结构，只导出您想要操作的函数。这种技术非常适合接口，因为您只对那些结构的行为感兴趣。这项技术的另一个好处是向结构中添加和导出一个创建函数(或构造函数)。这样可以确保该结构的状态总是有效的。拥有一个始终有效的状态可以使你的代码更加可靠，因为你不必为你想用这个结构做的每个操作处理无效的状态。这里有一个非常基本的例子:

在这个包中，我们定义了`Amount`类型，带有非导出字段`value`，构造函数`NewAmount`，以及`Amount`类型的`GetValue`方法。一旦由`NewAmount`函数创建了`Amount`结构，就没有办法改变它。因此，从包的外部来看，它是不可变的(在 go 1 中没有办法创建不可变的结构，尽管在 go 2 中有[建议改变这一点](https://github.com/golang/go/issues/27975))。此外，没有类型为`Amount`的变量处于无效状态(在本例中为负数量),因为创建它们的唯一方法已经验证了这一点。下面是我们如何从另一个包中调用它:

```
a, err := amounts.NewAmount(10)
*// handle err* log.Println(a.GetValue())
```

## 在函数中使用复制值而不是指针

最基本的概念是，在对象(或结构)被创建后，永远不要改变它。然而，我们经常使用实体状态非常重要的应用程序。然而，实体的状态和实体在程序中的内部表示是不同的事情。在使用不变性时，我们仍然可以让一个实体有多个状态。这意味着创建的结构不会改变，但是它的副本会改变。这并不意味着我们需要手动实现复制结构的每个字段的函数。

相反，我们可以依赖 Golang 在调用函数时复制值的固有行为。对于每个改变实体状态的操作，我们可以创建一个函数，它接收结构体作为一个参数(或者作为一个函数接收器),并在执行工作后返回修改后的版本。这是一项非常强大的技术，因为您可以在副本上随意更改，而无需更改函数调用方作为参数传递的变量。这意味着没有副作用，以及可预测的行为。如果同一个结构被传递给并发函数，每个函数都会收到一个它的副本，而不是一个指向它的指针。

当处理切片时，您可以看到这种行为被应用到`[append](https://golang.org/pkg/builtin/#append)`函数中。您也可以对您的函数使用完全相同的技术。

回到我们的例子，让我们实现`Account`类型，它包含一个`Amount`类型的`balance`字段。同样，让我们添加改变`Account`实体状态的方法`Deposit`和`Withdraw`。

如果你检查我们创建的方法，他们会觉得我们实际上是在改变用作函数接收器的`Account`结构的状态。因为我们没有使用指针，所以情况并非如此，因为该结构的副本被作为这些函数的接收器传递。我们正在改变仅在函数范围内有效的副本，然后返回它。如果我们从另一个包中调用它，这里有一个例子:

```
a, err := amounts.NewAmount(10)
acc := accounts.NewEmptyAccount()
acc2 := acc.Deposit(a)
log.Println(acc.GetBalance())
log.Println(acc2.GetBalance())
```

命令行上的结果如下所示:

```
2020/06/03 22:22:40 {0}
2020/06/03 22:22:40 {10}
```

正如你所看到的，虽然在变量`acc`上调用了`Deposit`方法，但它实际上并没有改变那个变量上的任何东西，而是返回了一个新的`Account`副本(分配给了`acc2`)和改变后的字段。

与复制值相比，使用指针有它的好处，特别是如果你的结构非常大，这可能会导致复制时的性能问题，但你应该总是问自己这样做是否值得，永远不要试图过早地优化代码。尤其是当您正在处理并发时。你可能会陷入一些糟糕的境地。

## 较少依赖全局或外部状态

不变性不仅适用于结构，也适用于函数。如果我们用相同的参数执行相同的函数两次，我们应该会收到相同的结果，对吗？如果我们依赖于外部状态或全局变量，这可能不总是正确的。最好避免这样。有几种方法可以实现这一点。我们称对于给定的输入总是返回相同输出的函数为纯函数。

如果你有一个共享的全局变量用于函数内部，考虑将该值作为参数传递，而不是直接在函数内部使用。这使得您的功能更加可预测，也更容易测试。整个代码的可读性也会变得更容易，因为其他人会知道值可能会影响函数的行为，因为它是一个参数，毕竟这就是参数的用途。这里有一个虚拟的例子:

函数`sum`使用一个全局变量作为其计算的一部分。这在函数签名中并不清楚。更好的方法是将 rand 变量作为参数传递。所以这个函数看起来像这样:

```
func sum(a, b, rand **int**) **int** {
   return a + b + rand
}
```

更加可预测，而且它不会影响函数范围之外的变量，以防我们需要给它赋值或者类似的事情。

另一种方法是将这些外部状态变量封装到一个不可变的结构中，并将该结构用作函数接收器。在函数签名是接口的一部分的情况下，这是非常重要的。这是我在本文的[中提到的一种非常常见的技术(重点是依赖注入，但它也同样适用于这种场景)。](/dependency-injection-in-go-using-receiver-functions-d76b7e541ecd)

## 最后的想法

如果您了解如何实现不变性，那么使用不变性可以提高代码的可读性和稳定性。就像生活中的一切一样，在每个场合使用它都有利弊。当在代码中实现它时，您必须考虑权衡。实现本文中描述的技术需要大量的样板代码，这可能非常繁琐并且容易出错。但是，如果我们在并发函数中共享状态时不使用不变性，事情会变得更糟，例如，这会导致复杂的逻辑和竞争条件。此外，实现不变性并不是免费的，因为通常您必须优先选择副本而不是指针，这在某些情况下会导致严重的性能问题。

[](https://skilled.dev) [## 编写面试问题

### 一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…

技术开发](https://skilled.dev)