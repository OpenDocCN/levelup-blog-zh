<html>
<head>
<title>Build a GraphQL Server with Node.js and Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js和Express构建一个GraphQL服务器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-graphql-server-with-node-js-express-ba1edf7b3b72?source=collection_archive---------2-----------------------#2019-11-09">https://levelup.gitconnected.com/build-a-graphql-server-with-node-js-express-ba1edf7b3b72?source=collection_archive---------2-----------------------#2019-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/24cf2dc7f72b546b69e4355de40807ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRk2ncJW1YSINjb0TgX6vg.jpeg"/></div></div></figure><h1 id="0b7e" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">GraphQL快速介绍</h1><p id="aeca" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">GraphQL为你的API提供了数据及其类型的完整定义(或描述)。它使客户能够准确地要求他们需要的，而不是更多，使API更容易随着时间的推移而发展，并支持强大的开发工具。</p><p id="8bdb" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">GraphQL是为了解决RESTful路由中出现的问题而构建的。RESTful路由指的是操作托管在服务器上的数据的传统模式或通用规则。这些约定包括<a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" rel="noopener ugc nofollow" target="_blank"> HTTP请求方法或动词</a>(如POST、PUT、GET、DELETE等)的类型以及请求被发送到的URL，以便执行CRUD(创建、读取、更新和删除)操作。</p><p id="d672" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">具有高度关系数据的RESTful路由开始变得相当具有挑战性。</p><ul class=""><li id="f77b" class="md me it lb b lc ly lg lz lk mf lo mg ls mh lw mi mj mk ml bi translated">当我们有大量嵌套关系时，决定URL模式就变得很困难</li><li id="a03f" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">当获取大量嵌套的数据时，我们很容易遇到这样的情况:我们发出太多的HTTP请求来获取我们需要的数据</li><li id="15e2" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">我们很容易过度获取数据</li></ul><p id="1550" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">GraphQL希望修复RESTful路由和过度服务数据方面的一些大的不一致。</p><p id="a1d1" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">GraphQL认为我们的应用程序中的所有数据看起来像一个图表。但是，它需要了解不同的数据片段、数据片段之间的关系以及如何访问这些数据。我们使用一个模式来实现这一点。</p><h2 id="2b95" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">(计划或理论的)纲要</h2><p id="ba9f" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">该模式告诉GraphQL正在处理的数据类型以及数据片段之间的关系。所以模式负责告诉GraphQL应用程序的数据、这些数据对象的属性<br/>以及这些对象如何相互关联。</p><p id="2b2e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">它是任何GraphQL服务器实现的核心，描述了连接到它的客户机可用的功能。</p><p id="50a8" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">模式中的核心构建块是<em class="nd">类型。类型</em>在模式中提供了广泛的功能，包括:</p><ul class=""><li id="8000" class="md me it lb b lc ly lg lz lk mf lo mg ls mh lw mi mj mk ml bi translated">创建类型之间的关系(例如，玩家和团队之间)</li><li id="317c" class="md me it lb b lc mm lg mn lk mo lo mp ls mq lw mi mj mk ml bi translated">定义客户端可以执行哪些数据获取(查询)和数据操作(变异)操作</li></ul><p id="a010" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">简而言之，模式通知GraphQL我们的数据是什么样的，以及可以对这些数据执行的操作😃。</p><h2 id="9e4e" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">强类型</h2><p id="f11e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">GraphQL是一种强类型语言。以下是一些常用的数据类型:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="0b41" class="mr kc it nj b gy nn no l np nq">| TYPE     | DESCRIPTION          <br/>|----------|-------------------------------------------------------|<br/>| Scalar   | Stores a single value                                                                   |<br/>| Object   | Shows what kind of object can be fetched                                                |<br/>| Query    | Entry point type to other specific types                                                |<br/>| Mutation | Entry point for data manipulation                                                       |<br/>| Enum     | Useful in a situation where you need the user to pick from a prescribed list of options |</span></pre><p id="b3a8" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">对象类型是模式中最常用的类型，代表一组字段。对象类型中的每个字段都映射到另一个类型，从而允许嵌套类型。换句话说，一个对象类型由多个标量类型或对象类型组成。定义对象类型的语法如下:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="3e16" class="mr kc it nj b gy nn no l np nq">type Person {<br/>   _id:ID<br/>   firstName: String<br/>   lastName: String<br/>   age: Int<br/>   height: Float<br/>}</span></pre><h2 id="b5a9" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">根查询</h2><p id="a8aa" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">图是一种数据结构，包含节点和每个节点之间的关系(也称为边)。记住这一点，GraphQL需要一个被称为根查询的数据，它本质上是数据图表的入口点。换句话说，根查询允许我们进入我们的数据结构。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="3d13" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在我们已经介绍了GraphQL背后的一些重要理论，让我们继续构建一个GraphQL服务器的基本工作示例。</p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">游戏时间到了！</figcaption></figure><h1 id="09f2" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">带有Node.js &amp; Express的GraphQL</h1><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/34aae13d1a4a6190396a49c4f6f33c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*YnTantyqOey7VzlevWtaeQ.png"/></div></figure><p id="307c" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">假设您已经安装了<a class="ae lx" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>，您可以继续创建一个新的项目文件夹，并使用以下命令初始化一个新的<em class="nd"> package.json </em>文件:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="3f3c" class="mr kc it nj b gy nn no l np nq">$ npm init -y</span></pre><p id="43e8" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">然后，您可以更新<em class="nd"> package.json </em>文件中的一些值，比如名称、作者和描述。</p><p id="0a7b" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在让我们安装一些graphql服务器需要的依赖项。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="dd26" class="mr kc it nj b gy nn no l np nq">$ npm i --save graphql graphql-tag express express-graphql body-parser axios graphql-playground-middleware-express</span><span id="5317" class="mr kc it nj b gy of no l np nq">$ npm i -D nodemon</span></pre><p id="b765" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">express-graphql库充当graphql和Express (HTTP服务器)之间的兼容层。Json服务器将被用来创建假的REST APIs。</p><h2 id="2173" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">假冒的原料药</h2><p id="07a5" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">继续在根目录下创建一个<strong class="lb iu"> db.json </strong>文件，json-server将使用它来为我们创建API。然后你可以把这个内容<a class="ae lx" href="https://gist.github.com/LukeMwila/8aaa944ae017a9c2fe7a626da8b1ecd2" rel="noopener ugc nofollow" target="_blank">添加到这个新添加的文件中。</a></p><p id="86cf" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">然后，您可以使用以下脚本更新package.json文件，以测试您的假API:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="1a2d" class="mr kc it nj b gy nn no l np nq">"json:server": "json-server --watch db.json --port 3004"</span></pre><p id="9c97" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">完成后，您可以运行以下命令:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="e5bd" class="mr kc it nj b gy nn no l np nq">$ npm run json:server</span></pre><p id="ac23" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">然后，您应该会看到以下内容:</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/41554a9ebf7dd89ffce3c04741b321bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LkPmEEcJOos-leycW_ptvw.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">CLI结果</figcaption></figure><p id="037c" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">请随意使用API客户端测试API，如<a class="ae lx" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>或直接在您的浏览器中测试。</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/c8a7589b13ccf2207ebb553f83cd8200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQSFpixwI_nQkdEoNIgQgg.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">邮递员结果</figcaption></figure><h2 id="5071" class="mr kc it bd kd ms mt dn kh mu mv dp kl lk mw mx kp lo my mz kt ls na nb kx nc bi translated">GraphQL实现</h2><p id="86d7" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在根目录下创建一个<strong class="lb iu"> src </strong>文件夹。然后，您可以设置以下文件和文件夹:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="d47a" class="mr kc it nj b gy nn no l np nq">├── schema/<br/>├── app.js<br/>└── server.js</span></pre><p id="3af6" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">让我们从<strong class="lb iu"> app.js </strong>和<strong class="lb iu"> server.js </strong>文件开始，用GraphQL层初始化我们的HTTP服务器。</p><p id="e9e6" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu"> app.js </strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="e331" class="mr kc it nj b gy nn no l np nq">const express = require('express');<br/>const expressGraphQL = require('express-graphql');<br/>const bodyParser = require('body-parser');<br/>const expressPlayground = require('graphql-playground-middleware-express').default;</span><span id="d556" class="mr kc it nj b gy of no l np nq">const schema = require('./schema');<br/>const app = express();</span><span id="6c3c" class="mr kc it nj b gy of no l np nq">app.get('/playground', expressPlayground({ endpoint: '/v1/graphql' }));</span><span id="a8ae" class="mr kc it nj b gy of no l np nq">app.use(bodyParser.json());<br/>app.use(<br/>  '/v1/graphql',<br/>  expressGraphQL({<br/>   schema,<br/>   graphiql: true<br/>  })<br/>);</span><span id="ce54" class="mr kc it nj b gy of no l np nq">module.exports = app;</span></pre><p id="5609" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu"> server.js </strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="0a60" class="mr kc it nj b gy nn no l np nq">const http = require('http');<br/>const app = require('./app');</span><span id="1fa7" class="mr kc it nj b gy of no l np nq">const port = process.env.PORT || 3003;<br/>const server = http.createServer(app);</span><span id="663d" class="mr kc it nj b gy of no l np nq">server.listen(port, () =&gt; console.log(`Server running on ${port}`));</span></pre><p id="2ff6" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在让我们继续定义我们的GraphQL模式。在模式文件夹中，设置以下文件和文件夹结构:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="5de9" class="mr kc it nj b gy nn no l np nq">├── types/<br/>├── index.js<br/>└── root_query.js</span></pre><p id="5185" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">让我们在<strong class="lb iu"> index.js </strong>文件中创建我们的模式。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="e0e7" class="mr kc it nj b gy nn no l np nq">const graphql = require('graphql');<br/>const { GraphQLSchema } = graphql;</span><span id="180d" class="mr kc it nj b gy of no l np nq">// Root query<br/>const query = require('./root_query');</span><span id="c179" class="mr kc it nj b gy of no l np nq">module.exports = new GraphQLSchema({<br/>  query<br/>});</span></pre><p id="fa2d" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">正如您所看到的，我们正在这个文件中导入我们的根查询，但是还没有用必要的内容填充我们的<strong class="lb iu"> root_query.js </strong>文件，所以现在让我们开始吧。</p><p id="87db" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu"> root_query.js </strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="7109" class="mr kc it nj b gy nn no l np nq">const graphql = require('graphql');<br/>const axios = require('axios');</span><span id="4b95" class="mr kc it nj b gy of no l np nq">const { GraphQLObjectType, GraphQLList } = graphql;</span><span id="57d2" class="mr kc it nj b gy of no l np nq">/** Data Types */<br/>const player = require('./types/player');<br/>const team = require('./types/team');</span><span id="987a" class="mr kc it nj b gy of no l np nq">const rootQuery = new GraphQLObjectType({<br/>  name: 'RootQueryType',<br/>  fields: () =&gt; ({<br/>    players: {<br/>      type: new GraphQLList(player),<br/>      resolve(parentValue, args) {<br/>       return axios<br/>         .get(`http://localhost:3004/players`)<br/>         .then(response =&gt; response.data);<br/>      }<br/>    },<br/>    teams: {<br/>      type: new GraphQLList(team),<br/>      resolve(parentValue, args) {<br/>       return axios<br/>         .get(`http://localhost:3004/teams`)<br/>         .then(response =&gt; response.data);<br/>       }<br/>    }<br/>  })<br/>});</span><span id="be76" class="mr kc it nj b gy of no l np nq">module.exports = rootQuery;</span></pre><p id="1a02" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">现在我们已经添加了根查询，让我们创建可以在图中访问的对象的两种数据类型。两个文件(<strong class="lb iu"> player.js </strong>和<strong class="lb iu"> team.js </strong>)都将被添加到<strong class="lb iu"> types </strong>文件夹中。</p><p id="9090" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu"> player.js </strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="a3fa" class="mr kc it nj b gy nn no l np nq">/**<br/> * Player type<br/> */<br/>const graphql = require('graphql');<br/>const axios = require('axios');<br/>/** Import object types from GraphQL */<br/>const { GraphQLObjectType, GraphQLString } = graphql;</span><span id="5401" class="mr kc it nj b gy of no l np nq">const Player = new GraphQLObjectType({<br/>  name: 'Player',<br/>  fields: () =&gt; ({<br/>    id: { type: GraphQLString },<br/>    firstName: { type: GraphQLString },<br/>    lastName: { type: GraphQLString },<br/>    team: {<br/>      type: require('./team'),<br/>      resolve(parentValue, args) {<br/>        return axios<br/>          .get(`<a class="ae lx" href="http://localhost:3004/team/${parentValue.id}`" rel="noopener ugc nofollow" target="_blank">http://localhost:3004/team/${parentValue.id}`</a>)<br/>          .then(response =&gt; response.data);<br/>      }<br/>    }<br/>  })<br/>});</span><span id="96c3" class="mr kc it nj b gy of no l np nq">module.exports = Player;</span></pre><p id="d461" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">您可能想知道resolve函数是干什么的。简而言之，它通过为GraphQL查询生成响应来充当查询处理程序。parentValue是我们正在处理的当前数据对象的实例。GraphQL模式中的每个解析器函数都接受四个位置参数，如下所示:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="2468" class="mr kc it nj b gy nn no l np nq">fieldName:(parentValue, args, context, info) =&gt; { result }</span></pre><p id="965f" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><strong class="lb iu"> team.js </strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="e678" class="mr kc it nj b gy nn no l np nq">/**<br/> * Team type<br/> */<br/>const graphql = require('graphql');<br/>const axios = require('axios');<br/>/** Import object types from GraphQL */<br/>const { GraphQLObjectType, GraphQLString, GraphQLList } = graphql;</span><span id="94d9" class="mr kc it nj b gy of no l np nq">const Team = new GraphQLObjectType({<br/>  name: 'Team',<br/>  fields: () =&gt; ({<br/>    id: { type: GraphQLString },<br/>    name: { type: GraphQLString },<br/>    players: {<br/>      type: new GraphQLList(require('./player')),<br/>      resolve(parentValue, args) {<br/>        return axios<br/>          .get(`<a class="ae lx" href="http://localhost:3004/teams/${parentValue.id}/players`" rel="noopener ugc nofollow" target="_blank">http://localhost:3004/teams/${parentValue.id}/players`</a>)<br/>          .then(response =&gt; response.data);<br/>      }<br/>    }<br/>  })<br/>});</span><span id="deed" class="mr kc it nj b gy of no l np nq">module.exports = Team;</span></pre><p id="96f5" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">完成后，您可以将以下脚本添加到您的<em class="nd"> package.json </em>文件中:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="3474" class="mr kc it nj b gy nn no l np nq">"start": "nodemon src/server.js"</span></pre><p id="1c7b" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">然后运行<code class="fe oi oj ok nj b">npm start</code>。</p><p id="7be7" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">一旦您的应用程序启动并运行，请在浏览器中打开两个选项卡并转到以下链接:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="efa8" class="mr kc it nj b gy nn no l np nq">GraphiQL: <a class="ae lx" href="http://localhost:3003/v1/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:3003/v1/graphql</a><br/>GraphQL Playground: <a class="ae lx" href="http://localhost:3003/playground" rel="noopener ugc nofollow" target="_blank">http://localhost:3003/playground</a></span></pre><p id="0995" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated"><a class="ae lx" href="https://github.com/graphql/graphiql" rel="noopener ugc nofollow" target="_blank"><em class="nd">graph QL</em></a>和<a class="ae lx" href="https://github.com/prisma-labs/graphql-playground" rel="noopener ugc nofollow" target="_blank"><em class="nd">graph QL Playground</em></a>都是浏览器内IDE，为您的GraphQL API提供了出色的开发工作流程，并为您的模式提供了文档。</p><p id="a601" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">在两个IDE中，测试以下查询:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="5169" class="mr kc it nj b gy nn no l np nq"># Write your query or mutation here<br/>query {<br/>  teams {<br/>    name<br/>    players {<br/>      id<br/>      firstName<br/>      lastName<br/>    }<br/>  }<br/>}</span></pre><p id="716e" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">预期的结果应该如下:</p><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/6c651ff55a7bb40423416645646961b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5jdzWM-Mm5-SKWLBcVn5Og.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">图形QL</figcaption></figure><figure class="ne nf ng nh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/7b8e4983bf8fd42346b524e6704f4266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H0vuGjv_tW6x36HXrjzI0Q.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">GraphQL游乐场</figcaption></figure></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="8dd2" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">女士们先生们，这是一个带有Node.js和Express的GraphQL服务器的基本实现。这个例子的源代码可以在这里找到<a class="ae lx" href="https://github.com/LukeMwila/basic-graphql-server" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4abf" class="pw-post-body-paragraph kz la it lb b lc ly le lf lg lz li lj lk ma lm ln lo mb lq lr ls mc lu lv lw im bi translated">如果你喜欢这篇文章，请在这里给我买杯咖啡<a class="ae lx" href="https://www.buymeacoffee.com/lukemwila" rel="noopener ugc nofollow" target="_blank">☕️😃。</a></p><figure class="ne nf ng nh gt ju"><div class="bz fp l di"><div class="on nz l"/></div></figure></div></div>    
</body>
</html>