# 戈朗的二分搜索法树速成班

> 原文：<https://levelup.gitconnected.com/a-crash-course-on-binary-search-trees-in-golang-41251020477d>

## 学习递归，提高您的计算机科学编程基础！

![](img/65466238bd6b12ec49fe99f3e311ccd2.png)

从 [Unsplash](https://images.unsplash.com/photo-1502082553048-f009c37129b9?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1650&q=80)

B 二进制搜索树(BST)是计算机科学的一个众所周知的棘手但有用的子领域。利用 BST 要求程序员熟悉递归函数和用于操作树的各种算法，比如插入或删除节点。如果你能学会流利地使用二分搜索法树，你就已经开始着手处理计算机科学中的许多其他基础知识了，因为我个人认为 BST 是一些最难开始学习的数据结构(但也是一些最有价值的!)).

在我们开始之前，**到底什么是二叉查找树**？嗯，基于树的数据结构简单地由信息节点组成，这些节点以类似树的方式连接到其他节点。二叉树有一个根节点，可能有左右两个子节点，每个子节点都有自己的子节点。基于两个孩子的树表示一个二叉树，你也可以有一个基于三个孩子的树，这是一个三叉树，等等。在树的最底部没有孩子的节点被表示为叶节点。这里有一个二叉树的例子:

```
 ___1___       # a single root node
       /       \     
      4         3     # up to two children
     / \       / \
    0   9     13  14  # 0 and 14 are leaf nodes
       / \     \
      7   10    2     # so are 7, 10 and 2
```

二叉树和二叉查找树的区别是什么？BST 附带的规则是，对于树中的每个节点，保证每个左边的子节点都小于其父节点，每个右边的子节点都大于或等于其父节点。这带来了快速操作时间的额外好处，因为我们可以通过搜索左侧或右侧的子分支来快速查找要操作的节点。**这里有一个二进制*搜索*树的例子:**

```
 ______7______
          /             \
        _3_           __11__
       /   \         /      \
      1     5       9       13
     / \   / \     / \     /  \
    0   2 4   6   8   10  12  14
```

既然我们已经熟悉了 BST 的一般规则，我们就可以深入研究一些常见的操作和与之相关的方法。**本文将涵盖以下 4 种 BST 方法:**

*   验证 BST
*   在 BST 中搜索节点
*   将节点插入 BST
*   删除 BST 中的节点

***注:*** *本文假设了 Go 中的基本编程技巧以及时间和空间复杂度的大 O 符号。你还应该知道* [*如何给 struct*](https://www.geeksforgeeks.org/how-to-add-a-method-to-struct-type-in-golang/) *添加方法。*

我们来编码吧！

# 验证 BST

为了在 BST 上执行操作，我们首先需要一个有效的 BST。在这个例子中，我们将遍历一个算法，以确保我们有一个有效的树。我们如何做到这一点？我们需要验证对于每一个节点，它的所有左边的子节点都小于它的值，而所有右边的子节点都大于或等于它的值。

我们可以使用**递归**和一些简单的检查来实现。对于第一个条件，我们需要确保对于我们当前所在的任何节点，该节点的值都在其在树中的配置范围内。**让我们快速看几个例子。**

```
 ______7______           # the root can be any value
     /             \
   _3_           __11__       # 11 must be > 7
  /   \         /      \
 1     5       9       13     # 5 must be < 7, but > 3
/ \   / \     / \     /  \
0   2 4   6   8   10  12  14  # 9 must be > 7, but < 11
```

> 要注意的模式是，如果我们去一个节点的右边的子节点，这个子节点必须大于它的父节点。如果我们去一个节点的左边的子节点，这个子节点必须总是小于它的父节点值。无论我们沿着树往下走多远，这两条规则都是正确的。因此，为了获得每个节点的值的有效范围，我们可以传递父节点的值来更新所有后续子节点各自的最小值或最大值。

让我们把它写成代码。假设所有节点都有三个属性`Value`、`Left`和`Right`，其中 left 和 right 代表其子值，因此可以是`nil`。因此，在我们检查节点的`Left`或`Right`子节点是否是`nil`之后，我们可以递归地检查子节点是否不是有效的 BST 子树。

> 递归调用栈一开始可能很难理解，但是从基本情况开始是最容易的。在下面的代码中，我们的基本情况是检查当前节点(表示为树)的值是否大于我们当前的最小值，并且小于或等于我们当前的最大值。如果不满足这个条件，我们在第 7 行返回 false。然后我们在第 9 行和第 12 行的左边和右边的子树上递归地继续这个逻辑。

基本上，如果我们引用`tree.Left`，我们必须更新我们的最大值。如果我们下降`tree.Right`，我们必须更新我们的最小值。如果这看起来有点模糊，试着用几个例子来解决它。

```
 5   # 5 can be any value
 / \
6   6 # tree.Left.validateBst() cannot be > 5, return false
```

因为我们在函数的最后返回`true`，如果我们没有违反每个节点的最小值和最大值的条件，我们将只返回`true`。

> 但是等等，为什么我们需要两个功能而不是一个？当涉及到递归代码逻辑时，除了使用正确的起始值调用递归函数的独立函数之外，通常还需要一个递归函数来调用自身。

在这个例子中，我们有一个独立的函数`ValidateBst()`，它用正确的起始值调用递归函数`validateBst()`。为什么起始值是`MinInt32`和`MaxInt32`？因为我们的第一个根节点的值可以是任何值，但是一旦我们向下移动一个左边或右边的子节点，父节点的值就会分别变成这些子节点的最大值或最小值。我已经尽力解释了这段代码的逻辑，但是没有什么比自己做一些小例子更好的了。:)

# 在 BST 中搜索节点

唷，如果你成功地验证了这棵树，**给自己一个鼓励，感谢你对学习的坚持！下一个问题应该更容易理解。在 BST 中搜索节点只需要根据我们要搜索的值是小于、等于还是大于当前节点的值来遍历节点。**

我们只需要检查这三个条件。在下面的代码中，我们有一个递归函数`Contains()`，它接受一个整数`value`，并返回一个关于树是否包含`value`的布尔值。我们首先检查`value`是否等于当前节点的`Value`。如果是，我们就完成了，可以返回`true`。

否则，我们必须检查值是否小于或大于当前节点的`Value`。如果少，我们先检查一下左边的孩子是不是`nil`。如果`Left`子节点是`nil`，那么`tree`不可能包含`value`，我们返回 false。如果有一个`Left`子节点，我们将递归调用`Contains()`函数——检查我们是否遇到一个`value`等于`tree.Value`的节点。当值大于当前节点的`Value`时，同样的逻辑也适用，我们必须递归调用子节点`Right`上的`Contains()`。

***注:*** *有没有发现我们这里只需要一个递归函数？这是因为我们从来不需要更新被传递的值，我们对每个递归调用都使用相同的整数值。*

# 将节点插入 BST

既然我们知道了 BST 中的搜索是如何工作的，那么插入一个节点就很容易了。插入与搜索有几乎相同的逻辑——有一点需要注意的是，如果没有子节点`nil`，我们就不能再遍历到当前节点的`Left`或`Right`,然后我们用输入`value`创建并插入一个新节点。

# 删除 BST 中的节点

好了，大的来了。删除二叉查找树中的节点不是一件简单的事情。这是因为我们必须处理多种情况，比如要删除的节点没有子节点、只有一个子节点或者有两个子节点。前两种情况没有那么糟糕，但是在删除一个有两个子节点的节点时，为了保持 BST 的有效性，您必须小心。

我们如何维护有效 BST 的一个关键方面是将当前节点的父节点传递给我们的递归调用。因为我们正在更新我们的递归参数，我们将需要独立方法`Remove()`来调用递归方法`remove()`。

现在，我们的前几个条件只是导航到我们想要删除的节点。与搜索和插入相同，我们检查`value`是否小于或大于当前`tree.Value`。如果两个条件都不成立，那就意味着我们找到了要删除的目标节点。当一个节点有一个父节点时，我们将有两个单独的方法来处理一般情况，以及当我们试图删除 BST 的根节点时的边缘情况。

对于删除具有父节点的节点的一般情况，我们有前面提到的四种情况。如果我们没有孩子，那么我们的生活会很轻松！我们只需检查当前节点是否等于`parent`的`Right`子节点或`parent`的`Left`子节点。然后我们简单地设置`parent.Right`或`parent.Left`等于`nil`。

如果我们只有一个孩子，事情也不会复杂多少。我们通常会发现要删除的节点是父节点的`Left`还是`Right`子节点。然后，我们将要删除的节点的相应子节点分配给父节点。这听起来很奇怪，所以让我们看一个例子，其中要删除的节点是 5。这通过设置下面第 20 行的`parent.Right = tree.Left`来完成。

```
 _3_                   _3_   # if 4 had any children, we would
   /   \                 /   \  # keep them in tact to maintain the
  1     5       ==>     1     4 # BST properties.
 / \   /               / \   
0   2 4               0   2 
```

常规节点的最后一种情况是当要删除的节点有两个子节点时的**。问题是当我们删除那个节点时，我们必须保持 BST 的有效性和完整性。但是我们用哪个子节点替换现在被删除的节点呢？该节点实际上是被删除节点的右子树中的最小节点，因为它是唯一维护 BST 属性的节点(自己检查一下！).**

我们可以通过将待删除节点的值设置为等于该节点右边子树中的最小值来解决这个问题(第 24 行)。然后，我们将删除右边子树中的最小值，因为它是重复的，我们不再希望它出现在我们的树中。更多例子！让我们删除下面树中值为 11 的节点。看看用 12 替换 11 是如何维护我们的树的，以及为什么我们必须删除 13 下重复的 12 值？

```
 ______7______                       ______7______
     /             \                     /             \
   _3_           __11__                _3_           __12__
  /   \         /      \      ==>     /   \         /      \
 1     5       9       13            1     5       9       13
/ \   / \     / \     /  \          / \   / \     / \     /  \
0  2 4   6   8   10  12  14        0   2 4   6   8   10  xx  14
```

寻找最小值的方法只是递归地在树中尽可能向左看:

还有最后一种情况，那就是我们需要删除 BST 本身的根。这种情况遵循与常规节点相同的逻辑，只是我们没有父节点，所以我们必须手动定义新的关系和树的新根。我们成功了！

现在你知道了！**这是二叉查找树最常见的四种表演方法。**还有更多的操作，如各种类型的遍历、反转二叉树等等。如果你喜欢这篇文章或者想要一个你感兴趣的话题的教程，我鼓励你在下面留下评论！感谢您的阅读。:)