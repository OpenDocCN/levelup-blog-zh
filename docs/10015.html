<html>
<head>
<title>Decoding nested JSON the right way in Elixir</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Elixir中正确解码嵌套的JSON</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-hidden-secrets-of-json-decoding-in-elixir-ae08cbf817f7?source=collection_archive---------12-----------------------#2021-10-14">https://levelup.gitconnected.com/the-hidden-secrets-of-json-decoding-in-elixir-ae08cbf817f7?source=collection_archive---------12-----------------------#2021-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/057d8b56b0d566bfefa2bfb20f35ecbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HHrhOy7RsqVz59SR5eIOPQ.jpeg"/></div></div></figure><h1 id="e655" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="3799" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当我为Holodex API 开发一个新的<a class="ae lu" href="https://github.com/DaniruKun/ex-holodex" rel="noopener ugc nofollow" target="_blank"> HTTP客户端时，我选择了由以下部分组成的典型堆栈:</a></p><ul class=""><li id="a456" class="lv lw iq ky b kz lx ld ly lh lz ll ma lp mb lt mc md me mf bi translated"><a class="ae lu" href="https://github.com/edgurgel/httpoison" rel="noopener ugc nofollow" target="_blank">httposin</a>，由<a class="ae lu" href="https://github.com/benoitc/hackney" rel="noopener ugc nofollow" target="_blank"> Hackney </a>提供支持的流行药剂HTTP客户端</li><li id="ff74" class="lv lw iq ky b kz mg ld mh lh mi ll mj lp mk lt mc md me mf bi translated">Jason ，快速JSON编码器/解码器库</li></ul><p id="bff4" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">虽然<code class="fe mo mp mq mr b">Jason</code>仍然在<a class="ae lu" href="https://gist.github.com/michalmuskala/4d64a5a7696ca84ac7c169a0206640d5" rel="noopener ugc nofollow" target="_blank">基准</a>中占据较高的位置，但它缺少某些功能，我将在下面演示。</p><h1 id="7f34" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">问题是</h1><p id="d154" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当您使用HTTP JSON API资源时，您会收到一个JSON字符串，然后使用您选择的JSON解码器对其进行解码:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="897f" class="na jz iq mr b gy nb nc l nd ne">Jason.decode!(~s({"name":"Dan","age":42,"nationality":"Latvian"}))<br/>%{"name" =&gt; "Dan", "age" =&gt; 42, "nationality" =&gt; "Latvian"}</span></pre><p id="fbf1" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">然而，你最终得到的是一张普通的仙丹图，它有很多缺点:</p><ul class=""><li id="fdaa" class="lv lw iq ky b kz lx ld ly lh lz ll ma lp mb lt mc md me mf bi translated">默认情况下，键是<strong class="ky ir">二进制</strong>，而不是<strong class="ky ir">原子</strong></li><li id="ff86" class="lv lw iq ky b kz mg ld mh lh mi ll mj lp mk lt mc md me mf bi translated">你不能使用<code class="fe mo mp mq mr b">map.key_name</code>语法，这不符合习惯，也不够自信</li><li id="4946" class="lv lw iq ky b kz mg ld mh lh mi ll mj lp mk lt mc md me mf bi translated">很难推断出系统域中数据的形状</li></ul><h1 id="e7db" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">解决方法</h1><h1 id="3ff2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">解决方案A:在HTTP客户机中预处理响应体</h1><p id="2696" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">像<code class="fe mo mp mq mr b">HTTPoison</code>这样的HTTP客户端库显示的一个常见模式是简单地<a class="ae lu" href="https://github.com/edgurgel/httpoison#wrapping-httpoisonbase" rel="noopener ugc nofollow" target="_blank">定义一组您期望接收的字段，然后迭代映射键并手动将它们转换成原子</a>。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="c0ad" class="na jz iq mr b gy nb nc l nd ne">defmodule Holobot.Holofans.Client do<br/>  @moduledoc """<br/>  Holofans API HTTP client implementation, based on HTTPoison.<br/>  """<br/>  use HTTPoison.Base<br/><br/>  @expected_fields ~w(count total channels videos query comments)<br/>  @api_version "v1"<br/><br/>  @impl true<br/>  def process_request_url(url) do<br/>    Application.fetch_env!(:holobot, :holofans_api) &lt;&gt; "#{@api_version}" &lt;&gt; url<br/>  end<br/><br/>  @impl true<br/>  def process_response_body(body) do<br/>    body<br/>    |&gt; Poison.decode!()<br/>    |&gt; Map.take(@expected_fields)<br/>    |&gt; Enum.map(fn {k, v} -&gt; {String.to_atom(k), v} end)<br/>  end<br/>end</span></pre><p id="4cd8" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">然而，这种方法存在许多问题:</p><ul class=""><li id="fde6" class="lv lw iq ky b kz lx ld ly lh lz ll ma lp mb lt mc md me mf bi translated">我们现在有了一个关于我们将收到的数据的<strong class="ky ir">形状</strong>的<strong class="ky ir">过于具体的假设</strong>(如果我们期望一个对象数组作为根实体呢？)</li><li id="1aae" class="lv lw iq ky b kz mg ld mh lh mi ll mj lp mk lt mc md me mf bi translated">只有顶层的<strong class="ky ir">键</strong>被转换成<strong class="ky ir">原子</strong>，但是任何种类的<strong class="ky ir">嵌套对象</strong>都将保留为带有二进制键的映射(现在你将根据深度拥有不同的访问器语法！)</li><li id="9260" class="lv lw iq ky b kz mg ld mh lh mi ll mj lp mk lt mc md me mf bi translated"><a class="ae lu" href="https://hexdocs.pm/elixir/1.12/String.html#to_atom/1" rel="noopener ugc nofollow" target="_blank"> String.to_atom/1 </a>会使您面临溢出全局atom表<a class="ae lu" href="https://www.erlang.org/erlang-enhancement-proposals/eep-0020.html" rel="noopener ugc nofollow" target="_blank">的危险，在一个正常运行时间非常长并且处理许多请求的系统中，这可能会成为一个大问题</a></li><li id="528b" class="lv lw iq ky b kz mg ld mh lh mi ll mj lp mk lt mc md me mf bi translated">客户端回调变得<strong class="ky ir">臃肿</strong>，它应该非常小，并且只对您的请求和响应应用最小的转换。</li><li id="5b25" class="lv lw iq ky b kz mg ld mh lh mi ll mj lp mk lt mc md me mf bi translated">因为它不是一个结构，所以不能利用像<a class="ae lu" href="https://github.com/ejpcmac/typed_struct" rel="noopener ugc nofollow" target="_blank"> TypedStruct </a>这样方便的库。</li></ul><p id="02ff" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">此外，如果您确实想尝试从反序列化的数据中创建结构，您可能最终会像这样实现一个<code class="fe mo mp mq mr b">builder</code>:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="fe67" class="na jz iq mr b gy nb nc l nd ne">@spec build_record(map) :: t()<br/>  def build_record(video) do<br/>    %__MODULE__{<br/>      yt_video_key: video["yt_video_key"],<br/>      title: video["title"],<br/>      status: video["status"],<br/>      live_schedule: video["live_schedule"],<br/>      live_start: video["live_start"],<br/>      live_end: video["live_end"],<br/>      live_viewers: video["live_viewers"],<br/>      channel: video["channel"]["yt_channel_id"],<br/>      is_uploaded: video["is_uploaded"],<br/>      duration_secs: video["duration_secs"],<br/>      is_captioned: video["is_captioned"]<br/>    }<br/>  end</span></pre><p id="fcba" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">当然，这很少是可行的方法，因为它会产生大量的重复。可以通过使用像<a class="ae lu" href="https://github.com/appcues/exconstructor" rel="noopener ugc nofollow" target="_blank"> ExConstructor </a>这样的库来解决这个问题，但是它仍然没有解决嵌套结构的问题。</p><h1 id="21f2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">解决方案B:使用Poison的内置对象解码功能</h1><p id="4d46" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">一位同事分享了ElixirConf最近关于我不知道的<code class="fe mo mp mq mr b">Poison</code>的一个特性的精彩演讲:将JSON字符串<strong class="ky ir">解码为您选择的结构</strong>:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="4149" class="na jz iq mr b gy nb nc l nd ne">Poison.decode!(~s({"name": "Dan", "age": 42}), as: %Person{})<br/>#=&gt; %Person{name: "Dan", age: 42}</span></pre><p id="9081" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">太好了！HTTP客户端是干净的，我们可以动态地指定数据的形状，并且结构定义模块也没有助手函数。</p><p id="2003" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">看来<code class="fe mo mp mq mr b">Poison</code>还利用<a class="ae lu" href="https://github.com/devinus/poison/blob/e5c0867aaf3c9e9cb6da424580dcd8e1a25081d0/lib/poison/parser.ex#L174" rel="noopener ugc nofollow" target="_blank"> String.to_existing_atom/1函数</a>解决了<strong class="ky ir">动态生成引擎盖下原子</strong>的问题。</p><p id="cb8b" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated"><strong class="ky ir">更新</strong>:看起来确保这种情况发生的最可靠的方法是将选项<code class="fe mo mp mq mr b">keys: :atoms!</code>也传递给<code class="fe mo mp mq mr b">Poison.decode/2</code>，例如:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="a1e3" class="na jz iq mr b gy nb nc l nd ne">Poison.decode!(~s({"name": "Dan", "age": 42}), %{as: %Person{}, keys: atoms!})</span></pre><p id="b701" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">剩下的唯一问题是<strong class="ky ir">嵌套数据</strong>。这是该特性几乎没有文档可言的地方，但它以如下方式工作:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="91d3" class="na jz iq mr b gy nb nc l nd ne">defmodule Holodex.Api.Videos do<br/>  alias Holodex.Api.Client<br/>  alias Holodex.Model.{Channel, Comment, Video}<br/><br/>  @list_of_videos_p [<br/>	%Video{<br/>	  channel: %Channel{},<br/>	  clips: [%Video{}],<br/>	  sources: [%Video{}],<br/>	  refers: [%Video{}],<br/>	  simulcasts: [%Video{}],<br/>	  mentions: [%Channel{}]<br/>	}<br/>  ]<br/><br/>  with url &lt;- build_videos_url(opts),<br/>		   body &lt;- Client.get!(url).body do<br/>		Poison.decode!(body, %{as: @list_of_videos_p})<br/>	  end<br/>end<br/><br/># Returns:<br/>  [<br/>	%Holodex.Model.Video{<br/>	  available_at: "2024-08-11T11:05:00.000Z",<br/>	  channel: %Holodex.Model.Channel{<br/>		banner: nil,<br/>		clip_count: nil,<br/>		description: nil,<br/>		english_name: "Planya",<br/>		id: "UCQaGj_l3dqmGWJLEbEmwgFQ",<br/>		...<br/>	  },<br/>	  id: "Sc5MRAvMm18",<br/>	  live_viewers: nil,<br/>	  mentions: nil,<br/>	  ...<br/>	},<br/>  ...<br/>  ]</span></pre><p id="2365" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">我们期望一个由<code class="fe mo mp mq mr b">Video</code>对象组成的数组，其中可能还包含一个嵌套的<code class="fe mo mp mq mr b">Channel</code>，以及嵌套在不同字段下的<code class="fe mo mp mq mr b">Video</code>和<code class="fe mo mp mq mr b">Channel</code>的数组。然后我们定义一个<strong class="ky ir">模式</strong>供解码器捕获(在本例中<code class="fe mo mp mq mr b">@list_of_videos_p</code>作为模块属性以供重用并保持函数干净)。<strong class="ky ir">模式</strong>简单地定义了数据如何映射到您选择的<strong class="ky ir">结构</strong>。接下来剩下的就是为你的结构定义<strong class="ky ir">类型规格</strong>，现在你也可以充分利用类型规格:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="77cd" class="na jz iq mr b gy nb nc l nd ne">@spec list_videos(opts()) ::<br/>          {:ok, [Video.t()]} | {:error, HTTPoison.Error.t()} | {:error, Exception.t()}<br/>  def list_videos(opts \\ %{}) do<br/>    with url &lt;- build_videos_url(opts),<br/>         {:ok, response} &lt;- Client.get(url),<br/>         {:ok, decoded} &lt;- Poison.decode(response.body, %{as: @list_of_videos_p}) do<br/>      {:ok, decoded}<br/>    end<br/>  end</span></pre><h1 id="6c8b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="bb1e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当然，这个解决方案不是免费的午餐:<code class="fe mo mp mq mr b">Poison</code>仍然比它的主要竞争对手<code class="fe mo mp mq mr b">Jason</code>慢一点。但是，在大多数解码外部数据的情况下，<code class="fe mo mp mq mr b">Poison</code>的这个主要特性比CPU时间或内存使用更有价值。</p><p id="6af1" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">还有一个和<code class="fe mo mp mq mr b">Poison.decode/2</code>一起使用关键字列表args的问题(透析器会抱怨)，我<a class="ae lu" href="https://github.com/devinus/poison/issues/199" rel="noopener ugc nofollow" target="_blank">在这里</a>提出过。我还在这里提出了关于<code class="fe mo mp mq mr b">as</code>选项使用<a class="ae lu" href="https://github.com/devinus/poison/issues/200" rel="noopener ugc nofollow" target="_blank">的文档质量差的问题，我希望也能解决这个问题。</a></p><p id="381f" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated">如果您对如何做得更好有更多建议，请随时联系</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="ec2c" class="pw-post-body-paragraph kw kx iq ky b kz lx lb lc ld ly lf lg lh ml lj lk ll mm ln lo lp mn lr ls lt ij bi translated"><em class="nm">原载于</em><a class="ae lu" href="https://danpetrov.xyz/elixir/programming/2021/10/11/decoding-nested-json-the-right-way-in-elixir.html" rel="noopener ugc nofollow" target="_blank"><em class="nm">https://danpetrov . XYZ</em></a><em class="nm">。</em></p></div></div>    
</body>
</html>