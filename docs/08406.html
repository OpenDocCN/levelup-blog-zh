<html>
<head>
<title>Complete guide to creating Node.js packages with ES6 modules that are easily usable from CJS modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ES6模块创建Node.js包的完整指南，这些模块可从CJS模块轻松使用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/complete-guide-to-creating-node-js-packages-with-es6-modules-that-are-easily-usable-from-cjs-module-db206e46fec9?source=collection_archive---------9-----------------------#2021-04-28">https://levelup.gitconnected.com/complete-guide-to-creating-node-js-packages-with-es6-modules-that-are-easily-usable-from-cjs-module-db206e46fec9?source=collection_archive---------9-----------------------#2021-04-28</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/4fbab253d13cf1e70ccee2dd3086a101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCMKmzyhFW5kgXM9dhCJAQ.jpeg"/></div></div></figure><p id="3fb9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">用ES6模块在Node.js上编写所有JavaScript代码是非常诱人的。但是这就产生了与大量现有CJS模块的互操作性问题。也就是说，很难从CJS模块使用ES6模块。Node.js使得从一个ES6模块使用CJS和ES6模块变得很容易，CJS模块可以很容易地使用CJS模块，但是CJS模块使用ES6模块是很痛苦的。与此同时，ES6模块提供了足够吸引人的好处来保证重写我们的代码以从CJS转换到ES6模块。这意味着我们需要一种策略来方便地使用CJS模块中的Node.js ES6模块。</p><p id="734a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">因为Node.js使用Chrome网络浏览器的V8 JavaScript引擎，所以它可以快速更新大多数最新的JavaScript特性。由于V8团队快速实现了新特性，Node.js可以快速采用这些特性。例如，这意味着Node.js程序员可以快速采用最新的功能，如ES6模块，即使我们可能不愿意在浏览器端的JavaScript中这样做。</p><p id="12ed" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在Node.js的开始，我们使用的是CommonJS (CJS)模块格式。在Ryan Dahl创建Node.js时，这是唯一可用的模块格式，所以这就是他所使用的。但是，ECMAScript 6为JavaScript带来了许多奇妙的改进，其中之一是一种通用的模块格式ES6模块，它可以移植到浏览器端和服务器端的JavaScript。如果没有其他原因，考虑将CJS模块重写为ES6模块的主要原因是为了从浏览器和服务器JavaScript中拥有相同的模块格式中获益。</p><p id="8392" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">但是软件工程的实用性在于Node.js上的CommonJS代码可能永远不会消失。重写工作代码的成本很高，而且不是所有的工程经理都会明白这样做的明智之处。这意味着我们必须制定出ES6和CJS模块之间兼容性的最佳实践。</p><p id="ee3c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">ES6和CJS模块之间的互操作性归结为:</p><ul class=""><li id="e7b6" class="la lb iu ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">在ES6模块中，我们使用<code class="fe lj lk ll lm b">import</code>语句来加载ES6模块和CJS模块。</li><li id="dd6d" class="la lb iu ke b kf ln kj lo kn lp kr lq kv lr kz lf lg lh li bi translated">在CJS模块中，我们使用<code class="fe lj lk ll lm b">require</code>语句来加载CJS模块。</li><li id="6ea0" class="la lb iu ke b kf ln kj lo kn lp kr lq kv lr kz lf lg lh li bi translated">在CJS模块中，我们通常不能加载ES6模块，但是<em class="ls">动态导入</em>特性给了我们可以加载ES6模块的<code class="fe lj lk ll lm b">import()</code>功能。</li></ul><p id="b192" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">你可能会想"<em class="ls">有什么问题吗？</em>“两种模块格式都可以加载另一种格式的模块。问题是<code class="fe lj lk ll lm b">import()</code>函数返回一个承诺，这使得很难遵循将模块对象赋给全局变量的正常模式。有了<code class="fe lj lk ll lm b">import</code>和<code class="fe lj lk ll lm b">require</code>语句，将模块引用赋给一个易于使用的全局变量变得非常容易。但是因为<code class="fe lj lk ll lm b">import()</code>是异步的，并且返回一个承诺，我们将使用的全局变量在一段时间内将具有值<code class="fe lj lk ll lm b">undefined</code>，这是我们的代码必须适应的。</p><p id="a32c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果这是一个<code class="fe lj lk ll lm b">require</code>语句，我们将能够立即使用该模块。这是因为<code class="fe lj lk ll lm b">require</code>是同步操作，这意味着当<code class="fe lj lk ll lm b">require</code>完成时，模块被完全加载。但是，使用<code class="fe lj lk ll lm b">import()</code>加载ES6模块是异步的。实际上，在这个例子中，这意味着<code class="fe lj lk ll lm b">es6module</code>将持有一个由<code class="fe lj lk ll lm b">import()</code>函数返回的承诺。要使用这个承诺，要么需要<code class="fe lj lk ll lm b">await</code>关键字，要么需要<code class="fe lj lk ll lm b">.then</code>块。这两个都不方便。</p><p id="8254" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">使用CJS模块中的ES6模块有两种通用策略:</p><ul class=""><li id="28ad" class="la lb iu ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">如果函数是异步的，它可以留在ES6模块中，可以使用<code class="fe lj lk ll lm b">import()</code>导入。调用该函数可以适应由<code class="fe lj lk ll lm b">import()</code>函数返回的承诺。</li><li id="775b" class="la lb iu ke b kf ln kj lo kn lp kr lq kv lr kz lf lg lh li bi translated">如果函数是异步的，实现函数的ES6模块必须重写为CJS模块，以便CJS模块可以使用<code class="fe lj lk ll lm b">require</code>。最简单的方法是使用transpiler，比如Babel，来做这件事。</li></ul><p id="264e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在本文中，我们将研究使用ES6和CJS模块的Node.js包的互操作性。特别是，我们将学习如何创建混合Node.js包，这些包使用CJS和ES6模块导出它们的API。</p><p id="fcff" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">有关一些背景信息，请参见以下文章:</p><div class="lt lu gq gs lv lw"><a href="https://techsparx.com/nodejs/esnext/dynamic-import-2.html" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fp"><div class="ly ab lz cl cj ma"><h2 class="bd iv gz z fq mb fs ft mc fv fx it bi translated">通过在Node.js中使用动态导入，我们可以在CommonJS代码中导入ES6模块，并进行更多更新</h2><div class="md l"><p class="bd b dl z fq mb fs ft mc fv fx dk translated">techsparx.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ka lw"/></div></div></a></div><div class="lt lu gq gs lv lw"><a href="https://techsparx.com/nodejs/esnext/esmodules-from-commonjs.html" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fp"><div class="ly ab lz cl cj ma"><h2 class="bd iv gz z fq mb fs ft mc fv fx it bi translated">在Node.js CommonJS模块中加载ES6模块</h2><div class="md l"><p class="bd b dl z fq mb fs ft mc fv fx dk translated">techsparx.com</p></div></div><div class="me l"><div class="mk l mg mh mi me mj ka lw"/></div></div></a></div><h1 id="2c05" class="ml mm iu bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">在CJS和ES6模块中加载模块</h1><p id="af1c" class="pw-post-body-paragraph kc kd iu ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz in bi translated">在继续之前，让我们回顾一下模块是如何在CJS和ES6代码中加载的。当Ryan Dahl创建Node.js时，CommonJS模块格式(CJS)是唯一可用的选择。因为CJS模块格式是唯一可用的选择，所以它的使用有很大的惯性。</p><p id="db1c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">对于加载另一个CJS模块的CJS模块:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="2558" class="nw mm iu lm b gz nx ny l nz oa">const fsextra = require('fs-extra'); <br/>const path = require('path'); <br/>const fs = require('fs/promises'); <br/>const apputil = require('./app-utils.js'); <br/>const myLocalModule = require('./path/myLocalModule'); <br/>const jsonData = require('./path/filename.json');</span></pre><p id="b345" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这些是使用CJS语句的几个例子。前三个加载包安装在一个<code class="fe lj lk ll lm b">node_modules</code>目录下。接下来的三个引用本地模块文件。<code class="fe lj lk ll lm b">require</code>不需要指定带有扩展名的完整文件名，因为Node.js会根据它在文件系统中找到的文件直觉地做什么。我们还可以使用<code class="fe lj lk ll lm b">require</code>加载JSON数据。</p><p id="8adb" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lj lk ll lm b">fs</code>包并不是唯一支持附属包的包。在Node.js中，访问子包需要正确的<em class="ls">需求说明符</em>，它遵循模式<em class="ls">模块名/子模块名</em>。</p><p id="40f6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">正如我们前面所说的，<code class="fe lj lk ll lm b">require</code>语句是同步的，这意味着当<code class="fe lj lk ll lm b">require</code>结束时模块被完全加载。该模块不是在后台延迟加载的，而是可以立即使用的。我们稍后会看到为什么这很重要。</p><p id="11ff" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">对于ES6模块，我们使用<code class="fe lj lk ll lm b">import</code>语句加载CJS或ES6模块:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="2674" class="nw mm iu lm b gz nx ny l nz oa">import fsextra from 'fs-extra'; <br/>import path from 'path'; <br/>import { promises as fs } from 'fs'; // alternatively: import { * as fs } from 'fs/promises'; <br/>import { unlink as fsunlink } from 'fs/promises'; <br/>import apputil from './app-utils.js'; <br/>import myES6Module from './path/myES6Module/index.mjs';</span></pre><p id="6823" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">ES6 <code class="fe lj lk ll lm b">import</code>语句有很多功能，这些例子只触及了皮毛。像CJS一样，像<code class="fe lj lk ll lm b">path</code>这样的简单模块说明符简单地加载已安装的<code class="fe lj lk ll lm b">path</code>模块。<code class="fe lj lk ll lm b">{ foo }</code>符号让您只能从指定的模块中加载特定的项目。<code class="fe lj lk ll lm b">{ foo as foobar }</code>符号允许您给它一个不同的名称。例如，我们将来自<code class="fe lj lk ll lm b">fs</code>模块的<code class="fe lj lk ll lm b">promises</code>对象命名为<code class="fe lj lk ll lm b">fs</code>，将来自<code class="fe lj lk ll lm b">fs/promises</code>模块的<code class="fe lj lk ll lm b">unlink</code>函数命名为<code class="fe lj lk ll lm b">fsunlink</code>。</p><p id="3cec" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">模块说明符实际上是一个URL。Node.js支持<code class="fe lj lk ll lm b">file:</code> URL，出于安全原因不支持<code class="fe lj lk ll lm b">http:</code> URL。如果你需要的话，你可以安装一个HTTP URL处理器。为了方便起见，Node.js透明地将文件名转换成URL。</p><p id="f410" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">要加载像JSON这样的数据文件，需要使用一个<code class="fe lj lk ll lm b">data:</code> URL。我们不会在这里讨论这个。</p><p id="1f4b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">回到CJS模块，我们说过加载一个ES6模块需要<code class="fe lj lk ll lm b">import()</code>函数。为此:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="98af" class="nw mm iu lm b gz nx ny l nz oa">import('./path/myES6Module/index.mjs') <br/>.then(myES6Module =&gt; {<br/>     // use the module<br/>})<br/>.catch(err =&gt; { console.error(err); });  </span><span id="7784" class="nw mm iu lm b gz ob ny l nz oa">// Alternative <br/>(async () =&gt; {<br/>   const myES6Module = await import('./path/myES6Module/index.mjs');<br/>   // use the module<br/>})()<br/>.catch(err =&gt; console.error(err));</span><span id="6c47" class="nw mm iu lm b gz ob ny l nz oa">// Alternative <br/>let myES6Module;<br/>(async () =&gt; {<br/>     myES6Module = await import('./path/myES6Module/index.mjs'); <br/>})().catch(err =&gt; console.error(err));</span></pre><p id="10ff" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">因为加载ES6模块是异步的，所以<code class="fe lj lk ll lm b">import()</code>函数也是异步的。这意味着<code class="fe lj lk ll lm b">import()</code>函数返回一个承诺。您可以使用<code class="fe lj lk ll lm b">.then</code> / <code class="fe lj lk ll lm b">.catch</code>块来处理承诺，或者在<code class="fe lj lk ll lm b">async</code>函数中使用<code class="fe lj lk ll lm b">await</code>关键字。在这两种情况下，模块引用都是在函数内部传递的，因此很难创建一个可靠地保存引用的全局变量。全局变量<code class="fe lj lk ll lm b">myES6Module</code>要么有值<code class="fe lj lk ll lm b">undefined</code>，要么是模块引用。任何使用该全局变量的代码都必须检测它当前拥有的值，并适应它不包含模块引用的时间。</p><p id="7f8f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">前面提到了另一种模式:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="b02e" class="nw mm iu lm b gz nx ny l nz oa">const myES6Module = import('./path/myES6Module/index.mjs');</span></pre><p id="8167" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">变量<code class="fe lj lk ll lm b">myES6Module</code>将包含一个承诺，最终该承诺将转变为<em class="ls">已解决</em>或<em class="ls">已拒绝</em>状态。但是留给您的问题是等待模块完成加载，并在模块加载失败时处理任何错误。这意味着使用<code class="fe lj lk ll lm b">.then</code> / <code class="fe lj lk ll lm b">.catch</code>块，或者在<code class="fe lj lk ll lm b">async</code>函数中使用<code class="fe lj lk ll lm b">await</code>关键字。</p><p id="0688" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在我们已经设置了上下文，让我们探索解决方案。我们将首先学习如何适应模块引用，这些引用可以是未定义的、未解决的承诺或已解决的承诺。</p><h1 id="b103" class="ml mm iu bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">使用ES6模块编写的混合Node.js包，其中CJS模块包含公共API</h1><p id="36d2" class="pw-post-body-paragraph kc kd iu ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz in bi translated">有多种方法可以让CJS模块轻松使用ES6包。在这一节中，我们将从围绕ES6模块实现CJS <em class="ls">包装模块</em>开始。也就是说，我们将使用ES6模块编写我们的代码，但为了从CJS模块使用，我们将提供一个瘦CJS模块，其函数只需调用ES6模块中的相应函数。加载ES6模块需要使用<code class="fe lj lk ll lm b">import()</code>功能。</p><p id="f100" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了给我们提供一个讨论问题的坚实基础，让我们考虑一下从<code class="fe lj lk ll lm b">node_modules</code>目录中随机选取的一个包:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="07dc" class="nw mm iu lm b gz nx ny l nz oa">$ tree node_modules/micromatch/<br/>node_modules/micromatch/<br/>├── CHANGELOG.md<br/>├── LICENSE<br/>├── README.md<br/>├── index.js<br/>└── lib<br/>     ├── cache.js<br/>     ├── compilers.js<br/>     ├── parsers.js<br/>     └── utils.js</span></pre><p id="4371" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lj lk ll lm b">lib</code>中的文件就是我所说的<em class="ls">内部模块</em>。<code class="fe lj lk ll lm b">index.js</code>中的代码是公共API。它的代码使用内部模块中的函数，但是这些模块不应该被包外的其他代码使用。</p><p id="d35c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">第一步是将<code class="fe lj lk ll lm b">lib/**.js</code>模块重构为ES6模块。这不仅仅需要重命名文件，还需要将任何对<code class="fe lj lk ll lm b">module.exports</code>对象的赋值改为等价的<code class="fe lj lk ll lm b">export</code>语句。在ES6模块中，数据和函数通过<code class="fe lj lk ll lm b">export</code>语句导出。</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="69fb" class="nw mm iu lm b gz nx ny l nz oa">$ tree node_modules/micromatch/ <br/>node_modules/micromatch/ <br/>├── CHANGELOG.md <br/>├── LICENSE <br/>├── README.md <br/>├── index.js <br/>└── lib<br/>     ├── cache.mjs<br/>     ├── compilers.mjs<br/>     ├── parsers.mjs<br/>     └── utils.mjs</span></pre><p id="7f95" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这就给我们留下了作为CJS模块的<code class="fe lj lk ll lm b">index.js</code>，我们需要使其可被ES6和CJS模块使用，并且内部模块是ES6格式的。由于我们在<code class="fe lj lk ll lm b">index.js</code>中什么都没做，模块将会失败。</p><p id="e8f9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe lj lk ll lm b">index.js</code>中，我们看到这段代码:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="3cff" class="nw mm iu lm b gz nx ny l nz oa">var compilers = require('./lib/compilers'); <br/>var parsers = require('./lib/parsers'); <br/>var cache = require('./lib/cache'); <br/>var utils = require('./lib/utils');</span></pre><p id="de3d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这就是我们对CJS模块加载内部CJS模块的期望。第一步是这种转换:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="1314" class="nw mm iu lm b gz nx ny l nz oa">const compilers = import('./lib/compilers.mjs'); <br/>const parsers = import('./lib/parsers.mjs'); <br/>const cache = import('./lib/cache.mjs'); <br/>const utils = import('./lib/utils.mjs');</span></pre><p id="9806" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">使用<code class="fe lj lk ll lm b">require</code>语句，我们可以省去文件扩展名，Node.js凭直觉知道该做什么。对于ES6 <code class="fe lj lk ll lm b">import</code>语句或<code class="fe lj lk ll lm b">import()</code>函数，我们需要提供文件扩展名。我们还将<code class="fe lj lk ll lm b">var</code>改为<code class="fe lj lk ll lm b">const</code>,因为使用<code class="fe lj lk ll lm b">const</code>来实现这个目的是一个最佳实践。</p><p id="8efe" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">需要记住的关键是，这些全局变量现在有了Promise对象，而不是模块引用。因此，包仍然会失败，因为对这些对象的现有引用将找不到预期的模块引用。</p><p id="9c7d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">当我们进一步检查代码时，发现了一个问题:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="f1cd" class="nw mm iu lm b gz nx ny l nz oa">function micromatch(list, patterns, options) {<br/>  patterns = utils.arrayify(patterns);<br/>  list = utils.arrayify(list);<br/>  ...<br/>}</span></pre><p id="c899" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们用来重写这个函数的任何路径都需要将它从同步函数转换为异步函数。本例中的<code class="fe lj lk ll lm b">micromatch</code>包显然导出了同步函数，它的API切换到异步函数是没有意义的。</p><p id="e723" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">例如，一个选项是:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="f316" class="nw mm iu lm b gz nx ny l nz oa">async function micromatch(list, patterns, options) {<br/>   patterns = (await utils).arrayify(patterns);   <br/>   list = (await utils).arrayify(list);   <br/>... <br/>}</span></pre><p id="6459" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">使用<code class="fe lj lk ll lm b">await</code>关键字是等待Promise对象解析的最干净的方法。但是使用它需要将<code class="fe lj lk ll lm b">micromatch</code>函数重新声明为<code class="fe lj lk ll lm b">async</code>，然后必须为此重写该函数的调用方。如果我们使用<code class="fe lj lk ll lm b">.then</code> / <code class="fe lj lk ll lm b">.catch</code>来等待Promise对象解析，情况也是如此。</p><p id="8df5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">显然，如果<code class="fe lj lk ll lm b">micromatch</code>函数是异步的，那么我们就可以完成这项任务。这就是为什么我们之前描述了异步和同步函数之间的区别。为了使<code class="fe lj lk ll lm b">micromatch</code>保持同步功能，它不能执行任何异步动作。</p><p id="9786" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们稍微改变一下方向，考虑一个不同的包，我们可以称之为<code class="fe lj lk ll lm b">asyncmatch</code>。</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="232b" class="nw mm iu lm b gz nx ny l nz oa">$ tree node_modules/asyncmatch/ <br/>node_modules/asyncmatch/<br/>├── CHANGELOG.md <br/>├── LICENSE <br/>├── README.md <br/>├── index.js <br/>└── lib<br/>   ├── compilers.mjs<br/>   └── utils.mjs</span></pre><p id="e4bf" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了便于讨论，我们稍微改变了一下名称和内容，以考虑一个公开异步API的包。和以前一样，<code class="fe lj lk ll lm b">index.js</code>会有这样的说法:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="baf7" class="nw mm iu lm b gz nx ny l nz oa">const compilers = import('./lib/compilers.mjs'); <br/>const utils = import('./lib/utils.mjs');</span></pre><p id="b21e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后，当<code class="fe lj lk ll lm b">index.js</code>开始实现API函数时，它将遵循这种模式:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="94cb" class="nw mm iu lm b gz nx ny l nz oa">async function asyncmatch(list, patterns, options) {<br/>   patterns = (await utils).arrayify(patterns);<br/>   list = (await utils).arrayify(list);   <br/>... <br/>}</span></pre><p id="cba1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">作为一个<code class="fe lj lk ll lm b">async</code>函数，我们可以很容易地在<code class="fe lj lk ll lm b">asyncmatch</code>中使用<code class="fe lj lk ll lm b">await</code>关键字。因此<code class="fe lj lk ll lm b">(await utils).arrayify</code>自动处理<code class="fe lj lk ll lm b">utils</code>变量中的承诺。</p><p id="ad2d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">因此，这是实现调用ES6模块中函数的CJS模块的一种模式。公共API是一个CJS模块，任何Node.js应用程序都可以自动轻松地使用它。内部模块采用ES6模块格式并不限制哪些应用程序可以使用该包。</p><p id="1116" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了让这更真实一点，让我们尝试一些实际的代码。代码片段可以在位于https://github.com/robogeek/async-javascript-examples<a class="ae oc" href="https://github.com/robogeek/async-javascript-examples" rel="noopener ugc nofollow" target="_blank">的一个名为<code class="fe lj lk ll lm b">hybrid-es6-cjs-module</code>的目录中找到。</a></p><p id="8516" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们从ES6模块<code class="fe lj lk ll lm b">hello.mjs</code>开始，它包含:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="732d" class="nw mm iu lm b gz nx ny l nz oa">export async function hello() {<br/>     return "Hello, world!"; <br/>}</span></pre><p id="384c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">因为这被声明为一个<code class="fe lj lk ll lm b">async</code>函数，所以它返回一个承诺。</p><p id="1ffc" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后我们创建一个CJS模块<code class="fe lj lk ll lm b">index.js</code>，包含:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="28d9" class="nw mm iu lm b gz nx ny l nz oa">const aasync = import('./async.mjs');  </span><span id="e49e" class="nw mm iu lm b gz ob ny l nz oa">console.log(aasync);  </span><span id="79ab" class="nw mm iu lm b gz ob ny l nz oa">async function hello() {<br/>    let ret = (await aasync).hello();     <br/>    console.log(aasync);<br/>    return ret;<br/>}<br/>module.exports.hello = hello;</span></pre><p id="9071" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">第一部分使用<code class="fe lj lk ll lm b">import()</code>加载ES6模块。然后我们实现一个<code class="fe lj lk ll lm b">async</code>函数，它将成为这个包的公共接口。该<code class="fe lj lk ll lm b">hello</code>函数调用<code class="fe lj lk ll lm b">async.mjs</code>中的<code class="fe lj lk ll lm b">hello</code>函数。</p><p id="6a9d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这当然是高度人为的。重点是我们在CJS模块中创建了一个<code class="fe lj lk ll lm b">async</code>函数，它在内部ES6模块中公开了另一个<code class="fe lj lk ll lm b">async</code>函数。任何使用这个包的应用程序都将使用<code class="fe lj lk ll lm b">index.js</code>中的API。好处是<code class="fe lj lk ll lm b">index.js</code>是CJS格式，可以很容易地从其他CJS模块中使用。</p><p id="8330" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这里有<code class="fe lj lk ll lm b">console.log</code>语句，所以我们可以在不同的时间点检查<code class="fe lj lk ll lm b">aasync</code>中模块引用的内容。</p><p id="afb7" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了测试这一点，创建一个名为<code class="fe lj lk ll lm b">test.js</code>的文件，包含:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="2be3" class="nw mm iu lm b gz nx ny l nz oa">const cjshello = require('./index.js');</span><span id="e55d" class="nw mm iu lm b gz ob ny l nz oa">async function callHello() {<br/>     let h = await cjshello.hello();<br/>     console.log(h); <br/>}</span><span id="bc79" class="nw mm iu lm b gz ob ny l nz oa">callHello()<br/>.then(() =&gt; { console.log('callHello SUCCESS'); })<br/>.catch(err =&gt; { console.log('callHello ERROR ', err); });</span></pre><p id="513e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这个脚本是用来模拟使用这个包的应用程序的，而<code class="fe lj lk ll lm b">callHello</code>函数是用来模拟使用这个包的。它调用<code class="fe lj lk ll lm b">hello</code>函数，使用<code class="fe lj lk ll lm b">await</code>来处理每个承诺，然后打印结果。然后在底部，我们使用<code class="fe lj lk ll lm b">.then</code>和<code class="fe lj lk ll lm b">.catch</code>块调用<code class="fe lj lk ll lm b">callHello</code>来处理承诺。</p><p id="73d2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">输出如下所示:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="2ff2" class="nw mm iu lm b gz nx ny l nz oa">$ node test.js  <br/>Promise { &lt;pending&gt; } <br/>Promise { [Module] { hello: [AsyncFunction: hello] } } <br/>Hello, world! <br/>callHello SUCCESS</span></pre><p id="4ffa" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们看到，在第一个<code class="fe lj lk ll lm b">console.log</code>中，承诺如预期的那样处于<em class="ls">待定</em>状态。但是<code class="fe lj lk ll lm b">await</code>关键字，不出所料，一直等到承诺成功解析。我们得到了预期的消息，以及<code class="fe lj lk ll lm b">SUCCESS</code>指示器。第二个<code class="fe lj lk ll lm b">console.log</code>如预期的那样，显示了承诺被解析，并且它包含一个<code class="fe lj lk ll lm b">Module</code>对象。</p><p id="99b2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">假设您的公共API需要使用回调风格的函数。将此添加到<code class="fe lj lk ll lm b">index.js</code>:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="aad7" class="nw mm iu lm b gz nx ny l nz oa">function helloCB(done) {<br/>     aasync.then(m =&gt; {<br/>         m.hello()<br/>         .then(msg =&gt; { done(undefined, msg); })<br/>         .catch(err =&gt; { done(err); });<br/>     })<br/>     .catch(err =&gt; {         done(err);     }); <br/>}<br/>module.exports.helloCB = helloCB;</span></pre><p id="f4f1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">记住<code class="fe lj lk ll lm b">aasync</code>包含从<code class="fe lj lk ll lm b">import()</code>函数返回的承诺，我们使用<code class="fe lj lk ll lm b">.then</code> / <code class="fe lj lk ll lm b">.catch</code>块来处理它。在<code class="fe lj lk ll lm b">.then</code>中，我们调用<code class="fe lj lk ll lm b">hello</code>函数，同样使用<code class="fe lj lk ll lm b">.then</code> / <code class="fe lj lk ll lm b">.catch</code>块。提供了一个回调函数，我们在典型的Node.js回调函数的<em class="ls">错误优先</em>模式中使用它。</p><p id="996f" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这应该提醒我们功能的巨大收益。不使用<code class="fe lj lk ll lm b">async</code>函数来实现这一点意味着使用两层<code class="fe lj lk ll lm b">.then</code> / <code class="fe lj lk ll lm b">.catch</code>块来处理每个承诺。确保捕捉到每个错误需要一些耐心来添加每个所需的<code class="fe lj lk ll lm b">.catch</code>块。</p><p id="1b8a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后我们可以对<code class="fe lj lk ll lm b">test.js</code>做一点调整:</p><p id="0142" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">消息现在指示哪个函数打印该消息。结果输出如下所示:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="1d66" class="nw mm iu lm b gz nx ny l nz oa">callHello() <br/>.then(() =&gt; { console.log('callHello SUCCESS'); }) <br/>.catch(err =&gt; { console.log('callHello ERROR ', err); }) </span><span id="1906" class="nw mm iu lm b gz ob ny l nz oa">cjshello.helloCB((err, msg) =&gt; {<br/>     if (err) {<br/>         console.log('helloCB ERROR ', err);<br/>     } else {<br/>         console.log('helloCB SUCCESS ', msg);<br/>     }<br/>});</span></pre><p id="aed2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">消息现在指示哪个函数打印该消息。结果输出如下所示:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="8c0c" class="nw mm iu lm b gz nx ny l nz oa">$ node test.js  <br/>Promise { &lt;pending&gt; } <br/>Promise { [Module] { hello: [AsyncFunction: hello] } } <br/>helloCB SUCCESS  Hello, world!<br/>Hello, world!<br/>callHello SUCCESS</span></pre><p id="c3cd" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们刚刚证明了一些重要的事情。我们可以使用ES6模块格式实现Node.js包的内部模块，并使用CJS模块公开公共API。然而，这种方法只适用于公开的API已经是异步的情况。</p><h1 id="b257" class="ml mm iu bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">在Node.js <code class="fe lj lk ll lm b">package.json</code>中为混合CJS/ES6模块使用条件导出</h1><p id="484a" class="pw-post-body-paragraph kc kd iu ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz in bi translated">我们已经证明，我们可以在Node.js包中使用ES6模块，并创建一个CJS接口模块，使该模块可以很容易地从CommonJS代码中使用。但是对于ES6模块来说，最好是直接加载ES6模块，而不是通过中间的CJS模块工作。</p><p id="59bf" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">从Node.js v12.7.0开始，我们能够向<code class="fe lj lk ll lm b">package.json</code>添加一个<code class="fe lj lk ll lm b">exports</code>字段。该字段的一个目的是声明如何处理辅助模块。例如:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="f07d" class="nw mm iu lm b gz nx ny l nz oa">{<br/>     "name": "module-name",<br/>     ...<br/>     "main": "index.js",<br/>     "exports": {<br/>         ".": "./index.js",<br/>         "promises": "./promises/index.js"<br/>     },<br/>     ... <br/>}</span></pre><p id="3ae5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这表明包的主接口是<code class="fe lj lk ll lm b">index.js</code>，包引用<code class="fe lj lk ll lm b">module-name/promises</code>解析为<code class="fe lj lk ll lm b">promises/index.js</code>。</p><p id="4391" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这个特性的一个变体是<em class="ls">条件导出</em>，它根据不同的条件映射到不同的文件路径。我们将使用的条件是模块是使用<code class="fe lj lk ll lm b">require</code>还是<code class="fe lj lk ll lm b">import</code>加载的。也就是说，上述内容可以写成:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="9a44" class="nw mm iu lm b gz nx ny l nz oa">{<br/>     "name": "module-name",<br/>     ...<br/>     "main": "index.js",<br/>     "exports": {<br/>         ".": {<br/>             "require": "./index.js",<br/>             "import": "./index.mjs",<br/>         },<br/>         "promises": {<br/>             "require": "./promises/index.js",<br/>             "import": "./promises/index.mjs",<br/>         }<br/>     },<br/>     ... <br/>}</span></pre><p id="a1ba" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是条件导出的嵌套形式。对于每个字段，我们有两个字段<code class="fe lj lk ll lm b">require</code>和<code class="fe lj lk ll lm b">import</code>。当使用<code class="fe lj lk ll lm b">require</code>语句请求模块时，<code class="fe lj lk ll lm b">require</code>字段告诉Node.js在哪里查找，并且从<code class="fe lj lk ll lm b">import</code>语句使用<code class="fe lj lk ll lm b">import</code>字段。</p><p id="c6b6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们看一个真实的例子。在<a class="ae oc" href="https://github.com/robogeek/async-javascript-examples" rel="noopener ugc nofollow" target="_blank">https://github.com/robogeek/async-javascript-examples</a>存储库中，您会找到一个名为<code class="fe lj lk ll lm b">conditional-exports</code>的目录。在该目录中有一个目录<code class="fe lj lk ll lm b">module</code>，包含:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="1b74" class="nw mm iu lm b gz nx ny l nz oa">$ tree module/ <br/>module/ <br/>├── index.js <br/>├── index.mjs <br/>└── package.json</span></pre><p id="8bba" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">从<code class="fe lj lk ll lm b">index.mjs</code>开始:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="3a6a" class="nw mm iu lm b gz nx ny l nz oa">export async function hello() {<br/>     console.log('in ES6');<br/>     return "Hello, world!"; <br/>}</span></pre><p id="3a7c" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果这是一个真实的Node.js包，那么这个模块会有比这更有趣的功能，但是这对于探索这个特性已经足够了。也就是说，我们有异步函数。</p><p id="8f90" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lj lk ll lm b">index.js</code>中的内容如下:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="b59d" class="nw mm iu lm b gz nx ny l nz oa">const _index = import('./index.mjs');<br/> module.exports.hello = async function() {<br/>     console.log('in CJS');<br/>     return (await _index).hello(); <br/>}</span></pre><p id="bd38" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是<code class="fe lj lk ll lm b">index.mjs</code>中ES6模块周围的<em class="ls">包装器</em>。模式是，对于内部模块中的每个函数，实现一个包装函数，如<code class="fe lj lk ll lm b">index.js</code>中所示。</p><p id="d6ea" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">假设您的包需要支持同步功能。我们不能在<code class="fe lj lk ll lm b">index.mjs</code>中实现它，然后在<code class="fe lj lk ll lm b">index.js</code>中使用包装函数。相反，创建一个名为<code class="fe lj lk ll lm b">shared.js</code>的文件，包含:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="732e" class="nw mm iu lm b gz nx ny l nz oa">module.exports.func1 = function() {<br/>     return "Synchronous shared function"; <br/>}</span></pre><p id="c7ef" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">因为这个同步功能在CJS模块中，所以可以用<code class="fe lj lk ll lm b">require</code>加载到<code class="fe lj lk ll lm b">index.js</code>中，用<code class="fe lj lk ll lm b">import</code>加载到<code class="fe lj lk ll lm b">index.mjs</code>中。在这两种情况下，它将保持同步功能。</p><p id="cfc0" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe lj lk ll lm b">index.mjs</code>中，我们这样导出这个函数:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="bd26" class="nw mm iu lm b gz nx ny l nz oa">export { func1 } from './shared.js';</span></pre><p id="7e97" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这就是所谓的重新导出，其中的<code class="fe lj lk ll lm b">export</code>语句表示它正在导出从另一个模块导入的东西。</p><p id="3097" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe lj lk ll lm b">index.js</code>中，我们将做同样的事情，但需要两步:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="e58a" class="nw mm iu lm b gz nx ny l nz oa">const shared = require('./shared.js'); <br/>... <br/>module.exports.func1 = shared.func1;</span></pre><p id="48d4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了圆满完成这个任务，<code class="fe lj lk ll lm b">package.json</code>:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="f2a4" class="nw mm iu lm b gz nx ny l nz oa">{<br/>   "name": "conditional-exports-module",<br/>   "main": "index.js",<br/>   "exports": {<br/>     "require": "./index.js",<br/>     "import": "./index.mjs"<br/>   },<br/>   "type": "commonjs"   <br/>   ... <br/>}</span></pre><p id="5bae" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是条件导出的简单形式，其中只有一个导出。</p><p id="9dde" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lj lk ll lm b">type</code>字段表示将扩展名为<code class="fe lj lk ll lm b">.js</code>的文件视为CommonJS。如果<code class="fe lj lk ll lm b">type</code>字段显示为<code class="fe lj lk ll lm b">module</code>，那么使用CJS文件将需要<code class="fe lj lk ll lm b">.cjs</code>扩展名，并且带有<code class="fe lj lk ll lm b">.js</code>扩展名的文件将被解释为ES6模块。</p><p id="d3c0" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了测试这一点，创建另一个名为<code class="fe lj lk ll lm b">test</code>的目录作为<code class="fe lj lk ll lm b">module</code>目录的同级，包含:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="49b5" class="nw mm iu lm b gz nx ny l nz oa">$ tree test/ test/ <br/>├── package.json <br/>├── test.js <br/>└── test.mjs</span></pre><p id="3152" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们将使用<code class="fe lj lk ll lm b">test.js</code>来验证加载CJS接口，使用<code class="fe lj lk ll lm b">test.mjs</code>来验证加载ES6接口。</p><p id="f514" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe lj lk ll lm b">test.mjs</code>我们有:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="513c" class="nw mm iu lm b gz nx ny l nz oa">import * as condit from "conditional-exports-module"; console.log(condit); <br/>console.log(await condit.hello());<br/>console.log(condit.func1());</span></pre><p id="6e81" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">请注意，在<code class="fe lj lk ll lm b">module/package.json</code>中，我们为包使用了这个模块名。这只是使用<code class="fe lj lk ll lm b">import</code>语句来加载模块，然后我们打印调用<code class="fe lj lk ll lm b">hello</code>函数的结果。因为那个函数是<code class="fe lj lk ll lm b">async</code>我们用<code class="fe lj lk ll lm b">await</code>。</p><p id="b480" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">如果你不知道，Node.js最近获得了在ES6模块顶层使用<code class="fe lj lk ll lm b">await</code>的能力。这就是我们在这里所做的。要了解更多信息，请参见:<a class="ae oc" href="https://techsparx.com/nodejs/async/top-level-async.html" rel="noopener ugc nofollow" target="_blank"> Node.js脚本编写者:顶级异步/等待现已推出</a></p><p id="cca4" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe lj lk ll lm b">test.js</code>中，我们有:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="d1d2" class="nw mm iu lm b gz nx ny l nz oa">const condit = require('conditional-exports-module');</span><span id="787b" class="nw mm iu lm b gz ob ny l nz oa">console.log(condit);<br/>condit.hello() <br/>.then(msg =&gt; { console.log(msg); }) <br/>.catch(err =&gt; { console.error(err); });  </span><span id="e798" class="nw mm iu lm b gz ob ny l nz oa">console.log(condit.func1());</span></pre><p id="edd2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">注意，我们使用了<code class="fe lj lk ll lm b">require</code>而不是<code class="fe lj lk ll lm b">import()</code>。这意味着我们可以直接使用模块引用，而不必消除任何Promise对象的歧义。因为<code class="fe lj lk ll lm b">hello</code>函数被定义为异步的，并且顶层<code class="fe lj lk ll lm b">await</code>在CJS模块中不可用，所以我们必须使用<code class="fe lj lk ll lm b">.then</code> / <code class="fe lj lk ll lm b">.catch</code>块来处理产生的承诺。</p><p id="5bc8" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">所需的<code class="fe lj lk ll lm b">package.json</code>是:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="21f7" class="nw mm iu lm b gz nx ny l nz oa">{<br/>   "name": "conditional-exports-test",<br/>   "main": "test.js",<br/>   "scripts": {<br/>     "test": "npm run test:js &amp;&amp; npm run test:es6",<br/>     "test:js": "node test.js",<br/>     "test:es6": "node test.mjs"<br/>   }<br/>   ... <br/>}</span></pre><p id="37cc" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们可以使用<code class="fe lj lk ll lm b">scripts</code>字段来帮助我们运行测试程序，如果没有别的作用的话。</p><p id="0b99" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">要进行设置，首先运行:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="b714" class="nw mm iu lm b gz nx ny l nz oa">$ cd test<br/>$ npm install ../module</span></pre><p id="1bf5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这将创建一个<code class="fe lj lk ll lm b">node_modules</code>目录，并在那里安装软件包。下次运行:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="05d0" class="nw mm iu lm b gz nx ny l nz oa">$ npm test  <br/>&gt; conditional-exports-test@1.0.0 test /Volumes/Extra/nodejs/async-javascript-examples/conditional-exports/test <br/>&gt; npm run test:js &amp;&amp; npm run test:es6  </span><span id="db95" class="nw mm iu lm b gz ob ny l nz oa">&gt; conditional-exports-test@1.0.0 test:js /Volumes/Extra/nodejs/async-javascript-examples/conditional-exports/test <br/>&gt; node test.js  </span><span id="cc4e" class="nw mm iu lm b gz ob ny l nz oa">{ hello: [AsyncFunction (anonymous)], func1: [Function (anonymous)] } <br/>in CJS <br/>Synchronous shared function <br/>in ES6 <br/>Hello, world!  </span><span id="e026" class="nw mm iu lm b gz ob ny l nz oa">&gt; conditional-exports-test@1.0.0 test:es6 /Volumes/Extra/nodejs/async-javascript-examples/conditional-exports/test <br/>&gt; node test.mjs</span><span id="45aa" class="nw mm iu lm b gz ob ny l nz oa">[Module] {<br/>   func1: [Function (anonymous)],<br/>   hello: [AsyncFunction: hello]<br/>}<br/>in ES6<br/>Hello, world!<br/>Synchronous shared function</span></pre><p id="5092" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们看到，为了运行<code class="fe lj lk ll lm b">test.js</code>脚本，它首先调用CJS模块中的函数，然后调用ES6模块中的函数。对于<code class="fe lj lk ll lm b">test.mjs</code>脚本，它只调用了ES6函数。</p><p id="c24a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这正是我们想要的。首先，我们有CJS和ES6模块格式的包的并行实现。我们可以轻松使用CJS或ES6模块中的任何一个，并轻松访问适当的实施。</p><p id="54fd" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">还有第三个场景要测试，那就是从CJS模块中使用<code class="fe lj lk ll lm b">import()</code>。为此，创建<code class="fe lj lk ll lm b">test-es6.js</code>包含:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="ab2f" class="nw mm iu lm b gz nx ny l nz oa">const _condit = import('conditional-exports-module');</span><span id="9825" class="nw mm iu lm b gz ob ny l nz oa">console.log(_condit);<br/>_condit .then(condit =&gt; {<br/>     console.log(condit);<br/>     condit.hello()<br/>     .then(msg =&gt; { console.log(msg); })<br/>     .catch(err =&gt; { console.error(err); });</span><span id="6441" class="nw mm iu lm b gz ob ny l nz oa">     console.log(condit.func1()); <br/>})<br/>.catch(err =&gt; { console.error(err); });</span></pre><p id="d73a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">注意，对于其中的每一个，模块说明符都保持不变。神奇正在<code class="fe lj lk ll lm b">package.json</code>发生。</p><p id="0da1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">无论如何，记住<code class="fe lj lk ll lm b">import()</code>返回一个承诺，这个承诺必须首先被解决。然后我们有一个异步函数，<code class="fe lj lk ll lm b">hello</code>，它返回一个必须解决的承诺。因此，测试需要正确构建两层<code class="fe lj lk ll lm b">.then</code> / <code class="fe lj lk ll lm b">.catch</code>。</p><p id="92d6" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">运行测试，我们得到:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="2808" class="nw mm iu lm b gz nx ny l nz oa">$ node test-es6.js </span><span id="08ba" class="nw mm iu lm b gz ob ny l nz oa">Promise { &lt;pending&gt; } <br/>[Module] {<br/> func1: [ (anonymous)],<br/> hello: [AsyncFunction: hello]<br/>} <br/>in ES6 <br/>Synchronous shared function <br/>Hello, world</span></pre><p id="f6a5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这也正是我们想要的。因为我们使用了<code class="fe lj lk ll lm b">import()</code>，函数调用直接到达ES6实现，跳过了CJS包装器模块。</p><p id="7747" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">为了实现同步功能，我们将它放入一个共享的CJS模块中。但是如果我们希望所有的代码都在ES6模块中，同时保持部分(或全部)功能同步，那该怎么办呢？显然，我们不能通过使用<code class="fe lj lk ll lm b">import()</code>函数从CJS模块中访问这些函数来做到这一点。</p><p id="5dd3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">还有一种方法，就是用Babel这样的Transpiler把ES6模块改写成CJS。</p><h1 id="e2ce" class="ml mm iu bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">用Babel编译一个混合的CJS/ES6 Node.js包</h1><p id="94c1" class="pw-post-body-paragraph kc kd iu ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz in bi translated">我们还没有开发出创建包含CJS和ES6实现的混合Node.js包的最佳方式。我们已经展示了我们可以用与ES6模块相同的API手工制作一个CJS模块。但是还有一个问题，就是可维护性。手工制作CJS包装器模块并不是什么最佳实践，因为我们可能会忽略在每次API更新时更新包装器。</p><p id="71ba" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在JavaScript生态系统中有一个神奇的工具，Babel，它是一个<em class="ls"> Transpiler </em>。这个词是<em class="ls">翻译</em>和<em class="ls">编译</em>的混搭，是关于将源代码从一种编程语言转换成另一种编程语言。就Babel而言，它的重点是JavaScript转换，例如作为一种工具，自动转换尖端的JavaScript功能，以便在较旧的JavaScript引擎上运行。在这种情况下，我们将使用它将我们的ES6模块转换为Node.js CommonJS模块。</p><p id="f607" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">首先复制<code class="fe lj lk ll lm b">module</code>目录及其内容，作为<code class="fe lj lk ll lm b">module-babel</code>。您可以在前面提到的Github存储库中找到它。</p><p id="99c9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">删除<code class="fe lj lk ll lm b">index.js</code>和<code class="fe lj lk ll lm b">shared.js</code>，因为我们不再需要它们。并且，在<code class="fe lj lk ll lm b">index.mjs</code>中添加此功能:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="c8bd" class="nw mm iu lm b gz nx ny l nz oa">export function func1() {<br/>     return "Synchronous ES6 function";<br/>}</span></pre><p id="ac31" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是已经在<code class="fe lj lk ll lm b">shared.js</code>中的<code class="fe lj lk ll lm b">func1</code>的重新实现。这就给我们留下了一个文件<code class="fe lj lk ll lm b">index.mjs</code>，其中包含了我们的整个API实现。</p><p id="3271" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">要安装Babel，请运行以下命令:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="664a" class="nw mm iu lm b gz nx ny l nz oa">$ npm install @babel/core --save-dev <br/>$ npm install @babel/cli --save-dev <br/>$ npm install @babel/plugin-transform-modules-commonjs --save-dev</span></pre><p id="0ad9" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这将安装Babel和它的CLI工具。这里命名的插件将ES6模块代码转换成CommonJS格式。</p><p id="4706" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">接下来，创建一个名为<code class="fe lj lk ll lm b">.babelrc</code>的文件，其中包含:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="e071" class="nw mm iu lm b gz nx ny l nz oa">{ "plugins": [ "@babel/plugin-transform-modules-commonjs" ] }</span></pre><p id="cdaa" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这会将Babel配置为使用该插件。</p><p id="365d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">接下来，将以下<code class="fe lj lk ll lm b">scripts</code>条目添加到<code class="fe lj lk ll lm b">package.json</code>:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="69ae" class="nw mm iu lm b gz nx ny l nz oa">"scripts": {<br/>     "build": "babel index.mjs --out-file index.js" <br/>},</span></pre><p id="a751" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是将单个ES6文件编译成CommonJS格式的命令。巴别塔有比这更多的选择，这是对巴别塔非常简单的使用。</p><p id="5859" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">运行脚本:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="e478" class="nw mm iu lm b gz nx ny l nz oa">$ npm run build  <br/>&gt; conditional-exports-module@1.0.0 build /Volumes/Extra/nodejs/async-javascript-examples/conditional-exports/module-babel <br/>&gt; babel index.mjs --out-file index.js</span></pre><p id="43ac" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">结果是:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="c48d" class="nw mm iu lm b gz nx ny l nz oa">"use strict";  <br/>Object.defineProperty(exports, "__esModule", {<br/>   value: true<br/>});</span><span id="f087" class="nw mm iu lm b gz ob ny l nz oa">exports.hello = hello;<br/>exports.func1 = func1;</span><span id="7df2" class="nw mm iu lm b gz ob ny l nz oa">async function hello() {<br/>   console.log('in ES6');<br/>   return "Hello, world!"; <br/>}<br/>function func1() {<br/>   return "Synchronous ES6 function"; <br/>}</span></pre><p id="2687" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这是一个非常合理的模块CJS再现。唯一的问题是ES6 中的跟踪输出说<em class="ls">不再正确。哦好吧。</em></p><p id="50f0" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">现在让我们再次设置<code class="fe lj lk ll lm b">test</code>目录。可能已经有一个<code class="fe lj lk ll lm b">node_modules</code>目录安装了<code class="fe lj lk ll lm b">../module</code>中的包。我们现在想使用<code class="fe lj lk ll lm b">../module-babel</code>，所以运行这个:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="d3ed" class="nw mm iu lm b gz nx ny l nz oa">$ cd ../test <br/>$ rm -rf node_modules <br/>$ npm install ../module-babel</span></pre><p id="cd01" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">我们现在可以运行测试程序并获得以下输出:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="4ad8" class="nw mm iu lm b gz nx ny l nz oa">&gt; conditional-exports-test@1.0.0 test:js /Volumes/Extra/nodejs/async-javascript-examples/conditional-exports/test <br/>&gt; node test.js  </span><span id="af6d" class="nw mm iu lm b gz ob ny l nz oa">{ hello: [AsyncFunction: hello], func1: [Function: func1] } <br/>in ES6 <br/>Synchronous ES6 function <br/>Hello, world!  </span><span id="99eb" class="nw mm iu lm b gz ob ny l nz oa">&gt; conditional-exports-test@1.0.0 test:es6 /Volumes/Extra/nodejs/async-javascript-examples/conditional-exports/test <br/>&gt; node test.mjs  </span><span id="a5e0" class="nw mm iu lm b gz ob ny l nz oa">[Module] {<br/> func1: [Function: func1],<br/> hello: [AsyncFunction: hello] <br/>} <br/>in ES6 <br/>Hello, world! <br/>Synchronous ES6 function</span></pre><p id="ffda" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">不同的输出顺序是<code class="fe lj lk ll lm b">hello</code>作为异步函数的一个简单副产品。无论如何，我们得到了我们期望的输出。</p><h1 id="20ac" class="ml mm iu bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">在TypeScript中实现包，编译到CJS和ES6模块</h1><p id="a625" class="pw-post-body-paragraph kc kd iu ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz in bi translated">JavaScript语言中添加的ECMAScript并不是唯一的游戏。另一个主要参与者是类型脚本语言。它的模块格式类似于ES6格式，我们可以直接重用ES6文件作为类型脚本文件。TypeScript给游戏带来的是比JavaScript语言更强的类型检查。是的，JavaScript程序员习惯于基本上没有类型检查。但是随着我们的程序变得越来越大，编译器通过静态检查我们的代码来帮助我们是有用的，这就是TypeScript的编译器所做的。</p><p id="f3aa" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">一些编程团队会接受这个想法，因此开发是在TypeScript中完成的。然而，运行时仍然是JavaScript，这意味着在运行之前必须编译代码。一些JavaScript程序员觉得这很奇怪，但是我们这些用Java或C或Pascal或PL/1或许多其他编译语言编写过代码的人已经习惯了。</p><p id="c45a" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">TypeScript编译器支持编译成许多不同的输出格式。通过适当的配置，我们可以引导它为Node.js生成CommonJS文件和ES6文件。</p><p id="73ea" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">让我们将<code class="fe lj lk ll lm b">module</code>目录复制为<code class="fe lj lk ll lm b">module-typescript</code>。然后删除<code class="fe lj lk ll lm b">module-typescript/index.js</code>，将<code class="fe lj lk ll lm b">module-typescript/index.mjs</code>改名为<code class="fe lj lk ll lm b">index.ts</code>。因为TypeScript可以编译ES6模块，所以没有进一步的更改。然而，了解TypeScript的一长串有用特性是值得的。</p><p id="ecde" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">TypeScript的文件扩展名是<code class="fe lj lk ll lm b">.ts</code>，在这个目录中，我们将在<code class="fe lj lk ll lm b">.ts</code>文件中编码。我们将使用编译器生成<code class="fe lj lk ll lm b">.cjs</code>和<code class="fe lj lk ll lm b">.mjs</code>文件。</p><p id="196e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">若要安装TypeScript编译器，请运行以下命令:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="7c8c" class="nw mm iu lm b gz nx ny l nz oa">$ npm install typescript</span></pre><p id="4926" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">若要熟悉，请键入:<code class="fe lj lk ll lm b">tsc --help</code></p><p id="bed3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">在<code class="fe lj lk ll lm b">package.json</code>中增加此<code class="fe lj lk ll lm b">scripts</code>部分:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="ce02" class="nw mm iu lm b gz nx ny l nz oa">"scripts": {<br/>     "build": "npm run build:cjs &amp;&amp; npm run build:es6",<br/>     "build:cjs": "tsc --target es2018 --module commonjs index.ts &amp;&amp; mv index.js index.cjs",<br/>     "build:es6": "tsc --types --sourceMap --declaration --declarationMap --target es2018 --module es2020 index.ts &amp;&amp; mv index.js index.mjs" <br/>},</span></pre><p id="6c98" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lj lk ll lm b">--target</code>选项描述要使用的ECMAScript语言的版本。使用<code class="fe lj lk ll lm b">es2018</code>给了我们需要的语言特性。</p><p id="7a3b" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lj lk ll lm b">--module</code>选项描述了要使用的模块格式。对于Node.js，我们使用<code class="fe lj lk ll lm b">commonjs</code>，对于ES6模块，我们使用<code class="fe lj lk ll lm b">es2020</code>。</p><p id="b5c3" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><code class="fe lj lk ll lm b">--types --sourceMap --declaration --declarationMap</code>选项告诉TypeScript生成描述文件中使用的类型的元数据文件。这些类型可以在编译其他包时使用，以帮助TypeScript进行更好的类型检查。</p><p id="cf35" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">和Babel一样，我们仅仅触及了TypeScript编译器的皮毛。无论如何，下一个任务是运行<code class="fe lj lk ll lm b">npm run build</code>来生成可运行的CJS和ES6文件。</p><p id="5591" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">通过添加这些声明来结束<code class="fe lj lk ll lm b">package.json</code>:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="88c7" class="nw mm iu lm b gz nx ny l nz oa">"main": "index.js", <br/>"exports": {<br/>     "require": "./index.cjs",<br/>     "import": "./index.mjs" <br/>},<br/>"type": "commonjs", <br/>"types": "./index.d.ts",</span></pre><p id="ad91" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">注意，我们为CJS模块使用了文件扩展名<code class="fe lj lk ll lm b">.cjs</code>。这是因为我们无法解决如何让<code class="fe lj lk ll lm b">tsc</code>将编译后的文件输出到一个特定的文件名。相反，请注意，它将编译后的文件输出为<code class="fe lj lk ll lm b">index.js</code>，然后我们将其重命名为另一个文件名。</p><p id="5f4d" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">另外增加的是<code class="fe lj lk ll lm b">types</code>字段。这对于声明类型定义文件的存在很重要。</p><p id="38f5" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">与Babel示例一样，我们需要将包重新安装到<code class="fe lj lk ll lm b">test</code>目录中。运行这些命令:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="49de" class="nw mm iu lm b gz nx ny l nz oa">$ cd ../test <br/>$ rm -rf node_modules <br/>$ npm install ../module-typescript <br/>$ npm test</span></pre><p id="dadf" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">测试程序应该像以前一样运行，没有变化。</p><h1 id="ad9b" class="ml mm iu bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">处理Node.js混合CJS/ES6模块中的边缘情况</h1><p id="a282" class="pw-post-body-paragraph kc kd iu ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz in bi translated">在混合CJS/ES6模块的Node.js文档中，有一个关于我们之前没有讨论的边缘情况的警告。也就是说，当应用程序通过其CJS和ES6接口使用混合包时会发生什么？在很大程度上，这不是一个问题，但有一个问题。</p><p id="6398" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">假设您的ES6代码声明了一个类，如下所示:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="238d" class="nw mm iu lm b gz nx ny l nz oa">export class Hello {<br/>     world() { return "Hello World"; }<br/>     async world2() { return "Hello World"; } <br/>}</span></pre><p id="bfd1" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">你尽职尽责地将它放入<code class="fe lj lk ll lm b">index.mjs</code>，Babel或TypeScript将它转换成CJS模块<code class="fe lj lk ll lm b">index.js</code>中的等价代码。在这种情况下，Hello类在每个。但是，在您的应用程序中，这样的语句会发生什么情况:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="4292" class="nw mm iu lm b gz nx ny l nz oa">if (obj instanceof Hello) { ... }</span></pre><p id="c0f2" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">从技术上讲，Hello类在<code class="fe lj lk ll lm b">index.js</code>和<code class="fe lj lk ll lm b">index.mjs</code>中的实现是不同的。即使它们是完全相同的结构，它们也是不同的类定义，因此不是同一个类。</p><p id="ee14" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">可能发生的情况是应用程序同时包含ES6和CJS模块。我们已经看到，使用<code class="fe lj lk ll lm b">import</code>或<code class="fe lj lk ll lm b">require</code>会导致在<code class="fe lj lk ll lm b">package.json</code>的条件导出中使用不同的路径，最终导致加载不同的文件。这意味着在ES6模块中使用了一个Hello实现，而在CJS模块中使用了另一个Hello实现，尽管两者来自同一个包。</p><p id="95e0" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">治疗方法与我们之前使用的<code class="fe lj lk ll lm b">shared.js</code>策略相同。让我们在<code class="fe lj lk ll lm b">module-typescript</code>中尝试一下。</p><p id="7997" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">将类定义代码放入CJS模块(<code class="fe lj lk ll lm b">shared.js</code>)中，该模块包含:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="eb5c" class="nw mm iu lm b gz nx ny l nz oa">module.exports.Hello = class Hello {<br/>     world() { return "Hello World"; }<br/>     async world2() { return "Hello World async"; } <br/>}</span></pre><p id="a96e" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">然后在<code class="fe lj lk ll lm b">index.ts</code>中添加以下内容:</p><pre class="no np nq nr gu ns lm nt nu aw nv bi"><span id="c8b2" class="nw mm iu lm b gz nx ny l nz oa">export { Hello } from './shared.js';</span></pre><p id="0c64" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">这演示了从CJS模块进行重新导出的工作方式，就像之前对ES6模块所做的那样。</p><p id="7d35" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">运行<code class="fe lj lk ll lm b">npm run build</code>后，检查生成的代码。在<code class="fe lj lk ll lm b">index.js</code>和<code class="fe lj lk ll lm b">index.mjs</code>中，你会发现Hello类是从<code class="fe lj lk ll lm b">shared.js</code>中的声明派生出来的。这将确保<code class="fe lj lk ll lm b">obj instanceof Hello</code>总是正确地识别类。</p><h1 id="3b83" class="ml mm iu bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">摘要</h1><p id="6308" class="pw-post-body-paragraph kc kd iu ke b kf nj kh ki kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz in bi translated">在本教程中，我们学习了如何构建一个Node.js包来支持基于CommonJS和ES6的用法。为此，我们开发了一个包含相同代码的并行实现的混合包。我们还了解了一个高级的<code class="fe lj lk ll lm b">package.json</code>特性，它让我们显式地声明一个包的导出。</p><p id="a591" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated">通过学习这些，您已经消除了在Node.js包中完全包含ES6模块的一个障碍。这是因为您现在知道如何确保您的客户能够轻松使用该产品包，无论他们使用的是ES6还是CJS模块。</p><p id="61fe" class="pw-post-body-paragraph kc kd iu ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz in bi translated"><em class="ls">原载于</em><a class="ae oc" href="https://techsparx.com/nodejs/esnext/esm-to-cjs.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">https://techsparx.com</em></a><em class="ls">。</em></p></div></div>    
</body>
</html>