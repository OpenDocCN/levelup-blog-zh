<html>
<head>
<title>3 Practical Tips to Make Your Java App Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高Java应用速度的3个实用技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-practical-tips-to-make-your-java-app-faster-d4aeaa846863?source=collection_archive---------14-----------------------#2021-05-16">https://levelup.gitconnected.com/3-practical-tips-to-make-your-java-app-faster-d4aeaa846863?source=collection_archive---------14-----------------------#2021-05-16</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="d310" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何避免Java代码优化中的常见陷阱</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/40b2301e0f862df0c7b65d2d3a43d4b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RoTjsoypLYx63A0F"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://www.pexels.com/photo/asphalt-blur-car-city-290470/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae kz" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</figcaption></figure><p id="bdbb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">大多数开发人员都有关于Java性能的问题。大多数开发人员不知道正确的答案。</p><p id="be62" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">优化问题发生在代码审查、面谈和代码变慢的时候。</p><p id="6c15" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">你想知道更多关于JIT编译器优化的信息吗？那个大方法是如何增加成本的？如何提高你的项目绩效？</em></p><p id="3a49" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们有三个通过，我们就开始吧。</p><pre class="kk kl km kn gu lx ly lz ma aw mb bi"><span id="356e" class="mc md iu ly b gz me mf l mg mh">· <a class="ae kz" href="#3591" rel="noopener ugc nofollow">Inlining in Java</a><br/>· <a class="ae kz" href="#2fd0" rel="noopener ugc nofollow">How composition beats inheritance</a><br/>· <a class="ae kz" href="#3245" rel="noopener ugc nofollow">Which methods can’t be inlined?</a><br/>· <a class="ae kz" href="#95ee" rel="noopener ugc nofollow">How do big methods perform?</a><br/>· <a class="ae kz" href="#e4ce" rel="noopener ugc nofollow">Takeaway</a><br/>· <a class="ae kz" href="#5899" rel="noopener ugc nofollow">Resources</a></span></pre><h1 id="3591" class="mi md iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">Java中的内联</h1><p id="cdec" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">内联方法是JIT编译器使用的一种优化技术。研究<a class="ae kz" href="https://www.usenix.org/legacy/events/vee05/full_papers/p121-stepanian.pdf" rel="noopener ugc nofollow" target="_blank">显示</a>加速高达93倍。很多方法都是内联的，很少有不内联的。<em class="lw">为什么？因为方法的大小。这就是小方法的好处之一。</em></p><p id="f108" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">有哪些方法容易内联？</em>静态的、私有的、最终的方法很容易内联。如果是单态的，虚拟调用可以被内联。<em class="lw">什么是单态调用？方法的单一调用点。当你得到一个方法覆盖，巨型调用，你需要做查找。</em>意味着您需要在vtable中搜索方法引用。</p><p id="eb40" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">什么方法可以被内联？公共方法。</em>有一些标准方法必须满足。方法大小是一个标准。在Linux 64位上，大小小于325字节的方法可以被内联。小型方法得到内联，而大型方法没有。</p><p id="b3df" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">JIT编译器如何优化单态调用？命中内联缓存以避免vtable查找。</em>实际上，如果没有方法覆盖，就只有单态调用。<em class="lw">这些方法可以内联，避免调用vtable。</em> <em class="lw">对vtable的调用不会发生，因为没有额外的覆盖。那么超形调用呢？</em>巨方法主要是一个方法的多个实现，例如覆盖方法。它们需要调用vtable，并且不能内联。</p><p id="efa0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">内联能为你做什么？为什么单态调用比多态调用好？让我们看看。</em></p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><p id="d23b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以使用<a class="ae kz" href="https://gist.github.com/zivce/73fe2cd7b5d2f4eec2d1996d0565a990" rel="noopener ugc nofollow" target="_blank">这个基准</a>来测试方法大小优化。为了测试方法调用的内联缓存，我们可以在这里使用<a class="ae kz" href="https://gist.github.com/zivce/bbe743087f1da53e01912d15c15c2a46" rel="noopener ugc nofollow" target="_blank">的基准测试</a>。</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="2fd0" class="mi md iu bd mj mk nl mm mn mo nm mq mr ka nn kb mt kd no ke mv kg np kh mx my bi translated">作曲如何击败遗传</h1><p id="c49a" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">双态调用在内联缓存中获得命中。我们可以看到双压电晶片将手术次数提高了35%。</p><p id="29f0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">去皮巨形是什么意思？我们剥离方法调用。</em>做简单的<code class="fe nq nr ns ly b">instanceof</code>可以提高内联缓存的命中率。优化带来了大约30%的吞吐量提升。</p><p id="9dcf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">是什么让巨形调用表现不佳？内联缓存中的未命中。去vtable。</em>遍历vtable会降低执行速度。</p><p id="6724" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">多态性的主要问题是:</p><p id="eceb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">像Java这样的编程语言为多态性提供了便利，作为构建模块化和可重用软件的方法之一。这种语言选择自然是有代价的，因为没有对虚拟调用的硬件支持，因此运行时必须模拟这种行为。—阿列克谢·shipilёv</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nt"><img src="../Images/a710967d2eabdd62038ec183f87d42af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qC6iwE8W5nnTEpDq6d4-GQ.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">JDK 13 —双压电晶片优化</figcaption></figure></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><p id="2200" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">我们错过了什么？单态调用与双态调用。</em>单态性能比双态性能好4倍。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nu"><img src="../Images/0b6ba5fd0db41c4aae72f69ff50001ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AWYzBP591Jdx3_NbED4Y1g.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">JDK 13 — JMH结果—单态与双态</figcaption></figure><p id="0f50" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们关闭内联方法会发生什么？添加<code class="fe nq nr ns ly b">@CompilerControl(<em class="lw">DONT_INLINE</em>)</code>禁用内联。<strong class="lc iv">两种非在线方法的通量均下降。</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nv"><img src="../Images/d717872443f14f4866ba10faa93f9305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mS6Q-bcezl5SSvB9Arg1HA.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">JDK 13 — JMH结果—单态与双态—内联关闭</figcaption></figure><p id="515e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">时间改进呢？内联如何影响平均时间？关闭内联如何影响平均时间？</em> <strong class="lc iv"> <em class="lw">内联方法平均执行得更好。</em>T24】</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nv"><img src="../Images/67d8c4f1bc278f220da4ff19c9ae02c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q9sa07ykmN4etl44oMYPlg.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">JDK 13 — JMH结果—单态与双态—平均时间</figcaption></figure></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><p id="3a02" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">您能从基准测试中学到什么？内联方法执行得更好。多态方法比单态方法表现差。<em class="lw"> </em>我们可以学习作文为什么会打败遗传。<strong class="lc iv">继承给vtable带来了更多的方法，造成了性能瓶颈。争取使用更小的方法，这样可以内联，并且性能更好。</strong></em></p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="3245" class="mi md iu bd mj mk nl mm mn mo nm mq mr ka nn kb mt kd no ke mv kg np kh mx my bi translated">哪些方法不能内联？</h1><p id="ee1a" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><em class="lw">如何搜索非优化方法？</em>使用<code class="fe nq nr ns ly b"><a class="ae kz" href="https://github.com/AdoptOpenJDK/jitwatch/blob/master/jarScan.sh" rel="noopener ugc nofollow" target="_blank">jarScan</a></code>，限制为325字节。该限制因平台而异。这个极限是大方法的一个指标。这里有一个大方法的例子。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nw nx l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">JITWatch的jarScan</figcaption></figure><p id="f780" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">是什么导致了这些方法的出现？</em>以我为例，是Spring的Builder。大方法可以自动生成。<em class="lw">检查这些方法，如果可能的话进行改进。</em></p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="95ee" class="mi md iu bd mj mk nl mm mn mo nm mq mr ka nn kb mt kd no ke mv kg np kh mx my bi translated">大方法表现如何？</h1><p id="ef3c" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">让我们从头开始尝试我们的<a class="ae kz" href="https://medium.com/r?url=https%3A%2F%2Fgist.github.com%2Fzivce%2F73fe2cd7b5d2f4eec2d1996d0565a990" rel="noopener">基准</a>。<strong class="lc iv"> <em class="lw">较小的方法执行效果好26倍。</em>T9】</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nv"><img src="../Images/39b7ee110788b2d19a401994ff8c998a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BxeK5YfSqARj4C-5E2cKVA.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">JDK 13 — JMH结果—大方法优于小方法—吞吐量</figcaption></figure><p id="4d4c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们不内联更小的方法会怎么样？内联方法如何影响平均时间？ <strong class="lc iv"> <em class="lw">内联方法的性能比对应的方法高2倍。</em>T15】</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nv"><img src="../Images/f792e1b39186ebf9d521ac0a3dcf73b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l1OCRRizIche8IMeDL16Pw.png"/></div></div></figure></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><p id="3c96" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">我们能从这些基准测试中学到什么？尽一切可能让你的方法内联。创建更小的方法，减少项目中现有的大方法。吞吐量的表现取决于规模。小的内联方法平均快2倍。</em></p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="e4ce" class="mi md iu bd mj mk nl mm mn mo nm mq mr ka nn kb mt kd no ke mv kg np kh mx my bi translated">外卖食品</h1><p id="8285" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">更喜欢组合而不是继承。你有一个额外的理由这样做，那就是性能。我们的结论是单一调用点方法表现更好。使用继承会扩大vtable，这使得缓存方法变得困难。</p><p id="5f3e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽一切可能内联方法。创建小方法，减少项目的大方法，减少执行的时间。</p></div><div class="ab cl ne nf hy ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="in io ip iq ir"><h1 id="5899" class="mi md iu bd mj mk nl mm mn mo nm mq mr ka nn kb mt kd no ke mv kg np kh mx my bi translated">资源</h1><p id="3c75" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">Java性能针对Java 8、11及更高版本的调优和编程的深入建议— Scott Oaks</p><p id="52bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">优化Java提高JVM应用程序性能的实用技术</p><div class="ny nz gq gs oa ob"><a href="https://dzone.com/articles/too-fast-too-megamorphic-what" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fp"><div class="od ab oe cl cj of"><h2 class="bd iv gz z fq og fs ft oh fv fx it bi translated">太快，太大:什么影响了Java中方法调用的性能？- DZone性能</h2><div class="oi l"><h3 class="bd b gz z fq og fs ft oh fv fx dk translated">先说一个小故事。几周前，我提议对java核心库邮件列表进行修改，以覆盖…</h3></div><div class="oj l"><p class="bd b dl z fq og fs ft oh fv fx dk translated">dzone.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op kt ob"/></div></div></a></div><div class="ny nz gq gs oa ob"><a href="https://shipilev.net/blog/2015/black-magic-method-dispatch/#_preface" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fp"><div class="od ab oe cl cj of"><h2 class="bd iv gz z fq og fs ft oh fv fx it bi translated">(Java)方法调度的魔力</h2><div class="oi l"><h3 class="bd b gz z fq og fs ft oh fv fx dk translated">像Java这样的编程语言提供了子类型/多态性的工具，作为构建…</h3></div><div class="oj l"><p class="bd b dl z fq og fs ft oh fv fx dk translated">shipilev.net</p></div></div></div></a></div></div></div>    
</body>
</html>