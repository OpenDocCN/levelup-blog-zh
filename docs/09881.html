<html>
<head>
<title>A Crash Course on Concurrency &amp; Parallelism in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋并发与并行速成班</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-crash-course-on-concurrency-parallelism-in-go-8ea935c9b0f8?source=collection_archive---------0-----------------------#2021-09-27">https://levelup.gitconnected.com/a-crash-course-on-concurrency-parallelism-in-go-8ea935c9b0f8?source=collection_archive---------0-----------------------#2021-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9449" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Go例程、等待组、互斥锁、通道等等！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/94473642dcb4b7c05c60fdc6539ad5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YNeQkncg_vwb9wtG.png"/></div></div></figure><p id="54b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">作为2021年最受欢迎的编程语言之一，Go 正在继续上升。它的一个主要卖点是其简化的并发和并行方法。使用Go例程、通道和等待组之类的工具，可以让你以最小的复杂度创建速度极快的应用程序。</p><p id="b6f6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文旨在强调在Go中编写并发程序的一些最重要和最基本的组件。将有大量的代码片段和例子，但我鼓励你在评论中留下问题，如果需要的话，我会尽快回复你！</p><blockquote class="lz ma mb"><p id="7c6f" class="ku kv mc kw b kx ky ju kz la lb jx lc md le lf lg me li lj lk mf lm ln lo lp im bi translated">万一你需要复习一下，<strong class="kw iu">并发</strong>就是<strong class="kw iu">同时处理</strong>多件事情的过程。<strong class="kw iu">并行</strong>就是<strong class="kw iu">同时做</strong>多件事的过程。我喜欢把并发想象成带着许多任务物品去杂货店买鸡蛋、面粉、巧克力片等等。我可以以任何顺序获得这些项目，但是一些调度将允许我的并发性更快。并行性更进了一步——就好像我把我的朋友带到商店，他们帮我同时买到清单上的所有商品。</p></blockquote></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="0168" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">围棋套路</h1><p id="b4d9" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">如果您还不熟悉，线程是并行执行并发任务的一种常见方式。一个线程有自己的执行堆栈，需要固定数量的堆栈空间，通常大小为1MB。从代码中调用线程时，线程实际上是由宿主操作系统管理的。</p><p id="6e4c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> Go例程就像一个超级轻量级线程</strong>——它们开始时只有2KB大小，如果需要可以自动扩展。它们也有自己的执行堆栈，但它们由go运行时管理，因此Go例程将被调度给计算机CPU核心上的实际线程。</p><p id="e0e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个简单的例子。下面的程序运行10个任务，每个任务的执行时间为四分之一秒。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="46df" class="nr mo it nn b gy ns nt l nu nv">Executing task 1<br/>Executing task 2<br/>Executing task 3<br/>Executing task 4<br/>Executing task 5<br/>Executing task 6<br/>Executing task 7<br/>Executing task 8<br/>Executing task 9<br/>Executing task 10<br/>Total execution time: 2.5s</span></pre><p id="3773" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们使用<code class="fe nw nx ny nn b">go</code>关键字与<code class="fe nw nx ny nn b">main()</code>线程并行运行<code class="fe nw nx ny nn b">executeTask()</code>。如果您运行这个程序，您可能会惊讶地发现没有任务完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="2d44" class="nr mo it nn b gy ns nt l nu nv">Total execution time: 0s</span></pre><p id="db69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是因为<strong class="kw iu"> Go程序在后台运行。</strong>一旦主线程启动了对<code class="fe nw nx ny nn b">executeTask()</code>的所有10个调用，它就退出<code class="fe nw nx ny nn b">for</code>循环并打印总执行时间——Go例程没有时间运行！我们可以通过调用<code class="fe nw nx ny nn b">time.Sleep()</code>来解决这个问题，这样Go例程就有时间执行了。另外，请注意，在运行中调用Go例程时，不能保证<strong class="kw iu">的执行顺序。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="846c" class="nr mo it nn b gy ns nt l nu nv">Executing task 5<br/>Executing task 2<br/>Executing task 7<br/>Executing task 8<br/>Executing task 3<br/>Executing task 10<br/>Executing task 9<br/>Executing task 4<br/>Executing task 6<br/>Executing task 1<br/>Total execution time: 300ms</span></pre><p id="023b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，现在我们所有的任务都执行了，但是如果它们中的任何一个运行超过300毫秒，那么它们将永远没有机会在主线程退出之前完成。我们将在等待组部分继续讨论这个问题，但现在我们可以看到Go例程如何给我们的程序带来巨大的性能提升。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="9a8c" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">等待组</h1><p id="af50" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">等待组只是在继续程序执行之前等待一组go例程完成。我们不必调用一个限制性的<code class="fe nw nx ny nn b">time.Sleep()</code>来希望我们的Go例程能在这段时间内完成，我们可以使用等待组来指定我们想要在给定的时间框架内运行和完成多少Go例程。</p><p id="2c5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go的一个特点是它如何通过引用传递对象。如果您创建了一个等待组并试图通过值传递它，Go将创建一个对象的副本，并且您将不会引用同一个等待组。这就是为什么您必须始终将等待组作为指针引用，以便每个方法都从等待组的同一个实例开始操作。</p><p id="a352" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的例子中，我们在调用go例程之前，在for循环的每次迭代中调用<code class="fe nw nx ny nn b">wg.Add(1)</code>。你可以在循环之外调用<code class="fe nw nx ny nn b">wg.Add(10)</code>，但是最好在启动go例程之前加入一个等待组。这是因为在<code class="fe nw nx ny nn b">for</code>循环的情况下，随着代码的进展，你可能会有中断、继续等等。根据我们对<code class="fe nw nx ny nn b">wg.Add()</code>的预期数量，这可能导致运行的go例程数量不足。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5e07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nw nx ny nn b">executeTask()</code>中，我们现在有了语句<code class="fe nw nx ny nn b">defer wg.Done()</code>。这一点很重要，因为一旦函数退出，我们总是会调用<code class="fe nw nx ny nn b">wg.Done()</code>,即使是由于死机。添加到等待组和调用<code class="fe nw nx ny nn b">wg.Done()</code>的go例程的数量必须始终相等。最后，我们只需要调用<code class="fe nw nx ny nn b">wg.Wait()</code>，这样我们就不会继续主程序线程，直到我们所有的go例程都执行完毕。</p><p id="5a52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们运行这个程序，我们会发现基本上没有开销，因为我们在四分之一秒内完成了所有的任务！</p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="3b5c" class="nr mo it nn b gy ns nt l nu nv">Executing task 10<br/>Executing task 1<br/>Executing task 5<br/>Executing task 2<br/>Executing task 3<br/>Executing task 4<br/>Executing task 7<br/>Executing task 6<br/>Executing task 8<br/>Executing task 9<br/>Total execution time: 250ms</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="5182" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">用互斥锁共享内存</h1><p id="7b10" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">我们已经学习了如何使用<code class="fe nw nx ny nn b">WaitGroup.Wait()</code>有效地等待我们的go例程执行完毕，但是如果我们还想在多个go例程之间使用内存资源呢？我们可以使用互斥锁来实现这一点，这将防止在我们的go例程试图同时访问同一个共享资源时出现竞争情况。</p><p id="a2d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用一个模拟的例子来查询一个数据库，同时维护一个缓存。这很简单，但将展示我们如何使用互斥锁来编写线程安全的代码。</p><p id="840b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个例子——我们定义了一个缓存和一个数据库，它们都是整数到整数的简单映射。除此之外，我们有一个<code class="fe nw nx ny nn b">for</code>循环，它使用我们之前见过的相同等待组模式迭代100，000次，只是我们还将一个读写互斥<code class="fe nw nx ny nn b">sync.RWMutex</code>传递给了<code class="fe nw nx ny nn b">GetBook()</code>函数。接下来我们将实现<code class="fe nw nx ny nn b">GetBook()</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3d28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nw nx ny nn b">GetBook()</code>函数将首先检查全局缓存映射中的给定值。注意，当我们访问第6行的缓存时，我们如何使用读写互斥体来调用读锁和读解锁。如果缓存是空的，那么我们继续查询延迟300毫秒的数据库。我们再次锁定数据库和缓存，因为我们正在更新它们，这样我们的代码就不会出现混乱并导致任何争用情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="3e39" class="nr mo it nn b gy ns nt l nu nv">Total execution time: 319ms</span></pre><p id="ab9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个例子实际上并没有提供太多的性能提升，事实上互斥锁已经足够昂贵了，这实际上降低了我们的代码速度，如果我们只从数据库中读取，而完全排除缓存的话。主要的一点是展示我们如何在代码中使用互斥体来保护共享内存。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="5550" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用信道的通信</h1><p id="2447" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">随着应用程序变得越来越大，在多个go例程之间共享内存变得越来越困难。虽然使用互斥锁是一种可能的解决方案，但这也带来了性能上的折衷，并增加了代码的复杂性。通道是一种高层次的交流方式，可以很容易地用来提高围棋程序的能力，同时保持效率和可读性。</p><blockquote class="nz"><p id="c86e" class="oa ob it bd oc od oe of og oh oi lp dk translated">“不要通过分享记忆来交流，通过交流来分享记忆”——罗伯·派克</p></blockquote><p id="524b" class="pw-post-body-paragraph ku kv it kw b kx oj ju kz la ok jx lc ld ol lf lg lh om lj lk ll on ln lo lp im bi translated">让我们来看一个使用通道在两个go例程之间进行通信的例子。我们将使用两个匿名函数，这也是go例程的常见模式。我们使用特殊操作<code class="fe nw nx ny nn b">&lt;-</code>与通道的发送或接收接口。第一个函数是从通道接收，而第二个函数是向通道发送。这是一个有效的程序，可以成功执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="14b5" class="nr mo it nn b gy ns nt l nu nv">Sending message to channel</span></pre><p id="b31f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您也可以通过传递第二个参数在第3行给出通道的最大大小。此外，<strong class="kw iu">通道本质上是阻塞的</strong>——所以如果你试图在main函数中做同样的事情，你实际上不能执行这些相同的操作。下面的代码显示了两个导致通道死锁的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="24dd" class="nr mo it bd mp oo op dn mt oq or dp mx ld os ot mz lh ou ov nb ll ow ox nd oy bi translated">频道类型</h2><p id="346b" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">像Go中的大多数对象和方法一样，<strong class="kw iu">通道是强类型的</strong>。这包括通过信道发送的信息类型，以及该信道是否只能接收或发送信息。在下面的代码中，我们有两个将同一个通道作为参数的方法。函数<code class="fe nw nx ny nn b">sendToChannel()</code>无法从通道接收，因为我们已经将通道参数<code class="fe nw nx ny nn b">ch</code>定义为<code class="fe nw nx ny nn b">chan&lt;- string</code>。<code class="fe nw nx ny nn b">receiveFromChannel()</code>的逻辑相反。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="2e28" class="nr mo it bd mp oo op dn mt oq or dp mx ld os ot mz lh ou ov nb ll ow ox nd oy bi translated">通道和控制流</h2><p id="ac6b" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">您可以在不同类型的控制流语句中使用通道，以获得代码中的附加功能。<strong class="kw iu">要在if语句</strong>中使用通道，您可以检查消息和通道的状态，类似于检查map中的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><blockquote class="lz ma mb"><p id="2423" class="ku kv mc kw b kx ky ju kz la lb jx lc md le lf lg me li lj lk mf lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>您可以通过调用close(ch)来关闭通道。如果这样做，就不能发送到关闭的通道，因为这将导致死机。但是，您可以很容易地从一个关闭的通道接收任何剩余的消息。</p></blockquote><p id="6e86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">要在for循环中使用一个通道，</strong>如果我们打算遍历一个通道，我们必须确保正确地关闭它。现在，当我们发送到通道时，我们在<code class="fe nw nx ny nn b">for</code>循环中推送<code class="fe nw nx ny nn b">i</code>的当前值，并确保在我们完成后发送到<code class="fe nw nx ny nn b">close</code>通道。这将允许我们毫无问题地从信道迭代接收。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e3a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，<strong class="kw iu">为了同时与多个通道</strong>交互，我们可以使用<strong class="kw iu"> select语句。</strong>这个例子将在退出前等待两个消息通过两个独立的通道发送。注意我们甚至不需要使用任何等待组！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="2f9a" class="nr mo it nn b gy ns nt l nu nv">$ go run main.go<br/>received one<br/>received two</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="faba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我关于Go中并发性和并行性的速成课程到此结束。如果你喜欢这篇文章或有任何问题，请在下面留下评论！感谢阅读。</p></div></div>    
</body>
</html>