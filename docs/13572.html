<html>
<head>
<title>Ace Your Next React Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">赢得下一次React面试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ace-your-next-react-interview-9227fc8ca105?source=collection_archive---------1-----------------------#2022-09-17">https://levelup.gitconnected.com/ace-your-next-react-interview-9227fc8ca105?source=collection_archive---------1-----------------------#2022-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ac63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你需要知道的16个最重要的反应问题</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8460abba3760156d21d6e6a7fc43bab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pnV2mXi_ZUdIKxcUYnGUnA.png"/></div></div></figure><h2 id="ced4" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak">1)React是如何工作的？</strong></h2><p id="4fc5" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">React的工作原理是使用一个叫做虚拟DOM的概念。它不是直接更新/呈现真实的DOM，而是构造一个虚拟DOM，它是真实DOM的精确表示。如果有任何状态更改、道具更改或其他触发重新渲染的操作，React将首先更新VirtualDOM并进行协调。协调是将虚拟DOM与真实DOM进行比较的过程。然而，逐个节点地比较整个树的代价是昂贵的。因此，React使用启发式方法在两棵树之间进行快速比较，最后只更新实际DOM中发生变化的节点。这样，React就不会重新渲染整个DOM，这是非常昂贵的。</p><h2 id="b5b2" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak"> 2)什么是虚拟世界和影子世界？</strong></h2><p id="5c1c" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">VirtualDOM是真实DOM的精确表示，用于协调以快速高效地呈现。另一方面，ShadowDOM是DOM的另一个副本，用于本地化和隔离。使用ShadowDOM，每个模块的变量的作用域被声明，这也有助于本地化CSS或作用域CSS，其中CSS只应用于一个组件，从而减少CSS样式冲突。</p><h2 id="e654" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak"> 3)类vs功能组件？</strong></h2><p id="87bd" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">以前，类组件是创建具有状态和组件生命周期特性的组件的唯一方式。2019年，react最终发布了React挂钩，使这些功能能够用于功能组件中。但是，有一项功能是错误处理程序这一功能组件中不存在的。它只存在于使用<code class="fe ly lz ma mb b">componentDidCatch</code>和<code class="fe ly lz ma mb b">static getDerivedStateFromError</code>的类组件中。</p><h2 id="503c" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">4)为什么首选挂钩？挂钩的类型？</h2><p id="5ef8" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">由于引入了react挂钩，React团队建议使用带有挂钩的功能组件，原因如下:</p><ul class=""><li id="e0a8" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated"><strong class="js iu">类对于人类和机器来说都是令人困惑的</strong></li></ul><p id="2130" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Javascript基本上不是面向对象的编程语言。ES6通过利用称为原型继承的概念来模仿类特性。React团队也意识到了这一点，并表示类组件很难优化，例如，缩小现在工作得很好。此外，类组件也使热重装变得不可靠</p><ul class=""><li id="7d7b" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated"><strong class="js iu">类组件中更复杂的代码</strong></li></ul><p id="df41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在类组件中的组件生命周期方法中，许多逻辑被组合在一起，因为我们只允许声明一次生命周期方法。然而，在一个功能组件中，我们可以多次调用<code class="fe ly lz ma mb b">useEffect</code>来解耦和本地化逻辑，因为<code class="fe ly lz ma mb b">useEffect</code>充当3个组件生命周期:<code class="fe ly lz ma mb b">componentDidMount</code>、<code class="fe ly lz ma mb b">componentDidUpdate</code>和<code class="fe ly lz ma mb b">componentWillUnmount</code></p><ul class=""><li id="2cfb" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated"><strong class="js iu">代码更简洁&amp;学习曲线低</strong></li></ul><p id="fcc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们不需要理解OOP，比如<code class="fe ly lz ma mb b">this</code>关键字、方法绑定等等。这使得学习曲线变得更加容易。此外，它还减少了需要编写的代码量。因此，使代码更短、更简洁。</p><ul class=""><li id="20b3" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated"><strong class="js iu">难以重用的逻辑</strong></li></ul><p id="0ba0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在类组件中，不可能在组件之间重用逻辑。做到这一点的唯一方法是特设(高阶组件)，或通过渲染道具。但是，这些方式都不够灵活。在功能组件中，我们可以创建自己的定制钩子来重用许多组件中的逻辑</p><p id="e6c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">挂钩类型</strong></p><ul class=""><li id="7c7a" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated">使用状态</li><li id="67c5" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">使用效果</li><li id="f02f" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">使用上下文</li><li id="8bca" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">用户教育</li><li id="4e8e" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">使用回调</li><li id="161f" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">使用备忘录</li><li id="4025" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">useImperativeHandler</li><li id="1688" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">useRef</li><li id="9f25" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">使用过渡</li><li id="9401" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">useDeferredValue</li></ul></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h2 id="b077" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">5)受控组件与非受控组件？</h2><p id="3cc5" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">受控组件意味着所有动态数据值都在React状态下处理和存储。因此，如果我们想要更新它，我们需要附加一个直接更新状态的事件处理程序。</p><p id="76c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相反，一个不受控制的组件不依赖于任何状态。如果我们想获得数据值，我们可以利用<code class="fe ly lz ma mb b">ref</code>直接检查DOM节点值。请注意，不建议使用这种方法</p><p id="ab1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="5692" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak"> 6)组件生命周期的类型和流程？</strong></h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mz"><img src="../Images/5f2e2812bf6c44f5e298203c8b6f2dde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-JxKWia_Ic-hi1y8oWIUw.png"/></div></div></figure><p id="6a07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">综上:</strong>构造器→渲染→组件did mount→getDerivedStateFromProps→shouldcomponentdupdate→渲染→getsnapshowbeforupdate→组件DidUpdate →组件WillUnmount</p><p id="93f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在React钩子中，<code class="fe ly lz ma mb b">useEffect</code>只充当3个组件生命周期，因为它足以处理大多数情况:<code class="fe ly lz ma mb b">componentDidMount</code>、<code class="fe ly lz ma mb b">componentDidUpdate</code>、<code class="fe ly lz ma mb b">componentWillUnmount</code></p><h2 id="3f3c" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak"> 7)什么是代码分裂和树抖动？</strong></h2><p id="3b84" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">代码分割是一种将代码分割成多个块并缓慢加载的方法。这意味着，只有当代码被使用时，我们才获取必要的代码块并加载它。使用这种方法，应用程序的主包大小将会大大减少。但是，请注意，因为UI是延迟呈现的，所以加载回退必须向用户表明UI没有完成呈现。</p><p id="cb6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同时，树抖动是在捆绑过程中将应用程序分割成单独的多个块的过程。通过使用React的<code class="fe ly lz ma mb b">lazy</code>和<code class="fe ly lz ma mb b">suspense</code>特性，可以利用代码分割和树抖动。</p><h2 id="89c9" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak"> 8) Redux vs语境？context在取代Redux吗？</strong></h2><p id="6a6e" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">Context和redux的目的相同，都是为了使许多组件之间的状态管理更加容易。但是，必须注意，redux是为大规模应用程序创建的，在这种应用程序中，状态经常被更新。Redux足够聪明，只在被选择和被使用的状态被更新时才触发渲染。同时，上下文没有这种优化。当上下文的1个值被更新时，订阅该上下文的每个组件也将被更新，即使它不使用更新的值。因此，上下文更适合存储静态数据，如应用程序主题、用户数据等。</p><h2 id="7711" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak"> 9)如何提高React性能？</strong></h2><ul class=""><li id="222d" class="mc md it js b jt lt jx lu kb na kf nb kj nc kn mh mi mj mk bi translated">使用<code class="fe ly lz ma mb b">PureComponent</code>或<code class="fe ly lz ma mb b">shouldComponentUpdate</code>或<code class="fe ly lz ma mb b">React.memo</code>指定组件何时应该重新渲染</li><li id="81ef" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">使用<code class="fe ly lz ma mb b">useCallback</code>或<code class="fe ly lz ma mb b">useMemo</code>来记忆函数声明或繁重的计算</li><li id="b564" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">如果呈现一个巨大的列表，考虑使用虚拟化列表，其中只呈现屏幕上显示的项目</li><li id="58b0" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">当组件(如<code class="fe ly lz ma mb b">setTimeout</code>或<code class="fe ly lz ma mb b">setInterval</code>)被卸载时，总是清理任何异步任务，以减少内存消耗</li><li id="5c80" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">对于任何不希望导致任何重新呈现的动态数据，将该数据存储在ref中，而不是state中</li><li id="ccde" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">启用代码拆分的惰性加载组件</li><li id="e2e7" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">依赖性优化，避免直接从根导入，例如:将<code class="fe ly lz ma mb b">import {get} from 'lodash</code>改为<code class="fe ly lz ma mb b">import get from 'lodash/get'</code></li><li id="0bd1" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">避免内联函数，因为它总是在每次组件重新呈现时重新声明</li><li id="d326" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">避免分散道具，因为道具可以随时改变，只使用你需要的道具。</li><li id="a03c" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">根据要求优化和定制webpack配置</li><li id="8b98" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">使用<code class="fe ly lz ma mb b">why-did-you-render</code>库或React profiler检查组件重新渲染</li></ul></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h2 id="6679" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak"> 10)什么是PureComponent、memo、useMemo、useCallback？</strong></h2><p id="a986" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">类组件中的<code class="fe ly lz ma mb b">PureComponent</code>或功能组件中的<code class="fe ly lz ma mb b">memo</code>用于进行前一状态与下一状态、前一属性与下一属性之间的浅层比较。因此，仅当状态或props值发生变化时，才会呈现组件。</p><p id="2b44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ly lz ma mb b">useCallback</code>用于记忆功能组件中的函数声明，因此相同的函数在重新渲染时不会被重新声明。<code class="fe ly lz ma mb b">useMemo</code>类似于<code class="fe ly lz ma mb b">useCallback</code>,但是它执行函数并存储返回值。它用于保存一些繁重计算返回的值。</p><h2 id="7fe7" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak"> 11)客户端vs服务器端渲染？</strong></h2><p id="5ec8" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">React是一个客户端渲染SPA(单页面应用程序)，这意味着服务器将只返回一个空白的HTML模板，javascript代码将在客户端运行，以指定渲染页面和填充HTML的内容和方式。</p><p id="0f5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">优点</strong>:</p><ul class=""><li id="9e25" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated">不需要主机服务器，静态主机如github page、netlify等就足够了</li><li id="acee" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">在初始加载之后，速度会很快，因为大部分JS包已经传递给了客户机。</li></ul><p id="024d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">缺点</strong>:</p><ul class=""><li id="12e3" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated">对SEO不好，因为服务器总是返回一个空的HTML模板。</li><li id="c5d4" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">取决于设备的渲染能力，因为一切都在客户端进行渲染。</li><li id="3a8a" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">初始加载很慢，因为大的JS包是从服务器传递过来的。我们需要显示加载微调器，以等待渲染完成。</li></ul><p id="0c15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同时，<code class="fe ly lz ma mb b">NextJs</code>是著名的服务器端渲染react应用。这里，服务器运行一些javascript代码来构造HTML模板并将其传递给客户机。客户端需要做的只是运行一些JS代码来将事件处理程序或监听器附加到现有的标记上</p><p id="8035" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">优点</strong>:</p><ul class=""><li id="22f4" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated">对SEO有好处，因为我们可以管理哪些HTML数据传递给客户端。</li><li id="55e1" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">不依赖于客户端设备，因为服务器是呈现HTML的一方</li><li id="8fd7" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">初始加载速度很快，因为服务器不需要传递整个应用捆绑包，服务器可以同时传递数据，从而消除了客户端的额外API调用。</li></ul><p id="209b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">缺点</strong>:</p><ul class=""><li id="0aa8" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated">需要专用的web服务器来处理客户端请求</li><li id="6205" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">每个页面导航都需要调用服务器来获取页面标记</li></ul></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h2 id="8dbe" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak"> 12)门户和片段的用例？</strong></h2><p id="bbe6" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">Fragment用于删除任何不必要的DOM节点，因为以前组件只能返回1个节点。因此，我们经常将一个组件包装在一个冗余的<code class="fe ly lz ma mb b">&lt;div&gt;</code>或<code class="fe ly lz ma mb b">&lt;span&gt;</code>中。</p><p id="635a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Portal用于转义父层次结构布局，我们可以将元素放在任何DOM节点中。Portal通常用于呈现模式、工具提示和任何弹出窗口。</p><h2 id="37bb" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak"> 13)为什么我们需要使用useRef？什么是forwardRef？</strong></h2><p id="af52" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">Ref用于存储任何不想引起任何重新渲染的动态数据，通常用于直接访问HTML DOM节点，类似于<code class="fe ly lz ma mb b">document.getElementById</code>。</p><p id="68b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ForwardRef是一个将引用从父组件转发到子组件的功能。通常，如果父组件想要访问数据或调用子组件中的函数，则使用forwardRef。</p><h2 id="7f58" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak"> 14)什么是渲染道具？</strong></h2><p id="4c85" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">render props是一个在自定义组件中传递渲染方法或函数作为道具的概念。Render props是一种常见技术，用于创建带有自定义UI呈现的可重用组件，如表格、列表等。</p><p id="2bfd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如</p><pre class="kp kq kr ks gt nd mb ne nf aw ng bi"><span id="781e" class="la lb it mb b gy nh ni l nj nk">&lt;CustomList<br/>    items={[1,2,3]}<br/>    renderItem={item =&gt; &lt;li&gt;{item}&lt;/li&gt;}<br/>/&gt;</span></pre><h2 id="423c" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak"> 15)什么是HOC(高阶分量)？还推荐吗？</strong></h2><p id="c3d8" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">HOC是传递公共逻辑或属性的组件包装器。HOC是类组件中的一种常见方法。然而，在一个功能组件中，定制钩子现在更倾向于重用一些逻辑或属性。</p><h2 id="f97c" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated"><strong class="ak"> 16)为什么渲染组件列表时我们需要</strong> <code class="fe ly lz ma mb b"><strong class="ak">key</strong></code> <strong class="ak">？</strong></h2><p id="4d32" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">React使用键来确定重新呈现列表的最有效方式。</p><p id="046d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我们有一个键为<code class="fe ly lz ma mb b">[1,2,3,4,5]</code>的组件列表，假设我们想在键6的中间添加一个新组件，那么键现在是<code class="fe ly lz ma mb b">[1,2,6,3,4,5]</code>。只要看着这个键，React就会移位，不会用<code class="fe ly lz ma mb b">[3,4,5]</code>的键重新渲染元素，把元素<code class="fe ly lz ma mb b">6</code>放在中间。这就是为什么键必须是唯一的。</p><p id="7323" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设我们使用索引作为键。中间放一个新组件后，按键会是<code class="fe ly lz ma mb b">[1,2,3,4,5,6]</code>。React将检测组件<code class="fe ly lz ma mb b">[3,4,5,6]</code>是否不同，并重新呈现列表中的4个项目。因此，这不是有效的</p><h2 id="8f6e" class="la lb it bd lc ld le dn lf lg lh dp li kb lj lk ll kf lm ln lo kj lp lq lr ls bi translated">实用问题</h2><p id="5634" class="pw-post-body-paragraph jq jr it js b jt lt jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj lx kl km kn im bi translated">很多面试问题会要求你编写一些可重用的组件，比如Modal、Toast message、自定义列表或表格等。</p><p id="5cfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在一些高级的react面试中，他们会要求你编写或设计俄罗斯方块或贪吃蛇游戏之类的游戏。你需要自己去探索。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="c6ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">React面试基础到此为止！如果你想学习React更多，请查看我的<a class="ae nl" href="https://andreassujono.medium.com/mastering-react-best-practices-2021-part-1-3-89203e5ad013" rel="noopener"> React mastering系列</a>，我在其中涵盖了React的几乎所有特性。</p><p id="79ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nm">感谢您的阅读。我会每两周发布一篇新文章(希望如此)。它们大多是我的软件工程师经历和我对社会生活的想法。如果你对我接下来应该写什么有任何问题或建议，请不要犹豫，把它们放在评论区。如果你喜欢我的帖子，你可以在下面的提示框中关注甚至给我买咖啡。感谢</em></p></div></div>    
</body>
</html>