<html>
<head>
<title>How to Write an LCD Driver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写LCD驱动程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-an-lcd-driver-ccee1c89106c?source=collection_archive---------4-----------------------#2022-04-11">https://levelup.gitconnected.com/how-to-write-an-lcd-driver-ccee1c89106c?source=collection_archive---------4-----------------------#2022-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ce7316d3b48e07168ca22b3607e42808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QF9bo1mNRdYiT8-p2rz8Qw.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="5505" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">为DFR0555 1602 LCD显示器设置C库。</h2></div><p id="7d96" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">作为一名嵌入式程序员，您通常必须处理各种各样的物理设备，尽管有时您可能会找到可用的库来使用软件驱动它们，但大多数情况下并非如此。根据我的经验，我通常从开源的Arduino库开始，但是很快意识到我需要对底层机器有更多的控制，所以我拥抱我的键盘，创建一个。文件，并开始创建我自己的驱动程序。</p><h2 id="e79c" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><em class="mf">今天我很高兴和你分享一个方法<br/>来为I2C设备快速开发极简驱动程序！</em></h2><p id="7df1" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">为了使解释更容易理解，我们将利用以下案例研究:让DFR0555 LCD显示器与恩智浦的<a class="ae ml" href="https://www.nxp.com/design/development-boards/freedom-development-boards/mcu-boards/freedom-development-platform-for-kinetis-kl14-kl15-kl24-kl25-mcus:FRDM-KL25Z" rel="noopener ugc nofollow" target="_blank"> FRDM-KL25Z </a>开发板交互，该开发板基于ARM Cortex-M0+微控制器，并与许多Arduino shields兼容。</p><h2 id="07be" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><em class="mf">但是，请注意，这里的讨论非常笼统，可以使用任何潜在的微控制器。</em></h2><h2 id="aaf0" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated">好吧，我们继续吧！</h2></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="3ebf" class="mt ln jb bd lo mu mv mw lr mx my mz lu kh na ki lx kk nb kl ma kn nc ko md nd bi translated">第一步:文件和代码</h1><p id="c3b7" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">首先，让我们对我们正在处理的设备类型有一个概念。</p><p id="0eff" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">DFR0555是一款16x2 LCD显示器，集成了背光控制器。<br/>从DFRobot网站，我们可以很容易地下载<a class="ae ml" href="https://dfimg.dfrobot.com/nobody/wiki/ee1c5bd150fc6b78f8cb8e8306898ab9.pdf" rel="noopener ugc nofollow" target="_blank">数据表</a>并发现显示器是基于<a class="ae ml" href="https://www.newhavendisplay.com/resources_dataFiles/datasheets/LCDs/AiP31068.pdf" rel="noopener ugc nofollow" target="_blank"> AIP31068L </a>控制器。</p><p id="4180" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">也许更有趣的是，DFRobot还提供了一个Arduino库，用于快速连接他们卖给我们的设备。<br/>有人可能会合理地认为FRDM板与Arduino软件API不兼容。但是这里有一个窍门:使用任何与你正在处理的那块有点类似的Arduino兼容板，并在那里运行示例代码。</p><p id="f1b1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在我的例子中，我使用了STMicroelectronics的可爱的<a class="ae ml" href="https://www.st.com/en/microcontrollers-microprocessors/stm32f401re.html" rel="noopener ugc nofollow" target="_blank"> STM32F401RE </a>作为开发板来运行<a class="ae ml" href="https://github.com/DFRobotdl/DFRobot_LCD/blob/master/examples/Blink/Blink.ino" rel="noopener ugc nofollow" target="_blank"> Blink示例</a>。显然，如果示例代码可以为您的目标编译和运行，您就不需要替代板。</p><p id="73b1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">此时，我们可以利用板载调试器来单步调试库代码:通过这种方式，我们可以了解哪些字节通过I2C从微控制器发送到LCD显示器。<br/>例如，函数<em class="ne">df robot _ rgblcd 1602::init()</em>启动通信，向地址为<em class="ne"> </em> 0x3e的从机发送字节0x80 0x28。</p><p id="c211" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">查看数据手册，我们发现以下情况:</p><ol class=""><li id="b53c" class="nf ng jb ks b kt ku kw kx kz nh ld ni lh nj ll nk nl nm nn bi translated">0x3e是LCD显示地址</li><li id="b087" class="nf ng jb ks b kt no kw np kz nq ld nr lh ns ll nk nl nm nn bi translated">0x28是代表“功能集:以2行模式显示”的命令</li><li id="67b5" class="nf ng jb ks b kt no kw np kz nq ld nr lh ns ll nk nl nm nn bi translated">在向显示器发送任何命令之前，我们必须发出0x80控制字节</li></ol><figure class="nu nv nw nx gt is gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/dcd2c60e2e4335b53e8e58d26bd338db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*Em95TiuJ7dETYmGmHVstmA.png"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">AiP31068数据表，表3 —指令表</figcaption></figure><p id="bf9f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">部分摘要</strong> : <br/>从逻辑上讲，你会在拥有代码之前寻找文档，但通常反过来做更容易。相反，运行示例代码并使用调试器逐句通过库指令。然后利用数据表进行双重检查，看看操作是否一致。</p><p id="a2d5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下一步，我们将通过分析数字信号，找出整个通信过程的确切工作原理。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="7b16" class="mt ln jb bd lo mu mv mw lr mx my mz lu kh na ki lx kk nb kl ma kn nc ko md nd bi translated">第二步:逻辑级分析</h1><p id="1779" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">使用调试器来分析整个I2C通信是乏味的。相反，你最好把大约10美元放入逻辑电平分析仪，这样可以节省几个小时的时间:这是一种硬件，能够沿着一根或多根导线对0和1进行采样。</p><p id="4f59" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您可以将该工具连接到I2C外设的SCL和SDA线，并使用<a class="ae ml" href="https://sigrok.org/wiki/PulseView" rel="noopener ugc nofollow" target="_blank"> Pulseview </a>检查发生了什么。</p><figure class="nu nv nw nx gt is gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/0864a6a945e70cc95864c3a61684cb4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*FB4UR-a4xCJj2YE-hKCmVA.jpeg"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">逻辑电平分析器</figcaption></figure><p id="2c77" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是我通过运行之前的草图得到的一部分。从时序图中，我可以推断出以下情况:</p><ol class=""><li id="c6c9" class="nf ng jb ks b kt ku kw kx kz nh ld ni lh nj ll nk nl nm nn bi translated">I2C大师(即。STM32)开始向从机0x3e(即DFR0555)</li><li id="dcbf" class="nf ng jb ks b kt no kw np kz nq ld nr lh ns ll nk nl nm nn bi translated">主机在总线上写入几个字节</li><li id="6ec5" class="nf ng jb ks b kt no kw np kz nq ld nr lh ns ll nk nl nm nn bi translated">从机应答每个字节</li><li id="805b" class="nf ng jb ks b kt no kw np kz nq ld nr lh ns ll nk nl nm nn bi translated">通信结束时，主机发出停止条件</li></ol><figure class="nu nv nw nx gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi od"><img src="../Images/f50793d8e319af03537f6bb0b5c124f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yil5v5h-XAjiEG6wJwTumw.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">Pulseview的外观— SDA和SCL线连接到CH0、CH1 (1)，软件解码消息(2)</figcaption></figure><p id="a448" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在我们有了关于如何从零开始构建I2C交易的精确信息。<br/>但是在编写任何库代码之前，让我们手动复制通信<br/>。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="8693" class="mt ln jb bd lo mu mv mw lr mx my mz lu kh na ki lx kk nb kl ma kn nc ko md nd bi translated">第三步:I2C控制台</h1><p id="f3f6" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">找到一个现有的，或者实现你自己的最低限度的，用于I2C通过UART通信的固件:它基本上允许你在串行监视器上键入一串字节，微控制器将通过I2C数据总线中继它们。为了简单起见，我把它叫做<em class="ne"> I2C控制台</em>。</p><p id="507f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">利用使用逻辑分析器捕获的会话，让我们提取发送到LCD模块的所有字节。这里有一个小的回顾。</p><figure class="nu nv nw nx gt is gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/ef31db3b0b8a46757d0a074d2f6250d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*f1fshvHfmPFkZ00tfuGKag.png"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">DFR0555初始化和字符显示命令</figcaption></figure><p id="71b1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在，使用I2C控制台尝试命令序列。作为一个例子，下面是当我键入命令来显示几个字符时，模块的行为。</p><figure class="nu nv nw nx gt is gh gi paragraph-image"><div class="gh gi of"><img src="../Images/9bef6e7fb0d151fa4cc24472e218f85b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/1*yYArSW2MNUanCkEIPS37lA.gif"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">使用I2C控制台显示“你好！”在液晶屏上</figcaption></figure><p id="5612" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">好了，无聊的部分结束了🤓是时候用一些嵌入式编码来弄脏我们的手了！</p><p id="1e14" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">边注:</strong> <a class="ae ml" href="https://github.com/tontonialberto/arm-programming/tree/main/FRDM-KL25Z/i2c-console" rel="noopener ugc nofollow" target="_blank">如果你想获得灵感，这是我为FRDM板设计的I2C控制台</a>版本。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="db98" class="mt ln jb bd lo mu mv mw lr mx my mz lu kh na ki lx kk nb kl ma kn nc ko md nd bi translated">第四步:自动化！</h1><p id="da54" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">如果您在前面的步骤中使用了所谓的替代电路板，那么现在是时候回到您的实际目标微控制器了。<br/>我不会在这里讨论实现的细节，因为我的架构可能与你的不同。</p><p id="b419" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">尽管如此，你可以看看GitHub 上的<a class="ae ml" href="https://github.com/tontonialberto/arm-programming/tree/main/FRDM-KL25Z/i2c-master-dfr0555" rel="noopener ugc nofollow" target="_blank">我的代码，这是一个现成的应用程序，它使用FRDM-KL25Z板在显示器上写字符。请随意将它作为您项目的灵感！</a></p><p id="567d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我用的是普通的C语言，代码是用Keil uv ision 5<a class="ae ml" href="https://www2.keil.com/mdk5/uvision/" rel="noopener ugc nofollow" target="_blank">开发、编译并上传到主板上的。</a></p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="b4d5" class="mt ln jb bd lo mu mv mw lr mx my mz lu kh na ki lx kk nb kl ma kn nc ko md nd bi translated">结论</h1><p id="96a8" class="pw-post-body-paragraph kq kr jb ks b kt mg kc kv kw mh kf ky kz mi lb lc ld mj lf lg lh mk lj lk ll ij bi translated">今天到此为止！我希望你喜欢这次讨论。对于任何反馈，或者如果你有任何不清楚的地方，请随时与我联系。我很乐意澄清😊</p><p id="a568" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">非常感谢您的关注。下次见！</p></div></div>    
</body>
</html>