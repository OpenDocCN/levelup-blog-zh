<html>
<head>
<title>Python Sets: A Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python集:完整指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-sets-a-complete-guide-dd4233a4c825?source=collection_archive---------16-----------------------#2022-10-03">https://levelup.gitconnected.com/python-sets-a-complete-guide-dd4233a4c825?source=collection_archive---------16-----------------------#2022-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7b10e3b673cd3b63bd2a95f0fb47c2a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXLUL-5Ma_AzB02hZWjy0w.png"/></div></div></figure><p id="aff6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">python中的集合提供了一种方法来创建一组唯一的无重复的无序项。它们的主要用例是检查一个项目是否存在于一组项目中，这在许多不同的情况下都很有用。</p><p id="8dec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">创建一个集合非常容易，有点类似于我们在Python中定义列表的<a class="ae kz" href="https://fjolt.com/article/python-lists" rel="noopener ugc nofollow" target="_blank">。唯一的区别，是我们使用<code class="fe la lb lc ld b">{}</code>花括号来定义一个集合:</a></p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="d1b4" class="lm ln it ld b gy lo lp l lq lr">mySet = { "some", "set", "of", "items" }</span></pre><p id="fa6a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">也可以使用<code class="fe la lb lc ld b">set()</code>功能从列表中定义集合:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="445b" class="lm ln it ld b gy lo lp l lq lr">mySet = set([ 'some', 'list', 'becoming', 'a', 'set' ])<br/># set is { 'some', 'list', 'becoming', 'a', 'set' }</span></pre><p id="8493" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您也可以使用相同的<code class="fe la lb lc ld b">set()</code>功能从字符串创建集合:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="4024" class="lm ln it ld b gy lo lp l lq lr">mySet = set('somestring')<br/># set is { 's', 'o', 'm', 'e', 's', 't', 'r', 'i', 'n', 'g' }</span></pre><p id="582a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与其他可计数类型的数据一样，我们也可以使用<code class="fe la lb lc ld b">len</code>来获得一个集合的长度:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="965c" class="lm ln it ld b gy lo lp l lq lr">let mySet = set([ 'some', 'list', 'becoming', 'a', 'set' ])<br/>print(len(mySet)) # Returns 5</span></pre><p id="a1a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们还可以使用<code class="fe la lb lc ld b">frozenset()</code>函数定义所谓的<code class="fe la lb lc ld b">frozenset</code>，它只是一个具有固定值的集合的不可变、不可更改的版本:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="5e40" class="lm ln it ld b gy lo lp l lq lr">let mySet = frozenset([ 'some', 'list', 'becoming', 'a', 'set' ])</span></pre><h1 id="7608" class="ls ln it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">组合和相交集合</h1><p id="84dc" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">我们可以使用<code class="fe la lb lc ld b">|</code>操作符将两个集合合并成一个集合。如果一个项目同时存在于两个集合中，只有一个副本会被带过来。这里有一个例子，我们结合了两个集合:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="3cba" class="lm ln it ld b gy lo lp l lq lr">mySet = { "set", "one" }<br/>myNewSet = { "set", "two" }</span><span id="c128" class="lm ln it ld b gy mu lp l lq lr">combinedSet = mySet | myNewSet<br/>print(combinedSet) # { "set", "one", "two" }</span></pre><p id="15c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用<code class="fe la lb lc ld b">&amp;</code>使<strong class="kd iu">集合与</strong>集合相交。这意味着我们将最终得到一个集合，其中的项目只是同时存在于两者中的项目。使用相同的示例，我们因此可以创建一个仅包含项目<code class="fe la lb lc ld b">set</code>的集合:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="20c6" class="lm ln it ld b gy lo lp l lq lr">mySet = { "set", "one" }<br/>myNewSet = { "set", "two" }</span><span id="934b" class="lm ln it ld b gy mu lp l lq lr">combinedSet = mySet &amp; myNewSet<br/>print(combinedSet) # { "set" }</span></pre><p id="5c69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以组合集合的另一种方法是通过减法，最后得到一个新的集合，该集合只包含当移除两个集合中的任何公共项时剩下的项。例如，下面的新集合只有一个项目— <code class="fe la lb lc ld b">cool</code>，因为<code class="fe la lb lc ld b">mySet</code>和<code class="fe la lb lc ld b">mySecondSet</code>都包含“集合”和“一”:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="ce70" class="lm ln it ld b gy lo lp l lq lr">mySet = { "set", "one", "cool" }<br/>mySecondSet = { "set", "one" }<br/>myNewSet = mySet - mySecondSet<br/>print(myNewSet) # { "cool" }</span></pre><p id="ab80" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们可以做所谓的<strong class="kd iu">对称差</strong>，我们最终得到一个集合，其中包含在<code class="fe la lb lc ld b">mySet</code>或<code class="fe la lb lc ld b">mySecondSet</code>中找到的项目，但不是两者都有:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="b573" class="lm ln it ld b gy lo lp l lq lr">mySet = { "set", "one", "cool", "nice" }<br/>mySecondSet = { "set", "one", "friendly" }<br/>myNewSet = mySet ^ mySecondSet<br/>print(myNewSet) # { "cool", "nice", "friendly" }</span></pre><h1 id="96b3" class="ls ln it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">使用集合测试成员资格</h1><p id="e374" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">集合的主要用例是<strong class="kd iu">测试成员关系</strong>，查看集合中是否存在某个项目。我们可以使用<code class="fe la lb lc ld b">in</code>和<code class="fe la lb lc ld b">not in</code>关键字来实现。让我们看一个例子。如果我们想检查<code class="fe la lb lc ld b">orange</code>是否在我们的<code class="fe la lb lc ld b">fruits</code>集合中，我们使用<code class="fe la lb lc ld b">in</code>:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="532a" class="lm ln it ld b gy lo lp l lq lr">fruits = { "orange", "apple", "peach" }<br/>print("orange" in fruits) # True</span></pre><p id="8bb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者，如果我们想检查橙色是否不在<code class="fe la lb lc ld b">fruits</code>中，我们使用<code class="fe la lb lc ld b">not in</code>:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="b389" class="lm ln it ld b gy lo lp l lq lr">fruits = { "orange", "apple", "peach" }<br/>print("orange" not in fruits) # False</span></pre><h1 id="a524" class="ls ln it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">制作器械包的副本</h1><p id="e469" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">与列表一样，我们可以使用附加到所有集合的<code class="fe la lb lc ld b">copy()</code>方法来复制一个集合。这不会改变该值，但会改变内存中该新集合的引用。这意味着，如果使用<code class="fe la lb lc ld b">==</code>通过值进行比较，集合将是相同的，当使用<code class="fe la lb lc ld b">is</code>通过引用进行比较时，集合将不是相同的:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="00ed" class="lm ln it ld b gy lo lp l lq lr">mySet = { "set", "one" }<br/>mySetCopy = mySet.copy();</span><span id="c2aa" class="lm ln it ld b gy mu lp l lq lr">print(mySet == mySetCopy) # True<br/>print(mySet is mySetCopy) # False</span></pre><h1 id="4cf9" class="ls ln it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">测试超集和子集</h1><p id="3410" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">集合的另一个真正有用的用例是检查一个集合是否是另一个集合的超集或子集的能力(有点绕口令):</p><ul class=""><li id="c994" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">子集将是完全包含在另一个集合中的集合。</li><li id="2b79" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">超集将是完全包含另一个集的成员的集。</li></ul><h1 id="7175" class="ls ln it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">在Python中检查子集</h1><p id="37a7" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">假设我们有两组，如下所示:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="0943" class="lm ln it ld b gy lo lp l lq lr">mySet = { "set", "one", "two" }<br/>mySecondSet = { "set", "one" }</span></pre><p id="3909" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe la lb lc ld b">mySecondSet</code>实际上是<code class="fe la lb lc ld b">mySet</code>的子集，因为它完全包含在<code class="fe la lb lc ld b">mySet</code>中。我们可以使用<code class="fe la lb lc ld b">&lt;=</code>操作符对此进行测试:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="2cd0" class="lm ln it ld b gy lo lp l lq lr">mySet = { "set", "one", "two" }<br/>mySecondSet = { "set", "one" }</span><span id="3b63" class="lm ln it ld b gy mu lp l lq lr">print(mySecondSet &lt;= mySet) # True</span></pre><p id="96db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还可以使用<code class="fe la lb lc ld b">&lt;</code>操作符来检查<strong class="kd iu">的真实子集</strong>，这意味着<code class="fe la lb lc ld b">mySecondSet</code>包含在<code class="fe la lb lc ld b">mySet</code>中，但其值不等于<code class="fe la lb lc ld b">mySet</code>。在上面的例子中，这也是正确的:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="8cd4" class="lm ln it ld b gy lo lp l lq lr">mySet = { "set", "one", "two" }<br/>mySecondSet = { "set", "one" }</span><span id="9808" class="lm ln it ld b gy mu lp l lq lr">print(mySecondSet &lt; mySet) # True</span></pre><p id="7631" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然而，在下面的例子中，<code class="fe la lb lc ld b">mySecondSet</code>确实是<code class="fe la lb lc ld b">mySet</code>的子集，但它不是<strong class="kd iu">的真实子集</strong>，因为两者的值相等:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="a884" class="lm ln it ld b gy lo lp l lq lr">mySet = { "set", "one", }<br/>mySecondSet = { "set", "one" }</span><span id="8dc6" class="lm ln it ld b gy mu lp l lq lr">print(mySecondSet &lt;= mySet) # True<br/>print(mySecondSet &lt; mySet) # False</span></pre><h1 id="18cc" class="ls ln it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">在Python中检查超集</h1><p id="8cc9" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">超集的工作方式与子集完全相同，唯一的区别是箭头方向相反。因此<code class="fe la lb lc ld b">&gt;</code>用于检查<strong class="kd iu">真的</strong>超集，而<code class="fe la lb lc ld b">&gt;=</code>用于检查任何超集。使用我们之前的例子，<code class="fe la lb lc ld b">mySet</code>是<code class="fe la lb lc ld b">mySecondSet</code>的超集，因此下面返回true:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="09b8" class="lm ln it ld b gy lo lp l lq lr">mySet = { "set", "one", "two" }<br/>mySecondSet = { "set", "one" }</span><span id="47b6" class="lm ln it ld b gy mu lp l lq lr">print(mySet &gt; mySecondSet) # True</span></pre><p id="d127" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，虽然mySet是下面的<code class="fe la lb lc ld b">mySeconSet</code>的超集，但它不是真正的超集，所以<code class="fe la lb lc ld b">&gt;</code>不返回true，而<code class="fe la lb lc ld b">&gt;=</code>返回:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="fbb5" class="lm ln it ld b gy lo lp l lq lr">mySet = { "set", "one", }<br/>mySecondSet = { "set", "one" }</span><span id="7e19" class="lm ln it ld b gy mu lp l lq lr">print(mySet &gt;= mySecondSet) # True<br/>print(mySet &gt; mySecondSet) # False</span></pre><h1 id="05c4" class="ls ln it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">在Python中测试两个集合是否有完全不同的值</h1><p id="cdc8" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">有时，你还会想检查两套在相互比较时是否完全是原装的。例如，<code class="fe la lb lc ld b">{ "one", "two" }</code>和<code class="fe la lb lc ld b">{ "three", "four" }</code>是两个相互比较时具有唯一值的集合。在Python中，<code class="fe la lb lc ld b">isdisjoint</code>函数允许我们完成这个任务:</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="29f6" class="lm ln it ld b gy lo lp l lq lr">mySet = { "one", "two", }<br/>mySecondSet = { "three", "four" }</span><span id="094f" class="lm ln it ld b gy mu lp l lq lr">print(mySet.isdisjoint(mySecondSet)) # True</span></pre><h1 id="f065" class="ls ln it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">其他设置方法</h1><p id="a23c" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">虽然我们到目前为止讨论的所有内容都适用于<code class="fe la lb lc ld b">frozenset</code>和<code class="fe la lb lc ld b">set</code> s，但是还有一些其他方法适用于<code class="fe la lb lc ld b">set</code> s，允许我们改变它们的值。这些是:</p><ul class=""><li id="8df3" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated"><code class="fe la lb lc ld b">set.add('item')</code> -向器械包添加一个物品。</li><li id="4b71" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><code class="fe la lb lc ld b">set.remove('item')</code> -从集合中删除一个项目。</li><li id="14b4" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><code class="fe la lb lc ld b">set.update(newSet)</code> -将<code class="fe la lb lc ld b">newSet</code>中的所有项目添加到原来的<code class="fe la lb lc ld b">set</code>中。这也可以写成<code class="fe la lb lc ld b">set |= newSet</code></li><li id="5769" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><code class="fe la lb lc ld b">set.clear()</code> -删除器械包中的所有物品</li><li id="c546" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><code class="fe la lb lc ld b">set.pop(4)</code> -删除集合中的第4个项目，如果没有指定数字，则删除最后一个项目</li><li id="2b78" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><code class="fe la lb lc ld b">set.intersection_update(newSet)</code> -仅保留在<code class="fe la lb lc ld b">set</code>和<code class="fe la lb lc ld b">newSet</code>中找到的项目。也可以写成<code class="fe la lb lc ld b">set &amp;= newSet</code></li><li id="291a" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><code class="fe la lb lc ld b">set.difference_update(newSet)</code> -取<code class="fe la lb lc ld b">set</code>，并删除<code class="fe la lb lc ld b">newSet</code>中发现的任何项目。也可以写成<code class="fe la lb lc ld b">set -= newSet</code></li><li id="f44f" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><code class="fe la lb lc ld b">set.symmetric_difference_update(newSet)</code> -只能在<code class="fe la lb lc ld b">set</code>和<code class="fe la lb lc ld b">newSet</code>中找到，不能两者都有。也可以写成<code class="fe la lb lc ld b">set ^= newSet</code></li></ul><p id="90a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然前5个提供了从集合中添加和删除项目的简单方法，但后3个与我们之前讨论交叉和组合集合时讨论的方法相同。这里的区别在于，我们可以使用这些函数来改变<code class="fe la lb lc ld b">set</code>本身。虽然这在正常情况下是可能的，但我们不能将这些方法应用于<code class="fe la lb lc ld b">frozenset</code>。</p><h1 id="d2c5" class="ls ln it bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">结论</h1><p id="9b60" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">这应该是你需要知道的关于Python中集合的一切。我希望你喜欢这个指南。我还在这里写了更多关于Python中所有不同数据结构的内容。如果你喜欢这个指南，你可能也会喜欢我这里的其他工程内容。</p><p id="e50e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读！您可以在下面了解有关Python数据集合的更多信息:</p><ul class=""><li id="eba3" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated"><a class="ae kz" href="https://fjolt.com/python-data-collections" rel="noopener ugc nofollow" target="_blank"> Python数据集合</a></li><li id="717d" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><a class="ae kz" href="https://fjolt.com/article/python-lists" rel="noopener ugc nofollow" target="_blank"> Python数据集合:列表</a></li><li id="9ee2" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><a class="ae kz" href="https://fjolt.com/article/python-tuples" rel="noopener ugc nofollow" target="_blank"> Python数据集合:元组</a></li><li id="51da" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><strong class="kd iu"> Python数据集合:集合</strong></li><li id="9acb" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated"><a class="ae kz" href="https://fjolt.com/article/python-dictionaries" rel="noopener ugc nofollow" target="_blank"> Python数据集合:字典</a></li></ul></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="d181" class="ls ln it bd lt lu nq lw lx ly nr ma mb mc ns me mf mg nt mi mj mk nu mm mn mo bi translated">分级编码</h1><p id="bf09" class="pw-post-body-paragraph kb kc it kd b ke mp kg kh ki mq kk kl km mr ko kp kq ms ks kt ku mt kw kx ky im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="c9d4" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="eda2" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">📰查看<a class="ae kz" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="075b" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">🔔关注我们:<a class="ae kz" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kz" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kz" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="bc54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🚀👉<a class="ae kz" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">将像你这样的开发人员安置在顶级创业公司和科技公司</strong> </a></p></div></div>    
</body>
</html>