<html>
<head>
<title>This One Trick Can Make Your Code 17 Times More Efficient</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这一招可以让你的代码效率提高17倍</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/this-one-trick-can-make-your-code-17-times-more-efficient-e65769006dfa?source=collection_archive---------0-----------------------#2020-07-03">https://levelup.gitconnected.com/this-one-trick-can-make-your-code-17-times-more-efficient-e65769006dfa?source=collection_archive---------0-----------------------#2020-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/02a9cf61cde0d23ecf49d589ffd48846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fvURVJPF_DSR6EpS"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/photos/FCHlYvR5gJI" rel="noopener ugc nofollow" target="_blank">去飞溅</a></figcaption></figure><div class=""/><div class=""><h2 id="abc3" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">用最少的努力提高性能</h2></div><p id="e705" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个人都希望自己的代码更高效——下面是一个简单技巧的实现及其原因，这个技巧只需最少的努力，却能显著提高性能。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="4c5f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想想Mandelbrot集，这是一个迷人的数学现象，涉及位运算、递归和虚数。因为这是一个如此复杂和计算多样化的函数，所以这是一个关于如何提高效率的很好的案例研究。深入的代码解释和产生的结果的漂亮图像可以在<a class="ae jg" href="https://medium.com/faun/visualize-the-beauty-of-recursion-by-programming-a-fractal-generator-714dbd94d6d1?source=---------41------------------" rel="noopener">这里</a>找到。</p><figure class="mb mc md me gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="772c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对我们的函数<code class="fe mh mi mj mk b">mandelbrot_set</code>计时，我们发现这个昂贵的函数平均需要大约8秒来运行。</p><figure class="mb mc md me gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5d96" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们做一个简单的改变:在一个单独的单元中，我们将加载Cython，这是一个致力于弥合C和Python之间差距的模块(稍后将详细介绍)。然后，在单元格顶部，我们将键入<code class="fe mh mi mj mk b">%%cython -a</code>，触发Jupyter Notebook的line magics通过Cython运行代码，cy thon会在后台自动将Python代码转换为C。我们的函数<code class="fe mh mi mj mk b">mandelbrot_set</code>可以用Python调用，但将使用C结构运行。</p><figure class="mb mc md me gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="13b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再次计时我们更新的代码，我们看到减少了将近两秒，或者25%。对于几乎什么都不做的人来说，这是一个很好的折扣！</p><figure class="mb mc md me gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="b897" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不过，我们可以做得更好。由于Cython试图将Python进程转换成C结构，因此受到了限制。我们可以帮助Cython做的事情之一是指定我们最终在函数中使用的所有变量的变量类型，以便它可以最好地优化我们的代码。</p><p id="0220" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意每个参数的数据类型是如何指定的(在这种情况下都用<code class="fe mh mi mj mk b">int</code>)。如果一个变量是独立创建的，我们可以使用<code class="fe mh mi mj mk b">cdef</code>关键字，后跟数据类型和采用该类型的变量。从直接声明的变量到for <code class="fe mh mi mj mk b">i in range(n)</code>中的<code class="fe mh mi mj mk b">i</code>的所有内容都可以声明，以给予Cython最大可能的帮助。</p><figure class="mb mc md me gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="59af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用指定的数据类型对更新后的函数进行计时，我们得到了令人震惊的时间减少，比原来的时间快了17倍。</p><figure class="mb mc md me gt iv"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="49a8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于一个打字速度快的人来说，仅仅10秒钟的时间，我们的代码效率就提高了17倍。虽然时间上的绝对减少只有几秒钟，但这会导致更长的脚本，并最终节省数小时的额外计算。</p><p id="2dba" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么这个神奇的巫术是怎么运作的呢？</p><p id="e1a3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Cython是一个可以将Python编写成速度更快、效率更高的c语言的模块。虽然Python的自由和开放性刺激了广泛的采用和匆忙的开发，特别是在数据科学和其他重计算领域，但这种自由是以低效为代价的。在C语言中，编码者有义务提供更多关于代码执行的信息，这是一项繁重的工作，可以加快处理速度。通过将我们的Python代码编写成高效的C结构和方法，您可以使它更高效——虽然这肯定有所帮助，但您甚至不需要了解任何C语言！</p><p id="14f3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关键字<code class="fe mh mi mj mk b">cdef</code>将一个变量声明为静态类型的C变量。使用这些C变量会导致代码执行更快，因为<em class="ml">变量</em>本身有指定的类型，而不是<em class="ml">值</em>在Python中有类型。例如，在Python中，可以将同一变量在一行中设置为整数，在另一行中设置为字符串——例如，<code class="fe mh mi mj mk b">a = “hello world”</code> &amp; <code class="fe mh mi mj mk b">a = 1</code>。然而，在C #中，静态类型变量被设置为只有一种数据类型。</p><p id="1197" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种刚性意味着它可以避免Python的动态类型所需的巨大内存空间开销。因为一个变量可以有很多可能的值，所以需要分配更多的内存。另一方面，对静态类型变量范围的严格限制意味着内存空间和执行过程要高效得多。函数参数也能够被声明为静态类型的C变量，如上所述。</p><p id="05f6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是为什么简单地声明变量类型会导致处理时间加速的原因。尽管有许多其他方法可以让Cython的Python代码更高效，但最简单、最不需要技术、也许回报最高的方法是写出变量类型。</p><p id="f069" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在你的剧本中有无数Cython的应用。</p><ul class=""><li id="756b" class="mm mn jj la b lb lc le lf lh mo ll mp lp mq lt mr ms mt mu bi translated">下一次，当您编写一个行方式的函数来应用于具有几千行的数据帧进行复杂的数据操作时，使用Cython可以大大加快遍历所有行所需的时间。</li><li id="d4a5" class="mm mn jj la b lb mv le mw lh mx ll my lp mz lt mr ms mt mu bi translated">如果您正在手工编写一个数据转换管道来应用复杂和/或有条件的扩充，请考虑在Cython中实现它。</li><li id="1b89" class="mm mn jj la b lb mv le mw lh mx ll my lp mz lt mr ms mt mu bi translated">为神经网络编写自定义优化器或损失函数(或自行实现现有函数)时，使用Cython可以加快训练过程。</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><div class="mb mc md me gt na"><a href="https://towardsdatascience.com/5-quick-easy-hacks-to-write-more-computationally-efficient-code-b1168208b8df" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jk gy z fp nf fr fs ng fu fw ji bi translated">5个快速简单的技巧来编写计算效率更高的代码</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">转变您低效的编码风格</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ja na"/></div></div></a></div><div class="is it gp gr iu na"><a href="https://towardsdatascience.com/jupyter-notebook-essential-productivity-hacks-9b7d69073769" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jk gy z fp nf fr fs ng fu fw ji bi translated">Jupyter笔记本基本生产力黑客</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">更高效地创建和编码</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="np l nl nm nn nj no ja na"/></div></div></a></div></div></div>    
</body>
</html>