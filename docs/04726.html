<html>
<head>
<title>Big O Notation: Calculating Time Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号:计算时间复杂度</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/big-o-notation-calculating-time-complexity-d4fd5750f0bb?source=collection_archive---------5-----------------------#2020-07-11">https://levelup.gitconnected.com/big-o-notation-calculating-time-complexity-d4fd5750f0bb?source=collection_archive---------5-----------------------#2020-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3868301579f360b7206b6a4f6447c74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZL-CW8Yafp4524JQf0YoQ.jpeg"/></div></div></figure><p id="f7d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">准备技术面试有时会很困难、令人沮丧和困惑。随着我继续找工作，我想我应该花些时间来分享我到目前为止学到的关于计算时间复杂度和大O符号的知识。当Flatiron第一次介绍这个主题时，对我来说并不容易理解，但是一旦你进一步深入研究，big O背后的想法实际上是相当简单的。这里有一个它是如何工作的纲要，以及你需要知道什么来开始钉那些技术面试问题！</p><p id="042e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，当人们说“大O”时，他们实际上指的是大θ(“大θ”)。这一概念旨在评估函数在接近特定值/无穷大时的极限行为。本质上，当使用大O或“上渐近界”时，您看到的是最坏的情况要计算时间复杂度，您只需查看具有最大指数的项，忽略系数/较小的项，您还可以计算函数中嵌套循环的数量，以帮助确定big O。在这个例子中，我试图在一个由60个数字组成的混排数组中找到一个特定的目标数字，比如说23。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="bb20" class="li lj it le b gy lk ll l lm ln">array = [*1..60].shuffle</span><span id="8461" class="li lj it le b gy lo ll l lm ln">def linear_search(array, target)<br/>  counter = 0<br/><br/>  # iterate through the given array starting <br/>  # at index 0 and continue until the end<br/> <br/>  while counter &lt; array.length <br/>    if array[counter] == target </span><span id="e01b" class="li lj it le b gy lo ll l lm ln">      # exit the loop if the target element is found <br/>      return "Took: #{counter} iterations to find the target." <br/>    else <br/>      counter += 1<br/>    end <br/>  end <br/><br/>  return "#{target} could not be found in the array." <br/>end</span><span id="97f3" class="li lj it le b gy lo ll l lm ln">linear_search(array, 23)</span></pre><p id="a8fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当试图找到目标时，运行我的方法<code class="fe lp lq lr le b">linear_search</code> 5次给出了这个输出— 23。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="1160" class="li lj it le b gy lk ll l lm ln">=&gt; "Took: 12 iterations to find the target."<br/>=&gt; "Took: 20 iterations to find the target."<br/>=&gt; "Took: 37 iterations to find the target."<br/>=&gt; "Took: 55 iterations to find the target."<br/>=&gt; "Took: 30 iterations to find the target."</span></pre><p id="b54e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本质上，这个输出告诉我们的是，给定我们的函数，如果它被混洗到数组的索引0，找到目标所需的最小迭代次数将是1。更重要的是，如果一直拖到最后，最坏的情况是60次迭代。如果我们的数组有150个数字/项，那么最坏的情况是150次迭代。线性搜索的大O符号是O(n)，其中n等于集合中元素的数量。</p><p id="8403" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是一些需要注意的其他常见大O符号:</p><ul class=""><li id="fb73" class="ls lt it kd b ke kf ki kj km lu kq lv ku lw ky lx ly lz ma bi translated">o(1)-总是花费相同的时间，速度不变。</li><li id="f3eb" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">O(log n) —每次循环迭代后，工作量除以2。</li><li id="e041" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">o(n)-计算时间取决于输入大小。</li><li id="8b73" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">O(n log n) —嵌套循环，其中内部循环在<code class="fe lp lq lr le b">log n</code>时间内运行。</li><li id="a9c4" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">o(n^2)——完成工作的时间随着关系的发展而增长。</li><li id="3fe3" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">o(n^3)——与<code class="fe lp lq lr le b">n^2</code>相似，但在<code class="fe lp lq lr le b">input size ^ 3</code>关系中成长。</li><li id="3c55" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">o(2^n)——计算工作在<code class="fe lp lq lr le b">2 ^ input size</code>关系中增长。</li></ul><p id="3df6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简而言之，这就是大O符号。基本上，您只是试图确定绝对最坏的情况，或者更确切地说，给定函数/算法的整体性能取决于它必须处理的数据量。这个主题乍一看似乎很有挑战性，但是计算时间复杂度并不一定如此。我的建议是尽可能多地查看代码示例，这些代码说明了上面列出的不同符号，以便真正区分它们的含义。如果你想通过技术面试，获得下一份工作，对大O符号有很强的理解是至关重要的！</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="f16e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">来自Level Up Coding的提示:订阅我们的<a class="ae mn" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> YouTube频道</a>或加入<a class="ae mn" href="https://skilled.dev" rel="noopener ugc nofollow" target="_blank"> Skilled.dev获取编码面试教程和职业建议</a>。</p><div class="mo mp gp gr mq mr"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd iu gy z fp mw fr fs mx fu fw is bi translated">编写面试问题</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">掌握编码面试的过程</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">技术开发</p></div></div><div class="na l"><div class="nb l nc nd ne na nf jz mr"/></div></div></a></div></div></div>    
</body>
</html>