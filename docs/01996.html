<html>
<head>
<title>Make HTTP Requests with the Fetch API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Fetch API发出HTTP请求</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/make-http-requests-with-the-fetch-api-d4920a7cb4e9?source=collection_archive---------1-----------------------#2020-02-11">https://levelup.gitconnected.com/make-http-requests-with-the-fetch-api-d4920a7cb4e9?source=collection_archive---------1-----------------------#2020-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/92c62624a1fb5ce4a1c32d561c0395ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CiXsoYlhqmB8RZkK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">杰瑞米·帕金斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c3ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Fetch API之前，HTTP请求是用<code class="fe le lf lg lh b">XmlHttpRequest</code>对象发出的。它更难使用，而且它不是基于承诺的，因为它是在JavaScript内置承诺之前添加的。</p><p id="cf29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以使用Fetch API更容易地发出HTTP请求。</p><p id="7ff1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了它，我们就有了一个关于<code class="fe le lf lg lh b">Request</code>和<code class="fe le lf lg lh b">Response</code>对象以及其他网络请求的通用定义。这使得它们可以在未来需要时随时使用。</p><p id="58d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还提供了相关概念的定义，如CORS和HTTP源头语义，取代了它们在其他地方的现有定义。</p><p id="e671" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何使用Fetch API发出客户端HTTP请求。</p><h1 id="5331" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">发出HTTP请求</h1><p id="9c4a" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">发出HTTP请求从使用<code class="fe le lf lg lh b">fetch</code>方法开始。它有一个强制参数，即我们要获取的资源的路径。</p><p id="565b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论成功与否，它都返回一个承诺，该承诺决定了对该请求的<code class="fe le lf lg lh b">Response</code>。我们可以选择传入一个<code class="fe le lf lg lh b">init</code> options对象作为参数。</p><p id="11be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦检索到了<code class="fe le lf lg lh b">Response</code>,就有许多方法来定义什么是主体内容以及应该如何处理它。</p><p id="e5de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">fetch</code>返回的承诺即使响应是404或者500也不会拒绝HTTP错误状态。当<code class="fe le lf lg lh b">ok</code>状态设置为<code class="fe le lf lg lh b">false</code>时，它将正常解决。</p><p id="3384" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">fetch</code>不会收到跨站cookies。无法使用<code class="fe le lf lg lh b">fetch</code>建立跨站点会话。</p><p id="c116" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">fetch</code>除非我们设置了凭据初始化选项，否则不会发送cookies。</p><p id="18cb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下调用<code class="fe le lf lg lh b">fetch</code>方法:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8e4c" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  const response = await fetch('<a class="ae kf" href="https://jsonplaceholder.typicode.com/todos/1'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1'</a>)<br/>  const json = await response.json();<br/>  console.log(json);<br/>})();</span></pre><p id="0d87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码用<code class="fe le lf lg lh b">fetch</code>发出一个GET请求，然后用<code class="fe le lf lg lh b">Response</code>对象的<code class="fe le lf lg lh b">json()</code>方法将其转换成一个JavaScript对象。然后我们可以将它记录在<code class="fe le lf lg lh b">console.log</code>中。</p><p id="e3a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于HTTP请求来说，这是最简单的情况。我们还可以在第二个参数中添加更多选项。我们可以设置以下选项:</p><ul class=""><li id="4bb1" class="my mz it ki b kj kk kn ko kr na kv nb kz nc ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">method</code> —请求方式</li><li id="d5d9" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">headers</code> —请求我们想要添加的标题</li><li id="c515" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">body</code> —请求正文。可以是<code class="fe le lf lg lh b">Blob</code>、<code class="fe le lf lg lh b">BufferSource</code>、<code class="fe le lf lg lh b">FormData</code>、<code class="fe le lf lg lh b">URLSearchParams</code>、<code class="fe le lf lg lh b">USVString</code>或<code class="fe le lf lg lh b">ReadableStream</code>对象。GET或HEAD请求不能有正文。</li><li id="f393" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">mode</code> —请求的模式。可以是<code class="fe le lf lg lh b">cors</code>、<code class="fe le lf lg lh b">no-cors</code>或<code class="fe le lf lg lh b">same-origin</code></li><li id="3cd1" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">credentials</code> —我们希望用于请求的请求凭据。可能的值有<code class="fe le lf lg lh b">omit</code>、<code class="fe le lf lg lh b">same-origin</code>或<code class="fe le lf lg lh b">include</code>。必须提供此选项才能自动发送当前域的cookies。从Chrome 50开始，这个属性也需要一个<code class="fe le lf lg lh b">FederatedCredential</code>实例或者一个<code class="fe le lf lg lh b">PasswordCredential</code>实例。</li><li id="f26d" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">cache</code> —我们希望用于请求的缓存模式</li><li id="71c7" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">redirect</code> —使用重定向模式。将此项设置为<code class="fe le lf lg lh b">follow</code>表示自动跟踪重定向，<code class="fe le lf lg lh b">error</code>表示重定向发生时出错中止，或者<code class="fe le lf lg lh b">manual</code>表示手动处理重定向</li><li id="fbac" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">referrer</code> —指定<code class="fe le lf lg lh b">no-referrer</code>、<code class="fe le lf lg lh b">client</code>或URL的字符串。默认值为<code class="fe le lf lg lh b">client</code></li><li id="c3bb" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">referrerPolicy</code> —指定引用HTTP头的值。可以是<code class="fe le lf lg lh b">no-referrer</code>、<code class="fe le lf lg lh b">no-referrer-when-downgrade</code>、<code class="fe le lf lg lh b">origin</code>、<code class="fe le lf lg lh b">origin-when-cross-origin</code>、<code class="fe le lf lg lh b">unsafe-url</code>中的一种</li><li id="5c77" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">integrity</code> —请求的子资源完整性值</li><li id="49e6" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">keepalive</code> —设置此选项以允许请求在页面上存活</li><li id="687b" class="my mz it ki b kj nh kn ni kr nj kv nk kz nl ld nd ne nf ng bi translated"><code class="fe le lf lg lh b">signal</code>—<code class="fe le lf lg lh b">AbortSignal</code>对象实例，让我们与获取请求通信，并通过<code class="fe le lf lg lh b">AbortController</code>中止它。</li></ul><p id="1b98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以编写一个基本的POST请求:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d751" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  const response = await fetch('<a class="ae kf" href="https://jsonplaceholder.typicode.com/posts'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts'</a>, {<br/>    method: 'POST',<br/>    body: JSON.stringify({<br/>      title: 'title',<br/>      body: 'body',<br/>      userId: 1<br/>    }),<br/>    headers: {<br/>      "Content-type": "application/json; charset=UTF-8"<br/>    }<br/>  })<br/>  const json = await response.json();<br/>  console.log(json);<br/>})();</span></pre><p id="6492" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在第二个参数的对象中设置所有选项，包括主体和头。</p><p id="559d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要上传文件，我们可以从文件输入中获取文件。假设我们在HTML中有它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="192f" class="mt lj it lh b gy mu mv l mw mx">&lt;input type='file' id='file-input'&gt;</span></pre><p id="17df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以编写以下代码来观察文件输入值的变化，并将文件上传到服务器:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d9c7" class="mt lj it lh b gy mu mv l mw mx">const upload = async (file) =&gt; {<br/>  const response = await   fetch('<a class="ae kf" href="https://jsonplaceholder.typicode.com/posts'" rel="noopener ugc nofollow" target="_blank">https://localhost/'</a>, {<br/>    method: 'POST',<br/>    body: file,<br/>    headers: {<br/>      'Content-Type': 'multipart/form-data'<br/>    }<br/>  })<br/>  const json = await response.json();<br/>  console.log(json);<br/>};</span><span id="3add" class="mt lj it lh b gy nm mv l mw mx">const input = document.getElementById('file-input');<br/>input.addEventListener('change', () =&gt; {<br/>  upload(input.files[0]);<br/>}, false);</span></pre><p id="c946" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，标题可能会根据我们使用的服务器而变化。总的想法是，我们从输入中获取文件，然后在请求体中发送它。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/cb2f9de29e8c54d4bf9ace48a2b1d446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b37pdY7en5aeTHZY"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">粘土堤</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">防溅板</a>上拍摄</figcaption></figure><h1 id="ea9a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">操纵响应</h1><p id="74ce" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">Response</code>有一些获取数据和操作数据的属性。我们可以使用<code class="fe le lf lg lh b">error</code>方法得到错误，<code class="fe le lf lg lh b">redirect</code>方法用不同的URL创建一个新的响应。</p><p id="d2e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Response</code>对象实现的<code class="fe le lf lg lh b">Body</code>对象具有用于读取<code class="fe le lf lg lh b">FormData</code>响应的<code class="fe le lf lg lh b">formData</code>方法。同样，还有读取JSON响应的<code class="fe le lf lg lh b">json</code>方法和读取纯文本的<code class="fe le lf lg lh b">text</code>方法。它们都解析为具有相应对象的承诺。<code class="fe le lf lg lh b">arrayBuffer</code>方法将读取二进制数据并解析为<code class="fe le lf lg lh b">ArrayBuffer</code>。<code class="fe le lf lg lh b">blob</code>方法读取二进制数据并将其解析为<code class="fe le lf lg lh b">Blob</code>。</p><p id="e2a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可能对我们有用的值属性包括获取响应头的<code class="fe le lf lg lh b">headers</code>，检查请求是否成功的<code class="fe le lf lg lh b">ok</code>，检查重定向是否发生的<code class="fe le lf lg lh b">redirect</code>。<code class="fe le lf lg lh b">status</code>是响应状态代码，<code class="fe le lf lg lh b">statusText</code>具有对应于状态代码的文本。<code class="fe le lf lg lh b">url</code>有响应URL，<code class="fe le lf lg lh b">body</code>有响应正文。</p><p id="c378" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于发出HTTP请求，Fetch API比<code class="fe le lf lg lh b">XmlHttpRequest</code>好得多。它允许我们提出大多数类型的请求，并且它是基于承诺的，因此它们可以与其他承诺一起按顺序运行。</p><p id="22f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它支持文本和二进制体。现在我们不需要第三方HTTP客户端来进行客户端HTTP请求。</p><p id="ed31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Request</code>和<code class="fe le lf lg lh b">Response</code>对象也被标准化，这样它们就可以和其他API一起使用。</p></div></div>    
</body>
</html>