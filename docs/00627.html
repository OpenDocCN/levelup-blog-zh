<html>
<head>
<title>DRY Up Your Code with GraphQL Fragments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用GraphQL片段擦干你的代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dry-up-your-code-with-graphql-fragments-4d080e4f545e?source=collection_archive---------1-----------------------#2019-06-11">https://levelup.gitconnected.com/dry-up-your-code-with-graphql-fragments-4d080e4f545e?source=collection_archive---------1-----------------------#2019-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4a672839c72a94ad42826822fce039b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N5ZtsTNNMM9Ht2i6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@katycao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Katy Cao </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="65a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我一直在学习在我的React应用程序中使用GraphQL和Apollo。这篇博客文章假设您对这两种技术都有基本的了解，并将专门讨论在使用Apollo定义的查询中使用GraphQL片段。如果您想了解更多关于在React中使用Apollo和GraphQL的信息，我可以在文章末尾找到相关文档的链接。</p><h1 id="be96" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我的问题</h1><p id="773d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于我的应用程序，我想让用户以两种方式找到食谱。1)提供一个搜索词，并显示与该词相关的50个结果的限制，如果需要，还允许通过结果分页。2)允许用户通过唯一的ID搜索特定的配方，并且只返回单个结果。我不再需要考虑限制、分页等等。</p><p id="5017" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这两种情况下，我都希望每个食谱得到相同类型的结果。从两个查询返回的食谱对象应该具有相同的属性，比如id、标题、图像、署名等。</p><p id="5647" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看下面的代码，看看我用来完成这个任务的两个查询:</p><p id="4a82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">用例1: </strong></p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="2eb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">用例2: </strong></p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="013b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我相信你已经注意到了，这里有几行重复的内容。配方上的所有属性在两次查询之间重复。如果有一种方法可以清理这种情况并减少我需要编写的代码量就好了……..</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mk mj l"/></div></figure><h1 id="4270" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我的解决方案</h1><p id="e30b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了一次编写查询属性，我们可以使用一个可以在多个查询中重用的Apollo/GraphQL片段。</p><p id="cd54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最简单的定义是:</p><blockquote class="ml"><p id="6e3e" class="mm mn iq bd mo mp mq mr ms mt mu la dk translated">"一个<a class="ae kc" href="http://graphql.org/learn/queries/#fragments" rel="noopener ugc nofollow" target="_blank"> GraphQL片段</a>是一个共享的查询逻辑."— Apollo文档(参考基本GraphQL概念。)</p></blockquote><p id="2f52" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">同样根据阿波罗文档，在阿波罗中片段有两个主要用途:</p><ul class=""><li id="7872" class="na nb iq kf b kg kh kk kl ko nc ks nd kw ne la nf ng nh ni bi translated">在多个查询、变异或订阅之间共享字段。</li><li id="5ea2" class="na nb iq kf b kg nj kk nk ko nl ks nm kw nn la nf ng nh ni bi translated">将您的查询进行分解，以允许您将字段访问与使用它们的位置放在一起。</li></ul><p id="c6a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的情况下，我更关心第一点，这就是我在这里要解决的问题，以清理这两个食谱查询。</p><p id="80a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们定义我们的片段。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="e036" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在第1行看到，我正在从<code class="fe no np nq nr b">apollo-boost</code>导入<code class="fe no np nq nr b">gql</code>标记，这样我可以更容易地在React中编写查询。然后我定义了一个常数，在这个常数中我定义了这个片段。名称<code class="fe no np nq nr b">RECIPE_ATTRIBUTES</code>指的是这一段<code class="fe no np nq nr b">gql</code>代码，这样我们可以在以后的其他查询中使用它。这不是片段本身，只是一些<code class="fe no np nq nr b">gql</code>代码的容器。</p><p id="446e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们标签中的代码片段使用了关键字<code class="fe no np nq nr b">fragment</code>来定义我们想要重用的实际代码段。在这种情况下，我将我的片段命名为<code class="fe no np nq nr b">recipeAttributes</code>。我把<code class="fe no np nq nr b">on Recipe</code>放在这个声明之后，因为这是这些属性所属的类型。</p><p id="cb79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我已经定义了我的片段，我需要将它添加到我的查询中，并替换重复的代码:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="ns mj l"/></div></figure><p id="1a87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">刚刚变得如此之短！我引入了我之前定义的<code class="fe no np nq nr b">RECIPE_ATTRIBUTES</code>常量，并将其插入到查询之后，但仍然在<code class="fe no np nq nr b">gql</code>标记内。然后，我能够在现有的查询中引用我定义为<code class="fe no np nq nr b">recipeAttributes</code>的片段。</p><p id="0ebd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这留给我最后的代码:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="21aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">概括地说，我们刚刚在Apollo <code class="fe no np nq nr b">gql</code>标签中写了一个GraphQL片段，以便封装和重用我们希望食谱如何返回给我们的定义。这有助于我们执行单一责任原则(SRP)。快速回顾一下SRP:</p><p id="2f51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nt">“单一责任原则(Single Responsibility Principle，SRP)是五个所谓的坚实原则之一，由Robert C. Martin开发并推广，旨在帮助开发人员生成灵活且可维护的代码。简而言之，SRP认为一个给定的模块或类应该负责程序功能的一个元素，因此只有一个改变的理由。— </em> <a class="ae kc" href="https://medium.com/@severinperez/writing-flexible-code-with-the-single-responsibility-principle-b71c4f3f883f" rel="noopener"> <em class="nt">塞弗林·佩雷斯</em> </a></p><p id="9857" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也有助于我们通过GraphQL将食谱的单一来源返回到我们的前端。我们已经在一个地方定义了预期的配方属性。</p><p id="61b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不仅有一个单独的变量来保存我们的查询和配方定义，并在一个地方定义了配方结果的结构，而且我们还减少了代码的数量和复杂性！赢赢！</p><p id="961a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这对你和对我一样有帮助！</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><div class="me mf mg mh gt ob"><a href="https://graphql.org/learn/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">GraphQL:一种API查询语言。</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">GraphQL在您的API中提供了完整的数据描述，使客户能够准确地要求他们…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">graphql.org</p></div></div><div class="ok l"><div class="ol l om on oo ok op jw ob"/></div></div></a></div><p id="0062" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank">https://www.apollographql.com/docs/react/</a></p><p id="486a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">https://www.apollographql.com/docs/react/advanced/fragments<a class="ae kc" href="https://www.apollographql.com/docs/react/advanced/fragments/" rel="noopener ugc nofollow" target="_blank"/></p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><div class="me mf mg mh gt ob"><a href="https://gitconnected.com/learn/graphql" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">学习GraphQL -最佳GraphQL教程(2019) | gitconnected</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">11大GraphQL教程-免费学习GraphQL。课程由开发人员提交和投票，使您能够…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">gitconnected.com</p></div></div><div class="ok l"><div class="oq l om on oo ok op jw ob"/></div></div></a></div></div></div>    
</body>
</html>