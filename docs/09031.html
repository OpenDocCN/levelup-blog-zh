<html>
<head>
<title>Memory Management in Swift with ARC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带ARC的Swift中的内存管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/memory-management-in-swift-with-arc-34f10d6f189a?source=collection_archive---------16-----------------------#2021-06-29">https://levelup.gitconnected.com/memory-management-in-swift-with-arc-34f10d6f189a?source=collection_archive---------16-----------------------#2021-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="404a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Swift内存管理快速指南，提高您的应用程序性能。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/180af65b0d61dcd10f2385cc8c8dc931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/0*Vd8jHCZbp9UkDsvx"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">内存管理| RAM |内存泄漏</figcaption></figure><p id="dc24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的设备📴有两种类型的内存来保存我们的数据:</p><ul class=""><li id="0eb7" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">磁盘存储器</li><li id="18ce" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">随机存取存储器</li></ul><p id="9b7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们打开一个应用程序时，<strong class="kt ir"> RAM </strong>的一小部分被分配给该应用程序，其中存储了其类的所有实例。这块内存被称为<strong class="kt ir">堆内存</strong>，这是我们在讨论内存管理时提到的那部分内存。</p><blockquote class="mb mc md"><p id="08b9" class="kr ks me kt b ku kv jr kw kx ky ju kz mf lb lc ld mg lf lg lh mh lj lk ll lm ij bi translated"><strong class="kt ir">堆</strong>是<strong class="kt ir">动态分配的</strong>内存所在的内存(RAM)部分</p></blockquote><p id="b96a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于堆内存非常有限，我们必须正确地管理它💰。糟糕的内存管理会大大降低应用程序的速度，并且迟早会导致崩溃。</p><h1 id="526f" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">但是swift是如何管理堆内存的呢？</h1><p id="f4cd" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">Swift使用一种叫做<strong class="kt ir">自动引用计数</strong> (ARC)的东西进行内存管理。每次创建一个类的新对象时，ARC都会分配一些内存来存储与该对象相关的数据。每个对象都有一个<strong class="kt ir">引用计数</strong>属性，该属性跟踪所有对其有<strong class="kt ir">强</strong>引用的对象。每次创建一个强引用，该对象的引用计数就会增加1。每当引用超出范围时，引用计数就减1。</p><p id="1ad1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">但是对象是如何被释放的… </strong></p><p id="3802" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们试着用一个例子来理解这一点。看看下面的商店类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">Swift示例的内存管理—车间级</figcaption></figure><p id="7212" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果包含一个对象的ViewController超出范围，该对象将被释放。但是，如果对象是在函数内部创建的，那么它的作用域将只在函数内部。一旦函数执行完成，对象将被释放。</p><p id="fb94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们有一个视图控制器MyViewController，我们在viewDidLoad()方法中创建一个类Shop的对象，如下所示(假设它是一个蛋糕店🍰):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">swift示例的内存管理</figcaption></figure><p id="ff74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，只要MyViewController不超出范围，就不会释放商店对象。但是如果我们定义一个函数runApp()如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">swift示例的内存管理</figcaption></figure><p id="f0ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并在viewDidLoad()中调用runApp()，而不是在那里创建对象，那么一旦runApp()超出范围，商店对象就会被释放。</p><p id="62ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，引用计数通过跟踪对对象的引用来识别是否仍然需要该对象。一旦引用计数达到零，该对象将被释放，与该对象相关联的内存将被释放，供另一个对象使用💁。</p><h1 id="2e7b" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">那么内存泄漏是如何发生的呢？</h1><p id="17d3" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">当内容在其生命周期结束后仍保留在内存中时，就会发生内存泄漏。</p><p id="9767" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简单来说，一个<strong class="kt ir">内存泄漏</strong>是一大块内存仍然被分配，但从未被使用过…🤔…</p><p id="65b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们想象这样一种情况，两个物体只相互参照，没有其他参照🗃 ↔️ 🗃.因为它们的引用计数都不能为零，所以它们不能被释放，并将继续占用内存。这被称为强<strong class="kt ir">参考周期</strong>或<strong class="kt ir">保持周期🔄</strong>。</p><p id="3507" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一个例子。让我们定义一个类蛋糕如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">swift示例的内存管理</figcaption></figure><p id="c6a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果我们将下面这段代码添加到runApp():</p><p id="a3ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nh ni nj nk b">let cake = Cake(“Sweet Tooth Special Chocolate Truffle Cake”)</code></p><p id="7517" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就产生了一个蛋糕的物体。接下来，在商店中添加属性“cakes”。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">Swift示例的内存管理</figcaption></figure><p id="e35b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果我们在runApp()中调用sells()，它将创建一个保留循环。这将导致<strong class="kt ir"> <em class="me">内存泄漏</em> </strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/13abd1d1971bd64bdc2d061244e32513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1hqwAM3BcbXQH-IU"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">Swift | ARC |内存泄漏中的引用循环</figcaption></figure><p id="345c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">商店和蛋糕之间的紧密联系</p><p id="948c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了打破这种循环，我们使用<strong class="kt ir">弱</strong>和<strong class="kt ir">无主</strong>引用。</p><h1 id="b91d" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">软弱？无主？🤯</h1><p id="975e" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">为了打破保持循环，我们使用了<strong class="kt ir">弱</strong>引用。默认情况下，swift中的所有引用都是<strong class="kt ir">强引用</strong>，并在创建时将引用计数增加1。但是弱引用不会影响引用计数。此外，<em class="me">弱引用总是可选变量，当引用计数变为零时，弱引用被设置为零</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nq"><img src="../Images/1f2bfd6bd07108bc816c374f8faa045f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NHHPoPG1OgLHDhpS"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">避免内存泄漏的弱引用|打破保持循环</figcaption></figure><p id="a838" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从蛋糕到商店的弱参考</p><p id="9861" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，如果我们回到我们的例子，在蛋糕类中，将“soldBy”的声明改为，</p><p id="780c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nh ni nj nk b">weak var soldBy: Shop?</code></p><p id="eca0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当在runApp()中调用sells()时，对商店的引用计数不会增加。因此，当所有其他对shop()的引用都被移除时，它将被释放，cake的引用计数变为零。</p><p id="f898" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与弱引用类似，<strong class="kt ir">无主</strong>引用不会影响对象的引用计数。但是与弱引用不同，<em class="me">无主引用从来都不是可选的</em>。这意味着如果你试图访问一个指向一个已经被释放的对象的无主属性，这就像是强行打开一个为零的可选值。</p><p id="1934" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重要的是，只有在引用和对象肯定会同时被释放的情况下，才应该使用无主引用。</p><p id="e013" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">等等…弱引用和无主引用除了一个是可选的而另一个不是之外是一样的吗…🤔。</p><p id="606e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，不尽然…当我们谈论引用计数时，我们通常指的是对象的<em class="me">强引用计数</em>。类似地，swift为该对象维护一个<em class="me">无主引用计数</em>和<em class="me">弱引用计数</em>。但是真正将弱引用与无主引用和强引用区分开来的是弱引用指向一个被称为“<strong class="kt ir">副表</strong>的东西，而不是对象本身。这就是为什么，当弱引用超出范围时，对象可以被反初始化和释放…因为弱引用根本不指向对象。当强引用计数达到零时，对象被释放，但是如果无主引用计数大于零，它会留下一个悬空指针。</p><p id="3465" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">副表是一个单独的内存块，用来存储对象的附加信息。一个对象最初没有副表条目，当为该对象创建弱引用时，它会自动创建。</p><h1 id="3729" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">带闭合的参考循环</h1><p id="d04d" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">闭包是导致内存泄漏的引用循环的另一种方式。让我们以车间课堂为例来理解这一点。让我们向我们的商店类添加一个计算属性cakeCount。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">参考周期示例</figcaption></figure><p id="82a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们在runApp()中使用这个属性，一个商店对象通过计算属性cakeCount引用闭包，闭包通过“<strong class="kt ir"> self </strong>”引用对象。由于这是一个双向的强引用，它创建了一个保留循环。</p><p id="4c92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，我们使用<strong class="kt ir">捕获列表</strong>来捕获闭包中对self的弱引用或无主引用，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">捕获列表以避免内存泄漏示例</figcaption></figure><p id="da6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，关闭不会影响引用计数，只要商店超出范围，关闭也会影响引用计数。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="dc66" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个总结。这涵盖了Swift内存管理的基础知识。感谢阅读！欢迎提出任何问题，非常感谢您的反馈，所以请留下您的评论！</p></div></div>    
</body>
</html>