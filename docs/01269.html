<html>
<head>
<title>NgRx and Angular Route Guards</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NgRx和角形路线防护装置</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ngrx-and-angular-route-guards-a3fc3d5255f8?source=collection_archive---------3-----------------------#2019-12-10">https://levelup.gitconnected.com/ngrx-and-angular-route-guards-a3fc3d5255f8?source=collection_archive---------3-----------------------#2019-12-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="0bbc" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">NgRx在实践中</h2><div class=""/><div class=""><h2 id="930f" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">NgRx与角形路线防护装置集成指南</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/4bbd1e7c83dd7c1e2ed82fb54f329a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXTLRLrxCExmy_rC3lQeSA.png"/></div></div></figure><p id="2490" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">Angular中我最喜欢的特性之一是预取路由事件组件数据的能力。预取改善了用户体验，并确保在激活路由时数据已经就位。这允许我们在导航到组件之前处理错误。当组件下面没有数据时，导航到组件是没有意义的。从最终用户的角度来看，保持对当前组件的关注并处理来自该页面的错误反馈要好得多。</p><h1 id="4f21" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">预取组件数据</h1><p id="15e4" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">假设我们有一个带独立路由配置的惰性加载的<code class="fe mt mu mv mw b">FundsModule</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d383" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在路线上有一个<code class="fe mt mu mv mw b">resolve</code>属性负责取出<code class="fe mt mu mv mw b">fund</code>并注入<code class="fe mt mu mv mw b">FundComponent</code>内部。通常预取可以使用<em class="mz"> Resolve Guard: </em>以如下方式实现</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f571" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">您只需要从路由配置中获取实体id，然后使用该id将请求发送到API服务，最后返回数据。这个响应将被注入到路由数据中，以便您可以从子组件中访问它。例如:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ccf8" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这个想法很简单。但是，这段代码有一个问题。如果您希望使用store和reducers一致地管理您的应用程序数据，您不能返回一个已解析的基金并将其注入到组件中。它必须放在商店里，因为商店负责提供访问和管理数据。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi na"><img src="../Images/7fcf862a568f48ba998b3a269970fca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*948oB3xoCLH6jd8OmL18RQ.png"/></div></figure><h1 id="234c" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">使用NgRx存储预取</h1><p id="78b4" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">不使用<em class="mz">解决</em> <em class="mz">防护</em>，可以使用<em class="mz">激活防护。</em>这种保护通常用于强制用户在访问组件之前进行身份验证。您可能想要阻止或限制访问，直到用户的帐户通过身份验证。通常，您可以像这样创建<em class="mz">激活保护</em>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="79d6" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">守卫返回可观察的布尔值作为结果。如果值为true，导航将继续到目标组件。否则，导航停止。在我们的例子中，这个守卫的角色实际上是检查我们的存储是否有数据，如果没有数据，就发出一个API请求:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2d23" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">虽然这段代码有点复杂，但仍然可读。首先，我们尝试使用<code class="fe mt mu mv mw b">FundFacade</code>从商店中提取<code class="fe mt mu mv mw b">getFund()</code>。如果存储中没有与基金相关的数据，将通过调用<code class="fe mt mu mv mw b">loadFunds()</code>方法来获取。在外观之下，<code class="fe mt mu mv mw b">loadFunds()</code>将分派一个动作，该动作最终将触发一个API请求(下一节将详细介绍)。如果没有从API接收到数据，守卫返回<code class="fe mt mu mv mw b">of(false)</code> <em class="mz"> </em>作为结果，从而阻止导航过程。成功后，守卫返回<code class="fe mt mu mv mw b">of(true)</code>，让用户导航到组件。</p><p id="2113" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">值得一提的是，如果商店中没有资金数据，门卫会发出API请求。这样，商店将在路线导航完成之前被填充。</p><h1 id="4f3f" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">关于门面模式</h1><p id="d86e" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">如果您想将商店相关的逻辑与代码的其他部分分开，我在上面的代码中使用的<a class="ae nb" href="https://en.wikipedia.org/wiki/Facade_pattern" rel="noopener ugc nofollow" target="_blank"> Facade模式</a>非常有用。从经验上讲，将NgRx相关的操作放在门面后面有助于组织和维护代码。facade本身通常负责调度动作，并使用选择器从存储中获取数据。</p><p id="549a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">让我给你看看它可能是什么样子。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d7fc" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如您所见，通过调用<code class="fe mt mu mv mw b">loadFunds()</code>，将会分派一个动作。另一方面，<code class="fe mt mu mv mw b">funds$</code> <em class="mz"> </em>可观察对象是通过选择特征存储的一部分来创建的。好的一面是，我们可能甚至没有意识到NgRx隐藏在表面之后。这就是这种模式的美妙之处。</p><h1 id="a642" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">动作和效果</h1><p id="cf61" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">为了使整个画面完整，以下是商店管理的其他元素。这些是您可能已经见过很多次的非常传统的代码示例。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="cb9b" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">动作和效果是基于<a class="ae nb" href="https://medium.com/angular-in-depth/ngrx-action-creators-redesigned-d396960e46da" rel="noopener"> <em class="mz">创作者</em> </a> <em class="mz">用新的方法创作出来的。在以前的NgRx版本中，为了创建一个动作，你必须创建一个动作类型，创建一个类，最后创建一个动作联合。</em></p><p id="a9c3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">现在，为了实现更大的灵活性，可以通过分别使用<code class="fe mt mu mv mw b">createAction</code>、<code class="fe mt mu mv mw b">createReducer</code>和<code class="fe mt mu mv mw b">createEffect</code>工厂函数，以一种不太冗长的方式创建动作、减少器和效果。<code class="fe mt mu mv mw b">createAction</code>函数的第一个参数是动作类型，可选的第二个参数是额外的元数据，或动作的“道具”。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="3a36" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当您将角度路由防护与NgRx结合使用时，这种方法非常有效。我强烈建议你在你的Angular应用中加入NgRx来进行状态管理，因为这绝对是提高生产力和代码可维护性的重要一步。</p><h1 id="cb0f" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">包裹</h1><p id="6488" class="pw-post-body-paragraph la lb iq lc b ld mo ka lf lg mp kd li lj mq ll lm ln mr lp lq lr ms lt lu lv ij bi translated">我向您展示了如果当前存储中没有数据，如何使用Route Guard发出API请求，以及如何在路线导航完成之前用数据填充存储。</p><p id="8422" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这太棒了。</p></div></div>    
</body>
</html>