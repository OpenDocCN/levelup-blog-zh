<html>
<head>
<title>4 Ways to Establish Communication between Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务之间建立通信的4种方式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/4-ways-to-establish-communication-between-microservices-984207f29497?source=collection_archive---------0-----------------------#2022-01-25">https://levelup.gitconnected.com/4-ways-to-establish-communication-between-microservices-984207f29497?source=collection_archive---------0-----------------------#2022-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c86" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">每种方法的主要优缺点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/77768d68bbd3ed903c7be028a49f61ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DUdsz7okKup5wY9B"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">亚伦·巴纳比在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的照片</a></figcaption></figure><p id="9c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当应用程序由单个后端服务组成时(通常称为单片应用程序)，该应用程序的类或模块在同一进程中，通常通过方法调用相互调用。</p><p id="3ce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，一个应用程序可以由几个服务组成:在一个单一的应用程序中，逻辑的某些部分可以被分成不同目的的独立服务(可伸缩性、容错等)。).多服务的另一个例子是微服务架构。</p><p id="a2f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个应用程序包含多个服务时，一个微服务迟早会向另一个微服务请求或传递一些数据，或者通知一个或多个其他微服务发生了一些事情。可用的集成模式很少，开发人员在选择一种模式之前必须权衡每种模式的利弊。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="218b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">RESTful Web API端点集成</h1><p id="5c02" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个微服务可以很容易地公开一个REST端点，供其他微服务调用。当一个微服务需要调用另一个微服务并接收即时(<strong class="lb iu">同步</strong>)响应时，通常会实现通过RESTful端点的集成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/cd00a15eb9387740d6b45b6af93d7d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*uXyVtF-1VIvh_nvafp47eA.png"/></div></figure><p id="f8a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于易于实现，当开发人员开始考虑集成微服务时，这可能是他们想到的第一个集成模式。在最简单的场景中，微服务1可以只使用<code class="fe na nb nc nd b">HttpClient</code>类来调用微服务2的GET端点。</p><p id="87d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果选择REST API端点方法作为项目中许多微服务的主要集成模式，开发人员可能会考虑使用NSwag工具构建一个web客户端，并将该客户端作为共享的NuGet包存储在自定义的NuGet存储库中。</p><p id="b88f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种集成方式的好处之一是从一个微服务直接路由到另一个微服务的调用之间的<strong class="lb iu">低延迟</strong>，而不需要任何额外的组件，例如消息代理。</p><p id="6610" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当在项目中广泛使用时，以下RESTful Web API端点集成风格特征会显著增加开发时间和系统复杂性:</p><ul class=""><li id="1033" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu">紧耦合。</strong>客户端微服务在编译时知道服务器微服务。如果今天微服务A只调用微服务B，明天却要调用微服务B和C怎么办？开发者将不得不修改微服务a的代码。</li><li id="a740" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu"> API版本控制。</strong>更改其他微服务使用的端点的接口会导致重大更改，而使用API版本控制技术可以避免这种情况。然而，拥有太多版本的相同API会导致微服务代码库中出现大量冗余代码。</li><li id="1f2b" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">客户端错误处理。</strong>每个调用其他微服务API的客户端微服务都应该为失败的请求实现重试逻辑。此外，客户端微服务必须存储由于服务器微服务故障或不可用而无法处理的一些存储请求的相关信息。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🔔<a class="ae ky" href="https://esashamathews.medium.com/subscribe" rel="noopener"> <strong class="lb iu">现在就订阅</strong> </a> <strong class="lb iu">，所以你不要错过我接下来的文章。</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1004" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">RPC / gRPC集成</h1><p id="b3e5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">gRPC 是一个框架，允许开发人员实现远程过程调用(RPC)集成模式，用于微服务之间的通信。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/8d478f4cf62210e8c6db2fba04171973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*6KcsJizNZ1qfJAOj6LybxQ.png"/></div></figure><p id="7646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从架构的角度来看，通过gRPC集成微服务与通过RESTful Web API端点集成微服务没有什么不同。</p><p id="2ad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">gRPC框架，像RESTful Web API端点一样，在微服务之间创建了一个<strong class="lb iu">紧密耦合</strong>。另外，<strong class="lb iu">通过改变<em class="nt">中定义的契约，可以很容易地对系统做出突破性的改变</em></strong>。proto 文件并且没有及时更新客户端。</p><p id="cad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与RESTful Web API端点方法类似，gRPC非常适合发起请求的客户端必须<strong class="lb iu">等待响应的情况</strong>。然而，由于使用了Protobuf协议，gRPC通常比RESTful Web API端点方法提供更好的延迟和高吞吐量(T21)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="48b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">消息传递集成</h1><p id="3210" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与RESTful Web API端点或gRPC集成不同，消息传递模式允许微服务之间进行间接通信。通信通过充当中介的消息总线组件传递。</p><p id="3c64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消息传递集成模式非常适合于<strong class="lb iu">异步(一劳永逸)通信</strong>，在这种情况下，微服务需要发送消息，而不是等待接收者的响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/a3e235e531989deb4ff9d7fe37933ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXrzyx9EWpZCLr4A1Be4XA.png"/></div></div></figure><p id="a43f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">微服务1将只等待来自服务总线的消息已成功提交到队列的响应，但不会等待微服务2完成消息处理。</p><p id="c2a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就架构而言，消息传递集成与RESTful Web API端点或gRPC确实不同。微服务是<strong class="lb iu">相互解耦</strong>的。如果其消息明天需要传递给比今天更多的消费者微服务，则不需要改变和重新编译客户端微服务代码。</p><p id="df45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，服务总线的使用提供了<strong class="lb iu">更好的关注点分离</strong>。Azure Service Bus等消息代理提供了广泛的开箱即用功能，如消息重新传递、死信队列存储、监控功能、会话等。如果不使用服务总线，微服务可能需要自己实现所有这些特性。</p><p id="586d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果服务总线组件失败，应用程序将停止工作。服务总线必须高度可用，以免成为<strong class="lb iu">单点故障</strong>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bcb1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">流式集成</h1><p id="5ac0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当通过流媒体代理(如Kafka、Redis)实现流媒体集成时，就<strong class="lb iu">解耦</strong>微服务而言，它在架构上类似于消息传递集成。请注意，流可以在没有流代理的情况下通过gRPC框架完成，但在这种情况下，服务将紧密耦合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/a5f801b6582a0fd975517d7b7a42a7ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yM7ycqLgXu-29Sf-FIbgzw.png"/></div></div></figure><p id="c847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在<strong class="lb iu">消息传递</strong>方面，流代理的作用与消息代理相同:一个微服务向流代理发送消息，一个或多个其他服务可以订阅来消费和处理它们。</p><p id="53da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，流和消息传递集成之间的第一个关键区别是，在消费者微服务处理了<strong class="lb iu">消息之后，它们不会从流代理中删除</strong>。</p><p id="295b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用消息代理时，新创建的微服务不能接收已经被另一个微服务处理过的旧消息来再次处理它们。但这可以通过流式传输代理自然完成，它可以从过去的任何时间点获取消息。</p><p id="116c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与仅充当消息传输的消息传递代理不同，流代理还充当<strong class="lb iu">数据存储</strong>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="84c2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="4963" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">RESTful web API端点和RPC集成风格非常适合微服务之间的同步通信，其中客户端微服务需要发起请求并等待响应。然而，这两种方法都导致了微服务和版本问题之间的紧密耦合。</p><p id="af57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过消息或流代理集成微服务允许松散耦合的通信。但是，消息可以根据需要在流代理中保留多长时间，甚至在消费者处理完消息之后。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="11db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。如果你喜欢你所读到的，看看下面这个故事:</p><div class="nw nx gp gr ny nz"><a rel="noopener  ugc nofollow" target="_blank" href="/top-misconceptions-about-dependency-injection-in-asp-net-core-c6a7afd14eb4"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">ASP.NET核心中关于依赖注入的主要误解</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">这甚至会导致错误。</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div></div></div>    
</body>
</html>