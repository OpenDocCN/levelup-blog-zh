<html>
<head>
<title>Learning Java after Javascript: Traversing trees with breadth-first and depth-first search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">先学Javascript后学Java:用广度优先和深度优先搜索遍历树</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-java-after-javascript-traversing-trees-with-breadth-first-and-depth-first-search-cfd96d0b05e5?source=collection_archive---------18-----------------------#2020-10-12">https://levelup.gitconnected.com/learning-java-after-javascript-traversing-trees-with-breadth-first-and-depth-first-search-cfd96d0b05e5?source=collection_archive---------18-----------------------#2020-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/d6ff29b1895406553b883743cdd280aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*sojympeoMuTGZQiJ7gwrpg.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">大多是因为logo才决定学Java的</figcaption></figure><blockquote class="jy jz ka"><p id="0077" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Javascript之后学习Java是我写的一个系列，记录我学习一门新语言的进展。</p></blockquote><p id="2f64" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我的关注者和积极支持者都知道，我最近完成了一个软件工程训练营，在那里我学习了Ruby、Rails、Javascript和React。为了在找工作的同时继续学习，我已经决定从<strong class="ke ir">构建Java程序</strong>(<a class="ae ld" href="https://www.thriftbooks.com/w/building-java-programs-a-back-to-basics-approach_stuart-reges/296941/#edition=7929069&amp;idiq=7923614" rel="noopener ugc nofollow" target="_blank">https://www . thrift books . com/w/Building-Java-Programs-a-back-to-basics-approach _ Stuart-reges/296941/# edition = 7929069&amp;idiq = 7923614</a>)这本书里拿起Java。</p><p id="bf4e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在今天的帖子中，我将通过展示如何在树状数据结构中实现广度优先和深度优先搜索来说明Java和Javascript之间的语法差异。下面的例子使用了一个简单的节点类。这些节点放在一起时会创建一个无环的树状结构。以下是Javascript和Java中的节点类:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Javascript中的节点类</figcaption></figure></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Java中的节点类</figcaption></figure><p id="db2a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在声明“静态类节点”的下面是节点类的属性。名为children的数组列表是用名为List的接口创建的。这通常在Java中完成，因为有许多不同的数组结构，如果以后你决定使用不同的结构，你只需要改变一个数组列表<node>()。下面是这个类的构造方法。</node></p><h2 id="145f" class="lr ls iq bd lt lu lv dn lw lx ly dp lz la ma mb mc lb md me mf lc mg mh mi mj bi translated">广度优先遍历</h2><p id="9390" class="pw-post-body-paragraph kb kc iq ke b kf mk kh ki kj ml kl km la mm kp kq lb mn kt ku lc mo kx ky kz ij bi translated">广度优先遍历首先从左到右，然后从上到下遍历树。我的解决方案使用队列。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Javascript中的广度优先遍历函数</figcaption></figure><p id="00cb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">该函数接收一个空数组，并返回该数组，其中包含从每个节点推入的数据。我首先声明一个队列，并将根节点推入其中。当队列长度不为0(或大于0)时，将第一个节点移出队列，将数据存储到数组中，并将该节点的每个子节点推送到队列中。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">Java中的广度优先遍历函数</figcaption></figure><p id="c5da" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这个函数在Java中的工作方式是一样的，尽管Java有一个可以从java.util包中使用的队列接口。在这里，我们将队列创建为一个链表，并依赖于我之前提到的一些内置的队列方法。</p><h2 id="8381" class="lr ls iq bd lt lu lv dn lw lx ly dp lz la ma mb mc lb md me mf lc mg mh mi mj bi translated">深度优先遍历</h2><p id="86be" class="pw-post-body-paragraph kb kc iq ke b kf mk kh ki kj ml kl km la mm kp kq lb mn kt ku lc mo kx ky kz ij bi translated">深度优先遍历从根节点移动到最左边的叶子，然后垂直到达每个叶子节点。我的解决方案使用递归来遍历每个节点。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="0d2a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">非常短的实现。我将数据从第一个节点推入数组，然后使用for of循环遍历节点的每个子节点，并对每个子节点调用深度优先搜索函数。这将在移动到右边的节点之前，将对每个最左边的节点的函数的调用添加到堆栈的叶节点。</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="fb01" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">在Java中也非常相似。一个显著的区别是，我们不能使用类似for of循环的东西，因为我们节点的children属性是一个ArrayList，为此我们必须使用常规的for循环。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="da0b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">我并没有详细讨论这两种语言中的一些句法差异；我只是想为那些有兴趣在学习Javascript之后学习Java的人展示这个算法的解决方案的并排比较。我强烈建议解析Java解决方案，并查找任何您不清楚的关键字。</p></div></div>    
</body>
</html>