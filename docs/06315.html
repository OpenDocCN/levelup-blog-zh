<html>
<head>
<title>Functional One-Liners in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia中的函数式一行程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-one-liners-in-julia-e0ed35d4ff7b?source=collection_archive---------1-----------------------#2020-11-15">https://levelup.gitconnected.com/functional-one-liners-in-julia-e0ed35d4ff7b?source=collection_archive---------1-----------------------#2020-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3f35" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Julia中提高函数式编程技能的实用日常技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7104bacad618a2c0f6c42d19b3b6b60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VtUqyqctMRvEIvScSYIQfw.png"/></div></div></figure><p id="77c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">作为一门如此富于表现力的语言，在为Julia编程时，很容易开始思考:</p><blockquote class="lz"><p id="0c6e" class="ma mb it bd mc md me mf mg mh mi lp dk translated">难道没有一种更良心、更优雅的方式来解决这个问题吗？</p></blockquote><p id="4bbc" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">许多问题可以用你熟悉的其他语言的方法直接解决。然而，在朱莉娅的作品中，往往有一种更简短、更清晰的做事方式。</p><h1 id="40e0" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">部分应用</h1><p id="f42e" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">Haskell推广了函数的部分应用或currying。这意味着不需要提供所有的参数，你就可以返回一个新的函数，并接受其余的参数。</p><p id="1534" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这听起来可能有些混乱，所以让我举一些例子。通常你会做这样的比较:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="50b4" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> 3 &lt; 4<br/>true</span></pre><p id="7a69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这和这个是一样的，因为Julia中的几乎所有东西都是一个函数:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="8e4b" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> &lt;(3, 4)<br/>true</span></pre><p id="d288" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你不提供所有的论据会怎么样？</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="0b8b" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> &lt;(4)<br/>(::Base.Fix2{typeof(&lt;),Int64}) (generic function with 1 method)</span></pre><p id="651c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">取而代之的是一个可调用的对象。我们可以把它储存起来，以后再用:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="f8ad" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> f = &lt;(4);<br/><br/><strong class="nm iu">julia&gt;</strong> f(3)<br/>true</span></pre><p id="4c17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这有什么用？使用<code class="fe nv nw nx nm b">map</code>、<code class="fe nv nw nx nm b">filter</code>和<code class="fe nv nw nx nm b">reduce</code>这样的函数真的很优雅。</p><h2 id="54e3" class="nq mp it bd mq ny nz dn mu oa ob dp my ld oc od na lh oe of nc ll og oh ne oi bi translated">查找所有小于值的元素</h2><p id="42f7" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">查找列表或区域中小于给定值的元素。<code class="fe nv nw nx nm b"> julia&gt; filter(&lt;(5), 1:10) 4-element Array{Int64,1}: 1 2 3 4</code></p><p id="f31c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您也可以使用它来查找更大的值:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="1b3c" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> filter(&gt;(5), 1:10)<br/>5-element Array{Int64,1}:<br/>  6<br/>  7<br/>  8<br/>  9<br/> 10</span></pre><h2 id="6d20" class="nq mp it bd mq ny nz dn mu oa ob dp my ld oc od na lh oe of nc ll og oh ne oi bi translated">查找元素的索引</h2><p id="bccc" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">我们可以找到数字4每次出现的索引</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="f76b" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> findall(==(4), [4, 8, 4, 2, 1, 5])<br/>2-element Array{Int64,1}:<br/> 1<br/> 3</span></pre><p id="1252" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者我们可以只寻找第一次出现的:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="9fb3" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> findfirst(==(4), [4, 8, 4, 2, 1, 5])<br/>1</span></pre><p id="f08b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这当然同样适用于字符串:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="7c4c" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> findlast(==("foo"), ["bar", "foo", "qux", "foo"])<br/>4</span></pre><h2 id="350e" class="nq mp it bd mq ny nz dn mu oa ob dp my ld oc od na lh oe of nc ll og oh ne oi bi translated">过滤掉特定的文件类型</h2><p id="8c84" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">假设您想要获得当前目录中所有<code class="fe nv nw nx nm b">.png</code>文件的列表。你是怎么做到的？</p><p id="5a1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用<code class="fe nv nw nx nm b">endswith</code>功能。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="983a" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> endswith("somefile.png", ".png")<br/>true</span></pre><p id="7d07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像许多其他函数一样，它可以用于局部应用，这使得它在过滤器中使用非常方便:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="63f2" class="nq mp it nm b gy nr ns l nt nu">pngs = filter(endswith(".png"), readdir())</span></pre><h1 id="2111" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">谓词功能否定</h1><p id="4b26" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">很遗憾，我很晚才发现这是一个诡计。但是事实证明，您可以将<code class="fe nv nw nx nm b">!</code>放在一个函数的前面，产生一个反转其输出的新函数。这实际上不是Julia语言内置的，而是一个函数本身，定义为:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="4826" class="nq mp it nm b gy nr ns l nt nu">!(f::Function) = (x...)-&gt;!f(x...)</span></pre><p id="676c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想说的可能还不完全清楚，所以让我们看一些例子。</p><h2 id="2b55" class="nq mp it bd mq ny nz dn mu oa ob dp my ld oc od na lh oe of nc ll og oh ne oi bi translated">删除空行</h2><p id="4dd5" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">假设您读取了由<code class="fe nv nw nx nm b">filename</code>给定的文件中的所有行，并且您想要去掉空行，您可以这样做:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="d732" class="nq mp it nm b gy nr ns l nt nu">filter(line -&gt; !isempty(line), readlines(filename))</span></pre><p id="01ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是这是一个更优雅的方法，使用<code class="fe nv nw nx nm b">!</code>的部分应用:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="bc63" class="nq mp it nm b gy nr ns l nt nu">filter(!isempty, readlines(filename))</span></pre><p id="1f59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个在REPL上使用虚拟数据的示例:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="4b6c" class="nq mp it nm b gy nr ns l nt nu">julia&gt; filter(!isempty, ["foo", "", "bar", ""])<br/>2-element Array{String,1}:<br/> "foo"<br/> "bar"</span></pre><h1 id="392a" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">广播和地图</h1><p id="3ff0" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">Julia有<code class="fe nv nw nx nm b">broadcast</code>功能，你可以把它想象成一个奇特的地图版本。您甚至可以以类似的方式使用它:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="6717" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> map(sqrt, [9, 16, 25])<br/>3-element Array{Float64,1}:<br/> 3.0<br/> 4.0<br/> 5.0<br/><br/><strong class="nm iu">julia&gt;</strong> broadcast(sqrt, [9, 16, 25])<br/>3-element Array{Float64,1}:<br/> 3.0<br/> 4.0<br/> 5.0</span></pre><p id="dfe4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当处理带有多个参数的函数时，真正的力量就来了，您希望重用其中一个参数，而更改其他参数。</p><h2 id="3c6e" class="nq mp it bd mq ny nz dn mu oa ob dp my ld oc od na lh oe of nc ll og oh ne oi bi translated">将字符串列表转换为数字</h2><p id="a218" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">要将一个字符串转换成一个数字，可以像这样使用<code class="fe nv nw nx nm b">parse</code>函数:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="46a9" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> parse(Int, "42")<br/>42</span></pre><p id="7b70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将此应用于多个文本字符串的简单方法是编写:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="34c2" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> map(s -&gt; parse(Int, s), ["7", "42", "1331"])<br/>3-element Array{Int64,1}:<br/>    7<br/>   42<br/> 1331</span></pre><p id="8698" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以用<code class="fe nv nw nx nm b">broadcast</code>函数来简化这一点:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="ddee" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> broadcast(parse, Int, ["7", "42", "1331"])<br/>3-element Array{Int64,1}:<br/>    7<br/>   42<br/> 1331</span></pre><p id="4f56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，这在Julia中是如此有用和常见，以至于有一个使用点<code class="fe nv nw nx nm b">.</code>后缀的更短的版本:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e353" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> parse.(Int, ["7", "42", "1331"])<br/>3-element Array{Int64,1}:<br/>    7<br/>   42<br/> 1331</span></pre><p id="c85b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你甚至可以链接这个:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="54b4" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> sqrt.(parse.(Int, ["9", "16", "25"]))<br/>3-element Array{Float64,1}:<br/> 3.0<br/> 4.0<br/> 5.0</span></pre><h2 id="0f1a" class="nq mp it bd mq ny nz dn mu oa ob dp my ld oc od na lh oe of nc ll og oh ne oi bi translated">将蛇包转换为骆驼包</h2><p id="0b22" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">在编程中，我们经常有像<code class="fe nv nw nx nm b">hello_how_are_you</code>这样写的标识符，我们可能想把它转换成像<code class="fe nv nw nx nm b">HelloHowAreYou</code>这样写的camel case。事实证明，在Julia中只需一行代码就可以轻松做到这一点。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="0641" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> greeting = "hello_how_are_you"<br/>"hello_how_are_you"<br/><br/><strong class="nm iu">julia&gt;</strong> join(uppercasefirst.(split(greeting, '_')))<br/>"HelloHowAreYou"</span></pre><h2 id="8619" class="nq mp it bd mq ny nz dn mu oa ob dp my ld oc od na lh oe of nc ll og oh ne oi bi translated">避免管道运算符的深度嵌套</h2><p id="5827" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">OOP爱好者对更面向函数的语言(如Julia)的一个常见抱怨是，很难读懂深度嵌套的函数调用。然而，我们可以通过使用管道操作符<code class="fe nv nw nx nm b">|&gt;.</code>来避免深度嵌套，这只是为了简单说明它的作用。下面是等效表达式的一个示例:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="dfb4" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> string(sqrt(16))<br/>"4.0"</span><span id="37a0" class="nq mp it nm b gy oj ns l nt nu"><strong class="nm iu">julia&gt;</strong> 16 |&gt; sqrt |&gt; string<br/>"4.0"</span></pre><p id="7f17" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这也适用于广播，因此您可以使用它在一种管道中的阶段之间传输多个值。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="89aa" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> [16, 4, 9] .|&gt; sqrt .|&gt; string<br/>3-element Vector{String}:<br/> "4.0"<br/> "2.0"<br/> "3.0"</span></pre><p id="fb04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，我们就可以把蛇的例子简化为骆驼的例子。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="8d2d" class="nq mp it nm b gy nr ns l nt nu"><strong class="nm iu">julia&gt;</strong> split(greeting, '_') .|&gt; uppercasefirst |&gt; join<br/>"HelloHowAreYou"</span></pre></div></div>    
</body>
</html>