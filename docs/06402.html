<html>
<head>
<title>How to Use AWS Nitro Enclaves Attestation Document</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用AWS Nitro Enclaves认证文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-aws-nitro-enclaves-attestation-document-7824e176ffa4?source=collection_archive---------3-----------------------#2020-11-22">https://levelup.gitconnected.com/how-to-use-aws-nitro-enclaves-attestation-document-7824e176ffa4?source=collection_archive---------3-----------------------#2020-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4c78" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的上一篇博客文章<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/running-python-app-on-aws-nitro-enclaves-56024667b684">中，在AWS Nitro Enclaves </a>上运行Python应用程序，我简要介绍了什么是<strong class="js iu"> AWS Nitro Enclaves </strong>，并演示了网络连接如何在Nitro Enclaves上工作。</p><p id="2a2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本周，我将讲述如何利用由<strong class="js iu"> Nitro安全模块(NSM) </strong>生成的证明文件。</p><h1 id="df45" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">常见场景</h1><p id="0b1a" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">AWS Nitro Enclaves是隔离的计算环境，可以安全地处理高度敏感的数据。当与enclave之外的其他组件(例如中央秘密存储)通信时，我们也希望这个过程尽可能安全。两个主要问题是:</p><ol class=""><li id="fcfe" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">外部组件如何知道它是否与正确的enclave映像通信，而不是与冒充enclave的攻击者通信？</li><li id="4e3f" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">我们如何保护enclave和外部组件之间传输的数据？</li></ol><p id="5c0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，AWS Nitro Enclaves提供了一个认证机制，其细节在<a class="ae ko" href="https://docs.aws.amazon.com/enclaves/latest/user/verify-root.html" rel="noopener ugc nofollow" target="_blank"> AWS文档</a>中提供。但是为了更容易理解它，我为您创建了一个Python演示来进行实际操作。</p><div class="mg mh gp gr mi mj"><a href="https://github.com/richardfan1126/nitro-enclave-python-demo/tree/master/attestation_verifier" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd iu gy z fp mo fr fs mp fu fw is bi translated">Richard fan 1126/nitro-enclave-python-demo</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">该项目展示了我们如何验证由AWS Nitro Enclaves的Nitro安全模块(NSM)生成的证明文件…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">github.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx my mj"/></div></div></a></div><h1 id="7529" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">组件</h1><ol class=""><li id="54a7" class="ls lt it js b jt ln jx lo kb mz kf na kj nb kn lx ly lz ma bi translated"><strong class="js iu">客户端</strong> <br/>这是为了模拟依赖于安全进程输出的通用组件。例如，支持SSO的网站需要知道用户是否已经过身份验证。</li><li id="d77a" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated"><strong class="js iu">服务器<br/> </strong>这是模拟处理敏感数据的流程。在前面的示例中，它将是SSO身份验证者，它可以访问OAuth应用程序机密来进行身份验证。</li><li id="f2d3" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated"><strong class="js iu"> SecretStore </strong> <br/>这是模拟存储秘密的中央数据库。在前面的例子中，它是存储不同SSO提供者的应用程序秘密的数据库。</li></ol><p id="db4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，为了简单起见，演示不会对秘密执行任何处理，因为这不是我们的重点。它只是将秘密的明文传递给客户端。</p><h1 id="1487" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">该过程</h1><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nc"><img src="../Images/5618c15363d271d5039158b68a69c74d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQWFBpog_Clz58nHPnPN0Q.png"/></div></div></figure><h2 id="ae72" class="nn kq it bd kr no np dn kv nq nr dp kz kb ns nt ld kf nu nv lh kj nw nx ll ny bi translated">1.客户端发送请求</h2><p id="044e" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">用户首先运行客户端应用程序，并将请求发送到服务器应用程序。这部分就像通过vsock通道发送一个JSON字符串一样简单</p><h2 id="aecc" class="nn kq it bd kr no np dn kv nq nr dp kz kb ns nt ld kf nu nv lh kj nw nx ll ny bi translated">2.生成加密密钥对的服务器</h2><p id="184b" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">当我们启动服务器应用程序时，它会生成一个随机的RSA密钥对。公钥将在每次请求时被发送到SecretStore。它用于加密从SecretStore到服务器的响应，以便只有服务器可以解密并获得实际内容。</p><p id="d3da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了生成随机密钥，大多数软件依赖于<code class="fe nz oa ob oc b">/dev/urandom</code>来生成随机值。这个特性在AWS Nitro Enclaves中不可用，但幸运的是，Luc van Donkersgoed在他的<a class="ae ko" href="https://github.com/donkersgoed/nitropepper-enclave-app/blob/main/kms.py" rel="noopener ugc nofollow" target="_blank">Nitro epper</a>项目中通过指示<strong class="js iu"> Crypto </strong> python包使用NSM提供的随机值生成器解决了这个问题。你可以阅读<a class="ae ko" href="https://www.sentiatechblog.com/ultra-secure-password-storage-with-nitropepper" rel="noopener ugc nofollow" target="_blank">他的博客文章</a>了解更多细节。</p><pre class="nd ne nf ng gt od oc oe of aw og bi"><span id="73f0" class="nn kq it oc b gy oh oi l oj ok">@classmethod<br/>def _monkey_patch_crypto(cls, nsm_rand_func):<br/>    """Monkeypatch Crypto to use the NSM rand function."""<br/>    Crypto.Random.get_random_bytes = nsm_rand_func<br/>    def new_random_read(self, n_bytes):<br/>        return nsm_rand_func(n_bytes)<br/>    Crypto.Random._UrandomRNG.read = new_random_read</span></pre><h2 id="7880" class="nn kq it bd kr no np dn kv nq nr dp kz kb ns nt ld kf nu nv lh kj nw nx ll ny bi translated">3.生成证明文档</h2><p id="2752" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">证明文档由NSM生成，AWS已经实现了一个<a class="ae ko" href="https://github.com/aws/aws-nitro-enclaves-nsm-api" rel="noopener ugc nofollow" target="_blank"> SDK </a>(用Rust编写)来执行请求。再次感谢Luc van Donkersgoed，他修改了代码<a class="ae ko" href="https://github.com/donkersgoed/aws-nitro-enclaves-nsm-api/commit/112a450082d108bf466ca57e687beaaeff19db4a" rel="noopener ugc nofollow" target="_blank">并使其可以在Python中使用。</a></p><pre class="nd ne nf ng gt od oc oe of aw og bi"><span id="2053" class="nn kq it oc b gy oh oi l oj ok">def get_attestation_doc(self):<br/>    """Get the attestation document from /dev/nsm."""<br/>    libnsm_att_doc_cose_signed = libnsm.nsm_get_attestation_doc(<br/>        self._nsm_fd,<br/>        self._public_key,<br/>        len(self._public_key)<br/>    )<br/>    return libnsm_att_doc_cose_signed</span></pre><p id="4439" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">证明文档有一个可选字段<code class="fe nz oa ob oc b">public_key</code>供消费者用来加密数据。在我们的例子中，我们将把步骤2中生成的公钥放入这个字段中(通过第二个参数<code class="fe nz oa ob oc b">nsm_get_attestation_doc</code>，它将被SecretStore使用。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi ol"><img src="../Images/1fc39e29876edb16b1b3247225a2a673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b47AqWkwNGD_Cxc13BtvCA.png"/></div></div><figcaption class="om on gj gh gi oo op bd b be z dk translated">证明文件中有一个可选字段<strong class="bd kr"> public_key </strong></figcaption></figure><p id="f529" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">证明文件编码为<a class="ae ko" href="https://en.wikipedia.org/wiki/CBOR" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">【简明二进制对象表示(CBOR)】</strong></a>，为二进制数据形式。我们将做一个base64编码，这样我们可以把它放在请求有效载荷中。</p><pre class="nd ne nf ng gt od oc oe of aw og bi"><span id="a56e" class="nn kq it oc b gy oh oi l oj ok"># Base64 encode the attestation doc<br/>attestation_doc_b64 = base64.b64encode(attestation_doc).decode()</span><span id="db0a" class="nn kq it oc b gy oq oi l oj ok"># Generate JSON request<br/>secretstore_request = json.dumps({<br/>    'attestation_doc_b64': attestation_doc_b64<br/>})</span><span id="87a0" class="nn kq it oc b gy oq oi l oj ok"># Send the request to secretstore<br/>secretstore_socket.send(str.encode(secretstore_request))</span></pre><h2 id="90d8" class="nn kq it bd kr no np dn kv nq nr dp kz kb ns nt ld kf nu nv lh kj nw nx ll ny bi translated">4.将请求发送到SecretStore</h2><p id="655b" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在我们的演示中，因为所有东西都在同一个实例中，所以我们完全通过vsock通道从服务器向SecretStore发送请求。</p><p id="9bae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是在现实生活中，秘密商店很可能在别处。为了在实例外部建立连接并避免传输中的数据被攻击者读取，我建议使用HTTPS。关于如何从enclave建立HTTPS连接，你可以按照我之前在http-proxy上的演示来做。</p><h2 id="3cab" class="nn kq it bd kr no np dn kv nq nr dp kz kb ns nt ld kf nu nv lh kj nw nx ll ny bi translated">5.验证证明文档</h2><p id="b896" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">为了验证证明文档，我们将做3件事:</p><ol class=""><li id="d883" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated"><strong class="js iu">匹配PCR</strong>—检查请求是否由所需的enclave映像生成。</li><li id="2c33" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated"><strong class="js iu">验证签名</strong> —确保请求的完整性，即请求未被修改。</li><li id="f3a6" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated"><strong class="js iu">验证证书</strong> —确保请求由<strong class="js iu"> AWS Nitro认证公钥基础设施(PKI) </strong>下的有效证书签名。这是通过根据AWS提供的根证书验证证书来完成的。</li></ol><p id="949f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">证明文档以<strong class="js iu"> CBOR </strong>编码，并使用<a class="ae ko" href="https://tools.ietf.org/html/rfc8152" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> CBOR对象签名和加密(COSE) </strong> </a>进行签名。我们将使用Python包<code class="fe nz oa ob oc b"><a class="ae ko" href="https://pypi.org/project/cbor2/" rel="noopener ugc nofollow" target="_blank">cbor2</a></code>和<code class="fe nz oa ob oc b"><a class="ae ko" href="https://pypi.org/project/cose/" rel="noopener ugc nofollow" target="_blank">cose</a></code>来进行解码和签名验证。证明文件的细节可在<a class="ae ko" href="https://github.com/aws/aws-nitro-enclaves-nsm-api/blob/main/docs/attestation_process.md" rel="noopener ugc nofollow" target="_blank"> AWS文件</a>中找到。</p><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div class="gh gi or"><img src="../Images/fbd516024c59c5de0603701948c4e446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*twc5pKA8gxB_vXkzVq0FDg.png"/></div><figcaption class="om on gj gh gi oo op bd b be z dk translated">包含证明文档的CBOR对象的结构</figcaption></figure><p id="40d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了获得证明文档，我们需要解码CBOR对象并获得该对象的第三个值。</p><pre class="nd ne nf ng gt od oc oe of aw og bi"><span id="7fb1" class="nn kq it oc b gy oh oi l oj ok"># Decode CBOR attestation document<br/>data = cbor2.loads(attestation_doc)</span><span id="c99a" class="nn kq it oc b gy oq oi l oj ok"># Load and decode document payload<br/>doc = data[2]<br/>doc_obj = cbor2.loads(doc)</span></pre><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi os"><img src="../Images/795d46e07c52fd6fd6403ba94d8d67ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMWdekorSXEC5hs8xJiiDw.png"/></div></div><figcaption class="om on gj gh gi oo op bd b be z dk translated">证明文件的结构</figcaption></figure></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="8c91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们将从文档中获得<strong class="js iu">PCR</strong>值，这些值是飞地的测量值。</p><p id="28dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们构建了服务器应用程序enclave映像之后，我们可以获得映像的PCRs值。我们可以检查证明文档中的值是否与它们匹配，以验证请求是由同一个enclave映像生成的。</p><p id="39fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有关PCR的更多详细信息，请查看<a class="ae ko" href="https://docs.aws.amazon.com/enclaves/latest/user/set-up-attestation.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="7091" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">匹配PCR后，我们将验证文档的签名。</p><p id="5ab4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该证明文件采用<a class="ae ko" href="https://pycose.readthedocs.io/en/latest/cose/messages/sign1message.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> COSE签名1 </strong> </a>格式并由证书签名。我们可以从文件中的<code class="fe nz oa ob oc b">certificate</code>字段获得证书。</p><p id="52fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">AWS Nitro Enclaves使用<strong class="js iu"> ES384 </strong>算法对文档进行签名。为了验证签名，我们将通过证书公钥的参数(即x/y坐标和曲线)创建一个<a class="ae ko" href="https://pycose.readthedocs.io/en/latest/cose/keys/ec2.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> EC2密钥</strong> </a>。</p><pre class="nd ne nf ng gt od oc oe of aw og bi"><span id="51aa" class="nn kq it oc b gy oh oi l oj ok"># Get signing certificate from attestation document<br/>cert = crypto.load_certificate(<br/>    crypto.FILETYPE_ASN1,<br/>    doc_obj['certificate']<br/>)</span><span id="3245" class="nn kq it oc b gy oq oi l oj ok"># Get the key parameters from the cert public key<br/>cert_public_numbers = cert.get_pubkey()\<br/>    .to_cryptography_key().public_numbers()<br/>x = long_to_bytes(cert_public_numbers.x)<br/>y = long_to_bytes(cert_public_numbers.y)</span><span id="1b5e" class="nn kq it oc b gy oq oi l oj ok"># Create the EC2 key from public key parameters<br/>key = EC2(<br/>    alg = CoseAlgorithms.ES384,<br/>    x   = x,<br/>    y   = y,<br/>    crv = CoseEllipticCurves.P_384<br/>)</span></pre><p id="361c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构造密钥后，我们将从接收到的数据中构造<strong class="js iu"> Sign1 </strong>消息，并对照<strong class="js iu"> EC2密钥</strong>进行验证。</p><pre class="nd ne nf ng gt od oc oe of aw og bi"><span id="5071" class="nn kq it oc b gy oh oi l oj ok"># Get the protected header from attestation document<br/>phdr = cbor2.loads(data[0])</span><span id="e8b2" class="nn kq it oc b gy oq oi l oj ok"># Construct the Sign1 message<br/>msg = cose.Sign1Message(phdr = phdr, uhdr = data[1], payload = doc)<br/>msg.signature = data[3]</span><span id="63fc" class="nn kq it oc b gy oq oi l oj ok"># Verify the signature using the EC2 key<br/>if not msg.verify_signature(key):<br/>    raise Exception("Wrong signature")</span></pre></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="a563" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">验证的最后一部分是验证证书本身。</p><p id="3fde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们使用同一文档中提供的证书来验证签名。我们需要确保证书本身是有效的，但不是由其他方颁发的(可能是攻击者的自签名证书)。</p><p id="dfa1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们将验证所提供的CA包是否由<strong class="js iu"> AWS Nitro认证公钥基础设施(PKI) </strong>的CA根证书签名。</p><p id="1681" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根证书可以在<a class="ae ko" href="https://docs.aws.amazon.com/enclaves/latest/user/verify-root.html#validation-process" rel="noopener ugc nofollow" target="_blank"> AWS文档</a>中找到。</p><pre class="nd ne nf ng gt od oc oe of aw og bi"><span id="0ee3" class="nn kq it oc b gy oh oi l oj ok"># Create an X509Store object for the CA bundles<br/>store = crypto.X509Store()</span><span id="5287" class="nn kq it oc b gy oq oi l oj ok"># Create the CA cert object from PEM string,<br/># and store into X509Store<br/>_cert = crypto.load_certificate(crypto.FILETYPE_PEM, root_cert_pem)<br/>store.add_cert(_cert)</span><span id="becf" class="nn kq it oc b gy oq oi l oj ok"># Get the CA bundle from attestation document<br/># and store into X509Store<br/># Except the first certificate, which is the root certificate<br/>for _cert_binary in doc_obj['cabundle'][1:]:<br/>    _cert = crypto.load_certificate(<br/>        crypto.FILETYPE_ASN1,<br/>        _cert_binary<br/>    )<br/>    store.add_cert(_cert)</span><span id="b3b5" class="nn kq it oc b gy oq oi l oj ok"># Get the X509Store context<br/>store_ctx = crypto.X509StoreContext(store, cert)</span><span id="2dfc" class="nn kq it oc b gy oq oi l oj ok"># Validate the certificate<br/># If the cert is invalid, it will raise exception<br/>store_ctx.verify_certificate()</span></pre><h2 id="fbed" class="nn kq it bd kr no np dn kv nq nr dp kz kb ns nt ld kf nu nv lh kj nw nx ll ny bi translated">6.将秘密加密并发送回飞地</h2><p id="2641" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">在将秘密发送回enclave之前，我们将使用服务器应用程序的公钥对其进行加密。密钥在我们启动enclave server应用程序时生成，并在证明文档中发送。</p><p id="10e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过这样做，我们可以确保只有服务器应用程序可以读取秘密，即使消息被其他方捕获。这非常重要，因为Nitro Enclave没有直接的网络访问，SecretStore和Enclave之间的连接很可能通过EC2实例，我们不希望它们读取它。</p><p id="e507" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们使用与上一步相同的方法，解码CBOR对象，以获得服务器应用程序的公钥。然后我们用<a class="ae ko" href="https://pycryptodome.readthedocs.io/en/latest/src/cipher/oaep.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu"> PKCS1_OAEP </strong> </a>对秘密进行加密，将密文编码成base64格式，发回服务器app。</p><pre class="nd ne nf ng gt od oc oe of aw og bi"><span id="3fdd" class="nn kq it oc b gy oh oi l oj ok"># Decode CBOR attestation document<br/>data = cbor2.loads(attestation_doc)</span><span id="d1ca" class="nn kq it oc b gy oq oi l oj ok"># Load and decode document payload<br/>doc = data[2]<br/>doc_obj = cbor2.loads(doc)</span><span id="ef18" class="nn kq it oc b gy oq oi l oj ok"># Get the public key from attestation document<br/>public_key_byte = doc_obj['public_key']<br/>public_key = RSA.import_key(public_key_byte)</span><span id="7594" class="nn kq it oc b gy oq oi l oj ok"># Encrypt the plaintext with the public key<br/># and encode the cipher text in base64<br/>cipher = PKCS1_OAEP.new(public_key)<br/>ciphertext = cipher.encrypt(str.encode(plaintext))</span><span id="5d6f" class="nn kq it oc b gy oq oi l oj ok">return base64.b64encode(ciphertext).decode()</span></pre><h2 id="7398" class="nn kq it bd kr no np dn kv nq nr dp kz kb ns nt ld kf nu nv lh kj nw nx ll ny bi translated"><strong class="ak"> 7。解密秘密并对其执行业务逻辑</strong></h2><p id="2cdd" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">server应用程序收到SecretStore的响应后，会使用自己的私钥来解密这个秘密。之后，我们可以对其执行业务逻辑，并将结果发送回客户端。</p><pre class="nd ne nf ng gt od oc oe of aw og bi"><span id="1193" class="nn kq it oc b gy oh oi l oj ok">def decrypt(self, ciphertext):<br/>    """<br/>    Decrypt ciphertext using private key<br/>    """<br/>    cipher = PKCS1_OAEP.new(self._rsa_key)<br/>    plaintext = cipher.decrypt(ciphertext)</span><span id="8109" class="nn kq it oc b gy oq oi l oj ok">    return plaintext.decode()</span><span id="2c2d" class="nn kq it oc b gy oq oi l oj ok"># Decrypt ciphertext using private key<br/>plaintext = nsm_util.decrypt(ciphertext)</span><span id="6063" class="nn kq it oc b gy oq oi l oj ok"># Perform the business logic on the plaintext secret</span><span id="bced" class="nn kq it oc b gy oq oi l oj ok"># Send the plaintext back to client<br/>client_connection.sendall(str.encode(plaintext))</span></pre><p id="1bfc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个演示中，我们不打算执行任何业务逻辑，而是直接将秘密发送回客户端。</p><h1 id="e527" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">可能的使用案例</h1><p id="d0c1" class="pw-post-body-paragraph jq jr it js b jt ln jv jw jx lo jz ka kb lp kd ke kf lq kh ki kj lr kl km kn im bi translated">当我们有经常使用的静态秘密时，这个演示中显示的模式很有用。例如</p><ol class=""><li id="1635" class="ls lt it js b jt ju jx jy kb lu kf lv kj lw kn lx ly lz ma bi translated">SSO应用程序机密</li><li id="6284" class="ls lt it js b jt mb jx mc kb md kf me kj mf kn lx ly lz ma bi translated">证书私钥</li></ol><p id="a3f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通常，我们会将这些秘密保存在一个单独的组件中。当请求到来时，它将在那个中央组件中被处理。例如，当用户请求SSO登录时，该请求将被重定向到有权访问SSO应用程序密码的验证者。</p><p id="9fed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是在使用Nitro Enclaves后，我们可以安全地将应用程序秘密传递到enclave中，并将认证工作卸载给它，而不会将应用程序秘密暴露给服务器管理员。</p><p id="6318" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，因为我们控制了整个流程，所以我们可以定制业务逻辑并将其添加到“SecretStore”中，使其不仅仅是一个商店。</p><h1 id="26b2" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">特征图像</h1><figure class="nd ne nf ng gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi pa"><img src="../Images/de14de5d06020745343158924777d2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LeLPGvole57i4s0O"/></div></div><figcaption class="om on gj gh gi oo op bd b be z dk translated"><a class="ae ko" href="https://unsplash.com/@cytonn_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Cytonn摄影</a>在<a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure></div></div>    
</body>
</html>