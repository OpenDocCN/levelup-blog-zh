<html>
<head>
<title>Constraint Programming in a big nut-shell 🐚</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大坚果壳中的约束编程🐚</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cp-solver-in-a-big-nut-shell-ba03f8fdd8b9?source=collection_archive---------3-----------------------#2020-12-29">https://levelup.gitconnected.com/cp-solver-in-a-big-nut-shell-ba03f8fdd8b9?source=collection_archive---------3-----------------------#2020-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d694" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我自己理解的约束编程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a217ef8a7b11a663b391669db4ceee18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3weCI1VutBffPwUZ31bMkQ.png"/></div></div></figure><h1 id="17e1" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">这是怎么回事？</h1><p id="68fb" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我最近有机会在一个工作项目中使用约束编程，创建一个“调度程序”功能，可以帮助人们生成时间表，并且足够灵活，可以在未来轻松扩展/修改。</p><p id="aa46" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们不是以“自下而上”的方式解决问题，而是以“自上而下”的方式解决问题，这一开始就令人难以置信。</p><h1 id="da17" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">自上而下与自下而上</h1><p id="2cf3" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">首先，我对什么是自顶向下和自底向上的定义不同于正确的，<a class="ae mk" href="https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design" rel="noopener ugc nofollow" target="_blank">对它是什么的官方定义</a>，就计算机科学和编程而言。在这种情况下，我对“自上而下”方法的定义是，首先从一个问题的所有答案开始，然后通过过滤掉所有错误的答案，“向下”找到解决方案集。所以我定义的“自下而上”的方法是相反的；从没有答案开始，然后启发式地建立可能的解决方案，并将它们添加到答案集中。</p><p id="0d9f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">通常，当试图想出一种算法来解决某个问题时，你会自然而然地想到自底向上的方法，而不是自顶向下的方法。让我们举一个简单的例题:</p><blockquote class="ml mm mn"><p id="aa05" class="lj lk mo ll b lm mf jr lo lp mg ju lr mp mh lu lv mq mi ly lz mr mj mc md me ij bi translated">2Sum —给定一个整数列表，找出所有唯一对的列表，这些对的总和将达到一个目标数</p></blockquote><p id="2392" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">输入数字:<code class="fe ms mt mu mv b">[1,0,-1,2,-2]</code></p><p id="f857" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">目标:<code class="fe ms mt mu mv b">0</code></p><p id="091f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">自底向上的方法可能如下所示:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="0871" class="na ks iq mv b gy nb nc l nd ne"># pseudo-python style<br/>#1. sort the list</span><span id="8a4f" class="na ks iq mv b gy nf nc l nd ne">sorted_nums = sorted(nums) # [-2, -1, 0, 1, 2]</span><span id="2f86" class="na ks iq mv b gy nf nc l nd ne">#2. loop through the sorted list with 2 pivots at the ends<br/># check if sum is == target<br/># if it is, add to set of answers<br/># if sum &gt; target, move right_pivot to left<br/># if sum &lt; target, move left_pivot to right</span><span id="4d0d" class="na ks iq mv b gy nf nc l nd ne">l_pivot = 0<br/>r_pivot = len(sorted_nums) - 1</span><span id="c035" class="na ks iq mv b gy nf nc l nd ne">pairs = set()</span><span id="d114" class="na ks iq mv b gy nf nc l nd ne">while l_pivot &gt; r_pivot:<br/>  sum = sorted_nums[l_pivot] + sorted_nums[r_pivot]<br/>  if sum == target:<br/>    answers.add((sorted_nums[l_pivot], sorted_nums[r_pivot]))<br/>    l_pivot += 1<br/>    r_pivot -= 1<br/>  elif sum &gt; target:<br/>    r_pivot -= 1<br/>  else: # sum &lt; target:<br/>    l_pivot += 1</span><span id="4e0d" class="na ks iq mv b gy nf nc l nd ne">#3. return list of unique pairs<br/>return list(pairs)</span></pre><p id="c791" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">要注意的关键点是，你从一个空的答案列表开始，并尝试启发式地建立答案列表。</p><p id="a530" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这是我想象的自上而下方法的样子:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="45c2" class="na ks iq mv b gy nb nc l nd ne"># 0.5 Generate all possible pairs from list of numbers</span><span id="dd8a" class="na ks iq mv b gy nf nc l nd ne">nums_with_idx = list(enumerate(nums))<br/>all_pairs = []<br/>for idx_1, num_1 in nums_with_idx:<br/>  for idx_2, num_2 in nums_with_idx:<br/>    if idx_1== idx_2: # same num<br/>      continue<br/>    elif num_1 &lt; num_2: # have some ordering for uniqueness<br/>      all_pairs.append((num_1, num_2))<br/>    else: # equal or num_1 &gt; num_2<br/>      all_pairs.append((num_2, num_1))</span><span id="f674" class="na ks iq mv b gy nf nc l nd ne"># 1. scan through all the pairs<br/># for each pair, if they don't add up to the target<br/># remove them from the list</span><span id="7244" class="na ks iq mv b gy nf nc l nd ne">for idx, pair in all_pairs:<br/>  if pair[0] + pair[1] != target:<br/>    all_pairs.pop(idx)</span><span id="bc41" class="na ks iq mv b gy nf nc l nd ne"># 2. put them in a set, and return list of unique pairs<br/>return list(set(all_pairs))</span></pre><p id="100e" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">看起来自上而下的方法是浪费且过于昂贵的，因为事实就是如此。通常，当考虑问题的解决方案时，我们希望制定一个可以使用尽可能少的内存/计算的好算法，而“自顶向下”的方法似乎只是一种丑陋的暴力方法。在这种情况下，我们为什么还要为自顶向下的方法烦恼呢？</p><h2 id="e9b7" class="na ks iq bd kt ng nh dn kx ni nj dp lb ls nk nl ld lw nm nn lf ma no np lh nq bi translated">求解器的通用性</h2><p id="8f42" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">自顶向下算法可能比自底向上算法更好的一个原因是求解器/算法的通用性。在许多情况下，自上而下的方法比自下而上的方法更适用于一般情况。</p><p id="76b6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们考虑一下，如果要解决的问题不是一个2Sum问题，而是一个XSum问题，上面两个现有的2Sum算法中哪一个会更合适？自底向上的2Sum算法需要完全重写，以便它不仅可以处理一对数字，还可以生成一组唯一的答案。自顶向下的2Sum算法可以很容易地修改来解决XSum问题的情况，只需要首先生成所有可能的组合，然后遍历所有组合数的总和来找到答案(即使它的时间复杂度将呈指数增长并且很快不可行)。</p><p id="6895" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">如果正确的解决方案要求您至少查看每个可能的答案至少一次，那么在计算复杂性方面，自顶向下的方法可能与自底向上的方法类似。</p><h2 id="5c02" class="na ks iq bd kt ng nh dn kx ni nj dp lb ls nk nl ld lw nm nn lf ma no np lh nq bi translated">最优化问题</h2><p id="1789" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我能想到的另一个原因是，自顶向下求解器通常是解决大多数优化问题的工具。</p><p id="4ae9" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">优化问题是指从所有可行的解决方案中寻找最佳解决方案的问题。由于自上而下的求解者已经从“整体”解决方案集开始，很容易看出使用自上而下的方法找到“最佳”解决方案并不是什么大问题。</p><p id="f3b6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">一般来说，任何涉及寻找所有解中的某个最优解的问题都可以定义为优化问题。一些著名的优化问题是背包问题、装箱问题或旅行推销员问题，它们都属于组合优化问题的范畴。</p><h1 id="8c41" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">为什么要约束编程？</h1><p id="4e7d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在直接进入什么是约束编程之前，我们需要首先理解它可以帮助解决的问题。约束编程用于帮助解决约束满足问题和约束优化问题。</p><p id="ea1a" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">有几个概念你需要知道，即<strong class="ll ir">变量</strong>，变量的<strong class="ll ir">域</strong>和问题的<strong class="ll ir">约束</strong>。这基本上类似于一个数学问题，其中给你规则和限制，然后要求你求解x/y/z。例如，假设你试图求解方程<code class="fe ms mt mu mv b">x + y = z</code>，其中x ∈ {0，1}，y ∈ {0，1}和z ∈ {0，1}。</p><p id="e3f4" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在这个问题中，我们看到x，y，z是我们的变量，它们中的每一个都可以取值范围从0到1(定义域)并且它们必须满足<code class="fe ms mt mu mv b">x + y = z</code>的约束。我们可以看到，只有某一组x、y和z的可能组合可以满足这些限制/要求:</p><p id="7d83" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><code class="fe ms mt mu mv b">x=0,y=0,z=0</code>是一个答案，<br/> <code class="fe ms mt mu mv b">x=1,y=0,z=1</code>是另一个<br/>，而<code class="fe ms mt mu mv b">x=1,y=1,z=1</code>不满足给定的约束<br/>，<code class="fe ms mt mu mv b">x=1,y=1,z=2</code>遵循约束，但<code class="fe ms mt mu mv b">z=2</code>不在提供的域中。</p><p id="bade" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">约束优化基本上又向前迈了一步，并试图根据某个目标值/函数从所有可行的解决方案(如果有的话)中找到最优组合。例如，我们可以尝试找到使<code class="fe ms mt mu mv b">x</code>或<code class="fe ms mt mu mv b">x + z</code>的值最大化的最佳组合，在这种情况下，设置<code class="fe ms mt mu mv b">z=1</code>的解决方案将比设置<code class="fe ms mt mu mv b">z=0</code>的解决方案更受青睐。</p><h1 id="6e79" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">Google的OR工具— CP-SAT求解器</h1><blockquote class="ml mm mn"><p id="7d26" class="lj lk mo ll b lm mf jr lo lp mg ju lr mp mh lu lv mq mi ly lz mr mj mc md me ij bi translated">运筹学工具—约束编程—统计可行性求解器</p></blockquote><p id="c74c" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在谷歌的OR-tools工具集中，有一个<a class="ae mk" href="https://developers.google.com/optimization/cp" rel="noopener ugc nofollow" target="_blank">约束编程</a>模块，可以帮助解决约束满足和约束优化问题，称为CP-SAT求解器。让我们简要回顾一下求解器使用的内部概念。我将使用Python版本，但也支持其他语言。</p><p id="702f" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们尝试解决上面提到的问题，稍加改变，找到满足<code class="fe ms mt mu mv b">x + 2*y = z</code>的<code class="fe ms mt mu mv b">x</code>、<code class="fe ms mt mu mv b">y</code>和<code class="fe ms mt mu mv b">z</code>的值，给定它们的域/约束。</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="e94e" class="na ks iq mv b gy nb nc l nd ne"># import the package<br/>from ortools.sat.python import cp_model</span><span id="1231" class="na ks iq mv b gy nf nc l nd ne">model = cp_model.CpModel() # initialize the model</span></pre><p id="8b31" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">首先要知道的是模型本身。我们首先初始化一个空模型，以包含所有的变量、约束和目标，它们将定义我们想要解决的约束问题。</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="7251" class="na ks iq mv b gy nb nc l nd ne"># setup the variables</span><span id="cbc4" class="na ks iq mv b gy nf nc l nd ne"># (lower_bound, upper_bound, name)<br/>x = model.NewIntVar(0, 1, 'x')<br/>y = model.NewIntVar(0, 1, 'y')<br/>z = model.NewIntVar(0, 1, 'z')</span></pre><p id="f7d5" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">接下来是变量。CP-solver实际上支持相当多的变量类型，其中一些甚至是特定于问题的类型。在初始化模型中的变量时，变量的域也是在这个阶段指定的。</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="cb54" class="na ks iq mv b gy nb nc l nd ne"># add the constraint</span><span id="cd52" class="na ks iq mv b gy nf nc l nd ne">model.Add(x + 2*y == z) </span></pre><p id="29c5" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在设置了<a class="ae mk" href="https://google.github.io/or-tools/python/ortools/sat/python/cp_model.html#cp_model.CpModel.NewBoolVar" rel="noopener ugc nofollow" target="_blank">变量</a>之后，我们可以开始向模型添加带有变量的约束。可以添加多个约束条件，以及变量的任意组合。因为x是一个IntVar，所以我们也可以用常量来操作它，在这个例子中是将它乘以2。还要注意的是，您正在向模型中添加一个看似评估过的语句(对或错)，但实际上不是。在引擎盖下，模型自动地将约束语句分解为“约束”。</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="2b8a" class="na ks iq mv b gy nb nc l nd ne">solver = cp_model.CpSolver()</span><span id="602a" class="na ks iq mv b gy nf nc l nd ne"># search for the first solution, first does not mean anything<br/>status = solver.Solve(model) # status is an enum</span><span id="1f6d" class="na ks iq mv b gy nf nc l nd ne">solver.StatusName(status) # &gt;&gt; 'FEASIBLE', or whatever status it is</span><span id="d803" class="na ks iq mv b gy nf nc l nd ne"># optional status checking up logic<br/>if status == cp_model.FEASBILE:<br/>  x_value = solver.Value(x)<br/>  y_value = solver.Value(y)<br/>  z_value = solver.Value(z)</span></pre><p id="f528" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在这个阶段，我们已经可以开始从模型中生成解决方案。在这样做之前，我们需要先求解模型。为此，我们首先需要创建一个规划求解对象。接下来，我们用要求解的模型调用求解器的Solve方法，它将返回一个状态。这里返回的状态是一个枚举，我们可以通过调用solver的StatusName或者只是逐个检查它是哪个状态来得到这个漂亮的名字。</p><p id="7afa" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">为了从这个解中得到x、y和z的实际值，我们需要使用求解器的值函数。我们只需将需要其值的变量传递给函数，就可以得到值本身。对于我的运行，它返回了<code class="fe ms mt mu mv b">x=0,y=0,z=0</code>，这是一个正确的解决方案，但不是最有趣的一个。</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="34b9" class="na ks iq mv b gy nb nc l nd ne">model.Maximize(z) # for minimization, you can use Minimize or -z</span><span id="62ec" class="na ks iq mv b gy nf nc l nd ne">status = solver.solve(model)</span><span id="28fa" class="na ks iq mv b gy nf nc l nd ne">if status == cp_model.FEASIBLE or status == cp_model.OPTIMAL:<br/>  x_value = solver.Value(x)<br/>  y_value = solver.Value(y)<br/>  z_value = solver.Value(z)</span></pre><p id="4026" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在求解模型之前，接下来可以做的事情就是给模型添加一个目标。使用这些变量，我们可以指导模型朝着给出最佳目标值的解决方案进行优化。在这种情况下，我们试图最大化<code class="fe ms mt mu mv b">z</code>的值，这意味着它将试图给出<code class="fe ms mt mu mv b">z</code>的值为1(而不是0)的解决方案。在我的例子中，我的解决方案中的值是<code class="fe ms mt mu mv b">x=1,y=0,z=1</code>。</p><p id="4d44" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这涵盖了求解器能做什么的非常基本的概念。还有更高级的概念，如<a class="ae mk" href="https://developers.google.com/optimization/cp/channeling" rel="noopener ugc nofollow" target="_blank">引导约束</a>来帮助形成变量之间的‘关系’，这我还不太熟悉。</p><h1 id="b026" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">不足？</h1><p id="865d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们可以看到约束问题解决方法是多么强大，因为它几乎可以应用于任何其他问题，并且许多问题也可以很容易地通过修改来解决。然而，我遇到了一些限制。</p><p id="1067" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">第一个限制是计算非常昂贵，因为随着更多的变量和条件被添加到模型中，计算复杂性似乎呈指数增长。这几乎和试图用蛮力的方式解决问题一样糟糕，尽管求解器使用了非常复杂的算法，使它比看起来更有效，这些算法我并不太熟悉。</p><p id="79e0" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这个求解器的另一个特别的限制是，还没有对多目标解决方案的内置支持。有一个<a class="ae mk" href="https://github.com/google/or-tools/issues/1344" rel="noopener ugc nofollow" target="_blank">解决方法</a>涉及到解决方案提示，虽然对我的用例来说效果很好，但是为了优化不同的目标，需要注意优化目标的顺序等等。</p><p id="2875" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">最后，我能找到的大多数指南(包括我拿出的幻灯片)似乎在一点上是一致的，那就是，如果你能用正常的方法有效地解决问题，那么你也许应该用那种方法来代替。在决定将求解器用于您的用例之前，您可能需要权衡从中获得的好处/坏处！</p><p id="3b20" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我希望这是有教育意义的，至少在某种程度上帮助了你。这无疑拓宽了我对其他我以前从未听说过的计算范式的接触。</p><h1 id="a243" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">参考</h1><p id="a99d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">其他可用的CP求解器:<a class="ae mk" href="http://www.constraint.org/en/tools/" rel="noopener ugc nofollow" target="_blank">http://www.constraint.org/en/tools/</a></p><p id="9894" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><a class="ae mk" href="https://www.cs.upc.edu/~erodri/webpage/cps/theory/cp/intro/slides.pdf" rel="noopener ugc nofollow" target="_blank">https://www . cs . UPC . edu/~ ero dri/网页/CPS/theory/CP/intro/slides . pdf</a></p><div class="nr ns gp gr nt nu"><a href="https://www.sciencedirect.com/topics/computer-science/constraint-programming" rel="noopener  ugc nofollow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">约束编程</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">约束规划(CP)已被证明是一个非常成功的技术推理指派问题，因为…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">www.sciencedirect.com</p></div></div><div class="od l"><div class="oe l of og oh od oi kp nu"/></div></div></a></div><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div></div>    
</body>
</html>