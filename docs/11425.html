<html>
<head>
<title>Converting Your Test Suite to PEST</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将您的测试套件转换为PEST</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/converting-your-test-suite-to-pest-9cdc26d79c7?source=collection_archive---------6-----------------------#2022-03-15">https://levelup.gitconnected.com/converting-your-test-suite-to-pest-9cdc26d79c7?source=collection_archive---------6-----------------------#2022-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d862ef0828095c95e5b21ef1340563ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mynL4fVz9R1lLGy-ZT5Vvg.png"/></div></div></figure><p id="1536" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">坦白地说，通过测试驱动开发来改变我写代码的方式改变了我作为程序员的能力。突然间，我可以满怀信心地编写服务和功能了——对我来说，为什么这么多公司<em class="kw">仍然</em>“没有时间做测试”是一个谜长期以来，<a class="ae kx" href="https://phpunit.de/" rel="noopener ugc nofollow" target="_blank"> PHPUnit </a>一直是编写TDD PHP时事实上的首选工具。</p><p id="fa05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近出现的一个新项目可能会改变这种情况。有<a class="ae kx" href="https://pestphp.com/docs" rel="noopener ugc nofollow" target="_blank">好的文档</a>和围绕它建立的<a class="ae kx" href="https://www.youtube.com/playlist?list=PLsGrIkNZ8eVk0RAThd7Ed6cdBvl5JW-GA" rel="noopener ugc nofollow" target="_blank"> meetup社区</a>，这对开发者来说是一个有吸引力的选择。我当然指的是PEST，所以我想我应该在我们自己的<a class="ae kx" href="https://github.com/Vonage/vonage-php-sdk-core" rel="noopener ugc nofollow" target="_blank"> Vonage PHP SDK </a>上介绍一下。</p><h1 id="078a" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">当前套房</h1><p id="f871" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们的Vonage PHP SDK经过多年的全面维护，因此包含一个完整的测试套件。虽然它不是“企业级”的，但它仍然是测试PEST的一个有用的练习。</p><p id="4cea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个分支上的当前套件有831个通过测试，运行4039个断言。有9个跳过的测试和15个未完成的测试。PHP8的总执行时间是13:54。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/00f37456870d003b29860e1dde5bd3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*FFOfLc3M1ACc28RP2Whn2w.png"/></div></figure><p id="75bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据记录，它运行得相当不错，其中一个测试实际上是超时测试，增加了时间。这里的目的不是真正提高跑步者，而是改变它，看看会发生什么。我们的第一站是<a class="ae kx" href="https://pestphp.com/docs/installation" rel="noopener ugc nofollow" target="_blank">安装害虫</a>并运行它。PEST值得注意的最重要的特性之一是<em class="kw">它完全向后兼容PHPUnit </em>，因此无论您使用什么语法，它都可以互换使用。这允许我们安装PEST，运行它以查看结果，并可能尝试和实现最近的<a class="ae kx" href="https://pestphp.com/docs/plugins/parallel" rel="noopener ugc nofollow" target="_blank">并行测试</a>功能。</p><p id="aa61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要安装PEST，我在命令行中运行以下命令:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="bd85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来似乎很容易，一个作曲家命令后，我可以运行害虫。然而，值得注意的是，它将运行的这个存储库已经有了要求——其中一个要求是PHP最低版本为7.3。PEST已经要求PHP的最低版本为7.3及以上，所以不需要修改就可以更新。</p><p id="9ea4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是时候运行PEST了，看看会发生什么:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5a6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您会注意到的第一件事是，PEST使用类似于<code class="fe mi mj mk ml b">--testdox</code>参数的输出格式来格式化PHPUnit的输出。它的输出相当不错:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/1eacd93511760ed8352c167f6fb08785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8k-hWAfeEmqd3hlGQ1oJUA.png"/></div></div></figure><p id="46dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，所以是13.28秒？好吧，实际上只对跑步者来说更快。如果我们尝试使用PEST的并行功能会怎么样？它是单独包装的，所以我们去买吧:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="a7da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在运行它:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="c124" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有……哦。好吧，看起来我们的运气已经用完了:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/e43746f19b06c4d6c761fab7619a4e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KIDY2fk2wF6Z-3jTfm0DGw.png"/></div></div></figure><p id="44de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">快速搜索一下就会发现，我们在PHP本身中有一个错误，正如PHPUnit的问题日志中所记录的:</p><p id="cdb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kx" href="https://github.com/sebastianbergmann/phpunit/issues/4305" rel="noopener ugc nofollow" target="_blank">sebastianbergmann/phpunit # 4305</a></p><p id="ae1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想这就是我们为有点锋芒所付出的代价。</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/579ff440313d33ba4009e2fb6f8e5514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*otMAaFIDAJLps6KL6QTFRg.jpeg"/></div></div></figure><h1 id="e231" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">PHPUnit语法与PEST</h1><p id="d9a6" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我一直在玩test runner，但是并没有真正展示代码或者解释PEST的实际用途。</p><p id="5d47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Laravel核心成员<a class="ae kx" href="https://twitter.com/enunomaduro" rel="noopener ugc nofollow" target="_blank"> Nuno Madro </a>创建了PEST作为一个新的框架，它模仿了<a class="ae kx" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a> Javascript框架的语法。这非常符合当前PHP(尤其是Laravel)转向更基于闭包的函数式语法的趋势，类似于Javascript的编写方式。这在逻辑上是有意义的，因为你的全栈web应用程序的PHP后端测试是用与前端测试相似的语法编写的。这里有一个来自Vonage PHP SDK的“之前和之后”的例子:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="f69e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里使用了一些常见的模式——神奇的方法<code class="fe mi mj mk ml b">setUp()</code>在测试执行之前运行，然后我们使用<code class="fe mi mj mk ml b">assertEquals()</code>,它是PHPUnit <code class="fe mi mj mk ml b">TestCase</code>的一个助手类(在我们的例子中，<code class="fe mi mj mk ml b">VonageTestCase</code>从它向上扩展)。</p><p id="73d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，向您展示用PEST语法编写的相同测试:</p><figure class="mc md me mf gt jr"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="6611" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总的来说，这是一个很好的例子，说明PHP生态系统正在向Javascript寻求新的想法——正如您所看到的，PEST语法非常类似于JEST。它还展示了PEST的一个核心价值，即在API中使用更灵活的方法链接来编写更少的代码，这是一种哲学上非常类似Laravel的方法。我们现在有了一个更高阶的<code class="fe mi mj mk ml b">beforeEach()</code>,它内部有一个闭包，将在每次测试之前运行，现在PHPUnit中的经典PHP函数结构已经被更多的函数式语法所取代。这个例子还展示了<a class="ae kx" href="https://pestphp.com/docs/expectations" rel="noopener ugc nofollow" target="_blank">期望API </a>是如何被设计成以一种人类可读的方式用方法名如<code class="fe mi mj mk ml b">expect(true)-&gt;toBe(value)</code>或<code class="fe mi mj mk ml b">expect($variable)-&gt;toBeArray()</code>来链接断言的。</p><h1 id="0792" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">好吧，那么自动化呢？</h1><p id="5f83" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">老实说，事情并没有如我所愿。不过，我会告诉你为什么。</p><p id="20ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我从Twitter 上注意到，不管代码是否在Laravel中，使用一个工具自动将PHPUnit套件转换成PEST实际上是可能的。因此，我前往<a class="ae kx" href="https://laravelshift.com/phpunit-to-pest-converter" rel="noopener ugc nofollow" target="_blank"> Pest Converter </a>和<a class="ae kx" href="https://github.com/SecondeJK/vonage-php-sdk-core/tree/pest-shift" rel="noopener ugc nofollow" target="_blank">设置一个存储库和分支，以便在</a>上进行试验。运行时，Shift将在您提供的基础分支上创建一个新的分支，并创建逻辑步骤提交以在语法间移动。首先需要做的事情之一是将<code class="fe mi mj mk ml b">test/</code>文件夹改为<code class="fe mi mj mk ml b">tests/</code>，这样转换器就知道在哪里寻找您的测试。</p><p id="3668" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，在转换后运行PEST时:</p><figure class="mc md me mf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/daabb78aaeb40109bfc6c38c12f9d44f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y2aPACyOrkaOJMjU-olCzA.png"/></div></div></figure><p id="1d84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯。那么，不是一帆风顺。值得注意的是，我不知道会发生什么，原因有两个:</p><ul class=""><li id="aefc" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated">Vonage PHP SDK是框架无关的</li><li id="3c65" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">这取决于<a class="ae kx" href="https://github.com/phpspec/prophecy" rel="noopener ugc nofollow" target="_blank">预言</a>库</li><li id="414f" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">使用了许多PHP特征，使得测试套件稍微复杂一些</li></ul><p id="b06c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与使用传统组合不同，PEST具有不同的模式配置。PEST有一个<code class="fe mi mj mk ml b">pest.php</code>配置文件，允许您指定助手函数、特征和常用方法，如<code class="fe mi mj mk ml b">RefreshDatabase</code>。您还可以指定要将这些类应用到哪些文件夹，如下所示:</p><p id="a63f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk ml b">uses(\VonageTest\HTTPTestTrait::class)-&gt;in('Secrets');</code></p><p id="2abd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">PEST转换器无法解决这些问题的原因是大量的边缘情况。Laravel Shift的<a class="ae kx" href="https://twitter.com/gonedark" rel="noopener ugc nofollow" target="_blank"> Jason McCreary </a>在我们的支持对话中指出的一件事是，一些测试将一个应用程序容器设置到<code class="fe mi mj mk ml b">$this-&gt;app</code>中，这与Laravel的应用程序基础设施相冲突(因为它不知道您是否有Laravel应用程序)。</p><h1 id="fb13" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="0acf" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">好了，虽然PEST Converter发现很难自动化测试，但它让我得出了两个结论:</p><ul class=""><li id="db7d" class="mq mr iq ka b kb kc kf kg kj ms kn mt kr mu kv mv mw mx my bi translated">Laravel Shift，Pest转换器的创建者已经在查看我使用过的库中的边缘案例，并在研究如何处理它们，但更重要的是</li><li id="485e" class="mq mr iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated"><em class="kw">如果你的测试套件很复杂或者过度设计，就不要运行转换器——先解决这个问题</em></li></ul><p id="3ca3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像任何事情一样，通过自动化进行重大重构也有风险。在我们的例子中，风险是我们正在处理一个没有框架的原始PHP库。然而，Shift通过目标分支进行更新，然后从目标分支创建Shift分支以最小化风险。如果不运行，就不要合并！您还可以选择使用<a class="ae kx" href="https://laravelshift.com/human-shifts" rel="noopener ugc nofollow" target="_blank">人工转换</a>服务，这将不可避免地产生一个完全转换的套件。</p><p id="aee0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想建议的是，如果你有一个Symfony或Laravel应用程序，这个转换器绝对是考虑到这些情况而设计的，所以这种转变将会非常稳固。</p><p id="7b6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你应该收养害虫吗？一如既往，这取决于你。如果你想保持在PHP变化的前沿，那么这肯定是一个有吸引力的选择。但是请记住，PEST构造其语法的方式自然符合Laravel的API流方法，所以如果您使用Symfony、CakePHP或Drupal等其他流行的工具，它确实有可能让您的开发人员感到困惑。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="497f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">最初发布于</em><a class="ae kx" href="https://learn.vonage.com/blog/2022/01/14/converting-your-test-suite-to-pest/" rel="noopener ugc nofollow" target="_blank"><em class="kw">https://learn . vonage . com/blog/2022/01/14/converting-your-test-suite-to-pest/</em></a></p></div></div>    
</body>
</html>