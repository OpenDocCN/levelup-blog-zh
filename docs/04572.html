<html>
<head>
<title>GraphQL Server with Deno and Oak Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Deno和Oak框架的GraphQL服务器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphql-server-with-deno-and-oak-framwork-953a74e97aa3?source=collection_archive---------2-----------------------#2020-07-03">https://levelup.gitconnected.com/graphql-server-with-deno-and-oak-framwork-953a74e97aa3?source=collection_archive---------2-----------------------#2020-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1d5583d239f4ebd08e396577ff5c1b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PSRG0OvD2vgVHXBSTav4wg.jpeg"/></div></div></figure><p id="c039" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://medium.com/@singhcoolish/deno-with-graphql-e1f192259984" rel="noopener">在我之前的话题</a>中，我已经解释了以下事情</p><ol class=""><li id="da0d" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">GraphQL是什么？</li><li id="a6d3" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">比较REST API和GraphQL</li><li id="8532" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">GraphQL术语</li></ol><h1 id="0db0" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">用Deno创建GraphQL服务器</h1><p id="e986" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated"><strong class="ka ir">我们的德诺属地</strong></p><p id="fafd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://deno.land/x/oak" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mo">Oak</em></strong></a><strong class="ka ir"><em class="mo">:</em></strong>Deno的<a class="ae kw" href="https://doc.deno.land/https/deno.land/std/http/mod.ts" rel="noopener ugc nofollow" target="_blank"> http </a>服务器的一个中间件框架，包括一个路由器中间件。</p><p id="5992" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://deno.land/x/oak_graphql" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mo">Oak-GraphQL</em></strong></a><strong class="ka ir"><em class="mo">:</em></strong>一个简单的用于oak deno框架的graph QL中间件。</p><p id="d63a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://deno.land/x/graphql_deno" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="mo">graph QL-Deno:</em></strong></a><strong class="ka ir"/>这是graphql-js到Deno的一对一端口。它正在工作，完全适应Deno并导出ts类型和JS代码。</p><p id="80b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mo">首先我们用</em><strong class="ka ir"><em class="mo">oak</em></strong><em class="mo">框架和</em><strong class="ka ir"><em class="mo">oak _ graph QL</em></strong><em class="mo">制作基本的deno服务器。我们正在为导入包创建一个公共依赖文件。</em></p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="d2e1" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak"> GraphQL模式</strong></h1><p id="cfc6" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">GraphQL模式是客户端可以从GraphQL API请求的数据的描述。<strong class="ka ir">它还定义了客户端可以用来从GraphQL服务器读取和写入数据的查询和变异函数。</strong>换句话说，您在GraphQL模式中指定您的客户端或应用程序UI数据需求。</p><p id="3f0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模式是使用GraphQL模式语言(也称为<strong class="ka ir">模式定义语言</strong>，SDL)编写的。</p><p id="2029" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用它，您可以定义对象类型和字段来表示可以从API检索的数据，以及定义API允许的操作组的根类型。</p><p id="5030" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">对象类型</strong></p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/ac241c85693b12abbda05219d7747bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-SHfIwL-tJ0Jzl10y3xqw.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">对象类型</figcaption></figure><p id="07e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">根类型</strong></p><p id="91ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根类型是查询类型、变异类型和订阅类型，这是您可以从GraphQL服务器运行请求的三种类型的操作。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/9fee9861f14decc3154d2ba750250397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Niy0iVaGW3yYOK_d0KAwA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">根类型</figcaption></figure><p id="9a89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们继续创建一个模式。添加一个新文件<code class="fe na nb nc nd b">src/schema/author.ts</code>，内容如下:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d7a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面是GraphQL模式。在其中，我们定义了一个具有四个字段的<strong class="ka ir"> Author </strong>类型、一个具有五个字段的<strong class="ka ir"> Post </strong>类型和一个具有两个字段的根查询类型。</p><h2 id="5997" class="ne lm iq bd ln nf ng dn lr nh ni dp lv kj nj nk lz kn nl nm md kr nn no mh np bi translated"><strong class="ak"> GraphQL查询</strong></h2><p id="93b1" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">根查询类型中的两个字段定义了服务器可以执行的查询/操作。<strong class="ka ir"> getAuthor </strong>根据作为参数传递给查询的id返回一个<strong class="ka ir">作者。<strong class="ka ir"> getPost </strong>基于作为查询参数传递的id返回一个<strong class="ka ir"> Post。</strong></strong></p><h2 id="1b1e" class="ne lm iq bd ln nf ng dn lr nh ni dp lv kj nj nk lz kn nl nm md kr nn no mh np bi translated"><strong class="ak"> GraphQL突变</strong></h2><p id="a842" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">GraphQL变异用于执行<strong class="ka ir">创建、更新和删除</strong>操作。<strong class="ka ir"> createAuthor </strong>，<strong class="ka ir"> createPost </strong>根据输入对象执行插入操作。</p><h1 id="6a60" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">解析器</strong></h1><p id="f549" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们的API能够运行两个查询操作</p><p id="ef6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个基于id 用作者文章数组检索<strong class="ka ir">作者，另一个基于id </strong>检索<strong class="ka ir">文章。我们的下一步是定义如何解析这些查询，以便将正确的字段返回给客户端。</strong></p><blockquote class="nq nr ns"><p id="4ba3" class="jy jz mo ka b kb kc kd ke kf kg kh ki nt kk kl km nu ko kp kq nv ks kt ku kv ij bi translated"><strong class="ka ir"> GraphQL有一个执行算法。</strong>这个执行算法的实现就是<strong class="ka ir">通过遍历模式中的每个字段，并执行它们的“解析器”功能来确定结果，从而将来自客户端的查询转换成实际结果。</strong></p></blockquote><p id="d32f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下代码添加到src/resolver/author.ts中</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="402f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个解析器函数都接收以下四个参数</p><ol class=""><li id="6fd1" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir"> parent </strong>:包含调用链中之前执行的解析器的结果。</li><li id="977f" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> args </strong>:这些是提供给GraphQL查询中的字段的参数。按照我们的例子，这将是getAuthor查询的id参数<strong class="ka ir"> getAuthor(_id: ID): Author。</strong></li><li id="7aee" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">上下文</strong> : <strong class="ka ir"> </strong>这是每个解析器都可以读取或写入的对象。您可以将允许访问数据库或包含HTTP请求头信息的对象保留在这里。上下文对象在各个解析器中是相同的，您可以根据需要向其中写入上下文信息。</li><li id="947e" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> info </strong>:它保存与当前查询相关的特定于字段的信息以及模式细节。</li></ol><h1 id="5f4e" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak"> GraphQL查询语言</strong></h1><p id="bab9" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">打开命令行并运行以下命令</p><p id="c562" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe na nb nc nd b">denon run --allow-net --allow-env --allow-write --allow-read --allow-plugin --unstable server.ts</code></p><p id="2c26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在服务器运行在<a class="ae kw" href="http://localhost:8080/graphql" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">http://localhost:8080/graph QL</strong></a>上</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/ab1f270ffcabe64ea0b3e6a057c155e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*igu5ycbjW91jmWPUJyTbFA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">创建作者</figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/9d99dd59d14c2503c4df90318f49cac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3yCC33J3NApgznojSxasRQ.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">创建帖子</figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/cf9f775b02966ed5aa741992350677e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5qA-sPhCzI7Q04S5_s-yA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">获取作者</figcaption></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/8c9f0dd60656055cb0424e9f07a54328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*10uQ8LY5b-VXufImmmwt1A.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">区别详解</figcaption></figure><h1 id="dccf" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="a221" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">如果你有建议，请在评论区告诉我🙋‍♂️</p><p id="f7a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谢谢大家！🖤</p><p id="f303" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是<a class="ae kw" href="https://github.com/singhcool/deno-server-graphQL" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> GitHub仓库</strong> </a> <strong class="ka ir"> </strong>的全部源代码。</p><p id="47d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一节中，我们将介绍以下内容</p><ol class=""><li id="5200" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">GraphQL订阅</li><li id="9a60" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">客户端集成了React JS的GraphQL</li></ol></div></div>    
</body>
</html>