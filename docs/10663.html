<html>
<head>
<title>Building Micro-services in Go using Keycloak for Authorisation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Keycloak进行授权在Go中构建微服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-micro-services-in-go-using-keycloak-for-authorisation-e00a29b80a43?source=collection_archive---------2-----------------------#2021-12-31">https://levelup.gitconnected.com/building-micro-services-in-go-using-keycloak-for-authorisation-e00a29b80a43?source=collection_archive---------2-----------------------#2021-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/54fabe9b9ef93e99591fe5626d9089fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rIpcc13nzEzAvwRL20RMuA.jpeg"/></div></div></figure><p id="f3e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当使用微服务架构构建应用程序时，最好有一个中央授权服务器来处理跨服务的认证和授权。Keycloak是一个流行的选择，作为一个开源的身份和访问管理解决方案。在这篇文章中，我将展示如何在你的Go微服务中使用keycloak进行授权。不幸的是，在写这篇文章的时候，还没有官方的keycloak适配器，但是我找到了一个很棒的库<a class="ae kw" href="http://github.com/Nerzal/gocloak/v8" rel="noopener ugc nofollow" target="_blank"> gocloak </a>一个keycloak管理客户端，我主要用它来实现自省功能，它实际上只是keycloak服务器的自省令牌api的包装器。如果您需要做的只是内省令牌，那么您应该考虑自己编写这个函数。</p><p id="57a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个特定的练习，我将构建一个简单的事件api，它只有3个端点，用于创建、检索一个事件并列出所有可用的事件。我还将把事件数据保存到mysql数据库中。你需要一个keycloak服务器来完成这项工作，我的本地主机上就有一个。</p><p id="c278" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">初始化go模块</strong></p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="8730" class="lg lh iq lc b gy li lj l lk ll">go mod init simplegoapi</span></pre><p id="ce6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">项目结构</strong></p><p id="4a4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我更喜欢为我的网络应用程序使用领域驱动设计，因为我觉得这真的有助于组织项目，使查找东西变得容易，并降低复杂性。下面是这个项目的结构。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="af24" class="lg lh iq lc b gy li lj l lk ll">simplegoapi<br/>- /src</span><span id="6bf1" class="lg lh iq lc b gy lm lj l lk ll">   - /config<br/>   - /controllers //contains the actual api’s<br/>   - /services    //Handles business logic<br/>   - /repositories //Handles data access layer<br/>   - /domains       //contains database related structs<br/>  main.go</span><span id="1d39" class="lg lh iq lc b gy lm lj l lk ll">go.mod<br/>go.sum</span></pre><p id="5335" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">更新go.mod </strong></p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="00c2" class="lg lh iq lc b gy li lj l lk ll">module simplegoapi</span><span id="9598" class="lg lh iq lc b gy lm lj l lk ll">go 1.17</span><span id="5f7c" class="lg lh iq lc b gy lm lj l lk ll">require (</span><span id="7ae3" class="lg lh iq lc b gy lm lj l lk ll">    github.com/Nerzal/gocloak/v8 v8.1.1</span><span id="b296" class="lg lh iq lc b gy lm lj l lk ll">    github.com/gorilla/mux v1.8.0</span><span id="ceb0" class="lg lh iq lc b gy lm lj l lk ll">    gorm.io/driver/mysql v1.0.4</span><span id="e5e9" class="lg lh iq lc b gy lm lj l lk ll">    gorm.io/gorm v1.20.12</span><span id="b392" class="lg lh iq lc b gy lm lj l lk ll">)</span><span id="fa72" class="lg lh iq lc b gy lm lj l lk ll">require (</span><span id="7b57" class="lg lh iq lc b gy lm lj l lk ll">    github.com/dgrijalva/jwt-go/v4 v4.0.0-preview1 // indirect</span><span id="7eed" class="lg lh iq lc b gy lm lj l lk ll">    github.com/go-resty/resty/v2 v2.3.0 // indirect</span><span id="08fe" class="lg lh iq lc b gy lm lj l lk ll">    github.com/go-sql-driver/mysql v1.5.0 // indirect</span><span id="eaf8" class="lg lh iq lc b gy lm lj l lk ll">    github.com/jinzhu/inflection v1.0.0 // indirect</span><span id="f944" class="lg lh iq lc b gy lm lj l lk ll">    github.com/jinzhu/now v1.1.1 // indirect</span><span id="a31e" class="lg lh iq lc b gy lm lj l lk ll">    github.com/pkg/errors v0.9.1 // indirect</span><span id="7d71" class="lg lh iq lc b gy lm lj l lk ll">    github.com/segmentio/ksuid v1.0.3 // indirect</span><span id="b278" class="lg lh iq lc b gy lm lj l lk ll">    golang.org/x/net v0.0.0–20200822124328-c89045814202 // indirect</span><span id="1399" class="lg lh iq lc b gy lm lj l lk ll">)</span></pre><p id="8bc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我创建了一个名为controller的接口，它只有一个方法RegisterRoutes，该方法将路由器作为参数，所有控制器都将实现controller接口，这将允许在各种控制器中注册路由，而不必在每次添加新路由时修改main.go。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="53ca" class="lg lh iq lc b gy li lj l lk ll">package controllers</span><span id="d1ea" class="lg lh iq lc b gy lm lj l lk ll">import (</span><span id="f9c6" class="lg lh iq lc b gy lm lj l lk ll">    “github.com/gorilla/mux”</span><span id="80c4" class="lg lh iq lc b gy lm lj l lk ll">)</span><span id="8b9c" class="lg lh iq lc b gy lm lj l lk ll">type Controller interface {</span><span id="4b8f" class="lg lh iq lc b gy lm lj l lk ll">    RegisterRoutes(router *mux.Router)<br/>}</span></pre><p id="cb5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们在models包的event.go文件中创建Events struct，其内容如下，这也代表了我们的数据库表。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="6eef" class="lg lh iq lc b gy li lj l lk ll">package domains</span><span id="222c" class="lg lh iq lc b gy lm lj l lk ll">import (</span><span id="c246" class="lg lh iq lc b gy lm lj l lk ll">“gorm.io/gorm”</span><span id="212b" class="lg lh iq lc b gy lm lj l lk ll">)</span><span id="9cbc" class="lg lh iq lc b gy lm lj l lk ll">type Event struct {</span><span id="2e49" class="lg lh iq lc b gy lm lj l lk ll">   gorm.Model</span><span id="fbb8" class="lg lh iq lc b gy lm lj l lk ll">   ID int `json:”ID”`</span><span id="a065" class="lg lh iq lc b gy lm lj l lk ll">   Title string `json:”Title”`</span><span id="7216" class="lg lh iq lc b gy lm lj l lk ll">   Description string `json:”Description”`</span><span id="df92" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><p id="3228" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个例子，我使用gorm orm来处理数据库迁移。存储库包中的eventRepository.go处理数据库中的持久化和检索。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="a4e2" class="lg lh iq lc b gy li lj l lk ll">package repositories</span><span id="c211" class="lg lh iq lc b gy lm lj l lk ll">import (</span><span id="4929" class="lg lh iq lc b gy lm lj l lk ll">   “simplegoapi/src/config”</span><span id="2efd" class="lg lh iq lc b gy lm lj l lk ll">   “simplegoapi/src/domains”</span><span id="ef33" class="lg lh iq lc b gy lm lj l lk ll">   “simplegoapi/src/errors”</span><span id="cbc3" class="lg lh iq lc b gy lm lj l lk ll">)</span><span id="2a31" class="lg lh iq lc b gy lm lj l lk ll">func SaveEvent(event *domains.Event) (*domains.Event, *errors.HttpError) {</span><span id="3355" class="lg lh iq lc b gy lm lj l lk ll">   e := config.Database.Create(&amp;event)</span><span id="01bc" class="lg lh iq lc b gy lm lj l lk ll">   if e.Error != nil {</span><span id="6f01" class="lg lh iq lc b gy lm lj l lk ll">      return nil, errors.DataAccessLayerError(e.Error.Error())</span><span id="84c3" class="lg lh iq lc b gy lm lj l lk ll">   }</span><span id="78bc" class="lg lh iq lc b gy lm lj l lk ll">   return event, nil</span><span id="5696" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="936a" class="lg lh iq lc b gy lm lj l lk ll">func FindOneEventById(id int) *domains.Event {</span><span id="c544" class="lg lh iq lc b gy lm lj l lk ll">   var event domains.Event</span><span id="0cd2" class="lg lh iq lc b gy lm lj l lk ll">   config.Database.First(&amp;event, id)</span><span id="f968" class="lg lh iq lc b gy lm lj l lk ll">   return &amp;event</span><span id="3491" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="e225" class="lg lh iq lc b gy lm lj l lk ll">func FindAllEvents() []domains.Event {</span><span id="abd5" class="lg lh iq lc b gy lm lj l lk ll">   var events []domains.Event</span><span id="01aa" class="lg lh iq lc b gy lm lj l lk ll">   config.Database.Find(&amp;events)</span><span id="a438" class="lg lh iq lc b gy lm lj l lk ll">   return events</span><span id="801b" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><p id="4eeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了初始化数据库连接和进行迁移，我在配置包中创建了dbHandler.go</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="d0f4" class="lg lh iq lc b gy li lj l lk ll">package config</span><span id="4372" class="lg lh iq lc b gy lm lj l lk ll">import (</span><span id="e22d" class="lg lh iq lc b gy lm lj l lk ll">   “gorm.io/driver/mysql”</span><span id="e27f" class="lg lh iq lc b gy lm lj l lk ll">   “gorm.io/gorm”</span><span id="bab1" class="lg lh iq lc b gy lm lj l lk ll">   “simplegoapi/src/domains”</span><span id="da09" class="lg lh iq lc b gy lm lj l lk ll">)</span><span id="3421" class="lg lh iq lc b gy lm lj l lk ll">var Database *gorm.DB</span><span id="ce7f" class="lg lh iq lc b gy lm lj l lk ll">func DbConnect() {</span><span id="27e3" class="lg lh iq lc b gy lm lj l lk ll">   dsn := “root:@tcp(127.0.0.1:3306)/simple_go_db?      <br/>   charset=utf8mb4&amp;parseTime=True&amp;loc=Local”</span><span id="4e62" class="lg lh iq lc b gy lm lj l lk ll">   db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})</span><span id="3447" class="lg lh iq lc b gy lm lj l lk ll">   Database = db</span><span id="e74d" class="lg lh iq lc b gy lm lj l lk ll">   if err != nil {</span><span id="a9e7" class="lg lh iq lc b gy lm lj l lk ll">      panic(“failed to connect database”)</span><span id="d0b9" class="lg lh iq lc b gy lm lj l lk ll">   }</span><span id="e961" class="lg lh iq lc b gy lm lj l lk ll">   runMigrations()</span><span id="2797" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="70cd" class="lg lh iq lc b gy lm lj l lk ll">func runMigrations() {</span><span id="5c01" class="lg lh iq lc b gy lm lj l lk ll">   Database.AutoMigrate(&amp;domains.Event{})</span><span id="aa4f" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><p id="5480" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们连接到我的本地mysql安装上的simple_go_db数据库。runMigration函数使用gorm在数据库中创建或更新作为表提供的结构。</p><p id="d947" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事件服务使用事件存储库处理创建和列出事件的业务逻辑</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="1561" class="lg lh iq lc b gy li lj l lk ll">package services</span><span id="7bd5" class="lg lh iq lc b gy lm lj l lk ll">import (</span><span id="fea9" class="lg lh iq lc b gy lm lj l lk ll">   “encoding/json”</span><span id="fec8" class="lg lh iq lc b gy lm lj l lk ll">   “fmt”</span><span id="005c" class="lg lh iq lc b gy lm lj l lk ll">   “github.com/gorilla/mux”</span><span id="de02" class="lg lh iq lc b gy lm lj l lk ll">   “io/ioutil”</span><span id="1204" class="lg lh iq lc b gy lm lj l lk ll">   “net/http”</span><span id="c0ec" class="lg lh iq lc b gy lm lj l lk ll">   “simplegoapi/src/domains”</span><span id="9f8f" class="lg lh iq lc b gy lm lj l lk ll">   “simplegoapi/src/errors”</span><span id="59d4" class="lg lh iq lc b gy lm lj l lk ll">   “simplegoapi/src/repositories”</span><span id="5b60" class="lg lh iq lc b gy lm lj l lk ll">   “strconv”</span><span id="f462" class="lg lh iq lc b gy lm lj l lk ll">)</span><span id="9a58" class="lg lh iq lc b gy lm lj l lk ll">func CreateEvent(w http.ResponseWriter, r *http.Request) {</span><span id="16e0" class="lg lh iq lc b gy lm lj l lk ll">   var newEvent domains.Event</span><span id="f9e8" class="lg lh iq lc b gy lm lj l lk ll">   reqBody, err := ioutil.ReadAll(r.Body)</span><span id="0aa9" class="lg lh iq lc b gy lm lj l lk ll">   if err != nil {</span><span id="5568" class="lg lh iq lc b gy lm lj l lk ll">     fmt.Fprintf(w, “Kindly enter data with the event title and    <br/>     description only in order to update”)</span><span id="4cde" class="lg lh iq lc b gy lm lj l lk ll">   }</span><span id="29d9" class="lg lh iq lc b gy lm lj l lk ll">   json.Unmarshal(reqBody, &amp;newEvent)</span><span id="718e" class="lg lh iq lc b gy lm lj l lk ll">   ev, httpErr := repositories.SaveEvent(&amp;newEvent)</span><span id="cc55" class="lg lh iq lc b gy lm lj l lk ll">   if httpErr != nil {</span><span id="928e" class="lg lh iq lc b gy lm lj l lk ll">      w.WriteHeader(httpErr.Code)</span><span id="fcbc" class="lg lh iq lc b gy lm lj l lk ll">      json.NewEncoder(w).Encode(errors.UnauthorizedError())</span><span id="ee54" class="lg lh iq lc b gy lm lj l lk ll">      return</span><span id="9e32" class="lg lh iq lc b gy lm lj l lk ll">   }</span><span id="57b6" class="lg lh iq lc b gy lm lj l lk ll">   w.WriteHeader(http.StatusCreated)</span><span id="1109" class="lg lh iq lc b gy lm lj l lk ll">   json.NewEncoder(w).Encode(&amp;ev)</span><span id="d6cb" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="8896" class="lg lh iq lc b gy lm lj l lk ll">func GetOneEvent(w http.ResponseWriter, r *http.Request) {</span><span id="8562" class="lg lh iq lc b gy lm lj l lk ll">   params := mux.Vars(r)</span><span id="74f8" class="lg lh iq lc b gy lm lj l lk ll">   idStr := params[ “id”]</span><span id="d0b5" class="lg lh iq lc b gy lm lj l lk ll">   id, err := strconv.Atoi(idStr)</span><span id="244b" class="lg lh iq lc b gy lm lj l lk ll">   if err != nil {</span><span id="3a4b" class="lg lh iq lc b gy lm lj l lk ll">     w.WriteHeader(400)</span><span id="0d0e" class="lg lh iq lc b gy lm lj l lk ll">     json.NewEncoder(w).Encode(</span><span id="179c" class="lg lh iq lc b gy lm lj l lk ll">     errors.BadRequestError(“Id must be an integer”))</span><span id="c7d8" class="lg lh iq lc b gy lm lj l lk ll">     return</span><span id="3e4d" class="lg lh iq lc b gy lm lj l lk ll">   }</span><span id="e761" class="lg lh iq lc b gy lm lj l lk ll">   event := repositories.FindOneEventById(id)</span><span id="7763" class="lg lh iq lc b gy lm lj l lk ll">   if event == nil {</span><span id="db18" class="lg lh iq lc b gy lm lj l lk ll">     w.WriteHeader(404)</span><span id="2817" class="lg lh iq lc b gy lm lj l lk ll">     json.NewEncoder(w).Encode(errors.NotFoundError())</span><span id="a188" class="lg lh iq lc b gy lm lj l lk ll">     return</span><span id="d0d8" class="lg lh iq lc b gy lm lj l lk ll">   }</span><span id="4a0e" class="lg lh iq lc b gy lm lj l lk ll">   json.NewEncoder(w).Encode(&amp;event)</span><span id="7a03" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="9a03" class="lg lh iq lc b gy lm lj l lk ll">func AllEvents(w http.ResponseWriter, r *http.Request) {</span><span id="b45a" class="lg lh iq lc b gy lm lj l lk ll">   events := repositories.FindAllEvents()</span><span id="33b2" class="lg lh iq lc b gy lm lj l lk ll">   json.NewEncoder(w).Encode(&amp;events)</span><span id="b91f" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><p id="0d17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在other中，为了返回结构良好的Json错误消息，我创建了一个httpError.go来返回基于定义的错误的消息。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="9132" class="lg lh iq lc b gy li lj l lk ll">package config</span><span id="b90e" class="lg lh iq lc b gy lm lj l lk ll">type HttpError struct {</span><span id="27d3" class="lg lh iq lc b gy lm lj l lk ll">   Code int `json:”code”`</span><span id="ea3e" class="lg lh iq lc b gy lm lj l lk ll">   Error string `json:”error”`</span><span id="2d05" class="lg lh iq lc b gy lm lj l lk ll">   Message string `json:”message”`</span><span id="8fae" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="1820" class="lg lh iq lc b gy lm lj l lk ll">func UnauthorizedError() HttpError{</span><span id="fe62" class="lg lh iq lc b gy lm lj l lk ll">   return HttpError{</span><span id="5eeb" class="lg lh iq lc b gy lm lj l lk ll">        401,</span><span id="74a7" class="lg lh iq lc b gy lm lj l lk ll">        “Unauthorized”,</span><span id="b0b8" class="lg lh iq lc b gy lm lj l lk ll">        “You are not authorized to access this resource”,</span><span id="4acf" class="lg lh iq lc b gy lm lj l lk ll">   }</span><span id="8a57" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="7a67" class="lg lh iq lc b gy lm lj l lk ll">func NotFoundError() *HttpError{</span><span id="d2b9" class="lg lh iq lc b gy lm lj l lk ll">   return &amp;HttpError{</span><span id="3735" class="lg lh iq lc b gy lm lj l lk ll">       404,</span><span id="4a37" class="lg lh iq lc b gy lm lj l lk ll">       “Not found”,</span><span id="e6f5" class="lg lh iq lc b gy lm lj l lk ll">       “The requested resource was not found”,</span><span id="885d" class="lg lh iq lc b gy lm lj l lk ll">   }</span><span id="362f" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="c599" class="lg lh iq lc b gy lm lj l lk ll">func DataAccessLayerError(message string) *HttpError{</span><span id="3b5e" class="lg lh iq lc b gy lm lj l lk ll">   return &amp;HttpError{</span><span id="f515" class="lg lh iq lc b gy lm lj l lk ll">       400,</span><span id="5963" class="lg lh iq lc b gy lm lj l lk ll">       “Data access error”,</span><span id="8e9f" class="lg lh iq lc b gy lm lj l lk ll">       message,</span><span id="3169" class="lg lh iq lc b gy lm lj l lk ll">   }</span><span id="cfa1" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="50eb" class="lg lh iq lc b gy lm lj l lk ll">func BadRequestError(message string) *HttpError{</span><span id="ae64" class="lg lh iq lc b gy lm lj l lk ll">   return &amp;HttpError{</span><span id="0b34" class="lg lh iq lc b gy lm lj l lk ll">       400,</span><span id="8439" class="lg lh iq lc b gy lm lj l lk ll">       “Bad Request”,</span><span id="b2fb" class="lg lh iq lc b gy lm lj l lk ll">       message,</span><span id="0cb7" class="lg lh iq lc b gy lm lj l lk ll">   }</span><span id="5fa1" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><p id="ba9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">授权</strong></p><p id="a140" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在另一个使用keycloak处理授权的例子中，我使用了一个拦截器，它基本上是一个在端点被调用时被调用的函数，试图检查用户是否被授权，然后如果允许的话，将请求转发到下游。在包含以下内容的服务包中创建authService.go</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="b935" class="lg lh iq lc b gy li lj l lk ll">package services</span><span id="10a9" class="lg lh iq lc b gy lm lj l lk ll">import (</span><span id="000f" class="lg lh iq lc b gy lm lj l lk ll">   “encoding/json”</span><span id="1c03" class="lg lh iq lc b gy lm lj l lk ll">   “github.com/Nerzal/gocloak/v8”</span><span id="fc65" class="lg lh iq lc b gy lm lj l lk ll">   _ “github.com/gorilla/mux”</span><span id="454b" class="lg lh iq lc b gy lm lj l lk ll">   “net/http”</span><span id="b1c0" class="lg lh iq lc b gy lm lj l lk ll">   “os”</span><span id="d6e2" class="lg lh iq lc b gy lm lj l lk ll">   “simplegoapi/src/errors”</span><span id="8a2c" class="lg lh iq lc b gy lm lj l lk ll">   “strings”</span><span id="7f59" class="lg lh iq lc b gy lm lj l lk ll">)</span><span id="2843" class="lg lh iq lc b gy lm lj l lk ll">type LoginResponse struct {</span><span id="f2e5" class="lg lh iq lc b gy lm lj l lk ll">   AccessToken string `json:”access_token”`</span><span id="de63" class="lg lh iq lc b gy lm lj l lk ll">   Title string `json:”Title”`</span><span id="e335" class="lg lh iq lc b gy lm lj l lk ll">   Description string `json:”Description”`</span><span id="97c1" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="24a4" class="lg lh iq lc b gy lm lj l lk ll">var(</span><span id="06ca" class="lg lh iq lc b gy lm lj l lk ll">   clientId = os.Getenv(“CLIENT_ID”)</span><span id="93dc" class="lg lh iq lc b gy lm lj l lk ll">   clientSecret = os.Getenv(“CLIENT_SECRET”)</span><span id="41ba" class="lg lh iq lc b gy lm lj l lk ll">   realm = os.Getenv(“REALM”)</span><span id="d883" class="lg lh iq lc b gy lm lj l lk ll">   hostname = os.Getenv(“HOST”)</span><span id="717e" class="lg lh iq lc b gy lm lj l lk ll">)</span><span id="fb59" class="lg lh iq lc b gy lm lj l lk ll">var client gocloak.GoCloak</span><span id="2764" class="lg lh iq lc b gy lm lj l lk ll">func InitializeOauthServer(){</span><span id="1527" class="lg lh iq lc b gy lm lj l lk ll">   client = gocloak.NewClient(hostname)</span><span id="2d79" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="748d" class="lg lh iq lc b gy lm lj l lk ll">func Protect(next http.Handler) http.Handler {</span><span id="bf3a" class="lg lh iq lc b gy lm lj l lk ll">   return http.HandlerFunc( func(w http.ResponseWriter, r   <br/>    *http.Request) {</span><span id="398c" class="lg lh iq lc b gy lm lj l lk ll">       authHeader := r.Header.Get(“Authorization”)</span><span id="4ac9" class="lg lh iq lc b gy lm lj l lk ll">       if len(authHeader) &lt; 1 {</span><span id="ad4a" class="lg lh iq lc b gy lm lj l lk ll">          w.WriteHeader(401)</span><span id="563b" class="lg lh iq lc b gy lm lj l lk ll">         json.NewEncoder(w).Encode(errors.UnauthorizedError())</span><span id="74be" class="lg lh iq lc b gy lm lj l lk ll">         return</span><span id="d81e" class="lg lh iq lc b gy lm lj l lk ll">      }</span><span id="0e4f" class="lg lh iq lc b gy lm lj l lk ll">     accessToken := strings.Split(authHeader,” “)[1]</span><span id="b636" class="lg lh iq lc b gy lm lj l lk ll">     rptResult, err := client.RetrospectToken(r.Context(), <br/>     accessToken, clientId, clientSecret, realm)</span><span id="a2e1" class="lg lh iq lc b gy lm lj l lk ll">     if err != nil{</span><span id="d0b2" class="lg lh iq lc b gy lm lj l lk ll">      w.WriteHeader(400)</span><span id="7fa0" class="lg lh iq lc b gy lm lj l lk ll">      json.NewEncoder(w).Encode(errors.BadRequestError(err.Error()))</span><span id="ad77" class="lg lh iq lc b gy lm lj l lk ll">      return</span><span id="0afc" class="lg lh iq lc b gy lm lj l lk ll">     }</span><span id="1336" class="lg lh iq lc b gy lm lj l lk ll">    isTokenValid := *rptResult.Active</span><span id="6029" class="lg lh iq lc b gy lm lj l lk ll">    if !isTokenValid {</span><span id="5bc0" class="lg lh iq lc b gy lm lj l lk ll">      w.WriteHeader(401)</span><span id="192f" class="lg lh iq lc b gy lm lj l lk ll">      json.NewEncoder(w).Encode(errors.UnauthorizedError())</span><span id="18ac" class="lg lh iq lc b gy lm lj l lk ll">      return</span><span id="2e92" class="lg lh iq lc b gy lm lj l lk ll">    }</span><span id="2a23" class="lg lh iq lc b gy lm lj l lk ll">    next.ServeHTTP(w, r)</span><span id="8c4c" class="lg lh iq lc b gy lm lj l lk ll">  })</span><span id="528f" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><p id="5275" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">protect函数检查传递的访问令牌是否有效，我们获取访问令牌，对其进行自省，如果有效，则继续服务请求。在控制器包中创建eventController，内容如下</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="aa07" class="lg lh iq lc b gy li lj l lk ll">package controllers</span><span id="d894" class="lg lh iq lc b gy lm lj l lk ll">import (</span><span id="2e6b" class="lg lh iq lc b gy lm lj l lk ll">   “net/http”</span><span id="94de" class="lg lh iq lc b gy lm lj l lk ll">   “simplegoapi/src/services”</span><span id="3971" class="lg lh iq lc b gy lm lj l lk ll">   “github.com/gorilla/mux”</span><span id="271d" class="lg lh iq lc b gy lm lj l lk ll">)</span><span id="3455" class="lg lh iq lc b gy lm lj l lk ll">type EventController struct {}</span><span id="c2b5" class="lg lh iq lc b gy lm lj l lk ll">func (t EventController) RegisterRoutes(router *mux.Router) {</span><span id="eae9" class="lg lh iq lc b gy lm lj l lk ll">   router.Handle(“/event”,   services.Protect(http.<br/>   HandlerFunc(services.CreateEvent))).Methods(“POST”)</span><span id="bc47" class="lg lh iq lc b gy lm lj l lk ll">   router.Handle(“/events/{id}”, services.Protect(http.<br/>   HandlerFunc(services.GetOneEvent))).Methods(“GET”)</span><span id="e539" class="lg lh iq lc b gy lm lj l lk ll">   router.Handle(“/events”, services.Protect(http.<br/>   HandlerFunc(services.AllEvents))).Methods(“GET”)</span><span id="bbb8" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><p id="213b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们实现了控制器接口的RegisterRoutes函数，传递authService的Protect函数和负责http中指定动作的各种函数。<br/> HandlerFunc函数。这样，首先调用保护函数，然后如果一切顺利，我们继续调用服务函数。</p><p id="2724" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，这就是main.go的样子</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="97ea" class="lg lh iq lc b gy li lj l lk ll">package main</span><span id="2c6c" class="lg lh iq lc b gy lm lj l lk ll">import (</span><span id="6dc9" class="lg lh iq lc b gy lm lj l lk ll">   “github.com/gorilla/mux”</span><span id="39dd" class="lg lh iq lc b gy lm lj l lk ll">   “log”</span><span id="8d0b" class="lg lh iq lc b gy lm lj l lk ll">   “net/http”</span><span id="fb4e" class="lg lh iq lc b gy lm lj l lk ll">   “simplegoapi/src/config”</span><span id="9cb5" class="lg lh iq lc b gy lm lj l lk ll">   “simplegoapi/src/controllers”</span><span id="90ad" class="lg lh iq lc b gy lm lj l lk ll">   “simplegoapi/src/services”</span><span id="531f" class="lg lh iq lc b gy lm lj l lk ll">)</span><span id="23d8" class="lg lh iq lc b gy lm lj l lk ll">func main() {</span><span id="ade6" class="lg lh iq lc b gy lm lj l lk ll">   run()</span><span id="b6cf" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="54b9" class="lg lh iq lc b gy lm lj l lk ll">func run(){</span><span id="e0d1" class="lg lh iq lc b gy lm lj l lk ll">   config.DbConnect()</span><span id="9865" class="lg lh iq lc b gy lm lj l lk ll">   services.InitializeOauthServer()</span><span id="dd83" class="lg lh iq lc b gy lm lj l lk ll">   router := mux.NewRouter().StrictSlash(true)</span><span id="afff" class="lg lh iq lc b gy lm lj l lk ll">   router.Use(commonMiddleware)</span><span id="10ee" class="lg lh iq lc b gy lm lj l lk ll">   registerRoutes(router)</span><span id="06bd" class="lg lh iq lc b gy lm lj l lk ll">   log.Fatal(http.ListenAndServe(“:8081”, router))</span><span id="4e58" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="8b9b" class="lg lh iq lc b gy lm lj l lk ll">func registerRoutes (router *mux.Router){</span><span id="480c" class="lg lh iq lc b gy lm lj l lk ll">   registerControllerRoutes(controllers.EventController{}, router)</span><span id="826f" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="0191" class="lg lh iq lc b gy lm lj l lk ll">func registerControllerRoutes(controller controllers.Controller, router *mux.Router) {</span><span id="a1c7" class="lg lh iq lc b gy lm lj l lk ll">   controller.RegisterRoutes(router)</span><span id="7703" class="lg lh iq lc b gy lm lj l lk ll">}</span><span id="235e" class="lg lh iq lc b gy lm lj l lk ll">func commonMiddleware(next http.Handler) http.Handler {</span><span id="97cd" class="lg lh iq lc b gy lm lj l lk ll">   return http.HandlerFunc(func(w http.ResponseWriter, r <br/>   *http.Request) {</span><span id="f0a3" class="lg lh iq lc b gy lm lj l lk ll">      w.Header().Add(“Content-Type”, “application/json”)</span><span id="3ef3" class="lg lh iq lc b gy lm lj l lk ll">      next.ServeHTTP(w, r)</span><span id="7a86" class="lg lh iq lc b gy lm lj l lk ll">    })</span><span id="f606" class="lg lh iq lc b gy lm lj l lk ll">}</span></pre><p id="6006" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们首先通过调用DbConnect函数连接到数据库，该函数也将运行db迁移，接下来我们初始化keycloak客户端，然后注册mux路由器，并继续调用registerRoutes函数，该函数调用控制器中实现的RegisterRoutes函数。我还添加了一个中间件，它为所有对application/json的请求全局设置Content-Type头。</p><p id="0bc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">继续启动您的keycloak服务器(如果尚未启动),并测试该服务。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ln"><img src="../Images/935aae01f30bfcc1a6dbe598a0798d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DiH2eQ5Ccak4w1Hfi6rzAQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">无效的令牌响应</figcaption></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ln"><img src="../Images/908059f771f845a471afcac20d47c1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQ0NiSg2M5BZQdjnPNUtLw.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">列出事件响应</figcaption></figure><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ln"><img src="../Images/72a91c56d0141f56a07525434ca78a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZsEFIMkca2tyvNO-FpAaQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">获得一个事件响应</figcaption></figure><p id="d1d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整的代码可以在这里找到<a class="ae kw" href="https://github.com/okemechris/simplego-api" rel="noopener ugc nofollow" target="_blank">https://github.com/okemechris/simplego-api</a></p></div></div>    
</body>
</html>