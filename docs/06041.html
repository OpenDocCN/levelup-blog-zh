<html>
<head>
<title>A RESTFul Gopher living in docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一只生活在码头的宁静的地鼠</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-restful-go-living-in-docker-14f06fdedd28?source=collection_archive---------7-----------------------#2020-10-21">https://levelup.gitconnected.com/a-restful-go-living-in-docker-14f06fdedd28?source=collection_archive---------7-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="530e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">权威指南</h2><div class=""/><div class=""><h2 id="23c4" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">一个简单的权威指南，供初学者构建一个REST API并在docker容器中运行</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/09d87c256caf26fc3169f5235262c7f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*SnrrlX6JTZbfzJlmerncrw.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated"><a class="ae ld" href="https://github.com/MariaLetta/free-gophers-pack/" rel="noopener ugc nofollow" target="_blank">https://github.com/MariaLetta/free-gophers-pack/</a></figcaption></figure><p id="7084" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">Go编译器可以生成一个二进制文件，该文件可以在任何机器上运行。然而，有时候将你的应用程序容器化会更方便，本教程将帮助你构建一个基本的RESTFul API内置go并将其容器化。</p><h1 id="0409" class="ma mb it bd mc md me mf mg mh mi mj mk ki ml kj mm kl mn km mo ko mp kp mq mr bi translated">在Go中构建Web服务器</h1><p id="a264" class="pw-post-body-paragraph le lf it lg b lh ms kd lj lk mt kg lm ln mu lp lq lr mv lt lu lv mw lx ly lz im bi translated">我们将编写一个简单的Go应用程序，在给URI打电话时公开一个简单的问候。为了首先构建它，我们将创建一个文件夹，假设我们称它为<code class="fe mx my mz na b">go-app</code>，它是我们将要编写的所有后端代码的目录。最终的文件夹结构将如下所示</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/70b7f593dbfc0c983d906458e8073e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*NdvzGROeM95PkAhjE_4hmA.png"/></div></figure><p id="c5de" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">接下来，我们将创建一个<a class="ae ld" href="https://blog.golang.org/using-go-modules" rel="noopener ugc nofollow" target="_blank"> Go模块</a>，它是存储在文件树中的<a class="ae ld" href="https://golang.org/ref/spec#Packages" rel="noopener ugc nofollow" target="_blank"> Go包</a>的集合，文件树的根是<code class="fe mx my mz na b">go.mod</code>文件，但是在服务器文件夹中运行命令</p><pre class="ks kt ku kv gt nc na nd ne aw nf bi"><span id="d0ea" class="ng mb it na b gy nh ni l nj nk">cd go-app<br/>go mod init go-app</span></pre><p id="f2eb" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">现在，我们将创建一个非常简单的服务器来处理HTTP请求。为此，我们将创建一个名为<code class="fe mx my mz na b">main.go</code>的新文件，并将下面的代码片段包含到该文件中</p><pre class="ks kt ku kv gt nc na nd ne aw nf bi"><span id="3eb5" class="ng mb it na b gy nh ni l nj nk">package main<br/>​<br/>import (<br/>    "fmt"<br/>    "log"<br/>    "net/http"<br/>)<br/>​<br/>func main() {<br/>    http.HandleFunc("/", hello)<br/>    fmt.Println("Server started")<br/>    log.Fatal(http.ListenAndServe(":8080", nil))<br/>}<br/>​<br/>func hello(w http.ResponseWriter, r *http.Request) {<br/>    w.WriteHeader(http.StatusOK)<br/>    w.Header().Set("Content-Type", "application/json")<br/>    w.Write([]byte(`{"message":"hello world!"}`))<br/>}</span></pre><p id="71f0" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">如果我们通读这个文件</p><h1 id="83a9" class="ma mb it bd mc md me mf mg mh mi mj mk ki ml kj mm kl mn km mo ko mp kp mq mr bi translated">main()函数</h1><p id="9993" class="pw-post-body-paragraph le lf it lg b lh ms kd lj lk mt kg lm ln mu lp lq lr mv lt lu lv mw lx ly lz im bi translated"><code class="fe mx my mz na b">main()</code>功能作为可执行程序的入口点。它不接受任何参数，也不返回任何内容，当您执行程序时，Go会自动调用该函数</p><p id="221d" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">在main()函数中，<code class="fe mx my mz na b">HandleFunc</code>调用告诉HTTP包用我们的<code class="fe mx my mz na b">hello</code>函数处理所有对webroot(“/”)的请求。当程序控制到达<code class="fe mx my mz na b">http.ListenAndServe</code>时，指定我们的代码应该监听端口<code class="fe mx my mz na b">8080</code></p><p id="5880" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">如果我们现在运行命令<code class="fe mx my mz na b">go run main.go</code>并在web浏览器上导航到<code class="fe mx my mz na b">localhost:8080</code>，我们应该会看到类似这样的内容。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d7cce8a632f9f8ed6c48324307701623.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/0*V4tVhlCQ7W0aUIc3.png"/></div></figure><p id="cb97" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">现在，我们有了一个基本的Go应用程序，用于响应URL <code class="fe mx my mz na b">http://localhost:8080</code>现在，下一个任务是构建一个docker映像，并在一个容器中运行我们的应用程序。为此，在项目根目录下创建一个名为Dockerfile的文件，并粘贴以下内容</p><pre class="ks kt ku kv gt nc na nd ne aw nf bi"><span id="1406" class="ng mb it na b gy nh ni l nj nk">FROM golang:1.17.5 AS GO_BUILD<br/>ENV CGO_ENABLED 0<br/>COPY . /go-app<br/>WORKDIR /go-app<br/>RUN go build -o server</span><span id="34f4" class="ng mb it na b gy nm ni l nj nk">FROM alpine:3.15<br/>WORKDIR /go-app<br/>COPY --from=GO_BUILD /go-app/server /go-app/server<br/>EXPOSE 8080<br/>CMD ["./server"]</span></pre><p id="3826" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">docker文件中每一行背后的推理</p><p id="c8cb" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这个文档中有两件重要的事情:</p><ol class=""><li id="34a2" class="nn no it lg b lh li lk ll ln np lr nq lv nr lz ns nt nu nv bi translated">这个文件使用了Docker中的Docker <a class="ae ld" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>，这只是一种说法，我们可以构建同一个文件中定义的多个Docker映像。在这个场景中，我们使用一个图像来构建我们的Go应用程序，使用另一个图像来运行它。</li><li id="a6ad" class="nn no it lg b lh nw lk nx ln ny lr nz lv oa lz ns nt nu nv bi translated">下一个是关于缓存的。为了加快构建过程，<a class="ae ld" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache" rel="noopener ugc nofollow" target="_blank"> Docker缓存Docker文件</a>中每一行的结果。行的顺序在Order文件中很重要，通常你应该在Order文件中执行那些不经常改变的动作，而不是那些经常改变的动作。</li></ol><p id="8980" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><code class="fe mx my mz na b">FROM golang:1.17.5 AS GO_BUILD</code>确保Docker将<a class="ae ld" href="https://hub.docker.com/_/golang/" rel="noopener ugc nofollow" target="_blank">官方Go图像</a>作为基础图像。在这种情况下，我们使用标签<code class="fe mx my mz na b">1.17.5</code>。我们将生成的图像标记为<code class="fe mx my mz na b">GO_BUILD</code></p><p id="a5fe" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><code class="fe mx my mz na b">WORKDIR /go-app</code>设置工作目录。</p><p id="6cea" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><code class="fe mx my mz na b">COPY . /go-app</code>复制内容结束</p><p id="edc0" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><code class="fe mx my mz na b">RUN go build -o server</code>将你的应用编译成二进制文件</p><p id="6284" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><code class="fe mx my mz na b">FROM alpine:3.15</code>使用alpine作为我们的跑步者图像，我们的GO应用程序将在其中运行</p><p id="064b" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><code class="fe mx my mz na b">COPY --from=GO_BUILD /go-app/server /go-app/server</code>将之前构建的二进制文件复制到映像中</p><p id="51c6" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><code class="fe mx my mz na b">EXPOSE 8080</code>通过端口8080公开应用程序</p><p id="1423" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><code class="fe mx my mz na b">CMD ["./server"]</code>设置容器运行时运行的默认命令</p><p id="b21e" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">要构建docker映像，请在项目根目录下执行以下命令</p><pre class="ks kt ku kv gt nc na nd ne aw nf bi"><span id="3998" class="ng mb it na b gy nh ni l nj nk">docker build -t api .</span></pre><p id="c3cf" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这将构建一个名为<code class="fe mx my mz na b">api</code>的docker映像，要运行这个映像，请执行下面的命令</p><pre class="ks kt ku kv gt nc na nd ne aw nf bi"><span id="1696" class="ng mb it na b gy nh ni l nj nk">docker run -it -p 8080:8080 api</span></pre><h1 id="5349" class="ma mb it bd mc md me mf mg mh mi mj mk ki ml kj mm kl mn km mo ko mp kp mq mr bi translated">结论</h1><p id="5340" class="pw-post-body-paragraph le lf it lg b lh ms kd lj lk mt kg lm ln mu lp lq lr mv lt lu lv mw lx ly lz im bi translated">现在，您已经知道如何创建Restful Go API，并将您的应用程序封装到生产就绪映像中。</p></div></div>    
</body>
</html>