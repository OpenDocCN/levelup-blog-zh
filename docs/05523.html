<html>
<head>
<title>3 Easy Steps to Implement Two-Factor Authentication in Node.JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在节点中实施双因素身份认证的3个简单步骤。射流研究…</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-easy-steps-to-implement-two-factor-authentication-in-node-js-559905530392?source=collection_archive---------0-----------------------#2020-09-07">https://levelup.gitconnected.com/3-easy-steps-to-implement-two-factor-authentication-in-node-js-559905530392?source=collection_archive---------0-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0938" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">2FA实现起来没有你想的那么恐怖，我用3个步骤证明给你看。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0e40efb4d2ed186fe1f5186853beef79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N4406TmgXqVQHMtF"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@cgower?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯多夫·高尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">双因素身份验证(2FA)是第二层帐户保护，我强烈建议每个人都应该启用它。与传统的用户名/密码不同，2FA要求用户输入与个人信息相关的附加信息。例如，最广为人知的2FA形式要求最终用户回答一个安全问题。如果最终用户是设置安全问题的人，他们回答问题应该没有问题。安全问题可以是:你母亲的娘家姓是什么？你的第一只宠物叫什么名字？你的家乡叫什么名字？</p><p id="51d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2FA的最新形式是通过电子邮件或SMS接收令牌，或者通过认证器应用程序(如Google Authenticator)获得令牌。服务器根据用户帐户生成密钥。秘密密钥有助于生成最终用户用来验证其身份的后续令牌。如果最终用户是帐户的持有者，那么他们应该知道在哪里寻找令牌(SMS、电子邮件或验证器应用程序)，并且令牌应该可以根据秘密进行验证。</p><p id="f263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以实现2FA，但是本文将回顾使用npm包实现2FA。</p><p id="a673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们快速回顾一下OTP。</p><h2 id="e12f" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">什么是OTP(一次性密码)？</h2><p id="9082" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">一次性密码顾名思义，就是最终用户使用一次的密码。我喜欢称它们为代币。与终端用户创建和知道的传统密码不同，服务器或认证器应用程序会生成OTP。一次性密码依靠两样东西:<strong class="lb iu">一个秘密和一个移动因子。</strong></p><p id="1b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初的OTP被称为HOTP <em class="lz">(基于HMAC的一次性密码或基于哈希的一次性密码)</em>。HOTP是由互联网工程任务组(IETF)发布的一种算法，命名为RFC4226。这种类型的动态口令的移动因素是计数器。</p><p id="dcef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成的令牌是使用密钥<em class="lz">(也称为种子)</em>和计数器的HMAC散列。散列的输出很长，所以为了更适合作为令牌，将其缩短。每个令牌都有一个计数器，只要终端用户生成一个令牌，针对该令牌的计数器就会增加。服务器也有一个计数器，但是当令牌被验证时，它的计数器增加。</p><p id="c58c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种认证的关键是服务器上的<em class="lz">前瞻窗口</em>。服务器计数器和令牌计数器很容易不同步，因此为了重新同步这两个计数器，服务器使用大小为<em class="lz"> n的先行窗口。</em>如果令牌计数器落在窗口内，则可以对其进行验证。然而，这个算法有一个问题。如果生成的令牌数量超过了前瞻窗口，您将最终锁定系统。换句话说，你将无法登录。我让您自己去探究这个安全问题。</p><p id="de4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TOTP是基于时间的一次性密码，基于HOTP，由IETF<a class="ae ky" href="https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" rel="noopener ugc nofollow" target="_blank">发布为</a><a class="ae ky" href="https://tools.ietf.org/html/rfc6238" rel="noopener ugc nofollow" target="_blank"> RFC6238 </a>。与计数器的移动因子HOTP不同，TOTP是一种时间移动因子的算法。生成的令牌在一段时间内有效，也称为时间步长。例如，如果您打开Google Authenticator应用程序，您会注意到一个计时器正在针对您的一些令牌运行。一旦定时器到期，认证器生成新的令牌。</p><p id="808e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><em class="lz">speakeasy</em></code>包支持这两种算法，但是在本文中，我将把重点放在TOTP上。</p><p id="add5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我之前提到的，您可以通过短信或电子邮件发送令牌，或者使用Authenticator应用程序获取令牌。如果您选择Authenticator应用程序路线，请为最终用户生成一个二维码，供其在初始设置2FA时扫描。然后使用验证者生成的令牌来验证秘密。如果您选择SMS/电子邮件路由，请创建一个要发送的令牌，并根据该令牌进行验证。</p><p id="7fa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想强调所有这些都应该发生在服务器上！请不要在客户端传递秘密。它违背了安全的目的。客户端应该显示二维码，只需一次，供最终用户扫描。</p><h2 id="bdc7" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">产生一个秘密</h2><p id="7a3a" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated"><code class="fe lv lw lx ly b">speakeasy</code>方法<code class="fe lv lw lx ly b">generateSecret</code>返回一个带有几种编码的对象，比如ASCII、十六进制、base32、otpauth_url等。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="e54b" class="ma mb it ly b gy nc nd l ne nf">import { generateSecret } from 'speakeasy'</span><span id="b4eb" class="ma mb it ly b gy ng nd l ne nf">interface TwoFactorEntity {<br/>  userId: number<br/>  secret: string<br/>  enabled: boolean // default value is false<br/>}</span><span id="b1cb" class="ma mb it ly b gy ng nd l ne nf">const generateUserSecret = <br/>(userRepo: Respository, twoFactor: TwoFactorEntity) =&gt; {</span><span id="cf8e" class="ma mb it ly b gy ng nd l ne nf">const secret = generateSecret()<br/>   twoFactor.secret = secret.base32<br/>   userRepo.save(twoFactor)<br/>   return secret</span><span id="9ad2" class="ma mb it ly b gy ng nd l ne nf">}</span></pre><p id="63ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成密码后，将其中一种编码存储在数据库中。这个存储应该是一个临时的占位符，或者有一些指示该帐户还没有启用2FA。</p><p id="a2f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终用户必须完成设置<em class="lz">(生成密码，验证令牌)</em>以启用2FA。如果他们在设置时没有成功验证该密码，则该密码是无用的，并且不应该针对该密码生成令牌，因为最终用户将永远无法登录。</p><p id="1090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的实现中，我在一个与用户<code class="fe lv lw lx ly b">TwoFactorEntity</code>有关系的实体上创建了一个<code class="fe lv lw lx ly b">enabled</code>列。如果最终用户在设置期间成功验证了秘密，则该标志为<em class="lz">真</em>。在随后的验证中，该标志不应复位。拥有这个列意味着我可以在我的数据库中只存储一次<code class="fe lv lw lx ly b">secret</code>(也就是说，我不需要一个<code class="fe lv lw lx ly b">temporary</code>列和一个<code class="fe lv lw lx ly b">permanent</code>列)。</p><p id="f911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要注意，我返回了秘密对象；这要是为了下一步！</p><h2 id="0ecc" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">显示二维码</h2><p id="e0bd" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated"><strong class="lb iu">如果你使用的是Authenticator应用程序路线，请继续阅读！</strong></p><p id="65e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如果没有，跳到下一个标题。</strong></p><p id="cff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装<code class="fe lv lw lx ly b">qrcode</code></p><p id="2648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用secret对象，将<code class="fe lv lw lx ly b">otpauth_url</code>编码传递给<code class="fe lv lw lx ly b">toDataURL</code>方法，它将返回一个PNG数据URL。在IMG标签中显示此URL，供最终用户扫描。记住在服务器上生成这个数据URL，并将URL传递回客户机。不要传递秘密！</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="b7c5" class="ma mb it ly b gy nc nd l ne nf">import { toDataURL } from 'qrcode'</span><span id="2724" class="ma mb it ly b gy ng nd l ne nf">interface SecretData {<br/>   otpauth_url: string<br/>}</span><span id="667a" class="ma mb it ly b gy ng nd l ne nf">const generateQRCode = async (secret: SecretData) =&gt; {<br/>    return await toDataURL(secret.otpauth_url)<br/>}</span></pre><h2 id="92e1" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">生成令牌</h2><p id="9695" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated"><strong class="lb iu">如果你选择短信/电子邮件，那么请继续阅读。</strong></p><p id="bcf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如果没有，跳到下一步。</strong></p><p id="671b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成TOTP令牌很简单，但是您可能需要进行一些自定义。您可以更改用于创建令牌的算法、时间步长、令牌的位数等。我将在这里包含这些选项的文档的直接链接<a class="ae ky" href="https://github.com/speakeasyjs/speakeasy#totp" rel="noopener ugc nofollow" target="_blank">。因此，请确保您阅读了<code class="fe lv lw lx ly b">speakeasy</code>文档，并咨询您的团队，找出适合您的正确行动方案。现在，我将向您展示该做些什么。</a></p><p id="bc68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要生成令牌，请使用保存在数据库中的编码。使用<code class="fe lv lw lx ly b">totp</code>构造函数传入秘密、编码和任何其他选项。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="43be" class="ma mb it ly b gy nc nd l ne nf">import { totp } from 'speakeasy'</span><span id="8fe5" class="ma mb it ly b gy ng nd l ne nf">interface SecretData {<br/>   base32: string<br/>}</span><span id="c5f5" class="ma mb it ly b gy ng nd l ne nf">const generateToken = (secret: SecretData) =&gt; {<br/>  const token = totp({ secret: secret.base32, encoding: 'base32'})<br/>  return token<br/>}</span></pre><p id="03f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，使用邮件或SMS客户端将令牌发送给最终用户。终端用户收到令牌后，请对其进行验证。下一步将教你如何编写验证函数。</p><h2 id="4ea6" class="ma mb it bd mc md me dn mf mg mh dp mi li mj mk ml lm mm mn mo lq mp mq mr ms bi translated">验证令牌</h2><p id="770c" class="pw-post-body-paragraph kz la it lb b lc mt ju le lf mu jx lh li mv lk ll lm mw lo lp lq mx ls lt lu im bi translated">最后一步！恭喜你，你走到了这一步。此时，您应该有一个生成秘密的方法，以及一些为最终用户创建令牌的策略。</p><p id="7a1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该步骤依赖于终端用户向服务器提供令牌。令牌通过短信或电子邮件发送，或在验证器应用程序中生成。使用传递给服务器的令牌和保存在数据库中的密码，验证最终用户。</p><p id="fc5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与生成令牌类似，<code class="fe lv lw lx ly b">speakeasy</code>提供了不同的选项来传递给<code class="fe lv lw lx ly b">verify</code>方法。这里的是更多选项的<code class="fe lv lw lx ly b">verify</code>文档的链接。</p><pre class="kj kk kl km gt my ly mz na aw nb bi"><span id="9f0f" class="ma mb it ly b gy nc nd l ne nf">import { totp } from 'speakeasy'</span><span id="9e17" class="ma mb it ly b gy ng nd l ne nf">const verifyToken = (userToken: string, serverSecret: string) =&gt; {<br/>    const verified = totp.verify({ <br/>         secret: serverSecret, <br/>         encoding: 'base32',<br/>         token: userToken<br/>        })</span><span id="d731" class="ma mb it ly b gy ng nd l ne nf">return verified<br/>}</span><span id="ab35" class="ma mb it ly b gy ng nd l ne nf">const enableTwoFactor = (<br/>      verified: boolean,<br/>      repo: Respository, <br/>      twoFactor: TwoFactorEntity) =&gt; {</span><span id="192e" class="ma mb it ly b gy ng nd l ne nf">if (!twoFactor.enabled) {<br/>        twoFactor.enabled = verified<br/>     }</span><span id="0bcb" class="ma mb it ly b gy ng nd l ne nf">repo.save(twoFactor)<br/>}</span></pre><p id="a049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的实现中，我使用了不同的方法来获取我的令牌实体。这里我没有包括检索。如果用户令牌验证了秘密，则<code class="fe lv lw lx ly b">verify</code>方法将返回<code class="fe lv lw lx ly b">true</code>，否则返回<code class="fe lv lw lx ly b">false</code>。验证过程的结果将有助于针对用户启用2FA。</p><p id="bec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">enableTwoFactor</code>函数使用我的数据库实体来启用2FA，当且仅当，two factor以前没有启用，这应该只发生一次。</p><p id="6d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您验证之后和启用之前，有明显的工作要考虑。例如，如果一个用户没有被验证，并且<code class="fe lv lw lx ly b">enabled</code>标志是<code class="fe lv lw lx ly b">false</code>，会发生什么呢？这对用户来说是什么样的？服务器应该返回什么样的响应？所有这些都取决于你的应用，所以我让你来填补空白。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="01ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样；你已经通过三个简单的步骤成功实现了2FA。集成2FA最困难的部分是中间的所有小步骤，这取决于您的应用程序(例如，设置端点，集成您的电子邮件或短信服务，计算前端部分，等等。).一旦最终用户启用2FA，对于每次后续登录，您的服务器将生成一个令牌，或者最终用户将查看authenticator应用程序，然后将该令牌输入到您的应用程序中。</p><p id="d6d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章让您对什么是2FA以及如何在您的应用程序中实现它有一个很好的了解。</p><p id="1d98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">快乐编码！</em></p></div></div>    
</body>
</html>