<html>
<head>
<title>The wonderfully ̶b̶r̶o̶k̶e̶n̶ quirky world of JavaScript — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript奇妙的̶b̶r̶o̶k̶e̶n̶奇异世界—第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-wonderfully-%CC%B6b%CC%B6r%CC%B6o%CC%B6k%CC%B6e%CC%B6n%CC%B6-quirky-world-of-javascript-part-1-54cb1eba0d4f?source=collection_archive---------18-----------------------#2020-04-04">https://levelup.gitconnected.com/the-wonderfully-%CC%B6b%CC%B6r%CC%B6o%CC%B6k%CC%B6e%CC%B6n%CC%B6-quirky-world-of-javascript-part-1-54cb1eba0d4f?source=collection_archive---------18-----------------------#2020-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="acba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JavaScript类型系统之旅。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/797d8005f4e1656d8d6d98f09d754bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JEBhuxs2Gjs0RvaqVskykA.png"/></div></div></figure><p id="8fe3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">几个月前，我开始学习如何构建web应用程序。我浏览了各种平台上的“全栈”课程列表，缩小到涵盖React和Node的课程，并开始浏览视频。随着我开始编写越来越多的代码，我很快意识到JavasScript与其他语言有多么不同。</p><p id="8925" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我主要来自Java &amp; Go背景，对动态类型语言非常陌生。我很快开始遇到会破坏我的代码的极端情况，有时是悄无声息的。我很快意识到，我需要先学习JavaScript基础，而不是学习Node &amp; React。在这个系列中，我将试着讲述我对JavaScript不同之处的认识，从<strong class="js iu">类型</strong>开始。</p><h1 id="24e4" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">概观</h1><p id="3e2c" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">每当你在JS中声明一个变量时，你就隐式地定义了一个类型。例如下面的代码:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="e78d" class="mj lc it mf b gy mk ml l mm mn">var name = "aditya";<br/>var age = 18;</span></pre><p id="3e07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">意味着名为<em class="la"> name </em>的变量属于类型<em class="la"> string，</em>T20】age属于类型<em class="la"> number </em>。<br/> JS共有7种类型:(<code class="fe mo mp mq mf b">string</code>、<code class="fe mo mp mq mf b">number</code>、<code class="fe mo mp mq mf b">boolean</code>、<code class="fe mo mp mq mf b">null</code>、<code class="fe mo mp mq mf b">undefined</code>、<code class="fe mo mp mq mf b">object</code>、<code class="fe mo mp mq mf b">Symbol</code>)。</p><p id="83da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了对象<strong class="js iu"> </strong>之外的一切都被认为是原语。原语一次只能包含一个值，而对象用于定义实体。对于来自OOP背景的人来说，JS对象是最接近类的东西(尽管两者之间有显著的差异)。</p><p id="8f43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">空值&amp;未定义。在编写代码时，变量常常没有值。它是不存在的，程序的流程也因此而改变。大多数语言都有一个特定的结构，我们可以用它来完成这个任务。<br/>比如Java里的<strong class="js iu"> </strong> <code class="fe mo mp mq mf b">null</code>，或者Golang里的<code class="fe mo mp mq mf b">nil</code> <strong class="js iu"> </strong>。另一方面，JS有两个广泛用于此目的的构造:<code class="fe mo mp mq mf b">null</code>和未定义的<em class="la">。<br/> </em>与普遍的看法相反，那两个是<strong class="js iu">不是</strong>一样的。<br/> <code class="fe mo mp mq mf b">undefined</code>表示已经声明了一个变量，但是还没有赋值，而<code class="fe mo mp mq mf b">null</code> <em class="la"> </em>是JS中的<em class="la">显式</em>值，习惯上用来表示没有值。以下代码的计算结果为false:</strong></p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="1401" class="mj lc it mf b gy mk ml l mm mn">console.log(null === undefined); //false</span></pre></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="3257" class="lb lc it bd ld le my lg lh li mz lk ll lm na lo lp lq nb ls lt lu nc lw lx ly bi translated">强迫</h1><p id="71c4" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">将变量从一种类型隐式转换为另一种类型的过程称为强制。当您尝试运行以下代码时，大多数语言，甚至是动态语言，都会抛出错误:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="3add" class="mj lc it mf b gy mk ml l mm mn">console.log("aditya" + 18); //aditya18</span></pre><p id="1653" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在JS领域中，“+”运算符意味着两个事物中的一个；要么你把两个数字相加，要么你把两个字符串串联起来。由于JS无法将<code class="fe mo mp mq mf b">aditya</code>转换成数字，所以它<em class="la">将</em> 18强制转换成字符串，并将它们串联起来。很漂亮吧？<br/>没那么快。您认为以下代码的输出是什么样的:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="38bb" class="mj lc it mf b gy mk ml l mm mn">console.log('18' - 8); //10</span></pre><p id="b6d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在JS land中，“-”运算符只用于从右边减去左边。由于JS对类型错误极其宽容，所以它不会在这里抛出错误。相反，它试图将字符串<code class="fe mo mp mq mf b">18</code>强制转换为一个数字，并返回<code class="fe mo mp mq mf b">10</code>。类型系统的这些问题导致了初学JS开发人员的一大堆错误。</p><p id="b130" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JS中的类型系统可能导致无声错误的另一个例子:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="0e50" class="mj lc it mf b gy mk ml l mm mn">console.log([ 2, 10, 30 ].sort()); // [10, 2, 30]</span></pre><p id="f150" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么会这样？因为默认情况下，<a class="ae nd" href="https://www.ecma-international.org/ecma-262/#sec-array.prototype.sort" rel="noopener ugc nofollow" target="_blank"> Array.prototype.sort </a>算法通过首先将所有元素转换为字符串来比较它们，&amp;然后在布尔上下文中对它们求值。</p><p id="0a3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">…..最后一个:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="be9b" class="mj lc it mf b gy mk ml l mm mn">console.log(1 &lt; 2 &lt; 3); // true<br/>console.log(3 &gt; 2 &gt; 1); //false</span></pre><p id="c8a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么会这样？第一种情况，JS将<code class="fe mo mp mq mf b">1 &lt; 2</code> <em class="la"> </em>转换为<em class="la"> </em>真<em class="la">。</em>然后<code class="fe mo mp mq mf b">(true) &lt; 3</code> = &gt; <code class="fe mo mp mq mf b">(1 &lt; 3)</code> <em class="la"> …..</em>评估为<strong class="js iu">真</strong>。<br/>而在后一种情况下，<code class="fe mo mp mq mf b">3 &gt; 2</code>的计算结果为真。然后<code class="fe mo mp mq mf b">true &gt; 1</code> = &gt; <code class="fe mo mp mq mf b">1 &gt; 1</code>得出<strong class="js iu">假</strong>。</p><p id="a1cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种语言的古怪性导致了<a class="ae nd" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank">流</a>和<a class="ae nd" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">类型脚本</a>的出现，它们的主要目的是将开发人员从JS类型系统的陷阱中解救出来。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="d4f9" class="lb lc it bd ld le my lg lh li mz lk ll lm na lo lp lq nb ls lt lu nc lw lx ly bi translated">平等</h1><p id="3f21" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">任何熟悉编程的人都会使用<code class="fe mo mp mq mf b">==</code>符号来比较两个变量。另一方面，JS有<strong class="js iu"> 2 </strong>种方法来相互比较变量。<code class="fe mo mp mq mf b">==</code>标志和<code class="fe mo mp mq mf b">===</code>标志。</p><h2 id="56c7" class="mj lc it bd ld ne nf dn lh ng nh dp ll kb ni nj lp kf nk nl lt kj nm nn lx no bi translated">双等于(==):</h2><p id="16a9" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated"><code class="fe mo mp mq mf b">==</code>算法检查<em class="la">是否与</em>相等。这意味着它只比较变量的值。如果类型不同，JS将强制变量检查值是否相同。例如:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="a8c1" class="mj lc it mf b gy mk ml l mm mn">console.log(3 == '3'); // true</span></pre><p id="99f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="6add" class="mj lc it mf b gy mk ml l mm mn">console.log(true == '1'); // also true!</span></pre><p id="86b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种松散的比较对于大多数用例来说是不实际的；因此JS引入了<code class="fe mo mp mq mf b">===</code>符号。</p><h2 id="ed6d" class="mj lc it bd ld ne nf dn lh ng nh dp ll kb ni nj lp kf nk nl lt kj nm nn lx no bi translated">三重等于(===):</h2><p id="8906" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">现在你可能已经猜到了，<code class="fe mo mp mq mf b">===</code>算法检查<em class="la">严格的</em>相等性。简单地说，如果变量的类型不匹配，它将返回false。<br/> Triple Equals在JS社区获得了如此广泛的欢迎，以至于ESLint已经<a class="ae nd" href="https://eslint.org/docs/rules/eqeqeq" rel="noopener ugc nofollow" target="_blank">进行了检查！</a></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="97ab" class="lb lc it bd ld le my lg lh li mz lk ll lm na lo lp lq nb ls lt lu nc lw lx ly bi translated">真实vs真实</h1><p id="e3b6" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">在JS中，<strong class="js iu">真值</strong>是在<a class="ae nd" href="https://developer.mozilla.org/en-US/docs/Glossary/Boolean" rel="noopener ugc nofollow" target="_blank">布尔</a>上下文中遇到时被认为是<code class="fe mo mp mq mf b">true</code>的值。<br/>一些例子有<code class="fe mo mp mq mf b"><em class="la">{}</em></code>(空对象)、<code class="fe mo mp mq mf b"><em class="la">[]</em></code>(空数组)、<code class="fe mo mp mq mf b"><em class="la">“0”</em></code> <em class="la"> </em>(带0的字符串)等。</p><p id="03dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似的，还有一个<em class="la"> falsy </em>值的列表。只有<code class="fe mo mp mq mf b">undefined</code>、<code class="fe mo mp mq mf b">null</code>、<code class="fe mo mp mq mf b">NaN</code>、0、<code class="fe mo mp mq mf b">“”</code>(空字符串)和<code class="fe mo mp mq mf b">false</code>被认为是<strong class="js iu"> falsy </strong>值。</p><p id="57df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这有什么关系？正因为如此:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="2d5e" class="mj lc it mf b gy mk ml l mm mn">console.log(true == 18);  // false<br/>if (18) {<br/>  console.log('This is executed'); //"This is executed"<br/>}</span></pre><p id="92a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，<code class="fe mo mp mq mf b">if</code>语句检查18是否为真，而不是它是否为真。像^这样的问题导致了双非运算符的出现。</p><h2 id="ac98" class="mj lc it bd ld ne nf dn lh ng nh dp ll kb ni nj lp kf nk nl lt kj nm nn lx no bi translated">双非运算符(！！):</h2><p id="c41f" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">为了强制检查变量的值是否为true/false，我们可以使用double not运算符。这就是为什么常见的代码是这样的:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="176e" class="mj lc it mf b gy mk ml l mm mn">function userHasName(user) {<br/>   return !!user.name;<br/>}</span><span id="e21c" class="mj lc it mf b gy np ml l mm mn">console.log(userHasName({name: ''})); //false</span><span id="975e" class="mj lc it mf b gy np ml l mm mn">console.log(userHasName({name: 'adi'})); //true</span></pre><p id="641f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还是从我们之前的例子来看:</p><pre class="kp kq kr ks gt me mf mg mh aw mi bi"><span id="4aeb" class="mj lc it mf b gy mk ml l mm mn">console.log(true == !!18);  // true</span></pre><p id="2006" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个关于JS中如何进行比较的详细解释。</p><h1 id="0d8e" class="lb lc it bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="66b1" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">总之，JS社区非常接受这样的细微差别，并且已经学会对这样的问题一笑置之。此外，社区正致力于采用有助于<em class="la"> </em>完全避免这些问题的技术。静态检查越来越受欢迎，<strong class="js iu"> TypeScript </strong>现在被许多人认为是一种生产就绪的语言。随着时间的推移，社区也在发展。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="17fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有一个Repl来玩这个博客中的所有代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="897c" class="mj lc it bd ld ne nf dn lh ng nh dp ll kb ni nj lp kf nk nl lt kj nm nn lx no bi translated">参考资料:</h2><p id="3501" class="pw-post-body-paragraph jq jr it js b jt lz jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn im bi translated">[1]:<a class="ae nd" href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Glossary/Truthy</a></p></div></div>    
</body>
</html>