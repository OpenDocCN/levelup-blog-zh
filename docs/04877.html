<html>
<head>
<title>Why and How to set Probes in Kubernetes? Design a robust K8s cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么以及如何在Kubernetes中设置探头？设计强大的K8s集群</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-and-how-to-set-probes-in-kubernetes-d7da39e94e64?source=collection_archive---------7-----------------------#2020-07-21">https://levelup.gitconnected.com/why-and-how-to-set-probes-in-kubernetes-d7da39e94e64?source=collection_archive---------7-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fbbc44b865296aa9664997ef9c24042b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlE7lDtrtfiIo-uLLmzZVA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@younis67?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> L N </a>在<a class="ae kf" href="https://unsplash.com/s/photos/probe?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="eb1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很难设计一个具有<strong class="ki iu">多个相互依赖的服务</strong>的健壮K8s集群。通常，如果某个核心服务崩溃，依赖于它的所有服务都会失败……这是意料之中的，但是我们应该能够查明导致失败的服务，并在无需任何手动操作的情况下重启/回滚。K8s <strong class="ki iu">活性</strong>、<strong class="ki iu">准备就绪</strong>探头和<code class="fe le lf lg lh b"><strong class="ki iu">minReadySeconds</strong></code>设置前来救援。</p><p id="9bcf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们逐一查看这些设置，看看为什么、如何以及在何种组合中使用它们:</p><h1 id="eddd" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak"> K8s活性探针</strong></h1><p id="9742" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">kubelet</code>使用<a class="ae kf" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">活性探测器</strong> </a>来知道<strong class="ki iu">何时重启容器</strong>。例如，活跃度探测器可以捕获死锁，此时应用程序正在运行，但无法取得进展。在这种状态下重启容器有助于提高应用程序的可用性。许多长时间运行的应用程序最终会转换到中断状态，除非重新启动，否则无法恢复。Kubernetes提供了活性探针来检测和补救这种情况。</p><p id="8c13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">活性可以通过以下方式检查:</p><ul class=""><li id="63fa" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated">活跃度命令(<code class="fe le lf lg lh b">exec</code></li></ul><pre class="mu mv mw mx gt my lh mz na aw nb bi"><span id="1c16" class="nc lj it lh b gy nd ne l nf ng">livenessProbe:<br/>   exec:<br/>     command:<br/>     - cat<br/>     - /tmp/healthy<br/>   initialDelaySeconds: 5<br/>   periodSeconds: 5</span></pre><ul class=""><li id="6b29" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated">活跃度HTTP GET请求(<code class="fe le lf lg lh b">httpGet</code></li></ul><pre class="mu mv mw mx gt my lh mz na aw nb bi"><span id="990d" class="nc lj it lh b gy nd ne l nf ng">livenessProbe:<br/>   httpGet:<br/>     path: /healthz<br/>     port: 8080<br/>     httpHeaders:<br/>     - name: Custom-Header<br/>       value: Awesome<br/>   initialDelaySeconds: 3<br/>   periodSeconds: 3</span></pre><ul class=""><li id="2dd3" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated">活跃度TCP探测(<code class="fe le lf lg lh b">tcpSocket</code></li></ul><pre class="mu mv mw mx gt my lh mz na aw nb bi"><span id="4551" class="nc lj it lh b gy nd ne l nf ng">readinessProbe:<br/>   tcpSocket:<br/>     port: 8080<br/>   initialDelaySeconds: 5<br/>   periodSeconds: 10<br/> livenessProbe:<br/>   tcpSocket:<br/>     port: 8080<br/>   initialDelaySeconds: 15<br/>   periodSeconds: 20</span></pre><p id="6059" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">重启策略:</strong></p><p id="9261" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:在Pod中重新启动容器(它刷新容器上的所有内容)不应与重新启动Pod相混淆。Pod不是一个进程，而是一个运行容器的环境。Pod会一直存在，直到被删除。</p><p id="b9e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个PodSpec有一个带有可能值<code class="fe le lf lg lh b">Always</code>、<code class="fe le lf lg lh b">OnFailure</code>和<code class="fe le lf lg lh b">Never</code>的<code class="fe le lf lg lh b">restartPolicy</code>字段。默认值为<code class="fe le lf lg lh b">Always</code>。<code class="fe le lf lg lh b">restartPolicy</code>适用于Pod中的所有容器。<code class="fe le lf lg lh b">restartPolicy</code>仅指在同一节点上通过<code class="fe le lf lg lh b">kubelet</code>重启容器。由<code class="fe le lf lg lh b">kubelet</code>重启的已退出容器以五分钟为上限的指数后退延迟(10秒、20秒、40秒……)重启，并在成功执行十分钟后重置。正如Pods文档中所讨论的，一旦绑定到一个节点，一个Pod将永远不会重新绑定到另一个节点。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="4f06" class="li lj it bd lk ll no ln lo lp np lr ls lt nq lv lw lx nr lz ma mb ns md me mf bi translated"><strong class="ak">在K8s中配置探头</strong></h1><p id="8fc7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><a class="ae kf" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#probe-v1-core" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">探测器</strong> </a>有许多字段，您可以使用这些字段来更精确地控制活动和就绪检查的行为:</p><ul class=""><li id="29df" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">initialDelaySeconds</code>:容器启动后，活动或准备就绪探测启动前的秒数。默认为<code class="fe le lf lg lh b">0</code>秒。最小值为<code class="fe le lf lg lh b">0</code>。</li><li id="5df8" class="ml mm it ki b kj nt kn nu kr nv kv nw kz nx ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">periodSeconds</code>:执行探测的频率(秒)。默认为<code class="fe le lf lg lh b">10</code>秒。最小值为<code class="fe le lf lg lh b">1</code>。</li><li id="b0d3" class="ml mm it ki b kj nt kn nu kr nv kv nw kz nx ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">timeoutSeconds</code>:探头超时前的秒数。默认为<code class="fe le lf lg lh b">1</code>秒。最小值是<code class="fe le lf lg lh b">1</code>。</li><li id="addd" class="ml mm it ki b kj nt kn nu kr nv kv nw kz nx ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">successThreshold</code>:探针失败后被认为成功的最少连续成功次数。默认为<code class="fe le lf lg lh b">1</code>。必须是<code class="fe le lf lg lh b">1</code>才能活跃度。最小值是<code class="fe le lf lg lh b">1</code>。</li><li id="7fce" class="ml mm it ki b kj nt kn nu kr nv kv nw kz nx ld mq mr ms mt bi translated">当一个探测器失败时，Kubernetes会在放弃前尝试失败阈值次。在活性探测的情况下放弃意味着重新启动容器。如果是准备就绪探测，Pod将被标记为未准备就绪。默认为<code class="fe le lf lg lh b">3</code>。最小值是<code class="fe le lf lg lh b">1</code>。</li></ul><p id="739d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">HTTP探针具有可在<code class="fe le lf lg lh b">httpGet</code>上设置的附加字段:</p><ul class=""><li id="6175" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">host</code>:要连接的主机名，默认为pod IP。您可能希望在httpHeaders中设置“Host”。</li><li id="d814" class="ml mm it ki b kj nt kn nu kr nv kv nw kz nx ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">scheme</code>:用于连接主机的方案(HTTP或HTTPS)。默认为HTTP。</li><li id="5a91" class="ml mm it ki b kj nt kn nu kr nv kv nw kz nx ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">path</code>:HTTP服务器上的访问路径。</li><li id="9633" class="ml mm it ki b kj nt kn nu kr nv kv nw kz nx ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">httpHeaders</code>:请求中要设置的自定义头。HTTP允许重复的头。</li><li id="5b3b" class="ml mm it ki b kj nt kn nu kr nv kv nw kz nx ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">port</code>:集装箱上要访问的端口的名称或编号。数字必须在<code class="fe le lf lg lh b">1</code>到<code class="fe le lf lg lh b">65535</code>的范围内。</li></ul><p id="da1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于TCP探针，<code class="fe le lf lg lh b">kubelet</code>在节点上建立探针连接，而不是在pod中，这意味着您不能在<code class="fe le lf lg lh b">host</code>参数中使用服务名，因为<code class="fe le lf lg lh b">kubelet</code>无法解析它。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="9060" class="li lj it bd lk ll no ln lo lp np lr ls lt nq lv lw lx nr lz ma mb ns md me mf bi translated"><strong class="ak"> K8s就绪探测器</strong></h1><p id="9d61" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">kubelet</code>使用<a class="ae kf" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">准备就绪探测器</strong> </a>来知道什么时候<strong class="ki iu">集装箱准备好开始接受交通</strong>。当一个<strong class="ki iu">箱</strong>的所有容器都准备好时，该箱被视为准备就绪。该信号的一个用途是控制哪些pod用作服务的后端。当一个Pod未就绪时，它将从服务负载平衡器中删除。</p><p id="9bc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时，应用程序暂时无法提供流量服务。例如，应用程序可能需要在启动时加载大量数据或配置文件，或者在启动后依赖外部服务。在这种情况下，您不希望终止应用程序，但也不希望向它发送请求。</p><p id="9da8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就绪探测器的配置类似于活跃度。唯一的区别是您使用了<code class="fe le lf lg lh b">readinessProbe</code>字段而不是<code class="fe le lf lg lh b">livenessProbe</code>字段。</p><p id="d93d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就绪和活性探测可以并行用于同一容器。使用这两种方法可以确保流量不会到达没有准备好的容器，并且容器在失败时会重新启动。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="1c8d" class="li lj it bd lk ll no ln lo lp np lr ls lt nq lv lw lx nr lz ma mb ns md me mf bi translated">K8s启动探测器</h1><p id="62ea" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">kubelet</code>使用<a class="ae kf" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">启动探测器</strong> </a>来了解容器应用程序何时启动。如果配置了这样的探测器，它会禁用活性和就绪性检查，直到成功，确保这些探测器不会干扰应用程序的启动。这可用于对缓慢启动的容器进行活性检查，避免它们在启动和运行前被<code class="fe le lf lg lh b">kubelet</code>杀死。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="1801" class="li lj it bd lk ll no ln lo lp np lr ls lt nq lv lw lx nr lz ma mb ns md me mf bi translated">Pod的最小就绪秒数</h1><p id="69e5" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b"><a class="ae kf" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds" rel="noopener ugc nofollow" target="_blank">.spec.minReadySeconds</a></code>是一个可选字段，它指定了一个新创建的Pod在没有任何容器崩溃的情况下被读取的最小秒数，这样它才被认为是可用的。默认为<code class="fe le lf lg lh b">0</code>(Pod一准备好就被认为是可用的)。</p><p id="395e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦一个Pod的容器被启动，如果它通过了<code class="fe le lf lg lh b">readinessProbe</code>(如果它通过了)，它就不会被认为是准备好了(接受流量)。然后，当Pod的所有容器都准备好时，就认为Pod准备好了。但是，如果为Pod定义了<code class="fe le lf lg lh b"><a class="ae kf" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds" rel="noopener ugc nofollow" target="_blank">.spec.minReadySeconds</a></code>设置，那么直到Pod经过了<code class="fe le lf lg lh b">.spec.minReadySeconds</code>定义的秒而没有任何容器崩溃，它才仍然被认为是就绪的。</p><p id="3df0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">这里有一些相关的有趣故事，你可能会觉得有帮助:</strong></p><ul class=""><li id="9cc1" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><a class="ae kf" href="https://medium.com/@goyalmunish/lets-make-kubernetes-cli-easier-5ba7f9c0509a" rel="noopener">让我们让Kubernetes CLI ( </a> <code class="fe le lf lg lh b"><a class="ae kf" href="https://medium.com/@goyalmunish/lets-make-kubernetes-cli-easier-5ba7f9c0509a" rel="noopener">kubectl</a></code> <a class="ae kf" href="https://medium.com/@goyalmunish/lets-make-kubernetes-cli-easier-5ba7f9c0509a" rel="noopener">)变得更简单</a></li><li id="0665" class="ml mm it ki b kj nt kn nu kr nv kv nw kz nx ld mq mr ms mt bi translated"><a class="ae kf" href="https://medium.com/@goyalmunish/passing-host-vs-container-environment-variables-to-docker-exec-5c1b18e6de8e" rel="noopener">docker exec命令中的主机与容器环境变量</a></li><li id="5d04" class="ml mm it ki b kj nt kn nu kr nv kv nw kz nx ld mq mr ms mt bi translated"><a class="ae kf" href="https://medium.com/@goyalmunish/docker-simplified-ad1f8a7350bf" rel="noopener"> Docker简体！</a></li><li id="3ed7" class="ml mm it ki b kj nt kn nu kr nv kv nw kz nx ld mq mr ms mt bi translated"><a class="ae kf" href="https://medium.com/@goyalmunish/kubernetes-simplified-300fef5fb0e6" rel="noopener"> Kubernetes简体！</a></li></ul></div></div>    
</body>
</html>