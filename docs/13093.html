<html>
<head>
<title>An Algorithm That Saved Biology and Shaped Modern Medicine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种拯救了生物学并塑造了现代医学的算法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-algorithm-that-saved-biology-shapes-modern-medicine-b242510949b8?source=collection_archive---------4-----------------------#2022-08-06">https://levelup.gitconnected.com/an-algorithm-that-saved-biology-shapes-modern-medicine-b242510949b8?source=collection_archive---------4-----------------------#2022-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f0c3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">发现模式是生物学研究的重要组成部分。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ffb2f1bf80fa7d16211c2cedc854b13b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vFlsXlD31C3bgxwk"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@flyd2069?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">飞:D </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="abf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论是在DNA、RNA或蛋白质中的一串氨基酸中寻找重复模式，模式匹配的应用都可以在许多地方找到。</p><p id="bd8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们深潜吧！</p><h1 id="afdb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">人类的DNA</h1><p id="92bf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">细胞的遗传信息存在于细胞核中(也存在于线粒体中，但那是以后的事了)。</p><p id="e94c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些信息是以DNA(脱氧核糖核酸)的形式存在的，它被构造成染色体。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/6cd07c3b923f12766f8ea3fcf70cab24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U9iFQmLU2bsAtmeh"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">沃伦·乌莫在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人类DNA是一种聚合物，由称为核苷酸的单体形成的两条链组成。</p><p id="59bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种聚合物非常长，含有数百万个核苷酸。</p><p id="3508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些链相互缠绕，形成双螺旋结构。</p><p id="190f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每条链中有四种类型的核苷酸，它们是:</p><ul class=""><li id="d277" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">腺嘌呤(甲)</li><li id="90d0" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">胸腺嘧啶</li><li id="d69d" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">鸟嘌呤</li><li id="c636" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">胞嘧啶</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/60b411d4d8de5c6fc82ceceb40f58996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*txCa_Hqjm7YKR4ZV.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自维基百科(忽略图片的RNA部分)</figcaption></figure><h1 id="e87b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">开创性的研究</h1><p id="02d7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设我们的研究小组发现，如果一个人的DNA中存在核苷酸(基因)序列，就会导致早期心脏病发作。</p><p id="1e4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">电视上都在播，人们聚集在一起做DNA测试。</p><p id="54b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们对一个人的DNA进行测序，我们将得到一长串数百万个核苷酸。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="2170" class="nq lw it nl b gy nr ns l nt nu">ATCGATGCAAGGTCGATCGATGCGCGCTAGCGATCGGCATCGATCGAGTCGATCGATCGATCGA...</span></pre><p id="d8b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于人类来说，搜索我们感兴趣的序列是一项耗时且乏味的任务，因此我们需要一台计算机来帮助完成这项任务。</p><h1 id="c5d7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">程序员介入</h1><p id="2c33" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设我们的研究小组里有一个程序员。</p><p id="888c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要求他们编写一个算法，可以在我们的长串核苷酸中找到这种模式。</p><h1 id="e82b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">问题陈述</h1><p id="9d24" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个问题陈述被公式化，明确地提到我们需要我们的计算机做什么。</p><blockquote class="nv nw nx"><p id="9201" class="kz la ny lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated"><em class="it">给定两个字符串:</em></p><p id="30fe" class="kz la ny lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated"><em class="it">-DNA中所有核苷酸的字符串(</em> <code class="fe ni nj nk nl b"><em class="it">dna</em></code> <em class="it"> ) </em></p><p id="ecbe" class="kz la ny lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated"><em class="it"> -感兴趣基因的字符串(</em> <code class="fe ni nj nk nl b"><em class="it">gene</em></code> <em class="it"> ) </em></p><p id="98aa" class="kz la ny lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated"><em class="it">在</em> <code class="fe ni nj nk nl b"><em class="it">dna</em></code>中找到所有出现的 <code class="fe ni nj nk nl b"><em class="it">gene</em></code> <em class="it"/></p></blockquote><h1 id="60fe" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">天真的解决方案</h1><p id="6117" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">程序员开始用蛮力方法来解决这个问题。</p><h2 id="31f6" class="nq lw it bd lx oc od dn mb oe of dp mf li og oh mh lm oi oj mj lq ok ol ml om bi translated">步伐</h2><ul class=""><li id="fef6" class="mt mu it lb b lc mn lf mo li on lm oo lq op lu my mz na nb bi translated">我们将<code class="fe ni nj nk nl b">dna</code>的长度保存在<code class="fe ni nj nk nl b">dna_length</code>变量中，将<code class="fe ni nj nk nl b">gene</code>的长度保存在<code class="fe ni nj nk nl b">gene_length</code>变量中。</li><li id="d6d1" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">我们将<code class="fe ni nj nk nl b">pointer_1</code>设置为<code class="fe ni nj nk nl b">dna</code>字符串的开头，并使用<code class="fe ni nj nk nl b">for</code>循环递增，直到索引<code class="fe ni nj nk nl b">dna_length — gene_length + 1</code></li><li id="d6ea" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">我们将<code class="fe ni nj nk nl b">pointer_2</code>设置为<code class="fe ni nj nk nl b">gene</code>字符串的开头，并使用<code class="fe ni nj nk nl b">while</code>循环递增它</li><li id="e54c" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe ni nj nk nl b">if</code>语句检查两个指针索引处的核苷酸是否相等。</li><li id="d72a" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">如果是这种情况，<code class="fe ni nj nk nl b">pointer_2</code>递增，否则<code class="fe ni nj nk nl b">pointer_1</code>递增。</li><li id="4408" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">如果<code class="fe ni nj nk nl b">pointer_2</code>横跨<code class="fe ni nj nk nl b">gene</code>的整个长度，并且能够与最后一个核苷酸匹配，我们打印出已经找到匹配。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="2494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干得好！</p><p id="af00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这个算法有效率吗？</p><p id="544b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法运行于:</p><ul class=""><li id="06ff" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">时间复杂度为O ( <code class="fe ni nj nk nl b">gene_length * (dna_length — gene_length + 1)</code>)，因为我们在两个字符串中循环。</li><li id="3b6f" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">O(1) 的空间复杂度，因为我们没有创建任何新的中间数据结构供我们的算法使用。</li></ul><h1 id="bd6c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">一种有效的方法:Knuth–Pratt-Morris算法</h1><p id="6042" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Knuth-Pratt-Morris算法中的步骤<strong class="lb iu">！</strong></p><p id="4dce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据Wikipedia的定义，该算法通过观察当出现不匹配时，第一个字符串本身包含足够的信息来确定下一个匹配可以从哪里开始，从而绕过对先前匹配的字符的重新检查，来搜索一个字符串在另一个字符串中的出现。</p><p id="ac23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个搜索算法的时间复杂度是<em class="ny"> </em> <code class="fe ni nj nk nl b">O(dna_length + gene_length )</code>。</p><p id="0568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个搜索算法的空间复杂度是<strong class="lb iu"> <em class="ny"> </em> </strong> <code class="fe ni nj nk nl b">O(gene_length )</code>。</p><p id="5af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是算法是如何在线性时间内做到这一点的？</p><h2 id="6194" class="nq lw it bd lx oc od dn mb oe of dp mf li og oh mh lm oi oj mj lq ok ol ml om bi translated">神奇的成分</h2><p id="1cd6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了在线性时间内执行模式搜索，该算法执行一个步骤，其中对<code class="fe ni nj nk nl b">gene</code>字符串进行预处理，以构建包含最长固有前缀的中间数组，该前缀也是该字符串的固有后缀。</p><p id="2690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迷茫？让我们把事情弄清楚。</p><p id="7f0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例1 </strong></p><p id="fdd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们取一个<code class="fe ni nj nk nl b">gene</code>字符串，即<code class="fe ni nj nk nl b">ATGA</code></p><p id="ce74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该字符串的前缀为<code class="fe ni nj nk nl b">A</code>、<code class="fe ni nj nk nl b">AT</code>、<code class="fe ni nj nk nl b">ATG</code>、<code class="fe ni nj nk nl b">ATGA</code>。</p><p id="d885" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个字符串的后缀是<code class="fe ni nj nk nl b">A</code>、<code class="fe ni nj nk nl b">GA</code>、<code class="fe ni nj nk nl b">TGA</code>、<code class="fe ni nj nk nl b">ATGA</code>。</p><p id="498f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们考虑适当的前缀和后缀时，我们分别排除整个字符串的前缀和后缀。</p><p id="218f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这个字符串的正确前缀是<code class="fe ni nj nk nl b">A</code>、<code class="fe ni nj nk nl b">AT</code>、<code class="fe ni nj nk nl b">ATG</code>(不包括<code class="fe ni nj nk nl b">ATGA</code>)。</p><p id="b75f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个字符串合适的后缀是<code class="fe ni nj nk nl b">A</code>、<code class="fe ni nj nk nl b">GA</code>、<code class="fe ni nj nk nl b">TGA</code>(不包括<code class="fe ni nj nk nl b">ATGA</code>)。</p><p id="4fff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例二</strong></p><p id="8f4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们取另一个<code class="fe ni nj nk nl b">gene</code>字符串，即<code class="fe ni nj nk nl b">ATATAGTA</code>。</p><p id="c4f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个数组，它包含最长的前缀，也是字符串的后缀。</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="ba0e" class="nq lw it nl b gy nr ns l nt nu">|A|T|A|T|A|G|T|A|</span><span id="f428" class="nq lw it nl b gy os ns l nt nu">[0,0,1,2,3,0,0,1]</span></pre><p id="a86b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看子串，直到索引<code class="fe ni nj nk nl b">2</code>，即<code class="fe ni nj nk nl b">ATA</code></p><p id="cb7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的正确前缀是<code class="fe ni nj nk nl b">A</code>、<code class="fe ni nj nk nl b">AT</code></p><p id="39a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的专有后缀是<code class="fe ni nj nk nl b">A</code>、<code class="fe ni nj nk nl b">TA</code></p><p id="4ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最长的固有前缀也是该子串的固有后缀是<code class="fe ni nj nk nl b">A</code>。它的长度是<code class="fe ni nj nk nl b">1</code>。因此，我们将<code class="fe ni nj nk nl b">1</code>放在数组的这个索引处。</p><p id="196f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例3 </strong></p><p id="5faa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看子串，直到索引<code class="fe ni nj nk nl b">4</code>，即<code class="fe ni nj nk nl b">ATATA</code></p><p id="2893" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的正确前缀是<code class="fe ni nj nk nl b">A</code>、<code class="fe ni nj nk nl b">AT</code>、<code class="fe ni nj nk nl b">ATA</code>、<code class="fe ni nj nk nl b">ATAT</code></p><p id="5133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的适当后缀是<code class="fe ni nj nk nl b">A</code>、<code class="fe ni nj nk nl b">TA</code>、<code class="fe ni nj nk nl b">ATA</code>、<code class="fe ni nj nk nl b">TATA</code></p><p id="a7b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也是该子串的适当后缀的适当前缀是<code class="fe ni nj nk nl b">A</code>和<code class="fe ni nj nk nl b">ATA</code>。</p><p id="0ab7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中最长的<code class="fe ni nj nk nl b">ATA</code>的长度为<code class="fe ni nj nk nl b">3</code>。</p><p id="2c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将<code class="fe ni nj nk nl b">3</code>放在数组的这个索引处。</p><h2 id="9da4" class="nq lw it bd lx oc od dn mb oe of dp mf li og oh mh lm oi oj mj lq ok ol ml om bi translated">创建中间数组</h2><p id="358f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们写一个生成这个中间数组的函数。</p><p id="0dcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数使用两个指针<code class="fe ni nj nk nl b">i</code>和<code class="fe ni nj nk nl b">j</code>，分别位于索引<code class="fe ni nj nk nl b">1</code>和<code class="fe ni nj nk nl b">0</code>处。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="e534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数将返回中间数组，即<code class="fe ni nj nk nl b">[0,1,2,0,1,2,3,3]</code>。</p><h2 id="9e73" class="nq lw it bd lx oc od dn mb oe of dp mf li og oh mh lm oi oj mj lq ok ol ml om bi translated">在DNA中寻找我们感兴趣的基因</h2><p id="4b98" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为此，我们将使用两个指针。</p><p id="dd7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">i</code>是<code class="fe ni nj nk nl b">dna</code>字符串上的指针。</p><p id="b4cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">j</code>是<code class="fe ni nj nk nl b">gene</code>字符串上的指针。</p><p id="8f18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在搜索时，我们试图将基因中的每个核苷酸与DNA中的核苷酸进行匹配。</p><p id="416a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这将使我们像在天真的方法中一样遍历两个字符串。</p><p id="fdcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这种情况，我们使用中间数组来决定下一个要匹配的字符(避免匹配的字符)，即根据我们生成的中间数组<code class="fe ni nj nk nl b">arr</code>改变<code class="fe ni nj nk nl b">j</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="4a0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来试试吧！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="4a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将输出到:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="1366" class="nq lw it nl b gy nr ns l nt nu">Gene found at index 0<br/>Gene found at index 2<br/>Gene found at index 4<br/>Gene found at index 6<br/>Gene found at index 8<br/>Gene found at index 10<br/>Gene found at index 12<br/>Gene found at index 14</span></pre><p id="4ace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是Knuth-Pratt-Morris算法如何使事情变得简单并为生物学家节省时间！</p></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><h1 id="b2f3" class="lv lw it bd lx ly pa ma mb mc pb me mf jz pc ka mh kc pd kd mj kf pe kg ml mm bi translated"><strong class="ak">资源</strong></h1><div class="pf pg gp gr ph pi"><a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">克努特-莫里斯-普拉特算法-维基百科</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">在计算机科学中，Knuth-Morris-Pratt字符串搜索算法(或KMP算法)搜索一个…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">en.wikipedia.org</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw ks pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">用我自己的话说就是Knuth-Morris-Pratt算法</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">在过去的几天里，我一直在阅读Knuth-Morris-Pratt字符串搜索算法的各种解释…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">jakeboxer.com</p></div></div></div></a></div><div class="pf pg gp gr ph pi"><a href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">模式搜索的KMP算法</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">给定一个文本txt[0..n-1]和模式pat[0..m-1]，写一个函数search(char pat[]，char txt[])打印所有…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="pr l"><div class="px l pt pu pv pr pw ks pi"/></div></div></a></div></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="98cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ny">感谢您阅读本文！</em></p><p id="7189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ny">如果你是Python或编程的新手，可以看看我的新书《没有公牛**t学习Python指南<strong class="lb iu">’</strong><em class="ny">下面:</em></em></p><div class="pf pg gp gr ph pi"><a href="https://bamaniaashish.gumroad.com/l/python-book" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">学习Python的无牛指南</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">你是一个正在考虑学习编程却不知道从哪里开始的人吗？我有适合你的解决方案…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">bamaniaashish.gumroad.com</p></div></div><div class="pr l"><div class="py l pt pu pv pr pw ks pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a href="https://bamania-ashish.medium.com/membership" rel="noopener follow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">通过我的推荐链接加入Medium——Ashish Bama nia博士</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">阅读Ashish Bamania博士(以及Medium上成千上万的其他作家)的每一个故事。您的会员费直接…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">bamania-ashish.medium.com</p></div></div><div class="pr l"><div class="pz l pt pu pv pr pw ks pi"/></div></div></a></div></div></div>    
</body>
</html>