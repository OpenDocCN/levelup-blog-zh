# 记录最佳实践— MDC、摄取和扩展

> 原文：<https://levelup.gitconnected.com/logging-best-practices-mdc-ingestion-and-scale-78319cee7b96>

![](img/319d5c9d84e17b1fe9bb1a46265e2ac6.png)

我不关心关于“哪个伐木工最好”的宗教战争。他们都有自己的问题。话虽如此，最差的伐木工可能是“内部”建造的…所以，是的，他们很烂，但重新发明轮子可能更糟糕。

让我们讨论如何通过从显而易见到微妙的正确使用准则来减少这些记录器的使用。希望您可以将这篇文章作为您公司记录最佳实践标准的基础。

请注意，虽然这主要是围绕 Java/JVM 日志，但是这里讨论的许多主题应该具有普遍的吸引力。

# 为什么伐木很难？

通常，它只是将数据打印到控制台/文件。看似琐碎。一些我们双手被绑在背后也能在 20 分钟内写出来的东西。

对于一个简单的记录器来说，可能就是这样。但是现代的伐木工支持机器可读的格式，MDC 和 get 摄取。我们可以使用许多常见的日志处理解决方案在一个位置搜索集群中多台机器的日志。当您试图分析规模问题时，开发期间决定的细微细节会产生巨大的影响。

第二个问题是性能。大多数典型的、高度调优的 web 应用程序大约有 95%的请求会命中缓存。这意味着 IO 非常少，性能非常高。但是，日志记录需要 IO，尤其是在摄取的情况下。这意味着在某些边缘情况下，日志记录的成本可能是系统最大的性能负担。

# 说真的，不要推出你自己的

一些开发人员仍然选择围绕现有的日志库推出他们自己的日志框架或包装器。拥有抽象是有意义的，但是抽象带来了一系列的问题。

自己卷是多余的。这牵涉到许多复杂的问题。无论你修复或挽救什么，都可能会反过来伤害你。正如我们最近在 Log4J 安全漏洞中看到的，一直到细微的性能缺陷和摄取预期的复杂自定义输出。发生了很多事。

# 编码最佳实践

在这一节中，我们将关注与在源代码中写日志相关的技巧。作为编码者和评审者，我们应该做什么和不应该做什么。每个提示都有解释。请记住，每条“规则”都有例外。我们不会把这些放在石头上…

# 保持日志消息简短

冗长的消息代价很大。成本在阅读时间。另一个代价是随着时间的推移摄入，他们并不总是告知超过一个简明的信息。

# 日志必须 100%唯一

系统中的每个日志行必须 100%唯一！

我们可以通过搜索系统中的字符串来验证日志消息不会重复，从而轻松实现这一点。

# 不要在循环中使用 Log 语句

这应该是显而易见的，但以防万一。在一个循环中记录日志，即使是在一个没有被打印的级别…也是一个性能问题。可能的话尽量避免。

假设您想要在默认情况下不可见的级别记录一些东西，并选择打破这个规则。只要保证简短就好。它不应该打破其他规则，尤其是下面的规则。

# 记录你已经“拥有”的东西

不要这样做:

```
logger.info("Reached X and value of method is {}", method());
```

即使这种方法很便宜。不管各自的日志记录级别如何，您都在有效地运行该方法！

如果必须在不同日志级别的情况下这样做，请使用 If 语句来防止代码每次都执行:

```
if(LOGGER.getLevel() == Level.DEBUG) {
       ...
}
```

要记录的正确的东西是你已经作为变量的东西。

# 不要记录列表或数组

哪怕是一个小单子。令人担忧的是，列表可能会增长并“过度拥挤”日志。将列表内容写入日志会使列表膨胀，并显著降低处理速度。

# 不要连接字符串

不要使用字符串连接进行日志记录，例如:

```
LOGGER.info("This is the variable: " + var);
```

相反，使用这个或由各种流行的日志框架提供的等效物:

```
LOGGER.info("This is the variable: {}", var);
```

如果日志由于日志级别而被吞噬，前者仍必须执行字符串串联，并将产生垃圾。后者将会消失。但是，请注意，至少在当前的 JVM 中，前者更快，所以这可能会产生误导。这是新版本 Java 正在解决的问题。

# 记录器字段必须始终是私有、静态和最终的

当声明一个类的日志字段时，它有时被公开，有时被声明为一个实例变量。这些事情可能会导致未来的错误。尤其是在重构的情况下。

# 通过示例清楚地定义日志记录级别

在您的指南中，准确定义将哪个日志记录级别分配给哪个代码类型。就个人而言，我倾向于将我们限制在四个级别，即使日志框架支持更多。我发现四个层次涵盖了我们需要的一切:

*   错误——这些是异常，某些东西失败了
*   警告—有一个故障，但并不严重
*   信息—发生了一些有趣的事情，我希望在我的应用程序中正常看到这些
*   调试—这可能是多余的。但是如果我们有一个问题，它可能是有趣的

# 不要记录框架为您记录的内容

有很多值得记录的事情。例如当前线程的名称、时间等。但是默认情况下，几乎所有地方都已经将这些内容写入了日志。不要重复这些努力。

# 不记录方法进入/退出

仅记录系统中的重要事件。进入或退出一个方法不是一个重要的事件。例如，如果我有一个启用特性 X 的方法，日志应该是“启用特性 X”而不是“启用特性 X 输入”。

# 不要填充方法

一个复杂的方法可能包含多个失败点，所以我们将日志放在方法的多个点上是有意义的，这样我们就可以在过程中检测到失败。不幸的是，这导致了重复的日志记录和冗长。

错误通常会映射到错误处理代码，这些代码通常应该被记录。因此，应该已经涵盖了所有错误条件。

这造成了我们有时需要改变代码的流程/行为的情况，因此日志记录会更优雅。例如:不要这样做:

```
if(x) {
    LOGGER.info(...);
    return value;
}if(y) {
    LOGGER.info(...);
    return otherValue;
} else {
    LOGGER.info(...);
    return thirdOption;
}
```

相反，更改代码以产生一个返回值:

```
Object value = computeValue();
LOGGER.info(...);
return value;
```

我们可以通过将方法中的代码重构为另一个方法来轻松实现这一点。

# 方法返回值通常很重要

如果在方法中有一个日志，并且没有包含方法的返回值，那么您就错过了重要的信息。努力把它包括进来，代价是代码看起来不那么优雅。

# 不要使用 AOP 日志记录

AOP 日志让我们在入口点注入日志。例如，您可以将 Spring 应用程序中的日志注入到系统中的每个方法入口/出口。这听起来可能很有趣，因为您可以对每个调用和每个返回值进行“完美”的跟踪。

不幸的是，性能和冗长使得调试更加困难。这只有在本地运行时才有用，在这种情况下，我们有更好的工具可以使用。

一些开发人员在 CI 过程中为测试运行启用此功能。起初，这听起来是个好主意，但是它让跟踪测试失败变得更加困难。

# 安全性

有许多重要的事情我们需要牢记在心。

# 不要记录未经整理的用户数据

当用户提交信息时，在我们对其进行基本的卫生处理之前，我们不能记录它。这是 Log4J 问题的核心。如果您记录“原始”用户输入，大多数复杂的 linters 会无缝地检测到这一点，并产生一个安全警告。我建议也使用这样的棉绒。

# PII 还原

良好的日志记录框架支持无缝删除个人身份信息(PII)。这对于遵守法律法规非常重要，例如 GDPR。理解这一功能并对其进行调优至关重要。否则，您可能会被日志中可能危及您安全的信息所困扰。

例如，组织中的大多数工程师都可以访问日志。但很少有人能接触到用户的信用卡信息或社会保障。如果你错误地登录了一张卡，你就有效地禁用了安全性。

# 志向；抱负

这些是我们需要追求的“模糊”目标。它们有道理，但不具体。

# 不要测试日志

日志是实现细节。它们是易碎的。集成测试有时依赖于日志。这是导致灾难的原因。

# 不要重复日志

当我们要抛出一个错误时，记录一个错误是很常见的。然而，由于大多数错误代码都是通用的，所以在通用错误处理代码中很可能有一个日志。

# 查看日志文件

当查看应用程序日志时，许多事情变得清晰了。日志、缺失信息和重复信息之间的微小不一致。在大多数公司中，R&D 编写日志代码，但 SRE/DevOps 等读取输出。

这是一个有问题的情况。开发人员必须在产品中狗粮他们的日志代码，在那里它看起来不同于本地执行。

# 少记录，稍后注入

诸如 [Lightrun](https://lightrun.com/) 之类的工具允许您将日志动态地注入到生产中(除了其他事情之外……)。不要摄入你可能永远都不需要的东西，而是按需摄入。

# 不要混淆日志和操作日志

在企业系统中，我们有两个非常独立的元素，称为日志。我们在这里讨论的是标准文件/接收日志，还有一个我们通常讨论日志事件的地方。通常驻留在数据库表中，为用户操作提供审计跟踪。

这是一个非常重要的特性，除了命名之外，它通常与日志记录完全无关。

# 将应用程序日志视为一种注释形式

日志是对其周围代码的一种注释形式，作为一种辅助功能，它应该有助于代码的可读性。以这种方式思考它们有助于生成更好、更干净和更一致的日志。

# MDC 指南

映射诊断上下文(MDC)对于现代日志记录至关重要。避免它类似于在调试器上禁用堆栈跟踪。MDC 为每个条目添加一个日志上下文映射。我们可以看到与特定日志行相关的用户 ID 或与之相关的支付交易 ID。这对于将事情放在背景中以及缩小问题范围非常有用。如果一个特定的用户报告了一个问题，那么只检查与该用户相关的日志的能力是非常宝贵的！

通常，人们会在事务开始时设置 MDC 中的值，并在事务结束时重置它们。

# 不要拥挤映射的诊断上下文

在 MDC 中，我们可以跟踪许多事情。添加用户名而不仅仅是用户 ID 的诱惑很大。但这是多余的，重复的。只保留最少的内容，让你了解请求的背景。常见的有价值的 MDC 价值包括:

*   请求 URI
*   用户标识
*   请求主机
*   交易 ID

# 在一个类中处理所有事情

应用程序代码中有单独的区域，值应该放入映射的诊断上下文中。然而，总共没有多少值。例如，一旦用户被认证，就应该添加用户 ID 上下文。事务 ID 只有在用户经过身份验证时才有意义。

一个简单的解决方案是创建一个 MDC 实用程序类，它将执行实际的 put 操作。这种方法的价值在于封装了 MDC 逻辑。这有助于我们跟踪所有的部分，以防我们需要删除或更新某些东西。

# 针对故障的计划—例如，自定义线程池

大多数 JVM web 应用程序使用线程池，MDC 使用 Java 中的线程上下文。请注意，在 Java (WebFlux)和 Node 等中还有其他的异步 API 选项。

但是最常见的默认情况是使用线程上下文。对于线程池，这意味着如果我们在完成请求后不调用 clean()，当前请求的上下文可能会隐式地成为未来请求的一部分。这通常很容易，除了应用程序出错的情况。在这种情况下，事情可能会很棘手。

一个常见的技巧是使用一个定制的线程池，当一个线程返回线程池时，这个线程池会清理 MDC。

# 配置

使用“现成”解决方案的一个好处是，我们只需调整配置文件就可以达到深度和广度。

# 使用 JSON 或其他机器可读的结构化格式

这对于正确的摄取非常有帮助，你应该用你的整个后端来调整它。

# 考虑异步日志记录的好处

异步日志记录性能更高，但也有风险。如果性能/吞吐量是主要考虑因素，这可能是一个有效的选项。

# 将日志级别设置为默认显示警告

包含信息级别的日志会导致多余的开销。这对大多数生产系统来说可能很高，但好处通常也很大。暂存应该将信息作为默认值。

# 测试中不要记录太多不同

在测试中增加日志记录是一种常见的做法。随着成本的变化，这是合理的，我们希望更快地看到失败的原因。然而，测试还检查我们是否有合适数量的日志来解决生产中的问题。

如果我们需要更高的日志级别来解决测试用例失败，这可能意味着我们的日志记录是不够的。

# 摘要

我希望这篇文章将有助于澄清你对这个问题的想法，并整理这些想法。在我们的日常编码中，有许多细微的日志实践可以改进。

我认为我们可以把核心思想概括为:

*   简洁明了
*   保持一致
*   不要搞砸性能
*   不要过度记录
*   注意隐私和安全风险

我希望你发现这是有用的，并可以在此基础上。