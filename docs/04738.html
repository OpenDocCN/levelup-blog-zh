<html>
<head>
<title>Bayesian Pairs Trading using Corporate Supply Chain Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用企业供应链数据的贝叶斯对交易</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/bayesian-pairs-trading-using-corporate-supply-chain-data-8b96305686d?source=collection_archive---------7-----------------------#2020-07-12">https://levelup.gitconnected.com/bayesian-pairs-trading-using-corporate-supply-chain-data-8b96305686d?source=collection_archive---------7-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9433" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使投资者能够为给定的企业供应链构建套期保值和统计套利策略。</h2></div><h1 id="9236" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">介绍</h1><p id="61da" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">配对交易是统计套利的经典方法，有着悠久的历史。确定配对交易的传统方法是通过frequentist统计协整检验，如Engle-Granger两步检验。</p><p id="d8fb" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在这里，我们提出了一个更复杂的贝叶斯方法来使用概率规划进行配对交易，这是贝叶斯机器学习的一种形式。与更简单的frequentist协整检验不同，我们的贝叶斯方法允许我们随着时间的推移监控一对股票之间的关系，这允许我们跟踪协整参数稳定或突然变化的股票对。当结合一个简单的均值回归交易算法，我们证明这是一个可行的理论交易策略，为进一步的评估和风险管理做好准备。</p><p id="d67f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">优秀配对交易候选人的一个潜在来源是企业供应链。找到一家公司的实际供应商和客户往往非常困难。许多公司不想向他们的竞争对手透露这些信息。利用混合数据源来提供公司供应链生态系统的完整画面，<a class="ae mb" href="https://rapidapi.com/alphawave/api/corporate-supply-chain/endpoints" rel="noopener ugc nofollow" target="_blank"> AlphaWave Data公司供应链API </a>使投资者能够为给定的公司供应链构建对冲和建立统计套利策略。详细描述这一分析的Jupyter笔记本也可以在<a class="ae mb" href="https://colab.research.google.com/drive/1e_SiiZn7WEW3OUNG-ftN3riPNjiz0M0C?usp=sharing" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>和<a class="ae mb" href="https://github.com/AlphaWaveData/Jupyter-Notebooks/blob/master/AlphaWave%20Corporate%20Supply%20Chain%20API%20Example.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><h1 id="3cf2" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">软件</h1><p id="e1af" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于这个项目，我们使用了几种基于Python的科学计算技术，并使用了股票回溯测试引擎以及<a class="ae mb" href="https://rapidapi.com/alphawave/api/corporate-supply-chain/endpoints" rel="noopener ugc nofollow" target="_blank"> AlphaWave数据公司供应链API </a>。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="1cba" class="ml kj it mh b gy mm mn l mo mp">import json<br/>import requests<br/>import pymc3 as pm<br/>import numpy as np<br/>import pandas as pd<br/>import theano as th<br/>import seaborn as sns<br/>import sklearn.decomposition<br/>import matplotlib.pyplot as plt<br/>%matplotlib notebook<br/>sns.set()</span><span id="0e06" class="ml kj it mh b gy mq mn l mo mp">import warnings<br/>warnings.filterwarnings('ignore')</span></pre><h1 id="8795" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">配对交易的股票选择</h1><p id="82ab" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因为我们的目标是建立一个pairs交易算法，一个共同整合股票的潜在来源是公司供应链。使用<a class="ae mb" href="https://rapidapi.com/alphawave/api/corporate-supply-chain/endpoints" rel="noopener ugc nofollow" target="_blank"> AlphaWave数据公司供应链API </a>，我们可以获得给定股票代码的供应商和客户列表。要用Python调用这个API，可以选择API控制台中提供的一个受支持的Python代码片段。下面是一个如何用Python请求调用API的例子。您需要在下面的代码块中插入您自己的<strong class="lc iu"> x-rapidapi-host </strong>和<strong class="lc iu"> x-rapidapi-key </strong>信息。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="c85d" class="ml kj it mh b gy mm mn l mo mp">url = "<a class="ae mb" href="https://corporate-supply-chain.p.rapidapi.com/api/v1/resources/supplychain" rel="noopener ugc nofollow" target="_blank">https://corporate-supply-chain.p.rapidapi.com/api/v1/resources/supplychain</a>"</span><span id="891d" class="ml kj it mh b gy mq mn l mo mp">querystring = {"ticker":"IBM"}</span><span id="586b" class="ml kj it mh b gy mq mn l mo mp">headers = {<br/>    'x-rapidapi-host': "YOUR_X-RAPIDAPI-HOST_WILL_COPY_DIRECTLY_FROM_RAPIDAPI_PYTHON_CODE_SNIPPETS",<br/>    'x-rapidapi-key': "YOUR_X-RAPIDAPI-KEY_WILL_COPY_DIRECTLY_FROM_RAPIDAPI_PYTHON_CODE_SNIPPETS"<br/>    }</span><span id="9a49" class="ml kj it mh b gy mq mn l mo mp">response = requests.request("GET", url, headers=headers, params=querystring)</span><span id="3e88" class="ml kj it mh b gy mq mn l mo mp">print(response.text)</span></pre><p id="105c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">输出:</p><figure class="mc md me mf gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/548371ff06f01f2949f2d72c27d45c03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jW3YzLAfKp6NL7UA7bGUBA.png"/></div></div></figure><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="02a7" class="ml kj it mh b gy mm mn l mo mp"># Create DataFrame.  <br/>df = pd.DataFrame.from_dict(response.json())<br/>df</span></pre><p id="c189" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">输出:</p><figure class="mc md me mf gt ms gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/2b165ca12b585147805bf349d8492100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*-4aZm6gh0AG5koLiiMvmEQ.png"/></div></figure><p id="e40b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">就是这样！</p><p id="080d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">现在，对于给定的股票代码(本例中为IBM)，您在pandas数据框架中有了一个供应商和客户列表。如果您愿意，您可以使用基本面数据、技术指标或其他替代数据来源进一步筛选供应商和客户列表，以获得良好的配对交易候选列表。</p><p id="0df0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在这个例子中，我们将选择IBM的客户ABC来继续我们的pairs trading分析。</p><h1 id="4cb3" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">市场数据</h1><p id="a11e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了这次探索，我们从金融数据供应商<a class="ae mb" href="https://iexcloud.io/" rel="noopener ugc nofollow" target="_blank"> IEX云</a>获取了几年的每日收盘数据。您需要在下面代码块中的<strong class="lc iu"> YOUR_IEX_API_KEY_HERE </strong>占位符中插入您自己的IEX API密钥。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3b1b" class="ml kj it mh b gy mm mn l mo mp">IEX_API_Key = 'YOUR_IEX_API_KEY_HERE'</span><span id="494e" class="ml kj it mh b gy mq mn l mo mp">tickers = [ 'IBM', 'ABC', ]</span><span id="ecde" class="ml kj it mh b gy mq mn l mo mp">#Create an empty string called `ticker_string` that we'll add tickers and commas to<br/>ticker_string = ''</span><span id="004c" class="ml kj it mh b gy mq mn l mo mp">#Loop through every element of `tickers` and add them and a comma to ticker_string<br/>for ticker in tickers: <br/>    ticker_string += ticker <br/>    ticker_string += ',' <br/>    <br/>#Drop the last comma from `ticker_string`<br/>ticker_string = ticker_string[:-1]</span><span id="6557" class="ml kj it mh b gy mq mn l mo mp">#Create the endpoint and years strings<br/>endpoints = 'chart'<br/>years = '5'</span><span id="b65a" class="ml kj it mh b gy mq mn l mo mp">#Interpolate the endpoint strings into the HTTP_request string<br/>HTTP_request = f'<a class="ae mb" href="https://cloud.iexapis.com/stable/stock/market/batch?symbols={ticker_string}&amp;types={endpoints}&amp;range={years}y&amp;cache=true&amp;token={IEX_API_Key}'" rel="noopener ugc nofollow" target="_blank">https://cloud.iexapis.com/stable/stock/market/batch?symbols={ticker_string}&amp;types={endpoints}&amp;range={years}y&amp;cache=true&amp;token={IEX_API_Key}'</a></span><span id="dfc1" class="ml kj it mh b gy mq mn l mo mp">#Send the HTTP request to the IEX Cloud API and store the response in a pandas DataFrame<br/>stock_data = pd.read_json(HTTP_request)</span><span id="2e71" class="ml kj it mh b gy mq mn l mo mp">#Create an empty list that we will append pandas Series of stock price data into<br/>series_list = []</span><span id="24ea" class="ml kj it mh b gy mq mn l mo mp">#Loop through each of our tickers and parse a pandas Series of their closing prices over the last 5 years<br/>for ticker in tickers: <br/>    series_list.append(pd.DataFrame(stock_data[ticker]['chart'])['close'])</span><span id="bd9d" class="ml kj it mh b gy mq mn l mo mp">#Add in a column of dates<br/>series_list.append(pd.DataFrame(stock_data['IBM']['chart'])['date'])</span><span id="0ab9" class="ml kj it mh b gy mq mn l mo mp">#Copy the 'tickers' list from earlier in the script, and add a new element called 'Date'. <br/>#These elements will be the column names of our pandas DataFrame later on.<br/>column_names = tickers.copy()<br/>column_names.append('Date')</span><span id="3829" class="ml kj it mh b gy mq mn l mo mp">#Concatenate the pandas Series togehter into a single DataFrame<br/>stock_data = pd.concat(series_list, axis=1)</span><span id="1f19" class="ml kj it mh b gy mq mn l mo mp">#Name the columns of the DataFrame and set the 'Date' column as the index<br/>stock_data.columns = column_names<br/>stock_data.set_index('Date', inplace = True)</span><span id="3bcd" class="ml kj it mh b gy mq mn l mo mp">stock1_name, stock2_name = 'IBM','ABC'<br/>orig_data = stock_data.loc['2018-01-01':,]<br/>data = orig_data.diff().cumsum()<br/>data1 = data[stock1_name].ffill().fillna(0).values<br/>data2 = data[stock2_name].ffill().fillna(0).values</span><span id="0b7c" class="ml kj it mh b gy mq mn l mo mp">plt.figure(figsize = (18,8))<br/>ax = plt.gca()<br/>plt.title("Potentially Cointegrated Stocks")<br/>orig_data[stock1_name].plot(ax=ax,color=sns.color_palette()[1],linewidth=2)<br/>orig_data[stock2_name].plot(ax=ax,color=sns.color_palette()[2],linewidth=2)<br/>plt.ylabel("Price (USD)")<br/>plt.legend()<br/>plt.show()</span></pre><figure class="mc md me mf gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/450a1261109db30ac9a0c168d30b7321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLX9Ng0Dw0JUA8q9FPxOKw.png"/></div></div></figure><h1 id="3fe4" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">贝叶斯建模</h1><p id="76f7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们的股票贝叶斯模型不会固有地对两只股票的整合顺序做出假设。但是，作为一个简化的假设，我们将假设一对协整股票的某种线性组合本身是平稳的，并且是正态分布的。</p><p id="a93f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">使用PyMC3语法，我们得到以下模型描述:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="35ad" class="ml kj it mh b gy mm mn l mo mp">with pm.Model() as model:<br/>    <br/>    # inject external stock data<br/>    stock1 = th.shared(data1)<br/>    stock2 = th.shared(data2)<br/>    <br/>    # define our cointegration variables<br/>    beta_sigma = pm.Exponential('beta_sigma', 50.)<br/>    beta = pm.GaussianRandomWalk('beta', sd=beta_sigma,<br/>                                 shape=data1.shape[0])<br/>    <br/>    # with our assumptions, cointegration can be reframed as a regression problem<br/>    stock2_regression = beta * stock1</span><span id="59bd" class="ml kj it mh b gy mq mn l mo mp"># Assume prices are Normally distributed, the mean comes from the regression.<br/>    sd = pm.HalfNormal('sd', sd=.1)<br/>    likelihood = pm.Normal('y',<br/>                           mu=stock2_regression,<br/>                           sd=sd,<br/>                           observed=stock2)</span><span id="a6f2" class="ml kj it mh b gy mq mn l mo mp">with model:<br/>    stock1.set_value(data1)<br/>    stock2.set_value(data2)<br/>    trace = pm.sample(2000,tune=1000,cores=4)</span><span id="c1de" class="ml kj it mh b gy mq mn l mo mp">rolling_beta = trace[beta].T.mean(axis=1)</span><span id="f1ca" class="ml kj it mh b gy mq mn l mo mp">plt.figure(figsize = (18,8))<br/>ax = plt.gca()<br/>plt.title("Beta Distribution over Time")<br/>pd.Series(rolling_beta,index=orig_data.index).plot(ax=ax,color='r',zorder=1e6,linewidth=2)<br/>for orbit in trace[beta][:500]:<br/>    pd.Series(orbit,index=orig_data.index).plot(ax=ax,color=sns.color_palette()[0],alpha=0.05)<br/>plt.legend(['Beta Mean','Beta Orbit'])<br/>#plt.savefig("beta distrib.png")</span><span id="2436" class="ml kj it mh b gy mq mn l mo mp">plt.show()</span></pre><figure class="mc md me mf gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/3a6e58d664bae31642b1b097db029ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzCqHnljk26s7uYPDQkQhQ.png"/></div></div></figure><p id="e88d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">请注意，𝛽(两只股票之间的关系)似乎经常突然变化。</p><h1 id="560e" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">交易策略</h1><p id="605b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">知道两只股票可能是也可能不是协整的，并不能明确定义交易策略。为此，我们提出以下简单的均值回复式交易算法，它利用了假设的股票组合的均值回复行为。每当我们的投资组合回到均值时，我们就交易。当算法不交易时，我们动态地更新𝛽和它的其他参数，以适应可能变化的协整条件。一旦交易开始，我们被迫以固定的价格交易这两只股票，因此我们的𝛽在交易期间被锁定。该算法的具体实现如下:</p><p id="3863" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">定义一个“信号”，这应该意味着-如果𝛽保持相对静止，归零。</p><p id="86c5" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">定义一个“平滑信号”，一个“信号”的15天移动平均线。</p><p id="47fa" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如果我们不交易…</p><ul class=""><li id="a2c3" class="na nb it lc b ld lw lg lx lj nc ln nd lr ne lv nf ng nh ni bi translated">更新𝛽，这样它就不会在我们不交易的时候保持不变。</li><li id="54af" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">如果平滑信号高于零<em class="no">且</em>向下移动，做空我们的投资组合。</li><li id="9ab4" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">如果平滑后的信号低于零<em class="no">且</em>向上移动，做多我们的投资组合。</li></ul><p id="aa8e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如果我们做多交易…</p><ul class=""><li id="acfb" class="na nb it lc b ld lw lg lx lj nc ln nd lr ne lv nf ng nh ni bi translated">如果平滑后的信号低于它的起始值，就平仓；我们可能偏离了平均值。</li><li id="f77a" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">如果平滑信号上升穿过零线，我们就达到了平均值。结束交易。</li></ul><p id="79e0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如果我们做空交易…</p><ul class=""><li id="4378" class="na nb it lc b ld lw lg lx lj nc ln nd lr ne lv nf ng nh ni bi translated">如果平滑后的信号高于它的起始值，就平仓；我们可能偏离了平均值。</li><li id="a0c8" class="na nb it lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">如果平滑后的信号落在零线上，我们就达到了平均值。结束交易。</li></ul><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="3136" class="ml kj it mh b gy mm mn l mo mp">def getStrategyPortfolioWeights(rolling_beta,stock_name1,stock_name2,data,smoothing_window=15):</span><span id="20c6" class="ml kj it mh b gy mq mn l mo mp">data1 = data[stock_name1].ffill().fillna(0).values<br/>    data2 = data[stock_name2].ffill().fillna(0).values</span><span id="2381" class="ml kj it mh b gy mq mn l mo mp"># initial signal rebalance<br/>    fixed_beta = rolling_beta[smoothing_window]<br/>    signal = fixed_beta*data1 - data2<br/>    smoothed_signal = pd.Series(signal).rolling(smoothing_window).mean()<br/>    d_smoothed_signal = smoothed_signal.diff()<br/>    trading = "not"<br/>    trading_start = 0</span><span id="1a48" class="ml kj it mh b gy mq mn l mo mp">leverage = 0*data.copy()<br/>    for i in range(smoothing_window,data1.shape[0]):<br/>        leverage.iloc[i,:] = leverage.iloc[i-1,:]</span><span id="b714" class="ml kj it mh b gy mq mn l mo mp">if trading=="not":</span><span id="e9cb" class="ml kj it mh b gy mq mn l mo mp"># dynamically rebalance the signal when not trading<br/>            fixed_beta = rolling_beta[i]<br/>            signal = fixed_beta*data1 - data2<br/>            smoothed_signal = pd.Series(signal).rolling(smoothing_window).mean()<br/>            d_smoothed_signal = smoothed_signal.diff()</span><span id="b742" class="ml kj it mh b gy mq mn l mo mp">if smoothed_signal[i]&gt;0 and d_smoothed_signal[i]&lt;0:</span><span id="de09" class="ml kj it mh b gy mq mn l mo mp">leverage.iloc[i,0] = -fixed_beta / (abs(fixed_beta)+1)<br/>                leverage.iloc[i,1] = 1 / (abs(fixed_beta)+1)</span><span id="4287" class="ml kj it mh b gy mq mn l mo mp">trading = "short"<br/>                trading_start = smoothed_signal[i]</span><span id="836c" class="ml kj it mh b gy mq mn l mo mp">elif smoothed_signal[i]&lt;0 and d_smoothed_signal[i]&gt;0:</span><span id="a2e9" class="ml kj it mh b gy mq mn l mo mp">fixed_beta = rolling_beta[i]<br/>                leverage.iloc[i,0] = fixed_beta / (abs(fixed_beta)+1)<br/>                leverage.iloc[i,1] = -1 / (abs(fixed_beta)+1)</span><span id="b3ee" class="ml kj it mh b gy mq mn l mo mp">trading = "long"<br/>                trading_start = smoothed_signal[i]</span><span id="d60c" class="ml kj it mh b gy mq mn l mo mp">else:<br/>                leverage.iloc[i,0] = 0<br/>                leverage.iloc[i,1] = 0</span><span id="7047" class="ml kj it mh b gy mq mn l mo mp">elif trading=="long":</span><span id="f183" class="ml kj it mh b gy mq mn l mo mp"># a failed trade<br/>            if smoothed_signal[i] &lt; trading_start:<br/>                leverage.iloc[i,0] = 0<br/>                leverage.iloc[i,1] = 0<br/>                trading = "not"</span><span id="4b41" class="ml kj it mh b gy mq mn l mo mp"># a successful trade<br/>            if smoothed_signal[i]&gt;0:<br/>                leverage.iloc[i,0] = 0<br/>                leverage.iloc[i,1] = 0<br/>                trading = "not"</span><span id="1a1c" class="ml kj it mh b gy mq mn l mo mp">elif trading=="short":</span><span id="d147" class="ml kj it mh b gy mq mn l mo mp"># a failed trade<br/>            if smoothed_signal[i] &gt; trading_start:<br/>                leverage.iloc[i,0] = 0<br/>                leverage.iloc[i,1] = 0<br/>                trading = "not"</span><span id="6d87" class="ml kj it mh b gy mq mn l mo mp"># a successful trade<br/>            if smoothed_signal[i]&lt;0:<br/>                leverage.iloc[i,0] = 0<br/>                leverage.iloc[i,1] = 0<br/>                trading = "not"<br/>                <br/>    return leverage</span></pre><h1 id="c76f" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结果</h1><p id="99c0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">作为一种多空算法，人们期望这种算法在市场下跌时表现强劲。这里的回溯测试包括2018年底的市场下跌，2019年初随后的较小跌幅，以及2020年3月的冠状病毒抛售。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="c377" class="ml kj it mh b gy mm mn l mo mp">portfolioWeights = getStrategyPortfolioWeights(rolling_beta,stock1_name, stock2_name,data).fillna(0)</span><span id="cdbe" class="ml kj it mh b gy mq mn l mo mp">def backtest(pricingDF,leverageDF,start_cash):<br/>    """Backtests pricing based on some given set of leverage. Leverage works such that it happens "overnight",<br/>    so leverage for "today" is applied to yesterday's close price. This algo can handle NaNs in pricing data<br/>    before a stock exists, but ffill() should be used for NaNs that occur after the stock has existed, even<br/>    if that stock ceases to exist later."""<br/>    <br/>    pricing = pricingDF.values<br/>    leverage = leverageDF.values<br/>    <br/>    shares = np.zeros_like(pricing)<br/>    cash = np.zeros(pricing.shape[0])<br/>    cash[0] = start_cash<br/>    curr_price = np.zeros(pricing.shape[1])<br/>    curr_price_div = np.zeros(pricing.shape[1])<br/>    <br/>    for t in range(1,pricing.shape[0]):<br/>        <br/>        if np.any(leverage[t]!=leverage[t-1]):</span><span id="12b8" class="ml kj it mh b gy mq mn l mo mp"># handle non-existent stock values<br/>            curr_price[:] = pricing[t-1]     # you can multiply with this one<br/>            curr_price[np.isnan(curr_price)] = 0<br/>            trading_allowed = (curr_price!=0)<br/>            curr_price_div[:] = curr_price    # you can divide with this one<br/>            curr_price_div[~trading_allowed] = 1<br/>            <br/>            # determine new positions (warning: leverage to non-trading_allowed stocks is just lost)<br/>            portfolio_value = (shares[t-1]*curr_price).sum()+cash[t-1]<br/>            target_shares = trading_allowed * (portfolio_value*leverage[t]) // curr_price_div<br/>            <br/>            # rebalance<br/>            shares[t] = target_shares<br/>            cash[t] = cash[t-1] - ((shares[t]-shares[t-1])*curr_price).sum()<br/>            <br/>        else:<br/>            <br/>            # maintain positions<br/>            shares[t] = shares[t-1]<br/>            cash[t] = cash[t-1]<br/>    <br/>    returns = (shares*np.nan_to_num(pricing)).sum(axis=1)+cash<br/>    pct_returns = (returns-start_cash)/start_cash<br/>    return (<br/>        pd.DataFrame( shares, index=pricingDF.index, columns=pricingDF.columns ),<br/>        pd.Series( cash, index=pricingDF.index ),<br/>        pd.Series( pct_returns, index=pricingDF.index)<br/>    )</span><span id="d265" class="ml kj it mh b gy mq mn l mo mp">shares, cash, returns = backtest( orig_data, portfolioWeights, 1e6 )</span><span id="8c9b" class="ml kj it mh b gy mq mn l mo mp">plt.figure(figsize = (18,8))<br/>ax = plt.gca()<br/>plt.title("Return Profile of Algorithm")<br/>plt.ylabel("Percent Returns")<br/>returns.plot(ax=ax,linewidth=3)<br/>vals = ax.get_yticks()<br/>ax.set_yticklabels(['{:,.0%}'.format(x) for x in vals])<br/>plt.show()</span></pre><figure class="mc md me mf gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/29d80f2cfe44bdb10a71dd2e83a2a7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kGRTVtFCWVY-WnAPbpgDcw.png"/></div></div></figure><p id="21fd" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">正如我们可能希望的那样，在市场下跌中表现强劲。由于我们的投资组合只有两只股票，回报率有些过高。对于这个算法的最终版本，我们可能会交易100对或更多来减少波动。</p><h1 id="fc1f" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论和潜在的未来方向</h1><p id="5400" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用<a class="ae mb" href="https://rapidapi.com/alphawave/api/corporate-supply-chain/endpoints" rel="noopener ugc nofollow" target="_blank"> AlphaWave数据公司供应链API </a>来识别股票对，我们展示了一个健壮的原型，它将被内置到一个更复杂的股票对交易算法中。这种算法和方法有许多地方可以改进，包括扩大投资组合，为𝛽何时适合交易建立标准，在更多时期内进行回溯测试，使用简化假设较少的贝叶斯模型，以及调查股票之间潜在的非线性关系。这一节的剩余部分将介绍其中的每一项。</p><h2 id="85b7" class="ml kj it bd kk np nq dn ko nr ns dp ks lj nt nu ku ln nv nw kw lr nx ny ky nz bi translated">过滤β以丢弃“坏”对</h2><p id="b31f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这篇文章中，我们主要用𝛽来交易两只股票，不考虑𝛽's的行为。限制交易只发生在𝛽稳定的时候，可能有助于识别适合配对交易的股票，因为期望我们的算法在可以想象的所有可能的股票配对中完美无缺是不合理的。</p><h2 id="8845" class="ml kj it bd kk np nq dn ko nr ns dp ks lj nt nu ku ln nv nw kw lr nx ny ky nz bi translated">附加回溯测试</h2><p id="d9bc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">虽然目前的回溯测试很有希望，但该算法尚未经过各种配对和时间段的严格回溯测试。理想情况下，这项工作将大幅扩大规模，对其在更广泛的股票范围内的表现进行分析，将是朝着可以在市场上交易的算法版本迈出的一步。</p><p id="a03a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">对哪些股票最适合配对的更深入的分析也可以来自于计算大千世界中每一个可能配对的𝛽，例如罗素3000指数中的股票。这种关系是否显著应该从高性能股票对是否具有某种特殊的市场结构关系(例如:公司供应链、相同行业、类似产品等)来判断。)，以帮助避免过度拟合。</p><h2 id="013f" class="ml kj it bd kk np nq dn ko nr ns dp ks lj nt nu ku ln nv nw kw lr nx ny ky nz bi translated">模型简化假设</h2><p id="cc45" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在整个调查中，假设一对协整股票(𝑝)的线性组合变化很小，对分析来说不重要。人们可以想象，如果𝑝的波动很大，那么这个假设就是错误的。此外，还假设𝑝是静止的。人们可以设想这样一种情况，其中𝑝不是稳定的，但仍然是均值回复的，这样它的均值几乎是稳定的。在我们目前的分析中，这两只股票可能并不理想，但在𝑝.的不同统计模型中，它们可能看起来更有序</p><p id="87d7" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">放松对𝑝的简化假设可能会揭示我们可以成功进行配对交易的额外股票，因此在我们无法找到足够多具有理想𝛽属性的配对的情况下，这可能是一个富有成效的未来方向。</p><h2 id="3a61" class="ml kj it bd kk np nq dn ko nr ns dp ks lj nt nu ku ln nv nw kw lr nx ny ky nz bi translated">协整分组</h2><p id="382d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">与标准的frequentist协整检验不同，我们的贝叶斯模型很容易扩展到三个或更多的股票，而我们的模型几乎没有变化。</p><p id="b8b5" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">主要的变化是我们现在有了额外的𝛽变量。虽然还不清楚试图在更大的协整投资组合(三个或更多)上交易会有什么影响，但使用贝叶斯统计和概率规划来构建是完全可行的。</p><h2 id="4ff1" class="ml kj it bd kk np nq dn ko nr ns dp ks lj nt nu ku ln nv nw kw lr nx ny ky nz bi translated">深度贝叶斯分析</h2><p id="2afc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">到目前为止，假设是股票的一个<em class="no">线性</em>组合产生一些平稳(或低阶积分)分布𝑝.有些股票可能会有非线性关系。我们可以对股票应用贝叶斯神经网络来捕捉非线性关系，而不是假设简单的线性加权。如果我们从PyMC3和Theano转向Edgar和TensorFlow，这将变得完全可行。</p><p id="c5de" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> <em class="no">来自《走向数据科学》编辑的提示:</em> </strong> <em class="no">虽然我们允许独立作者根据我们的</em> <a class="ae mb" href="https://towardsdatascience.com/questions-96667b06af5" rel="noopener" target="_blank"> <em class="no">规则和指导方针</em> </a> <em class="no">发表文章，但我们并不认可每个作者的贡献。你不应该在没有寻求专业建议的情况下依赖一个作者的作品。详见我们的</em> <a class="ae mb" href="https://towardsdatascience.com/readers-terms-b5d780a700a4" rel="noopener" target="_blank"> <em class="no">读者术语</em> </a> <em class="no">。</em></p></div></div>    
</body>
</html>