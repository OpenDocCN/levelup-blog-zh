<html>
<head>
<title>JavaScript Function Construction (Part 5)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript函数构造(第5部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-function-construction-part-5-90733a0e6369?source=collection_archive---------20-----------------------#2020-04-19">https://levelup.gitconnected.com/javascript-function-construction-part-5-90733a0e6369?source=collection_archive---------20-----------------------#2020-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="faf7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在与IIFCs的反应中提取请求</h2></div><p id="9e58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/function-construction-whats-your-function-5a282b81fc62">第1部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/function-construction-part-2-f6a711075b11">第2部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-3-d673ff247541">第3部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-4-d532f0a5e4af">第4部分</a> | <strong class="kh ir">第5部分</strong> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-6-72cfd6b18a7c">第6部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-7-17c5661e6ea7">第7部分</a></p><p id="0006" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天是一个特殊的日子。</p><p id="f631" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，不完全是…但是今天基本上是一个月博客价值的顶点…有时候真的很特别。</p><p id="26b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天我想介绍如何使用JavaScript函数构造器向SQL数据库发出获取请求。</p><p id="20d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还想使用我写的关于JavaScript函数构造的前四篇博客中使用的同一个函数构造器框架来发出这些请求。</p><p id="4e6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还想通过React发出这些请求，在上一篇博客中，我们用<code class="fe lc ld le lf b">getTime.js</code> IIFC(立即调用函数构造函数)获得了一些经验。</p><p id="93ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着服务器、数据库和后端框架的建立，会有很多移动的部分，我将尽可能快地对此进行介绍。我想把重点放在重构我们的IIFC来处理前端的获取请求上，所以后端的工作超出了这篇博客的范围。</p><p id="0f05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许我会在未来的博客中建立一个后台和数据库，但现在，我会小心谨慎，暂缓行动。</p><p id="cf76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以让我们开始吧。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h2 id="f04e" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated">基本后端</h2><p id="7b9b" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我将使用Ruby On Rails作为我们的后端服务器，PostgreSQL作为我们的数据库，这两者都相对容易安装和运行。</p><p id="357f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我应该使用一个简单的JSON服务器来跳过所有的序言，但是我想证明我们的获取可以在任何为HTTP端点提供JSON API的后端上工作。</p><p id="fe0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还将使用<code class="fe lc ld le lf b">-- api</code>标志构建我们的Rails后端，这样我们就可以直接向位于HTTP端点的JSON API发出请求，我们可以通过端口3001访问它。</p><p id="8ed5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除此之外，我还将使用快速JSON API来序列化我们将提供给HTTP端点的数据，并使用JSON viewer chrome扩展来通过chrome清晰地查看数据。</p><p id="cc04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很大程度上意味着我将带着飘扬的旗帜去管理<code class="fe lc ld le lf b">rails new</code>:</p><p id="f2ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">rails new blog_example --api --postgresql</code></p><p id="7849" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想要从我们的数据库是一些基本的表格，以便有一些数据工作。如果你读过我的SQL JOINs博客文章，我们将使用来自美国和欧洲的人的相同的表，所以这可能看起来很熟悉。</p><p id="71c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还将使用ruby gem Faker为我们的数据库生成随机数据。</p><p id="cf6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用几个<code class="fe lc ld le lf b">rails g resource</code>命令来设置我们的表。</p><p id="c505" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不会说得太详细，但是我们的迁移是这样的:</p><p id="04ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml"> create_usas.rb: </em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="771d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml"> create_europes.rb: </em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="396f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的模式应该是这样的:</p><p id="54aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml"> schema.rb </em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ab21" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的种子应该是这样的:</p><p id="f21e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml"> seeds.rb: </em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="a611" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就可以运行<code class="fe lc ld le lf b">rails db:migrate</code>和<code class="fe lc ld le lf b">rails db:seed</code>让我们的数据库启动并运行。</p><p id="74d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您遇到错误并想从头开始重建整个数据库，那么<code class="fe lc ld le lf b">rails db:reset</code>也非常有用。</p><p id="1058" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在我们运行<code class="fe lc ld le lf b">rails s</code>之前，我们还需要做一些设置，让我们的HTTP端点将我们的数据库呈现为JSON对象，这就是快速JSON API发挥作用的地方。</p><p id="9cad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于演示的目的，我们不需要担心模型。我们没有在美国和欧洲表之间建立任何关系。我们只是想提供一个URL上的表。</p><p id="8b65" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要为一个表创建一个新的序列化器，我们可以<code class="fe lc ld le lf b">run rails g serializer &lt;table_name&gt;</code>，经过一些修改，最终应该是这样的:</p><p id="8efe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml"> usa_serializer.rb: </em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="698b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">欧洲_serializer.rb: </em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="aefb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的控制器应该是这样的:</p><p id="2174" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml"> usas_controller.rb: </em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f0c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml"> europes_controller.rb: </em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ea42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，我理解“美国”和“欧洲”奇怪的复数形式。这是一个活跃的记录。如果你不知道我在说什么，请注意这两个控制器是复数的。Ruby On Rail就是有点怪怪的。</p><p id="7309" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成所有设置后，我们终于可以运行<code class="fe lc ld le lf b"> rails s</code>，但是使用<code class="fe lc ld le lf b">-p</code>标记在端口3001上设置我们的服务器。这样我们就可以在端口3000上设置我们的React前端，向端口3001发出请求，并且知道无论我们重启服务器多少次，它都将一直在端口3001上。</p><p id="4eef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您想在哪个端口上设置rails服务器由您决定，但是要确保它与React前端不在同一个端口上。事情不是这样的。</p><p id="d800" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们用<code class="fe lc ld le lf b">rails s -p 3001</code>启动我们的后端，我们可以在chrome中导航到<code class="fe lc ld le lf b">http://localhost:3001</code>，并看到Rails主页:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mt"><img src="../Images/6dd32abf78de7e41e9d86999c31bb700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RbSNFr8z3ThnlrxmGobusQ.jpeg"/></div></div></figure><p id="9587" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们分别导航到<code class="fe lc ld le lf b">http://localhost:3001/usas</code>和<code class="fe lc ld le lf b">http://localhost:3001/europes</code>，我们现在应该看到PostgreSQL数据库中的两个表作为JSON对象提供给两个HTTP端点:</p><p id="3bab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">美国表:</em></p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi na"><img src="../Images/9f475300b849d2aad3be5bfac1cd4a95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*TOAZpYlJBezRfsWRo4UkYQ.jpeg"/></div></div></figure><p id="83d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">欧洲表:</em></p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi na"><img src="../Images/9f475300b849d2aad3be5bfac1cd4a95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*TOAZpYlJBezRfsWRo4UkYQ.jpeg"/></div></div></figure><p id="d1f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于Faker随机生成我们插入数据库的数据，因此您的姓名、年龄和当前州/当前国家会有所不同。</p><p id="b235" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我在这里掩盖了Rails设置中的许多小细节，但这是我们希望我们的后端做的。</p><p id="215f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着我们的后端设置和SQL表作为JSON对象被发送到我们的HTTP端点，我们可以将注意力转向我们的React前端，并开始发出获取请求。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h2 id="8c2b" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated">从前到后</h2><p id="3dbd" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们需要做三件事:</p><p id="0aae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.)让React启动并运行</p><p id="5572" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.)重构<code class="fe lc ld le lf b">getTime.js</code></p><p id="24e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.)通过React从重构的IIFC发送获取请求</p><p id="99ca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从第一个开始，用<code class="fe lc ld le lf b">create-react-app</code>构建一个最基本的React应用程序。</p><p id="b181" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将抄近路，使用我在上一篇博客中使用的React应用程序。</p><p id="3840" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着在运行<code class="fe lc ld le lf b">create-react-app</code>之后，您需要做的唯一更改是在您的<code class="fe lc ld le lf b">./src</code>目录中添加一个名为<code class="fe lc ld le lf b">utility</code>的文件夹，并在其中创建一个名为<code class="fe lc ld le lf b">fetchFunctions.js</code>的新JavaScript文件:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/5b32e9f28f3396d4e8ddb3f9e173cad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*Og0tb3_WJ9YAruJfs-edHA.jpeg"/></div></figure><p id="d1f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要对<code class="fe lc ld le lf b">App.js</code>做一些小的重构。我们需要<code class="fe lc ld le lf b">App.js</code>成为一个类组件，我还将删除默认React主页上<code class="fe lc ld le lf b">&lt;p&gt;</code>标签中的<em class="ml">‘编辑src/App.js并保存以重新加载’</em>文本:</p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f0cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这两个变化，我们应该能够<code class="fe lc ld le lf b">run npm start</code>和，如果我们导航到<code class="fe lc ld le lf b">http://localhost:3000</code>，就会看到一个稍有修改的React主页:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nc"><img src="../Images/c2328f32e08d903d6a0dd5fe7c9e8ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ixf9u8saONSjksqllY8j_Q.jpeg"/></div></div></figure><p id="093d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太棒了。</p><p id="588b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把清单上的第一件事划掉，然后继续下一件事:</p><p id="c7c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重构<code class="fe lc ld le lf b">getTime.js</code></p><p id="ebfe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简洁起见，我将把<code class="fe lc ld le lf b">getTime.js</code>中的所有内容复制到<code class="fe lc ld le lf b">fetchFunctions.js</code>中，并去掉所有与时间有关的内容。我还需要更改我们正在定义的变量的名称空间，让<code class="fe lc ld le lf b">fetchFunctions.js</code>的框架看起来像这样:</p><p id="7b86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在fetchFunctions.js: </em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2c5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将遵循与处理<code class="fe lc ld le lf b">getTime.js</code>相同的公式将参数传递给<code class="fe lc ld le lf b">fetchFunctions.js</code>。我们将调用<code class="fe lc ld le lf b">fetchFunctions.prototype</code>对象中的方法，并向<code class="fe lc ld le lf b">localhost:3001</code>发送获取请求，然后返回我们想要的数据。我们还将向<code class="fe lc ld le lf b">fetchFunctions.js</code>发送几个额外的参数，以便从<code class="fe lc ld le lf b">App.js</code>中提取尽可能多的代码。</p><p id="b15d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们将注意力转回到<code class="fe lc ld le lf b">App.js</code>上，看看我们将向IIFC发送什么。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h2 id="8f28" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated">在两个脚本之间</h2><p id="9084" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们可以像处理<code class="fe lc ld le lf b">getTime.js</code>一样，从将<code class="fe lc ld le lf b">fetchFunctions.js</code>导入<code class="fe lc ld le lf b">App.js</code>开始。</p><p id="559a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lc ld le lf b">App.js</code>中:</p><pre class="mm mn mo mp gt nd lf ne nf aw ng bi"><span id="a529" class="ln lo iq lf b gy nh ni l nj nk">import fetchFunctions from ‘./utility/fetchFunctions’</span></pre><p id="cec2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不能测试任何东西，看看目前是否一切正常。<code class="fe lc ld le lf b">fetchFunctions.js</code>原型对象没有任何方法供我们测试。所以让我们在<code class="fe lc ld le lf b">fetchFunctions.js</code>中添加一个简单的测试函数，在<code class="fe lc ld le lf b">App.js</code>中的<code class="fe lc ld le lf b">componentDidMount()</code>中添加<code class="fe lc ld le lf b">console.log()</code>它。</p><p id="753b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在fetchFunctions.js中的原型:</em></p><pre class="mm mn mo mp gt nd lf ne nf aw ng bi"><span id="3148" class="ln lo iq lf b gy nh ni l nj nk">test: function() { return ‘This is only a test.’ }</span></pre><p id="d50b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在App.js: </em></p><pre class="mm mn mo mp gt nd lf ne nf aw ng bi"><span id="cc35" class="ln lo iq lf b gy nh ni l nj nk">componentDidMount(){ console.log(fetchFunctions(‘test’)) }</span></pre><p id="30d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在应该看到<em class="ml">‘这只是一个测试。’在chrome的控制台窗口中:</em></p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nl"><img src="../Images/d442c7b27ad5c8de6ee5c16d4dbb7c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJcPLOgCyAuHKH0Su_IFOA.jpeg"/></div></div></figure><p id="c7fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了。到目前为止一切顺利。</p><p id="40f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过，对于我们的获取请求，我们想要向<code class="fe lc ld le lf b">fetchFunctions.js</code>发送3个参数:方法的名称空间、方法将向其发送请求的URL，以及对于<code class="fe lc ld le lf b">POST</code>或<code class="fe lc ld le lf b">PATCH</code>方法，一个包含我们想要用来更新数据库的信息的对象。</p><p id="8e07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想发出一个<code class="fe lc ld le lf b">GET</code>请求，我们的调用应该是这样的:</p><pre class="mm mn mo mp gt nd lf ne nf aw ng bi"><span id="e718" class="ln lo iq lf b gy nh ni l nj nk">fetchFunctions(‘get‘, ‘http://localhost:3001/usas’)</span></pre><p id="539e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者对一个人来说:</p><pre class="mm mn mo mp gt nd lf ne nf aw ng bi"><span id="e730" class="ln lo iq lf b gy nh ni l nj nk">fetchFunctions(‘get‘, ‘http://localhost:3001/usas/1’)</span></pre><p id="0ddb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想发出一个POST请求，我们还想发送一个更新数据的对象:</p><pre class="mm mn mo mp gt nd lf ne nf aw ng bi"><span id="f899" class="ln lo iq lf b gy nh ni l nj nk">fetchFunctions(‘post‘, ‘http://localhost:3001/usas’, newPersonObj)</span></pre><p id="34e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者对于修补程序请求:</p><pre class="mm mn mo mp gt nd lf ne nf aw ng bi"><span id="03b7" class="ln lo iq lf b gy nh ni l nj nk">fetchFunctions(‘patch‘, ‘http://localhost:3001/usas/1’, updatedPersonObj)</span></pre><p id="ee07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是对于删除请求，我们只需要方法和URL:</p><pre class="mm mn mo mp gt nd lf ne nf aw ng bi"><span id="a943" class="ln lo iq lf b gy nh ni l nj nk">fetchFunctions(‘delete‘, ‘http://localhost:3001/usas/1’)</span></pre><p id="bf16" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想要这个公式工作，我们需要更新<code class="fe lc ld le lf b">fetchFunctions</code>变量和<code class="fe lc ld le lf b">fetchFuncions.init()</code>函数来接受一些新的参数。</p><p id="61c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在fetchFunctions.js: </em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="87f7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们将两个新参数传递给<code class="fe lc ld le lf b">fetchFunctions.init()</code>。我们向其发送请求的URL，以及(如果需要的话)一个包含我们希望用来更新数据库的新数据的对象。</p><p id="2d96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以调用<code class="fe lc ld le lf b">fetchFunctions.prototype</code>对象中的一个方法，同时还可以访问我们传递的两个额外参数，这取决于我们调用的是哪个方法。</p><p id="c7b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们只是想要网址，我们有。如果我们需要一个对象发送到数据库，我们有。</p><p id="199e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以为需要发送到后端的特定头定义另一个参数，但是对于本演示来说，这是不必要的。</p><p id="0d25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们现在可以向原型对象添加我们的第一个方法，简单的<code class="fe lc ld le lf b">GET</code>请求:</p><p id="1d80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在fetchFunctions.js中的原型:</em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="30c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的函数定义<code class="fe lc ld le lf b">get</code>接收我们从<code class="fe lc ld le lf b">App.js</code>传入的URL，并返回它从服务器得到的承诺。</p><p id="b730" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的关键点是我们返回服务器对请求的响应。服务器正在返回一个承诺，而不是一个对象或数组。如果我们不从服务器返回这个承诺，我们将无法将承诺发送回<code class="fe lc ld le lf b">App.js</code>，在那里我们可以将它转换成JSON并在我们的应用程序中使用它。</p><p id="b8ae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果我们在<code class="fe lc ld le lf b">get</code>方法中确实回报了承诺，我们可以接受那个回应，并对它做我们想做的任何事情。现在，让我们确保事情正常运行，并<code class="fe lc ld le lf b">console.log()</code>响应。</p><p id="3f5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在App.js中:</em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5076" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在chrome中查看控制台窗口:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nm"><img src="../Images/6fc47cd7d6915aa23af420d417b3f6b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1oCrK-9zjRo9Z6dDSQiQ-g.jpeg"/></div></div></figure><p id="38ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯……好吧……确实有效。</p><p id="6047" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们继续挖掘嵌套对象，我们会看到我们从USA表中获得所有数据:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/d71f190f98ba15c1ee76bf7fd89957b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*K7TfRe-sWetrwQdAxPq30Q.jpeg"/></div></figure><p id="4e94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从控制台的第2个条目中看到，获取请求来自<code class="fe lc ld le lf b">fetchFunctions.js</code>，具体来说是来自<code class="fe lc ld le lf b">fetchFunctions.init()</code>:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d500d6f5224b71f48c91311e284909ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*SmMCYJrNWFKCpclbNi5uRg.jpeg"/></div></figure><p id="4c89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这正是我们想要的。</p><p id="0aea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的问题是数据在响应中的嵌套有多深。这是一个来自Fast JSON API的问题，但这个问题很容易解决。</p><p id="079c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以很好地访问<code class="fe lc ld le lf b">res_obj.data</code>，但这是在我们点击<code class="fe lc ld le lf b">res_obj.data.attributes</code>时<code class="fe lc ld le lf b">undefined</code>返回的地方。没关系。我们所要做的就是映射数据对象以获得SQL表中的每一行。</p><p id="3d96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">in App.js:</code></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="79d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们让我们所有的人:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi np"><img src="../Images/2b0cf6832122998a2129ea71510c6a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b9h2pk68vgdPpsJMegr2WA.jpeg"/></div></div></figure><p id="7e88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太棒了。</p><p id="4469" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以对一个人使用相同的GET方法。我们所要做的就是将我们想要找到的人的ID添加到URL中，以及我们如何处理响应。</p><p id="5405" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在App.js中:</em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="e360" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在控制台中:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d39cbacb3e884fae6d27b9cadd884464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*wGYozdlXJmK4o_vt3E65sQ.jpeg"/></div></figure><p id="7f8b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太棒了。</p><p id="e72d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，用户标识可以通过状态、表单或登录来动态设置。我只是静态地设置它来演示我们可以像对待普通的获取请求一样对待<code class="fe lc ld le lf b">fetchFunctions.js</code>。</p><p id="a094" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以将得到的两个响应设置为state中的一个属性，并在<code class="fe lc ld le lf b">render()</code>函数中设置<code class="fe lc ld le lf b">console.log()</code> state来测试它。</p><p id="932b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在App.js中:</em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7ef3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在控制台中:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nr"><img src="../Images/dae984a3ab719685e4e994bcbf2e4a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9evrV3_fZ2W0gpJkqmBjA.jpeg"/></div></div></figure><p id="b622" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了。</p><p id="8e97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是发布请求呢？</p><p id="706f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">难道我们没有设置<code class="fe lc ld le lf b">fetchFunctions.js</code>接受第三个参数吗？</p><p id="b6aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在任何地方都不用它。我们从哪里得到这个东西的？</p><p id="a4ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">别害怕，我的朋友。</p><p id="819a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当向服务器发送一个<code class="fe lc ld le lf b">POST</code>或<code class="fe lc ld le lf b">PATCH</code>请求时，还需要在获取数据的同时发送想要更新数据库的数据。</p><p id="0227" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对我来说，这更像是一个功能选择，但我已经习惯了用我想发送给服务器的所有数据创建一个新对象，然后在函数调用中将其发送给<code class="fe lc ld le lf b">fetchFunctions.js</code>。</p><p id="9b2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以发送单独的数据片段，比如<code class="fe lc ld le lf b">this.state.person.first_name</code>或<code class="fe lc ld le lf b">this.state.person.age</code>等等，但是我喜欢将我想要发送的所有数据与<code class="fe lc ld le lf b">POST</code>或<code class="fe lc ld le lf b">PATCH</code>请求打包在一起，然后作为参数传递给<code class="fe lc ld le lf b">fetchFunctions.js</code>的想法。它让所有东西保持紧凑，并在一块。它还在整个过程之上增加了一层，以防我遇到某种错误。</p><p id="e61c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我在我们今天正在进行的演示中尝试这样做，它看起来会像这样:</p><p id="1f5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在App.js: </em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="e6c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的问题是，我们在<code class="fe lc ld le lf b">fetchFunctions.js</code>中没有处理<code class="fe lc ld le lf b">POST</code>请求的方法。</p><p id="8d53" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，我们写一个吧。它将以与我们的<code class="fe lc ld le lf b">GET</code>请求相同的方式开始，但是添加了所需的方法、头和主体。</p><p id="d71d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在fetchFunctions.js中的原型:</em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5412" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们只需将obj传入<code class="fe lc ld le lf b">JSON.stringify()</code>。这是在将信息传递给函数构造函数之前，对要发送给服务器的信息进行打包的好处之一。我们不必明确列出我们想要更新的每一行。我们可以用新信息创建一个对象，并将其传递给<code class="fe lc ld le lf b">fetchFunctions.js</code></p><p id="2101" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从这里，我们可以返回到<code class="fe lc ld le lf b">App.js</code>并处理从服务器返回的承诺。</p><p id="ba5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在App.js中</em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c752" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们保存<code class="fe lc ld le lf b">App.js</code>，React应该会在热加载后向数据库添加一个新的人员，我们应该会在控制台中看到记录的新信息:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ns"><img src="../Images/79b970034afabbca2d82a934626ef1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNHGJfwowflGjmcu4G0QwQ.jpeg"/></div></div></figure><p id="8058" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了确保它保存在我们的数据库中，让我们用<code class="fe lc ld le lf b">fetchFunctions(‘get’, ‘http://localhost:3001/usas’)</code>再次<code class="fe lc ld le lf b">GET</code>所有用户:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nt"><img src="../Images/0e9163f95a4cb50bbe56fbfd5c8de3e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_DrKjxhmcBNddYfx9bwrDQ.jpeg"/></div></div></figure><p id="e6c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太棒了。</p><p id="93f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您曾经使用过Axios来处理您的获取请求，事情可能会变得非常熟悉。</p><p id="d597" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要介意用户ID从10跳到14。在写这篇博客的时候，我不得不测试一些东西，这导致了用户id的跳过。</p><p id="082e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，<code class="fe lc ld le lf b">userObj</code>可以通过状态、表单或登录进行动态设置，就像您通常通过获取请求发送动态参数一样。出于演示的目的，我将它们设置为静态对象。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h2 id="5be9" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated">给我接通联合国</h2><p id="7cb6" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">一个<code class="fe lc ld le lf b">PATCH</code>请求以完全相同的方式运行。从技术上讲，我们可以结合使用<code class="fe lc ld le lf b">POST</code>和<code class="fe lc ld le lf b">PATCH</code>两种方法。但我认为把它们分开是明智的。在一个更大规模的应用程序中，你肯定会有4个以上的基本获取请求，所以让我们保持我们各自的RESTful方法独立。</p><p id="d4dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论哪种方式，我们都可以像编写<code class="fe lc ld le lf b">POST </code>请求一样编写<code class="fe lc ld le lf b">PATCH</code>请求:</p><p id="9dd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在fetchFunctions.js中的原型:</em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="8398" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的区别是我们从React传递给它的URL和obj:</p><p id="3467" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在App.js中:</em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7679" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在控制台中:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nu"><img src="../Images/6ca74759cd604ba307bcba76cd6bca78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MbjA81rXEi1hNnMgDkFx_g.jpeg"/></div></div></figure><p id="923d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们再次检查我们的<code class="fe lc ld le lf b">fetchFunctions(‘get’, ‘http://localhost:3001/usas’) </code>方法，以确保它是持久的:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nv"><img src="../Images/a2cb69607ccdabda45217fb8695bd6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aC0EkGCvdHmJsSvI9PGftg.jpeg"/></div></div></figure><p id="41b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">光荣。</p><p id="4f37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们有<code class="fe lc ld le lf b">DELETE</code>方法，这是所有方法中最简单的，可以遵循相同的公式。</p><p id="b27f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先我们将新函数添加到<code class="fe lc ld le lf b">fetchFunctions.prototype</code>对象中</p><p id="e5ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在fetchFunctions.js中的原型:</em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3d3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后用我们想要的用户的URL和插入的ID调用函数<code class="fe lc ld le lf b">DELETE</code></p><p id="0b88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在App.js </em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="07d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查是否有效:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nw"><img src="../Images/911d737d33c979a3a91198efdf7c1968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NTXm2NQRnVF8jG6Ci3Lujg.jpeg"/></div></div></figure><p id="228b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用我们的<code class="fe lc ld le lf b">fetchFunctions(‘get’, ‘<a class="ae lb" href="http://localhost:3001/usas'" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/usas'</a>)</code>方法再次检查，看看是否有效:</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nt"><img src="../Images/457f1fc2747c19d0140d03659ef51d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjPLgPlW5b3wTAihdyROAQ.jpeg"/></div></div></figure><p id="bdec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">惊人的。那全是垃圾。</p><p id="f384" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们最后看一下<code class="fe lc ld le lf b">fetchFunctions.js</code>和<code class="fe lc ld le lf b">App.js</code>，结束这篇博客:</p><p id="d210" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在App.js中</em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f844" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">在fetchFunctions.js中:</em></p><figure class="mm mn mo mp gt mq"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h2 id="f9b0" class="ln lo iq bd lp lq lr dn ls lt lu dp lv ko lw lx ly ks lz ma mb kw mc md me mf bi translated">任务完成</h2><p id="5dc5" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">从这里开始，世界就是你的了。</p><p id="0645" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将我们的用户数据呈现给不同的组件，从尽可能多的不同组件中调用<code class="fe lc ld le lf b">fetchFunctions.js</code>,添加带有各种头的特定获取请求，完全重构<code class="fe lc ld le lf b">fetchFunctions.js</code>以将方法链接到我们的调用中，从<code class="fe lc ld le lf b">fetchFunctions.js</code>中取出所有东西，并将其框架用于完全不同的目的……甚至尝试将我们的旧学校IIFC转换成ES6类……几乎任何你想做的事情。</p><p id="e02f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们开发的方式<code class="fe lc ld le lf b">fetchFunctions.js</code>允许我们写取请求而不必写取请求。它只编写一次，我们可以通过编写一个单行函数调用和几个参数来引用整个IIFC。我们所要做的就是传入不同的参数，然后<code class="fe lc ld le lf b">fetchFunctions.js</code>抽象出所有我们需要反复编写的代码。</p><p id="16a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管怎样，我希望这篇博客能帮助你了解JavaScript在函数式编程中的动态性。我不确定我的下一篇博客会写些什么，但是我想我已经在这个关于JavaScript函数构造的系列博客中有所建树了。</p><p id="06c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在写作和准备这些博客中学到了很多，我希望我也能教你一些新东西。</p><p id="81ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读。保持强壮和健康。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="7654" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh?hl=en-US" rel="noopener ugc nofollow" target="_blank"> JSON浏览器Chrome扩展</a></p><p id="c403" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://github.com/Netflix/fast_jsonapi" rel="noopener ugc nofollow" target="_blank">快速JSON API </a></p><p id="bac5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://github.com/faker-ruby/faker" rel="noopener ugc nofollow" target="_blank">骗子</a></p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><h1 id="a894" class="nx lo iq bd lp ny nz oa ls ob oc od lv jw oe jx ly jz of ka mb kc og kd me oh bi translated">JavaScript函数构造</h1><p id="b197" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/function-construction-whats-your-function-5a282b81fc62">第1部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/function-construction-part-2-f6a711075b11">第2部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-3-d673ff247541">第3部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-4-d532f0a5e4af">第4部分</a> | <strong class="kh ir">第5部分</strong> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-6-72cfd6b18a7c">第6部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-7-17c5661e6ea7">第7部分</a></p></div></div>    
</body>
</html>