<html>
<head>
<title>The „L“ in SOLID Software Architecture — Liskov Substitution Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">固体软件体系结构中的“L”——利斯科夫替代原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-l-in-solid-software-architecture-liskov-substitution-principle-54cc9abb67f9?source=collection_archive---------26-----------------------#2020-06-04">https://levelup.gitconnected.com/the-l-in-solid-software-architecture-liskov-substitution-principle-54cc9abb67f9?source=collection_archive---------26-----------------------#2020-06-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="52e9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">“L”代表Liskov替换原则，鼓励允许在不破坏事物的情况下用基类替换子类的架构。</h2></div><p id="42b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继承在软件架构中是一个强大的特性，尤其是在能够覆盖基类行为的情况下。如果你愿意，你可以扩展一个基本类并完全改变它的行为。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/a3b97135e1dfbcff6e123f12af9c9c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O_IKLN1SBGwhmnK-"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">遗产有点像俄罗斯洋娃娃(照片由<a class="ae lr" href="https://unsplash.com/@ilmatar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Iza Gawrych </a>拍摄)。</figcaption></figure><p id="1665" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就引出了什么时候应该真正使用继承的问题。为什么不用构图来代替呢？如何知道应该通过扩展已经存在的东西并修改其行为来实现一个新特性，还是选择一个完全不同的模式呢？</p><p id="11b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">芭芭拉·利斯科夫在<a class="ae lr" href="https://dl.acm.org/doi/10.1145/62139.62141" rel="noopener ugc nofollow" target="_blank">1987年的主题演讲</a>中回答了这个问题，后来<a class="ae lr" href="https://dl.acm.org/doi/10.1145/197320.197383" rel="noopener ugc nofollow" target="_blank">在1994年的另一篇论文</a>中正式提出了这个问题:</p><blockquote class="ls lt lu"><p id="b988" class="kf kg lv kh b ki kj jr kk kl km ju kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated">子类型要求<em class="iq">:设</em><strong class="kh ir"><em class="iq">【ϕ(x】</em></strong><em class="iq">为关于类型</em> <strong class="kh ir"> <em class="iq"> T </em> </strong> <em class="iq">的对象</em> <strong class="kh ir"> <em class="iq"> x </em> </strong> <em class="iq">的可证属性。那么</em><strong class="kh ir"><em class="iq">【ϕ(y】</em></strong><em class="iq">对于类型</em><strong class="kh ir"><em class="iq">s</em><strong class="kh ir"><em class="iq">s</em></strong><em class="iq">的对象</em><strong class="kh ir"><em class="iq">y</em></strong><em class="iq"><em class="iq">s</em><strong class="kh ir"><em class="iq">应该是</em><strong class="kh ir"><em class="iq"/></strong><em class="iq">的子类型。</em></strong></em></strong></p></blockquote><p id="bedb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种说法现在被称为“利斯科夫替代原理”，可以用稍微不太正式的措辞来表达:</p><p id="6333" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当使用基类<strong class="kh ir"> T </strong>时，人们应该能够将这个基类<strong class="kh ir"> T </strong>与任何子类<strong class="kh ir"> S </strong>(继承自<strong class="kh ir"> T </strong>)交换，并期望相同的行为<strong class="kh ir"> ϕ </strong>。</p><p id="d03f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们考虑一个简单的例子，我们想为一个给定的事件发送一封通知邮件。我们希望能够发送一封普通的电子邮件或一封包含关于订阅的附加信息的订阅用户的电子邮件。目前，我们总是发送普通电子邮件:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="8437" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，我们有一个<code class="fe mb mc md me b">EmailBroadcaster</code>和一个从前者继承而来的<code class="fe mb mc md me b">SubscriptionEmailBroadcaster</code>——他做的事情基本上是一样的，但更多一点，所以这需要继承，对吗？</p><p id="b49f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，假设现在我们想从使用基本的<code class="fe mb mc md me b">EmailBroadcaster</code>切换到新的<code class="fe mb mc md me b">SubscriptionEmailBroadcaster</code>。按照上面的逻辑，我们应该可以用<code class="fe mb mc md me b">SubscriptionEmailBroadcaster</code>替换旧的<code class="fe mb mc md me b">EmailBroadcaster</code>，因为它继承了它。它适用于父类，所以它也应该适用于子类。毕竟，“它做同样的事情，但更多一点”，对不对？</p><p id="757e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想改变它，你会发现它实际上不起作用，因为编译失败了。在<code class="fe mb mc md me b">onAccountCreated</code>中，我们将<code class="fe mb mc md me b">User</code>或<code class="fe mb mc md me b">SubscribedUser</code>(后者可能是前者的子类)传递给广播方法。但是，新的<code class="fe mb mc md me b">SubscriptionEmailBroadcaster</code>T13只有带一个<code class="fe mb mc md me b">SubscribedUser</code>。</p><p id="4bc6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过以这种方式建模我们的架构，我们打破了Liskov替换原则，更具体地说，是为了避免类似问题而应该满足的以下要求中的第一个:</p><p id="4bb5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 1。不要在子类中加强前置条件。</strong></p><p id="05e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">子类方法的参数类型应该匹配基类方法的参数类型，或者比基类方法的参数类型更抽象。</strong>在我们的例子中，<code class="fe mb mc md me b">SubscribedUser</code>是<code class="fe mb mc md me b">User</code>的一个子类型——因为我们需要一个更具体的(而不是抽象的)类型，所以我们加强了前置条件。</p><p id="3c1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在一个更简单的例子中，这个规则将被打破，在子类方法中只期望正数，而被重写的基类方法同时接受正数和负数。</p><p id="2cdb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">子类在接受什么方面应该总是更自由，而不是更严格。</p><p id="5f7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 2。不要弱化子类中的后置条件。</strong></p><p id="29c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">子类方法的返回类型应该匹配基类方法的返回类型或者是基类方法的返回类型的子类型。这也适用于异常:子类方法抛出的异常应该匹配或者是基类方法抛出的异常的子类型。这是为了避免引入依赖基类的代码无法捕捉的异常。</strong></p><p id="7171" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">子类应该总是更严格地返回或抛出什么，而不是更自由。</p><p id="7729" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，我们如何修正我们的例子呢？基本上有两种方法:反转我们的继承结构或者使用复合。</p><p id="e3d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个选项意味着<code class="fe mb mc md me b">SubscriptionEmailBroadcaster</code>成为基类而<code class="fe mb mc md me b">EmailBroadcaster</code>继承自它。人们可以将<code class="fe mb mc md me b">SubscriptionEmailBroadcaster</code>重命名为<code class="fe mb mc md me b">EmailBroadcaster</code>，将之前的<code class="fe mb mc md me b">EmailBroadcaster</code>重命名为<code class="fe mb mc md me b">AnonymousEmailBroadcaster</code>，以反映它不需要订阅:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a712" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当从<code class="fe mb mc md me b">EmailBroadcaster</code>开始时，我们现在可以毫无问题地把它换成<code class="fe mb mc md me b">AnonymousEmailBroadcaster</code>，因为它实际上反映了继承的行为——子类可以做它的基类可以做的任何事情(根据它的契约)。</p><p id="999c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用组合而不是继承的第二种选择可以通过使用独立广播公司遵循的一个接口来实现:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="4f7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，如果我们只是用<code class="fe mb mc md me b">SubscriptionEmailBroadcaster</code>替换<code class="fe mb mc md me b">AnonymousEmailBroadcaster</code>，编译器也会抱怨(因为构造函数不同)。然而，这并不是什么大问题，因为我们并不期望新类能够正常工作——毕竟，除了实现相同的接口之外，它与其他类没有任何关系。</p><p id="bb51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Liskov替换原则在理论上非常容易理解:只要确保你可以将你的基类替换为它们的子类，而不会遇到问题。</p><p id="13c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我个人觉得在实践中很难发现。我的猜测是，这是由于直觉地将“继承”一词解释为“修改使用共同的行为”。</p><p id="502d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更容易发现违规，我建议将“继承”解释为“扩展使用共同行为”。</p><p id="d7ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种方式，我们总是记住子类是建立在基类的行为之上的，并不试图改变最初的行为。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="1be3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章写起来特别有趣，因为它需要一些时间来按照<a class="ae lr" href="https://medium.com/@richartkeil/the-s-in-solid-5a6e0d778cbc" rel="noopener">单一责任</a>和<a class="ae lr" href="https://medium.com/@richartkeil/ccdb25bbecd2" rel="noopener">打开关闭原则</a>帖子的事件通知示例的思路提出一个合适的示例。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><p id="a2ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过在我的博客上注册<a class="ae lr" href="http://blog.richartkeil.com" rel="noopener ugc nofollow" target="_blank">来获得关于新帖子的电子邮件通知。</a></p></div></div>    
</body>
</html>