# 魔术师算法指南，第 5 部分:广度优先搜索

> 原文：<https://levelup.gitconnected.com/the-magicians-guide-to-algorithms-part-4-the-breadth-first-search-b800aec8ccf8>

![](img/0c89f060681c0144b49e98db65e9c616.png)

所以本周我们将讨论列表中最难的算法之一，或者说是咒语。这和最终铸造一个完全成形的守护神是一样的，所以当你破解了这个的时候要自豪。

**广度优先搜索**

所以广度优先搜索(bfs)这个咒语在我们理解它要遍历什么样的数据结构之前没有多大意义。这意味着我们需要了解一些关于树的知识。

树是一种数据结构，看起来像这样:

```
 6
                                  / \
                                 5   7
                                / \   \
                               3   4   9
                              /       / \
                             2       8   10
                            /
                           1
```

事实上，这就是所谓的二叉树。这意味着根节点，也就是 *6* ，以及其后的每个子节点最多只能有两个子节点，一边一个。此外，左侧的每个子节点的值必须小于其父节点的值，甚至右侧的节点的值也必须大于其父节点的值。

花点时间检查下面的代码。上面的树可以用一组对象来表示，如下所示:

```
var tree = [
    {value: 6, left: 1, right: 2},
    {value: 5, left: 3, right: 4},
    {value: 7, left: null, right: 5},
    {value: 3, left: 6, right: null},
    {value: 4, left: null, right: null},
    {value: 9, left: 7, right: 8},
    {value: 2, left: 9, right: null},
    {value: 8, left: null, right: null},
    {value: 10, left: null, right: null},
    {value: 1, left: null, right: null}
    ]
```

让我们来看看这个咒语:

bfs 咒语有两个参数。第一个是树，第二个是我们要寻找的值。为了开始滚动，我们将`tree[0]`处的节点推到`queue`——这是根节点。这就是所谓的“入队”

我们立即进入一个 while 循环，如果我们找到了正确的节点或者用完了队列中的节点，这个循环就会退出。

因此，对于队列中的每个节点，我们首先将它从数组中移出。这就是所谓的“出列”我们首先检查刚刚出队的节点的值是否等于我们正在搜索的值。如果是这样的话，我们不需要继续循环，只需要返回节点。

否则，我们检查是否有一个左节点和一个右节点，根据我们的发现将其中一个或两个节点添加到队列中。这里我们不需要 if/else 子句，因为我们总是需要检查两个条件。

如果我们到达了树的底部而没有找到正确的节点，一条消息将被记录到控制台，通知我们没有找到该节点。

现在你知道了。

**为什么要进行“广度优先”搜索？**

让我们快速回顾一下这个叫做广度优先搜索的东西。这种算法通过在下降到下一行之前读取树的同一行中的所有节点来遍历树，这使得它成为 Pince 夫人通过一次扫描每一层来查找书架上的书的有用咒语。

在上面的树中，如果我们想找到值为 1 的节点，它会这样读它们:6 5 7 3 4 9 2 8 10 1，然后返回。

BFS 算法有一个表亲，叫做 DFS 算法，或者我们将在下周讨论的深度优先搜索。

下次见。干杯！

点击查看上周关于选择排序的帖子[。](https://medium.com/gitconnected/the-magicians-guide-to-algorithms-part-4-the-selection-sort-454148f55c73)