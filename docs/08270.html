<html>
<head>
<title>Tip of the Day: Create a Point and Click System in Unity 3D</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">日积月累:在Unity 3D中创建一个点并单击系统</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/tip-of-the-day-create-a-point-click-system-in-unity-3d-8de30efee5e2?source=collection_archive---------2-----------------------#2021-04-16">https://levelup.gitconnected.com/tip-of-the-day-create-a-point-click-system-in-unity-3d-8de30efee5e2?source=collection_archive---------2-----------------------#2021-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9f05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在许多游戏类型中，如策略游戏或动作游戏，如暗黑破坏神或亡命之徒，使用等轴透视依赖于点击系统来移动玩家。</p><h2 id="c91e" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">通过几个简单的步骤创建一个点击系统</h2><p id="17bc" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">首先，为了创建这个系统，你需要理解这个导航系统依赖于一个叫做Navmesh的网格。基本上，Navmesh允许玩家或AI智能地在场景中导航。所以角色会自动计算到达目的地所需的路径。</p><p id="c1b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi lj translated">设置好你的场景后，打开<strong class="jp ir">窗口&gt; AI &gt;导航</strong>。在导航窗口中，打开<em class="ls">对象标签</em>，然后在你的层级中选择你的角色将要移动的平面或地形。确保选择<em class="ls">导航静态</em>，然后打开<em class="ls">烘焙标签</em>烘焙网格。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/caa82c2f183cf4061fb1ed12858f5bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/1*qCkGa_koJ_IwTSaJl8KztA.gif"/></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/e9544e636f06795f1262649ff9c4c137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*7STVlE9ZeF959wZ1ERtsMw.jpeg"/></div></figure><p id="7b9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的场景现在应该有一个蓝色高亮显示，显示您的角色可以使用Navmesh移动到哪里。为了更精确，选择场景中不会移动且角色不能去的障碍物/对象，使它们成为静态，然后再次烘焙网格。</p><h2 id="d383" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">播放器设置</h2><p id="7e78" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">A.在你的玩家游戏对象上，添加一个<em class="ls">导航网格代理组件</em>。<br/> B .创建一个C#脚本，添加到播放器中。</p><p id="8c14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">C.在脚本中获取您的NavMeshAgent(您应该使用<strong class="jp ir"> UnityEngine。AI </strong>命名空间)</p><pre class="lu lv lw lx gt mc md me mf aw mg bi"><span id="3bc1" class="kl km iq md b gy mh mi l mj mk">NavMeshAgent _navAgent;<br/>_navAgent = GetComponent&lt;NavMeshAgent&gt;();</span></pre><p id="d72d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">//为了实现这一点，我们需要知道鼠标在屏幕上点击的位置，并返回将用于字符目的地的坐标。为此，我们需要使用光线投射。</p><p id="9e25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">D.在Update()中，检查鼠标点击，并声明两个变量，一个用于<em class="ls">射线投射</em>，另一个用于<em class="ls">射线</em>。</p><pre class="lu lv lw lx gt mc md me mf aw mg bi"><span id="19a7" class="kl km iq md b gy mh mi l mj mk">if(Input.GetMouseButtonDown(0))<br/>        {<br/>            RaycastHit hit;<br/>            Ray ray =            Camera.main.ScreenPointToRay(Input.mousePosition);<br/>        }</span></pre><p id="6b33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">E.现在我们需要使用<em class="ls">物理检查射线是否真的击中了可行走区域网格上的碰撞器。光线投射</em>法。</p><pre class="lu lv lw lx gt mc md me mf aw mg bi"><span id="6b88" class="kl km iq md b gy mh mi l mj mk">if (Physics.Raycast(ray, out hit, 1000, _navAgent.areaMask))<br/>            {<br/>                _navAgent.SetDestination(hit.point);<br/>            }<br/>//out hit returns the info of the collision of the ray<br/>//_navAgent.areMask represents the layermask that are walkable</span></pre><p id="5846" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终的导航代码应该是这样的:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ml"><img src="../Images/1182a57ad7247f113aafb1ebe18af8e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5oa8CpHBbI2oVhoNGATjg.png"/></div></div></figure><p id="5bae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你愿意，这可以扩展到实例化一个鼠标点击光标直接在目的地，以显示玩家他要去的地方，例如。并且这种方法也可以用于AI角色在没有任何输入的情况下导航NavMesh。</p><p id="7fbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，角色应该能够计算出到达目的地的最快路径。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/e9544e636f06795f1262649ff9c4c137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*7STVlE9ZeF959wZ1ERtsMw.jpeg"/></div></figure></div></div>    
</body>
</html>