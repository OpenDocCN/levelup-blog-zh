<html>
<head>
<title>Huffman Encoding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">霍夫曼编码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/huffman-encoding-424d40d92f70?source=collection_archive---------11-----------------------#2021-12-06">https://levelup.gitconnected.com/huffman-encoding-424d40d92f70?source=collection_archive---------11-----------------------#2021-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2990" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是贪婪算法之一，也是我们作为计算机科学团体压缩文本的最初尝试之一。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/d397a6d7d087308f2fe9e34a0c25c3f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_L892Cq1HUD84EHYYy8tQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">来源:桑迪·米勒经由<a class="ae lb" href="https://unsplash.com/photos/Kl4LNdg6on4" rel="noopener ugc nofollow" target="_blank">Unsplash.com</a></figcaption></figure><p id="979f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">贪婪算法是在每个阶段都选择对自己最好的算法。</p><p id="e73e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用贪婪算法解决的常见问题有霍夫曼编码、背包问题和硬币兑换问题。让我们探索霍夫曼编码</p><h1 id="9268" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">霍夫曼编码</h1><p id="570a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">想知道文本是如何发送的吗？</p><p id="e811" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，这是一个非常复杂的问题，我们只关心尽可能高效地发送文本<br/>。为了更快的传输，我们需要更小的比特。这意味着<br/>我们需要压缩我们的文本，但是我们如何归档呢？</p><p id="f047" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">视频和图像使用有损压缩，我们可以在这里失去一点细节，而不是一个<br/>列车粉碎。不幸的是，这不是文本的情况，我们不能失去任何东西，因为文本的上下文将被完全改变。</p><p id="b751" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的压缩仅限于无损压缩。</p><p id="bcd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">多年来，更好的文本压缩算法已经被设计出来，但是<br/>都是基于霍夫曼编码。</p><p id="166e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由数学家大卫·霍夫曼提出，霍夫曼编码是基于数据使用的<br/>不等式。</p><p id="a1b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我说的数据是指字符，有些字符比其他字符用得多。</p><p id="bdca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们更多地使用元音，而不是辅音，如“X”或“Q”，因此这种算法选择“在每个阶段什么是最好的”。</p><p id="591f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用霍夫曼编码算法压缩和解压缩单词Huffman；</p><p id="3f9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有说明霍夫曼的树和表。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mf"><img src="../Images/1f63a595ea90525f38bdd6a9084496cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UniKg1QrONzRmw9bNXXFxw.png"/></div></div></figure><p id="20d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">H-出现一次</p><p id="1d1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">U-出现一次</p><p id="2280" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">f-出现了两次</p><p id="5b17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">m-出现一次</p><p id="2db2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出现一次</p><p id="58de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">n-出现一次</p><p id="c0c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们按照以下简单的5个步骤，用表中的数据绘制树。</p><p id="768f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤1:在我们的树中为每个字符创建一个节点，然后用频率标记它。</p><p id="619c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二步:将这些节点按频率从低到高升序排列。</p><p id="f07e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第3步:然后我们将前两个节点连接起来，并指定一个父节点。父节点的标签是两个频率的和。</p><p id="2236" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤4:刚刚形成的父节点和子节点一起被重新插入到列表中。</p><p id="1a9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤5:重复步骤3和4，直到我们有1个父节点</p><p id="0dd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">见下图；</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mg"><img src="../Images/90c5673c71adbd4db30ab48db4b888a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9fdC0c9lXKVLzk9PC_cAg.png"/></div></div></figure><p id="81e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这翻译过来就是；</p><p id="69e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">h: 000，</p><p id="a3df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">u: 001，</p><p id="dfa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">男:010，</p><p id="f6c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">答:011，</p><p id="6eed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">n:10，</p><p id="19b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">女:11，</p><p id="7e74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编码输出:00000111110100111011</p><p id="aac6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们编码出这个问题的解决方案。</p><p id="e905" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先创建我们的树节点，它接受右边和左边的节点，我们将其初始化为零，也是符号和概率。</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="32d2" class="mm ld iq mi b gy mn mo l mp mq"># A Huffman Tree Node</span><span id="081f" class="mm ld iq mi b gy mr mo l mp mq">class Node:</span><span id="12fc" class="mm ld iq mi b gy mr mo l mp mq">def __init__(self, prob, symbol, left=None, right=None):</span><span id="488e" class="mm ld iq mi b gy mr mo l mp mq">self.prob = prob</span><span id="2156" class="mm ld iq mi b gy mr mo l mp mq">self.symbol = symbol</span><span id="c11b" class="mm ld iq mi b gy mr mo l mp mq">self.left = left</span><span id="e55e" class="mm ld iq mi b gy mr mo l mp mq">self.right = right</span><span id="ac20" class="mm ld iq mi b gy mr mo l mp mq">self.code = ''</span></pre><p id="1d64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们传递一个助手函数来打印遍历树时的符号代码。</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="0232" class="mm ld iq mi b gy mn mo l mp mq"># A helper function to print the codes of symbols by traveling Huffman Tree</span><span id="eaad" class="mm ld iq mi b gy mr mo l mp mq">codes = dict()<br/>def Calculate_Codes(node, value=''):</span><span id="a58f" class="mm ld iq mi b gy mr mo l mp mq">newValue = value + str(node.code)</span><span id="3249" class="mm ld iq mi b gy mr mo l mp mq">if (node.left):</span><span id="9efe" class="mm ld iq mi b gy mr mo l mp mq">Calculate_Codes(node.left, newValue)</span><span id="1449" class="mm ld iq mi b gy mr mo l mp mq">if (node.right):</span><span id="14ad" class="mm ld iq mi b gy mr mo l mp mq">Calculate_Codes(node.right, newValue)</span><span id="37c1" class="mm ld iq mi b gy mr mo l mp mq">if (not node.left and not node.right):</span><span id="3480" class="mm ld iq mi b gy mr mo l mp mq">codes[node.symbol] = newValue</span><span id="e0ef" class="mm ld iq mi b gy mr mo l mp mq">return codes</span></pre><p id="daa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们创建一个辅助函数来计算数据中符号的概率</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="3382" class="mm ld iq mi b gy mn mo l mp mq"># A helper function to calculate the probabilities of symbols in given data</span><span id="0651" class="mm ld iq mi b gy mr mo l mp mq">def Calculate_Probability(data):</span><span id="bd52" class="mm ld iq mi b gy mr mo l mp mq">symbols = dict()</span><span id="bf9d" class="mm ld iq mi b gy mr mo l mp mq">for element in data:</span><span id="77b9" class="mm ld iq mi b gy mr mo l mp mq">if symbols.get(element) == None:</span><span id="081a" class="mm ld iq mi b gy mr mo l mp mq">symbols[element] = 1</span><span id="aaf6" class="mm ld iq mi b gy mr mo l mp mq">else:</span><span id="de9e" class="mm ld iq mi b gy mr mo l mp mq">symbols[element] += 1</span><span id="b92b" class="mm ld iq mi b gy mr mo l mp mq">return symbols</span></pre><p id="2824" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们有函数来计算压缩和非压缩数据之间的空间差异。</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="50d3" class="mm ld iq mi b gy mn mo l mp mq"># A helper function to calculate the space difference between compressed and non compressed data</span><span id="5953" class="mm ld iq mi b gy mr mo l mp mq">def Total_Gain(data, coding):</span><span id="d7be" class="mm ld iq mi b gy mr mo l mp mq">before_compression = len(data) * 8</span><span id="987a" class="mm ld iq mi b gy mr mo l mp mq">after_compression = 0</span><span id="0f15" class="mm ld iq mi b gy mr mo l mp mq">symbols = coding.keys()</span><span id="b21b" class="mm ld iq mi b gy mr mo l mp mq">for symbol in symbols:</span><span id="cfd9" class="mm ld iq mi b gy mr mo l mp mq">count = data.count(symbol)</span><span id="2ccc" class="mm ld iq mi b gy mr mo l mp mq">after_compression += count * len(coding[symbol])</span><span id="5632" class="mm ld iq mi b gy mr mo l mp mq">print("Space usage before compression (in bits):", before_compression)</span><span id="84ae" class="mm ld iq mi b gy mr mo l mp mq">print("Space usage after compression (in bits):", after_compression)</span><span id="7267" class="mm ld iq mi b gy mr mo l mp mq">def Huffman_Encoding(data):</span><span id="8718" class="mm ld iq mi b gy mr mo l mp mq">symbol_with_probs = Calculate_Probability(data)</span><span id="2d60" class="mm ld iq mi b gy mr mo l mp mq">symbols = symbol_with_probs.keys()</span><span id="4801" class="mm ld iq mi b gy mr mo l mp mq">probabilities = symbol_with_probs.values()</span><span id="afed" class="mm ld iq mi b gy mr mo l mp mq">print("symbols: ", symbols)</span><span id="9726" class="mm ld iq mi b gy mr mo l mp mq">print("probabilities: ", probabilities)</span><span id="5f26" class="mm ld iq mi b gy mr mo l mp mq">nodes = []</span></pre><p id="b486" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将符号转换成概率，再转换成霍夫曼树。</p><pre class="km kn ko kp gt mh mi mj mk aw ml bi"><span id="af76" class="mm ld iq mi b gy mn mo l mp mq"># converting symbols and probabilities into huffman tree nodes</span><span id="cd70" class="mm ld iq mi b gy mr mo l mp mq">for symbol in symbols:</span><span id="80a3" class="mm ld iq mi b gy mr mo l mp mq">nodes.append(Node(symbol_with_probs.get(symbol), symbol))</span><span id="0754" class="mm ld iq mi b gy mr mo l mp mq">while len(nodes) &gt; 1:</span><span id="9fa7" class="mm ld iq mi b gy mr mo l mp mq">nodes = sorted(nodes, key=lambda x: x.prob)</span><span id="d5cc" class="mm ld iq mi b gy mr mo l mp mq">right = nodes[0]</span><span id="ca68" class="mm ld iq mi b gy mr mo l mp mq">left = nodes[1]</span><span id="64f9" class="mm ld iq mi b gy mr mo l mp mq">left.code = 0</span><span id="7367" class="mm ld iq mi b gy mr mo l mp mq">right.code = 1</span><span id="3b3d" class="mm ld iq mi b gy mr mo l mp mq">newNode = Node(left.prob + right.prob, left.symbol + right.symbol, left, right)</span><span id="eddd" class="mm ld iq mi b gy mr mo l mp mq">nodes.remove(left)</span><span id="c0fc" class="mm ld iq mi b gy mr mo l mp mq">nodes.remove(right)</span><span id="cd9b" class="mm ld iq mi b gy mr mo l mp mq">nodes.append(newNode)</span><span id="1c9b" class="mm ld iq mi b gy mr mo l mp mq">huffman_encoding = Calculate_Codes(nodes[0])</span><span id="9f84" class="mm ld iq mi b gy mr mo l mp mq">print("symbols with codes", huffman_encoding)</span><span id="78ba" class="mm ld iq mi b gy mr mo l mp mq">Total_Gain(data, huffman_encoding)</span><span id="8e04" class="mm ld iq mi b gy mr mo l mp mq">encoded_output = Output_Encoded(data, huffman_encoding)</span><span id="0f2d" class="mm ld iq mi b gy mr mo l mp mq">return encoded_output, nodes[0]</span><span id="ccc5" class="mm ld iq mi b gy mr mo l mp mq">def Huffman_Decoding(encoded_data, huffman_tree):</span><span id="2431" class="mm ld iq mi b gy mr mo l mp mq">tree_head = huffman_tree</span><span id="a261" class="mm ld iq mi b gy mr mo l mp mq">decoded_output = []</span><span id="f1e8" class="mm ld iq mi b gy mr mo l mp mq">for x in encoded_data:</span><span id="28fb" class="mm ld iq mi b gy mr mo l mp mq">if x == '1':</span><span id="69c2" class="mm ld iq mi b gy mr mo l mp mq">huffman_tree = huffman_tree.right</span><span id="74c8" class="mm ld iq mi b gy mr mo l mp mq">elif x == '0':</span><span id="a2e8" class="mm ld iq mi b gy mr mo l mp mq">huffman_tree = huffman_tree.left</span><span id="bd1d" class="mm ld iq mi b gy mr mo l mp mq">try:</span><span id="129f" class="mm ld iq mi b gy mr mo l mp mq">if huffman_tree.left.symbol == None and huffman_tree.right.symbol == None:</span><span id="083e" class="mm ld iq mi b gy mr mo l mp mq">pass</span><span id="c852" class="mm ld iq mi b gy mr mo l mp mq">except AttributeError:</span><span id="66a6" class="mm ld iq mi b gy mr mo l mp mq">decoded_output.append(huffman_tree.symbol)</span><span id="62b2" class="mm ld iq mi b gy mr mo l mp mq">huffman_tree = tree_head</span><span id="3e38" class="mm ld iq mi b gy mr mo l mp mq">string = ''.join([str(item) for item in decoded_output])</span><span id="1896" class="mm ld iq mi b gy mr mo l mp mq">return string</span><span id="ba50" class="mm ld iq mi b gy mr mo l mp mq">data = "huffman"</span><span id="5115" class="mm ld iq mi b gy mr mo l mp mq">print(data)</span><span id="ce5f" class="mm ld iq mi b gy mr mo l mp mq">encoding, tree = Huffman_Encoding(data)</span><span id="58c6" class="mm ld iq mi b gy mr mo l mp mq">print("Encoded output", encoding)</span><span id="b715" class="mm ld iq mi b gy mr mo l mp mq">print("Decoded Output", Huffman_Decoding(encoding, tree))</span></pre><p id="55ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码由<a class="ms mt ep" href="https://medium.com/u/483d2ec29b96?source=post_page-----424d40d92f70--------------------------------" rel="noopener" target="_blank"> Gugu Sibanyoni </a>提供。</p></div></div>    
</body>
</html>