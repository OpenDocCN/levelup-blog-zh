<html>
<head>
<title>Everything You Need to Know About Receiver Operating Characteristic (ROC) Curve in Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在机器学习中你需要知道的关于接收机工作特性(ROC)曲线的一切</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/everything-you-need-to-know-about-receiver-operating-characteristic-roc-curve-in-machine-learning-5191aecde751?source=collection_archive---------13-----------------------#2021-06-12">https://levelup.gitconnected.com/everything-you-need-to-know-about-receiver-operating-characteristic-roc-curve-in-machine-learning-5191aecde751?source=collection_archive---------13-----------------------#2021-06-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="11d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于ROC曲线的定义、解释、限制、计算复杂性和多类扩展的深入讨论。</p><blockquote class="ko kp kq"><p id="defe" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">背景</strong></p></blockquote><p id="efb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">受试者操作特性曲线，简称ROC曲线，是一种衡量和可视化分类器性能的机制。我们希望分类器识别尽可能多的相关例子。但同时，我们也不希望它产生太多的误报。ROC曲线描绘了命中率和假阳性率之间的关系以揭示折衷。我们将在这篇博文中详细探讨这个问题。术语插曲:命中率有其他的名字:真正的肯定率，回忆，和敏感性。但在这篇博文中，我们将坚持使用点击率。</p><blockquote class="ko kp kq"><p id="19da" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">了解ROC曲线的成分</strong></p></blockquote><p id="1696" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">分类结果和基础事实的可能组合可以用下面的混淆矩阵(或列联表)来表示。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kv"><img src="../Images/4fbb0c9223e13d584453ef833e1c9cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7gCmeKU3aq8SWQvRrRO8Aw.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">混淆矩阵</figcaption></figure><p id="3dbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">命中率由所有真实阳性中的真实阳性的比率来定义。换句话说，在所有真正相关的例子中，分类器成功识别了多少？假阳性率被定义为基于真阴性的错误比率。换句话说，在所有真正不相关的例子中，分类器错误地击中了多少个。在数学上，它们可以表示为条件概率:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/d6f154302fd6533ce0f1c6d57a357bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*t6qcp25yDk9mWRAWEIyYag.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">条件概率中的定义</figcaption></figure><p id="f917" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过计算落入混淆矩阵的四个单元中的例子来估计概率。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/924410b4d7315010592ccf0145e2af8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*Qqp-Ohu1p1fGZk3kCGewTA.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">估计公式</figcaption></figure><p id="f155" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">条件概率形式的定义为理解命中率和假阳性率提供了许多有用的视角。</p><p id="267b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，由于命中率和假阳性率取决于各自的基本事实标签，因此它们对于数据集中的类分布变化是不变的。因此，它们是反映分类器内在质量的良好度量。你可以通过随机抽样各种真实标签分布组合的测试数据集来测试。所得的命中率和假阳性率在所有那些采样的测试数据集中是相同的，只有由随机采样引入的微小差异。</p><p id="1c22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，从条件概率公式中也可以清楚地看出，命中率和误报率加起来不等于1。由于公式中的基本事实分母，将它们相乘或相除并不能提供任何直接有用的见解。</p><blockquote class="ko kp kq"><p id="c058" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">绘制ROC曲线</strong></p></blockquote><p id="1a18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了绘制ROC曲线，我们需要理解分类是如何工作的。对于大多数分类器，通常有一个阈值，我们可以调整决策边界。例如，在逻辑回归中，分类器将产生一个介于0和1之间的值。阈值(在逻辑回归中通常为0.5)是分类器划线的地方。生产值高于阈值的示例将被分类为正，否则为负。改变阈值会影响命中率和假阳性率。因为分类器越积极地尝试找到所有相关的例子，假阳性的风险就越高。相反，分类者越是试图避免说出相关的例子，错误分类负面例子的机会就越低。</p><p id="23ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">给定一个数据集，有一个阈值范围，我们将使用上面的估计公式得到一组相应的命中率和假阳性率对。然后我们可以绘制ROC图，x轴为假阳性率，y轴为命中率。请参见下图。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/f473d2e05405b3f7d8592153cd53fcc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*v4ToyjXc3OOsJSubuvFNJw.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">ROC曲线图解</figcaption></figure><p id="2d89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了清楚起见，ROC曲线上的每个点都是具有不同阈值的相同分类器。</p><blockquote class="ko kp kq"><p id="ee58" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">了解ROC曲线</strong></p></blockquote><p id="ecf0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们仔细看看，了解图表上的内容。<code class="fe lo lp lq lr b">y=x</code>线是分类器只是随机猜测的时候。要了解为什么会出现这种情况，请考虑命中率和假阳性率的条件概率定义。随机猜测意味着分类结果独立于基本事实标签。在这种情况下，命中率等于假阳性率。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi ls"><img src="../Images/9ed725177c2b9b20cda4c61d28230c4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EvUQcRSnY1KMSVDNbVYXQ.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">y=x证明</figcaption></figure><p id="d701" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">点<code class="fe lo lp lq lr b">(0,0)</code>是分类器永远不会有任何假阳性的地方，因为它无论如何也不会调出任何阳性的例子。这就像是一个完全无声的分类器。相反地，点<code class="fe lo lp lq lr b">(1,1)</code>是分类器为所有的例子点火的地方，达到100%的命中率，但是也得到100%的假阳性率，因为它把所有的负面例子误分类为正面。</p><p id="80b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，直觉上，我们希望我们的分类器的ROC曲线在<code class="fe lo lp lq lr b">y=x</code>线之上。这意味着在相同的假阳性率下，分类器具有良好的命中率。或者对称地，在相同的命中率下，分类器具有更少的假阳性。显然，<code class="fe lo lp lq lr b">(0,1)</code>是理论理想之所在。</p><p id="b698" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，ROC曲线低于<code class="fe lo lp lq lr b">y=x</code>的分类器可能看起来比随机猜测差。但是我们实际上可以把它翻转过来——把它的分类正面视为负面，反之亦然——使它比随机猜测更好。当然，在这种情况下，更重要的是调查为什么分类器会得出与基本事实相反的结论。这通常是由于代码中的错误造成的。</p><p id="17da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了比较分类器的性能，我们通常使用曲线下面积(AUC)作为单一指标。AUC越大，性能越好。然而，当把它应用到现实世界的场景中时，我们需要考虑错误的代价。在某些情况下，低命中率的代价要高得多，例如在疾病检测中。在其他情况下，高假阳性率可能更具破坏性。我们应该根据具体的用例来选择最大化期望回报的阈值。</p><blockquote class="ko kp kq"><p id="6972" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">ROC曲线的限制</strong></p></blockquote><p id="2dd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在许多情况下，ROC曲线是一个很好的性能指标。但是它不一定揭示分类器的精度。精确度被定义为在所有分类的阳性中，有多少是真正的阳性。就条件概率而言，其公式如下</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/111f519ee7380d65f97ee020d5d3123c.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*Ive8Em4BSmGl5isBaOjfFQ.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">精度定义</figcaption></figure><p id="5a17" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在遗漏一些相关的例子没什么问题，但是我们希望对分类的阳性结果有很高的置信度的情况下，精度是有用的。</p><p id="4042" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要了解为什么ROC在这种情况下不是首选，请考虑一个基本事实很少的数据集。一个分类器可以通过将基础真值阳性的超集分类为阳性来实现高命中率和低假阳性率(接近理想的<code class="fe lo lp lq lr b">(0,1)</code>点)——假设超集的基数是基础真值阳性的两倍。命中率是100%，因为它成功地识别了所有的地面真相阳性。尽管存在过多的假阳性，但由于数据集中压倒性数量的地面真阴性(假阳性率的分母)，假阳性率仍然很低。然而，这种情况下的精度只有50%。</p><blockquote class="ko kp kq"><p id="b7e4" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">计算复杂度</strong></p></blockquote><p id="109c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ROC曲线是具有不同阈值的相同分类器。您可能认为，为了获得命中率和假阳性率对来绘制曲线，我们必须对测试数据运行多次分类器，每次都使用不同的阈值。在那种情况下，计算复杂度将是<code class="fe lo lp lq lr b">m*n*O(classifier)</code>。<code class="fe lo lp lq lr b">m</code>是门槛的数量。<code class="fe lo lp lq lr b">n</code>是例数。<code class="fe lo lp lq lr b">O(classifier)</code>是对一个例子进行分类的复杂性，这在许多基于现代深度神经网络的模型中是非常昂贵的。</p><p id="935f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上有一种更有效的方法。请注意，分类器在应用阈值之前生成的值不会改变。所以没有必要对例子重新进行分类。只需对所有示例运行一次分类器，并按降序对输出值进行排序。其计算复杂度为<code class="fe lo lp lq lr b">n*O(classifier)+nlog(n)</code>。然后，我们只需要一次线性扫描来绘制ROC曲线。在扫描过程中，我们跟踪命中率和假阳性率。让我们用逻辑回归作为说明的例子。输出值将全部在[0，1]范围内。如果阈值大于或等于输出值，则分类器将示例分类为肯定的。有关线性扫描算法，请参见以下Python代码片段:</p><pre class="kw kx ky kz gt lu lr lv lw aw lx bi"><span id="52ec" class="ly lz it lr b gy ma mb l mc md">hit = 0.<br/>false_positive = 0.<br/>n = len(output_values)<br/>roc = []</span><span id="063d" class="ly lz it lr b gy me mb l mc md"># output_values is sorted in descending order.<br/>for i, v in enumerate(output_values):<br/>    # Assuming threshold == v, then the ith example will be <br/>    # classified as positive, because the example is classifier<br/>    # positive when threshold &gt;= v.<br/>    if label(i) == POSITIVE:<br/>        hit += 1<br/>    else:<br/>        false_positive += 1<br/>    roc.append((false_positive/n, hit/n))</span></pre><p id="5820" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的关键见解是，由于输出值按降序排序，从左向右移动阈值不会改变之前遇到的示例的分类-当一个示例被分类为肯定时，当我们降低阈值时，它仍然是肯定的分类。因此，我们可以简单地在线性扫描中不断累积命中和假阳性计数。整体综合体是<code class="fe lo lp lq lr b">n*O(classifier)+nlog(n)+n</code>。当<code class="fe lo lp lq lr b">O(classifier)</code>是重的部分时，这个算法更有效。</p><blockquote class="ko kp kq"><p id="e085" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">扩展到多个类</strong></p></blockquote><p id="c555" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们一直假设标签中只有两个类。实际上，ROC曲线主要是为二元分类设计的。当我们有两个以上的类时，我们通常为每个类构建一个vs其余的对，并绘制相应的ROC曲线。举一个具体的例子，多类分类器通常使用softmax来生成概率数组。数组中的<code class="fe lo lp lq lr b">ith</code>值对应于<code class="fe lo lp lq lr b">ith</code>类的概率。对于任何类别<code class="fe lo lp lq lr b">i</code>，我们可以通过改变<code class="fe lo lp lq lr b">ith</code>值的阈值来绘制其ROC曲线。如果<code class="fe lo lp lq lr b">ith</code>值大于或等于阈值，则该示例被分类为类别<code class="fe lo lp lq lr b">i</code>(正)。否则归类为其他(负面)。有了这样的结构，我们回到我们的二元分类，在这里可以创建ROC曲线。请参见下图进行说明。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/9ee85b41a619adb202fc5e193e6d0782.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*aq0sX1-3hxRSl_GD7g4qag.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">多级ROC曲线</figcaption></figure><p id="4828" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还需要发展AUC指标，因为我们不再只处理一条ROC曲线。有<a class="ae mg" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.108.3250&amp;rep=rep1&amp;type=pdf" rel="noopener ugc nofollow" target="_blank">项研究</a>被用来评估地表下的体积(VUS)和一些在计算上更易处理的近似值。我们没有时间讨论细节。我个人的观点是，如果一个指标变得难以计算和理解，那么它可能不再是解决问题的好指标。我们应该寻找替代方案。例如，<a class="ae mg" href="https://www.image-net.org/" rel="noopener ugc nofollow" target="_blank"> ImageNet </a>正在评估前1名和前5名准确度的分类器，尽管它的类别分布是不平衡的——有许多类别只有很少的例子。</p><blockquote class="ko kp kq"><p id="c21a" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu">总结</strong></p></blockquote><p id="ba23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">今天就到此为止。我计划在不久的将来写一些与ML相关的博客文章。所以，希望下次能见到你。</p></div></div>    
</body>
</html>