<html>
<head>
<title>The Quick Guide to Flutter Unit Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤振单元试验快速指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-quick-guide-to-flutter-unit-testing-2f892539622b?source=collection_archive---------2-----------------------#2022-03-27">https://levelup.gitconnected.com/the-quick-guide-to-flutter-unit-testing-2f892539622b?source=collection_archive---------2-----------------------#2022-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae42" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">新颤振测试仪指南，但初级编码经验。</h2></div></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><p id="30c3" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">媒体界有一种误解，认为单元测试不适合MVP。相反，单元测试是MVP的福音！如果没有单元测试，您有两个选择:</p><ol class=""><li id="5a65" class="ll lm it kr b ks kt kv kw ky ln lc lo lg lp lk lq lr ls lt bi translated">最终不可避免地向用户发布一个错误</li><li id="d9b6" class="ll lm it kr b ks lu kv lv ky lw lc lx lg ly lk lq lr ls lt bi translated">手动测试一切，每次更新</li></ol><p id="d0ee" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">第一个不好，原因很明显，但第二个是一个伪装的魔鬼。在一个小的应用程序中，在你<code class="fe lz ma mb mc b">git push</code>之前测试核心功能是很容易的，但是一旦你开始添加一些功能，手动测试就变成了一项耗时的任务。</p><p id="1397" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">有了自动化的单元测试，您就避免了错误的产生，并且节省了大量的时间:不再需要手动测试每个分支，您最终可以在30秒或者更短的时间内一次测试完所有的分支。从长远来看，预先花掉10%的额外时间可以节省你几个小时。</p><p id="8f35" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">更重要的是，如果你正确设置了代码库，颤振测试非常容易编写。即使您没有，Flutter的设计也考虑到了良好的实践，因此向更易测试的代码库迁移并不困难。</p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="2df5" class="md me it bd mf mg mh dn mi mj mk dp ml ky mm mn mo lc mp mq mr lg ms mt mu mv bi translated">建筑</h2><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi mw"><img src="../Images/59d92ded2f3f9be43dc366c623b7ee64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jEaqw-u5UHeXWWQVGQeYZQ.png"/></div></div></figure><p id="95f8" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">准备测试的Flutter代码库使用了一些简单的依赖注入模式。通常，服务会与BLoC层对话，而BLoC层会与UI层对话。</p><h2 id="1931" class="md me it bd mf mg mh dn mi mj mk dp ml ky mm mn mo lc mp mq mr lg ms mt mu mv bi translated">服务</h2><p id="f8f5" class="pw-post-body-paragraph kp kq it kr b ks ni ju ku kv nj jx kx ky nk la lb lc nl le lf lg nm li lj lk im bi translated">服务可以有依赖关系，但只能依赖于其他服务。这不是什么不知名的“最佳实践”，这是直觉。您的服务为您执行功能，并且可以在许多地方使用。如果我们将它直接绑定到一个特定的小部件或区块，它就不再是一项服务，它只是您的小部件/区块的一部分！</p><p id="10c0" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们如何依赖注入服务？我用的是一个叫<code class="fe lz ma mb mc b">get_it</code>(此处<a class="ae nn" href="https://pub.dev/packages/get_it" rel="noopener ugc nofollow" target="_blank">为</a>的包！).我建议看一下文档，但是总的来说，这个包的流程非常简单。首先，在应用程序的根目录下，创建一个名为<code class="fe lz ma mb mc b">service_locator.dart</code>的文件(或者你想要的任何东西)。然后，在文件顶部做<code class="fe lz ma mb mc b">final getIt = GetIt.instance;</code>。编写一个注册所有服务的函数，恰当地命名为<code class="fe lz ma mb mc b">registerServices</code>。对于每个服务，按照<code class="fe lz ma mb mc b">getIt.registerSingleton&lt;MyService&gt;(MyService());</code>的思路做一些事情。下面是我的<code class="fe lz ma mb mc b">service_locator.dart</code>在真实应用中的样子:</p><figure class="mx my mz na gt nb"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="07a9" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这里通常不应该有逻辑，但是一点点配置不会有什么坏处。</p><p id="f14f" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这里的最后一步是在运行应用程序的<code class="fe lz ma mb mc b">void main() {}</code>函数中调用<code class="fe lz ma mb mc b">registerServices</code>。</p><figure class="mx my mz na gt nb"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bd5d" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">服务几乎没有依赖性，因此它们是迄今为止最容易测试的。对于这种情况，考虑一个简单的<code class="fe lz ma mb mc b">LocalImageService</code>类(这个类用于生产应用程序，所以这不是一个“玩具”用例！):</p><figure class="mx my mz na gt nb"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0814" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这里有几件事情正在发生:首先要注意的是，我们实际上正在使用<code class="fe lz ma mb mc b">getIt&lt;ImagePicker&gt;()</code>(这来自外部包)来消费一个依赖项。这就是服务定位器发挥作用的地方。另一件事是只有一个执行路径需要测试，那就是<code class="fe lz ma mb mc b">selectImage</code> api！所以让我们开始测试它。</p><p id="aaa1" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">测试进入<code class="fe lz ma mb mc b">test</code>目录，而不是<code class="fe lz ma mb mc b">src</code>目录。路径是完全相同的:例如，如果我们在<code class="fe lz ma mb mc b">src/services/local_image_service.dart</code>下有<code class="fe lz ma mb mc b">LocalImageService</code>，您将想要进行测试<code class="fe lz ma mb mc b">test/services/local_image_service_test.dart</code>。另一个区别是文件名只是<code class="fe lz ma mb mc b">{filename}_test.dart</code>。</p><p id="e30c" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们要为此设置模拟/假货。我用<code class="fe lz ma mb mc b">mocktail</code>，(<a class="ae nn" href="https://pub.dev/packages/mocktail" rel="noopener ugc nofollow" target="_blank">这里用</a>！)但是也可以用mockito。我们唯一需要的模拟是对我们的<code class="fe lz ma mb mc b">ImagePicker</code>的模拟。使用mocktail很容易设置:</p><pre class="mx my mz na gt nq mc nr ns aw nt bi"><span id="1ea6" class="md me it mc b gy nu nv l nw nx">class MockImagePicker extends Mock implements ImagePicker {}</span></pre><p id="42ab" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们还需要一个假的<code class="fe lz ma mb mc b">XFile</code>(函数的返回值。一个“假”和一个模拟非常相似，但是唯一的区别是你不能根除实现。当逻辑每次都非常相似，或者对象只是一个外壳，根本没有逻辑时，我会使用fakes)。</p><pre class="mx my mz na gt nq mc nr ns aw nt bi"><span id="f48a" class="md me it mc b gy nu nv l nw nx">class FakeXFile extends Fake implements XFile {}</span></pre><p id="d5f3" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">现在，我们要做的就是编写测试！</p><figure class="mx my mz na gt nb"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="70c4" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我在评论中描述了所有的复杂性，所以我建议看一看那些。</p><p id="8de5" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">您可能还想测试并确保返回值也是<code class="fe lz ma mb mc b">fakeXFile</code>，但是我将把它留给读者作为练习。</p><p id="611a" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">就是这样！您编写并依赖注入了一个服务。</p><h2 id="a03f" class="md me it bd mf mg mh dn mi mj mk dp ml ky mm mn mo lc mp mq mr lg ms mt mu mv bi translated">集团</h2><p id="f6a1" class="pw-post-body-paragraph kp kq it kr b ks ni ju ku kv nj jx kx ky nk la lb lc nl le lf lg nm li lj lk im bi translated">顺便说一下，BLoC现在是cubit:我们将测试Cubit，而不是测试BLoC，它们在功能上是等价的，可以互换。</p><p id="96dd" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这是我们的腕尺:</p><figure class="mx my mz na gt nb"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8331" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">超级简单。请注意，我们在任何地方都不依赖于UI:这完全是在块层，但是它可以通过功能直接绑定到UI:也许(并且很可能)这个cubit在其他地方没有用，并且有一些特定于应用程序的动作。那也行！</p><p id="18de" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">测试是什么样的？幸运的是，BLoC hand用他们的<code class="fe lz ma mb mc b">bloc_test</code>包帮你测试。</p><p id="1414" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">下面是其中一个测试的样子，评论道:</p><figure class="mx my mz na gt nb"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4cf1" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">因为我们已经处理了依赖注入，所以测试设置起来既快又容易！</p><h2 id="a653" class="md me it bd mf mg mh dn mi mj mk dp ml ky mm mn mo lc mp mq mr lg ms mt mu mv bi translated"><strong class="ak">小工具</strong></h2><p id="c435" class="pw-post-body-paragraph kp kq it kr b ks ni ju ku kv nj jx kx ky nk la lb lc nl le lf lg nm li lj lk im bi translated">测试的最后一层是小部件测试。小部件与bloc对话，bloc很好，因为我们可以操纵它们的状态来观察UI是否做出相应的反应。</p><p id="a797" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">下面是我们将要测试的小部件:</p><figure class="mx my mz na gt nb"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4afb" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">非常简单的小部件，除了是一个很好的例子之外，真的没什么用。</p><p id="9489" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">一般来说，将字符串存储在变量中对于翻译之类的事情来说是个好主意，但是</p><p id="f388" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这里应该写很多测试，但是我们只做一个:</p><ul class=""><li id="ee96" class="ll lm it kr b ks kt kv kw ky ln lc lo lg lp lk ny lr ls lt bi translated">点击文字按钮是否调用上传功能？</li><li id="005e" class="ll lm it kr b ks lu kv lv ky lw lc lx lg ly lk ny lr ls lt bi translated">非空状态是否意味着我们显示<code class="fe lz ma mb mc b">hasImageCopy</code>文本？</li><li id="8414" class="ll lm it kr b ks lu kv lv ky lw lc lx lg ly lk ny lr ls lt bi translated">空状态是否显示<code class="fe lz ma mb mc b">TextButton</code>？(这是我们要写的)</li></ul><p id="78d0" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们现在需要模仿腕尺，但是腕尺有一个特殊的模仿:</p><pre class="mx my mz na gt nq mc nr ns aw nt bi"><span id="9e0f" class="md me it mc b gy nu nv l nw nx">class MockImageUploadCubit extends MockCubit&lt;XFile?&gt; implements ImageUploadCubit {}</span></pre><p id="2898" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们的测试现在将使用<code class="fe lz ma mb mc b">testWidgets</code>关键字。这意味着我们正在运行一个小部件测试，我们应该得到一个无头的<code class="fe lz ma mb mc b">widgetTester</code>。本质上，这是一个窗口小部件被渲染的环境，但不是给你我看的，只是为了让我们可以验证在那个环境中发生的事情。</p><pre class="mx my mz na gt nq mc nr ns aw nt bi"><span id="51b9" class="md me it mc b gy nu nv l nw nx">testWidgets('should show button on null state', (tester) async {});</span></pre><p id="60bc" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">总的来说，我最喜欢编写小部件测试，因为它们实际上只涉及一个依赖项:当前块！这意味着几乎没有什么需要剔除的，所以编写这些测试轻而易举。</p><figure class="mx my mz na gt nb"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><p id="5294" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">就是这样！恭喜，您已经测试了应用程序的所有层。在我们分开之前，这里有一个我在应用程序中使用的Makefile，这样我可以快速查看生成的覆盖率报告。将您不想包含在您的覆盖报告中的任何文件添加到<code class="fe lz ma mb mc b">t-clean</code>部分。</p><figure class="mx my mz na gt nb"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8149" class="pw-post-body-paragraph kp kq it kr b ks kt ju ku kv kw jx kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我在每次提交/ PR之前运行<code class="fe lz ma mb mc b">full-t</code>,以确保我没有错过任何测试的黑暗角落，并允许自己有很大的覆盖率。</p></div></div>    
</body>
</html>