<html>
<head>
<title>How to Deploy a Multi Container (two tier) Go Application in EKS Fargate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在EKS法盖特部署多容器(两层)Go应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-deploy-a-multi-container-two-tier-go-application-in-eks-fargate-6266494f5bcf?source=collection_archive---------9-----------------------#2022-05-02">https://levelup.gitconnected.com/how-to-deploy-a-multi-container-two-tier-go-application-in-eks-fargate-6266494f5bcf?source=collection_archive---------9-----------------------#2022-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="eddb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇(另一篇)长文中，我们探索了在EKS法盖特部署2层Go应用程序的端到端场景。两层意味着我们将有一个后端应用程序容器(在Go中)与一个数据库(Postgres)容器交互。我们将通过在EKS建立两层应用程序和服务来服务通信的细微差别，以及处理fargate配置文件的复杂性来工作。</p><p id="89d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这可能是特定于Go应用程序的，但目的是探索将任何多容器应用程序部署到EKS法盖特的通用步骤。大部分的YAMLs都有大量的注释来解释。在这个初学者教程中没有使用Terraform，但是使用Terraform可以自动完成大多数步骤。</p><p id="22fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将执行以下步骤:</p><ul class=""><li id="593e" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">为Go应用程序创建一个Docker图像。</li><li id="eace" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">使用Docker Compose在本地测试容器。</li><li id="05a6" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">创建Kubernetes资源:部署、PVC、状态集等。</li><li id="8a26" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">在ALB创建入口和TLS终端。</li></ul><h1 id="ff13" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">步骤0:先决条件</h1><p id="cb30" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">不用说，在我们开始做任何事情之前，我们需要设置好所有的环境。需要以下软件:</p><ul class=""><li id="941a" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><a class="ae mc" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">码头工人</a></li><li id="79d7" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae mc" href="https://helm.sh/docs/intro/install/" rel="noopener ugc nofollow" target="_blank">掌舵</a></li><li id="6d97" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae mc" href="https://docs.aws.amazon.com/eks/latest/userguide/create-cluster.html" rel="noopener ugc nofollow" target="_blank">AWS上的EKS集群</a>(注意:记住对于Fargate，您<a class="ae mc" href="https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.html" rel="noopener ugc nofollow" target="_blank">不能挂载EBS卷</a>，并且EFS <a class="ae mc" href="https://docs.aws.amazon.com/eks/latest/userguide/efs-csi.html" rel="noopener ugc nofollow" target="_blank">不允许在Fargate </a>上进行动态配置，因此我们将使用EFS 的<a class="ae mc" href="https://docs.aws.amazon.com/eks/latest/userguide/efs-csi.html" rel="noopener ugc nofollow" target="_blank">静态配置)</a></li></ul><p id="ce98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了创建fargate集群，强烈推荐使用EKSCTL ,因为它可以在正确的名称空间中创建必要的标签、pod执行角色、Fargate概要文件和许多其他后端手工工作，这样可以省去很多麻烦。如果您决定使用控制台创建，记得在之前做好<a class="ae mc" href="https://docs.aws.amazon.com/eks/latest/userguide/fargate-getting-started.html" rel="noopener ugc nofollow" target="_blank">准备工作</a>:修补CoreDNS，在kube-system中创建fargate配置文件，创建podexecution角色，创建私有子网，标记它们等等。最后，使用1.21版本，因为1.22已经删除了许多有用的注释。我使用以下命令创建:<code class="fe md me mf mg b">eksctl create cluster --name YOUR_CLUSTER_NAME --version 1.21 --fargate</code></p><p id="3665" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用任何应用程序，但出于本教程的目的，我使用了一个简单的主应用程序上传到Github repo <a class="ae mc" href="https://github.com/gravito/simpleservice" rel="noopener ugc nofollow" target="_blank">这里</a>。这是一个简单的2层应用程序，用于检查数据库连接。</p><p id="4727" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它只有一个回答“text/plain”的“/live”端点；charset=utf-8 `。下面的响应可能是:<br/> -`干得好:`:如果应用程序能够与Postgres数据库连接<br/> -`正在运行`:如果在与数据库连接的过程中发生了一些错误</p><h1 id="6653" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">步骤1:为Go应用程序创建一个Docker映像</h1><p id="1cad" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">正如你们中的一些人可能知道的，Docker映像是从Dockerfiles创建的，Docker files是一个文本文档，包含运行完全独立的软件二进制文件及其所有依赖项所需的所有步骤。</p><p id="f215" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不用说，创建Docker映像的第一步是在本地测试它。这是理解具体构建步骤的重要一步，稍后我们将使用Dockerfile自动完成。</p><p id="8c97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于演示应用程序，幸运的是非常简单。我们需要做的只是编译二进制文件，运行它，它会自动连接到数据库。数据库配置分别取自PORT和POSTGRES_URL。</p><h2 id="e647" class="mh la iq bd lb mi mj dn lf mk ml dp lj jy mm mn ln kc mo mp lr kg mq mr lv ms bi translated">在EC2上安装和设置Go和Postgres:</h2><p id="969a" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">这里不用费太多脑筋，只是在EC2中安装Postgres和Go来测试我们的Docker映像。我在这里提到了<a class="ae mc" href="https://www.how2shout.com/linux/install-postgresql-13-on-aws-ec2-amazon-linux-2/" rel="noopener ugc nofollow" target="_blank">的链接</a>。</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="039f" class="mh la iq mg b gy nb nc l nd ne">-&gt; sudo tee /etc/yum.repos.d/pgdg.repo&lt;&lt;EOF</span><span id="b418" class="mh la iq mg b gy nf nc l nd ne">-&gt; Adding Repo Info<br/>[pgdg13]<br/>name=PostgreSQL 13 for RHEL/CentOS 7 - x86_64<br/>baseurl=https://download.postgresql.org/pub/repos/yum/13/redhat/rhel-7-x86_64<br/>enabled=1<br/>gpgcheck=0<br/>EOF</span><span id="1282" class="mh la iq mg b gy nf nc l nd ne">-&gt; Installing and enabling Postgres<br/>sudo yum update<br/>sudo yum install postgresql13 postgresql13-server<br/>sudo /usr/pgsql-13/bin/postgresql-13-setup initdb<br/>sudo systemctl start postgresql-13<br/>sudo systemctl enable postgresql-13</span><span id="fe15" class="mh la iq mg b gy nf nc l nd ne">-&gt; Change password using below commands:<br/>sudo passwd postgres</span><span id="376e" class="mh la iq mg b gy nf nc l nd ne">-&gt; Create database for backend. We used simpleservice.<br/>sudo -u postgres psql<br/>CREATE DATABASE simpleservice<br/>\q</span></pre><p id="ae29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装Go应用程序只需一个简单的步骤:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="c19e" class="mh la iq mg b gy nb nc l nd ne">sudo yum install golang -y</span></pre><p id="0d51" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们尝试运行GoLang应用程序并连接Postgres。如果您仔细阅读自述文件，要构建这个演示应用程序，我们只需运行:“GO111MODULE=on go build”命令来构建simple_service二进制文件。我们现在只需运行二进制文件来启动服务器。</p><p id="a9d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">端口和数据库连接url在config文件夹中配置。使用您创建的用户名、密码和数据库名称更改PostgresURL的envDefault值，以连接到数据库。请注意，我们正在使用？sslmode =禁用查询字符串。总的网址是:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="80d0" class="mh la iq mg b gy nb nc l nd ne">postgres://&lt;user&gt;:&lt;pass&gt;@&lt;IP&gt;/&lt;dbname&gt;?sslmode=disable</span></pre><p id="c54c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当所有步骤都完成后，只需运行二进制:。/simple_service，然后使用localhost:curl localhost:<port>/live进行连接</port></p><p id="9e4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该得到如下的“做得很好:)”消息:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="0cf4" class="mh la iq mg b gy nb nc l nd ne">[ec2-user@ip-172-31-29-226 ~]$ curl localhost:8000/live<br/>Well done :)</span></pre><p id="c64b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们为什么要通过所有的手动步骤来测试这个图像呢？这是因为我们将自动化所有这些步骤！让我们看看我们能怎么做。</p><h2 id="abb9" class="mh la iq bd lb mi mj dn lf mk ml dp lj jy mm mn ln kc mo mp lr kg mq mr lv ms bi translated">创建Docker图像:</h2><p id="c745" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">看看下面的Docker图片，这是一个building a Go二进制文件:</p><figure class="mt mu mv mw gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="dd16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不会仔细检查每一条语句，因为大多数语句都可以在Dockerfile reference <a class="ae mc" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。添加的注释是不言自明的。</p><p id="b7da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于Go，我们需要go mod和go sum文件(第11行),并且需要从go mod和sum文件下载所有依赖项(第14行)。然而，正如<a class="ae mc" href="https://go.dev/doc/go1.11" rel="noopener ugc nofollow" target="_blank"> Go 1.11 </a>中介绍的那样，“go mod下载”只有在原始go mod和go sum文件被更改的情况下才会重新运行。由于这些文件很少改变，我们在编译时节省了大量时间。然后，我们简单地将所有文件复制到工作目录中(第17行)。然后我们在第20行构建二进制文件。请注意，再次构建时间将会非常快，因为所有的依赖项都已经在前面的步骤中下载并缓存了(否则我们可以走远路，只构建二进制文件并每次下载所有的依赖项！).</p><p id="1054" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们利用多阶段构建来降低映像大小，并为其复制二进制文件和环境文件。通常的docker构建和docker推送会将图像上传到dockerhub。请注意，根据该命名约定，非官方图像名称应该命名如下:<code class="fe md me mf mg b">&lt;username&gt;/&lt;image_name&gt;:&lt;tag_name&gt;.</code></p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="0631" class="mh la iq mg b gy nb nc l nd ne">docker build -t gravito/simple-service:latest .<br/>docker push gravito/simple-service:latest</span></pre><h1 id="43b1" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">步骤2:使用Docker Compose在本地测试容器</h1><p id="0357" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">在我们进入Kubernetes的复杂世界之前，我们可以使用Docker Compose在本地测试图像。</p><p id="fdac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用docker run命令测试基本映像，并使用端口转发暴露主机上的8080端点。请注意，当卷曲本地主机时，您的连接将被拒绝，因为数据库容器没有运行:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="ff06" class="mh la iq mg b gy nb nc l nd ne"># fetching image from dockerhub<br/>docker pull gravito/simple-service:latest</span><span id="ac30" class="mh la iq mg b gy nf nc l nd ne"># running the image and port forwarding<br/>docker run -it -p 8080:8080 gravito/simple-service:latest</span><span id="43fb" class="mh la iq mg b gy nf nc l nd ne"># using curl to access 8080 on localhost will give error as follows:</span><span id="1044" class="mh la iq mg b gy nf nc l nd ne">Listening on port 8080<br/>Sat Apr 23 13:31:27 2022 - error querying database: dial tcp 127.0.0.1:5432: connect: connection refused<br/>Sat Apr 23 13:31:27 2022 - simple request</span></pre><p id="e17d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果我们还需要设置数据库容器，我们需要定义环境变量，然后定义到数据库容器的连接URL，公开5432端口，设置数据库的用户名/密码，等等。对于我们的本地通用容器来说，这将是太多的工作。</p><p id="55ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是Docker compose将提供帮助的地方。Compose是一个定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用YAML文件来配置应用程序的服务。然后，只需一个命令，您就可以从您的配置中创建并启动所有服务。这是测试多容器图像的有效方法。</p><p id="32d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Docker合成文件下面找到:</p><figure class="mt mu mv mw gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9cc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，我们不打算详细说明Docker Compose是如何工作的，因为我们在这里使用它只是为了测试，因为实际代码无论如何都会在Kubernetes中运行。</p><p id="e2c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，总结就是我们正在创建两个服务。一个前端，一个数据库。数据库服务将从hub中提取postgres映像(第18行),并使用环境变量创建我们的数据库(第23行),同时在端口5432上公开DB(第25行)。临时存储由卷提供(第27行)。</p><p id="379f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前端将在本地构建容器(第5行)并公开端口8080(与DB config相同)。请注意，DB config环境变量是第14行和第15行中提供的连接字符串和端口。</p><p id="3a49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于Docker Compose，环境变量从<a class="ae mc" href="https://docs.docker.com/compose/env-file/" rel="noopener ugc nofollow" target="_blank">中选取。本地的env </a>文件。因此，请确保您已经将所有相关的环境变量放入该文件中。</p><p id="aa71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦设置了环境变量，文件就准备好了，只需运行:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="cac8" class="mh la iq mg b gy nb nc l nd ne">docker-compose up -d</span></pre><p id="f724" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将创建应用程序。使用CURL访问它:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="8770" class="mh la iq mg b gy nb nc l nd ne">curl <a class="ae mc" href="http://localhost:8080/live" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/live</a> </span></pre><p id="6273" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您需要编辑docker文件并返工，请首先运行以下命令进行拆除:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="583e" class="mh la iq mg b gy nb nc l nd ne">docker-compose down --remove-orphans --volumes</span></pre><p id="5a96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后运行以下命令重新构建:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="1a94" class="mh la iq mg b gy nb nc l nd ne">docker-compose up --build</span></pre><h1 id="ea16" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">步骤3:创建Kubernetes资源:部署、PVC、Statefulsets等。</h1><p id="65b7" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">现在我们终于来到了库伯内特斯。在我们部署这些资源之前，您必须了解这些资源是什么以及它们的作用。因此，在继续之前，请随意阅读这篇关于Kubernetes资源的非常详细和<a class="ae mc" href="https://medium.com/@shrut_terminator/the-all-mighty-guide-to-devops-interview-questions-kubernetes-edition-a33da07a3b00" rel="noopener">全面的文章</a>，它是由您真正以用户友好的方式撰写的:)。</p><p id="0907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始部署资源之前，我们需要设计一些注意事项。所以我们有一个应用程序和一个数据库。所以自然地，我们需要保存数据。这将需要StatefulSet +持久卷控制器+持久卷的组合。</p><p id="efe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要存储所有用户名，密码和其他相关信息的秘密。然后，我们将需要通常的应用程序部署和内部服务来访问它们。</p><p id="6c38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要入口将应用程序暴露在外面。为什么是入口，为什么不是负载平衡器服务？这是因为将来如果应用程序扩展并且我们添加了更多的单元，我们将需要为每个应用程序使用多个负载平衡器。相反，我们可以简单地使用入口对象并在内部路由到新的服务。有点像下面给出的:</p><figure class="mt mu mv mw gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/3e5c0afebf87d9518e79051ef51535b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LzqedNcl6kUO4Oc4oLjPpQ.png"/></div></div></figure><p id="69dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了连接到数据库，我们只需在应用程序的连接字符串中提供postgres服务名和端口号。这是通过使用内部服务机制来确保内部应用程序与数据库通信的关键。例如:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="ef2a" class="mh la iq mg b gy nb nc l nd ne">postgres://user:pass@&lt;db-service-name&gt;:&lt;port-number-of-database-service&gt;/dbname?sslmode=disable</span></pre><p id="1c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到这些因素，让我们开始创造一切。</p><h2 id="9a65" class="mh la iq bd lb mi mj dn lf mk ml dp lj jy mm mn ln kc mo mp lr kg mq mr lv ms bi translated">设计存储解决方案:</h2><p id="94fb" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">您可能知道，对于EKS，它需要容器存储接口(CSI)驱动程序来支持其存储。如前所述，Fargate仅支持EFS静态配置，因此我们将使用它。</p><p id="ab32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，好消息是EFS的Fargate不需要手动安装EFS CSI驱动程序的T2。因此，我们只需要创建EFS，并挂载正确的子网。按照“<a class="ae mc" href="https://docs.aws.amazon.com/eks/latest/userguide/efs-csi.html#efs-create-filesystem" rel="noopener ugc nofollow" target="_blank">创建EFS文件系统</a>”中的步骤，为EFS正确创建和配置挂载目标。</p><p id="ddd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们只需从他们的<a class="ae mc" href="https://github.com/kubernetes-sigs/aws-efs-csi-driver.git" rel="noopener ugc nofollow" target="_blank"> github repo </a>中复制样例配置模板。或者，您可以使用以下代码:</p><ul class=""><li id="ef59" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir">持久卷</strong>:</li></ul><figure class="mt mu mv mw gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7144" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保将“volumeHandle”(第15行)替换为适当的EFS文件系统ID: <code class="fe md me mf mg b">aws efs describe-file-systems --query "FileSystems[*].FileSystemId" --output text</code></p><ul class=""><li id="4d02" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir">持久卷索赔</strong>:</li></ul><figure class="mt mu mv mw gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><ul class=""><li id="90ad" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir">存储类</strong>:</li></ul><figure class="mt mu mv mw gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="50f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获得PVC将显示我们绑定如下:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="09ef" class="mh la iq mg b gy nb nc l nd ne">kubectl get pvc</span><span id="bb86" class="mh la iq mg b gy nf nc l nd ne">NAME        STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><span id="834c" class="mh la iq mg b gy nf nc l nd ne">efs-claim   Bound    efs-pv   5Gi        RWX            efs-sc         5s</span></pre><ul class=""><li id="acf6" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir">机密:N </strong>注意敏感信息已被删除。请在使用yaml之前输入它。此外，由于某种原因，我不能在Secrets中使用嵌套变量:(。</li></ul><p id="1e30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">申请密码:</strong></p><figure class="mt mu mv mw gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3483" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意第16行，确保提供我们稍后将为Postgres数据库创建的相同服务名。这确保了应用程序可以使用内部服务在内部连接到数据库。</p><p id="3f75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据库的秘密:</strong></p><figure class="mt mu mv mw gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d320" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用“<em class="nq">描述机密</em>”调用来验证机密:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="b682" class="mh la iq mg b gy nb nc l nd ne">kubectl describe secrets  postgres-secret</span><span id="d5e5" class="mh la iq mg b gy nf nc l nd ne">Name:         postgres-secret<br/>Namespace:    default<br/>Labels:       &lt;none&gt;<br/>Annotations:  &lt;none&gt;</span><span id="c635" class="mh la iq mg b gy nf nc l nd ne">Type:  Opaque</span><span id="ee3d" class="mh la iq mg b gy nf nc l nd ne">Data<br/>====<br/>POSTGRES_USER:      6 bytes<br/>DATA_SOURCE_NAME:   70 bytes<br/>POSTGRES_DB:        14 bytes<br/>POSTGRES_PASSWORD:  6 bytes</span></pre><h2 id="4589" class="mh la iq bd lb mi mj dn lf mk ml dp lj jy mm mn ln kc mo mp lr kg mq mr lv ms bi translated">设置数据库容器:</h2><ul class=""><li id="13b6" class="kl km iq jp b jq lx ju ly jy nr kc ns kg nt kk kq kr ks kt bi translated"><strong class="jp ir"> Postgres有状态集:</strong></li></ul><p id="b522" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们部署数据库容器。为此，我们将使用statefulsets。请看看下面的数据库yaml文件:</p><figure class="mt mu mv mw gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e597" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第7行到第12行是不言自明的，因为我们指定了这个statefulset将使用的服务，还指定了需要附加(或标记)到这个statefulset要附加到的所有pod的选择器。</p><p id="8745" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从第15行到第18行，我们将相同的标签应用于我们在第9行中为Statefulsets选择的pod。</p><p id="1b1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第21行，我们使用Dockerhub中的postgres图像。第26行，我们引用了之前为环境变量创建的postgres秘密。</p><p id="a479" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第30行到第32行，我们指定了用于数据库的存储解决方案。我们将使用前面定义的PVC。对于statefulset，需要在“卷”部分定义存储解决方案。我们在第40行中指定了这个部分。在第43行，我们指定了PVC名称作为我们要使用的存储解决方案。</p><p id="9221" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Line #31 " <em class="nq"> mountPath </em>"定义postgres数据在Pod中的实际存储位置。实际上，我们将提供的本地卷将映射到pod中的路径“<em class="nq"> /var/lib/postgresql/data </em>”。该路径取自postgres Docker <a class="ae mc" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank">网站</a>的默认环境变量PGDATA。</p><p id="747c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为数据指定正确的postgres路径非常重要，否则容器将无法与其存储的数据库建立连接(您将得到<code class="fe md me mf mg b">No PostgreSQL clusters exist</code>错误)。</p><p id="ec12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在创建这个statefulset之前，确保您的EFS已经正确安装了所有子网。如果您正确地遵循了之前的步骤，现在就不会有问题了。</p><ul class=""><li id="9a68" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir"> Postgres服务:</strong></li></ul><p id="d87c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里没有什么，只是为端口5432创建了一个内部服务:</p><figure class="mt mu mv mw gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="10bf" class="mh la iq bd lb mi mj dn lf mk ml dp lj jy mm mn ln kc mo mp lr kg mq mr lv ms bi translated">设置应用程序容器:</h2><p id="208e" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">非常简单。繁重的工作是在设置存储解决方案时完成的。现在，我们只需使用之前上传的映像创建一个内部服务和部署。</p><ul class=""><li id="52b8" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir">部署Yaml </strong>:</li></ul><figure class="mt mu mv mw gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><ul class=""><li id="1432" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><strong class="jp ir">服务Yaml </strong>:</li></ul><figure class="mt mu mv mw gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3ebc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一切都应该很好地完成，并运行到这一点:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="eadf" class="mh la iq mg b gy nb nc l nd ne">➜  kubectl get all                                                  <br/>NAME                                         READY   STATUS    RESTARTS   AGE<br/>pod/fullstack-app-postgres-bf57ff694-zsbs7   1/1     Running   0          6m57s<br/>pod/fullstack-postgres-0                     2/2     Running   0          77m</span><span id="c6ed" class="mh la iq mg b gy nf nc l nd ne">NAME                             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE<br/>service/fullstack-app-postgres   ClusterIP   10.100.51.249   &lt;none&gt;        8080/TCP   6m25s<br/>service/fullstack-postgres       ClusterIP   10.100.166.85   &lt;none&gt;        5432/TCP   18m<br/>service/kubernetes               ClusterIP   10.100.0.1      &lt;none&gt;        443/TCP    158m</span><span id="8975" class="mh la iq mg b gy nf nc l nd ne">NAME                                     READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/fullstack-app-postgres   1/1     1            1           7m</span><span id="8318" class="mh la iq mg b gy nf nc l nd ne">NAME                                               DESIRED   CURRENT   READY   AGE<br/>replicaset.apps/fullstack-app-postgres-bf57ff694   1         1         1       7m1s</span><span id="3be8" class="mh la iq mg b gy nf nc l nd ne">NAME                                  READY   AGE<br/>statefulset.apps/fullstack-postgres   1/1     77m</span></pre><h1 id="9e34" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">步骤4:使用Ingress对外公开应用程序:</h1><p id="aaf8" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">为了使用入口，我们需要入口控制器。对于AWS Fargate，我们将使用AWS负载平衡器控制器来设置我们的入口。我们简单地按照AWS博客<a class="ae mc" href="https://aws.amazon.com/premiumsupport/knowledge-center/eks-alb-ingress-controller-fargate/" rel="noopener ugc nofollow" target="_blank">这里</a>(在测试负载平衡器部分之前)安装AWS负载平衡器控制器。</p><p id="41e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们将只使用Ingress公开我们的内部应用程序服务，而不是数据库服务。内部应用程序使用我们秘密提供的localhost和clusterIP服务自动连接数据库。</p><p id="09e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住这些事情，一旦配置了负载平衡器，就使用下面的入口Yaml:</p><figure class="mt mu mv mw gt ng"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="426c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第7行到第9行是Fargate所需的注释。第14行是入口将路由到的实际路径。我把所有路径都放在这里，因为我们只有一个端点/live可以工作。当我们添加新的端点时，我们可以在这里更新入口。第16行是要连接的后端服务。注意，在我们的应用程序中，只配置了/live API调用。所有其他API将给出404未找到错误。</p><p id="14c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦应用了入口，我们可以按如下方式检查入口地址:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="0539" class="mh la iq mg b gy nb nc l nd ne">kubectl get ingress</span><span id="1f4f" class="mh la iq mg b gy nf nc l nd ne">NAME          CLASS    HOSTS   ADDRESS                                                                 PORTS   AGE</span><span id="2e23" class="mh la iq mg b gy nf nc l nd ne">ingress-app   &lt;none&gt;   *       k8s-default-ingressa-1234567890.us-east-1.elb.amazonaws.com   80      4m55s</span></pre><p id="0069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用浏览器中的地址访问我们的应用程序:</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="3fa9" class="mh la iq mg b gy nb nc l nd ne"><a class="ae mc" href="http://k8s-default-ingressa-1234567890.us-east-1.elb.amazonaws.com/live" rel="noopener ugc nofollow" target="_blank">http://k8s-default-ingressa-1234567890.us-east-1.elb.amazonaws.com/live</a></span><span id="0407" class="mh la iq mg b gy nf nc l nd ne">Well done :)</span></pre><h2 id="fdbc" class="mh la iq bd lb mi mj dn lf mk ml dp lj jy mm mn ln kc mo mp lr kg mq mr lv ms bi translated">使用TLS保护应用程序:</h2><p id="220c" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">很高兴能走到这一步。到目前为止，我们使用HTTP连接到我们的应用程序。这是非常错误的，因为我们需要HTTPS并使用TLS保护我们的应用程序。</p><p id="25ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有4种主要的TLS终端。每个步骤都在附加的链接中提供:</p><ul class=""><li id="7d9d" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">负载均衡器处的<a class="ae mc" href="https://aws.amazon.com/premiumsupport/knowledge-center/terminate-https-traffic-eks-acm/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a>:最常见的场景，我们将在这里实现。这是使用公共信任的ACM证书完成的。该证书将被绑定到负载平衡器本身。</li><li id="6d5b" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae mc" href="https://aws.amazon.com/blogs/security/tls-enabled-kubernetes-clusters-with-acm-private-ca-and-amazon-eks-2/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">在入口</strong> </a>:我们可以将整个TLS卸载到入口控制器为我们完成。通常使用私有CA完成。</li><li id="c151" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae mc" href="https://aws.amazon.com/blogs/containers/setting-up-end-to-end-tls-encryption-on-amazon-eks-with-the-new-aws-load-balancer-controller/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a>:端到端加密，最安全。再次使用私有CA实现。</li><li id="07cc" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated"><a class="ae mc" href="https://www.jetstack.io/blog/cert-manager-istio-integration/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">相互TLS </strong> </a>:吊舱间TLS通信。通常通过使用Istio、私有CA和证书管理器来完成。</li></ul><p id="e95c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的场景，首先我们需要购买自定义域，并在Route53中注册它。我已经准备好了。接下来，我们需要获得ACM证书。只需进入AWS控制台中的ACM，请求一个公共ACM证书，输入您的域名，点击DNS验证，然后点击请求。</p><figure class="mt mu mv mw gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nu"><img src="../Images/db230651c4b3974f924dcdaa5030d96e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_EndevuO2wiDFFNaWAoJqg.png"/></div></div></figure><p id="fca8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，单击Route53窗口中的证书，并单击验证待定的“在Route 53中创建记录”。这将为ACM的验证创建DNS记录。一段时间后，在ACM窗口中，您可以看到证书已颁发。完成这一步后，只需复制证书的ARN。</p><figure class="mt mu mv mw gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nv"><img src="../Images/9d141b78d4fda3e7a9061edf6a2251d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*APEsy-zIYrdewdv2TIkSZw.png"/></div></div></figure><p id="406a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AWS中剩下的最后一步是创建一个子域名，并将其与我们的ELB相关联。这很简单。转到Route53控制台，并选择您的域。在那里，“创建记录”，把你想要使用的域名，然后打开别名，指向你的ALB。查看这个<a class="ae mc" href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-elb-load-balancer.html#routing-to-elb-load-balancer-configuring" rel="noopener ugc nofollow" target="_blank">博客</a>了解更多信息。</p><figure class="mt mu mv mw gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nw"><img src="../Images/dbd394c32a7d914de29ced8f71cf4282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMWV9Dh6Zd1IDukc_fzlVQ.png"/></div></div></figure><p id="4d6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在Kubernetes中，我们只需编辑现有的入口并添加证书注释，如<a class="ae mc" href="https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.2/guide/ingress/annotations/#ssl" rel="noopener ugc nofollow" target="_blank">文档</a>中所给出的。</p><pre class="mt mu mv mw gt mx mg my mz aw na bi"><span id="5e10" class="mh la iq mg b gy nb nc l nd ne">kubectl edit ingress ingress-app</span><span id="6d50" class="mh la iq mg b gy nf nc l nd ne"><strong class="mg ir">Add following annotation and save the file:<br/></strong>alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:us-west-2:xxxxx:certificate/xxxxxxx</span></pre><p id="3b40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦入口更新，您可以使用自定义域访问您的ELB，它将只适用于HTTPS！</p><h1 id="770f" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结束了！</h1><p id="a06c" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">关于使用Fargate创建端到端二层EKS解决方案的文章到此结束。我们定义了一个Dockerimage，在本地测试了它，然后设置了必要的Kubernetes资源。我们创建了必要的EFS解决方案，并围绕它创建了有状态工作负载。最后，我们使用Ingress公开了我们的应用程序，并使用自定义域和TLS保护它。本博客使用的所有回购和代码都可以在我的github回购<a class="ae mc" href="https://github.com/gravito/simpleservice" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="18ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一部分中，我们将通过使用Jenkins创建CI/CD解决方案来扩展该应用程序，并添加监控解决方案来使用sidecar代理抓取数据库指标。务必在此处检查后续部件<a class="ae mc" href="https://medium.com/@shrut_terminator/how-to-monitor-your-database-statefulsets-using-prometheus-grafana-and-enable-ci-cd-using-1b8a1447529a" rel="noopener">。</a></p><p id="c66c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望读者能更清楚地了解如何在Fargate上设置有状态工作负载。Fargate是一个有趣的无服务器概念，看到它向前发展有多远将是令人兴奋的！现在快乐Kubernetes:)。</p></div></div>    
</body>
</html>