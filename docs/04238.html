<html>
<head>
<title>Advanced pytest techniques I learned while contributing to pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在为熊猫做贡献时学到的高级pytest技术</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/advanced-pytest-techniques-i-learned-while-contributing-to-pandas-7ba1465b65eb?source=collection_archive---------6-----------------------#2020-06-16">https://levelup.gitconnected.com/advanced-pytest-techniques-i-learned-while-contributing-to-pandas-7ba1465b65eb?source=collection_archive---------6-----------------------#2020-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jp jq jr js gh gi paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gh gi jo"><img src="../Images/5d242cf4322d14884ebc87d555301bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvLEl2aCwzCzFjldBRkq9g.jpeg"/></div></div></figure><p id="ffee" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在过去的几个月里，我向<code class="fe kx ky kz la b"><a class="ae lb" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">pandas</a></code>贡献了相当多的PRs，这是Python优秀的数据处理生态系统核心的开源数据分析和操作库。</p><p id="d6ea" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">由于<code class="fe kx ky kz la b">pandas</code>已经有10多年的历史了，包含了超过50万行代码，没有人能够知道一个简单的代码变化的所有后果。因此，我们需要依靠我们的测试套件来避免不断破坏数百万用户代码的风险，并且广泛覆盖角落和边缘案例是至关重要的。</p><p id="3324" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在本文中，我想分享我在那段时间学到的一些高级pytest特性。我假设对<code class="fe kx ky kz la b"><a class="ae lb" href="https://docs.pytest.org/en/stable/" rel="noopener ugc nofollow" target="_blank">pytest</a></code>有基本的了解，包括夹具、常规参数化和测试异常。如果你不熟悉这些，我推荐你先看看realpython.com的pytest教程。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="c249" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><strong class="ak">参数化您的夹具</strong></h1><p id="a670" class="pw-post-body-paragraph jz ka iq kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ij bi translated">我非常喜欢测试中的参数化。这是一种测试多种配置的优雅而简洁的方法，目的是找出程序中的错误，增强对应用程序的信心。我不知道的是，你甚至可以直接参数化fixtures，而不仅仅是测试用例。</p><p id="5ebb" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">例如，我们广泛使用我们钟爱的<code class="fe kx ky kz la b"><a class="ae lb" href="https://github.com/pandas-dev/pandas/blob/master/pandas/conftest.py#L388-L422" rel="noopener ugc nofollow" target="_blank">index</a></code>夹具，它为我们提供了各种不同的<code class="fe kx ky kz la b">Index</code>实例:</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="f5f7" class="mu lk iq la b gy mv mw l mx my">indices_dict = {<br/>    <strong class="la ir">"unicode"</strong>: tm.makeUnicodeIndex(100),<br/>    <strong class="la ir">"string"</strong>: tm.makeStringIndex(100),<br/>    <strong class="la ir">"datetime"</strong>: tm.makeDateIndex(100),<br/>    <strong class="la ir">"datetime-tz"</strong>: tm.makeDateIndex(100, tz="US/Pacific"),<br/>    <strong class="la ir">"period"</strong>: tm.makePeriodIndex(100),<br/>    <strong class="la ir">"timedelta"</strong>: tm.makeTimedeltaIndex(100),<br/>    <strong class="la ir">"int"</strong>: tm.makeIntIndex(100),<br/>    <strong class="la ir">"uint"</strong>: tm.makeUIntIndex(100),<br/>    <strong class="la ir">"range"</strong>: tm.makeRangeIndex(100),<br/>    <strong class="la ir">"float"</strong>: tm.makeFloatIndex(100),<br/>    <strong class="la ir">"bool"</strong>: tm.makeBoolIndex(10),<br/>    <strong class="la ir">"categorical"</strong>: tm.makeCategoricalIndex(100),<br/>    <strong class="la ir">"interval"</strong>: tm.makeIntervalIndex(100),<br/>    <strong class="la ir">"empty"</strong>: Index([]),<br/>    <strong class="la ir">"tuples"</strong>: MultiIndex.from_tuples(zip(["foo", "bar", "baz"], [1, 2, 3])),<br/>    <strong class="la ir">"mi-with-dt64tz-level"</strong>: _create_mi_with_dt64tz_level(),<br/>    <strong class="la ir">"multi"</strong>: _create_multiindex(),<br/>    <strong class="la ir">"repeats"</strong>: Index([0, 0, 1, 1, 2, 2]),<br/>}<br/><br/><br/>@pytest.fixture(params=indices_dict.keys())<br/>def index(request):<br/>    <em class="mz">"""<br/>    Fixture for many "simple" kinds of indices.<br/>    These indices are unlikely to cover corner cases, e.g.<br/>        - no names<br/>        - no NaTs/NaNs<br/>        - no values near implementation bounds<br/>        - ...<br/>    """<br/>    </em># copy to avoid mutation, e.g. setting .name<br/>    return indices_dict[request.param].copy()</span></pre><p id="23d5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">让我们用一个小例子来实现这一点:运行下面的测试</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="7140" class="mu lk iq la b gy mv mw l mx my">def test_indices(index):<br/>    assert isinstance(index, pd.Index)</span></pre><p id="51b7" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">生产</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="5944" class="mu lk iq la b gy mv mw l mx my">test_example.py::test_indices[unicode] PASSED<br/>test_example.py::test_indices[string] PASSED<br/>test_example.py::test_indices[datetime] PASSED<br/>test_example.py::test_indices[datetime-tz] PASSED<br/>test_example.py::test_indices[period] PASSED<br/>test_example.py::test_indices[timedelta] PASSED<br/>test_example.py::test_indices[int] PASSED<br/>test_example.py::test_indices[uint] PASSED<br/>test_example.py::test_indices[range] PASSED<br/>test_example.py::test_indices[float] PASSED<br/>test_example.py::test_indices[bool] PASSED<br/>test_example.py::test_indices[categorical] PASSED<br/>test_example.py::test_indices[interval] PASSED<br/>test_example.py::test_indices[empty] PASSED<br/>test_example.py::test_indices[tuples] PASSED<br/>test_example.py::test_indices[mi-with-dt64tz-level] PASSED<br/>test_example.py::test_indices[multi] PASSED<br/>test_example.py::test_indices[repeats] PASSED</span></pre><p id="3281" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">那不是很方便吗？我们可以编写一个测试，就像我们使用一个常规的fixture一样，每个fixture值<code class="fe kx ky kz la b">pytest</code>自动执行一次！</p><p id="5b97" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">在pandas，这很好，因为我们提供了大量不同的指数，这些指数有时(由于历史或性能原因)不共享一个通用的实现。参数化的夹具让我们不必对此想太多。如果一个测试用例应该适用于所有的索引，我们可以使用<code class="fe kx ky kz la b">index</code> fixture并自动覆盖所有的索引类型。这很有效:通过在我们的测试套件中应用更多的参数化夹具，我实际上发现了我们没有覆盖的bug。</p><p id="9ab5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我不认为参数化fixtures对于每个代码库都是必不可少的，但是在以下两种情况下它们会派上用场:</p><ol class=""><li id="06ae" class="na nb iq kb b kc kd kg kh kk nc ko nd ks ne kw nf ng nh ni bi translated">您希望确保无法仅通过继承来保证的通用功能(就像上面的例子)。</li><li id="763c" class="na nb iq kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated">您拥有在多个测试中使用的公共参数，例如，多个功能接受相同的参数(<a class="ae lb" href="https://github.com/pandas-dev/pandas/blob/master/pandas/conftest.py#L147-L253" rel="noopener ugc nofollow" target="_blank">见此处</a>)。</li></ol><p id="6004" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><em class="mz">注意:即使参数化夹具有多个值，你也应该给它们一个单数名称。</em></p><h1 id="d22f" class="lj lk iq bd ll lm no lo lp lq np ls lt lu nq lw lx ly nr ma mb mc ns me mf mg bi translated">在参数化中设置id</h1><p id="29fe" class="pw-post-body-paragraph jz ka iq kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ij bi translated">另一个(相关的)我以前没有使用的特性是在参数化中指定<code class="fe kx ky kz la b">ids</code>。大多数时候这是不必要的，因为<code class="fe kx ky kz la b">pytest</code>会找到好的默认值。然而，有时这些默认值很难读懂或者不够简洁。举以下例子:</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="5400" class="mu lk iq la b gy mv mw l mx my">@pytest.mark.parametrize("obj", [pd.Index([]), pd.Series([])])<br/>def test_with_ids(obj):<br/>    assert obj.empty</span></pre><p id="8a8d" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">运行该测试会导致</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="e557" class="mu lk iq la b gy mv mw l mx my">test_example.py::test_with_ids[<strong class="la ir">obj0</strong>] PASSED                                                                                                      <br/>test_example.py::test_with_ids[<strong class="la ir">obj1</strong>] PASSED</span></pre><p id="d168" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">万一将来其中一次运行失败，您总是需要通过计算参数化值来导出失败的配置。也就是说，如果<code class="fe kx ky kz la b">obj1</code>失败，你必须搜索第二个参数化值。虽然这种方法有效，但它相当烦人。一个更好的替代方法是手动覆盖id</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="1c1d" class="mu lk iq la b gy mv mw l mx my">@pytest.mark.parametrize(<br/>    "obj",<br/>    [pd.Index([]), pd.Series([])]<strong class="la ir">,<br/>    ids=["Index", "Series"]<br/></strong>)<br/>def test_with_ids(obj):<br/>    assert obj.empty</span></pre><p id="3b04" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">或者传递一个可调用函数来隐式派生id</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="41cf" class="mu lk iq la b gy mv mw l mx my">@pytest.mark.parametrize(<br/>    "obj",<br/>    [pd.Index([]), pd.Series([])]<strong class="la ir">,<br/>    ids=lambda x: type(x).__name__<br/></strong>)<br/>def test_with_ids(obj):<br/>    assert obj.empty</span></pre><p id="bee1" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">两种方法都产生</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="b37f" class="mu lk iq la b gy mv mw l mx my">test_example.py::test_with_ids[<strong class="la ir">Index</strong>] PASSED                                                                                                      <br/>test_example.py::test_with_ids[<strong class="la ir">Series</strong>] PASSED</span></pre><p id="53e1" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><em class="mz">注意:上面的例子集中于参数化测试，但是当参数化夹具时，它以同样的方式工作。</em></p><h1 id="3112" class="lj lk iq bd ll lm no lo lp lq np ls lt lu nq lw lx ly nr ma mb mc ns me mf mg bi translated">在测试中调用skip或xfail</h1><p id="d645" class="pw-post-body-paragraph jz ka iq kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ij bi translated">通常，当您想要<code class="fe kx ky kz la b">skip</code>或<code class="fe kx ky kz la b">xfail</code>一个测试时，您会使用<code class="fe kx ky kz la b">pytest</code>优雅的修饰语法。但是，有时您需要检查的条件只有在运行时才可用。在这种情况下，您也可以在测试逻辑内部调用<code class="fe kx ky kz la b">pytest.skip</code>或<code class="fe kx ky kz la b">pytest.xfail</code>:</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="dcce" class="mu lk iq la b gy mv mw l mx my">def test_indexing(index):<br/>    if len(index) == 0:<br/>        pytest.skip("Test case is not applicable for empty data.")<br/>    index[0]</span></pre><p id="f5bd" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这产生了</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="9eeb" class="mu lk iq la b gy mv mw l mx my">test_example.py::test_indexing[unicode] PASSED<br/>test_example.py::test_indexing[string] PASSED<br/>test_example.py::test_indexing[datetime] PASSED<br/>test_example.py::test_indexing[datetime-tz] PASSED<br/>test_example.py::test_indexing[period] PASSED<br/>test_example.py::test_indexing[timedelta] PASSED<br/>test_example.py::test_indexing[int] PASSED<br/>test_example.py::test_indexing[uint] PASSED<br/>test_example.py::test_indexing[range] PASSED<br/>test_example.py::test_indexing[float] PASSED<br/>test_example.py::test_indexing[bool] PASSED<br/>test_example.py::test_indexing[categorical] PASSED<br/>test_example.py::test_indexing[interval] PASSED<br/><strong class="la ir">test_example.py::test_indexing[empty] SKIPPED</strong><br/>test_example.py::test_indexing[tuples] PASSED<br/>test_example.py::test_indexing[mi-with-dt64tz-level] PASSED<br/>test_example.py::test_indexing[multi] PASSED<br/>test_example.py::test_indexing[repeats] PASSED</span></pre><p id="f12a" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><em class="mz">注意:虽然这种可能性很大，但它也有不利的一面，那就是建立一个在结果中被有效忽略的测试运行。因此，装饰语法应该总是首选(如果可能的话)，因为它已经可以在测试集合中进行评估。</em></p><h1 id="3d05" class="lj lk iq bd ll lm no lo lp lq np ls lt lu nq lw lx ly nr ma mb mc ns me mf mg bi translated">间接参数化</h1><p id="7baf" class="pw-post-body-paragraph jz ka iq kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ij bi translated">有时，您只想使用夹具参数化值的子集。例如，如果您想使用<code class="fe kx ky kz la b">index</code>夹具，但您只想使用它的<code class="fe kx ky kz la b">MultiIndex</code>值，您会怎么做？那么你有以下选择:</p><ol class=""><li id="da44" class="na nb iq kb b kc kd kg kh kk nc ko nd ks ne kw nf ng nh ni bi translated">使用新的参数化或夹具(→多余)</li><li id="e19a" class="na nb iq kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated">使用明确的<code class="fe kx ky kz la b">pytest.skip</code>(→创建未使用的测试运行)</li><li id="3605" class="na nb iq kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated">使用间接参数化</li></ol><p id="1fb5" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我们已经讨论了第2点，让我们来看看选项3:</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="b3ef" class="mu lk iq la b gy mv mw l mx my">@pytest.mark.parametrize(<br/>    "index",<br/>    ["mi-with-dt64tz-level", "multi"],<br/>    indirect=True<br/>)<br/>def test_dummy(index):<br/>    assert isinstance(index, pd.MultiIndex)</span></pre><p id="1df0" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">语法一开始可能有点让人不知所措，但实际上很有意义(像往常一样):首先，将参数化的fixture添加到签名中。然后，将参数化添加到您指定的测试函数中</p><ol class=""><li id="a10c" class="na nb iq kb b kc kd kg kh kk nc ko nd ks ne kw nf ng nh ni bi translated">要间接参数化的夹具</li><li id="0039" class="na nb iq kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated">您要选择的值</li><li id="475e" class="na nb iq kb b kc nj kg nk kk nl ko nm ks nn kw nf ng nh ni bi translated">将<code class="fe kx ky kz la b">indirect</code>标志设置为<code class="fe kx ky kz la b">True</code></li></ol><p id="dff3" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">这会导致以下两次测试运行:</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="a00e" class="mu lk iq la b gy mv mw l mx my">test_example.py::test_multiindex[mi-with-dt64tz-level] PASSED<br/>test_example.py::test_multiindex[multi] PASSED</span></pre><p id="1ca0" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">我认为这种方法的主要缺点是它要求您手动指定fixture值。因此，如果我们向我们的<code class="fe kx ky kz la b">index</code>夹具添加一个新的<code class="fe kx ky kz la b">MultiIndex</code>值，间接参数化不能自动选取它。因此，您必须权衡使用这三种方法中的哪一种。</p><p id="f2e1" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">如果你想深入这个话题，我推荐你阅读pytest-tricks 上的这篇文章，这篇文章提供了更多的背景知识。</p><h1 id="2e7f" class="lj lk iq bd ll lm no lo lp lq np ls lt lu nq lw lx ly nr ma mb mc ns me mf mg bi translated">pytest.raises vs nullcontext</h1><p id="4bff" class="pw-post-body-paragraph jz ka iq kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ij bi translated">本文的最后一部分讨论了在处理参数化时可能会遇到的冗余。更具体地说，当您测试只在一些参数化值中出现，而在其他参数化值中没有出现的异常时。举以下例子:</p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="8f1d" class="mu lk iq la b gy mv mw l mx my">@pytest.mark.parametrize(<br/>    "obj, raises",<br/>    [<br/>        ([], False),<br/>        (pd.Index([]), True),<br/>    ],<br/>)<br/>def test_exception(obj, raises):<br/>    if raises:<br/>        with pytest.raises(ValueError):<br/>            # you should also test the error message, using<br/>            # the 'matches' parameter in .raises()<br/>            # I don't have enough space here though...<br/>            bool(obj)<br/>    else:<br/>        bool(obj)</span></pre><p id="31b9" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">当测试变得比这个最小的例子更大时，调用<code class="fe kx ky kz la b">bool(obj)</code>两次的冗余可能会很烦人。</p><p id="c230" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">经过一番挖掘之后，我在pytest GitHub页面中偶然发现了<a class="ae lb" href="https://github.com/pytest-dev/pytest/issues/1830" rel="noopener ugc nofollow" target="_blank">这条线索，有人最终建议使用<code class="fe kx ky kz la b">contextlib.nullcontext</code>:</a></p><pre class="mm mn mo mp gt mq la mr ms aw mt bi"><span id="00c9" class="mu lk iq la b gy mv mw l mx my">from contextlib import nullcontext<br/><br/><br/>@pytest.mark.parametrize(<br/>    "obj, expected_raises",<br/>    [<br/>        ([], nullcontext()),<br/>        (pd.Index([]), pytest.raises(ValueError)),<br/>    ],<br/>)<br/>def test_exception2(obj, expected_raises):<br/>    with expected_raises:<br/>        bool(obj)</span></pre><p id="fbe8" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated"><em class="mz">注意:</em> <code class="fe kx ky kz la b"><em class="mz">contextlib.nullcontext</em></code> <em class="mz">仅在Python3.7之后可用。如果您使用的是更早的版本，</em> <a class="ae lb" href="https://github.com/pytest-dev/pytest/issues/1830#issuecomment-425653756" rel="noopener ugc nofollow" target="_blank"> <em class="mz">请在提到的线程</em> </a> <em class="mz">中查看此评论。</em></p><p id="bd10" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">但是，请不要过度使用这个特性。虽然对于简单的用例来说，这是一种优雅的方式，但它也鼓励您对不同的行为使用参数化，而单独的测试会更合适。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="d371" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="b073" class="pw-post-body-paragraph jz ka iq kb b kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw ij bi translated">虽然还有很多更棒的<code class="fe kx ky kz la b">pytest</code>特性我没有谈到，但我希望你和我一样喜欢探索这些特性。</p><p id="dcdf" class="pw-post-body-paragraph jz ka iq kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ij bi translated">为开源项目做贡献通常是发现和学习新概念或新技术的好机会，同时也是回报社区的好机会。因此，如果您还没有，请继续检查您感兴趣的或已经使用的开源项目中尚未解决的问题。这对你和其他人来说都是双赢的；)</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><div class="mm mn mo mp gt nt"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">编写面试问题</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">技术开发</p></div></div><div class="oc l"><div class="od l oe of og oc oh jx nt"/></div></div></a></div></div></div>    
</body>
</html>