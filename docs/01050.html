<html>
<head>
<title>Build a Video Conferencing App Using Dolby Voxeet and Stream Chat with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dolby Voxeet构建视频会议应用程序，并使用React进行流聊天</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-video-conferencing-app-using-dolby-voxeet-and-stream-chat-901e9180d38c?source=collection_archive---------1-----------------------#2019-10-30">https://levelup.gitconnected.com/build-a-video-conferencing-app-using-dolby-voxeet-and-stream-chat-901e9180d38c?source=collection_archive---------1-----------------------#2019-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a78d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着最近推出的<a class="ae ko" href="https://getstream.io/chat/" rel="noopener ugc nofollow" target="_blank">流聊天</a>，这里的团队一直在与供应商合作，为各种平台添加实时聊天和消息。我们收到了一些语音和视频聊天的请求，在环顾市场后，与<a class="ae ko" href="https://www.voxeet.com/" rel="noopener ugc nofollow" target="_blank"> Voxeet </a>(最近被杜比收购)合作是一个明确的选择。证据就在布丁中，所以我们使用流聊天和Voxeet为一个实时视频会议应用程序构建了一个全功能的概念证明。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/d561293fded778c33ba897c18e3ad841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xPKJiStZZ9pwskwh"/></div></div></figure><p id="da03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着最近<a class="ae ko" href="https://getstream.io/chat/" rel="noopener ugc nofollow" target="_blank">流聊天</a>的推出，这里的团队一直在与供应商合作，为各种平台添加实时聊天和消息。我们收到了一些语音和视频聊天的请求，在环顾市场后，与<a class="ae ko" href="https://voxeet.com" rel="noopener ugc nofollow" target="_blank"> Voxeet </a>(最近被<a class="ae ko" href="https://dolby.com" rel="noopener ugc nofollow" target="_blank"> Dolby </a>收购)合作是一个明确的选择。证据还在酝酿中，所以我们使用Stream Chat和Voxeet作为React的web应用程序，为一个实时视频会议应用程序构建了一个全功能的概念证明。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/8063712b41ce5a31c8bfacefa965ad0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o0fbbkG_KopkZ1HU"/></div></div></figure><p id="99dc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们之所以决定使用Voxeet，而不是其他竞争对手，例如Twilio的可编程视频平台，主要是出于以下原因:</p><ul class=""><li id="9036" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated"><a class="ae ko" href="https://voxeet.com" rel="noopener ugc nofollow" target="_blank"> Voxeet </a>是视频领域的行业领导者，提供流行语言的SDKs您可以选择JavaScript、iOS (Swift)或Android (Java)</li><li id="01d1" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">可预测且慷慨的<a class="ae ko" href="https://www.voxeet.com/pricing/" rel="noopener ugc nofollow" target="_blank">定价</a>完全合理的模式——基于语音和视频的时长</li><li id="0ca4" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">他们的<a class="ae ko" href="https://developer.voxeet.com/getstarted/javascript/getstarted-javascript/" rel="noopener ugc nofollow" target="_blank">文档</a>是为开发人员编写的，重点是如何集成——包括开始时很好的示例教程</li><li id="5a0f" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">它们提供了一个React集成，可与<a class="ae ko" href="https://getstream.github.io/stream-chat-react/" rel="noopener ugc nofollow" target="_blank">流聊天React组件</a>完美配合，使开发人员能够轻松访问底层Voxeet API并将其与流聊天连接</li></ul><p id="41a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们的初步测试表明，与Twilio相比，Voxeet的延迟大大降低，并且在实时视频(及其视频会议API)方面提供了更高的清晰度。有了更好的文档，我们提前知道我们将能够执行而不会遇到任何问题。</p><p id="916b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章的其余部分，我们将概述我们如何在不到一周的时间内着手构建一个类似于<a class="ae ko" href="https://zoom.us/" rel="noopener ugc nofollow" target="_blank"> Zoom </a>(视频通信工具)的竞争对手。我们将使用Voxeet进行实时视频(通过<a class="ae ko" href="https://webrtc.org/" rel="noopener ugc nofollow" target="_blank"> WebRTC </a>)以及<a class="ae ko" href="https://getstream.io/chat/" rel="noopener ugc nofollow" target="_blank">流聊天</a>进行实时聊天/信息传递。</p><blockquote class="lp lq lr"><p id="2311" class="jq jr ls js b jt ju jv jw jx jy jz ka lt kc kd ke lu kg kh ki lv kk kl km kn im bi translated"><strong class="js iu"> <em class="it">注</em> </strong> <em class="it"> : </em>你可以在这里找到位于<a class="ae ko" href="https://stream-dolby.netlify.com/" rel="noopener ugc nofollow" target="_blank">的演示。前端UI的完整代码可在</a><a class="ae ko" href="https://github.com/GetStream/stream-dolby-voxeet" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。如果您想使用后端API运行演示，请参见这个<a class="ae ko" href="https://github.com/GetStream/stream-dolby-voxeet-api" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p></blockquote><h1 id="f7a0" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">先决条件</h1><p id="9270" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">要完全遵循本教程，您需要确保对以下内容有一个适当的理解:</p><p id="af7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还需要确保您的计算机上安装了以下软件:</p><p id="37e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，您需要创建以下服务的免费帐户:</p><ul class=""><li id="2826" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated"><a class="ae ko" href="https://signup.heroku.com/login" rel="noopener ugc nofollow" target="_blank"> Heroku </a>(用于托管API-free层)</li><li id="d22b" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated"><a class="ae ko" href="https://getstream.io/chat/" rel="noopener ugc nofollow" target="_blank">流</a>(实时聊天功能——14天免费试用)</li><li id="4c93" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated"><a class="ae ko" href="https://developer.voxeet.com/dashboard/register" rel="noopener ugc nofollow" target="_blank"> Voxeet </a>(用于视频会议——自由层)</li></ul><h1 id="b87a" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">入门指南</h1><h1 id="5980" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">建筑</h1><p id="ca8f" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">这个应用程序的构建相当简单。它需要两个主要元素——前端UI和后端API。如果你想更进一步，你可以在Netlify上托管前端CRA应用程序，在Heroku上托管API，只需几分钟。</p><h1 id="3a02" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">步骤1:前端用户界面</h1><p id="d815" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">首先，确保你已经用<a class="ae ko" href="https://getstream.io/chat/" rel="noopener ugc nofollow" target="_blank"> Stream </a>和<a class="ae ko" href="https://developer.voxeet.com/dashboard/register" rel="noopener ugc nofollow" target="_blank"> Voxeet </a>建立了一个账户，并且你已经有了每个账户的所有密钥和令牌，你将需要以下内容:</p><p id="9066" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，在您的终端中运行<code class="fe mz na nb nc b">npx create-react-app stream-voxeet</code>。完成后，为了安全起见，将流API密钥和来自相关仪表板的Voxeet密钥添加到项目根目录下的一个<code class="fe mz na nb nc b">.env</code>文件中。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/37c4806c03662c1d6e23f1337de06020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sf_737hsMIRc0RNm"/></div></div></figure><p id="f256" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在您的<code class="fe mz na nb nc b">.env</code>文件中，您将需要以下环境变量:</p><ul class=""><li id="ca82" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">反应_应用_流_键</li><li id="692d" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">REACT_APP_VOX_KEY</li><li id="9076" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">反应_应用_声音_秘密</li></ul><p id="9fed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到您的终端，安装项目所需的依赖项:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5f3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，在应用程序的根目录下创建一个<code class="fe mz na nb nc b">jsconfig.json</code>文件。复制并粘贴以下内容:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="eb4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们的项目已经设置好了，让我们进入代码编辑器并开始构建。</p><h1 id="e81e" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">第二步:设置</h1><p id="fe9d" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">首先，我们将设置Redux存储、中间件和样式化组件主题，并删除CRA样板文件提供的默认设置。</p><p id="8366" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将希望<em class="ls">移除<code class="fe mz na nb nc b">App.js</code>和<code class="fe mz na nb nc b">index.js</code>文件中这些资产的导入</em>，以及从<code class="fe mz na nb nc b">App.js</code>中去除所有样板标记——只留下父<code class="fe mz na nb nc b">div</code>。</p><p id="e4c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，在您的<code class="fe mz na nb nc b">/src</code>目录中创建以下目录:</p><h2 id="bc4a" class="nf lx it bd ly ng nh dn mc ni nj dp mg kb nk nl mk kf nm nn mo kj no np ms nq bi translated">风格</h2><p id="40f1" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated"><strong class="js iu">颜色</strong>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="53cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">断点</strong>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5eae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将导入这些变量来帮助填充我们的样式组件主题。然后，我们将创建一个<code class="fe mz na nb nc b">colorUtils.js</code>文件，并将以下代码粘贴到其中:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cb2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以在<code class="fe mz na nb nc b">styles/theme.js</code>中把这些都放在一起——这个主题将在我们所有的样式组件中可用，并且可以通过<code class="fe mz na nb nc b">withTheme</code> HOC访问。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="54ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们将创建<code class="fe mz na nb nc b">styles/global.js</code>。这个文件实际上是我们之前删除的<code class="fe mz na nb nc b">index.css</code>的替代文件。请注意，我们稍后还将导入两个额外的文件来覆盖stream-chat-react和voxeet的样式。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6202" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将很快在我们的<code class="fe mz na nb nc b">App.js</code>中把这一切联系在一起，但首先，我们将建立我们的Redux商店。</p><h2 id="c1f3" class="nf lx it bd ly ng nh dn mc ni nj dp mg kb nk nl mk kf nm nn mo kj no np ms nq bi translated">Redux</h2><p id="0c26" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">在您的数据目录中，添加一个名为<code class="fe mz na nb nc b">createReducer.js</code>的文件，其中包含以下代码:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e72c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下代码将把Voxeet reducer挂接到我们的Redux存储，并使<code class="fe mz na nb nc b">Conference</code>组件能够正确工作。我们还将在数据目录中创建一个<code class="fe mz na nb nc b">rootSaga.js</code>文件；然而，现在，我们将把它留为空白，以后再来讨论它。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="faf8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们在<code class="fe mz na nb nc b">data/createStore.js</code>中创建Redux store本身，以便将它们联系在一起——我们将在Voxeet组件中添加所需的thunk中间件，以及redux-saga中间件，稍后当我们向应用程序添加简单的身份验证以及一些其他有趣的东西时，我们将使用该中间件。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4ec0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在准备开始包括Voxeet的组件，稍后还将包括流聊天。然而，您现在应该从上面的文件中获得两个缺失的导入。一个是我们马上要创建的会议屏幕。另一个是<code class="fe mz na nb nc b">utils/history.js</code>。</p><p id="0faf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过以这种方式导入<code class="fe mz na nb nc b">history</code>，我们可以将它传递给上面文件中的<code class="fe mz na nb nc b">Router</code>，它将与react-router v4的<code class="fe mz na nb nc b">BrowserRouter</code>操作相同。我们也可以在我们的传奇中(以及我们代码中的任何地方)导入它，以便在不使用<code class="fe mz na nb nc b">&lt;Link /&gt;</code>的情况下以编程方式导航，或者在<code class="fe mz na nb nc b">history</code>属性不可访问的区域导航。</p><p id="8e50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是历史实用程序的代码:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="1544" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">步骤3:初始化Voxeet</h1><p id="7050" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">我们将从创建会议屏幕开始，视频通话将在这个屏幕上进行。在您的<code class="fe mz na nb nc b">screens</code>目录中创建<code class="fe mz na nb nc b">Conference/Conference.js</code>，在您的编辑器中打开它并粘贴以下内容:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4517" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您现在应该能够转到<code class="fe mz na nb nc b">http://localhost:3000/test</code>查看完全正常的视频通话屏幕。Voxeet组件棒极了。开箱即用，Voxeet为其SDK和API提供了所有可用特性的完整功能。</p><p id="6118" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们只能通过覆盖默认CSS来控制Voxeet UI的样式，用户将拥有随机生成的用户名和id。所以，让我们解决这个问题。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8a43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">传递给这些道具的组件将分别取代聊天抽屉和底部动作栏。<code class="fe mz na nb nc b">ConferenceRoom</code>将从Redux传递必要的状态作为道具，允许我们使用定制组件来改变调用的状态。此外，它将帮助我们提供一个自定义的聊天UI，我们将在教程的后面使用流聊天！</p><p id="c514" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">经过以上更改，您现在应该会看到会议屏幕的主包装器在浏览器中将是全高全宽的，底部的操作栏将会消失。我们现在可以开始构建我们的自定义调用UI了。</p><p id="d704" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以让这个文件为空，因为我们首先需要一些其他组件，然后我们可以在ActionButtons栏本身中使用它们。</p><p id="e110" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到<code class="fe mz na nb nc b">src/components</code>让我们用下面的代码创建一个名为Icons的新目录和一个<code class="fe mz na nb nc b">Icon.js</code>文件:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f22c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个文件创建了一个可重用的<code class="fe mz na nb nc b">Icon</code>组件，我们可以用它来生成一组一致的SVG图标。然后，我们可以像使用任何其他react组件一样使用这些图标。<code class="fe mz na nb nc b">Icon</code>组件还提供了额外的功能——比如通过<code class="fe mz na nb nc b">size</code>道具控制图标高度/宽度的能力(同时保持一致性，如果我们正确设置<code class="fe mz na nb nc b">viewBox</code>的话),以及用<code class="fe mz na nb nc b">color</code>道具改变颜色的能力。</p><p id="cc2d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了速度和方便起见，我们使用了<a class="ae ko" href="https://material.io/resources/icons/" rel="noopener ugc nofollow" target="_blank">材质图标</a>——将它们转换到我们的新图标组件中使用轻而易举。为了避免重复，这里有一个链接指向一个包含完整图标文件夹的<a class="ae ko" href="https://stream-blog.s3.amazonaws.com/blog/wp-content/uploads/25a67b81dacb3a644d546a8295caaa04/icons.zip" rel="noopener ugc nofollow" target="_blank"> ZIP文件</a>，你可以直接放入你的<code class="fe mz na nb nc b">components</code>目录。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="981c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们准备创建我们的自定义动作栏！</p><p id="c549" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到<code class="fe mz na nb nc b">screens/Conference/components/ActionsButtons.js</code>，我们现在可以添加以下内容:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cfdb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">目前，我们正在将<code class="fe mz na nb nc b">unreadCount</code>道具设置为回退到<code class="fe mz na nb nc b">0</code>，因为我们还没有在任何地方定义它。一旦我们建立了流聊天，我们将从我们的Redux存储中提取这些数据。</p><p id="433d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有其他属性都由Voxeet <code class="fe mz na nb nc b">ConferenceRoom</code>组件提供，并由默认的<code class="fe mz na nb nc b">ActionsButtons</code> UI在内部使用，以有条件地改变按钮的状态——所以我们也将这样做。这种状态取决于用户的麦克风或摄像头是否被禁用、聊天抽屉是否打开等参数。</p><p id="d610" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我们在UI中保留了一些默认的Voxeet视图，如设置(用于控制输入/输出设备，以及用于查看所有活动参与者的<code class="fe mz na nb nc b">AttendeesList</code>)。</p><p id="6778" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在剩下要做的就是将我们全新的<code class="fe mz na nb nc b">ActionsButtons</code>导入到<code class="fe mz na nb nc b">ConferenceRoom</code>中，如下所示:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="dfd1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在您的浏览器中，您应该会在屏幕底部看到我们的自定义通话UI！您可以挂断电话，禁用您的摄像头或麦克风，与其他参与者共享您的屏幕，更改您的I/O设置，查看参与者列表，最后但同样重要的是，切换聊天抽屉。这将是空的，但我们很快会回来。</p><p id="5975" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还想覆盖一些Voxeets CSS，使会议屏幕与应用程序的其余部分相匹配。为了简洁起见，下面是我们完成版本的完整CSS文件——您可以随意调整任何您认为合适的值。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="38de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在剩下要做的就是跳转到<code class="fe mz na nb nc b">styles/global.js</code>并添加下面两行来将我们的覆盖导入到全局CSS文件中:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="cae9" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">步骤4:设置后端API和身份验证</h1><p id="4207" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">在设置我们的聊天组件之前，我们将通过首先设置应用程序的后端API和身份验证来简化事情。</p><p id="a112" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个项目的后端很简单，Voxeet的react组件为您处理所有与Voxeet相关的后端功能。我们需要做的就是传入用户数据，这意味着我们只需要为流聊天生成一个令牌。</p><p id="835d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在这里下载样板文件，并按照下面的部分让后端和认证流程在您的应用程序中工作。或者，您可以点击Heroku按钮，立即将完整的API代码部署到Heroku，或者点击此处查看完成的API报告。</p><blockquote class="lp lq lr"><p id="880b" class="jq jr ls js b jt ju jv jw jx jy jz ka lt kc kd ke lu kg kh ki lv kk kl km kn im bi translated"><strong class="js iu">注意</strong>:如果您选择使用Heroku自动部署，您可以安全地跳过下一部分，直接构建认证流程。</p></blockquote><p id="2377" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们开始编写后端代码吧！</p><p id="603d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，许多工作已经通过提供的样板API完成了。我们需要做一些小的改变，让它按照我们想要的方式工作。</p><p id="1907" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在您的前端存储库之外，从您想要存储API代码的目录在您的终端中运行下面的命令。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a6e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，运行<code class="fe mz na nb nc b">cd stream-voxeet-api &amp;&amp; yarn</code>并在编辑器中打开<code class="fe mz na nb nc b">stream-chat-voxeet</code>目录。</p><p id="2602" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们首先将<code class="fe mz na nb nc b">env.example</code>重命名为<code class="fe mz na nb nc b">.env</code>，并将之前保存的流密钥和秘密插入到正确的变量中。完成后，它应该看起来像这样:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0e7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们回到终端，运行<code class="fe mz na nb nc b">yarn dev</code>来启动开发服务器。repo使用nodemon在您进行更改时自动刷新，同时保持服务器活动。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3e8f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可选地，您将在第<strong class="js iu"> 28 </strong>行看到repo使用robohash为用户生成一个头像。在我们的最终版本中，我们使用了ui-avatars.com，因为它生成的图像更适合我们的设计，但是你可以在这里放入任何你认为合适的头像生成URL。</p><p id="a93f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">后端就这样了！</p><p id="867a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以测试Postman(或者您选择的REST客户机)是否工作正常，方法是让服务器运行，并向<code class="fe mz na nb nc b">http://localhost:8080/v1/token</code>发出POST请求，其中主体是以下对象:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="330e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果成功，您将在响应正文中看到以下内容:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d9e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">厉害！我们现在可以开始构建我们的登录表单，并在我们的应用程序中验证用户。</p><p id="4f81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让你的API服务器暂时运行，回到你的编辑器中的前端代码。</p><p id="dba4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还需要Axios周围的这个小包装实用程序向我们的后端发出请求，并将其保存在<code class="fe mz na nb nc b">src/utils/fetch.js</code>中的项目文件中</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="36ca" class="nf lx it bd ly ng nh dn mc ni nj dp mg kb nk nl mk kf nm nn mo kj no np ms nq bi translated">构建认证流程</h2><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="140f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输入</strong>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5dfd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">按钮</strong>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9c3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">正文</strong>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="af81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经拥有了使用Formik和Yup构建我们的<code class="fe mz na nb nc b">LoginForm</code>组件所需的所有组件，这些组件是我们在本教程开始时安装的。</p><p id="ec41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Formik是一个很棒的库，允许我们用React轻松构建复杂的表单，而Yup提供了一个很好的、强大的方法来验证我们的输入值。在本教程中，我们不会利用Formik的全部潜力，但是如果您在完成本教程后决定构建这个项目，这将为您快速、轻松地构建任何形式奠定坚实的基础。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="29a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们从从T4进口T2和T3开始。组件<code class="fe mz na nb nc b">&lt;Formik /&gt;</code>将是我们渲染函数中的根元素，我们从props传入我们的<code class="fe mz na nb nc b">onSubmit</code>处理程序，以及第24行getter函数中定义的一些初始值，最后，我们的<code class="fe mz na nb nc b">this.renderForm</code>函数作为组件的子元素。</p><p id="3a9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们也在进口<code class="fe mz na nb nc b">validationSchema.js</code>——这就是Yup的用武之地。语法非常容易掌握，不仅文档容易理解，而且Yup还提供了有用的助手来验证电子邮件、电话号码等，以及传递自定义正则表达式验证器的选项，并可以轻松设置错误消息，如果条件不满足，这些消息将被传递到输入组件中。</p><p id="d316" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在表单组件旁边的<code class="fe mz na nb nc b">LoginForm</code>目录中创建验证文件，并粘贴以下代码:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e43f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，回到<code class="fe mz na nb nc b">LoginForm.js</code>内部，您会看到我们正在将我们的Yup模式作为<code class="fe mz na nb nc b">validationSchema</code>道具传递给Formik。此时，我们的表单将完全可操作，但是还没有呈现到DOM的任何地方，也没有将它的值发送到后端。</p><p id="f885" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们快速跳转到<code class="fe mz na nb nc b">App.js</code>并更新文件来呈现我们的登录路径。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5e69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，当您导航到<a class="ae ko" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>时，您应该看到我们的登录页面呈现在屏幕上，并带有登录表单。您也可以填写表单，单击下面的按钮并打开您的控制台来查看表单的输出。</p><p id="6ceb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在需要一种方法将表单数据发送到后端，检索我们的令牌，并在将它们发送到会议屏幕之前验证用户。是时候来点还原魔法了！🧙‍♂️</p><p id="6fd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将从创建动作创建者和动作类型开始。您可以在下面找到相关的片段，它们将保存在我们项目的<code class="fe mz na nb nc b">data/auth</code>中。</p><p id="6810" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">数据/授权/类型. js </strong>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b095" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> data/auth/actions.js </strong>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="630f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在<code class="fe mz na nb nc b">auth/sagas/index.js</code>中添加以下代码:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5209" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mz na nb nc b">redux-saga</code>还提供了一些助手，比如<code class="fe mz na nb nc b">takeEvery</code>(用在上面的代码片段中)，它将动作类型作为第一个参数，将传奇作为第二个参数。每次动作被触发，传奇就会开始。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ae66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们快速分析一下这是怎么回事。</p><ul class=""><li id="7f2b" class="lb lc it js b jt ju jx jy kb ld kf le kj lf kn lg lh li lj bi translated">我们从redux-saga导入<code class="fe mz na nb nc b">all</code>、<code class="fe mz na nb nc b">call</code>和<code class="fe mz na nb nc b">put</code>助手，如果我们的登录操作没有提供会议别名，我们还导入<code class="fe mz na nb nc b">shortid</code>来生成会议别名。</li><li id="7579" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">然后，我们从utils目录导入<code class="fe mz na nb nc b">history</code>和<code class="fe mz na nb nc b">fetch</code>。</li><li id="cc7d" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">我们还导入了我们的<code class="fe mz na nb nc b">LOGIN</code>动作类型，这样我们就可以在以后的故事中触发一个成功动作或错误动作。</li><li id="bf1a" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">接下来，我们定义我们的saga并析构它的第一个也是唯一的参数，该参数将始终是我们解雇的动作创建者(<code class="fe mz na nb nc b">loginRequest</code>)，这意味着我们可以从动作中提取值并在我们的saga中使用它们，在本例中，是可选的会议别名和表单数据。</li><li id="3756" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">然后，我们打开一个try/catch块，对用户名进行一些简单的格式化，以确保在运行fetch调用之前，它全部是小写的并且不包含空格(我们使用regex将它们替换为' _ ')。</li><li id="b46e" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">我们使用<code class="fe mz na nb nc b">call</code>助手，并将fetch作为第一个参数传入。将传递以下所有参数以获取自身。</li><li id="519a" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">Axios(因此我们的fetch util)从服务器返回响应体作为<code class="fe mz na nb nc b">data</code>键，所以我们也要对其进行析构，以便从响应中提取令牌和用户对象。</li><li id="6f31" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">接下来，我们将这些值存储在localStorage中，这样我们就可以跨会话持久化用户(稍后当我们到达我们的reducer时会详细介绍)，然后检查动作数据中是否出现了<code class="fe mz na nb nc b">conferenceAlias</code>。如果不是，我们使用<code class="fe mz na nb nc b">shortid</code>生成一个。</li><li id="e7ac" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">最后，我们使用<code class="fe mz na nb nc b">all</code>助手来并行运行两个saga助手。第一个是<code class="fe mz na nb nc b">put</code>，它将触发我们的成功动作以供缩减器使用；第二个是<code class="fe mz na nb nc b">call</code>，其中我们通过<code class="fe mz na nb nc b">history.push</code>将用户导航到会议屏幕。</li><li id="8c8d" class="lb lc it js b jt lk jx ll kb lm kf ln kj lo kn lg lh li lj bi translated">我们还使用catch块中的<code class="fe mz na nb nc b">put</code>来触发<code class="fe mz na nb nc b">LOGIN.ERROR</code>动作，并将消息传递给减速器。</li></ul><p id="ee06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然我们的登录传奇已经准备好了，我们需要确保我们确实在运行传奇，以便它可以监听<code class="fe mz na nb nc b">LOGIN.REQUEST</code>动作。我们将通过在初始化Redux存储时创建的根saga中使用另一个saga助手(<code class="fe mz na nb nc b">fork</code>)来实现这一点。</p><p id="318d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在您的编辑器中打开<code class="fe mz na nb nc b">data/rootSaga.js</code>,将其修改为如下代码片段:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c6d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，在<code class="fe mz na nb nc b">data/auth</code>中创建一个<code class="fe mz na nb nc b">reducer.js</code>文件，并向其中添加以下代码:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c430" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">reducer将处理<code class="fe mz na nb nc b">LOGIN.SUCCESS</code>动作，并将用户令牌和配置文件数据保存到Redux存储中。我们正在传递一些初始状态，默认值设置为从<code class="fe mz na nb nc b">localStorage</code>中提取值——如果它们不存在，它们将返回null，因此使应用程序处于未验证状态，可以登录。</p><p id="a981" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以在组件中使用这些数据来创建一个会议屏幕路由的包装器，以防止未经身份验证的用户访问它。在您的<code class="fe mz na nb nc b">src/containers</code>目录中，创建一个名为<code class="fe mz na nb nc b">AuthedRoute.js</code>的新文件，并在下面的代码片段中粘贴:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="aa1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的组件负责保护我们的路由免受未授权用户的访问，并在授权请求正在进行时显示一个加载屏幕。它还会将<code class="fe mz na nb nc b">conferenceAlias</code>参数传递给<code class="fe mz na nb nc b">location.state</code>，这样，如果用户试图在没有登录的情况下访问会议，它会存储id，这样我们就可以通过检查位置状态中的值并将其传递给我们之前设置的动作创建者来重定向他们。</p><p id="70a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于加载屏幕，将以下文件添加到<code class="fe mz na nb nc b">screens/LoadingScreen.js</code>:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="416b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，让我们回到我们的<code class="fe mz na nb nc b">screens/Login/Login.js</code>文件，并做以下更改:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="60d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们在类中添加了一个新方法，<code class="fe mz na nb nc b">renderWelcome</code>,它呈现了一个略有不同的UI，显示了用户头像和一个“开始视频通话”按钮来发起通话。我们在渲染函数中有条件地调用that或<code class="fe mz na nb nc b">renderLogin</code>,这取决于用户是否经过身份验证。</p><p id="18d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们的后端已经就绪，我们的登录屏幕已经完全运行，我们可以通过用Stream构建我们的聊天实现来完成我们的应用程序了！🎉</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/e0d11fc3d5b697df8f0497f90fe9c0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7AhEHexZ4nyfYOGX"/></div></div></figure><h1 id="8f22" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">第五步:流式聊天</h1><p id="4c08" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">如果您点击了我们之前构建的通话UI中的聊天按钮，您肯定会注意到，打开抽屉会将视频移到左边，但抽屉本身是不可见的。所以现在是开始集成流聊天和构建自定义抽屉的最佳时机，我们可以将它传递到我们的<code class="fe mz na nb nc b">ConferenceRoom</code>中。</p><p id="e324" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，您需要添加下面的<code class="fe mz na nb nc b">Portal</code> util，它是使用Reacts内部门户实现构建的。如果您以前没有使用过门户，它们基本上允许您在树中的任何地方定义组件，但是可以在当前父层次结构之外的任何地方将它呈现到DOM中。我们将使用门户在主体内部呈现一个聊天抽屉——在应用程序的其余部分之上。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d7ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们需要创建我们的<code class="fe mz na nb nc b">chat</code>减速器，并将其导入到我们的根减速器中。下面是缩减器的代码，后面是显示根缩减器的代码片段。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1c6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，进入我们的聊天抽屉！</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d8a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里发生了很多事情——所以这里有一个分类。</p><p id="f37a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，在我们的构造函数中，我们定义了我们的默认状态，还设置了<code class="fe mz na nb nc b">this.chatClient</code>来包含我们的<code class="fe mz na nb nc b">StreamChat</code>实例，并向它传递我们在教程开始时设置的<code class="fe mz na nb nc b">.env</code>变量。然后，在<code class="fe mz na nb nc b">componentDidMount</code>中，我们调用<code class="fe mz na nb nc b">this.chatClient.setUser</code>并传入一个表示我们的<code class="fe mz na nb nc b">user</code>的对象，我们使用Redux选择器将它拉入props。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="96b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还在这里初始化了一个监听器，它在<code class="fe mz na nb nc b">message.new</code>事件时触发。每次在通道中发送新消息时，回调将运行并使用我们的<code class="fe mz na nb nc b">setUnreadCount</code>动作创建器更新我们的未读计数。</p><p id="539b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，在我们的渲染函数中，我们渲染了<code class="fe mz na nb nc b">stream-chat-react</code>组件，这些组件将为我们的UI提供动力，并为我们处理大量的状态管理。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="677f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们用<code class="fe mz na nb nc b">Chat</code>组件包装一切，并将<code class="fe mz na nb nc b">this.chatClient</code>传递给客户端道具。在其中，我们呈现了从<code class="fe mz na nb nc b">this.state</code>传递给我们的<code class="fe mz na nb nc b">channel</code>的<code class="fe mz na nb nc b">Channel</code>组件，随后是<code class="fe mz na nb nc b">Window</code>，它将包装我们聊天UI的视觉方面。然后，在我们的<code class="fe mz na nb nc b">Window</code>内部，我们渲染<code class="fe mz na nb nc b">ChatHeader</code>、<code class="fe mz na nb nc b">MessageList</code>、<code class="fe mz na nb nc b">MessageInput</code>。</p><p id="bd59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到<code class="fe mz na nb nc b">screens/Conference/components</code>内部，创建<code class="fe mz na nb nc b">ChatHeader.js</code>并添加以下代码片段:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5862" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我们需要一个完全可操作的聊天UI的一切！</p><p id="d36b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是我们还没有完成…</p><p id="5452" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要包含来自<code class="fe mz na nb nc b">stream-chat-react</code>的CSS文件。当然，从库中导出的默认文件是有响应的。然而，由于我们是在一个375像素宽的包装器div中呈现聊天组件，这带来了一些问题。</p><p id="12d3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为CSS媒体查询对窗口的大小作出反应，而不是父div的大小，所以诸如<code class="fe mz na nb nc b">padding</code>和<code class="fe mz na nb nc b">max-width</code>这样的属性将是不正确的——使用它对整个视窗的值，而不管容器的大小。为了解决这个问题，我们将去掉媒体查询，只使用移动设备大小的定义。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6f9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将上述文件放在您的<code class="fe mz na nb nc b">public</code>目录中，然后在<code class="fe mz na nb nc b">public/index.html</code>中您可以像这样导入文件:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d339" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还需要沿着屏幕底部跳回我们为自定义呼叫UI制作的<code class="fe mz na nb nc b">ActionsButtons.js</code>组件，并将其连接到我们的redux存储，以便我们可以检索未读计数并相应地显示通知标记:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="d91f" class="lw lx it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">最后的想法</h1><p id="c384" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">在本教程中，您已经成功构建了一个功能完整的视频会议应用程序。想了解更多关于Voxeet的信息，请访问他们的网站:https://voxeet.com。</p><p id="9d0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您有兴趣将聊天添加到您的应用程序中，Stream Chat可以满足您的需求React组件(我们在本教程中使用过),以及用于JS、iOS、Android和大多数其他流行编程语言的SDK和库。</p><p id="bfc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编码快乐！✌️</p></div></div>    
</body>
</html>