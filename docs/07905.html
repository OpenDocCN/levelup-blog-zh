<html>
<head>
<title>Simple Twitter Bot with Node.js Tutorial Part 3: Search and Retweet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Node.js的简单Twitter Bot教程第3部分:搜索和转发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simple-twitter-bot-tutorial-part-3-search-and-retweet-d96b60731b48?source=collection_archive---------6-----------------------#2021-03-20">https://levelup.gitconnected.com/simple-twitter-bot-tutorial-part-3-search-and-retweet-d96b60731b48?source=collection_archive---------6-----------------------#2021-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7e639c6bef3639f5d472b598df0e6522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-z7o7-P3X2EgEI_C0Pfow.jpeg"/></div></div></figure><p id="82fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">本文原载于</em> <a class="ae kx" href="https://blog.shahednasser.com/simple-twitter-bot-tutorial-part-3-search-and-retweet/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">我的个人博客</em> </a> <em class="kw">。</em></p><p id="f426" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程的前两部分中，我们讨论了如何创建一个Twitter bot，它从历史上的 API中的<a class="ae kx" href="https://history.muffinlabs.com/" rel="noopener ugc nofollow" target="_blank">发送推文，然后创建了一些计划任务，确保这些推文在一天的特定时间自动发布。我们使用</a><a class="ae kx" href="https://github.com/FeedHive/twitter-api-client" rel="noopener ugc nofollow" target="_blank"> twitter-api-client </a>来轻松连接Twitter API。你可以在<a class="ae kx" href="https://twitter.com/HistoryBot7" rel="noopener ugc nofollow" target="_blank"> @HistoryBot7 </a>上看到这个教程的机器人真人版。</p><p id="0393" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在教程的这一部分，我们将基于特定的查询来搜索推文并转发它们。你可能见过很多机器人这样做。你发一条带有标签或关键词的微博，机器人会立刻转发。这就是我们将要做的。我们将每分钟搜索带有标签“#HistoryBot”的推文，并转发它们。</p><p id="5165" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在<a class="ae kx" href="https://github.com/shahednasser/history-bot" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>上继续阅读本教程的代码。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="6867" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">搜索推文</h1><p id="d5f6" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">第一步是搜索带有标签“#HistoryBot”的最新推文，以便我们稍后转发它们。</p><p id="4bdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在项目的根目录下创建一个名为<code class="fe mi mj mk ml b">search.js</code>的新文件。我们在一个单独的文件中这样做的原因是，我们以后需要在这个文件上单独运行一个预定的命令。</p><p id="363b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该文件应该从初始化TwitterClient开始，如下所示:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="de3e" class="mu lg iq ml b gy mv mw l mx my">//search.js<br/>require('dotenv').config()<br/>const {TwitterClient} = require('twitter-api-client')<br/><br/>const twitterClient = new TwitterClient({<br/>    apiKey: process.env.TWITTER_API_KEY,<br/>    apiSecret: process.env.TWITTER_API_SECRET,<br/>    accessToken: process.env.TWITTER_ACCESS_TOKEN,<br/>    accessTokenSecret: process.env.TWITTER_ACCESS_TOKEN_SECRET<br/>})</span></pre><p id="564e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你一直关注教程，你会注意到这和<code class="fe mi mj mk ml b">index.js</code>中的完全一样。所以，与其重复代码。我们将把这段代码移动到另一个名为<code class="fe mi mj mk ml b">init.js</code>的文件中，在其中导出<code class="fe mi mj mk ml b">twitterClient</code>，然后在我们的<code class="fe mi mj mk ml b">index.js</code>文件和<code class="fe mi mj mk ml b">search.js</code>文件中需要它。(如果只是按照自己项目的教程来做，就不需要做这一步了。)</p><p id="c11f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，现在我们将拥有包含以下内容的<code class="fe mi mj mk ml b">init.js</code>:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="8687" class="mu lg iq ml b gy mv mw l mx my">//init.js<br/>require('dotenv').config()<br/>const {TwitterClient} = require('twitter-api-client')<br/><br/>const twitterClient = new TwitterClient({<br/>    apiKey: process.env.TWITTER_API_KEY,<br/>    apiSecret: process.env.TWITTER_API_SECRET,<br/>    accessToken: process.env.TWITTER_ACCESS_TOKEN,<br/>    accessTokenSecret: process.env.TWITTER_ACCESS_TOKEN_SECRET<br/>})<br/><br/>module.exports = twitterClient</span></pre><p id="d270" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们将在<code class="fe mi mj mk ml b">index.js</code>中需要twitterClient，并删除之前初始化Twitter客户端的代码:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="9afe" class="mu lg iq ml b gy mv mw l mx my">//index.js<br/>const twitterClient = require('./init')<br/>const axios = require('axios')<br/><br/>axios.get... //rest of the code from before</span></pre><p id="7690" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将<code class="fe mi mj mk ml b">search.js</code>修改如下:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="30b4" class="mu lg iq ml b gy mv mw l mx my">//search.js<br/>const twitterClient = require('./init')</span></pre><p id="c575" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这样，我们可以避免在不同的文件中重复相同的代码。</p><p id="ee9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在回到我们的搜索脚本。初始化Twitter客户端后，我们需要搜索包含“#HistoryBot”的tweets。为此，我们将在<code class="fe mi mj mk ml b">twitterClient</code>上使用方法<code class="fe mi mj mk ml b">tweets.search</code>。这个方法采用可变数量的参数，例如，<code class="fe mi mj mk ml b">since_id</code>帮助您在特定的tweet之后获得tweet。这可以帮助你优化你正在做的搜索和你正在检索的推文。你可以在这里找到它们所有参数的列表<a class="ae kx" href="https://developer.twitter.com/en/docs/tweets/search/api-reference/get-search-tweets" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="134a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们示例的基本用法，我们将向它传递两个参数:<code class="fe mi mj mk ml b">q</code>这是我们正在执行的搜索查询，在我们的教程中是“#HistoryBot ”,但是您可以在其中放置任何类型的关键字或标签，以便在tweet中查找。第二个参数是<code class="fe mi mj mk ml b">result_type</code>，值将是<code class="fe mi mj mk ml b">recent</code>。这是为了确保我们得到最新的结果，因为这个参数的默认值是<code class="fe mi mj mk ml b">mixed</code>，它检索最近的推文和热门推文的组合。我们需要使用<code class="fe mi mj mk ml b">recent</code>，因为我们的目标是转发推文。</p><p id="642c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，该方法调用的端点最多检索15条tweets。如果您愿意，可以通过传递参数<code class="fe mi mj mk ml b">count</code>来更改它，该参数最多可以是100。</p><p id="f8cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们在<code class="fe mi mj mk ml b">search.js</code>中的代码如下:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="a6b0" class="mu lg iq ml b gy mv mw l mx my">const twitterClient = require('./init')<br/><br/>twitterClient.tweets.search({<br/>    q: '#HistoryBot',<br/>    result_type: 'recent', //get latest tweets with this hashtag<br/>}).then ((response) =&gt; {<br/>	console.log(response)<br/>}).catch ((err) =&gt; console.error(err))</span></pre><p id="10ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将检索最后15条包含“#HistoryBot”的推文，然后将它们打印到控制台。</p><p id="db4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要对此进行测试，请在您的终端中运行以下命令:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="581f" class="mu lg iq ml b gy mv mw l mx my">node search.js</span></pre><p id="b663" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切正常，您将看到一个包含<code class="fe mi mj mk ml b">status</code>属性的对象，它有一个状态数组。每个状态都有类似于<code class="fe mi mj mk ml b">id</code>、<code class="fe mi mj mk ml b">id_str</code>、<code class="fe mi mj mk ml b">text</code>以及许多其他属性。请记住，有这个标签的推文并不多(可能没有)，因为我使用这个标签是为了确保教程不会随机转发任何东西。因此，您可以用任何其他东西替换这个标签来查看它的效果。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="446e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">转发推文</h1><p id="90e9" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">在基于我们的查询搜索推文之后，我们将希望把它们转发到我们的机器人中。为此，我们将在<code class="fe mi mj mk ml b">twitterClient</code>上使用<code class="fe mi mj mk ml b">tweets.statusesRetweetById</code>方法。这个方法取参数<code class="fe mi mj mk ml b">id</code>，这个参数将是我们之前收到的状态对象的<code class="fe mi mj mk ml b">id_str</code>。</p><p id="361f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的是，如果一条推文已经发了，Twitter会忽略它。如果您已经达到了转发的限制，您将收到一个状态代码为403的错误。你可以在这里阅读更多关于这个端点<a class="ae kx" href="https://developer.twitter.com/en/docs/twitter-api/v1/tweets/post-and-engage/api-reference/post-statuses-retweet-id" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="8b98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们将修改<code class="fe mi mj mk ml b">search.js</code>中的代码，如下所示:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="e8c2" class="mu lg iq ml b gy mv mw l mx my">//...<br/>twitterClient.tweets.search({<br/>    q: '#HistoryBot',<br/>    result_type: 'recent', //get latest tweets with this hashtag<br/>}).then ((response) =&gt; {<br/>    if (response.statuses) {<br/>        response.statuses.forEach((status) =&gt; {<br/>            twitterClient.tweets.statusesRetweetById({<br/>                id: status.id_str<br/>            })<br/>            .then ((resp) =&gt; console.log(`Retweeted tweet #${status.id}`))<br/>            .catch ((err) =&gt; console.error(err))<br/>        })<br/>    }<br/>}).catch ((err) =&gt; console.error(err))</span></pre><p id="5873" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们没有将来自<code class="fe mi mj mk ml b">tweets.search</code>的响应打印到我们的控制台，而是迭代响应中接收到的<code class="fe mi mj mk ml b">statuses</code>数组，并使用<code class="fe mi mj mk ml b">tweets.statusesRetweetById</code>转发每条推文，将每种状态的<code class="fe mi mj mk ml b">id_str</code>传递给它。如果成功，它将打印到控制台<code class="fe mi mj mk ml b">Retweeted tweet #${status.id}</code>，其中<code class="fe mi mj mk ml b">status.id</code>是状态的id。如果失败，它会将收到的错误打印到控制台。</p><p id="7843" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们通过运行相同的命令再次测试这一点:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="5571" class="mu lg iq ml b gy mv mw l mx my">node search.js</span></pre><p id="83ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会看到它会转发带有这个标签的推文。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d12b98d2b10c17a082e18334431c9ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*5j9pV0Wh_ZglQUqb.png"/></div></figure><p id="824c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:我已经在@HistoryBot7上发了这条推文<a class="ae kx" href="https://twitter.com/HistoryBot7/status/1373249880324501511" rel="noopener ugc nofollow" target="_blank">，所以如果没有任何带有标签的推文，你也可以测试一下！</a></p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="4747" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">部署到服务器</h1><p id="2295" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如果你看过我们教程的第2部分，你会发现我们在alwaysdata上部署了这个机器人。我们现在将使用更新后的代码更新服务器，这样我们就可以调度一个每分钟运行一次的任务并执行<code class="fe mi mj mk ml b">search.js</code>。</p><p id="d749" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，用最新的更改更新您在服务器上使用的GitHub存储库:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="dae2" class="mu lg iq ml b gy mv mw l mx my">git add . <br/>git commit -m "added retweet functionality" <br/>git push origin master</span></pre><p id="ebef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，用SSH连接到您的服务器，就像我们在第2部分中所做的那样，使用您的凭证。</p><p id="a032" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">连接后，导航到包含bot代码的目录，并从GitHub存储库中提取代码:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="aa70" class="mu lg iq ml b gy mv mw l mx my">cd history-bot <br/>git pull origin master</span></pre><p id="239e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将使用最新的更改更新我们服务器上的代码。</p><p id="de51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们在alwaysdata服务器上创建计划任务。如果您使用不同的服务器，这只是创建cron作业的一种简单方法。</p><p id="1378" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在alwaysdata管理控制面板中，转到侧栏中“高级”下的“计划任务”。然后单击“添加计划任务”</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/c377b773c0aebda6acc86c679c93dbdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FiqHxdKCR8433P3o.png"/></div></div></figure><p id="a8b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一页的表单中，为“任务类型”选择“执行命令”，然后为“值”键入命令“node ~/history-bot/search.js”。确保根据您自己的服务器路径和文件替换该命令。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/34a575c69be6a8b7ce0ff59bebf335f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zkc4ASVe-4UM-rUW.png"/></div></div></figure><p id="2d52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Environment部分，从下拉列表中选择您的SSH用户，并输入工作目录字段<code class="fe mi mj mk ml b">/home/history-bot/history-bot</code>，其中第一个history-bot是您在alwaysdata上为bot创建的应用程序的名称，第二个是我们拥有history bot的目录。您也可以选择省略它，因为我们的命令已经指定了<code class="fe mi mj mk ml b">search.js</code>的完整路径</p><p id="2d70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在“频率”部分，选择“每”，并在字段中键入1，以每分钟执行一次命令。当然，您可以根据您的使用情况进行更改。</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/a352370ff5cfeaa578d7149e001972e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*msRLN0GHaY-PIADi.png"/></div></div></figure><p id="65a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成后，点击提交。然后，转到侧边栏中Web下的Sites，重启你的应用。现在，脚本将每分钟执行一次！</p><p id="e655" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要测试本教程的历史机器人，只需用#HistoryBot发布一些东西，它就会转发给你！</p><p id="48c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，如果您的机器人已经在整个教程中转发了一些推文，您需要取消转发才能看到它现在生效。</p><p id="9ae4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果机器人不能正常工作，你可以检查你的服务器上的日志以获取更多信息。如果你使用的是alwaysdata，你可以在<code class="fe mi mj mk ml b">~/admin/logs/job/2021</code>下找到日志。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="89d2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="cbe3" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">按照这3个教程，你应该能够创建一个机器人，定期发推文，并根据特定的关键字或标签搜索Twitter，并转发推文，然后部署机器人。希望你能用它创造一些伟大的东西！</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="db58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">原载于2021年3月20日https://blog.shahednasser.com</em><em class="kw">的</em> <a class="ae kx" href="https://blog.shahednasser.com/simple-twitter-bot-tutorial-part-3-search-and-retweet/" rel="noopener ugc nofollow" target="_blank"> <em class="kw">。</em></a></p></div></div>    
</body>
</html>