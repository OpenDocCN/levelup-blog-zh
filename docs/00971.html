<html>
<head>
<title>React Hooks — Should We Be Hooked on Hooks?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应钩子——我们应该被钩子钩住吗？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-hooks-should-we-be-hooked-on-hooks-8622f6cd6f7c?source=collection_archive---------3-----------------------#2019-10-03">https://levelup.gitconnected.com/react-hooks-should-we-be-hooked-on-hooks-8622f6cd6f7c?source=collection_archive---------3-----------------------#2019-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="80bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">钩子优点之我见</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bad4ab2d667e66386243a70111b654b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SKvitFeyMQOKq9Poam0ELA.jpeg"/></div></div></figure><p id="0c26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React钩子是在2019年2月16日向公众发布的React 16.8中引入的。如果我们在Reactjs.org的文档中找到一行关于React钩子的解释，我们会看到:</p><blockquote class="lr"><p id="c88c" class="ls lt it bd lu lv lw lx ly lz ma lp dk translated">" React钩子允许你使用状态和React生命周期特性，而不需要使用类和React组件生命周期方法."</p></blockquote><p id="f660" class="pw-post-body-paragraph ku kv it kw b kx mb ju kz la mc jx lc ld md lf lg lh me lj lk ll mf ln lo lp im bi translated">但是，它们可以远不止这些…</p><p id="e581" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它们允许我们考虑新的设计模式、更大的分离和功能性编程的新方法，让我们有机会编写更干净、更容易测试并且可以从不同角度处理问题的代码。</p><p id="fff6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它与您现有的React代码一起工作非常愉快，并且适合逐渐引入一个平台或团队。钩子是完全可选的，普通的JS是完全向后兼容的。</p><p id="3728" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，由于开发环境的本质，一旦您承诺引入它，其他开发人员可能会被迫在审查期间或重新访问代码时捡起它。</p><p id="8997" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我个人认为…我是一个超级粉丝，没有新的概念需要学习，它只是想让我们更容易地接触到我们已经知道的概念(道具、状态、上下文、引用和生命周期)。</p><p id="c749" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么？</p><p id="0109" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Reacts组件和自顶向下的数据流非常适合将大的UI分解成更小的可重用组件。然而，因为组件依赖于有状态的逻辑，而有状态的逻辑不能被提取出来以分离关注点，所以它可以创建具有重复逻辑的大型组件，使得事情更难测试。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="65b9" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">我们如何改善这一点？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/73d4370bcc4b636723de757beb03166c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iDuqmG4vzOm1-E4q2_xIsw.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">这是React Conf 2018上Dan Abromovs代码的一个例子</figcaption></figure><ul class=""><li id="75de" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated">共享独立于组件实现的可重用行为(如<a class="ae lq" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具模式</a>)。</li><li id="520e" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">使用状态、挂钩和组件生命周期事件，而不使用类。</li><li id="9122" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">在组件的一个地方使用相关的逻辑，而不是在不同的生命周期方法之间分割。</li></ul><p id="99a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们仔细看看上面的代码，特别是最左边的图像。它包含一个组件，处理具有各种状态和生命周期效果的输入字段。</p><p id="e735" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们想与另一个组件共享这里的逻辑呢？换句话说，如果我们想分离关注点。</p><p id="e6d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也许我们可以有一个单独渲染的JSX，然后使用渲染道具或更高阶的组件模式。这两种模式都工作得很好，但是都需要对代码进行大量的修改，并且并不总是最容易遵循或在组件之间共享的模式。</p><p id="22be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你现在把目光投向上图的最右边…</p><p id="f424" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以看到无需创建类就能使用状态和反应生命周期事件的能力。我们可以创建一种在组件之间重用有状态逻辑的通用方法。</p><p id="cb58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它依赖于一些函数，当你仔细想想，这些函数是有意义的。多年来，函数一直是分离关注点和传递逻辑的完美机制。神奇的是，我们的函数现在也可以表现得像一个类，可以管理状态和生命周期事件。</p><p id="5c83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们仔细看看两个不同的例子。</p><p id="1a55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在下面看到，我们有我们通常的反应组件。我们创建一个类，使用一个构造函数来创建我们的状态，添加一些Reacts多生命周期事件，并通过在构造函数中绑定我们的方法来管理<code class="fe ny nz oa ob b">this</code>关键字。</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="6b9e" class="og mo it ob b gy oh oi l oj ok">import React, { Component } from 'react';<br/>import { render } from 'react-dom';</span><span id="ec6d" class="og mo it ob b gy ol oi l oj ok">class App extends Component { <br/> constructor() {<br/> super();<br/>  this.buttonSubmit = React.createRef();<br/>  this.state = {<br/>   name: '',<br/>   username: '',<br/>   formSubmitted: false<br/>  };</span><span id="847a" class="og mo it ob b gy ol oi l oj ok"> this.handleSubmit = this.handleSubmit.bind(this);<br/> this.handleChange = this.handleChange.bind(this);</span><span id="90ad" class="og mo it ob b gy ol oi l oj ok">}</span><span id="65ca" class="og mo it ob b gy ol oi l oj ok">componentDidMount(){<br/> this.buttonSubmit.current.addEventListener('click',    this.handleSubmit)<br/> console.log("component mounted")<br/>}</span><span id="43ad" class="og mo it ob b gy ol oi l oj ok">componentDidUpdate(){<br/> console.log("component updated")<br/>}</span><span id="3a00" class="og mo it ob b gy ol oi l oj ok">componentWillUnmount(){<br/> this.buttonSubmit.current.EventListener('click', this.handleSubmit)<br/> console.log("component unmounted")<br/>}</span><span id="da30" class="og mo it ob b gy ol oi l oj ok">handleChange(e){<br/> const {name, value} = e.target<br/> this.setState({...this.state, [name]: value})<br/>}</span><span id="0b64" class="og mo it ob b gy ol oi l oj ok">handleSubmit(){<br/> this.setState({formSubmitted: true})<br/>}</span><span id="05d4" class="og mo it ob b gy ol oi l oj ok">render() {<br/> return (<br/>  &lt;div&gt;<br/>  {this.state.formSubmitted<br/>  ? &lt;h1&gt; {this.state.username} has signed in &lt;/h1&gt;<br/>  : &lt;div&gt;<br/>      &lt;input type="text"<br/>       name="name"<br/>       id="name"<br/>       placeholder="name"<br/>       value={this.state.name}<br/>       onChange={this.handleChange}<br/>      /&gt;<br/>    &lt;div&gt;<br/>     &lt;input type="text"<br/>      name="username"<br/>      id="username"<br/>      placeholder="username"<br/>      value={this.state.username}<br/>      onChange={this.handleChange}<br/>     /&gt;<br/>    &lt;/div&gt;<br/>    &lt;button ref={this.buttonSubmit}&gt;Submit&lt;/button&gt;<br/>   &lt;/div&gt;<br/>  }<br/> &lt;/div&gt;<br/> );<br/> }<br/>}</span><span id="28b8" class="og mo it ob b gy ol oi l oj ok">render(&lt;Apps /&gt;, document.getElementById('root'));</span></pre><p id="bcc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的例子向我们展示了在我们添加了一些React钩子魔术之后，它会是什么样子。</p><p id="5d43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会注意到我们现在用React的一个名为<code class="fe ny nz oa ob b">useState</code>的内置钩子来管理状态，并且我们用<code class="fe ny nz oa ob b">useEffect</code>钩子简化了所有的<code class="fe ny nz oa ob b">lifeCycle</code>事件。</p><pre class="kj kk kl km gt oc ob od oe aw of bi"><span id="047c" class="og mo it ob b gy oh oi l oj ok">import React, { Component, useState, useRef, useEffect} from 'react';<br/>import { render } from 'react-dom';</span><span id="b4e6" class="og mo it ob b gy ol oi l oj ok">const useHandleForm = initialValue =&gt; {<br/> const [value, setValue] = useState(initialValue)</span><span id="292b" class="og mo it ob b gy ol oi l oj ok"> const handleChange = (e) =&gt; {<br/>  const { value } = e.target<br/>  setValue(value)<br/> }</span><span id="132e" class="og mo it ob b gy ol oi l oj ok"> return {<br/>  value,<br/>  onChange: handleChange<br/> }<br/>}</span><span id="e48f" class="og mo it ob b gy ol oi l oj ok">const App = () =&gt; {<br/> const name = useHandleForm('');<br/> const username = useHandleForm('');</span><span id="52b3" class="og mo it ob b gy ol oi l oj ok"> const [formSubmitted, setFormSubmitted] = useState(false)<br/> const buttonSubmit = useRef()</span><span id="6c1b" class="og mo it ob b gy ol oi l oj ok"> useEffect(() =&gt; {<br/>  // This gets called after every render, by default<br/>  // (the first one, and every one after that)</span><span id="4ced" class="og mo it ob b gy ol oi l oj ok">  buttonSubmit.current.addEventListener('click', handleSubmit)</span><span id="7490" class="og mo it ob b gy ol oi l oj ok">  // If you want to implement componentWillUnmount,<br/>  // return a function from here, and React will call<br/>  // it prior to unmounting.</span><span id="33f6" class="og mo it ob b gy ol oi l oj ok">  return () =&gt; buttonSubmit.current.removeEventListener('click',   handleSubmit);</span><span id="0b74" class="og mo it ob b gy ol oi l oj ok">}, [buttonSubmit])</span><span id="33be" class="og mo it ob b gy ol oi l oj ok">const handleSubmit = () =&gt; {<br/> setFormSubmitted(true);<br/>}</span><span id="6309" class="og mo it ob b gy ol oi l oj ok">return (<br/>  &lt;div&gt;<br/>  {this.state.formSubmitted<br/>  ? &lt;h1&gt; {name.value} has signed in &lt;/h1&gt;<br/>  : &lt;div&gt;<br/>      &lt;input type="text"<br/>       name="name"<br/>       id="name"<br/>       placeholder="name"<br/>       {...name}<br/>      /&gt;<br/>    &lt;div&gt;<br/>     &lt;input type="text"<br/>      name="username"<br/>      id="username"<br/>      placeholder="username"<br/>      {...username}<br/>     /&gt;<br/>    &lt;/div&gt;<br/>    &lt;button ref={this.buttonSubmit}&gt;Submit&lt;/button&gt;<br/>   &lt;/div&gt;<br/>  }<br/> &lt;/div&gt;<br/> );<br/>}</span><span id="28f1" class="og mo it ob b gy ol oi l oj ok">render(&lt;App /&gt;, document.getElementById('root'));</span></pre><p id="93ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是还有更多…</p><p id="e453" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们不局限于React提供的钩子，我们也可以构建自己的钩子，这就是钩子的价值开始为我所用的地方。</p><p id="3587" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，我们能够分离处理表单输入的逻辑，我们现在可以跨平台使用它，而不需要依赖渲染属性或更高级的组件模式。</p><p id="9458" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们所说的，有一些库正在被创建和更新，其中有一些有用的钩子，我们可以在将来重用。nikgraf 收藏了大量藏品，非常值得一游。</p><p id="dd1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不再有<code class="fe ny nz oa ob b">this</code>。</p><p id="e758" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">构建类组件的另一个难点是我们必须管理<code class="fe ny nz oa ob b">this</code>关键字。React和ES6已经试图用多种方式来减轻这种负担，以应对无限的<code class="fe ny nz oa ob b">this</code>。</p><p id="ba80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">箭头函数通过将<code class="fe ny nz oa ob b">this</code>关键字绑定到词法范围而不是上下文减轻了负担，当前推荐的处理<code class="fe ny nz oa ob b">this</code>的方法是在创建时将其绑定到构造函数中，如我们的示例所示。</p><p id="87b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是多个解决方案会增加开发人员的复杂性。React钩子允许我们减少对<code class="fe ny nz oa ob b">this</code>的依赖，因为<code class="fe ny nz oa ob b">useState</code>和<code class="fe ny nz oa ob b">useEffect</code>钩子输出局部变量，消除了将<code class="fe ny nz oa ob b">this </code>绑定到类范围的需要。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="a080" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">最后的想法</h1><p id="5513" class="pw-post-body-paragraph ku kv it kw b kx om ju kz la on jx lc ld oo lf lg lh op lj lk ll oq ln lo lp im bi translated">在这里，我们仅仅触及了React挂钩的表面。还有许多值得发现的内置挂钩，值得下次讨论。</p><p id="6838" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个例子是<code class="fe ny nz oa ob b">useContext</code>钩子，它可以减少对Redux库的依赖。但是我尝试做的是给你一个关于优势的高层次的观点。</p><p id="4001" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我相信您已经阅读了网上的文章，并且您可能已经得出结论，React Hooks的采用正在加快步伐，正如我所做的那样，React背后的团队为此投入了大量资源。</p><p id="c3bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至少，它为我们提供了新的工具和解决一些常见问题的方法。</p></div></div>    
</body>
</html>