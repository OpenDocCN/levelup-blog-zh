<html>
<head>
<title>How I am handling out-of-order events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何处理无序事件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-am-handling-out-of-order-events-d3e356959820?source=collection_archive---------2-----------------------#2022-09-05">https://levelup.gitconnected.com/how-i-am-handling-out-of-order-events-d3e356959820?source=collection_archive---------2-----------------------#2022-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1439" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用基于标点的技术处理无序事件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d2745e3a4b2b9bb4b43e936dbb30fd69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n-Z8FTriP50YYEs-"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@uxindo" rel="noopener ugc nofollow" target="_blank"> @uxindo </a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> unsplash </a>拍摄</figcaption></figure><p id="096d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在分布式系统的世界中，我们经常处理事件和消费者，而不考虑消费它们时的时间现实。作为开发人员，我们倾向于以顺序的方式思考事件，但是当我们不在单线程环境中工作时，我们的思考不能反映现实。</p><p id="c6f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我不得不围绕如何最好地处理事件的<strong class="ky ir">顺序</strong>做出设计决策时，我挣扎了很久，我想分享一些我的发现。</p><blockquote class="ls lt lu"><p id="b746" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated"><em class="iq">使用以下链接可以找到演示的链接:</em><a class="ae kv" href="https://github.com/ramihamati/demo_outoforder/tree/main/OutOfOrderDemo.Punctuation" rel="noopener ugc nofollow" target="_blank">https://github . com/ramihamati/demo _ out of order/tree/main/out of order demo。标点符号</a></p></blockquote></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="6807" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">定义</h1><p id="3034" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><strong class="ky ir">无序事件</strong>是指接收时间晚于预期的事件(或者处理时间早于预期)。这可能会导致我们的系统出现不正确的状态。</p><p id="663f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在处理这种情况时，有两种常用的处理方法:</p><ul class=""><li id="411a" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">IOP——按顺序处理——通常使用一个缓冲区来存储多个事件，我们可以稍后在实际调度它们进行处理之前对它们进行排序。</li><li id="646a" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">OOP——无序处理——不需要订单维护。在排序需求的情况下，OOP缓冲输入项，直到满足一个特殊的条件。这种情况由进度指示器支持，如标点、低水位线或心跳。</li></ul><p id="2909" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义了属于这两类的几种技术:</p><blockquote class="ls lt lu"><p id="2bf2" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">基于缓冲区的方法</p><p id="4324" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">基于标点的方法</p><p id="f928" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">基于推测的方法</p><p id="f415" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">基于近似的方法</p></blockquote><p id="52d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">你可以通过本页底部的链接了解更多信息。</em></p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="ba64" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">语境</h1><ul class=""><li id="d6e2" class="nd ne iq ky b kz my lc mz lf nr lj ns ln nt lr ni nj nk nl bi translated">出于特殊的查询目的，我想消费多个事件并将其转换成聚合事件</li><li id="8172" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">转换后的模型并不重要，因此最终的一致性足够好。</li><li id="4bad" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">我需要一个简单的解决方案，缓冲不是一个选项，因为它引入了额外的复杂性。</li><li id="67ad" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">我的事件是基本的域操作，如创建、更新、删除。这简化了我的设计</li></ul><p id="00a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我决定采用基于标点符号的方法，使用实体版本控制系统。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="8e3f" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">设计决策</h1><ul class=""><li id="cc92" class="nd ne iq ky b kz my lc mz lf nr lj ns ln nt lr ni nj nk nl bi translated">原始的域模型将有一个由存储库透明处理的版本属性。</li><li id="bbf6" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">发送的事件将包含独立于动作类型的整个域模型(作为事件模型)。这意味着如果我在一个创建的事件之前收到一个更新的事件，我可以使用这个信息来创建我的转换模型</li><li id="eac5" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">每个转换后的模型将存储用于创建它的所有事件的版本。</li></ul></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="36d6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">实施—结构</h1><p id="f4c8" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我将介绍的项目结构如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f6b6c45afbaff56aff4b0c9bb6e2a2c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*4_inxR6K3R8vChyHKF0GlA.png"/></div></figure><ul class=""><li id="9f3e" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">api项目包含原始的领域模型</li><li id="a226" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">监听器包含转换后的模型</li><li id="f950" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">公共项目包含基础设施类，帮助我维护版本系统以及事件和事件模型。</li></ul></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="13c0" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">实施— Api</h1><p id="f6ed" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">因为域模型必须包含一个版本，所以我创建了一个接口来实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4a8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述接口的实现将代表我们的mongo实体的基类(我不会详细介绍<code class="fe nx ny nz oa b">BaseDocument</code>，它只是一个mongo基类，你可以在git项目中查看)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d8e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于我的实现，重要的是我没有让用户处理版本，因为他可能会忘记增加它。相反，我是在存储库中这样做的。您可以在git中查看完整的代码，但这里有一个片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0a5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于API，我创建了一个简单的控制器，它将创建和更新实体，对于每个动作，它将发布一个事件。每个事件都有一个事件模型，特定实体的事件模型对于与该实体相关的所有操作都是相同的。这很有用，因为如果我在一个创建的事件之后收到一个更新事件，我就可以访问转换后的模型所需的全部信息。</p><p id="e992" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于出版商，我使用的是为RabbitMQ 配置的<a class="ae kv" href="https://masstransit-project.com/usage/transports/rabbitmq.html" rel="noopener ugc nofollow" target="_blank"> MassTransit</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="2650" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">实现监听器</h1><p id="6d99" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这部分有点复杂。这里我们有一组由一个或多个实体组成的实体。也许从结果开始，然后举例说明解决方案更容易。我在这里的目标是创建一个<code class="fe nx ny nz oa b">BookExpanded</code>，一个包含书籍和作者详细信息的模型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="aa0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们可能会有什么样的情况:</p><ul class=""><li id="80f6" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">在<code class="fe nx ny nz oa b"><em class="lv">BookCreated</em> </code>事件之前接收<code class="fe nx ny nz oa b"><em class="lv">BookUpdated</em> </code>事件</li><li id="6060" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">在<code class="fe nx ny nz oa b"><em class="lv">BookCreated</em></code> <em class="lv"> / </em> <code class="fe nx ny nz oa b"><em class="lv">Updated</em> </code>事件之后接收<code class="fe nx ny nz oa b"><em class="lv">AuthorCreated</em> </code>事件</li><li id="c105" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">在<code class="fe nx ny nz oa b"><em class="lv">AuthorCreated</em> </code>或<code class="fe nx ny nz oa b"><em class="lv">BookCreated</em></code> <em class="lv"> / </em> <code class="fe nx ny nz oa b"><em class="lv">Updated</em> </code>事件之后接收<code class="fe nx ny nz oa b"><em class="lv">AuthorUpdated</em> </code>事件</li></ul><p id="5d82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，以上所有的可能性都会在我们的系统中引发一个不正确的状态。在<code class="fe nx ny nz oa b"><em class="lv">BookCreated </em></code>之后收到<code class="fe nx ny nz oa b"><em class="lv">AuthorCreated </em></code>事件意味着我们必须将该信息存储在某个地方，正因为如此，我们将需要一个单独的<code class="fe nx ny nz oa b"><em class="lv">BookAuthor </em></code>副本作为一个实体</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a6e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多版本文档是存储用于创建转换模型的实体的多个版本的基类。</p><p id="0d0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">版本控制系统由一个前缀和实体的id组成，在我的例子中，多版本文档有一个基本前缀(可以删除)，因为每个转换后的文档都有一个主事件，转换后的文档将存储该前缀。</p><p id="ceb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多版本文档有两个主要方法，<code class="fe nx ny nz oa b">CanSetVersion</code>和<code class="fe nx ny nz oa b">SetVersion</code>，主要检查是否有更低版本，如果有，则设置为新版本。其他两个派生方法使用预定义的前缀<code class="fe nx ny nz oa b">CanSetOwnVersion</code>和<code class="fe nx ny nz oa b">SetOwnVersion</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="fdfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nx ny nz oa b">MultiVersionField</code>是来自我们转换类的versionable属性的基类(参见<code class="fe nx ny nz oa b">BookExpanded </code>模型中的<code class="fe nx ny nz oa b">Author </code>属性)。我们希望能够更新这个属性，只要有一个更新的版本，但使它无缝</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0ce1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我可以展示整个BookExpanded模型。您可以看到，为了构建这个模型，我使用了图书事件，而不是作者事件。因为作者将被存储在一个单独的副本中，所以我们使用构建的BookAuthor模型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="a661" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">实现—侦听器消费者</h1><p id="e096" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这是一个很长的阅读，所以对于那些设法达到这一步的人，谢谢大家！</p><p id="48ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一节中，我将向您展示最终消费者以及他们如何利用最终构建的模型</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/ed3aa8b5452a6897fffcf132341e5c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*ORno5gdZtmkoCXO0vXGGuA.png"/></div></figure><p id="b2e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这里只展示一个示例，您可以在GitHub链接中查看其余的示例。下面创建了ConsumerAuthorCreated，所有消费者的模式都是相似的，我们首先创建作者，并检查在收到该事件之前是否创建了任何书籍。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="7709" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">读数</strong></h1><div class="oc od gp gr oe of"><a href="https://vithursa.medium.com/out-of-order-events-processing-techniques-ab3fbb6f8b" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">无序事件处理技术</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">在这个快速的世界里，每一项操作和功能都涉及到大量的数据，而不依赖于领域…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">vithursa.medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot kp of"/></div></div></a></div><p id="d8ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.researchgate.net/figure/A-summary-of-the-out-of-order-event-processing-techniques_tbl4_323160411" rel="noopener ugc nofollow" target="_blank">https://www . researchgate . net/figure/A-summary-of-the-out-of-order-event-processing-techniques _ TBL 4 _ 323160411</a></p><div class="oc od gp gr oe of"><a href="https://www.martinfowler.com/eaaDev/RetroactiveEvent.html" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">追溯事件</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">处理追溯事件意味着我们当前的应用程序状态在某些方面是不正确的。如果我们…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.martinfowler.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot kp of"/></div></div></a></div></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="e7d8" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">分级编码</h1><p id="193f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="3a07" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="1a94" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">📰查看<a class="ae kv" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="b517" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">🔔关注我们:<a class="ae kv" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae kv" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae kv" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="9f50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🚀👉<a class="ae kv" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>