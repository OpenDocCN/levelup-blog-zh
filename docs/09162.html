<html>
<head>
<title>A Crash Course on Binary Search Trees in GoLang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗的二分搜索法树速成班</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-crash-course-on-binary-search-trees-in-golang-41251020477d?source=collection_archive---------8-----------------------#2021-07-12">https://levelup.gitconnected.com/a-crash-course-on-binary-search-trees-in-golang-41251020477d?source=collection_archive---------8-----------------------#2021-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dcf3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习递归，提高您的计算机科学编程基础！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/65466238bd6b12ec49fe99f3e311ccd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XLeNAZS_2gJBHheg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">从<a class="ae ky" href="https://images.unsplash.com/photo-1502082553048-f009c37129b9?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1650&amp;q=80" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="efbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> B </span>二进制搜索树(BST)是计算机科学的一个众所周知的棘手但有用的子领域。利用BST要求程序员熟悉递归函数和用于操作树的各种算法，比如插入或删除节点。如果你能学会流利地使用二分搜索法树，你就已经开始着手处理计算机科学中的许多其他基础知识了，因为我个人认为BST是一些最难开始学习的数据结构(但也是一些最有价值的!)).</p><p id="d7a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始之前，<strong class="lb iu">到底什么是二叉查找树</strong>？嗯，基于树的数据结构简单地由信息节点组成，这些节点以类似树的方式连接到其他节点。二叉树有一个根节点，可能有左右两个子节点，每个子节点都有自己的子节点。基于两个孩子的树表示一个二叉树，你也可以有一个基于三个孩子的树，这是一个三叉树，等等。在树的最底部没有孩子的节点被表示为叶节点。这里有一个二叉树的例子:</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="04da" class="mj mk it mf b gy ml mm l mn mo">        ___1___       # a single root node<br/>       /       \     <br/>      4         3     # up to two children<br/>     / \       / \<br/>    0   9     13  14  # 0 and 14 are leaf nodes<br/>       / \     \<br/>      7   10    2     # so are 7, 10 and 2</span></pre><p id="2827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">二叉树和二叉查找树的区别是什么？BST附带的规则是，对于树中的每个节点，保证每个左边的子节点都小于其父节点，每个右边的子节点都大于或等于其父节点。这带来了快速操作时间的额外好处，因为我们可以通过搜索左侧或右侧的子分支来快速查找要操作的节点。<strong class="lb iu">这里有一个二进制<em class="mp">搜索</em>树的例子:</strong></p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="91df" class="mj mk it mf b gy ml mm l mn mo">           ______7______<br/>          /             \<br/>        _3_           __11__<br/>       /   \         /      \<br/>      1     5       9       13<br/>     / \   / \     / \     /  \<br/>    0   2 4   6   8   10  12  14</span></pre><p id="816a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经熟悉了BST的一般规则，我们就可以深入研究一些常见的操作和与之相关的方法。<strong class="lb iu">本文将涵盖以下4种BST方法:</strong></p><ul class=""><li id="1273" class="mq mr it lb b lc ld lf lg li ms lm mt lq mu lu mv mw mx my bi translated">验证BST</li><li id="1691" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">在BST中搜索节点</li><li id="bce2" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">将节点插入BST</li><li id="8f0e" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">删除BST中的节点</li></ul><p id="3f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="mp">注:</em> </strong> <em class="mp">本文假设了Go中的基本编程技巧以及时间和空间复杂度的大O符号。你还应该知道</em> <a class="ae ky" href="https://www.geeksforgeeks.org/how-to-add-a-method-to-struct-type-in-golang/" rel="noopener ugc nofollow" target="_blank"> <em class="mp">如何给struct </em> </a> <em class="mp">添加方法。</em></p><p id="7b51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来编码吧！</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="0907" class="nl mk it bd nm nn no np nq nr ns nt nu jz nv ka nw kc nx kd ny kf nz kg oa ob bi translated">验证BST</h1><p id="7a47" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">为了在BST上执行操作，我们首先需要一个有效的BST。在这个例子中，我们将遍历一个算法，以确保我们有一个有效的树。我们如何做到这一点？我们需要验证对于每一个节点，它的所有左边的子节点都小于它的值，而所有右边的子节点都大于或等于它的值。</p><p id="436b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<strong class="lb iu">递归</strong>和一些简单的检查来实现。对于第一个条件，我们需要确保对于我们当前所在的任何节点，该节点的值都在其在树中的配置范围内。<strong class="lb iu">让我们快速看几个例子。</strong></p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="96f6" class="mj mk it mf b gy ml mm l mn mo">      ______7______           # the root can be any value<br/>     /             \<br/>   _3_           __11__       # 11 must be &gt; 7<br/>  /   \         /      \<br/> 1     5       9       13     # 5 must be &lt; 7, but &gt; 3<br/>/ \   / \     / \     /  \<br/>0   2 4   6   8   10  12  14  # 9 must be &gt; 7, but &lt; 11</span></pre><blockquote class="oh oi oj"><p id="307d" class="kz la mp lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">要注意的模式是，如果我们去一个节点的右边的子节点，这个子节点必须大于它的父节点。如果我们去一个节点的左边的子节点，这个子节点必须总是小于它的父节点值。无论我们沿着树往下走多远，这两条规则都是正确的。因此，为了获得每个节点的值的有效范围，我们可以传递父节点的值来更新所有后续子节点各自的最小值或最大值。</p></blockquote><p id="e8d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把它写成代码。假设所有节点都有三个属性<code class="fe on oo op mf b">Value</code>、<code class="fe on oo op mf b">Left</code>和<code class="fe on oo op mf b">Right</code>，其中left和right代表其子值，因此可以是<code class="fe on oo op mf b">nil</code>。因此，在我们检查节点的<code class="fe on oo op mf b">Left</code>或<code class="fe on oo op mf b">Right</code>子节点是否是<code class="fe on oo op mf b">nil</code>之后，我们可以递归地检查子节点是否不是有效的BST子树。</p><blockquote class="oh oi oj"><p id="4589" class="kz la mp lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">递归调用栈一开始可能很难理解，但是从基本情况开始是最容易的。在下面的代码中，我们的基本情况是检查当前节点(表示为树)的值是否大于我们当前的最小值，并且小于或等于我们当前的最大值。如果不满足这个条件，我们在第7行返回false。然后我们在第9行和第12行的左边和右边的子树上递归地继续这个逻辑。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="1e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，如果我们引用<code class="fe on oo op mf b">tree.Left</code>，我们必须更新我们的最大值。如果我们下降<code class="fe on oo op mf b">tree.Right</code>，我们必须更新我们的最小值。如果这看起来有点模糊，试着用几个例子来解决它。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="5bc9" class="mj mk it mf b gy ml mm l mn mo">  5   # 5 can be any value<br/> / \<br/>6   6 # tree.Left.validateBst() cannot be &gt; 5, return false</span></pre><p id="5964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们在函数的最后返回<code class="fe on oo op mf b">true</code>，如果我们没有违反每个节点的最小值和最大值的条件，我们将只返回<code class="fe on oo op mf b">true</code>。</p><blockquote class="oh oi oj"><p id="ba4e" class="kz la mp lb b lc ld ju le lf lg jx lh ok lj lk ll ol ln lo lp om lr ls lt lu im bi translated">但是等等，为什么我们需要两个功能而不是一个？当涉及到递归代码逻辑时，除了使用正确的起始值调用递归函数的独立函数之外，通常还需要一个递归函数来调用自身。</p></blockquote><p id="090d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们有一个独立的函数<code class="fe on oo op mf b">ValidateBst()</code>，它用正确的起始值调用递归函数<code class="fe on oo op mf b">validateBst()</code>。为什么起始值是<code class="fe on oo op mf b">MinInt32</code>和<code class="fe on oo op mf b">MaxInt32</code>？因为我们的第一个根节点的值可以是任何值，但是一旦我们向下移动一个左边或右边的子节点，父节点的值就会分别变成这些子节点的最大值或最小值。我已经尽力解释了这段代码的逻辑，但是没有什么比自己做一些小例子更好的了。:)</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="51b3" class="nl mk it bd nm nn no np nq nr ns nt nu jz nv ka nw kc nx kd ny kf nz kg oa ob bi translated">在BST中搜索节点</h1><p id="50bb" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">唷，如果你成功地验证了这棵树，<strong class="lb iu">给自己一个鼓励，感谢你对学习的坚持！下一个问题应该更容易理解。在BST中搜索节点只需要根据我们要搜索的值是小于、等于还是大于当前节点的值来遍历节点。</strong></p><p id="6687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要检查这三个条件。在下面的代码中，我们有一个递归函数<code class="fe on oo op mf b">Contains()</code>，它接受一个整数<code class="fe on oo op mf b">value</code>，并返回一个关于树是否包含<code class="fe on oo op mf b">value</code>的布尔值。我们首先检查<code class="fe on oo op mf b">value</code>是否等于当前节点的<code class="fe on oo op mf b">Value</code>。如果是，我们就完成了，可以返回<code class="fe on oo op mf b">true</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="1e6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，我们必须检查值是否小于或大于当前节点的<code class="fe on oo op mf b">Value</code>。如果少，我们先检查一下左边的孩子是不是<code class="fe on oo op mf b">nil</code>。如果<code class="fe on oo op mf b">Left</code>子节点是<code class="fe on oo op mf b">nil</code>，那么<code class="fe on oo op mf b">tree</code>不可能包含<code class="fe on oo op mf b">value</code>，我们返回false。如果有一个<code class="fe on oo op mf b">Left</code>子节点，我们将递归调用<code class="fe on oo op mf b">Contains()</code>函数——检查我们是否遇到一个<code class="fe on oo op mf b">value</code>等于<code class="fe on oo op mf b">tree.Value</code>的节点。当值大于当前节点的<code class="fe on oo op mf b">Value</code>时，同样的逻辑也适用，我们必须递归调用子节点<code class="fe on oo op mf b">Right</code>上的<code class="fe on oo op mf b">Contains()</code>。</p><p id="4834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="mp">注:</em> </strong> <em class="mp">有没有发现我们这里只需要一个递归函数？这是因为我们从来不需要更新被传递的值，我们对每个递归调用都使用相同的整数值。</em></p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="97b9" class="nl mk it bd nm nn no np nq nr ns nt nu jz nv ka nw kc nx kd ny kf nz kg oa ob bi translated">将节点插入BST</h1><p id="202a" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">既然我们知道了BST中的搜索是如何工作的，那么插入一个节点就很容易了。插入与搜索有几乎相同的逻辑——有一点需要注意的是，如果没有子节点<code class="fe on oo op mf b">nil</code>，我们就不能再遍历到当前节点的<code class="fe on oo op mf b">Left</code>或<code class="fe on oo op mf b">Right</code>,然后我们用输入<code class="fe on oo op mf b">value</code>创建并插入一个新节点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="89f9" class="nl mk it bd nm nn no np nq nr ns nt nu jz nv ka nw kc nx kd ny kf nz kg oa ob bi translated">删除BST中的节点</h1><p id="3057" class="pw-post-body-paragraph kz la it lb b lc oc ju le lf od jx lh li oe lk ll lm of lo lp lq og ls lt lu im bi translated">好了，大的来了。删除二叉查找树中的节点不是一件简单的事情。这是因为我们必须处理多种情况，比如要删除的节点没有子节点、只有一个子节点或者有两个子节点。前两种情况没有那么糟糕，但是在删除一个有两个子节点的节点时，为了保持BST的有效性，您必须小心。</p><p id="a684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何维护有效BST的一个关键方面是将当前节点的父节点传递给我们的递归调用。因为我们正在更新我们的递归参数，我们将需要独立方法<code class="fe on oo op mf b">Remove()</code>来调用递归方法<code class="fe on oo op mf b">remove()</code>。</p><p id="4d28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的前几个条件只是导航到我们想要删除的节点。与搜索和插入相同，我们检查<code class="fe on oo op mf b">value</code>是否小于或大于当前<code class="fe on oo op mf b">tree.Value</code>。如果两个条件都不成立，那就意味着我们找到了要删除的目标节点。当一个节点有一个父节点时，我们将有两个单独的方法来处理一般情况，以及当我们试图删除BST的根节点时的边缘情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="75f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于删除具有父节点的节点的一般情况，我们有前面提到的四种情况。如果我们没有孩子，那么我们的生活会很轻松！我们只需检查当前节点是否等于<code class="fe on oo op mf b">parent</code>的<code class="fe on oo op mf b">Right</code>子节点或<code class="fe on oo op mf b">parent</code>的<code class="fe on oo op mf b">Left</code>子节点。然后我们简单地设置<code class="fe on oo op mf b">parent.Right</code>或<code class="fe on oo op mf b">parent.Left</code>等于<code class="fe on oo op mf b">nil</code>。</p><p id="e01a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只有一个孩子，事情也不会复杂多少。我们通常会发现要删除的节点是父节点的<code class="fe on oo op mf b">Left</code>还是<code class="fe on oo op mf b">Right</code>子节点。然后，我们将要删除的节点的相应子节点分配给父节点。这听起来很奇怪，所以让我们看一个例子，其中要删除的节点是5。这通过设置下面第20行的<code class="fe on oo op mf b">parent.Right = tree.Left</code>来完成。</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="bd9b" class="mj mk it mf b gy ml mm l mn mo">    _3_                   _3_   # if 4 had any children, we would<br/>   /   \                 /   \  # keep them in tact to maintain the<br/>  1     5       ==&gt;     1     4 # BST properties.<br/> / \   /               / \   <br/>0   2 4               0   2   </span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="8aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">常规节点的最后一种情况是当要删除的节点有两个子节点时的<strong class="lb iu">。问题是当我们删除那个节点时，我们必须保持BST的有效性和完整性。但是我们用哪个子节点替换现在被删除的节点呢？该节点实际上是被删除节点的右子树中的最小节点，因为它是唯一维护BST属性的节点(自己检查一下！).</strong></p><p id="9a78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过将待删除节点的值设置为等于该节点右边子树中的最小值来解决这个问题(第24行)。然后，我们将删除右边子树中的最小值，因为它是重复的，我们不再希望它出现在我们的树中。更多例子！让我们删除下面树中值为11的节点。看看用12替换11是如何维护我们的树的，以及为什么我们必须删除13下重复的12值？</p><pre class="kj kk kl km gt me mf mg mh aw mi bi"><span id="afbf" class="mj mk it mf b gy ml mm l mn mo">      ______7______                       ______7______<br/>     /             \                     /             \<br/>   _3_           __11__                _3_           __12__<br/>  /   \         /      \      ==&gt;     /   \         /      \<br/> 1     5       9       13            1     5       9       13<br/>/ \   / \     / \     /  \          / \   / \     / \     /  \<br/>0  2 4   6   8   10  12  14        0   2 4   6   8   10  xx  14</span></pre><p id="a066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">寻找最小值的方法只是递归地在树中尽可能向左看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="b571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有最后一种情况，那就是我们需要删除BST本身的根。这种情况遵循与常规节点相同的逻辑，只是我们没有父节点，所以我们必须手动定义新的关系和树的新根。我们成功了！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="b29d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你知道了！<strong class="lb iu">这是二叉查找树最常见的四种表演方法。</strong>还有更多的操作，如各种类型的遍历、反转二叉树等等。如果你喜欢这篇文章或者想要一个你感兴趣的话题的教程，我鼓励你在下面留下评论！感谢您的阅读。:)</p></div></div>    
</body>
</html>