<html>
<head>
<title>JavaScript Best Practices — Object Creation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—对象创建</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-object-creation-511036aee198?source=collection_archive---------10-----------------------#2020-05-29">https://levelup.gitconnected.com/javascript-best-practices-object-creation-511036aee198?source=collection_archive---------10-----------------------#2020-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/817cdcf8b796085fa90b7d2b8f0c5044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zV8BaTGmYzlXpjrK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@russn_fckr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> russn_fckr </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d9fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用默认参数和属性缩写，清理我们的JavaScript代码很容易。</p><p id="1073" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究在JavaScript代码中创建对象的最佳实践。</p><p id="ab1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将研究对象文字、工厂函数、<code class="fe le lf lg lh b">Object.create</code>和构造函数/类的使用。</p><h1 id="8cb2" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">对象文字</h1><p id="7f60" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以用对象文字符号创建对象。它不需要创建类、构造函数或原型。</p><p id="4d7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只是将所有内容放在花括号内，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="922a" class="mt lj it lh b gy mu mv l mw mx">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};</span></pre><p id="4b84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对于只创建一次的对象很有好处。</p><p id="0747" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们需要创建多个具有相同结构的对象，那么我们必须找到另一种方法。</p><h1 id="f645" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">工厂功能</h1><p id="7d7d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">工厂函数是返回新对象的函数。</p><p id="2124" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="cd46" class="mt lj it lh b gy mu mv l mw mx">const create = () =&gt; ({<br/>  a: 1,<br/>  b(){}<br/>});</span><span id="d4b6" class="mt lj it lh b gy my mv l mw mx">const obj = create();</span></pre><p id="8e1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用<code class="fe le lf lg lh b">create</code>对象来返回并分配对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d3b6" class="mt lj it lh b gy mu mv l mw mx">{<br/>  a: 1,<br/>  b(){}<br/>}</span></pre><p id="e29a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">去<code class="fe le lf lg lh b">obj</code>。</p><p id="f697" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">工厂函数会导致内存膨胀，因为每个对象都有自己唯一的<code class="fe le lf lg lh b">b</code>方法副本。</p><h1 id="b02c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">原型链</h1><p id="ddfd" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以通过使用<code class="fe le lf lg lh b">Object.create</code>方法创建继承另一个对象属性的对象。</p><p id="2137" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种继承被称为原型链。</p><p id="fec2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用如下方法:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="51f5" class="mt lj it lh b gy mu mv l mw mx">const create = () =&gt; {<br/>  const parent = {<br/>    a: 1,<br/>    b() {}<br/>  }<br/>  return Object.create(parent);<br/>};</span><span id="2f7b" class="mt lj it lh b gy my mv l mw mx">const obj = create();</span></pre><p id="7c97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在用<code class="fe le lf lg lh b">create</code>创建的每个对象都继承了<code class="fe le lf lg lh b">parent</code>对象的属性。</p><p id="d83b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建的对象总是具有带有<code class="fe le lf lg lh b">parent</code>属性的<code class="fe le lf lg lh b">__proto__</code>属性。</p><h1 id="6890" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">ES5构造函数</h1><p id="8d15" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">构造函数是充当对象模板的函数。</p><p id="0fbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个对象都是作为构造函数的字段和方法创建的。</p><p id="bb5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的所有实例都引用这些字段和方法。</p><p id="5932" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以定义如下:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b0d8" class="mt lj it lh b gy mu mv l mw mx">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="dfb7" class="mt lj it lh b gy my mv l mw mx">Person.prototype.greet = function() {<br/>  return `hi ${this.name}`;<br/>}</span></pre><p id="5029" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以使用<code class="fe le lf lg lh b">new</code>关键字通过编写以下代码来创建一个<code class="fe le lf lg lh b">Person</code>构造函数的实例:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="74b8" class="mt lj it lh b gy mu mv l mw mx">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="9210" class="mt lj it lh b gy my mv l mw mx">Person.prototype.greet = function() {<br/>  return `hi ${this.name}`;<br/>}</span><span id="2769" class="mt lj it lh b gy my mv l mw mx">const joe = new Person('joe');<br/>const greeting = joe.greet();</span></pre><p id="f7e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">greet</code>方法是<code class="fe le lf lg lh b">Person</code>构造函数的实例方法，所以我们可以在从<code class="fe le lf lg lh b">new</code>关键字创建的对象上调用它。</p><p id="f4e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将一个方法附加到构造函数的<code class="fe le lf lg lh b">prototype</code>属性，那么它就成为构造函数的方法。</p><p id="1cf4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不想再用它了，因为它又长又丑，而且容易出错。</p><h1 id="f8d9" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">ES6类</h1><p id="449f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">更好的方法是使用ES6类，它是ES5构造函数之上的语法糖。</p><p id="22c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们是相同的东西，只是语法更好。</p><p id="38ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可以将上面的例子改写为:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="34fb" class="mt lj it lh b gy mu mv l mw mx">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="3e1b" class="mt lj it lh b gy my mv l mw mx">  greet() {<br/>    return `hi ${this.name}`;<br/>  }<br/>}</span><span id="4181" class="mt lj it lh b gy my mv l mw mx">const joe = new Person('joe');<br/>const greeting = joe.greet();<br/>console.log(greeting);</span></pre><p id="928a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，下列内容:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f1ac" class="mt lj it lh b gy mu mv l mw mx">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="96e7" class="mt lj it lh b gy my mv l mw mx">  greet() {<br/>    return `hi ${this.name}`;<br/>  }<br/>}</span></pre><p id="0e54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与以下内容相同:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c866" class="mt lj it lh b gy mu mv l mw mx">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="73e2" class="mt lj it lh b gy my mv l mw mx">Person.prototype.greet = function() {<br/>  return `hi ${this.name}`;<br/>}</span></pre><p id="e2b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个示例的其余代码是相同的。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/182f780b076769fde246ce637f18d50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wjwCVcCMJQ58bta_"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@ethanhjy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">胡伊森</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="8e82" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">表演</h1><p id="979a" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">类语法比返回对象文字的工厂函数大约快3倍。</p><p id="55d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是使用ES6类语法的更多原因。对开发者和浏览器来说都更快。</p><h1 id="06ca" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">私人数据</h1><p id="d2f6" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以用闭包和弱映射封装私有数据。</p><p id="6415" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只需要用<code class="fe le lf lg lh b">let</code>和<code class="fe le lf lg lh b">const</code>给类和函数的let添加私有变量。那么它们在函数之外是不可用的。</p><p id="f667" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有当对键的引用仍然存在时，才能检索弱映射。一旦它被破坏，那么给定键的值就没有了。</p><p id="9ccd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们都允许我们将不同的属性混合到一个构造函数中，或者将对象混合到一个实体中。</p><h1 id="c6e1" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="9a2d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">对象文字和工厂函数提供了创建一次性对象的简单方法。</p><p id="13d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想创建多个具有相同结构的对象，那么我们必须使用类或<code class="fe le lf lg lh b">Object.create</code>方法。</p><p id="b2b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类语法创建对象的速度比工厂函数快，所以这可能是使用类的一个优势。</p></div></div>    
</body>
</html>