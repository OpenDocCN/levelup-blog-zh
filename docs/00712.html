<html>
<head>
<title>I Wrote A Frontend Framework Without Any Frontend Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我写了一个前端框架，没有任何前端代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/i-wrote-a-frontend-framework-without-any-frontend-code-4e93ae321a4?source=collection_archive---------0-----------------------#2019-07-05">https://levelup.gitconnected.com/i-wrote-a-frontend-framework-without-any-frontend-code-4e93ae321a4?source=collection_archive---------0-----------------------#2019-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cd96edd4ff65d40a27f345c40dee3554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O8s-GnxQPCyWNVc2WJyB5g.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@goran_ivos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Goran Ivos </a>在<a class="ae kf" href="https://unsplash.com/search/photos/frontend?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="90e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我喜欢围棋。我不喜欢JavaScript。所以我提出了这个问题…</p><blockquote class="le"><p id="ad20" class="lf lg it bd lh li lj lk ll lm ln ld dk translated">如果不使用JavaScript或其生态系统，我如何编写一个反应式的单页应用程序呢？</p></blockquote><p id="288b" class="pw-post-body-paragraph kg kh it ki b kj lo kl km kn lp kp kq kr lq kt ku kv lr kx ky kz ls lb lc ld im bi translated">这是我想到的:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="752a" class="mc md it ly b gy me mf l mg mh">package main</span><span id="b472" class="mc md it ly b gy mi mf l mg mh">import "github.com/elliotchance/pepper"</span><span id="c7bd" class="mc md it ly b gy mi mf l mg mh">type Counter struct {<br/>    Number int<br/>}</span><span id="79f7" class="mc md it ly b gy mi mf l mg mh">func (c *Counter) Render() (string, error) {<br/>    return `<br/>        Counter: {{ .Number }}&lt;br/&gt;<br/>        &lt;button <a class="ae kf" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>="AddOne"&gt;+&lt;/button&gt;<br/>    `, nil<br/>}</span><span id="9c99" class="mc md it ly b gy mi mf l mg mh">func (c *Counter) AddOne() {<br/>    c.Number++<br/>}</span><span id="5bb2" class="mc md it ly b gy mi mf l mg mh">func main() {<br/>    panic(pepper.StartServer(func() pepper.Component {<br/>        return &amp;Counter{}<br/>    }))<br/>}</span></pre><p id="717c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些代码封装了整个堆栈。如果您已经安装了Go，现在就可以试用:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="521b" class="mc md it ly b gy me mf l mg mh">go get -u github.com/elliotchance/pepper/examples/ex01_counter<br/>ex01_counter</span></pre><p id="704a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在在你的浏览器中打开<a class="ae kf" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a>…或者，看一下这张截图:</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/d8d5e98cbd5062c8cc3fc4dd6b2657dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*_5PToeRaOY72YfSthgyViw.png"/></div></figure><p id="dc6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，所以它不会赢得任何设计奖项，但点击<code class="fe mk ml mm ly b">+</code>按钮确实会像预期的那样增加数字。</p><h1 id="82a3" class="mn md it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">这到底是怎么回事？</h1><p id="1a1f" class="pw-post-body-paragraph kg kh it ki b kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated"><code class="fe mk ml mm ly b">Counter</code>是一个组件，因为它有一个<code class="fe mk ml mm ly b">Render()</code>方法。<code class="fe mk ml mm ly b">Render</code>返回一个将被正确呈现给客户端的<code class="fe mk ml mm ly b">html/template</code>。它可以引用任何状态，比如<code class="fe mk ml mm ly b">Number</code>，或者将事件绑定到方法，比如<code class="fe mk ml mm ly b">@click="AddOne"</code>。</p><p id="9dc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">架构非常简单。当浏览器打开页面(<a class="ae kf" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>)时，它返回了一个<em class="np">几乎为空的页面。这个页面包含一个空的<code class="fe mk ml mm ly b">div</code>和一些通过websocket连接的函数。</em></p><p id="5956" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">页面加载后，websocket将立即连接。连接后，服务器将呈现组件并发送HTML，它将被放置在页面上。</p><p id="cd92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以这只是后端渲染？嗯，是也不是。它有效地呈现了整个组件，并通过websocket发送整个HTML。然而，那只是因为现在这很容易。服务器可以被优化来发送diff，或者完全避免呈现未改变的组件。</p><h1 id="711e" class="mn md it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">我能用它吗？</h1><p id="4b19" class="pw-post-body-paragraph kg kh it ki b kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated"><strong class="ki iu">花椒还是极具实验性的。</strong>它需要持续连接到服务器(用于websocket ),所以它不适用于任何必须离线运行的东西，也不适用于互联网不稳定的情况。</p><p id="adeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想pepper的一些很好的用例是:</p><ol class=""><li id="56e4" class="nq nr it ki b kj kk kn ko kr ns kv nt kz nu ld nv nw nx ny bi translated">显示实时数据。流式指标、图表、日志、仪表板等。</li><li id="f443" class="nq nr it ki b kj nz kn oa kr ob kv oc kz od ld nv nw nx ny bi translated">依赖持久连接的应用程序。如聊天客户端、定时互动考试等。</li><li id="5b2a" class="nq nr it ki b kj nz kn oa kr ob kv oc kz od ld nv nw nx ny bi translated">受益于持久状态的应用程序。整个状态可以保存或恢复成JSON这样的序列化格式。非常适合有许多问题/步骤的表单或调查。</li><li id="1741" class="nq nr it ki b kj nz kn oa kr ob kv oc kz od ld nv nw nx ny bi translated">构建前端应用的原型。无需设置复杂的环境、构建工具和依赖项，就可以轻松启动、运行和迭代更改。</li></ol><h1 id="0212" class="mn md it bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated">还有更复杂的例子吗？</h1><p id="fc0d" class="pw-post-body-paragraph kg kh it ki b kj nk kl km kn nl kp kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">是啊！浏览主存储库页面上的<a class="ae kf" href="https://github.com/elliotchance/pepper#examples" rel="noopener ugc nofollow" target="_blank">示例，其中涵盖了表单、嵌套组件，到您阅读本文时可能还会有更多内容。</a></p></div></div>    
</body>
</html>