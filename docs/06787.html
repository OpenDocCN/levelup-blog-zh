<html>
<head>
<title>Microservices in Rust with GraphQL and Cap’n Proto</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL和Cap'n Proto的防锈微服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/microservices-in-rust-with-graphql-and-capn-proto-e125bec23eae?source=collection_archive---------5-----------------------#2020-12-31">https://levelup.gitconnected.com/microservices-in-rust-with-graphql-and-capn-proto-e125bec23eae?source=collection_archive---------5-----------------------#2020-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dc4d9f7dca82e995e8a99ec6705c9908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ll4m9oMn7L-K_zp9wWxfxQ.png"/></div></div></figure><h1 id="dac2" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">概观</h1><p id="1ea0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我发现这个话题很有趣，因为我目前正在从事一个个人物联网项目，我一直在寻找能够提供最佳性能的技术。Rust吸引了我的注意力，因为它在过去的几年里越来越受欢迎。在我看来，我们可以把它看作是C++的改进版本，因为它有更好的内存管理和安全性。此外，这是一种命令式编程语言，不像Java、Python、Ruby等是面向对象的。我们也可以将它与Go进行比较，因为它也具有功能性风格，但我更喜欢Rust，因为它的安全性和性能。</p><p id="65f7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我也是一名Go程序员，我认为它在并发性方面非常出色，毫无疑问，Go的创造者在设计和工程方面做了出色的工作。由于这个事实，与其他语言相比，我们可以很容易地使用go例程和通道来处理并发性。也许这是Rust的一个缺点，因为很难使用任何像tokio或async-std这样的异步机箱来处理线程。你可以查看一个echo服务器示例来清楚地理解我想说的话<a class="ae lz" href="https://github.com/seguidor777/tls_echo" rel="noopener ugc nofollow" target="_blank">https://github.com/seguidor777/tls_echo</a></p><p id="e484" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">另一方面，我选择GraphQL是因为它吸引了我的注意力，而且我更喜欢它而不是REST json。我给大家分享一个简短的故事:</p><p id="5481" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">脸书在2015年创建了GraphQL，此后一直受到主流开发者的关注。GraphQL不仅减少了噪音，还允许用户使用应用程序时有更好的界面。自从GraphQL降低了它所有的复杂性后，它就被弃用了。</p><p id="1e54" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最后，我们为微服务之间的服务间通信提供了Cap'n proto。可以把Capnp想象成一个RPC框架，非常类似于gRPC，但是要快得多，因为它不需要对消息进行编码/解码。我就不多说了，不过你可以看看它的网页【https://capnproto.org/<a class="ae lz" href="https://capnproto.org/" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="3388" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">假设</h1><p id="eba5" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我假设你已经知道什么是微服务架构，我们不需要深入细节。</p><h1 id="bcff" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">计算机设置</h1><ul class=""><li id="f833" class="ma mb iq ky b kz la ld le lh mc ll md lp me lt mf mg mh mi bi translated">安装铁锈v 1.47+【https://www.rust-lang.org/tools/install T4】。</li><li id="7b36" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated">安装Cap'n原型工具v 0 . 8 . 0+<a class="ae lz" href="https://capnproto.org/install.html" rel="noopener ugc nofollow" target="_blank">https://capnproto.org/install.html</a>。</li></ul><h1 id="46b9" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">创建微服务</h1><p id="846a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这个演示应用程序仅用于与模拟的starwars数据库交互，由两个微服务组成:</p><p id="fa54" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">元数据:</strong>执行查询以在数据库中查找或创建一个人。</p><p id="64f4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> API网关:</strong>分派外部GraphQL请求，并将它们重定向到元数据服务。</p><p id="9858" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">注意:</strong>我们没有任何外部依赖。但是如果你愿意，你可以试试蟑螂和sqlx箱子。</p><h1 id="006b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">元数据服务</h1><p id="3870" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们已经准备好开始编码元数据服务了。让我们用命令<strong class="ky ir"> cargo new metadata </strong>创建一个新项目</p><p id="564c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们的<strong class="ky ir"> Cargo.toml </strong>文件应该如下所示(版本可能不同):</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c7a3" class="mx jz iq mt b gy my mz l na nb">[package]<br/>name = "metadata"<br/>version = "0.1.0"<br/>authors = ["Jorge Luna &lt;<a class="ae lz" href="mailto:seguidor777@gmail.com" rel="noopener ugc nofollow" target="_blank">j</a>orge.luna@digitalonus.com&gt;"]<br/>edition = "2018"</span><span id="580d" class="mx jz iq mt b gy nc mz l na nb">[dependencies]<br/>capnp = "0.14.0"<br/>capnp-rpc = "0.14.0"<br/>futures = "0.3.0"<br/>async-std = { version = "1.8.0", features = ["unstable"] }</span><span id="25cd" class="mx jz iq mt b gy nc mz l na nb">[build-dependencies]<br/>capnpc = "0.14.1"</span></pre><p id="cf3c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后我们需要定义Capnp模式和生成新Rust模块的构建脚本。</p><p id="1e2a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> capnp/starwars.capnp </strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4cf5" class="mx jz iq mt b gy my mz l na nb">@0xc1da187e3c0d97cd;<br/><br/>interface StarWars {<br/>    struct Human {<br/>      id @0 :Text;<br/>      name @1 :Text;<br/>      homePlanet @2 :Text;<br/>      appearsIn @3 :AppearsIn;<br/><br/>      enum AppearsIn {<br/>        newHope @0;<br/>        empire @1;<br/>        jedi @2;<br/>      }<br/>    }<br/><br/>    showHuman @0 (id: Text) -&gt; Human;<br/>    createHuman @1 Human -&gt; Human;<br/>}</span></pre><p id="df7a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> build.rs </strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4c8d" class="mx jz iq mt b gy my mz l na nb">fn main() {<br/>    ::capnpc::CompilerCommand::<em class="nd">new</em>()<br/>        .src_prefix("capnp")<br/>        .file("capnp/starwars.capnp")<br/>        .run().expect("failed to compile schema");<br/>}</span></pre><p id="ccd7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后我们需要编辑<strong class="ky ir"> main.rs </strong>文件如下。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="776a" class="mx jz iq mt b gy my mz l na nb">mod rpc;<br/>pub mod starwars_capnp {<br/>    include!(concat!(env!("OUT_DIR"), "/starwars_capnp.rs"));<br/>}<br/><br/>fn main() {<br/>    rpc::server::run().expect("cannot run server")<br/>}</span></pre><p id="d8ed" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">还要为RPC服务器创建一个新模块，我们需要这些文件:</p><p id="5f33" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> src/rpc/mod.rs </strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="434c" class="mx jz iq mt b gy my mz l na nb">pub mod server;</span></pre><p id="b31d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> src/rpc/server.rs </strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2b2d" class="mx jz iq mt b gy my mz l na nb">use crate::starwars_capnp;<br/>use capnp::capability::Promise;<br/>use capnp_rpc::{pry, RpcSystem};<br/>use capnp_rpc::twoparty::{VatNetwork};<br/>use capnp_rpc::rpc_twoparty_capnp::{Side};<br/>use futures::{AsyncReadExt, FutureExt};<br/>use futures::task::LocalSpawnExt;<br/><br/>struct StarWars;<br/><br/>impl starwars_capnp::star_wars::Server for StarWars {<br/>    fn show_human(&amp;mut self, params: starwars_capnp::star_wars::ShowHumanParams, mut results: starwars_capnp::star_wars::ShowHumanResults)<br/>        -&gt; Promise&lt;(), capnp::Error&gt; {<br/>        // get a reader object for the sent request<br/>        let request_reader = pry!(params.get());<br/>        // get the send ID<br/>        let _id = request_reader.get_id();<br/><br/>        // set return values<br/>        results.get().set_name("Luke");<br/>        results.get().set_appears_in(starwars_capnp::star_wars::human::AppearsIn::NewHope);<br/>        results.get().set_home_planet("Mars");<br/>        Promise::<em class="nd">ok</em>(())<br/>    }<br/><br/>    fn create_human(&amp;mut self, params: starwars_capnp::star_wars::CreateHumanParams, mut results: starwars_capnp::star_wars::CreateHumanResults)<br/>        -&gt; Promise&lt;(), capnp::Error&gt; {<br/>        // get a reader object for the sent request<br/>        let request_reader = pry!(params.get());<br/><br/>        // set return values<br/>        results.get().set_id("1234");<br/>        results.get().set_name(request_reader.get_name().unwrap());<br/>        results.get().set_appears_in(request_reader.get_appears_in().unwrap());<br/>        results.get().set_home_planet(request_reader.get_home_planet().unwrap());<br/>        Promise::<em class="nd">ok</em>(())<br/>    }<br/>}<br/><br/>pub fn run() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {<br/>    let addr = "127.0.0.1:8001";<br/>    let mut exec = futures::executor::LocalPool::<em class="nd">new</em>();<br/>    let spawner = exec.spawner();<br/><br/>    exec.run_until(async move {<br/>        let listener = async_std::net::TcpListener::<em class="nd">bind</em>(&amp;addr).await.unwrap();<br/><br/>        println!("Metadata: tcp://{}", addr);<br/><br/>        let client: starwars_capnp::star_wars::Client = capnp_rpc::new_client(StarWars);<br/><br/>        loop {<br/>            let (stream, _) = listener.accept().await.unwrap();<br/><br/>            stream.set_nodelay(true).unwrap();<br/><br/>            let (reader, writer) = stream.split();<br/>            let network = VatNetwork::<em class="nd">new</em>(<br/>                reader,<br/>                writer,<br/>                Side::<em class="nd">Server</em>,<br/>                Default::<em class="nd">default</em>(),<br/>            );<br/><br/>            let rpc_system =<br/>                RpcSystem::<em class="nd">new</em>(Box::<em class="nd">new</em>(network), <em class="nd">Some</em>(client.clone().client));<br/><br/>            spawner.spawn_local(Box::<em class="nd">pin</em>(rpc_system.map(|_|())))?;<br/>        }<br/>    })<br/>}</span></pre><p id="41e8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们刚刚定义了用于服务间通信的RPC方法。</p><p id="4c97" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">一旦你有了所有的文件，安装依赖项并使用<strong class="ky ir"> cargo run </strong>运行项目</p><h1 id="ff05" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak"> API网关服务</strong></h1><p id="efd4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们通过使用<strong class="ky ir"> cargo new api-gateway </strong>创建另一个项目来创建API gateway服务</p><p id="7ee2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对于这个项目，我们将重用相同的<strong class="ky ir"> capnp/starwars.capnp </strong>和<strong class="ky ir"> build.rs </strong>文件，因为我们实际上共享相同的RPC模式。</p><p id="a29a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">将此依赖关系添加到<strong class="ky ir"> Cargo.toml </strong>文件中:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="fdca" class="mx jz iq mt b gy my mz l na nb">... Omitted for brevity<br/><br/>[dependencies]<br/>actix-web = "3"<br/>actix-cors = "0.4.0"<br/>actix-rt = "1.1.0"<br/>juniper_warp = "0.6.0"<br/>serde = "1.0.103"<br/>serde_json = "1.0.44"<br/>serde_derive = "1.0.103"<br/>juniper = "0.14.2"<br/>capnp = "0.14.0"<br/>capnp-rpc = "0.14.0"<br/>futures = "0.3.0"<br/>async-std = { version = "1.8.0", features = ["unstable"] }<br/><br/>[build-dependencies]<br/>capnpc = "0.14.1"</span></pre><p id="cfdd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">并编辑<strong class="ky ir"> main.rs </strong>文件如下:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="015d" class="mx jz iq mt b gy my mz l na nb">mod graphql;<br/>mod rpc;<br/>pub mod starwars_capnp {<br/>    include!(concat!(env!("OUT_DIR"), "/starwars_capnp.rs"));<br/>}<br/><br/>use actix_cors::Cors;<br/>use actix_web::{guard, middleware, web, App, Error, HttpResponse, HttpServer};<br/>use juniper::http::graphiql::graphiql_source;<br/>use juniper::http::GraphQLRequest;<br/>use graphql::schema::{create_schema, Schema};<br/>use std::io;<br/>use std::sync::Arc;<br/><br/>async fn graphiql() -&gt; HttpResponse {<br/>    let html = graphiql_source("http://127.0.0.1:8000/");<br/>    HttpResponse::<em class="nd">Ok</em>()<br/>        .content_type("text/html; charset=utf-8")<br/>        .body(html)<br/>}<br/><br/>async fn graphql(<br/>    st: web::Data&lt;Arc&lt;Schema&gt;&gt;,<br/>    data: web::Json&lt;GraphQLRequest&gt;,<br/>) -&gt; Result&lt;HttpResponse, Error&gt; {<br/>    let user = web::block(move || {<br/>        let res = data.execute(&amp;st, &amp;());<br/>        <em class="nd">Ok</em>::&lt;_, serde_json::error::Error&gt;(serde_json::to_string(&amp;res)?)<br/>    })<br/>        .await?;<br/>    <em class="nd">Ok</em>(HttpResponse::<em class="nd">Ok</em>()<br/>        .content_type("application/json")<br/>        .body(user))<br/>}<br/><br/>#[actix_web::main]<br/>async fn main() -&gt; io::Result&lt;()&gt; {<br/>    // Create Juniper schema<br/>    let schema = std::sync::Arc::<em class="nd">new</em>(create_schema());<br/>    let addr = "127.0.0.1:8000";<br/><br/>    println!("API Gateway: http://{}", addr);<br/><br/>    // Start http server<br/>    HttpServer::<em class="nd">new</em>(move || {<br/>        App::<em class="nd">new</em>()<br/>            .data(schema.clone())<br/>            .wrap(middleware::Logger::<em class="nd">default</em>())<br/>            .wrap(<br/>                Cors::<em class="nd">new</em>()<br/>                    .allowed_methods(vec!["POST", "GET"])<br/>                    .supports_credentials()<br/>                    .max_age(3600)<br/>                    .finish(),<br/>            )<br/>            .service(web::resource("/").guard(guard::Post()).to(graphql))<br/>            .service(web::resource("/").guard(guard::Get()).to(graphiql))<br/>    }).bind(addr)?<br/>    .run()<br/>    .await<br/>}</span></pre><p id="f919" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">基本上，我们正在运行GraphQL服务器，并注册了两条路由来分发来自操场的请求。</p><p id="07e8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">对于模式，让我们创建这些文件:</p><p id="316b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> src/graphql/mod.rs </strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3c03" class="mx jz iq mt b gy my mz l na nb">pub mod schema;</span></pre><p id="8365" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> src/graphql/schema.rs </strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8bc9" class="mx jz iq mt b gy my mz l na nb">use crate::rpc;<br/>use juniper::{FieldResult, RootNode};<br/>use juniper::{GraphQLEnum, GraphQLInputObject, GraphQLObject};<br/><br/>#[derive(GraphQLEnum)]<br/>pub enum Episode {<br/>    <em class="nd">NewHope</em>,<br/>    <em class="nd">Empire</em>,<br/>    <em class="nd">Jedi</em>,<br/>}<br/><br/>#[derive(GraphQLObject)]<br/>#[graphql(description = "A human of any type")]<br/>pub struct Human {<br/>    pub id: String,<br/>    pub name: String,<br/>    pub appears_in: Episode,<br/>    pub home_planet: String,<br/>}<br/><br/>#[derive(GraphQLInputObject)]<br/>#[graphql(description = "A new human of any type")]<br/>pub struct NewHuman {<br/>    pub name: String,<br/>    pub appears_in: Episode,<br/>    pub home_planet: String,<br/>}<br/><br/>pub struct QueryRoot;<br/><br/>#[juniper::object]<br/>impl QueryRoot {<br/>    fn <em class="nd">show_human</em>(id: String) -&gt; FieldResult&lt;Human&gt; {<br/>        rpc::client::show_human(id)<br/>    }<br/>}<br/><br/>pub struct MutationRoot;<br/><br/>#[juniper::object]<br/>impl MutationRoot {<br/>    fn <em class="nd">create_human</em>(new_human: NewHuman) -&gt; FieldResult&lt;Human&gt; {<br/>        rpc::client::create_human(new_human)<br/>    }<br/>}<br/><br/>pub type Schema = RootNode&lt;<em class="nd">'static</em>, QueryRoot, MutationRoot&gt;;<br/><br/>pub fn create_schema() -&gt; Schema {<br/>    Schema::<em class="nd">new</em>(QueryRoot {}, MutationRoot {})<br/>}</span></pre><p id="4c7e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里我们定义了json有效负载的结构以及查询和变异数据的方法的实现。</p><p id="5990" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">让我们定义用于将调用重定向到服务器的RPC客户端。</p><p id="74a7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">该模块由以下文件组成:</p><p id="ad46" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> src/rpc/mod.rs </strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="03e8" class="mx jz iq mt b gy my mz l na nb">pub mod client;</span></pre><p id="2f66" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir"> src/rpc/client.rs </strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7b80" class="mx jz iq mt b gy my mz l na nb">use crate::graphql::schema::{Episode, Human, NewHuman};<br/>use crate::starwars_capnp;<br/>use capnp_rpc::RpcSystem;<br/>use capnp_rpc::twoparty::VatNetwork;<br/>use capnp_rpc::rpc_twoparty_capnp::Side;<br/>use futures::{AsyncReadExt, FutureExt};<br/>use futures::task::{LocalSpawnExt};<br/>use juniper::FieldResult;<br/><br/>pub fn show_human(id: String) -&gt; FieldResult&lt;Human&gt; {<br/>    let mut exec = futures::executor::LocalPool::<em class="nd">new</em>();<br/>    let spawner = exec.spawner();<br/><br/>    exec.run_until(async move {<br/>        let mut rpc_system: RpcSystem&lt;Side&gt; = get_rpc_system().await?;<br/>        let starwars_client: starwars_capnp::star_wars::Client = rpc_system.bootstrap(Side::<em class="nd">Server</em>);<br/><br/>        spawner.spawn_local(Box::<em class="nd">pin</em>(rpc_system.map(|_|())))?;<br/><br/>        // Create get_result request object<br/>        let mut request = starwars_client.show_human_request();<br/><br/>        // Set Human ID<br/>        request.get().set_id(&amp;id);<br/><br/>        // Send request, and await response<br/>        let response = request.send().promise.await?;<br/><br/>        <em class="nd">Ok</em>(Human {<br/>            id,<br/>            name: response.get().unwrap().get_name().unwrap().to_string(),<br/>            appears_in: appears_in_from_capnp(response.get().unwrap().get_appears_in().unwrap()),<br/>            home_planet: response.get().unwrap().get_home_planet().unwrap().to_string(),<br/>        })<br/>    })<br/>}<br/><br/>pub fn create_human(new_human: NewHuman) -&gt; FieldResult&lt;Human&gt; {<br/>    let mut exec = futures::executor::LocalPool::<em class="nd">new</em>();<br/>    let spawner = exec.spawner();<br/><br/>    exec.run_until(async move {<br/>        let mut rpc_system: RpcSystem&lt;Side&gt; = get_rpc_system().await?;<br/>        let starwars_client: starwars_capnp::star_wars::Client = rpc_system.bootstrap(Side::<em class="nd">Server</em>);<br/><br/>        spawner.spawn_local(Box::<em class="nd">pin</em>(rpc_system.map(|_|())))?;<br/><br/>        // Create get_result request object<br/>        let mut request = starwars_client.create_human_request();<br/><br/>        // Set Human fields<br/>        request.get().set_name(&amp;new_human.name);<br/>        request.get().set_home_planet(&amp;new_human.home_planet);<br/>        request.get().set_appears_in(appears_in_to_capnp(new_human.appears_in));<br/><br/>        // Send request, and await response<br/>        let response = request.send().promise.await?;<br/><br/>        <em class="nd">Ok</em>(Human {<br/>            id: response.get().unwrap().get_id().unwrap().to_string(),<br/>            name: response.get().unwrap().get_name().unwrap().to_string(),<br/>            appears_in: appears_in_from_capnp(response.get().unwrap().get_appears_in().unwrap()),<br/>            home_planet: response.get().unwrap().get_home_planet().unwrap().to_string(),<br/>        })<br/>    })<br/>}<br/><br/>fn appears_in_from_capnp(appears_in: starwars_capnp::star_wars::human::AppearsIn) -&gt; Episode {<br/>    match appears_in {<br/>        starwars_capnp::star_wars::human::AppearsIn::NewHope =&gt; Episode::<em class="nd">NewHope</em>,<br/>        starwars_capnp::star_wars::human::AppearsIn::Empire =&gt; Episode::<em class="nd">Empire</em>,<br/>        starwars_capnp::star_wars::human::AppearsIn::Jedi =&gt; Episode::<em class="nd">Jedi</em>,<br/>    }<br/>}<br/><br/>fn appears_in_to_capnp(appears_in: Episode) -&gt; starwars_capnp::star_wars::human::AppearsIn {<br/>    match appears_in {<br/>        Episode::<em class="nd">NewHope </em>=&gt; starwars_capnp::star_wars::human::AppearsIn::NewHope,<br/>        Episode::<em class="nd">Empire </em>=&gt; starwars_capnp::star_wars::human::AppearsIn::Empire,<br/>        Episode::<em class="nd">Jedi </em>=&gt; starwars_capnp::star_wars::human::AppearsIn::Jedi,<br/>    }<br/>}<br/><br/>async fn get_rpc_system() -&gt; Result&lt;RpcSystem&lt;Side&gt;, Box&lt;dyn std::error::Error&gt;&gt; {<br/>    let stream = async_std::net::TcpStream::<em class="nd">connect</em>("127.0.0.1:8001").await?;<br/><br/>    stream.set_nodelay(true)?;<br/><br/>    let (reader, writer) = stream.split();<br/>    let network = Box::<em class="nd">new</em>(<br/>        VatNetwork::<em class="nd">new</em>(reader, writer, Side::<em class="nd">Client</em>, Default::<em class="nd">default</em>())<br/>    );<br/><br/>    <em class="nd">Ok</em>(RpcSystem::<em class="nd">new</em>(network, <em class="nd">None</em>))<br/>}</span></pre><p id="2aeb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里我们建立了与RPC服务器的连接，并使用来自GraphQL请求的相同数据执行调用。</p><p id="e10f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们需要翻译Enum类型，以与Capnp模式中定义的类型兼容。</p><p id="db1d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最后，用命令<strong class="ky ir"> cargo run </strong>在另一个shell中运行这个项目，并打开显示的URL。</p><h1 id="2c84" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">测试API </strong></h1><p id="e4b0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">从API网关服务访问URL<a class="ae lz" href="http://127.0.0.1:8000" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000</a>来访问GraphQL playground。</p><p id="9cb0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">运行下一个查询来显示人类数据:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="fc07" class="mx jz iq mt b gy my mz l na nb">{<br/>  showHuman(id: "1235") {<br/>    id<br/>    name<br/>    appearsIn<br/>    homePlanet<br/>  }<br/>}</span></pre><p id="d861" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">使用一些数据运行这个查询来创建一个新的人类，并查看结果。</p><p id="4375" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">(尝试更改这些值)</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8bdd" class="mx jz iq mt b gy my mz l na nb">mutation {<br/>  createHuman(newHuman: {<br/>    name: "Luke",<br/>    appearsIn: NEW_HOPE,<br/>    homePlanet: "Mars",<br/>  }) {<br/>    id<br/>    name<br/>    appearsIn<br/>    homePlanet<br/>  }<br/>}</span></pre><p id="cadb" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">你也可以用你选择的任何工具进行负载测试，我推荐bombardier或siege。</p><p id="cbab" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我希望你喜欢这篇教程，作为一名软件架构师，我的目标是与他人分享我对Rust中微服务世界的介绍。如果这篇文章对你有帮助，请在下面留下一些掌声和评论。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="9f08" class="jy jz iq bd ka kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv bi translated">参考</h1><div class="nq nr gp gr ns nt"><a href="https://github.com/actix/examples/tree/master/juniper" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">actix/示例</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">社区展示和Actix生态系统使用示例。-actix/示例</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">github.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh jw nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://github.com/capnproto/capnproto-rust/tree/master/capnp-rpc/examples/hello-world" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">capnproto/capnproto-rust</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">铁锈船长。通过在GitHub上创建帐户，为capnproto/capnproto-rust开发做出贡献。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">github.com</p></div></div><div class="oc l"><div class="oi l oe of og oc oh jw nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://www.apress.com/gp/book/9781484258590" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">Rust for the IoT -使用Rust和Raspberry Pi构建物联网应用程序| Joseph Faisal…</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">开始为物联网(IoT)编写Rust应用程序。这本书是一个编程技能的迁移…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">www.apress.com</p></div></div><div class="oc l"><div class="oj l oe of og oc oh jw nt"/></div></div></a></div></div></div>    
</body>
</html>