<html>
<head>
<title>Use Modules to Build a Modular JavaScript App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用模块构建模块化的JavaScript应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-modules-to-build-a-modular-javascript-app-6aeaf82fa85d?source=collection_archive---------5-----------------------#2019-11-11">https://levelup.gitconnected.com/use-modules-to-build-a-modular-javascript-app-6aeaf82fa85d?source=collection_archive---------5-----------------------#2019-11-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a201ec7487410f460ca1178d98059172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7QUpKvHVkIAO3FIy"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">弗洛里安·奥利佛在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="45db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ES6的一大特色是JavaScript支持内置模块。模块允许我们通过使用<code class="fe le lf lg lh b">export</code>和<code class="fe le lf lg lh b">import</code>语法在文件之间共享代码。与使用<code class="fe le lf lg lh b">script</code>标签和全局变量跨文件共享代码相比，这是一个很大的改进。</p><p id="0ac9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe le lf lg lh b">script</code>标签容易出错，因为加载顺序很重要。脚本顺序错误会导致我们的程序执行尚未声明的代码。它还迫使我们编写没有真正结构或逻辑组合的意大利面条式代码。模块不存在这个问题，因为所有的东西都是在文件之间直接导出和导入的。此外，我们可以很容易地知道导入代码的定义，因为在哪个模块中被导入和引用是显式的。</p><h1 id="e357" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">出口和进口</h1><p id="d80e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">为了使JavaScript文件中的代码可导入，我们必须用<code class="fe le lf lg lh b">export</code>语句显式导出它们。为此，我们只需将<code class="fe le lf lg lh b">export</code>放在您希望向其他文件公开的变量或常量前面。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6619" class="mt lj it lh b gy mu mv l mw mx">export let num = 1;</span></pre><p id="e678" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将导出变量<code class="fe le lf lg lh b">num</code>,以便其他模块可以<code class="fe le lf lg lh b">import</code>使用它。</p><p id="28bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以导出任何用<code class="fe le lf lg lh b">var</code>、<code class="fe le lf lg lh b">let</code>、<code class="fe le lf lg lh b">const</code>声明的东西，还有函数和类。导出的项目必须在顶层声明。<code class="fe le lf lg lh b">export</code>不能在其他地方使用，比如内部函数和类。</p><p id="3531" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以一次导出多个成员。我们所要做的就是将所有成员用逗号分隔的大括号括起来。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="336f" class="mt lj it lh b gy mu mv l mw mx">const num1 = 1;<br/>const num2 = 2;<br/>const num3 = 3;<br/>export {num1, num2, num3};</span></pre><p id="2510" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将让我们在其他JavaScript文件中导入<code class="fe le lf lg lh b">num1</code>、<code class="fe le lf lg lh b">num2</code>和<code class="fe le lf lg lh b">num3</code>。</p><p id="66ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经导出了成员，我们可以在其他JavaScript文件中导入它们。我们可以使用<code class="fe le lf lg lh b">import</code>语句将一个或多个成员导入到一个模块中，并使用它们。例如，如果我们在<code class="fe le lf lg lh b">moduleA.js</code>中有以下内容:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="37aa" class="mt lj it lh b gy mu mv l mw mx">const num1 = 1;<br/>const num2 = 2;<br/>const num3 = 3;<br/>export {num1, num2, num3};</span></pre><p id="3fad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe le lf lg lh b">moduleB.js</code>中，我们可以编写以下代码来从<code class="fe le lf lg lh b">moduleA.js</code>导入项目:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7f83" class="mt lj it lh b gy mu mv l mw mx">import {num1, num2, num3} from './moduleA'</span></pre><p id="3cbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">from</code>关键字后的路径以句点开始。句点表示我们在当前文件夹中。</p><p id="fbc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里假设<code class="fe le lf lg lh b">moduleA.js</code>和<code class="fe le lf lg lh b">moduleB.js</code>在同一个文件夹中。如果我们将它们放在不同的文件夹中，那么如果我们想要将导出的<code class="fe le lf lg lh b">moduleA.js</code>成员导入到<code class="fe le lf lg lh b">moduleB.js</code>中，我们需要指定<code class="fe le lf lg lh b">moduleA.js</code>相对于<code class="fe le lf lg lh b">moduleB.js</code>的路径。例如，如果<code class="fe le lf lg lh b">moduleA.js</code>比<code class="fe le lf lg lh b">moduleB.js</code>高一级，那么在<code class="fe le lf lg lh b">moduleB.js</code>中我们写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3e73" class="mt lj it lh b gy mu mv l mw mx">import {num1, num2, num3} from '../moduleAFolder/moduleA'</span></pre><p id="3153" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">路径前的2个句点意味着我们向上一级文件夹，然后得到<code class="fe le lf lg lh b">moduleAFolder</code>，然后得到<code class="fe le lf lg lh b">moduleA.js</code>。</p><p id="69cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以在<code class="fe le lf lg lh b">script</code>标签中使用JavaScript模块。为此，我们必须将脚本标签的<code class="fe le lf lg lh b">type</code>属性设置为<code class="fe le lf lg lh b">module</code>来使用它们。例如，如果我们想在HTML文件中使用<code class="fe le lf lg lh b">moduleA.js</code>，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="026c" class="mt lj it lh b gy mu mv l mw mx">&lt;script type='module' src='moduleA.js'&gt;&lt;/script&gt;</span></pre><p id="0715" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在JavaScript模块中使用<code class="fe le lf lg lh b">import</code>和<code class="fe le lf lg lh b">export</code>。它们不能与常规脚本一起工作。</p><p id="44b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">脚本自动在严格模式下运行，所以我们不能意外声明全局变量，做其他不启用严格模式也能做的事情。它们还会自动异步加载，这样我们就不必担心长脚本会阻碍页面的加载。另外，<code class="fe le lf lg lh b">import</code>和<code class="fe le lf lg lh b">export</code>只发生在两个脚本之间，所以没有设置全局变量。因此，不能在控制台中直接查看它们。</p><h1 id="c387" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">默认导出</h1><p id="9b9a" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">还有一个用于导出模块成员的默认导出选项。我们以前以通过名称导入变量的方式导出变量。还有默认的导出，它从模块中导出单个成员，而不需要在导入时通过名称显式引用它。例如，如果我们想要导出一个模块中的单个成员，我们可以在<code class="fe le lf lg lh b">moduleA.js</code>中编写以下内容:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="fca0" class="mt lj it lh b gy mu mv l mw mx">const num = 1;<br/>export default num;</span></pre><p id="523a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你使用<code class="fe le lf lg lh b">export default</code>的时候没有花括号。</p><p id="39c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在您想要导入成员的文件中。在<code class="fe le lf lg lh b">moduleB.js</code>中我们写道:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0031" class="mt lj it lh b gy mu mv l mw mx">import num from './moduleA'</span></pre><p id="536b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们再次省略了花括号。这是因为每个模块只允许一个默认导出。或者，我们可以在<code class="fe le lf lg lh b">moduleB.js</code>中写下以下内容:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ee32" class="mt lj it lh b gy mu mv l mw mx">import {default as num} from './moduleA'</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/d57e050ac4b9467efaf8fa9d317e9eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sc2UXg5SxukvDCwq"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jentheodore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jen Theodore </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="8e49" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">重命名导入和导出</h1><p id="1205" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">如果我们有许多模块，并且它们的导出成员具有相同的名称，那么如果我们试图导入多个模块，就会发生冲突。这将是我们需要解决的问题。幸运的是，JavaScript有<code class="fe le lf lg lh b">as</code>关键字让我们重命名导出和导入，这样我们可以避免代码中的名称冲突。为了使用<code class="fe le lf lg lh b">as</code>关键字重命名导出，我们在<code class="fe le lf lg lh b">moduleA.js</code>中编写了以下内容:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="2c01" class="mt lj it lh b gy mu mv l mw mx">export {<br/>  num1 as numOne,<br/>  num2 as numTwo<br/>}</span></pre><p id="f16f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe le lf lg lh b">moduleB.js</code>中，我们可以通过编写以下内容来导入它们:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="11e9" class="mt lj it lh b gy mu mv l mw mx">import { numOne, numTwo } from './<!-- -->moduleA'</span></pre><p id="2653" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，我们可以在导入时进行重命名。为此，在<code class="fe le lf lg lh b">moduleA.js</code>中，我们把:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3edb" class="mt lj it lh b gy mu mv l mw mx">export {<br/>  num1,<br/>  num2<br/>}</span></pre><p id="c096" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe le lf lg lh b">moduleB.js</code>中，我们放入:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="7ffa" class="mt lj it lh b gy mu mv l mw mx">import { num1 as numOne, num2 as numTwo } from './<!-- -->moduleA'</span></pre><p id="c184" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们试图导入模块中的成员，而模块中的成员具有相同的名称，例如:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3a88" class="mt lj it lh b gy mu mv l mw mx">import { <!-- -->num1, num2<!-- --> } from './moduleA';<br/>import { <!-- -->num1, num2<!-- --> } from './moduleB';<br/>import { <!-- -->num1, num2<!-- --> } from './moduleC';</span></pre><p id="b0dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们会看到我们得到了<code class="fe le lf lg lh b">SyntaxError</code>。因此，我们必须对它们进行重命名，以便模块能够运行:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="118c" class="mt lj it lh b gy mu mv l mw mx">import { <!-- -->num1 as num1A, num2<!-- --> as num2A } from './moduleA';<br/>import { <!-- -->num1 as num1B, num2 <!-- -->as num2B } from './moduleB';<br/>import { <!-- -->num1 as num1C, num2 <!-- -->as num2C } from './moduleC';</span></pre><p id="1348" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从具有同名成员的多个模块中导入的一种更干净的方法是将模块的所有导出成员作为一个对象导入。我们可以用星号来表示。例如，代替:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a0b2" class="mt lj it lh b gy mu mv l mw mx">import { <!-- -->num1 as num1A, num2<!-- --> as num2A } from './moduleA';<br/>import { <!-- -->num1 as num1B, num2 <!-- -->as num2B } from './moduleB';<br/>import { <!-- -->num1 as num1C, num2 <!-- -->as num2C } from './moduleC';</span></pre><p id="3a91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以改为写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0044" class="mt lj it lh b gy mu mv l mw mx">import * as moduleA from './moduleA';<br/>import * as moduleB from './moduleB';<br/>import * as moduleC from './moduleC';</span></pre><p id="5a7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在导入下面的代码中，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="cbc9" class="mt lj it lh b gy mu mv l mw mx">moduleA.num1;<br/>moduleA.num2;<br/>moduleB.num1;<br/>moduleB.num2;<br/>moduleC.num1;<br/>moduleC.num2;</span></pre><p id="ae16" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以导出和导入类。因此，如果我们有一个包含一个或多个类的文件，比如包含以下类的<code class="fe le lf lg lh b">Person.js</code>文件:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b03e" class="mt lj it lh b gy mu mv l mw mx">class Person {<br/>  constructor(firstName, lastName) {<br/>    this._firstName = firstName;<br/>    this._lastName = lastName;<br/>  }<br/>  get fullName() {<br/>    return `${this.firstName} ${this.lastName}`<br/>  }<br/>  get firstName() {<br/>    return this._firstName<br/>  }<br/>  get lastName() {<br/>    return this._lastName<br/>  }<br/>  sayHi() {<br/>    return `Hi, ${this.firstName} ${this.lastName}`<br/>  }<br/>  set firstName(firstName) {<br/>    this._firstName = firstName;<br/>  }<br/>  set lastName(lastName) {<br/>    this._lastName = lastName;<br/>  }<br/>}</span></pre><p id="9aca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们编写下面的代码来导出一个类:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="303d" class="mt lj it lh b gy mu mv l mw mx">export { Person };</span></pre><p id="ff17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样导出了<code class="fe le lf lg lh b">Person</code>类，然后为了导入它，我们编写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b89b" class="mt lj it lh b gy mu mv l mw mx">import { Person } from './person';</span></pre><h1 id="35d1" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">动态模块加载</h1><p id="f9f6" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">JavaScript模块可以动态加载。这让我们只在需要的时候加载模块，而不是在应用运行的时候加载所有的模块。为此，我们使用了返回承诺的<code class="fe le lf lg lh b">import()</code>函数。当参数中的模块被加载时，承诺就实现了。promise解析为一个模块对象，然后可以被应用程序的代码使用。如果我们在<code class="fe le lf lg lh b">Person.js</code>中有<code class="fe le lf lg lh b">Person</code>类，那么我们可以用下面的代码动态导入它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5c4c" class="mt lj it lh b gy mu mv l mw mx">import('./Person')<br/>.then((module)=&gt;{<br/>  const Person = module.Person;<br/>  const person = new Person('Jane', 'Smith');<br/>  person.sayHi();<br/>})</span></pre><p id="77c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者使用<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>语法，我们可以把它放在一个函数中:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4fc5" class="mt lj it lh b gy mu mv l mw mx">const importPerson = async ()=&gt;{ <br/>  const module = await import('./Person');<br/>  const Person = module.Person;<br/>  const person = new Person('Jane', 'Smith');<br/>  person.sayHi();<br/>}</span><span id="94e8" class="mt lj it lh b gy mz mv l mw mx">importPerson();</span></pre><p id="3279" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，JavaScript模块对于组织代码非常有用。它允许我们导出想要向其他模块公开的内容，消除了对全局变量的需求。此外，可以重命名导出和导入，以避免在导入多个模块时发生冲突。此外，所有导出的成员可以一次全部导入，这样我们就可以将整个模块作为一个对象，而不是导入单个成员。最后，如果我们只想从模块中导出一个东西，我们可以使用<code class="fe le lf lg lh b">export default</code>。</p></div></div>    
</body>
</html>