<html>
<head>
<title>Object-oriented thinking is easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的思维很容易</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/object-oriented-thinking-is-easy-93aa51162f72?source=collection_archive---------1-----------------------#2021-03-04">https://levelup.gitconnected.com/object-oriented-thinking-is-easy-93aa51162f72?source=collection_archive---------1-----------------------#2021-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4b4794950634128d257dc1424a6b19cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wl8-gKm6ci1KcviT"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="a28a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">面向对象编程(OOP)并不是在计算机程序中建模世界的完美方式。然而，这比试图理解处理器芯片、虚拟机甚至操作系统的复杂性要容易得多。</p><p id="0a6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有很多面向对象的术语，但是没有一个会让学生气馁。任何值得学习的东西都会有很多相关的术语。老师应该尽可能清楚地解释术语。稍后我将回到行话。</p><p id="83db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OOP的基本思想很简单:你编写代表问题域中对象的类。例如，如果你正在写一个汽车租赁帐单的程序，你将创建对象来表示汽车、客户帐户、发票等等。</p><p id="a2ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你不用担心诸如芯片的寄存器有多少位、操作系统如何调度线程等细节。你甚至不必担心你正在使用的编程语言的晦涩难懂的特性。</p><p id="6742" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OOP思想的实现并不总是符合预期。C++和Java在这方面受到了很多批评。</p><p id="5064" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们当然可以不同意将OOP概念转化为工作解决方案的最佳方式，但是通常OOP编程语言确实简化了编程任务。</p><p id="a906" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">OOP的一个著名弱点是香蕉猴子丛林问题。你需要一个物体(香蕉)来做一件简单的小事。但是你需要一些东西来拿香蕉(猴子)。接下来，您知道，您已经将整个生态系统(丛林)导入到您的项目中。</p><p id="bd41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个例子，不太引人注目:使用Java和Java虚拟机(JVM)，向用户的临时目录写一个文本文件，文本为“Hello，world！”</p><p id="4847" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一项很容易的任务。我们需要从<code class="fe le lf lg lh b">java.io</code>包中导入三到四个类。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="895e" class="lq lr it lh b gy ls lt l lu lv">package org.example.fileops;</span><span id="ab37" class="lq lr it lh b gy lw lt l lu lv">import java.io.File;<br/>import java.io.FileNotFoundException;<br/>import java.io.FileWriter;<br/>import java.io.IOException;</span></pre><p id="9641" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">FileHelloWorld</code>类将只包含一个静态过程<code class="fe le lf lg lh b">main()</code>。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="9237" class="lq lr it lh b gy ls lt l lu lv">public class FileHelloWorld {<br/>    <br/>    public static void main(String[] args) {<br/>        String tempDirPath = System.getProperty("java.io.tmpdir");<br/>        String nameWithExtension = "HelloWorld.txt";<br/>        String filename = tempDirPath + File.separatorChar <br/>                + nameWithExtension;<br/>        File file = new File(filename);<br/>        try {<br/>            file.createNewFile();<br/>            try (FileWriter writer = new FileWriter(file)) {<br/>                writer.write("Hello, world!");<br/>            }<br/>            System.out.println("Please look in " + tempDirPath <br/>                    + " for " + nameWithExtension);<br/>        } catch (IOException ioe) {<br/>            System.err.println(ioe.getMessage());<br/>        }<br/>    }<br/>    <br/>}</span></pre><p id="da05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我运行这个，果然:</p><blockquote class="lx ly lz"><p id="7cee" class="kg kh ma ki b kj kk kl km kn ko kp kq mb ks kt ku mc kw kx ky md la lb lc ld im bi translated">run: <br/>请在C:\ Users \ AL \ AppData \ Local \ Temp \中查找HelloWorld.txt <br/>构建成功(总时间:0秒)</p></blockquote><p id="9c42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过添加检查文件是否已经存在并请求用户允许覆盖它来增加循环复杂度。那就需要更多的物体。</p><p id="cfde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顺便说一下，这还需要我们写一个If-Else语句，可能是嵌套的，无论如何都要避免，因为这会让我们看起来像不懂事的乡巴佬。</p><p id="105c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过，说真的，我怀疑您的temp文件夹中是否已经有了HelloWorld.txt文件。然而，这个<code class="fe le lf lg lh b">main()</code>忽略了<code class="fe le lf lg lh b">createNewFile()</code>函数的返回类型，它是一个布尔原语(Java语言中小写的“<code class="fe le lf lg lh b">boolean</code>”)。</p><p id="52fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这实际上比If语句更让我烦恼。但这并不能证明我的观点，即需要一大堆对象来完成一个小任务。</p><p id="fde3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目前，<code class="fe le lf lg lh b">FileHelloWorld</code>需要一个<code class="fe le lf lg lh b">File</code>对象和一个<code class="fe le lf lg lh b">FileWriter</code>对象，一个<code class="fe le lf lg lh b">IOException</code>对象以防在创建、打开、写入和关闭文件时出错…</p><p id="d257" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和大约八个不同的<code class="fe le lf lg lh b">String</code>实例(如果我没有数错的话；请在评论中告诉我——请记住<code class="fe le lf lg lh b">String</code>文字是对象，不是原语。如果我们想给这个简单的程序一个图形用户界面，还需要几十个对象。</p><p id="12d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我确信这个程序可以更简单，无论是用Java还是其他编程语言。即便如此，Java开发工具包的面向对象设计使我们不必担心几个重要的细节。</p><p id="5a0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，如何查看文件分配表(FAT)来检查是否有足够的空间来存放新文件？Mac OS用FATs吗？Linux呢？有任何有效的安全限制吗？诸如此类。</p><p id="8abf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原来我们不需要导入<code class="fe le lf lg lh b">FileNotFoundException</code>。它由<code class="fe le lf lg lh b">IOException</code>通过继承层次结构覆盖。</p><p id="4316" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当谈到OOP时，继承是人们不同意的事情之一，这导致一些人编造故事，艾伦·凯告诉所谓的专家他们都错了。</p><p id="202f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有主要的OOP语言(例如C++、Java、C#，仅举三个例子)似乎都有继承，所以如果我们想用这些语言编程，我们必须处理继承。</p><p id="7307" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">继承带来多态性。这仅仅意味着传递物体的灵活性。如果一个类中的单元接受一个给定类的参数，它也接受该类的子类的参数。</p><p id="522e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，假设我们编写一个类，它的构造函数需要一个<code class="fe le lf lg lh b">URLConnection</code>。但是我们不关心它是HTTP还是HTTPS连接。这两种类型之间的任何不同都由适当的虚函数查找来解决。</p><p id="d61a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">多态性可以使我们不必编写一些If-Else语句，从而降低我们编写的类的圈复杂度。但是，不要忘乎所以，要务实。有时一个恰当的If语句比一个做作的枚举更好。</p><p id="2074" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">封装是OOP基本思想的自然结果:每个对象都知道自己的状态，并控制其他对象如何查询或改变该状态。</p><p id="1292" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就计算机芯片而言，没有像<code class="fe le lf lg lh b">FileWriter</code>对象、<code class="fe le lf lg lh b">Invoice</code>对象这样的东西，或者我们的程序可能需要的任何类型的对象。</p><p id="fa86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">计算机芯片根据寄存器和堆栈来“思考”。例如，如果从堆栈中按位弹出一个值，或者flags寄存器等于零，程序可能会转到某一行。</p><p id="6fee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从那以后，芯片可能会从堆栈中弹出另一个值，并与主寄存器进行位与运算。该操作的结果可能触发到程序中另一个位置的另一个跳转。</p><p id="692d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使对类有所了解的JVM，除了编程到对象中的内容之外，对对象也一无所知。</p><p id="c093" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对我们来说，这是有意义的，例如，<code class="fe le lf lg lh b">CheckDeposit</code>扩展了<code class="fe le lf lg lh b">Deposit</code>，后者又扩展了<code class="fe le lf lg lh b">Transaction</code>(后者隐含地扩展了<code class="fe le lf lg lh b">Object</code>)。</p><p id="0986" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是就JVM而言，继承层次结构可以很容易地被<code class="fe le lf lg lh b">Sr82xa_</code>扩展<code class="fe le lf lg lh b">Mpla47ñ</code>，后者扩展<code class="fe le lf lg lh b">T10Oa3</code>(后者隐式扩展<code class="fe le lf lg lh b">Object</code>)。</p><p id="a7ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe le lf lg lh b">Withdrawal</code>扩展了<code class="fe le lf lg lh b">Transaction</code>，那么<code class="fe le lf lg lh b">Withdrawal</code>实例可以被发送给需要<code class="fe le lf lg lh b">Transaction</code>实例的函数，但是不能被发送给需要<code class="fe le lf lg lh b">Deposit</code>实例的函数。</p><p id="9f28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那只是常识。但是我们必须向电脑解释。</p><p id="65c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像行话一样，首字母缩写词使OOP的学习曲线变得陡峭。最著名的OOP首字母缩略词之一可能是SOLID。这可能感觉就像一个密码，把知道的人和不知道的人分开。</p><p id="3def" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SOLID只是五个相关OOP概念的助记符。在我看来，其中最重要的是单一责任原则。如果你遵守单一责任原则，其他四个坚实的概念几乎会自动到位。</p><p id="af2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单一责任原则适用于最小的单元，也适用于类、包、模块、程序和整个系统。</p><p id="97be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般来说，Java开发工具包的作者非常善于在类级别遵守单一责任原则。例如，<code class="fe le lf lg lh b">FileWriter</code>类只有一个责任:写文件。要读取文件，你需要类似于<code class="fe le lf lg lh b">FileReader</code>(也来自<code class="fe le lf lg lh b">java.io</code>)的东西。</p><p id="a100" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从包装的角度来看，就不是这样了。在我看来，<code class="fe le lf lg lh b">java.util</code>中至少有一组类和接口应该被分离到不同的包<code class="fe le lf lg lh b">java.collections</code>中。当然，现在改变已经太晚了。</p><p id="f562" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在类的层次上，单一责任原则仅仅是对OOP概念的一种肯定，即计算机程序中的对象反映了我们试图解决的问题领域中的对象。</p><p id="8544" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，纸质发票可能会在适用时列出货币兑换，但它的唯一职责是列出要记入客户账户的费用，而不是按需执行任意的货币兑换。</p><p id="bf52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，<code class="fe le lf lg lh b">Invoice</code>对象可能需要调用<code class="fe le lf lg lh b">CurrencyConverter</code>对象来获得货币兑换，但是<code class="fe le lf lg lh b">Invoice</code>对象的唯一职责是列出要向<code class="fe le lf lg lh b">Account</code>对象收取的费用。任意货币转换由<code class="fe le lf lg lh b">CurrencyConverter</code>单独负责。</p><p id="811c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接口分离原则(实线中的I)可以用单一责任原则来表述:接口不应该强迫实现类违反单一责任原则。</p><p id="2dc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">人们似乎想出了玩具例子来解释接口隔离原则，这比他们用来解释单一责任原则的玩具例子更愚蠢。</p><p id="ea8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想出既现实又容易理解的例子有时会很难。</p><p id="b799" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，关于接口分离原则，我想到了<code class="fe le lf lg lh b">Animal</code>类和<code class="fe le lf lg lh b">GlideCapable</code>和<code class="fe le lf lg lh b">FlightCapable</code>接口。希望读者能理解我举这个例子的意图，并原谅这个例子有多愚蠢。</p><p id="3a8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">玩具例子的愚蠢不应该使我们看不到OOP的要点:通过允许我们把我们的程序看作是对我们手头问题的心理模型中的对象进行操作来简化编程，而不是考虑计算机芯片或运行这些程序的操作系统的螺母和螺栓。</p><p id="b15a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果OOP的现实被证明是复杂的，那是因为OOP思想的实现增加了不必要的复杂性，而不是因为OOP思想有任何固有的缺陷。</p></div></div>    
</body>
</html>