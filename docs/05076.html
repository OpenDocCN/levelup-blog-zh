<html>
<head>
<title>The new aspect of Java with functional programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程的Java新面貌</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-new-aspect-of-java-with-functional-programming-d2ca6517d15e?source=collection_archive---------7-----------------------#2020-08-02">https://levelup.gitconnected.com/the-new-aspect-of-java-with-functional-programming-d2ca6517d15e?source=collection_archive---------7-----------------------#2020-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8348" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数式编程是Javascript和Python中一个众所周知的概念。但是，对于java开发人员来说，这是一件不可思议的事情。在<a class="ae ko" href="https://www.oracle.com/java/technologies/java8.html" rel="noopener ugc nofollow" target="_blank"> Java 8 </a>之前，Java是一个纯面向对象的程序设计，对象是一等公民。我们过去用Java做命令式编码。从版本8开始，Java引入了进行函数式编程的新功能。然而，Java并不是像Javascript那样的函数式编程语言。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/0dbcf0b67e7e6469ebdbce9bc9a724b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Guvw1igKLLl0V3YiKQ3SMw.png"/></div></div></figure><h2 id="8809" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">什么是函数式编程？</h2><p id="d2cc" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">为了理解函数式编程，我们需要先了解一些基本概念。</p><ol class=""><li id="536d" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn me mf mg mh bi translated"><strong class="js iu">命令式编程:</strong>在这种编程范式中，我们需要告诉我们需要做什么以及如何去做？它依赖于if、when、for、forEach等语句。</li></ol><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="9750" class="lb lc it mj b gy mn mo l mp mq">public class Programming {<br/>    <br/>    //remove duplicates from the list of numbers<br/>    public static void main(String[] args) {<br/>        <br/>        List&lt;Integer&gt; numbers = Arrays.<em class="mr">asList</em>(1,2,2,3,4,5,6,7,7,8,9,9,8);<br/>        <br/>        //imperative style of removing duplicates from the list<br/>        List&lt;Integer&gt; newList = new ArrayList&lt;&gt;();<br/>        <br/>        for(Integer number: numbers) {<br/>            if(!newList.contains(number)) {<br/>                newList.add(number);<br/>            }<br/>        }<br/>        System.<em class="mr">out</em>.println(newList);<br/>    }<br/>}</span></pre><p id="bf01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.<strong class="js iu">声明式编程:</strong>它只是要求做什么，它取决于表达式而不是语句。<strong class="js iu">声明性代码</strong>专注于构建软件的<strong class="js iu">逻辑，而不实际描述其流程</strong>。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="7495" class="lb lc it mj b gy mn mo l mp mq">public class Programming {<br/><br/>    //remove duplicates from the list of numbers<br/>    public static void main(String[] args) {<br/><br/>        List&lt;Integer&gt; numbers = Arrays.<em class="mr">asList</em>(1,2,2,3,4,5,6,7,7,8,9,9,8);<br/><br/>        //declarative style of removing duplicates from the list<br/>        List&lt;Integer&gt; newList = numbers.stream().distinct().collect(Collectors.<em class="mr">toList</em>());<br/>        <br/>        System.<em class="mr">out</em>.println(newList);<br/>    }<br/>}</span></pre><p id="a10b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.<strong class="js iu">高阶函数:</strong>这些函数可以将函数作为参数，也可以在执行后返回函数。<code class="fe ms mt mu mj b">Collections.sort()</code>方法是采用比较器a参数的高阶函数的一个例子。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="2076" class="lb lc it mj b gy mn mo l mp mq">List&lt;String&gt; list = new ArrayList&lt;&gt;();<br/>list.add("One");<br/>list.add("Two");<br/>list.add("Three");<br/><br/>Collections.sort(list, (String a, String b) -&gt; {<br/>    return a.compareTo(b);<br/>});<br/><br/>System.out.println(list);</span></pre><p id="c7a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.<strong class="js iu">函数式编程:</strong>是声明式编程+高阶函数+不变性。这种编程完全依赖于纯函数。我们来了解一下<strong class="js iu">什么是Java(或者任何编程语言)中的纯函数</strong>？</p><p id="fe32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个纯粹的函数完全依赖于两件事:</p><p id="d29a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这不会改变任何事情。</p><p id="1efb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它不依赖于任何变化的事物。就像我们在java lambdas中只能有final变量。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="f43e" class="lb lc it mj b gy mn mo l mp mq">//it's not a pure function as it modifies the list of numbers<br/>public int getValue(List&lt;Integer&gt; numbers) {<br/>    numbers.add(100);<br/>    return numbers.get(0);<br/>}<br/><br/>//it's a pure function as it does not modify the value of anything<br/>public int getValue(List&lt;Integer&gt; numbers) {<br/>    return numbers.get(0);<br/>}</span></pre><p id="3e21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧！！那真的很酷。现在，我们明白了这个新的Java术语是什么。但是，我们为什么要在实现中使用它呢？它对我们有什么帮助？</p><h2 id="6b52" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">为什么我们需要函数式编程？</h2><ol class=""><li id="dd4e" class="lz ma it js b jt lu jx lv kb mv kf mw kj mx kn me mf mg mh bi translated">在代码中具有不变性。</li><li id="49b4" class="lz ma it js b jt my jx mz kb na kf nb kj nc kn me mf mg mh bi translated">并行化更容易实现。</li><li id="e04f" class="lz ma it js b jt my jx mz kb na kf nb kj nc kn me mf mg mh bi translated">懒惰评估</li></ol><p id="268a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">为什么不变性很重要？</strong></p><p id="21ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">改变数据结构会产生意想不到的副作用，我们必须对此进行检查。有了不变性，我们可以保持数据结构的可预测性和无副作用，并且更容易推理。</p><p id="cee0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在纯函数中，我们可以使用任何数据结构，而不用担心由于对数据结构的异步访问而导致的可变性或模糊结果。</p><p id="9bdf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设，我们有一个命令式代码，它运行良好，除非它是一个顺序代码，这时候，我们需要让它并发，以提高其性能。这样做就变得复杂了。好的，没问题，我们喜欢复杂的事情，我们会做，我们开始将代码从顺序迁移到并发，我们完成了它，现在，我们得到了更快的结果，但是，结果并不准确。没问题，我们会花更多的时间来解决这些准确性问题，现在，我们可以部署我们的新解决方案，以提高性能。</p><p id="429f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们部署我们的新解决方案之前，我有一个问题，我们在并发代码中使用了10个线程，它将我们的性能提高了5倍，我们不能增加线程的数量以获得更好的性能吗？让我们试试那个。我们将线程增加到100个，这次性能下降了。这个实验清楚地告诉我们，并发不仅仅依赖于线程。这也取决于硬件(CPU的核心数)。</p><p id="2238" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我试图解释开发人员在处理并发代码时需要认识到很多事情。在这里，函数式编程通过在这些事物之上进行抽象来拯救我们。</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="52ce" class="lb lc it mj b gy mn mo l mp mq">public class Programming {<br/><br/>    //remove duplicates from the list of numbers<br/>    public static void main(String[] args) {<br/><br/>        List&lt;Integer&gt; numbers = Arrays.<em class="mr">asList</em>(1,2,2,3,4,5,6,7,7,8,9,9,8);<br/><br/>        //sequential code<br/>        List&lt;Integer&gt; newList = numbers.stream().distinct().collect(Collectors.<em class="mr">toList</em>());</span><span id="026d" class="lb lc it mj b gy nd mo l mp mq">       //parallel code<br/>       List&lt;Integer&gt; newList = numbers.parallelStream().distinct().collect(Collectors.<em class="mr">toList</em>());<br/>        System.<em class="mr">out</em>.println(newList);<br/>    }<br/>}</span></pre><p id="79ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，parallelStream()并行执行代码以获得更好的性能。它在内部处理线程，将任务分成多个子任务。</p><p id="88bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">懒评</strong></p><p id="69d2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它做一个懒惰的评估。如果流的结果没有在任何地方被使用，则它不执行该流。让我试着在下面的例子中解释一下:</p><pre class="kq kr ks kt gt mi mj mk ml aw mm bi"><span id="7ee2" class="lb lc it mj b gy mn mo l mp mq">public class Programming {<br/><br/>    public static int doubleNum(int number) {<br/>        System.<em class="mr">out</em>.println("doubleNumber: " + number);<br/>        return number*2;<br/>    }</span><span id="ac94" class="lb lc it mj b gy nd mo l mp mq">    //here result of stream is not being used<br/>    public static void main(String[] args) {<br/><br/>        List&lt;Integer&gt; numbers = Arrays.<em class="mr">asList</em>(1,2,3,4);<br/><br/>        numbers.stream().map(n -&gt; <em class="mr">doubleNum</em>(n));<br/>    }<br/><br/>}<br/>//Result:<br/>Process finished with exit code 0</span><span id="0754" class="lb lc it mj b gy nd mo l mp mq">--------------------------------------------------------------------<br/>public class Programming {<br/><br/>    public static int doubleNum(int number) {<br/>        System.<em class="mr">out</em>.println("doubleNumber: " + number);<br/>        return number*2;<br/>    }<br/><br/>    public static void main(String[] args) {<br/><br/>        List&lt;Integer&gt; numbers = Arrays.<em class="mr">asList</em>(1,2,3,4);<br/><br/>        numbers.stream().map(n -&gt; <em class="mr">doubleNum</em>(n)).forEach(System.<em class="mr">out</em>::println);<br/>    }<br/><br/>}<br/>//Result:<br/>doubleNumber: 1<br/>2<br/>doubleNumber: 2<br/>4<br/>doubleNumber: 3<br/>6<br/>doubleNumber: 4<br/>8<br/>Process finished with exit code 0</span></pre></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="180b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">流是Java中函数式编程的基本构件。它不是一种数据结构。这是功能的抽象。它是基于推模型的。当数据可供处理时，它会推送数据，而对于列表和其他集合，客户端会拉取数据进行处理。</p><h2 id="52b7" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">四个著名的功能界面:</h2><ol class=""><li id="b161" class="lz ma it js b jt lu jx lv kb mv kf mw kj mx kn me mf mg mh bi translated"><code class="fe ms mt mu mj b">Supplier&lt;T&gt; =====&gt; T get() ------&gt; Factories in streams</code></li><li id="3b0c" class="lz ma it js b jt my jx mz kb na kf nb kj nc kn me mf mg mh bi translated"><code class="fe ms mt mu mj b">Predicate&lt;T&gt; =====&gt; boolean test(T) ------&gt; filters in streams</code></li><li id="8b30" class="lz ma it js b jt my jx mz kb na kf nb kj nc kn me mf mg mh bi translated"><code class="fe ms mt mu mj b">Function&lt;T, R&gt; =====&gt; R apply(T) -------&gt; map in streams</code></li><li id="4ec9" class="lz ma it js b jt my jx mz kb na kf nb kj nc kn me mf mg mh bi translated"><code class="fe ms mt mu mj b">Consumer&lt;T&gt; ======&gt; void accept(T) -------&gt; forEach in streams</code></li></ol><blockquote class="nl nm nn"><p id="b523" class="jq jr mr js b jt ju jv jw jx jy jz ka no kc kd ke np kg kh ki nq kk kl km kn im bi translated">注意:异常在流中没有得到很好的处理，这成为流的一个限制。它只是有一个<strong class="js iu">数据通道</strong>进行通信。在异步编程中，<a class="ae ko" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" rel="noopener ugc nofollow" target="_blank"> CompletableFuture </a>可以优雅地处理错误(或异常)，因为它有<strong class="js iu"> 2个通道(数据和错误)</strong>进行通信。</p></blockquote><h2 id="a8e2" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">结论:</h2><p id="ef68" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">在我看来，开发人员更熟悉命令式编码风格，而不是函数式(或声明式)，函数式需要更多的数学思考，使代码更容易出错。为什么我们需要像数学家一样编码？我们应该只关注业务逻辑，并利用提供给我们的API和框架来完成其他事情。</p><p id="f734" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望有帮助，感谢阅读！</p></div></div>    
</body>
</html>