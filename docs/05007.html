<html>
<head>
<title>A Guide to Python Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python装饰者指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-guide-to-python-decorators-f3b03dd05514?source=collection_archive---------11-----------------------#2020-07-29">https://levelup.gitconnected.com/a-guide-to-python-decorators-f3b03dd05514?source=collection_archive---------11-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f3dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及在哪里可以使用它们。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/abe715a4cef5563158a9ed268d2f39e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RLjO-LdoAZacrsTB8eZScg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@flowforfrank?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ferenc Almasi </a>在<a class="ae ky" href="https://unsplash.com/s/photos/decorator?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="be46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装饰器是Python最酷的特性之一，也是我最喜欢的特性之一。装饰者接受一个函数，添加另一个功能，并返回改进的函数。</p><p id="982d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在我们深入研究它的特性和用途之前，我们必须先了解一些基本的东西。</p><h1 id="b853" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">介绍</h1><p id="29f8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python中的一切都是对象。是的，一切！</p><p id="86c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数也不例外。因为它们是对象，所以可以作为参数传递给其他函数，也可以作为结果返回。它们也有一些属性，比如<code class="fe ms mt mu mv b">__name__</code>和<code class="fe ms mt mu mv b">__doc__</code>。</p><p id="cdf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数是执行特定任务的一组语句。它有助于组织我们的代码，避免重复并使代码可重用。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0238" class="na lw it mv b gy nb nc l nd ne">def function_name(args):<br/>    '''docstring'''<br/>    statements(s)</span></pre><p id="855a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数的语法非常简单。它以关键字<code class="fe ms mt mu mv b">def</code>开头，后面是它唯一的名称、一些参数，最后是一个分号。它可以有一个文档(docstring)来描述这个函数做什么。</p><p id="1e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后面的所有语句构成了函数体，并且必须有正确的缩进。最后，它还可以包含一个return语句。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5d80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="aa1e" class="na lw it mv b gy nb nc l nd ne">start of program.<br/>name: basic_function<br/>doc: Basic function doc<br/>basic function: 1<br/>end of program: 2</span></pre><p id="0e86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数也是一个<em class="nh">可调用的</em>对象。一般来说，可调用对象是可以被调用的东西。您可以使用内置函数<code class="fe ms mt mu mv b">callable()</code>检查对象是否可调用。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="4ff5" class="lv lw it bd lx ly np ma mb mc nq me mf jz nr ka mh kc ns kd mj kf nt kg ml mm bi translated">装修工</h1><p id="d0e9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">回到装饰师。根据定义，装饰器就是一个简单的函数，它接收一个函数，做一些事情，然后返回另一个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="854f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行此程序:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="a1bd" class="na lw it mv b gy nb nc l nd ne">start program<br/>basic function<br/>wrapper function<br/>basic function<br/>end program</span></pre><p id="bb72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们了解一下这里刚刚发生了什么。<code class="fe ms mt mu mv b">decorator</code>函数，顾名思义，就是我们的装饰器。它接收一个函数作为参数，称为<code class="fe ms mt mu mv b">func</code>。是的，非常新颖的名字。在我们的函数内部，我们声明了另一个名为<code class="fe ms mt mu mv b">wrapper</code>的函数。不用在里面声明，但是很好管理。</p><p id="bdc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe ms mt mu mv b">wrapper</code>函数只是调用作为参数传递给装饰器的原始函数，但是您可以添加任何您想添加的功能。</p><p id="8d1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后返回<code class="fe ms mt mu mv b">wrapper</code>函数。记住，我们仍然需要一个可调用的对象。现在，可以调用这个新函数了，只需添加我们原来的功能和新代码。</p><p id="f83d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是Python有一个语法来简化这个声明。要装饰一个函数，你可以使用<code class="fe ms mt mu mv b">@</code>符号和装饰者的名字，并把它放在你想要装饰的函数上面。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="3261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0abe" class="na lw it mv b gy nb nc l nd ne">decorator func<br/>start of program...<br/>before func wrapped<br/>wrapped func<br/>after func wrapped<br/>end of program</span></pre><p id="d12d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将同一个装饰器用于任意数量的函数，也可以用任意装饰器装饰一个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="3caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="9c41" class="na lw it mv b gy nb nc l nd ne">decorator 2<br/>decorator 1<br/>decorator 1<br/>&gt;&gt; start<br/>before func<br/>before func<br/>basic 1<br/>before func<br/>basic 2<br/>&gt;&gt; end</span></pre><p id="1232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个函数有多个装饰器时，它们的调用顺序与声明顺序相反。那就是:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="7a9a" class="na lw it mv b gy nb nc l nd ne">@decorator_1<br/>@decorator_2<br/>def wrapped():</span></pre><p id="2d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与以下内容相同:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="c29a" class="na lw it mv b gy nb nc l nd ne">a = decorator_1(decorator_2(wrapped))</span></pre><p id="8225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果修饰函数返回一个值，而你想保留这个属性，你只需要让包装函数从修饰函数返回这个值。</p><h1 id="f4b8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">甲级装修工</h1><p id="fe38" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">通过将<code class="fe ms mt mu mv b">__call__</code>方法添加到一个类中，可以将它变成一个可调用的对象。因为装饰器只是一个函数，因此是一个可调用的对象，所以你可以通过实现函数<code class="fe ms mt mu mv b">__call__</code>将一个类变成装饰器。</p><p id="661a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迷惑？让我们看一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="31f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="3002" class="na lw it mv b gy nb nc l nd ne">&gt; Decorator class __init__<br/>&gt;&gt; start<br/>&gt; before call from class... wrapped<br/>wrapped func<br/>&gt; after call from class<br/>&gt;&gt; end</span></pre><p id="03d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的区别在于类是在声明时被实例化的。它应该接收一个函数作为<code class="fe ms mt mu mv b">__init__</code>方法的参数。这是正在装饰的功能。</p><p id="efa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们调用修饰函数时，我们实际上是在调用类的实例对象。因为对象是可调用的，所以函数<code class="fe ms mt mu mv b">__call__</code>被调用。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="6115" class="lv lw it bd lx ly np ma mb mc nq me mf jz nr ka mh kc ns kd mj kf nt kg ml mm bi translated">带参数的函数</h1><p id="7904" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">但是如果你试图修饰的函数必须接收一些参数呢？很简单，只需返回一个与你试图修饰的函数具有相同签名的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="69a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="1c0f" class="na lw it mv b gy nb nc l nd ne">&gt; decorator args...<br/>&gt; decorator args...<br/>&gt;&gt; start<br/>before calling func add<br/>wrapped 1<br/>after calling func add<br/>ret: 15<br/>before calling func sub<br/>wrapped 2<br/>after calling func sub<br/>ret: 5<br/>&gt;&gt; end</span></pre><p id="0ecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于上课？遵循同样的规则。只需将您想要的签名添加到<code class="fe ms mt mu mv b">__call__</code>功能中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="76f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="cf47" class="na lw it mv b gy nb nc l nd ne">&gt; Decorator class __init__<br/>&gt;&gt; start<br/>&gt; before call from class... wrapped<br/>wrapped func: 10 20<br/>&gt; after call from class<br/>&gt;&gt; end</span></pre><p id="2055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不知道签名或者必须接受多种类型的函数，您也可以将<code class="fe ms mt mu mv b">*args</code>和<code class="fe ms mt mu mv b">**kwargs</code>用于“包装器”函数。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="0729" class="lv lw it bd lx ly np ma mb mc nq me mf jz nr ka mh kc ns kd mj kf nt kg ml mm bi translated">有争论的装饰者</h1><p id="d9e8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您还可以向装饰器本身传递一个参数。在这种情况下，你必须添加另一个抽象层，即返回另一个包装函数。</p><p id="b230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是必要的，因为参数被传递给装饰器。那么这个返回的函数实际上是用来修饰我们想要的函数。同样，这也很容易用一个例子来理解。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="423d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="54ec" class="na lw it mv b gy nb nc l nd ne">&gt; decorator_with_args: test<br/>&gt;&gt; real decorator for func add<br/>start program<br/>&gt;&gt;&gt; before func add<br/>&gt;&gt;&gt;&gt; add function<br/>&gt;&gt;&gt; after func add<br/>20<br/>end program</span></pre><p id="cdfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在类装饰器中，我们必须做类似的调整。现在，类构造函数将接收所有装饰参数。<code class="fe ms mt mu mv b">__call__</code>方法现在应该返回一个函数，一个实际上执行被修饰函数的包装器。示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e8f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6efa" class="na lw it mv b gy nb nc l nd ne">&gt; Decorator args class __init__: teste<br/>&gt;&gt; start<br/>&gt;&gt;&gt; before wrapper function<br/>add func: 10 20<br/>&gt;&gt;&gt; after wrapper fnction<br/>&gt;&gt; end</span></pre><h1 id="fead" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">证明文件</h1><p id="4424" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">函数的一个属性是它的文档字符串(或docstring)，由<code class="fe ms mt mu mv b">__doc__</code>属性访问。它是一个字符串常量，被定义为函数定义中的第一条语句。</p><p id="b14d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当修饰时，我们实际上是返回一个新的函数，带有其他属性。但是我们不想改变它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="1e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe ms mt mu mv b">wrapped</code>函数实际上是<code class="fe ms mt mu mv b">decorated</code>函数，因为它已经被它所替代。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="3c49" class="na lw it mv b gy nb nc l nd ne">start of program...<br/>decorated<br/>Decorated function<br/>end of program</span></pre><p id="70e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是来自模块<code class="fe ms mt mu mv b">functools</code>的函数<code class="fe ms mt mu mv b">wraps</code>来救援的地方。它保留了原始的函数属性。你只需要用它来装饰你的<code class="fe ms mt mu mv b">wrapper</code>功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="45e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="49fe" class="na lw it mv b gy nb nc l nd ne">start of program...<br/>wrapped<br/>Wrapped function<br/>end of program</span></pre></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="f594" class="lv lw it bd lx ly np ma mb mc nq me mf jz nr ka mh kc ns kd mj kf nt kg ml mm bi translated">应用程序</h1><p id="55ae" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">直到现在，我们还没有在真正的应用程序或真正的用途中真正使用装饰器。但是在哪里可以使用它们呢？让我们看一些例子。</p><h2 id="baab" class="na lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">时机</h2><p id="ab39" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个基本用途是获取函数的处理时间。您可以获得函数调用前后的时间，然后可以根据需要使用这些时间(记录到日志、数据库、调试等等)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f0cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="3837" class="na lw it mv b gy nb nc l nd ne">start program<br/>add 10 20 0<br/>&gt;&gt; function add_with_delay processed time (ms): 0.015000000000000001<br/>add 10 20 1<br/>&gt;&gt; function add_with_delay processed time (ms): 1000.7980000000001<br/>end program</span></pre><h2 id="a330" class="na lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">记录</h2><p id="7121" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">decorator的另一个常见用途是记录函数的使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="53fc" class="na lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">回收</h2><p id="aa35" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">回调函数是在某个事件发生时调用的函数，比如调用了路由、收到了消息或者服务器完成了处理。</p><p id="f6c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以添加一个在该事件发生时要执行的函数。例如，这在HTTP服务器中用于响应URL请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="7bae" class="na lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">检查条件</h2><p id="ea9f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您可以在执行函数之前使用装饰器来检查条件，比如用户是否登录，用户是否有权限使用函数，或者参数是否有效(类型、值等)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="8eb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4780" class="na lw it mv b gy nb nc l nd ne">start program<br/>Traceback (most recent call last):<br/>  File "example_permission.py", line 22, in &lt;module&gt;<br/>    do_something()<br/>  File "example_permission.py", line 7, in wrapped_check<br/>    raise ValueError("Not permitted")<br/>ValueError: Not permitted</span></pre><h2 id="d762" class="na lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">创建单例</h2><p id="0f3b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你可以用一个装饰器来装饰一个类。唯一的区别是装饰器接收的是一个类，而不是一个函数。</p><p id="79af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">singleton是只有一个实例的类。我们可以将实例保存为包装函数的属性，并在请求时返回它。例如，当我们处理数据库连接时，这是很有用的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="3315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="114f" class="na lw it mv b gy nb nc l nd ne">start<br/>140548309536336<br/>140548309536336<br/>end</span></pre><h2 id="8b94" class="na lw it bd lx nu nv dn mb nw nx dp mf li ny nz mh lm oa ob mj lq oc od ml oe bi translated">错误处理</h2><p id="b1a7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您可以确保处理一些异常族，而不必为您需要检查每个函数输入一个<code class="fe ms mt mu mv b">try</code>块。然后，您可以记录或停止程序的执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2731" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b714" class="na lw it mv b gy nb nc l nd ne">start<br/>5.0<br/>&gt;&gt; Error in func div<br/>0<br/>end</span></pre></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="b9f0" class="lv lw it bd lx ly np ma mb mc nq me mf jz nr ka mh kc ns kd mj kf nt kg ml mm bi translated">结论</h1><p id="e675" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我们看到了Python装饰器及其用途。这是一个很好的工具，可以改进您的代码，使您的项目更容易使用和维护。</p><p id="efe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们的一些特性:</p><ul class=""><li id="3cb4" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">它们可以重复使用。</li><li id="354a" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">它们可以接收参数并返回值。</li><li id="f64b" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">它们可以存储值。</li><li id="0805" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">他们可以布置班级。</li><li id="771c" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">它们可以向其他函数和类添加功能。</li></ul><p id="f824" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python也有一些内置的装饰器，比如<code class="fe ms mt mu mv b">classmethod</code>、<code class="fe ms mt mu mv b">property</code>和<code class="fe ms mt mu mv b">staticmethod</code>。</p><p id="bd34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过其他方法使用decorators，比如<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/python-dunder-methods-ea98ceabad15"> dunder </a>方法，来丰富您的类和项目。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="5a07" class="lv lw it bd lx ly np ma mb mc nq me mf jz nr ka mh kc ns kd mj kf nt kg ml mm bi translated">分级编码</h1><p id="1981" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">感谢您成为我们社区的一员！<a class="ae ky" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae ky" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Skilled.dev编码面试课程</strong> </a>。</p><div class="ot ou gp gr ov ow"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">编写面试问题</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">掌握编码面试的过程</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">技术开发</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div></div></div>    
</body>
</html>