<html>
<head>
<title>TypeScript Generic Types as Parameters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将泛型类型作为参数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-generic-types-as-parameters-882e692073d5?source=collection_archive---------0-----------------------#2019-01-02">https://levelup.gitconnected.com/typescript-generic-types-as-parameters-882e692073d5?source=collection_archive---------0-----------------------#2019-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ef55b752a742223cf1d3670c00dd6a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x3XjzpudPgjSty3MeE7clA.png"/></div></div></figure><p id="0035" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在不断追求遵循<a class="ae kw" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> D.R.Y. </a>的原则和创建完美的动态、可重用代码的过程中，你可能会无意中发现泛型的概念。虽然在编程世界中这不是一个新概念，但如果你从90年代就开始编写JavaScript，这肯定是一个新概念。TypeScript是一个很棒的超级集合，它允许我们使用泛型的概念来编写漂亮的、动态的、可重用的代码。</p><p id="b3a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常情况下，您会遇到用多个数据模型来表示应用程序的情况。例如，假设我们正在创建一个应用程序来跟踪各种公司、他们销售的产品以及购买这些产品的买家。我们将创建一些类型脚本模型来表示这些不同的数据类:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">我们产品跟踪应用的示例模型</figcaption></figure><p id="db5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于这个例子的目的，我已经为每个类添加了几个静态道具。我已经定义了特定的<code class="fe lh li lj lk b">displayProp</code>字符串，用于确定显示什么模型属性。此外，我有一个<code class="fe lh li lj lk b">tableName</code>属性，您可以想象它是这个模型引用的数据库表的名称。</p><p id="2db6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们想要一份我们所有公司、产品以及这些产品的买家的列表。我们可以为每个公司、产品和买家创建一个特定的列表组件，但是仅仅为了显示每个模型类型的列表，就会有大量的代码重复。这将是不可维护的，因为我们的应用程序越来越复杂，我们希望在一个列表中显示更多的数据类型！</p><h1 id="7967" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">创建动态列表组件</h1><p id="7fcc" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们可以创建一个不关心数据类型的通用组件，而不是为每种数据类型创建一个列表。我将在这个例子中使用Angular，但是这些概念也适用于其他框架(还有VanillaJS！).</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">通用列表组件</figcaption></figure><p id="7955" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您会注意到，我们已经通过在类名中添加<code class="fe lh li lj lk b">&lt;T&gt;</code>参数定义了一个泛型类。这允许我们在不同的类属性上使用泛型类型。但是，我们对各种型号的“名称”有不同的名称(例如，产品名称、公司名称、买方名称等。)，那么我们应该如何在我们的<code class="fe lh li lj lk b">&lt;h4&gt;</code>元素中引用这些属性呢？</p><h1 id="60ed" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">我们需要能够像使用参数一样使用泛型类型！</h1><p id="3270" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">您会注意到我的组件上的一个特殊属性，它是对泛型类型的引用，我们可以动态地使用它，就像它是一个实际的对象一样:</p><pre class="kx ky kz la gt mo lk mp mq aw mr bi"><span id="cc13" class="ms lm iq lk b gy mt mu l mv mw">const modelType: { new(...args: any[]): T; };</span></pre><p id="07eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">语法很奇怪，但本质上我们是说<code class="fe lh li lj lk b">modelType</code>应该是一个通用对象，其中new关键字可以接受任意数量的属性。</p><p id="7751" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这允许我们在通用组件中动态创建一个通用类型的新对象:</p><pre class="kx ky kz la gt mo lk mp mq aw mr bi"><span id="2190" class="ms lm iq lk b gy mt mu l mv mw">const newGenericObj = new modelType({});</span></pre><p id="2cfa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的例子，我们只需要在<code class="fe lh li lj lk b">&lt;h4&gt;</code>标签中访问模型(static <code class="fe lh li lj lk b">displayProp</code>)中显示属性的静态属性，因此我们甚至不需要创建一个新的泛型对象，只需将对泛型类型的引用传递到我们的泛型列表组件中:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用泛型列表组件和传入的泛型类型的例子</figcaption></figure><p id="d25c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了提高健壮性，我们可以创建一个接口来定义这个泛型类型参数设置，还可以定义我们期望从模型中得到的静态属性:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">描述我们的通用参数方案的可重用接口</figcaption></figure><p id="3cb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们可以重构前面的例子，这样我们的<code class="fe lh li lj lk b">modelType</code>属性现在就是类型<code class="fe lh li lj lk b">IGenericModel&lt;T&gt;</code>。</p><p id="5504" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这也不是唯一的方法。也许在前面的例子中创建那些“ref”属性感觉过于冗长。还有另一种方法可以定义我们的modelType属性:</p><pre class="kx ky kz la gt mo lk mp mq aw mr bi"><span id="884c" class="ms lm iq lk b gy mt mu l mv mw">//(data model is the class name of your model)<br/>modelType: &lt;T&gt;({}) =&gt; T;</span></pre><p id="068b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着<code class="fe lh li lj lk b">modelType</code>将是一个返回我们的泛型类型的函数(本质上与我们之前的定义相同)。这允许我们简单地将类型引用传递给泛型列表组件，因此不用这样做:</p><pre class="kx ky kz la gt mo lk mp mq aw mr bi"><span id="059b" class="ms lm iq lk b gy mt mu l mv mw">[modelType]="productRef"</span></pre><p id="6bcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，我们可以只传入实际的类类型:</p><pre class="kx ky kz la gt mo lk mp mq aw mr bi"><span id="69a1" class="ms lm iq lk b gy mt mu l mv mw">[modelType]="Product"</span></pre><p id="17be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">泛型可能会有点混乱，但是一旦你掌握了语法和整体概念，你就可以开始全面应用这个概念，以使你的UI组件数据不可知。希望使用类型作为参数的概念将帮助您编写更动态、更通用的组件！</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><figure class="kx ky kz la gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com/"><div class="gh gi ne"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="nf ng gp gr nh ni"><a href="https://gitconnected.com/learn/typescript" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">学习TypeScript -最佳TypeScript教程(2019) | gitconnected</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">前18名打字稿教程。课程由开发者提交并投票，使您能够找到最好的…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">gitconnected.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw jw ni"/></div></div></a></div></div></div>    
</body>
</html>