<html>
<head>
<title>CI/CD control flow with Git commit message arguments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有Git提交消息参数的CI/CD控制流</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ci-cd-control-flow-with-git-commit-message-arguments-153b4fcd505e?source=collection_archive---------4-----------------------#2020-01-04">https://levelup.gitconnected.com/ci-cd-control-flow-with-git-commit-message-arguments-153b4fcd505e?source=collection_archive---------4-----------------------#2020-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3e75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CI/CD系统，因为它们所有迷人的内部工作方式、复杂性和过多的可配置性；在一天结束的时候，和其他定制软件没有什么不同。</p><p id="fd4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就像任何其他软件系统一样，逻辑上CI/CD引擎由输入、输出、控制流和错误处理等契约组成。这些“契约”可能通过预先制作的“任务”插件来表达，这些插件提供可配置的输入，这些输入采用静态值或依赖于某种上下文/环境变量，所有这些在CI/CD平台上可能有很大的不同。</p><h1 id="1521" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">CI/CD基础</h1><p id="dc10" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">通常，开发运维人员将定义由一个或多个任务组成的定制工作流(或管道),这些任务将在运行时以预定的顺序执行，其中后续步骤仅在一个或多个先前步骤成功完成后执行。这些“工作流”通常被硬连线为模板，以重复自动化这些重复的操作集，这些操作集通常以我们都熟悉的两个类别之一结束:构建/测试工件；或者部署它们。</p><p id="3a84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">CI/CD“pipeline”模板中可用的行为定制级别通常相当有限，对其流程/行为的更改将需要开发团队向负责实施流程的DevOps团队请求更改。第二，总的来说，每个新调用可用的上下文信息(通过变量)非常有限，仅限于基本信息，如应用程序/项目名称、版本、内部版本号、环境等；或者通过与源代码一起检入的某种定制CI/CD控制文件。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/8a7de460ae53e20190588913fa4c2d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XdKRw68gGe2TH1El"/></div></figure><h1 id="5c14" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">定制CI/CD输入合同</h1><p id="e7d9" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">理想情况下，在设计CI/CD管道时，如果我们能够提供某种级别的定制，这种定制可以在每次触发/调用管道时轻松传达，并且可以在每次独特的管道实例化时发生变化，那就太好了。拥有这种能力可以减少对静态/硬连线管道的更改数量，并为开发人员在提交SCM时触发管道扩展功能。</p><p id="3235" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在当今世界中，由“GitOps”驱动的自动化越来越成为规范，由Git驱动的CI/CD系统的输入契约通常受到Git中的设施的约束，这些设施允许在存储库中发生变化时传递定制信息。其中最主要的是基本的Git提交消息。那么我们如何利用这一点让开发人员定制每个CI/CD调用呢？</p><p id="33c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也许是这样的？</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lw"><img src="../Images/a320700334774ca24bbb993ac4e04b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y6xIP2RC50Wzi3pQ"/></div></div></figure><p id="ba4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也有同样的需求，以下是我的解决方法。</p><h1 id="e891" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">提交消息CI/CD参数</h1><p id="7e19" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当时我正在用<a class="ae mb" href="https://azure.microsoft.com/en-us/services/devops/pipelines/" rel="noopener ugc nofollow" target="_blank"> Azure Pipelines </a>做一些CI/CD原型制作，遇到了一个有趣的特性，叫做<a class="ae mb" href="https://github.com/microsoft/azure-pipelines-tasks/blob/master/docs/authoring/commands.md" rel="noopener ugc nofollow" target="_blank">日志命令</a>。该特性基本上允许管道中的任务向<em class="mc"> STDOUT </em>发送特定格式的文本，Azure管道将检测该输出并对其采取行动。其中一个函数用于设置管道变量，您向<em class="mc"> STDOUT </em>发出的语法如下所示:</p><pre class="lp lq lr ls gt md me mf mg aw mh bi"><span id="fc9a" class="mi km iq me b gy mj mk l ml mm">##vso[task.setvariable]value</span></pre><p id="6f58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样设置的变量可用于管道的后续部分。鉴于此，我决定扩展这个想法，编写一个名为<a class="ae mb" href="https://github.com/bitsofinfo/gitops-argparser" rel="noopener ugc nofollow" target="_blank"> gitops-argparser </a>的小实用程序，它扩展了这个想法，让您在YAML中定义可接受的参数，然后简单地调用它，传递提交消息，您的变量将被解析并发送到<em class="mc"> STDOUT </em>。</p><p id="437a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是这样工作的(<a class="ae mb" href="https://github.com/bitsofinfo/gitops-argparser" rel="noopener ugc nofollow" target="_blank">参见完整的gitops-argparser自述文件了解详细信息</a>):</p><p id="2048" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，定义您的参数配置文件:</p><pre class="lp lq lr ls gt md me mf mg aw mh bi"><span id="e44a" class="mi km iq me b gy mj mk l ml mm">arguments:<br/>  - long: arg1<br/>    dataType: string<br/>    help: This is argument number one<br/>    defaultValue: arg1default<br/>  - long: arg2<br/>    dataType: string<br/>    help: This is argument number two<br/>    defaultValue: "hi"<br/>  - long: arg3<br/>    dataType: int<br/>    help: This is argument number three<br/>    defaultValue: 2<br/>  - long: arg4<br/>    dataType: bool<br/>    help: This is argument number four<br/>    defaultValue: true</span></pre><p id="9ebb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，基于您的CI/CD平台和它如何工作的细节，定义一个参数变量发射器模板(这支持<a class="ae mb" href="https://golang.org/pkg/text/template/" rel="noopener ugc nofollow" target="_blank"> Golang模板</a>和<a class="ae mb" href="https://github.com/Masterminds/sprig" rel="noopener ugc nofollow" target="_blank"> Sprig函数支持</a>)。这是Azure的一个示例。这个文件的位置默认为本地目录，但是可以用ENV var: <code class="fe mn mo mp me b">COMMIT_MSG_ARGPARSER_OUTPUT_TMPL_FILE</code>覆盖</p><pre class="lp lq lr ls gt md me mf mg aw mh bi"><span id="6459" class="mi km iq me b gy mj mk l ml mm">{{ range $arg := .Arguments }}<br/>##vso[task.setvariable variable={{$arg.Name}}]{{$arg.Value}}<br/>{{ end }}</span></pre><p id="b494" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在你的Azure Pipeline任务中，像这样做:</p><pre class="lp lq lr ls gt md me mf mg aw mh bi"><span id="b8d0" class="mi km iq me b gy mj mk l ml mm">...<br/><br/>- task: Bash@3<br/>    displayName: Parse commit message args<br/>    targetType: 'Inline'<br/>    script: ./gitops-argparser $(Build.SourceVersionMessage)<br/><br/>- task: Bash@3<br/>    displayName: Print pipeline vars from commit message args<br/>    targetType: 'Inline'<br/>    script: | <br/>        echo $(arg1)<br/>        echo $(arg2)<br/>        echo $(arg3)<br/>        echo $(arg4)</span></pre><p id="e4dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么接下来会发生什么？您向Git提交触发管道的内容，但在提交消息中指定参数:</p><p id="8207" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，类似于:</p><pre class="lp lq lr ls gt md me mf mg aw mh bi"><span id="d1ec" class="mi km iq me b gy mj mk l ml mm">git commit . -m "whatever text -arg1 val1 -arg2 val2"; git push</span></pre><p id="66ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的管道拾取这些变量，并使这些变量对管道可用，然后您可以利用它们来控制您希望在整个CI/CD流中出现的任何行为。</p><p id="3ecc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望您会发现这很有用，或者只是触发一些额外的头脑风暴来解决您的特定需求。目前我唯一的使用例子是Azure Pipelines，还没有Docker镜像，但是我可能会添加一个。在任何情况下，这个想法肯定可以扩大！</p><p id="0c26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mb" href="https://github.com/bitsofinfo/gitops-argparser" rel="noopener ugc nofollow" target="_blank">https://github.com/bitsofinfo/gitops-argparser</a></p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="91ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mc">原载于2020年1月4日</em><a class="ae mb" href="https://bitsofinfo.wordpress.com/2020/01/04/cicd-git-commit-message-arguments/" rel="noopener ugc nofollow" target="_blank"><em class="mc">【http://bitsofinfo.wordpress.com】</em></a><em class="mc">。</em></p></div></div>    
</body>
</html>