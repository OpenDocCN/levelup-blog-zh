<html>
<head>
<title>A Module Federation Example for React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React的模块联合示例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-module-federation-example-for-react-1fa29d6ac07b?source=collection_archive---------0-----------------------#2020-10-28">https://levelup.gitconnected.com/a-module-federation-example-for-react-1fa29d6ac07b?source=collection_archive---------0-----------------------#2020-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d0df" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">具有模块联合的微前端</h2></div><p id="25f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看通过模块联合实现的React微前端解决方案</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/169b4700506e68b244fad8b7e3536098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0OZzs6S9bhrQeHA9NlSGbw.png"/></div></div></figure><h1 id="8035" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">前情提要…</h1><p id="a662" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">这个例子的基础是我不久前写的另一篇<a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/a-micro-frontend-solution-for-react-1914b19663b">文章</a>，展示了带有React的微前端。简言之，该应用程序是一个法国牛头犬配件网店，其中的主机应用程序是一个简单的React应用程序，带有产品列表和购物车页面。这两条路线是渲染一个产品和一个购物车微前端。查看<a class="ae mk" rel="noopener ugc nofollow" target="_blank" href="/a-micro-frontend-solution-for-react-1914b19663b">故事</a>了解更多详情。在这篇文章中，我想介绍一种使用模块联合的微前端的可能实现，并从几个角度比较这两种解决方案。如果你想详细了解这个例子，下面是一份报告:</p><div class="ml mm gp gr mn mo"><a href="https://github.com/burzaszsolt/react-module-federation" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">burzaszsolt/react-模块-联邦</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">这是一个使用javascript方法将微前端与react结合使用的例子。如果你有docker，那就是…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">github.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc ll mo"/></div></div></a></div><h1 id="df62" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">模块联盟</h1><p id="1d11" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">您可能从未听说过这个Javascript架构，因为它是Webpack 5中引入的一个非常新的特性。最好的描述来自发明者<a class="ae mk" href="https://medium.com/@ScriptedAlchemy" rel="noopener">本人</a>:</p><blockquote class="nd ne nf"><p id="ed09" class="kf kg ng kh b ki kj jr kk kl km ju kn nh kp kq kr ni kt ku kv nj kx ky kz la ij bi translated">模块联合允许JavaScript应用程序从另一个应用程序动态加载代码—在此过程中，共享依赖关系，如果使用联合模块的应用程序没有联合代码所需的依赖关系— Webpack将从该联合构建源下载缺少的依赖关系。</p></blockquote><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="aa2f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">听起来很酷，对吧？如果你想了解更多关于这个话题的信息，请先阅读这个故事，然后再回来。现在让我们来看看，为了使用模块联合作为我的应用程序的微前端架构的基础，我必须做哪些更改。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="438d" class="ln lo iq bd lp lq nt ls lt lu nu lw lx jw nv jx lz jz nw ka mb kc nx kd md me bi translated"><strong class="ak">解决方案</strong></h1><h2 id="a15e" class="ny lo iq bd lp nz oa dn lt ob oc dp lx ko od oe lz ks of og mb kw oh oi md oj bi translated">遥控器</h2><p id="ba64" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">为了将我的微前端变成远程应用，我所要做的就是将<code class="fe ok ol om on b">ModuleFederationPlugin</code>添加到我的webpack配置文件中。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oo nl l"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">产品微前端的webpack配置</figcaption></figure><p id="6e0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在插件配置中，我将<code class="fe ok ol om on b">ProductService</code>定义为一个我想从这个应用程序中公开的组件，这样它就可以在其他应用程序中使用。配置的另一个重要部分是<code class="fe ok ol om on b">shared</code>对象，在这里我可以列出主机和远程之间共享的所有依赖项。</p><h2 id="be49" class="ny lo iq bd lp nz oa dn lt ob oc dp lx ko od oe lz ks of og mb kw oh oi md oj bi translated">主持</h2><p id="8ada" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">有了这些改变，我就有了一个可以使用的遥控器。我所要做的就是在三个小步骤中改变主机，这样它就可以渲染微前端。第一步是更改webpack配置:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oo nl l"/></div></figure><p id="0281" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ok ol om on b">ModuleFederationPlugin</code>配置中，我将产品和购物车微前端定义为<code class="fe ok ol om on b">remotes</code>。这允许我在我的组件中访问它们。</p><p id="d0cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二步是在我的<code class="fe ok ol om on b">index.html</code>中添加所有遥控器的<code class="fe ok ol om on b">remoteEntry.js</code>。这些包很小(几kB ),包含关于模块的最少信息。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oo nl l"/></div></figure><p id="258f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三步(我最喜欢的)是在主机中渲染遥控器:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oo nl l"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">主机应用程序中的产品组件</figcaption></figure><p id="32a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我可以从<code class="fe ok ol om on b">mfProducts</code>遥控器惰性导入<code class="fe ok ol om on b">ProductService</code>，并在我的<code class="fe ok ol om on b">Products</code>组件中渲染它，就这样。就是这么简单。🎉🙌</p><h2 id="c28d" class="ny lo iq bd lp nz oa dn lt ob oc dp lx ko od oe lz ks of og mb kw oh oi md oj bi translated"><strong class="ak">双向主机</strong></h2><p id="bf7e" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">正如你可能注意到的，我还在微前端中公开并添加了远程主机应用程序。这意味着我所有的应用都是消费者和远程用户，这使得它们被称为双向主机。这样做允许我在我的微前端渲染主机应用程序，这样我就可以轻松地开发它们，就像它们是一个应用程序一样。我的微前端的入口点是呈现下面组件的<code class="fe ok ol om on b">index.js</code>:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oo nl l"/></div><figcaption class="op oq gj gh gi or os bd b be z dk translated">产品微前端中的App.js</figcaption></figure><p id="44b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我可以像处理遥控器一样处理暴露的主机应用程序。结果是，不管我在看哪个应用程序，它们看起来都一样。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="10ba" class="ln lo iq bd lp lq nt ls lt lu nu lw lx jw nv jx lz jz nw ka mb kc nx kd md me bi translated">结论</h1><p id="d000" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在这一章中，我想观察一下我的同一个应用程序的两个实现的一些方面，看看它们之间有什么不同。</p><h2 id="75a4" class="ny lo iq bd lp nz oa dn lt ob oc dp lx ko od oe lz ks of og mb kw oh oi md oj bi translated">暴露应用程序</h2><p id="7b31" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在前面的例子中，我从每个微前端创建了一个库，可以通过window对象在其他应用程序中访问这个库。这个库包含了一些方法，我实现了这些方法来渲染或卸载微前端。这并不是一个复杂的解决方案，但有了<code class="fe ok ol om on b">ModuleFederationPlugin</code>就更简单了。</p><h2 id="7cd4" class="ny lo iq bd lp nz oa dn lt ob oc dp lx ko od oe lz ks of og mb kw oh oi md oj bi translated">使用应用程序</h2><p id="9870" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">我很惊讶我可以如此轻松地使用主机上的遥控器。之前我创建了一个定制的<code class="fe ok ol om on b">useMicrofrontend</code> React钩子来动态地将微前端包加载到应用程序中。对于模块联合，默认情况下是支持的。</p><h2 id="4857" class="ny lo iq bd lp nz oa dn lt ob oc dp lx ko od oe lz ks of og mb kw oh oi md oj bi translated">表演</h2><p id="653a" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">这是模块联合的最大优势之一。通过共享依赖项，包的大小减少了很多。在前面的实现中，导航到cart页面会产生大约2.3MB的下载数据，这是cart微前端(开发构建)的包大小。对于同一个页面，通过模块联合传输的总数据量只有大约700kB。即使在如此小的应用程序中，这也是一个巨大的差异。</p><h2 id="bdf2" class="ny lo iq bd lp nz oa dn lt ob oc dp lx ko od oe lz ks of og mb kw oh oi md oj bi translated">发展</h2><p id="6a94" class="pw-post-body-paragraph kf kg iq kh b ki mf jr kk kl mg ju kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在我的第一个例子中，我可以将每个微前端作为一个独立的应用程序运行，但要将它们集成到主机应用程序中，我必须在每次更改时重新构建它们。使用双向主机实现，我可以立即检查我在任何应用程序中所做的每个更改，并测试它如何集成到整个应用程序中。这使得开发更加舒适和高效，同时保持了微前端的优势。</p><p id="977b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总而言之，我喜欢模块联盟的工作方式，很高兴看到它解决了使用微前端的一些缺点。我相信这是前进的方向，它将改变我们开发web应用程序的方式。</p></div></div>    
</body>
</html>