<html>
<head>
<title>How Does Golang Channel Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang频道是如何运作的</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-does-golang-channel-works-6d66acd54753?source=collection_archive---------1-----------------------#2021-08-08">https://levelup.gitconnected.com/how-does-golang-channel-works-6d66acd54753?source=collection_archive---------1-----------------------#2021-08-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f77c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解戈朗通道的内部运作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/848223016ebb93df1f40612028381f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*TwLvjm5ivaQKtYA3HbdmMw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">Goroutine和Channel</figcaption></figure><p id="e6c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个<strong class="kw iu"> goroutine </strong> <em class="lq">是一个轻量级的用户空间线程，由Go运行时管理。它同时执行任务，可能是并行的<em class="lq">。</em></em></p><p id="c5b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个<strong class="kw iu">通道</strong>用于goroutines之间的通信。</p><p id="1115" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我们将深入探讨通道的内部工作原理及其发送/接收操作。</p><h1 id="7d56" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">制作缓冲通道</h1><p id="e238" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们首先为下面的解释创建一个缓冲通道。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="1896" class="mt ls it mp b gy mu mv l mw mx">ch := make(chan int, 3)      </span></pre><p id="6955" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的语句创建了一个缓冲通道，最多可容纳3个类型为<code class="fe my mz na mp b">int</code>的值。</p><p id="2bd0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在底层，函数<code class="fe my mz na mp b">make</code>在堆上分配一个<code class="fe my mz na mp b">hchan</code>结构，并返回一个指向它的指针。</p><p id="fd1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是<code class="fe my mz na mp b">hchan</code>结构的一些字段及其解释。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/65d31063163825ad635028199078723d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*wprFXP6zyl8FPC1PhvslsQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated"><code class="fe my mz na mp b">hchan</code>结构的一些字段</figcaption></figure><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="e1b0" class="mt ls it mp b gy mu mv l mw mx">type <strong class="mp iu">hchan</strong> struct {</span><span id="a5c2" class="mt ls it mp b gy nc mv l mw mx"> buf      unsafe.Pointer<br/> sendx    uint<br/> recvx    uint<br/> lock     mutex<br/> <br/> ...   // other fields</span><span id="c36a" class="mt ls it mp b gy nc mv l mw mx">}</span></pre><ul class=""><li id="a73f" class="nd ne it kw b kx ky la lb ld nf lh ng ll nh lp ni nj nk nl bi translated"><code class="fe my mz na mp b">buf</code>是指向一个数组的指针，该数组维护一个<strong class="kw iu">循环队列</strong></li><li id="3215" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated"><code class="fe my mz na mp b">sendx</code>是数组中已发送元素的索引</li><li id="a914" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated"><code class="fe my mz na mp b">recvx</code>是数组中接收到的元素的索引</li><li id="34f4" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated"><code class="fe my mz na mp b">lock</code>确保通道的读写是原子操作</li></ul><h1 id="b444" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">解除阻塞发送和接收</h1><p id="7848" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">当通道未满时，我们可以在循环队列后面无阻塞地插入元素。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="0777" class="mt ls it mp b gy mu mv l mw mx">// G1 sends three elements into the channel, capicity = 3</span><span id="690b" class="mt ls it mp b gy nc mv l mw mx">ch &lt;- elem1<br/>ch &lt;- elem2<br/>ch &lt;- elem3</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/45bb6512f8fbbf8a014c484b04c94d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/1*MiGvGXqdwFYIvJG04oXc8A.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">解除阻塞发送操作</figcaption></figure><p id="fed3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当通道不为空时，我们可以从循环队列的前面无阻塞地接收元素。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="9827" class="mt ls it mp b gy mu mv l mw mx">// G2 receive three elements from the channel, capicity = 3</span><span id="d2ac" class="mt ls it mp b gy nc mv l mw mx">&lt;- ch<br/>&lt;- ch<br/>&lt;- ch</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/689a808087cc5c488f8ee8ada7050f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/1*79LgSQLrvrMQSAvy0R7cmw.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">解锁接收操作</figcaption></figure><h1 id="b9c1" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">等待路线</h1><p id="5d4e" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在处理goroutines之间的阻塞时，其他字段也很重要。让我们看一看。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/fdeb894b4417c15dfc6b469e07fa5324.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*P1TfF2N2KyAYjd5ZPsXOMA.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated"><code class="fe my mz na mp b">hchan</code>结构的一些字段</figcaption></figure><ul class=""><li id="c801" class="nd ne it kw b kx ky la lb ld nf lh ng ll nh lp ni nj nk nl bi translated"><code class="fe my mz na mp b">recvq</code>在试图读取通道上的数据时，存储阻塞的goroutines。</li><li id="c822" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated"><code class="fe my mz na mp b">sendq</code>尝试从通道发送数据时，存储被阻止的goroutines。</li></ul><blockquote class="ns nt nu"><p id="1f44" class="ku kv lq kw b kx ky ju kz la lb jx lc nv le lf lg nw li lj lk nx lm ln lo lp im bi translated">记住<code class="fe my mz na mp b">recq</code>和<code class="fe my mz na mp b">sendq</code>都是链表。</p></blockquote><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="eb28" class="mt ls it mp b gy mu mv l mw mx">type <strong class="mp iu">hchan</strong> struct {</span><span id="c424" class="mt ls it mp b gy nc mv l mw mx"> buf      unsafe.Pointer<br/> sendx    uint<br/> recvx    uint<br/> lock     mutex<br/> <br/> sendq    <strong class="mp iu">waitq</strong>   <br/> recvq    <strong class="mp iu">waitq</strong> </span><span id="dcdf" class="mt ls it mp b gy nc mv l mw mx"> ...   // more fields</span><span id="2a59" class="mt ls it mp b gy nc mv l mw mx">}</span><span id="ea9c" class="mt ls it mp b gy nc mv l mw mx">type <strong class="mp iu">waitq</strong> struct {<br/>  first *sudog      <br/>  last  *sudog<br/>}</span><span id="dfc4" class="mt ls it mp b gy nc mv l mw mx">// pseudo goroutine<br/>type <strong class="mp iu">sudog</strong> struct {<br/>  g     *g<br/>  elem  unsafe.Pointer <br/>  next  *sudog      <br/>  prev  *sudog<br/>  ...</span><span id="d5d3" class="mt ls it mp b gy nc mv l mw mx">  c     *hchan</span><span id="0240" class="mt ls it mp b gy nc mv l mw mx">}</span></pre><h1 id="0b43" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">从空信道接收</h1><p id="69ec" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">当通道为空时，接收操作会导致当前goroutine阻塞。所有阻塞的goroutines都存储在<code class="fe my mz na mp b">recvq</code>队列中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nz oa di ob bf oc"><div class="gh gi ny"><img src="../Images/7fcfaa4be553fcdda97a09ebd33c21d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/1*pisoQBZZpXjFxwXuSfIWuA.gif"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">从空信道接收</figcaption></figure><blockquote class="od"><p id="6abc" class="oe of it bd og oh oi oj ok ol om lp dk translated">阻塞的是goroutines，而不是OS线程。</p></blockquote><p id="3028" class="pw-post-body-paragraph ku kv it kw b kx on ju kz la oo jx lc ld op lf lg lh oq lj lk ll or ln lo lp im bi translated">那么，阻塞的goroutine什么时候恢复？</p><p id="66a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">答案是当一个新的goroutine在通道上执行发送操作时。</p><p id="3bf5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是细节。</p><ol class=""><li id="33ff" class="nd ne it kw b kx ky la lb ld nf lh ng ll nh lp os nj nk nl bi translated">新的goroutine将新数据直接复制到第一个等待的goroutine的元素中</li><li id="4b09" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp os nj nk nl bi translated">第一个等待程序从<code class="fe my mz na mp b">recvq</code>弹出</li><li id="e8ba" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp os nj nk nl bi translated">运行时调度器设置弹出的goroutine runnable，并把它放在它的'<code class="fe my mz na mp b">runqueue</code>。然后被阻塞的goroutine被触发并准备再次运行。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/7d6e3d3d9ec69b9943afbed80fcb1e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/1*Njsb290vyPAx0o6Qc1udTw.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">接收goroutine以继续</figcaption></figure><h1 id="5027" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">在完整信道上发送</h1><p id="407c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">当通道已满时，下一个发送操作会阻塞它们各自的goroutines。所有阻塞的goroutines都存储在<code class="fe my mz na mp b">sendq</code>队列中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/0c71ad880cdb45fc5a6e44404a715bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/1*cVt3pF8FcBtF3q1oVc3fHg.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">在完整信道上发送</figcaption></figure><p id="1cb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在另一个goroutine接收之前，被阻塞的goroutine将继续运行。以下是详细情况:</p><ol class=""><li id="19a0" class="nd ne it kw b kx ky la lb ld nf lh ng ll nh lp os nj nk nl bi translated">当新的goroutine在通道上执行接收操作时，缓冲区中的第一个元素将被删除</li><li id="e65a" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp os nj nk nl bi translated">第一辆等待的戈罗廷从<code class="fe my mz na mp b">sendq</code>起飞</li><li id="77ce" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp os nj nk nl bi translated">poped goroutine的元素被复制到缓冲区中</li><li id="0b8a" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp os nj nk nl bi translated">运行时调度器设置弹出的goroutine runnable，并放在它的'<code class="fe my mz na mp b">runqueue</code>。然后被阻塞的goroutine被触发并准备再次运行。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/75e015e7644eb8985ead057222cd1b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/1*PuE69Rxr70vr7b0FLKNnKQ.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">发送goroutine以继续</figcaption></figure></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="aad7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">渠道是围棋中一个非常强大而有趣的机制。希望这篇文章能解释Go中通道的基本工作原理。</p><p id="6bce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的视频绝对值得一看，有时间一定要看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pc pd l"/></div></figure><p id="eca9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，如果你喜欢这篇文章，请鼓掌，让其他人也能看到。💚</p><p id="f3b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">参考文章:</p><ul class=""><li id="7052" class="nd ne it kw b kx ky la lb ld nf lh ng ll nh lp ni nj nk nl bi translated"><a class="ae pe" href="https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8" rel="noopener" target="_blank">潜入戈朗海峡深处</a></li><li id="22f5" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated"><a class="ae pe" href="https://medium.com/@tilaklodha/concurrency-and-parallelism-in-golang-5333e9a4ba64" rel="noopener">Golang中的并发和并行</a></li><li id="3a04" class="nd ne it kw b kx nm la nn ld no lh np ll nq lp ni nj nk nl bi translated"><a class="ae pe" href="https://medium.com/swlh/go-a-tale-of-concurrency-a-beginners-guide-b8976b26feb" rel="noopener"> Go a Tale of Concurrency初学者指南</a></li></ul></div></div>    
</body>
</html>