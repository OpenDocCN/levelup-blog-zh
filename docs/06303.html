<html>
<head>
<title>10 Modern JavaScript syntax to help you code faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10种现代JavaScript语法帮助您更快地编码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/10-modern-javascript-syntax-to-help-you-code-faster-82cc0a5a3960?source=collection_archive---------0-----------------------#2020-11-13">https://levelup.gitconnected.com/10-modern-javascript-syntax-to-help-you-code-faster-82cc0a5a3960?source=collection_archive---------0-----------------------#2020-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="4b5d" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">技术</h2><div class=""/><p id="fbe4" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">甚至在10年前，JavaScript还只是一个让网站具有交互性的前端工具，只有一小部分开发人员在积极使用。然而，从那时起，情况发生了很大变化。</p><p id="32c9" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja"> NodeJS </strong>的引入，以及随之而来的服务器端解决方案，以及像<strong class="jy ja"> Webpack </strong>或<strong class="jy ja"> Grunt </strong>这样的构建工具的采用，使得学习JavaScript的前景变得非常受欢迎，以至于它很快成为世界上最受欢迎的语言之一。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/57f087dc77a88d362f035f10adae1393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUjtNn5egreEGK6eO9NCUw.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">来自<a class="ae lk" href="https://undraw.co" rel="noopener ugc nofollow" target="_blank">未绘制的插图</a></figcaption></figure><p id="b08c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">然而，JavaScript的迅速流行需要改进的语法和可维护的、易于理解的代码。不久之后——ES6出现了，一种新的JavaScript，其编写方式优雅而简洁。</p><p id="4b9f" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">从那以后，又发布了一些JavaScript版本，最新的版本是ES2020，为这种语言添加了许多开发人员友好的特性。本文将重点介绍10种这样的现代JavaScript语法，它们非常有用，易于适应，并且不需要深入了解所介绍的概念。</p><h1 id="3f42" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">1.字符串填充</h1><h2 id="0fa0" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kh mo mp lz kl mq mr md kp ms mt mh iw bi translated">String.prototype.padEnd()</h2><p id="7c73" class="pw-post-body-paragraph jw jx iq jy b jz mu kb kc kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt ij bi translated">这个方法会将当前字符串附加到另一个给定的字符串，如果需要的话会多次附加，直到它达到特定的长度。如下例所示，<code class="fe mz na nb nc b">hmm</code>字符串将被多次追加<code class="fe mz na nb nc b">.</code>，直到最后一个字符串的长度为6。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nd"><img src="../Images/87267a832aad42084e09615b99b72bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uMZGkCPogbNfo9Tb9OU6Gg.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例— String.prototype.padEnd()</figcaption></figure><h2 id="554c" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kh mo mp lz kl mq mr md kp ms mt mh iw bi translated">String.prototype.padStart()</h2><p id="ac17" class="pw-post-body-paragraph jw jx iq jy b jz mu kb kc kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt ij bi translated">这与<code class="fe mz na nb nc b">String.prototype.padEnd()</code>非常相似，除了现在字符串将从前面追加，而不是从末尾追加。</p><p id="1833" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">一个很受欢迎的场景是屏蔽电话号码或电子邮件地址。在支付网关或安全门户中，隐藏联系信息并显示最后3-4个字符是非常常见的，这足以让用户识别它是否是针对他们的。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ne"><img src="../Images/0db25b4ae3bfc8a291d846ddd8f8780a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kyYlyd1CZDXHE3eVXq6n2g.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例— String.prototype.padStart()</figcaption></figure><h1 id="54ea" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">2.Array.prototype.includes()</h1><p id="99f8" class="pw-post-body-paragraph jw jx iq jy b jz mu kb kc kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt ij bi translated">如果元素存在于给定的数组中，<code class="fe mz na nb nc b">includes</code>方法将返回<code class="fe mz na nb nc b">true</code>。如果该方法提供了第二个参数<code class="fe mz na nb nc b">fromIndex</code>，那么将从给定的索引开始搜索数组</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nf"><img src="../Images/885c6c4b92c520e1ea463135b4c189ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FdLWeJKlBg-OcnxRVUBn0g.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例— Array.prototype.includes()</figcaption></figure><h1 id="f7b3" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">3.Rest参数和扩展语法</h1><h2 id="7fcc" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kh mo mp lz kl mq mr md kp ms mt mh iw bi translated">休息参数</h2><p id="0242" class="pw-post-body-paragraph jw jx iq jy b jz mu kb kc kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt ij bi translated">当我们试图创建一个不确定参数个数的函数时，Rest参数特别有用。在函数定义过程中，在参数名称前添加一个<code class="fe mz na nb nc b">...</code>将创建一个数组，该数组将收集所有其他参数。也许，下面的例子会让事情变得更清楚——</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ng"><img src="../Images/90afed47af5b3256cced5a22720576f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDPthGcQpby9T2OZbo9Lkw.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例-静止参数</figcaption></figure><p id="1dde" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">我们也可以选择定义前几个参数，让数组中的参数的其余部分被收集。但是，这只能从正面进行，而不能从反面进行。换句话说，只有最后一个参数可以是rest参数—</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nh"><img src="../Images/d4b983105edb8d7933f50996514553c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhG1OEwPB6s-A7EcMMGkxw.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例-静止参数</figcaption></figure><h2 id="2f7e" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kh mo mp lz kl mq mr md kp ms mt mh iw bi translated">扩展语法</h2><p id="6f5e" class="pw-post-body-paragraph jw jx iq jy b jz mu kb kc kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt ij bi translated">从表面上看，休息和传播似乎是一回事，但实际上是完全相反的。语法(即<code class="fe mz na nb nc b">...</code>)可能看起来很相似，但它们的使用方式是它们的区别所在。</p><p id="7619" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">在一个函数调用中— </strong>如果我们用spread语法传递一个数组，它实际上会将其扩展成一个参数列表。让我们考虑上面的<code class="fe mz na nb nc b">getSum()</code>例子，它接受不确定数量的参数。如果我们有一个数字数组，我们想重复使用这个方法，我们会这样做——</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ni"><img src="../Images/92c95a1cd0b87023e18c9abd09fd2f78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILbtSAp6N7IXrY9BM8Hwnw.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例—在函数调用中传播语法</figcaption></figure><p id="495c" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">到浅层拷贝— </strong>我们可以使用spread语法，对克隆的那个做任何进一步的操作都不会影响原来的数组。这个特性在对象的情况下也非常有用，但是稍后会详细介绍。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nj"><img src="../Images/782f3a267bf19eabc9cb2e6544fcd2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJn5tg9OoapprKUBLCp-MQ.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例-在浅层副本中传播语法</figcaption></figure><p id="a0be" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">数组操作— </strong> Spread语法提供了一种简单的替代方法来处理基本的数组操作，如连接、在不同位置添加元素等。这个可以用一个例子来更好的解释——</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nk"><img src="../Images/57eacc1625a827d5e693b110b8f10693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F49CeINQ9iCoNLCduCzXtw.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例-数组运算中的扩展语法</figcaption></figure><p id="077b" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated"><strong class="jy ja">继续讨论对象—</strong>es 2018中引入了扩散/静止属性。它的工作方式与之前讨论过的非常相似，只是在某些地方稍有改动。这里有几个如何利用它的例子—</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nl"><img src="../Images/1d4224717883015c1dc5cbf0f0b2db6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RGSUiJoItIOFslLyLCk_cQ.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例-对象的静止/伸展</figcaption></figure><h1 id="b6c1" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">4.对象迭代器</h1><h2 id="5c9d" class="mj lm iq bd ln mk ml dn lr mm mn dp lv kh mo mp lz kl mq mr md kp ms mt mh iw bi translated">键、值和条目—</h2><p id="e93d" class="pw-post-body-paragraph jw jx iq jy b jz mu kb kc kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt ij bi translated"><code class="fe mz na nb nc b">Object.keys()</code>返回一个对象所有键的数组，同样<code class="fe mz na nb nc b">Object.values()</code>返回一个所有值的数组。另一方面，<code class="fe mz na nb nc b">Object.entries()</code>返回一个由<code class="fe mz na nb nc b">[key, value]</code>对组成的数组。一如既往，实例胜于雄辩—</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nm"><img src="../Images/2e8fd76eb6f2586f620171c5a815c1e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovjD27Hmsb9YBxUIn757mA.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例-对象关键字、值、条目</figcaption></figure><h1 id="5ed4" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">5.可选链接</h1><p id="89f3" class="pw-post-body-paragraph jw jx iq jy b jz mu kb kc kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt ij bi translated">当您处理不可靠、不可预测的数据时，这个特性就派上了用场。例如，我个人曾面临过多种场景，在这些场景中，我需要一些深度嵌套的属性，而整个应用程序会出现这样的消息</p><blockquote class="nn no np"><p id="cec4" class="jw jx nq jy b jz ka kb kc kd ke kf kg nr ki kj kk ns km kn ko nt kq kr ks kt ij bi translated">未捕获的类型错误:无法读取未定义/空的属性<strong class="jy ja"> someProperty </strong></p></blockquote><p id="ef9a" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这就是可选链接要解决的问题。只有当链条不是<em class="nq">无效</em>(即不是<code class="fe mz na nb nc b">null</code>或<code class="fe mz na nb nc b">undefined</code>)时，操作器<code class="fe mz na nb nc b">?.</code>才会进入下一级深度。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nu"><img src="../Images/b9cc4d17d480e8d46437d09ca079a082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zITbwqy3hnZAoXVByJwS-A.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例-可选链接</figcaption></figure><h1 id="df74" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">6.零融合算子</h1><p id="dd97" class="pw-post-body-paragraph jw jx iq jy b jz mu kb kc kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt ij bi translated">如果你用过逻辑OR <code class="fe mz na nb nc b">||</code>，你会觉得很熟悉。如果你没有，让我们先讨论一下。如果您的变量是<em class="nq"> falsy </em>(即<code class="fe mz na nb nc b">null</code>、<code class="fe mz na nb nc b">undefined</code>、<code class="fe mz na nb nc b">0</code>和<code class="fe mz na nb nc b">false</code>中的一个)，逻辑OR将提供默认值。</p><p id="7f51" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">非常类似地，如果变量是<em class="nq"> nullish </em>(即<code class="fe mz na nb nc b">null</code>或<code class="fe mz na nb nc b">undefined</code>)，Nullish合并<code class="fe mz na nb nc b">??</code>将提供默认值。让我们看一个例子——</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nv"><img src="../Images/a9ab2d9f36195e37bd1e8972cfac1b7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*neaVz5kokxEeiLHGurgW2Q.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例—零化合并运算符</figcaption></figure><h1 id="50c7" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">7.逻辑赋值运算符</h1><p id="b856" class="pw-post-body-paragraph jw jx iq jy b jz mu kb kc kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt ij bi translated">逻辑AND赋值(即<code class="fe mz na nb nc b">&amp;&amp;=</code>)运算符仅在<em class="nq"> truthy </em>中的变量时赋值，而逻辑or赋值(即<code class="fe mz na nb nc b">||=</code>)运算符会在变量为<em class="nq"> falsy — </em>时赋值</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nl"><img src="../Images/ba920a2a3be2fd7b3d577d1cd9b76dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4M7p5TKTsudxtw936t9wA.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例-逻辑赋值运算符</figcaption></figure><p id="8569" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">在我们不确定一个属性是否存在于一个对象中，但是我们需要以某种方式操作它的场景中，逻辑OR赋值提供了一个更干净的选择来代替<code class="fe mz na nb nc b">undefined</code>检查。</p><p id="6da6" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">比方说，我们需要找出一个元素在数组中重复出现的次数。我更喜欢这样做，通过迭代数组并存储对象中每个元素的计数—</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nl"><img src="../Images/38c55a8892fdbaf766045ddd26dc30e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-98-rs0qFunHGJcRLmx7lg.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例-逻辑或赋值运算符</figcaption></figure><h1 id="b238" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">8.数字分隔符</h1><p id="9926" class="pw-post-body-paragraph jw jx iq jy b jz mu kb kc kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt ij bi translated">JavaScript已经学会在读取数字时排除下划线。当我们处理大数字时，这提高了代码的可读性</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nl"><img src="../Images/b75cfb8c4ea82eaab62cd042abb519e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9v_KKrRox0UvpG5Qy5G9Q.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例-数字分隔符</figcaption></figure><h1 id="ccbe" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">9.模板文字</h1><p id="2616" class="pw-post-body-paragraph jw jx iq jy b jz mu kb kc kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt ij bi translated">模板文字使得处理字符串更加容易。我们可以去掉转义字符，通过用反勾号(即<code class="fe mz na nb nc b">`</code>)将输出打包，得到与代码中完全一样的输出</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nl"><img src="../Images/f87e22c91bbdc29737d3be52e3ea8f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ufbb33Px2HT5AgOitUm0-A.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例—模板文字</figcaption></figure><p id="f2c9" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">模板文字的另一个有用的特性是他们所谓的——表达式插值。大多数时候，我们希望在字符串之间添加某种表达式，代码可读性受到字符串连接所需的所有<code class="fe mz na nb nc b">+</code>符号的严重影响。一个更好的方法是将<code class="fe mz na nb nc b">${expression}</code>中的表达式包装在一个模板文字中—</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nl"><img src="../Images/4377b816f922a3121330601242ac678c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNI_sQFKExieEYX8AZLdTw.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例-使用模板文字的表达式插值</figcaption></figure><h1 id="506d" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">10.默认参数</h1><p id="915b" class="pw-post-body-paragraph jw jx iq jy b jz mu kb kc kd mv kf kg kh mw kj kk kl mx kn ko kp my kr ks kt ij bi translated">此功能使我们能够在函数定义中用默认值初始化参数，只有在没有提供所述参数的情况下(即<code class="fe mz na nb nc b">undefined</code>)才会考虑该参数。当我们需要创建一个可以带或不带任何参数调用的函数时，这是很有用的</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi nl"><img src="../Images/792ed0b2b56a8aed64c120778e3ac0c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28yfHx5Lr04_IWbRE2XmGg.png"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">示例-默认参数</figcaption></figure></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="9f04" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">这就是名单！<br/>感谢并祝贺到达文章结尾。希望你觉得有用。</p><p id="e044" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">当你在这里的时候，你也可以看看我的其他几篇文章</p><ul class=""><li id="d400" class="od oe iq jy b jz ka kd ke kh of kl og kp oh kt oi oj ok ol bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/how-to-flex-a-beginners-guide-904c3edc2fdc">Flexbox终极指南</a></li><li id="6de1" class="od oe iq jy b jz om kd on kh oo kl op kp oq kt oi oj ok ol bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/10-css-things-i-wish-i-knew-when-i-was-a-beginner-68ba4b5b3da8">我希望自己在初学时就知道的10件CSS事情</a></li></ul><p id="fe95" class="pw-post-body-paragraph jw jx iq jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ij bi translated">干杯！</p></div></div>    
</body>
</html>