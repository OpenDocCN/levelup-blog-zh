<html>
<head>
<title>How and why to use a function to configure New() in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何以及为什么在Golang中使用函数来配置New()</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-and-why-to-use-a-function-to-configure-new-in-golang-f042b52ca99?source=collection_archive---------8-----------------------#2022-02-10">https://levelup.gitconnected.com/how-and-why-to-use-a-function-to-configure-new-in-golang-f042b52ca99?source=collection_archive---------8-----------------------#2022-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ef76f9162dbd5663373eb0330bce290b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_t6sKmbn6k9_usmByvsKg.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@geekgunda?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Chinmay Bhattar </a>在<a class="ae jg" href="https://unsplash.com/s/photos/golang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><div class=""><h2 id="22d7" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">因为对象太主流？</h2></div><p id="10fb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当实现返回某个<code class="fe lu lv lw lx b">struct</code>的新实例的方法<code class="fe lu lv lw lx b">New()</code>时，我最近喜欢传递配置新实例的函数，而不是传递配置值的对象/映射，让<code class="fe lu lv lw lx b">New</code>方法处理一切。</p><p id="5a16" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原因如下。</p><h1 id="ab49" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">定义我们的目标</h1><p id="4151" class="pw-post-body-paragraph ky kz jj la b lb mq kk ld le mr kn lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">考虑我们简单命名的类<code class="fe lu lv lw lx b">objectInstance</code>:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="f506" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">使用配置对象</h1><p id="cdf0" class="pw-post-body-paragraph ky kz jj la b lb mq kk ld le mr kn lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">现在考虑以下使用配置对象初始化新的<code class="fe lu lv lw lx b">objectInstance</code>的实现:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="d382" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这导致使用者代码如下所示:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="86c5" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">使用配置功能</h1><p id="61dc" class="pw-post-body-paragraph ky kz jj la b lb mq kk ld le mr kn lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">实现上面的方法，我们使用一个函数来初始化这个<code class="fe lu lv lw lx b">objectInstance</code>,看起来像这样:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b6c4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">消费代码现在看起来像这样:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="b9b2" class="ly lz jj bd ma mb mc md me mf mg mh mi kp mj kq mk ks ml kt mm kv mn kw mo mp bi translated">为什么以及何时使用这种模式</h1><p id="9560" class="pw-post-body-paragraph ky kz jj la b lb mq kk ld le mr kn lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">我很确定有一个我没有听说过的模式名称，所以我不会给它命名。</p><p id="538c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，这种模式显然不适合用于只传递一两个参数的情况。在这种情况下，遵从保持简单的原则！</p><p id="79ad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在必须传递多个参数来配置一个对象实例的情况下，这种模式是一种更简洁的替代方式，该对象的设计目的是向消费者隐藏复杂性。想象一个标准化的HTTP服务器实例，其中你可能必须定义各种超时值、主体大小限制、绑定接口、监听端口等等。</p><p id="53ff" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我发现这种做事方式非常好:</p><h2 id="53c3" class="nc lz jj bd ma nd ne dn me nf ng dp mi lh nh ni mk ll nj nk mm lp nl nm mo nn bi translated">封装配置范围</h2><p id="e780" class="pw-post-body-paragraph ky kz jj la b lb mq kk ld le mr kn lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">所有与配置<code class="fe lu lv lw lx b">objectInstance</code>相关的代码都可以封装在一个函数的作用域中。这通过允许您在自己的配置函数中定义仅在<code class="fe lu lv lw lx b">objectInstance</code>的初始化中使用的变量，提高了作用域的健康性。</p><p id="9ae8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果不需要使用来自父作用域的值，您甚至可以将其完全抽象出来，这也提高了可测试性:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="40bb" class="nc lz jj bd ma nd ne dn me nf ng dp mi lh nh ni mk ll nj nk mm lp nl nm mo nn bi translated">避免混乱的值检查</h2><p id="3937" class="pw-post-body-paragraph ky kz jj la b lb mq kk ld le mr kn lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">Golang在错误处理方面极其冗长。你已经有足够的<code class="fe lu lv lw lx b">error</code>要检查，所以减少你必须做的其他检查的数量。</p><p id="9c3d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用一个函数来配置初始化器类允许我们减少圈复杂度，当有一些事情需要检查时，圈复杂度会迅速增加:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ebb8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在看起来像这样:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="7232" class="nc lz jj bd ma nd ne dn me nf ng dp mi lh nh ni mk ll nj nk mm lp nl nm mo nn bi translated">避免配置对象中的代码重复</h2><p id="a618" class="pw-post-body-paragraph ky kz jj la b lb mq kk ld le mr kn lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">当使用一个对象配置返回另一个对象的函数时，在大多数情况下，返回的对象实例具有许多与其配置对象相似的属性:</p><figure class="mv mw mx my gt iv"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bf78" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用配置功能可以通过以下方式完全避免这种情况:</p><ol class=""><li id="7721" class="no np jj la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">允许使用者直接访问对象实例的属性，而</li><li id="d4ec" class="no np jj la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">支持在消费者配置后运行验证检查</li></ol></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="a551" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总之，试一试，看看它如何改变您的代码！下次见-</p><p id="20c7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你发现以上有用，考虑给一些👏这对你来说是免费的，它将激励我在我的工程旅程中继续分享类似的概念。或者，我刚刚创建了<a class="ae jg" href="https://hi.joeir.net/other-things/my-referral-codes" rel="noopener ugc nofollow" target="_blank">这个推荐页面</a>，如果你愿意为我使用的服务给我一个推荐奖励(在大多数情况下，你也会得到一些东西)。</p></div></div>    
</body>
</html>