# 除了 React 中正确钻孔之外

> 原文：<https://levelup.gitconnected.com/beyond-prop-drilling-in-react-using-context-reducers-and-custom-hooks-to-connect-components-f427b7d4289>

## 使用上下文、缩减器和定制挂钩来连接组件

![](img/78cc09a119738dfae070c3f38a3fa108.png)

由[安德烈·库兹明](https://www.shutterstock.com/g/akz)为[穿梭者托](https://www.shutterstock.com/)

React 文档和介绍性教程很好地解释了钩子如何工作，但是没有解释它们如何一起工作。

我们知道如何使用`useState`和`useEffect`在组件内部做一些事情。但是当我们需要在组件之间共享状态时会发生什么呢？我们怎样才能做到这一点而不把我们的代码变成意大利面条呢？

我写了这篇文章来帮助缩小这个差距。这篇文章很长，内容丰富，但希望它能让您了解创建协作组件组的不同实践。

在我们进入我们的例子之前，让我们先介绍一下玩家。

# 什么是语境？

如果你已经很熟悉了，那就跳过它。

上下文是一个 React 特性，它允许我们存储数据，这些数据在组件树的更深处变得可用。通过使用上下文，我们可以避免“prop drilling”，即我们将属性从一个组件传递到下一个组件，再传递到下一个组件，直到我们最终到达实际使用这些属性的组件。

Context 的工作方式是定义一个上下文，在其提供程序中存储一个值，然后使用子级中的上下文来检索该值:

这段代码返回`<h1>Other components can get me through context!</h1>`。

一些需要注意的事项:

*   上下文是作为模块中的顶级变量创建的。这让 React 跟踪不同类型的上下文(您可以创建许多不同的类型！)并确保你得到了你所要求的上下文类型。
*   上下文的提供者将其值提供给任何想要使用该值的子节点。
*   当提供者的值改变时，任何使用该上下文的组件都会被重新呈现。

## 谨慎使用上下文！

最后一行至关重要。*每当提供者的* `*value*` *发生变化时，为该上下文调用* `*useContext*` *的每个组件都会被重新呈现。这意味着上下文并不是在任何地方都有用。*

*   如果您在应用程序的根目录附近使用上下文，那么`value`属性应该很少改变。如果它的值在你的站点中被使用，你会发现每次你的上下文的`value`属性改变时，你的站点都要做大量额外的重新渲染。顶级上下文对于用户配置文件信息或样式主题等事情有意义，因为这些很少改变。它实际上是为组件“提供上下文”。跟踪用户交互或 API 数据存储/检索应该使用不同的技术。
*   你需要小心追踪`value`是如何变化的。当您在组件中构建对象文字，或者使用`filter`或`map`数组函数时，尤其如此。这些技术每次都创建新的对象和数组，每次都改变`value`，这会导致过多的重新渲染和无限循环。这需要小心管理。

对于需要在全局级别操作和跟踪数据的情况，使用针对目标状态管理优化的库，例如 [Redux](https://redux.js.org/) 。尽管有无数文章声称 Context 可以取代 Redux，但它优化的状态管理和渲染触发使它成为一个可行的全局状态管理器。即使在中等规模的应用程序中，React Context 也无法在全局级别管理频繁的数据更改，否则会导致严重的性能问题。

但是在一小组合作的组件中，上下文将完成这项工作。它还可以和 Redux 一起使用，用于在将结果存储到全局状态之前管理一小组临时的、迭代的状态变化。

# 什么是减速器？

如果您已经熟悉了这一点，也可以跳过这一步。

缩减器是一个函数，它获取状态，并在给定要执行的不同动作后，返回新的状态。(如果严格从设计模式的角度来看，它实际上是一个使用命令模式实现更改的 reducer 函数，但是 React 社区将这种组合简单地描述为 reducer。)

这个想法是你可以发送一个动作给你的 reducer 以及先前的状态，基于那个动作获得新的状态，并且以一种让你不必担心新的状态是如何产生的方式去做。只要你告诉减速器“做 *X* ，减速器就可以按照它喜欢的任何方式做 *X* 。它使重构变得更容易，并且利用构建 reducer 的新技术，它使向 reducer 添加新动作变得更容易。

Reducers 可能会感觉很麻烦，尤其是如果您遵循任何使用`switch` / `case`来处理不同命令的老派 Redux 示例。使用简单状态，可以更容易地创建具有不同属性的对象并更新该对象，或者只是将属性作为独立的状态单元来处理。

然而，通过使用缩减器，您的组件不需要知道如何改变您的状态。组件关心的只是状态，并且它可以改变状态。所有改变状态的机制都存储在一个位置，供任何需要的组件使用。

此外，不用写永无止境的`switch` / `case`列表，你可以使用 [Redux Toolkit](https://redux-toolkit.js.org/) 中的`[createSlice](https://redux-toolkit.js.org/api/createSlice)`轻松创建一个成熟的缩减器。虽然是为 Redux 做的，但是这个相同的功能可以为 React 的`useReducer`钩子做减速器。它允许您为给定的动作定义 reducer 代码，并且它会自动为您创建动作。这比你自己管理这些行为要令人满意得多。我强烈推荐使用它来创建生产就绪的 reducer 代码，不管有没有 Redux。我们将在下面的例子中展示如何使用它。

## 使用 useReducer 管理复杂的状态更改

Redux 是使用全局状态缩减器的首选库，而 React 提供了自己的机制`useReducer`，根据您提供的缩减器来调度更新状态的操作。它接受初始状态和一个接受您的命令的 reducer，并用一个 dispatcher 返回最新的状态。当一个动作被发送到 dispatcher 时，它到达 reducer，后者根据数据更新状态。

例如，我们可以用如下方式管理表单的字段:

在这个例子中，所有更新状态的代码都在`exampleReducer.js`中，但是`Form.jsx`并不关心。它只知道，只要通过`changeField`命令将字段的名称和值发送给 reducer，reducer 就会以某种方式更新值。如果 reducer 需要做任何特殊的检查或转换，它可以在组件不担心的情况下完成。

关于`useReducer`的一个好处是，像`useState`中的 setter 一样，`dispatch`函数在组件的生命周期内不会改变。这意味着您可以通过组件层次结构将它传递到任何地方，添加它以影响依赖关系，并确信它不会触发任何额外的渲染。

# 自定义挂钩:隐藏杂物

如果你已经熟悉这个，你知道该怎么做。

许多 React 的新开发者将定制钩子视为某种形式的神秘艺术，只有 React 的高级牧师才能尝试。

它们真的很简单。它们是辅助函数，就像其他辅助函数一样，只是它们在内部使用了钩子。通常他们结合 React 的标准钩子来隐藏使用这些标准钩子的混乱。例如，React-Redux 的`useSelector`是您会发现的更复杂的定制钩子之一，但是它本质上使用基本的 React 钩子来订阅特定内容的状态变化。

这是编写定制钩子的关键:如果你想创建一个助手函数，并且它需要使用钩子，那么你需要创建一个定制钩子。如果它不需要钩子，就用简单的函数。

虽然您当然可以使用钩子来生成可重用的代码，但是它对于将所有代码都放在组件之外也非常有帮助。不用三四个钩子来管理组件中的状态和效果，你可以用一个名为 something sensical 的钩子，准确地返回你需要的信息，而不必担心组件本身的效果和状态管理。一项非常有益的家务管理技术。

# 上下文、useReducer 和定制钩子:天作之合

好吧，如果你跳过了最后三个部分，从这里开始。

当`useReducer`与上下文结合时，您就有了一种方法，可以从您的提供者下的任何组件更新您的状态，而无需进行适当的训练。你可以把这些乱七八糟的东西藏在一个定制的钩子里。

我们将通过一个简单的可搜索列表展示它是如何工作的。我们将介绍顶层组件，然后向下展示各个部分是如何组合在一起的。

这是我们的顶级组件:

我们可以看到，我们用自定义钩子创建了上下文值，然后输出列表。

您会注意到列表中还有另外三个组件— `<Search/>`、`<Results/>`和`<Pagination/>` —但是它们都没有任何属性。它们将利用传入`<SearchableListContext.Provider/>`的值来检索上下文的值。

此外，我们还有将要使用的上下文:

上下文非常容易定义。开发人员通常会将它嵌入到使用它的提供者的同一个组件中，但是我倾向于将它做成自己的模块，这样我就可以很容易地导入它，然后通过`useContext(SearchableListContext)`访问它。

(这是一个非常简单的例子，我们所有的子组件对父组件都是可用的，所以你可以不使用上下文。但是随着您的协作组件组变得更大或者变得嵌套，这些实践将变得更加有用。)

## 旁注:关注点分离和制造愚蠢的组件

您可能会注意到，这个组件看起来非常简单。它为钩子提供一个列表和一个搜索功能，将钩子的结果发送给上下文提供者，并为列表创建结构。就是这样。

这是故意的。将所有代码放在一个地方非常容易，可以产生 200 行的组件，将表示、状态管理、交互性和业务逻辑放在一个地方。这样做可能会很难跟踪任何特定问题发生了什么。

我倾向于将我的代码分成以下几层:

*   状态管理
*   业务逻辑
*   交互性
*   介绍会；展示会

尽管这些层之间的界限有时会模糊，但它让我独立地思考每一层。状态的东西不关心状态为什么改变，它只是做它。业务逻辑知道为什么状态需要改变，但是不关心它如何改变。交互层知道它需要向业务逻辑发送用户响应，但是不关心业务逻辑如何进行交互。表示逻辑只输出结果。

通过将代码分成这些块，每个块在其自己的上下文中都是可管理和可理解的。

这是组件设计的一个很大的部分:当我几个月后回到同样的代码时，在我能感觉到一个组件是做什么的之前，我必须努力完成多少代码？通过拆分代码并给程序块起一个有用的名字，你未来的自己就不需要记住程序块做了什么。他们可以查看一小块代码区域中的名称，以决定下一步去哪里。

# 将复杂性隐藏在自定义挂钩中

顶层组件如此简单的主要原因是因为我们将复杂性隐藏在自定义挂钩中。这是一次性定制钩子的主要原因。即使钩子不可重用，它也不会使表示逻辑复杂化。

让我们看看这个定制钩子如何构建我们用于组件组其余部分的上下文值:

你可以看到钩子基本上做了四件事:

1.  设置一个缩减器来管理我们的状态
2.  产生在我们的演示中使用的价值
3.  生成 setters 来管理业务逻辑，并对交互层隐藏状态管理层
4.  将值和设置器捆绑到一个内存化的对象中，用于我们的上下文中

通过将所有这些代码放入一个定制的钩子中，我们可以在一个文件中管理我们的业务逻辑的范围。我们不需要转换思维齿轮来管理状态或表达。如果我在这个文件中，我会考虑 getters 和 setters，以及搜索和数据返回的业务规则，仅此而已。我会在其他地方担心如何处理这些信息。

这听起来相对简单，但是需要很多代码，因为我们将结果传递给一个上下文。我们不希望无限的重新渲染。所以我们需要记住一切。

## 创建上下文值以及 useCallback 和 useMemo 的重要性

`useCallback`和`useMemo`真的没有得到应有的功劳。通常人们会从性能优化的角度来谈论它们。但是当你需要管理依赖和重新渲染的时候，它们才真正闪耀。通过记忆对象和函数，您告诉 React 只在依赖关系改变时重新创建它们。这让您可以控制何时触发效果和更新上下文。

在我们的例子中，我们需要记忆返回的对象。如果我们简单地返回一个对象文字，那么每次调用钩子时都会重新创建它，每次都要强制重新呈现所有的消费者，这在最好的情况下是浪费，在最坏的情况下会产生无限的呈现。

但是记忆一个对象意味着查看该对象中的所有依赖项。虽然我们可以欺骗并将`// eslint-disable-next-line react-deps/exhaustive-hooks`添加到最后一个`useMemo`中，但是我们冒着不能捕捉到变化的风险。通过每次恰当地管理依赖性，我们可以更好地理解为什么我们在绝对必要的时候打破规则，而不是让它成为一种轻率的习惯。

如果我们看看`searchableListContextValue`中的依赖列表，我们可以看到`pageCount`、`pageNumber`和`searchText`是原语(字符串、布尔值或数字)，但是`displayedList`、`setFullList`、`setSearchText`和`setPageNumber`是在钩子内部创建的对象或函数。如果我们只是简单地将它们发送到`useMemo`而没有记忆它们，`searchableListContextValue`仍然会被重新创建，因为每次都会创建对象/函数的新版本。所以我们也需要将这些对象和函数包装在`useMemo`或`useCallback`中。

当我们开始记忆函数和对象时，我们最终会创建一个依赖树，从一个对象到另一个对象，直到最终达到我们无法控制的原语或参数。对于`searchableListContextValue`，这棵树看起来像这样(原谅 ASCII 艺术):

searchableListContextValue 的相关性树

您可以通过查看您需要记忆什么、它的依赖项、需要记忆什么依赖项等等来创建其中之一。最后，您应该能够锁定每一个依赖项，或者作为一个原始值，一个仅由事件改变的值，或者根据钩子或组件的契约改变的参数。

在这种情况下，我们可以将所有这些依赖性缩小到当我们的状态改变时，或者当`items`或`onSearch`改变时改变的东西。我们可以控制自己的状态，但我们无法控制`items`或`onSearch`。当我们首先将它们传递给`SearchableList`时，我们需要记住这一点。

我们可以从`setFilteredList`的依赖数组中移除`onSearch`，但是对于一个内部组件组，我们也可以管理我们为`onSearch`发送的内容，以防止依赖被过于频繁地触发。如果可能的话，我会避免移除依赖关系，因为如果提供的`onSearch`函数由于某种原因需要更改，我们将无从知晓。

如果我们要建一个图书馆，我们必须用不同的方式来管理它。例如，来自`react-redux`的`useSelector`允许选择器是任何类型的函数，但是它检查结果，以查看组件是否应该重新呈现。

## 旁注:命名很难，但很重要。

不骗你，`useSearchableListContextValue`是一个很长的名字。它并不完美，但它确切地说明了它的作用。

命名函数、变量或组件时，记住两件事:

1.  六个月后，你会忘记名字的含义。确保它有足够的描述性，这个名字能告诉你它是做什么的，代表什么。
2.  确保你可以口头使用这个名字。有多少次你不得不告诉某人他们需要更新`numCtl`或打电话`setNetSysMgr()`？这样做比`numControls`或`setNetworkSystemManager()`要难得多。甚至考虑一下`inputCount`和`numInputs`发音的区别。如果它们代表相同的东西，考虑一下更容易脱口而出的那个。

编写代码不仅仅是为了告诉计算机做什么。它是用来告诉另一个开发者你要求计算机做什么的。你正在用一种叫 JavaScript(或 TypeScript 或其他什么)的语言写一篇文章，其他人需要能够阅读。一些惯例，像钩子被要求以`use`开始，使这变得困难，但是我们必须尽我们所能给出最好的镜头。

# 使用缩减器管理状态

我们已经研究了定制钩子如何将我们的状态连接到我们的组件并添加业务逻辑，但是我们还没有研究状态本身。这里是我们定义减速器的地方。

下面的文件使用 Redux Toolkit 的`createSlice`来创建一个缩减器，以及我们调用来更新缩减器的命令/动作:

如果你看过旧的 Redux 教程，这看起来与你习惯的定义 reducers 和动作完全不同。这就是`createSlice`如此有用的原因。您创建更新状态的函数，用对象文字给它们命名，瞧！瞬间减压器和动作。

如果您的操作需要不止一个参数，就像上面的`setReducerSearch`，您创建一个包含`prepare`和`reducer`函数的对象，一个用来打包参数，另一个用来用那个包更新状态。

这些“case reducer”函数既可以就地更新状态，也可以返回一个全新的对象。由`createSlice`返回的 reducer 允许您以任何方式更新内容，结果将是一个新的对象。

你可以在 [Redux Toolkit 文档](https://redux-toolkit.js.org/usage/usage-guide#simplifying-slices-with-createslice)中阅读更多关于`createSlice`的内容。但是您可以看到，每个返回的动作函数都与`reducers`对象中的一个函数相关联，并且这些函数在被整个`reducer`返回之前更新我们的状态。

这是一个非常简单的状态:完整列表、过滤列表、页码和搜索文本。但是该模型可以用于更复杂的状态，例如多选项卡模式或多步骤表单，其中它可以维护每个选项卡或步骤的数据，并标识要显示哪个选项卡/步骤。

一旦定义了 reducer 及其动作，reducer 就可以与 React 的`useReducer`挂钩一起使用，并在其返回的`dispatch`函数中调用动作。

# 交互和表示:使用上下文的组件

既然我们已经说明了上下文值是如何创建的，现在我们来看看它是如何被消费的。因为我们已经将业务逻辑放入了定制钩子中，并将状态放入了缩减器中，所以上下文消费者最终变得简单得可笑。

## 搜索

您可以看到，`Search`正在获取我们放在`SearchableListContext.Provider`实例中的上下文，并将其放在组件树上。所有`Search`关心的，所有它*应该*关心的，是将文本字段连接到搜索文本及其设置器。实际的工作发生在自定义钩子内部。

## 结果

同样，复杂性被保留在钩子中。我们只是简单地输出`displayedItems`。我们不关心如何决定哪些项目应该被显示。我们只是关心我们应该展示它们。

## 页码

最后一块。同样，我们只需要总页数、当前页码以及如何设置新页码。我们不需要知道这些值是如何得到的，或者 setter 是如何工作的。

这个组件有点复杂，因为我们需要从头开始创建一个数组来映射结果，但这还不算太疯狂。

还有我们的合作组件组！通过上下文和 reducer 链接，用自定义钩子封装。

你可以在[https://codesandbox.io/s/searchablelist-9erd0](https://codesandbox.io/s/searchablelist-9erd0)尽情享受这种自然的荣耀。

# TL；博士；医生

*   在让程序做你想做的事情之后，开发的第二个目标是编写几个月后任何人都能读懂的代码。如果看不懂，就重写。
*   上下文允许您减少任何给定组件中要跟踪的代码量，但是必须小心管理以防止虚假的重新呈现。
*   分离关注点——表示、交互、业务逻辑和状态——有助于集中您的思维，而不会一次转向太多方向。
*   定制挂钩让您可以将业务代码与组件代码分开，使您的组件更小、更容易理解。
*   Reducers 允许您将复杂的状态管理放在一个位置。Redux Toolkit 是简化构建一个缩减器的好方法。
*   给事物命名很难，但对交流很重要，也能提醒你在找出 bug 时可以忽略什么。

就是这样！希望这给了你一些关于如何开始构建协作组件的想法。