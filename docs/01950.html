<html>
<head>
<title>Run, Gateway, Run! — Algorithmic Trading the Serverless Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快跑，盖特威，快跑！—无服务器方式的算法交易</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/run-gateway-run-algorithmic-trading-the-serverless-way-71634dc1a37?source=collection_archive---------1-----------------------#2020-02-08">https://levelup.gitconnected.com/run-gateway-run-algorithmic-trading-the-serverless-way-71634dc1a37?source=collection_archive---------1-----------------------#2020-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="c6e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的<a class="ae ko" href="https://medium.com/@juri.sarbach/building-my-own-cloud-based-robo-advisor-5588ec1b74d3" rel="noopener">上一篇文章</a>中，我展示了我在谷歌云平台(GCP)上的自动算法交易基础设施的解决方案。最初，我打算将应用程序部署为由Cloud Scheduler触发的小块无服务器云功能。我没有采用这种首选方法，而是选择构建一个基于Kubernetes的应用程序，因为我必须在计算实例或Docker容器中运行Interactive Brokers (IB)网关软件。因此，无服务器的方式似乎从一开始就注定要失败。</p><h2 id="9bcf" class="kp kq it bd kr ks kt dn ku kv kw dp kx kb ky kz la kf lb lc ld kj le lf lg lh bi translated">运行时间！</h2><p id="8b45" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">然而，在开发Kubernetes应用程序时，我意识到这实际上是不正确的。确实有一种方法可以在Google Cloud上无服务器地运行容器化的工作负载。该产品被称为<a class="ae ko" href="https://cloud.google.com/run/" rel="noopener ugc nofollow" target="_blank">云运行</a>，并于最近正式发布(在本文的剩余部分，我指的是<a class="ae ko" href="https://cloud.google.com/run/choosing-a-platform#cloud-run-fully-managed" rel="noopener ugc nofollow" target="_blank">完全托管平台</a>)。云运行允许您部署监听HTTP端口的无状态工作负载。该服务自动公开一个惟一的端点(URL ),您可以通过HTTP请求来调用它。并且它会自动上下伸缩，如果没有请求，它甚至会变为零。</p><p id="ae4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这方面感觉很像云功能。只是您部署了整个Docker映像，而不仅仅是Python、Node.js或Go函数。这意味着您可以使用任何编程语言或运行任何您喜欢的二进制文件。像IB网关这样的二进制文件。因此，让我们将交易应用程序重新设计成无服务器的。</p><p id="50f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于Cloud Run使用容器，我可以重用我的Kubernetes解决方案中的很多内容。然而，正如我们将看到的，云运行工作负载的短暂本质要求对应用程序逻辑进行一些更改。基本思路是把Kubernetes上的每一个微服务都变成一个无服务器的云运行服务。为了触发投资策略算法，我使用了<a class="ae ko" href="https://cloud.google.com/scheduler/" rel="noopener ugc nofollow" target="_blank">云调度器</a>。这是GCP的cron job as a service产品，并从Kubernetes中的cron job对象接管了该功能。因此，从高层次的角度来看，这就是新应用程序架构的样子:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/a7c2b7575f078add444369721cd87925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIG-nS-DxA8WGsukahbG3A.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">简单的计划</figcaption></figure><p id="d089" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们一步一步地进行设置。我从核心(应用本身)开始，然后接触云调度器的配置、认证、秘密管理，最后是持续部署。我将只强调代码的一些部分。如果你对更多细节感兴趣，你可以在GitHub上找到完整的源代码。</p><h2 id="f5e8" class="kp kq it bd kr ks kt dn ku kv kw dp kx kb ky kz la kf lb lc ld kj le lf lg lh bi translated">铺平道路</h2><p id="5f6d" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">与Kubernetes解决方案相比，主要的变化来自于这样一个事实，即在Cloud Run版本中不再有一直运行的网关。在Kubernetes集群中，网关微服务始终处于运行状态，可用于应用程序的其他部分，如分配器或投资策略。虽然应用程序架构在云运行中仍然是请求驱动的，但我们现在必须为每个请求启动网关。因此，我们取消了分离，而是将它与每个服务捆绑在一起。</p><p id="d9a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据<a class="ae ko" href="https://cloud.google.com/run/docs/reference/container-contract#cpu-request" rel="noopener ugc nofollow" target="_blank">云运行契约</a>，计算仅限于请求的持续时间。与Kubernetes不同，Kubernetes在pod创建期间使用<a class="ae ko" href="https://github.com/IbcAlpha/IBC" rel="noopener ugc nofollow" target="_blank"> IBC </a>启动网关，这次我们将对每个请求启动网关，并在返回响应之前停止网关。像这样，它在容器进入挂起状态之前被正确终止。</p><p id="e454" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和之前的Kubernetes版本一样，我使用gunicorn和Falcon作为web服务器。它提供入口点并处理HTTP请求，调用实际的应用程序，并产生响应:</p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="7675" class="kp kq it me b gy mi mj l mk ml"># <a class="ae ko" href="https://github.com/jsarbach/ib-trading/blob/master/cloud-run/application/py/main.py" rel="noopener ugc nofollow" target="_blank">main.py</a></span><span id="ffa5" class="kp kq it me b gy mm mj l mk ml">from datetime import datetime<br/>import falcon<br/>import json<br/>import logging</span><span id="5920" class="kp kq it me b gy mm mj l mk ml"><br/>class Main:</span><span id="eeb9" class="kp kq it me b gy mm mj l mk ml">    <strong class="me iu">def on_get</strong>(self, request, response, trading_mode):<br/>        self._on_request(request, response, trading_mode)</span><span id="6b27" class="kp kq it me b gy mm mj l mk ml">    <strong class="me iu">def on_post</strong>(self, request, response, trading_mode):<br/>        body = json.load(request.stream)\<br/>           if request.content_length else {}<br/>        self._on_request(request, response, trading_mode, **body)</span><span id="6abf" class="kp kq it me b gy mm mj l mk ml">    @staticmethod<br/>    def _on_request(_, response, trading_mode, **body):<br/>        if trading_mode in ['live', 'paper']:<br/>            try:<br/>                [start and connect to IB gateway...]</span><span id="f885" class="kp kq it me b gy mm mj l mk ml">                [run application logic...]</span><span id="6a41" class="kp kq it me b gy mm mj l mk ml">                [disconnect from and terminate gateway...]<br/>            except Exception as e:<br/>                error_str = '{}: {}'.format(e.__class__.__name__, e)<br/>                logging.error(error_str)<br/>                retval = {'error': error_str}<br/>                response.status = falcon.HTTP_500<br/>        else:<br/>            logging.warning('Trading mode unset or invalid')<br/>            retval = {}<br/>            response.status = falcon.HTTP_200</span><span id="ced0" class="kp kq it me b gy mm mj l mk ml">        retval['utcTimestamp'] = datetime.utcnow().isoformat()<br/>        response.content_type = falcon.MEDIA_JSON<br/>        <strong class="me iu">response.body = json.dumps(retval)</strong></span><span id="1fd8" class="kp kq it me b gy mm mj l mk ml"><strong class="me iu">api = falcon.API()<br/>api.add_route('/{trading_mode}', Main())</strong></span></pre><p id="a643" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，一个先决条件是我们可以从应用程序内部控制网关，在我的例子中，应用程序是用Python编写的。幸运的是，<a class="ae ko" href="https://github.com/erdewit/ib_insync" rel="noopener ugc nofollow" target="_blank"> IB-insync </a>再次帮了大忙:通过它的<a class="ae ko" href="https://ib-insync.readthedocs.io/api.html#ibc" rel="noopener ugc nofollow" target="_blank"> IBC类</a>，命令IBC启动和终止网关只需要一个函数调用。</p><p id="3f57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了进一步简化，我编写了一个继承自IB-insync的IB类的类，并添加了必要的IBC类功能。特别是，我将启动网关和连接到网关打包到一个方法中。它每秒尝试连接网关一次，直到连接成功或超时。启动网关通常需要大约20到25秒。</p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="68bc" class="kp kq it me b gy mi mj l mk ml"># <a class="ae ko" href="https://github.com/jsarbach/ib-trading/blob/master/cloud-run/application/py/lib/ibgw.py" rel="noopener ugc nofollow" target="_blank">ibgw.py</a></span><span id="cbbf" class="kp kq it me b gy mm mj l mk ml">from ib_insync import IB, IBC<br/>import logging</span><span id="ff21" class="kp kq it me b gy mm mj l mk ml"><br/>class IBGW(IB):</span><span id="7a32" class="kp kq it me b gy mm mj l mk ml">    def __init__(self,<br/>                 ibc_config,<br/>                 ib_config={},<br/>                 connection_timeout=60):<br/>        self.ibc_config = ibc_config<br/>        self.ib_config = {<br/>            'host': '127.0.0.1',<br/>            'port': 4001,<br/>            'clientId': 1,<br/>            **ib_config<br/>        }<br/>        self.connection_timeout = connection_timeout</span><span id="258b" class="kp kq it me b gy mm mj l mk ml"><strong class="me iu">        self.ibc = IBC(**self.ibc_config)<br/>        </strong>super().__init__()</span><span id="4087" class="kp kq it me b gy mm mj l mk ml">    def start_and_connect(self):<br/>        logging.info('Starting IBC...')<br/>        <strong class="me iu">self.ibc.start()<br/>        </strong>wait = self.connection_timeout</span><span id="ba52" class="kp kq it me b gy mm mj l mk ml">        try:<br/>            while not self.isConnected():  <br/>                # retry until connection is established or timeout<br/>                # is reached<br/>                IB.sleep(1)<br/>                wait -= 1<br/>                logging.info('Connecting to IB gateway...')<br/>                try:<br/>                    <strong class="me iu">self.connect(**self.ib_config)<br/>                </strong>except ConnectionRefusedError:<br/>                    if not wait:<br/>                        logging.warning('Timeout reached')<br/>                        raise TimeoutError(<br/>                            'Could not connect to IB gateway')<br/>        except Exception as e:<br/>            logging.error(e)<br/>            raise e</span><span id="7ec3" class="kp kq it me b gy mm mj l mk ml">    def stop_and_terminate(self, wait=0):<br/>        [...]</span></pre><p id="da51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">准备好web服务器和网关后，我们就可以转向应用程序本身了。</p><h2 id="9e7f" class="kp kq it bd kr ks kt dn ku kv kw dp kx kb ky kz la kf lb lc ld kj le lf lg lh bi translated">一个图像来统治他们</h2><p id="55a1" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">交易应用程序有几个组件，运行投资策略是最明显的一个。但我也有一些辅助服务，比如显示未平仓头寸和账户摘要的<em class="mn">汇总</em>服务，或者是关闭所有未平仓头寸的<em class="mn">汇总</em>服务。这两者都是从我的部署在App Engine上的仪表板上临时触发的，App Engine已经是Kubernetes解决方案的一部分。</p><p id="bc80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然这些组件都有自己的云运行服务，可以单独触发，但应用程序Docker映像本身对于所有服务都是相同的。无论我是调用摘要服务还是某个策略服务，始终是由云运行启动的那一个应用映像。运行时实际执行的内容由环境变量控制，尤其是由意图变量控制。意图是定义请求将在容器内采用什么路由的开关。环境变量将由云运行服务注入，因此我们确实只需要一个<a class="ae ko" href="https://github.com/jsarbach/ib-trading/blob/master/cloud-run/application/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>和一个Docker image用于所有服务。</p><p id="f4ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">多亏了Python的<code class="fe mo mp mq me b">import_module()</code>功能，我们可以根据自己的意图动态导入自己需要的东西。例如，如果INTENT设置为“summary ”,则首先导入模块<code class="fe mo mp mq me b">intents.summary</code>,然后调用<code class="fe mo mp mq me b">summary.main()</code>。</p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="e2cd" class="kp kq it me b gy mi mj l mk ml"># <a class="ae ko" href="https://github.com/jsarbach/ib-trading/blob/master/cloud-run/application/py/main.py" rel="noopener ugc nofollow" target="_blank">main.py</a></span><span id="eeaa" class="kp kq it me b gy mm mj l mk ml">import falcon<br/>from importlib import import_module<br/>import json<br/>from os import environ</span><span id="cbaa" class="kp kq it me b gy mm mj l mk ml"><strong class="me iu"><br/>INTENT = environ.get('INTENT')</strong></span><span id="247d" class="kp kq it me b gy mm mj l mk ml">[...]</span><span id="cc8c" class="kp kq it me b gy mm mj l mk ml"><strong class="me iu">intent = import_module('intents.' + INTENT)</strong></span><span id="9a2b" class="kp kq it me b gy mm mj l mk ml">[...]<br/></span><span id="28b3" class="kp kq it me b gy mm mj l mk ml">class Main:</span><span id="1a61" class="kp kq it me b gy mm mj l mk ml">    [...]</span><span id="ffd7" class="kp kq it me b gy mm mj l mk ml">    @staticmethod<br/>    def _on_request(_, response, trading_mode, **body):<br/>        [...]</span><span id="996a" class="kp kq it me b gy mm mj l mk ml">        ib_gw.start_and_connect()<br/>        retval = <strong class="me iu">intent.main</strong>(ib_gw, trading_mode, **body)<strong class="me iu"><br/>        </strong>response.status = falcon.HTTP_200</span><span id="8e42" class="kp kq it me b gy mm mj l mk ml">        [...]</span><span id="ba5c" class="kp kq it me b gy mm mj l mk ml">        response.content_type = falcon.MEDIA_JSON<br/>        response.body = json.dumps(retval)</span></pre><p id="becc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">summary.py中的<code class="fe mo mp mq me b">main()</code>函数现在执行实际工作并产生响应。</p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="7dd6" class="kp kq it me b gy mi mj l mk ml"># <a class="ae ko" href="https://github.com/jsarbach/ib-trading/blob/master/cloud-run/application/py/intents/summary.py" rel="noopener ugc nofollow" target="_blank">summary.py</a></span><span id="1510" class="kp kq it me b gy mm mj l mk ml">def main(ib_gw, trading_mode):<br/>    [get account summary information…]</span><span id="eee6" class="kp kq it me b gy mm mj l mk ml">    response = {…}</span><span id="d01d" class="kp kq it me b gy mm mj l mk ml">    return response</span></pre><p id="2cc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将整个交易应用程序和网关打包到一个图像中，比为每个目的创建图像更容易维护。</p><h2 id="be24" class="kp kq it bd kr ks kt dn ku kv kw dp kx kb ky kz la kf lb lc ld kj le lf lg lh bi translated">准备运行</h2><p id="963c" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">既然已经准备好部署映像，让我们创建云运行服务。首先，选择应用图像和<a class="ae ko" href="https://cloud.google.com/run/docs/locations" rel="noopener ugc nofollow" target="_blank"> GCP地区</a>。接下来，激活认证，因为你可能不希望全世界都访问你的服务。请记住，托管平台上的云运行服务会获得一个可公开访问的URL。如果需要身份验证，则只接受授权头中包含有效令牌的请求。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/e99856af07994a1537d800c17a13303d.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*c9iNzX16JubiaS8-KuYQXg.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">你不得通过(除非得到授权)</figcaption></figure><p id="fa3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我选择以下非默认<em class="mn">修订</em>设置:</p><ul class=""><li id="93b6" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated">内存分配:在内存使用方面，IB网关可能有点贪婪，所以为了安全起见，我很大方地给了它2 GB的内存。</li><li id="947e" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">每个容器的最大请求数:由于网关不允许同一个用户ID有多个并发会话，我通过将这个值改为1来防止并发。</li><li id="d051" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">服务帐户:预设是计算引擎的默认服务帐户，具有项目编辑器的角色。这是相当广泛的。因此，我为我的云运行服务创建了一个指定的服务帐户，并只赋予它真正需要的角色。这是一种很好的做法，并且遵循最小特权原则。</li><li id="4fe6" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">最大实例数:出于与上面相同的原因(不允许并发)，我不想要多个实例，因此，我再次将其设置为1。</li><li id="199f" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated">环境变量:设置意图和应用程序需要的任何其他变量。</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ng"><img src="../Images/ee6fc7394a8de73a1ba5d06bc49203e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hP3WL3tyJIm21NQahBUHpg.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">没有意图就没有服务</figcaption></figure><p id="0bac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是一些云运行服务的示例:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nh"><img src="../Images/0fbdecbca7e4c880060f27601e8b92aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwORwajs5NCVYec-8r73NA.png"/></div></div></figure><h2 id="24f0" class="kp kq it bd kr ks kt dn ku kv kw dp kx kb ky kz la kf lb lc ld kj le lf lg lh bi translated">设置时钟</h2><p id="5c87" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">如果说Cloud Run是交易应用的心脏，那么Cloud Scheduler就是心脏起搏器。它触发云运行服务，根据预定义的时间表执行自动化投资，在我的例子中是每天一次。配置非常简单:用cron job notation定义频率，选择HTTP作为目标，并指定请求(云运行服务URL、GET/POST方法、请求体)。</p><p id="2342" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">唯一稍微高级的部分是认证。因为我们只允许对我们的云运行服务的认证请求，所以我们必须确保云调度器在触发服务时在授权头中添加一个可接受的ID令牌。我创建了一个新的服务帐户，并为其分配了<em class="mn">云运行调用者</em>角色。现在可以用它来认证所有调用我的云运行服务的东西，比如云调度器或应用引擎。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ni"><img src="../Images/b10562412158965f431c32945c3437d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbkOvwwdz-xrB5s-2UEq8Q.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">在IAM中创建服务帐户</figcaption></figure><p id="bef3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建调度程序作业时，选择<em class="mn">添加OIDC令牌</em>作为授权头，然后输入您刚刚创建的服务帐户以及受众(云运行服务URL)。完成了。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nj"><img src="../Images/286632797a52d46fd77136d3cdafdfbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZWELG3LknRzTzc2tw0UmA.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">带身份验证的云调度程序配置</figcaption></figure><h2 id="a99c" class="kp kq it bd kr ks kt dn ku kv kw dp kx kb ky kz la kf lb lc ld kj le lf lg lh bi translated">我的特勤局</h2><p id="1a37" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">我特别喜欢Kubernetes的一点是你可以<a class="ae ko" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank">管理秘密的方式</a>。幸运的是，这在谷歌云平台上有一个等价的服务:<a class="ae ko" href="https://cloud.google.com/secret-manager" rel="noopener ugc nofollow" target="_blank"> Secret Manager </a>(目前处于测试阶段)。这是一个存储敏感数据的地方，比如我的IB证书。我将用户ID和密码都存储在Secret Manager中，并在运行时启动IB网关之前检索它们的最新版本:</p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="655b" class="kp kq it me b gy mi mj l mk ml"># <a class="ae ko" href="https://github.com/jsarbach/ib-trading/blob/master/cloud-run/application/py/main.py" rel="noopener ugc nofollow" target="_blank">main.py</a></span><span id="c1a9" class="kp kq it me b gy mm mj l mk ml">from base64 import b64decode<br/>from googleapiclient.discovery import build<br/></span><span id="2e3c" class="kp kq it me b gy mm mj l mk ml">SECRET_RESOURCE = 'projects/[PROJECT_ID]/secrets/ib-credentials_{}_{}/versions/latest'<br/></span><span id="183d" class="kp kq it me b gy mm mj l mk ml"><strong class="me iu">def get_secret</strong>(trading_mode, name):<br/>    [...]</span><span id="0148" class="kp kq it me b gy mm mj l mk ml"><strong class="me iu">    response = secret_service.projects().secrets().versions()\<br/>        .access(name=SECRET_RESOURCE.format(<br/>            trading_mode, name)).execute()</strong></span><span id="bb5f" class="kp kq it me b gy mm mj l mk ml">    [...]</span><span id="f834" class="kp kq it me b gy mm mj l mk ml"><strong class="me iu">    return b64decode(response['payload']['data']).decode()</strong></span><span id="d3bc" class="kp kq it me b gy mm mj l mk ml"><br/># build Secret Manager service<br/><strong class="me iu">secret_service = build('secretmanager',<br/>                       'v1beta1',<br/>                        cache_discovery=False)</strong></span><span id="9d4b" class="kp kq it me b gy mm mj l mk ml">[...]</span><span id="d47c" class="kp kq it me b gy mm mj l mk ml">ib_credentials = {<br/>    secret: <strong class="me iu">get_secret(trading_mode, secret)</strong><br/>    for secret in ['userid', 'password']<br/>}<br/>config = {<br/>    **ibc_config,<br/>    'tradingMode': trading_mode,<br/>    **ib_credentials<br/>}<br/>logging.info({**config, 'password': 'xxx'})</span><span id="3d0c" class="kp kq it me b gy mm mj l mk ml">ib_gw = IBGW(config)</span></pre><p id="6c82" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，您的云运行服务帐户需要<em class="mn">Secret Manager Secret Accessor</em>角色才能检索凭证。</p><p id="3610" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Secret Manager的优点是凭证的存储和管理与应用程序本身是分离的。密码不是添加到容器映像中，而是保存在一个集中的保险库中。这不仅方便了密码轮换，而且还让您不必寻找如何安全地存储凭证并向容器添加凭证的巧妙方法。这在自动化部署时特别有用。</p><h2 id="031f" class="kp kq it bd kr ks kt dn ku kv kw dp kx kb ky kz la kf lb lc ld kj le lf lg lh bi translated">构建、部署、重复</h2><p id="1f02" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">部署应用程序的更新需要构建新的应用程序映像，将其推送到容器存储库，并更新所有云运行服务以使用新映像。幸运的是，这可以通过<a class="ae ko" href="https://cloud.google.com/cloud-build" rel="noopener ugc nofollow" target="_blank">云构建</a>实现自动化，这使得整个部署过程更加方便，同时也不容易出错。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nk"><img src="../Images/77544ea806436cc46f3fba8df00b9118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vUA4FVRtMv5QpqPgnPGE5A.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">云构建的自动化部署渠道</figcaption></figure><p id="9b1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，将一个包含三个构建步骤的<a class="ae ko" href="https://github.com/jsarbach/ib-trading/blob/master/cloud-run/application/cloudbuild.yaml" rel="noopener ugc nofollow" target="_blank"> cloudbuild.yaml </a>文件添加到您的代码库中:构建映像，将映像推送到容器注册表，并使用新映像更新云运行服务:</p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="9c6c" class="kp kq it me b gy mi mj l mk ml">images:<br/>- "eu.gcr.io/${PROJECT_ID}/cloud-run/application"<br/>steps:<br/>- name: "gcr.io/cloud-builders/docker"<br/>  args: ["build", "-t", "eu.gcr.io/${PROJECT_ID}/cloud-run/application:${SHORT_SHA}", "cloud-run/application/"]<br/>- name: "gcr.io/cloud-builders/docker"<br/>  args: ["push", "eu.gcr.io/${PROJECT_ID}/cloud-run/application:${SHORT_SHA}"]<br/>- name: "gcr.io/cloud-builders/gcloud-slim"<br/>  entrypoint: "bash"<br/>  args:<br/>  - "-c"<br/>  - |<br/>    services=(${_SERVICES})<br/>    for service in "${services[@]}"<br/>    do<br/>      gcloud run deploy ${service}-dev --image eu.gcr.io/${PROJECT_ID}/cloud-run/application:${SHORT_SHA} --region ${_GCP_REGION} --platform managed<br/>    done</span></pre><p id="dfc8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用git commit hash ( <code class="fe mo mp mq me b">${SHORT_SHA}</code>)标记图像的好处是，您总是可以很容易地追溯其中的内容。</p><p id="c8a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，创建一个构建触发器，它将执行yaml文件中定义的构建步骤:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/8414141df1f935aa7bc4de802d4496ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*bYcFxKZw937KvZ0YnH50kA.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">云构建触发器配置</figcaption></figure><p id="ed5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我添加了两个替代变量，GCP地区和服务。当执行构建时，它们将在cloudbuild.yaml中被替换为它们的值。像这样，我们不必硬编码GCP地区或云运行服务的名称。</p><p id="4cb8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参见<a class="ae ko" href="https://cloud.google.com/run/docs/continuous-deployment-with-cloud-build" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多关于如何配置持续部署管道的细节，尤其是对于IAM设置。特别是，记住授予您的云构建服务帐户<em class="mn">云运行管理</em>角色，并将其作为具有<em class="mn">服务帐户用户</em>角色的成员添加到运行时服务帐户。</p><p id="e47f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，您可以创建多个构建触发器来支持不同的发布阶段。例如，您可以创建一个与部署测试版本的开发分支相关联的，另一个与部署到生产的主分支相关联的。</p><p id="6846" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我上面的管道部署到测试阶段，因此在服务名后面加上了<code class="fe mo mp mq me b">-dev</code>后缀。每当我认为一个映像足够稳定，可以在生产中使用时，我会手动将其标记为“稳定”,并运行一个<a class="ae ko" href="https://github.com/jsarbach/ib-trading/blob/master/cloud-run/application/deploy-to-production.sh" rel="noopener ugc nofollow" target="_blank"> bash脚本</a>,该脚本基本上执行最后一个构建步骤，即在所有服务上循环，以使用<code class="fe mo mp mq me b">application:stable</code>映像部署生产服务的新版本。</p><h2 id="007f" class="kp kq it bd kr ks kt dn ku kv kw dp kx kb ky kz la kf lb lc ld kj le lf lg lh bi translated">被宠坏的选择</h2><p id="9d76" class="pw-post-body-paragraph jq jr it js b jt li jv jw jx lj jz ka kb lk kd ke kf ll kh ki kj lm kl km kn im bi translated">就是这样！下面是完整的架构总结:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nm"><img src="../Images/df4a52f07f94921daf4af1180af2effc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RH7IzgxPxB5qG5kMwpIyoQ.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">这就是我喜欢的方式:完全无服务器</figcaption></figure><p id="5966" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与<a class="ae ko" href="https://medium.com/@juri.sarbach/building-my-own-cloud-based-robo-advisor-5588ec1b74d3" rel="noopener">的Kubernetes </a>建筑相比，它看起来有些相同但又不同。当然，关键的区别是应用程序核心的无服务器性。然而，大部分环境保持不变。特别是，我使用相同的Firestore数据库来存储设置和记录应用程序活动，它是在App Engine上运行的相同的仪表板应用程序，现在直接向云运行发出经过身份验证的请求，而不是使用无服务器VPC访问来连接到Kubernetes集群。</p><p id="2f5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么，您应该选择Kubernetes还是Cloud Run实现呢？看你的要求了，真的。需要考虑的事项:</p><ul class=""><li id="8c52" class="ms mt it js b jt ju jx jy kb mu kf mv kj mw kn mx my mz na bi translated">交易频率:你的交易频率越高，IB网关持续运行就越有价值。然而，如果你的策略一天只交易一两次，甚至更少，云运行方式可能就足够了。</li><li id="384d" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">并发性:</strong>您是否运行需要同时访问网关的多个策略和分配器？那么您必须选择Kubernetes实现。由于每个IB帐户只能有一个打开的会话，因此在Cloud Run中同时运行多个网关实例是不可能的。</li><li id="716e" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">延迟:</strong>如前所述，启动网关需要20到25秒。如果你的交易策略需要对市场的实时观察，这当然是不能接受的。在这种情况下，您应该选择基于Kubernetes的解决方案。</li><li id="14d3" class="ms mt it js b jt nb jx nc kb nd kf ne kj nf kn mx my mz na bi translated"><strong class="js iu">成本:</strong>如果你对成本很敏感，那么<a class="ae ko" href="https://cloud.google.com/run/pricing#cloudrun-pricing" rel="noopener ugc nofollow" target="_blank">云运行</a>实施更有吸引力，因为基础设施在不使用时会缩减到零，不需要任何成本。</li></ul><p id="74fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的案例中，云运行实现显然是一条正确的道路。我目前运行两种每日策略，即我每周需要10次网关，每次大约一分钟。因此，让群集全天候运行毫无意义。延迟不是问题，因为我依赖收盘价。此外，我的GCP账单内爆了大约三个数量级，从每月70美元到几乎为零。抱歉谷歌。；-)</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/35dba96dabb8ff9b8b5fcfcaa5ba9dc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*rUKBRvkeb2mgABnyoxPKgg.gif"/></div></figure></div></div>    
</body>
</html>