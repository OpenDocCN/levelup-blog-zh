<html>
<head>
<title>How to execute shell commands properly in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中正确执行shell命令</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-execute-shell-commands-properly-in-python-5b90c1a9213f?source=collection_archive---------0-----------------------#2022-02-14">https://levelup.gitconnected.com/how-to-execute-shell-commands-properly-in-python-5b90c1a9213f?source=collection_archive---------0-----------------------#2022-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a418" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解在Python中运行shell命令的不同方式</h2></div><p id="1186" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一种脚本语言，Python是自动化的一个很好的选择。您可以编写简单的Python代码来链接和自动化不同程序的执行。当作业完成时，您可以编写一些Python脚本来提取和分析结果。有些程序，比如<a class="ae le" href="https://lynn-kwong.medium.com/how-to-run-scrapy-spiders-in-your-program-7db56792c1f7" rel="noopener"> Scrapy </a>，现在已经有了Python可以直接调用的API，也就是说你可以直接用原生Python代码运行这些程序。然而，许多人仍然没有合适的Python and，您仍然需要直接运行shell命令。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/7c5d7f13fc18ce685efa7335d986cd7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WHCqRhEtpUE6dW19.jpg"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk translated">图片来自<a class="ae le" href="https://pixabay.com/photos/operating-system-command-shell-os-246242/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>。</figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="7a0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想大部分Python开发者之前已经使用过<code class="fe mc md me mf b">os.system()</code>来执行shell命令了。是的，<code class="fe mc md me mf b">os</code>模块的<code class="fe mc md me mf b">system()</code>函数是Python中执行shell命令的最简单方式。然而，它有两个主要缺点。</p><p id="0968" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，您只能获得shell命令的退出代码，而不能从<code class="fe mc md me mf b">os.system()</code>获得标准输出或错误。如果您不关心shell命令的输出或错误消息，而只想运行它，这可能不是问题。在这种情况下，多注意一点第二个缺点，这个缺点更重要。</p><p id="1c1c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其次，<code class="fe mc md me mf b">os.system()</code>容易受到shell注入的影响，也称为OS命令注入。如果您的程序接受将在<code class="fe mc md me mf b">os.system()</code>函数中使用的用户输入，这将是一个严重的安全问题。我们现在用一个简单的例子来说明这个问题。假设我们有一些脚本接受用户输入的主机名或IP地址，它们将被用作<code class="fe mc md me mf b">ping</code>命令的输入来测试网络连接。用户输入可以来自前端或简单地使用<code class="fe mc md me mf b">input</code>功能:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="1306" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以看到<code class="fe mc md me mf b">ping</code>命令的结果:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="d1c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设一个邪恶的用户输入如下命令:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="79b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你会看到一些有趣但也相当危险的东西:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="88e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mc md me mf b">os.system()</code>函数，传入的字符串被解析为Linux shell命令。特别是分号<code class="fe mc md me mf b">;</code>用于分隔命令。因此，在上面的例子中，如果用户输入<code class="fe mc md me mf b">google.com; cat /etc/passwd</code>，将会执行两个命令。第一个是<code class="fe mc md me mf b">ping -c 3 google.com</code>，第二个是<code class="fe mc md me mf b">cat /etc/passwd</code>。</p><p id="1982" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe mc md me mf b">/etc/passwd</code>的内容暴露给外部用户，这将是一个严重的安全问题。此外，用户可以在分号后输入任何Linux shell命令。假设用户输入一个破坏性的命令，比如<code class="fe mc md me mf b">rm -rf /</code>，这个命令会对你的系统造成严重的损害。</p><p id="05a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，最佳实践是避免使用<code class="fe mc md me mf b">os.system()</code>，而是使用<em class="mi">子流程</em>模块，这将很快介绍。如果不可避免，不要接受用户输入或在用户输入传递到<code class="fe mc md me mf b">os.system()</code>之前清除用户输入，这样就不会执行危险的命令<code class="fe mc md me mf b">.</code></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="2407" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">用</strong> <code class="fe mc md me mf b"><a class="ae le" href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">subprocess.run()</strong></a></code> <strong class="kk iu">。</strong></p><p id="13e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我想你已经意识到了<code class="fe mc md me mf b">os.system()</code>功能的危险。或者，建议尽可能使用<em class="mi">子进程</em>模块来执行shell命令。它可以做与<code class="fe mc md me mf b">os.system()</code>相同的工作，甚至更多。更重要的是，我们可以避免外壳注入，这样使用起来更安全。</p><p id="c55e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你阅读一些旧的教程或帖子时，你会看到很多来自<em class="mi">子流程</em>模块的函数被使用，包括<code class="fe mc md me mf b">call()</code>、<code class="fe mc md me mf b">run()</code>、<code class="fe mc md me mf b">check_output</code>等。然而，对于现代Python版本(&gt; 3.5)，建议对所有用例使用<code class="fe mc md me mf b">run()</code>函数。</p><blockquote class="mj mk ml"><p id="86ff" class="ki kj mi kk b kl km ju kn ko kp jx kq mm ks kt ku mn kw kx ky mo la lb lc ld im bi translated">调用子流程的推荐方法是对它可以处理的所有用例使用<code class="fe mc md me mf b">run()</code>函数。对于更高级的用例，可以直接使用底层的<code class="fe mc md me mf b">Popen</code>接口。</p></blockquote><p id="7086" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很多时候我们只需要使用<code class="fe mc md me mf b">run()</code>函数，这个函数使用了引擎盖下的<code class="fe mc md me mf b">Popen</code>类。对于想要异步运行shell命令的特殊情况，您可以直接使用<code class="fe mc md me mf b">Popen</code>类，它不像<code class="fe mc md me mf b">run()</code>，不会等待shell命令完成。</p><p id="38d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">稍后我们将介绍<code class="fe mc md me mf b">Popen()</code>类。现在，让我们看看如何使用<code class="fe mc md me mf b">run()</code>函数来避免shell注入。</p><p id="28b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">r<a class="ae le" href="https://docs.python.org/3/library/subprocess.html#subprocess.run" rel="noopener ugc nofollow" target="_blank">un()</a></code>功能有一个<code class="fe mc md me mf b">shell</code>标志。如果这个标志是<code class="fe mc md me mf b">True</code>，那么它的工作方式类似于<code class="fe mc md me mf b">os.system()</code>函数，并接受一个字符串作为输入。因此，它具有与<code class="fe mc md me mf b">os.sytem()</code>相同的安全问题:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="0fda" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到它具有与上面所示的<code class="fe mc md me mf b">os.system()</code>相同的结果和问题。</p><p id="8777" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果<code class="fe mc md me mf b">shell</code>标志是<code class="fe mc md me mf b">False</code>，这意味着shell命令将以列表而不是字符串的形式传入。让我们看看在这种情况下是否还会发生shell注入:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="0ff2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，数字3也应该作为字符串传入，否则将引发异常。错误信息将是:<br/> <code class="fe mc md me mf b">TypeError: expected str, bytes or os.PathLike object, not int</code>。</p><p id="5f44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有趣的是，<code class="fe mc md me mf b">subprocess.run()</code>功能这次失败了。如果仔细检查，可以看到<code class="fe mc md me mf b">google.com; cat /etc/passwd</code>是作为一个整体传递的，并没有拆分成两个shell命令。这意味着<code class="fe mc md me mf b">google.com; cat /etc/passwd</code>作为一个整体作为<code class="fe mc md me mf b">ping</code>命令的输入被传递，因为<code class="fe mc md me mf b">google.com; cat /etc/passwd </code>不是一个有效的主机名或IP地址，所以<code class="fe mc md me mf b">ping</code>命令将失败，如注释中所示。</p><p id="eb2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，通过将<code class="fe mc md me mf b">shell</code>标志设置为<code class="fe mc md me mf b">False</code>，我们可以安全地接受用户输入，并避免为<code class="fe mc md me mf b">subprocess.run()</code>函数注入shell。由于<code class="fe mc md me mf b">False</code>是<code class="fe mc md me mf b">shell</code>标志的默认值，我们不需要显式地将其设置为<code class="fe mc md me mf b">False</code>。然而，你应该避免将它设置为<code class="fe mc md me mf b">True</code>，除非你有非常好的理由这样做。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="418a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">得到标准输出和误差。</strong></p><p id="497a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了克服shell注入问题之外，<code class="fe mc md me mf b">subprocess.run()</code>函数还有其他有用的属性。让我们来探索一下。</p><p id="6013" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与<code class="fe mc md me mf b">os.system()</code>在屏幕上打印突出输出(STDOUT)和标准错误(STDERR)不同，<code class="fe mc md me mf b">subprocess.run()</code>可以捕获输出和错误，并在代码中提供它们:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="7226" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重要的是，使用<code class="fe mc md me mf b">stdout=subprocess.PIPE</code>和<code class="fe mc md me mf b">stderr=subprocess.PIPE</code>选项，标准输出和误差被保存到结果的<code class="fe mc md me mf b">stdout</code>和<code class="fe mc md me mf b">stderr</code>属性中，结果的类型为<code class="fe mc md me mf b"><a class="ae le" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" rel="noopener ugc nofollow" target="_blank">subprocess.CompletedProcess</a></code>。此外，<code class="fe mc md me mf b">text=True</code>指定stdout和stderr应该有原始的字符串数据，而不是字节。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="3646" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">用</strong> <code class="fe mc md me mf b"><a class="ae le" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">subprocess.Popen()</strong></a></code> <strong class="kk iu">。</strong></p><p id="528f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们已经注意到的，<code class="fe mc md me mf b">subprocess.run()</code>功能会一直阻塞，直到shell命令完成。如果shell命令需要很长时间才能完成，这可能并不可取。您可能希望在后台运行shell命令，同时做一些其他事情。为此，您可以直接使用<code class="fe mc md me mf b"><a class="ae le" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" rel="noopener ugc nofollow" target="_blank">subprocess.Popen()</a></code>类，该类由底层的<code class="fe mc md me mf b">subprocess.run()</code>函数使用。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="4b17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述代码的要点:</p><ul class=""><li id="d165" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld mu mv mw mx bi translated"><code class="fe mc md me mf b">subprocess.Popen()</code>具有与<code class="fe mc md me mf b">subprocess.run()</code>相同的选项。</li><li id="2e61" class="mp mq it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated"><code class="fe mc md me mf b">subprocess.Popen()</code>无阻塞，立即返回。shell命令在后台运行。</li><li id="fc94" class="mp mq it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">由<code class="fe mc md me mf b">subprocess.Popen()</code>返回的结果属于<code class="fe mc md me mf b">subprocess.Popen</code>类型。我们可以使用<code class="fe mc md me mf b">poll()</code>方法来检查shell命令是否已经完成。如果shell命令没有完成，那么返回<code class="fe mc md me mf b">None</code>。否则，将返回shell命令的退出代码。特别是退出代码<strong class="kk iu"> 0 </strong>表示shell命令成功完成。</li><li id="c219" class="mp mq it kk b kl my ko mz kr na kv nb kz nc ld mu mv mw mx bi translated">shell命令的标准输出和错误由<code class="fe mc md me mf b">communicate()</code>方法返回，而不是像<code class="fe mc md me mf b">subprocess.run()</code>一样由<code class="fe mc md me mf b">stdout</code>和<code class="fe mc md me mf b">stderr</code>属性返回。</li></ul><p id="4dd5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">subprocess.Popen()</code>的设定更多。例如，您可以等待运行shell命令的子进程使用<code class="fe mc md me mf b"><a class="ae le" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.wait" rel="noopener ugc nofollow" target="_blank">wait()</a></code>方法完成，或者您可以将超时传递给<code class="fe mc md me mf b"><a class="ae le" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" rel="noopener ugc nofollow" target="_blank">communicate()</a></code>方法。一旦你掌握了<code class="fe mc md me mf b">subprocess.Popen()</code>的基础知识，处理这些情况应该是相当简单的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="110d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们介绍了在Python中执行shell命令的不同方法。一般来说，我们应该避免使用<code class="fe mc md me mf b">os.system()</code>，而是使用<code class="fe mc md me mf b">subprocess.run()</code>(默认情况下，将<code class="fe mc md me mf b">shell</code>设置为<code class="fe mc md me mf b">False</code>)。如果你需要在后台异步运行shell命令，你可以使用<code class="fe mc md me mf b">subprocess.Popen()</code>来代替。使用<code class="fe mc md me mf b">subprocess.run()</code>和<code class="fe mc md me mf b">subprocess.Popen()</code>，可以获得标准输出和错误，并直接在Python代码中使用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d208" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相关文章:</p><ul class=""><li id="0569" class="mp mq it kk b kl km ko kp kr mr kv ms kz mt ld mu mv mw mx bi translated"><a class="ae le" href="https://lynn-kwong.medium.com/how-to-run-scrapy-spiders-in-your-program-7db56792c1f7?source=your_stories_page----------------------------------------" rel="noopener">如何在你的Python程序中运行Scrapy spider</a></li></ul></div></div>    
</body>
</html>