<html>
<head>
<title>Let’s Learn Java Threads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们学习Java线程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lets-learn-java-threads-e156481883cb?source=collection_archive---------7-----------------------#2021-03-07">https://levelup.gitconnected.com/lets-learn-java-threads-e156481883cb?source=collection_archive---------7-----------------------#2021-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq jr js"><p id="e468" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">在Java中使用线程的一个主要原因是让一个任务与另一个任务并行运行。</p></blockquote><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/a339201d4213ac28afc106c53c861395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jiFGxomcgbN-WQBB"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated"><a class="ae li" href="https://unsplash.com/@thatalexpalmer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿历克斯·帕莫尔</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="4728" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">为什么我们在Java中使用线程？</h1><p id="300b" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">我们使用线程通过同时做多件事来提高Java应用程序的速度。用技术术语来说，线程帮助我们在Java程序中实现并行。由于CPU是高速的，并且它甚至包含多个内核，所以仅仅一个线程不能利用所有的内核。这意味着我们昂贵的硬件将在大部分时间处于闲置状态。</p><p id="fd17" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mj kg kh ki ml kk kl km mn ko kp kq kr im bi translated">使用多线程，我们可以通过服务更多客户端和更快地服务它们来充分利用多核。因为在当今快节奏的世界中，响应时间非常重要。这就是我们拥有多核CPU的原因。多线程。多线程是在Java应用程序中利用CPU巨大计算能力的一种方式。</p><h1 id="6e79" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">在Java中使用多线程的原因</h1><p id="7eac" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">即使是Java应用程序也至少包含一个叫做主线程的线程，它执行你的main方法。JVM使用了更多的线程，例如<strong class="jw iu">守护线程</strong>，它们负责垃圾收集和其他一些日常工作。作为应用程序开发人员，我们还可以添加新的用户线程，使我们的应用程序更快、更高效。这里有一些在Java中使用多线程的常见原因和场景。</p><h1 id="cc87" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">1)并行编程</h1><p id="c2fe" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">在Java中使用线程的主要原因之一是<strong class="jw iu">让一个任务与另一个任务</strong>并行运行，例如绘图和事件处理。GUI应用程序(如Swing和Java FX GUIs)是Java多线程的最佳范例。在典型的GUI应用中，用户发起一个动作，例如从网络下载文件或者从硬盘加载游戏模块。</p><p id="c081" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mj kg kh ki ml kk kl km mn ko kp kq kr im bi translated">这些操作需要一些时间来完成，但是我们不能冻结GUI，因为那样用户会认为我们的应用程序被挂起了。相反，我们需要一个单独的线程来执行耗时的任务，并不断向用户显示相关的消息，或者允许他同时执行其他任务，以保持GUI的活力。这是通过在Java中使用多线程来实现的。</p><h1 id="b8f1" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">2)充分利用CPU的能力。</h1><p id="690d" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">在Java中使用多线程的另一个常见原因是<strong class="jw iu">通过充分利用CPU能力来提高应用程序的吞吐量</strong>。例如，如果我们有32个核心CPU，并且我们只使用其中的一个来服务1000个客户端，并且假设我们的应用程序受到CPU的限制，我们可以通过使用32个线程将吞吐量提高到32倍，这将利用您CPU的所有32个核心。</p><h1 id="bd55" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">3)减少响应时间</h1><p id="c685" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">我们还可以使用多线程来减少响应时间，通过<strong class="jw iu">将一个大问题分成更小的块，并使用多线程</strong>来处理它们，从而进行快速计算。例如，map-reduce模式是基于将一个大问题分成几个小问题并处理它们。</p><h1 id="61ee" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">4)同时服务多个客户端。</h1><p id="52c5" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">使用多线程显著提高应用程序性能的最常见场景之一是客户端-服务器应用程序。单线程应用程序意味着一次只有一个客户端可以连接到服务器，但多线程服务器意味着<strong class="jw iu">多个客户端可以同时连接到服务器</strong>。这意味着下一个客户端不必等到我们的应用程序处理完前一个客户端的请求。</p><h1 id="fbf2" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">线程的生命周期</h1><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi mp"><img src="../Images/4cc147cd223fe6c378ae9ccdc2fde3ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v_QYSW7xRtmWIYjc.jpeg"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">礼遇:【https://www.tutorialspoint.com】T4</figcaption></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="b9e4" class="lj lk it bd ll lm mx lo lp lq my ls lt lu mz lw lx ly na ma mb mc nb me mf mg bi translated">如何在Java中创建线程</h1><p id="e7bf" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">创建线程有两种方法:</p><ol class=""><li id="a483" class="nc nd it jw b jx jy kb kc mj ne ml nf mn ng kr nh ni nj nk bi translated">通过扩展<strong class="jw iu">线程类。</strong></li><li id="4fb9" class="nc nd it jw b jx nl kb nm mj nn ml no mn np kr nh ni nj nk bi translated">通过实现<strong class="jw iu">可运行接口</strong>。</li></ol><h1 id="93e9" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">线程类</h1><p id="fdb1" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">Thread类提供了在线程上创建和执行操作的构造函数和方法。Thread类扩展Object类，实现Runnable接口。</p><h1 id="eef2" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">Thread类的常用构造函数</h1><ul class=""><li id="db65" class="nc nd it jw b jx mh kb mi mj nq ml nr mn ns kr nt ni nj nk bi translated">线程()</li><li id="68a8" class="nc nd it jw b jx nl kb nm mj nn ml no mn np kr nt ni nj nk bi translated">线程(字符串名称)</li><li id="fc0a" class="nc nd it jw b jx nl kb nm mj nn ml no mn np kr nt ni nj nk bi translated">线程(可运行r)</li><li id="7f9e" class="nc nd it jw b jx nl kb nm mj nn ml no mn np kr nt ni nj nk bi translated">Thread(Runnable r，字符串名称)</li></ul><h1 id="635c" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">螺纹类的常用方法</h1><pre class="kt ku kv kw gt nu nv nw nx aw ny bi"><span id="9f14" class="nz lk it nv b gy oa ob l oc od"><strong class="nv iu">public void run(): </strong>is used to perform action for a thread.</span><span id="45ed" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public void start(): </strong>starts the execution of the thread. JVM calls the run() method on the thread.</span><span id="a791" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public void sleep(long milliseconds): c</strong>auses the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds.</span><span id="e9f1" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public void join(): </strong>waits for a thread to die.</span><span id="0f5b" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public void join(long milliseconds): </strong>waits for a thread to die for the specified milliseconds.</span><span id="015a" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public int getPriority(): </strong>returns the priority of the thread.</span><span id="553b" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public int setPriority(int priority): </strong>changes the priority of the thread.</span><span id="2102" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public String getName(): </strong>returns the name of the thread.</span><span id="7c19" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public void setName(String name): </strong>changes the name of the thread.</span><span id="b61d" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public Thread currentThread(): </strong>returns the reference of currently executing thread.</span><span id="932a" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public int getId(): </strong>returns the id of the thread.</span><span id="641f" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public Thread.State getState(): </strong>returns the state of the thread.</span><span id="0b66" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public boolean isAlive(): </strong>tests if the thread is alive.</span><span id="a5f8" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public void yield(): </strong>causes the currently executing thread object to temporarily pause and allow other threads to execute.</span><span id="d52f" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public boolean isDaemon(): </strong>tests if the thread is a daemon thread.</span><span id="3a85" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public void setDaemon(boolean b): </strong>marks the thread as daemon or user thread.</span><span id="0ec6" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public void interrupt(): </strong>interrupts the thread.</span><span id="074c" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public boolean isInterrupted(): </strong>tests if the thread has been interrupted.</span><span id="b455" class="nz lk it nv b gy oe ob l oc od"><strong class="nv iu">public static boolean interrupted(): </strong>tests if the current thread has been interrupted.</span></pre><h1 id="5934" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">可运行接口</h1><p id="2e07" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">Runnable接口应该由任何类来实现，这些类的实例应该由线程来执行。runnable接口只有一个名为run()的方法。</p><pre class="kt ku kv kw gt nu nv nw nx aw ny bi"><span id="c03c" class="nz lk it nv b gy oa ob l oc od"><strong class="nv iu">public void run(): </strong>is used to perform action for a thread.</span></pre><h1 id="e668" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">开始线程</h1><p id="52d6" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">线程类的<strong class="jw iu"> start()方法</strong>用于启动一个新创建的线程。它执行以下任务。</p><ul class=""><li id="11a1" class="nc nd it jw b jx jy kb kc mj ne ml nf mn ng kr nt ni nj nk bi translated">一个新线程启动(带有一个新的调用堆栈)。</li><li id="bc7f" class="nc nd it jw b jx nl kb nm mj nn ml no mn np kr nt ni nj nk bi translated">线程从新状态转移到可运行状态。</li><li id="e052" class="nc nd it jw b jx nl kb nm mj nn ml no mn np kr nt ni nj nk bi translated">当线程有机会执行时，它的目标run()方法将会运行。</li></ul><p id="b3c1" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mj kg kh ki ml kk kl km mn ko kp kq kr im bi translated"><em class="jv">让我们通过一个简单的例子来看看线程是如何工作的。</em></p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="532b" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">线程同步</h1><p id="c1b2" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">java中的同步是控制多个线程访问任何共享资源的能力<em class="jv">。</em></p><p id="b73a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mj kg kh ki ml kk kl km mn ko kp kq kr im bi translated">Java同步是一个更好的选择，只允许一个线程访问共享资源。</p><h2 id="b95f" class="nz lk it bd ll oh oi dn lp oj ok dp lt mj ol om lx ml on oo mb mn op oq mf or bi translated">同步主要用于</h2><blockquote class="os"><p id="f6a7" class="ot ou it bd ov ow ox oy oz pa pb kr dk translated"><em class="pc">防止螺纹干涉。</em></p><p id="054a" class="ot ou it bd ov ow ox oy oz pa pb kr dk translated"><em class="pc">防止一致性问题。</em></p></blockquote><h1 id="bffe" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu pd lw lx ly pe ma mb mc pf me mf mg bi translated">Java中的锁概念</h1><p id="c519" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">同步是围绕称为锁或监视器的内部实体建立的。每个对象都有一个与之关联的锁。按照惯例，需要一致访问对象字段的线程必须在访问它们之前获取对象的锁，然后在完成访问后释放锁。</p><p id="7474" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mj kg kh ki ml kk kl km mn ko kp kq kr im bi translated">在本例中，没有同步，因此输出不一致。让我们看看这个例子:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="1cad" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">Java同步方法</h1><p id="ad3b" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">如果我们将任何方法声明为synchronized，它就是所谓的synchronized方法。</p><p id="194f" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mj kg kh ki ml kk kl km mn ko kp kq kr im bi translated">同步方法用于锁定任何共享资源的对象。</p><p id="547a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mj kg kh ki ml kk kl km mn ko kp kq kr im bi translated">当线程调用同步方法时，它会自动获取该对象的锁，并在线程完成其任务时释放它。请参见下面的示例。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="b3e0" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="96c7" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">本文结束时，我们已经学习了Java中的线程。以及他们是如何实施的。希望这篇文章能帮助你发展关于这些概念的知识。让我们在不久的将来遇见另一篇有趣的文章。</p><p id="1f54" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mj kg kh ki ml kk kl km mn ko kp kq kr im bi translated">谢谢你看了我的文章，祝你学习愉快🙌😊</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h2 id="2f60" class="nz lk it bd ll oh oi dn lp oj ok dp lt mj ol om lx ml on oo mb mn op oq mf or bi translated">参考</h2><p id="9363" class="pw-post-body-paragraph jt ju it jw b jx mh jz ka kb mi kd ke mj mk kh ki ml mm kl km mn mo kp kq kr im bi translated">大一新生100个核心Java面试问题…<a class="ae li" href="https://techvidvan.com/tutorials/core-java-interview-questions-answers/" rel="noopener ugc nofollow" target="_blank">https://techvidvan . com/tutorials/core-Java-interview-questions-answers/</a></p><p id="b5ce" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mj kg kh ki ml kk kl km mn ko kp kq kr im bi translated">在Java中创建线程—Java point。【https://www.javatpoint.com/creating-thread T2】号</p><p id="2a6b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke mj kg kh ki ml kk kl km mn ko kp kq kr im bi translated">Java中的同步—Java point。【https://www.javatpoint.com/synchronization-in-java T4】</p></div></div>    
</body>
</html>