<html>
<head>
<title>Wait… What Happens When my React Native Application Starts? — An In-depth Look Inside React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">等等…当我的React本机应用程序启动时会发生什么？—深入了解React Native</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/wait-what-happens-when-my-react-native-application-starts-an-in-depth-look-inside-react-native-5f306ef3250f?source=collection_archive---------0-----------------------#2018-03-19">https://levelup.gitconnected.com/wait-what-happens-when-my-react-native-application-starts-an-in-depth-look-inside-react-native-5f306ef3250f?source=collection_archive---------0-----------------------#2018-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="134a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解本机函数如何在内部反应，以及它在您不知道的情况下为您做了什么。</h2></div><p id="0223" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">免责声明:本文假设对React本机和本机模块有(非常)基本的了解。如果你从未玩过它们，我建议你先看看</em> <a class="ae lc" href="https://facebook.github.io/react-native/docs/native-modules-android.html" rel="noopener ugc nofollow" target="_blank"> <em class="lb">官方文档</em> </a> <em class="lb">。</em></p><p id="3cfa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> <em class="lb">编辑:</em> </strong> <em class="lb">本文基于我在伦敦为2018年3月的</em><a class="ae lc" href="https://reactfest.uk/" rel="noopener ugc nofollow" target="_blank"><em class="lb">react fest</em></a><em class="lb">会议所做的一次演讲。你可以在这里看到我说的</em><a class="ae lc" href="https://www.youtube.com/watch?v=rReCzR6DMEM" rel="noopener ugc nofollow" target="_blank"><em class="lb"/></a><em class="lb">！</em></p><p id="6778" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我开始使用React Native时，一些事情很快困扰了我:<em class="lb">那里发生了什么？的确，从那些仅仅使用React Native来构建(伟大的)应用程序的人的角度来看，事情有时看起来很神奇。想从Javascript中获得一些可用的原生代码吗？直接用<code class="fe ld le lf lg b">@ReactMethod</code>(或者iOS上的<code class="fe ld le lf lg b">RCT_EXPORT_METHOD</code>)！想要将事件从本机发送到Javascript吗？没问题，只需获取适当的Javascript模块，并像调用任何本机方法一样调用它！更不用说，同样的Javascript代码会在iOS和Android上运行…</em></p><p id="df24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如人们可能会猜测的那样，这些事情不是微不足道的。事实上，相当复杂。<strong class="kh ir">那么是什么让React Native实现了这样的壮举呢？</strong>简单且常见的答案是:</p><blockquote class="lh li lj"><p id="85b9" class="kf kg lb kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">React原生“桥”，咄！</p></blockquote><p id="f720" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/149f62f17ed86d3aa250c7c9703f3763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p0OGaNEm_F9uWaGmN517TA.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">有些人对本土的解释做出了反应…</figcaption></figure><p id="37db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是谁想要简单的答案呢？这一次我们将详细讨论。但是要注意:事情可能会变得一团糟。</p><h1 id="c19d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">React本地基础设施</h1><p id="39aa" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">让我们开门见山:<strong class="kh ir">为了发挥作用，React Native依赖于运行时构建的完整基础设施。</strong>哒哒！</p><blockquote class="lh li lj"><p id="716b" class="kf kg lb kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">等等…你刚才不是给了我们另一个隐晦的解释吗？</p></blockquote><p id="a112" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我有吗？但是这里有两点需要注意。首先，基础设施:著名的“桥”只是其中的一部分——我敢说，还不是最不可思议的。第二，<em class="lb">运行时</em>:每次启动React原生应用程序时，在执行任何自定义代码之前，都会构建上述基础设施<em class="lb">。换句话说，<strong class="kh ir">在您的应用程序上线并可见之前，它会经历一个过渡状态，在这个状态下，React Native会忙于为您构建应用程序的基础</strong>。</em></p><p id="b9c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你说这个所谓的基础设施是什么样子的？好吧，让我们画一个地图，显示各个部分(由箭头连接，大致意思是“存储对的引用”)。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi na"><img src="../Images/8623c69b284cbee8b67ac7a0de74b44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZBOTTHTIOTZT0h62mvFxLQ.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">react Native infra structure——对于iOS，Java徽标可以替换为Objective-C徽标</figcaption></figure><p id="9ddc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喔，这有点复杂，不是吗？这是一个简化的版本…为了理解这种混乱，我们将按照它们在发布时被创建的顺序，一个接一个地描述它的各个部分。我们走吧！</p><h1 id="eb8d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">启动React本机应用程序</h1><p id="8b06" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">请记住，每当React本机应用程序启动时，整个过程都是构建的。让我们来看看几个步骤，把你在手机上按下应用程序图标的那一刻和一切都变得可见的那一刻分开。</p><p id="ef31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，您的应用程序只有两件事要处理:</p><ul class=""><li id="6ef2" class="nb nc iq kh b ki kj kl km ko nd ks ne kw nf la ng nh ni nj bi translated">应用程序的代码，</li><li id="e5dd" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated">一个独特的线程，<strong class="kh ir">主线程* </strong>，由手机操作系统自动分配给它。</li></ul><p id="cc81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简化解释，我们将在概念上把代码分成两部分:框架代码<em class="lb">—</em>—您不必每次都编写的代码——和定制代码<em class="lb"/>—它实际上描述了您的应用程序。两者都分布在Javascript和native上，这给了我们总共四部分代码<strong class="kh ir">来浏览。在主线程上，首先要处理的是框架代码的本机部分。</strong></p><p id="af73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">*也称为</em> UI线程<em class="lb">，作为——初始化之外——主要负责UI相关的工作</em></p><h1 id="4af0" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">创建本地基础</h1><p id="548a" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">需要意识到的一件重要的事情是，尽管大多数UI代码——<code class="fe ld le lf lg b">&lt;View&gt;</code>、<code class="fe ld le lf lg b">&lt;Text&gt;</code>……——是用Javascript编写的，但最终呈现的只是原生视图。就是这样。这意味着React本机框架需要:</p><ol class=""><li id="53c7" class="nb nc iq kh b ki kj kl km ko nd ks ne kw nf la np nh ni nj bi translated">创建本地视图并将它们的连接映射到Javascript组件，</li><li id="3828" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la np nh ni nj bi translated">存储这些本地视图并显示它们。</li></ol><p id="20f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然第一步将由<strong class="kh ir"> UIManagerModule </strong>处理(稍后我们将描述)，但是<strong class="kh ir"> RootView </strong>将处理第二步。<code class="fe ld le lf lg b">RootView</code>或多或少是一个容器，其中本地视图被组织在一个大树中——如果你愿意，是Javascript组件树的本地表示——手机屏幕上显示的所有内容都将存储在那里。</p><p id="0bb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到我们的初始化过程:一切都从创建上面的<code class="fe ld le lf lg b">RootView</code>——现在是一个空容器——开始，然后继续到<strong class="kh ir">桥接口</strong>。</p><blockquote class="lh li lj"><p id="e5c9" class="kf kg lb kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">桥梁不是应该在原生和Javascript之间吗？为什么你需要一个接口呢？</p></blockquote><p id="1850" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确实是！但是尽管大部分本机部分——包括<code class="fe ld le lf lg b">RootView</code>——是用特定于平台的语言(Objective-C或Java)编写的，桥完全是用C++实现的。因此，桥接口充当API，允许前者与后者进行交互。桥本身由两端组成，原生于Javascript，反之亦然。</p><p id="8baa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果没有端点来调度调用，那么这个桥就什么都不是。这些端点是<strong class="kh ir">本地模块</strong>，并且最终将成为Javascript环境中唯一可用的<em class="lb">东西。换句话说，除了本机模块之外的所有东西最终对您的Javascript应用程序都是不可见的。因此，除了您可能决定创建或不创建的<strong class="kh ir">定制模块</strong>之外，框架还包括<strong class="kh ir">核心模块</strong>。后者的一个例子是<strong class="kh ir"> UIManagerModule </strong>，它存储了所有Javascript UI组件及其相关本地视图的映射。每当Javascript UI组件被创建、更新或删除时，<code class="fe ld le lf lg b">UIManagerModule</code>将使用这个映射来相应地创建、更新或删除相应的本地视图。它还会将更改转发到存储在<code class="fe ld le lf lg b">RootView</code>中的本地视图树，以便使它们可见。</em></p><p id="0717" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从初始化的角度来看，所有本机模块都被同等对待:为每个模块创建一个实例，对该实例的引用存储在Javascript到本机桥上，以便以后可以从Javascript调用它们。此外，对桥接口的引用也被传递给每个本机模块，允许它们直接调用Javascript。最后，将创建两个额外的线程:JS线程<strong class="kh ir">和NativeModulesThread*。</strong></p><p id="aba2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">*严格来说，在React Native的iOS实现的情况下，它不是一个唯一的线程，而是一个线程池。</em></p><h1 id="e110" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">Intermezzo:设置Javascript引擎</h1><p id="b171" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">在继续之前，让我们快速总结一下到目前为止发生的事情:</p><ul class=""><li id="0dec" class="nb nc iq kh b ki kj kl km ko nd ks ne kw nf la ng nh ni nj bi translated">在主线程上创建了一堆本地内容，</li><li id="aef5" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated">我们现在有三个线程要处理，</li><li id="f8dd" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated">绝对没有Javascript被处理过。</li></ul><p id="3714" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到我们最初的地图，我们得到的是这个:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nq"><img src="../Images/4c3daafb4bd0513761eb65da664e8a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mxbWTuyH7yk786i24Ue8Wg.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">反应当地人的本性</figcaption></figure><p id="5c50" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着现在是加载Javascript包的时候了——框架和定制代码都是如此！</p><p id="7679" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一种解释型脚本语言，Javascript不能按原样运行:它需要被转换成字节码，然后被执行。这是<strong class="kh ir"> Javascript虚拟机</strong>(又名Javascript引擎)的工作。现在有很多Javascript引擎，包括Chrome的V8，Mozilla的SpiderMonkey和Safari的Javascript core……如果在调试模式下，React Native将使用<strong class="kh ir"> V8 </strong>并直接在浏览器中运行，否则，它将默认使用<strong class="kh ir"> JavaScriptCore </strong>并在设备上运行。顺便说一句，默认情况下，Android中不包含JavaScriptCore(尽管它在iOS中)，因此React Native会自动在Android应用程序中捆绑一份JavaScript core，这使得Android应用程序比iOS应用程序略重。</p><p id="8eba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论如何，在有效地启动Javascript引擎之前，React Native必须给它一个表示执行环境的上下文。这包括Javascript全局对象，意味着这个全局对象实际上是在C++桥上创建和存储的。为什么这如此重要？<strong class="kh ir">因为全局对象不仅可以从Javascript环境内部访问，还可以从外部访问</strong>。因此，它是C++(本机)和Javascript之间的主要通信方式，因为通过全局对象，一些本机函数将对Javascript可用——这些函数反过来将用于将数据从Javascript传回本机。</p><p id="7ebd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很多东西都存储在全局对象上，但是<strong class="kh ir"> ModuleConfig </strong>数组和<strong class="kh ir"> flushQueue() </strong>函数尤其重要。<code class="fe ld le lf lg b">ModuleConfig</code>数组的每个元素都描述了一个本机模块(无论是核心模块还是自定义模块)，包括它的名称、导出的常量、方法……<code class="fe ld le lf lg b">flushQueue()</code>函数在确保Javascript和本机环境之间的通信方面起着关键作用，因为它将被定期用于将调用从第一个传递回第二个。</p><p id="14c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦Javascript上下文被完全创建和填充，它就被提供给Javascript引擎，该引擎开始在 <strong class="kh ir"> JS线程</strong>上加载React原生Javascript包<strong class="kh ir">。</strong></p><h1 id="85a2" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">加载Javascript包</h1><p id="e3b0" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">随着虚拟机开始处理框架代码的Javascript部分，它将创建<strong class="kh ir"> BatchedBridge </strong>。这个名字可能听起来很耳熟，因为它有时会出现在错误消息中！尽管它的名字很奇特，但它只是一个简单的队列，存储“从Javascript到native的调用”。“调用”是包含本机模块ID、方法ID(对于指定的本机模块)以及调用本机方法所用的参数的对象。定期地(默认情况下每隔5毫秒)，<code class="fe ld le lf lg b">BatchedBridge</code>将调用<code class="fe ld le lf lg b">global.flushQueue()</code>，将它的内容——一个“调用”数组——传递给C++桥本地端的Javascript。这些小数组被称为<strong class="kh ir">批处理</strong>，它们被索引以确保一个批处理中包含的所有UI更改同时可见(这是必要的，因为整个过程是异步的)。桥的本地端的Javascript将最终在一个批处理中迭代每个调用，并使用指定的模块ID将它们分派到适当的本地模块——它能这样做是因为它有一个指向每个和任何本地模块的引用，记得吗？</p><p id="5f47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是创建<code class="fe ld le lf lg b">NativeModules</code>对象——是的，每次你想调用一个本机模块时，这个对象必须从‘react-native’导入。将使用前面提到的<code class="fe ld le lf lg b">ModuleConfig</code>数组填充<code class="fe ld le lf lg b">NativeModules</code>对象。我不会在这里详细介绍这个过程，但它大致相当于对包含在<code class="fe ld le lf lg b">ModuleConfig</code>中的每个<code class="fe ld le lf lg b">module_name</code>执行<code class="fe ld le lf lg b">NativeModules[module_name]={}</code>，然后对给定模块的每个导出的本机方法执行<code class="fe ld le lf lg b">NativeModules[module_name][method_name]=fillerMethod</code>。<code class="fe ld le lf lg b">fillerMethod</code>只是用来存储它在<code class="fe ld le lf lg b">BatchedBridge</code>上接收到的所有参数，以及方法和模块ID(类似于<code class="fe ld le lf lg b">fillerMethod = function(...args) { BatchedBridge.enqueueNativeCall(moduleID, methodID, args)}</code>)，有效地创建了一个从Javascript到native的“调用”。话虽这么说，后来写<code class="fe ld le lf lg b">MyNativeModule.myMethod(args)</code>被炒的其实是上面的<code class="fe ld le lf lg b">fillerMethod</code>！</p><p id="5e87" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们快到了。最后需要做的是创建核心JS模块，其中的<code class="fe ld le lf lg b">DeviceEventEmitter</code>——将用于将事件从本机发送到Javascript——或<code class="fe ld le lf lg b">AppRegistry</code>—存储对应用程序主要组件的引用。为了能够从本机调用，这些模块被注册在Javascript全局对象上…</p><p id="4ed1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…至此，完整的React本机基础架构已经构建完成！</p><h1 id="cde5" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">使React本机应用程序可见</h1><p id="9196" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">尽管初始化已经完成，但是我们的应用程序在这个阶段仍然是不可见的！事实上，Javascript包的加载发生在JS线程上，它独立于主线程(也称为UI线程)。因此，JS线程必须警告主线程它的任务已经完成，作为响应，主线程使用<code class="fe ld le lf lg b">AppRegistry</code> (JS模块)请求JS线程处理主定制组件——通常是<code class="fe ld le lf lg b">App.js</code>。</p><p id="a4b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从线程角度总结一下，React本机应用的启动过程如下所示:</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nr"><img src="../Images/f4133dd000101fcad2b3d733edacf91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dd1a2PfTwd1C-Etb-cWl5w.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">React Native的启动例程</figcaption></figure><p id="8647" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">包含在应用程序主组件中的Javascript组件树将被遍历，每次遇到UI组件时调用<code class="fe ld le lf lg b">UIManagerModule</code>。<code class="fe ld le lf lg b">UIManagerModule</code>(在UI线程上)将依次负责创建本地视图并将它们存储在<code class="fe ld le lf lg b">RootView</code>中:恭喜，您的应用程序现在可见了！🎉 🎉</p><h1 id="625e" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">附加外卖</h1><p id="0252" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated"><em class="lb">本文基于我2018年3月在伦敦</em><a class="ae lc" href="https://reactfest.uk/" rel="noopener ugc nofollow" target="_blank"><em class="lb">react fest</em></a><em class="lb">上的一次演讲。以下是我在会议期间被问到的一些问题的答案。</em></p><blockquote class="lh li lj"><p id="326b" class="kf kg lb kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">如果我们不使用NativeModuleThread，那么创建它有什么意义呢？</p></blockquote><p id="0207" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确实，这个线程在启动过程中没有被积极地使用。然而，这一点在后面真的很重要，因为Javascript对native的每一次调用——在被分派到适当的native模块之后——都将在这个线程上运行。实现细节:在iOS版本的React Native上，这个线程并不存在。相反，每个本机模块在实例化时被赋予一个<code class="fe ld le lf lg b">GCDQueue</code>(并且系统负责线程管理)。</p><blockquote class="lh li lj"><p id="07ea" class="kf kg lb kh b ki kj jr kk kl km ju kn lk kp kq kr ll kt ku kv lm kx ky kz la ij bi translated">哎，为什么C++里桥的两端<strong class="kh ir">都是</strong>？我们不是应该一头用Javascript，一头用native吗？</p></blockquote><p id="5ba8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这确实有点令人困惑。但是一旦我们明确了React Native需要弥补的差距，这就有意义了。这个“差距”在这里是双重的:</p><ul class=""><li id="64a3" class="nb nc iq kh b ki kj kl km ko nd ks ne kw nf la ng nh ni nj bi translated">一个<strong class="kh ir">语言缺口</strong>(原生，Javascript)，以及</li><li id="5de9" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated">一个<strong class="kh ir">螺纹间隙</strong> (JS螺纹，主螺纹，NativeModuleThread)</li></ul><p id="5fb7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，语言问题主要通过Javascript全局对象来解决，该对象可从C++和Javascript环境中访问。因此，我们在React Native中通常所说的“桥”只需要处理不同线程上的工作分派。在这方面,“原生Javascript”和“原生Javascript”这两个名称非常有意义，尽管它们都是用同一种语言实现的:第一个从本地线程(无论是主线程还是NativeModuleThread)调用<em class="lb">，并将工作<em class="lb">转发给JS线程</em>，而第二个将从JS线程</em>(使用<code class="fe ld le lf lg b">global.flushQueue()</code>函数)调用<em class="lb">，并将调用<em class="lb">分派给本地线程</em>。</em></p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="9c7f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！这是一个稍微详细一点的关于什么样的异能是天生反应的概述。我希望它触发了您的好奇心，并且——谁知道呢——让您想要为这个框架做贡献？</p></div></div>    
</body>
</html>