<html>
<head>
<title>DevOps Essentials — Continuous Integrations and Continuous Deployments with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DevOps Essentials —与Docker的持续集成和持续部署</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/devops-essentials-continuous-integration-and-deployments-of-docker-applications-with-aws-373f60daf320?source=collection_archive---------4-----------------------#2019-10-25">https://levelup.gitconnected.com/devops-essentials-continuous-integration-and-deployments-of-docker-applications-with-aws-373f60daf320?source=collection_archive---------4-----------------------#2019-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/be81ae18322148a41037ffcb144feb2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPWEdCZUnJoMV9dmHZkMHg.jpeg"/></div></div></figure><p id="29cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我之前的博客《<a class="ae kw" href="https://blog.usejournal.com/handling-authentication-with-nodejs-24fc29265e0f" rel="noopener ugc nofollow" target="_blank"> <em class="kx">用Node.js </em> </a> <em class="kx">》中，</em>我们学习了如何通过为我们的应用程序创建一个RESTful API来使用JSON Web Token (JWT)进行身份验证。</p><div class="ky kz gp gr la lb"><a href="https://blog.usejournal.com/handling-authentication-with-nodejs-24fc29265e0f" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd ir gy z fp lg fr fs lh fu fw ip bi translated">使用Nodejs处理身份验证</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">信息的机密性和完整性是相辅相成的。它需要处理进程访问管理…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">blog.usejournal.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp jw lb"/></div></div></a></div><p id="9013" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将从DevOps的角度来看如何使用Docker、Github和Travis CI处理Node.js应用程序的部署，并了解一些业界最佳实践。</p><h2 id="c67e" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated"><strong class="ak">我们将学习:</strong></h2><ol class=""><li id="8395" class="mj mk iq ka b kb ml kf mm kj mn kn mo kr mp kv mq mr ms mt bi translated">如何归档申请</li><li id="d55e" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">如何使用Travis CI和GitHub自动化部署</li><li id="1cb3" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">如何在AWS弹性豆茎上部署Dockerised应用程序</li></ol><p id="f93d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你还是docker世界的初学者，可以从这里开始<a class="ae kw" href="https://medium.com/@desaijay315/docker-the-beginners-guide-85a27e50c271" rel="noopener">:</a></p><div class="ky kz gp gr la lb"><a href="https://medium.com/@desaijay315/docker-the-beginners-guide-85a27e50c271" rel="noopener follow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd ir gy z fp lg fr fs lh fu fw ip bi translated">docker——初学者指南</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">Docker在软件开发公司和团队中非常受欢迎，它极大地提高了生产率，因为…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">medium.com</p></div></div><div class="lk l"><div class="mz l lm ln lo lk lp jw lb"/></div></div></a></div><h1 id="ef81" class="na lr iq bd ls nb nc nd lv ne nf ng ly nh ni nj mb nk nl nm me nn no np mh nq bi translated">Docker是什么？</h1><p id="e6f2" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nr kl km kn ns kp kq kr nt kt ku kv ij bi translated">Docker是一款开源工具，专为开发人员、开发人员和系统管理员设计，用于在虚拟机、笔记本电脑或云上构建、发布和运行分布式应用。</p><h2 id="5e6c" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated">基于集装箱的环境</h2><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/4317e1b1e4aff28839819cafebcb5aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/0*W5BILIvRKWqMzq-n.png"/></div></figure><blockquote class="nz oa ob"><p id="a10f" class="jy jz kx ka b kb kc kd ke kf kg kh ki oc kk kl km od ko kp kq oe ks kt ku kv ij bi translated"><em class="iq">容器是映像的一个实例，它在自己的隔离环境中运行自己的一组硬件和物理资源、内存和网络中的程序。</em></p></blockquote><p id="ae21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">容器共享单个主机操作系统，这使得快速部署和可移植性更加高效。我们只需要那些封装在应用程序容器中的组件。我们在不同的容器中运行不同的应用程序，并隔离运行时环境。容器比虚拟机消耗更少的CPU和内存，并且更具成本效益。</p><p id="86b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用Docker图像来创建Docker容器。</p><p id="148a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Dockerfile </strong></p><p id="eb7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Dockerfile文件包含一组指令和命令，用于构建唯一且独立的映像。</p><h2 id="c800" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated"><strong class="ak">克隆回购</strong></h2><div class="ky kz gp gr la lb"><a href="https://github.com/desaijay315/nodejs_auth" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd ir gy z fp lg fr fs lh fu fw ip bi translated">desaijay315/nodejs_auth</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">github.com</p></div></div><div class="lk l"><div class="of l lm ln lo lk lp jw lb"/></div></div></a></div><h2 id="4c59" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated">在根文件夹中创建一个docker文件</h2><pre class="nv nw nx ny gt og oh oi oj aw ok bi"><span id="34f1" class="lq lr iq oh b gy ol om l on oo">touch Dockerfile</span></pre><h2 id="dc7e" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated"><em class="op">在Dockerfile </em>中输入以下命令</h2><figure class="nv nw nx ny gt jr"><div class="bz fp l di"><div class="oq or l"/></div><figcaption class="os ot gj gh gi ou ov bd b be z dk translated">Dockerfile文件内容</figcaption></figure><p id="ca39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">FROM</strong></code> <strong class="ka ir"> <em class="kx"> — </em> </strong>从DockerHub中指定基础图像</p><p id="5457" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于ocker运行在Linux环境中，我们将为我们的应用程序指定存储位置。我们所有的命令(<code class="fe ow ox oy oh b"><strong class="ka ir">COPY</strong></code> <strong class="ka ir">、</strong>、<code class="fe ow ox oy oh b"><strong class="ka ir">RUN</strong></code>、<strong class="ka ir">、</strong>、<code class="fe ow ox oy oh b"><strong class="ka ir">CMD</strong></code>)都会在这个目录下运行。如果<code class="fe ow ox oy oh b"><strong class="ka ir">/usr/app</strong></code> <strong class="ka ir"> </strong>没有创建，则<code class="fe ow ox oy oh b">WORKDIR</code>命令会自动创建</p><h2 id="caba" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated">安装一些依赖项</h2><p id="1e27" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nr kl km kn ns kp kq kr nt kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">COPY</strong></code> —将文件从源文件复制到目标文件。我们正在将<code class="fe ow ox oy oh b">package.json</code>文件复制到<code class="fe ow ox oy oh b">/usr/app</code>文件夹中</p><p id="830b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">RUN</strong></code> —这将运行命令<code class="fe ow ox oy oh b">npm install</code>并安装所有依赖项</p><p id="89ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">EXPOSE</strong></code>—公开容器监听的端口，并使应用程序在外部环境中可用</p><p id="c34d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">CMD</strong></code> —这将在容器启动时运行命令</p><h2 id="b5e9" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated">Docker撰写</h2><p id="0952" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nr kl km kn ns kp kq kr nt kt ku kv ij bi translated">Docker Compose用于同时启动多个容器。它使得在docker-compose.yml文件中定义的不同服务能够在一个隔离的环境中运行</p><h2 id="2b91" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated">在根文件夹中创建docker-compose.yml</h2><pre class="nv nw nx ny gt og oh oi oj aw ok bi"><span id="7538" class="lq lr iq oh b gy ol om l on oo">touch docker-compose.yml</span></pre><h2 id="67dc" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated">输入如下说明</h2><pre class="nv nw nx ny gt og oh oi oj aw ok bi"><span id="4a4e" class="lq lr iq oh b gy ol om l on oo">version: '3'<br/>services:<br/> app:<br/>  container_name: docker_nodejsauth<br/>  restart: always<br/>  build: .<br/>  ports:<br/>   - 3000:3000<br/>  links:<br/>   - mongo</span><span id="5aa5" class="lq lr iq oh b gy oz om l on oo">mongo:<br/> container_name: mongo<br/> restart: always<br/> image: mongo<br/> ports:<br/>  - 27017:27017</span></pre><p id="0d91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">version</strong></code> —定义作曲者文件版本</p><p id="c696" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">services</strong></code> —定义服务的种类</p><p id="843c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">app</strong></code> —这是使用Dockerfile构建的Node.js应用程序，如上所示。这可以是你想要的任何名字。(例如。节点应用、网络应用、任何东西)</p><p id="6953" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">container_name</strong></code> —节点应用程序容器的名称</p><p id="077a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">restart</strong></code> —无论何时失败，重启我们的应用程序</p><p id="7f79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">build</strong></code> —从我们创建的docker文件构建docker容器。(点)指定Dockerfile的相对路径。</p><p id="2562" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">ports</strong></code> —将端口从我们的容器映射到Node.js应用程序端口</p><p id="1718" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">links</strong></code> —由于我们使用MongoDB作为现有应用程序的数据库，我们将从Docker Hub存储库中设置mongo映像/服务。</p><p id="d000" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">mongo</strong></code> —来自Docker Hub存储库的Mongo映像。为Mongo指定<code class="fe ow ox oy oh b">container_name</code>、<code class="fe ow ox oy oh b">image</code>、<code class="fe ow ox oy oh b">restart</code>和<code class="fe ow ox oy oh b">ports</code>。</p><p id="e3bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:这里，我们使用Mlab.com服务来托管我们的数据库，所以请相应地检查MongoDB连接。</p><h1 id="5b70" class="na lr iq bd ls nb nc nd lv ne nf ng ly nh ni nj mb nk nl nm me nn no np mh nq bi translated">特拉维斯·CI</h1><p id="1347" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nr kl km kn ns kp kq kr nt kt ku kv ij bi translated">Travis CI用于持续集成和部署。一旦代码库被推送到git，Travis将把repo克隆到全新的环境中。它将运行你的所有测试，并通过邮件和聊天IRC提供持续的反馈。</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pa"><img src="../Images/b7816b873f34deab52570b146674e320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOTHAwmOmLX3uyo0S6gG5g.png"/></div></div></figure><h2 id="abb1" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated">Travis入门</h2><ol class=""><li id="1a2f" class="mj mk iq ka b kb ml kf mm kj mn kn mo kr mp kv mq mr ms mt bi translated">用你的Github账户在<a class="ae kw" href="https://travis-ci.org" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> Travis-CI </strong> </a>上注册(该账户拥有这个回购)。</li><li id="763c" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">在设置页面，通过点击同步账户来同步你所有的Git回复</li></ol><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pb"><img src="../Images/600080ca27ea95c29f1694baadb1347c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XFpchqXGVxD_ct-jNUFJjg.png"/></div></div></figure><h2 id="0d0f" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated">在根文件夹中创建. travis.yml文件</h2><pre class="nv nw nx ny gt og oh oi oj aw ok bi"><span id="b9d0" class="lq lr iq oh b gy ol om l on oo">touch .travis.yml</span></pre><h2 id="e079" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated">在. travis.yml文件中输入以下指令</h2><pre class="nv nw nx ny gt og oh oi oj aw ok bi"><span id="f68a" class="lq lr iq oh b gy ol om l on oo">sudo: required<br/>services:<br/> - docker</span><span id="afb0" class="lq lr iq oh b gy oz om l on oo">before_install:<br/> - docker build -t beingjd/docker-nodeauth -f Dockerfile .</span><span id="e36a" class="lq lr iq oh b gy oz om l on oo">script:<br/> - docker run -e CI=true beingjd/docker-nodeauth npm test</span></pre><p id="6c6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们正在使用docker，我们将使用docker服务，要求Travis CI安装docker并构建Docker应用程序</p><p id="683f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">before_install</strong></code>:安装依赖项前执行所有命令。这里，我们首先构建docker映像。</p><p id="9b09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ow ox oy oh b"><strong class="ka ir">script</strong></code>:执行使构建通过或失败的命令。我们在docker映像上运行<code class="fe ow ox oy oh b">npm test</code>命令来运行测试。</p><p id="48a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在将文件推送到GitHub，让Travis运行您所有的测试。</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pc"><img src="../Images/ca2de0a32490f23221fbaf89a3130a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxpPpaFo6XHb2cR7YRI_LA.png"/></div></div></figure><p id="5eeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到测试成功通过，并准备在AWS上部署。</p><h1 id="8424" class="na lr iq bd ls nb nc nd lv ne nf ng ly nh ni nj mb nk nl nm me nn no np mh nq bi translated">使用AWS ElasticBeanstalk部署</h1><p id="9e01" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nr kl km kn ns kp kq kr nt kt ku kv ij bi translated">注册亚马逊网络服务。请记住，有些服务确实需要您的信用卡，所以请在使用Elastic Beanstalk创建应用程序之前完成所有步骤。</p><h2 id="ecc9" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated"><strong class="ak"> <em class="op">弹性豆茎的一些优点:</em> </strong></h2><ol class=""><li id="fa38" class="mj mk iq ka b kb ml kf mm kj mn kn mo kr mp kv mq mr ms mt bi translated">Elastic Beanstalk有许多EC2实例、一个可选的数据库以及一些其他的AWS组件(弹性负载平衡器、自动伸缩组、安全组)。</li><li id="9e8f" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">Elastic Beanstalk不会在它为您创建的这些资源上增加任何成本，并且它会在AWS内部需要软件更新时管理这些资源。</li><li id="fcc3" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">如果流量增加，它可以自动产生更多的EC2实例。</li></ol><p id="91a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kx">创建应用程序，并为其提供一个合适的名称，使其类似于GitHub repo的名称</em> </strong></p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pd"><img src="../Images/1c3380ba46fc4e0c239306f529e54e8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1OCqPuIjXDx__muSuoooWQ.png"/></div></div></figure><h2 id="d85f" class="lq lr iq bd ls lt lu dn lv lw lx dp ly kj lz ma mb kn mc md me kr mf mg mh mi bi translated">修改. travis.yml文件并添加以下说明:</h2><figure class="nv nw nx ny gt jr"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="bb56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们在GitHub上推送更改，Travis将使用上述指令自动部署应用程序。</p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pe"><img src="../Images/a26c4dff5b930ff24122ca54fdf8745b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u0VQ4dJ21vi8QbBM91DhXw.png"/></div></div><figcaption class="os ot gj gh gi ou ov bd b be z dk translated">Travis在elastic beanstalk上部署节点应用程序</figcaption></figure><p id="0f7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦部署了节点应用程序，访问在AWS Elastic Beanstalk中创建的应用程序，它应该显示“Health Ok”状态，这意味着我们已经成功地在AWS上部署了应用程序。</p><p id="83c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">点击URL访问应用程序。</strong></p><figure class="nv nw nx ny gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pf"><img src="../Images/2a091a701f3c91b7c3197c0bb869b7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXOtg6LlbDxCaD9aZTdSrQ.png"/></div></div></figure><h1 id="42fc" class="na lr iq bd ls nb nc nd lv ne nf ng ly nh ni nj mb nk nl nm me nn no np mh nq bi translated">结论</h1><p id="0de3" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nr kl km kn ns kp kq kr nt kt ku kv ij bi translated">在本文中，我们学习了一种实用的方法来将应用程序Docker化，在AWS Elastic Beanstalk上部署Docker应用程序，并使用Travis CI和Github自动进行测试和部署。</p><p id="4f1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经在我的<a class="ae kw" href="https://github.com/desaijay315/docker-nodeauth" rel="noopener ugc nofollow" target="_blank"> Github </a>上创建了我们的应用<strong class="ka ir"> <em class="kx"> </em> </strong>的存储库，请随意分叉代码并尝试运行我上面提到的所有命令/代码。</p><p id="460d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还上传了<a class="ae kw" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>集合，用于在GitHub上测试我们这个app <strong class="ka ir"> </strong>的所有API。</p><p id="1f60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是用Postman测试上述应用程序的<a class="ae kw" href="https://www.topcoder.com/blog/testing-nodejs-application-with-postman/" rel="noopener ugc nofollow" target="_blank">链接</a></p><blockquote class="nz oa ob"><p id="ce25" class="jy jz kx ka b kb kc kd ke kf kg kh ki oc kk kl km od ko kp kq oe ks kt ku kv ij bi translated">如果你喜欢，请留下一些掌声以示支持。此外，请在下面留下您的回答，如果您遇到任何问题，请联系我。</p><p id="a32b" class="jy jz kx ka b kb kc kd ke kf kg kh ki oc kk kl km od ko kp kq oe ks kt ku kv ij bi translated"><em class="iq">关注我</em><a class="ae kw" href="http://www.twitter.com/beingjaydesai" rel="noopener ugc nofollow" target="_blank"><em class="iq">Twitter</em></a><em class="iq">|查看我的</em><a class="ae kw" href="https://www.linkedin.com/in/iamjaydesai/" rel="noopener ugc nofollow" target="_blank"><em class="iq">LinkedIn</em></a><em class="iq">|查看我的</em> <a class="ae kw" href="https://github.com/desaijay315" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> GitHub </em> </a></p></blockquote></div></div>    
</body>
</html>