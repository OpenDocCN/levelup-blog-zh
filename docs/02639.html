<html>
<head>
<title>How to Use Java Collections Safely in Multi-Threaded Environments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在多线程环境中安全地使用Java集合</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-java-collections-safely-in-multi-threaded-environments-83c94be57ab8?source=collection_archive---------1-----------------------#2020-03-27">https://levelup.gitconnected.com/how-to-use-java-collections-safely-in-multi-threaded-environments-83c94be57ab8?source=collection_archive---------1-----------------------#2020-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/425e2193c2c87f0d0daf7edf9079a529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jsUzLABU2iC7sQQs5iUxVg.jpeg"/></div></div></figure><p id="4738" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Collections </strong>是一个Java框架，它提供了各种实用程序类，实现了一些众所周知的数据结构，比如映射、列表和集合。几乎所有的高级编程语言都提供了这些数据结构的某种实现，Java也不例外。熟悉的类如<strong class="ka ir"> ArrayList </strong>、<strong class="ka ir"> HashMap </strong>和<strong class="ka ir"> HashSet </strong>都是这个框架的一部分。</p><p id="1ac2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在单线程环境中使用它们是微不足道的，但在多线程应用中我们需要小心，因为大多数这些类没有内部同步，这意味着它们在默认情况下不是线程安全的。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/11ea5893fa65a3ca422ee00b440d1881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKSfDu2qV9ADxj6OmhpMRg.png"/></div></div></figure><h1 id="5039" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是线程安全？</h1><p id="3b57" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">对象的线程安全意味着同时从多个线程访问/修改该对象不会使其处于不一致的状态。有许多方法可以实现这一点，最简单的方法之一是<strong class="ka ir">互斥</strong>这意味着一次只有一个线程可以与一个对象交互。通过将读/写操作放在一个<strong class="ka ir">锁</strong>之后，该锁在任何给定时间只能被一个线程获取，潜在的竞争条件被消除，从而实现线程安全。</p><h1 id="129d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">异常:堆栈</strong>、<strong class="ak">向量</strong>、<strong class="ak">属性</strong>、<strong class="ak">哈希表</strong></h1><p id="2743" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">让我们先把这些解决掉。当我说集合框架中的大多数实现都不是线程安全的时候，我说的是这些坏孩子。是的，这些是线程安全的。</p><p id="1e31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">堆栈、向量、属性和哈希表类都在Java 1.0中实现，因此它们大多被认为是遗留类。如果您查看它们的实现，您会发现它们都是在对象级同步的。下面是<strong class="ka ir">栈</strong>的实现，它使用<strong class="ka ir"> synchronized </strong>关键字为所有操作锁定整个对象。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><h1 id="7d27" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么不在默认情况下同步它们呢？</h1><p id="757b" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">“为什么他们在实现最早的集合时会考虑到线程安全，而在后来却放弃了这一理念？”你可能会问。嗯，答案其实很简单:<strong class="ka ir">同步的成本。</strong></p><p id="0f31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同步并不便宜，因此默认情况下将它嵌入到每个集合中会剥夺开发人员的自由。因此，现在大多数集合都是为了优化单线程应用程序中的吞吐量而编写的。</p><p id="2935" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，如果在多线程应用程序中使用非线程安全集合，会发生什么呢？</p><h1 id="568b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><em class="mg">并发修改异常</em></h1><p id="42ec" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">收集是<strong class="ka ir">快速失败</strong>。快速失效意味着一旦检测到意外情况，操作就会终止。非线程安全集合通过保存一个名为<strong class="ka ir"> modCount </strong>的变量来实现这一点。该变量负责跟踪对该对象所做的修改。如果在操作过程中modCount以某种方式增加，就会抛出ConcurrentModificationException来通知您。但是，您不应该依赖于处理这个异常，因为这不是检测并发修改的可靠方法。抛出这个异常只是为了帮助开发人员发现问题，并让他们知道他们可能需要考虑一些额外的同步。</p><h1 id="f76f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">如何在多线程应用中使用集合？</strong></h1><p id="e5a9" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">Collections framework实际上提供了一种将常规集合转换为同步集合的方法:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="10ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同步是通过将所提供的集合放入一个包装类来实现的，该包装类只是保存一个<strong class="ka ir">互斥体</strong>，并在每次操作之前锁定它。这也是对象级同步，这意味着在执行任何类型的操作之前，整个集合都是锁定的。</p><p id="7d92" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">迭代器是</strong> <strong class="ka ir">还是</strong> <strong class="ka ir">不同步！</strong>如果你想使用迭代器遍历集合，你需要手动同步它们。请记住，智能for循环也在幕后使用迭代器，因此同样适用。</p><p id="dfba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然对象级同步可能适用于大多数应用程序，但它是实现线程安全的强力方式。它效率不高，并且会产生读/写争用。幸运的是，我们有更好的选择。</p><h1 id="27bf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">java.util .并发包</h1><p id="1c1e" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">这个包提供了多种实现来尽可能高效地实现集合中的并发性。不依赖于对象级同步，而是使用更复杂的方法来处理并发性。</p><p id="db27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看一些例子:</p><ul class=""><li id="ac62" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated"><strong class="ka ir">并发哈希表<br/></strong>Java中的哈希表将数据存储在称为<strong class="ka ir">段</strong>的哈希块中。<strong class="ka ir"> </strong>默认情况下，创建一个HashMap有32个段。ConcurrentHashMap只锁定段而不是整个对象，对每个段使用不同的互斥体。这提供了多个线程来同时访问不同的段。读取操作根本没有被锁定。</li><li id="be21" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated"><strong class="ka ir"> CopyOnWriteArrayList </strong> <br/>保持一个内部数组来存储元素。当你添加一个元素到列表中时，所有的东西都被复制，新元素被附加到列表的末尾。然后，这个新列表被分配给内部数组。该方法允许您安全地遍历列表，因为即使有更新，也会为它创建一个新数组。如果需要定期更新列表，复制会带来巨大的开销，所以只有在很少需要添加/删除元素时才应该使用这种方法。</li></ul><p id="e63d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">推荐人:</strong></p><div class="mv mw gp gr mx my"><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/collections.html" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">并发收款</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">Java教程是为JDK 8编写的。本页中描述的示例和实践没有利用…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">docs.oracle.com</p></div></div></div></a></div><div class="mv mw gp gr mx my"><a href="https://en.wikipedia.org/wiki/Thread_safety" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">线程安全</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">线程安全是一个适用于多线程代码的计算机编程概念。线程安全代码只操纵…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">en.wikipedia.org</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm jw my"/></div></div></a></div><div class="mv mw gp gr mx my"><a href="https://www.ibm.com/developerworks/java/library/j-jtp08223/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">构建更好的散列表</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">Brian Goetz深入研究了ConcurrentHashMap的代码，并研究了它如何实现出色的吞吐量和并发性…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">www.ibm.com</p></div></div><div class="nh l"><div class="nn l nj nk nl nh nm jw my"/></div></div></a></div></div></div>    
</body>
</html>