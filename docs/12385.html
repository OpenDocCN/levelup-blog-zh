<html>
<head>
<title>Memory Management in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的内存管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/memory-management-in-javascript-d3bb6b7f12ed?source=collection_archive---------6-----------------------#2022-06-06">https://levelup.gitconnected.com/memory-management-in-javascript-d3bb6b7f12ed?source=collection_archive---------6-----------------------#2022-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f5b78103a703acb05739cdb4e9fc85de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ebg9rIUCisByUsUl"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Nubelson Fernandes 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="cd10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> Javascript </strong>是一种高级语言，由现代浏览器(Javascript引擎)完成垃圾收集。这给Javascript开发人员一种印象，他们既不需要知道幕后发生了什么，也不需要做些什么来改善他们的Javascript应用程序的内存管理。C语言等低级语言速度更快、效率更高的原因之一是因为我们可以手动控制GC，因此它们在内存管理方面更优化、更高效。</p><p id="d975" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Javascript内存管理由三个主要部分组成:</p><p id="b318" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">1)当我们给一个变量赋值时，它会自动分配一个可用的内存块来存储这个值，并引用链接到这个变量。</p><p id="fcde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2)然后在脚本中使用该变量。</p><p id="7363" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">3)当变量不再被使用时(或者引用被移除)，堆中的内存将被自动释放，以防止内存泄漏。</p><p id="0cee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上所述，Javascript使用标记和清除算法进行内存管理。基本上，它会标记脚本使用的内存引用，并清除其余的。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="49ca" class="ln lo it lj b gy lp lq l lr ls">var apple = {<br/>  color: 'red',<br/>  category: 'fruits'<br/>}</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lt"><img src="../Images/25f0da7789a668c574ded73d7fd88d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9_REDdBLKnX_XbUzyKJjpQ.png"/></div></div></figure><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5815" class="ln lo it lj b gy lp lq l lr ls">var apple = {<br/>  color: 'red',<br/>  category: 'fruits'<br/>}<br/><br/>apple = 10</span></pre><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi lu"><img src="../Images/8e8be92038cc52410158b76f03c821c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wER90vRhY6lnf0tGJUFlw.png"/></div></div></figure><p id="04a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可能会出现垃圾收集无法释放未使用的内存并导致内存泄漏的情况。作为Javascript开发人员，我们可以做些事情来防止它们。内存泄漏的三个最常见原因是:</p><p id="12d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> 1)事件监听器</strong> <br/>当DOM元素从DOM树中分离并且在Javascript中不再引用它时，事件监听器将被自动移除。然而，IE等较旧的浏览器将无法正确处理这一问题。此外，我们还应该仔细规划事件侦听器的使用，因为在事件被触发之前，它们大部分时间都不会被使用，并且当这些DOM元素处于活动状态时，它们会占用内存。</p><p id="6706" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> 2)全局变量</strong>这个全局执行上下文是在执行任何代码之前创建的，因此这些全局变量将总是被附加，而不会被垃圾收集。再次强调，规划很重要。尝试在阻塞范围内使用用“let”和“const”(不是“var”，如果我们用“var”声明，它将是全局对象的一部分)定义的局部变量，例如在函数中。当从堆栈中弹出函数调用时，函数中的局部变量会被自动清除。</p><p id="6f67" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> 3)后台持续运行的东西</strong>T5】我们在使用setInterval()等函数时也要小心。当我们在回调函数中使用一个变量时，这个变量总是被附加的，不会被清除。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><blockquote class="mc md me"><p id="1a21" class="kg kh mf ki b kj kk kl km kn ko kp kq mg ks kt ku mh kw kx ky mi la lb lc ld im bi translated"><strong class="ki iu">结论</strong>:</p><p id="60c1" class="kg kh mf ki b kj kk kl km kn ko kp kq mg ks kt ku mh kw kx ky mi la lb lc ld im bi translated">先规划后执行，甚至是分配变量的逻辑。这将有助于提高您的应用程序的性能，尤其是当它扩展时。</p></blockquote><p id="6ff8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想看更多的网络开发或软件工程相关的内容，请关注我。干杯！</p></div></div>    
</body>
</html>