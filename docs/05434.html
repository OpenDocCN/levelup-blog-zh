<html>
<head>
<title>Rust Adventures: Introduction to Collections — Hash Maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust Adventures:集合介绍—哈希映射</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rust-adventures-introduction-to-collections-hash-maps-53ccc5e5a214?source=collection_archive---------3-----------------------#2020-08-28">https://levelup.gitconnected.com/rust-adventures-introduction-to-collections-hash-maps-53ccc5e5a214?source=collection_archive---------3-----------------------#2020-08-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2b8403b5c6e11f4e2e3c65f63808d0bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W8KBrJgmsIlYtn24AhHfSQ.jpeg"/></div></div></figure><p id="e65c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这次我们继续我们的冒险者通过<a class="ae kz" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank">铁锈</a>土地和<a class="ae kz" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">散列地图</a>！</p><p id="4479" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种集合真的很有用，可以让你的程序更快，我们去看看怎么样。所有的代码你都可以在这里找到<a class="ae kz" href="https://github.com/victorinno/rust_collections_hasmmap" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="1ec4" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">什么是哈希映射？</h1><p id="6b6c" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">哈希映射是所有编程语言中非常常见的结构。有人称之为字典、哈希表等。基本思想是有一个指向一个值的键。这个键由一个映射我们数据的<a class="ae kz" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank">散列函数</a>处理。返回结果被称为哈希，这是算法跟踪数据的方式。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/d8e186723083589a1409a410affc7c6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*HSXgoaltXEA7Uqs_8Pw7Yg.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><a class="ae kz" href="https://abseil.io/blog/20180927-swisstables" rel="noopener ugc nofollow" target="_blank">https://abseil.io/blog/20180927-swisstables</a></figcaption></figure><p id="7280" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这把钥匙，你可以非常快速地检索数据。在<a class="ae kz" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">大O记法</a>中，复杂度平均为<em class="mt"> O(1) </em>，最坏情况下为<em class="mt"> O(n)。</em></p><h1 id="8413" class="lh li it bd lj lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me bi translated">创建哈希映射</h1><p id="562c" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">它非常类似于一个矢量。我们可以使用<code class="fe mz na nb nc b">new</code>函数，仅此而已。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/a822ef199b5a112e0025100f26d8897b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*cYtdpVsdMXPF4kEeyYmqzw.png"/></div></figure><p id="ffca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像向量一样，因为我们在编译时不知道它的大小，所以值存储在堆中。与Vectors不同，你需要用<code class="fe mz na nb nc b">use std::colelctions::HashMap</code>从standard导入库。这些键也必须是同类的，换句话说，它们必须是同一类型。</p><h1 id="22dc" class="lh li it bd lj lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me bi translated">哈希映射的基本操作</h1><p id="4834" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">像向量一样，我们可以从哈希表中读取、插入、更新和删除值。Rust只是给了我们一个API，让我们检查一下。</p><h2 id="bb1e" class="ng li it bd lj nh ni dn ln nj nk dp lr km nl nm lv kq nn no lz ku np nq md nr bi translated">读取和插入元素</h2><p id="a3ab" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">要将值放入哈希表中，我们不仅需要决定要处理的值，还需要决定哪种元素可以被定义为标识一个或多个值的键。</p><p id="1ec5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，让我们创建一个学生列表。我们会知道他们每个人的名字、性别和年龄。有人想把他们按性别分组，然后在以后的报告中查看男女学生的名单。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="06f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将是我们的基本结构。现在我们做一些逻辑来读一个向量，把学生按性别分组。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bf51" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">逻辑非常简单:</p><ul class=""><li id="d09e" class="ns nt it kd b ke kf ki kj km nu kq nv ku nw ky nx ny nz oa bi translated">首先，我们创建一个新的哈希映射</li><li id="652d" class="ns nt it kd b ke ob ki oc km od kq oe ku of ky nx ny nz oa bi translated">性别的每一种可能性都将是我们的键，而值将是一个空向量。为了插入它们，我们使用<code class="fe mz na nb nc b">insert(key, value)</code>功能。</li><li id="cff2" class="ns nt it kd b ke ob ki oc km od kq oe ku of ky nx ny nz oa bi translated">迭代学生</li><li id="ae99" class="ns nt it kd b ke ob ki oc km od kq oe ku of ky nx ny nz oa bi translated"><code class="fe mz na nb nc b">get_mut</code>将尝试在我们的哈希表中找到这个学生的性别，如果他找到了，返回<code class="fe mz na nb nc b">Some(Vec&lt;Student&gt;)</code>否则返回<code class="fe mz na nb nc b">None</code>。它返回的向量是可变的，所以我们可以改变它的值</li><li id="fe12" class="ns nt it kd b ke ob ki oc km od kq oe ku of ky nx ny nz oa bi translated"><code class="fe mz na nb nc b">map</code>将获得现值，而<code class="fe mz na nb nc b">push</code>将该学生纳入该组。如果没有，它什么也不做，这在这个程序中是不可能的。<code class="fe mz na nb nc b">map</code>要求使用clojure，所以我们使用了lambda表达式。</li></ul><p id="e811" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要使用散列映射，您可以使用一些不同的<code class="fe mz na nb nc b">get</code>方法，将一个键作为参数传递。结果就是您可能想要使用的值。</p><p id="e118" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">更新哈希映射中的值</strong></p><p id="f313" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们想改变价值观呢？这很简单，也完全可能。</p><p id="8752" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管键的数量和它们携带的值是可增长的，但是每个键只能有一个值。所以你有一些选择:</p><ul class=""><li id="861c" class="ns nt it kd b ke kf ki kj km nu kq nv ku nw ky nx ny nz oa bi translated">用新值更改当前值</li><li id="1ed0" class="ns nt it kd b ke ob ki oc km od kq oe ku of ky nx ny nz oa bi translated">忽略新值并保留当前值</li><li id="fa72" class="ns nt it kd b ke ob ki oc km od kq oe ku of ky nx ny nz oa bi translated">根据新值更改该值</li></ul><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d84d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在第一个例子中，我们使用方法<code class="fe mz na nb nc b">initialize_gender</code>将一个新的向量放入一个不存在的键中。测试<code class="fe mz na nb nc b">try_to_modify</code>方法是否:</p><ul class=""><li id="d64b" class="ns nt it kd b ke kf ki kj km nu kq nv ku nw ky nx ny nz oa bi translated">初始化母密钥</li><li id="12d5" class="ns nt it kd b ke ob ki oc km od kq oe ku of ky nx ny nz oa bi translated">在里面放一个值</li><li id="07e5" class="ns nt it kd b ke ob ki oc km od kq oe ku of ky nx ny nz oa bi translated">打印结果</li><li id="d092" class="ns nt it kd b ke ob ki oc km od kq oe ku of ky nx ny nz oa bi translated">他们再次尝试初始化母密钥</li><li id="6358" class="ns nt it kd b ke ob ki oc km od kq oe ku of ky nx ny nz oa bi translated">再次打印结果</li></ul><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi og"><img src="../Images/e917e034e5fc8a97666a81c6b56a8fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*HxvUvKszZlAgZaXplmDInw.png"/></div></figure><p id="de22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，结果是一样的。发生这种情况是因为<code class="fe mz na nb nc b">entry</code>。当我们称它为枚举<a class="ae kz" href="https://doc.rust-lang.org/beta/std/collections/hash_map/enum.Entry.html" rel="noopener ugc nofollow" target="_blank">条目</a>时:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/f74d712f3fe597181d8f63c57991c956.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*a0WUEgry2gYiteXVSCFQQw.png"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated"><a class="ae kz" href="https://doc.rust-lang.org/beta/std/collections/hash_map/enum.Entry.html" rel="noopener ugc nofollow" target="_blank">https://doc . rust-lang . org/beta/STD/collections/hash _ map/enum。Entry.html</a></figcaption></figure><p id="8c6b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它有两个选项，<code class="fe mz na nb nc b">Occupied</code>当我们有密钥时，和<code class="fe mz na nb nc b">Vacant</code>当密钥不存在时。<code class="fe mz na nb nc b">or_insert</code>方法的行为取决于输入的结果。如果它被占用，它什么也不做，否则它将插入传递的参数。</p><p id="36e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用ti安全地插入值，例如:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="157e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在考虑这个问题:我想把所有男同学的年龄加一。我们怎么能这样做呢？</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f20d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该算法使用可变引用<code class="fe mz na nb nc b">entry</code>返回，对于每个学生，我们将年龄增加1。结果如下所示:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/fcf55beff0cef58e5b028228f9fb64b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*Pp2wQzju-TDRllZUTnRa2A.png"/></div></figure><p id="33b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，我们可以讨论的最后一件事是值的替换。我们可以假设到了年底，班级会发生变化，我们需要改变学生名单，所以让我们开始吧。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/b1d7611b1f18c9fda6202e8732a9df31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*ik2xbKOJli90UyXXbCPx9w.png"/></div></figure><p id="2910" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mz na nb nc b">insert</code>方法使它变得简单。它会将值放入传递键中，如果它有内容，同样会被新的级别所替换。</p><h1 id="6bda" class="lh li it bd lj lk mu lm ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me bi translated">结论</h1><p id="cb5e" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">哈希映射是一个很好的工具。你可以做缓存，组织你的向量，对一些问题有很好的表现。有了O(1)复杂度，你可以非常快速地处理非常大的数据集。</p><p id="1148" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就这样，我们继续探索铁锈。在我们的下一篇文章中，我们将讨论字符串，并结束这个系列。</p><p id="5f40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望你和我一起享受它！</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><div class="ml mm mn mo gt ok"><a href="https://profile.codersrank.io/user/victorinno" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">victorinno的CodersRank简介</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">这是什么？这代表了你目前的经历。它通过分析您连接的存储库进行计算。由…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">profile.codersrank.io</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy jz ok"/></div></div></a></div></div></div>    
</body>
</html>