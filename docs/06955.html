<html>
<head>
<title>Direct Cache Mapping and Memory Access Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">直接缓存映射和内存访问时间</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/direct-cache-mapping-and-memory-access-time-d06f5e5ece02?source=collection_archive---------9-----------------------#2021-01-13">https://levelup.gitconnected.com/direct-cache-mapping-and-memory-access-time-d06f5e5ece02?source=collection_archive---------9-----------------------#2021-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="46d6" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">是什么让一个软件开发者觉得自己很有钱？<br/>他们的缓存。</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/8ce8f9d0f40ef4aaa1361cdfea05fb45.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*CqxA4ZFh2U1k5QLF.gif"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片来自<a class="ae lb" href="https://imgur.com/r/gif/KydfV1H" rel="noopener ugc nofollow" target="_blank"> Imgur </a>:“如果有疑问，清空你的缓存和cookies”</figcaption></figure><p id="f79a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">一句话，缓存是来自网站或应用程序的数据信息，存储在您的设备上以加快浏览过程。缓存数据使得用户经常浏览的网站以更快的速度加载。</p><p id="a5aa" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">最快的数据存取保存在处理器中。通常，有两级缓存。一级高速缓存位于处理器芯片上。第二层位于主存储器和处理器之间。离处理器的数据越远，计算机检索所需数据的时间就越长。信息在处理器中存储得越近，检索数据的速度就越快。</p><p id="dd75" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">在下图中，很容易看出处理器、高速缓存和内存是如何相互连接的。一级高速缓存位于处理器内部。在处理器之外，有一个二级高速缓存，主存储器，然后是磁盘二级存储器。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi lf"><img src="../Images/30150435eb5adf3bbc34ad39eeaf2907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_guQLdk_D9Lg5YB0Fe1wg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">计算机体系结构图</figcaption></figure><p id="4f76" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">高速缓冲存储器的结构使主存储器在处理器看来比实际速度更快。</p><p id="648f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">当处理器寻找数据时，它首先查看缓存，看它是否在那里。</p><p id="e786" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">如果找到了，我们会得到“读取命中”，并从缓存中获取数据。如果信息不在高速缓存中，那么我们得到一个“读未命中”，处理器继续从主存储器中寻找信息，稍后将内容保存到高速缓存中。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi lk"><img src="../Images/af250bc213d49017d49bfe09f86a9e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TIiUF1QGInGNA2W5Z3oMfg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">缓存图</figcaption></figure></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="e750" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">三种类型的缓存未命中</h1><p id="5430" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lc ms ke kf ld mt ki kj le mu km kn ko ij bi translated">缓存未命中有3个原因。</p><ol class=""><li id="4951" class="mv mw iq jt b ju jv jy jz lc mx ld my le mz ko na nb nc nd bi translated"><strong class="jt ir">强制</strong>:第一次进入街区；必须将该块放入缓存中；也称为冷启动未命中或第一参考未命中。</li><li id="3a0d" class="mv mw iq jt b ju ne jy nf lc ng ld nh le ni ko na nb nc nd bi translated"><strong class="jt ir">容量</strong>:由于高速缓存包含程序执行所需的所有块(程序工作集远大于高速缓存容量)，块被从高速缓存中丢弃而发生。</li><li id="d75b" class="mv mw iq jt b ju ne jy nf lc ng ld nh le ni ko na nb nc nd bi translated"><strong class="jt ir">冲突</strong>:在集合关联或直接映射块放置策略的情况下，当几个块被映射到同一个集合或块帧时，发生冲突未命中；也称为碰撞失误或干扰失误。</li></ol></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><blockquote class="nj"><p id="4fb3" class="nk nl iq bd nm nn no np nq nr ns ko dk translated">为什么开发商破产了？因为他用完了所有的缓存。</p></blockquote></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><h1 id="daab" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">直接缓存映射</h1><p id="49d4" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lc ms ke kf ld mt ki kj le mu km kn ko ij bi translated">在直接映射缓存中，每个内存块在缓存中所占的位置是固定的。例如，假设我们的高速缓存大小为4，内存访问字符串为“7，0，1，2，1，4，1，7”。</p><p id="e386" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">在直接映射缓存中，每个元素都有一个固定的存储位置。因为我们的缓存大小为4，所以我们只能将元素放在4缓存块中。缓存不能一次扩展4个元素。当内存访问字符串除以缓存大小时，我们可以通过取模来确定元素应该在的位置。</p><p id="391b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">我们的第一个字符串是7。7模4是3。字符串7只能存储在缓存中的第三个位置(实际上是第四个位置，因为缓存是基于0的索引)</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nt"><img src="../Images/2659f9afc082048043552ebaf0dc9f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FRpqIqz-NWleJ3nIyTn9tw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">直接缓存过程的示例</figcaption></figure><p id="d08a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">在上面的例子中，我们第一次尝试访问字符串时，会查看缓存。我们意识到7不在缓存中，因此我们有一个读取未命中。由于7 mod 4是3，我们现在将字符串7放入缓存3位置。</p><p id="0b6e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">接下来，我们看字符串0。0只能位于缓存位置0。因为0不在那里，所以我们从主内存中取出数据，但是我们将0放在缓存中，以便将来更容易定位。在此阶段，0位于高速缓存位置0，而7仍位于高速缓存位置3。</p><p id="328e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">接下来，我们看看字符串1。1不在缓存中，所以我们从主内存中取出数据，并将其放在缓存位置1。我们对字符串2执行类似的步骤。现在，缓存0位置有0，缓存1位置有1，缓存2位置有2，缓存3位置有7。我们的缓存已满。</p><p id="938c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">我们要访问的下一个字符串是1。这一次，1位于缓存位置1。我们得到一个阅读命中。提取1比前一次快，因为它在缓存中。</p><p id="4ef1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">接下来，我们要拉进4。4不在我们的缓存中。如果我们的缓存程序是直接映射的，则4只能位于位置0。我们的缓存容量已满，存在缓存冲突。这一次，我们从0缓存位置替换0，并用4替换它。现在我们的缓存有4、1、2和7。</p><p id="51b7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">接下来，我们想要获取1和7，在那里我们已经读取了命中，并且我们能够更快地检索数据。</p><h1 id="8132" class="ls lt iq bd lu lv nu lx ly lz nv mb mc md nw mf mg mh nx mj mk ml ny mn mo mp bi translated">存储器存取时间</h1><p id="f488" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lc ms ke kf ld mt ki kj le mu km kn ko ij bi translated">根据定义，内存访问时间是RAM中的一个字符传输到CPU或从CPU传输出来所需要的时间。快速RAM芯片的存取时间为10纳秒(ns)或更短。</p><p id="9ad5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">在上面的例子中，我们可以通过直接缓存映射来计算内存访问时间。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nt"><img src="../Images/2659f9afc082048043552ebaf0dc9f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FRpqIqz-NWleJ3nIyTn9tw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">直接缓存过程的示例</figcaption></figure><p id="067d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">存储器访问时间可通过以下公式计算。</p><pre class="kq kr ks kt gt nz oa ob oc aw od bi"><span id="59f0" class="oe lt iq oa b gy of og l oh oi">(# of Hits X time to fetch data from cache) + (# of Misses X time to fetch data from main memory)</span></pre><p id="f902" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">命中的数目可以从“读取命中”中找到，未命中的数目是“读取未命中”。从高速缓存或主存储器获取数据的时间长度可能不同。</p><p id="6bb3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">如果从缓存中获取数据的时间是6纳秒，从主内存中获取数据的时间是35纳秒，那么我们的示例为:</p><pre class="kq kr ks kt gt nz oa ob oc aw od bi"><span id="898e" class="oe lt iq oa b gy of og l oh oi">(2 X 6ns) + (6 X 30ns) = 192</span></pre><p id="8cdf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lc kd ke kf ld kh ki kj le kl km kn ko ij bi translated">由于高速缓存比主内存更靠近处理器，因此获取数据的速度更快。我们可以看到，处理器从主存中取数据需要的时间越多，内存访问时间就越长。</p></div></div>    
</body>
</html>