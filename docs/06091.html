<html>
<head>
<title>Object Indexing in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的对象索引</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/object-indexing-in-react-269295e1eae2?source=collection_archive---------5-----------------------#2020-10-26">https://levelup.gitconnected.com/object-indexing-in-react-269295e1eae2?source=collection_archive---------5-----------------------#2020-10-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ba07" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">停止过度使用数组函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4497771cc2dc2d15940290554da6428b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RU89TcfRAR5mmclMX9x57w.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae ky" href="https://unsplash.com/s/photos/lists?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a4f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript数组方法可能非常方便，但有时会被过度使用。这些数组函数易于调用，少量的代码/降低的复杂性可能会导致开发人员在它们可能不是最有效的方法时过于依赖它们。这就引出了本文的主题，<strong class="lb iu">对象索引</strong>。</p><p id="4c14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">索引允许我们将集合中的对象与相关联的某个数字(或索引)相关联。与使用数组中的项的索引来访问该项类似，您可以对对象中的项进行索引，使它们可以在某个键上被访问。查看下面的对象集合，首先作为一个数组，然后作为一个对象。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="215c" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">Array</strong><br/>[{id: 1, name: "test 1", createdAt: "Sunday Oct 25 2020", "color": "red"}, {id: 2, name: "test 2", createdAt: "Monday Oct 26 2020",  color: "blue"}, ...]</span><span id="02ca" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu">Object<br/></strong>{1: {id: 1, name: "test 1", createdAt: "Sunday Oct 25 2020", color: "red"}, 2: {id: 2, name: "test 2", createdAt: "Monday Oct 26 2020",  color: "blue"}, ...}</span></pre><p id="874b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数组的例子中，你可以访问数组中的第二项，但是要写<code class="fe mh mi mj lw b">array[1]</code>。在对象示例中，可以通过写<code class="fe mh mi mj lw b">object[2]</code>来访问对象中的第二项。</p><p id="db0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么索引如何帮助我们做出反应呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/5e3d51fd541f49bd81ccb55e1b0fd323.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/1*OXwiMP0SKoXcjWqrlskDgw.gif"/></div></figure><p id="b891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下在一个数组中有一个项目集合的场景。这些项目作为选项呈现在一个<code class="fe mh mi mj lw b">select</code>元素中。在<code class="fe mh mi mj lw b">select</code>元素下面，有一个显示组件，用于呈现所选项的属性(<code class="fe mh mi mj lw b">id, name, createdAt, color</code>)。请参见下面的示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/c0d37d0718db826b5fd3d2a7c7aa60ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrgNrgu4I3OrHNIzy4m2_w.png"/></div></div></figure><p id="804c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以为<code class="fe mh mi mj lw b">select</code>元素编写一个<code class="fe mh mi mj lw b">onChange</code>方法，利用好的ol’<code class="fe mh mi mj lw b">find</code>数组方法来更新当前的<code class="fe mh mi mj lw b">item</code>。大概是这样的:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="abd4" class="ma mb it lw b gy mc md l me mf">const findItem = (e) =&gt;{<br/>  var newItem = items.find(x=&gt;x.id === e.target.value)<br/>  setItem(newItem) <br/>};</span></pre><p id="c185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很好，但是如果数据集更大呢？或者如果操作变得更加复杂呢？如果您要查找的值是集合中某个对象的子对象，该怎么办？</p><p id="6d3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想说的是，尽管<code class="fe mh mi mj lw b">find</code>对于我们当前的用例来说并不是非常低效，但当应用程序的复杂性或数据集的大小增加时，它的效率会变得更低。对象索引可以为访问集合中的项目提供快速有效的方法。参见下面的<code class="fe mh mi mj lw b">Items</code>组件。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f6e9" class="ma mb it lw b gy mc md l me mf">import {useState, useEffect} from 'react';<br/>import '../App.css';<br/>import SelectedItem from './SelectedItem';<br/>import items from '../items.json';</span><span id="78b1" class="ma mb it lw b gy mg md l me mf">const Items = () =&gt;{<br/>  <br/>  const [item, setItem] = useState(items[0])</span><span id="188d" class="ma mb it lw b gy mg md l me mf">  const onChangeItem = (e)=&gt;{<br/>    var id = e.target.value<br/>    findItem(id)<br/>  }</span><span id="80a7" class="ma mb it lw b gy mg md l me mf">  const findItem = (id) =&gt;{<br/>    var newItem = items.find(x=&gt;x.id === id)<br/>    setItem(newItem)<br/>  };</span><span id="0688" class="ma mb it lw b gy mg md l me mf">  return (&lt;div&gt;<br/>    Items: &lt;select style={{width: 200}} value={item.id} onChange={onChangeItem}&gt;<br/>      {items.map(x=&gt;{<br/>        return &lt;option key={x.id} value={x.id}&gt;{x.name}&lt;/option&gt;<br/>      })}<br/>    &lt;/select&gt;<br/>    &lt;SelectedItem item={item}/&gt;<br/>  &lt;/div&gt;);<br/>};</span><span id="2666" class="ma mb it lw b gy mg md l me mf">export default Items;</span></pre><p id="09af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用<code class="fe mh mi mj lw b">find</code>来检索基于在<code class="fe mh mi mj lw b">select</code>元素中选择的<code class="fe mh mi mj lw b">id</code>的项目。如果您试图将整个对象存储为<code class="fe mh mi mj lw b">select</code>元素的值，您<em class="mm">可能</em>很难在您的集合中找到<code class="fe mh mi mj lw b">[Object object]</code>😝。如果我们能够访问一个对象，而该对象的键是项目id，并且这些键指向伴随的对象，那将会很方便。如果我们没有(比如上面的例子)，我们可以基于items数组创建一个。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="efa3" class="ma mb it lw b gy mc md l me mf">var map = new Object();<br/>items.forEach(x=&gt;{<br/>  map[x.id] = x<br/>})<br/>console.log(map)</span><span id="0af3" class="ma mb it lw b gy mg md l me mf">&gt;  {1: {id: 1, name: "test 1", createdAt: "Sunday Oct 25 2020", color: "red"}, 2: {id: 2, name: "test 2", createdAt: "Monday Oct 26 2020",  color: "blue"}, ...}</span></pre><p id="4b4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe mh mi mj lw b">useState</code>将这个对象存储在state中，并且我们可以在一个<code class="fe mh mi mj lw b">useEffect</code>钩子中实现上面的逻辑。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5a48" class="ma mb it lw b gy mc md l me mf">const [itemsMap, setTodosMap] = useState(null)</span><span id="0f4a" class="ma mb it lw b gy mg md l me mf">useEffect(()=&gt;{<br/>  var map = new Object();<br/>  items.forEach(x=&gt;{<br/>    map[x.id] = x<br/>  })<br/>  setTodosMap(map)<br/>}, [items]) //pass items as dependency so the map gets updated if the items list gets updated</span></pre><p id="44fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们更新的<code class="fe mh mi mj lw b">Items</code>组件。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5ef6" class="ma mb it lw b gy mc md l me mf">const Items = () =&gt;{<br/>  <br/>  const [item, setItem] = useState(items[0])<br/>  const [itemsMap, setTodosMap] = useState(null)</span><span id="9fdd" class="ma mb it lw b gy mg md l me mf">  useEffect(()=&gt;{<br/>    var map = new Object();<br/>    items.forEach(x=&gt;{<br/>      map[x.id] = x<br/>    })<br/>    setTodosMap(map)<br/>  }, [items])</span><span id="b0de" class="ma mb it lw b gy mg md l me mf">  const onChangeItem = (e)=&gt;{<br/>    var id = e.target.value<br/>    findItem(id)<br/>  }</span><span id="1a0c" class="ma mb it lw b gy mg md l me mf">  const findItem = (id) =&gt;{<br/>    var newItem = items.find(x=&gt;x.id === id)<br/>    setItem(newItem)<br/>  };</span><span id="f07b" class="ma mb it lw b gy mg md l me mf">  return (&lt;div&gt;<br/>    Items: &lt;select style={{width: 200}} value={item.id} onChange={onChangeItem}&gt;<br/>      {items.map(x=&gt;{<br/>        return &lt;option key={x.id} value={x.id}&gt;{x.name}&lt;/option&gt;<br/>      })}<br/>    &lt;/select&gt;<br/>    &lt;SelectedItem item={item}/&gt;<br/>  &lt;/div&gt;);<br/>};</span><span id="ebd1" class="ma mb it lw b gy mg md l me mf">export default Items;</span></pre><p id="cb94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了地图，我们不再需要使用执行<code class="fe mh mi mj lw b">find</code>数组方法的<code class="fe mh mi mj lw b">findItem</code>函数。现在我们需要做的就是使用<code class="fe mh mi mj lw b">onChangeItem</code>中的<code class="fe mh mi mj lw b">setItem</code>并将<code class="fe mh mi mj lw b">itemsMap</code>中已经在<code class="fe mh mi mj lw b">id</code>索引<em class="mm">的对象传递给它。见下文。</em></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="dd7a" class="ma mb it lw b gy mc md l me mf">const onChangeItem = (e)=&gt;{<br/>    var id = e.target.value<br/>    setItem(itemsMap[id])<br/>}</span></pre><p id="9f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管需要实现更多的代码/逻辑，但从长远来看，每次我们从列表中选择一个新项目时，索引会比使用<code class="fe mh mi mj lw b">find</code>更有效。通过利用对象索引，我们的React应用程序不需要依赖数组方法，如果数据集增长或应用程序复杂性增加，数组方法可能会变得非常昂贵。</p><p id="1975" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的源代码可以在<a class="ae ky" href="https://github.com/macro6461/medium-object-indexing" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="89e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://matt-croak.medium.com/membership" rel="noopener"> <em class="mm">在这里将你的免费媒体会员升级为付费会员</em> </a> <em class="mm">，每月只需5美元，你就可以获得数千位作家的无限量无广告故事。这是一个附属链接，你的会员资格的一部分帮助我为我创造的内容获得奖励。谢谢大家！</em></p><h1 id="2531" class="mu mb it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">参考</h1><div class="nl nm gp gr nn no"><a href="https://github.com/macro6461/medium-object-indexing" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">macro 6461/介质对象索引</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">这个项目是用Create React App引导的。在项目目录中，您可以运行:在…中运行应用程序</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ks no"/></div></div></a></div></div></div>    
</body>
</html>