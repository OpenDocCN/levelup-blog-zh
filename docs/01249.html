<html>
<head>
<title>Introduction to TypeScript Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript接口简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-typescript-interfaces-85303aede25d?source=collection_archive---------3-----------------------#2019-12-05">https://levelup.gitconnected.com/introduction-to-typescript-interfaces-85303aede25d?source=collection_archive---------3-----------------------#2019-12-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5a08e8d48ae343839b0a754ce215dfc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mAyZJ_ZJJIzVYUQx"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">艾默生·彼得斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4425" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与普通JavaScript相比，TypeScript的最大优势在于，它通过为我们的程序对象添加类型安全来扩展JavaScript的特性。它通过检查对象可以采用的值的形状来做到这一点。检查形状被称为鸭分型或结构分型。这对于在TypeScript程序的代码中定义契约非常有用。在本文中，我们将研究如何定义一个TypeScript接口，并向它添加必需的或可选的属性。</p><h1 id="c3f2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">定义接口</h1><p id="f0a9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了定义一个基本接口，我们在TypeScript中使用了<code class="fe mh mi mj mk b">interface</code>关键字。这个关键字是TypeScript专有的，在JavaScript中不可用。我们可以像下面的代码那样定义一个TypeScript接口:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="970a" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  name: string<br/>}</span></pre><p id="1daf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，如果一个变量或参数已经用这个接口指定，那么所有使用它的类型的对象都将拥有<code class="fe mh mi mj mk b">name</code>属性。分配给类型为的变量的对象文本不能有任何其他属性。作为这种类型的参数传入的参数也只能具有此属性。例如，下面的代码将成功编译，并使用TypeScript编译器运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1a71" class="mt lf it mk b gy mu mv l mw mx">interface Person{<br/>  name: string<br/>}</span><span id="d7a7" class="mt lf it mk b gy my mv l mw mx">const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}`);<br/>}<br/>greet({ name: 'Joe' });</span></pre><p id="86d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码将会编译并运行，因为它只有<code class="fe mh mi mj mk b">name</code>属性，并且它的值是一个字符串，就像在<code class="fe mh mi mj mk b">Person</code>接口中指定的一样。但是，下面的代码不会被TypeScript编译器编译并引发错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0a38" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  name: string<br/>}</span><span id="4848" class="mt lf it mk b gy my mv l mw mx">const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}`);<br/>}</span><span id="0f15" class="mt lf it mk b gy my mv l mw mx">greet({ name: 'Joe', foo: 'abc' });</span></pre><p id="e9ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为我们指定了<code class="fe mh mi mj mk b">greet</code>函数中的<code class="fe mh mi mj mk b">person</code>参数的类型为<code class="fe mh mi mj mk b">Person</code>。作为参数传入的对象只能有<code class="fe mh mi mj mk b">name</code>属性，并且它的值只能是字符串。如果一个变量已经被接口的类型指定了，我们就不能给一个对象赋予与接口中列出的属性不同的属性:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="58e4" class="mt lf it mk b gy mu mv l mw mx">const p: Person = { name: 'Joe', foo: 'abc' };</span></pre><p id="3c8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码也不会编译，因为object literal有一个额外的属性没有在<code class="fe mh mi mj mk b">Person</code>接口中列出。在支持TypeScript的编辑器(如Visual Studio代码)中，我们会得到错误消息“Type“{ name:string；foo:string；“}”不可赋给类型“Person”。Object literal只能指定已知的属性，并且类型“Person”中不存在“foo”。</p><p id="6d61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用接口，当指定变量的类型时，当我们写对象文字时，我们得到代码的自动完成。</p><h1 id="a686" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可选属性</h1><p id="8a04" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript接口可以有可选的属性。这使得接口比仅仅添加所需的属性更加灵活。我们可以在属性名后面加上问号<code class="fe mh mi mj mk b">?</code>来指定一个可选属性。例如，我们可以编写以下代码来定义具有可选属性的接口:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1ff4" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  name: string,<br/>  age?: number<br/>}</span></pre><p id="d96e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe mh mi mj mk b">age</code>是一个可选属性，因为我们在属性名后面加了一个问号。我们可以用它作为下面的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bd21" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  name: string,<br/>  age?: number<br/>}</span><span id="cafb" class="mt lf it mk b gy my mv l mw mx">const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}. ${person.age ? `You're ${person.age} years old.` : ''}`);<br/>}</span><span id="a59d" class="mt lf it mk b gy my mv l mw mx">greet({ name: 'Joe', age: 10 });</span></pre><p id="24ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们传递给上面代码中的<code class="fe mh mi mj mk b">greet</code>函数的对象中，我们传递了<code class="fe mh mi mj mk b">age</code>属性及其值的一个数字。然后我们在代码中使用它，首先检查它是否被定义，如果被定义，我们在主字符串中添加额外的文本。我们也可以省略可选属性，如下面的代码所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2e54" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  name: string,<br/>  age?: number<br/>}</span><span id="e37b" class="mt lf it mk b gy my mv l mw mx">const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}. ${person.age ? `You're ${person.age} years old.` : ''}`);<br/>}</span><span id="f747" class="mt lf it mk b gy my mv l mw mx">greet({ name: 'Joe' });</span></pre><p id="29ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码仍然会运行，因为<code class="fe mh mi mj mk b">age</code>属性已经被指定为可选的。如果我们给它分配一个对象文字，那么接口概述的规则仍然适用。例如，如果我们写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4c35" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  name: string,<br/>  age?: number<br/>}</span><span id="02de" class="mt lf it mk b gy my mv l mw mx">const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}. ${person.age ? `You're ${person.age} years old.` : ''}`);<br/>}</span><span id="bff8" class="mt lf it mk b gy my mv l mw mx">const person: Person = { name: 'Joe' };<br/>greet(person);</span></pre><p id="3691" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这仍然有效，因为我们坚持在<code class="fe mh mi mj mk b">Person</code>接口中定义属性描述。如果我们添加带有数字属性的<code class="fe mh mi mj mk b">age</code>属性，它仍然可以编译和运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="998d" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  name: string,<br/>  age?: number<br/>}</span><span id="674b" class="mt lf it mk b gy my mv l mw mx">const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}. ${person.age ? `You're ${person.age} years old.` : ''}`);<br/>}</span><span id="2bbc" class="mt lf it mk b gy my mv l mw mx">const person: Person = { name: 'Joe', age: 20 }<br/>greet(person);</span></pre><p id="5eb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可选属性很有用，因为我们可以定义可能使用的属性，同时防止使用不属于接口的属性。这可以防止由于代码中的拼写错误而产生的错误。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/dd6a7e8ef1dc340e1bf4bf2ce92d95ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h-ktjm8xqR0jTXh6"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片由<a class="ae kf" href="https://unsplash.com/@agmakonts?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Adam Grabek </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="3051" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">只读属性</h1><p id="01c4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了使属性在对象第一次被创建后不可修改，我们可以在属性前使用<code class="fe mh mi mj mk b">readonly</code>关键字来指定属性只能在对象被创建时写一次，以后任何时候都不能写。例如，我们可以编写以下代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a7fb" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  readonly name: string,<br/>  age?: number<br/>}</span><span id="00a6" class="mt lf it mk b gy my mv l mw mx">const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}. ${person.age ? `You're ${person.age} years old.` : ''}`);<br/>}</span><span id="df19" class="mt lf it mk b gy my mv l mw mx">const person: Person = { name: 'Joe', age: 20 };<br/>greet(person);</span></pre><p id="81d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在<code class="fe mh mi mj mk b">name</code>属性前面添加了<code class="fe mh mi mj mk b">readonly</code>关键字，这样它只能被修改一次，而且只能修改一次。因此，如果我们试图给<code class="fe mh mi mj mk b">name</code>属性赋予新的内容，TypeScript编译器将不会编译和编码，代码也不会运行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7d0c" class="mt lf it mk b gy mu mv l mw mx">interface Person{<br/>  readonly name: string,<br/>  age?: number<br/>}</span><span id="94b8" class="mt lf it mk b gy my mv l mw mx">const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}. ${person.age ? `You're ${person.age} years old.` : ''}`);<br/>}</span><span id="27f7" class="mt lf it mk b gy my mv l mw mx">let person: Person = { name: 'Joe', age: 20 };<br/>person.name = 'Jane';<br/>greet(person);</span></pre><p id="675a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们尝试编译它或在支持TypeScript的文本编辑器中编译它时，上面的代码会给我们错误消息“无法分配给' name ',因为它是只读属性”。但是，我们可以将整个对象重新分配给不同的值，如下面的代码所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c27d" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  readonly name: string,<br/>  age?: number<br/>}</span><span id="6005" class="mt lf it mk b gy my mv l mw mx">const greet = (person: Person) =&gt; {<br/>  console.log(`Hello, ${person.name}. ${person.age ? `You're ${person.age} years old.` : ''}`);<br/>}</span><span id="eb75" class="mt lf it mk b gy my mv l mw mx">let person: Person = { name: 'Joe', age: 20 };<br/>person = { name: 'Jane', age: 20 };<br/>greet(person);</span></pre><p id="544e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后不是记录“你好，乔。你已经20岁了。，我们得到‘你好，简。你已经20岁了。'</p><p id="30a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想将一个数组指定为只读的，也就是说，只在它被创建时才被改变，我们可以使用与<code class="fe mh mi mj mk b">Array</code>相同的<code class="fe mh mi mj mk b">ReadonlyArray</code>类型，但是所有的变异方法都被从中移除了，这样我们就不会意外地改变数组中的任何内容。例如，我们可以在下面的代码中使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="025f" class="mt lf it mk b gy mu mv l mw mx">let readOnlyArray: ReadonlyArray&lt;number&gt; = [1,2,3];</span></pre><p id="abda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果我们尝试编写以下代码，TypeScript编译器会给出错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1921" class="mt lf it mk b gy mu mv l mw mx">readOnlyArray[0] = 12;<br/>readOnlyArray.push(5);<br/>readOnlyArray.length = 100;</span></pre><p id="9b78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到以下错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e048" class="mt lf it mk b gy mu mv l mw mx">Index signature in type 'readonly number[]' only permits reading.(2542)</span><span id="3511" class="mt lf it mk b gy my mv l mw mx">Property 'push' does not exist on type 'readonly number[]'.(2339)</span><span id="9728" class="mt lf it mk b gy my mv l mw mx">Cannot assign to 'length' because it is a read-only property.(2540)</span></pre><p id="4dfc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想将一个<code class="fe mh mi mj mk b">ReadonlyArray</code>转换回一个可写数组，我们可以使用类型断言<code class="fe mh mi mj mk b">as</code>操作符将其转换回一个常规数组:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e800" class="mt lf it mk b gy mu mv l mw mx">let arr = readOnlyArray as number[];</span></pre><h2 id="b151" class="mt lf it bd lg na nb dn lk nc nd dp lo kr ne nf ls kv ng nh lw kz ni nj ma nk bi translated">结论</h2><p id="c06e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript接口对于在我们的代码中定义契约非常方便。我们可以用它来指定变量和函数参数的类型。它们让我们知道变量可以具有什么属性，以及它们是必需的、可选的还是只读的。我们可以用<code class="fe mh mi mj mk b">interfaces</code>关键字定义接口，用变量名后的问号定义可选属性，用<code class="fe mh mi mj mk b">readonly</code>关键字定义只读属性。</p></div></div>    
</body>
</html>